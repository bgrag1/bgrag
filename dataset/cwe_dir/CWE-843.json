[
    {
        "cve_id": "CVE-2022-34918",
        "func_name": "kernel/git/netdev/net/nft_setelem_parse_data",
        "description": "An issue was discovered in the Linux kernel through 5.18.9. A type confusion bug in nft_set_elem_init (leading to a buffer overflow) could be used by a local attacker to escalate privileges, a different vulnerability than CVE-2022-32250. (The attacker can obtain root access, but must start with an unprivileged user namespace to obtain CAP_NET_ADMIN access.) This can be fixed in nft_setelem_parse_data in net/netfilter/nf_tables_api.c.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?h=7e6bc1f6cabcd30aba0b11219d8e01b952eacbb6",
        "commit_title": "Make sure element data type and length do not mismatch the one specified",
        "commit_text": "by the set declaration.  ",
        "func_before": "static int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t\t  struct nft_data_desc *desc,\n\t\t\t\t  struct nft_data *data,\n\t\t\t\t  struct nlattr *attr)\n{\n\tint err;\n\n\terr = nft_data_init(ctx, data, NFT_DATA_VALUE_MAXLEN, desc, attr);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (desc->type != NFT_DATA_VERDICT && desc->len != set->dlen) {\n\t\tnft_data_release(data, desc->type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
        "func": "static int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t\t  struct nft_data_desc *desc,\n\t\t\t\t  struct nft_data *data,\n\t\t\t\t  struct nlattr *attr)\n{\n\tu32 dtype;\n\tint err;\n\n\terr = nft_data_init(ctx, data, NFT_DATA_VALUE_MAXLEN, desc, attr);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (set->dtype == NFT_DATA_VERDICT)\n\t\tdtype = NFT_DATA_VERDICT;\n\telse\n\t\tdtype = NFT_DATA_VALUE;\n\n\tif (dtype != desc->type ||\n\t    set->dlen != desc->len) {\n\t\tnft_data_release(data, desc->type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,13 +3,20 @@\n \t\t\t\t  struct nft_data *data,\n \t\t\t\t  struct nlattr *attr)\n {\n+\tu32 dtype;\n \tint err;\n \n \terr = nft_data_init(ctx, data, NFT_DATA_VALUE_MAXLEN, desc, attr);\n \tif (err < 0)\n \t\treturn err;\n \n-\tif (desc->type != NFT_DATA_VERDICT && desc->len != set->dlen) {\n+\tif (set->dtype == NFT_DATA_VERDICT)\n+\t\tdtype = NFT_DATA_VERDICT;\n+\telse\n+\t\tdtype = NFT_DATA_VALUE;\n+\n+\tif (dtype != desc->type ||\n+\t    set->dlen != desc->len) {\n \t\tnft_data_release(data, desc->type);\n \t\treturn -EINVAL;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (desc->type != NFT_DATA_VERDICT && desc->len != set->dlen) {"
            ],
            "added_lines": [
                "\tu32 dtype;",
                "\tif (set->dtype == NFT_DATA_VERDICT)",
                "\t\tdtype = NFT_DATA_VERDICT;",
                "\telse",
                "\t\tdtype = NFT_DATA_VALUE;",
                "",
                "\tif (dtype != desc->type ||",
                "\t    set->dlen != desc->len) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13118",
        "func_name": "GNOME/libxslt/xsltFormatNumberConversion",
        "description": "In numbers.c in libxslt 1.1.33, a type holding grouping characters of an xsl:number instruction was too narrow and an invalid character/length combination could be passed to xsltNumberFormatDecimal, leading to a read of uninitialized stack data.",
        "git_url": "https://github.com/GNOME/libxslt/commit/6ce8de69330783977dd14f6569419489875fb71b",
        "commit_title": "Fix uninitialized read with UTF-8 grouping chars",
        "commit_text": " The character type in xsltFormatNumberConversion was too narrow and an invalid character/length combination could be passed to xsltNumberFormatDecimal, resulting in an uninitialized read.  Found by OSS-Fuzz.",
        "func_before": "xmlXPathError\nxsltFormatNumberConversion(xsltDecimalFormatPtr self,\n\t\t\t   xmlChar *format,\n\t\t\t   double number,\n\t\t\t   xmlChar **result)\n{\n    xmlXPathError status = XPATH_EXPRESSION_OK;\n    xmlBufferPtr buffer;\n    xmlChar *the_format, *prefix = NULL, *suffix = NULL;\n    xmlChar *nprefix, *nsuffix = NULL;\n    xmlChar pchar;\n    int\t    prefix_length, suffix_length = 0, nprefix_length, nsuffix_length;\n    double  scale;\n    int\t    j, len;\n    int     self_grouping_len;\n    xsltFormatNumberInfo format_info;\n    /*\n     * delayed_multiplier allows a 'trailing' percent or\n     * permille to be treated as suffix\n     */\n    int\t\tdelayed_multiplier = 0;\n    /* flag to show no -ve format present for -ve number */\n    char\tdefault_sign = 0;\n    /* flag to show error found, should use default format */\n    char\tfound_error = 0;\n\n    if (xmlStrlen(format) <= 0) {\n\txsltTransformError(NULL, NULL, NULL,\n                \"xsltFormatNumberConversion : \"\n\t\t\"Invalid format (0-length)\\n\");\n    }\n    *result = NULL;\n    switch (xmlXPathIsInf(number)) {\n\tcase -1:\n\t    if (self->minusSign == NULL)\n\t\t*result = xmlStrdup(BAD_CAST \"-\");\n\t    else\n\t\t*result = xmlStrdup(self->minusSign);\n\t    /* no-break on purpose */\n\tcase 1:\n\t    if ((self == NULL) || (self->infinity == NULL))\n\t\t*result = xmlStrcat(*result, BAD_CAST \"Infinity\");\n\t    else\n\t\t*result = xmlStrcat(*result, self->infinity);\n\t    return(status);\n\tdefault:\n\t    if (xmlXPathIsNaN(number)) {\n\t\tif ((self == NULL) || (self->noNumber == NULL))\n\t\t    *result = xmlStrdup(BAD_CAST \"NaN\");\n\t\telse\n\t\t    *result = xmlStrdup(self->noNumber);\n\t\treturn(status);\n\t    }\n    }\n\n    buffer = xmlBufferCreate();\n    if (buffer == NULL) {\n\treturn XPATH_MEMORY_ERROR;\n    }\n\n    format_info.integer_hash = 0;\n    format_info.integer_digits = 0;\n    format_info.frac_digits = 0;\n    format_info.frac_hash = 0;\n    format_info.group = -1;\n    format_info.multiplier = 1;\n    format_info.add_decimal = FALSE;\n    format_info.is_multiplier_set = FALSE;\n    format_info.is_negative_pattern = FALSE;\n\n    the_format = format;\n\n    /*\n     * First we process the +ve pattern to get percent / permille,\n     * as well as main format\n     */\n    prefix = the_format;\n    prefix_length = xsltFormatNumberPreSuffix(self, &the_format, &format_info);\n    if (prefix_length < 0) {\n\tfound_error = 1;\n\tgoto OUTPUT_NUMBER;\n    }\n\n    /*\n     * Here we process the \"number\" part of the format.  It gets\n     * a little messy because of the percent/per-mille - if that\n     * appears at the end, it may be part of the suffix instead\n     * of part of the number, so the variable delayed_multiplier\n     * is used to handle it\n     */\n    self_grouping_len = xmlStrlen(self->grouping);\n    while ((*the_format != 0) &&\n\t   (xsltUTF8Charcmp(the_format, self->decimalPoint) != 0) &&\n\t   (xsltUTF8Charcmp(the_format, self->patternSeparator) != 0)) {\n\n\tif (delayed_multiplier != 0) {\n\t    format_info.multiplier = delayed_multiplier;\n\t    format_info.is_multiplier_set = TRUE;\n\t    delayed_multiplier = 0;\n\t}\n\tif (xsltUTF8Charcmp(the_format, self->digit) == 0) {\n\t    if (format_info.integer_digits > 0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    format_info.integer_hash++;\n\t    if (format_info.group >= 0)\n\t\tformat_info.group++;\n\t} else if (xsltUTF8Charcmp(the_format, self->zeroDigit) == 0) {\n\t    format_info.integer_digits++;\n\t    if (format_info.group >= 0)\n\t\tformat_info.group++;\n\t} else if ((self_grouping_len > 0) &&\n\t    (!xmlStrncmp(the_format, self->grouping, self_grouping_len))) {\n\t    /* Reset group count */\n\t    format_info.group = 0;\n\t    the_format += self_grouping_len;\n\t    continue;\n\t} else if (xsltUTF8Charcmp(the_format, self->percent) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 100;\n\t} else  if (xsltUTF8Charcmp(the_format, self->permille) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 1000;\n\t} else\n\t    break; /* while */\n\n\tif ((len=xmlUTF8Strsize(the_format, 1)) < 1) {\n\t    found_error = 1;\n\t    goto OUTPUT_NUMBER;\n\t}\n\tthe_format += len;\n\n    }\n\n    /* We have finished the integer part, now work on fraction */\n    if ( (*the_format != 0) &&\n         (xsltUTF8Charcmp(the_format, self->decimalPoint) == 0) ) {\n        format_info.add_decimal = TRUE;\n        if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n            found_error = 1;\n            goto OUTPUT_NUMBER;\n        }\n\tthe_format += len;\t/* Skip over the decimal */\n    }\n\n    while (*the_format != 0) {\n\n\tif (xsltUTF8Charcmp(the_format, self->zeroDigit) == 0) {\n\t    if (format_info.frac_hash != 0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    format_info.frac_digits++;\n\t} else if (xsltUTF8Charcmp(the_format, self->digit) == 0) {\n\t    format_info.frac_hash++;\n\t} else if (xsltUTF8Charcmp(the_format, self->percent) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 100;\n\t    if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t        found_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    the_format += len;\n\t    continue; /* while */\n\t} else if (xsltUTF8Charcmp(the_format, self->permille) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 1000;\n\t    if  ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t        found_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    the_format += len;\n\t    continue; /* while */\n\t} else if (xsltUTF8Charcmp(the_format, self->grouping) != 0) {\n\t    break; /* while */\n\t}\n\tif ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t    found_error = 1;\n\t    goto OUTPUT_NUMBER;\n\t}\n\tthe_format += len;\n\tif (delayed_multiplier != 0) {\n\t    format_info.multiplier = delayed_multiplier;\n\t    delayed_multiplier = 0;\n\t    format_info.is_multiplier_set = TRUE;\n\t}\n    }\n\n    /*\n     * If delayed_multiplier is set after processing the\n     * \"number\" part, should be in suffix\n     */\n    if (delayed_multiplier != 0) {\n\tthe_format -= len;\n\tdelayed_multiplier = 0;\n    }\n\n    suffix = the_format;\n    suffix_length = xsltFormatNumberPreSuffix(self, &the_format, &format_info);\n    if ( (suffix_length < 0) ||\n\t ((*the_format != 0) &&\n\t  (xsltUTF8Charcmp(the_format, self->patternSeparator) != 0)) ) {\n\tfound_error = 1;\n\tgoto OUTPUT_NUMBER;\n    }\n\n    /*\n     * We have processed the +ve prefix, number part and +ve suffix.\n     * If the number is -ve, we must substitute the -ve prefix / suffix\n     */\n    if (number < 0) {\n        /*\n\t * Note that j is the number of UTF8 chars before the separator,\n\t * not the number of bytes! (bug 151975)\n\t */\n        j =  xmlUTF8Strloc(format, self->patternSeparator);\n\tif (j < 0) {\n\t/* No -ve pattern present, so use default signing */\n\t    default_sign = 1;\n\t}\n\telse {\n\t    /* Skip over pattern separator (accounting for UTF8) */\n\t    the_format = (xmlChar *)xmlUTF8Strpos(format, j + 1);\n\t    /*\n\t     * Flag changes interpretation of percent/permille\n\t     * in -ve pattern\n\t     */\n\t    format_info.is_negative_pattern = TRUE;\n\t    format_info.is_multiplier_set = FALSE;\n\n\t    /* First do the -ve prefix */\n\t    nprefix = the_format;\n\t    nprefix_length = xsltFormatNumberPreSuffix(self,\n\t\t\t\t\t&the_format, &format_info);\n\t    if (nprefix_length<0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\n\t    while (*the_format != 0) {\n\t\tif ( (xsltUTF8Charcmp(the_format, (self)->percent) == 0) ||\n\t\t     (xsltUTF8Charcmp(the_format, (self)->permille)== 0) ) {\n\t\t    if (format_info.is_multiplier_set) {\n\t\t\tfound_error = 1;\n\t\t\tgoto OUTPUT_NUMBER;\n\t\t    }\n\t\t    format_info.is_multiplier_set = TRUE;\n\t\t    delayed_multiplier = 1;\n\t\t}\n\t\telse if (IS_SPECIAL(self, the_format))\n\t\t    delayed_multiplier = 0;\n\t\telse\n\t\t    break; /* while */\n\t\tif ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t\t    found_error = 1;\n\t\t    goto OUTPUT_NUMBER;\n\t\t}\n\t\tthe_format += len;\n\t    }\n\t    if (delayed_multiplier != 0) {\n\t\tformat_info.is_multiplier_set = FALSE;\n\t\tthe_format -= len;\n\t    }\n\n\t    /* Finally do the -ve suffix */\n\t    if (*the_format != 0) {\n\t\tnsuffix = the_format;\n\t\tnsuffix_length = xsltFormatNumberPreSuffix(self,\n\t\t\t\t\t&the_format, &format_info);\n\t\tif (nsuffix_length < 0) {\n\t\t    found_error = 1;\n\t\t    goto OUTPUT_NUMBER;\n\t\t}\n\t    }\n\t    else\n\t\tnsuffix_length = 0;\n\t    if (*the_format != 0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    /*\n\t     * Here's another Java peculiarity:\n\t     * if -ve prefix/suffix == +ve ones, discard & use default\n\t     */\n\t    if ((nprefix_length != prefix_length) ||\n\t\t(nsuffix_length != suffix_length) ||\n\t\t((nprefix_length > 0) &&\n\t\t (xmlStrncmp(nprefix, prefix, prefix_length) !=0 )) ||\n\t\t((nsuffix_length > 0) &&\n\t\t (xmlStrncmp(nsuffix, suffix, suffix_length) !=0 ))) {\n\t\tprefix = nprefix;\n\t\tprefix_length = nprefix_length;\n\t\tsuffix = nsuffix;\n\t\tsuffix_length = nsuffix_length;\n\t    } /* else {\n\t\tdefault_sign = 1;\n\t    }\n\t    */\n\t}\n    }\n\nOUTPUT_NUMBER:\n    if (found_error != 0) {\n\txsltTransformError(NULL, NULL, NULL,\n                \"xsltFormatNumberConversion : \"\n\t\t\"error in format string '%s', using default\\n\", format);\n\tdefault_sign = (number < 0.0) ? 1 : 0;\n\tprefix_length = suffix_length = 0;\n\tformat_info.integer_hash = 0;\n\tformat_info.integer_digits = 1;\n\tformat_info.frac_digits = 1;\n\tformat_info.frac_hash = 4;\n\tformat_info.group = -1;\n\tformat_info.multiplier = 1;\n\tformat_info.add_decimal = TRUE;\n    }\n\n    /* Ready to output our number.  First see if \"default sign\" is required */\n    if (default_sign != 0)\n\txmlBufferAdd(buffer, self->minusSign, xmlUTF8Strsize(self->minusSign, 1));\n\n    /* Put the prefix into the buffer */\n    for (j = 0; j < prefix_length; j++) {\n\tif ((pchar = *prefix++) == SYMBOL_QUOTE) {\n\t    len = xmlUTF8Strsize(prefix, 1);\n\t    xmlBufferAdd(buffer, prefix, len);\n\t    prefix += len;\n\t    j += len - 1;\t/* length of symbol less length of quote */\n\t} else\n\t    xmlBufferAdd(buffer, &pchar, 1);\n    }\n\n    /* Next do the integer part of the number */\n    number = fabs(number) * (double)format_info.multiplier;\n    scale = pow(10.0, (double)(format_info.frac_digits + format_info.frac_hash));\n    number = floor((scale * number + 0.5)) / scale;\n    if ((self->grouping != NULL) &&\n        (self->grouping[0] != 0)) {\n\n\tlen = xmlStrlen(self->grouping);\n\tpchar = xsltGetUTF8Char(self->grouping, &len);\n\txsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n\t\t\t\tformat_info.integer_digits,\n\t\t\t\tformat_info.group,\n\t\t\t\tpchar, len);\n    } else\n\txsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n\t\t\t\tformat_info.integer_digits,\n\t\t\t\tformat_info.group,\n\t\t\t\t',', 1);\n\n    /* Special case: java treats '.#' like '.0', '.##' like '.0#', etc. */\n    if ((format_info.integer_digits + format_info.integer_hash +\n\t format_info.frac_digits == 0) && (format_info.frac_hash > 0)) {\n        ++format_info.frac_digits;\n\t--format_info.frac_hash;\n    }\n\n    /* Add leading zero, if required */\n    if ((floor(number) == 0) &&\n\t(format_info.integer_digits + format_info.frac_digits == 0)) {\n        xmlBufferAdd(buffer, self->zeroDigit, xmlUTF8Strsize(self->zeroDigit, 1));\n    }\n\n    /* Next the fractional part, if required */\n    if (format_info.frac_digits + format_info.frac_hash == 0) {\n        if (format_info.add_decimal)\n\t    xmlBufferAdd(buffer, self->decimalPoint,\n\t\t\t xmlUTF8Strsize(self->decimalPoint, 1));\n    }\n    else {\n      number -= floor(number);\n\tif ((number != 0) || (format_info.frac_digits != 0)) {\n\t    xmlBufferAdd(buffer, self->decimalPoint,\n\t\t\t xmlUTF8Strsize(self->decimalPoint, 1));\n\t    number = floor(scale * number + 0.5);\n\t    for (j = format_info.frac_hash; j > 0; j--) {\n\t\tif (fmod(number, 10.0) >= 1.0)\n\t\t    break; /* for */\n\t\tnumber /= 10.0;\n\t    }\n\t    xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n\t\t\t\tformat_info.frac_digits + j,\n\t\t\t\t0, 0, 0);\n\t}\n    }\n    /* Put the suffix into the buffer */\n    for (j = 0; j < suffix_length; j++) {\n\tif ((pchar = *suffix++) == SYMBOL_QUOTE) {\n            len = xmlUTF8Strsize(suffix, 1);\n\t    xmlBufferAdd(buffer, suffix, len);\n\t    suffix += len;\n\t    j += len - 1;\t/* length of symbol less length of escape */\n\t} else\n\t    xmlBufferAdd(buffer, &pchar, 1);\n    }\n\n    *result = xmlStrdup(xmlBufferContent(buffer));\n    xmlBufferFree(buffer);\n    return status;\n}",
        "func": "xmlXPathError\nxsltFormatNumberConversion(xsltDecimalFormatPtr self,\n\t\t\t   xmlChar *format,\n\t\t\t   double number,\n\t\t\t   xmlChar **result)\n{\n    xmlXPathError status = XPATH_EXPRESSION_OK;\n    xmlBufferPtr buffer;\n    xmlChar *the_format, *prefix = NULL, *suffix = NULL;\n    xmlChar *nprefix, *nsuffix = NULL;\n    xmlChar pchar;\n    int\t    prefix_length, suffix_length = 0, nprefix_length, nsuffix_length;\n    double  scale;\n    int\t    j, len;\n    int     self_grouping_len;\n    xsltFormatNumberInfo format_info;\n    /*\n     * delayed_multiplier allows a 'trailing' percent or\n     * permille to be treated as suffix\n     */\n    int\t\tdelayed_multiplier = 0;\n    /* flag to show no -ve format present for -ve number */\n    char\tdefault_sign = 0;\n    /* flag to show error found, should use default format */\n    char\tfound_error = 0;\n\n    if (xmlStrlen(format) <= 0) {\n\txsltTransformError(NULL, NULL, NULL,\n                \"xsltFormatNumberConversion : \"\n\t\t\"Invalid format (0-length)\\n\");\n    }\n    *result = NULL;\n    switch (xmlXPathIsInf(number)) {\n\tcase -1:\n\t    if (self->minusSign == NULL)\n\t\t*result = xmlStrdup(BAD_CAST \"-\");\n\t    else\n\t\t*result = xmlStrdup(self->minusSign);\n\t    /* no-break on purpose */\n\tcase 1:\n\t    if ((self == NULL) || (self->infinity == NULL))\n\t\t*result = xmlStrcat(*result, BAD_CAST \"Infinity\");\n\t    else\n\t\t*result = xmlStrcat(*result, self->infinity);\n\t    return(status);\n\tdefault:\n\t    if (xmlXPathIsNaN(number)) {\n\t\tif ((self == NULL) || (self->noNumber == NULL))\n\t\t    *result = xmlStrdup(BAD_CAST \"NaN\");\n\t\telse\n\t\t    *result = xmlStrdup(self->noNumber);\n\t\treturn(status);\n\t    }\n    }\n\n    buffer = xmlBufferCreate();\n    if (buffer == NULL) {\n\treturn XPATH_MEMORY_ERROR;\n    }\n\n    format_info.integer_hash = 0;\n    format_info.integer_digits = 0;\n    format_info.frac_digits = 0;\n    format_info.frac_hash = 0;\n    format_info.group = -1;\n    format_info.multiplier = 1;\n    format_info.add_decimal = FALSE;\n    format_info.is_multiplier_set = FALSE;\n    format_info.is_negative_pattern = FALSE;\n\n    the_format = format;\n\n    /*\n     * First we process the +ve pattern to get percent / permille,\n     * as well as main format\n     */\n    prefix = the_format;\n    prefix_length = xsltFormatNumberPreSuffix(self, &the_format, &format_info);\n    if (prefix_length < 0) {\n\tfound_error = 1;\n\tgoto OUTPUT_NUMBER;\n    }\n\n    /*\n     * Here we process the \"number\" part of the format.  It gets\n     * a little messy because of the percent/per-mille - if that\n     * appears at the end, it may be part of the suffix instead\n     * of part of the number, so the variable delayed_multiplier\n     * is used to handle it\n     */\n    self_grouping_len = xmlStrlen(self->grouping);\n    while ((*the_format != 0) &&\n\t   (xsltUTF8Charcmp(the_format, self->decimalPoint) != 0) &&\n\t   (xsltUTF8Charcmp(the_format, self->patternSeparator) != 0)) {\n\n\tif (delayed_multiplier != 0) {\n\t    format_info.multiplier = delayed_multiplier;\n\t    format_info.is_multiplier_set = TRUE;\n\t    delayed_multiplier = 0;\n\t}\n\tif (xsltUTF8Charcmp(the_format, self->digit) == 0) {\n\t    if (format_info.integer_digits > 0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    format_info.integer_hash++;\n\t    if (format_info.group >= 0)\n\t\tformat_info.group++;\n\t} else if (xsltUTF8Charcmp(the_format, self->zeroDigit) == 0) {\n\t    format_info.integer_digits++;\n\t    if (format_info.group >= 0)\n\t\tformat_info.group++;\n\t} else if ((self_grouping_len > 0) &&\n\t    (!xmlStrncmp(the_format, self->grouping, self_grouping_len))) {\n\t    /* Reset group count */\n\t    format_info.group = 0;\n\t    the_format += self_grouping_len;\n\t    continue;\n\t} else if (xsltUTF8Charcmp(the_format, self->percent) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 100;\n\t} else  if (xsltUTF8Charcmp(the_format, self->permille) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 1000;\n\t} else\n\t    break; /* while */\n\n\tif ((len=xmlUTF8Strsize(the_format, 1)) < 1) {\n\t    found_error = 1;\n\t    goto OUTPUT_NUMBER;\n\t}\n\tthe_format += len;\n\n    }\n\n    /* We have finished the integer part, now work on fraction */\n    if ( (*the_format != 0) &&\n         (xsltUTF8Charcmp(the_format, self->decimalPoint) == 0) ) {\n        format_info.add_decimal = TRUE;\n        if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n            found_error = 1;\n            goto OUTPUT_NUMBER;\n        }\n\tthe_format += len;\t/* Skip over the decimal */\n    }\n\n    while (*the_format != 0) {\n\n\tif (xsltUTF8Charcmp(the_format, self->zeroDigit) == 0) {\n\t    if (format_info.frac_hash != 0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    format_info.frac_digits++;\n\t} else if (xsltUTF8Charcmp(the_format, self->digit) == 0) {\n\t    format_info.frac_hash++;\n\t} else if (xsltUTF8Charcmp(the_format, self->percent) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 100;\n\t    if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t        found_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    the_format += len;\n\t    continue; /* while */\n\t} else if (xsltUTF8Charcmp(the_format, self->permille) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 1000;\n\t    if  ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t        found_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    the_format += len;\n\t    continue; /* while */\n\t} else if (xsltUTF8Charcmp(the_format, self->grouping) != 0) {\n\t    break; /* while */\n\t}\n\tif ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t    found_error = 1;\n\t    goto OUTPUT_NUMBER;\n\t}\n\tthe_format += len;\n\tif (delayed_multiplier != 0) {\n\t    format_info.multiplier = delayed_multiplier;\n\t    delayed_multiplier = 0;\n\t    format_info.is_multiplier_set = TRUE;\n\t}\n    }\n\n    /*\n     * If delayed_multiplier is set after processing the\n     * \"number\" part, should be in suffix\n     */\n    if (delayed_multiplier != 0) {\n\tthe_format -= len;\n\tdelayed_multiplier = 0;\n    }\n\n    suffix = the_format;\n    suffix_length = xsltFormatNumberPreSuffix(self, &the_format, &format_info);\n    if ( (suffix_length < 0) ||\n\t ((*the_format != 0) &&\n\t  (xsltUTF8Charcmp(the_format, self->patternSeparator) != 0)) ) {\n\tfound_error = 1;\n\tgoto OUTPUT_NUMBER;\n    }\n\n    /*\n     * We have processed the +ve prefix, number part and +ve suffix.\n     * If the number is -ve, we must substitute the -ve prefix / suffix\n     */\n    if (number < 0) {\n        /*\n\t * Note that j is the number of UTF8 chars before the separator,\n\t * not the number of bytes! (bug 151975)\n\t */\n        j =  xmlUTF8Strloc(format, self->patternSeparator);\n\tif (j < 0) {\n\t/* No -ve pattern present, so use default signing */\n\t    default_sign = 1;\n\t}\n\telse {\n\t    /* Skip over pattern separator (accounting for UTF8) */\n\t    the_format = (xmlChar *)xmlUTF8Strpos(format, j + 1);\n\t    /*\n\t     * Flag changes interpretation of percent/permille\n\t     * in -ve pattern\n\t     */\n\t    format_info.is_negative_pattern = TRUE;\n\t    format_info.is_multiplier_set = FALSE;\n\n\t    /* First do the -ve prefix */\n\t    nprefix = the_format;\n\t    nprefix_length = xsltFormatNumberPreSuffix(self,\n\t\t\t\t\t&the_format, &format_info);\n\t    if (nprefix_length<0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\n\t    while (*the_format != 0) {\n\t\tif ( (xsltUTF8Charcmp(the_format, (self)->percent) == 0) ||\n\t\t     (xsltUTF8Charcmp(the_format, (self)->permille)== 0) ) {\n\t\t    if (format_info.is_multiplier_set) {\n\t\t\tfound_error = 1;\n\t\t\tgoto OUTPUT_NUMBER;\n\t\t    }\n\t\t    format_info.is_multiplier_set = TRUE;\n\t\t    delayed_multiplier = 1;\n\t\t}\n\t\telse if (IS_SPECIAL(self, the_format))\n\t\t    delayed_multiplier = 0;\n\t\telse\n\t\t    break; /* while */\n\t\tif ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t\t    found_error = 1;\n\t\t    goto OUTPUT_NUMBER;\n\t\t}\n\t\tthe_format += len;\n\t    }\n\t    if (delayed_multiplier != 0) {\n\t\tformat_info.is_multiplier_set = FALSE;\n\t\tthe_format -= len;\n\t    }\n\n\t    /* Finally do the -ve suffix */\n\t    if (*the_format != 0) {\n\t\tnsuffix = the_format;\n\t\tnsuffix_length = xsltFormatNumberPreSuffix(self,\n\t\t\t\t\t&the_format, &format_info);\n\t\tif (nsuffix_length < 0) {\n\t\t    found_error = 1;\n\t\t    goto OUTPUT_NUMBER;\n\t\t}\n\t    }\n\t    else\n\t\tnsuffix_length = 0;\n\t    if (*the_format != 0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    /*\n\t     * Here's another Java peculiarity:\n\t     * if -ve prefix/suffix == +ve ones, discard & use default\n\t     */\n\t    if ((nprefix_length != prefix_length) ||\n\t\t(nsuffix_length != suffix_length) ||\n\t\t((nprefix_length > 0) &&\n\t\t (xmlStrncmp(nprefix, prefix, prefix_length) !=0 )) ||\n\t\t((nsuffix_length > 0) &&\n\t\t (xmlStrncmp(nsuffix, suffix, suffix_length) !=0 ))) {\n\t\tprefix = nprefix;\n\t\tprefix_length = nprefix_length;\n\t\tsuffix = nsuffix;\n\t\tsuffix_length = nsuffix_length;\n\t    } /* else {\n\t\tdefault_sign = 1;\n\t    }\n\t    */\n\t}\n    }\n\nOUTPUT_NUMBER:\n    if (found_error != 0) {\n\txsltTransformError(NULL, NULL, NULL,\n                \"xsltFormatNumberConversion : \"\n\t\t\"error in format string '%s', using default\\n\", format);\n\tdefault_sign = (number < 0.0) ? 1 : 0;\n\tprefix_length = suffix_length = 0;\n\tformat_info.integer_hash = 0;\n\tformat_info.integer_digits = 1;\n\tformat_info.frac_digits = 1;\n\tformat_info.frac_hash = 4;\n\tformat_info.group = -1;\n\tformat_info.multiplier = 1;\n\tformat_info.add_decimal = TRUE;\n    }\n\n    /* Ready to output our number.  First see if \"default sign\" is required */\n    if (default_sign != 0)\n\txmlBufferAdd(buffer, self->minusSign, xmlUTF8Strsize(self->minusSign, 1));\n\n    /* Put the prefix into the buffer */\n    for (j = 0; j < prefix_length; j++) {\n\tif ((pchar = *prefix++) == SYMBOL_QUOTE) {\n\t    len = xmlUTF8Strsize(prefix, 1);\n\t    xmlBufferAdd(buffer, prefix, len);\n\t    prefix += len;\n\t    j += len - 1;\t/* length of symbol less length of quote */\n\t} else\n\t    xmlBufferAdd(buffer, &pchar, 1);\n    }\n\n    /* Next do the integer part of the number */\n    number = fabs(number) * (double)format_info.multiplier;\n    scale = pow(10.0, (double)(format_info.frac_digits + format_info.frac_hash));\n    number = floor((scale * number + 0.5)) / scale;\n    if ((self->grouping != NULL) &&\n        (self->grouping[0] != 0)) {\n        int gchar;\n\n\tlen = xmlStrlen(self->grouping);\n\tgchar = xsltGetUTF8Char(self->grouping, &len);\n\txsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n\t\t\t\tformat_info.integer_digits,\n\t\t\t\tformat_info.group,\n\t\t\t\tgchar, len);\n    } else\n\txsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n\t\t\t\tformat_info.integer_digits,\n\t\t\t\tformat_info.group,\n\t\t\t\t',', 1);\n\n    /* Special case: java treats '.#' like '.0', '.##' like '.0#', etc. */\n    if ((format_info.integer_digits + format_info.integer_hash +\n\t format_info.frac_digits == 0) && (format_info.frac_hash > 0)) {\n        ++format_info.frac_digits;\n\t--format_info.frac_hash;\n    }\n\n    /* Add leading zero, if required */\n    if ((floor(number) == 0) &&\n\t(format_info.integer_digits + format_info.frac_digits == 0)) {\n        xmlBufferAdd(buffer, self->zeroDigit, xmlUTF8Strsize(self->zeroDigit, 1));\n    }\n\n    /* Next the fractional part, if required */\n    if (format_info.frac_digits + format_info.frac_hash == 0) {\n        if (format_info.add_decimal)\n\t    xmlBufferAdd(buffer, self->decimalPoint,\n\t\t\t xmlUTF8Strsize(self->decimalPoint, 1));\n    }\n    else {\n      number -= floor(number);\n\tif ((number != 0) || (format_info.frac_digits != 0)) {\n\t    xmlBufferAdd(buffer, self->decimalPoint,\n\t\t\t xmlUTF8Strsize(self->decimalPoint, 1));\n\t    number = floor(scale * number + 0.5);\n\t    for (j = format_info.frac_hash; j > 0; j--) {\n\t\tif (fmod(number, 10.0) >= 1.0)\n\t\t    break; /* for */\n\t\tnumber /= 10.0;\n\t    }\n\t    xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n\t\t\t\tformat_info.frac_digits + j,\n\t\t\t\t0, 0, 0);\n\t}\n    }\n    /* Put the suffix into the buffer */\n    for (j = 0; j < suffix_length; j++) {\n\tif ((pchar = *suffix++) == SYMBOL_QUOTE) {\n            len = xmlUTF8Strsize(suffix, 1);\n\t    xmlBufferAdd(buffer, suffix, len);\n\t    suffix += len;\n\t    j += len - 1;\t/* length of symbol less length of escape */\n\t} else\n\t    xmlBufferAdd(buffer, &pchar, 1);\n    }\n\n    *result = xmlStrdup(xmlBufferContent(buffer));\n    xmlBufferFree(buffer);\n    return status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -349,13 +349,14 @@\n     number = floor((scale * number + 0.5)) / scale;\n     if ((self->grouping != NULL) &&\n         (self->grouping[0] != 0)) {\n+        int gchar;\n \n \tlen = xmlStrlen(self->grouping);\n-\tpchar = xsltGetUTF8Char(self->grouping, &len);\n+\tgchar = xsltGetUTF8Char(self->grouping, &len);\n \txsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n \t\t\t\tformat_info.integer_digits,\n \t\t\t\tformat_info.group,\n-\t\t\t\tpchar, len);\n+\t\t\t\tgchar, len);\n     } else\n \txsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n \t\t\t\tformat_info.integer_digits,",
        "diff_line_info": {
            "deleted_lines": [
                "\tpchar = xsltGetUTF8Char(self->grouping, &len);",
                "\t\t\t\tpchar, len);"
            ],
            "added_lines": [
                "        int gchar;",
                "\tgchar = xsltGetUTF8Char(self->grouping, &len);",
                "\t\t\t\tgchar, len);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-21731",
        "func_name": "tensorflow/ConcatShapeHelper",
        "description": "Tensorflow is an Open Source Machine Learning Framework. The implementation of shape inference for `ConcatV2` can be used to trigger a denial of service attack via a segfault caused by a type confusion. The `axis` argument is translated into `concat_dim` in the `ConcatShapeHelper` helper function. Then, a value for `min_rank` is computed based on `concat_dim`. This is then used to validate that the `values` tensor has at least the required rank. However, `WithRankAtLeast` receives the lower bound as a 64-bits value and then compares it against the maximum 32-bits integer value that could be represented. Due to the fact that `min_rank` is a 32-bits value and the value of `axis`, the `rank` argument is a negative value, so the error check is bypassed. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/08d7b00c0a5a20926363849f611729f53f3ec022",
        "commit_title": "Fix Segfault in Concat V2 shape function.",
        "commit_text": " PiperOrigin-RevId: 412120654",
        "func_before": "Status ConcatShapeHelper(InferenceContext* c, int start_value_index,\n                         int end_value_index, int dim_index) {\n  ShapeHandle unused;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(dim_index), 0, &unused));\n  const Tensor* concat_dim_t = c->input_tensor(dim_index);\n  if (concat_dim_t == nullptr) {\n    // Return an unknown shape with same rank as inputs, or an unknown rank\n    // if no input's rank is known.\n\n    // Find rank.\n    int32_t rank = InferenceContext::kUnknownRank;\n    for (int i = start_value_index; i < end_value_index; ++i) {\n      if (rank == InferenceContext::kUnknownRank) rank = c->Rank(c->input(i));\n      if (rank != InferenceContext::kUnknownRank) {\n        break;\n      }\n    }\n    if (rank == InferenceContext::kUnknownRank) {\n      c->set_output(0, c->UnknownShape());\n      return Status::OK();\n    } else if (rank == 0) {\n      return errors::InvalidArgument(\n          \"Can't concatenate scalars (use tf.stack instead)\");\n    } else {\n      for (int i = start_value_index; i < end_value_index; ++i) {\n        // Check that all the inputs are of the correct rank.\n        TF_RETURN_IF_ERROR(c->WithRank(c->input(i), rank, &unused));\n      }\n    }\n    // Build result of <rank> different unknown dims.\n    std::vector<DimensionHandle> dims;\n    dims.reserve(rank);\n    for (int i = 0; i < rank; ++i) dims.push_back(c->UnknownDim());\n    c->set_output(0, c->MakeShape(dims));\n    return Status::OK();\n  }\n\n  // Merge all the non-concat dims, and sum the concat dim to make an output\n  // shape.\n  int64_t concat_dim;\n  if (concat_dim_t->dtype() == DT_INT32) {\n    concat_dim = static_cast<int64_t>(concat_dim_t->flat<int32>()(0));\n  } else {\n    concat_dim = concat_dim_t->flat<int64_t>()(0);\n  }\n\n  // Minimum required number of dimensions.\n  const int min_rank = concat_dim < 0 ? -concat_dim : concat_dim + 1;\n\n  ShapeHandle output_before;\n  ShapeHandle output_after;\n\n  ShapeHandle input = c->input(end_value_index - 1);\n  TF_RETURN_IF_ERROR(c->WithRankAtLeast(input, min_rank, &input));\n  TF_RETURN_IF_ERROR(c->Subshape(input, 0, concat_dim, &output_before));\n  DimensionHandle output_middle = c->Dim(input, concat_dim);\n  if (concat_dim == -1) {\n    output_after = c->Scalar();  // no dimensions.\n  } else {\n    TF_RETURN_IF_ERROR(c->Subshape(input, concat_dim + 1, &output_after));\n  }\n\n  for (int i = end_value_index - 2; i >= start_value_index; --i) {\n    ShapeHandle before;\n    ShapeHandle after;\n    input = c->input(i);\n    TF_RETURN_IF_ERROR(c->WithRankAtLeast(input, min_rank, &input));\n    TF_RETURN_IF_ERROR(c->Subshape(input, 0, concat_dim, &before));\n    DimensionHandle middle = c->Dim(input, concat_dim);\n    if (concat_dim == -1) {\n      after = c->Scalar();\n    } else {\n      TF_RETURN_IF_ERROR(c->Subshape(input, concat_dim + 1, &after));\n    }\n\n    TF_RETURN_IF_ERROR(c->Merge(before, output_before, &output_before));\n    TF_RETURN_IF_ERROR(c->Add(output_middle, middle, &output_middle));\n    TF_RETURN_IF_ERROR(c->Merge(after, output_after, &output_after));\n  }\n\n  ShapeHandle s;\n  TF_RETURN_IF_ERROR(\n      c->Concatenate(output_before, c->Vector(output_middle), &s));\n  TF_RETURN_IF_ERROR(c->Concatenate(s, output_after, &s));\n  c->set_output(0, s);\n  return Status::OK();\n}",
        "func": "Status ConcatShapeHelper(InferenceContext* c, int start_value_index,\n                         int end_value_index, int dim_index) {\n  ShapeHandle unused;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(dim_index), 0, &unused));\n  const Tensor* concat_dim_t = c->input_tensor(dim_index);\n  if (concat_dim_t == nullptr) {\n    // Return an unknown shape with same rank as inputs, or an unknown rank\n    // if no input's rank is known.\n\n    // Find rank.\n    int32_t rank = InferenceContext::kUnknownRank;\n    for (int i = start_value_index; i < end_value_index; ++i) {\n      if (rank == InferenceContext::kUnknownRank) rank = c->Rank(c->input(i));\n      if (rank != InferenceContext::kUnknownRank) {\n        break;\n      }\n    }\n    if (rank == InferenceContext::kUnknownRank) {\n      c->set_output(0, c->UnknownShape());\n      return Status::OK();\n    } else if (rank == 0) {\n      return errors::InvalidArgument(\n          \"Can't concatenate scalars (use tf.stack instead)\");\n    } else {\n      for (int i = start_value_index; i < end_value_index; ++i) {\n        // Check that all the inputs are of the correct rank.\n        TF_RETURN_IF_ERROR(c->WithRank(c->input(i), rank, &unused));\n      }\n    }\n    // Build result of <rank> different unknown dims.\n    std::vector<DimensionHandle> dims;\n    dims.reserve(rank);\n    for (int i = 0; i < rank; ++i) dims.push_back(c->UnknownDim());\n    c->set_output(0, c->MakeShape(dims));\n    return Status::OK();\n  }\n\n  // Merge all the non-concat dims, and sum the concat dim to make an output\n  // shape.\n  int64_t concat_dim;\n  if (concat_dim_t->dtype() == DT_INT32) {\n    concat_dim = static_cast<int64_t>(concat_dim_t->flat<int32>()(0));\n  } else {\n    concat_dim = concat_dim_t->flat<int64_t>()(0);\n  }\n\n  // Minimum required number of dimensions.\n  const int64 min_rank = concat_dim < 0 ? -concat_dim : concat_dim + 1;\n\n  ShapeHandle output_before;\n  ShapeHandle output_after;\n\n  ShapeHandle input = c->input(end_value_index - 1);\n  TF_RETURN_IF_ERROR(c->WithRankAtLeast(input, min_rank, &input));\n  TF_RETURN_IF_ERROR(c->Subshape(input, 0, concat_dim, &output_before));\n  DimensionHandle output_middle = c->Dim(input, concat_dim);\n  if (concat_dim == -1) {\n    output_after = c->Scalar();  // no dimensions.\n  } else {\n    TF_RETURN_IF_ERROR(c->Subshape(input, concat_dim + 1, &output_after));\n  }\n\n  for (int i = end_value_index - 2; i >= start_value_index; --i) {\n    ShapeHandle before;\n    ShapeHandle after;\n    input = c->input(i);\n    TF_RETURN_IF_ERROR(c->WithRankAtLeast(input, min_rank, &input));\n    TF_RETURN_IF_ERROR(c->Subshape(input, 0, concat_dim, &before));\n    DimensionHandle middle = c->Dim(input, concat_dim);\n    if (concat_dim == -1) {\n      after = c->Scalar();\n    } else {\n      TF_RETURN_IF_ERROR(c->Subshape(input, concat_dim + 1, &after));\n    }\n\n    TF_RETURN_IF_ERROR(c->Merge(before, output_before, &output_before));\n    TF_RETURN_IF_ERROR(c->Add(output_middle, middle, &output_middle));\n    TF_RETURN_IF_ERROR(c->Merge(after, output_after, &output_after));\n  }\n\n  ShapeHandle s;\n  TF_RETURN_IF_ERROR(\n      c->Concatenate(output_before, c->Vector(output_middle), &s));\n  TF_RETURN_IF_ERROR(c->Concatenate(s, output_after, &s));\n  c->set_output(0, s);\n  return Status::OK();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,7 +45,7 @@\n   }\n \n   // Minimum required number of dimensions.\n-  const int min_rank = concat_dim < 0 ? -concat_dim : concat_dim + 1;\n+  const int64 min_rank = concat_dim < 0 ? -concat_dim : concat_dim + 1;\n \n   ShapeHandle output_before;\n   ShapeHandle output_after;",
        "diff_line_info": {
            "deleted_lines": [
                "  const int min_rank = concat_dim < 0 ? -concat_dim : concat_dim + 1;"
            ],
            "added_lines": [
                "  const int64 min_rank = concat_dim < 0 ? -concat_dim : concat_dim + 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-46463",
        "func_name": "nginx/njs/njs_vmcode_await",
        "description": "njs through 0.7.1, used in NGINX, was discovered to contain a control flow hijack caused by a Type Confusion vulnerability in njs_promise_perform_then().",
        "git_url": "https://github.com/nginx/njs/commit/6a40a85ff239497c6458c7dbef18f6a2736fe992",
        "commit_title": "Fixed type confusion bug while resolving promises.",
        "commit_text": " Previously, the internal function njs_promise_perform_then() which implements PerformPromiseThen() expects its first argument to always be a promise instance.  This assertion might be invalid because the functions corresponding to Promise.prototype.then() and Promise.resolve() incorrectly verified their arguments.  Specifically, the functions recognized their first argument as promise if it was an object which was an Promise or had Promise object in its prototype chain.  The later condition is not correct because internal slots are not inherited according to the spec.  This closes #447 issue in Github.",
        "func_before": "static njs_jump_off_t\nnjs_vmcode_await(njs_vm_t *vm, njs_vmcode_await_t *await)\n{\n    size_t              size;\n    njs_int_t           ret;\n    njs_frame_t         *frame;\n    njs_value_t         ctor, val, on_fulfilled, on_rejected, *value;\n    njs_promise_t       *promise;\n    njs_function_t      *fulfilled, *rejected;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *active;\n\n    active = &vm->active_frame->native;\n\n    value = njs_scope_valid_value(vm, await->retval);\n    if (njs_slow_path(value == NULL)) {\n        return NJS_ERROR;\n    }\n\n    njs_set_function(&ctor, &vm->constructors[NJS_OBJ_TYPE_PROMISE]);\n\n    promise = njs_promise_resolve(vm, &ctor, value);\n    if (njs_slow_path(promise == NULL)) {\n        return NJS_ERROR;\n    }\n\n    ctx = active->function->await;\n\n    if (ctx == NULL) {\n        ctx = njs_mp_alloc(vm->mem_pool, sizeof(njs_async_ctx_t));\n        if (njs_slow_path(ctx == NULL)) {\n            njs_memory_error(vm);\n            return NJS_ERROR;\n        }\n\n        size = njs_function_frame_size(active);\n\n        fulfilled = njs_promise_create_function(vm, size);\n        if (njs_slow_path(fulfilled == NULL)) {\n            return NJS_ERROR;\n        }\n\n        ctx->await = fulfilled->context;\n        ctx->capability = active->function->context;\n\n        active->function->context = NULL;\n\n        ret = njs_function_frame_save(vm, ctx->await, NULL);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n\n    } else {\n        fulfilled = njs_promise_create_function(vm, 0);\n        if (njs_slow_path(fulfilled == NULL)) {\n            return NJS_ERROR;\n        }\n    }\n\n    ctx->pc = (u_char *) await + sizeof(njs_vmcode_await_t);\n    ctx->index = await->retval;\n\n    frame = (njs_frame_t *) active;\n\n    if (frame->exception.catch != NULL) {\n        ctx->await->native.pc = frame->exception.catch;\n\n    } else {\n        ctx->await->native.pc = ctx->pc;\n    }\n\n    fulfilled->context = ctx;\n    fulfilled->args_count = 1;\n    fulfilled->u.native = njs_await_fulfilled;\n\n    rejected = njs_promise_create_function(vm, 0);\n    if (njs_slow_path(rejected == NULL)) {\n        return NJS_ERROR;\n    }\n\n    rejected->context = ctx;\n    rejected->args_count = 1;\n    rejected->u.native = njs_await_rejected;\n\n    njs_set_object(&val, &promise->object);\n    njs_set_function(&on_fulfilled, fulfilled);\n    njs_set_function(&on_rejected, rejected);\n\n    ret = njs_promise_perform_then(vm, &val, &on_fulfilled, &on_rejected, NULL);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return NJS_ERROR;\n    }\n\n    (void) njs_vmcode_return(vm, NULL, &vm->retval);\n\n    return NJS_AGAIN;\n}",
        "func": "static njs_jump_off_t\nnjs_vmcode_await(njs_vm_t *vm, njs_vmcode_await_t *await)\n{\n    size_t              size;\n    njs_int_t           ret;\n    njs_frame_t         *frame;\n    njs_value_t         ctor, val, on_fulfilled, on_rejected, *value;\n    njs_promise_t       *promise;\n    njs_function_t      *fulfilled, *rejected;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *active;\n\n    active = &vm->active_frame->native;\n\n    value = njs_scope_valid_value(vm, await->retval);\n    if (njs_slow_path(value == NULL)) {\n        return NJS_ERROR;\n    }\n\n    njs_set_function(&ctor, &vm->constructors[NJS_OBJ_TYPE_PROMISE]);\n\n    promise = njs_promise_resolve(vm, &ctor, value);\n    if (njs_slow_path(promise == NULL)) {\n        return NJS_ERROR;\n    }\n\n    ctx = active->function->await;\n\n    if (ctx == NULL) {\n        ctx = njs_mp_alloc(vm->mem_pool, sizeof(njs_async_ctx_t));\n        if (njs_slow_path(ctx == NULL)) {\n            njs_memory_error(vm);\n            return NJS_ERROR;\n        }\n\n        size = njs_function_frame_size(active);\n\n        fulfilled = njs_promise_create_function(vm, size);\n        if (njs_slow_path(fulfilled == NULL)) {\n            return NJS_ERROR;\n        }\n\n        ctx->await = fulfilled->context;\n        ctx->capability = active->function->context;\n\n        active->function->context = NULL;\n\n        ret = njs_function_frame_save(vm, ctx->await, NULL);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n\n    } else {\n        fulfilled = njs_promise_create_function(vm, 0);\n        if (njs_slow_path(fulfilled == NULL)) {\n            return NJS_ERROR;\n        }\n    }\n\n    ctx->pc = (u_char *) await + sizeof(njs_vmcode_await_t);\n    ctx->index = await->retval;\n\n    frame = (njs_frame_t *) active;\n\n    if (frame->exception.catch != NULL) {\n        ctx->await->native.pc = frame->exception.catch;\n\n    } else {\n        ctx->await->native.pc = ctx->pc;\n    }\n\n    fulfilled->context = ctx;\n    fulfilled->args_count = 1;\n    fulfilled->u.native = njs_await_fulfilled;\n\n    rejected = njs_promise_create_function(vm, 0);\n    if (njs_slow_path(rejected == NULL)) {\n        return NJS_ERROR;\n    }\n\n    rejected->context = ctx;\n    rejected->args_count = 1;\n    rejected->u.native = njs_await_rejected;\n\n    njs_set_promise(&val, promise);\n    njs_set_function(&on_fulfilled, fulfilled);\n    njs_set_function(&on_rejected, rejected);\n\n    ret = njs_promise_perform_then(vm, &val, &on_fulfilled, &on_rejected, NULL);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return NJS_ERROR;\n    }\n\n    (void) njs_vmcode_return(vm, NULL, &vm->retval);\n\n    return NJS_AGAIN;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -82,7 +82,7 @@\n     rejected->args_count = 1;\n     rejected->u.native = njs_await_rejected;\n \n-    njs_set_object(&val, &promise->object);\n+    njs_set_promise(&val, promise);\n     njs_set_function(&on_fulfilled, fulfilled);\n     njs_set_function(&on_rejected, rejected);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    njs_set_object(&val, &promise->object);"
            ],
            "added_lines": [
                "    njs_set_promise(&val, promise);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-46463",
        "func_name": "nginx/njs/njs_promise_perform_then",
        "description": "njs through 0.7.1, used in NGINX, was discovered to contain a control flow hijack caused by a Type Confusion vulnerability in njs_promise_perform_then().",
        "git_url": "https://github.com/nginx/njs/commit/6a40a85ff239497c6458c7dbef18f6a2736fe992",
        "commit_title": "Fixed type confusion bug while resolving promises.",
        "commit_text": " Previously, the internal function njs_promise_perform_then() which implements PerformPromiseThen() expects its first argument to always be a promise instance.  This assertion might be invalid because the functions corresponding to Promise.prototype.then() and Promise.resolve() incorrectly verified their arguments.  Specifically, the functions recognized their first argument as promise if it was an object which was an Promise or had Promise object in its prototype chain.  The later condition is not correct because internal slots are not inherited according to the spec.  This closes #447 issue in Github.",
        "func_before": "njs_int_t\nnjs_promise_perform_then(njs_vm_t *vm, njs_value_t *value,\n    njs_value_t *fulfilled, njs_value_t *rejected,\n    njs_promise_capability_t *capability)\n{\n    njs_int_t               ret;\n    njs_value_t             arguments[2];\n    njs_promise_t           *promise;\n    njs_function_t          *function;\n    njs_promise_data_t      *data;\n    njs_promise_reaction_t  *fulfilled_reaction, *rejected_reaction;\n\n    if (!njs_is_function(fulfilled)) {\n        fulfilled = njs_value_arg(&njs_value_undefined);\n    }\n\n    if (!njs_is_function(rejected)) {\n        rejected = njs_value_arg(&njs_value_undefined);\n    }\n\n    promise = njs_promise(value);\n    data = njs_data(&promise->value);\n\n    fulfilled_reaction = njs_mp_alloc(vm->mem_pool,\n                                      sizeof(njs_promise_reaction_t));\n    if (njs_slow_path(fulfilled_reaction == NULL)) {\n        njs_memory_error(vm);\n        return NJS_ERROR;\n    }\n\n    fulfilled_reaction->capability = capability;\n    fulfilled_reaction->handler = *fulfilled;\n    fulfilled_reaction->type = NJS_PROMISE_FULFILL;\n\n    rejected_reaction = njs_mp_alloc(vm->mem_pool,\n                                     sizeof(njs_promise_reaction_t));\n    if (njs_slow_path(rejected_reaction == NULL)) {\n        njs_memory_error(vm);\n        return NJS_ERROR;\n    }\n\n    rejected_reaction->capability = capability;\n    rejected_reaction->handler = *rejected;\n    rejected_reaction->type = NJS_PROMISE_REJECTED;\n\n    if (data->state == NJS_PROMISE_PENDING) {\n        njs_queue_insert_tail(&data->fulfill_queue, &fulfilled_reaction->link);\n        njs_queue_insert_tail(&data->reject_queue, &rejected_reaction->link);\n\n    } else {\n        function = njs_promise_create_function(vm,\n                                               sizeof(njs_promise_context_t));\n        function->u.native = njs_promise_reaction_job;\n\n        if (data->state == NJS_PROMISE_REJECTED) {\n            njs_set_data(&arguments[0], rejected_reaction, 0);\n\n            ret = njs_promise_host_rejection_tracker(vm, promise,\n                                                     NJS_PROMISE_HANDLE);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n\n        } else {\n            njs_set_data(&arguments[0], fulfilled_reaction, 0);\n        }\n\n        arguments[1] = data->result;\n\n        ret = njs_promise_add_event(vm, function, arguments, 2);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n\n    data->is_handled = 1;\n\n    if (capability == NULL) {\n        njs_vm_retval_set(vm, &njs_value_undefined);\n\n    } else {\n        njs_vm_retval_set(vm, &capability->promise);\n    }\n\n    return NJS_OK;\n}",
        "func": "njs_int_t\nnjs_promise_perform_then(njs_vm_t *vm, njs_value_t *value,\n    njs_value_t *fulfilled, njs_value_t *rejected,\n    njs_promise_capability_t *capability)\n{\n    njs_int_t               ret;\n    njs_value_t             arguments[2];\n    njs_promise_t           *promise;\n    njs_function_t          *function;\n    njs_promise_data_t      *data;\n    njs_promise_reaction_t  *fulfilled_reaction, *rejected_reaction;\n\n    njs_assert(njs_is_promise(value));\n\n    if (!njs_is_function(fulfilled)) {\n        fulfilled = njs_value_arg(&njs_value_undefined);\n    }\n\n    if (!njs_is_function(rejected)) {\n        rejected = njs_value_arg(&njs_value_undefined);\n    }\n\n    promise = njs_promise(value);\n    data = njs_data(&promise->value);\n\n    fulfilled_reaction = njs_mp_alloc(vm->mem_pool,\n                                      sizeof(njs_promise_reaction_t));\n    if (njs_slow_path(fulfilled_reaction == NULL)) {\n        njs_memory_error(vm);\n        return NJS_ERROR;\n    }\n\n    fulfilled_reaction->capability = capability;\n    fulfilled_reaction->handler = *fulfilled;\n    fulfilled_reaction->type = NJS_PROMISE_FULFILL;\n\n    rejected_reaction = njs_mp_alloc(vm->mem_pool,\n                                     sizeof(njs_promise_reaction_t));\n    if (njs_slow_path(rejected_reaction == NULL)) {\n        njs_memory_error(vm);\n        return NJS_ERROR;\n    }\n\n    rejected_reaction->capability = capability;\n    rejected_reaction->handler = *rejected;\n    rejected_reaction->type = NJS_PROMISE_REJECTED;\n\n    if (data->state == NJS_PROMISE_PENDING) {\n        njs_queue_insert_tail(&data->fulfill_queue, &fulfilled_reaction->link);\n        njs_queue_insert_tail(&data->reject_queue, &rejected_reaction->link);\n\n    } else {\n        function = njs_promise_create_function(vm,\n                                               sizeof(njs_promise_context_t));\n        function->u.native = njs_promise_reaction_job;\n\n        if (data->state == NJS_PROMISE_REJECTED) {\n            njs_set_data(&arguments[0], rejected_reaction, 0);\n\n            ret = njs_promise_host_rejection_tracker(vm, promise,\n                                                     NJS_PROMISE_HANDLE);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n\n        } else {\n            njs_set_data(&arguments[0], fulfilled_reaction, 0);\n        }\n\n        arguments[1] = data->result;\n\n        ret = njs_promise_add_event(vm, function, arguments, 2);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n\n    data->is_handled = 1;\n\n    if (capability == NULL) {\n        njs_vm_retval_set(vm, &njs_value_undefined);\n\n    } else {\n        njs_vm_retval_set(vm, &capability->promise);\n    }\n\n    return NJS_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,6 +9,8 @@\n     njs_function_t          *function;\n     njs_promise_data_t      *data;\n     njs_promise_reaction_t  *fulfilled_reaction, *rejected_reaction;\n+\n+    njs_assert(njs_is_promise(value));\n \n     if (!njs_is_function(fulfilled)) {\n         fulfilled = njs_value_arg(&njs_value_undefined);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    njs_assert(njs_is_promise(value));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-46463",
        "func_name": "nginx/njs/njs_promise_resolve",
        "description": "njs through 0.7.1, used in NGINX, was discovered to contain a control flow hijack caused by a Type Confusion vulnerability in njs_promise_perform_then().",
        "git_url": "https://github.com/nginx/njs/commit/6a40a85ff239497c6458c7dbef18f6a2736fe992",
        "commit_title": "Fixed type confusion bug while resolving promises.",
        "commit_text": " Previously, the internal function njs_promise_perform_then() which implements PerformPromiseThen() expects its first argument to always be a promise instance.  This assertion might be invalid because the functions corresponding to Promise.prototype.then() and Promise.resolve() incorrectly verified their arguments.  Specifically, the functions recognized their first argument as promise if it was an object which was an Promise or had Promise object in its prototype chain.  The later condition is not correct because internal slots are not inherited according to the spec.  This closes #447 issue in Github.",
        "func_before": "njs_promise_t *\nnjs_promise_resolve(njs_vm_t *vm, njs_value_t *constructor, njs_value_t *x)\n{\n    njs_int_t                 ret;\n    njs_value_t               value;\n    njs_object_t              *object;\n    njs_promise_capability_t  *capability;\n\n    static const njs_value_t  string_constructor = njs_string(\"constructor\");\n\n    if (njs_is_object(x)) {\n        object = njs_object_proto_lookup(njs_object(x), NJS_PROMISE,\n                                         njs_object_t);\n\n        if (object != NULL) {\n            ret = njs_value_property(vm, x, njs_value_arg(&string_constructor),\n                                     &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NULL;\n            }\n\n            if (njs_values_same(&value, constructor)) {\n                return njs_promise(x);\n            }\n        }\n    }\n\n    capability = njs_promise_new_capability(vm, constructor);\n    if (njs_slow_path(capability == NULL)) {\n        return NULL;\n    }\n\n    ret = njs_function_call(vm, njs_function(&capability->resolve),\n                            &njs_value_undefined, x, 1, &value);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return NULL;\n    }\n\n    return njs_promise(&capability->promise);\n}",
        "func": "njs_promise_t *\nnjs_promise_resolve(njs_vm_t *vm, njs_value_t *constructor, njs_value_t *x)\n{\n    njs_int_t                 ret;\n    njs_value_t               value;\n    njs_promise_capability_t  *capability;\n\n    static const njs_value_t  string_constructor = njs_string(\"constructor\");\n\n    if (njs_is_promise(x)) {\n        ret = njs_value_property(vm, x, njs_value_arg(&string_constructor),\n                                 &value);\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return NULL;\n        }\n\n        if (njs_values_same(&value, constructor)) {\n            return njs_promise(x);\n        }\n    }\n\n    capability = njs_promise_new_capability(vm, constructor);\n    if (njs_slow_path(capability == NULL)) {\n        return NULL;\n    }\n\n    ret = njs_function_call(vm, njs_function(&capability->resolve),\n                            &njs_value_undefined, x, 1, &value);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return NULL;\n    }\n\n    return njs_promise(&capability->promise);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,25 +3,19 @@\n {\n     njs_int_t                 ret;\n     njs_value_t               value;\n-    njs_object_t              *object;\n     njs_promise_capability_t  *capability;\n \n     static const njs_value_t  string_constructor = njs_string(\"constructor\");\n \n-    if (njs_is_object(x)) {\n-        object = njs_object_proto_lookup(njs_object(x), NJS_PROMISE,\n-                                         njs_object_t);\n+    if (njs_is_promise(x)) {\n+        ret = njs_value_property(vm, x, njs_value_arg(&string_constructor),\n+                                 &value);\n+        if (njs_slow_path(ret == NJS_ERROR)) {\n+            return NULL;\n+        }\n \n-        if (object != NULL) {\n-            ret = njs_value_property(vm, x, njs_value_arg(&string_constructor),\n-                                     &value);\n-            if (njs_slow_path(ret == NJS_ERROR)) {\n-                return NULL;\n-            }\n-\n-            if (njs_values_same(&value, constructor)) {\n-                return njs_promise(x);\n-            }\n+        if (njs_values_same(&value, constructor)) {\n+            return njs_promise(x);\n         }\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    njs_object_t              *object;",
                "    if (njs_is_object(x)) {",
                "        object = njs_object_proto_lookup(njs_object(x), NJS_PROMISE,",
                "                                         njs_object_t);",
                "        if (object != NULL) {",
                "            ret = njs_value_property(vm, x, njs_value_arg(&string_constructor),",
                "                                     &value);",
                "            if (njs_slow_path(ret == NJS_ERROR)) {",
                "                return NULL;",
                "            }",
                "",
                "            if (njs_values_same(&value, constructor)) {",
                "                return njs_promise(x);",
                "            }"
            ],
            "added_lines": [
                "    if (njs_is_promise(x)) {",
                "        ret = njs_value_property(vm, x, njs_value_arg(&string_constructor),",
                "                                 &value);",
                "        if (njs_slow_path(ret == NJS_ERROR)) {",
                "            return NULL;",
                "        }",
                "        if (njs_values_same(&value, constructor)) {",
                "            return njs_promise(x);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-46463",
        "func_name": "nginx/njs/njs_promise_prototype_then",
        "description": "njs through 0.7.1, used in NGINX, was discovered to contain a control flow hijack caused by a Type Confusion vulnerability in njs_promise_perform_then().",
        "git_url": "https://github.com/nginx/njs/commit/6a40a85ff239497c6458c7dbef18f6a2736fe992",
        "commit_title": "Fixed type confusion bug while resolving promises.",
        "commit_text": " Previously, the internal function njs_promise_perform_then() which implements PerformPromiseThen() expects its first argument to always be a promise instance.  This assertion might be invalid because the functions corresponding to Promise.prototype.then() and Promise.resolve() incorrectly verified their arguments.  Specifically, the functions recognized their first argument as promise if it was an object which was an Promise or had Promise object in its prototype chain.  The later condition is not correct because internal slots are not inherited according to the spec.  This closes #447 issue in Github.",
        "func_before": "static njs_int_t\nnjs_promise_prototype_then(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t                 ret;\n    njs_value_t               *promise, *fulfilled, *rejected, constructor;\n    njs_object_t              *object;\n    njs_function_t            *function;\n    njs_promise_capability_t  *capability;\n\n    promise = njs_argument(args, 0);\n\n    if (njs_slow_path(!njs_is_object(promise))) {\n        goto failed;\n    }\n\n    object = njs_object_proto_lookup(njs_object(promise), NJS_PROMISE,\n                                     njs_object_t);\n    if (njs_slow_path(object == NULL)) {\n        goto failed;\n    }\n\n    function = njs_promise_create_function(vm, sizeof(njs_promise_context_t));\n    function->u.native = njs_promise_constructor;\n\n    njs_set_function(&constructor, function);\n\n    ret = njs_value_species_constructor(vm, promise, &constructor,\n                                        &constructor);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    capability = njs_promise_new_capability(vm, &constructor);\n    if (njs_slow_path(capability == NULL)) {\n        return NJS_ERROR;\n    }\n\n    fulfilled = njs_arg(args, nargs, 1);\n    rejected = njs_arg(args, nargs, 2);\n\n    return njs_promise_perform_then(vm, promise, fulfilled, rejected,\n                                    capability);\n\nfailed:\n\n    njs_type_error(vm, \"required a promise object\");\n\n    return NJS_ERROR;\n}",
        "func": "static njs_int_t\nnjs_promise_prototype_then(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t                 ret;\n    njs_value_t               *promise, *fulfilled, *rejected, constructor;\n    njs_function_t            *function;\n    njs_promise_capability_t  *capability;\n\n    promise = njs_argument(args, 0);\n\n    if (njs_slow_path(!njs_is_promise(promise))) {\n        goto failed;\n    }\n\n    function = njs_promise_create_function(vm, sizeof(njs_promise_context_t));\n    function->u.native = njs_promise_constructor;\n\n    njs_set_function(&constructor, function);\n\n    ret = njs_value_species_constructor(vm, promise, &constructor,\n                                        &constructor);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    capability = njs_promise_new_capability(vm, &constructor);\n    if (njs_slow_path(capability == NULL)) {\n        return NJS_ERROR;\n    }\n\n    fulfilled = njs_arg(args, nargs, 1);\n    rejected = njs_arg(args, nargs, 2);\n\n    return njs_promise_perform_then(vm, promise, fulfilled, rejected,\n                                    capability);\n\nfailed:\n\n    njs_type_error(vm, \"required a promise object\");\n\n    return NJS_ERROR;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,19 +4,12 @@\n {\n     njs_int_t                 ret;\n     njs_value_t               *promise, *fulfilled, *rejected, constructor;\n-    njs_object_t              *object;\n     njs_function_t            *function;\n     njs_promise_capability_t  *capability;\n \n     promise = njs_argument(args, 0);\n \n-    if (njs_slow_path(!njs_is_object(promise))) {\n-        goto failed;\n-    }\n-\n-    object = njs_object_proto_lookup(njs_object(promise), NJS_PROMISE,\n-                                     njs_object_t);\n-    if (njs_slow_path(object == NULL)) {\n+    if (njs_slow_path(!njs_is_promise(promise))) {\n         goto failed;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    njs_object_t              *object;",
                "    if (njs_slow_path(!njs_is_object(promise))) {",
                "        goto failed;",
                "    }",
                "",
                "    object = njs_object_proto_lookup(njs_object(promise), NJS_PROMISE,",
                "                                     njs_object_t);",
                "    if (njs_slow_path(object == NULL)) {"
            ],
            "added_lines": [
                "    if (njs_slow_path(!njs_is_promise(promise))) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3676",
        "func_name": "eclipse/omr/TR_InvariantArgumentPreexistence::processIndirectCall",
        "description": "In Eclipse Openj9 before version 0.35.0, interface calls can be inlined without a runtime type check. Malicious bytecode could make use of this inlining to access or modify memory via an incompatible type.",
        "git_url": "https://github.com/eclipse/omr/commit/f5ab765943c192e25ac8ea8d341f88e6ed9f90d2",
        "commit_title": "Stop devirtualizing interface calls in preexistence",
        "commit_text": " Previously, it was possible for the JIT to devirtualize an interface call, and for execution to reach the call (whether inlined or not) with a receiver that is not an instance of the class expected by the implementing method. The callee could then access fields of the receiver as though it were of the expected type.  The conditionals added in this commit still allow (on their own) for an interface call to be devirtualized when preexistence has already proven that the receiver is an instance of some particular class that implements the expected interface. However, preexistence currently fails to devirtualize in that situation. It passes the class to TR_PersistentCHTable::findSingleInterfaceImplementer(), which needs the interface. This can be improved in the future by having preexistence treat the call in the same way as a non-interface call, but with the added requirement that the devirtualized callee must be public.",
        "func_before": "void TR_InvariantArgumentPreexistence::processIndirectCall(TR::Node *node, TR::TreeTop *treeTop, vcount_t visitCount)\n   {\n#ifdef J9_PROJECT_SPECIFIC\n\n   if (trace())\n      traceMsg(comp(), \"PREX:      [%p] %s %s\\n\", node, node->getOpCode().getName(), node->getSymbolReference()->getName(comp()->getDebug()));\n\n   if (!node->getSymbol()->castToMethodSymbol()->firstArgumentIsReceiver())\n      {\n      if (trace())\n         traceMsg(comp(), \"PREX:        - First arg is not receiver\\n\");\n      return;\n      }\n\n   //\n   // Step 1: Analyze\n   //\n\n   // Decision variables\n   //\n   bool  isInterface             = false;\n   ParmInfo           tmpInfo;  tmpInfo.clear();\n   ParmInfo           *receiverInfo = &tmpInfo;\n   TR::Symbol          *receiverSymbol = NULL;\n   bool               receiverFromParm = false;\n   int32_t            receiverParmOrdinal = -1;\n   ParmInfo *existingInfo = NULL;\n   TR::MethodSymbol   *methodSymbol   = node->getSymbol()->castToMethodSymbol();\n\n   TR_ResolvedMethod *resolvedMethod = methodSymbol->getResolvedMethodSymbol()? methodSymbol->getResolvedMethodSymbol()->getResolvedMethod() : NULL;\n   if (!resolvedMethod)\n      {\n      if (methodSymbol->isInterface())\n         {\n         isInterface = true;\n         }\n      else\n         {\n         if (trace())\n            traceMsg(comp(), \"PREX:        - Unresolved\\n\");\n         return;\n         }\n      }\n\n   TR::Node *receiver = node->getChild(node->getFirstArgumentIndex());\n   if (receiver->getOpCode().isLoadDirect())\n      {\n      existingInfo = getSuitableParmInfo(receiver);\n      if (!existingInfo)\n         {\n         if (trace())\n            traceMsg(comp(), \"PREX:        - No parm info for receiver\\n\");\n         return;\n         }\n\n      receiverInfo = existingInfo;\n      receiverFromParm = true;\n\n      receiverSymbol = receiver->getSymbolReference()->getSymbol();\n      receiverParmOrdinal = receiverSymbol->getParmSymbol()->getOrdinal();\n      if (methodSymbol->isVirtual() || methodSymbol->isInterface())\n         {\n         if (node->getSymbolReference() == getSymRefTab()->findObjectNewInstanceImplSymbol())\n            {\n            // Let's not get fancy with these guys\n            // They are the java/lang/Object.newInstancePrototype special methods\n            if (trace())\n               traceMsg(comp(), \"PREX:        - newInstancePrototype\\n\");\n            return;\n            }\n\n         if (trace())\n            traceMsg(comp(), \"PREX:        Receiver is %p incoming Parm %d parmInfo %p\\n\", receiver, receiverParmOrdinal, existingInfo);\n         }\n      }\n\n   // Bonus goodies for known objects\n   //\n   if (receiver->getSymbolReference()\n       && receiver->getSymbolReference()->hasKnownObjectIndex()\n       && !comp()->isOutOfProcessCompilation()\n      )\n      {\n      if (trace())\n         traceMsg(comp(), \"PREX:          Receiver is obj%d\\n\", receiver->getSymbolReference()->getKnownObjectIndex());\n\n      receiverInfo->setKnownObjectIndex(receiver->getSymbolReference()->getKnownObjectIndex());\n      receiverInfo->setClassIsFixed();\n\n      // Also set the class info\n      //\n      TR::KnownObjectTable *knot = comp()->getKnownObjectTable();\n\n         {\n         TR::ClassTableCriticalSection setClass(comp()->fe());\n         receiverInfo->setClass(TR::Compiler->cls.objectClass(comp(), knot->getPointer(receiver->getSymbolReference()->getKnownObjectIndex())));\n         }\n      }\n\n   // Quit if class is not compatible with the method\n   if (resolvedMethod && receiverInfo->getClass() && !classIsCompatibleWithMethod(receiverInfo->getClass(), resolvedMethod))\n      return;\n\n   //\n   // Step 2: Transform\n   //\n\n   if (methodSymbol->isComputed())\n      {\n#ifdef J9_PROJECT_SPECIFIC\n      if (methodSymbol->getRecognizedMethod() == TR::java_lang_invoke_MethodHandle_invokeExact && receiverInfo->hasKnownObjectIndex())\n         specializeInvokeExactSymbol(node, receiverInfo->getKnownObjectIndex(), comp(), this);\n\n      // The method is a specialized thunk archetype, no further improvement is needed.\n      // Keeping running subsequent code may result in a crash because `offset` on the symref is not valid.\n      if (node->getSymbol()->castToMethodSymbol()->getMethod()->isArchetypeSpecimen())\n         return;\n#endif\n      }\n   else if (!isInterface && receiverInfo->classIsFixed())\n      {\n      devirtualizeVirtualCall(node, treeTop, receiverInfo->getClass());\n      }\n   else if (!isInterface && receiverInfo->classIsCurrentlyFinal()\n            && comp()->ilGenRequest().details().supportsInvalidation())\n      {\n      TR_PersistentClassInfo* classInfo = comp()->getPersistentInfo()->getPersistentCHTable()->findClassInfoAfterLocking(receiverInfo->getClass(), comp());\n      bool canDevirtualize = true;\n\n      if (comp()->getMethodHotness() == warm\n          && classInfo\n          && classInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n         canDevirtualize = false;\n\n      if (canDevirtualize && devirtualizeVirtualCall(node, treeTop, receiverInfo->getClass()))\n         {\n         if (trace())\n            traceMsg(comp(), \"devirtualize with assumption\\n\");\n         // improve receiverInfo\n         receiverInfo->setClassIsFixed();\n         // For the outer most method, we have to carry the information of fixed type to inliner,\n         // such that it can be propagated to deeper frames.\n         // The receiver type is current final, which means it's the most concrete type atm. If\n         // the receiver is from parm of the jitted method, this property applies to all call\n         // sites to this method in this compilation. Thus, it is safe to set fixed type on the\n         // parm of this method.\n         //\n         if (_isOutermostMethod && receiverFromParm)\n            {\n            receiverSymbol->getParmSymbol()->setFixedType(receiverInfo->getClass());\n            }\n         // Improve the prex arg for inlined method\n         else if (receiverFromParm && comp()->getCurrentInlinedCallArgInfo())\n            {\n            TR_PrexArgInfo *argInfo = comp()->getCurrentInlinedCallArgInfo();\n            TR_PrexArgument *arg = argInfo->get(receiverParmOrdinal);\n            if (arg && !(arg->classIsFixed() && arg->getClass()))\n               {\n               arg->setClassIsFixed(receiverInfo->getClass());\n               }\n            }\n         TR_ASSERT(receiverInfo->getClass(), \"Currently final classes must have a valid class pointer\");\n         bool inc = comp()->getCHTable()->recompileOnClassExtend(comp(), receiverInfo->getClass());\n         if (classInfo && inc) classInfo->incNumPrexAssumptions();\n         }\n      }\n   else if (receiverFromParm)\n      {\n      // If the method being called is currently not overridden, we can register\n      // a recomp action on the method-override event for this method\n      //\n      if (!isInterface && !resolvedMethod->virtualMethodIsOverridden() && !resolvedMethod->isAbstract())\n         {\n         // if the number of recompile assumptions on this particular\n         // class has exceeded a threshold, don't do prex anymore for this class\n         //\n         bool addAssumptions = false;\n         TR_PersistentMethodInfo *callInfo = NULL;\n\n         if (comp()->ilGenRequest().details().supportsInvalidation())\n            {\n            addAssumptions = true;\n            if ((comp()->getMethodHotness() == warm) &&\n               (callInfo = TR_PersistentMethodInfo::get(resolvedMethod)) &&\n               callInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n               addAssumptions = false;\n            }\n\n         if (addAssumptions &&\n               performTransformation(comp(), \"%sdevirtualizing invoke [%p] on preexistent argument %d [%p]\\n\", optDetailString(), node, receiverParmOrdinal, receiverSymbol))\n            {\n            if (trace())\n               traceMsg(comp(), \"secs devirtualizing invoke on preexistent argument %d in %s\\n\", receiverParmOrdinal, comp()->signature());\n\n            node->devirtualizeCall(treeTop);\n            bool inc = comp()->getCHTable()->recompileOnMethodOverride(comp(), resolvedMethod);\n            if (callInfo && inc) callInfo->incNumPrexAssumptions();\n            }\n         }\n      else if (receiverInfo->getClass())\n         {\n#ifdef J9_PROJECT_SPECIFIC\n         TR::ClassTableCriticalSection processIndirectCall(comp()->fe());\n         TR::SymbolReference *symRef = node->getSymbolReference();\n         TR_PersistentCHTable * chTable = comp()->getPersistentInfo()->getPersistentCHTable();\n         TR::MethodSymbol *methSymbol = node->getSymbol()->getMethodSymbol();\n         if (methSymbol->isInterface() || methodSymbol)\n            {\n            TR_ResolvedMethod * method = NULL;\n            bool newMethod = true;\n            // There is the risk of invaliding a method repeatedly due to class hierarchy extensions\n            // In the following avoid devirtualization based on single implementor if the method has\n            // been invalidated once\n            //\n            TR::Recompilation *recompInfo = comp()->getRecompilationInfo();\n            if (recompInfo && recompInfo->getMethodInfo()->getNumberOfInvalidations() >= 1 && !chTable->findSingleConcreteSubClass(receiverInfo->getClass(), comp()))\n               {\n               // will exit without performing any transformation\n               //fprintf(stderr, \"will not perform devirt\\n\");\n               }\n            else if (methSymbol->isInterface())\n               {\n               if (comp()->getPersistentInfo()->getRuntimeAssumptionTable()->getAssumptionCount(RuntimeAssumptionOnClassExtend) < 100000)\n                  method = chTable->findSingleInterfaceImplementer(receiverInfo->getClass(), node->getSymbolReference()->getCPIndex(), node->getSymbolReference()->getOwningMethod(comp()), comp());\n               //if (method)\n               //   fprintf(stderr, \"%s assumptios=%d\\n\", comp()->signature(), comp()->getPersistentInfo()->getRuntimeAssumptionTable()->getAssumptionCount(RuntimeAssumptionOnClassExtend));\n               }\n            else\n               {\n               if (resolvedMethod->isAbstract())\n                  method = chTable->findSingleAbstractImplementer(receiverInfo->getClass(), symRef->getOffset(), node->getSymbolReference()->getOwningMethod(comp()), comp());\n               else if (!chTable->isOverriddenInThisHierarchy(resolvedMethod, receiverInfo->getClass(), symRef->getOffset(), comp()))\n                  {\n                  method = symRef->getOwningMethod(comp())->getResolvedVirtualMethod(comp(), receiverInfo->getClass(), symRef->getOffset());\n                  newMethod = false;\n                  }\n               }\n\n            if (method && !method->virtualMethodIsOverridden())\n               {\n               TR_PersistentClassInfo *classInfo = comp()->getPersistentInfo()->getPersistentCHTable()->findClassInfoAfterLocking(receiverInfo->getClass(), comp());\n\n               // if the number of recompile assumptions on this particular\n               // class has exceeded a threshold, don't do prex anymore for this class\n               //\n               bool addAssumptions = false;\n\n               if (comp()->ilGenRequest().details().supportsInvalidation())\n                  {\n                  addAssumptions = true;\n                  if ((comp()->getMethodHotness() == warm) &&\n                        classInfo &&\n                        classInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n                     addAssumptions = false;\n\n                  // check the subclasses as well\n                  if (classInfo && addAssumptions)\n                     {\n                     TR_ScratchList<TR_PersistentClassInfo> subClasses(trMemory());\n                     TR_ClassQueries::collectAllSubClasses(classInfo, &subClasses, comp());\n                     ListIterator<TR_PersistentClassInfo> subClassesIt(&subClasses);\n                     for (TR_PersistentClassInfo *subClassInfo = subClassesIt.getFirst(); subClassInfo; subClassInfo = subClassesIt.getNext())\n                        {\n                        if (subClassInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n                           {\n                           addAssumptions = false;\n                           break;\n                           }\n                        }\n                     }\n                  }\n\n               if (addAssumptions &&\n                   performTransformation(comp(), \"%sspecialize and devirtualize invoke [%p] based on only a single implementation for call on parameter %d [%p]\\n\", optDetailString(), node, receiverParmOrdinal, receiverSymbol))\n                  {\n                  if (newMethod || !method->isSameMethod(resolvedMethod))\n                     {\n                     TR::SymbolReference *newSymRef =\n                      getSymRefTab()->findOrCreateMethodSymbol\n                                   (symRef->getOwningMethodIndex(), -1, method, TR::MethodSymbol::Virtual);\n                     newSymRef->copyAliasSets(symRef, getSymRefTab());\n\n                     int32_t offset = -1;\n                     if (methSymbol->isInterface())\n                        offset = node->getSymbolReference()->getOwningMethod(comp())->getResolvedInterfaceMethodOffset(method->containingClass(), node->getSymbolReference()->getCPIndex());\n                     else\n                        offset = symRef->getOffset();\n\n                     newSymRef->setOffset(offset);\n                     node->setSymbolReference(newSymRef);\n                     }\n\n                  node->devirtualizeCall(treeTop);\n                  if (treeTop->getNode()->getOpCodeValue() == TR::ResolveCHK)\n                     TR::Node::recreate(treeTop->getNode(), TR::treetop);\n                  else if (treeTop->getNode()->getOpCodeValue() == TR::ResolveAndNULLCHK)\n                     TR::Node::recreate(treeTop->getNode(), TR::NULLCHK);\n\n                  bool doInc = comp()->getCHTable()->recompileOnNewClassExtend(comp(), receiverInfo->getClass());\n\n                  if (classInfo)\n                     {\n                     classInfo->setShouldNotBeNewlyExtended(comp()->getCompThreadID());\n                     if (doInc) classInfo->incNumPrexAssumptions();\n                     TR_ScratchList<TR_PersistentClassInfo> subClasses(trMemory());\n                     TR_ClassQueries::collectAllSubClasses(classInfo, &subClasses, comp());\n                     ListIterator<TR_PersistentClassInfo> subClassesIt(&subClasses);\n                     for (TR_PersistentClassInfo *subClassInfo = subClassesIt.getFirst(); subClassInfo; subClassInfo = subClassesIt.getNext())\n                        {\n                        TR_OpaqueClassBlock *subClass = (TR_OpaqueClassBlock *) subClassInfo->getClassId();\n                        subClassInfo->setShouldNotBeNewlyExtended(comp()->getCompThreadID());\n                        if (comp()->getCHTable()->recompileOnNewClassExtend(comp(), subClass))\n                           subClassInfo->incNumPrexAssumptions();\n                        }\n                     }\n\n\n                  //comp()->getCHTable()->recompileOnMethodOverride(comp(), method);\n                  _success = true;\n                  }\n               else\n                  {\n                  return;\n                  }\n               }\n            else\n               {\n               return;\n               }\n            }\n#endif\n         }\n      }\n\n\n   if (comp()->isPeekingMethod() && receiverInfo->getClass() && !isInterface)\n      {\n      TR::SymbolReference *symRef = node->getSymbolReference();\n      int32_t offset = symRef->getOffset();\n      //printf(\"Node %p arg %d\\n\", node, receiverParmOrdinal);\n      //printf(\"Method is %s\\n\", resolvedMethod->signature(trMemory()));\n      //fflush(stdout);\n\n      TR_ResolvedMethod *originalResolvedMethod = resolvedMethod;\n      TR_OpaqueClassBlock *originalClazz = originalResolvedMethod->containingClass();\n      bool canRefine = true;\n      if (originalClazz != receiverInfo->getClass())\n         {\n         TR_YesNoMaybe isInstance = fe()->isInstanceOf(originalClazz, receiverInfo->getClass(), true);\n         if (isInstance == TR_yes)\n            canRefine = false;\n\n         isInstance = fe()->isInstanceOf(receiverInfo->getClass(), originalClazz, true);\n         if (isInstance == TR_no)\n            canRefine = false;\n         }\n\n      TR_ResolvedMethod *resolvedMethod = NULL;\n      if (canRefine)\n         resolvedMethod = symRef->getOwningMethod(comp())->getResolvedVirtualMethod(comp(), receiverInfo->getClass(), offset);\n\n      if (resolvedMethod)\n         {\n         if (!originalResolvedMethod || !resolvedMethod->isSameMethod(originalResolvedMethod))\n            {\n            TR::SymbolReference * newSymRef =\n          _peekingSymRefTab->findOrCreateMethodSymbol(\n                             symRef->getOwningMethodIndex(), -1, resolvedMethod, TR::MethodSymbol::Virtual);\n            newSymRef->copyAliasSets(symRef, _peekingSymRefTab);\n            newSymRef->setOffset(offset);\n            node->setSymbolReference(newSymRef);\n            }\n         }\n      }\n#endif\n   }",
        "func": "void TR_InvariantArgumentPreexistence::processIndirectCall(TR::Node *node, TR::TreeTop *treeTop, vcount_t visitCount)\n   {\n#ifdef J9_PROJECT_SPECIFIC\n\n   if (trace())\n      traceMsg(comp(), \"PREX:      [%p] %s %s\\n\", node, node->getOpCode().getName(), node->getSymbolReference()->getName(comp()->getDebug()));\n\n   if (!node->getSymbol()->castToMethodSymbol()->firstArgumentIsReceiver())\n      {\n      if (trace())\n         traceMsg(comp(), \"PREX:        - First arg is not receiver\\n\");\n      return;\n      }\n\n   //\n   // Step 1: Analyze\n   //\n\n   // Decision variables\n   //\n   bool  isInterface             = false;\n   ParmInfo           tmpInfo;  tmpInfo.clear();\n   ParmInfo           *receiverInfo = &tmpInfo;\n   TR::Symbol          *receiverSymbol = NULL;\n   bool               receiverFromParm = false;\n   int32_t            receiverParmOrdinal = -1;\n   ParmInfo *existingInfo = NULL;\n   TR::MethodSymbol   *methodSymbol   = node->getSymbol()->castToMethodSymbol();\n\n   TR_ResolvedMethod *resolvedMethod = methodSymbol->getResolvedMethodSymbol()? methodSymbol->getResolvedMethodSymbol()->getResolvedMethod() : NULL;\n   if (!resolvedMethod)\n      {\n      if (methodSymbol->isInterface())\n         {\n         isInterface = true;\n         }\n      else\n         {\n         if (trace())\n            traceMsg(comp(), \"PREX:        - Unresolved\\n\");\n         return;\n         }\n      }\n\n   TR::Node *receiver = node->getChild(node->getFirstArgumentIndex());\n   if (receiver->getOpCode().isLoadDirect())\n      {\n      existingInfo = getSuitableParmInfo(receiver);\n      if (!existingInfo)\n         {\n         if (trace())\n            traceMsg(comp(), \"PREX:        - No parm info for receiver\\n\");\n         return;\n         }\n\n      receiverInfo = existingInfo;\n      receiverFromParm = true;\n\n      receiverSymbol = receiver->getSymbolReference()->getSymbol();\n      receiverParmOrdinal = receiverSymbol->getParmSymbol()->getOrdinal();\n      if (methodSymbol->isVirtual() || methodSymbol->isInterface())\n         {\n         if (node->getSymbolReference() == getSymRefTab()->findObjectNewInstanceImplSymbol())\n            {\n            // Let's not get fancy with these guys\n            // They are the java/lang/Object.newInstancePrototype special methods\n            if (trace())\n               traceMsg(comp(), \"PREX:        - newInstancePrototype\\n\");\n            return;\n            }\n\n         if (trace())\n            traceMsg(comp(), \"PREX:        Receiver is %p incoming Parm %d parmInfo %p\\n\", receiver, receiverParmOrdinal, existingInfo);\n         }\n      }\n\n   // Bonus goodies for known objects\n   //\n   if (receiver->getSymbolReference()\n       && receiver->getSymbolReference()->hasKnownObjectIndex()\n       && !comp()->isOutOfProcessCompilation()\n      )\n      {\n      if (trace())\n         traceMsg(comp(), \"PREX:          Receiver is obj%d\\n\", receiver->getSymbolReference()->getKnownObjectIndex());\n\n      receiverInfo->setKnownObjectIndex(receiver->getSymbolReference()->getKnownObjectIndex());\n      receiverInfo->setClassIsFixed();\n\n      // Also set the class info\n      //\n      TR::KnownObjectTable *knot = comp()->getKnownObjectTable();\n\n         {\n         TR::ClassTableCriticalSection setClass(comp()->fe());\n         receiverInfo->setClass(TR::Compiler->cls.objectClass(comp(), knot->getPointer(receiver->getSymbolReference()->getKnownObjectIndex())));\n         }\n      }\n\n   // Quit if class is not compatible with the method\n   if (resolvedMethod && receiverInfo->getClass() && !classIsCompatibleWithMethod(receiverInfo->getClass(), resolvedMethod))\n      {\n      if (trace())\n         traceMsg(comp(), \"PREX:        - Receiver type incompatible with method \\n\");\n\n      return;\n      }\n\n   TR::MethodSymbol *methSymbol = node->getSymbol()->getMethodSymbol();\n   if (methSymbol->isInterface())\n      {\n      // Interface type signatures can't be trusted most places in bytecode, so\n      // only transform interface calls when we have a class bound for the\n      // receiver.\n      TR_OpaqueClassBlock *klass = receiverInfo->getClass();\n      if (klass == NULL || TR::Compiler->cls.isInterfaceClass(comp(), klass))\n         {\n         if (trace())\n            {\n            traceMsg(\n               comp(),\n               \"PREX:        - No class type bound for interface call receiver\\n\");\n            }\n\n         return;\n         }\n\n      TR_ResolvedMethod *caller = node->getSymbolReference()->getOwningMethod(comp());\n      TR::Method *callee = methSymbol->getMethod();\n      bool aotOk = true;\n      TR_OpaqueClassBlock *iface = fe()->getClassFromSignature(\n         callee->classNameChars(), callee->classNameLength(), caller, aotOk);\n\n      if (iface == NULL)\n         {\n         if (trace())\n            {\n            traceMsg(\n               comp(),\n               \"PREX:        - Failed to identify interface for interface call\\n\");\n            }\n\n         return;\n         }\n\n      if (fe()->isInstanceOf(klass, iface, true, true, true) != TR_yes)\n         {\n         if (trace())\n            {\n            traceMsg(\n               comp(),\n               \"PREX:        - Insufficient class type bound for interface call receiver\\n\");\n            }\n\n         return;\n         }\n      }\n\n   //\n   // Step 2: Transform\n   //\n\n   if (methodSymbol->isComputed())\n      {\n#ifdef J9_PROJECT_SPECIFIC\n      if (methodSymbol->getRecognizedMethod() == TR::java_lang_invoke_MethodHandle_invokeExact && receiverInfo->hasKnownObjectIndex())\n         specializeInvokeExactSymbol(node, receiverInfo->getKnownObjectIndex(), comp(), this);\n\n      // The method is a specialized thunk archetype, no further improvement is needed.\n      // Keeping running subsequent code may result in a crash because `offset` on the symref is not valid.\n      if (node->getSymbol()->castToMethodSymbol()->getMethod()->isArchetypeSpecimen())\n         return;\n#endif\n      }\n   else if (!isInterface && receiverInfo->classIsFixed())\n      {\n      devirtualizeVirtualCall(node, treeTop, receiverInfo->getClass());\n      }\n   else if (!isInterface && receiverInfo->classIsCurrentlyFinal()\n            && comp()->ilGenRequest().details().supportsInvalidation())\n      {\n      TR_PersistentClassInfo* classInfo = comp()->getPersistentInfo()->getPersistentCHTable()->findClassInfoAfterLocking(receiverInfo->getClass(), comp());\n      bool canDevirtualize = true;\n\n      if (comp()->getMethodHotness() == warm\n          && classInfo\n          && classInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n         canDevirtualize = false;\n\n      if (canDevirtualize && devirtualizeVirtualCall(node, treeTop, receiverInfo->getClass()))\n         {\n         if (trace())\n            traceMsg(comp(), \"devirtualize with assumption\\n\");\n         // improve receiverInfo\n         receiverInfo->setClassIsFixed();\n         // For the outer most method, we have to carry the information of fixed type to inliner,\n         // such that it can be propagated to deeper frames.\n         // The receiver type is current final, which means it's the most concrete type atm. If\n         // the receiver is from parm of the jitted method, this property applies to all call\n         // sites to this method in this compilation. Thus, it is safe to set fixed type on the\n         // parm of this method.\n         //\n         if (_isOutermostMethod && receiverFromParm)\n            {\n            receiverSymbol->getParmSymbol()->setFixedType(receiverInfo->getClass());\n            }\n         // Improve the prex arg for inlined method\n         else if (receiverFromParm && comp()->getCurrentInlinedCallArgInfo())\n            {\n            TR_PrexArgInfo *argInfo = comp()->getCurrentInlinedCallArgInfo();\n            TR_PrexArgument *arg = argInfo->get(receiverParmOrdinal);\n            if (arg && !(arg->classIsFixed() && arg->getClass()))\n               {\n               arg->setClassIsFixed(receiverInfo->getClass());\n               }\n            }\n         TR_ASSERT(receiverInfo->getClass(), \"Currently final classes must have a valid class pointer\");\n         bool inc = comp()->getCHTable()->recompileOnClassExtend(comp(), receiverInfo->getClass());\n         if (classInfo && inc) classInfo->incNumPrexAssumptions();\n         }\n      }\n   else if (receiverFromParm)\n      {\n      // If the method being called is currently not overridden, we can register\n      // a recomp action on the method-override event for this method\n      //\n      if (!isInterface && !resolvedMethod->virtualMethodIsOverridden() && !resolvedMethod->isAbstract())\n         {\n         // if the number of recompile assumptions on this particular\n         // class has exceeded a threshold, don't do prex anymore for this class\n         //\n         bool addAssumptions = false;\n         TR_PersistentMethodInfo *callInfo = NULL;\n\n         if (comp()->ilGenRequest().details().supportsInvalidation())\n            {\n            addAssumptions = true;\n            if ((comp()->getMethodHotness() == warm) &&\n               (callInfo = TR_PersistentMethodInfo::get(resolvedMethod)) &&\n               callInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n               addAssumptions = false;\n            }\n\n         if (addAssumptions &&\n               performTransformation(comp(), \"%sdevirtualizing invoke [%p] on preexistent argument %d [%p]\\n\", optDetailString(), node, receiverParmOrdinal, receiverSymbol))\n            {\n            if (trace())\n               traceMsg(comp(), \"secs devirtualizing invoke on preexistent argument %d in %s\\n\", receiverParmOrdinal, comp()->signature());\n\n            node->devirtualizeCall(treeTop);\n            bool inc = comp()->getCHTable()->recompileOnMethodOverride(comp(), resolvedMethod);\n            if (callInfo && inc) callInfo->incNumPrexAssumptions();\n            }\n         }\n      else if (receiverInfo->getClass())\n         {\n#ifdef J9_PROJECT_SPECIFIC\n         TR::ClassTableCriticalSection processIndirectCall(comp()->fe());\n         TR::SymbolReference *symRef = node->getSymbolReference();\n         TR_PersistentCHTable * chTable = comp()->getPersistentInfo()->getPersistentCHTable();\n         if (methSymbol->isInterface() || methodSymbol)\n            {\n            TR_ResolvedMethod * method = NULL;\n            bool newMethod = true;\n            // There is the risk of invaliding a method repeatedly due to class hierarchy extensions\n            // In the following avoid devirtualization based on single implementor if the method has\n            // been invalidated once\n            //\n            TR::Recompilation *recompInfo = comp()->getRecompilationInfo();\n            if (recompInfo && recompInfo->getMethodInfo()->getNumberOfInvalidations() >= 1 && !chTable->findSingleConcreteSubClass(receiverInfo->getClass(), comp()))\n               {\n               // will exit without performing any transformation\n               //fprintf(stderr, \"will not perform devirt\\n\");\n               }\n            else if (methSymbol->isInterface())\n               {\n               if (comp()->getPersistentInfo()->getRuntimeAssumptionTable()->getAssumptionCount(RuntimeAssumptionOnClassExtend) < 100000)\n                  method = chTable->findSingleInterfaceImplementer(receiverInfo->getClass(), node->getSymbolReference()->getCPIndex(), node->getSymbolReference()->getOwningMethod(comp()), comp());\n               if (method == NULL)\n                  {\n                  if (trace())\n                     {\n                     traceMsg(\n                        comp(),\n                        \"PREX:        - Failed to find interface callee\\n\");\n                     }\n                  return;\n                  }\n               }\n            else\n               {\n               if (resolvedMethod->isAbstract())\n                  method = chTable->findSingleAbstractImplementer(receiverInfo->getClass(), symRef->getOffset(), node->getSymbolReference()->getOwningMethod(comp()), comp());\n               else if (!chTable->isOverriddenInThisHierarchy(resolvedMethod, receiverInfo->getClass(), symRef->getOffset(), comp()))\n                  {\n                  method = symRef->getOwningMethod(comp())->getResolvedVirtualMethod(comp(), receiverInfo->getClass(), symRef->getOffset());\n                  newMethod = false;\n                  }\n               }\n\n            if (method && !method->virtualMethodIsOverridden())\n               {\n               TR_PersistentClassInfo *classInfo = comp()->getPersistentInfo()->getPersistentCHTable()->findClassInfoAfterLocking(receiverInfo->getClass(), comp());\n\n               // if the number of recompile assumptions on this particular\n               // class has exceeded a threshold, don't do prex anymore for this class\n               //\n               bool addAssumptions = false;\n\n               if (comp()->ilGenRequest().details().supportsInvalidation())\n                  {\n                  addAssumptions = true;\n                  if ((comp()->getMethodHotness() == warm) &&\n                        classInfo &&\n                        classInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n                     addAssumptions = false;\n\n                  // check the subclasses as well\n                  if (classInfo && addAssumptions)\n                     {\n                     TR_ScratchList<TR_PersistentClassInfo> subClasses(trMemory());\n                     TR_ClassQueries::collectAllSubClasses(classInfo, &subClasses, comp());\n                     ListIterator<TR_PersistentClassInfo> subClassesIt(&subClasses);\n                     for (TR_PersistentClassInfo *subClassInfo = subClassesIt.getFirst(); subClassInfo; subClassInfo = subClassesIt.getNext())\n                        {\n                        if (subClassInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions())\n                           {\n                           addAssumptions = false;\n                           break;\n                           }\n                        }\n                     }\n                  }\n\n               if (addAssumptions &&\n                   performTransformation(comp(), \"%sspecialize and devirtualize invoke [%p] based on only a single implementation for call on parameter %d [%p]\\n\", optDetailString(), node, receiverParmOrdinal, receiverSymbol))\n                  {\n                  if (newMethod || !method->isSameMethod(resolvedMethod))\n                     {\n                     TR::SymbolReference *newSymRef =\n                      getSymRefTab()->findOrCreateMethodSymbol\n                                   (symRef->getOwningMethodIndex(), -1, method, TR::MethodSymbol::Virtual);\n                     newSymRef->copyAliasSets(symRef, getSymRefTab());\n\n                     int32_t offset = -1;\n                     if (methSymbol->isInterface())\n                        offset = node->getSymbolReference()->getOwningMethod(comp())->getResolvedInterfaceMethodOffset(method->containingClass(), node->getSymbolReference()->getCPIndex());\n                     else\n                        offset = symRef->getOffset();\n\n                     newSymRef->setOffset(offset);\n                     node->setSymbolReference(newSymRef);\n                     }\n\n                  node->devirtualizeCall(treeTop);\n                  if (treeTop->getNode()->getOpCodeValue() == TR::ResolveCHK)\n                     TR::Node::recreate(treeTop->getNode(), TR::treetop);\n                  else if (treeTop->getNode()->getOpCodeValue() == TR::ResolveAndNULLCHK)\n                     TR::Node::recreate(treeTop->getNode(), TR::NULLCHK);\n\n                  bool doInc = comp()->getCHTable()->recompileOnNewClassExtend(comp(), receiverInfo->getClass());\n\n                  if (classInfo)\n                     {\n                     classInfo->setShouldNotBeNewlyExtended(comp()->getCompThreadID());\n                     if (doInc) classInfo->incNumPrexAssumptions();\n                     TR_ScratchList<TR_PersistentClassInfo> subClasses(trMemory());\n                     TR_ClassQueries::collectAllSubClasses(classInfo, &subClasses, comp());\n                     ListIterator<TR_PersistentClassInfo> subClassesIt(&subClasses);\n                     for (TR_PersistentClassInfo *subClassInfo = subClassesIt.getFirst(); subClassInfo; subClassInfo = subClassesIt.getNext())\n                        {\n                        TR_OpaqueClassBlock *subClass = (TR_OpaqueClassBlock *) subClassInfo->getClassId();\n                        subClassInfo->setShouldNotBeNewlyExtended(comp()->getCompThreadID());\n                        if (comp()->getCHTable()->recompileOnNewClassExtend(comp(), subClass))\n                           subClassInfo->incNumPrexAssumptions();\n                        }\n                     }\n\n\n                  //comp()->getCHTable()->recompileOnMethodOverride(comp(), method);\n                  _success = true;\n                  }\n               else\n                  {\n                  return;\n                  }\n               }\n            else\n               {\n               return;\n               }\n            }\n#endif\n         }\n      }\n\n\n   if (comp()->isPeekingMethod() && receiverInfo->getClass() && !isInterface)\n      {\n      TR::SymbolReference *symRef = node->getSymbolReference();\n      int32_t offset = symRef->getOffset();\n      //printf(\"Node %p arg %d\\n\", node, receiverParmOrdinal);\n      //printf(\"Method is %s\\n\", resolvedMethod->signature(trMemory()));\n      //fflush(stdout);\n\n      TR_ResolvedMethod *originalResolvedMethod = resolvedMethod;\n      TR_OpaqueClassBlock *originalClazz = originalResolvedMethod->containingClass();\n      bool canRefine = true;\n      if (originalClazz != receiverInfo->getClass())\n         {\n         TR_YesNoMaybe isInstance = fe()->isInstanceOf(originalClazz, receiverInfo->getClass(), true);\n         if (isInstance == TR_yes)\n            canRefine = false;\n\n         isInstance = fe()->isInstanceOf(receiverInfo->getClass(), originalClazz, true);\n         if (isInstance == TR_no)\n            canRefine = false;\n         }\n\n      TR_ResolvedMethod *resolvedMethod = NULL;\n      if (canRefine)\n         resolvedMethod = symRef->getOwningMethod(comp())->getResolvedVirtualMethod(comp(), receiverInfo->getClass(), offset);\n\n      if (resolvedMethod)\n         {\n         if (!originalResolvedMethod || !resolvedMethod->isSameMethod(originalResolvedMethod))\n            {\n            TR::SymbolReference * newSymRef =\n          _peekingSymRefTab->findOrCreateMethodSymbol(\n                             symRef->getOwningMethodIndex(), -1, resolvedMethod, TR::MethodSymbol::Virtual);\n            newSymRef->copyAliasSets(symRef, _peekingSymRefTab);\n            newSymRef->setOffset(offset);\n            node->setSymbolReference(newSymRef);\n            }\n         }\n      }\n#endif\n   }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -99,7 +99,62 @@\n \n    // Quit if class is not compatible with the method\n    if (resolvedMethod && receiverInfo->getClass() && !classIsCompatibleWithMethod(receiverInfo->getClass(), resolvedMethod))\n+      {\n+      if (trace())\n+         traceMsg(comp(), \"PREX:        - Receiver type incompatible with method \\n\");\n+\n       return;\n+      }\n+\n+   TR::MethodSymbol *methSymbol = node->getSymbol()->getMethodSymbol();\n+   if (methSymbol->isInterface())\n+      {\n+      // Interface type signatures can't be trusted most places in bytecode, so\n+      // only transform interface calls when we have a class bound for the\n+      // receiver.\n+      TR_OpaqueClassBlock *klass = receiverInfo->getClass();\n+      if (klass == NULL || TR::Compiler->cls.isInterfaceClass(comp(), klass))\n+         {\n+         if (trace())\n+            {\n+            traceMsg(\n+               comp(),\n+               \"PREX:        - No class type bound for interface call receiver\\n\");\n+            }\n+\n+         return;\n+         }\n+\n+      TR_ResolvedMethod *caller = node->getSymbolReference()->getOwningMethod(comp());\n+      TR::Method *callee = methSymbol->getMethod();\n+      bool aotOk = true;\n+      TR_OpaqueClassBlock *iface = fe()->getClassFromSignature(\n+         callee->classNameChars(), callee->classNameLength(), caller, aotOk);\n+\n+      if (iface == NULL)\n+         {\n+         if (trace())\n+            {\n+            traceMsg(\n+               comp(),\n+               \"PREX:        - Failed to identify interface for interface call\\n\");\n+            }\n+\n+         return;\n+         }\n+\n+      if (fe()->isInstanceOf(klass, iface, true, true, true) != TR_yes)\n+         {\n+         if (trace())\n+            {\n+            traceMsg(\n+               comp(),\n+               \"PREX:        - Insufficient class type bound for interface call receiver\\n\");\n+            }\n+\n+         return;\n+         }\n+      }\n \n    //\n    // Step 2: Transform\n@@ -203,7 +258,6 @@\n          TR::ClassTableCriticalSection processIndirectCall(comp()->fe());\n          TR::SymbolReference *symRef = node->getSymbolReference();\n          TR_PersistentCHTable * chTable = comp()->getPersistentInfo()->getPersistentCHTable();\n-         TR::MethodSymbol *methSymbol = node->getSymbol()->getMethodSymbol();\n          if (methSymbol->isInterface() || methodSymbol)\n             {\n             TR_ResolvedMethod * method = NULL;\n@@ -222,8 +276,16 @@\n                {\n                if (comp()->getPersistentInfo()->getRuntimeAssumptionTable()->getAssumptionCount(RuntimeAssumptionOnClassExtend) < 100000)\n                   method = chTable->findSingleInterfaceImplementer(receiverInfo->getClass(), node->getSymbolReference()->getCPIndex(), node->getSymbolReference()->getOwningMethod(comp()), comp());\n-               //if (method)\n-               //   fprintf(stderr, \"%s assumptios=%d\\n\", comp()->signature(), comp()->getPersistentInfo()->getRuntimeAssumptionTable()->getAssumptionCount(RuntimeAssumptionOnClassExtend));\n+               if (method == NULL)\n+                  {\n+                  if (trace())\n+                     {\n+                     traceMsg(\n+                        comp(),\n+                        \"PREX:        - Failed to find interface callee\\n\");\n+                     }\n+                  return;\n+                  }\n                }\n             else\n                {",
        "diff_line_info": {
            "deleted_lines": [
                "         TR::MethodSymbol *methSymbol = node->getSymbol()->getMethodSymbol();",
                "               //if (method)",
                "               //   fprintf(stderr, \"%s assumptios=%d\\n\", comp()->signature(), comp()->getPersistentInfo()->getRuntimeAssumptionTable()->getAssumptionCount(RuntimeAssumptionOnClassExtend));"
            ],
            "added_lines": [
                "      {",
                "      if (trace())",
                "         traceMsg(comp(), \"PREX:        - Receiver type incompatible with method \\n\");",
                "",
                "      }",
                "",
                "   TR::MethodSymbol *methSymbol = node->getSymbol()->getMethodSymbol();",
                "   if (methSymbol->isInterface())",
                "      {",
                "      // Interface type signatures can't be trusted most places in bytecode, so",
                "      // only transform interface calls when we have a class bound for the",
                "      // receiver.",
                "      TR_OpaqueClassBlock *klass = receiverInfo->getClass();",
                "      if (klass == NULL || TR::Compiler->cls.isInterfaceClass(comp(), klass))",
                "         {",
                "         if (trace())",
                "            {",
                "            traceMsg(",
                "               comp(),",
                "               \"PREX:        - No class type bound for interface call receiver\\n\");",
                "            }",
                "",
                "         return;",
                "         }",
                "",
                "      TR_ResolvedMethod *caller = node->getSymbolReference()->getOwningMethod(comp());",
                "      TR::Method *callee = methSymbol->getMethod();",
                "      bool aotOk = true;",
                "      TR_OpaqueClassBlock *iface = fe()->getClassFromSignature(",
                "         callee->classNameChars(), callee->classNameLength(), caller, aotOk);",
                "",
                "      if (iface == NULL)",
                "         {",
                "         if (trace())",
                "            {",
                "            traceMsg(",
                "               comp(),",
                "               \"PREX:        - Failed to identify interface for interface call\\n\");",
                "            }",
                "",
                "         return;",
                "         }",
                "",
                "      if (fe()->isInstanceOf(klass, iface, true, true, true) != TR_yes)",
                "         {",
                "         if (trace())",
                "            {",
                "            traceMsg(",
                "               comp(),",
                "               \"PREX:        - Insufficient class type bound for interface call receiver\\n\");",
                "            }",
                "",
                "         return;",
                "         }",
                "      }",
                "               if (method == NULL)",
                "                  {",
                "                  if (trace())",
                "                     {",
                "                     traceMsg(",
                "                        comp(),",
                "                        \"PREX:        - Failed to find interface callee\\n\");",
                "                     }",
                "                  return;",
                "                  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14639",
        "func_name": "axiomatic-systems/Bento4/AP4_VisualSampleEntry::ReadFields",
        "description": "AP4_VisualSampleEntry::ReadFields in Core/Ap4SampleEntry.cpp in Bento4 1.5.0-617 uses incorrect character data types, which causes a stack-based buffer underflow and out-of-bounds write, leading to denial of service (application crash) or possibly unspecified other impact.",
        "git_url": "https://github.com/axiomatic-systems/Bento4/commit/03d1222ab9c2ce779cdf01bdb96cdd69cbdcfeda",
        "commit_title": "fix for #190",
        "commit_text": "",
        "func_before": "AP4_Result\nAP4_VisualSampleEntry::ReadFields(AP4_ByteStream& stream)\n{\n    // sample entry\n    AP4_Result result = AP4_SampleEntry::ReadFields(stream);\n    if (result < 0) return result;\n\n    // read fields from this class\n    stream.ReadUI16(m_Predefined1);\n    stream.ReadUI16(m_Reserved2);\n    stream.Read(m_Predefined2, sizeof(m_Predefined2));\n    stream.ReadUI16(m_Width);\n    stream.ReadUI16(m_Height);\n    stream.ReadUI32(m_HorizResolution);\n    stream.ReadUI32(m_VertResolution);\n    stream.ReadUI32(m_Reserved3);\n    stream.ReadUI16(m_FrameCount);\n\n    char compressor_name[33];\n    compressor_name[32] = 0;\n    stream.Read(compressor_name, 32);\n    int name_length = compressor_name[0];\n    if (name_length < 32) {\n        compressor_name[name_length+1] = 0; // force null termination\n        m_CompressorName = &compressor_name[1];\n    }\n\n    stream.ReadUI16(m_Depth);\n    stream.ReadUI16(m_Predefined3);\n\n    return AP4_SUCCESS;\n}",
        "func": "AP4_Result\nAP4_VisualSampleEntry::ReadFields(AP4_ByteStream& stream)\n{\n    // sample entry\n    AP4_Result result = AP4_SampleEntry::ReadFields(stream);\n    if (result < 0) return result;\n\n    // read fields from this class\n    stream.ReadUI16(m_Predefined1);\n    stream.ReadUI16(m_Reserved2);\n    stream.Read(m_Predefined2, sizeof(m_Predefined2));\n    stream.ReadUI16(m_Width);\n    stream.ReadUI16(m_Height);\n    stream.ReadUI32(m_HorizResolution);\n    stream.ReadUI32(m_VertResolution);\n    stream.ReadUI32(m_Reserved3);\n    stream.ReadUI16(m_FrameCount);\n\n    AP4_UI08 compressor_name[33];\n    compressor_name[32] = 0;\n    stream.Read(compressor_name, 32);\n    AP4_UI08 name_length = compressor_name[0];\n    if (name_length < 32) {\n        compressor_name[name_length+1] = 0; // force null termination\n        m_CompressorName = (const char*)(&compressor_name[1]);\n    }\n\n    stream.ReadUI16(m_Depth);\n    stream.ReadUI16(m_Predefined3);\n\n    return AP4_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,13 +16,13 @@\n     stream.ReadUI32(m_Reserved3);\n     stream.ReadUI16(m_FrameCount);\n \n-    char compressor_name[33];\n+    AP4_UI08 compressor_name[33];\n     compressor_name[32] = 0;\n     stream.Read(compressor_name, 32);\n-    int name_length = compressor_name[0];\n+    AP4_UI08 name_length = compressor_name[0];\n     if (name_length < 32) {\n         compressor_name[name_length+1] = 0; // force null termination\n-        m_CompressorName = &compressor_name[1];\n+        m_CompressorName = (const char*)(&compressor_name[1]);\n     }\n \n     stream.ReadUI16(m_Depth);",
        "diff_line_info": {
            "deleted_lines": [
                "    char compressor_name[33];",
                "    int name_length = compressor_name[0];",
                "        m_CompressorName = &compressor_name[1];"
            ],
            "added_lines": [
                "    AP4_UI08 compressor_name[33];",
                "    AP4_UI08 name_length = compressor_name[0];",
                "        m_CompressorName = (const char*)(&compressor_name[1]);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-1731",
        "func_name": "chromium/HTMLSelectElement::platformHandleKeydownEvent",
        "description": "core/html/HTMLSelectElement.cpp in the DOM implementation in Blink, as used in Google Chrome before 34.0.1847.131 on Windows and OS X and before 34.0.1847.132 on Linux, does not properly check renderer state upon a focus event, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that leverage \"type confusion\" for SELECT elements.",
        "git_url": "https://github.com/chromium/chromium/commit/8af0539080de07191019585dd752678f55774f54",
        "commit_title": "Add renderer type checks to HTMLSelectElement event handlers.",
        "commit_text": " focus() can change the renderer type.   This CL is based on a patch by jbutler@chromium.org. This CL fixed one bug in the original CL, and added a test. The test is only for OSX because other platforms don't use HTMLSelectElement::platformHandleKeydownEvent.   ",
        "func_before": "bool HTMLSelectElement::platformHandleKeydownEvent(KeyboardEvent* event)\n{\n    if (!RenderTheme::theme().popsMenuByArrowKeys())\n        return false;\n\n    if (!isSpatialNavigationEnabled(document().frame())) {\n        if (event->keyIdentifier() == \"Down\" || event->keyIdentifier() == \"Up\") {\n            focus();\n            // Calling focus() may cause us to lose our renderer. Return true so\n            // that our caller doesn't process the event further, but don't set\n            // the event as handled.\n            if (!renderer() || isDisabledFormControl())\n                return true;\n\n            // Save the selection so it can be compared to the new selection\n            // when dispatching change events during selectOption, which\n            // gets called from RenderMenuList::valueChanged, which gets called\n            // after the user makes a selection from the menu.\n            saveLastSelection();\n            if (RenderMenuList* menuList = toRenderMenuList(renderer()))\n                menuList->showPopup();\n            event->setDefaultHandled();\n        }\n        return true;\n    }\n\n    return false;\n}",
        "func": "bool HTMLSelectElement::platformHandleKeydownEvent(KeyboardEvent* event)\n{\n    if (!RenderTheme::theme().popsMenuByArrowKeys())\n        return false;\n\n    if (!isSpatialNavigationEnabled(document().frame())) {\n        if (event->keyIdentifier() == \"Down\" || event->keyIdentifier() == \"Up\") {\n            focus();\n            // Calling focus() may cause us to lose our renderer. Return true so\n            // that our caller doesn't process the event further, but don't set\n            // the event as handled.\n            if (!renderer() || !renderer()->isMenuList() || isDisabledFormControl())\n                return true;\n\n            // Save the selection so it can be compared to the new selection\n            // when dispatching change events during selectOption, which\n            // gets called from RenderMenuList::valueChanged, which gets called\n            // after the user makes a selection from the menu.\n            saveLastSelection();\n            if (RenderMenuList* menuList = toRenderMenuList(renderer()))\n                menuList->showPopup();\n            event->setDefaultHandled();\n        }\n        return true;\n    }\n\n    return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,7 @@\n             // Calling focus() may cause us to lose our renderer. Return true so\n             // that our caller doesn't process the event further, but don't set\n             // the event as handled.\n-            if (!renderer() || isDisabledFormControl())\n+            if (!renderer() || !renderer()->isMenuList() || isDisabledFormControl())\n                 return true;\n \n             // Save the selection so it can be compared to the new selection",
        "diff_line_info": {
            "deleted_lines": [
                "            if (!renderer() || isDisabledFormControl())"
            ],
            "added_lines": [
                "            if (!renderer() || !renderer()->isMenuList() || isDisabledFormControl())"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-1731",
        "func_name": "chromium/HTMLSelectElement::listBoxDefaultEventHandler",
        "description": "core/html/HTMLSelectElement.cpp in the DOM implementation in Blink, as used in Google Chrome before 34.0.1847.131 on Windows and OS X and before 34.0.1847.132 on Linux, does not properly check renderer state upon a focus event, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that leverage \"type confusion\" for SELECT elements.",
        "git_url": "https://github.com/chromium/chromium/commit/8af0539080de07191019585dd752678f55774f54",
        "commit_title": "Add renderer type checks to HTMLSelectElement event handlers.",
        "commit_text": " focus() can change the renderer type.   This CL is based on a patch by jbutler@chromium.org. This CL fixed one bug in the original CL, and added a test. The test is only for OSX because other platforms don't use HTMLSelectElement::platformHandleKeydownEvent.   ",
        "func_before": "void HTMLSelectElement::listBoxDefaultEventHandler(Event* event)\n{\n    const Vector<HTMLElement*>& listItems = this->listItems();\n    bool dragSelection = false;\n    if (event->type() == EventTypeNames::gesturetap && event->isGestureEvent()) {\n        focus();\n        // Calling focus() may cause us to lose our renderer or change the render type, in which case do not want to handle the event.\n        if (!renderer() || !renderer()->isListBox())\n            return;\n\n        // Convert to coords relative to the list box if needed.\n        GestureEvent& gestureEvent = toGestureEvent(*event);\n        IntPoint localOffset = roundedIntPoint(renderer()->absoluteToLocal(gestureEvent.absoluteLocation(), UseTransforms));\n        int listIndex = toRenderListBox(renderer())->listIndexAtOffset(toIntSize(localOffset));\n        if (listIndex >= 0) {\n            if (!isDisabledFormControl())\n                updateSelectedState(listIndex, true, gestureEvent.shiftKey());\n            event->setDefaultHandled();\n        }\n    } else if (event->type() == EventTypeNames::mousedown && event->isMouseEvent() && toMouseEvent(event)->button() == LeftButton) {\n        focus();\n        // Calling focus() may cause us to lose our renderer, in which case do not want to handle the event.\n        if (!renderer())\n            return;\n\n        // Convert to coords relative to the list box if needed.\n        MouseEvent* mouseEvent = toMouseEvent(event);\n        IntPoint localOffset = roundedIntPoint(renderer()->absoluteToLocal(mouseEvent->absoluteLocation(), UseTransforms));\n        int listIndex = toRenderListBox(renderer())->listIndexAtOffset(toIntSize(localOffset));\n        if (listIndex >= 0) {\n            if (!isDisabledFormControl()) {\n#if OS(MACOSX)\n                updateSelectedState(listIndex, mouseEvent->metaKey(), mouseEvent->shiftKey());\n#else\n                updateSelectedState(listIndex, mouseEvent->ctrlKey(), mouseEvent->shiftKey());\n#endif\n            }\n            if (LocalFrame* frame = document().frame())\n                frame->eventHandler().setMouseDownMayStartAutoscroll();\n\n            event->setDefaultHandled();\n        }\n    } else if (event->type() == EventTypeNames::mousemove && event->isMouseEvent() && !toRenderBox(renderer())->canBeScrolledAndHasScrollableArea()) {\n        MouseEvent* mouseEvent = toMouseEvent(event);\n        if (mouseEvent->button() != LeftButton || !mouseEvent->buttonDown())\n            return;\n\n        IntPoint localOffset = roundedIntPoint(renderer()->absoluteToLocal(mouseEvent->absoluteLocation(), UseTransforms));\n        int listIndex = toRenderListBox(renderer())->listIndexAtOffset(toIntSize(localOffset));\n        if (listIndex >= 0) {\n            if (!isDisabledFormControl()) {\n                if (m_multiple) {\n                    // Only extend selection if there is something selected.\n                    if (m_activeSelectionAnchorIndex < 0)\n                        return;\n\n                    setActiveSelectionEndIndex(listIndex);\n                    updateListBoxSelection(false);\n                } else {\n                    setActiveSelectionAnchorIndex(listIndex);\n                    setActiveSelectionEndIndex(listIndex);\n                    updateListBoxSelection(true);\n                }\n            }\n            dragSelection = true;\n        }\n    } else if (event->type() == EventTypeNames::mouseup && event->isMouseEvent() && toMouseEvent(event)->button() == LeftButton && renderer() && !toRenderBox(renderer())->autoscrollInProgress()) {\n        // We didn't start this click/drag on any options.\n        if (m_lastOnChangeSelection.isEmpty())\n            return;\n        // This makes sure we fire dispatchFormControlChangeEvent for a single\n        // click. For drag selection, onChange will fire when the autoscroll\n        // timer stops.\n        if (!dragSelection) {\n            listBoxOnChange();\n        }\n    } else if (event->type() == EventTypeNames::keydown) {\n        if (!event->isKeyboardEvent())\n            return;\n        const String& keyIdentifier = toKeyboardEvent(event)->keyIdentifier();\n\n        bool handled = false;\n        int endIndex = 0;\n        if (m_activeSelectionEndIndex < 0) {\n            // Initialize the end index\n            if (keyIdentifier == \"Down\" || keyIdentifier == \"PageDown\") {\n                int startIndex = lastSelectedListIndex();\n                handled = true;\n                if (keyIdentifier == \"Down\")\n                    endIndex = nextSelectableListIndex(startIndex);\n                else\n                    endIndex = nextSelectableListIndexPageAway(startIndex, SkipForwards);\n            } else if (keyIdentifier == \"Up\" || keyIdentifier == \"PageUp\") {\n                int startIndex = optionToListIndex(selectedIndex());\n                handled = true;\n                if (keyIdentifier == \"Up\")\n                    endIndex = previousSelectableListIndex(startIndex);\n                else\n                    endIndex = nextSelectableListIndexPageAway(startIndex, SkipBackwards);\n            }\n        } else {\n            // Set the end index based on the current end index.\n            if (keyIdentifier == \"Down\") {\n                endIndex = nextSelectableListIndex(m_activeSelectionEndIndex);\n                handled = true;\n            } else if (keyIdentifier == \"Up\") {\n                endIndex = previousSelectableListIndex(m_activeSelectionEndIndex);\n                handled = true;\n            } else if (keyIdentifier == \"PageDown\") {\n                endIndex = nextSelectableListIndexPageAway(m_activeSelectionEndIndex, SkipForwards);\n                handled = true;\n            } else if (keyIdentifier == \"PageUp\") {\n                endIndex = nextSelectableListIndexPageAway(m_activeSelectionEndIndex, SkipBackwards);\n                handled = true;\n            }\n        }\n        if (keyIdentifier == \"Home\") {\n            endIndex = firstSelectableListIndex();\n            handled = true;\n        } else if (keyIdentifier == \"End\") {\n            endIndex = lastSelectableListIndex();\n            handled = true;\n        }\n\n        if (isSpatialNavigationEnabled(document().frame()))\n            // Check if the selection moves to the boundary.\n            if (keyIdentifier == \"Left\" || keyIdentifier == \"Right\" || ((keyIdentifier == \"Down\" || keyIdentifier == \"Up\") && endIndex == m_activeSelectionEndIndex))\n                return;\n\n        if (endIndex >= 0 && handled) {\n            // Save the selection so it can be compared to the new selection\n            // when dispatching change events immediately after making the new\n            // selection.\n            saveLastSelection();\n\n            ASSERT_UNUSED(listItems, !listItems.size() || static_cast<size_t>(endIndex) < listItems.size());\n            setActiveSelectionEndIndex(endIndex);\n\n            bool selectNewItem = !m_multiple || toKeyboardEvent(event)->shiftKey() || !isSpatialNavigationEnabled(document().frame());\n            if (selectNewItem)\n                m_activeSelectionState = true;\n            // If the anchor is unitialized, or if we're going to deselect all\n            // other options, then set the anchor index equal to the end index.\n            bool deselectOthers = !m_multiple || (!toKeyboardEvent(event)->shiftKey() && selectNewItem);\n            if (m_activeSelectionAnchorIndex < 0 || deselectOthers) {\n                if (deselectOthers)\n                    deselectItemsWithoutValidation();\n                setActiveSelectionAnchorIndex(m_activeSelectionEndIndex);\n            }\n\n            toRenderListBox(renderer())->scrollToRevealElementAtListIndex(endIndex);\n            if (selectNewItem) {\n                updateListBoxSelection(deselectOthers);\n                listBoxOnChange();\n            } else\n                scrollToSelection();\n\n            event->setDefaultHandled();\n        }\n    } else if (event->type() == EventTypeNames::keypress) {\n        if (!event->isKeyboardEvent())\n            return;\n        int keyCode = toKeyboardEvent(event)->keyCode();\n\n        if (keyCode == '\\r') {\n            if (form())\n                form()->submitImplicitly(event, false);\n            event->setDefaultHandled();\n        } else if (m_multiple && keyCode == ' ' && isSpatialNavigationEnabled(document().frame())) {\n            // Use space to toggle selection change.\n            m_activeSelectionState = !m_activeSelectionState;\n            updateSelectedState(listToOptionIndex(m_activeSelectionEndIndex), true /*multi*/, false /*shift*/);\n            listBoxOnChange();\n            event->setDefaultHandled();\n        }\n    }\n}",
        "func": "void HTMLSelectElement::listBoxDefaultEventHandler(Event* event)\n{\n    const Vector<HTMLElement*>& listItems = this->listItems();\n    bool dragSelection = false;\n    if (event->type() == EventTypeNames::gesturetap && event->isGestureEvent()) {\n        focus();\n        // Calling focus() may cause us to lose our renderer or change the render type, in which case do not want to handle the event.\n        if (!renderer() || !renderer()->isListBox())\n            return;\n\n        // Convert to coords relative to the list box if needed.\n        GestureEvent& gestureEvent = toGestureEvent(*event);\n        IntPoint localOffset = roundedIntPoint(renderer()->absoluteToLocal(gestureEvent.absoluteLocation(), UseTransforms));\n        int listIndex = toRenderListBox(renderer())->listIndexAtOffset(toIntSize(localOffset));\n        if (listIndex >= 0) {\n            if (!isDisabledFormControl())\n                updateSelectedState(listIndex, true, gestureEvent.shiftKey());\n            event->setDefaultHandled();\n        }\n    } else if (event->type() == EventTypeNames::mousedown && event->isMouseEvent() && toMouseEvent(event)->button() == LeftButton) {\n        focus();\n        // Calling focus() may cause us to lose our renderer, in which case do not want to handle the event.\n        if (!renderer() || !renderer()->isListBox() || isDisabledFormControl())\n            return;\n\n        // Convert to coords relative to the list box if needed.\n        MouseEvent* mouseEvent = toMouseEvent(event);\n        IntPoint localOffset = roundedIntPoint(renderer()->absoluteToLocal(mouseEvent->absoluteLocation(), UseTransforms));\n        int listIndex = toRenderListBox(renderer())->listIndexAtOffset(toIntSize(localOffset));\n        if (listIndex >= 0) {\n            if (!isDisabledFormControl()) {\n#if OS(MACOSX)\n                updateSelectedState(listIndex, mouseEvent->metaKey(), mouseEvent->shiftKey());\n#else\n                updateSelectedState(listIndex, mouseEvent->ctrlKey(), mouseEvent->shiftKey());\n#endif\n            }\n            if (LocalFrame* frame = document().frame())\n                frame->eventHandler().setMouseDownMayStartAutoscroll();\n\n            event->setDefaultHandled();\n        }\n    } else if (event->type() == EventTypeNames::mousemove && event->isMouseEvent() && !toRenderBox(renderer())->canBeScrolledAndHasScrollableArea()) {\n        MouseEvent* mouseEvent = toMouseEvent(event);\n        if (mouseEvent->button() != LeftButton || !mouseEvent->buttonDown())\n            return;\n\n        IntPoint localOffset = roundedIntPoint(renderer()->absoluteToLocal(mouseEvent->absoluteLocation(), UseTransforms));\n        int listIndex = toRenderListBox(renderer())->listIndexAtOffset(toIntSize(localOffset));\n        if (listIndex >= 0) {\n            if (!isDisabledFormControl()) {\n                if (m_multiple) {\n                    // Only extend selection if there is something selected.\n                    if (m_activeSelectionAnchorIndex < 0)\n                        return;\n\n                    setActiveSelectionEndIndex(listIndex);\n                    updateListBoxSelection(false);\n                } else {\n                    setActiveSelectionAnchorIndex(listIndex);\n                    setActiveSelectionEndIndex(listIndex);\n                    updateListBoxSelection(true);\n                }\n            }\n            dragSelection = true;\n        }\n    } else if (event->type() == EventTypeNames::mouseup && event->isMouseEvent() && toMouseEvent(event)->button() == LeftButton && renderer() && !toRenderBox(renderer())->autoscrollInProgress()) {\n        // We didn't start this click/drag on any options.\n        if (m_lastOnChangeSelection.isEmpty())\n            return;\n        // This makes sure we fire dispatchFormControlChangeEvent for a single\n        // click. For drag selection, onChange will fire when the autoscroll\n        // timer stops.\n        if (!dragSelection) {\n            listBoxOnChange();\n        }\n    } else if (event->type() == EventTypeNames::keydown) {\n        if (!event->isKeyboardEvent())\n            return;\n        const String& keyIdentifier = toKeyboardEvent(event)->keyIdentifier();\n\n        bool handled = false;\n        int endIndex = 0;\n        if (m_activeSelectionEndIndex < 0) {\n            // Initialize the end index\n            if (keyIdentifier == \"Down\" || keyIdentifier == \"PageDown\") {\n                int startIndex = lastSelectedListIndex();\n                handled = true;\n                if (keyIdentifier == \"Down\")\n                    endIndex = nextSelectableListIndex(startIndex);\n                else\n                    endIndex = nextSelectableListIndexPageAway(startIndex, SkipForwards);\n            } else if (keyIdentifier == \"Up\" || keyIdentifier == \"PageUp\") {\n                int startIndex = optionToListIndex(selectedIndex());\n                handled = true;\n                if (keyIdentifier == \"Up\")\n                    endIndex = previousSelectableListIndex(startIndex);\n                else\n                    endIndex = nextSelectableListIndexPageAway(startIndex, SkipBackwards);\n            }\n        } else {\n            // Set the end index based on the current end index.\n            if (keyIdentifier == \"Down\") {\n                endIndex = nextSelectableListIndex(m_activeSelectionEndIndex);\n                handled = true;\n            } else if (keyIdentifier == \"Up\") {\n                endIndex = previousSelectableListIndex(m_activeSelectionEndIndex);\n                handled = true;\n            } else if (keyIdentifier == \"PageDown\") {\n                endIndex = nextSelectableListIndexPageAway(m_activeSelectionEndIndex, SkipForwards);\n                handled = true;\n            } else if (keyIdentifier == \"PageUp\") {\n                endIndex = nextSelectableListIndexPageAway(m_activeSelectionEndIndex, SkipBackwards);\n                handled = true;\n            }\n        }\n        if (keyIdentifier == \"Home\") {\n            endIndex = firstSelectableListIndex();\n            handled = true;\n        } else if (keyIdentifier == \"End\") {\n            endIndex = lastSelectableListIndex();\n            handled = true;\n        }\n\n        if (isSpatialNavigationEnabled(document().frame()))\n            // Check if the selection moves to the boundary.\n            if (keyIdentifier == \"Left\" || keyIdentifier == \"Right\" || ((keyIdentifier == \"Down\" || keyIdentifier == \"Up\") && endIndex == m_activeSelectionEndIndex))\n                return;\n\n        if (endIndex >= 0 && handled) {\n            // Save the selection so it can be compared to the new selection\n            // when dispatching change events immediately after making the new\n            // selection.\n            saveLastSelection();\n\n            ASSERT_UNUSED(listItems, !listItems.size() || static_cast<size_t>(endIndex) < listItems.size());\n            setActiveSelectionEndIndex(endIndex);\n\n            bool selectNewItem = !m_multiple || toKeyboardEvent(event)->shiftKey() || !isSpatialNavigationEnabled(document().frame());\n            if (selectNewItem)\n                m_activeSelectionState = true;\n            // If the anchor is unitialized, or if we're going to deselect all\n            // other options, then set the anchor index equal to the end index.\n            bool deselectOthers = !m_multiple || (!toKeyboardEvent(event)->shiftKey() && selectNewItem);\n            if (m_activeSelectionAnchorIndex < 0 || deselectOthers) {\n                if (deselectOthers)\n                    deselectItemsWithoutValidation();\n                setActiveSelectionAnchorIndex(m_activeSelectionEndIndex);\n            }\n\n            toRenderListBox(renderer())->scrollToRevealElementAtListIndex(endIndex);\n            if (selectNewItem) {\n                updateListBoxSelection(deselectOthers);\n                listBoxOnChange();\n            } else\n                scrollToSelection();\n\n            event->setDefaultHandled();\n        }\n    } else if (event->type() == EventTypeNames::keypress) {\n        if (!event->isKeyboardEvent())\n            return;\n        int keyCode = toKeyboardEvent(event)->keyCode();\n\n        if (keyCode == '\\r') {\n            if (form())\n                form()->submitImplicitly(event, false);\n            event->setDefaultHandled();\n        } else if (m_multiple && keyCode == ' ' && isSpatialNavigationEnabled(document().frame())) {\n            // Use space to toggle selection change.\n            m_activeSelectionState = !m_activeSelectionState;\n            updateSelectedState(listToOptionIndex(m_activeSelectionEndIndex), true /*multi*/, false /*shift*/);\n            listBoxOnChange();\n            event->setDefaultHandled();\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,7 +20,7 @@\n     } else if (event->type() == EventTypeNames::mousedown && event->isMouseEvent() && toMouseEvent(event)->button() == LeftButton) {\n         focus();\n         // Calling focus() may cause us to lose our renderer, in which case do not want to handle the event.\n-        if (!renderer())\n+        if (!renderer() || !renderer()->isListBox() || isDisabledFormControl())\n             return;\n \n         // Convert to coords relative to the list box if needed.",
        "diff_line_info": {
            "deleted_lines": [
                "        if (!renderer())"
            ],
            "added_lines": [
                "        if (!renderer() || !renderer()->isListBox() || isDisabledFormControl())"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-1911",
        "func_name": "facebook/hermes/JSObject::getComputedWithReceiver_RJS",
        "description": "A type confusion vulnerability when resolving properties of JavaScript objects with specially-crafted prototype chains in Facebook Hermes prior to commit fe52854cdf6725c2eaa9e125995da76e6ceb27da allows attackers to potentially execute arbitrary code via crafted JavaScript. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.",
        "git_url": "https://github.com/facebook/hermes/commit/fe52854cdf6725c2eaa9e125995da76e6ceb27da",
        "commit_title": "[CVE-2020-1911] Look up HostObject computed properties on the right object in the prototype chain.",
        "commit_text": " Summary: The change in the hermes repository fixes the security vulnerability CVE-2020-1911.  This vulnerability only affects applications which allow evaluation of uncontrolled, untrusted JavaScript code not shipped with the app, so React Native apps will generally not be affected.  This revision includes a test for the bug.  The test is generic JSI code, so it is included in the hermes and react-native repositories.  Changelog: [Internal]  Reviewed By: tmikov  Differential Revision: D23322992  fbshipit-source-id: 4e88c974afe1ad33a263f9cac03e9dc98d33649a",
        "func_before": "CallResult<PseudoHandle<>> JSObject::getComputedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    Handle<> receiver) {\n  // Try the fast-path first: no \"index-like\" properties and the \"name\" already\n  // is a valid integer index.\n  if (selfHandle->flags_.fastIndexProperties) {\n    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n      // Do we have this value present in our array storage? If so, return it.\n      PseudoHandle<> ourValue = createPseudoHandle(\n          getOwnIndexed(selfHandle.get(), runtime, *arrayIndex));\n      if (LLVM_LIKELY(!ourValue->isEmpty()))\n        return ourValue;\n    }\n  }\n\n  // If nameValHandle is an object, we should convert it to string now,\n  // because toString may have side-effect, and we want to do this only\n  // once.\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto nameValPrimitiveHandle = *converted;\n\n  ComputedPropertyDescriptor desc;\n\n  // Locate the descriptor. propObj contains the object which may be anywhere\n  // along the prototype chain.\n  MutableHandle<JSObject> propObj{runtime};\n  if (LLVM_UNLIKELY(\n          getComputedPrimitiveDescriptor(\n              selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  if (!propObj)\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n  if (LLVM_LIKELY(\n          !desc.flags.accessor && !desc.flags.hostObject &&\n          !desc.flags.proxyObject))\n    return createPseudoHandle(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n\n  if (desc.flags.accessor) {\n    auto *accessor = vmcast<PropertyAccessor>(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n    if (!accessor->getter)\n      return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n    // Execute the accessor on this object.\n    return accessor->getter.get(runtime)->executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    SymbolID id{};\n    LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n    auto propRes = vmcast<HostObject>(selfHandle.get())->get(id);\n    if (propRes == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return createPseudoHandle(*propRes);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return JSProxy::getComputed(propObj, runtime, *key, receiver);\n  }\n}",
        "func": "CallResult<PseudoHandle<>> JSObject::getComputedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    Handle<> receiver) {\n  // Try the fast-path first: no \"index-like\" properties and the \"name\" already\n  // is a valid integer index.\n  if (selfHandle->flags_.fastIndexProperties) {\n    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n      // Do we have this value present in our array storage? If so, return it.\n      PseudoHandle<> ourValue = createPseudoHandle(\n          getOwnIndexed(selfHandle.get(), runtime, *arrayIndex));\n      if (LLVM_LIKELY(!ourValue->isEmpty()))\n        return ourValue;\n    }\n  }\n\n  // If nameValHandle is an object, we should convert it to string now,\n  // because toString may have side-effect, and we want to do this only\n  // once.\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto nameValPrimitiveHandle = *converted;\n\n  ComputedPropertyDescriptor desc;\n\n  // Locate the descriptor. propObj contains the object which may be anywhere\n  // along the prototype chain.\n  MutableHandle<JSObject> propObj{runtime};\n  if (LLVM_UNLIKELY(\n          getComputedPrimitiveDescriptor(\n              selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  if (!propObj)\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n  if (LLVM_LIKELY(\n          !desc.flags.accessor && !desc.flags.hostObject &&\n          !desc.flags.proxyObject))\n    return createPseudoHandle(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n\n  if (desc.flags.accessor) {\n    auto *accessor = vmcast<PropertyAccessor>(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n    if (!accessor->getter)\n      return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n    // Execute the accessor on this object.\n    return accessor->getter.get(runtime)->executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    SymbolID id{};\n    LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n    auto propRes = vmcast<HostObject>(propObj.get())->get(id);\n    if (propRes == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return createPseudoHandle(*propRes);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return JSProxy::getComputed(propObj, runtime, *key, receiver);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -57,7 +57,7 @@\n   } else if (desc.flags.hostObject) {\n     SymbolID id{};\n     LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n-    auto propRes = vmcast<HostObject>(selfHandle.get())->get(id);\n+    auto propRes = vmcast<HostObject>(propObj.get())->get(id);\n     if (propRes == ExecutionStatus::EXCEPTION)\n       return ExecutionStatus::EXCEPTION;\n     return createPseudoHandle(*propRes);",
        "diff_line_info": {
            "deleted_lines": [
                "    auto propRes = vmcast<HostObject>(selfHandle.get())->get(id);"
            ],
            "added_lines": [
                "    auto propRes = vmcast<HostObject>(propObj.get())->get(id);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-3022",
        "func_name": "torvalds/linux/__fib6_rule_action",
        "description": "A flaw was found in the IPv6 module of the Linux kernel. The arg.result was not used consistently in fib6_rule_lookup, sometimes holding rt6_info and other times fib6_info. This was not accounted for in other parts of the code where rt6_info was expected unconditionally, potentially leading to a kernel panic in fib6_rule_suppress.",
        "git_url": "https://github.com/torvalds/linux/commit/a65120bae4b7425a39c5783aa3d4fc29677eef0e",
        "commit_title": "ipv6: Use result arg in fib_lookup_arg consistently",
        "commit_text": " arg.result is sometimes used as fib6_result and sometimes used to hold the rt6_info. Add rt6_info to fib6_result and make the use of arg.result consistent through ipv6 rules.  The rt6 entry is filled in for lookups returning a dst_entry, but not for direct fib_lookups that just want a fib6_info. ",
        "func_before": "static int __fib6_rule_action(struct fib_rule *rule, struct flowi *flp,\n\t\t\t      int flags, struct fib_lookup_arg *arg)\n{\n\tstruct flowi6 *flp6 = &flp->u.ip6;\n\tstruct rt6_info *rt = NULL;\n\tstruct fib6_table *table;\n\tstruct net *net = rule->fr_net;\n\tpol_lookup_t lookup = arg->lookup_ptr;\n\tint err = 0;\n\tu32 tb_id;\n\n\tswitch (rule->action) {\n\tcase FR_ACT_TO_TBL:\n\t\tbreak;\n\tcase FR_ACT_UNREACHABLE:\n\t\terr = -ENETUNREACH;\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tgoto discard_pkt;\n\tdefault:\n\tcase FR_ACT_BLACKHOLE:\n\t\terr = -EINVAL;\n\t\trt = net->ipv6.ip6_blk_hole_entry;\n\t\tgoto discard_pkt;\n\tcase FR_ACT_PROHIBIT:\n\t\terr = -EACCES;\n\t\trt = net->ipv6.ip6_prohibit_entry;\n\t\tgoto discard_pkt;\n\t}\n\n\ttb_id = fib_rule_get_table(rule, arg);\n\ttable = fib6_get_table(net, tb_id);\n\tif (!table) {\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trt = lookup(net, table, flp6, arg->lookup_data, flags);\n\tif (rt != net->ipv6.ip6_null_entry) {\n\t\terr = fib6_rule_saddr(net, rule, flags, flp6,\n\t\t\t\t      ip6_dst_idev(&rt->dst)->dev);\n\n\t\tif (err == -EAGAIN)\n\t\t\tgoto again;\n\n\t\terr = rt->dst.error;\n\t\tif (err != -EAGAIN)\n\t\t\tgoto out;\n\t}\nagain:\n\tip6_rt_put(rt);\n\terr = -EAGAIN;\n\trt = NULL;\n\tgoto out;\n\ndiscard_pkt:\n\tdst_hold(&rt->dst);\nout:\n\targ->result = rt;\n\treturn err;\n}",
        "func": "static int __fib6_rule_action(struct fib_rule *rule, struct flowi *flp,\n\t\t\t      int flags, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct flowi6 *flp6 = &flp->u.ip6;\n\tstruct rt6_info *rt = NULL;\n\tstruct fib6_table *table;\n\tstruct net *net = rule->fr_net;\n\tpol_lookup_t lookup = arg->lookup_ptr;\n\tint err = 0;\n\tu32 tb_id;\n\n\tswitch (rule->action) {\n\tcase FR_ACT_TO_TBL:\n\t\tbreak;\n\tcase FR_ACT_UNREACHABLE:\n\t\terr = -ENETUNREACH;\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tgoto discard_pkt;\n\tdefault:\n\tcase FR_ACT_BLACKHOLE:\n\t\terr = -EINVAL;\n\t\trt = net->ipv6.ip6_blk_hole_entry;\n\t\tgoto discard_pkt;\n\tcase FR_ACT_PROHIBIT:\n\t\terr = -EACCES;\n\t\trt = net->ipv6.ip6_prohibit_entry;\n\t\tgoto discard_pkt;\n\t}\n\n\ttb_id = fib_rule_get_table(rule, arg);\n\ttable = fib6_get_table(net, tb_id);\n\tif (!table) {\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trt = lookup(net, table, flp6, arg->lookup_data, flags);\n\tif (rt != net->ipv6.ip6_null_entry) {\n\t\terr = fib6_rule_saddr(net, rule, flags, flp6,\n\t\t\t\t      ip6_dst_idev(&rt->dst)->dev);\n\n\t\tif (err == -EAGAIN)\n\t\t\tgoto again;\n\n\t\terr = rt->dst.error;\n\t\tif (err != -EAGAIN)\n\t\t\tgoto out;\n\t}\nagain:\n\tip6_rt_put(rt);\n\terr = -EAGAIN;\n\trt = NULL;\n\tgoto out;\n\ndiscard_pkt:\n\tdst_hold(&rt->dst);\nout:\n\tres->rt6 = rt;\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,7 @@\n static int __fib6_rule_action(struct fib_rule *rule, struct flowi *flp,\n \t\t\t      int flags, struct fib_lookup_arg *arg)\n {\n+\tstruct fib6_result *res = arg->result;\n \tstruct flowi6 *flp6 = &flp->u.ip6;\n \tstruct rt6_info *rt = NULL;\n \tstruct fib6_table *table;\n@@ -55,6 +56,6 @@\n discard_pkt:\n \tdst_hold(&rt->dst);\n out:\n-\targ->result = rt;\n+\tres->rt6 = rt;\n \treturn err;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\targ->result = rt;"
            ],
            "added_lines": [
                "\tstruct fib6_result *res = arg->result;",
                "\tres->rt6 = rt;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-3022",
        "func_name": "torvalds/linux/fib6_rule_lookup",
        "description": "A flaw was found in the IPv6 module of the Linux kernel. The arg.result was not used consistently in fib6_rule_lookup, sometimes holding rt6_info and other times fib6_info. This was not accounted for in other parts of the code where rt6_info was expected unconditionally, potentially leading to a kernel panic in fib6_rule_suppress.",
        "git_url": "https://github.com/torvalds/linux/commit/a65120bae4b7425a39c5783aa3d4fc29677eef0e",
        "commit_title": "ipv6: Use result arg in fib_lookup_arg consistently",
        "commit_text": " arg.result is sometimes used as fib6_result and sometimes used to hold the rt6_info. Add rt6_info to fib6_result and make the use of arg.result consistent through ipv6 rules.  The rt6 entry is filled in for lookups returning a dst_entry, but not for direct fib_lookups that just want a fib6_info. ",
        "func_before": "struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tif (net->ipv6.fib6_has_custom_rules) {\n\t\tstruct fib_lookup_arg arg = {\n\t\t\t.lookup_ptr = lookup,\n\t\t\t.lookup_data = skb,\n\t\t\t.flags = FIB_LOOKUP_NOREF,\n\t\t};\n\n\t\t/* update flow if oif or iif point to device enslaved to l3mdev */\n\t\tl3mdev_update_flow(net, flowi6_to_flowi(fl6));\n\n\t\tfib_rules_lookup(net->ipv6.fib6_rules_ops,\n\t\t\t\t flowi6_to_flowi(fl6), flags, &arg);\n\n\t\tif (arg.result)\n\t\t\treturn arg.result;\n\t} else {\n\t\tstruct rt6_info *rt;\n\n\t\trt = lookup(net, net->ipv6.fib6_local_tbl, fl6, skb, flags);\n\t\tif (rt != net->ipv6.ip6_null_entry && rt->dst.error != -EAGAIN)\n\t\t\treturn &rt->dst;\n\t\tip6_rt_put(rt);\n\t\trt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\t\tif (rt->dst.error != -EAGAIN)\n\t\t\treturn &rt->dst;\n\t\tip6_rt_put(rt);\n\t}\n\n\tdst_hold(&net->ipv6.ip6_null_entry->dst);\n\treturn &net->ipv6.ip6_null_entry->dst;\n}",
        "func": "struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tif (net->ipv6.fib6_has_custom_rules) {\n\t\tstruct fib6_result res = {};\n\t\tstruct fib_lookup_arg arg = {\n\t\t\t.lookup_ptr = lookup,\n\t\t\t.lookup_data = skb,\n\t\t\t.result = &res,\n\t\t\t.flags = FIB_LOOKUP_NOREF,\n\t\t};\n\n\t\t/* update flow if oif or iif point to device enslaved to l3mdev */\n\t\tl3mdev_update_flow(net, flowi6_to_flowi(fl6));\n\n\t\tfib_rules_lookup(net->ipv6.fib6_rules_ops,\n\t\t\t\t flowi6_to_flowi(fl6), flags, &arg);\n\n\t\tif (res.rt6)\n\t\t\treturn &res.rt6->dst;\n\t} else {\n\t\tstruct rt6_info *rt;\n\n\t\trt = lookup(net, net->ipv6.fib6_local_tbl, fl6, skb, flags);\n\t\tif (rt != net->ipv6.ip6_null_entry && rt->dst.error != -EAGAIN)\n\t\t\treturn &rt->dst;\n\t\tip6_rt_put(rt);\n\t\trt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\t\tif (rt->dst.error != -EAGAIN)\n\t\t\treturn &rt->dst;\n\t\tip6_rt_put(rt);\n\t}\n\n\tdst_hold(&net->ipv6.ip6_null_entry->dst);\n\treturn &net->ipv6.ip6_null_entry->dst;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,9 +3,11 @@\n \t\t\t\t   int flags, pol_lookup_t lookup)\n {\n \tif (net->ipv6.fib6_has_custom_rules) {\n+\t\tstruct fib6_result res = {};\n \t\tstruct fib_lookup_arg arg = {\n \t\t\t.lookup_ptr = lookup,\n \t\t\t.lookup_data = skb,\n+\t\t\t.result = &res,\n \t\t\t.flags = FIB_LOOKUP_NOREF,\n \t\t};\n \n@@ -15,8 +17,8 @@\n \t\tfib_rules_lookup(net->ipv6.fib6_rules_ops,\n \t\t\t\t flowi6_to_flowi(fl6), flags, &arg);\n \n-\t\tif (arg.result)\n-\t\t\treturn arg.result;\n+\t\tif (res.rt6)\n+\t\t\treturn &res.rt6->dst;\n \t} else {\n \t\tstruct rt6_info *rt;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (arg.result)",
                "\t\t\treturn arg.result;"
            ],
            "added_lines": [
                "\t\tstruct fib6_result res = {};",
                "\t\t\t.result = &res,",
                "\t\tif (res.rt6)",
                "\t\t\treturn &res.rt6->dst;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-3022",
        "func_name": "torvalds/linux/fib6_rule_suppress",
        "description": "A flaw was found in the IPv6 module of the Linux kernel. The arg.result was not used consistently in fib6_rule_lookup, sometimes holding rt6_info and other times fib6_info. This was not accounted for in other parts of the code where rt6_info was expected unconditionally, potentially leading to a kernel panic in fib6_rule_suppress.",
        "git_url": "https://github.com/torvalds/linux/commit/a65120bae4b7425a39c5783aa3d4fc29677eef0e",
        "commit_title": "ipv6: Use result arg in fib_lookup_arg consistently",
        "commit_text": " arg.result is sometimes used as fib6_result and sometimes used to hold the rt6_info. Add rt6_info to fib6_result and make the use of arg.result consistent through ipv6 rules.  The rt6 entry is filled in for lookups returning a dst_entry, but not for direct fib_lookups that just want a fib6_info. ",
        "func_before": "static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n{\n\tstruct rt6_info *rt = (struct rt6_info *) arg->result;\n\tstruct net_device *dev = NULL;\n\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\n\t/* do not accept result if the route does\n\t * not meet the required prefix length\n\t */\n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\n\t/* do not accept result if the route uses a device\n\t * belonging to a forbidden interface group\n\t */\n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\n\treturn false;\n\nsuppress_route:\n\tip6_rt_put(rt);\n\treturn true;\n}",
        "func": "static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct rt6_info *rt = res->rt6;\n\tstruct net_device *dev = NULL;\n\n\tif (!rt)\n\t\treturn false;\n\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\n\t/* do not accept result if the route does\n\t * not meet the required prefix length\n\t */\n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\n\t/* do not accept result if the route uses a device\n\t * belonging to a forbidden interface group\n\t */\n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\n\treturn false;\n\nsuppress_route:\n\tip6_rt_put(rt);\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,11 @@\n static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n {\n-\tstruct rt6_info *rt = (struct rt6_info *) arg->result;\n+\tstruct fib6_result *res = arg->result;\n+\tstruct rt6_info *rt = res->rt6;\n \tstruct net_device *dev = NULL;\n+\n+\tif (!rt)\n+\t\treturn false;\n \n \tif (rt->rt6i_idev)\n \t\tdev = rt->rt6i_idev->dev;",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct rt6_info *rt = (struct rt6_info *) arg->result;"
            ],
            "added_lines": [
                "\tstruct fib6_result *res = arg->result;",
                "\tstruct rt6_info *rt = res->rt6;",
                "",
                "\tif (!rt)",
                "\t\treturn false;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-13220",
        "func_name": "torvalds/linux/hidp_connection_add",
        "description": "An elevation of privilege vulnerability in the Upstream kernel bluez. Product: Android. Versions: Android kernel. Android ID: A-63527053.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=51bda2bca53b265715ca1852528f38dc67429d9a",
        "commit_title": "it's OK after we'd verified the sockets, but not before that.",
        "commit_text": " ",
        "func_before": "int hidp_connection_add(struct hidp_connadd_req *req,\n\t\t\tstruct socket *ctrl_sock,\n\t\t\tstruct socket *intr_sock)\n{\n\tstruct hidp_session *session;\n\tstruct l2cap_conn *conn;\n\tstruct l2cap_chan *chan = l2cap_pi(ctrl_sock->sk)->chan;\n\tint ret;\n\n\tret = hidp_verify_sockets(ctrl_sock, intr_sock);\n\tif (ret)\n\t\treturn ret;\n\n\tconn = NULL;\n\tl2cap_chan_lock(chan);\n\tif (chan->conn)\n\t\tconn = l2cap_conn_get(chan->conn);\n\tl2cap_chan_unlock(chan);\n\n\tif (!conn)\n\t\treturn -EBADFD;\n\n\tret = hidp_session_new(&session, &chan->dst, ctrl_sock,\n\t\t\t       intr_sock, req, conn);\n\tif (ret)\n\t\tgoto out_conn;\n\n\tret = l2cap_register_user(conn, &session->user);\n\tif (ret)\n\t\tgoto out_session;\n\n\tret = 0;\n\nout_session:\n\thidp_session_put(session);\nout_conn:\n\tl2cap_conn_put(conn);\n\treturn ret;\n}",
        "func": "int hidp_connection_add(struct hidp_connadd_req *req,\n\t\t\tstruct socket *ctrl_sock,\n\t\t\tstruct socket *intr_sock)\n{\n\tstruct hidp_session *session;\n\tstruct l2cap_conn *conn;\n\tstruct l2cap_chan *chan;\n\tint ret;\n\n\tret = hidp_verify_sockets(ctrl_sock, intr_sock);\n\tif (ret)\n\t\treturn ret;\n\n\tchan = l2cap_pi(ctrl_sock->sk)->chan;\n\tconn = NULL;\n\tl2cap_chan_lock(chan);\n\tif (chan->conn)\n\t\tconn = l2cap_conn_get(chan->conn);\n\tl2cap_chan_unlock(chan);\n\n\tif (!conn)\n\t\treturn -EBADFD;\n\n\tret = hidp_session_new(&session, &chan->dst, ctrl_sock,\n\t\t\t       intr_sock, req, conn);\n\tif (ret)\n\t\tgoto out_conn;\n\n\tret = l2cap_register_user(conn, &session->user);\n\tif (ret)\n\t\tgoto out_session;\n\n\tret = 0;\n\nout_session:\n\thidp_session_put(session);\nout_conn:\n\tl2cap_conn_put(conn);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,13 +4,14 @@\n {\n \tstruct hidp_session *session;\n \tstruct l2cap_conn *conn;\n-\tstruct l2cap_chan *chan = l2cap_pi(ctrl_sock->sk)->chan;\n+\tstruct l2cap_chan *chan;\n \tint ret;\n \n \tret = hidp_verify_sockets(ctrl_sock, intr_sock);\n \tif (ret)\n \t\treturn ret;\n \n+\tchan = l2cap_pi(ctrl_sock->sk)->chan;\n \tconn = NULL;\n \tl2cap_chan_lock(chan);\n \tif (chan->conn)",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct l2cap_chan *chan = l2cap_pi(ctrl_sock->sk)->chan;"
            ],
            "added_lines": [
                "\tstruct l2cap_chan *chan;",
                "\tchan = l2cap_pi(ctrl_sock->sk)->chan;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-23454",
        "func_name": "torvalds/linux/cbq_classify",
        "description": "cbq_classify in net/sched/sch_cbq.c in the Linux kernel through 6.1.4 allows attackers to cause a denial of service (slab-out-of-bounds read) because of type confusion (non-negative numbers can sometimes indicate a TC_ACT_SHOT condition rather than valid classification results).",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=caa4b35b4317d5147b3ab0fbdc9c075c7d2e9c12",
        "commit_title": "If asked to drop a packet via TC_ACT_SHOT it is unsafe to assume that",
        "commit_text": "res.class contains a valid pointer  Sample splat reported by Kyle Zeng  [    5.405624] 0: reclassify loop, rule prio 0, protocol 800 [    5.406326] ================================================================== [    5.407240] BUG: KASAN: slab-out-of-bounds in cbq_enqueue+0x54b/0xea0 [    5.407987] Read of size 1 at addr ffff88800e3122aa by task poc/299 [    5.408731] [    5.408897] CPU: 0 PID: 299 Comm: poc Not tainted 5.10.155+ #15 [    5.409516] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014 [    5.410439] Call Trace: [    5.410764]  dump_stack+0x87/0xcd [    5.411153]  print_address_description+0x7a/0x6b0 [    5.411687]  ? vprintk_func+0xb9/0xc0 [    5.411905]  ? printk+0x76/0x96 [    5.412110]  ? cbq_enqueue+0x54b/0xea0 [    5.412323]  kasan_report+0x17d/0x220 [    5.412591]  ? cbq_enqueue+0x54b/0xea0 [    5.412803]  __asan_report_load1_noabort+0x10/0x20 [    5.413119]  cbq_enqueue+0x54b/0xea0 [    5.413400]  ? __kasan_check_write+0x10/0x20 [    5.413679]  __dev_queue_xmit+0x9c0/0x1db0 [    5.413922]  dev_queue_xmit+0xc/0x10 [    5.414136]  ip_finish_output2+0x8bc/0xcd0 [    5.414436]  __ip_finish_output+0x472/0x7a0 [    5.414692]  ip_finish_output+0x5c/0x190 [    5.414940]  ip_output+0x2d8/0x3c0 [    5.415150]  ? ip_mc_finish_output+0x320/0x320 [    5.415429]  __ip_queue_xmit+0x753/0x1760 [    5.415664]  ip_queue_xmit+0x47/0x60 [    5.415874]  __tcp_transmit_skb+0x1ef9/0x34c0 [    5.416129]  tcp_connect+0x1f5e/0x4cb0 [    5.416347]  tcp_v4_connect+0xc8d/0x18c0 [    5.416577]  __inet_stream_connect+0x1ae/0xb40 [    5.416836]  ? local_bh_enable+0x11/0x20 [    5.417066]  ? lock_sock_nested+0x175/0x1d0 [    5.417309]  inet_stream_connect+0x5d/0x90 [    5.417548]  ? __inet_stream_connect+0xb40/0xb40 [    5.417817]  __sys_connect+0x260/0x2b0 [    5.418037]  __x64_sys_connect+0x76/0x80 [    5.418267]  do_syscall_64+0x31/0x50 [    5.418477]  entry_SYSCALL_64_after_hwframe+0x61/0xc6 [    5.418770] RIP: 0033:0x473bb7 [    5.418952] Code: 64 89 01 48 83 c8 ff c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 64 8b 04 25 18 00 00 00 85 c0 75 10 b8 2a 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 51 c3 48 83 ec 18 89 54 24 0c 48 89 34 24 89 [    5.420046] RSP: 002b:00007fffd20eb0f8 EFLAGS: 00000246 ORIG_RAX: 000000000000002a [    5.420472] RAX: ffffffffffffffda RBX: 00007fffd20eb578 RCX: 0000000000473bb7 [    5.420872] RDX: 0000000000000010 RSI: 00007fffd20eb110 RDI: 0000000000000007 [    5.421271] RBP: 00007fffd20eb150 R08: 0000000000000001 R09: 0000000000000004 [    5.421671] R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000001 [    5.422071] R13: 00007fffd20eb568 R14: 00000000004fc740 R15: 0000000000000002 [    5.422471] [    5.422562] Allocated by task 299: [    5.422782]  __kasan_kmalloc+0x12d/0x160 [    5.423007]  kasan_kmalloc+0x5/0x10 [    5.423208]  kmem_cache_alloc_trace+0x201/0x2e0 [    5.423492]  tcf_proto_create+0x65/0x290 [    5.423721]  tc_new_tfilter+0x137e/0x1830 [    5.423957]  rtnetlink_rcv_msg+0x730/0x9f0 [    5.424197]  netlink_rcv_skb+0x166/0x300 [    5.424428]  rtnetlink_rcv+0x11/0x20 [    5.424639]  netlink_unicast+0x673/0x860 [    5.424870]  netlink_sendmsg+0x6af/0x9f0 [    5.425100]  __sys_sendto+0x58d/0x5a0 [    5.425315]  __x64_sys_sendto+0xda/0xf0 [    5.425539]  do_syscall_64+0x31/0x50 [    5.425764]  entry_SYSCALL_64_after_hwframe+0x61/0xc6 [    5.426065] [    5.426157] The buggy address belongs to the object at ffff88800e312200 [    5.426157]  which belongs to the cache kmalloc-128 of size 128 [    5.426955] The buggy address is located 42 bytes to the right of [    5.426955]  128-byte region [ffff88800e312200, ffff88800e312280) [    5.427688] The buggy address belongs to the page: [    5.427992] page:000000009875fabc refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0xe312 [    5.428562] flags: 0x100000000000200(slab) [    5.428812] raw: 0100000000000200 dead000000000100 dead000000000122 ffff888007843680 [    5.429325] raw: 0000000000000000 0000000000100010 00000001ffffffff ffff88800e312401 [    5.429875] page dumped because: kasan: bad access detected [    5.430214] page->mem_cgroup:ffff88800e312401 [    5.430471] [    5.430564] Memory state around the buggy address: [    5.430846]  ffff88800e312180: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc [    5.431267]  ffff88800e312200: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 fc [    5.431705] >ffff88800e312280: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc [    5.432123]                                   ^ [    5.432391]  ffff88800e312300: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 fc [    5.432810]  ffff88800e312380: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc [    5.433229] ================================================================== [    5.433648] Disabling lock debugging due to kernel taint  ",
        "func_before": "static struct cbq_class *\ncbq_classify(struct sk_buff *skb, struct Qdisc *sch, int *qerr)\n{\n\tstruct cbq_sched_data *q = qdisc_priv(sch);\n\tstruct cbq_class *head = &q->link;\n\tstruct cbq_class **defmap;\n\tstruct cbq_class *cl = NULL;\n\tu32 prio = skb->priority;\n\tstruct tcf_proto *fl;\n\tstruct tcf_result res;\n\n\t/*\n\t *  Step 1. If skb->priority points to one of our classes, use it.\n\t */\n\tif (TC_H_MAJ(prio ^ sch->handle) == 0 &&\n\t    (cl = cbq_class_lookup(q, prio)) != NULL)\n\t\treturn cl;\n\n\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n\tfor (;;) {\n\t\tint result = 0;\n\t\tdefmap = head->defaults;\n\n\t\tfl = rcu_dereference_bh(head->filter_list);\n\t\t/*\n\t\t * Step 2+n. Apply classifier.\n\t\t */\n\t\tresult = tcf_classify(skb, NULL, fl, &res, true);\n\t\tif (!fl || result < 0)\n\t\t\tgoto fallback;\n\n\t\tcl = (void *)res.class;\n\t\tif (!cl) {\n\t\t\tif (TC_H_MAJ(res.classid))\n\t\t\t\tcl = cbq_class_lookup(q, res.classid);\n\t\t\telse if ((cl = defmap[res.classid & TC_PRIO_MAX]) == NULL)\n\t\t\t\tcl = defmap[TC_PRIO_BESTEFFORT];\n\n\t\t\tif (cl == NULL)\n\t\t\t\tgoto fallback;\n\t\t}\n\t\tif (cl->level >= head->level)\n\t\t\tgoto fallback;\n#ifdef CONFIG_NET_CLS_ACT\n\t\tswitch (result) {\n\t\tcase TC_ACT_QUEUED:\n\t\tcase TC_ACT_STOLEN:\n\t\tcase TC_ACT_TRAP:\n\t\t\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;\n\t\t\tfallthrough;\n\t\tcase TC_ACT_SHOT:\n\t\t\treturn NULL;\n\t\tcase TC_ACT_RECLASSIFY:\n\t\t\treturn cbq_reclassify(skb, cl);\n\t\t}\n#endif\n\t\tif (cl->level == 0)\n\t\t\treturn cl;\n\n\t\t/*\n\t\t * Step 3+n. If classifier selected a link sharing class,\n\t\t *\t   apply agency specific classifier.\n\t\t *\t   Repeat this procedure until we hit a leaf node.\n\t\t */\n\t\thead = cl;\n\t}\n\nfallback:\n\tcl = head;\n\n\t/*\n\t * Step 4. No success...\n\t */\n\tif (TC_H_MAJ(prio) == 0 &&\n\t    !(cl = head->defaults[prio & TC_PRIO_MAX]) &&\n\t    !(cl = head->defaults[TC_PRIO_BESTEFFORT]))\n\t\treturn head;\n\n\treturn cl;\n}",
        "func": "static struct cbq_class *\ncbq_classify(struct sk_buff *skb, struct Qdisc *sch, int *qerr)\n{\n\tstruct cbq_sched_data *q = qdisc_priv(sch);\n\tstruct cbq_class *head = &q->link;\n\tstruct cbq_class **defmap;\n\tstruct cbq_class *cl = NULL;\n\tu32 prio = skb->priority;\n\tstruct tcf_proto *fl;\n\tstruct tcf_result res;\n\n\t/*\n\t *  Step 1. If skb->priority points to one of our classes, use it.\n\t */\n\tif (TC_H_MAJ(prio ^ sch->handle) == 0 &&\n\t    (cl = cbq_class_lookup(q, prio)) != NULL)\n\t\treturn cl;\n\n\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n\tfor (;;) {\n\t\tint result = 0;\n\t\tdefmap = head->defaults;\n\n\t\tfl = rcu_dereference_bh(head->filter_list);\n\t\t/*\n\t\t * Step 2+n. Apply classifier.\n\t\t */\n\t\tresult = tcf_classify(skb, NULL, fl, &res, true);\n\t\tif (!fl || result < 0)\n\t\t\tgoto fallback;\n\t\tif (result == TC_ACT_SHOT)\n\t\t\treturn NULL;\n\n\t\tcl = (void *)res.class;\n\t\tif (!cl) {\n\t\t\tif (TC_H_MAJ(res.classid))\n\t\t\t\tcl = cbq_class_lookup(q, res.classid);\n\t\t\telse if ((cl = defmap[res.classid & TC_PRIO_MAX]) == NULL)\n\t\t\t\tcl = defmap[TC_PRIO_BESTEFFORT];\n\n\t\t\tif (cl == NULL)\n\t\t\t\tgoto fallback;\n\t\t}\n\t\tif (cl->level >= head->level)\n\t\t\tgoto fallback;\n#ifdef CONFIG_NET_CLS_ACT\n\t\tswitch (result) {\n\t\tcase TC_ACT_QUEUED:\n\t\tcase TC_ACT_STOLEN:\n\t\tcase TC_ACT_TRAP:\n\t\t\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;\n\t\t\tfallthrough;\n\t\tcase TC_ACT_RECLASSIFY:\n\t\t\treturn cbq_reclassify(skb, cl);\n\t\t}\n#endif\n\t\tif (cl->level == 0)\n\t\t\treturn cl;\n\n\t\t/*\n\t\t * Step 3+n. If classifier selected a link sharing class,\n\t\t *\t   apply agency specific classifier.\n\t\t *\t   Repeat this procedure until we hit a leaf node.\n\t\t */\n\t\thead = cl;\n\t}\n\nfallback:\n\tcl = head;\n\n\t/*\n\t * Step 4. No success...\n\t */\n\tif (TC_H_MAJ(prio) == 0 &&\n\t    !(cl = head->defaults[prio & TC_PRIO_MAX]) &&\n\t    !(cl = head->defaults[TC_PRIO_BESTEFFORT]))\n\t\treturn head;\n\n\treturn cl;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,6 +28,8 @@\n \t\tresult = tcf_classify(skb, NULL, fl, &res, true);\n \t\tif (!fl || result < 0)\n \t\t\tgoto fallback;\n+\t\tif (result == TC_ACT_SHOT)\n+\t\t\treturn NULL;\n \n \t\tcl = (void *)res.class;\n \t\tif (!cl) {\n@@ -48,8 +50,6 @@\n \t\tcase TC_ACT_TRAP:\n \t\t\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;\n \t\t\tfallthrough;\n-\t\tcase TC_ACT_SHOT:\n-\t\t\treturn NULL;\n \t\tcase TC_ACT_RECLASSIFY:\n \t\t\treturn cbq_reclassify(skb, cl);\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tcase TC_ACT_SHOT:",
                "\t\t\treturn NULL;"
            ],
            "added_lines": [
                "\t\tif (result == TC_ACT_SHOT)",
                "\t\t\treturn NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-23455",
        "func_name": "torvalds/linux/atm_tc_enqueue",
        "description": "atm_tc_enqueue in net/sched/sch_atm.c in the Linux kernel through 6.1.4 allows attackers to cause a denial of service because of type confusion (non-negative numbers can sometimes indicate a TC_ACT_SHOT condition rather than valid classification results).",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=a2965c7be0522eaa18808684b7b82b248515511b",
        "commit_title": "If asked to drop a packet via TC_ACT_SHOT it is unsafe to assume",
        "commit_text": "res.class contains a valid pointer  ",
        "func_before": "static int atm_tc_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t\t  struct sk_buff **to_free)\n{\n\tstruct atm_qdisc_data *p = qdisc_priv(sch);\n\tstruct atm_flow_data *flow;\n\tstruct tcf_result res;\n\tint result;\n\tint ret = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n\n\tpr_debug(\"atm_tc_enqueue(skb %p,sch %p,[qdisc %p])\\n\", skb, sch, p);\n\tresult = TC_ACT_OK;\t/* be nice to gcc */\n\tflow = NULL;\n\tif (TC_H_MAJ(skb->priority) != sch->handle ||\n\t    !(flow = (struct atm_flow_data *)atm_tc_find(sch, skb->priority))) {\n\t\tstruct tcf_proto *fl;\n\n\t\tlist_for_each_entry(flow, &p->flows, list) {\n\t\t\tfl = rcu_dereference_bh(flow->filter_list);\n\t\t\tif (fl) {\n\t\t\t\tresult = tcf_classify(skb, NULL, fl, &res, true);\n\t\t\t\tif (result < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tflow = (struct atm_flow_data *)res.class;\n\t\t\t\tif (!flow)\n\t\t\t\t\tflow = lookup_flow(sch, res.classid);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tflow = NULL;\ndone:\n\t\t;\n\t}\n\tif (!flow) {\n\t\tflow = &p->link;\n\t} else {\n\t\tif (flow->vcc)\n\t\t\tATM_SKB(skb)->atm_options = flow->vcc->atm_options;\n\t\t/*@@@ looks good ... but it's not supposed to work :-) */\n#ifdef CONFIG_NET_CLS_ACT\n\t\tswitch (result) {\n\t\tcase TC_ACT_QUEUED:\n\t\tcase TC_ACT_STOLEN:\n\t\tcase TC_ACT_TRAP:\n\t\t\t__qdisc_drop(skb, to_free);\n\t\t\treturn NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;\n\t\tcase TC_ACT_SHOT:\n\t\t\t__qdisc_drop(skb, to_free);\n\t\t\tgoto drop;\n\t\tcase TC_ACT_RECLASSIFY:\n\t\t\tif (flow->excess)\n\t\t\t\tflow = flow->excess;\n\t\t\telse\n\t\t\t\tATM_SKB(skb)->atm_options |= ATM_ATMOPT_CLP;\n\t\t\tbreak;\n\t\t}\n#endif\n\t}\n\n\tret = qdisc_enqueue(skb, flow->q, to_free);\n\tif (ret != NET_XMIT_SUCCESS) {\ndrop: __maybe_unused\n\t\tif (net_xmit_drop_count(ret)) {\n\t\t\tqdisc_qstats_drop(sch);\n\t\t\tif (flow)\n\t\t\t\tflow->qstats.drops++;\n\t\t}\n\t\treturn ret;\n\t}\n\t/*\n\t * Okay, this may seem weird. We pretend we've dropped the packet if\n\t * it goes via ATM. The reason for this is that the outer qdisc\n\t * expects to be able to q->dequeue the packet later on if we return\n\t * success at this place. Also, sch->q.qdisc needs to reflect whether\n\t * there is a packet egligible for dequeuing or not. Note that the\n\t * statistics of the outer qdisc are necessarily wrong because of all\n\t * this. There's currently no correct solution for this.\n\t */\n\tif (flow == &p->link) {\n\t\tsch->q.qlen++;\n\t\treturn NET_XMIT_SUCCESS;\n\t}\n\ttasklet_schedule(&p->task);\n\treturn NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n}",
        "func": "static int atm_tc_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t\t  struct sk_buff **to_free)\n{\n\tstruct atm_qdisc_data *p = qdisc_priv(sch);\n\tstruct atm_flow_data *flow;\n\tstruct tcf_result res;\n\tint result;\n\tint ret = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n\n\tpr_debug(\"atm_tc_enqueue(skb %p,sch %p,[qdisc %p])\\n\", skb, sch, p);\n\tresult = TC_ACT_OK;\t/* be nice to gcc */\n\tflow = NULL;\n\tif (TC_H_MAJ(skb->priority) != sch->handle ||\n\t    !(flow = (struct atm_flow_data *)atm_tc_find(sch, skb->priority))) {\n\t\tstruct tcf_proto *fl;\n\n\t\tlist_for_each_entry(flow, &p->flows, list) {\n\t\t\tfl = rcu_dereference_bh(flow->filter_list);\n\t\t\tif (fl) {\n\t\t\t\tresult = tcf_classify(skb, NULL, fl, &res, true);\n\t\t\t\tif (result < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (result == TC_ACT_SHOT)\n\t\t\t\t\tgoto done;\n\n\t\t\t\tflow = (struct atm_flow_data *)res.class;\n\t\t\t\tif (!flow)\n\t\t\t\t\tflow = lookup_flow(sch, res.classid);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\t\tflow = NULL;\ndone:\n\t\t;\n\t}\n\tif (!flow) {\n\t\tflow = &p->link;\n\t} else {\n\t\tif (flow->vcc)\n\t\t\tATM_SKB(skb)->atm_options = flow->vcc->atm_options;\n\t\t/*@@@ looks good ... but it's not supposed to work :-) */\n#ifdef CONFIG_NET_CLS_ACT\n\t\tswitch (result) {\n\t\tcase TC_ACT_QUEUED:\n\t\tcase TC_ACT_STOLEN:\n\t\tcase TC_ACT_TRAP:\n\t\t\t__qdisc_drop(skb, to_free);\n\t\t\treturn NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;\n\t\tcase TC_ACT_SHOT:\n\t\t\t__qdisc_drop(skb, to_free);\n\t\t\tgoto drop;\n\t\tcase TC_ACT_RECLASSIFY:\n\t\t\tif (flow->excess)\n\t\t\t\tflow = flow->excess;\n\t\t\telse\n\t\t\t\tATM_SKB(skb)->atm_options |= ATM_ATMOPT_CLP;\n\t\t\tbreak;\n\t\t}\n#endif\n\t}\n\n\tret = qdisc_enqueue(skb, flow->q, to_free);\n\tif (ret != NET_XMIT_SUCCESS) {\ndrop: __maybe_unused\n\t\tif (net_xmit_drop_count(ret)) {\n\t\t\tqdisc_qstats_drop(sch);\n\t\t\tif (flow)\n\t\t\t\tflow->qstats.drops++;\n\t\t}\n\t\treturn ret;\n\t}\n\t/*\n\t * Okay, this may seem weird. We pretend we've dropped the packet if\n\t * it goes via ATM. The reason for this is that the outer qdisc\n\t * expects to be able to q->dequeue the packet later on if we return\n\t * success at this place. Also, sch->q.qdisc needs to reflect whether\n\t * there is a packet egligible for dequeuing or not. Note that the\n\t * statistics of the outer qdisc are necessarily wrong because of all\n\t * this. There's currently no correct solution for this.\n\t */\n\tif (flow == &p->link) {\n\t\tsch->q.qlen++;\n\t\treturn NET_XMIT_SUCCESS;\n\t}\n\ttasklet_schedule(&p->task);\n\treturn NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,10 +20,13 @@\n \t\t\t\tresult = tcf_classify(skb, NULL, fl, &res, true);\n \t\t\t\tif (result < 0)\n \t\t\t\t\tcontinue;\n+\t\t\t\tif (result == TC_ACT_SHOT)\n+\t\t\t\t\tgoto done;\n+\n \t\t\t\tflow = (struct atm_flow_data *)res.class;\n \t\t\t\tif (!flow)\n \t\t\t\t\tflow = lookup_flow(sch, res.classid);\n-\t\t\t\tgoto done;\n+\t\t\t\tgoto drop;\n \t\t\t}\n \t\t}\n \t\tflow = NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\tgoto done;"
            ],
            "added_lines": [
                "\t\t\t\tif (result == TC_ACT_SHOT)",
                "\t\t\t\t\tgoto done;",
                "",
                "\t\t\t\tgoto drop;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0286",
        "func_name": "openssl/GENERAL_NAME_cmp",
        "description": "There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.\n\n",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=2f7530077e0ef79d98718138716bc51ca0cad658",
        "commit_title": "",
        "commit_text": "CVE-2023-0286: Fix GENERAL_NAME_cmp for x400Address (3.0)  ",
        "func_before": "int GENERAL_NAME_cmp(GENERAL_NAME *a, GENERAL_NAME *b)\n{\n    int result = -1;\n\n    if (!a || !b || a->type != b->type)\n        return -1;\n    switch (a->type) {\n    case GEN_X400:\n        result = ASN1_TYPE_cmp(a->d.x400Address, b->d.x400Address);\n        break;\n\n    case GEN_EDIPARTY:\n        result = edipartyname_cmp(a->d.ediPartyName, b->d.ediPartyName);\n        break;\n\n    case GEN_OTHERNAME:\n        result = OTHERNAME_cmp(a->d.otherName, b->d.otherName);\n        break;\n\n    case GEN_EMAIL:\n    case GEN_DNS:\n    case GEN_URI:\n        result = ASN1_STRING_cmp(a->d.ia5, b->d.ia5);\n        break;\n\n    case GEN_DIRNAME:\n        result = X509_NAME_cmp(a->d.dirn, b->d.dirn);\n        break;\n\n    case GEN_IPADD:\n        result = ASN1_OCTET_STRING_cmp(a->d.ip, b->d.ip);\n        break;\n\n    case GEN_RID:\n        result = OBJ_cmp(a->d.rid, b->d.rid);\n        break;\n    }\n    return result;\n}",
        "func": "int GENERAL_NAME_cmp(GENERAL_NAME *a, GENERAL_NAME *b)\n{\n    int result = -1;\n\n    if (!a || !b || a->type != b->type)\n        return -1;\n    switch (a->type) {\n    case GEN_X400:\n        result = ASN1_STRING_cmp(a->d.x400Address, b->d.x400Address);\n        break;\n\n    case GEN_EDIPARTY:\n        result = edipartyname_cmp(a->d.ediPartyName, b->d.ediPartyName);\n        break;\n\n    case GEN_OTHERNAME:\n        result = OTHERNAME_cmp(a->d.otherName, b->d.otherName);\n        break;\n\n    case GEN_EMAIL:\n    case GEN_DNS:\n    case GEN_URI:\n        result = ASN1_STRING_cmp(a->d.ia5, b->d.ia5);\n        break;\n\n    case GEN_DIRNAME:\n        result = X509_NAME_cmp(a->d.dirn, b->d.dirn);\n        break;\n\n    case GEN_IPADD:\n        result = ASN1_OCTET_STRING_cmp(a->d.ip, b->d.ip);\n        break;\n\n    case GEN_RID:\n        result = OBJ_cmp(a->d.rid, b->d.rid);\n        break;\n    }\n    return result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n         return -1;\n     switch (a->type) {\n     case GEN_X400:\n-        result = ASN1_TYPE_cmp(a->d.x400Address, b->d.x400Address);\n+        result = ASN1_STRING_cmp(a->d.x400Address, b->d.x400Address);\n         break;\n \n     case GEN_EDIPARTY:",
        "diff_line_info": {
            "deleted_lines": [
                "        result = ASN1_TYPE_cmp(a->d.x400Address, b->d.x400Address);"
            ],
            "added_lines": [
                "        result = ASN1_STRING_cmp(a->d.x400Address, b->d.x400Address);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0286",
        "func_name": "openssl/GENERAL_NAME_cmp",
        "description": "There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.\n\n",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=2c6c9d439b484e1ba9830d8454a34fa4f80fdfe9",
        "commit_title": "",
        "commit_text": "CVE-2023-0286: Fix GENERAL_NAME_cmp for x400Address (1.1.1)  ",
        "func_before": "int GENERAL_NAME_cmp(GENERAL_NAME *a, GENERAL_NAME *b)\n{\n    int result = -1;\n\n    if (!a || !b || a->type != b->type)\n        return -1;\n    switch (a->type) {\n    case GEN_X400:\n        result = ASN1_TYPE_cmp(a->d.x400Address, b->d.x400Address);\n        break;\n\n    case GEN_EDIPARTY:\n        result = edipartyname_cmp(a->d.ediPartyName, b->d.ediPartyName);\n        break;\n\n    case GEN_OTHERNAME:\n        result = OTHERNAME_cmp(a->d.otherName, b->d.otherName);\n        break;\n\n    case GEN_EMAIL:\n    case GEN_DNS:\n    case GEN_URI:\n        result = ASN1_STRING_cmp(a->d.ia5, b->d.ia5);\n        break;\n\n    case GEN_DIRNAME:\n        result = X509_NAME_cmp(a->d.dirn, b->d.dirn);\n        break;\n\n    case GEN_IPADD:\n        result = ASN1_OCTET_STRING_cmp(a->d.ip, b->d.ip);\n        break;\n\n    case GEN_RID:\n        result = OBJ_cmp(a->d.rid, b->d.rid);\n        break;\n    }\n    return result;\n}",
        "func": "int GENERAL_NAME_cmp(GENERAL_NAME *a, GENERAL_NAME *b)\n{\n    int result = -1;\n\n    if (!a || !b || a->type != b->type)\n        return -1;\n    switch (a->type) {\n    case GEN_X400:\n        result = ASN1_STRING_cmp(a->d.x400Address, b->d.x400Address);\n        break;\n\n    case GEN_EDIPARTY:\n        result = edipartyname_cmp(a->d.ediPartyName, b->d.ediPartyName);\n        break;\n\n    case GEN_OTHERNAME:\n        result = OTHERNAME_cmp(a->d.otherName, b->d.otherName);\n        break;\n\n    case GEN_EMAIL:\n    case GEN_DNS:\n    case GEN_URI:\n        result = ASN1_STRING_cmp(a->d.ia5, b->d.ia5);\n        break;\n\n    case GEN_DIRNAME:\n        result = X509_NAME_cmp(a->d.dirn, b->d.dirn);\n        break;\n\n    case GEN_IPADD:\n        result = ASN1_OCTET_STRING_cmp(a->d.ip, b->d.ip);\n        break;\n\n    case GEN_RID:\n        result = OBJ_cmp(a->d.rid, b->d.rid);\n        break;\n    }\n    return result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n         return -1;\n     switch (a->type) {\n     case GEN_X400:\n-        result = ASN1_TYPE_cmp(a->d.x400Address, b->d.x400Address);\n+        result = ASN1_STRING_cmp(a->d.x400Address, b->d.x400Address);\n         break;\n \n     case GEN_EDIPARTY:",
        "diff_line_info": {
            "deleted_lines": [
                "        result = ASN1_TYPE_cmp(a->d.x400Address, b->d.x400Address);"
            ],
            "added_lines": [
                "        result = ASN1_STRING_cmp(a->d.x400Address, b->d.x400Address);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-21656",
        "func_name": "envoyproxy/envoy/SPIFFEValidator::matchSubjectAltName",
        "description": "Envoy is an open source edge and service proxy, designed for cloud-native applications. The default_validator.cc implementation used to implement the default certificate validation routines has a \"type confusion\" bug when processing subjectAltNames. This processing allows, for example, an rfc822Name or uniformResourceIndicator to be authenticated as a domain name. This confusion allows for the bypassing of nameConstraints, as processed by the underlying OpenSSL/BoringSSL implementation, exposing the possibility of impersonation of arbitrary servers. As a result Envoy will trust upstream certificates that should not be trusted.",
        "git_url": "https://github.com/envoyproxy/envoy/commit/bb95af848c939cfe5b5ee33c5b1770558077e64e",
        "commit_title": "Specify type for matching Subject Alternative Name. (#18628)",
        "commit_text": " \r",
        "func_before": "bool SPIFFEValidator::matchSubjectAltName(X509& leaf_cert) {\n  bssl::UniquePtr<GENERAL_NAMES> san_names(static_cast<GENERAL_NAMES*>(\n      X509_get_ext_d2i(&leaf_cert, NID_subject_alt_name, nullptr, nullptr)));\n  // We must not have san_names == nullptr here because this function is called after the\n  // SPIFFE cert validation algorithm succeeded, which requires exactly one URI SAN in the leaf\n  // cert.\n  ASSERT(san_names != nullptr,\n         \"san_names should have at least one name after SPIFFE cert validation\");\n\n  // Only match against URI SAN since SPIFFE specification does not restrict values in other SAN\n  // types. See the discussion: https://github.com/envoyproxy/envoy/issues/15392\n  for (const GENERAL_NAME* general_name : san_names.get()) {\n    if (general_name->type == GEN_URI) {\n      const std::string san = Utility::generalNameAsString(general_name);\n      for (const auto& config_san_matcher : subject_alt_name_matchers_) {\n        if (config_san_matcher.match(san)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}",
        "func": "bool SPIFFEValidator::matchSubjectAltName(X509& leaf_cert) {\n  bssl::UniquePtr<GENERAL_NAMES> san_names(static_cast<GENERAL_NAMES*>(\n      X509_get_ext_d2i(&leaf_cert, NID_subject_alt_name, nullptr, nullptr)));\n  // We must not have san_names == nullptr here because this function is called after the\n  // SPIFFE cert validation algorithm succeeded, which requires exactly one URI SAN in the leaf\n  // cert.\n  ASSERT(san_names != nullptr,\n         \"san_names should have at least one name after SPIFFE cert validation\");\n\n  for (const GENERAL_NAME* general_name : san_names.get()) {\n    for (const auto& config_san_matcher : subject_alt_name_matchers_) {\n      if (config_san_matcher->match(general_name)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,15 +7,10 @@\n   ASSERT(san_names != nullptr,\n          \"san_names should have at least one name after SPIFFE cert validation\");\n \n-  // Only match against URI SAN since SPIFFE specification does not restrict values in other SAN\n-  // types. See the discussion: https://github.com/envoyproxy/envoy/issues/15392\n   for (const GENERAL_NAME* general_name : san_names.get()) {\n-    if (general_name->type == GEN_URI) {\n-      const std::string san = Utility::generalNameAsString(general_name);\n-      for (const auto& config_san_matcher : subject_alt_name_matchers_) {\n-        if (config_san_matcher.match(san)) {\n-          return true;\n-        }\n+    for (const auto& config_san_matcher : subject_alt_name_matchers_) {\n+      if (config_san_matcher->match(general_name)) {\n+        return true;\n       }\n     }\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "  // Only match against URI SAN since SPIFFE specification does not restrict values in other SAN",
                "  // types. See the discussion: https://github.com/envoyproxy/envoy/issues/15392",
                "    if (general_name->type == GEN_URI) {",
                "      const std::string san = Utility::generalNameAsString(general_name);",
                "      for (const auto& config_san_matcher : subject_alt_name_matchers_) {",
                "        if (config_san_matcher.match(san)) {",
                "          return true;",
                "        }"
            ],
            "added_lines": [
                "    for (const auto& config_san_matcher : subject_alt_name_matchers_) {",
                "      if (config_san_matcher->match(general_name)) {",
                "        return true;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-21656",
        "func_name": "envoyproxy/envoy/SPIFFEValidator::SPIFFEValidator",
        "description": "Envoy is an open source edge and service proxy, designed for cloud-native applications. The default_validator.cc implementation used to implement the default certificate validation routines has a \"type confusion\" bug when processing subjectAltNames. This processing allows, for example, an rfc822Name or uniformResourceIndicator to be authenticated as a domain name. This confusion allows for the bypassing of nameConstraints, as processed by the underlying OpenSSL/BoringSSL implementation, exposing the possibility of impersonation of arbitrary servers. As a result Envoy will trust upstream certificates that should not be trusted.",
        "git_url": "https://github.com/envoyproxy/envoy/commit/bb95af848c939cfe5b5ee33c5b1770558077e64e",
        "commit_title": "Specify type for matching Subject Alternative Name. (#18628)",
        "commit_text": " \r",
        "func_before": "SPIFFEValidator::SPIFFEValidator(const Envoy::Ssl::CertificateValidationContextConfig* config,\n                                 SslStats& stats, TimeSource& time_source)\n    : stats_(stats), time_source_(time_source) {\n  ASSERT(config != nullptr);\n  allow_expired_certificate_ = config->allowExpiredCertificate();\n\n  SPIFFEConfig message;\n  Config::Utility::translateOpaqueConfig(config->customValidatorConfig().value().typed_config(),\n                                         ProtobufMessage::getStrictValidationVisitor(), message);\n\n  if (!config->subjectAltNameMatchers().empty()) {\n    for (const auto& matcher : config->subjectAltNameMatchers()) {\n      subject_alt_name_matchers_.push_back(Matchers::StringMatcherImpl(matcher));\n    }\n  }\n\n  const auto size = message.trust_domains().size();\n  trust_bundle_stores_.reserve(size);\n  for (auto& domain : message.trust_domains()) {\n    if (trust_bundle_stores_.find(domain.name()) != trust_bundle_stores_.end()) {\n      throw EnvoyException(absl::StrCat(\n          \"Multiple trust bundles are given for one trust domain for \", domain.name()));\n    }\n\n    auto cert = Config::DataSource::read(domain.trust_bundle(), true, config->api());\n    bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(const_cast<char*>(cert.data()), cert.size()));\n    RELEASE_ASSERT(bio != nullptr, \"\");\n    bssl::UniquePtr<STACK_OF(X509_INFO)> list(\n        PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));\n    if (list == nullptr || sk_X509_INFO_num(list.get()) == 0) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load trusted CA certificate for \", domain.name()));\n    }\n\n    auto store = X509StorePtr(X509_STORE_new());\n    bool has_crl = false;\n    bool ca_loaded = false;\n    for (const X509_INFO* item : list.get()) {\n      if (item->x509) {\n        X509_STORE_add_cert(store.get(), item->x509);\n        ca_certs_.push_back(bssl::UniquePtr<X509>(item->x509));\n        X509_up_ref(item->x509);\n        if (!ca_loaded) {\n          // TODO: With the current interface, we cannot return the multiple\n          // cert information on getCaCertInformation method.\n          // So temporarily we return the first CA's info here.\n          ca_loaded = true;\n          ca_file_name_ = absl::StrCat(domain.name(), \": \",\n                                       domain.trust_bundle().filename().empty()\n                                           ? \"<inline>\"\n                                           : domain.trust_bundle().filename());\n        }\n      }\n\n      if (item->crl) {\n        has_crl = true;\n        X509_STORE_add_crl(store.get(), item->crl);\n      }\n    }\n    if (has_crl) {\n      X509_STORE_set_flags(store.get(), X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n    }\n    trust_bundle_stores_[domain.name()] = std::move(store);\n  }\n}",
        "func": "SPIFFEValidator::SPIFFEValidator(const Envoy::Ssl::CertificateValidationContextConfig* config,\n                                 SslStats& stats, TimeSource& time_source)\n    : stats_(stats), time_source_(time_source) {\n  ASSERT(config != nullptr);\n  allow_expired_certificate_ = config->allowExpiredCertificate();\n\n  SPIFFEConfig message;\n  Config::Utility::translateOpaqueConfig(config->customValidatorConfig().value().typed_config(),\n                                         ProtobufMessage::getStrictValidationVisitor(), message);\n\n  if (!config->subjectAltNameMatchers().empty()) {\n    for (const auto& matcher : config->subjectAltNameMatchers()) {\n      if (matcher.san_type() ==\n          envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI) {\n        // Only match against URI SAN since SPIFFE specification does not restrict values in other\n        // SAN types. See the discussion: https://github.com/envoyproxy/envoy/issues/15392\n        // TODO(pradeepcrao): Throw an exception when a non-URI matcher is encountered after the\n        // deprecated field match_subject_alt_names is removed\n        subject_alt_name_matchers_.emplace_back(createStringSanMatcher(matcher));\n      }\n    }\n  }\n\n  const auto size = message.trust_domains().size();\n  trust_bundle_stores_.reserve(size);\n  for (auto& domain : message.trust_domains()) {\n    if (trust_bundle_stores_.find(domain.name()) != trust_bundle_stores_.end()) {\n      throw EnvoyException(absl::StrCat(\n          \"Multiple trust bundles are given for one trust domain for \", domain.name()));\n    }\n\n    auto cert = Config::DataSource::read(domain.trust_bundle(), true, config->api());\n    bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(const_cast<char*>(cert.data()), cert.size()));\n    RELEASE_ASSERT(bio != nullptr, \"\");\n    bssl::UniquePtr<STACK_OF(X509_INFO)> list(\n        PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));\n    if (list == nullptr || sk_X509_INFO_num(list.get()) == 0) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load trusted CA certificate for \", domain.name()));\n    }\n\n    auto store = X509StorePtr(X509_STORE_new());\n    bool has_crl = false;\n    bool ca_loaded = false;\n    for (const X509_INFO* item : list.get()) {\n      if (item->x509) {\n        X509_STORE_add_cert(store.get(), item->x509);\n        ca_certs_.push_back(bssl::UniquePtr<X509>(item->x509));\n        X509_up_ref(item->x509);\n        if (!ca_loaded) {\n          // TODO: With the current interface, we cannot return the multiple\n          // cert information on getCaCertInformation method.\n          // So temporarily we return the first CA's info here.\n          ca_loaded = true;\n          ca_file_name_ = absl::StrCat(domain.name(), \": \",\n                                       domain.trust_bundle().filename().empty()\n                                           ? \"<inline>\"\n                                           : domain.trust_bundle().filename());\n        }\n      }\n\n      if (item->crl) {\n        has_crl = true;\n        X509_STORE_add_crl(store.get(), item->crl);\n      }\n    }\n    if (has_crl) {\n      X509_STORE_set_flags(store.get(), X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n    }\n    trust_bundle_stores_[domain.name()] = std::move(store);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,14 @@\n \n   if (!config->subjectAltNameMatchers().empty()) {\n     for (const auto& matcher : config->subjectAltNameMatchers()) {\n-      subject_alt_name_matchers_.push_back(Matchers::StringMatcherImpl(matcher));\n+      if (matcher.san_type() ==\n+          envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI) {\n+        // Only match against URI SAN since SPIFFE specification does not restrict values in other\n+        // SAN types. See the discussion: https://github.com/envoyproxy/envoy/issues/15392\n+        // TODO(pradeepcrao): Throw an exception when a non-URI matcher is encountered after the\n+        // deprecated field match_subject_alt_names is removed\n+        subject_alt_name_matchers_.emplace_back(createStringSanMatcher(matcher));\n+      }\n     }\n   }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "      subject_alt_name_matchers_.push_back(Matchers::StringMatcherImpl(matcher));"
            ],
            "added_lines": [
                "      if (matcher.san_type() ==",
                "          envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI) {",
                "        // Only match against URI SAN since SPIFFE specification does not restrict values in other",
                "        // SAN types. See the discussion: https://github.com/envoyproxy/envoy/issues/15392",
                "        // TODO(pradeepcrao): Throw an exception when a non-URI matcher is encountered after the",
                "        // deprecated field match_subject_alt_names is removed",
                "        subject_alt_name_matchers_.emplace_back(createStringSanMatcher(matcher));",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-21656",
        "func_name": "envoyproxy/envoy/CertificateValidationContextConfigImpl::CertificateValidationContextConfigImpl",
        "description": "Envoy is an open source edge and service proxy, designed for cloud-native applications. The default_validator.cc implementation used to implement the default certificate validation routines has a \"type confusion\" bug when processing subjectAltNames. This processing allows, for example, an rfc822Name or uniformResourceIndicator to be authenticated as a domain name. This confusion allows for the bypassing of nameConstraints, as processed by the underlying OpenSSL/BoringSSL implementation, exposing the possibility of impersonation of arbitrary servers. As a result Envoy will trust upstream certificates that should not be trusted.",
        "git_url": "https://github.com/envoyproxy/envoy/commit/bb95af848c939cfe5b5ee33c5b1770558077e64e",
        "commit_title": "Specify type for matching Subject Alternative Name. (#18628)",
        "commit_text": " \r",
        "func_before": "CertificateValidationContextConfigImpl::CertificateValidationContextConfigImpl(\n    const envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext& config,\n    Api::Api& api)\n    : ca_cert_(Config::DataSource::read(config.trusted_ca(), true, api)),\n      ca_cert_path_(Config::DataSource::getPath(config.trusted_ca())\n                        .value_or(ca_cert_.empty() ? EMPTY_STRING : INLINE_STRING)),\n      certificate_revocation_list_(Config::DataSource::read(config.crl(), true, api)),\n      certificate_revocation_list_path_(\n          Config::DataSource::getPath(config.crl())\n              .value_or(certificate_revocation_list_.empty() ? EMPTY_STRING : INLINE_STRING)),\n      subject_alt_name_matchers_(config.match_subject_alt_names().begin(),\n                                 config.match_subject_alt_names().end()),\n      verify_certificate_hash_list_(config.verify_certificate_hash().begin(),\n                                    config.verify_certificate_hash().end()),\n      verify_certificate_spki_list_(config.verify_certificate_spki().begin(),\n                                    config.verify_certificate_spki().end()),\n      allow_expired_certificate_(config.allow_expired_certificate()),\n      trust_chain_verification_(config.trust_chain_verification()),\n      custom_validator_config_(\n          config.has_custom_validator_config()\n              ? absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>(\n                    config.custom_validator_config())\n              : absl::nullopt),\n      api_(api), only_verify_leaf_cert_crl_(config.only_verify_leaf_cert_crl()) {\n  if (ca_cert_.empty() && custom_validator_config_ == absl::nullopt) {\n    if (!certificate_revocation_list_.empty()) {\n      throw EnvoyException(fmt::format(\"Failed to load CRL from {} without trusted CA\",\n                                       certificateRevocationListPath()));\n    }\n    if (!subject_alt_name_matchers_.empty()) {\n      throw EnvoyException(\"SAN-based verification of peer certificates without \"\n                           \"trusted CA is insecure and not allowed\");\n    }\n    if (allow_expired_certificate_) {\n      throw EnvoyException(\"Certificate validity period is always ignored without trusted CA\");\n    }\n  }\n}",
        "func": "CertificateValidationContextConfigImpl::CertificateValidationContextConfigImpl(\n    const envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext& config,\n    Api::Api& api)\n    : ca_cert_(Config::DataSource::read(config.trusted_ca(), true, api)),\n      ca_cert_path_(Config::DataSource::getPath(config.trusted_ca())\n                        .value_or(ca_cert_.empty() ? EMPTY_STRING : INLINE_STRING)),\n      certificate_revocation_list_(Config::DataSource::read(config.crl(), true, api)),\n      certificate_revocation_list_path_(\n          Config::DataSource::getPath(config.crl())\n              .value_or(certificate_revocation_list_.empty() ? EMPTY_STRING : INLINE_STRING)),\n      subject_alt_name_matchers_(getSubjectAltNameMatchers(config)),\n      verify_certificate_hash_list_(config.verify_certificate_hash().begin(),\n                                    config.verify_certificate_hash().end()),\n      verify_certificate_spki_list_(config.verify_certificate_spki().begin(),\n                                    config.verify_certificate_spki().end()),\n      allow_expired_certificate_(config.allow_expired_certificate()),\n      trust_chain_verification_(config.trust_chain_verification()),\n      custom_validator_config_(\n          config.has_custom_validator_config()\n              ? absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>(\n                    config.custom_validator_config())\n              : absl::nullopt),\n      api_(api), only_verify_leaf_cert_crl_(config.only_verify_leaf_cert_crl()) {\n  if (ca_cert_.empty() && custom_validator_config_ == absl::nullopt) {\n    if (!certificate_revocation_list_.empty()) {\n      throw EnvoyException(fmt::format(\"Failed to load CRL from {} without trusted CA\",\n                                       certificateRevocationListPath()));\n    }\n    if (!subject_alt_name_matchers_.empty()) {\n      throw EnvoyException(\"SAN-based verification of peer certificates without \"\n                           \"trusted CA is insecure and not allowed\");\n    }\n    if (allow_expired_certificate_) {\n      throw EnvoyException(\"Certificate validity period is always ignored without trusted CA\");\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,8 +8,7 @@\n       certificate_revocation_list_path_(\n           Config::DataSource::getPath(config.crl())\n               .value_or(certificate_revocation_list_.empty() ? EMPTY_STRING : INLINE_STRING)),\n-      subject_alt_name_matchers_(config.match_subject_alt_names().begin(),\n-                                 config.match_subject_alt_names().end()),\n+      subject_alt_name_matchers_(getSubjectAltNameMatchers(config)),\n       verify_certificate_hash_list_(config.verify_certificate_hash().begin(),\n                                     config.verify_certificate_hash().end()),\n       verify_certificate_spki_list_(config.verify_certificate_spki().begin(),",
        "diff_line_info": {
            "deleted_lines": [
                "      subject_alt_name_matchers_(config.match_subject_alt_names().begin(),",
                "                                 config.match_subject_alt_names().end()),"
            ],
            "added_lines": [
                "      subject_alt_name_matchers_(getSubjectAltNameMatchers(config)),"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-21656",
        "func_name": "envoyproxy/envoy/DefaultCertValidator::matchSubjectAltName",
        "description": "Envoy is an open source edge and service proxy, designed for cloud-native applications. The default_validator.cc implementation used to implement the default certificate validation routines has a \"type confusion\" bug when processing subjectAltNames. This processing allows, for example, an rfc822Name or uniformResourceIndicator to be authenticated as a domain name. This confusion allows for the bypassing of nameConstraints, as processed by the underlying OpenSSL/BoringSSL implementation, exposing the possibility of impersonation of arbitrary servers. As a result Envoy will trust upstream certificates that should not be trusted.",
        "git_url": "https://github.com/envoyproxy/envoy/commit/bb95af848c939cfe5b5ee33c5b1770558077e64e",
        "commit_title": "Specify type for matching Subject Alternative Name. (#18628)",
        "commit_text": " \r",
        "func_before": "bool DefaultCertValidator::matchSubjectAltName(\n    X509* cert,\n    const std::vector<Matchers::StringMatcherImpl<envoy::type::matcher::v3::StringMatcher>>&\n        subject_alt_name_matchers) {\n  bssl::UniquePtr<GENERAL_NAMES> san_names(\n      static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(cert, NID_subject_alt_name, nullptr, nullptr)));\n  if (san_names == nullptr) {\n    return false;\n  }\n  for (const GENERAL_NAME* general_name : san_names.get()) {\n    const std::string san = Utility::generalNameAsString(general_name);\n    for (auto& config_san_matcher : subject_alt_name_matchers) {\n      // For DNS SAN, if the StringMatcher type is exact, we have to follow DNS matching semantics.\n      if (general_name->type == GEN_DNS &&\n                  config_san_matcher.matcher().match_pattern_case() ==\n                      envoy::type::matcher::v3::StringMatcher::MatchPatternCase::kExact\n              ? Utility::dnsNameMatch(config_san_matcher.matcher().exact(), absl::string_view(san))\n              : config_san_matcher.match(san)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
        "func": "bool DefaultCertValidator::matchSubjectAltName(\n    X509* cert, const std::vector<SanMatcherPtr>& subject_alt_name_matchers) {\n  bssl::UniquePtr<GENERAL_NAMES> san_names(\n      static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(cert, NID_subject_alt_name, nullptr, nullptr)));\n  if (san_names == nullptr) {\n    return false;\n  }\n  for (const auto& config_san_matcher : subject_alt_name_matchers) {\n    for (const GENERAL_NAME* general_name : san_names.get()) {\n      if (config_san_matcher->match(general_name)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,21 +1,13 @@\n bool DefaultCertValidator::matchSubjectAltName(\n-    X509* cert,\n-    const std::vector<Matchers::StringMatcherImpl<envoy::type::matcher::v3::StringMatcher>>&\n-        subject_alt_name_matchers) {\n+    X509* cert, const std::vector<SanMatcherPtr>& subject_alt_name_matchers) {\n   bssl::UniquePtr<GENERAL_NAMES> san_names(\n       static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(cert, NID_subject_alt_name, nullptr, nullptr)));\n   if (san_names == nullptr) {\n     return false;\n   }\n-  for (const GENERAL_NAME* general_name : san_names.get()) {\n-    const std::string san = Utility::generalNameAsString(general_name);\n-    for (auto& config_san_matcher : subject_alt_name_matchers) {\n-      // For DNS SAN, if the StringMatcher type is exact, we have to follow DNS matching semantics.\n-      if (general_name->type == GEN_DNS &&\n-                  config_san_matcher.matcher().match_pattern_case() ==\n-                      envoy::type::matcher::v3::StringMatcher::MatchPatternCase::kExact\n-              ? Utility::dnsNameMatch(config_san_matcher.matcher().exact(), absl::string_view(san))\n-              : config_san_matcher.match(san)) {\n+  for (const auto& config_san_matcher : subject_alt_name_matchers) {\n+    for (const GENERAL_NAME* general_name : san_names.get()) {\n+      if (config_san_matcher->match(general_name)) {\n         return true;\n       }\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    X509* cert,",
                "    const std::vector<Matchers::StringMatcherImpl<envoy::type::matcher::v3::StringMatcher>>&",
                "        subject_alt_name_matchers) {",
                "  for (const GENERAL_NAME* general_name : san_names.get()) {",
                "    const std::string san = Utility::generalNameAsString(general_name);",
                "    for (auto& config_san_matcher : subject_alt_name_matchers) {",
                "      // For DNS SAN, if the StringMatcher type is exact, we have to follow DNS matching semantics.",
                "      if (general_name->type == GEN_DNS &&",
                "                  config_san_matcher.matcher().match_pattern_case() ==",
                "                      envoy::type::matcher::v3::StringMatcher::MatchPatternCase::kExact",
                "              ? Utility::dnsNameMatch(config_san_matcher.matcher().exact(), absl::string_view(san))",
                "              : config_san_matcher.match(san)) {"
            ],
            "added_lines": [
                "    X509* cert, const std::vector<SanMatcherPtr>& subject_alt_name_matchers) {",
                "  for (const auto& config_san_matcher : subject_alt_name_matchers) {",
                "    for (const GENERAL_NAME* general_name : san_names.get()) {",
                "      if (config_san_matcher->match(general_name)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-21656",
        "func_name": "envoyproxy/envoy/DefaultCertValidator::initializeSslContexts",
        "description": "Envoy is an open source edge and service proxy, designed for cloud-native applications. The default_validator.cc implementation used to implement the default certificate validation routines has a \"type confusion\" bug when processing subjectAltNames. This processing allows, for example, an rfc822Name or uniformResourceIndicator to be authenticated as a domain name. This confusion allows for the bypassing of nameConstraints, as processed by the underlying OpenSSL/BoringSSL implementation, exposing the possibility of impersonation of arbitrary servers. As a result Envoy will trust upstream certificates that should not be trusted.",
        "git_url": "https://github.com/envoyproxy/envoy/commit/bb95af848c939cfe5b5ee33c5b1770558077e64e",
        "commit_title": "Specify type for matching Subject Alternative Name. (#18628)",
        "commit_text": " \r",
        "func_before": "int DefaultCertValidator::initializeSslContexts(std::vector<SSL_CTX*> contexts,\n                                                bool provides_certificates) {\n\n  int verify_mode = SSL_VERIFY_NONE;\n  int verify_mode_validation_context = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n\n  if (config_ != nullptr) {\n    envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext::\n        TrustChainVerification verification = config_->trustChainVerification();\n    if (verification == envoy::extensions::transport_sockets::tls::v3::\n                            CertificateValidationContext::ACCEPT_UNTRUSTED) {\n      verify_mode = SSL_VERIFY_PEER; // Ensure client-certs will be requested even if we have\n                                     // nothing to verify against\n      verify_mode_validation_context = SSL_VERIFY_PEER;\n    }\n  }\n\n  if (config_ != nullptr && !config_->caCert().empty() && !provides_certificates) {\n    ca_file_path_ = config_->caCertPath();\n    bssl::UniquePtr<BIO> bio(\n        BIO_new_mem_buf(const_cast<char*>(config_->caCert().data()), config_->caCert().size()));\n    RELEASE_ASSERT(bio != nullptr, \"\");\n    // Based on BoringSSL's X509_load_cert_crl_file().\n    bssl::UniquePtr<STACK_OF(X509_INFO)> list(\n        PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));\n    if (list == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load trusted CA certificates from \", config_->caCertPath()));\n    }\n\n    for (auto& ctx : contexts) {\n      X509_STORE* store = SSL_CTX_get_cert_store(ctx);\n      bool has_crl = false;\n      for (const X509_INFO* item : list.get()) {\n        if (item->x509) {\n          X509_STORE_add_cert(store, item->x509);\n          if (ca_cert_ == nullptr) {\n            X509_up_ref(item->x509);\n            ca_cert_.reset(item->x509);\n          }\n        }\n        if (item->crl) {\n          X509_STORE_add_crl(store, item->crl);\n          has_crl = true;\n        }\n      }\n      if (ca_cert_ == nullptr) {\n        throw EnvoyException(\n            absl::StrCat(\"Failed to load trusted CA certificates from \", config_->caCertPath()));\n      }\n      if (has_crl) {\n        X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl()\n                                        ? X509_V_FLAG_CRL_CHECK\n                                        : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n      }\n      verify_mode = SSL_VERIFY_PEER;\n      verify_trusted_ca_ = true;\n\n      // NOTE: We're using SSL_CTX_set_cert_verify_callback() instead of X509_verify_cert()\n      // directly. However, our new callback is still calling X509_verify_cert() under\n      // the hood. Therefore, to ignore cert expiration, we need to set the callback\n      // for X509_verify_cert to ignore that error.\n      if (config_->allowExpiredCertificate()) {\n        X509_STORE_set_verify_cb(store, CertValidatorUtil::ignoreCertificateExpirationCallback);\n      }\n    }\n  }\n\n  if (config_ != nullptr && !config_->certificateRevocationList().empty()) {\n    bssl::UniquePtr<BIO> bio(\n        BIO_new_mem_buf(const_cast<char*>(config_->certificateRevocationList().data()),\n                        config_->certificateRevocationList().size()));\n    RELEASE_ASSERT(bio != nullptr, \"\");\n\n    // Based on BoringSSL's X509_load_cert_crl_file().\n    bssl::UniquePtr<STACK_OF(X509_INFO)> list(\n        PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));\n    if (list == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load CRL from \", config_->certificateRevocationListPath()));\n    }\n\n    for (auto& ctx : contexts) {\n      X509_STORE* store = SSL_CTX_get_cert_store(ctx);\n      for (const X509_INFO* item : list.get()) {\n        if (item->crl) {\n          X509_STORE_add_crl(store, item->crl);\n        }\n      }\n      X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl()\n                                      ? X509_V_FLAG_CRL_CHECK\n                                      : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n    }\n  }\n\n  const Envoy::Ssl::CertificateValidationContextConfig* cert_validation_config = config_;\n  if (cert_validation_config != nullptr) {\n    if (!cert_validation_config->subjectAltNameMatchers().empty()) {\n      for (const envoy::type::matcher::v3::StringMatcher& matcher :\n           cert_validation_config->subjectAltNameMatchers()) {\n        subject_alt_name_matchers_.push_back(Matchers::StringMatcherImpl(matcher));\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n\n    if (!cert_validation_config->verifyCertificateHashList().empty()) {\n      for (auto hash : cert_validation_config->verifyCertificateHashList()) {\n        // Remove colons from the 95 chars long colon-separated \"fingerprint\"\n        // in order to get the hex-encoded string.\n        if (hash.size() == 95) {\n          hash.erase(std::remove(hash.begin(), hash.end(), ':'), hash.end());\n        }\n        const auto& decoded = Hex::decode(hash);\n        if (decoded.size() != SHA256_DIGEST_LENGTH) {\n          throw EnvoyException(absl::StrCat(\"Invalid hex-encoded SHA-256 \", hash));\n        }\n        verify_certificate_hash_list_.push_back(decoded);\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n\n    if (!cert_validation_config->verifyCertificateSpkiList().empty()) {\n      for (const auto& hash : cert_validation_config->verifyCertificateSpkiList()) {\n        const auto decoded = Base64::decode(hash);\n        if (decoded.size() != SHA256_DIGEST_LENGTH) {\n          throw EnvoyException(absl::StrCat(\"Invalid base64-encoded SHA-256 \", hash));\n        }\n        verify_certificate_spki_list_.emplace_back(decoded.begin(), decoded.end());\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n  }\n\n  return verify_mode;\n}",
        "func": "int DefaultCertValidator::initializeSslContexts(std::vector<SSL_CTX*> contexts,\n                                                bool provides_certificates) {\n\n  int verify_mode = SSL_VERIFY_NONE;\n  int verify_mode_validation_context = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n\n  if (config_ != nullptr) {\n    envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext::\n        TrustChainVerification verification = config_->trustChainVerification();\n    if (verification == envoy::extensions::transport_sockets::tls::v3::\n                            CertificateValidationContext::ACCEPT_UNTRUSTED) {\n      verify_mode = SSL_VERIFY_PEER; // Ensure client-certs will be requested even if we have\n                                     // nothing to verify against\n      verify_mode_validation_context = SSL_VERIFY_PEER;\n    }\n  }\n\n  if (config_ != nullptr && !config_->caCert().empty() && !provides_certificates) {\n    ca_file_path_ = config_->caCertPath();\n    bssl::UniquePtr<BIO> bio(\n        BIO_new_mem_buf(const_cast<char*>(config_->caCert().data()), config_->caCert().size()));\n    RELEASE_ASSERT(bio != nullptr, \"\");\n    // Based on BoringSSL's X509_load_cert_crl_file().\n    bssl::UniquePtr<STACK_OF(X509_INFO)> list(\n        PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));\n    if (list == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load trusted CA certificates from \", config_->caCertPath()));\n    }\n\n    for (auto& ctx : contexts) {\n      X509_STORE* store = SSL_CTX_get_cert_store(ctx);\n      bool has_crl = false;\n      for (const X509_INFO* item : list.get()) {\n        if (item->x509) {\n          X509_STORE_add_cert(store, item->x509);\n          if (ca_cert_ == nullptr) {\n            X509_up_ref(item->x509);\n            ca_cert_.reset(item->x509);\n          }\n        }\n        if (item->crl) {\n          X509_STORE_add_crl(store, item->crl);\n          has_crl = true;\n        }\n      }\n      if (ca_cert_ == nullptr) {\n        throw EnvoyException(\n            absl::StrCat(\"Failed to load trusted CA certificates from \", config_->caCertPath()));\n      }\n      if (has_crl) {\n        X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl()\n                                        ? X509_V_FLAG_CRL_CHECK\n                                        : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n      }\n      verify_mode = SSL_VERIFY_PEER;\n      verify_trusted_ca_ = true;\n\n      // NOTE: We're using SSL_CTX_set_cert_verify_callback() instead of X509_verify_cert()\n      // directly. However, our new callback is still calling X509_verify_cert() under\n      // the hood. Therefore, to ignore cert expiration, we need to set the callback\n      // for X509_verify_cert to ignore that error.\n      if (config_->allowExpiredCertificate()) {\n        X509_STORE_set_verify_cb(store, CertValidatorUtil::ignoreCertificateExpirationCallback);\n      }\n    }\n  }\n\n  if (config_ != nullptr && !config_->certificateRevocationList().empty()) {\n    bssl::UniquePtr<BIO> bio(\n        BIO_new_mem_buf(const_cast<char*>(config_->certificateRevocationList().data()),\n                        config_->certificateRevocationList().size()));\n    RELEASE_ASSERT(bio != nullptr, \"\");\n\n    // Based on BoringSSL's X509_load_cert_crl_file().\n    bssl::UniquePtr<STACK_OF(X509_INFO)> list(\n        PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr));\n    if (list == nullptr) {\n      throw EnvoyException(\n          absl::StrCat(\"Failed to load CRL from \", config_->certificateRevocationListPath()));\n    }\n\n    for (auto& ctx : contexts) {\n      X509_STORE* store = SSL_CTX_get_cert_store(ctx);\n      for (const X509_INFO* item : list.get()) {\n        if (item->crl) {\n          X509_STORE_add_crl(store, item->crl);\n        }\n      }\n      X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl()\n                                      ? X509_V_FLAG_CRL_CHECK\n                                      : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n    }\n  }\n\n  const Envoy::Ssl::CertificateValidationContextConfig* cert_validation_config = config_;\n  if (cert_validation_config != nullptr) {\n    if (!cert_validation_config->subjectAltNameMatchers().empty()) {\n      for (const envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher& matcher :\n           cert_validation_config->subjectAltNameMatchers()) {\n        subject_alt_name_matchers_.emplace_back(createStringSanMatcher(matcher));\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n\n    if (!cert_validation_config->verifyCertificateHashList().empty()) {\n      for (auto hash : cert_validation_config->verifyCertificateHashList()) {\n        // Remove colons from the 95 chars long colon-separated \"fingerprint\"\n        // in order to get the hex-encoded string.\n        if (hash.size() == 95) {\n          hash.erase(std::remove(hash.begin(), hash.end(), ':'), hash.end());\n        }\n        const auto& decoded = Hex::decode(hash);\n        if (decoded.size() != SHA256_DIGEST_LENGTH) {\n          throw EnvoyException(absl::StrCat(\"Invalid hex-encoded SHA-256 \", hash));\n        }\n        verify_certificate_hash_list_.push_back(decoded);\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n\n    if (!cert_validation_config->verifyCertificateSpkiList().empty()) {\n      for (const auto& hash : cert_validation_config->verifyCertificateSpkiList()) {\n        const auto decoded = Base64::decode(hash);\n        if (decoded.size() != SHA256_DIGEST_LENGTH) {\n          throw EnvoyException(absl::StrCat(\"Invalid base64-encoded SHA-256 \", hash));\n        }\n        verify_certificate_spki_list_.emplace_back(decoded.begin(), decoded.end());\n      }\n      verify_mode = verify_mode_validation_context;\n    }\n  }\n\n  return verify_mode;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -96,9 +96,9 @@\n   const Envoy::Ssl::CertificateValidationContextConfig* cert_validation_config = config_;\n   if (cert_validation_config != nullptr) {\n     if (!cert_validation_config->subjectAltNameMatchers().empty()) {\n-      for (const envoy::type::matcher::v3::StringMatcher& matcher :\n+      for (const envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher& matcher :\n            cert_validation_config->subjectAltNameMatchers()) {\n-        subject_alt_name_matchers_.push_back(Matchers::StringMatcherImpl(matcher));\n+        subject_alt_name_matchers_.emplace_back(createStringSanMatcher(matcher));\n       }\n       verify_mode = verify_mode_validation_context;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "      for (const envoy::type::matcher::v3::StringMatcher& matcher :",
                "        subject_alt_name_matchers_.push_back(Matchers::StringMatcherImpl(matcher));"
            ],
            "added_lines": [
                "      for (const envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher& matcher :",
                "        subject_alt_name_matchers_.emplace_back(createStringSanMatcher(matcher));"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-21656",
        "func_name": "envoyproxy/envoy/DefaultCertValidator::verifyCertificate",
        "description": "Envoy is an open source edge and service proxy, designed for cloud-native applications. The default_validator.cc implementation used to implement the default certificate validation routines has a \"type confusion\" bug when processing subjectAltNames. This processing allows, for example, an rfc822Name or uniformResourceIndicator to be authenticated as a domain name. This confusion allows for the bypassing of nameConstraints, as processed by the underlying OpenSSL/BoringSSL implementation, exposing the possibility of impersonation of arbitrary servers. As a result Envoy will trust upstream certificates that should not be trusted.",
        "git_url": "https://github.com/envoyproxy/envoy/commit/bb95af848c939cfe5b5ee33c5b1770558077e64e",
        "commit_title": "Specify type for matching Subject Alternative Name. (#18628)",
        "commit_text": " \r",
        "func_before": "Envoy::Ssl::ClientValidationStatus DefaultCertValidator::verifyCertificate(\n    X509* cert, const std::vector<std::string>& verify_san_list,\n    const std::vector<Matchers::StringMatcherImpl<envoy::type::matcher::v3::StringMatcher>>&\n        subject_alt_name_matchers) {\n  Envoy::Ssl::ClientValidationStatus validated = Envoy::Ssl::ClientValidationStatus::NotValidated;\n\n  if (!verify_san_list.empty()) {\n    if (!verifySubjectAltName(cert, verify_san_list)) {\n      stats_.fail_verify_san_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n\n  if (!subject_alt_name_matchers.empty()) {\n    if (!matchSubjectAltName(cert, subject_alt_name_matchers)) {\n      stats_.fail_verify_san_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n\n  if (!verify_certificate_hash_list_.empty() || !verify_certificate_spki_list_.empty()) {\n    const bool valid_certificate_hash =\n        !verify_certificate_hash_list_.empty() &&\n        verifyCertificateHashList(cert, verify_certificate_hash_list_);\n    const bool valid_certificate_spki =\n        !verify_certificate_spki_list_.empty() &&\n        verifyCertificateSpkiList(cert, verify_certificate_spki_list_);\n\n    if (!valid_certificate_hash && !valid_certificate_spki) {\n      stats_.fail_verify_cert_hash_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n\n  return validated;\n}",
        "func": "Envoy::Ssl::ClientValidationStatus DefaultCertValidator::verifyCertificate(\n    X509* cert, const std::vector<std::string>& verify_san_list,\n    const std::vector<SanMatcherPtr>& subject_alt_name_matchers) {\n  Envoy::Ssl::ClientValidationStatus validated = Envoy::Ssl::ClientValidationStatus::NotValidated;\n\n  if (!verify_san_list.empty()) {\n    if (!verifySubjectAltName(cert, verify_san_list)) {\n      stats_.fail_verify_san_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n\n  if (!subject_alt_name_matchers.empty()) {\n    if (!matchSubjectAltName(cert, subject_alt_name_matchers)) {\n      stats_.fail_verify_san_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n\n  if (!verify_certificate_hash_list_.empty() || !verify_certificate_spki_list_.empty()) {\n    const bool valid_certificate_hash =\n        !verify_certificate_hash_list_.empty() &&\n        verifyCertificateHashList(cert, verify_certificate_hash_list_);\n    const bool valid_certificate_spki =\n        !verify_certificate_spki_list_.empty() &&\n        verifyCertificateSpkiList(cert, verify_certificate_spki_list_);\n\n    if (!valid_certificate_hash && !valid_certificate_spki) {\n      stats_.fail_verify_cert_hash_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n\n  return validated;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,6 @@\n Envoy::Ssl::ClientValidationStatus DefaultCertValidator::verifyCertificate(\n     X509* cert, const std::vector<std::string>& verify_san_list,\n-    const std::vector<Matchers::StringMatcherImpl<envoy::type::matcher::v3::StringMatcher>>&\n-        subject_alt_name_matchers) {\n+    const std::vector<SanMatcherPtr>& subject_alt_name_matchers) {\n   Envoy::Ssl::ClientValidationStatus validated = Envoy::Ssl::ClientValidationStatus::NotValidated;\n \n   if (!verify_san_list.empty()) {",
        "diff_line_info": {
            "deleted_lines": [
                "    const std::vector<Matchers::StringMatcherImpl<envoy::type::matcher::v3::StringMatcher>>&",
                "        subject_alt_name_matchers) {"
            ],
            "added_lines": [
                "    const std::vector<SanMatcherPtr>& subject_alt_name_matchers) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-21656",
        "func_name": "envoyproxy/envoy/DefaultCertValidator::doVerifyCertChain",
        "description": "Envoy is an open source edge and service proxy, designed for cloud-native applications. The default_validator.cc implementation used to implement the default certificate validation routines has a \"type confusion\" bug when processing subjectAltNames. This processing allows, for example, an rfc822Name or uniformResourceIndicator to be authenticated as a domain name. This confusion allows for the bypassing of nameConstraints, as processed by the underlying OpenSSL/BoringSSL implementation, exposing the possibility of impersonation of arbitrary servers. As a result Envoy will trust upstream certificates that should not be trusted.",
        "git_url": "https://github.com/envoyproxy/envoy/commit/bb95af848c939cfe5b5ee33c5b1770558077e64e",
        "commit_title": "Specify type for matching Subject Alternative Name. (#18628)",
        "commit_text": " \r",
        "func_before": "int DefaultCertValidator::doVerifyCertChain(\n    X509_STORE_CTX* store_ctx, Ssl::SslExtendedSocketInfo* ssl_extended_info, X509& leaf_cert,\n    const Network::TransportSocketOptions* transport_socket_options) {\n  if (verify_trusted_ca_) {\n    int ret = X509_verify_cert(store_ctx);\n    if (ssl_extended_info) {\n      ssl_extended_info->setCertificateValidationStatus(\n          ret == 1 ? Envoy::Ssl::ClientValidationStatus::Validated\n                   : Envoy::Ssl::ClientValidationStatus::Failed);\n    }\n\n    if (ret <= 0) {\n      stats_.fail_verify_error_.inc();\n      ENVOY_LOG(debug, \"{}\", Utility::getX509VerificationErrorInfo(store_ctx));\n      return allow_untrusted_certificate_ ? 1 : ret;\n    }\n  }\n\n  Envoy::Ssl::ClientValidationStatus validated =\n      verifyCertificate(&leaf_cert,\n                        transport_socket_options != nullptr\n                            ? transport_socket_options->verifySubjectAltNameListOverride()\n                            : std::vector<std::string>{},\n                        subject_alt_name_matchers_);\n\n  if (ssl_extended_info) {\n    if (ssl_extended_info->certificateValidationStatus() ==\n        Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      ssl_extended_info->setCertificateValidationStatus(validated);\n    } else if (validated != Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      ssl_extended_info->setCertificateValidationStatus(validated);\n    }\n  }\n\n  // If `trusted_ca` exists, it is already verified in the code above. Thus, we just need to make\n  // sure the verification for other validation context configurations doesn't fail (i.e. either\n  // `NotValidated` or `Validated`). If `trusted_ca` doesn't exist, we will need to make sure other\n  // configurations are verified and the verification succeed.\n  int validation_status = verify_trusted_ca_\n                              ? validated != Envoy::Ssl::ClientValidationStatus::Failed\n                              : validated == Envoy::Ssl::ClientValidationStatus::Validated;\n\n  return allow_untrusted_certificate_ ? 1 : validation_status;\n}",
        "func": "int DefaultCertValidator::doVerifyCertChain(\n    X509_STORE_CTX* store_ctx, Ssl::SslExtendedSocketInfo* ssl_extended_info, X509& leaf_cert,\n    const Network::TransportSocketOptions* transport_socket_options) {\n  if (verify_trusted_ca_) {\n    int ret = X509_verify_cert(store_ctx);\n    if (ssl_extended_info) {\n      ssl_extended_info->setCertificateValidationStatus(\n          ret == 1 ? Envoy::Ssl::ClientValidationStatus::Validated\n                   : Envoy::Ssl::ClientValidationStatus::Failed);\n    }\n\n    if (ret <= 0) {\n      stats_.fail_verify_error_.inc();\n      ENVOY_LOG(debug, \"{}\", Utility::getX509VerificationErrorInfo(store_ctx));\n      return allow_untrusted_certificate_ ? 1 : ret;\n    }\n  }\n\n  Envoy::Ssl::ClientValidationStatus validated =\n      verifyCertificate(&leaf_cert,\n                        transport_socket_options != nullptr\n                            ? transport_socket_options->verifySubjectAltNameListOverride()\n                            : std::vector<std::string>{},\n                        subject_alt_name_matchers_);\n\n  if (ssl_extended_info) {\n    if (ssl_extended_info->certificateValidationStatus() ==\n        Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      ssl_extended_info->setCertificateValidationStatus(validated);\n    } else if (validated != Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      ssl_extended_info->setCertificateValidationStatus(validated);\n    }\n  }\n\n  // If `trusted_ca` exists, it is already verified in the code above. Thus, we just need to make\n  // sure the verification for other validation context configurations doesn't fail (i.e. either\n  // `NotValidated` or `Validated`). If `trusted_ca` doesn't exist, we will need to make sure\n  // other configurations are verified and the verification succeed.\n  int validation_status = verify_trusted_ca_\n                              ? validated != Envoy::Ssl::ClientValidationStatus::Failed\n                              : validated == Envoy::Ssl::ClientValidationStatus::Validated;\n\n  return allow_untrusted_certificate_ ? 1 : validation_status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,8 +34,8 @@\n \n   // If `trusted_ca` exists, it is already verified in the code above. Thus, we just need to make\n   // sure the verification for other validation context configurations doesn't fail (i.e. either\n-  // `NotValidated` or `Validated`). If `trusted_ca` doesn't exist, we will need to make sure other\n-  // configurations are verified and the verification succeed.\n+  // `NotValidated` or `Validated`). If `trusted_ca` doesn't exist, we will need to make sure\n+  // other configurations are verified and the verification succeed.\n   int validation_status = verify_trusted_ca_\n                               ? validated != Envoy::Ssl::ClientValidationStatus::Failed\n                               : validated == Envoy::Ssl::ClientValidationStatus::Validated;",
        "diff_line_info": {
            "deleted_lines": [
                "  // `NotValidated` or `Validated`). If `trusted_ca` doesn't exist, we will need to make sure other",
                "  // configurations are verified and the verification succeed."
            ],
            "added_lines": [
                "  // `NotValidated` or `Validated`). If `trusted_ca` doesn't exist, we will need to make sure",
                "  // other configurations are verified and the verification succeed."
            ]
        }
    },
    {
        "cve_id": "CVE-2021-29513",
        "func_name": "tensorflow/PyArrayDescr_to_TF_DataType",
        "description": "TensorFlow is an end-to-end open source platform for machine learning. Calling TF operations with tensors of non-numeric types when the operations expect numeric tensors result in null pointer dereferences. The conversion from Python array to C++ array(https://github.com/tensorflow/tensorflow/blob/ff70c47a396ef1e3cb73c90513da4f5cb71bebba/tensorflow/python/lib/core/ndarray_tensor.cc#L113-L169) is vulnerable to a type confusion. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/030af767d357d1b4088c4a25c72cb3906abac489",
        "commit_title": "Fix `tf.raw_ops.ResourceCountUpTo` null pointer dereference.",
        "commit_text": " PiperOrigin-RevId: 368294347",
        "func_before": "Status PyArrayDescr_to_TF_DataType(PyArray_Descr* descr,\n                                   TF_DataType* out_tf_datatype) {\n  PyObject* key;\n  PyObject* value;\n  Py_ssize_t pos = 0;\n  if (PyDict_Next(descr->fields, &pos, &key, &value)) {\n    // In Python 3, the keys of numpy custom struct types are unicode, unlike\n    // Python 2, where the keys are bytes.\n    const char* key_string =\n        PyBytes_Check(key) ? PyBytes_AsString(key)\n                           : PyBytes_AsString(PyUnicode_AsASCIIString(key));\n    if (!key_string) {\n      return errors::Internal(\"Corrupt numpy type descriptor\");\n    }\n    tensorflow::string key = key_string;\n    // The typenames here should match the field names in the custom struct\n    // types constructed in test_util.py.\n    // TODO(mrry,keveman): Investigate Numpy type registration to replace this\n    // hard-coding of names.\n    if (key == \"quint8\") {\n      *out_tf_datatype = TF_QUINT8;\n    } else if (key == \"qint8\") {\n      *out_tf_datatype = TF_QINT8;\n    } else if (key == \"qint16\") {\n      *out_tf_datatype = TF_QINT16;\n    } else if (key == \"quint16\") {\n      *out_tf_datatype = TF_QUINT16;\n    } else if (key == \"qint32\") {\n      *out_tf_datatype = TF_QINT32;\n    } else if (key == \"resource\") {\n      *out_tf_datatype = TF_RESOURCE;\n    } else {\n      return errors::Internal(\"Unsupported numpy data type\");\n    }\n    return Status::OK();\n  }\n  return errors::Internal(\"Unsupported numpy data type\");\n}",
        "func": "Status PyArrayDescr_to_TF_DataType(PyArray_Descr* descr,\n                                   TF_DataType* out_tf_datatype) {\n  PyObject* key;\n  PyObject* value;\n  Py_ssize_t pos = 0;\n\n  // Return an error if the fields attribute is null.\n  // Occurs with an improper conversion attempt to resource.\n  if (descr->fields == nullptr) {\n    return errors::Internal(\"Unexpected numpy data type\");\n  }\n\n  if (PyDict_Next(descr->fields, &pos, &key, &value)) {\n    // In Python 3, the keys of numpy custom struct types are unicode, unlike\n    // Python 2, where the keys are bytes.\n    const char* key_string =\n        PyBytes_Check(key) ? PyBytes_AsString(key)\n                           : PyBytes_AsString(PyUnicode_AsASCIIString(key));\n    if (!key_string) {\n      return errors::Internal(\"Corrupt numpy type descriptor\");\n    }\n    tensorflow::string key = key_string;\n    // The typenames here should match the field names in the custom struct\n    // types constructed in test_util.py.\n    // TODO(mrry,keveman): Investigate Numpy type registration to replace this\n    // hard-coding of names.\n    if (key == \"quint8\") {\n      *out_tf_datatype = TF_QUINT8;\n    } else if (key == \"qint8\") {\n      *out_tf_datatype = TF_QINT8;\n    } else if (key == \"qint16\") {\n      *out_tf_datatype = TF_QINT16;\n    } else if (key == \"quint16\") {\n      *out_tf_datatype = TF_QUINT16;\n    } else if (key == \"qint32\") {\n      *out_tf_datatype = TF_QINT32;\n    } else if (key == \"resource\") {\n      *out_tf_datatype = TF_RESOURCE;\n    } else {\n      return errors::Internal(\"Unsupported numpy data type\");\n    }\n    return Status::OK();\n  }\n  return errors::Internal(\"Unsupported numpy data type\");\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,13 @@\n   PyObject* key;\n   PyObject* value;\n   Py_ssize_t pos = 0;\n+\n+  // Return an error if the fields attribute is null.\n+  // Occurs with an improper conversion attempt to resource.\n+  if (descr->fields == nullptr) {\n+    return errors::Internal(\"Unexpected numpy data type\");\n+  }\n+\n   if (PyDict_Next(descr->fields, &pos, &key, &value)) {\n     // In Python 3, the keys of numpy custom struct types are unicode, unlike\n     // Python 2, where the keys are bytes.",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  // Return an error if the fields attribute is null.",
                "  // Occurs with an improper conversion attempt to resource.",
                "  if (descr->fields == nullptr) {",
                "    return errors::Internal(\"Unexpected numpy data type\");",
                "  }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-29519",
        "func_name": "tensorflow/SparseCrossOp",
        "description": "TensorFlow is an end-to-end open source platform for machine learning. The API of `tf.raw_ops.SparseCross` allows combinations which would result in a `CHECK`-failure and denial of service. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/3d782b7d47b1bf2ed32bd4a246d6d6cadc4c903d/tensorflow/core/kernels/sparse_cross_op.cc#L114-L116) is tricked to consider a tensor of type `tstring` which in fact contains integral elements. Fixing the type confusion by preventing mixing `DT_STRING` and `DT_INT64` types solves this issue. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/b1cc5e5a50e7cee09f2c6eb48eb40ee9c4125025",
        "commit_title": "Fix `tf.raw_ops.SparseCross` failing CHECK.",
        "commit_text": " PiperOrigin-RevId: 368701671",
        "func_before": "explicit SparseCrossOp(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n    // Read signed_hash_key_ as int64 since uint64 attributes are not\n    // supported by REGISTER_OP.\n    int64 signed_hash_key_;\n    OP_REQUIRES_OK(context, context->GetAttr(\"hash_key\", &signed_hash_key_));\n    hash_key_ = static_cast<uint64>(signed_hash_key_);\n  }",
        "func": "explicit SparseCrossOp(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n    // Read signed_hash_key_ as int64 since uint64 attributes are not\n    // supported by REGISTER_OP.\n    int64 signed_hash_key_;\n    OP_REQUIRES_OK(context, context->GetAttr(\"hash_key\", &signed_hash_key_));\n    hash_key_ = static_cast<uint64>(signed_hash_key_);\n    OP_REQUIRES_OK(context, context->GetAttr(\"internal_type\", &internal_type_));\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,4 +5,5 @@\n     int64 signed_hash_key_;\n     OP_REQUIRES_OK(context, context->GetAttr(\"hash_key\", &signed_hash_key_));\n     hash_key_ = static_cast<uint64>(signed_hash_key_);\n+    OP_REQUIRES_OK(context, context->GetAttr(\"internal_type\", &internal_type_));\n   }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    OP_REQUIRES_OK(context, context->GetAttr(\"internal_type\", &internal_type_));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-29519",
        "func_name": "tensorflow/Compute",
        "description": "TensorFlow is an end-to-end open source platform for machine learning. The API of `tf.raw_ops.SparseCross` allows combinations which would result in a `CHECK`-failure and denial of service. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/3d782b7d47b1bf2ed32bd4a246d6d6cadc4c903d/tensorflow/core/kernels/sparse_cross_op.cc#L114-L116) is tricked to consider a tensor of type `tstring` which in fact contains integral elements. Fixing the type confusion by preventing mixing `DT_STRING` and `DT_INT64` types solves this issue. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/b1cc5e5a50e7cee09f2c6eb48eb40ee9c4125025",
        "commit_title": "Fix `tf.raw_ops.SparseCross` failing CHECK.",
        "commit_text": " PiperOrigin-RevId: 368701671",
        "func_before": "void Compute(OpKernelContext* context) override {\n    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n\n    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in));\n\n    const Tensor* num_buckets_t;\n    OP_REQUIRES_OK(context, context->input(\"num_buckets\", &num_buckets_t));\n    const int64 num_buckets = num_buckets_t->scalar<int64>()();\n\n    const Tensor* strong_hash_t;\n    OP_REQUIRES_OK(context, context->input(\"strong_hash\", &strong_hash_t));\n    const bool strong_hash = strong_hash_t->scalar<bool>()();\n\n    const Tensor* salt_t;\n    OP_REQUIRES_OK(context, context->input(\"salt\", &salt_t));\n    const auto salt = salt_t->flat<int64>();\n    std::vector<int64> key_{salt(0), salt(1)};\n\n    std::vector<std::unique_ptr<ColumnInterface<int64>>> columns =\n        GenerateKeyedColumnsFromInput<int64>(indices_list_in, values_list_in,\n                                             shapes_list_in, dense_list_in,\n                                             key_);\n    Tensor* indices_out;\n    Tensor* values_out;\n    Tensor* shape_out;\n    const int64 batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);\n    std::vector<int64> output_start_indices(batch_size);\n    OP_REQUIRES_OK(\n        context,\n        CreateOutputTensors(columns, batch_size, context, &indices_out,\n                            &values_out, &shape_out, &output_start_indices));\n    const tstring unused_sep;\n    HashCrosserV2 crosser(columns, num_buckets, 0, unused_sep);\n    OutputUpdater<int64> updater(output_start_indices, indices_out, values_out);\n    auto do_work = [&columns, crosser, updater, strong_hash](int64 begin,\n                                                             int64 end) {\n      for (int b = begin; b < end; b++) {\n        ProductIterator<int64> product_iterator(columns, b);\n        int64 cross_count = 0;\n        while (product_iterator.HasNext()) {\n          const auto permutation = product_iterator.Next();\n          updater.Update(b, cross_count,\n                         crosser.Generate(b, permutation, strong_hash));\n          cross_count++;\n        }\n      }\n    };\n\n    auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();\n    // TODO(zakaria): optimize kCostPerUnit\n    const int kCostPerUnit = 5000 * indices_list_in.size();\n    Shard(worker_threads->num_threads, worker_threads->workers, batch_size,\n          kCostPerUnit, do_work);\n  }",
        "func": "void Compute(OpKernelContext* context) override {\n    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n\n    // Set internal_type to invalid_type so that the check will be ignored.\n    DataType internal_type = DT_INVALID;\n    OP_REQUIRES_OK(\n        context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,\n                               dense_list_in, internal_type));\n\n    const Tensor* num_buckets_t;\n    OP_REQUIRES_OK(context, context->input(\"num_buckets\", &num_buckets_t));\n    const int64 num_buckets = num_buckets_t->scalar<int64>()();\n\n    const Tensor* strong_hash_t;\n    OP_REQUIRES_OK(context, context->input(\"strong_hash\", &strong_hash_t));\n    const bool strong_hash = strong_hash_t->scalar<bool>()();\n\n    const Tensor* salt_t;\n    OP_REQUIRES_OK(context, context->input(\"salt\", &salt_t));\n    const auto salt = salt_t->flat<int64>();\n    std::vector<int64> key_{salt(0), salt(1)};\n\n    std::vector<std::unique_ptr<ColumnInterface<int64>>> columns =\n        GenerateKeyedColumnsFromInput<int64>(indices_list_in, values_list_in,\n                                             shapes_list_in, dense_list_in,\n                                             key_);\n    Tensor* indices_out;\n    Tensor* values_out;\n    Tensor* shape_out;\n    const int64 batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);\n    std::vector<int64> output_start_indices(batch_size);\n    OP_REQUIRES_OK(\n        context,\n        CreateOutputTensors(columns, batch_size, context, &indices_out,\n                            &values_out, &shape_out, &output_start_indices));\n    const tstring unused_sep;\n    HashCrosserV2 crosser(columns, num_buckets, 0, unused_sep);\n    OutputUpdater<int64> updater(output_start_indices, indices_out, values_out);\n    auto do_work = [&columns, crosser, updater, strong_hash](int64 begin,\n                                                             int64 end) {\n      for (int b = begin; b < end; b++) {\n        ProductIterator<int64> product_iterator(columns, b);\n        int64 cross_count = 0;\n        while (product_iterator.HasNext()) {\n          const auto permutation = product_iterator.Next();\n          updater.Update(b, cross_count,\n                         crosser.Generate(b, permutation, strong_hash));\n          cross_count++;\n        }\n      }\n    };\n\n    auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();\n    // TODO(zakaria): optimize kCostPerUnit\n    const int kCostPerUnit = 5000 * indices_list_in.size();\n    Shard(worker_threads->num_threads, worker_threads->workers, batch_size,\n          kCostPerUnit, do_work);\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,8 +9,11 @@\n     OP_REQUIRES_OK(context,\n                    context->input_list(\"dense_inputs\", &dense_list_in));\n \n-    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,\n-                                          shapes_list_in, dense_list_in));\n+    // Set internal_type to invalid_type so that the check will be ignored.\n+    DataType internal_type = DT_INVALID;\n+    OP_REQUIRES_OK(\n+        context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,\n+                               dense_list_in, internal_type));\n \n     const Tensor* num_buckets_t;\n     OP_REQUIRES_OK(context, context->input(\"num_buckets\", &num_buckets_t));",
        "diff_line_info": {
            "deleted_lines": [
                "    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,",
                "                                          shapes_list_in, dense_list_in));"
            ],
            "added_lines": [
                "    // Set internal_type to invalid_type so that the check will be ignored.",
                "    DataType internal_type = DT_INVALID;",
                "    OP_REQUIRES_OK(",
                "        context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,",
                "                               dense_list_in, internal_type));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-29519",
        "func_name": "tensorflow/ValidateInput",
        "description": "TensorFlow is an end-to-end open source platform for machine learning. The API of `tf.raw_ops.SparseCross` allows combinations which would result in a `CHECK`-failure and denial of service. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/3d782b7d47b1bf2ed32bd4a246d6d6cadc4c903d/tensorflow/core/kernels/sparse_cross_op.cc#L114-L116) is tricked to consider a tensor of type `tstring` which in fact contains integral elements. Fixing the type confusion by preventing mixing `DT_STRING` and `DT_INT64` types solves this issue. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/b1cc5e5a50e7cee09f2c6eb48eb40ee9c4125025",
        "commit_title": "Fix `tf.raw_ops.SparseCross` failing CHECK.",
        "commit_text": " PiperOrigin-RevId: 368701671",
        "func_before": "Status ValidateInput(const OpInputList& indices_list_in,\n                     const OpInputList& values_list_in,\n                     const OpInputList& shapes_list_in,\n                     const OpInputList& dense_list_in) {\n  const auto size = indices_list_in.size();\n  // Validates indices_list_in OpInputList.\n  for (int i = 0; i < size; i++) {\n    if (!TensorShapeUtils::IsMatrix(indices_list_in[i].shape())) {\n      return errors::InvalidArgument(\n          \"Input indices should be a matrix but received shape \",\n          indices_list_in[i].shape().DebugString(), \" at position \", i);\n    }\n    if (indices_list_in[i].shape().dim_size(1) != 2) {\n      return errors::InvalidArgument(\"Expected D2 of index to be 2 got \",\n                                     indices_list_in[i].shape().dim_size(1),\n                                     \" at position \", i);\n    }\n  }\n\n  // Validates values_list_in OpInputList.\n  if (values_list_in.size() != size) {\n    return errors::InvalidArgument(\"Expected \", size, \" input values, got \",\n                                   values_list_in.size());\n  }\n  for (int i = 0; i < size; i++) {\n    if (!TensorShapeUtils::IsVector(values_list_in[i].shape())) {\n      return errors::InvalidArgument(\n          \"Input values should be a vector but received shape \",\n          values_list_in[i].shape().DebugString(), \" at position \", i);\n    }\n    if (indices_list_in[i].shape().dim_size(0) !=\n        values_list_in[i].shape().dim_size(0)) {\n      return errors::InvalidArgument(\n          \"Expected size of values to be \",\n          indices_list_in[i].shape().dim_size(0), \" got \",\n          values_list_in[i].shape().dim_size(0), \" at position \", i);\n    }\n  }\n\n  // Validates shapes_list_in OpInputList\n  if (shapes_list_in.size() != size) {\n    return errors::InvalidArgument(\"Expected \", size, \" input shapes, got \",\n                                   shapes_list_in.size());\n  }\n  for (int i = 0; i < size; i++) {\n    if (!TensorShapeUtils::IsVector(shapes_list_in[i].shape())) {\n      return errors::InvalidArgument(\n          \"Input shapes should be a vector but received shape \",\n          shapes_list_in[i].shape().DebugString(), \" at position \", i);\n    }\n\n    if (shapes_list_in[i].vec<int64>().size() != 2) {\n      return errors::InvalidArgument(\"shape should imply a 2D tensor, but got \",\n                                     shapes_list_in[i].shape().DebugString(),\n                                     \" at position \", i);\n    }\n  }\n\n  // Validates dense_list_in OpInputList\n  for (int i = 0; i < dense_list_in.size(); ++i) {\n    if (!TensorShapeUtils::IsMatrix(dense_list_in[i].shape())) {\n      return errors::InvalidArgument(\n          \"Dense inputs should be a matrix but received shape \",\n          dense_list_in[i].shape().DebugString(), \" at position \", i);\n    }\n  }\n\n  // Validates batch sizes.  (Note: we do this after validating the input\n  // shapes, because CalculateBatchSize() depends on inputs having valid\n  // shapes).\n  const auto batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);\n  for (int i = 0; i < size; i++) {\n    if (shapes_list_in[i].vec<int64>()(0) != batch_size) {\n      return errors::InvalidArgument(\"Expected batch size \", batch_size,\n                                     \" got \", shapes_list_in[i].vec<int64>()(0),\n                                     \" at position \", i);\n    }\n  }\n  for (int i = 0; i < dense_list_in.size(); ++i) {\n    if (dense_list_in[i].dim_size(0) != batch_size) {\n      return errors::InvalidArgument(\"Expected batch size \", batch_size,\n                                     \" got \", dense_list_in[i].dim_size(0),\n                                     \" at dense tensor \", i);\n    }\n  }\n\n  return Status::OK();\n}",
        "func": "Status ValidateInput(const OpInputList& indices_list_in,\n                     const OpInputList& values_list_in,\n                     const OpInputList& shapes_list_in,\n                     const OpInputList& dense_list_in,\n                     const DataType& internal_type) {\n  const auto size = indices_list_in.size();\n  // Only perform internal_type check for SparseCrossOp.\n  // Check if the internal_type is not invalid before doing so.\n  bool check_type = internal_type != DT_INVALID;\n  // Validates indices_list_in OpInputList.\n  for (int i = 0; i < size; i++) {\n    if (check_type && indices_list_in[i].dtype() != DT_INT64) {\n      return errors::InvalidArgument(\"Input indices should be of type \",\n                                     DT_INT64, \" but received \",\n                                     indices_list_in[i].dtype());\n    }\n    if (!TensorShapeUtils::IsMatrix(indices_list_in[i].shape())) {\n      return errors::InvalidArgument(\n          \"Input indices should be a matrix but received shape \",\n          indices_list_in[i].shape().DebugString(), \" at position \", i);\n    }\n    if (indices_list_in[i].shape().dim_size(1) != 2) {\n      return errors::InvalidArgument(\"Expected D2 of index to be 2 got \",\n                                     indices_list_in[i].shape().dim_size(1),\n                                     \" at position \", i);\n    }\n  }\n\n  // Validates values_list_in OpInputList.\n  if (values_list_in.size() != size) {\n    return errors::InvalidArgument(\"Expected \", size, \" input values, got \",\n                                   values_list_in.size());\n  }\n  for (int i = 0; i < size; i++) {\n    // Make sure to avoid the expected type to be string, but input values to be\n    // int64.\n    if (check_type && internal_type == DT_STRING &&\n        values_list_in[i].dtype() == DT_INT64) {\n      return errors::InvalidArgument(\"Input values should be of internal type \",\n                                     internal_type, \" but received \",\n                                     values_list_in[i].dtype());\n    }\n    if (!TensorShapeUtils::IsVector(values_list_in[i].shape())) {\n      return errors::InvalidArgument(\n          \"Input values should be a vector but received shape \",\n          values_list_in[i].shape().DebugString(), \" at position \", i);\n    }\n    if (indices_list_in[i].shape().dim_size(0) !=\n        values_list_in[i].shape().dim_size(0)) {\n      return errors::InvalidArgument(\n          \"Expected size of values to be \",\n          indices_list_in[i].shape().dim_size(0), \" got \",\n          values_list_in[i].shape().dim_size(0), \" at position \", i);\n    }\n  }\n\n  // Validates shapes_list_in OpInputList\n  if (shapes_list_in.size() != size) {\n    return errors::InvalidArgument(\"Expected \", size, \" input shapes, got \",\n                                   shapes_list_in.size());\n  }\n  for (int i = 0; i < size; i++) {\n    if (check_type && shapes_list_in[i].dtype() != DT_INT64) {\n      return errors::InvalidArgument(\"Input shape should be of type \", DT_INT64,\n                                     \" but received \",\n                                     shapes_list_in[i].dtype());\n    }\n    if (!TensorShapeUtils::IsVector(shapes_list_in[i].shape())) {\n      return errors::InvalidArgument(\n          \"Input shapes should be a vector but received shape \",\n          shapes_list_in[i].shape().DebugString(), \" at position \", i);\n    }\n\n    if (shapes_list_in[i].vec<int64>().size() != 2) {\n      return errors::InvalidArgument(\"shape should imply a 2D tensor, but got \",\n                                     shapes_list_in[i].shape().DebugString(),\n                                     \" at position \", i);\n    }\n  }\n\n  // Validates dense_list_in OpInputList\n  for (int i = 0; i < dense_list_in.size(); ++i) {\n    // Make sure to avoid the expected type to be string, but input values to be\n    // int64.\n    if (check_type && internal_type == DT_STRING &&\n        dense_list_in[i].dtype() == DT_INT64) {\n      return errors::InvalidArgument(\"Dense inputs should be of internal type \",\n                                     internal_type, \" but received \",\n                                     dense_list_in[i].dtype());\n    }\n    if (!TensorShapeUtils::IsMatrix(dense_list_in[i].shape())) {\n      return errors::InvalidArgument(\n          \"Dense inputs should be a matrix but received shape \",\n          dense_list_in[i].shape().DebugString(), \" at position \", i);\n    }\n  }\n\n  // Validates batch sizes.  (Note: we do this after validating the input\n  // shapes, because CalculateBatchSize() depends on inputs having valid\n  // shapes).\n  const auto batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);\n  for (int i = 0; i < size; i++) {\n    if (shapes_list_in[i].vec<int64>()(0) != batch_size) {\n      return errors::InvalidArgument(\"Expected batch size \", batch_size,\n                                     \" got \", shapes_list_in[i].vec<int64>()(0),\n                                     \" at position \", i);\n    }\n  }\n  for (int i = 0; i < dense_list_in.size(); ++i) {\n    if (dense_list_in[i].dim_size(0) != batch_size) {\n      return errors::InvalidArgument(\"Expected batch size \", batch_size,\n                                     \" got \", dense_list_in[i].dim_size(0),\n                                     \" at dense tensor \", i);\n    }\n  }\n\n  return Status::OK();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,19 @@\n Status ValidateInput(const OpInputList& indices_list_in,\n                      const OpInputList& values_list_in,\n                      const OpInputList& shapes_list_in,\n-                     const OpInputList& dense_list_in) {\n+                     const OpInputList& dense_list_in,\n+                     const DataType& internal_type) {\n   const auto size = indices_list_in.size();\n+  // Only perform internal_type check for SparseCrossOp.\n+  // Check if the internal_type is not invalid before doing so.\n+  bool check_type = internal_type != DT_INVALID;\n   // Validates indices_list_in OpInputList.\n   for (int i = 0; i < size; i++) {\n+    if (check_type && indices_list_in[i].dtype() != DT_INT64) {\n+      return errors::InvalidArgument(\"Input indices should be of type \",\n+                                     DT_INT64, \" but received \",\n+                                     indices_list_in[i].dtype());\n+    }\n     if (!TensorShapeUtils::IsMatrix(indices_list_in[i].shape())) {\n       return errors::InvalidArgument(\n           \"Input indices should be a matrix but received shape \",\n@@ -23,6 +32,14 @@\n                                    values_list_in.size());\n   }\n   for (int i = 0; i < size; i++) {\n+    // Make sure to avoid the expected type to be string, but input values to be\n+    // int64.\n+    if (check_type && internal_type == DT_STRING &&\n+        values_list_in[i].dtype() == DT_INT64) {\n+      return errors::InvalidArgument(\"Input values should be of internal type \",\n+                                     internal_type, \" but received \",\n+                                     values_list_in[i].dtype());\n+    }\n     if (!TensorShapeUtils::IsVector(values_list_in[i].shape())) {\n       return errors::InvalidArgument(\n           \"Input values should be a vector but received shape \",\n@@ -43,6 +60,11 @@\n                                    shapes_list_in.size());\n   }\n   for (int i = 0; i < size; i++) {\n+    if (check_type && shapes_list_in[i].dtype() != DT_INT64) {\n+      return errors::InvalidArgument(\"Input shape should be of type \", DT_INT64,\n+                                     \" but received \",\n+                                     shapes_list_in[i].dtype());\n+    }\n     if (!TensorShapeUtils::IsVector(shapes_list_in[i].shape())) {\n       return errors::InvalidArgument(\n           \"Input shapes should be a vector but received shape \",\n@@ -58,6 +80,14 @@\n \n   // Validates dense_list_in OpInputList\n   for (int i = 0; i < dense_list_in.size(); ++i) {\n+    // Make sure to avoid the expected type to be string, but input values to be\n+    // int64.\n+    if (check_type && internal_type == DT_STRING &&\n+        dense_list_in[i].dtype() == DT_INT64) {\n+      return errors::InvalidArgument(\"Dense inputs should be of internal type \",\n+                                     internal_type, \" but received \",\n+                                     dense_list_in[i].dtype());\n+    }\n     if (!TensorShapeUtils::IsMatrix(dense_list_in[i].shape())) {\n       return errors::InvalidArgument(\n           \"Dense inputs should be a matrix but received shape \",",
        "diff_line_info": {
            "deleted_lines": [
                "                     const OpInputList& dense_list_in) {"
            ],
            "added_lines": [
                "                     const OpInputList& dense_list_in,",
                "                     const DataType& internal_type) {",
                "  // Only perform internal_type check for SparseCrossOp.",
                "  // Check if the internal_type is not invalid before doing so.",
                "  bool check_type = internal_type != DT_INVALID;",
                "    if (check_type && indices_list_in[i].dtype() != DT_INT64) {",
                "      return errors::InvalidArgument(\"Input indices should be of type \",",
                "                                     DT_INT64, \" but received \",",
                "                                     indices_list_in[i].dtype());",
                "    }",
                "    // Make sure to avoid the expected type to be string, but input values to be",
                "    // int64.",
                "    if (check_type && internal_type == DT_STRING &&",
                "        values_list_in[i].dtype() == DT_INT64) {",
                "      return errors::InvalidArgument(\"Input values should be of internal type \",",
                "                                     internal_type, \" but received \",",
                "                                     values_list_in[i].dtype());",
                "    }",
                "    if (check_type && shapes_list_in[i].dtype() != DT_INT64) {",
                "      return errors::InvalidArgument(\"Input shape should be of type \", DT_INT64,",
                "                                     \" but received \",",
                "                                     shapes_list_in[i].dtype());",
                "    }",
                "    // Make sure to avoid the expected type to be string, but input values to be",
                "    // int64.",
                "    if (check_type && internal_type == DT_STRING &&",
                "        dense_list_in[i].dtype() == DT_INT64) {",
                "      return errors::InvalidArgument(\"Dense inputs should be of internal type \",",
                "                                     internal_type, \" but received \",",
                "                                     dense_list_in[i].dtype());",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-33624",
        "func_name": "torvalds/linux/sanitize_ptr_alu",
        "description": "In kernel/bpf/verifier.c in the Linux kernel before 5.12.13, a branch can be mispredicted (e.g., because of type confusion) and consequently an unprivileged BPF program can read arbitrary memory locations via a side-channel attack, aka CID-9183671af6db.",
        "git_url": "https://github.com/torvalds/linux/commit/9183671af6dbf60a1219371d4ed73e23f43b49db",
        "commit_title": "bpf: Fix leakage under speculation on mispredicted branches",
        "commit_text": " The verifier only enumerates valid control-flow paths and skips paths that are unreachable in the non-speculative domain. And so it can miss issues under speculative execution on mispredicted branches.  For example, a type confusion has been demonstrated with the following crafted program:    // r0 = pointer to a map array entry   // r6 = pointer to readable stack slot   // r9 = scalar controlled by attacker   1: r0 = *(u64 *)(r0) // cache miss   2: if r0 != 0x0 goto line 4   3: r6 = r9   4: if r0 != 0x1 goto line 6   5: r9 = *(u8 *)(r6)   6: // leak r9  Since line 3 runs iff r0 == 0 and line 5 runs iff r0 == 1, the verifier concludes that the pointer dereference on line 5 is safe. But: if the attacker trains both the branches to fall-through, such that the following is speculatively executed ...    r6 = r9   r9 = *(u8 *)(r6)   // leak r9  ... then the program will dereference an attacker-controlled value and could leak its content under speculative execution via side-channel. This requires to mistrain the branch predictor, which can be rather tricky, because the branches are mutually exclusive. However such training can be done at congruent addresses in user space using different branches that are not mutually exclusive. That is, by training branches in user space ...    A:  if r0 != 0x0 goto line C   B:  ...   C:  if r0 != 0x0 goto line D   D:  ...  ... such that addresses A and C collide to the same CPU branch prediction entries in the PHT (pattern history table) as those of the BPF program's lines 2 and 4, respectively. A non-privileged attacker could simply brute force such collisions in the PHT until observing the attack succeeding.  Alternative methods to mistrain the branch predictor are also possible that avoid brute forcing the collisions in the PHT. A reliable attack has been demonstrated, for example, using the following crafted program:    // r0 = pointer to a [control] map array entry   // r7 = *(u64 *)(r0 + 0), training/attack phase   // r8 = *(u64 *)(r0 + 8), oob address   // [...]   // r0 = pointer to a [data] map array entry   1: if r7 == 0x3 goto line 3   2: r8 = r0   // crafted sequence of conditional jumps to separate the conditional   // branch in line 193 from the current execution flow   3: if r0 != 0x0 goto line 5   4: if r0 == 0x0 goto exit   5: if r0 != 0x0 goto line 7   6: if r0 == 0x0 goto exit   [...]   187: if r0 != 0x0 goto line 189   188: if r0 == 0x0 goto exit   // load any slowly-loaded value (due to cache miss in phase 3) ...   189: r3 = *(u64 *)(r0 + 0x1200)   // ... and turn it into known zero for verifier, while preserving slowly-   // loaded dependency when executing:   190: r3 &= 1   191: r3 &= 2   // speculatively bypassed phase dependency   192: r7 += r3   193: if r7 == 0x3 goto exit   194: r4 = *(u8 *)(r8 + 0)   // leak r4  As can be seen, in training phase (phase != 0x3), the condition in line 1 turns into false and therefore r8 with the oob address is overridden with the valid map value address, which in line 194 we can read out without issues. However, in attack phase, line 2 is skipped, and due to the cache miss in line 189 where the map value is (zeroed and later) added to the phase register, the condition in line 193 takes the fall-through path due to prior branch predictor training, where under speculation, it'll load the byte at oob address r8 (unknown scalar type at that point) which could then be leaked via side-channel.  One way to mitigate these is to 'branch off' an unreachable path, meaning, the current verification path keeps following the is_branch_taken() path and we push the other branch to the verification stack. Given this is unreachable from the non-speculative domain, this branch's vstate is explicitly marked as speculative. This is needed for two reasons: i) if this path is solely seen from speculative execution, then we later on still want the dead code elimination to kick in in order to sanitize these instructions with jmp-1s, and ii) to ensure that paths walked in the non-speculative domain are not pruned from earlier walks of paths walked in the speculative domain. Additionally, for robustness, we mark the registers which have been part of the conditional as unknown in the speculative path given there should be no assumptions made on their content.  The fix in here mitigates type confusion attacks described earlier due to i) all code paths in the BPF program being explored and ii) existing verifier logic already ensuring that given memory access instruction references one specific data structure.  An alternative to this fix that has also been looked at in this scope was to mark aux->alu_state at the jump instruction with a BPF_JMP_TAKEN state as well as direction encoding (always-goto, always-fallthrough, unknown), such that mixing of different always-* directions themselves as well as mixing of always-* with unknown directions would cause a program rejection by the verifier, e.g. programs with constructs like 'if ([...]) { x = 0; } else { x = 1; }' with subsequent 'if (x == 1) { [...] }'. For unprivileged, this would result in only single direction always-* taken paths, and unknown taken paths being allowed, such that the former could be patched from a conditional jump to an unconditional jump (ja). Compared to this approach here, it would have two downsides: i) valid programs that otherwise are not performing any pointer arithmetic, etc, would potentially be rejected/broken, and ii) we are required to turn off path pruning for unprivileged, where both can be avoided in this work through pushing the invalid branch to the verification stack.  The issue was originally discovered by Adam and Ofek, and later independently discovered and reported as a result of Benedict and Piotr's research work. ",
        "func_before": "static int sanitize_ptr_alu(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_insn *insn,\n\t\t\t    const struct bpf_reg_state *ptr_reg,\n\t\t\t    const struct bpf_reg_state *off_reg,\n\t\t\t    struct bpf_reg_state *dst_reg,\n\t\t\t    struct bpf_sanitize_info *info,\n\t\t\t    const bool commit_window)\n{\n\tstruct bpf_insn_aux_data *aux = commit_window ? cur_aux(env) : &info->aux;\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tbool off_is_imm = tnum_is_const(off_reg->var_off);\n\tbool off_is_neg = off_reg->smin_value < 0;\n\tbool ptr_is_dst_reg = ptr_reg == dst_reg;\n\tu8 opcode = BPF_OP(insn->code);\n\tu32 alu_state, alu_limit;\n\tstruct bpf_reg_state tmp;\n\tbool ret;\n\tint err;\n\n\tif (can_skip_alu_sanitation(env, insn))\n\t\treturn 0;\n\n\t/* We already marked aux for masking from non-speculative\n\t * paths, thus we got here in the first place. We only care\n\t * to explore bad access from here.\n\t */\n\tif (vstate->speculative)\n\t\tgoto do_sim;\n\n\tif (!commit_window) {\n\t\tif (!tnum_is_const(off_reg->var_off) &&\n\t\t    (off_reg->smin_value < 0) != (off_reg->smax_value < 0))\n\t\t\treturn REASON_BOUNDS;\n\n\t\tinfo->mask_to_left = (opcode == BPF_ADD &&  off_is_neg) ||\n\t\t\t\t     (opcode == BPF_SUB && !off_is_neg);\n\t}\n\n\terr = retrieve_ptr_limit(ptr_reg, &alu_limit, info->mask_to_left);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (commit_window) {\n\t\t/* In commit phase we narrow the masking window based on\n\t\t * the observed pointer move after the simulated operation.\n\t\t */\n\t\talu_state = info->aux.alu_state;\n\t\talu_limit = abs(info->aux.alu_limit - alu_limit);\n\t} else {\n\t\talu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;\n\t\talu_state |= off_is_imm ? BPF_ALU_IMMEDIATE : 0;\n\t\talu_state |= ptr_is_dst_reg ?\n\t\t\t     BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;\n\t}\n\n\terr = update_alu_sanitation_state(aux, alu_state, alu_limit);\n\tif (err < 0)\n\t\treturn err;\ndo_sim:\n\t/* If we're in commit phase, we're done here given we already\n\t * pushed the truncated dst_reg into the speculative verification\n\t * stack.\n\t *\n\t * Also, when register is a known constant, we rewrite register-based\n\t * operation to immediate-based, and thus do not need masking (and as\n\t * a consequence, do not need to simulate the zero-truncation either).\n\t */\n\tif (commit_window || off_is_imm)\n\t\treturn 0;\n\n\t/* Simulate and find potential out-of-bounds access under\n\t * speculative execution from truncation as a result of\n\t * masking when off was not within expected range. If off\n\t * sits in dst, then we temporarily need to move ptr there\n\t * to simulate dst (== 0) +/-= ptr. Needed, for example,\n\t * for cases where we use K-based arithmetic in one direction\n\t * and truncated reg-based in the other in order to explore\n\t * bad access.\n\t */\n\tif (!ptr_is_dst_reg) {\n\t\ttmp = *dst_reg;\n\t\t*dst_reg = *ptr_reg;\n\t}\n\tret = push_stack(env, env->insn_idx + 1, env->insn_idx, true);\n\tif (!ptr_is_dst_reg && ret)\n\t\t*dst_reg = tmp;\n\treturn !ret ? REASON_STACK : 0;\n}",
        "func": "static int sanitize_ptr_alu(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_insn *insn,\n\t\t\t    const struct bpf_reg_state *ptr_reg,\n\t\t\t    const struct bpf_reg_state *off_reg,\n\t\t\t    struct bpf_reg_state *dst_reg,\n\t\t\t    struct bpf_sanitize_info *info,\n\t\t\t    const bool commit_window)\n{\n\tstruct bpf_insn_aux_data *aux = commit_window ? cur_aux(env) : &info->aux;\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tbool off_is_imm = tnum_is_const(off_reg->var_off);\n\tbool off_is_neg = off_reg->smin_value < 0;\n\tbool ptr_is_dst_reg = ptr_reg == dst_reg;\n\tu8 opcode = BPF_OP(insn->code);\n\tu32 alu_state, alu_limit;\n\tstruct bpf_reg_state tmp;\n\tbool ret;\n\tint err;\n\n\tif (can_skip_alu_sanitation(env, insn))\n\t\treturn 0;\n\n\t/* We already marked aux for masking from non-speculative\n\t * paths, thus we got here in the first place. We only care\n\t * to explore bad access from here.\n\t */\n\tif (vstate->speculative)\n\t\tgoto do_sim;\n\n\tif (!commit_window) {\n\t\tif (!tnum_is_const(off_reg->var_off) &&\n\t\t    (off_reg->smin_value < 0) != (off_reg->smax_value < 0))\n\t\t\treturn REASON_BOUNDS;\n\n\t\tinfo->mask_to_left = (opcode == BPF_ADD &&  off_is_neg) ||\n\t\t\t\t     (opcode == BPF_SUB && !off_is_neg);\n\t}\n\n\terr = retrieve_ptr_limit(ptr_reg, &alu_limit, info->mask_to_left);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (commit_window) {\n\t\t/* In commit phase we narrow the masking window based on\n\t\t * the observed pointer move after the simulated operation.\n\t\t */\n\t\talu_state = info->aux.alu_state;\n\t\talu_limit = abs(info->aux.alu_limit - alu_limit);\n\t} else {\n\t\talu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;\n\t\talu_state |= off_is_imm ? BPF_ALU_IMMEDIATE : 0;\n\t\talu_state |= ptr_is_dst_reg ?\n\t\t\t     BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;\n\t}\n\n\terr = update_alu_sanitation_state(aux, alu_state, alu_limit);\n\tif (err < 0)\n\t\treturn err;\ndo_sim:\n\t/* If we're in commit phase, we're done here given we already\n\t * pushed the truncated dst_reg into the speculative verification\n\t * stack.\n\t *\n\t * Also, when register is a known constant, we rewrite register-based\n\t * operation to immediate-based, and thus do not need masking (and as\n\t * a consequence, do not need to simulate the zero-truncation either).\n\t */\n\tif (commit_window || off_is_imm)\n\t\treturn 0;\n\n\t/* Simulate and find potential out-of-bounds access under\n\t * speculative execution from truncation as a result of\n\t * masking when off was not within expected range. If off\n\t * sits in dst, then we temporarily need to move ptr there\n\t * to simulate dst (== 0) +/-= ptr. Needed, for example,\n\t * for cases where we use K-based arithmetic in one direction\n\t * and truncated reg-based in the other in order to explore\n\t * bad access.\n\t */\n\tif (!ptr_is_dst_reg) {\n\t\ttmp = *dst_reg;\n\t\t*dst_reg = *ptr_reg;\n\t}\n\tret = sanitize_speculative_path(env, NULL, env->insn_idx + 1,\n\t\t\t\t\tenv->insn_idx);\n\tif (!ptr_is_dst_reg && ret)\n\t\t*dst_reg = tmp;\n\treturn !ret ? REASON_STACK : 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -81,7 +81,8 @@\n \t\ttmp = *dst_reg;\n \t\t*dst_reg = *ptr_reg;\n \t}\n-\tret = push_stack(env, env->insn_idx + 1, env->insn_idx, true);\n+\tret = sanitize_speculative_path(env, NULL, env->insn_idx + 1,\n+\t\t\t\t\tenv->insn_idx);\n \tif (!ptr_is_dst_reg && ret)\n \t\t*dst_reg = tmp;\n \treturn !ret ? REASON_STACK : 0;",
        "diff_line_info": {
            "deleted_lines": [
                "\tret = push_stack(env, env->insn_idx + 1, env->insn_idx, true);"
            ],
            "added_lines": [
                "\tret = sanitize_speculative_path(env, NULL, env->insn_idx + 1,",
                "\t\t\t\t\tenv->insn_idx);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-33624",
        "func_name": "torvalds/linux/check_cond_jmp_op",
        "description": "In kernel/bpf/verifier.c in the Linux kernel before 5.12.13, a branch can be mispredicted (e.g., because of type confusion) and consequently an unprivileged BPF program can read arbitrary memory locations via a side-channel attack, aka CID-9183671af6db.",
        "git_url": "https://github.com/torvalds/linux/commit/9183671af6dbf60a1219371d4ed73e23f43b49db",
        "commit_title": "bpf: Fix leakage under speculation on mispredicted branches",
        "commit_text": " The verifier only enumerates valid control-flow paths and skips paths that are unreachable in the non-speculative domain. And so it can miss issues under speculative execution on mispredicted branches.  For example, a type confusion has been demonstrated with the following crafted program:    // r0 = pointer to a map array entry   // r6 = pointer to readable stack slot   // r9 = scalar controlled by attacker   1: r0 = *(u64 *)(r0) // cache miss   2: if r0 != 0x0 goto line 4   3: r6 = r9   4: if r0 != 0x1 goto line 6   5: r9 = *(u8 *)(r6)   6: // leak r9  Since line 3 runs iff r0 == 0 and line 5 runs iff r0 == 1, the verifier concludes that the pointer dereference on line 5 is safe. But: if the attacker trains both the branches to fall-through, such that the following is speculatively executed ...    r6 = r9   r9 = *(u8 *)(r6)   // leak r9  ... then the program will dereference an attacker-controlled value and could leak its content under speculative execution via side-channel. This requires to mistrain the branch predictor, which can be rather tricky, because the branches are mutually exclusive. However such training can be done at congruent addresses in user space using different branches that are not mutually exclusive. That is, by training branches in user space ...    A:  if r0 != 0x0 goto line C   B:  ...   C:  if r0 != 0x0 goto line D   D:  ...  ... such that addresses A and C collide to the same CPU branch prediction entries in the PHT (pattern history table) as those of the BPF program's lines 2 and 4, respectively. A non-privileged attacker could simply brute force such collisions in the PHT until observing the attack succeeding.  Alternative methods to mistrain the branch predictor are also possible that avoid brute forcing the collisions in the PHT. A reliable attack has been demonstrated, for example, using the following crafted program:    // r0 = pointer to a [control] map array entry   // r7 = *(u64 *)(r0 + 0), training/attack phase   // r8 = *(u64 *)(r0 + 8), oob address   // [...]   // r0 = pointer to a [data] map array entry   1: if r7 == 0x3 goto line 3   2: r8 = r0   // crafted sequence of conditional jumps to separate the conditional   // branch in line 193 from the current execution flow   3: if r0 != 0x0 goto line 5   4: if r0 == 0x0 goto exit   5: if r0 != 0x0 goto line 7   6: if r0 == 0x0 goto exit   [...]   187: if r0 != 0x0 goto line 189   188: if r0 == 0x0 goto exit   // load any slowly-loaded value (due to cache miss in phase 3) ...   189: r3 = *(u64 *)(r0 + 0x1200)   // ... and turn it into known zero for verifier, while preserving slowly-   // loaded dependency when executing:   190: r3 &= 1   191: r3 &= 2   // speculatively bypassed phase dependency   192: r7 += r3   193: if r7 == 0x3 goto exit   194: r4 = *(u8 *)(r8 + 0)   // leak r4  As can be seen, in training phase (phase != 0x3), the condition in line 1 turns into false and therefore r8 with the oob address is overridden with the valid map value address, which in line 194 we can read out without issues. However, in attack phase, line 2 is skipped, and due to the cache miss in line 189 where the map value is (zeroed and later) added to the phase register, the condition in line 193 takes the fall-through path due to prior branch predictor training, where under speculation, it'll load the byte at oob address r8 (unknown scalar type at that point) which could then be leaked via side-channel.  One way to mitigate these is to 'branch off' an unreachable path, meaning, the current verification path keeps following the is_branch_taken() path and we push the other branch to the verification stack. Given this is unreachable from the non-speculative domain, this branch's vstate is explicitly marked as speculative. This is needed for two reasons: i) if this path is solely seen from speculative execution, then we later on still want the dead code elimination to kick in in order to sanitize these instructions with jmp-1s, and ii) to ensure that paths walked in the non-speculative domain are not pruned from earlier walks of paths walked in the speculative domain. Additionally, for robustness, we mark the registers which have been part of the conditional as unknown in the speculative path given there should be no assumptions made on their content.  The fix in here mitigates type confusion attacks described earlier due to i) all code paths in the BPF program being explored and ii) existing verifier logic already ensuring that given memory access instruction references one specific data structure.  An alternative to this fix that has also been looked at in this scope was to mark aux->alu_state at the jump instruction with a BPF_JMP_TAKEN state as well as direction encoding (always-goto, always-fallthrough, unknown), such that mixing of different always-* directions themselves as well as mixing of always-* with unknown directions would cause a program rejection by the verifier, e.g. programs with constructs like 'if ([...]) { x = 0; } else { x = 1; }' with subsequent 'if (x == 1) { [...] }'. For unprivileged, this would result in only single direction always-* taken paths, and unknown taken paths being allowed, such that the former could be patched from a conditional jump to an unconditional jump (ja). Compared to this approach here, it would have two downsides: i) valid programs that otherwise are not performing any pointer arithmetic, etc, would potentially be rejected/broken, and ii) we are required to turn off path pruning for unprivileged, where both can be avoided in this work through pushing the invalid branch to the verification stack.  The issue was originally discovered by Adam and Ofek, and later independently discovered and reported as a result of Benedict and Piotr's research work. ",
        "func_before": "static int check_cond_jmp_op(struct bpf_verifier_env *env,\n\t\t\t     struct bpf_insn *insn, int *insn_idx)\n{\n\tstruct bpf_verifier_state *this_branch = env->cur_state;\n\tstruct bpf_verifier_state *other_branch;\n\tstruct bpf_reg_state *regs = this_branch->frame[this_branch->curframe]->regs;\n\tstruct bpf_reg_state *dst_reg, *other_branch_regs, *src_reg = NULL;\n\tu8 opcode = BPF_OP(insn->code);\n\tbool is_jmp32;\n\tint pred = -1;\n\tint err;\n\n\t/* Only conditional jumps are expected to reach here. */\n\tif (opcode == BPF_JA || opcode > BPF_JSLE) {\n\t\tverbose(env, \"invalid BPF_JMP/JMP32 opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tif (insn->imm != 0) {\n\t\t\tverbose(env, \"BPF_JMP/JMP32 uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* check src1 operand */\n\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\tverbose(env, \"R%d pointer comparison prohibited\\n\",\n\t\t\t\tinsn->src_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tsrc_reg = &regs[insn->src_reg];\n\t} else {\n\t\tif (insn->src_reg != BPF_REG_0) {\n\t\t\tverbose(env, \"BPF_JMP/JMP32 uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* check src2 operand */\n\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tdst_reg = &regs[insn->dst_reg];\n\tis_jmp32 = BPF_CLASS(insn->code) == BPF_JMP32;\n\n\tif (BPF_SRC(insn->code) == BPF_K) {\n\t\tpred = is_branch_taken(dst_reg, insn->imm, opcode, is_jmp32);\n\t} else if (src_reg->type == SCALAR_VALUE &&\n\t\t   is_jmp32 && tnum_is_const(tnum_subreg(src_reg->var_off))) {\n\t\tpred = is_branch_taken(dst_reg,\n\t\t\t\t       tnum_subreg(src_reg->var_off).value,\n\t\t\t\t       opcode,\n\t\t\t\t       is_jmp32);\n\t} else if (src_reg->type == SCALAR_VALUE &&\n\t\t   !is_jmp32 && tnum_is_const(src_reg->var_off)) {\n\t\tpred = is_branch_taken(dst_reg,\n\t\t\t\t       src_reg->var_off.value,\n\t\t\t\t       opcode,\n\t\t\t\t       is_jmp32);\n\t} else if (reg_is_pkt_pointer_any(dst_reg) &&\n\t\t   reg_is_pkt_pointer_any(src_reg) &&\n\t\t   !is_jmp32) {\n\t\tpred = is_pkt_ptr_branch_taken(dst_reg, src_reg, opcode);\n\t}\n\n\tif (pred >= 0) {\n\t\t/* If we get here with a dst_reg pointer type it is because\n\t\t * above is_branch_taken() special cased the 0 comparison.\n\t\t */\n\t\tif (!__is_pointer_value(false, dst_reg))\n\t\t\terr = mark_chain_precision(env, insn->dst_reg);\n\t\tif (BPF_SRC(insn->code) == BPF_X && !err &&\n\t\t    !__is_pointer_value(false, src_reg))\n\t\t\terr = mark_chain_precision(env, insn->src_reg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (pred == 1) {\n\t\t/* only follow the goto, ignore fall-through */\n\t\t*insn_idx += insn->off;\n\t\treturn 0;\n\t} else if (pred == 0) {\n\t\t/* only follow fall-through branch, since\n\t\t * that's where the program will go\n\t\t */\n\t\treturn 0;\n\t}\n\n\tother_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx,\n\t\t\t\t  false);\n\tif (!other_branch)\n\t\treturn -EFAULT;\n\tother_branch_regs = other_branch->frame[other_branch->curframe]->regs;\n\n\t/* detect if we are comparing against a constant value so we can adjust\n\t * our min/max values for our dst register.\n\t * this is only legit if both are scalars (or pointers to the same\n\t * object, I suppose, but we don't support that right now), because\n\t * otherwise the different base pointers mean the offsets aren't\n\t * comparable.\n\t */\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tstruct bpf_reg_state *src_reg = &regs[insn->src_reg];\n\n\t\tif (dst_reg->type == SCALAR_VALUE &&\n\t\t    src_reg->type == SCALAR_VALUE) {\n\t\t\tif (tnum_is_const(src_reg->var_off) ||\n\t\t\t    (is_jmp32 &&\n\t\t\t     tnum_is_const(tnum_subreg(src_reg->var_off))))\n\t\t\t\treg_set_min_max(&other_branch_regs[insn->dst_reg],\n\t\t\t\t\t\tdst_reg,\n\t\t\t\t\t\tsrc_reg->var_off.value,\n\t\t\t\t\t\ttnum_subreg(src_reg->var_off).value,\n\t\t\t\t\t\topcode, is_jmp32);\n\t\t\telse if (tnum_is_const(dst_reg->var_off) ||\n\t\t\t\t (is_jmp32 &&\n\t\t\t\t  tnum_is_const(tnum_subreg(dst_reg->var_off))))\n\t\t\t\treg_set_min_max_inv(&other_branch_regs[insn->src_reg],\n\t\t\t\t\t\t    src_reg,\n\t\t\t\t\t\t    dst_reg->var_off.value,\n\t\t\t\t\t\t    tnum_subreg(dst_reg->var_off).value,\n\t\t\t\t\t\t    opcode, is_jmp32);\n\t\t\telse if (!is_jmp32 &&\n\t\t\t\t (opcode == BPF_JEQ || opcode == BPF_JNE))\n\t\t\t\t/* Comparing for equality, we can combine knowledge */\n\t\t\t\treg_combine_min_max(&other_branch_regs[insn->src_reg],\n\t\t\t\t\t\t    &other_branch_regs[insn->dst_reg],\n\t\t\t\t\t\t    src_reg, dst_reg, opcode);\n\t\t\tif (src_reg->id &&\n\t\t\t    !WARN_ON_ONCE(src_reg->id != other_branch_regs[insn->src_reg].id)) {\n\t\t\t\tfind_equal_scalars(this_branch, src_reg);\n\t\t\t\tfind_equal_scalars(other_branch, &other_branch_regs[insn->src_reg]);\n\t\t\t}\n\n\t\t}\n\t} else if (dst_reg->type == SCALAR_VALUE) {\n\t\treg_set_min_max(&other_branch_regs[insn->dst_reg],\n\t\t\t\t\tdst_reg, insn->imm, (u32)insn->imm,\n\t\t\t\t\topcode, is_jmp32);\n\t}\n\n\tif (dst_reg->type == SCALAR_VALUE && dst_reg->id &&\n\t    !WARN_ON_ONCE(dst_reg->id != other_branch_regs[insn->dst_reg].id)) {\n\t\tfind_equal_scalars(this_branch, dst_reg);\n\t\tfind_equal_scalars(other_branch, &other_branch_regs[insn->dst_reg]);\n\t}\n\n\t/* detect if R == 0 where R is returned from bpf_map_lookup_elem().\n\t * NOTE: these optimizations below are related with pointer comparison\n\t *       which will never be JMP32.\n\t */\n\tif (!is_jmp32 && BPF_SRC(insn->code) == BPF_K &&\n\t    insn->imm == 0 && (opcode == BPF_JEQ || opcode == BPF_JNE) &&\n\t    reg_type_may_be_null(dst_reg->type)) {\n\t\t/* Mark all identical registers in each branch as either\n\t\t * safe or unknown depending R == 0 or R != 0 conditional.\n\t\t */\n\t\tmark_ptr_or_null_regs(this_branch, insn->dst_reg,\n\t\t\t\t      opcode == BPF_JNE);\n\t\tmark_ptr_or_null_regs(other_branch, insn->dst_reg,\n\t\t\t\t      opcode == BPF_JEQ);\n\t} else if (!try_match_pkt_pointers(insn, dst_reg, &regs[insn->src_reg],\n\t\t\t\t\t   this_branch, other_branch) &&\n\t\t   is_pointer_value(env, insn->dst_reg)) {\n\t\tverbose(env, \"R%d pointer comparison prohibited\\n\",\n\t\t\tinsn->dst_reg);\n\t\treturn -EACCES;\n\t}\n\tif (env->log.level & BPF_LOG_LEVEL)\n\t\tprint_verifier_state(env, this_branch->frame[this_branch->curframe]);\n\treturn 0;\n}",
        "func": "static int check_cond_jmp_op(struct bpf_verifier_env *env,\n\t\t\t     struct bpf_insn *insn, int *insn_idx)\n{\n\tstruct bpf_verifier_state *this_branch = env->cur_state;\n\tstruct bpf_verifier_state *other_branch;\n\tstruct bpf_reg_state *regs = this_branch->frame[this_branch->curframe]->regs;\n\tstruct bpf_reg_state *dst_reg, *other_branch_regs, *src_reg = NULL;\n\tu8 opcode = BPF_OP(insn->code);\n\tbool is_jmp32;\n\tint pred = -1;\n\tint err;\n\n\t/* Only conditional jumps are expected to reach here. */\n\tif (opcode == BPF_JA || opcode > BPF_JSLE) {\n\t\tverbose(env, \"invalid BPF_JMP/JMP32 opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tif (insn->imm != 0) {\n\t\t\tverbose(env, \"BPF_JMP/JMP32 uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* check src1 operand */\n\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\tverbose(env, \"R%d pointer comparison prohibited\\n\",\n\t\t\t\tinsn->src_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tsrc_reg = &regs[insn->src_reg];\n\t} else {\n\t\tif (insn->src_reg != BPF_REG_0) {\n\t\t\tverbose(env, \"BPF_JMP/JMP32 uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* check src2 operand */\n\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\tif (err)\n\t\treturn err;\n\n\tdst_reg = &regs[insn->dst_reg];\n\tis_jmp32 = BPF_CLASS(insn->code) == BPF_JMP32;\n\n\tif (BPF_SRC(insn->code) == BPF_K) {\n\t\tpred = is_branch_taken(dst_reg, insn->imm, opcode, is_jmp32);\n\t} else if (src_reg->type == SCALAR_VALUE &&\n\t\t   is_jmp32 && tnum_is_const(tnum_subreg(src_reg->var_off))) {\n\t\tpred = is_branch_taken(dst_reg,\n\t\t\t\t       tnum_subreg(src_reg->var_off).value,\n\t\t\t\t       opcode,\n\t\t\t\t       is_jmp32);\n\t} else if (src_reg->type == SCALAR_VALUE &&\n\t\t   !is_jmp32 && tnum_is_const(src_reg->var_off)) {\n\t\tpred = is_branch_taken(dst_reg,\n\t\t\t\t       src_reg->var_off.value,\n\t\t\t\t       opcode,\n\t\t\t\t       is_jmp32);\n\t} else if (reg_is_pkt_pointer_any(dst_reg) &&\n\t\t   reg_is_pkt_pointer_any(src_reg) &&\n\t\t   !is_jmp32) {\n\t\tpred = is_pkt_ptr_branch_taken(dst_reg, src_reg, opcode);\n\t}\n\n\tif (pred >= 0) {\n\t\t/* If we get here with a dst_reg pointer type it is because\n\t\t * above is_branch_taken() special cased the 0 comparison.\n\t\t */\n\t\tif (!__is_pointer_value(false, dst_reg))\n\t\t\terr = mark_chain_precision(env, insn->dst_reg);\n\t\tif (BPF_SRC(insn->code) == BPF_X && !err &&\n\t\t    !__is_pointer_value(false, src_reg))\n\t\t\terr = mark_chain_precision(env, insn->src_reg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (pred == 1) {\n\t\t/* Only follow the goto, ignore fall-through. If needed, push\n\t\t * the fall-through branch for simulation under speculative\n\t\t * execution.\n\t\t */\n\t\tif (!env->bypass_spec_v1 &&\n\t\t    !sanitize_speculative_path(env, insn, *insn_idx + 1,\n\t\t\t\t\t       *insn_idx))\n\t\t\treturn -EFAULT;\n\t\t*insn_idx += insn->off;\n\t\treturn 0;\n\t} else if (pred == 0) {\n\t\t/* Only follow the fall-through branch, since that's where the\n\t\t * program will go. If needed, push the goto branch for\n\t\t * simulation under speculative execution.\n\t\t */\n\t\tif (!env->bypass_spec_v1 &&\n\t\t    !sanitize_speculative_path(env, insn,\n\t\t\t\t\t       *insn_idx + insn->off + 1,\n\t\t\t\t\t       *insn_idx))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tother_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx,\n\t\t\t\t  false);\n\tif (!other_branch)\n\t\treturn -EFAULT;\n\tother_branch_regs = other_branch->frame[other_branch->curframe]->regs;\n\n\t/* detect if we are comparing against a constant value so we can adjust\n\t * our min/max values for our dst register.\n\t * this is only legit if both are scalars (or pointers to the same\n\t * object, I suppose, but we don't support that right now), because\n\t * otherwise the different base pointers mean the offsets aren't\n\t * comparable.\n\t */\n\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\tstruct bpf_reg_state *src_reg = &regs[insn->src_reg];\n\n\t\tif (dst_reg->type == SCALAR_VALUE &&\n\t\t    src_reg->type == SCALAR_VALUE) {\n\t\t\tif (tnum_is_const(src_reg->var_off) ||\n\t\t\t    (is_jmp32 &&\n\t\t\t     tnum_is_const(tnum_subreg(src_reg->var_off))))\n\t\t\t\treg_set_min_max(&other_branch_regs[insn->dst_reg],\n\t\t\t\t\t\tdst_reg,\n\t\t\t\t\t\tsrc_reg->var_off.value,\n\t\t\t\t\t\ttnum_subreg(src_reg->var_off).value,\n\t\t\t\t\t\topcode, is_jmp32);\n\t\t\telse if (tnum_is_const(dst_reg->var_off) ||\n\t\t\t\t (is_jmp32 &&\n\t\t\t\t  tnum_is_const(tnum_subreg(dst_reg->var_off))))\n\t\t\t\treg_set_min_max_inv(&other_branch_regs[insn->src_reg],\n\t\t\t\t\t\t    src_reg,\n\t\t\t\t\t\t    dst_reg->var_off.value,\n\t\t\t\t\t\t    tnum_subreg(dst_reg->var_off).value,\n\t\t\t\t\t\t    opcode, is_jmp32);\n\t\t\telse if (!is_jmp32 &&\n\t\t\t\t (opcode == BPF_JEQ || opcode == BPF_JNE))\n\t\t\t\t/* Comparing for equality, we can combine knowledge */\n\t\t\t\treg_combine_min_max(&other_branch_regs[insn->src_reg],\n\t\t\t\t\t\t    &other_branch_regs[insn->dst_reg],\n\t\t\t\t\t\t    src_reg, dst_reg, opcode);\n\t\t\tif (src_reg->id &&\n\t\t\t    !WARN_ON_ONCE(src_reg->id != other_branch_regs[insn->src_reg].id)) {\n\t\t\t\tfind_equal_scalars(this_branch, src_reg);\n\t\t\t\tfind_equal_scalars(other_branch, &other_branch_regs[insn->src_reg]);\n\t\t\t}\n\n\t\t}\n\t} else if (dst_reg->type == SCALAR_VALUE) {\n\t\treg_set_min_max(&other_branch_regs[insn->dst_reg],\n\t\t\t\t\tdst_reg, insn->imm, (u32)insn->imm,\n\t\t\t\t\topcode, is_jmp32);\n\t}\n\n\tif (dst_reg->type == SCALAR_VALUE && dst_reg->id &&\n\t    !WARN_ON_ONCE(dst_reg->id != other_branch_regs[insn->dst_reg].id)) {\n\t\tfind_equal_scalars(this_branch, dst_reg);\n\t\tfind_equal_scalars(other_branch, &other_branch_regs[insn->dst_reg]);\n\t}\n\n\t/* detect if R == 0 where R is returned from bpf_map_lookup_elem().\n\t * NOTE: these optimizations below are related with pointer comparison\n\t *       which will never be JMP32.\n\t */\n\tif (!is_jmp32 && BPF_SRC(insn->code) == BPF_K &&\n\t    insn->imm == 0 && (opcode == BPF_JEQ || opcode == BPF_JNE) &&\n\t    reg_type_may_be_null(dst_reg->type)) {\n\t\t/* Mark all identical registers in each branch as either\n\t\t * safe or unknown depending R == 0 or R != 0 conditional.\n\t\t */\n\t\tmark_ptr_or_null_regs(this_branch, insn->dst_reg,\n\t\t\t\t      opcode == BPF_JNE);\n\t\tmark_ptr_or_null_regs(other_branch, insn->dst_reg,\n\t\t\t\t      opcode == BPF_JEQ);\n\t} else if (!try_match_pkt_pointers(insn, dst_reg, &regs[insn->src_reg],\n\t\t\t\t\t   this_branch, other_branch) &&\n\t\t   is_pointer_value(env, insn->dst_reg)) {\n\t\tverbose(env, \"R%d pointer comparison prohibited\\n\",\n\t\t\tinsn->dst_reg);\n\t\treturn -EACCES;\n\t}\n\tif (env->log.level & BPF_LOG_LEVEL)\n\t\tprint_verifier_state(env, this_branch->frame[this_branch->curframe]);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -80,14 +80,28 @@\n \t\tif (err)\n \t\t\treturn err;\n \t}\n+\n \tif (pred == 1) {\n-\t\t/* only follow the goto, ignore fall-through */\n+\t\t/* Only follow the goto, ignore fall-through. If needed, push\n+\t\t * the fall-through branch for simulation under speculative\n+\t\t * execution.\n+\t\t */\n+\t\tif (!env->bypass_spec_v1 &&\n+\t\t    !sanitize_speculative_path(env, insn, *insn_idx + 1,\n+\t\t\t\t\t       *insn_idx))\n+\t\t\treturn -EFAULT;\n \t\t*insn_idx += insn->off;\n \t\treturn 0;\n \t} else if (pred == 0) {\n-\t\t/* only follow fall-through branch, since\n-\t\t * that's where the program will go\n+\t\t/* Only follow the fall-through branch, since that's where the\n+\t\t * program will go. If needed, push the goto branch for\n+\t\t * simulation under speculative execution.\n \t\t */\n+\t\tif (!env->bypass_spec_v1 &&\n+\t\t    !sanitize_speculative_path(env, insn,\n+\t\t\t\t\t       *insn_idx + insn->off + 1,\n+\t\t\t\t\t       *insn_idx))\n+\t\t\treturn -EFAULT;\n \t\treturn 0;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t/* only follow the goto, ignore fall-through */",
                "\t\t/* only follow fall-through branch, since",
                "\t\t * that's where the program will go"
            ],
            "added_lines": [
                "",
                "\t\t/* Only follow the goto, ignore fall-through. If needed, push",
                "\t\t * the fall-through branch for simulation under speculative",
                "\t\t * execution.",
                "\t\t */",
                "\t\tif (!env->bypass_spec_v1 &&",
                "\t\t    !sanitize_speculative_path(env, insn, *insn_idx + 1,",
                "\t\t\t\t\t       *insn_idx))",
                "\t\t\treturn -EFAULT;",
                "\t\t/* Only follow the fall-through branch, since that's where the",
                "\t\t * program will go. If needed, push the goto branch for",
                "\t\t * simulation under speculative execution.",
                "\t\tif (!env->bypass_spec_v1 &&",
                "\t\t    !sanitize_speculative_path(env, insn,",
                "\t\t\t\t\t       *insn_idx + insn->off + 1,",
                "\t\t\t\t\t       *insn_idx))",
                "\t\t\treturn -EFAULT;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-1075",
        "func_name": "torvalds/linux/tls_is_tx_ready",
        "description": "A flaw was found in the Linux Kernel. The tls_is_tx_ready() incorrectly checks for list emptiness, potentially accessing a type confused entry to the list_head, leaking the last byte of the confused field that overlaps with rec->tx_ready.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/?h=ffe2a22562444720b05bdfeb999c03e810d84cbb",
        "commit_title": "tls_is_tx_ready() checks that list_first_entry() does not return NULL.",
        "commit_text": "This condition can never happen. For empty lists, list_first_entry() returns the list_entry() of the head, which is a type confusion. Use list_first_entry_or_null() which returns NULL in case of empty lists.  Link: https://lore.kernel.org/r/20230128-list-entry-null-check-tls-v1-1-525bbfe6f0d0@diag.uniroma1.it ",
        "func_before": "static bool tls_is_tx_ready(struct tls_sw_context_tx *ctx)\n{\n\tstruct tls_rec *rec;\n\n\trec = list_first_entry(&ctx->tx_list, struct tls_rec, list);\n\tif (!rec)\n\t\treturn false;\n\n\treturn READ_ONCE(rec->tx_ready);\n}",
        "func": "static bool tls_is_tx_ready(struct tls_sw_context_tx *ctx)\n{\n\tstruct tls_rec *rec;\n\n\trec = list_first_entry_or_null(&ctx->tx_list, struct tls_rec, list);\n\tif (!rec)\n\t\treturn false;\n\n\treturn READ_ONCE(rec->tx_ready);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n {\n \tstruct tls_rec *rec;\n \n-\trec = list_first_entry(&ctx->tx_list, struct tls_rec, list);\n+\trec = list_first_entry_or_null(&ctx->tx_list, struct tls_rec, list);\n \tif (!rec)\n \t\treturn false;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\trec = list_first_entry(&ctx->tx_list, struct tls_rec, list);"
            ],
            "added_lines": [
                "\trec = list_first_entry_or_null(&ctx->tx_list, struct tls_rec, list);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-1076",
        "func_name": "torvalds/linux/tap_open",
        "description": "A flaw was found in the Linux Kernel. The tun/tap sockets have their socket UID hardcoded to 0 due to a type confusion in their initialization function. While it will be often correct, as tuntap devices require CAP_NET_ADMIN, it may not always be the case, e.g., a non-root user only having that capability. This would make tun/tap sockets being incorrectly treated in filtering/routing decisions, possibly bypassing network filters.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/?h=66b2c338adce580dfce2199591e65e2bab889cff",
        "commit_title": "sock_init_data() assumes that the `struct socket` passed in input is",
        "commit_text": "contained in a `struct socket_alloc` allocated with sock_alloc(). However, tap_open() passes a `struct socket` embedded in a `struct tap_queue` allocated with sk_alloc(). This causes a type confusion when issuing a container_of() with SOCK_INODE() in sock_init_data() which results in assigning a wrong sk_uid to the `struct sock` in input. On default configuration, the type confused field overlaps with padding bytes between `int vnet_hdr_sz` and `struct tap_dev __rcu *tap` in `struct tap_queue`, which makes the uid of all tap sockets 0, i.e., the root one. Fix the assignment by using sock_init_data_uid().  ",
        "func_before": "static int tap_open(struct inode *inode, struct file *file)\n{\n\tstruct net *net = current->nsproxy->net_ns;\n\tstruct tap_dev *tap;\n\tstruct tap_queue *q;\n\tint err = -ENODEV;\n\n\trtnl_lock();\n\ttap = dev_get_by_tap_file(imajor(inode), iminor(inode));\n\tif (!tap)\n\t\tgoto err;\n\n\terr = -ENOMEM;\n\tq = (struct tap_queue *)sk_alloc(net, AF_UNSPEC, GFP_KERNEL,\n\t\t\t\t\t     &tap_proto, 0);\n\tif (!q)\n\t\tgoto err;\n\tif (ptr_ring_init(&q->ring, tap->dev->tx_queue_len, GFP_KERNEL)) {\n\t\tsk_free(&q->sk);\n\t\tgoto err;\n\t}\n\n\tinit_waitqueue_head(&q->sock.wq.wait);\n\tq->sock.type = SOCK_RAW;\n\tq->sock.state = SS_CONNECTED;\n\tq->sock.file = file;\n\tq->sock.ops = &tap_socket_ops;\n\tsock_init_data(&q->sock, &q->sk);\n\tq->sk.sk_write_space = tap_sock_write_space;\n\tq->sk.sk_destruct = tap_sock_destruct;\n\tq->flags = IFF_VNET_HDR | IFF_NO_PI | IFF_TAP;\n\tq->vnet_hdr_sz = sizeof(struct virtio_net_hdr);\n\n\t/*\n\t * so far only KVM virtio_net uses tap, enable zero copy between\n\t * guest kernel and host kernel when lower device supports zerocopy\n\t *\n\t * The macvlan supports zerocopy iff the lower device supports zero\n\t * copy so we don't have to look at the lower device directly.\n\t */\n\tif ((tap->dev->features & NETIF_F_HIGHDMA) && (tap->dev->features & NETIF_F_SG))\n\t\tsock_set_flag(&q->sk, SOCK_ZEROCOPY);\n\n\terr = tap_set_queue(tap, file, q);\n\tif (err) {\n\t\t/* tap_sock_destruct() will take care of freeing ptr_ring */\n\t\tgoto err_put;\n\t}\n\n\tdev_put(tap->dev);\n\n\trtnl_unlock();\n\treturn err;\n\nerr_put:\n\tsock_put(&q->sk);\nerr:\n\tif (tap)\n\t\tdev_put(tap->dev);\n\n\trtnl_unlock();\n\treturn err;\n}",
        "func": "static int tap_open(struct inode *inode, struct file *file)\n{\n\tstruct net *net = current->nsproxy->net_ns;\n\tstruct tap_dev *tap;\n\tstruct tap_queue *q;\n\tint err = -ENODEV;\n\n\trtnl_lock();\n\ttap = dev_get_by_tap_file(imajor(inode), iminor(inode));\n\tif (!tap)\n\t\tgoto err;\n\n\terr = -ENOMEM;\n\tq = (struct tap_queue *)sk_alloc(net, AF_UNSPEC, GFP_KERNEL,\n\t\t\t\t\t     &tap_proto, 0);\n\tif (!q)\n\t\tgoto err;\n\tif (ptr_ring_init(&q->ring, tap->dev->tx_queue_len, GFP_KERNEL)) {\n\t\tsk_free(&q->sk);\n\t\tgoto err;\n\t}\n\n\tinit_waitqueue_head(&q->sock.wq.wait);\n\tq->sock.type = SOCK_RAW;\n\tq->sock.state = SS_CONNECTED;\n\tq->sock.file = file;\n\tq->sock.ops = &tap_socket_ops;\n\tsock_init_data_uid(&q->sock, &q->sk, inode->i_uid);\n\tq->sk.sk_write_space = tap_sock_write_space;\n\tq->sk.sk_destruct = tap_sock_destruct;\n\tq->flags = IFF_VNET_HDR | IFF_NO_PI | IFF_TAP;\n\tq->vnet_hdr_sz = sizeof(struct virtio_net_hdr);\n\n\t/*\n\t * so far only KVM virtio_net uses tap, enable zero copy between\n\t * guest kernel and host kernel when lower device supports zerocopy\n\t *\n\t * The macvlan supports zerocopy iff the lower device supports zero\n\t * copy so we don't have to look at the lower device directly.\n\t */\n\tif ((tap->dev->features & NETIF_F_HIGHDMA) && (tap->dev->features & NETIF_F_SG))\n\t\tsock_set_flag(&q->sk, SOCK_ZEROCOPY);\n\n\terr = tap_set_queue(tap, file, q);\n\tif (err) {\n\t\t/* tap_sock_destruct() will take care of freeing ptr_ring */\n\t\tgoto err_put;\n\t}\n\n\tdev_put(tap->dev);\n\n\trtnl_unlock();\n\treturn err;\n\nerr_put:\n\tsock_put(&q->sk);\nerr:\n\tif (tap)\n\t\tdev_put(tap->dev);\n\n\trtnl_unlock();\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,7 @@\n \tq->sock.state = SS_CONNECTED;\n \tq->sock.file = file;\n \tq->sock.ops = &tap_socket_ops;\n-\tsock_init_data(&q->sock, &q->sk);\n+\tsock_init_data_uid(&q->sock, &q->sk, inode->i_uid);\n \tq->sk.sk_write_space = tap_sock_write_space;\n \tq->sk.sk_destruct = tap_sock_destruct;\n \tq->flags = IFF_VNET_HDR | IFF_NO_PI | IFF_TAP;",
        "diff_line_info": {
            "deleted_lines": [
                "\tsock_init_data(&q->sock, &q->sk);"
            ],
            "added_lines": [
                "\tsock_init_data_uid(&q->sock, &q->sk, inode->i_uid);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-1076",
        "func_name": "torvalds/linux/tun_chr_open",
        "description": "A flaw was found in the Linux Kernel. The tun/tap sockets have their socket UID hardcoded to 0 due to a type confusion in their initialization function. While it will be often correct, as tuntap devices require CAP_NET_ADMIN, it may not always be the case, e.g., a non-root user only having that capability. This would make tun/tap sockets being incorrectly treated in filtering/routing decisions, possibly bypassing network filters.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/?h=a096ccca6e503a5c575717ff8a36ace27510ab0a",
        "commit_title": "sock_init_data() assumes that the `struct socket` passed in input is",
        "commit_text": "contained in a `struct socket_alloc` allocated with sock_alloc(). However, tun_chr_open() passes a `struct socket` embedded in a `struct tun_file` allocated with sk_alloc(). This causes a type confusion when issuing a container_of() with SOCK_INODE() in sock_init_data() which results in assigning a wrong sk_uid to the `struct sock` in input. On default configuration, the type confused field overlaps with the high 4 bytes of `struct tun_struct __rcu *tun` of `struct tun_file`, NULL at the time of call, which makes the uid of all tun sockets 0, i.e., the root one. Fix the assignment by using sock_init_data_uid().  ",
        "func_before": "static int tun_chr_open(struct inode *inode, struct file * file)\n{\n\tstruct net *net = current->nsproxy->net_ns;\n\tstruct tun_file *tfile;\n\n\ttfile = (struct tun_file *)sk_alloc(net, AF_UNSPEC, GFP_KERNEL,\n\t\t\t\t\t    &tun_proto, 0);\n\tif (!tfile)\n\t\treturn -ENOMEM;\n\tif (ptr_ring_init(&tfile->tx_ring, 0, GFP_KERNEL)) {\n\t\tsk_free(&tfile->sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&tfile->napi_mutex);\n\tRCU_INIT_POINTER(tfile->tun, NULL);\n\ttfile->flags = 0;\n\ttfile->ifindex = 0;\n\n\tinit_waitqueue_head(&tfile->socket.wq.wait);\n\n\ttfile->socket.file = file;\n\ttfile->socket.ops = &tun_socket_ops;\n\n\tsock_init_data(&tfile->socket, &tfile->sk);\n\n\ttfile->sk.sk_write_space = tun_sock_write_space;\n\ttfile->sk.sk_sndbuf = INT_MAX;\n\n\tfile->private_data = tfile;\n\tINIT_LIST_HEAD(&tfile->next);\n\n\tsock_set_flag(&tfile->sk, SOCK_ZEROCOPY);\n\n\treturn 0;\n}",
        "func": "static int tun_chr_open(struct inode *inode, struct file * file)\n{\n\tstruct net *net = current->nsproxy->net_ns;\n\tstruct tun_file *tfile;\n\n\ttfile = (struct tun_file *)sk_alloc(net, AF_UNSPEC, GFP_KERNEL,\n\t\t\t\t\t    &tun_proto, 0);\n\tif (!tfile)\n\t\treturn -ENOMEM;\n\tif (ptr_ring_init(&tfile->tx_ring, 0, GFP_KERNEL)) {\n\t\tsk_free(&tfile->sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&tfile->napi_mutex);\n\tRCU_INIT_POINTER(tfile->tun, NULL);\n\ttfile->flags = 0;\n\ttfile->ifindex = 0;\n\n\tinit_waitqueue_head(&tfile->socket.wq.wait);\n\n\ttfile->socket.file = file;\n\ttfile->socket.ops = &tun_socket_ops;\n\n\tsock_init_data_uid(&tfile->socket, &tfile->sk, inode->i_uid);\n\n\ttfile->sk.sk_write_space = tun_sock_write_space;\n\ttfile->sk.sk_sndbuf = INT_MAX;\n\n\tfile->private_data = tfile;\n\tINIT_LIST_HEAD(&tfile->next);\n\n\tsock_set_flag(&tfile->sk, SOCK_ZEROCOPY);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,7 +22,7 @@\n \ttfile->socket.file = file;\n \ttfile->socket.ops = &tun_socket_ops;\n \n-\tsock_init_data(&tfile->socket, &tfile->sk);\n+\tsock_init_data_uid(&tfile->socket, &tfile->sk, inode->i_uid);\n \n \ttfile->sk.sk_write_space = tun_sock_write_space;\n \ttfile->sk.sk_sndbuf = INT_MAX;",
        "diff_line_info": {
            "deleted_lines": [
                "\tsock_init_data(&tfile->socket, &tfile->sk);"
            ],
            "added_lines": [
                "\tsock_init_data_uid(&tfile->socket, &tfile->sk, inode->i_uid);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-1077",
        "func_name": "torvalds/linux/_pick_next_task_rt",
        "description": "In the Linux kernel, pick_next_rt_entity() may return a type confused entry, not detected by the BUG_ON condition, as the confused entry will not be NULL, but list_head.The buggy error condition would lead to a type confused entry with the list head,which would then be used as a type confused sched_rt_entity,causing memory corruption.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/?h=7c4a5b89a0b5a57a64b601775b296abf77a9fe97",
        "commit_title": "Commit 326587b84078 (\"sched: fix goto retry in pick_next_task_rt()\")",
        "commit_text": "removed any path which could make pick_next_rt_entity() return NULL. However, BUG_ON(!rt_se) in _pick_next_task_rt() (the only caller of pick_next_rt_entity()) still checks the error condition, which can never happen, since list_entry() never returns NULL. Remove the BUG_ON check, and instead emit a warning in the only possible error condition here: the queue being empty which should never happen.  Link: https://lore.kernel.org/r/20230128-list-entry-null-check-sched-v3-1-b1a71bd1ac6b@diag.uniroma1.it ",
        "func_before": "static struct task_struct *_pick_next_task_rt(struct rq *rq)\n{\n\tstruct sched_rt_entity *rt_se;\n\tstruct rt_rq *rt_rq  = &rq->rt;\n\n\tdo {\n\t\trt_se = pick_next_rt_entity(rt_rq);\n\t\tBUG_ON(!rt_se);\n\t\trt_rq = group_rt_rq(rt_se);\n\t} while (rt_rq);\n\n\treturn rt_task_of(rt_se);\n}",
        "func": "static struct task_struct *_pick_next_task_rt(struct rq *rq)\n{\n\tstruct sched_rt_entity *rt_se;\n\tstruct rt_rq *rt_rq  = &rq->rt;\n\n\tdo {\n\t\trt_se = pick_next_rt_entity(rt_rq);\n\t\tif (unlikely(!rt_se))\n\t\t\treturn NULL;\n\t\trt_rq = group_rt_rq(rt_se);\n\t} while (rt_rq);\n\n\treturn rt_task_of(rt_se);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,8 @@\n \n \tdo {\n \t\trt_se = pick_next_rt_entity(rt_rq);\n-\t\tBUG_ON(!rt_se);\n+\t\tif (unlikely(!rt_se))\n+\t\t\treturn NULL;\n \t\trt_rq = group_rt_rq(rt_se);\n \t} while (rt_rq);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tBUG_ON(!rt_se);"
            ],
            "added_lines": [
                "\t\tif (unlikely(!rt_se))",
                "\t\t\treturn NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-1077",
        "func_name": "torvalds/linux/pick_next_rt_entity",
        "description": "In the Linux kernel, pick_next_rt_entity() may return a type confused entry, not detected by the BUG_ON condition, as the confused entry will not be NULL, but list_head.The buggy error condition would lead to a type confused entry with the list head,which would then be used as a type confused sched_rt_entity,causing memory corruption.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/?h=7c4a5b89a0b5a57a64b601775b296abf77a9fe97",
        "commit_title": "Commit 326587b84078 (\"sched: fix goto retry in pick_next_task_rt()\")",
        "commit_text": "removed any path which could make pick_next_rt_entity() return NULL. However, BUG_ON(!rt_se) in _pick_next_task_rt() (the only caller of pick_next_rt_entity()) still checks the error condition, which can never happen, since list_entry() never returns NULL. Remove the BUG_ON check, and instead emit a warning in the only possible error condition here: the queue being empty which should never happen.  Link: https://lore.kernel.org/r/20230128-list-entry-null-check-sched-v3-1-b1a71bd1ac6b@diag.uniroma1.it ",
        "func_before": "static struct sched_rt_entity *pick_next_rt_entity(struct rt_rq *rt_rq)\n{\n\tstruct rt_prio_array *array = &rt_rq->active;\n\tstruct sched_rt_entity *next = NULL;\n\tstruct list_head *queue;\n\tint idx;\n\n\tidx = sched_find_first_bit(array->bitmap);\n\tBUG_ON(idx >= MAX_RT_PRIO);\n\n\tqueue = array->queue + idx;\n\tnext = list_entry(queue->next, struct sched_rt_entity, run_list);\n\n\treturn next;\n}",
        "func": "static struct sched_rt_entity *pick_next_rt_entity(struct rt_rq *rt_rq)\n{\n\tstruct rt_prio_array *array = &rt_rq->active;\n\tstruct sched_rt_entity *next = NULL;\n\tstruct list_head *queue;\n\tint idx;\n\n\tidx = sched_find_first_bit(array->bitmap);\n\tBUG_ON(idx >= MAX_RT_PRIO);\n\n\tqueue = array->queue + idx;\n\tif (SCHED_WARN_ON(list_empty(queue)))\n\t\treturn NULL;\n\tnext = list_entry(queue->next, struct sched_rt_entity, run_list);\n\n\treturn next;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,6 +9,8 @@\n \tBUG_ON(idx >= MAX_RT_PRIO);\n \n \tqueue = array->queue + idx;\n+\tif (SCHED_WARN_ON(list_empty(queue)))\n+\t\treturn NULL;\n \tnext = list_entry(queue->next, struct sched_rt_entity, run_list);\n \n \treturn next;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (SCHED_WARN_ON(list_empty(queue)))",
                "\t\treturn NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-1078",
        "func_name": "torvalds/linux/rds_rm_zerocopy_callback",
        "description": "A flaw was found in the Linux Kernel in RDS (Reliable Datagram Sockets) protocol. The rds_rm_zerocopy_callback() uses list_entry() on the head of a list causing a type confusion. Local user can trigger this with rds_message_put(). Type confusion leads to `struct rds_msg_zcopy_info *info` actually points to something else that is potentially controlled by local user. It is known how to trigger this, which causes an out of bounds access, and a lock corruption.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/?h=f753a68980cf4b59a80fe677619da2b1804f526d",
        "commit_title": "rds_rm_zerocopy_callback() uses list_entry() on the head of a list",
        "commit_text": "causing a type confusion. Use list_first_entry() to actually access the first element of the rs_zcookie_queue list.  Link: https://lore.kernel.org/r/20230202-rds-zerocopy-v3-1-83b0df974f9a@diag.uniroma1.it ",
        "func_before": "static void rds_rm_zerocopy_callback(struct rds_sock *rs,\n\t\t\t\t     struct rds_znotifier *znotif)\n{\n\tstruct rds_msg_zcopy_info *info;\n\tstruct rds_msg_zcopy_queue *q;\n\tu32 cookie = znotif->z_cookie;\n\tstruct rds_zcopy_cookies *ck;\n\tstruct list_head *head;\n\tunsigned long flags;\n\n\tmm_unaccount_pinned_pages(&znotif->z_mmp);\n\tq = &rs->rs_zcookie_queue;\n\tspin_lock_irqsave(&q->lock, flags);\n\thead = &q->zcookie_head;\n\tif (!list_empty(head)) {\n\t\tinfo = list_entry(head, struct rds_msg_zcopy_info,\n\t\t\t\t  rs_zcookie_next);\n\t\tif (info && rds_zcookie_add(info, cookie)) {\n\t\t\tspin_unlock_irqrestore(&q->lock, flags);\n\t\t\tkfree(rds_info_from_znotifier(znotif));\n\t\t\t/* caller invokes rds_wake_sk_sleep() */\n\t\t\treturn;\n\t\t}\n\t}\n\n\tinfo = rds_info_from_znotifier(znotif);\n\tck = &info->zcookies;\n\tmemset(ck, 0, sizeof(*ck));\n\tWARN_ON(!rds_zcookie_add(info, cookie));\n\tlist_add_tail(&q->zcookie_head, &info->rs_zcookie_next);\n\n\tspin_unlock_irqrestore(&q->lock, flags);\n\t/* caller invokes rds_wake_sk_sleep() */\n}",
        "func": "static void rds_rm_zerocopy_callback(struct rds_sock *rs,\n\t\t\t\t     struct rds_znotifier *znotif)\n{\n\tstruct rds_msg_zcopy_info *info;\n\tstruct rds_msg_zcopy_queue *q;\n\tu32 cookie = znotif->z_cookie;\n\tstruct rds_zcopy_cookies *ck;\n\tstruct list_head *head;\n\tunsigned long flags;\n\n\tmm_unaccount_pinned_pages(&znotif->z_mmp);\n\tq = &rs->rs_zcookie_queue;\n\tspin_lock_irqsave(&q->lock, flags);\n\thead = &q->zcookie_head;\n\tif (!list_empty(head)) {\n\t\tinfo = list_first_entry(head, struct rds_msg_zcopy_info,\n\t\t\t\t\trs_zcookie_next);\n\t\tif (rds_zcookie_add(info, cookie)) {\n\t\t\tspin_unlock_irqrestore(&q->lock, flags);\n\t\t\tkfree(rds_info_from_znotifier(znotif));\n\t\t\t/* caller invokes rds_wake_sk_sleep() */\n\t\t\treturn;\n\t\t}\n\t}\n\n\tinfo = rds_info_from_znotifier(znotif);\n\tck = &info->zcookies;\n\tmemset(ck, 0, sizeof(*ck));\n\tWARN_ON(!rds_zcookie_add(info, cookie));\n\tlist_add_tail(&q->zcookie_head, &info->rs_zcookie_next);\n\n\tspin_unlock_irqrestore(&q->lock, flags);\n\t/* caller invokes rds_wake_sk_sleep() */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,9 +13,9 @@\n \tspin_lock_irqsave(&q->lock, flags);\n \thead = &q->zcookie_head;\n \tif (!list_empty(head)) {\n-\t\tinfo = list_entry(head, struct rds_msg_zcopy_info,\n-\t\t\t\t  rs_zcookie_next);\n-\t\tif (info && rds_zcookie_add(info, cookie)) {\n+\t\tinfo = list_first_entry(head, struct rds_msg_zcopy_info,\n+\t\t\t\t\trs_zcookie_next);\n+\t\tif (rds_zcookie_add(info, cookie)) {\n \t\t\tspin_unlock_irqrestore(&q->lock, flags);\n \t\t\tkfree(rds_info_from_znotifier(znotif));\n \t\t\t/* caller invokes rds_wake_sk_sleep() */",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tinfo = list_entry(head, struct rds_msg_zcopy_info,",
                "\t\t\t\t  rs_zcookie_next);",
                "\t\tif (info && rds_zcookie_add(info, cookie)) {"
            ],
            "added_lines": [
                "\t\tinfo = list_first_entry(head, struct rds_msg_zcopy_info,",
                "\t\t\t\t\trs_zcookie_next);",
                "\t\tif (rds_zcookie_add(info, cookie)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-46878",
        "func_name": "fluent/fluent-bit/flb_pack_msgpack_to_json_format",
        "description": "An issue was discovered in Treasure Data Fluent Bit 1.7.1, erroneous parsing in flb_pack_msgpack_to_json_format leads to type confusion bug that interprets whatever is on the stack as msgpack maps and arrays, leading to use-after-free. This can be used by an attacker to craft a specially craft file and trick the victim opening it using the affect software, triggering use-after-free and execute arbitrary code on the target system.",
        "git_url": "https://github.com/fluent/fluent-bit/commit/8040e0b04e48d2cf1a2853e8ac2c2561e18c4a11",
        "commit_title": "pack: fix type confusion bugs. Amongst other OSS-Fuzz 5136174263566336",
        "commit_text": "",
        "func_before": "flb_sds_t flb_pack_msgpack_to_json_format(const char *data, uint64_t bytes,\n                                          int json_format, int date_format,\n                                          flb_sds_t date_key)\n{\n    int i;\n    int len;\n    int ok = MSGPACK_UNPACK_SUCCESS;\n    int records = 0;\n    int map_size;\n    size_t off = 0;\n    char time_formatted[32];\n    size_t s;\n    flb_sds_t out_tmp;\n    flb_sds_t out_js;\n    flb_sds_t out_buf = NULL;\n    msgpack_unpacked result;\n    msgpack_object root;\n    msgpack_object map;\n    msgpack_sbuffer tmp_sbuf;\n    msgpack_packer tmp_pck;\n    msgpack_object *obj;\n    msgpack_object *k;\n    msgpack_object *v;\n    struct tm tm;\n    struct flb_time tms;\n\n    /* Iterate the original buffer and perform adjustments */\n    records = flb_mp_count(data, bytes);\n    if (records <= 0) {\n        return NULL;\n    }\n\n    /* For json lines and streams mode we need a pre-allocated buffer */\n    if (json_format == FLB_PACK_JSON_FORMAT_LINES ||\n        json_format == FLB_PACK_JSON_FORMAT_STREAM) {\n        out_buf = flb_sds_create_size(bytes + bytes / 4);\n        if (!out_buf) {\n            flb_errno();\n            return NULL;\n        }\n    }\n\n    /* Create temporary msgpack buffer */\n    msgpack_sbuffer_init(&tmp_sbuf);\n    msgpack_packer_init(&tmp_pck, &tmp_sbuf, msgpack_sbuffer_write);\n\n    /*\n     * If the format is the original msgpack style of one big array,\n     * registrate the array, otherwise is not necessary. FYI, original format:\n     *\n     * [\n     *   [timestamp, map],\n     *   [timestamp, map],\n     *   [T, M]...\n     * ]\n     */\n    if (json_format == FLB_PACK_JSON_FORMAT_JSON) {\n        msgpack_pack_array(&tmp_pck, records);\n    }\n\n    msgpack_unpacked_init(&result);\n    while (msgpack_unpack_next(&result, data, bytes, &off) == ok) {\n        /* Each array must have two entries: time and record */\n        root = result.data;\n        if (root.via.array.size != 2) {\n            continue;\n        }\n\n        /* Unpack time */\n        flb_time_pop_from_msgpack(&tms, &result, &obj);\n\n        /* Get the record/map */\n        map = root.via.array.ptr[1];\n        map_size = map.via.map.size;\n\n        if (date_key != NULL) {\n            msgpack_pack_map(&tmp_pck, map_size + 1);\n        }\n        else {\n            msgpack_pack_map(&tmp_pck, map_size);\n        }\n\n        if (date_key != NULL) {\n            /* Append date key */\n            msgpack_pack_str(&tmp_pck, flb_sds_len(date_key));\n            msgpack_pack_str_body(&tmp_pck, date_key, flb_sds_len(date_key));\n\n            /* Append date value */\n            switch (date_format) {\n            case FLB_PACK_JSON_DATE_DOUBLE:\n                msgpack_pack_double(&tmp_pck, flb_time_to_double(&tms));\n                break;\n            case FLB_PACK_JSON_DATE_ISO8601:\n            /* Format the time, use microsecond precision not nanoseconds */\n                gmtime_r(&tms.tm.tv_sec, &tm);\n                s = strftime(time_formatted, sizeof(time_formatted) - 1,\n                             FLB_PACK_JSON_DATE_ISO8601_FMT, &tm);\n\n                len = snprintf(time_formatted + s,\n                               sizeof(time_formatted) - 1 - s,\n                               \".%06\" PRIu64 \"Z\",\n                               (uint64_t) tms.tm.tv_nsec / 1000);\n                s += len;\n                msgpack_pack_str(&tmp_pck, s);\n                msgpack_pack_str_body(&tmp_pck, time_formatted, s);\n                break;\n            case FLB_PACK_JSON_DATE_EPOCH:\n                msgpack_pack_uint64(&tmp_pck, (long long unsigned)(tms.tm.tv_sec));\n                break;\n            }\n        }\n\n        /* Append remaining keys/values */\n        for (i = 0; i < map_size; i++) {\n            k = &map.via.map.ptr[i].key;\n            v = &map.via.map.ptr[i].val;\n            msgpack_pack_object(&tmp_pck, *k);\n            msgpack_pack_object(&tmp_pck, *v);\n        }\n\n        /*\n         * If the format is the original msgpack style, just continue since\n         * we don't care about separator or JSON convertion at this point.\n         */\n        if (json_format == FLB_PACK_JSON_FORMAT_JSON) {\n            continue;\n        }\n\n        /*\n         * Here we handle two types of records concatenation:\n         *\n         * FLB_PACK_JSON_FORMAT_LINES: add  breakline (\\n) after each record\n         *\n         *\n         *     {'ts':abc,'k1':1}\n         *     {'ts':abc,'k1':2}\n         *     {N}\n         *\n         * FLB_PACK_JSON_FORMAT_STREAM: no separators, e.g:\n         *\n         *     {'ts':abc,'k1':1}{'ts':abc,'k1':2}{N}\n         */\n        if (json_format == FLB_PACK_JSON_FORMAT_LINES ||\n            json_format == FLB_PACK_JSON_FORMAT_STREAM) {\n\n            /* Encode current record into JSON in a temporary variable */\n            out_js = flb_msgpack_raw_to_json_sds(tmp_sbuf.data, tmp_sbuf.size);\n            if (!out_js) {\n                msgpack_sbuffer_destroy(&tmp_sbuf);\n                flb_sds_destroy(out_buf);\n                return NULL;\n            }\n\n            /*\n             * One map record has been converted, now append it to the\n             * outgoing out_buf sds variable.\n             */\n            out_tmp = flb_sds_cat(out_buf, out_js, flb_sds_len(out_js));\n            if (!out_tmp) {\n                msgpack_sbuffer_destroy(&tmp_sbuf);\n                flb_sds_destroy(out_js);\n                flb_sds_destroy(out_buf);\n                return NULL;\n            }\n\n            /* Release temporary json sds buffer */\n            flb_sds_destroy(out_js);\n\n            /* If a realloc happened, check the returned address */\n            if (out_tmp != out_buf) {\n                out_buf = out_tmp;\n            }\n\n            /* Append the breakline only for json lines mode */\n            if (json_format == FLB_PACK_JSON_FORMAT_LINES) {\n                out_tmp = flb_sds_cat(out_buf, \"\\n\", 1);\n                if (!out_tmp) {\n                    msgpack_sbuffer_destroy(&tmp_sbuf);\n                    flb_sds_destroy(out_buf);\n                    return NULL;\n                }\n                if (out_tmp != out_buf) {\n                    out_buf = out_tmp;\n                }\n            }\n            msgpack_sbuffer_clear(&tmp_sbuf);\n        }\n    }\n\n    /* Release the unpacker */\n    msgpack_unpacked_destroy(&result);\n\n    /* Format to JSON */\n    if (json_format == FLB_PACK_JSON_FORMAT_JSON) {\n        out_buf = flb_msgpack_raw_to_json_sds(tmp_sbuf.data, tmp_sbuf.size);\n        msgpack_sbuffer_destroy(&tmp_sbuf);\n\n        if (!out_buf) {\n            return NULL;\n        }\n    }\n    else {\n        msgpack_sbuffer_destroy(&tmp_sbuf);\n    }\n\n    if (out_buf && flb_sds_len(out_buf) == 0) {\n        flb_sds_destroy(out_buf);\n        return NULL;\n    }\n\n    return out_buf;\n}",
        "func": "flb_sds_t flb_pack_msgpack_to_json_format(const char *data, uint64_t bytes,\n                                          int json_format, int date_format,\n                                          flb_sds_t date_key)\n{\n    int i;\n    int len;\n    int ok = MSGPACK_UNPACK_SUCCESS;\n    int records = 0;\n    int map_size;\n    size_t off = 0;\n    char time_formatted[32];\n    size_t s;\n    flb_sds_t out_tmp;\n    flb_sds_t out_js;\n    flb_sds_t out_buf = NULL;\n    msgpack_unpacked result;\n    msgpack_object root;\n    msgpack_object map;\n    msgpack_sbuffer tmp_sbuf;\n    msgpack_packer tmp_pck;\n    msgpack_object *obj;\n    msgpack_object *k;\n    msgpack_object *v;\n    struct tm tm;\n    struct flb_time tms;\n\n    /* Iterate the original buffer and perform adjustments */\n    records = flb_mp_count(data, bytes);\n    if (records <= 0) {\n        return NULL;\n    }\n\n    /* For json lines and streams mode we need a pre-allocated buffer */\n    if (json_format == FLB_PACK_JSON_FORMAT_LINES ||\n        json_format == FLB_PACK_JSON_FORMAT_STREAM) {\n        out_buf = flb_sds_create_size(bytes + bytes / 4);\n        if (!out_buf) {\n            flb_errno();\n            return NULL;\n        }\n    }\n\n    /* Create temporary msgpack buffer */\n    msgpack_sbuffer_init(&tmp_sbuf);\n    msgpack_packer_init(&tmp_pck, &tmp_sbuf, msgpack_sbuffer_write);\n\n    /*\n     * If the format is the original msgpack style of one big array,\n     * registrate the array, otherwise is not necessary. FYI, original format:\n     *\n     * [\n     *   [timestamp, map],\n     *   [timestamp, map],\n     *   [T, M]...\n     * ]\n     */\n    if (json_format == FLB_PACK_JSON_FORMAT_JSON) {\n        msgpack_pack_array(&tmp_pck, records);\n    }\n\n    msgpack_unpacked_init(&result);\n    while (msgpack_unpack_next(&result, data, bytes, &off) == ok) {\n        /* Each array must have two entries: time and record */\n        root = result.data;\n        if (root.type != MSGPACK_OBJECT_ARRAY) {\n            continue;\n        }\n        if (root.via.array.size != 2) {\n            continue;\n        }\n\n        /* Unpack time */\n        flb_time_pop_from_msgpack(&tms, &result, &obj);\n\n        /* Get the record/map */\n        map = root.via.array.ptr[1];\n        if (map.type != MSGPACK_OBJECT_MAP) {\n            continue;\n        }\n        map_size = map.via.map.size;\n\n        if (date_key != NULL) {\n            msgpack_pack_map(&tmp_pck, map_size + 1);\n        }\n        else {\n            msgpack_pack_map(&tmp_pck, map_size);\n        }\n\n        if (date_key != NULL) {\n            /* Append date key */\n            msgpack_pack_str(&tmp_pck, flb_sds_len(date_key));\n            msgpack_pack_str_body(&tmp_pck, date_key, flb_sds_len(date_key));\n\n            /* Append date value */\n            switch (date_format) {\n            case FLB_PACK_JSON_DATE_DOUBLE:\n                msgpack_pack_double(&tmp_pck, flb_time_to_double(&tms));\n                break;\n            case FLB_PACK_JSON_DATE_ISO8601:\n            /* Format the time, use microsecond precision not nanoseconds */\n                gmtime_r(&tms.tm.tv_sec, &tm);\n                s = strftime(time_formatted, sizeof(time_formatted) - 1,\n                             FLB_PACK_JSON_DATE_ISO8601_FMT, &tm);\n\n                len = snprintf(time_formatted + s,\n                               sizeof(time_formatted) - 1 - s,\n                               \".%06\" PRIu64 \"Z\",\n                               (uint64_t) tms.tm.tv_nsec / 1000);\n                s += len;\n                msgpack_pack_str(&tmp_pck, s);\n                msgpack_pack_str_body(&tmp_pck, time_formatted, s);\n                break;\n            case FLB_PACK_JSON_DATE_EPOCH:\n                msgpack_pack_uint64(&tmp_pck, (long long unsigned)(tms.tm.tv_sec));\n                break;\n            }\n        }\n\n        /* Append remaining keys/values */\n        for (i = 0; i < map_size; i++) {\n            k = &map.via.map.ptr[i].key;\n            v = &map.via.map.ptr[i].val;\n            msgpack_pack_object(&tmp_pck, *k);\n            msgpack_pack_object(&tmp_pck, *v);\n        }\n\n        /*\n         * If the format is the original msgpack style, just continue since\n         * we don't care about separator or JSON convertion at this point.\n         */\n        if (json_format == FLB_PACK_JSON_FORMAT_JSON) {\n            continue;\n        }\n\n        /*\n         * Here we handle two types of records concatenation:\n         *\n         * FLB_PACK_JSON_FORMAT_LINES: add  breakline (\\n) after each record\n         *\n         *\n         *     {'ts':abc,'k1':1}\n         *     {'ts':abc,'k1':2}\n         *     {N}\n         *\n         * FLB_PACK_JSON_FORMAT_STREAM: no separators, e.g:\n         *\n         *     {'ts':abc,'k1':1}{'ts':abc,'k1':2}{N}\n         */\n        if (json_format == FLB_PACK_JSON_FORMAT_LINES ||\n            json_format == FLB_PACK_JSON_FORMAT_STREAM) {\n\n            /* Encode current record into JSON in a temporary variable */\n            out_js = flb_msgpack_raw_to_json_sds(tmp_sbuf.data, tmp_sbuf.size);\n            if (!out_js) {\n                msgpack_sbuffer_destroy(&tmp_sbuf);\n                flb_sds_destroy(out_buf);\n                return NULL;\n            }\n\n            /*\n             * One map record has been converted, now append it to the\n             * outgoing out_buf sds variable.\n             */\n            out_tmp = flb_sds_cat(out_buf, out_js, flb_sds_len(out_js));\n            if (!out_tmp) {\n                msgpack_sbuffer_destroy(&tmp_sbuf);\n                flb_sds_destroy(out_js);\n                flb_sds_destroy(out_buf);\n                return NULL;\n            }\n\n            /* Release temporary json sds buffer */\n            flb_sds_destroy(out_js);\n\n            /* If a realloc happened, check the returned address */\n            if (out_tmp != out_buf) {\n                out_buf = out_tmp;\n            }\n\n            /* Append the breakline only for json lines mode */\n            if (json_format == FLB_PACK_JSON_FORMAT_LINES) {\n                out_tmp = flb_sds_cat(out_buf, \"\\n\", 1);\n                if (!out_tmp) {\n                    msgpack_sbuffer_destroy(&tmp_sbuf);\n                    flb_sds_destroy(out_buf);\n                    return NULL;\n                }\n                if (out_tmp != out_buf) {\n                    out_buf = out_tmp;\n                }\n            }\n            msgpack_sbuffer_clear(&tmp_sbuf);\n        }\n    }\n\n    /* Release the unpacker */\n    msgpack_unpacked_destroy(&result);\n\n    /* Format to JSON */\n    if (json_format == FLB_PACK_JSON_FORMAT_JSON) {\n        out_buf = flb_msgpack_raw_to_json_sds(tmp_sbuf.data, tmp_sbuf.size);\n        msgpack_sbuffer_destroy(&tmp_sbuf);\n\n        if (!out_buf) {\n            return NULL;\n        }\n    }\n    else {\n        msgpack_sbuffer_destroy(&tmp_sbuf);\n    }\n\n    if (out_buf && flb_sds_len(out_buf) == 0) {\n        flb_sds_destroy(out_buf);\n        return NULL;\n    }\n\n    return out_buf;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -62,6 +62,9 @@\n     while (msgpack_unpack_next(&result, data, bytes, &off) == ok) {\n         /* Each array must have two entries: time and record */\n         root = result.data;\n+        if (root.type != MSGPACK_OBJECT_ARRAY) {\n+            continue;\n+        }\n         if (root.via.array.size != 2) {\n             continue;\n         }\n@@ -71,6 +74,9 @@\n \n         /* Get the record/map */\n         map = root.via.array.ptr[1];\n+        if (map.type != MSGPACK_OBJECT_MAP) {\n+            continue;\n+        }\n         map_size = map.via.map.size;\n \n         if (date_key != NULL) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (root.type != MSGPACK_OBJECT_ARRAY) {",
                "            continue;",
                "        }",
                "        if (map.type != MSGPACK_OBJECT_MAP) {",
                "            continue;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-24823",
        "func_name": "RIOT-OS/RIOT/_iphc_encode",
        "description": "RIOT-OS, an operating system that supports Internet of Things devices, contains a network stack with the ability to process 6LoWPAN frames. Prior to version 2022.10, an attacker can send a crafted frame to the device resulting in a type confusion between IPv6 extension headers and a UDP header. This occurs while encoding a 6LoWPAN IPHC header. The type confusion manifests in an out of bounds write in the packet buffer. The overflow can be used to corrupt other packets and the allocator metadata. Corrupting a pointer will easily lead to denial of service. While carefully manipulating the allocator metadata gives an attacker the possibility to write data to arbitrary locations and thus execute arbitrary code. Version 2022.10 fixes this issue. As a workaround, apply the patches manually.",
        "git_url": "https://github.com/RIOT-OS/RIOT/commit/dafc397fdc3655aeb5c7b9963a43f1604c6a2062",
        "commit_title": "gnrc_sixlowpan_iphc: fix packet type confusion in _iphc_encode()",
        "commit_text": " (cherry picked from commit 4a081f86616cb5c9dd0b5d7b286da03285d1652a)",
        "func_before": "static gnrc_pktsnip_t *_iphc_encode(gnrc_pktsnip_t *pkt,\n                                    const gnrc_netif_hdr_t *netif_hdr,\n                                    gnrc_netif_t *iface)\n{\n    assert(pkt != NULL);\n    uint8_t *iphc_hdr;\n    gnrc_pktsnip_t *dispatch, *ptr = pkt->next;\n    size_t dispatch_size = 0;\n    uint16_t inline_pos = 0;\n    uint8_t nh;\n\n    dispatch = NULL;    /* use dispatch as temporary pointer for prev */\n    /* determine maximum dispatch size and write protect all headers until\n     * then because they will be removed */\n    while ((ptr != NULL) && _compressible(ptr)) {\n        gnrc_pktsnip_t *tmp = gnrc_pktbuf_start_write(ptr);\n\n        if (tmp == NULL) {\n            DEBUG(\"6lo iphc: unable to write protect compressible header\\n\");\n            return NULL;\n        }\n        ptr = tmp;\n        if (dispatch == NULL) {\n            /* pkt was already write protected in gnrc_sixlowpan.c:_send so\n             * we shouldn't do it again */\n            pkt->next = ptr;    /* reset original packet */\n        }\n        else {\n            dispatch->next = ptr;\n        }\n        if (ptr->type == GNRC_NETTYPE_UNDEF) {\n            /* most likely UDP for now so use that (XXX: extend if extension\n             * headers make problems) */\n            dispatch_size += sizeof(udp_hdr_t);\n            break;  /* nothing special after UDP so quit even if more UNDEF\n                     * come */\n        }\n        else {\n            dispatch_size += ptr->size;\n        }\n        dispatch = ptr; /* use dispatch as temporary point for prev */\n        ptr = ptr->next;\n    }\n    /* there should be at least one compressible header in `pkt`, otherwise this\n     * function should not be called */\n    assert(dispatch_size > 0);\n    dispatch = gnrc_pktbuf_add(NULL, NULL, dispatch_size + 1,\n                               GNRC_NETTYPE_SIXLOWPAN);\n\n    if (dispatch == NULL) {\n        DEBUG(\"6lo iphc: error allocating dispatch space\\n\");\n        return NULL;\n    }\n\n    iphc_hdr = dispatch->data;\n    inline_pos = _iphc_ipv6_encode(pkt, netif_hdr, iface, iphc_hdr);\n\n    if (inline_pos == 0) {\n        DEBUG(\"6lo iphc: error encoding IPv6 header\\n\");\n        gnrc_pktbuf_release(dispatch);\n        return NULL;\n    }\n\n    nh = ((ipv6_hdr_t *)pkt->next->data)->nh;\n#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\n    while (_compressible_nh(nh)) {\n        ssize_t local_pos = 0;\n        if (pkt->next->next == NULL) {\n            DEBUG(\"6lo iphc: packet next header missing data\");\n            gnrc_pktbuf_release(dispatch);\n            return NULL;\n        }\n        switch (nh) {\n            case PROTNUM_UDP:\n                local_pos = _nhc_udp_encode_snip(pkt, &iphc_hdr[inline_pos]);\n                /* abort loop on next iteration */\n                nh = PROTNUM_RESERVED;\n                break;\n            case PROTNUM_IPV6: {    /* encapsulated IPv6 header */\n                local_pos = _nhc_ipv6_encode_snip(pkt, netif_hdr, iface,\n                                                  &iphc_hdr[inline_pos], &nh);\n                break;\n            }\n            case PROTNUM_IPV6_EXT_HOPOPT:\n            case PROTNUM_IPV6_EXT_RH:\n            case PROTNUM_IPV6_EXT_FRAG:\n            case PROTNUM_IPV6_EXT_DST:\n            case PROTNUM_IPV6_EXT_MOB:\n                local_pos = _nhc_ipv6_ext_encode_snip(pkt,\n                                                      &iphc_hdr[inline_pos],\n                                                      &nh);\n                if (local_pos == 0) {\n                    /* abort loop, extension header is not compressible as\n                     * length field is too large value */\n                    nh = PROTNUM_RESERVED;\n                }\n                break;\n            default:\n                /* abort loop on next iteration */\n                nh = PROTNUM_RESERVED;\n                break;\n        }\n        if (local_pos < 0) {\n            DEBUG(\"6lo iphc: error on compressing next header\\n\");\n            gnrc_pktbuf_release(dispatch);\n            return NULL;\n        }\n        inline_pos += local_pos;\n    }\n#endif\n\n    /* shrink dispatch allocation to final size */\n    /* NOTE: Since this only shrinks the data nothing bad SHOULD happen ;-) */\n    gnrc_pktbuf_realloc_data(dispatch, (size_t)inline_pos);\n\n    /* remove IPv6 header */\n    pkt = gnrc_pktbuf_remove_snip(pkt, pkt->next);\n\n    /* insert dispatch into packet */\n    dispatch->next = pkt->next;\n    pkt->next = dispatch;\n    return pkt;\n}",
        "func": "static gnrc_pktsnip_t *_iphc_encode(gnrc_pktsnip_t *pkt,\n                                    const gnrc_netif_hdr_t *netif_hdr,\n                                    gnrc_netif_t *iface)\n{\n    assert(pkt != NULL);\n    uint8_t *iphc_hdr;\n    gnrc_pktsnip_t *dispatch, *ptr = pkt->next;\n    size_t dispatch_size = 0;\n    uint16_t inline_pos = 0;\n    uint8_t nh;\n\n    dispatch = NULL;    /* use dispatch as temporary pointer for prev */\n    /* determine maximum dispatch size and write protect all headers until\n     * then because they will be removed */\n    while ((ptr != NULL) && _compressible(ptr)) {\n        gnrc_pktsnip_t *tmp = gnrc_pktbuf_start_write(ptr);\n\n        if (tmp == NULL) {\n            DEBUG(\"6lo iphc: unable to write protect compressible header\\n\");\n            return NULL;\n        }\n        ptr = tmp;\n        if (dispatch == NULL) {\n            /* pkt was already write protected in gnrc_sixlowpan.c:_send so\n             * we shouldn't do it again */\n            pkt->next = ptr;    /* reset original packet */\n        }\n        else {\n            dispatch->next = ptr;\n        }\n        dispatch_size += ptr->size;\n        dispatch = ptr; /* use dispatch as temporary point for prev */\n        ptr = ptr->next;\n    }\n    /* there should be at least one compressible header in `pkt`, otherwise this\n     * function should not be called */\n    assert(dispatch_size > 0);\n    dispatch = gnrc_pktbuf_add(NULL, NULL, dispatch_size + 1,\n                               GNRC_NETTYPE_SIXLOWPAN);\n\n    if (dispatch == NULL) {\n        DEBUG(\"6lo iphc: error allocating dispatch space\\n\");\n        return NULL;\n    }\n\n    iphc_hdr = dispatch->data;\n    inline_pos = _iphc_ipv6_encode(pkt, netif_hdr, iface, iphc_hdr);\n\n    if (inline_pos == 0) {\n        DEBUG(\"6lo iphc: error encoding IPv6 header\\n\");\n        gnrc_pktbuf_release(dispatch);\n        return NULL;\n    }\n\n    nh = ((ipv6_hdr_t *)pkt->next->data)->nh;\n#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\n    while (_compressible_nh(nh)) {\n        ssize_t local_pos = 0;\n        if (pkt->next->next == NULL) {\n            DEBUG(\"6lo iphc: packet next header missing data\");\n            gnrc_pktbuf_release(dispatch);\n            return NULL;\n        }\n        switch (nh) {\n            case PROTNUM_UDP:\n                local_pos = _nhc_udp_encode_snip(pkt, &iphc_hdr[inline_pos]);\n                /* abort loop on next iteration */\n                nh = PROTNUM_RESERVED;\n                break;\n            case PROTNUM_IPV6: {    /* encapsulated IPv6 header */\n                local_pos = _nhc_ipv6_encode_snip(pkt, netif_hdr, iface,\n                                                  &iphc_hdr[inline_pos], &nh);\n                break;\n            }\n            case PROTNUM_IPV6_EXT_HOPOPT:\n            case PROTNUM_IPV6_EXT_RH:\n            case PROTNUM_IPV6_EXT_FRAG:\n            case PROTNUM_IPV6_EXT_DST:\n            case PROTNUM_IPV6_EXT_MOB:\n                local_pos = _nhc_ipv6_ext_encode_snip(pkt,\n                                                      &iphc_hdr[inline_pos],\n                                                      &nh);\n                if (local_pos == 0) {\n                    /* abort loop, extension header is not compressible as\n                     * length field is too large value */\n                    nh = PROTNUM_RESERVED;\n                }\n                break;\n            default:\n                /* abort loop on next iteration */\n                nh = PROTNUM_RESERVED;\n                break;\n        }\n        if (local_pos < 0) {\n            DEBUG(\"6lo iphc: error on compressing next header\\n\");\n            gnrc_pktbuf_release(dispatch);\n            return NULL;\n        }\n        inline_pos += local_pos;\n    }\n#endif\n\n    /* shrink dispatch allocation to final size */\n    /* NOTE: Since this only shrinks the data nothing bad SHOULD happen ;-) */\n    gnrc_pktbuf_realloc_data(dispatch, (size_t)inline_pos);\n\n    /* remove IPv6 header */\n    pkt = gnrc_pktbuf_remove_snip(pkt, pkt->next);\n\n    /* insert dispatch into packet */\n    dispatch->next = pkt->next;\n    pkt->next = dispatch;\n    return pkt;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,16 +28,7 @@\n         else {\n             dispatch->next = ptr;\n         }\n-        if (ptr->type == GNRC_NETTYPE_UNDEF) {\n-            /* most likely UDP for now so use that (XXX: extend if extension\n-             * headers make problems) */\n-            dispatch_size += sizeof(udp_hdr_t);\n-            break;  /* nothing special after UDP so quit even if more UNDEF\n-                     * come */\n-        }\n-        else {\n-            dispatch_size += ptr->size;\n-        }\n+        dispatch_size += ptr->size;\n         dispatch = ptr; /* use dispatch as temporary point for prev */\n         ptr = ptr->next;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "        if (ptr->type == GNRC_NETTYPE_UNDEF) {",
                "            /* most likely UDP for now so use that (XXX: extend if extension",
                "             * headers make problems) */",
                "            dispatch_size += sizeof(udp_hdr_t);",
                "            break;  /* nothing special after UDP so quit even if more UNDEF",
                "                     * come */",
                "        }",
                "        else {",
                "            dispatch_size += ptr->size;",
                "        }"
            ],
            "added_lines": [
                "        dispatch_size += ptr->size;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-23557",
        "func_name": "facebook/hermes/copyDataPropertiesSlowPath_RJS",
        "description": "An error in Hermes' algorithm for copying objects properties prior to commit a00d237346894c6067a594983be6634f4168c9ad could be used by a malicious attacker to execute arbitrary code via type confusion. Note that this is only exploitable in cases where Hermes is used to execute untrusted JavaScript. Hence, most React Native applications are not affected.",
        "git_url": "https://github.com/facebook/hermes/commit/a00d237346894c6067a594983be6634f4168c9ad",
        "commit_title": "Use copyDataProperties slow path for objects with accessors",
        "commit_text": " Summary: Fix a bug present in `hermesBuiltinCopyDataProperties`. `hermesBuiltinCopyDataProperties` is meant to copy an object. It does this by iterating over all the properties in the source object, and then writing the key-value pair into a new object which is returned.The iteration is done using `JSObject::forEachOwnPropertyWhile`, providing a callback to process each property. It will take the property id, look it up in the source object using `getNamedPropertyValue_RJS`, then take that resulting value and write it into the target. However, that API explicitly states the following:  > Obviously the callbacks shouldn't be  doing naughty things like modifying the property map or creating new hidden classes (even implicitly)  But, `getNamedPropertyValue_RJS` can perform arbitrary JS execution if it is a getter, including adding/deleting new properties, which would modify the object's HiddenClass, thus violating `JSObject::forEachOwnPropertyWhile`'s precondition.Therefore, the fix is to use the correct, but slower path, whenever there is an accessor on the object. This code path is more 1:1 to the spec. At the beginning, it will simply find all the properties of the source object using `JSObject::getOwnPropertyKeys` and then iterate on those, rather than use `JSObject::forEachOwnPropertyWhile`. This way, we are allowed to manipulate the source object however we wish, which is necessary in order to call `getNamedPropertyValue_RJS`.  Reviewed By: neildhar  Differential Revision: D41701871  fbshipit-source-id: c4be179f57d52827f12ca26b1ab8d17cdccd7447",
        "func_before": "CallResult<HermesValue> copyDataPropertiesSlowPath_RJS(\n    Runtime &runtime,\n    Handle<JSObject> target,\n    Handle<JSObject> from,\n    Handle<JSObject> excludedItems) {\n  assert(\n      from->isProxyObject() &&\n      \"copyDataPropertiesSlowPath_RJS is only for Proxy\");\n\n  // 5. Let keys be ? from.[[OwnPropertyKeys]]().\n  auto cr = JSProxy::getOwnPropertyKeys(\n      from,\n      runtime,\n      OwnKeysFlags()\n          .plusIncludeSymbols()\n          .plusIncludeNonSymbols()\n          .plusIncludeNonEnumerable());\n  if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto keys = *cr;\n\n  MutableHandle<> nextKeyHandle{runtime};\n  MutableHandle<> propValueHandle{runtime};\n  MutableHandle<SymbolID> tmpSymbolStorage{runtime};\n  GCScopeMarkerRAII marker{runtime};\n  // 6. For each element nextKey of keys in List order, do\n  for (uint32_t nextKeyIdx = 0, endIdx = keys->getEndIndex();\n       nextKeyIdx < endIdx;\n       ++nextKeyIdx) {\n    marker.flush();\n    nextKeyHandle = keys->at(runtime, nextKeyIdx).unboxToHV(runtime);\n    if (nextKeyHandle->isNumber()) {\n      CallResult<PseudoHandle<StringPrimitive>> strRes =\n          toString_RJS(runtime, nextKeyHandle);\n      if (LLVM_UNLIKELY(strRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      nextKeyHandle = strRes->getHermesValue();\n    }\n\n    // b. For each element e of excludedItems in List order, do\n    //   i. If SameValue(e, nextKey) is true, then\n    //     1. Set excluded to true.\n    if (excludedItems) {\n      assert(\n          !excludedItems->isProxyObject() &&\n          \"internal excludedItems object is a proxy\");\n      ComputedPropertyDescriptor desc;\n      CallResult<bool> cr = JSObject::getOwnComputedPrimitiveDescriptor(\n          excludedItems,\n          runtime,\n          nextKeyHandle,\n          JSObject::IgnoreProxy::Yes,\n          tmpSymbolStorage,\n          desc);\n      if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      if (*cr)\n        continue;\n    }\n\n    //   i. Let desc be ? from.[[GetOwnProperty]](nextKey).\n    ComputedPropertyDescriptor desc;\n    CallResult<bool> crb =\n        JSProxy::getOwnProperty(from, runtime, nextKeyHandle, desc, nullptr);\n    if (LLVM_UNLIKELY(crb == ExecutionStatus::EXCEPTION))\n      return ExecutionStatus::EXCEPTION;\n    //   ii. If desc is not undefined and desc.[[Enumerable]] is true, then\n    if (*crb && desc.flags.enumerable) {\n      //     1. Let propValue be ? Get(from, nextKey).\n      CallResult<PseudoHandle<>> crv =\n          JSProxy::getComputed(from, runtime, nextKeyHandle, from);\n      if (LLVM_UNLIKELY(crv == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      propValueHandle = std::move(*crv);\n      //     2. Perform ! CreateDataProperty(target, nextKey, propValue).\n      crb = JSObject::defineOwnComputed(\n          target,\n          runtime,\n          nextKeyHandle,\n          DefinePropertyFlags::getDefaultNewPropertyFlags(),\n          propValueHandle);\n      if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      assert(\n          crb != ExecutionStatus::EXCEPTION && *crb &&\n          \"CreateDataProperty failed\");\n    }\n  }\n  return target.getHermesValue();\n}",
        "func": "CallResult<HermesValue> copyDataPropertiesSlowPath_RJS(\n    Runtime &runtime,\n    Handle<JSObject> target,\n    Handle<JSObject> from,\n    Handle<JSObject> excludedItems) {\n  // 5. Let keys be ? from.[[OwnPropertyKeys]]().\n  auto cr = JSObject::getOwnPropertyKeys(\n      from,\n      runtime,\n      OwnKeysFlags()\n          .plusIncludeSymbols()\n          .plusIncludeNonSymbols()\n          .plusIncludeNonEnumerable());\n  if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto keys = *cr;\n\n  MutableHandle<> nextKeyHandle{runtime};\n  MutableHandle<> propValueHandle{runtime};\n  MutableHandle<SymbolID> tmpSymbolStorage{runtime};\n  GCScopeMarkerRAII marker{runtime};\n  // 6. For each element nextKey of keys in List order, do\n  for (uint32_t nextKeyIdx = 0, endIdx = keys->getEndIndex();\n       nextKeyIdx < endIdx;\n       ++nextKeyIdx) {\n    marker.flush();\n    nextKeyHandle = keys->at(runtime, nextKeyIdx).unboxToHV(runtime);\n    if (nextKeyHandle->isNumber()) {\n      CallResult<PseudoHandle<StringPrimitive>> strRes =\n          toString_RJS(runtime, nextKeyHandle);\n      if (LLVM_UNLIKELY(strRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      nextKeyHandle = strRes->getHermesValue();\n    }\n\n    // b. For each element e of excludedItems in List order, do\n    //   i. If SameValue(e, nextKey) is true, then\n    //     1. Set excluded to true.\n    if (excludedItems) {\n      assert(\n          !excludedItems->isProxyObject() &&\n          \"internal excludedItems object is a proxy\");\n      ComputedPropertyDescriptor desc;\n      CallResult<bool> cr = JSObject::getOwnComputedPrimitiveDescriptor(\n          excludedItems,\n          runtime,\n          nextKeyHandle,\n          JSObject::IgnoreProxy::Yes,\n          tmpSymbolStorage,\n          desc);\n      if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      if (*cr)\n        continue;\n    }\n\n    //   i. Let desc be ? from.[[GetOwnProperty]](nextKey).\n    ComputedPropertyDescriptor desc;\n    CallResult<bool> crb = JSObject::getOwnComputedDescriptor(\n        from, runtime, nextKeyHandle, tmpSymbolStorage, desc);\n    if (LLVM_UNLIKELY(crb == ExecutionStatus::EXCEPTION))\n      return ExecutionStatus::EXCEPTION;\n    //   ii. If desc is not undefined and desc.[[Enumerable]] is true, then\n    // TODO(T141997867), move this special case behavior for host objects to\n    // getOwnComputedDescriptor.\n    if ((*crb && desc.flags.enumerable) || from->isHostObject()) {\n      //     1. Let propValue be ? Get(from, nextKey).\n      CallResult<PseudoHandle<>> crv =\n          JSObject::getComputed_RJS(from, runtime, nextKeyHandle);\n      if (LLVM_UNLIKELY(crv == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      propValueHandle = std::move(*crv);\n      //     2. Perform ! CreateDataProperty(target, nextKey, propValue).\n      crb = JSObject::defineOwnComputed(\n          target,\n          runtime,\n          nextKeyHandle,\n          DefinePropertyFlags::getDefaultNewPropertyFlags(),\n          propValueHandle);\n      if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      assert(\n          crb != ExecutionStatus::EXCEPTION && *crb &&\n          \"CreateDataProperty failed\");\n    }\n  }\n  return target.getHermesValue();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,12 +3,8 @@\n     Handle<JSObject> target,\n     Handle<JSObject> from,\n     Handle<JSObject> excludedItems) {\n-  assert(\n-      from->isProxyObject() &&\n-      \"copyDataPropertiesSlowPath_RJS is only for Proxy\");\n-\n   // 5. Let keys be ? from.[[OwnPropertyKeys]]().\n-  auto cr = JSProxy::getOwnPropertyKeys(\n+  auto cr = JSObject::getOwnPropertyKeys(\n       from,\n       runtime,\n       OwnKeysFlags()\n@@ -62,15 +58,17 @@\n \n     //   i. Let desc be ? from.[[GetOwnProperty]](nextKey).\n     ComputedPropertyDescriptor desc;\n-    CallResult<bool> crb =\n-        JSProxy::getOwnProperty(from, runtime, nextKeyHandle, desc, nullptr);\n+    CallResult<bool> crb = JSObject::getOwnComputedDescriptor(\n+        from, runtime, nextKeyHandle, tmpSymbolStorage, desc);\n     if (LLVM_UNLIKELY(crb == ExecutionStatus::EXCEPTION))\n       return ExecutionStatus::EXCEPTION;\n     //   ii. If desc is not undefined and desc.[[Enumerable]] is true, then\n-    if (*crb && desc.flags.enumerable) {\n+    // TODO(T141997867), move this special case behavior for host objects to\n+    // getOwnComputedDescriptor.\n+    if ((*crb && desc.flags.enumerable) || from->isHostObject()) {\n       //     1. Let propValue be ? Get(from, nextKey).\n       CallResult<PseudoHandle<>> crv =\n-          JSProxy::getComputed(from, runtime, nextKeyHandle, from);\n+          JSObject::getComputed_RJS(from, runtime, nextKeyHandle);\n       if (LLVM_UNLIKELY(crv == ExecutionStatus::EXCEPTION))\n         return ExecutionStatus::EXCEPTION;\n       propValueHandle = std::move(*crv);",
        "diff_line_info": {
            "deleted_lines": [
                "  assert(",
                "      from->isProxyObject() &&",
                "      \"copyDataPropertiesSlowPath_RJS is only for Proxy\");",
                "",
                "  auto cr = JSProxy::getOwnPropertyKeys(",
                "    CallResult<bool> crb =",
                "        JSProxy::getOwnProperty(from, runtime, nextKeyHandle, desc, nullptr);",
                "    if (*crb && desc.flags.enumerable) {",
                "          JSProxy::getComputed(from, runtime, nextKeyHandle, from);"
            ],
            "added_lines": [
                "  auto cr = JSObject::getOwnPropertyKeys(",
                "    CallResult<bool> crb = JSObject::getOwnComputedDescriptor(",
                "        from, runtime, nextKeyHandle, tmpSymbolStorage, desc);",
                "    // TODO(T141997867), move this special case behavior for host objects to",
                "    // getOwnComputedDescriptor.",
                "    if ((*crb && desc.flags.enumerable) || from->isHostObject()) {",
                "          JSObject::getComputed_RJS(from, runtime, nextKeyHandle);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-23557",
        "func_name": "facebook/hermes/hermesBuiltinCopyDataProperties",
        "description": "An error in Hermes' algorithm for copying objects properties prior to commit a00d237346894c6067a594983be6634f4168c9ad could be used by a malicious attacker to execute arbitrary code via type confusion. Note that this is only exploitable in cases where Hermes is used to execute untrusted JavaScript. Hence, most React Native applications are not affected.",
        "git_url": "https://github.com/facebook/hermes/commit/a00d237346894c6067a594983be6634f4168c9ad",
        "commit_title": "Use copyDataProperties slow path for objects with accessors",
        "commit_text": " Summary: Fix a bug present in `hermesBuiltinCopyDataProperties`. `hermesBuiltinCopyDataProperties` is meant to copy an object. It does this by iterating over all the properties in the source object, and then writing the key-value pair into a new object which is returned.The iteration is done using `JSObject::forEachOwnPropertyWhile`, providing a callback to process each property. It will take the property id, look it up in the source object using `getNamedPropertyValue_RJS`, then take that resulting value and write it into the target. However, that API explicitly states the following:  > Obviously the callbacks shouldn't be  doing naughty things like modifying the property map or creating new hidden classes (even implicitly)  But, `getNamedPropertyValue_RJS` can perform arbitrary JS execution if it is a getter, including adding/deleting new properties, which would modify the object's HiddenClass, thus violating `JSObject::forEachOwnPropertyWhile`'s precondition.Therefore, the fix is to use the correct, but slower path, whenever there is an accessor on the object. This code path is more 1:1 to the spec. At the beginning, it will simply find all the properties of the source object using `JSObject::getOwnPropertyKeys` and then iterate on those, rather than use `JSObject::forEachOwnPropertyWhile`. This way, we are allowed to manipulate the source object however we wish, which is necessary in order to call `getNamedPropertyValue_RJS`.  Reviewed By: neildhar  Differential Revision: D41701871  fbshipit-source-id: c4be179f57d52827f12ca26b1ab8d17cdccd7447",
        "func_before": "CallResult<HermesValue>\nhermesBuiltinCopyDataProperties(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope{runtime};\n\n  // 1. Assert: Type(target) is Object.\n  Handle<JSObject> target = args.dyncastArg<JSObject>(0);\n  // To be safe, ignore non-objects.\n  if (!target)\n    return HermesValue::encodeUndefinedValue();\n\n  // 3. If source is undefined or null, return target.\n  Handle<> untypedSource = args.getArgHandle(1);\n  if (untypedSource->isNull() || untypedSource->isUndefined())\n    return target.getHermesValue();\n\n  // 4. Let from be ! ToObject(source).\n  Handle<JSObject> source = untypedSource->isObject()\n      ? Handle<JSObject>::vmcast(untypedSource)\n      : Handle<JSObject>::vmcast(\n            runtime.makeHandle(*toObject(runtime, untypedSource)));\n\n  // 2. Assert: excludedItems is a List of property keys.\n  // In Hermes, excludedItems is represented as a JSObject, created by\n  // bytecode emitted by the compiler, whose keys are the excluded\n  // propertyKeys\n  Handle<JSObject> excludedItems = args.dyncastArg<JSObject>(2);\n  assert(\n      (!excludedItems || !excludedItems->isProxyObject()) &&\n      \"excludedItems internal List is a Proxy\");\n\n  if (source->isProxyObject()) {\n    return copyDataPropertiesSlowPath_RJS(\n        runtime, target, source, excludedItems);\n  }\n\n  MutableHandle<> nameHandle{runtime};\n  MutableHandle<> valueHandle{runtime};\n  MutableHandle<SymbolID> tmpSymbolStorage{runtime};\n\n  // Process all named properties/symbols.\n  bool success = JSObject::forEachOwnPropertyWhile(\n      source,\n      runtime,\n      // indexedCB.\n      [&source,\n       &target,\n       &excludedItems,\n       &nameHandle,\n       &valueHandle,\n       &tmpSymbolStorage](\n          Runtime &runtime, uint32_t index, ComputedPropertyDescriptor desc) {\n        if (!desc.flags.enumerable)\n          return true;\n\n        nameHandle = HermesValue::encodeNumberValue(index);\n\n        if (excludedItems) {\n          assert(\n              !excludedItems->isProxyObject() &&\n              \"internal excludedItems object is a proxy\");\n          ComputedPropertyDescriptor xdesc;\n          auto cr = JSObject::getOwnComputedPrimitiveDescriptor(\n              excludedItems,\n              runtime,\n              nameHandle,\n              JSObject::IgnoreProxy::Yes,\n              tmpSymbolStorage,\n              xdesc);\n          if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n            return false;\n          if (*cr)\n            return true;\n        }\n\n        valueHandle = JSObject::getOwnIndexed(\n            createPseudoHandle(source.get()), runtime, index);\n\n        if (LLVM_UNLIKELY(\n                JSObject::defineOwnComputedPrimitive(\n                    target,\n                    runtime,\n                    nameHandle,\n                    DefinePropertyFlags::getDefaultNewPropertyFlags(),\n                    valueHandle) == ExecutionStatus::EXCEPTION)) {\n          return false;\n        }\n\n        return true;\n      },\n      // namedCB.\n      [&source, &target, &excludedItems, &valueHandle](\n          Runtime &runtime, SymbolID sym, NamedPropertyDescriptor desc) {\n        if (!desc.flags.enumerable)\n          return true;\n        if (InternalProperty::isInternal(sym))\n          return true;\n\n        // Skip excluded items.\n        if (excludedItems) {\n          auto cr = JSObject::hasNamedOrIndexed(excludedItems, runtime, sym);\n          assert(\n              cr != ExecutionStatus::EXCEPTION &&\n              \"hasNamedOrIndex failed, which can only happen with a proxy, \"\n              \"but excludedItems should never be a proxy\");\n          if (*cr)\n            return true;\n        }\n\n        auto cr =\n            JSObject::getNamedPropertyValue_RJS(source, runtime, source, desc);\n        if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n          return false;\n\n        valueHandle = std::move(*cr);\n\n        // sym can be an index-like property, so we have to bypass the assert in\n        // defineOwnPropertyInternal.\n        if (LLVM_UNLIKELY(\n                JSObject::defineOwnPropertyInternal(\n                    target,\n                    runtime,\n                    sym,\n                    DefinePropertyFlags::getDefaultNewPropertyFlags(),\n                    valueHandle) == ExecutionStatus::EXCEPTION)) {\n          return false;\n        }\n\n        return true;\n      });\n\n  if (LLVM_UNLIKELY(!success))\n    return ExecutionStatus::EXCEPTION;\n\n  return target.getHermesValue();\n}",
        "func": "CallResult<HermesValue>\nhermesBuiltinCopyDataProperties(void *, Runtime &runtime, NativeArgs args) {\n  GCScope gcScope{runtime};\n\n  // 1. Assert: Type(target) is Object.\n  Handle<JSObject> target = args.dyncastArg<JSObject>(0);\n  // To be safe, ignore non-objects.\n  if (!target)\n    return HermesValue::encodeUndefinedValue();\n\n  // 3. If source is undefined or null, return target.\n  Handle<> untypedSource = args.getArgHandle(1);\n  if (untypedSource->isNull() || untypedSource->isUndefined())\n    return target.getHermesValue();\n\n  // 4. Let from be ! ToObject(source).\n  Handle<JSObject> source = untypedSource->isObject()\n      ? Handle<JSObject>::vmcast(untypedSource)\n      : Handle<JSObject>::vmcast(\n            runtime.makeHandle(*toObject(runtime, untypedSource)));\n\n  // 2. Assert: excludedItems is a List of property keys.\n  // In Hermes, excludedItems is represented as a JSObject, created by\n  // bytecode emitted by the compiler, whose keys are the excluded\n  // propertyKeys\n  Handle<JSObject> excludedItems = args.dyncastArg<JSObject>(2);\n  assert(\n      (!excludedItems || !excludedItems->isProxyObject()) &&\n      \"excludedItems internal List is a Proxy\");\n\n  // We cannot use the fast path if the object is a proxy, host object, or when\n  // there could potentially be an accessor defined on the object. This is\n  // because in order to use JSObject::forEachOwnPropertyWhile, we must not\n  // modify the underlying property map or hidden class. However, if we have an\n  // accessor, we cannot guarantee that condition, so we use the slow path.\n  if (source->isProxyObject() || source->isHostObject() ||\n      source->getClass(runtime)->getMayHaveAccessor()) {\n    return copyDataPropertiesSlowPath_RJS(\n        runtime, target, source, excludedItems);\n  }\n\n  MutableHandle<> nameHandle{runtime};\n  MutableHandle<> valueHandle{runtime};\n  MutableHandle<SymbolID> tmpSymbolStorage{runtime};\n\n  // Process all named properties/symbols.\n  bool success = JSObject::forEachOwnPropertyWhile(\n      source,\n      runtime,\n      // indexedCB.\n      [&source,\n       &target,\n       &excludedItems,\n       &nameHandle,\n       &valueHandle,\n       &tmpSymbolStorage](\n          Runtime &runtime, uint32_t index, ComputedPropertyDescriptor desc) {\n        if (!desc.flags.enumerable)\n          return true;\n\n        nameHandle = HermesValue::encodeNumberValue(index);\n\n        if (excludedItems) {\n          assert(\n              !excludedItems->isProxyObject() &&\n              \"internal excludedItems object is a proxy\");\n          ComputedPropertyDescriptor xdesc;\n          auto cr = JSObject::getOwnComputedPrimitiveDescriptor(\n              excludedItems,\n              runtime,\n              nameHandle,\n              JSObject::IgnoreProxy::Yes,\n              tmpSymbolStorage,\n              xdesc);\n          if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n            return false;\n          if (*cr)\n            return true;\n        }\n\n        valueHandle = JSObject::getOwnIndexed(\n            createPseudoHandle(source.get()), runtime, index);\n\n        if (LLVM_UNLIKELY(\n                JSObject::defineOwnComputedPrimitive(\n                    target,\n                    runtime,\n                    nameHandle,\n                    DefinePropertyFlags::getDefaultNewPropertyFlags(),\n                    valueHandle) == ExecutionStatus::EXCEPTION)) {\n          return false;\n        }\n\n        return true;\n      },\n      // namedCB.\n      [&source, &target, &excludedItems, &valueHandle](\n          Runtime &runtime, SymbolID sym, NamedPropertyDescriptor desc) {\n        if (!desc.flags.enumerable)\n          return true;\n        if (InternalProperty::isInternal(sym))\n          return true;\n\n        // Skip excluded items.\n        if (excludedItems) {\n          auto cr = JSObject::hasNamedOrIndexed(excludedItems, runtime, sym);\n          assert(\n              cr != ExecutionStatus::EXCEPTION &&\n              \"hasNamedOrIndex failed, which can only happen with a proxy, \"\n              \"but excludedItems should never be a proxy\");\n          if (*cr)\n            return true;\n        }\n\n        SmallHermesValue shv =\n            JSObject::getNamedSlotValueUnsafe(*source, runtime, desc);\n        valueHandle = runtime.makeHandle(shv.unboxToHV(runtime));\n\n        // sym can be an index-like property, so we have to bypass the assert in\n        // defineOwnPropertyInternal.\n        if (LLVM_UNLIKELY(\n                JSObject::defineOwnPropertyInternal(\n                    target,\n                    runtime,\n                    sym,\n                    DefinePropertyFlags::getDefaultNewPropertyFlags(),\n                    valueHandle) == ExecutionStatus::EXCEPTION)) {\n          return false;\n        }\n\n        return true;\n      });\n\n  if (LLVM_UNLIKELY(!success))\n    return ExecutionStatus::EXCEPTION;\n\n  return target.getHermesValue();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,13 @@\n       (!excludedItems || !excludedItems->isProxyObject()) &&\n       \"excludedItems internal List is a Proxy\");\n \n-  if (source->isProxyObject()) {\n+  // We cannot use the fast path if the object is a proxy, host object, or when\n+  // there could potentially be an accessor defined on the object. This is\n+  // because in order to use JSObject::forEachOwnPropertyWhile, we must not\n+  // modify the underlying property map or hidden class. However, if we have an\n+  // accessor, we cannot guarantee that condition, so we use the slow path.\n+  if (source->isProxyObject() || source->isHostObject() ||\n+      source->getClass(runtime)->getMayHaveAccessor()) {\n     return copyDataPropertiesSlowPath_RJS(\n         runtime, target, source, excludedItems);\n   }\n@@ -106,12 +112,9 @@\n             return true;\n         }\n \n-        auto cr =\n-            JSObject::getNamedPropertyValue_RJS(source, runtime, source, desc);\n-        if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n-          return false;\n-\n-        valueHandle = std::move(*cr);\n+        SmallHermesValue shv =\n+            JSObject::getNamedSlotValueUnsafe(*source, runtime, desc);\n+        valueHandle = runtime.makeHandle(shv.unboxToHV(runtime));\n \n         // sym can be an index-like property, so we have to bypass the assert in\n         // defineOwnPropertyInternal.",
        "diff_line_info": {
            "deleted_lines": [
                "  if (source->isProxyObject()) {",
                "        auto cr =",
                "            JSObject::getNamedPropertyValue_RJS(source, runtime, source, desc);",
                "        if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))",
                "          return false;",
                "",
                "        valueHandle = std::move(*cr);"
            ],
            "added_lines": [
                "  // We cannot use the fast path if the object is a proxy, host object, or when",
                "  // there could potentially be an accessor defined on the object. This is",
                "  // because in order to use JSObject::forEachOwnPropertyWhile, we must not",
                "  // modify the underlying property map or hidden class. However, if we have an",
                "  // accessor, we cannot guarantee that condition, so we use the slow path.",
                "  if (source->isProxyObject() || source->isHostObject() ||",
                "      source->getClass(runtime)->getMayHaveAccessor()) {",
                "        SmallHermesValue shv =",
                "            JSObject::getNamedSlotValueUnsafe(*source, runtime, desc);",
                "        valueHandle = runtime.makeHandle(shv.unboxToHV(runtime));"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-25933",
        "func_name": "facebook/hermes/inferBinaryArith",
        "description": "A type confusion bug in TypedArray prior to commit e6ed9c1a4b02dc219de1648f44cd808a56171b81 could have been used by a malicious attacker to execute arbitrary code via untrusted JavaScript. Note that this is only exploitable in cases where Hermes is used to execute untrusted JavaScript. Hence, most React Native applications are not affected.",
        "git_url": "https://github.com/facebook/hermes/commit/e6ed9c1a4b02dc219de1648f44cd808a56171b81",
        "commit_title": "Re-sync with internal repository (#960)",
        "commit_text": " Co-authored-by: Facebook Community Bot <6422482+facebook-github-bot@users.noreply.github.com>",
        "func_before": "static bool inferBinaryArith(\n    BinaryOperatorInst *BOI,\n    Type numberType = Type::createNumber()) {\n  Type LeftTy = BOI->getLeftHandSide()->getType();\n  Type RightTy = BOI->getRightHandSide()->getType();\n\n  // Number - Number => Number\n  if (LeftTy.isNumberType() && RightTy.isNumberType()) {\n    BOI->setType(numberType);\n    return true;\n  }\n\n  // BigInt - BigInt => BigInt\n  if (LeftTy.isBigIntType() && RightTy.isBigIntType()) {\n    BOI->setType(Type::createBigInt());\n    return true;\n  }\n\n  Type mayBeBigInt = LeftTy.canBeBigInt() && RightTy.canBeBigInt()\n      ? Type::createBigInt()\n      : Type::createNoType();\n\n  // ?? - ?? => Number|?BigInt. BigInt is only possible if both operands can be\n  // BigInt due to the no automatic BigInt conversion.\n  BOI->setType(Type::unionTy(numberType, mayBeBigInt));\n  return true;\n}",
        "func": "static bool inferBinaryArith(\n    BinaryOperatorInst *BOI,\n    Type numberType = Type::createNumber()) {\n  Type LeftTy = BOI->getLeftHandSide()->getType();\n  Type RightTy = BOI->getRightHandSide()->getType();\n\n  // Number - Number => Number\n  if (LeftTy.isNumberType() && RightTy.isNumberType()) {\n    BOI->setType(numberType);\n    return true;\n  }\n\n  // BigInt - BigInt => BigInt\n  if (LeftTy.isBigIntType() && RightTy.isBigIntType()) {\n    BOI->setType(Type::createBigInt());\n    return true;\n  }\n\n  Type mayBeBigInt = (isBigIntOrObject(LeftTy) && isBigIntOrObject(RightTy))\n      ? Type::createBigInt()\n      : Type::createNoType();\n\n  // ?? - ?? => Number|?BigInt. BigInt is only possible if both operands are\n  // BigInt|Object due to the no automatic BigInt conversion.\n  BOI->setType(Type::unionTy(numberType, mayBeBigInt));\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,12 +16,12 @@\n     return true;\n   }\n \n-  Type mayBeBigInt = LeftTy.canBeBigInt() && RightTy.canBeBigInt()\n+  Type mayBeBigInt = (isBigIntOrObject(LeftTy) && isBigIntOrObject(RightTy))\n       ? Type::createBigInt()\n       : Type::createNoType();\n \n-  // ?? - ?? => Number|?BigInt. BigInt is only possible if both operands can be\n-  // BigInt due to the no automatic BigInt conversion.\n+  // ?? - ?? => Number|?BigInt. BigInt is only possible if both operands are\n+  // BigInt|Object due to the no automatic BigInt conversion.\n   BOI->setType(Type::unionTy(numberType, mayBeBigInt));\n   return true;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  Type mayBeBigInt = LeftTy.canBeBigInt() && RightTy.canBeBigInt()",
                "  // ?? - ?? => Number|?BigInt. BigInt is only possible if both operands can be",
                "  // BigInt due to the no automatic BigInt conversion."
            ],
            "added_lines": [
                "  Type mayBeBigInt = (isBigIntOrObject(LeftTy) && isBigIntOrObject(RightTy))",
                "  // ?? - ?? => Number|?BigInt. BigInt is only possible if both operands are",
                "  // BigInt|Object due to the no automatic BigInt conversion."
            ]
        }
    },
    {
        "cve_id": "CVE-2023-25933",
        "func_name": "facebook/hermes/inferUnaryArith",
        "description": "A type confusion bug in TypedArray prior to commit e6ed9c1a4b02dc219de1648f44cd808a56171b81 could have been used by a malicious attacker to execute arbitrary code via untrusted JavaScript. Note that this is only exploitable in cases where Hermes is used to execute untrusted JavaScript. Hence, most React Native applications are not affected.",
        "git_url": "https://github.com/facebook/hermes/commit/e6ed9c1a4b02dc219de1648f44cd808a56171b81",
        "commit_title": "Re-sync with internal repository (#960)",
        "commit_text": " Co-authored-by: Facebook Community Bot <6422482+facebook-github-bot@users.noreply.github.com>",
        "func_before": "static bool inferUnaryArith(UnaryOperatorInst *UOI, Type numberResultType) {\n  Value *op = UOI->getSingleOperand();\n\n  if (op->getType().isNumberType()) {\n    UOI->setType(numberResultType);\n    return true;\n  }\n\n  if (op->getType().isBigIntType()) {\n    UOI->setType(Type::createBigInt());\n    return true;\n  }\n\n  Type mayBeBigInt =\n      op->getType().canBeBigInt() ? Type::createBigInt() : Type::createNoType();\n\n  // - ?? => Number|?BigInt. BigInt is only possible if op.Type canBeBigInt.\n  UOI->setType(Type::unionTy(numberResultType, mayBeBigInt));\n  return true;\n}",
        "func": "static bool inferUnaryArith(UnaryOperatorInst *UOI, Type numberResultType) {\n  Value *op = UOI->getSingleOperand();\n\n  if (op->getType().isNumberType()) {\n    UOI->setType(numberResultType);\n    return true;\n  }\n\n  if (op->getType().isBigIntType()) {\n    UOI->setType(Type::createBigInt());\n    return true;\n  }\n\n  Type mayBeBigInt = isBigIntOrObject(op->getType()) ? Type::createBigInt()\n                                                     : Type::createNoType();\n\n  // - ?? => Number|?BigInt. BigInt is only possible if op.Type is\n  // BigInt|Object.\n  UOI->setType(Type::unionTy(numberResultType, mayBeBigInt));\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,10 +11,11 @@\n     return true;\n   }\n \n-  Type mayBeBigInt =\n-      op->getType().canBeBigInt() ? Type::createBigInt() : Type::createNoType();\n+  Type mayBeBigInt = isBigIntOrObject(op->getType()) ? Type::createBigInt()\n+                                                     : Type::createNoType();\n \n-  // - ?? => Number|?BigInt. BigInt is only possible if op.Type canBeBigInt.\n+  // - ?? => Number|?BigInt. BigInt is only possible if op.Type is\n+  // BigInt|Object.\n   UOI->setType(Type::unionTy(numberResultType, mayBeBigInt));\n   return true;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  Type mayBeBigInt =",
                "      op->getType().canBeBigInt() ? Type::createBigInt() : Type::createNoType();",
                "  // - ?? => Number|?BigInt. BigInt is only possible if op.Type canBeBigInt."
            ],
            "added_lines": [
                "  Type mayBeBigInt = isBigIntOrObject(op->getType()) ? Type::createBigInt()",
                "                                                     : Type::createNoType();",
                "  // - ?? => Number|?BigInt. BigInt is only possible if op.Type is",
                "  // BigInt|Object."
            ]
        }
    },
    {
        "cve_id": "CVE-2023-25933",
        "func_name": "facebook/hermes/inferBinaryInst",
        "description": "A type confusion bug in TypedArray prior to commit e6ed9c1a4b02dc219de1648f44cd808a56171b81 could have been used by a malicious attacker to execute arbitrary code via untrusted JavaScript. Note that this is only exploitable in cases where Hermes is used to execute untrusted JavaScript. Hence, most React Native applications are not affected.",
        "git_url": "https://github.com/facebook/hermes/commit/e6ed9c1a4b02dc219de1648f44cd808a56171b81",
        "commit_title": "Re-sync with internal repository (#960)",
        "commit_text": " Co-authored-by: Facebook Community Bot <6422482+facebook-github-bot@users.noreply.github.com>",
        "func_before": "static bool inferBinaryInst(BinaryOperatorInst *BOI) {\n  switch (BOI->getOperatorKind()) {\n    // The following operations always return a boolean result.\n    // They may throw, they may read/write memory, but the result of the\n    // operation must be a boolean.\n    case BinaryOperatorInst::OpKind::EqualKind:\n    case BinaryOperatorInst::OpKind::NotEqualKind:\n    case BinaryOperatorInst::OpKind::StrictlyEqualKind:\n    case BinaryOperatorInst::OpKind::StrictlyNotEqualKind:\n    case BinaryOperatorInst::OpKind::LessThanKind:\n    case BinaryOperatorInst::OpKind::LessThanOrEqualKind:\n    case BinaryOperatorInst::OpKind::GreaterThanKind:\n    case BinaryOperatorInst::OpKind::GreaterThanOrEqualKind:\n    case BinaryOperatorInst::OpKind::InKind:\n    case BinaryOperatorInst::OpKind::InstanceOfKind:\n      // Notice that the spec says that comparison of NaN should return\n      // \"Undefined\" but all VMs return 'false'. We decided to conform to the\n      // current implementation and not to the spec.\n      BOI->setType(Type::createBoolean());\n      return true;\n\n    // These arithmetic operations always return a number or bigint:\n    // https://262.ecma-international.org/#sec-multiplicative-operators\n    case BinaryOperatorInst::OpKind::DivideKind:\n    case BinaryOperatorInst::OpKind::MultiplyKind:\n    // https://tc39.es/ecma262/#sec-subtraction-operator-minus\n    case BinaryOperatorInst::OpKind::SubtractKind:\n    // https://tc39.es/ecma262/#sec-left-shift-operator\n    case BinaryOperatorInst::OpKind::LeftShiftKind:\n    // https://tc39.es/ecma262/#sec-signed-right-shift-operator\n    case BinaryOperatorInst::OpKind::RightShiftKind:\n      return inferBinaryArith(BOI);\n\n    case BinaryOperatorInst::OpKind::ModuloKind:\n      return inferBinaryArith(BOI, Type::createInt32());\n\n    // https://es5.github.io/#x11.7.3\n    case BinaryOperatorInst::OpKind::UnsignedRightShiftKind:\n      BOI->setType(Type::createUint32());\n      return true;\n\n    // The Add operator is special:\n    // https://262.ecma-international.org/#sec-addition-operator-plus\n    case BinaryOperatorInst::OpKind::AddKind: {\n      Type LeftTy = BOI->getLeftHandSide()->getType();\n      Type RightTy = BOI->getRightHandSide()->getType();\n      // String + String -> String. It is enough for one of the operands to be\n      // a string to force the result to be a string.\n      if (LeftTy.isStringType() || RightTy.isStringType()) {\n        BOI->setType(Type::createString());\n        return true;\n      }\n\n      // Number + Number -> Number.\n      if (LeftTy.isNumberType() && RightTy.isNumberType()) {\n        BOI->setType(Type::createNumber());\n        return true;\n      }\n\n      // BigInt + BigInt -> BigInt.\n      if (LeftTy.isBigIntType() && RightTy.isBigIntType()) {\n        BOI->setType(Type::createBigInt());\n        return true;\n      }\n\n      // ?BigInt + ?BigInt => ?BigInt. Both operands need to \"may be a BigInt\"\n      // for a possible BigInt result from this operator. This is true because\n      // there's no automative BigInt type conversion.\n      Type mayBeBigInt = (LeftTy.canBeBigInt() && RightTy.canBeBigInt())\n          ? Type::createBigInt()\n          : Type::createNoType();\n\n      // handy alias for number|maybe(BigInt).\n      Type numeric = Type::unionTy(Type::createNumber(), mayBeBigInt);\n\n      // If both sides of the binary operand are known and both sides are known\n      // to be non-string (and can't be converted to strings) then the result\n      // must be of a numeric type.\n      if (isSideEffectFree(LeftTy) && isSideEffectFree(RightTy) &&\n          !LeftTy.canBeString() && !RightTy.canBeString()) {\n        BOI->setType(numeric);\n        return true;\n      }\n\n      // The plus operator always returns a number, bigint, or a string.\n      BOI->setType(Type::unionTy(numeric, Type::createString()));\n      return false;\n    }\n\n    // https://tc39.es/ecma262/#sec-binary-bitwise-operators\n    case BinaryOperatorInst::OpKind::AndKind:\n    case BinaryOperatorInst::OpKind::OrKind:\n    case BinaryOperatorInst::OpKind::XorKind:\n      return inferBinaryBitwise(BOI);\n\n    default:\n      break;\n  }\n  return false;\n}",
        "func": "static bool inferBinaryInst(BinaryOperatorInst *BOI) {\n  switch (BOI->getOperatorKind()) {\n    // The following operations always return a boolean result.\n    // They may throw, they may read/write memory, but the result of the\n    // operation must be a boolean.\n    case BinaryOperatorInst::OpKind::EqualKind:\n    case BinaryOperatorInst::OpKind::NotEqualKind:\n    case BinaryOperatorInst::OpKind::StrictlyEqualKind:\n    case BinaryOperatorInst::OpKind::StrictlyNotEqualKind:\n    case BinaryOperatorInst::OpKind::LessThanKind:\n    case BinaryOperatorInst::OpKind::LessThanOrEqualKind:\n    case BinaryOperatorInst::OpKind::GreaterThanKind:\n    case BinaryOperatorInst::OpKind::GreaterThanOrEqualKind:\n    case BinaryOperatorInst::OpKind::InKind:\n    case BinaryOperatorInst::OpKind::InstanceOfKind:\n      // Notice that the spec says that comparison of NaN should return\n      // \"Undefined\" but all VMs return 'false'. We decided to conform to the\n      // current implementation and not to the spec.\n      BOI->setType(Type::createBoolean());\n      return true;\n\n    // These arithmetic operations always return a number or bigint:\n    // https://262.ecma-international.org/#sec-multiplicative-operators\n    case BinaryOperatorInst::OpKind::DivideKind:\n    case BinaryOperatorInst::OpKind::MultiplyKind:\n    // https://tc39.es/ecma262/#sec-subtraction-operator-minus\n    case BinaryOperatorInst::OpKind::SubtractKind:\n    // https://tc39.es/ecma262/#sec-left-shift-operator\n    case BinaryOperatorInst::OpKind::LeftShiftKind:\n    // https://tc39.es/ecma262/#sec-signed-right-shift-operator\n    case BinaryOperatorInst::OpKind::RightShiftKind:\n      return inferBinaryArith(BOI);\n\n    case BinaryOperatorInst::OpKind::ModuloKind:\n      return inferBinaryArith(BOI, Type::createInt32());\n\n    // https://es5.github.io/#x11.7.3\n    case BinaryOperatorInst::OpKind::UnsignedRightShiftKind:\n      BOI->setType(Type::createUint32());\n      return true;\n\n    // The Add operator is special:\n    // https://262.ecma-international.org/#sec-addition-operator-plus\n    case BinaryOperatorInst::OpKind::AddKind: {\n      Type LeftTy = BOI->getLeftHandSide()->getType();\n      Type RightTy = BOI->getRightHandSide()->getType();\n      // String + String -> String. It is enough for one of the operands to be\n      // a string to force the result to be a string.\n      if (LeftTy.isStringType() || RightTy.isStringType()) {\n        BOI->setType(Type::createString());\n        return true;\n      }\n\n      // Number + Number -> Number.\n      if (LeftTy.isNumberType() && RightTy.isNumberType()) {\n        BOI->setType(Type::createNumber());\n        return true;\n      }\n\n      // BigInt + BigInt -> BigInt.\n      if (LeftTy.isBigIntType() && RightTy.isBigIntType()) {\n        BOI->setType(Type::createBigInt());\n        return true;\n      }\n\n      // ?BigInt + ?BigInt => ?BigInt. Both operands need to \"may be a BigInt\"\n      // for a possible BigInt result from this operator. This is true because\n      // there's no automative BigInt type conversion.\n      Type mayBeBigInt = (isBigIntOrObject(LeftTy) && isBigIntOrObject(RightTy))\n          ? Type::createBigInt()\n          : Type::createNoType();\n\n      // handy alias for number|maybe(BigInt).\n      Type numeric = Type::unionTy(Type::createNumber(), mayBeBigInt);\n\n      // If both sides of the binary operand are known and both sides are known\n      // to be non-string (and can't be converted to strings) then the result\n      // must be of a numeric type.\n      if (isSideEffectFree(LeftTy) && isSideEffectFree(RightTy) &&\n          !LeftTy.canBeString() && !RightTy.canBeString()) {\n        BOI->setType(numeric);\n        return true;\n      }\n\n      // The plus operator always returns a number, bigint, or a string.\n      BOI->setType(Type::unionTy(numeric, Type::createString()));\n      return false;\n    }\n\n    // https://tc39.es/ecma262/#sec-binary-bitwise-operators\n    case BinaryOperatorInst::OpKind::AndKind:\n    case BinaryOperatorInst::OpKind::OrKind:\n    case BinaryOperatorInst::OpKind::XorKind:\n      return inferBinaryBitwise(BOI);\n\n    default:\n      break;\n  }\n  return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -66,7 +66,7 @@\n       // ?BigInt + ?BigInt => ?BigInt. Both operands need to \"may be a BigInt\"\n       // for a possible BigInt result from this operator. This is true because\n       // there's no automative BigInt type conversion.\n-      Type mayBeBigInt = (LeftTy.canBeBigInt() && RightTy.canBeBigInt())\n+      Type mayBeBigInt = (isBigIntOrObject(LeftTy) && isBigIntOrObject(RightTy))\n           ? Type::createBigInt()\n           : Type::createNoType();\n ",
        "diff_line_info": {
            "deleted_lines": [
                "      Type mayBeBigInt = (LeftTy.canBeBigInt() && RightTy.canBeBigInt())"
            ],
            "added_lines": [
                "      Type mayBeBigInt = (isBigIntOrObject(LeftTy) && isBigIntOrObject(RightTy))"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-25933",
        "func_name": "facebook/hermes/inferBinaryBitwise",
        "description": "A type confusion bug in TypedArray prior to commit e6ed9c1a4b02dc219de1648f44cd808a56171b81 could have been used by a malicious attacker to execute arbitrary code via untrusted JavaScript. Note that this is only exploitable in cases where Hermes is used to execute untrusted JavaScript. Hence, most React Native applications are not affected.",
        "git_url": "https://github.com/facebook/hermes/commit/e6ed9c1a4b02dc219de1648f44cd808a56171b81",
        "commit_title": "Re-sync with internal repository (#960)",
        "commit_text": " Co-authored-by: Facebook Community Bot <6422482+facebook-github-bot@users.noreply.github.com>",
        "func_before": "static bool inferBinaryBitwise(BinaryOperatorInst *BOI) {\n  Type LeftTy = BOI->getLeftHandSide()->getType();\n  Type RightTy = BOI->getRightHandSide()->getType();\n\n  Type mayBeBigInt = LeftTy.canBeBigInt() && RightTy.canBeBigInt()\n      ? Type::createBigInt()\n      : Type::createNoType();\n\n  // ?? - ?? => Int32|?BigInt. BigInt is only possible if both operands can be\n  // BigInt due to the no automatic BigInt conversion.\n  BOI->setType(Type::unionTy(Type::createInt32(), mayBeBigInt));\n  return true;\n}",
        "func": "static bool inferBinaryBitwise(BinaryOperatorInst *BOI) {\n  Type LeftTy = BOI->getLeftHandSide()->getType();\n  Type RightTy = BOI->getRightHandSide()->getType();\n\n  Type mayBeBigInt = (isBigIntOrObject(LeftTy) && isBigIntOrObject(RightTy))\n      ? Type::createBigInt()\n      : Type::createNoType();\n\n  // ?? - ?? => Int32|?BigInt. BigInt is only possible if both operands are\n  // BigInt|Object due to the no automatic BigInt conversion.\n  BOI->setType(Type::unionTy(Type::createInt32(), mayBeBigInt));\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,12 +2,12 @@\n   Type LeftTy = BOI->getLeftHandSide()->getType();\n   Type RightTy = BOI->getRightHandSide()->getType();\n \n-  Type mayBeBigInt = LeftTy.canBeBigInt() && RightTy.canBeBigInt()\n+  Type mayBeBigInt = (isBigIntOrObject(LeftTy) && isBigIntOrObject(RightTy))\n       ? Type::createBigInt()\n       : Type::createNoType();\n \n-  // ?? - ?? => Int32|?BigInt. BigInt is only possible if both operands can be\n-  // BigInt due to the no automatic BigInt conversion.\n+  // ?? - ?? => Int32|?BigInt. BigInt is only possible if both operands are\n+  // BigInt|Object due to the no automatic BigInt conversion.\n   BOI->setType(Type::unionTy(Type::createInt32(), mayBeBigInt));\n   return true;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  Type mayBeBigInt = LeftTy.canBeBigInt() && RightTy.canBeBigInt()",
                "  // ?? - ?? => Int32|?BigInt. BigInt is only possible if both operands can be",
                "  // BigInt due to the no automatic BigInt conversion."
            ],
            "added_lines": [
                "  Type mayBeBigInt = (isBigIntOrObject(LeftTy) && isBigIntOrObject(RightTy))",
                "  // ?? - ?? => Int32|?BigInt. BigInt is only possible if both operands are",
                "  // BigInt|Object due to the no automatic BigInt conversion."
            ]
        }
    },
    {
        "cve_id": "CVE-2023-25933",
        "func_name": "facebook/hermes/typedArrayPrototypeAt",
        "description": "A type confusion bug in TypedArray prior to commit e6ed9c1a4b02dc219de1648f44cd808a56171b81 could have been used by a malicious attacker to execute arbitrary code via untrusted JavaScript. Note that this is only exploitable in cases where Hermes is used to execute untrusted JavaScript. Hence, most React Native applications are not affected.",
        "git_url": "https://github.com/facebook/hermes/commit/e6ed9c1a4b02dc219de1648f44cd808a56171b81",
        "commit_title": "Re-sync with internal repository (#960)",
        "commit_text": " Co-authored-by: Facebook Community Bot <6422482+facebook-github-bot@users.noreply.github.com>",
        "func_before": "CallResult<HermesValue>\ntypedArrayPrototypeAt(void *, Runtime &runtime, NativeArgs args) {\n  // 1. Let O be the this value.\n  // 2. Perform ? ValidateTypedArray(O).\n  if (LLVM_UNLIKELY(\n          JSTypedArrayBase::validateTypedArray(\n              runtime, args.getThisHandle(), true) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  GCScope gcScope{runtime};\n\n  auto O = args.vmcastThis<JSTypedArrayBase>();\n\n  // 3. Let len be O.[[ArrayLength]].\n  // The this objects [[ArrayLength]] internal slot is accessed in place of\n  // performing a [[Get]] of \"length\".\n  double len = O->getLength();\n\n  // 4. Let relativeIndex be ? ToIntegerOrInfinity(index).\n  auto idx = args.getArgHandle(0);\n  auto relativeIndexRes = toIntegerOrInfinity(runtime, idx);\n  if (relativeIndexRes == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  const double relativeIndex = relativeIndexRes->getNumber();\n\n  double k;\n  // 5. If relativeIndex  0, then\n  if (relativeIndex >= 0) {\n    // a. Let k be relativeIndex.\n    k = relativeIndex;\n  } else {\n    // 6. Else,\n    // a. Let k be len + relativeIndex.\n    k = len + relativeIndex;\n  }\n\n  // 7. If k < 0 or k  len, return undefined.\n  if (k < 0 || k >= len) {\n    return HermesValue::encodeUndefinedValue();\n  }\n\n  // 8. Return ? Get(O, ! ToString((k))).\n  // Since we know we have a TypedArray, we can directly call JSTypedArray::at\n  // rather than getComputed_RJS like the spec mandates.\n#define TYPED_ARRAY(name, type)                                            \\\n  case CellKind::name##ArrayKind: {                                        \\\n    auto *arr = vmcast<JSTypedArray<type, CellKind::name##ArrayKind>>(*O); \\\n    if (!arr->attached(runtime)) {                                         \\\n      return runtime.raiseTypeError(\"Underlying ArrayBuffer detached\");    \\\n    }                                                                      \\\n    return HermesValue::encodeNumberValue(arr->at(runtime, k));            \\\n  }\n  switch (O->getKind()) {\n#include \"hermes/VM/TypedArrays.def\"\n    default:\n      llvm_unreachable(\"Invalid TypedArray after ValidateTypedArray call\");\n  }\n}",
        "func": "CallResult<HermesValue>\ntypedArrayPrototypeAt(void *, Runtime &runtime, NativeArgs args) {\n  // 1. Let O be the this value.\n  // 2. Perform ? ValidateTypedArray(O).\n  if (LLVM_UNLIKELY(\n          JSTypedArrayBase::validateTypedArray(\n              runtime, args.getThisHandle(), true) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  GCScope gcScope{runtime};\n\n  auto O = args.vmcastThis<JSTypedArrayBase>();\n\n  // 3. Let len be O.[[ArrayLength]].\n  // The this objects [[ArrayLength]] internal slot is accessed in place of\n  // performing a [[Get]] of \"length\".\n  double len = O->getLength();\n\n  // 4. Let relativeIndex be ? ToIntegerOrInfinity(index).\n  auto idx = args.getArgHandle(0);\n  auto relativeIndexRes = toIntegerOrInfinity(runtime, idx);\n  if (relativeIndexRes == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  const double relativeIndex = relativeIndexRes->getNumber();\n\n  double k;\n  // 5. If relativeIndex  0, then\n  if (relativeIndex >= 0) {\n    // a. Let k be relativeIndex.\n    k = relativeIndex;\n  } else {\n    // 6. Else,\n    // a. Let k be len + relativeIndex.\n    k = len + relativeIndex;\n  }\n\n  // 7. If k < 0 or k  len, return undefined.\n  if (k < 0 || k >= len) {\n    return HermesValue::encodeUndefinedValue();\n  }\n\n  // 8. Return ? Get(O, ! ToString((k))).\n  // Since we know we have a TypedArray, we can directly call JSTypedArray::at\n  // rather than getComputed_RJS like the spec mandates.\n#define TYPED_ARRAY(name, type)                                            \\\n  case CellKind::name##ArrayKind: {                                        \\\n    auto *arr = vmcast<JSTypedArray<type, CellKind::name##ArrayKind>>(*O); \\\n    if (!arr->attached(runtime)) {                                         \\\n      return runtime.raiseTypeError(\"Underlying ArrayBuffer detached\");    \\\n    }                                                                      \\\n    return HermesValue::encodeUntrustedNumberValue(arr->at(runtime, k));   \\\n  }\n  switch (O->getKind()) {\n#include \"hermes/VM/TypedArrays.def\"\n    default:\n      llvm_unreachable(\"Invalid TypedArray after ValidateTypedArray call\");\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -50,7 +50,7 @@\n     if (!arr->attached(runtime)) {                                         \\\n       return runtime.raiseTypeError(\"Underlying ArrayBuffer detached\");    \\\n     }                                                                      \\\n-    return HermesValue::encodeNumberValue(arr->at(runtime, k));            \\\n+    return HermesValue::encodeUntrustedNumberValue(arr->at(runtime, k));   \\\n   }\n   switch (O->getKind()) {\n #include \"hermes/VM/TypedArrays.def\"",
        "diff_line_info": {
            "deleted_lines": [
                "    return HermesValue::encodeNumberValue(arr->at(runtime, k));            \\"
            ],
            "added_lines": [
                "    return HermesValue::encodeUntrustedNumberValue(arr->at(runtime, k));   \\"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19391",
        "func_name": "LuaJIT/lj_debug_getinfo",
        "description": "In LuaJIT through 2.0.5, as used in Moonjit before 2.1.2 and other products, debug.getinfo has a type confusion issue that leads to arbitrary memory write or read operations, because certain cases involving valid stack levels and > options are mishandled. NOTE: The LuaJIT project owner states that the debug libary is unsafe by definition and that this is not a vulnerability. When LuaJIT was originally developed, the expectation was that the entire debug library had no security guarantees and thus it made no sense to assign CVEs. However, not all users of later LuaJIT derivatives share this perspective",
        "git_url": "https://github.com/LuaJIT/LuaJIT/commit/c017b2bafc24f71620de7225c5fdcd4a71ff2593",
        "commit_title": "Fix vulnerability in debug.getinfo",
        "commit_text": "",
        "func_before": "int lj_debug_getinfo(lua_State *L, const char *what, lj_Debug *ar, int ext)\n{\n  int opt_f = 0, opt_L = 0;\n  TValue *frame = NULL;\n  TValue *nextframe = NULL;\n  GCfunc *fn;\n  if (*what == '>') {\n    TValue *func = L->top - 1;\n    api_check(L, tvisfunc(func));\n    fn = funcV(func);\n    L->top--;\n    what++;\n  } else {\n    uint32_t offset = (uint32_t)ar->i_ci & 0xffff;\n    uint32_t size = (uint32_t)ar->i_ci >> 16;\n    lua_assert(offset != 0);\n    frame = tvref(L->stack) + offset;\n    if (size) nextframe = frame + size;\n    lua_assert(frame <= tvref(L->maxstack) &&\n\t       (!nextframe || nextframe <= tvref(L->maxstack)));\n    fn = frame_func(frame);\n    lua_assert(fn->c.gct == ~LJ_TFUNC);\n  }\n  for (; *what; what++) {\n    if (*what == 'S') {\n      if (isluafunc(fn)) {\n\tGCproto *pt = funcproto(fn);\n\tBCLine firstline = pt->firstline;\n\tGCstr *name = proto_chunkname(pt);\n\tar->source = strdata(name);\n\tlj_debug_shortname(ar->short_src, name, pt->firstline);\n\tar->linedefined = (int)firstline;\n\tar->lastlinedefined = (int)(firstline + pt->numline);\n\tar->what = (firstline || !pt->numline) ? \"Lua\" : \"main\";\n      } else {\n\tar->source = \"=[C]\";\n\tar->short_src[0] = '[';\n\tar->short_src[1] = 'C';\n\tar->short_src[2] = ']';\n\tar->short_src[3] = '\\0';\n\tar->linedefined = -1;\n\tar->lastlinedefined = -1;\n\tar->what = \"C\";\n      }\n    } else if (*what == 'l') {\n      ar->currentline = frame ? debug_frameline(L, fn, nextframe) : -1;\n    } else if (*what == 'u') {\n      ar->nups = fn->c.nupvalues;\n      if (ext) {\n\tif (isluafunc(fn)) {\n\t  GCproto *pt = funcproto(fn);\n\t  ar->nparams = pt->numparams;\n\t  ar->isvararg = !!(pt->flags & PROTO_VARARG);\n\t} else {\n\t  ar->nparams = 0;\n\t  ar->isvararg = 1;\n\t}\n      }\n    } else if (*what == 'n') {\n      ar->namewhat = frame ? lj_debug_funcname(L, frame, &ar->name) : NULL;\n      if (ar->namewhat == NULL) {\n\tar->namewhat = \"\";\n\tar->name = NULL;\n      }\n    } else if (*what == 'f') {\n      opt_f = 1;\n    } else if (*what == 'L') {\n      opt_L = 1;\n    } else {\n      return 0;  /* Bad option. */\n    }\n  }\n  if (opt_f) {\n    setfuncV(L, L->top, fn);\n    incr_top(L);\n  }\n  if (opt_L) {\n    if (isluafunc(fn)) {\n      GCtab *t = lj_tab_new(L, 0, 0);\n      GCproto *pt = funcproto(fn);\n      const void *lineinfo = proto_lineinfo(pt);\n      if (lineinfo) {\n\tBCLine first = pt->firstline;\n\tint sz = pt->numline < 256 ? 1 : pt->numline < 65536 ? 2 : 4;\n\tMSize i, szl = pt->sizebc-1;\n\tfor (i = 0; i < szl; i++) {\n\t  BCLine line = first +\n\t    (sz == 1 ? (BCLine)((const uint8_t *)lineinfo)[i] :\n\t     sz == 2 ? (BCLine)((const uint16_t *)lineinfo)[i] :\n\t     (BCLine)((const uint32_t *)lineinfo)[i]);\n\t  setboolV(lj_tab_setint(L, t, line), 1);\n\t}\n      }\n      settabV(L, L->top, t);\n    } else {\n      setnilV(L->top);\n    }\n    incr_top(L);\n  }\n  return 1;  /* Ok. */\n}",
        "func": "int lj_debug_getinfo(lua_State *L, const char *what, lj_Debug *ar, int ext)\n{\n  int opt_f = 0, opt_L = 0;\n  TValue *frame = NULL;\n  TValue *nextframe = NULL;\n  GCfunc *fn;\n  if (*what == '>') {\n    TValue *func = L->top - 1;\n    if (!tvisfunc(func))\n\t  return 0;\n    fn = funcV(func);\n    L->top--;\n    what++;\n  } else {\n    uint32_t offset = (uint32_t)ar->i_ci & 0xffff;\n    uint32_t size = (uint32_t)ar->i_ci >> 16;\n    lua_assert(offset != 0);\n    frame = tvref(L->stack) + offset;\n    if (size) nextframe = frame + size;\n    lua_assert(frame <= tvref(L->maxstack) &&\n\t       (!nextframe || nextframe <= tvref(L->maxstack)));\n    fn = frame_func(frame);\n    lua_assert(fn->c.gct == ~LJ_TFUNC);\n  }\n  for (; *what; what++) {\n    if (*what == 'S') {\n      if (isluafunc(fn)) {\n\tGCproto *pt = funcproto(fn);\n\tBCLine firstline = pt->firstline;\n\tGCstr *name = proto_chunkname(pt);\n\tar->source = strdata(name);\n\tlj_debug_shortname(ar->short_src, name, pt->firstline);\n\tar->linedefined = (int)firstline;\n\tar->lastlinedefined = (int)(firstline + pt->numline);\n\tar->what = (firstline || !pt->numline) ? \"Lua\" : \"main\";\n      } else {\n\tar->source = \"=[C]\";\n\tar->short_src[0] = '[';\n\tar->short_src[1] = 'C';\n\tar->short_src[2] = ']';\n\tar->short_src[3] = '\\0';\n\tar->linedefined = -1;\n\tar->lastlinedefined = -1;\n\tar->what = \"C\";\n      }\n    } else if (*what == 'l') {\n      ar->currentline = frame ? debug_frameline(L, fn, nextframe) : -1;\n    } else if (*what == 'u') {\n      ar->nups = fn->c.nupvalues;\n      if (ext) {\n\tif (isluafunc(fn)) {\n\t  GCproto *pt = funcproto(fn);\n\t  ar->nparams = pt->numparams;\n\t  ar->isvararg = !!(pt->flags & PROTO_VARARG);\n\t} else {\n\t  ar->nparams = 0;\n\t  ar->isvararg = 1;\n\t}\n      }\n    } else if (*what == 'n') {\n      ar->namewhat = frame ? lj_debug_funcname(L, frame, &ar->name) : NULL;\n      if (ar->namewhat == NULL) {\n\tar->namewhat = \"\";\n\tar->name = NULL;\n      }\n    } else if (*what == 'f') {\n      opt_f = 1;\n    } else if (*what == 'L') {\n      opt_L = 1;\n    } else {\n      return 0;  /* Bad option. */\n    }\n  }\n  if (opt_f) {\n    setfuncV(L, L->top, fn);\n    incr_top(L);\n  }\n  if (opt_L) {\n    if (isluafunc(fn)) {\n      GCtab *t = lj_tab_new(L, 0, 0);\n      GCproto *pt = funcproto(fn);\n      const void *lineinfo = proto_lineinfo(pt);\n      if (lineinfo) {\n\tBCLine first = pt->firstline;\n\tint sz = pt->numline < 256 ? 1 : pt->numline < 65536 ? 2 : 4;\n\tMSize i, szl = pt->sizebc-1;\n\tfor (i = 0; i < szl; i++) {\n\t  BCLine line = first +\n\t    (sz == 1 ? (BCLine)((const uint8_t *)lineinfo)[i] :\n\t     sz == 2 ? (BCLine)((const uint16_t *)lineinfo)[i] :\n\t     (BCLine)((const uint32_t *)lineinfo)[i]);\n\t  setboolV(lj_tab_setint(L, t, line), 1);\n\t}\n      }\n      settabV(L, L->top, t);\n    } else {\n      setnilV(L->top);\n    }\n    incr_top(L);\n  }\n  return 1;  /* Ok. */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,8 @@\n   GCfunc *fn;\n   if (*what == '>') {\n     TValue *func = L->top - 1;\n-    api_check(L, tvisfunc(func));\n+    if (!tvisfunc(func))\n+\t  return 0;\n     fn = funcV(func);\n     L->top--;\n     what++;",
        "diff_line_info": {
            "deleted_lines": [
                "    api_check(L, tvisfunc(func));"
            ],
            "added_lines": [
                "    if (!tvisfunc(func))",
                "\t  return 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-5815",
        "func_name": "GNOME/libxslt/xsltNumberFormatGetMultipleLevel",
        "description": "Type confusion in xsltNumberFormatGetMultipleLevel prior to libxslt 1.1.33 could allow attackers to potentially exploit heap corruption via crafted XML data.",
        "git_url": "https://github.com/GNOME/libxslt/commit/08b62c25871b38d5d573515ca8a065b4b8f64f6b",
        "commit_title": "Always set context node before calling XPath iterators",
        "commit_text": " The xmlXPathNext* iterators rely on the XPath context node being set to the start node of the iteration. Some parts of the code base like the xsl:key functions also leave the context node in an unspecified state. Make sure that the context node is reset before invoking the XPath iterators. Also backup and restore the context node in xsltNumberFormatGetMultipleLevel for good measure.  This bug could also lead to type confusion and invalid reads in connection with namespace nodes.  Fixes #13. Also see the Chromium bug report:  https://bugs.chromium.org/p/chromium/issues/detail?id=930663  Thanks to Nicolas Grgoire for the report.",
        "func_before": "static int\nxsltNumberFormatGetMultipleLevel(xsltTransformContextPtr context,\n\t\t\t\t xmlNodePtr node,\n\t\t\t\t xsltCompMatchPtr countPat,\n\t\t\t\t xsltCompMatchPtr fromPat,\n\t\t\t\t double *array,\n\t\t\t\t int max)\n{\n    int amount = 0;\n    int cnt;\n    xmlNodePtr ancestor;\n    xmlNodePtr preceding;\n    xmlXPathParserContextPtr parser;\n\n    context->xpathCtxt->node = node;\n    parser = xmlXPathNewParserContext(NULL, context->xpathCtxt);\n    if (parser) {\n\t/* ancestor-or-self::*[count] */\n\tfor (ancestor = node;\n\t     (ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE);\n\t     ancestor = xmlXPathNextAncestor(parser, ancestor)) {\n\n\t    if ((fromPat != NULL) &&\n\t\txsltTestCompMatchList(context, ancestor, fromPat))\n\t\tbreak; /* for */\n\n\t    if (xsltTestCompMatchCount(context, ancestor, countPat, node)) {\n\t\t/* count(preceding-sibling::*) */\n\t\tcnt = 1;\n\t\tfor (preceding =\n                        xmlXPathNextPrecedingSibling(parser, ancestor);\n\t\t     preceding != NULL;\n\t\t     preceding =\n\t\t        xmlXPathNextPrecedingSibling(parser, preceding)) {\n\n\t            if (xsltTestCompMatchCount(context, preceding, countPat,\n                                               node))\n\t\t\tcnt++;\n\t\t}\n\t\tarray[amount++] = (double)cnt;\n\t\tif (amount >= max)\n\t\t    break; /* for */\n\t    }\n\t}\n\txmlXPathFreeParserContext(parser);\n    }\n    return amount;\n}",
        "func": "static int\nxsltNumberFormatGetMultipleLevel(xsltTransformContextPtr context,\n\t\t\t\t xmlNodePtr node,\n\t\t\t\t xsltCompMatchPtr countPat,\n\t\t\t\t xsltCompMatchPtr fromPat,\n\t\t\t\t double *array,\n\t\t\t\t int max)\n{\n    int amount = 0;\n    int cnt;\n    xmlNodePtr oldCtxtNode;\n    xmlNodePtr ancestor;\n    xmlNodePtr preceding;\n    xmlXPathParserContextPtr parser;\n\n    oldCtxtNode = context->xpathCtxt->node;\n    parser = xmlXPathNewParserContext(NULL, context->xpathCtxt);\n    if (parser) {\n\t/* ancestor-or-self::*[count] */\n\tancestor = node;\n\twhile ((ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE)) {\n\t    if ((fromPat != NULL) &&\n\t\txsltTestCompMatchList(context, ancestor, fromPat))\n\t\tbreak; /* for */\n\n            /*\n             * The xmlXPathNext* iterators require that the context node is\n             * set to the start node. Calls to xsltTestCompMatch* may also\n             * leave the context node in an undefined state, so make sure\n             * that the context node is reset before each iterator invocation.\n             */\n\n\t    if (xsltTestCompMatchCount(context, ancestor, countPat, node)) {\n\t\t/* count(preceding-sibling::*) */\n\t\tcnt = 1;\n                context->xpathCtxt->node = ancestor;\n                preceding = xmlXPathNextPrecedingSibling(parser, ancestor);\n                while (preceding != NULL) {\n\t            if (xsltTestCompMatchCount(context, preceding, countPat,\n                                               node))\n\t\t\tcnt++;\n                    context->xpathCtxt->node = ancestor;\n                    preceding =\n                        xmlXPathNextPrecedingSibling(parser, preceding);\n\t\t}\n\t\tarray[amount++] = (double)cnt;\n\t\tif (amount >= max)\n\t\t    break; /* for */\n\t    }\n            context->xpathCtxt->node = node;\n            ancestor = xmlXPathNextAncestor(parser, ancestor);\n\t}\n\txmlXPathFreeParserContext(parser);\n    }\n    context->xpathCtxt->node = oldCtxtNode;\n    return amount;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,41 +8,50 @@\n {\n     int amount = 0;\n     int cnt;\n+    xmlNodePtr oldCtxtNode;\n     xmlNodePtr ancestor;\n     xmlNodePtr preceding;\n     xmlXPathParserContextPtr parser;\n \n-    context->xpathCtxt->node = node;\n+    oldCtxtNode = context->xpathCtxt->node;\n     parser = xmlXPathNewParserContext(NULL, context->xpathCtxt);\n     if (parser) {\n \t/* ancestor-or-self::*[count] */\n-\tfor (ancestor = node;\n-\t     (ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE);\n-\t     ancestor = xmlXPathNextAncestor(parser, ancestor)) {\n-\n+\tancestor = node;\n+\twhile ((ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE)) {\n \t    if ((fromPat != NULL) &&\n \t\txsltTestCompMatchList(context, ancestor, fromPat))\n \t\tbreak; /* for */\n \n+            /*\n+             * The xmlXPathNext* iterators require that the context node is\n+             * set to the start node. Calls to xsltTestCompMatch* may also\n+             * leave the context node in an undefined state, so make sure\n+             * that the context node is reset before each iterator invocation.\n+             */\n+\n \t    if (xsltTestCompMatchCount(context, ancestor, countPat, node)) {\n \t\t/* count(preceding-sibling::*) */\n \t\tcnt = 1;\n-\t\tfor (preceding =\n-                        xmlXPathNextPrecedingSibling(parser, ancestor);\n-\t\t     preceding != NULL;\n-\t\t     preceding =\n-\t\t        xmlXPathNextPrecedingSibling(parser, preceding)) {\n-\n+                context->xpathCtxt->node = ancestor;\n+                preceding = xmlXPathNextPrecedingSibling(parser, ancestor);\n+                while (preceding != NULL) {\n \t            if (xsltTestCompMatchCount(context, preceding, countPat,\n                                                node))\n \t\t\tcnt++;\n+                    context->xpathCtxt->node = ancestor;\n+                    preceding =\n+                        xmlXPathNextPrecedingSibling(parser, preceding);\n \t\t}\n \t\tarray[amount++] = (double)cnt;\n \t\tif (amount >= max)\n \t\t    break; /* for */\n \t    }\n+            context->xpathCtxt->node = node;\n+            ancestor = xmlXPathNextAncestor(parser, ancestor);\n \t}\n \txmlXPathFreeParserContext(parser);\n     }\n+    context->xpathCtxt->node = oldCtxtNode;\n     return amount;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    context->xpathCtxt->node = node;",
                "\tfor (ancestor = node;",
                "\t     (ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE);",
                "\t     ancestor = xmlXPathNextAncestor(parser, ancestor)) {",
                "",
                "\t\tfor (preceding =",
                "                        xmlXPathNextPrecedingSibling(parser, ancestor);",
                "\t\t     preceding != NULL;",
                "\t\t     preceding =",
                "\t\t        xmlXPathNextPrecedingSibling(parser, preceding)) {",
                ""
            ],
            "added_lines": [
                "    xmlNodePtr oldCtxtNode;",
                "    oldCtxtNode = context->xpathCtxt->node;",
                "\tancestor = node;",
                "\twhile ((ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE)) {",
                "            /*",
                "             * The xmlXPathNext* iterators require that the context node is",
                "             * set to the start node. Calls to xsltTestCompMatch* may also",
                "             * leave the context node in an undefined state, so make sure",
                "             * that the context node is reset before each iterator invocation.",
                "             */",
                "",
                "                context->xpathCtxt->node = ancestor;",
                "                preceding = xmlXPathNextPrecedingSibling(parser, ancestor);",
                "                while (preceding != NULL) {",
                "                    context->xpathCtxt->node = ancestor;",
                "                    preceding =",
                "                        xmlXPathNextPrecedingSibling(parser, preceding);",
                "            context->xpathCtxt->node = node;",
                "            ancestor = xmlXPathNextAncestor(parser, ancestor);",
                "    context->xpathCtxt->node = oldCtxtNode;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-24045",
        "func_name": "facebook/hermes/hermes::evalUnaryOperator",
        "description": "A type confusion vulnerability could be triggered when resolving the \"typeof\" unary operator in Facebook Hermes prior to v0.10.0. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.",
        "git_url": "https://github.com/facebook/hermes/commit/55e1b2343f4deb1a1b5726cfe1e23b2068217ff2",
        "commit_title": "Handle typeof applied to empty in InstSimplify",
        "commit_text": " Summary: Do not simplify `typeof` if it is applied to an invalid type. This handles a case like the one in the added test, where `typeof` is called on a literal empty in unreachable code.  Reviewed By: kodafb  Differential Revision: D31000173  fbshipit-source-id: 2d7f69cbcc9c1bb0a916585c07171089444c85dc",
        "func_before": "Literal *hermes::evalUnaryOperator(\n    UnaryOperatorInst::OpKind kind,\n    IRBuilder &builder,\n    Literal *operand) {\n  switch (kind) {\n    case UnaryOperatorInst::OpKind::MinusKind:\n      // Negate constant integers.\n      switch (operand->getKind()) {\n        case ValueKind::LiteralNumberKind:\n          if (auto *literalNum = llvh::dyn_cast<LiteralNumber>(operand)) {\n            auto V = -literalNum->getValue();\n            return builder.getLiteralNumber(V);\n          }\n          break;\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralNaN();\n        case ValueKind::LiteralBoolKind:\n          if (evalIsTrue(builder, operand)) {\n            return builder.getLiteralNumber(-1);\n          } else { // evalIsFalse(operand)\n            return builder.getLiteralNegativeZero();\n          }\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralNegativeZero();\n        default:\n          break;\n      }\n      break;\n    case UnaryOperatorInst::OpKind::TypeofKind:\n      switch (operand->getKind()) {\n        case ValueKind::GlobalObjectKind:\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralString(\"object\");\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralString(\"undefined\");\n        case ValueKind::LiteralBoolKind:\n          return builder.getLiteralString(\"boolean\");\n        case ValueKind::LiteralNumberKind:\n          return builder.getLiteralString(\"number\");\n        case ValueKind::LiteralStringKind:\n          return builder.getLiteralString(\"string\");\n        default:\n          llvm_unreachable(\"Invalid literal kind.\");\n      }\n      break;\n\n    case UnaryOperatorInst::OpKind::BangKind:\n      if (evalIsTrue(builder, operand)) {\n        return builder.getLiteralBool(false);\n      }\n      if (evalIsFalse(builder, operand)) {\n        return builder.getLiteralBool(true);\n      }\n      break;\n\n    case UnaryOperatorInst::OpKind::VoidKind:\n      return builder.getLiteralUndefined();\n\n    default:\n      break;\n  }\n\n  return nullptr;\n}",
        "func": "Literal *hermes::evalUnaryOperator(\n    UnaryOperatorInst::OpKind kind,\n    IRBuilder &builder,\n    Literal *operand) {\n  switch (kind) {\n    case UnaryOperatorInst::OpKind::MinusKind:\n      // Negate constant integers.\n      switch (operand->getKind()) {\n        case ValueKind::LiteralNumberKind:\n          if (auto *literalNum = llvh::dyn_cast<LiteralNumber>(operand)) {\n            auto V = -literalNum->getValue();\n            return builder.getLiteralNumber(V);\n          }\n          break;\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralNaN();\n        case ValueKind::LiteralBoolKind:\n          if (evalIsTrue(builder, operand)) {\n            return builder.getLiteralNumber(-1);\n          } else { // evalIsFalse(operand)\n            return builder.getLiteralNegativeZero();\n          }\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralNegativeZero();\n        default:\n          break;\n      }\n      break;\n    case UnaryOperatorInst::OpKind::TypeofKind:\n      switch (operand->getKind()) {\n        case ValueKind::GlobalObjectKind:\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralString(\"object\");\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralString(\"undefined\");\n        case ValueKind::LiteralBoolKind:\n          return builder.getLiteralString(\"boolean\");\n        case ValueKind::LiteralNumberKind:\n          return builder.getLiteralString(\"number\");\n        case ValueKind::LiteralStringKind:\n          return builder.getLiteralString(\"string\");\n        default:\n          break;\n      }\n      break;\n\n    case UnaryOperatorInst::OpKind::BangKind:\n      if (evalIsTrue(builder, operand)) {\n        return builder.getLiteralBool(false);\n      }\n      if (evalIsFalse(builder, operand)) {\n        return builder.getLiteralBool(true);\n      }\n      break;\n\n    case UnaryOperatorInst::OpKind::VoidKind:\n      return builder.getLiteralUndefined();\n\n    default:\n      break;\n  }\n\n  return nullptr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,7 +40,7 @@\n         case ValueKind::LiteralStringKind:\n           return builder.getLiteralString(\"string\");\n         default:\n-          llvm_unreachable(\"Invalid literal kind.\");\n+          break;\n       }\n       break;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "          llvm_unreachable(\"Invalid literal kind.\");"
            ],
            "added_lines": [
                "          break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-21287",
        "func_name": "android/sfnt_init_face",
        "description": "In multiple locations, there is a possible code execution due to type confusion. This could lead to remote code execution with no additional execution privileges needed. User interaction is not needed for exploitation.\n\n",
        "git_url": "https://android.googlesource.com/platform/external/freetype/+/a79e80a25874dacaa266906a9048f13d4bac41c6",
        "commit_title": "Cherrypick following three changes",
        "commit_text": " [cherrypick 545bf3a27] [sfnt, truetype] Add `size_reset` to `MetricsVariations`. [cherrypick daad10810] [truetype] tt_size_reset_height to take FT_Size [cherrypick 51ad7b243] [services] FT_Size_Reset_Func to return FT_Error  Bug: 278221085 Test: TreeHugger (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:9fe9411db4b7e715a39c0ccf48d1e0328f1d8e7c) (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:cff127c5bc4a47ef88df305380ee2a47318a865b) Merged-In: I7e839b2a36e35c27974a82cc76e853996a7c7688 ",
        "func_before": "FT_LOCAL_DEF( FT_Error )\n  sfnt_init_face( FT_Stream      stream,\n                  TT_Face        face,\n                  FT_Int         face_instance_index,\n                  FT_Int         num_params,\n                  FT_Parameter*  params )\n  {\n    FT_Error      error;\n    FT_Library    library         = face->root.driver->root.library;\n    SFNT_Service  sfnt;\n    FT_Int        face_index;\n    FT_Long       woff2_num_faces = 0;\n\n\n    /* for now, parameters are unused */\n    FT_UNUSED( num_params );\n    FT_UNUSED( params );\n\n\n    sfnt = (SFNT_Service)face->sfnt;\n    if ( !sfnt )\n    {\n      sfnt = (SFNT_Service)FT_Get_Module_Interface( library, \"sfnt\" );\n      if ( !sfnt )\n      {\n        FT_ERROR(( \"sfnt_init_face: cannot access `sfnt' module\\n\" ));\n        return FT_THROW( Missing_Module );\n      }\n\n      face->sfnt       = sfnt;\n      face->goto_table = sfnt->goto_table;\n    }\n\n    FT_FACE_FIND_GLOBAL_SERVICE( face, face->psnames, POSTSCRIPT_CMAPS );\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n    if ( !face->mm )\n    {\n      /* we want the MM interface from the `truetype' module only */\n      FT_Module  tt_module = FT_Get_Module( library, \"truetype\" );\n\n\n      face->mm = ft_module_get_service( tt_module,\n                                        FT_SERVICE_ID_MULTI_MASTERS,\n                                        0 );\n    }\n\n    if ( !face->var )\n    {\n      /* we want the metrics variations interface */\n      /* from the `truetype' module only          */\n      FT_Module  tt_module = FT_Get_Module( library, \"truetype\" );\n\n\n      face->var = ft_module_get_service( tt_module,\n                                         FT_SERVICE_ID_METRICS_VARIATIONS,\n                                         0 );\n    }\n#endif\n\n    FT_TRACE2(( \"SFNT driver\\n\" ));\n\n    error = sfnt_open_font( stream,\n                            face,\n                            &face_instance_index,\n                            &woff2_num_faces );\n    if ( error )\n      return error;\n\n    /* Stream may have changed in sfnt_open_font. */\n    stream = face->root.stream;\n\n    FT_TRACE2(( \"sfnt_init_face: %p (index %d)\\n\",\n                (void *)face,\n                face_instance_index ));\n\n    face_index = FT_ABS( face_instance_index ) & 0xFFFF;\n\n    /* value -(N+1) requests information on index N */\n    if ( face_instance_index < 0 )\n      face_index--;\n\n    if ( face_index >= face->ttc_header.count )\n    {\n      if ( face_instance_index >= 0 )\n        return FT_THROW( Invalid_Argument );\n      else\n        face_index = 0;\n    }\n\n    if ( FT_STREAM_SEEK( face->ttc_header.offsets[face_index] ) )\n      return error;\n\n    /* check whether we have a valid TrueType file */\n    error = sfnt->load_font_dir( face, stream );\n    if ( error )\n      return error;\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n    {\n      FT_Memory  memory = face->root.memory;\n\n      FT_ULong  fvar_len;\n\n      FT_ULong  version;\n      FT_ULong  offset;\n\n      FT_UShort  num_axes;\n      FT_UShort  axis_size;\n      FT_UShort  num_instances;\n      FT_UShort  instance_size;\n\n      FT_Int  instance_index;\n\n      FT_Byte*  default_values  = NULL;\n      FT_Byte*  instance_values = NULL;\n\n\n      instance_index = FT_ABS( face_instance_index ) >> 16;\n\n      /* test whether current face is a GX font with named instances */\n      if ( face->goto_table( face, TTAG_fvar, stream, &fvar_len ) ||\n           fvar_len < 20                                          ||\n           FT_READ_ULONG( version )                               ||\n           FT_READ_USHORT( offset )                               ||\n           FT_STREAM_SKIP( 2 ) /* reserved */                     ||\n           FT_READ_USHORT( num_axes )                             ||\n           FT_READ_USHORT( axis_size )                            ||\n           FT_READ_USHORT( num_instances )                        ||\n           FT_READ_USHORT( instance_size )                        )\n      {\n        version       = 0;\n        offset        = 0;\n        num_axes      = 0;\n        axis_size     = 0;\n        num_instances = 0;\n        instance_size = 0;\n      }\n\n      /* check that the data is bound by the table length */\n      if ( version != 0x00010000UL                    ||\n           axis_size != 20                            ||\n           num_axes == 0                              ||\n           /* `num_axes' limit implied by 16-bit `instance_size' */\n           num_axes > 0x3FFE                          ||\n           !( instance_size == 4 + 4 * num_axes ||\n              instance_size == 6 + 4 * num_axes )     ||\n           /* `num_instances' limit implied by limited range of name IDs */\n           num_instances > 0x7EFF                     ||\n           offset                          +\n             axis_size * num_axes          +\n             instance_size * num_instances > fvar_len )\n        num_instances = 0;\n      else\n        face->variation_support |= TT_FACE_FLAG_VAR_FVAR;\n\n      /*\n       * As documented in the OpenType specification, an entry for the\n       * default instance may be omitted in the named instance table.  In\n       * particular this means that even if there is no named instance\n       * table in the font we actually do have a named instance, namely the\n       * default instance.\n       *\n       * For consistency, we always want the default instance in our list\n       * of named instances.  If it is missing, we try to synthesize it\n       * later on.  Here, we have to adjust `num_instances' accordingly.\n       */\n\n      if ( ( face->variation_support & TT_FACE_FLAG_VAR_FVAR ) &&\n           !( FT_QALLOC(  default_values, num_axes * 4 ) ||\n              FT_QALLOC( instance_values, num_axes * 4 ) )     )\n      {\n        /* the current stream position is 16 bytes after the table start */\n        FT_ULong  array_start = FT_STREAM_POS() - 16 + offset;\n        FT_ULong  default_value_offset, instance_offset;\n\n        FT_Byte*  p;\n        FT_UInt   i;\n\n\n        default_value_offset = array_start + 8;\n        p                    = default_values;\n\n        for ( i = 0; i < num_axes; i++ )\n        {\n          (void)FT_STREAM_READ_AT( default_value_offset, p, 4 );\n\n          default_value_offset += axis_size;\n          p                    += 4;\n        }\n\n        instance_offset = array_start + axis_size * num_axes + 4;\n\n        for ( i = 0; i < num_instances; i++ )\n        {\n          (void)FT_STREAM_READ_AT( instance_offset,\n                                   instance_values,\n                                   num_axes * 4 );\n\n          if ( !ft_memcmp( default_values, instance_values, num_axes * 4 ) )\n            break;\n\n          instance_offset += instance_size;\n        }\n\n        if ( i == num_instances )\n        {\n          /* no default instance in named instance table; */\n          /* we thus have to synthesize it                */\n          num_instances++;\n        }\n      }\n\n      FT_FREE( default_values );\n      FT_FREE( instance_values );\n\n      /* we don't support Multiple Master CFFs yet; */\n      /* note that `glyf' or `CFF2' have precedence */\n      if ( face->goto_table( face, TTAG_glyf, stream, 0 ) &&\n           face->goto_table( face, TTAG_CFF2, stream, 0 ) &&\n           !face->goto_table( face, TTAG_CFF, stream, 0 ) )\n        num_instances = 0;\n\n      /* instance indices in `face_instance_index' start with index 1, */\n      /* thus `>' and not `>='                                         */\n      if ( instance_index > num_instances )\n      {\n        if ( face_instance_index >= 0 )\n          return FT_THROW( Invalid_Argument );\n        else\n          num_instances = 0;\n      }\n\n      face->root.style_flags = (FT_Long)num_instances << 16;\n    }\n#endif\n\n    face->root.num_faces  = face->ttc_header.count;\n    face->root.face_index = face_instance_index;\n\n    /* `num_faces' for a WOFF2 needs to be handled separately. */\n    if ( woff2_num_faces )\n      face->root.num_faces = woff2_num_faces;\n\n    return error;\n  }",
        "func": "FT_LOCAL_DEF( FT_Error )\n  sfnt_init_face( FT_Stream      stream,\n                  TT_Face        face,\n                  FT_Int         face_instance_index,\n                  FT_Int         num_params,\n                  FT_Parameter*  params )\n  {\n    FT_Error      error;\n    FT_Library    library         = face->root.driver->root.library;\n    SFNT_Service  sfnt;\n    FT_Int        face_index;\n    FT_Long       woff2_num_faces = 0;\n\n\n    /* for now, parameters are unused */\n    FT_UNUSED( num_params );\n    FT_UNUSED( params );\n\n\n    sfnt = (SFNT_Service)face->sfnt;\n    if ( !sfnt )\n    {\n      sfnt = (SFNT_Service)FT_Get_Module_Interface( library, \"sfnt\" );\n      if ( !sfnt )\n      {\n        FT_ERROR(( \"sfnt_init_face: cannot access `sfnt' module\\n\" ));\n        return FT_THROW( Missing_Module );\n      }\n\n      face->sfnt       = sfnt;\n      face->goto_table = sfnt->goto_table;\n    }\n\n    FT_FACE_FIND_GLOBAL_SERVICE( face, face->psnames, POSTSCRIPT_CMAPS );\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n    if ( !face->mm )\n    {\n      /* we want the MM interface from the `truetype' module only */\n      FT_Module  tt_module = FT_Get_Module( library, \"truetype\" );\n\n\n      face->mm = ft_module_get_service( tt_module,\n                                        FT_SERVICE_ID_MULTI_MASTERS,\n                                        0 );\n    }\n\n    if ( !face->tt_var )\n    {\n      /* we want the metrics variations interface */\n      /* from the `truetype' module only          */\n      FT_Module  tt_module = FT_Get_Module( library, \"truetype\" );\n\n\n      face->tt_var = ft_module_get_service( tt_module,\n                                            FT_SERVICE_ID_METRICS_VARIATIONS,\n                                            0 );\n    }\n\n    if ( !face->face_var )\n      face->face_var = ft_module_get_service(\n                         &face->root.driver->root,\n                         FT_SERVICE_ID_METRICS_VARIATIONS,\n                         0 );\n#endif\n\n    FT_TRACE2(( \"SFNT driver\\n\" ));\n\n    error = sfnt_open_font( stream,\n                            face,\n                            &face_instance_index,\n                            &woff2_num_faces );\n    if ( error )\n      return error;\n\n    /* Stream may have changed in sfnt_open_font. */\n    stream = face->root.stream;\n\n    FT_TRACE2(( \"sfnt_init_face: %p (index %d)\\n\",\n                (void *)face,\n                face_instance_index ));\n\n    face_index = FT_ABS( face_instance_index ) & 0xFFFF;\n\n    /* value -(N+1) requests information on index N */\n    if ( face_instance_index < 0 )\n      face_index--;\n\n    if ( face_index >= face->ttc_header.count )\n    {\n      if ( face_instance_index >= 0 )\n        return FT_THROW( Invalid_Argument );\n      else\n        face_index = 0;\n    }\n\n    if ( FT_STREAM_SEEK( face->ttc_header.offsets[face_index] ) )\n      return error;\n\n    /* check whether we have a valid TrueType file */\n    error = sfnt->load_font_dir( face, stream );\n    if ( error )\n      return error;\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n    {\n      FT_Memory  memory = face->root.memory;\n\n      FT_ULong  fvar_len;\n\n      FT_ULong  version;\n      FT_ULong  offset;\n\n      FT_UShort  num_axes;\n      FT_UShort  axis_size;\n      FT_UShort  num_instances;\n      FT_UShort  instance_size;\n\n      FT_Int  instance_index;\n\n      FT_Byte*  default_values  = NULL;\n      FT_Byte*  instance_values = NULL;\n\n\n      instance_index = FT_ABS( face_instance_index ) >> 16;\n\n      /* test whether current face is a GX font with named instances */\n      if ( face->goto_table( face, TTAG_fvar, stream, &fvar_len ) ||\n           fvar_len < 20                                          ||\n           FT_READ_ULONG( version )                               ||\n           FT_READ_USHORT( offset )                               ||\n           FT_STREAM_SKIP( 2 ) /* reserved */                     ||\n           FT_READ_USHORT( num_axes )                             ||\n           FT_READ_USHORT( axis_size )                            ||\n           FT_READ_USHORT( num_instances )                        ||\n           FT_READ_USHORT( instance_size )                        )\n      {\n        version       = 0;\n        offset        = 0;\n        num_axes      = 0;\n        axis_size     = 0;\n        num_instances = 0;\n        instance_size = 0;\n      }\n\n      /* check that the data is bound by the table length */\n      if ( version != 0x00010000UL                    ||\n           axis_size != 20                            ||\n           num_axes == 0                              ||\n           /* `num_axes' limit implied by 16-bit `instance_size' */\n           num_axes > 0x3FFE                          ||\n           !( instance_size == 4 + 4 * num_axes ||\n              instance_size == 6 + 4 * num_axes )     ||\n           /* `num_instances' limit implied by limited range of name IDs */\n           num_instances > 0x7EFF                     ||\n           offset                          +\n             axis_size * num_axes          +\n             instance_size * num_instances > fvar_len )\n        num_instances = 0;\n      else\n        face->variation_support |= TT_FACE_FLAG_VAR_FVAR;\n\n      /*\n       * As documented in the OpenType specification, an entry for the\n       * default instance may be omitted in the named instance table.  In\n       * particular this means that even if there is no named instance\n       * table in the font we actually do have a named instance, namely the\n       * default instance.\n       *\n       * For consistency, we always want the default instance in our list\n       * of named instances.  If it is missing, we try to synthesize it\n       * later on.  Here, we have to adjust `num_instances' accordingly.\n       */\n\n      if ( ( face->variation_support & TT_FACE_FLAG_VAR_FVAR ) &&\n           !( FT_QALLOC(  default_values, num_axes * 4 ) ||\n              FT_QALLOC( instance_values, num_axes * 4 ) )     )\n      {\n        /* the current stream position is 16 bytes after the table start */\n        FT_ULong  array_start = FT_STREAM_POS() - 16 + offset;\n        FT_ULong  default_value_offset, instance_offset;\n\n        FT_Byte*  p;\n        FT_UInt   i;\n\n\n        default_value_offset = array_start + 8;\n        p                    = default_values;\n\n        for ( i = 0; i < num_axes; i++ )\n        {\n          (void)FT_STREAM_READ_AT( default_value_offset, p, 4 );\n\n          default_value_offset += axis_size;\n          p                    += 4;\n        }\n\n        instance_offset = array_start + axis_size * num_axes + 4;\n\n        for ( i = 0; i < num_instances; i++ )\n        {\n          (void)FT_STREAM_READ_AT( instance_offset,\n                                   instance_values,\n                                   num_axes * 4 );\n\n          if ( !ft_memcmp( default_values, instance_values, num_axes * 4 ) )\n            break;\n\n          instance_offset += instance_size;\n        }\n\n        if ( i == num_instances )\n        {\n          /* no default instance in named instance table; */\n          /* we thus have to synthesize it                */\n          num_instances++;\n        }\n      }\n\n      FT_FREE( default_values );\n      FT_FREE( instance_values );\n\n      /* we don't support Multiple Master CFFs yet; */\n      /* note that `glyf' or `CFF2' have precedence */\n      if ( face->goto_table( face, TTAG_glyf, stream, 0 ) &&\n           face->goto_table( face, TTAG_CFF2, stream, 0 ) &&\n           !face->goto_table( face, TTAG_CFF, stream, 0 ) )\n        num_instances = 0;\n\n      /* instance indices in `face_instance_index' start with index 1, */\n      /* thus `>' and not `>='                                         */\n      if ( instance_index > num_instances )\n      {\n        if ( face_instance_index >= 0 )\n          return FT_THROW( Invalid_Argument );\n        else\n          num_instances = 0;\n      }\n\n      face->root.style_flags = (FT_Long)num_instances << 16;\n    }\n#endif\n\n    face->root.num_faces  = face->ttc_header.count;\n    face->root.face_index = face_instance_index;\n\n    /* `num_faces' for a WOFF2 needs to be handled separately. */\n    if ( woff2_num_faces )\n      face->root.num_faces = woff2_num_faces;\n\n    return error;\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,17 +45,23 @@\n                                         0 );\n     }\n \n-    if ( !face->var )\n+    if ( !face->tt_var )\n     {\n       /* we want the metrics variations interface */\n       /* from the `truetype' module only          */\n       FT_Module  tt_module = FT_Get_Module( library, \"truetype\" );\n \n \n-      face->var = ft_module_get_service( tt_module,\n-                                         FT_SERVICE_ID_METRICS_VARIATIONS,\n-                                         0 );\n-    }\n+      face->tt_var = ft_module_get_service( tt_module,\n+                                            FT_SERVICE_ID_METRICS_VARIATIONS,\n+                                            0 );\n+    }\n+\n+    if ( !face->face_var )\n+      face->face_var = ft_module_get_service(\n+                         &face->root.driver->root,\n+                         FT_SERVICE_ID_METRICS_VARIATIONS,\n+                         0 );\n #endif\n \n     FT_TRACE2(( \"SFNT driver\\n\" ));",
        "diff_line_info": {
            "deleted_lines": [
                "    if ( !face->var )",
                "      face->var = ft_module_get_service( tt_module,",
                "                                         FT_SERVICE_ID_METRICS_VARIATIONS,",
                "                                         0 );",
                "    }"
            ],
            "added_lines": [
                "    if ( !face->tt_var )",
                "      face->tt_var = ft_module_get_service( tt_module,",
                "                                            FT_SERVICE_ID_METRICS_VARIATIONS,",
                "                                            0 );",
                "    }",
                "",
                "    if ( !face->face_var )",
                "      face->face_var = ft_module_get_service(",
                "                         &face->root.driver->root,",
                "                         FT_SERVICE_ID_METRICS_VARIATIONS,",
                "                         0 );"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-21287",
        "func_name": "android/tt_size_reset",
        "description": "In multiple locations, there is a possible code execution due to type confusion. This could lead to remote code execution with no additional execution privileges needed. User interaction is not needed for exploitation.\n\n",
        "git_url": "https://android.googlesource.com/platform/external/freetype/+/a79e80a25874dacaa266906a9048f13d4bac41c6",
        "commit_title": "Cherrypick following three changes",
        "commit_text": " [cherrypick 545bf3a27] [sfnt, truetype] Add `size_reset` to `MetricsVariations`. [cherrypick daad10810] [truetype] tt_size_reset_height to take FT_Size [cherrypick 51ad7b243] [services] FT_Size_Reset_Func to return FT_Error  Bug: 278221085 Test: TreeHugger (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:9fe9411db4b7e715a39c0ccf48d1e0328f1d8e7c) (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:cff127c5bc4a47ef88df305380ee2a47318a865b) Merged-In: I7e839b2a36e35c27974a82cc76e853996a7c7688 ",
        "func_before": "FT_LOCAL_DEF( FT_Error )\n  tt_size_reset( TT_Size  size,\n                 FT_Bool  only_height )\n  {\n    TT_Face           face;\n    FT_Size_Metrics*  size_metrics;\n\n\n    face = (TT_Face)size->root.face;\n\n    /* nothing to do for CFF2 */\n    if ( face->is_cff2 )\n      return FT_Err_Ok;\n\n    size->ttmetrics.valid = FALSE;\n\n    size_metrics = &size->hinted_metrics;\n\n    /* copy the result from base layer */\n    *size_metrics = size->root.metrics;\n\n    if ( size_metrics->x_ppem < 1 || size_metrics->y_ppem < 1 )\n      return FT_THROW( Invalid_PPem );\n\n    /* This bit flag, if set, indicates that the ppems must be       */\n    /* rounded to integers.  Nearly all TrueType fonts have this bit */\n    /* set, as hinting won't work really well otherwise.             */\n    /*                                                               */\n    if ( face->header.Flags & 8 )\n    {\n      /* the TT spec always asks for ROUND, not FLOOR or CEIL */\n      size_metrics->ascender = FT_PIX_ROUND(\n                                 FT_MulFix( face->root.ascender,\n                                            size_metrics->y_scale ) );\n      size_metrics->descender = FT_PIX_ROUND(\n                                 FT_MulFix( face->root.descender,\n                                            size_metrics->y_scale ) );\n      size_metrics->height = FT_PIX_ROUND(\n                               FT_MulFix( face->root.height,\n                                          size_metrics->y_scale ) );\n    }\n\n    size->ttmetrics.valid = TRUE;\n\n    if ( only_height )\n    {\n      /* we must not recompute the scaling values here since       */\n      /* `tt_size_reset' was already called (with only_height = 0) */\n      return FT_Err_Ok;\n    }\n\n    if ( face->header.Flags & 8 )\n    {\n      /* base scaling values on integer ppem values, */\n      /* as mandated by the TrueType specification   */\n      size_metrics->x_scale = FT_DivFix( size_metrics->x_ppem << 6,\n                                         face->root.units_per_EM );\n      size_metrics->y_scale = FT_DivFix( size_metrics->y_ppem << 6,\n                                         face->root.units_per_EM );\n\n      size_metrics->max_advance = FT_PIX_ROUND(\n                                    FT_MulFix( face->root.max_advance_width,\n                                               size_metrics->x_scale ) );\n    }\n\n    /* compute new transformation */\n    if ( size_metrics->x_ppem >= size_metrics->y_ppem )\n    {\n      size->ttmetrics.scale   = size_metrics->x_scale;\n      size->ttmetrics.ppem    = size_metrics->x_ppem;\n      size->ttmetrics.x_ratio = 0x10000L;\n      size->ttmetrics.y_ratio = FT_DivFix( size_metrics->y_ppem,\n                                           size_metrics->x_ppem );\n    }\n    else\n    {\n      size->ttmetrics.scale   = size_metrics->y_scale;\n      size->ttmetrics.ppem    = size_metrics->y_ppem;\n      size->ttmetrics.x_ratio = FT_DivFix( size_metrics->x_ppem,\n                                           size_metrics->y_ppem );\n      size->ttmetrics.y_ratio = 0x10000L;\n    }\n\n    size->metrics = size_metrics;\n\n#ifdef TT_USE_BYTECODE_INTERPRETER\n    size->cvt_ready = -1;\n#endif /* TT_USE_BYTECODE_INTERPRETER */\n\n    return FT_Err_Ok;\n  }",
        "func": "FT_LOCAL_DEF( FT_Error )\n  tt_size_reset( TT_Size  size )\n  {\n    FT_Error          error;\n    TT_Face           face         = (TT_Face)size->root.face;\n    FT_Size_Metrics*  size_metrics = &size->hinted_metrics;\n\n\n    error = tt_size_reset_height( (FT_Size)size );\n    if ( error )\n      return error;\n\n    if ( face->header.Flags & 8 )\n    {\n      /* base scaling values on integer ppem values, */\n      /* as mandated by the TrueType specification   */\n      size_metrics->x_scale = FT_DivFix( size_metrics->x_ppem << 6,\n                                         face->root.units_per_EM );\n      size_metrics->y_scale = FT_DivFix( size_metrics->y_ppem << 6,\n                                         face->root.units_per_EM );\n\n      size_metrics->max_advance = FT_PIX_ROUND(\n                                    FT_MulFix( face->root.max_advance_width,\n                                               size_metrics->x_scale ) );\n    }\n\n    /* compute new transformation */\n    if ( size_metrics->x_ppem >= size_metrics->y_ppem )\n    {\n      size->ttmetrics.scale   = size_metrics->x_scale;\n      size->ttmetrics.ppem    = size_metrics->x_ppem;\n      size->ttmetrics.x_ratio = 0x10000L;\n      size->ttmetrics.y_ratio = FT_DivFix( size_metrics->y_ppem,\n                                           size_metrics->x_ppem );\n    }\n    else\n    {\n      size->ttmetrics.scale   = size_metrics->y_scale;\n      size->ttmetrics.ppem    = size_metrics->y_ppem;\n      size->ttmetrics.x_ratio = FT_DivFix( size_metrics->x_ppem,\n                                           size_metrics->y_ppem );\n      size->ttmetrics.y_ratio = 0x10000L;\n    }\n\n    size->metrics = size_metrics;\n\n#ifdef TT_USE_BYTECODE_INTERPRETER\n    size->cvt_ready = -1;\n#endif /* TT_USE_BYTECODE_INTERPRETER */\n\n    return FT_Err_Ok;\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,53 +1,14 @@\n FT_LOCAL_DEF( FT_Error )\n-  tt_size_reset( TT_Size  size,\n-                 FT_Bool  only_height )\n+  tt_size_reset( TT_Size  size )\n   {\n-    TT_Face           face;\n-    FT_Size_Metrics*  size_metrics;\n+    FT_Error          error;\n+    TT_Face           face         = (TT_Face)size->root.face;\n+    FT_Size_Metrics*  size_metrics = &size->hinted_metrics;\n \n \n-    face = (TT_Face)size->root.face;\n-\n-    /* nothing to do for CFF2 */\n-    if ( face->is_cff2 )\n-      return FT_Err_Ok;\n-\n-    size->ttmetrics.valid = FALSE;\n-\n-    size_metrics = &size->hinted_metrics;\n-\n-    /* copy the result from base layer */\n-    *size_metrics = size->root.metrics;\n-\n-    if ( size_metrics->x_ppem < 1 || size_metrics->y_ppem < 1 )\n-      return FT_THROW( Invalid_PPem );\n-\n-    /* This bit flag, if set, indicates that the ppems must be       */\n-    /* rounded to integers.  Nearly all TrueType fonts have this bit */\n-    /* set, as hinting won't work really well otherwise.             */\n-    /*                                                               */\n-    if ( face->header.Flags & 8 )\n-    {\n-      /* the TT spec always asks for ROUND, not FLOOR or CEIL */\n-      size_metrics->ascender = FT_PIX_ROUND(\n-                                 FT_MulFix( face->root.ascender,\n-                                            size_metrics->y_scale ) );\n-      size_metrics->descender = FT_PIX_ROUND(\n-                                 FT_MulFix( face->root.descender,\n-                                            size_metrics->y_scale ) );\n-      size_metrics->height = FT_PIX_ROUND(\n-                               FT_MulFix( face->root.height,\n-                                          size_metrics->y_scale ) );\n-    }\n-\n-    size->ttmetrics.valid = TRUE;\n-\n-    if ( only_height )\n-    {\n-      /* we must not recompute the scaling values here since       */\n-      /* `tt_size_reset' was already called (with only_height = 0) */\n-      return FT_Err_Ok;\n-    }\n+    error = tt_size_reset_height( (FT_Size)size );\n+    if ( error )\n+      return error;\n \n     if ( face->header.Flags & 8 )\n     {",
        "diff_line_info": {
            "deleted_lines": [
                "  tt_size_reset( TT_Size  size,",
                "                 FT_Bool  only_height )",
                "    TT_Face           face;",
                "    FT_Size_Metrics*  size_metrics;",
                "    face = (TT_Face)size->root.face;",
                "",
                "    /* nothing to do for CFF2 */",
                "    if ( face->is_cff2 )",
                "      return FT_Err_Ok;",
                "",
                "    size->ttmetrics.valid = FALSE;",
                "",
                "    size_metrics = &size->hinted_metrics;",
                "",
                "    /* copy the result from base layer */",
                "    *size_metrics = size->root.metrics;",
                "",
                "    if ( size_metrics->x_ppem < 1 || size_metrics->y_ppem < 1 )",
                "      return FT_THROW( Invalid_PPem );",
                "",
                "    /* This bit flag, if set, indicates that the ppems must be       */",
                "    /* rounded to integers.  Nearly all TrueType fonts have this bit */",
                "    /* set, as hinting won't work really well otherwise.             */",
                "    /*                                                               */",
                "    if ( face->header.Flags & 8 )",
                "    {",
                "      /* the TT spec always asks for ROUND, not FLOOR or CEIL */",
                "      size_metrics->ascender = FT_PIX_ROUND(",
                "                                 FT_MulFix( face->root.ascender,",
                "                                            size_metrics->y_scale ) );",
                "      size_metrics->descender = FT_PIX_ROUND(",
                "                                 FT_MulFix( face->root.descender,",
                "                                            size_metrics->y_scale ) );",
                "      size_metrics->height = FT_PIX_ROUND(",
                "                               FT_MulFix( face->root.height,",
                "                                          size_metrics->y_scale ) );",
                "    }",
                "",
                "    size->ttmetrics.valid = TRUE;",
                "",
                "    if ( only_height )",
                "    {",
                "      /* we must not recompute the scaling values here since       */",
                "      /* `tt_size_reset' was already called (with only_height = 0) */",
                "      return FT_Err_Ok;",
                "    }"
            ],
            "added_lines": [
                "  tt_size_reset( TT_Size  size )",
                "    FT_Error          error;",
                "    TT_Face           face         = (TT_Face)size->root.face;",
                "    FT_Size_Metrics*  size_metrics = &size->hinted_metrics;",
                "    error = tt_size_reset_height( (FT_Size)size );",
                "    if ( error )",
                "      return error;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-21287",
        "func_name": "android/tt_face_get_metrics",
        "description": "In multiple locations, there is a possible code execution due to type confusion. This could lead to remote code execution with no additional execution privileges needed. User interaction is not needed for exploitation.\n\n",
        "git_url": "https://android.googlesource.com/platform/external/freetype/+/a79e80a25874dacaa266906a9048f13d4bac41c6",
        "commit_title": "Cherrypick following three changes",
        "commit_text": " [cherrypick 545bf3a27] [sfnt, truetype] Add `size_reset` to `MetricsVariations`. [cherrypick daad10810] [truetype] tt_size_reset_height to take FT_Size [cherrypick 51ad7b243] [services] FT_Size_Reset_Func to return FT_Error  Bug: 278221085 Test: TreeHugger (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:9fe9411db4b7e715a39c0ccf48d1e0328f1d8e7c) (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:cff127c5bc4a47ef88df305380ee2a47318a865b) Merged-In: I7e839b2a36e35c27974a82cc76e853996a7c7688 ",
        "func_before": "FT_LOCAL_DEF( void )\n  tt_face_get_metrics( TT_Face     face,\n                       FT_Bool     vertical,\n                       FT_UInt     gindex,\n                       FT_Short   *abearing,\n                       FT_UShort  *aadvance )\n  {\n    FT_Error        error;\n    FT_Stream       stream = face->root.stream;\n    TT_HoriHeader*  header;\n    FT_ULong        table_pos, table_size, table_end;\n    FT_UShort       k;\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n    FT_Service_MetricsVariations  var =\n      (FT_Service_MetricsVariations)face->var;\n#endif\n\n\n    if ( vertical )\n    {\n      void*  v = &face->vertical;\n\n\n      header     = (TT_HoriHeader*)v;\n      table_pos  = face->vert_metrics_offset;\n      table_size = face->vert_metrics_size;\n    }\n    else\n    {\n      header     = &face->horizontal;\n      table_pos  = face->horz_metrics_offset;\n      table_size = face->horz_metrics_size;\n    }\n\n    table_end = table_pos + table_size;\n\n    k = header->number_Of_HMetrics;\n\n    if ( k > 0 )\n    {\n      if ( gindex < (FT_UInt)k )\n      {\n        table_pos += 4 * gindex;\n        if ( table_pos + 4 > table_end )\n          goto NoData;\n\n        if ( FT_STREAM_SEEK( table_pos ) ||\n             FT_READ_USHORT( *aadvance ) ||\n             FT_READ_SHORT( *abearing )  )\n          goto NoData;\n      }\n      else\n      {\n        table_pos += 4 * ( k - 1 );\n        if ( table_pos + 2 > table_end )\n          goto NoData;\n\n        if ( FT_STREAM_SEEK( table_pos ) ||\n             FT_READ_USHORT( *aadvance ) )\n          goto NoData;\n\n        table_pos += 4 + 2 * ( gindex - k );\n        if ( table_pos + 2 > table_end )\n          *abearing = 0;\n        else\n        {\n          if ( FT_STREAM_SEEK( table_pos ) )\n            *abearing = 0;\n          else\n            (void)FT_READ_SHORT( *abearing );\n        }\n      }\n    }\n    else\n    {\n    NoData:\n      *abearing = 0;\n      *aadvance = 0;\n    }\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n    if ( var )\n    {\n      FT_Face  f = FT_FACE( face );\n      FT_Int   a = (FT_Int)*aadvance;\n      FT_Int   b = (FT_Int)*abearing;\n\n\n      if ( vertical )\n      {\n        if ( var->vadvance_adjust )\n          var->vadvance_adjust( f, gindex, &a );\n        if ( var->tsb_adjust )\n          var->tsb_adjust( f, gindex, &b );\n      }\n      else\n      {\n        if ( var->hadvance_adjust )\n          var->hadvance_adjust( f, gindex, &a );\n        if ( var->lsb_adjust )\n          var->lsb_adjust( f, gindex, &b );\n      }\n\n      *aadvance = (FT_UShort)a;\n      *abearing = (FT_Short)b;\n    }\n#endif\n  }",
        "func": "FT_LOCAL_DEF( void )\n  tt_face_get_metrics( TT_Face     face,\n                       FT_Bool     vertical,\n                       FT_UInt     gindex,\n                       FT_Short   *abearing,\n                       FT_UShort  *aadvance )\n  {\n    FT_Error        error;\n    FT_Stream       stream = face->root.stream;\n    TT_HoriHeader*  header;\n    FT_ULong        table_pos, table_size, table_end;\n    FT_UShort       k;\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n    FT_Service_MetricsVariations  var =\n      (FT_Service_MetricsVariations)face->tt_var;\n#endif\n\n\n    if ( vertical )\n    {\n      void*  v = &face->vertical;\n\n\n      header     = (TT_HoriHeader*)v;\n      table_pos  = face->vert_metrics_offset;\n      table_size = face->vert_metrics_size;\n    }\n    else\n    {\n      header     = &face->horizontal;\n      table_pos  = face->horz_metrics_offset;\n      table_size = face->horz_metrics_size;\n    }\n\n    table_end = table_pos + table_size;\n\n    k = header->number_Of_HMetrics;\n\n    if ( k > 0 )\n    {\n      if ( gindex < (FT_UInt)k )\n      {\n        table_pos += 4 * gindex;\n        if ( table_pos + 4 > table_end )\n          goto NoData;\n\n        if ( FT_STREAM_SEEK( table_pos ) ||\n             FT_READ_USHORT( *aadvance ) ||\n             FT_READ_SHORT( *abearing )  )\n          goto NoData;\n      }\n      else\n      {\n        table_pos += 4 * ( k - 1 );\n        if ( table_pos + 2 > table_end )\n          goto NoData;\n\n        if ( FT_STREAM_SEEK( table_pos ) ||\n             FT_READ_USHORT( *aadvance ) )\n          goto NoData;\n\n        table_pos += 4 + 2 * ( gindex - k );\n        if ( table_pos + 2 > table_end )\n          *abearing = 0;\n        else\n        {\n          if ( FT_STREAM_SEEK( table_pos ) )\n            *abearing = 0;\n          else\n            (void)FT_READ_SHORT( *abearing );\n        }\n      }\n    }\n    else\n    {\n    NoData:\n      *abearing = 0;\n      *aadvance = 0;\n    }\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n    if ( var )\n    {\n      FT_Face  f = FT_FACE( face );\n      FT_Int   a = (FT_Int)*aadvance;\n      FT_Int   b = (FT_Int)*abearing;\n\n\n      if ( vertical )\n      {\n        if ( var->vadvance_adjust )\n          var->vadvance_adjust( f, gindex, &a );\n        if ( var->tsb_adjust )\n          var->tsb_adjust( f, gindex, &b );\n      }\n      else\n      {\n        if ( var->hadvance_adjust )\n          var->hadvance_adjust( f, gindex, &a );\n        if ( var->lsb_adjust )\n          var->lsb_adjust( f, gindex, &b );\n      }\n\n      *aadvance = (FT_UShort)a;\n      *abearing = (FT_Short)b;\n    }\n#endif\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n \n #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n     FT_Service_MetricsVariations  var =\n-      (FT_Service_MetricsVariations)face->var;\n+      (FT_Service_MetricsVariations)face->tt_var;\n #endif\n \n ",
        "diff_line_info": {
            "deleted_lines": [
                "      (FT_Service_MetricsVariations)face->var;"
            ],
            "added_lines": [
                "      (FT_Service_MetricsVariations)face->tt_var;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-21287",
        "func_name": "android/tt_apply_mvar",
        "description": "In multiple locations, there is a possible code execution due to type confusion. This could lead to remote code execution with no additional execution privileges needed. User interaction is not needed for exploitation.\n\n",
        "git_url": "https://android.googlesource.com/platform/external/freetype/+/a79e80a25874dacaa266906a9048f13d4bac41c6",
        "commit_title": "Cherrypick following three changes",
        "commit_text": " [cherrypick 545bf3a27] [sfnt, truetype] Add `size_reset` to `MetricsVariations`. [cherrypick daad10810] [truetype] tt_size_reset_height to take FT_Size [cherrypick 51ad7b243] [services] FT_Size_Reset_Func to return FT_Error  Bug: 278221085 Test: TreeHugger (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:9fe9411db4b7e715a39c0ccf48d1e0328f1d8e7c) (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:cff127c5bc4a47ef88df305380ee2a47318a865b) Merged-In: I7e839b2a36e35c27974a82cc76e853996a7c7688 ",
        "func_before": "FT_LOCAL_DEF( void )\n  tt_apply_mvar( TT_Face  face )\n  {\n    GX_Blend  blend = face->blend;\n    GX_Value  value, limit;\n    FT_Short  mvar_hasc_delta = 0;\n    FT_Short  mvar_hdsc_delta = 0;\n    FT_Short  mvar_hlgp_delta = 0;\n\n\n    if ( !( face->variation_support & TT_FACE_FLAG_VAR_MVAR ) )\n      return;\n\n    value = blend->mvar_table->values;\n    limit = value + blend->mvar_table->valueCount;\n\n    for ( ; value < limit; value++ )\n    {\n      FT_Short*  p = ft_var_get_value_pointer( face, value->tag );\n      FT_Int     delta;\n\n\n      delta = ft_var_get_item_delta( face,\n                                     &blend->mvar_table->itemStore,\n                                     value->outerIndex,\n                                     value->innerIndex );\n\n      if ( p )\n      {\n        FT_TRACE5(( \"value %c%c%c%c (%d unit%s) adjusted by %d unit%s (MVAR)\\n\",\n                    (FT_Char)( value->tag >> 24 ),\n                    (FT_Char)( value->tag >> 16 ),\n                    (FT_Char)( value->tag >> 8 ),\n                    (FT_Char)( value->tag ),\n                    value->unmodified,\n                    value->unmodified == 1 ? \"\" : \"s\",\n                    delta,\n                    delta == 1 ? \"\" : \"s\" ));\n\n        /* since we handle both signed and unsigned values as FT_Short, */\n        /* ensure proper overflow arithmetic                            */\n        *p = (FT_Short)( value->unmodified + (FT_Short)delta );\n\n        /* Treat hasc, hdsc and hlgp specially, see below. */\n        if ( value->tag == MVAR_TAG_HASC )\n          mvar_hasc_delta = (FT_Short)delta;\n        else if ( value->tag == MVAR_TAG_HDSC )\n          mvar_hdsc_delta = (FT_Short)delta;\n        else if ( value->tag == MVAR_TAG_HLGP )\n          mvar_hlgp_delta = (FT_Short)delta;\n      }\n    }\n\n    /* adjust all derived values */\n    {\n      FT_Face  root = &face->root;\n\n      /*\n       * Apply the deltas of hasc, hdsc and hlgp to the FT_Face's ascender,\n       * descender and height attributes, no matter how they were originally\n       * computed.\n       *\n       * (Code that ignores those and accesses the font's metrics values\n       * directly is already served by the delta application code above.)\n       *\n       * The MVAR table supports variations for both typo and win metrics.\n       * According to Behdad Esfahbod, the thinking of the working group was\n       * that no one uses win metrics anymore for setting line metrics (the\n       * specification even calls these metrics \"horizontal clipping\n       * ascent/descent\", probably for their role on the Windows platform in\n       * computing clipping boxes), and new fonts should use typo metrics, so\n       * typo deltas should be applied to whatever sfnt_load_face decided the\n       * line metrics should be.\n       *\n       * Before, the following led to different line metrics between default\n       * outline and instances, visible when e.g. the default outlines were\n       * used as the regular face and instances for everything else:\n       *\n       * 1. sfnt_load_face applied the hhea metrics by default.\n       * 2. This code later applied the typo metrics by default, regardless of\n       *    whether they were actually changed or the font had the OS/2 table's\n       *    fsSelection's bit 7 (USE_TYPO_METRICS) set.\n       */\n      FT_Short  current_line_gap = root->height - root->ascender +\n                                   root->descender;\n\n\n      root->ascender  = root->ascender + mvar_hasc_delta;\n      root->descender = root->descender + mvar_hdsc_delta;\n      root->height    = root->ascender - root->descender +\n                        current_line_gap + mvar_hlgp_delta;\n\n      root->underline_position  = face->postscript.underlinePosition -\n                                  face->postscript.underlineThickness / 2;\n      root->underline_thickness = face->postscript.underlineThickness;\n\n      /* iterate over all FT_Size objects and call `tt_size_reset' */\n      /* to propagate the metrics changes                          */\n      FT_List_Iterate( &root->sizes_list,\n                       tt_size_reset_iterator,\n                       NULL );\n    }\n  }",
        "func": "FT_LOCAL_DEF( void )\n  tt_apply_mvar( TT_Face  face )\n  {\n    GX_Blend  blend = face->blend;\n    GX_Value  value, limit;\n    FT_Short  mvar_hasc_delta = 0;\n    FT_Short  mvar_hdsc_delta = 0;\n    FT_Short  mvar_hlgp_delta = 0;\n\n\n    if ( !( face->variation_support & TT_FACE_FLAG_VAR_MVAR ) )\n      return;\n\n    value = blend->mvar_table->values;\n    limit = value + blend->mvar_table->valueCount;\n\n    for ( ; value < limit; value++ )\n    {\n      FT_Short*  p = ft_var_get_value_pointer( face, value->tag );\n      FT_Int     delta;\n\n\n      delta = ft_var_get_item_delta( face,\n                                     &blend->mvar_table->itemStore,\n                                     value->outerIndex,\n                                     value->innerIndex );\n\n      if ( p )\n      {\n        FT_TRACE5(( \"value %c%c%c%c (%d unit%s) adjusted by %d unit%s (MVAR)\\n\",\n                    (FT_Char)( value->tag >> 24 ),\n                    (FT_Char)( value->tag >> 16 ),\n                    (FT_Char)( value->tag >> 8 ),\n                    (FT_Char)( value->tag ),\n                    value->unmodified,\n                    value->unmodified == 1 ? \"\" : \"s\",\n                    delta,\n                    delta == 1 ? \"\" : \"s\" ));\n\n        /* since we handle both signed and unsigned values as FT_Short, */\n        /* ensure proper overflow arithmetic                            */\n        *p = (FT_Short)( value->unmodified + (FT_Short)delta );\n\n        /* Treat hasc, hdsc and hlgp specially, see below. */\n        if ( value->tag == MVAR_TAG_HASC )\n          mvar_hasc_delta = (FT_Short)delta;\n        else if ( value->tag == MVAR_TAG_HDSC )\n          mvar_hdsc_delta = (FT_Short)delta;\n        else if ( value->tag == MVAR_TAG_HLGP )\n          mvar_hlgp_delta = (FT_Short)delta;\n      }\n    }\n\n    /* adjust all derived values */\n    {\n      FT_Service_MetricsVariations  var =\n        (FT_Service_MetricsVariations)face->face_var;\n\n      FT_Face  root = &face->root;\n\n      /*\n       * Apply the deltas of hasc, hdsc and hlgp to the FT_Face's ascender,\n       * descender and height attributes, no matter how they were originally\n       * computed.\n       *\n       * (Code that ignores those and accesses the font's metrics values\n       * directly is already served by the delta application code above.)\n       *\n       * The MVAR table supports variations for both typo and win metrics.\n       * According to Behdad Esfahbod, the thinking of the working group was\n       * that no one uses win metrics anymore for setting line metrics (the\n       * specification even calls these metrics \"horizontal clipping\n       * ascent/descent\", probably for their role on the Windows platform in\n       * computing clipping boxes), and new fonts should use typo metrics, so\n       * typo deltas should be applied to whatever sfnt_load_face decided the\n       * line metrics should be.\n       *\n       * Before, the following led to different line metrics between default\n       * outline and instances, visible when e.g. the default outlines were\n       * used as the regular face and instances for everything else:\n       *\n       * 1. sfnt_load_face applied the hhea metrics by default.\n       * 2. This code later applied the typo metrics by default, regardless of\n       *    whether they were actually changed or the font had the OS/2 table's\n       *    fsSelection's bit 7 (USE_TYPO_METRICS) set.\n       */\n      FT_Short  current_line_gap = root->height - root->ascender +\n                                   root->descender;\n\n\n      root->ascender  = root->ascender + mvar_hasc_delta;\n      root->descender = root->descender + mvar_hdsc_delta;\n      root->height    = root->ascender - root->descender +\n                        current_line_gap + mvar_hlgp_delta;\n\n      root->underline_position  = face->postscript.underlinePosition -\n                                  face->postscript.underlineThickness / 2;\n      root->underline_thickness = face->postscript.underlineThickness;\n\n      /* iterate over all FT_Size objects and call `var->size_reset' */\n      /* to propagate the metrics changes                            */\n      if ( var && var->size_reset )\n        FT_List_Iterate( &root->sizes_list,\n                         ft_size_reset_iterator,\n                         (void*)var );\n    }\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -53,6 +53,9 @@\n \n     /* adjust all derived values */\n     {\n+      FT_Service_MetricsVariations  var =\n+        (FT_Service_MetricsVariations)face->face_var;\n+\n       FT_Face  root = &face->root;\n \n       /*\n@@ -94,10 +97,11 @@\n                                   face->postscript.underlineThickness / 2;\n       root->underline_thickness = face->postscript.underlineThickness;\n \n-      /* iterate over all FT_Size objects and call `tt_size_reset' */\n-      /* to propagate the metrics changes                          */\n-      FT_List_Iterate( &root->sizes_list,\n-                       tt_size_reset_iterator,\n-                       NULL );\n+      /* iterate over all FT_Size objects and call `var->size_reset' */\n+      /* to propagate the metrics changes                            */\n+      if ( var && var->size_reset )\n+        FT_List_Iterate( &root->sizes_list,\n+                         ft_size_reset_iterator,\n+                         (void*)var );\n     }\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "      /* iterate over all FT_Size objects and call `tt_size_reset' */",
                "      /* to propagate the metrics changes                          */",
                "      FT_List_Iterate( &root->sizes_list,",
                "                       tt_size_reset_iterator,",
                "                       NULL );"
            ],
            "added_lines": [
                "      FT_Service_MetricsVariations  var =",
                "        (FT_Service_MetricsVariations)face->face_var;",
                "",
                "      /* iterate over all FT_Size objects and call `var->size_reset' */",
                "      /* to propagate the metrics changes                            */",
                "      if ( var && var->size_reset )",
                "        FT_List_Iterate( &root->sizes_list,",
                "                         ft_size_reset_iterator,",
                "                         (void*)var );"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-21287",
        "func_name": "android/cff_metrics_adjust",
        "description": "In multiple locations, there is a possible code execution due to type confusion. This could lead to remote code execution with no additional execution privileges needed. User interaction is not needed for exploitation.\n\n",
        "git_url": "https://android.googlesource.com/platform/external/freetype/+/a79e80a25874dacaa266906a9048f13d4bac41c6",
        "commit_title": "Cherrypick following three changes",
        "commit_text": " [cherrypick 545bf3a27] [sfnt, truetype] Add `size_reset` to `MetricsVariations`. [cherrypick daad10810] [truetype] tt_size_reset_height to take FT_Size [cherrypick 51ad7b243] [services] FT_Size_Reset_Func to return FT_Error  Bug: 278221085 Test: TreeHugger (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:9fe9411db4b7e715a39c0ccf48d1e0328f1d8e7c) (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:cff127c5bc4a47ef88df305380ee2a47318a865b) Merged-In: I7e839b2a36e35c27974a82cc76e853996a7c7688 ",
        "func_before": "static void\n  cff_metrics_adjust( CFF_Face  face )\n  {\n    FT_Service_MetricsVariations  var = (FT_Service_MetricsVariations)face->var;\n\n\n    var->metrics_adjust( FT_FACE( face ) );\n  }",
        "func": "static void\n  cff_metrics_adjust( CFF_Face  face )\n  {\n    FT_Service_MetricsVariations\n      var = (FT_Service_MetricsVariations)face->tt_var;\n\n\n    var->metrics_adjust( FT_FACE( face ) );\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,8 @@\n static void\n   cff_metrics_adjust( CFF_Face  face )\n   {\n-    FT_Service_MetricsVariations  var = (FT_Service_MetricsVariations)face->var;\n+    FT_Service_MetricsVariations\n+      var = (FT_Service_MetricsVariations)face->tt_var;\n \n \n     var->metrics_adjust( FT_FACE( face ) );",
        "diff_line_info": {
            "deleted_lines": [
                "    FT_Service_MetricsVariations  var = (FT_Service_MetricsVariations)face->var;"
            ],
            "added_lines": [
                "    FT_Service_MetricsVariations",
                "      var = (FT_Service_MetricsVariations)face->tt_var;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-21287",
        "func_name": "android/cff_hadvance_adjust",
        "description": "In multiple locations, there is a possible code execution due to type confusion. This could lead to remote code execution with no additional execution privileges needed. User interaction is not needed for exploitation.\n\n",
        "git_url": "https://android.googlesource.com/platform/external/freetype/+/a79e80a25874dacaa266906a9048f13d4bac41c6",
        "commit_title": "Cherrypick following three changes",
        "commit_text": " [cherrypick 545bf3a27] [sfnt, truetype] Add `size_reset` to `MetricsVariations`. [cherrypick daad10810] [truetype] tt_size_reset_height to take FT_Size [cherrypick 51ad7b243] [services] FT_Size_Reset_Func to return FT_Error  Bug: 278221085 Test: TreeHugger (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:9fe9411db4b7e715a39c0ccf48d1e0328f1d8e7c) (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:cff127c5bc4a47ef88df305380ee2a47318a865b) Merged-In: I7e839b2a36e35c27974a82cc76e853996a7c7688 ",
        "func_before": "static FT_Error\n  cff_hadvance_adjust( CFF_Face  face,\n                       FT_UInt   gindex,\n                       FT_Int   *avalue )\n  {\n    FT_Service_MetricsVariations  var = (FT_Service_MetricsVariations)face->var;\n\n\n    return var->hadvance_adjust( FT_FACE( face ), gindex, avalue );\n  }",
        "func": "static FT_Error\n  cff_hadvance_adjust( CFF_Face  face,\n                       FT_UInt   gindex,\n                       FT_Int   *avalue )\n  {\n    FT_Service_MetricsVariations\n      var = (FT_Service_MetricsVariations)face->tt_var;\n\n\n    return var->hadvance_adjust( FT_FACE( face ), gindex, avalue );\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,8 @@\n                        FT_UInt   gindex,\n                        FT_Int   *avalue )\n   {\n-    FT_Service_MetricsVariations  var = (FT_Service_MetricsVariations)face->var;\n+    FT_Service_MetricsVariations\n+      var = (FT_Service_MetricsVariations)face->tt_var;\n \n \n     return var->hadvance_adjust( FT_FACE( face ), gindex, avalue );",
        "diff_line_info": {
            "deleted_lines": [
                "    FT_Service_MetricsVariations  var = (FT_Service_MetricsVariations)face->var;"
            ],
            "added_lines": [
                "    FT_Service_MetricsVariations",
                "      var = (FT_Service_MetricsVariations)face->tt_var;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-21287",
        "func_name": "android/cff_face_init",
        "description": "In multiple locations, there is a possible code execution due to type confusion. This could lead to remote code execution with no additional execution privileges needed. User interaction is not needed for exploitation.\n\n",
        "git_url": "https://android.googlesource.com/platform/external/freetype/+/a79e80a25874dacaa266906a9048f13d4bac41c6",
        "commit_title": "Cherrypick following three changes",
        "commit_text": " [cherrypick 545bf3a27] [sfnt, truetype] Add `size_reset` to `MetricsVariations`. [cherrypick daad10810] [truetype] tt_size_reset_height to take FT_Size [cherrypick 51ad7b243] [services] FT_Size_Reset_Func to return FT_Error  Bug: 278221085 Test: TreeHugger (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:9fe9411db4b7e715a39c0ccf48d1e0328f1d8e7c) (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:cff127c5bc4a47ef88df305380ee2a47318a865b) Merged-In: I7e839b2a36e35c27974a82cc76e853996a7c7688 ",
        "func_before": "FT_LOCAL_DEF( FT_Error )\n  cff_face_init( FT_Stream      stream,\n                 FT_Face        cffface,        /* CFF_Face */\n                 FT_Int         face_index,\n                 FT_Int         num_params,\n                 FT_Parameter*  params )\n  {\n    CFF_Face            face        = (CFF_Face)cffface;\n    FT_Error            error;\n    SFNT_Service        sfnt;\n    FT_Service_PsCMaps  psnames;\n    PSHinter_Service    pshinter;\n    PSAux_Service       psaux;\n    FT_Service_CFFLoad  cffload;\n    FT_Bool             pure_cff    = 1;\n    FT_Bool             cff2        = 0;\n    FT_Bool             sfnt_format = 0;\n    FT_Library          library     = cffface->driver->root.library;\n\n\n    sfnt = (SFNT_Service)FT_Get_Module_Interface( library,\n                                                  \"sfnt\" );\n    if ( !sfnt )\n    {\n      FT_ERROR(( \"cff_face_init: cannot access `sfnt' module\\n\" ));\n      error = FT_THROW( Missing_Module );\n      goto Exit;\n    }\n\n    FT_FACE_FIND_GLOBAL_SERVICE( face, psnames, POSTSCRIPT_CMAPS );\n\n    pshinter = (PSHinter_Service)FT_Get_Module_Interface( library,\n                                                          \"pshinter\" );\n\n    psaux = (PSAux_Service)FT_Get_Module_Interface( library,\n                                                    \"psaux\" );\n    if ( !psaux )\n    {\n      FT_ERROR(( \"cff_face_init: cannot access `psaux' module\\n\" ));\n      error = FT_THROW( Missing_Module );\n      goto Exit;\n    }\n    face->psaux = psaux;\n\n    FT_FACE_FIND_GLOBAL_SERVICE( face, cffload, CFF_LOAD );\n\n    FT_TRACE2(( \"CFF driver\\n\" ));\n\n    /* create input stream from resource */\n    if ( FT_STREAM_SEEK( 0 ) )\n      goto Exit;\n\n    /* check whether we have a valid OpenType file */\n    FT_TRACE2(( \"  \" ));\n    error = sfnt->init_face( stream, face, face_index, num_params, params );\n    if ( !error )\n    {\n      if ( face->format_tag != TTAG_OTTO )  /* `OTTO'; OpenType/CFF font */\n      {\n        FT_TRACE2(( \"  not an OpenType/CFF font\\n\" ));\n        error = FT_THROW( Unknown_File_Format );\n        goto Exit;\n      }\n\n      /* if we are performing a simple font format check, exit immediately */\n      if ( face_index < 0 )\n        return FT_Err_Ok;\n\n      sfnt_format = 1;\n\n      /* now, the font can be either an OpenType/CFF font, or an SVG CEF */\n      /* font; in the latter case it doesn't have a `head' table         */\n      error = face->goto_table( face, TTAG_head, stream, 0 );\n      if ( !error )\n      {\n        pure_cff = 0;\n\n        /* load font directory */\n        error = sfnt->load_face( stream, face, face_index,\n                                 num_params, params );\n        if ( error )\n          goto Exit;\n      }\n      else\n      {\n        /* load the `cmap' table explicitly */\n        error = sfnt->load_cmap( face, stream );\n        if ( error )\n          goto Exit;\n      }\n\n      /* now load the CFF part of the file; */\n      /* give priority to CFF2              */\n      error = face->goto_table( face, TTAG_CFF2, stream, 0 );\n      if ( !error )\n      {\n        cff2          = 1;\n        face->is_cff2 = cff2;\n      }\n\n      if ( FT_ERR_EQ( error, Table_Missing ) )\n        error = face->goto_table( face, TTAG_CFF, stream, 0 );\n\n      if ( error )\n        goto Exit;\n    }\n    else\n    {\n      /* rewind to start of file; we are going to load a pure-CFF font */\n      if ( FT_STREAM_SEEK( 0 ) )\n        goto Exit;\n      error = FT_Err_Ok;\n    }\n\n    /* now load and parse the CFF table in the file */\n    {\n      CFF_Font         cff = NULL;\n      CFF_FontRecDict  dict;\n      FT_Memory        memory = cffface->memory;\n      FT_Int32         flags;\n      FT_UInt          i;\n\n\n      if ( FT_NEW( cff ) )\n        goto Exit;\n\n      face->extra.data = cff;\n      error = cff_font_load( library,\n                             stream,\n                             face_index,\n                             cff,\n                             face,\n                             pure_cff,\n                             cff2 );\n      if ( error )\n        goto Exit;\n\n      /* if we are performing a simple font format check, exit immediately */\n      /* (this is here for pure CFF)                                       */\n      if ( face_index < 0 )\n      {\n        cffface->num_faces = (FT_Long)cff->num_faces;\n        return FT_Err_Ok;\n      }\n\n      cff->pshinter = pshinter;\n      cff->psnames  = psnames;\n      cff->cffload  = cffload;\n\n      cffface->face_index = face_index & 0xFFFF;\n\n      /* Complement the root flags with some interesting information. */\n      /* Note that this is only necessary for pure CFF and CEF fonts; */\n      /* SFNT based fonts use the `name' table instead.               */\n\n      cffface->num_glyphs = (FT_Long)cff->num_glyphs;\n\n      dict = &cff->top_font.font_dict;\n\n      /* we need the `psnames' module for CFF and CEF formats */\n      /* which aren't CID-keyed                               */\n      if ( dict->cid_registry == 0xFFFFU && !psnames )\n      {\n        FT_ERROR(( \"cff_face_init:\"\n                   \" cannot open CFF & CEF fonts\\n\" ));\n        FT_ERROR(( \"              \"\n                   \" without the `psnames' module\\n\" ));\n        error = FT_THROW( Missing_Module );\n        goto Exit;\n      }\n\n#ifdef FT_DEBUG_LEVEL_TRACE\n      {\n        FT_UInt     idx;\n        FT_String*  s;\n\n\n        FT_TRACE4(( \"SIDs\\n\" ));\n\n        /* dump string index, including default strings for convenience */\n        for ( idx = 0; idx <= 390; idx++ )\n        {\n          s = cff_index_get_sid_string( cff, idx );\n          if ( s )\n            FT_TRACE4(( \"  %5d %s\\n\", idx, s ));\n        }\n\n        /* In Multiple Master CFFs, two SIDs hold the Normalize Design  */\n        /* Vector (NDV) and Convert Design Vector (CDV) charstrings,    */\n        /* which may contain null bytes in the middle of the data, too. */\n        /* We thus access `cff->strings' directly.                      */\n        for ( idx = 1; idx < cff->num_strings; idx++ )\n        {\n          FT_Byte*    s1    = cff->strings[idx - 1];\n          FT_Byte*    s2    = cff->strings[idx];\n          FT_PtrDist  s1len = s2 - s1 - 1; /* without the final null byte */\n          FT_PtrDist  l;\n\n\n          FT_TRACE4(( \"  %5d \", idx + 390 ));\n          for ( l = 0; l < s1len; l++ )\n            FT_TRACE4(( \"%c\", s1[l] ));\n          FT_TRACE4(( \"\\n\" ));\n        }\n\n        /* print last element */\n        if ( cff->num_strings )\n        {\n          FT_Byte*    s1    = cff->strings[cff->num_strings - 1];\n          FT_Byte*    s2    = cff->string_pool + cff->string_pool_size;\n          FT_PtrDist  s1len = s2 - s1 - 1;\n          FT_PtrDist  l;\n\n\n          FT_TRACE4(( \"  %5d \", cff->num_strings + 390 ));\n          for ( l = 0; l < s1len; l++ )\n            FT_TRACE4(( \"%c\", s1[l] ));\n          FT_TRACE4(( \"\\n\" ));\n        }\n      }\n#endif /* FT_DEBUG_LEVEL_TRACE */\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n      {\n        FT_Service_MultiMasters       mm  = (FT_Service_MultiMasters)face->mm;\n        FT_Service_MetricsVariations  var = (FT_Service_MetricsVariations)face->var;\n\n        FT_UInt  instance_index = (FT_UInt)face_index >> 16;\n\n\n        if ( FT_HAS_MULTIPLE_MASTERS( cffface ) &&\n             mm                                 &&\n             instance_index > 0                 )\n        {\n          error = mm->set_instance( cffface, instance_index );\n          if ( error )\n            goto Exit;\n\n          if ( var )\n            var->metrics_adjust( cffface );\n        }\n      }\n#endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */\n\n      if ( !dict->has_font_matrix )\n        dict->units_per_em = pure_cff ? 1000 : face->root.units_per_EM;\n\n      /* Normalize the font matrix so that `matrix->yy' is 1; if  */\n      /* it is zero, we use `matrix->yx' instead.  The scaling is */\n      /* done with `units_per_em' then (at this point, it already */\n      /* contains the scaling factor, but without normalization   */\n      /* of the matrix).                                          */\n      /*                                                          */\n      /* Note that the offsets must be expressed in integer font  */\n      /* units.                                                   */\n\n      {\n        FT_Matrix*  matrix = &dict->font_matrix;\n        FT_Vector*  offset = &dict->font_offset;\n        FT_ULong*   upm    = &dict->units_per_em;\n        FT_Fixed    temp;\n\n\n        temp = matrix->yy ? FT_ABS( matrix->yy )\n                          : FT_ABS( matrix->yx );\n\n        if ( temp != 0x10000L )\n        {\n          *upm = (FT_ULong)FT_DivFix( (FT_Long)*upm, temp );\n\n          matrix->xx = FT_DivFix( matrix->xx, temp );\n          matrix->yx = FT_DivFix( matrix->yx, temp );\n          matrix->xy = FT_DivFix( matrix->xy, temp );\n          matrix->yy = FT_DivFix( matrix->yy, temp );\n          offset->x  = FT_DivFix( offset->x,  temp );\n          offset->y  = FT_DivFix( offset->y,  temp );\n        }\n\n        offset->x >>= 16;\n        offset->y >>= 16;\n      }\n\n      for ( i = cff->num_subfonts; i > 0; i-- )\n      {\n        CFF_FontRecDict  sub = &cff->subfonts[i - 1]->font_dict;\n        CFF_FontRecDict  top = &cff->top_font.font_dict;\n\n        FT_Matrix*  matrix;\n        FT_Vector*  offset;\n        FT_ULong*   upm;\n        FT_Fixed    temp;\n\n\n        if ( sub->has_font_matrix )\n        {\n          FT_Long  scaling;\n\n\n          /* if we have a top-level matrix, */\n          /* concatenate the subfont matrix */\n\n          if ( top->has_font_matrix )\n          {\n            if ( top->units_per_em > 1 && sub->units_per_em > 1 )\n              scaling = (FT_Long)FT_MIN( top->units_per_em,\n                                         sub->units_per_em );\n            else\n              scaling = 1;\n\n            FT_Matrix_Multiply_Scaled( &top->font_matrix,\n                                       &sub->font_matrix,\n                                       scaling );\n            FT_Vector_Transform_Scaled( &sub->font_offset,\n                                        &top->font_matrix,\n                                        scaling );\n\n            sub->units_per_em = (FT_ULong)\n                                  FT_MulDiv( (FT_Long)sub->units_per_em,\n                                             (FT_Long)top->units_per_em,\n                                             scaling );\n          }\n        }\n        else\n        {\n          sub->font_matrix = top->font_matrix;\n          sub->font_offset = top->font_offset;\n\n          sub->units_per_em = top->units_per_em;\n        }\n\n        matrix = &sub->font_matrix;\n        offset = &sub->font_offset;\n        upm    = &sub->units_per_em;\n\n        temp = matrix->yy ? FT_ABS( matrix->yy )\n                          : FT_ABS( matrix->yx );\n\n\n        if ( temp != 0x10000L )\n        {\n          *upm = (FT_ULong)FT_DivFix( (FT_Long)*upm, temp );\n\n          matrix->xx = FT_DivFix( matrix->xx, temp );\n          matrix->yx = FT_DivFix( matrix->yx, temp );\n          matrix->xy = FT_DivFix( matrix->xy, temp );\n          matrix->yy = FT_DivFix( matrix->yy, temp );\n          offset->x  = FT_DivFix( offset->x,  temp );\n          offset->y  = FT_DivFix( offset->y,  temp );\n        }\n\n        offset->x >>= 16;\n        offset->y >>= 16;\n      }\n\n      if ( pure_cff )\n      {\n        char*  style_name = NULL;\n\n\n        /* set up num_faces */\n        cffface->num_faces = (FT_Long)cff->num_faces;\n\n        /* compute number of glyphs */\n        if ( dict->cid_registry != 0xFFFFU )\n          cffface->num_glyphs = (FT_Long)( cff->charset.max_cid + 1 );\n        else\n          cffface->num_glyphs = (FT_Long)cff->charstrings_index.count;\n\n        /* set global bbox, as well as EM size */\n        cffface->bbox.xMin =   dict->font_bbox.xMin            >> 16;\n        cffface->bbox.yMin =   dict->font_bbox.yMin            >> 16;\n        /* no `U' suffix here to 0xFFFF! */\n        cffface->bbox.xMax = ( dict->font_bbox.xMax + 0xFFFF ) >> 16;\n        cffface->bbox.yMax = ( dict->font_bbox.yMax + 0xFFFF ) >> 16;\n\n        cffface->units_per_EM = (FT_UShort)( dict->units_per_em );\n\n        cffface->ascender  = (FT_Short)( cffface->bbox.yMax );\n        cffface->descender = (FT_Short)( cffface->bbox.yMin );\n\n        cffface->height = (FT_Short)( ( cffface->units_per_EM * 12 ) / 10 );\n        if ( cffface->height < cffface->ascender - cffface->descender )\n          cffface->height = (FT_Short)( cffface->ascender -\n                                        cffface->descender );\n\n        cffface->underline_position  =\n          (FT_Short)( dict->underline_position >> 16 );\n        cffface->underline_thickness =\n          (FT_Short)( dict->underline_thickness >> 16 );\n\n        /* retrieve font family & style name */\n        if ( dict->family_name )\n        {\n          char*  family_name;\n\n\n          family_name = cff_index_get_sid_string( cff, dict->family_name );\n          if ( family_name )\n            cffface->family_name = cff_strcpy( memory, family_name );\n        }\n\n        if ( !cffface->family_name )\n        {\n          cffface->family_name = cff_index_get_name(\n                                   cff,\n                                   (FT_UInt)( face_index & 0xFFFF ) );\n          if ( cffface->family_name )\n            remove_subset_prefix( cffface->family_name );\n        }\n\n        if ( cffface->family_name )\n        {\n          char*  full   = cff_index_get_sid_string( cff,\n                                                    dict->full_name );\n          char*  fullp  = full;\n          char*  family = cffface->family_name;\n\n\n          /* We try to extract the style name from the full name.   */\n          /* We need to ignore spaces and dashes during the search. */\n          if ( full && family )\n          {\n            while ( *fullp )\n            {\n              /* skip common characters at the start of both strings */\n              if ( *fullp == *family )\n              {\n                family++;\n                fullp++;\n                continue;\n              }\n\n              /* ignore spaces and dashes in full name during comparison */\n              if ( *fullp == ' ' || *fullp == '-' )\n              {\n                fullp++;\n                continue;\n              }\n\n              /* ignore spaces and dashes in family name during comparison */\n              if ( *family == ' ' || *family == '-' )\n              {\n                family++;\n                continue;\n              }\n\n              if ( !*family && *fullp )\n              {\n                /* The full name begins with the same characters as the  */\n                /* family name, with spaces and dashes removed.  In this */\n                /* case, the remaining string in `fullp' will be used as */\n                /* the style name.                                       */\n                style_name = cff_strcpy( memory, fullp );\n\n                /* remove the style part from the family name (if present) */\n                if ( style_name )\n                  remove_style( cffface->family_name, style_name );\n              }\n              break;\n            }\n          }\n        }\n        else\n        {\n          char  *cid_font_name =\n                   cff_index_get_sid_string( cff,\n                                             dict->cid_font_name );\n\n\n          /* do we have a `/FontName' for a CID-keyed font? */\n          if ( cid_font_name )\n            cffface->family_name = cff_strcpy( memory, cid_font_name );\n        }\n\n        if ( style_name )\n          cffface->style_name = style_name;\n        else\n          /* assume \"Regular\" style if we don't know better */\n          cffface->style_name = cff_strcpy( memory, \"Regular\" );\n\n        /********************************************************************\n         *\n         * Compute face flags.\n         */\n        flags = FT_FACE_FLAG_SCALABLE   | /* scalable outlines */\n                FT_FACE_FLAG_HORIZONTAL | /* horizontal data   */\n                FT_FACE_FLAG_HINTER;      /* has native hinter */\n\n        if ( sfnt_format )\n          flags |= FT_FACE_FLAG_SFNT;\n\n        /* fixed width font? */\n        if ( dict->is_fixed_pitch )\n          flags |= FT_FACE_FLAG_FIXED_WIDTH;\n\n  /* XXX: WE DO NOT SUPPORT KERNING METRICS IN THE GPOS TABLE FOR NOW */\n#if 0\n        /* kerning available? */\n        if ( face->kern_pairs )\n          flags |= FT_FACE_FLAG_KERNING;\n#endif\n\n        cffface->face_flags |= flags;\n\n        /********************************************************************\n         *\n         * Compute style flags.\n         */\n        flags = 0;\n\n        if ( dict->italic_angle )\n          flags |= FT_STYLE_FLAG_ITALIC;\n\n        {\n          char  *weight = cff_index_get_sid_string( cff,\n                                                    dict->weight );\n\n\n          if ( weight )\n            if ( !ft_strcmp( weight, \"Bold\"  ) ||\n                 !ft_strcmp( weight, \"Black\" ) )\n              flags |= FT_STYLE_FLAG_BOLD;\n        }\n\n        /* double check */\n        if ( !(flags & FT_STYLE_FLAG_BOLD) && cffface->style_name )\n          if ( !ft_strncmp( cffface->style_name, \"Bold\", 4 )  ||\n               !ft_strncmp( cffface->style_name, \"Black\", 5 ) )\n            flags |= FT_STYLE_FLAG_BOLD;\n\n        cffface->style_flags = flags;\n      }\n\n#ifndef FT_CONFIG_OPTION_NO_GLYPH_NAMES\n      /* CID-keyed CFF or CFF2 fonts don't have glyph names -- the SFNT */\n      /* loader has unset this flag because of the 3.0 `post' table.    */\n      if ( dict->cid_registry == 0xFFFFU && !cff2 )\n        cffface->face_flags |= FT_FACE_FLAG_GLYPH_NAMES;\n#endif\n\n      if ( dict->cid_registry != 0xFFFFU && pure_cff )\n        cffface->face_flags |= FT_FACE_FLAG_CID_KEYED;\n\n      /********************************************************************\n       *\n       * Compute char maps.\n       */\n\n      /* Try to synthesize a Unicode charmap if there is none available */\n      /* already.  If an OpenType font contains a Unicode \"cmap\", we    */\n      /* will use it, whatever be in the CFF part of the file.          */\n      {\n        FT_CharMapRec  cmaprec;\n        FT_CharMap     cmap;\n        FT_Int         nn;\n        CFF_Encoding   encoding = &cff->encoding;\n\n\n        for ( nn = 0; nn < cffface->num_charmaps; nn++ )\n        {\n          cmap = cffface->charmaps[nn];\n\n          /* Windows Unicode? */\n          if ( cmap->platform_id == TT_PLATFORM_MICROSOFT &&\n               cmap->encoding_id == TT_MS_ID_UNICODE_CS   )\n            goto Skip_Unicode;\n\n          /* Apple Unicode platform id? */\n          if ( cmap->platform_id == TT_PLATFORM_APPLE_UNICODE )\n            goto Skip_Unicode; /* Apple Unicode */\n        }\n\n        /* since CID-keyed fonts don't contain glyph names, we can't */\n        /* construct a cmap                                          */\n        if ( pure_cff && cff->top_font.font_dict.cid_registry != 0xFFFFU )\n          goto Exit;\n\n        /* we didn't find a Unicode charmap -- synthesize one */\n        cmaprec.face        = cffface;\n        cmaprec.platform_id = TT_PLATFORM_MICROSOFT;\n        cmaprec.encoding_id = TT_MS_ID_UNICODE_CS;\n        cmaprec.encoding    = FT_ENCODING_UNICODE;\n\n        nn = cffface->num_charmaps;\n\n        error = FT_CMap_New( &cff_cmap_unicode_class_rec, NULL,\n                             &cmaprec, NULL );\n        if ( error                                      &&\n             FT_ERR_NEQ( error, No_Unicode_Glyph_Name ) &&\n             FT_ERR_NEQ( error, Unimplemented_Feature ) )\n          goto Exit;\n        error = FT_Err_Ok;\n\n        /* if no Unicode charmap was previously selected, select this one */\n        if ( !cffface->charmap && nn != cffface->num_charmaps )\n          cffface->charmap = cffface->charmaps[nn];\n\n      Skip_Unicode:\n        if ( encoding->count > 0 )\n        {\n          FT_CMap_Class  clazz;\n\n\n          cmaprec.face        = cffface;\n          cmaprec.platform_id = TT_PLATFORM_ADOBE;  /* Adobe platform id */\n\n          if ( encoding->offset == 0 )\n          {\n            cmaprec.encoding_id = TT_ADOBE_ID_STANDARD;\n            cmaprec.encoding    = FT_ENCODING_ADOBE_STANDARD;\n            clazz               = &cff_cmap_encoding_class_rec;\n          }\n          else if ( encoding->offset == 1 )\n          {\n            cmaprec.encoding_id = TT_ADOBE_ID_EXPERT;\n            cmaprec.encoding    = FT_ENCODING_ADOBE_EXPERT;\n            clazz               = &cff_cmap_encoding_class_rec;\n          }\n          else\n          {\n            cmaprec.encoding_id = TT_ADOBE_ID_CUSTOM;\n            cmaprec.encoding    = FT_ENCODING_ADOBE_CUSTOM;\n            clazz               = &cff_cmap_encoding_class_rec;\n          }\n\n          error = FT_CMap_New( clazz, NULL, &cmaprec, NULL );\n        }\n      }\n    }\n\n  Exit:\n    return error;\n  }",
        "func": "FT_LOCAL_DEF( FT_Error )\n  cff_face_init( FT_Stream      stream,\n                 FT_Face        cffface,        /* CFF_Face */\n                 FT_Int         face_index,\n                 FT_Int         num_params,\n                 FT_Parameter*  params )\n  {\n    CFF_Face            face        = (CFF_Face)cffface;\n    FT_Error            error;\n    SFNT_Service        sfnt;\n    FT_Service_PsCMaps  psnames;\n    PSHinter_Service    pshinter;\n    PSAux_Service       psaux;\n    FT_Service_CFFLoad  cffload;\n    FT_Bool             pure_cff    = 1;\n    FT_Bool             cff2        = 0;\n    FT_Bool             sfnt_format = 0;\n    FT_Library          library     = cffface->driver->root.library;\n\n\n    sfnt = (SFNT_Service)FT_Get_Module_Interface( library,\n                                                  \"sfnt\" );\n    if ( !sfnt )\n    {\n      FT_ERROR(( \"cff_face_init: cannot access `sfnt' module\\n\" ));\n      error = FT_THROW( Missing_Module );\n      goto Exit;\n    }\n\n    FT_FACE_FIND_GLOBAL_SERVICE( face, psnames, POSTSCRIPT_CMAPS );\n\n    pshinter = (PSHinter_Service)FT_Get_Module_Interface( library,\n                                                          \"pshinter\" );\n\n    psaux = (PSAux_Service)FT_Get_Module_Interface( library,\n                                                    \"psaux\" );\n    if ( !psaux )\n    {\n      FT_ERROR(( \"cff_face_init: cannot access `psaux' module\\n\" ));\n      error = FT_THROW( Missing_Module );\n      goto Exit;\n    }\n    face->psaux = psaux;\n\n    FT_FACE_FIND_GLOBAL_SERVICE( face, cffload, CFF_LOAD );\n\n    FT_TRACE2(( \"CFF driver\\n\" ));\n\n    /* create input stream from resource */\n    if ( FT_STREAM_SEEK( 0 ) )\n      goto Exit;\n\n    /* check whether we have a valid OpenType file */\n    FT_TRACE2(( \"  \" ));\n    error = sfnt->init_face( stream, face, face_index, num_params, params );\n    if ( !error )\n    {\n      if ( face->format_tag != TTAG_OTTO )  /* `OTTO'; OpenType/CFF font */\n      {\n        FT_TRACE2(( \"  not an OpenType/CFF font\\n\" ));\n        error = FT_THROW( Unknown_File_Format );\n        goto Exit;\n      }\n\n      /* if we are performing a simple font format check, exit immediately */\n      if ( face_index < 0 )\n        return FT_Err_Ok;\n\n      sfnt_format = 1;\n\n      /* now, the font can be either an OpenType/CFF font, or an SVG CEF */\n      /* font; in the latter case it doesn't have a `head' table         */\n      error = face->goto_table( face, TTAG_head, stream, 0 );\n      if ( !error )\n      {\n        pure_cff = 0;\n\n        /* load font directory */\n        error = sfnt->load_face( stream, face, face_index,\n                                 num_params, params );\n        if ( error )\n          goto Exit;\n      }\n      else\n      {\n        /* load the `cmap' table explicitly */\n        error = sfnt->load_cmap( face, stream );\n        if ( error )\n          goto Exit;\n      }\n\n      /* now load the CFF part of the file; */\n      /* give priority to CFF2              */\n      error = face->goto_table( face, TTAG_CFF2, stream, 0 );\n      if ( !error )\n      {\n        cff2          = 1;\n        face->is_cff2 = cff2;\n      }\n\n      if ( FT_ERR_EQ( error, Table_Missing ) )\n        error = face->goto_table( face, TTAG_CFF, stream, 0 );\n\n      if ( error )\n        goto Exit;\n    }\n    else\n    {\n      /* rewind to start of file; we are going to load a pure-CFF font */\n      if ( FT_STREAM_SEEK( 0 ) )\n        goto Exit;\n      error = FT_Err_Ok;\n    }\n\n    /* now load and parse the CFF table in the file */\n    {\n      CFF_Font         cff = NULL;\n      CFF_FontRecDict  dict;\n      FT_Memory        memory = cffface->memory;\n      FT_Int32         flags;\n      FT_UInt          i;\n\n\n      if ( FT_NEW( cff ) )\n        goto Exit;\n\n      face->extra.data = cff;\n      error = cff_font_load( library,\n                             stream,\n                             face_index,\n                             cff,\n                             face,\n                             pure_cff,\n                             cff2 );\n      if ( error )\n        goto Exit;\n\n      /* if we are performing a simple font format check, exit immediately */\n      /* (this is here for pure CFF)                                       */\n      if ( face_index < 0 )\n      {\n        cffface->num_faces = (FT_Long)cff->num_faces;\n        return FT_Err_Ok;\n      }\n\n      cff->pshinter = pshinter;\n      cff->psnames  = psnames;\n      cff->cffload  = cffload;\n\n      cffface->face_index = face_index & 0xFFFF;\n\n      /* Complement the root flags with some interesting information. */\n      /* Note that this is only necessary for pure CFF and CEF fonts; */\n      /* SFNT based fonts use the `name' table instead.               */\n\n      cffface->num_glyphs = (FT_Long)cff->num_glyphs;\n\n      dict = &cff->top_font.font_dict;\n\n      /* we need the `psnames' module for CFF and CEF formats */\n      /* which aren't CID-keyed                               */\n      if ( dict->cid_registry == 0xFFFFU && !psnames )\n      {\n        FT_ERROR(( \"cff_face_init:\"\n                   \" cannot open CFF & CEF fonts\\n\" ));\n        FT_ERROR(( \"              \"\n                   \" without the `psnames' module\\n\" ));\n        error = FT_THROW( Missing_Module );\n        goto Exit;\n      }\n\n#ifdef FT_DEBUG_LEVEL_TRACE\n      {\n        FT_UInt     idx;\n        FT_String*  s;\n\n\n        FT_TRACE4(( \"SIDs\\n\" ));\n\n        /* dump string index, including default strings for convenience */\n        for ( idx = 0; idx <= 390; idx++ )\n        {\n          s = cff_index_get_sid_string( cff, idx );\n          if ( s )\n            FT_TRACE4(( \"  %5d %s\\n\", idx, s ));\n        }\n\n        /* In Multiple Master CFFs, two SIDs hold the Normalize Design  */\n        /* Vector (NDV) and Convert Design Vector (CDV) charstrings,    */\n        /* which may contain null bytes in the middle of the data, too. */\n        /* We thus access `cff->strings' directly.                      */\n        for ( idx = 1; idx < cff->num_strings; idx++ )\n        {\n          FT_Byte*    s1    = cff->strings[idx - 1];\n          FT_Byte*    s2    = cff->strings[idx];\n          FT_PtrDist  s1len = s2 - s1 - 1; /* without the final null byte */\n          FT_PtrDist  l;\n\n\n          FT_TRACE4(( \"  %5d \", idx + 390 ));\n          for ( l = 0; l < s1len; l++ )\n            FT_TRACE4(( \"%c\", s1[l] ));\n          FT_TRACE4(( \"\\n\" ));\n        }\n\n        /* print last element */\n        if ( cff->num_strings )\n        {\n          FT_Byte*    s1    = cff->strings[cff->num_strings - 1];\n          FT_Byte*    s2    = cff->string_pool + cff->string_pool_size;\n          FT_PtrDist  s1len = s2 - s1 - 1;\n          FT_PtrDist  l;\n\n\n          FT_TRACE4(( \"  %5d \", cff->num_strings + 390 ));\n          for ( l = 0; l < s1len; l++ )\n            FT_TRACE4(( \"%c\", s1[l] ));\n          FT_TRACE4(( \"\\n\" ));\n        }\n      }\n#endif /* FT_DEBUG_LEVEL_TRACE */\n\n#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n      {\n        FT_Service_MultiMasters\n          mm = (FT_Service_MultiMasters)face->mm;\n        FT_Service_MetricsVariations\n          var = (FT_Service_MetricsVariations)face->face_var;\n\n        FT_UInt  instance_index = (FT_UInt)face_index >> 16;\n\n\n        if ( FT_HAS_MULTIPLE_MASTERS( cffface ) &&\n             mm                                 &&\n             instance_index > 0                 )\n        {\n          error = mm->set_instance( cffface, instance_index );\n          if ( error )\n            goto Exit;\n\n          if ( var )\n            var->metrics_adjust( cffface );\n        }\n      }\n#endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */\n\n      if ( !dict->has_font_matrix )\n        dict->units_per_em = pure_cff ? 1000 : face->root.units_per_EM;\n\n      /* Normalize the font matrix so that `matrix->yy' is 1; if  */\n      /* it is zero, we use `matrix->yx' instead.  The scaling is */\n      /* done with `units_per_em' then (at this point, it already */\n      /* contains the scaling factor, but without normalization   */\n      /* of the matrix).                                          */\n      /*                                                          */\n      /* Note that the offsets must be expressed in integer font  */\n      /* units.                                                   */\n\n      {\n        FT_Matrix*  matrix = &dict->font_matrix;\n        FT_Vector*  offset = &dict->font_offset;\n        FT_ULong*   upm    = &dict->units_per_em;\n        FT_Fixed    temp;\n\n\n        temp = matrix->yy ? FT_ABS( matrix->yy )\n                          : FT_ABS( matrix->yx );\n\n        if ( temp != 0x10000L )\n        {\n          *upm = (FT_ULong)FT_DivFix( (FT_Long)*upm, temp );\n\n          matrix->xx = FT_DivFix( matrix->xx, temp );\n          matrix->yx = FT_DivFix( matrix->yx, temp );\n          matrix->xy = FT_DivFix( matrix->xy, temp );\n          matrix->yy = FT_DivFix( matrix->yy, temp );\n          offset->x  = FT_DivFix( offset->x,  temp );\n          offset->y  = FT_DivFix( offset->y,  temp );\n        }\n\n        offset->x >>= 16;\n        offset->y >>= 16;\n      }\n\n      for ( i = cff->num_subfonts; i > 0; i-- )\n      {\n        CFF_FontRecDict  sub = &cff->subfonts[i - 1]->font_dict;\n        CFF_FontRecDict  top = &cff->top_font.font_dict;\n\n        FT_Matrix*  matrix;\n        FT_Vector*  offset;\n        FT_ULong*   upm;\n        FT_Fixed    temp;\n\n\n        if ( sub->has_font_matrix )\n        {\n          FT_Long  scaling;\n\n\n          /* if we have a top-level matrix, */\n          /* concatenate the subfont matrix */\n\n          if ( top->has_font_matrix )\n          {\n            if ( top->units_per_em > 1 && sub->units_per_em > 1 )\n              scaling = (FT_Long)FT_MIN( top->units_per_em,\n                                         sub->units_per_em );\n            else\n              scaling = 1;\n\n            FT_Matrix_Multiply_Scaled( &top->font_matrix,\n                                       &sub->font_matrix,\n                                       scaling );\n            FT_Vector_Transform_Scaled( &sub->font_offset,\n                                        &top->font_matrix,\n                                        scaling );\n\n            sub->units_per_em = (FT_ULong)\n                                  FT_MulDiv( (FT_Long)sub->units_per_em,\n                                             (FT_Long)top->units_per_em,\n                                             scaling );\n          }\n        }\n        else\n        {\n          sub->font_matrix = top->font_matrix;\n          sub->font_offset = top->font_offset;\n\n          sub->units_per_em = top->units_per_em;\n        }\n\n        matrix = &sub->font_matrix;\n        offset = &sub->font_offset;\n        upm    = &sub->units_per_em;\n\n        temp = matrix->yy ? FT_ABS( matrix->yy )\n                          : FT_ABS( matrix->yx );\n\n\n        if ( temp != 0x10000L )\n        {\n          *upm = (FT_ULong)FT_DivFix( (FT_Long)*upm, temp );\n\n          matrix->xx = FT_DivFix( matrix->xx, temp );\n          matrix->yx = FT_DivFix( matrix->yx, temp );\n          matrix->xy = FT_DivFix( matrix->xy, temp );\n          matrix->yy = FT_DivFix( matrix->yy, temp );\n          offset->x  = FT_DivFix( offset->x,  temp );\n          offset->y  = FT_DivFix( offset->y,  temp );\n        }\n\n        offset->x >>= 16;\n        offset->y >>= 16;\n      }\n\n      if ( pure_cff )\n      {\n        char*  style_name = NULL;\n\n\n        /* set up num_faces */\n        cffface->num_faces = (FT_Long)cff->num_faces;\n\n        /* compute number of glyphs */\n        if ( dict->cid_registry != 0xFFFFU )\n          cffface->num_glyphs = (FT_Long)( cff->charset.max_cid + 1 );\n        else\n          cffface->num_glyphs = (FT_Long)cff->charstrings_index.count;\n\n        /* set global bbox, as well as EM size */\n        cffface->bbox.xMin =   dict->font_bbox.xMin            >> 16;\n        cffface->bbox.yMin =   dict->font_bbox.yMin            >> 16;\n        /* no `U' suffix here to 0xFFFF! */\n        cffface->bbox.xMax = ( dict->font_bbox.xMax + 0xFFFF ) >> 16;\n        cffface->bbox.yMax = ( dict->font_bbox.yMax + 0xFFFF ) >> 16;\n\n        cffface->units_per_EM = (FT_UShort)( dict->units_per_em );\n\n        cffface->ascender  = (FT_Short)( cffface->bbox.yMax );\n        cffface->descender = (FT_Short)( cffface->bbox.yMin );\n\n        cffface->height = (FT_Short)( ( cffface->units_per_EM * 12 ) / 10 );\n        if ( cffface->height < cffface->ascender - cffface->descender )\n          cffface->height = (FT_Short)( cffface->ascender -\n                                        cffface->descender );\n\n        cffface->underline_position  =\n          (FT_Short)( dict->underline_position >> 16 );\n        cffface->underline_thickness =\n          (FT_Short)( dict->underline_thickness >> 16 );\n\n        /* retrieve font family & style name */\n        if ( dict->family_name )\n        {\n          char*  family_name;\n\n\n          family_name = cff_index_get_sid_string( cff, dict->family_name );\n          if ( family_name )\n            cffface->family_name = cff_strcpy( memory, family_name );\n        }\n\n        if ( !cffface->family_name )\n        {\n          cffface->family_name = cff_index_get_name(\n                                   cff,\n                                   (FT_UInt)( face_index & 0xFFFF ) );\n          if ( cffface->family_name )\n            remove_subset_prefix( cffface->family_name );\n        }\n\n        if ( cffface->family_name )\n        {\n          char*  full   = cff_index_get_sid_string( cff,\n                                                    dict->full_name );\n          char*  fullp  = full;\n          char*  family = cffface->family_name;\n\n\n          /* We try to extract the style name from the full name.   */\n          /* We need to ignore spaces and dashes during the search. */\n          if ( full && family )\n          {\n            while ( *fullp )\n            {\n              /* skip common characters at the start of both strings */\n              if ( *fullp == *family )\n              {\n                family++;\n                fullp++;\n                continue;\n              }\n\n              /* ignore spaces and dashes in full name during comparison */\n              if ( *fullp == ' ' || *fullp == '-' )\n              {\n                fullp++;\n                continue;\n              }\n\n              /* ignore spaces and dashes in family name during comparison */\n              if ( *family == ' ' || *family == '-' )\n              {\n                family++;\n                continue;\n              }\n\n              if ( !*family && *fullp )\n              {\n                /* The full name begins with the same characters as the  */\n                /* family name, with spaces and dashes removed.  In this */\n                /* case, the remaining string in `fullp' will be used as */\n                /* the style name.                                       */\n                style_name = cff_strcpy( memory, fullp );\n\n                /* remove the style part from the family name (if present) */\n                if ( style_name )\n                  remove_style( cffface->family_name, style_name );\n              }\n              break;\n            }\n          }\n        }\n        else\n        {\n          char  *cid_font_name =\n                   cff_index_get_sid_string( cff,\n                                             dict->cid_font_name );\n\n\n          /* do we have a `/FontName' for a CID-keyed font? */\n          if ( cid_font_name )\n            cffface->family_name = cff_strcpy( memory, cid_font_name );\n        }\n\n        if ( style_name )\n          cffface->style_name = style_name;\n        else\n          /* assume \"Regular\" style if we don't know better */\n          cffface->style_name = cff_strcpy( memory, \"Regular\" );\n\n        /********************************************************************\n         *\n         * Compute face flags.\n         */\n        flags = FT_FACE_FLAG_SCALABLE   | /* scalable outlines */\n                FT_FACE_FLAG_HORIZONTAL | /* horizontal data   */\n                FT_FACE_FLAG_HINTER;      /* has native hinter */\n\n        if ( sfnt_format )\n          flags |= FT_FACE_FLAG_SFNT;\n\n        /* fixed width font? */\n        if ( dict->is_fixed_pitch )\n          flags |= FT_FACE_FLAG_FIXED_WIDTH;\n\n  /* XXX: WE DO NOT SUPPORT KERNING METRICS IN THE GPOS TABLE FOR NOW */\n#if 0\n        /* kerning available? */\n        if ( face->kern_pairs )\n          flags |= FT_FACE_FLAG_KERNING;\n#endif\n\n        cffface->face_flags |= flags;\n\n        /********************************************************************\n         *\n         * Compute style flags.\n         */\n        flags = 0;\n\n        if ( dict->italic_angle )\n          flags |= FT_STYLE_FLAG_ITALIC;\n\n        {\n          char  *weight = cff_index_get_sid_string( cff,\n                                                    dict->weight );\n\n\n          if ( weight )\n            if ( !ft_strcmp( weight, \"Bold\"  ) ||\n                 !ft_strcmp( weight, \"Black\" ) )\n              flags |= FT_STYLE_FLAG_BOLD;\n        }\n\n        /* double check */\n        if ( !(flags & FT_STYLE_FLAG_BOLD) && cffface->style_name )\n          if ( !ft_strncmp( cffface->style_name, \"Bold\", 4 )  ||\n               !ft_strncmp( cffface->style_name, \"Black\", 5 ) )\n            flags |= FT_STYLE_FLAG_BOLD;\n\n        cffface->style_flags = flags;\n      }\n\n#ifndef FT_CONFIG_OPTION_NO_GLYPH_NAMES\n      /* CID-keyed CFF or CFF2 fonts don't have glyph names -- the SFNT */\n      /* loader has unset this flag because of the 3.0 `post' table.    */\n      if ( dict->cid_registry == 0xFFFFU && !cff2 )\n        cffface->face_flags |= FT_FACE_FLAG_GLYPH_NAMES;\n#endif\n\n      if ( dict->cid_registry != 0xFFFFU && pure_cff )\n        cffface->face_flags |= FT_FACE_FLAG_CID_KEYED;\n\n      /********************************************************************\n       *\n       * Compute char maps.\n       */\n\n      /* Try to synthesize a Unicode charmap if there is none available */\n      /* already.  If an OpenType font contains a Unicode \"cmap\", we    */\n      /* will use it, whatever be in the CFF part of the file.          */\n      {\n        FT_CharMapRec  cmaprec;\n        FT_CharMap     cmap;\n        FT_Int         nn;\n        CFF_Encoding   encoding = &cff->encoding;\n\n\n        for ( nn = 0; nn < cffface->num_charmaps; nn++ )\n        {\n          cmap = cffface->charmaps[nn];\n\n          /* Windows Unicode? */\n          if ( cmap->platform_id == TT_PLATFORM_MICROSOFT &&\n               cmap->encoding_id == TT_MS_ID_UNICODE_CS   )\n            goto Skip_Unicode;\n\n          /* Apple Unicode platform id? */\n          if ( cmap->platform_id == TT_PLATFORM_APPLE_UNICODE )\n            goto Skip_Unicode; /* Apple Unicode */\n        }\n\n        /* since CID-keyed fonts don't contain glyph names, we can't */\n        /* construct a cmap                                          */\n        if ( pure_cff && cff->top_font.font_dict.cid_registry != 0xFFFFU )\n          goto Exit;\n\n        /* we didn't find a Unicode charmap -- synthesize one */\n        cmaprec.face        = cffface;\n        cmaprec.platform_id = TT_PLATFORM_MICROSOFT;\n        cmaprec.encoding_id = TT_MS_ID_UNICODE_CS;\n        cmaprec.encoding    = FT_ENCODING_UNICODE;\n\n        nn = cffface->num_charmaps;\n\n        error = FT_CMap_New( &cff_cmap_unicode_class_rec, NULL,\n                             &cmaprec, NULL );\n        if ( error                                      &&\n             FT_ERR_NEQ( error, No_Unicode_Glyph_Name ) &&\n             FT_ERR_NEQ( error, Unimplemented_Feature ) )\n          goto Exit;\n        error = FT_Err_Ok;\n\n        /* if no Unicode charmap was previously selected, select this one */\n        if ( !cffface->charmap && nn != cffface->num_charmaps )\n          cffface->charmap = cffface->charmaps[nn];\n\n      Skip_Unicode:\n        if ( encoding->count > 0 )\n        {\n          FT_CMap_Class  clazz;\n\n\n          cmaprec.face        = cffface;\n          cmaprec.platform_id = TT_PLATFORM_ADOBE;  /* Adobe platform id */\n\n          if ( encoding->offset == 0 )\n          {\n            cmaprec.encoding_id = TT_ADOBE_ID_STANDARD;\n            cmaprec.encoding    = FT_ENCODING_ADOBE_STANDARD;\n            clazz               = &cff_cmap_encoding_class_rec;\n          }\n          else if ( encoding->offset == 1 )\n          {\n            cmaprec.encoding_id = TT_ADOBE_ID_EXPERT;\n            cmaprec.encoding    = FT_ENCODING_ADOBE_EXPERT;\n            clazz               = &cff_cmap_encoding_class_rec;\n          }\n          else\n          {\n            cmaprec.encoding_id = TT_ADOBE_ID_CUSTOM;\n            cmaprec.encoding    = FT_ENCODING_ADOBE_CUSTOM;\n            clazz               = &cff_cmap_encoding_class_rec;\n          }\n\n          error = FT_CMap_New( clazz, NULL, &cmaprec, NULL );\n        }\n      }\n    }\n\n  Exit:\n    return error;\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -222,8 +222,10 @@\n \n #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT\n       {\n-        FT_Service_MultiMasters       mm  = (FT_Service_MultiMasters)face->mm;\n-        FT_Service_MetricsVariations  var = (FT_Service_MetricsVariations)face->var;\n+        FT_Service_MultiMasters\n+          mm = (FT_Service_MultiMasters)face->mm;\n+        FT_Service_MetricsVariations\n+          var = (FT_Service_MetricsVariations)face->face_var;\n \n         FT_UInt  instance_index = (FT_UInt)face_index >> 16;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        FT_Service_MultiMasters       mm  = (FT_Service_MultiMasters)face->mm;",
                "        FT_Service_MetricsVariations  var = (FT_Service_MetricsVariations)face->var;"
            ],
            "added_lines": [
                "        FT_Service_MultiMasters",
                "          mm = (FT_Service_MultiMasters)face->mm;",
                "        FT_Service_MetricsVariations",
                "          var = (FT_Service_MetricsVariations)face->face_var;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-21287",
        "func_name": "android/tt_size_request",
        "description": "In multiple locations, there is a possible code execution due to type confusion. This could lead to remote code execution with no additional execution privileges needed. User interaction is not needed for exploitation.\n\n",
        "git_url": "https://android.googlesource.com/platform/external/freetype/+/a79e80a25874dacaa266906a9048f13d4bac41c6",
        "commit_title": "Cherrypick following three changes",
        "commit_text": " [cherrypick 545bf3a27] [sfnt, truetype] Add `size_reset` to `MetricsVariations`. [cherrypick daad10810] [truetype] tt_size_reset_height to take FT_Size [cherrypick 51ad7b243] [services] FT_Size_Reset_Func to return FT_Error  Bug: 278221085 Test: TreeHugger (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:9fe9411db4b7e715a39c0ccf48d1e0328f1d8e7c) (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:cff127c5bc4a47ef88df305380ee2a47318a865b) Merged-In: I7e839b2a36e35c27974a82cc76e853996a7c7688 ",
        "func_before": "static FT_Error\n  tt_size_request( FT_Size          size,\n                   FT_Size_Request  req )\n  {\n    TT_Size   ttsize = (TT_Size)size;\n    FT_Error  error  = FT_Err_Ok;\n\n\n#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS\n\n    if ( FT_HAS_FIXED_SIZES( size->face ) )\n    {\n      TT_Face       ttface = (TT_Face)size->face;\n      SFNT_Service  sfnt   = (SFNT_Service)ttface->sfnt;\n      FT_ULong      strike_index;\n\n\n      error = sfnt->set_sbit_strike( ttface, req, &strike_index );\n\n      if ( error )\n        ttsize->strike_index = 0xFFFFFFFFUL;\n      else\n        return tt_size_select( size, strike_index );\n    }\n\n#endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */\n\n    {\n      FT_Error  err = FT_Request_Metrics( size->face, req );\n\n\n      if ( err )\n      {\n        error = err;\n        goto Exit;\n      }\n    }\n\n    if ( FT_IS_SCALABLE( size->face ) )\n    {\n      error = tt_size_reset( ttsize, 0 );\n\n#ifdef TT_USE_BYTECODE_INTERPRETER\n      /* for the `MPS' bytecode instruction we need the point size */\n      if ( !error )\n      {\n        FT_UInt  resolution =\n                   ttsize->metrics->x_ppem > ttsize->metrics->y_ppem\n                     ? req->horiResolution\n                     : req->vertResolution;\n\n\n        /* if we don't have a resolution value, assume 72dpi */\n        if ( req->type == FT_SIZE_REQUEST_TYPE_SCALES ||\n             !resolution                              )\n          resolution = 72;\n\n        ttsize->point_size = FT_MulDiv( ttsize->ttmetrics.ppem,\n                                        64 * 72,\n                                        resolution );\n      }\n#endif\n    }\n\n  Exit:\n    return error;\n  }",
        "func": "static FT_Error\n  tt_size_request( FT_Size          size,\n                   FT_Size_Request  req )\n  {\n    TT_Size   ttsize = (TT_Size)size;\n    FT_Error  error  = FT_Err_Ok;\n\n\n#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS\n\n    if ( FT_HAS_FIXED_SIZES( size->face ) )\n    {\n      TT_Face       ttface = (TT_Face)size->face;\n      SFNT_Service  sfnt   = (SFNT_Service)ttface->sfnt;\n      FT_ULong      strike_index;\n\n\n      error = sfnt->set_sbit_strike( ttface, req, &strike_index );\n\n      if ( error )\n        ttsize->strike_index = 0xFFFFFFFFUL;\n      else\n        return tt_size_select( size, strike_index );\n    }\n\n#endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */\n\n    {\n      FT_Error  err = FT_Request_Metrics( size->face, req );\n\n\n      if ( err )\n      {\n        error = err;\n        goto Exit;\n      }\n    }\n\n    if ( FT_IS_SCALABLE( size->face ) )\n    {\n      error = tt_size_reset( ttsize );\n\n#ifdef TT_USE_BYTECODE_INTERPRETER\n      /* for the `MPS' bytecode instruction we need the point size */\n      if ( !error )\n      {\n        FT_UInt  resolution =\n                   ttsize->metrics->x_ppem > ttsize->metrics->y_ppem\n                     ? req->horiResolution\n                     : req->vertResolution;\n\n\n        /* if we don't have a resolution value, assume 72dpi */\n        if ( req->type == FT_SIZE_REQUEST_TYPE_SCALES ||\n             !resolution                              )\n          resolution = 72;\n\n        ttsize->point_size = FT_MulDiv( ttsize->ttmetrics.ppem,\n                                        64 * 72,\n                                        resolution );\n      }\n#endif\n    }\n\n  Exit:\n    return error;\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -38,7 +38,7 @@\n \n     if ( FT_IS_SCALABLE( size->face ) )\n     {\n-      error = tt_size_reset( ttsize, 0 );\n+      error = tt_size_reset( ttsize );\n \n #ifdef TT_USE_BYTECODE_INTERPRETER\n       /* for the `MPS' bytecode instruction we need the point size */",
        "diff_line_info": {
            "deleted_lines": [
                "      error = tt_size_reset( ttsize, 0 );"
            ],
            "added_lines": [
                "      error = tt_size_reset( ttsize );"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-21287",
        "func_name": "android/tt_size_select",
        "description": "In multiple locations, there is a possible code execution due to type confusion. This could lead to remote code execution with no additional execution privileges needed. User interaction is not needed for exploitation.\n\n",
        "git_url": "https://android.googlesource.com/platform/external/freetype/+/a79e80a25874dacaa266906a9048f13d4bac41c6",
        "commit_title": "Cherrypick following three changes",
        "commit_text": " [cherrypick 545bf3a27] [sfnt, truetype] Add `size_reset` to `MetricsVariations`. [cherrypick daad10810] [truetype] tt_size_reset_height to take FT_Size [cherrypick 51ad7b243] [services] FT_Size_Reset_Func to return FT_Error  Bug: 278221085 Test: TreeHugger (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:9fe9411db4b7e715a39c0ccf48d1e0328f1d8e7c) (cherry picked from https://googleplex-android-review.googlesource.com/q/commit:cff127c5bc4a47ef88df305380ee2a47318a865b) Merged-In: I7e839b2a36e35c27974a82cc76e853996a7c7688 ",
        "func_before": "static FT_Error\n  tt_size_select( FT_Size   size,\n                  FT_ULong  strike_index )\n  {\n    TT_Face   ttface = (TT_Face)size->face;\n    TT_Size   ttsize = (TT_Size)size;\n    FT_Error  error  = FT_Err_Ok;\n\n\n    ttsize->strike_index = strike_index;\n\n    if ( FT_IS_SCALABLE( size->face ) )\n    {\n      /* use the scaled metrics, even when tt_size_reset fails */\n      FT_Select_Metrics( size->face, strike_index );\n\n      tt_size_reset( ttsize, 0 ); /* ignore return value */\n    }\n    else\n    {\n      SFNT_Service      sfnt         = (SFNT_Service)ttface->sfnt;\n      FT_Size_Metrics*  size_metrics = &size->metrics;\n\n\n      error = sfnt->load_strike_metrics( ttface,\n                                         strike_index,\n                                         size_metrics );\n      if ( error )\n        ttsize->strike_index = 0xFFFFFFFFUL;\n    }\n\n    return error;\n  }",
        "func": "static FT_Error\n  tt_size_select( FT_Size   size,\n                  FT_ULong  strike_index )\n  {\n    TT_Face   ttface = (TT_Face)size->face;\n    TT_Size   ttsize = (TT_Size)size;\n    FT_Error  error  = FT_Err_Ok;\n\n\n    ttsize->strike_index = strike_index;\n\n    if ( FT_IS_SCALABLE( size->face ) )\n    {\n      /* use the scaled metrics, even when tt_size_reset fails */\n      FT_Select_Metrics( size->face, strike_index );\n\n      tt_size_reset( ttsize ); /* ignore return value */\n    }\n    else\n    {\n      SFNT_Service      sfnt         = (SFNT_Service)ttface->sfnt;\n      FT_Size_Metrics*  size_metrics = &size->metrics;\n\n\n      error = sfnt->load_strike_metrics( ttface,\n                                         strike_index,\n                                         size_metrics );\n      if ( error )\n        ttsize->strike_index = 0xFFFFFFFFUL;\n    }\n\n    return error;\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n       /* use the scaled metrics, even when tt_size_reset fails */\n       FT_Select_Metrics( size->face, strike_index );\n \n-      tt_size_reset( ttsize, 0 ); /* ignore return value */\n+      tt_size_reset( ttsize ); /* ignore return value */\n     }\n     else\n     {",
        "diff_line_info": {
            "deleted_lines": [
                "      tt_size_reset( ttsize, 0 ); /* ignore return value */"
            ],
            "added_lines": [
                "      tt_size_reset( ttsize ); /* ignore return value */"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-10757",
        "func_name": "torvalds/linux/move_page_tables",
        "description": "A flaw was found in the Linux Kernel in versions after 4.5-rc1 in the way mremap handled DAX Huge Pages. This flaw allows a local attacker with access to a DAX enabled storage to escalate their privileges on the system.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5bfea2d9b17f1034a68147a8b03b9789af5700f9",
        "commit_title": "The original code in mm/mremap.c checks huge pmd by:",
        "commit_text": " \t\tif (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd)) {  However, a DAX mapped nvdimm is mapped as huge page (by default) but it is not transparent huge page (_PAGE_PSE | PAGE_DEVMAP).  This commit changes the condition to include the case.  This addresses CVE-2020-10757.  Cc: <stable@vger.kernel.org> ",
        "func_before": "unsigned long move_page_tables(struct vm_area_struct *vma,\n\t\tunsigned long old_addr, struct vm_area_struct *new_vma,\n\t\tunsigned long new_addr, unsigned long len,\n\t\tbool need_rmap_locks)\n{\n\tunsigned long extent, next, old_end;\n\tstruct mmu_notifier_range range;\n\tpmd_t *old_pmd, *new_pmd;\n\n\told_end = old_addr + len;\n\tflush_cache_range(vma, old_addr, old_end);\n\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_UNMAP, 0, vma, vma->vm_mm,\n\t\t\t\told_addr, old_end);\n\tmmu_notifier_invalidate_range_start(&range);\n\n\tfor (; old_addr < old_end; old_addr += extent, new_addr += extent) {\n\t\tcond_resched();\n\t\tnext = (old_addr + PMD_SIZE) & PMD_MASK;\n\t\t/* even if next overflowed, extent below will be ok */\n\t\textent = next - old_addr;\n\t\tif (extent > old_end - old_addr)\n\t\t\textent = old_end - old_addr;\n\t\told_pmd = get_old_pmd(vma->vm_mm, old_addr);\n\t\tif (!old_pmd)\n\t\t\tcontinue;\n\t\tnew_pmd = alloc_new_pmd(vma->vm_mm, vma, new_addr);\n\t\tif (!new_pmd)\n\t\t\tbreak;\n\t\tif (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd)) {\n\t\t\tif (extent == HPAGE_PMD_SIZE) {\n\t\t\t\tbool moved;\n\t\t\t\t/* See comment in move_ptes() */\n\t\t\t\tif (need_rmap_locks)\n\t\t\t\t\ttake_rmap_locks(vma);\n\t\t\t\tmoved = move_huge_pmd(vma, old_addr, new_addr,\n\t\t\t\t\t\t    old_end, old_pmd, new_pmd);\n\t\t\t\tif (need_rmap_locks)\n\t\t\t\t\tdrop_rmap_locks(vma);\n\t\t\t\tif (moved)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsplit_huge_pmd(vma, old_pmd, old_addr);\n\t\t\tif (pmd_trans_unstable(old_pmd))\n\t\t\t\tcontinue;\n\t\t} else if (extent == PMD_SIZE) {\n#ifdef CONFIG_HAVE_MOVE_PMD\n\t\t\t/*\n\t\t\t * If the extent is PMD-sized, try to speed the move by\n\t\t\t * moving at the PMD level if possible.\n\t\t\t */\n\t\t\tbool moved;\n\n\t\t\tif (need_rmap_locks)\n\t\t\t\ttake_rmap_locks(vma);\n\t\t\tmoved = move_normal_pmd(vma, old_addr, new_addr,\n\t\t\t\t\told_end, old_pmd, new_pmd);\n\t\t\tif (need_rmap_locks)\n\t\t\t\tdrop_rmap_locks(vma);\n\t\t\tif (moved)\n\t\t\t\tcontinue;\n#endif\n\t\t}\n\n\t\tif (pte_alloc(new_vma->vm_mm, new_pmd))\n\t\t\tbreak;\n\t\tnext = (new_addr + PMD_SIZE) & PMD_MASK;\n\t\tif (extent > next - new_addr)\n\t\t\textent = next - new_addr;\n\t\tmove_ptes(vma, old_pmd, old_addr, old_addr + extent, new_vma,\n\t\t\t  new_pmd, new_addr, need_rmap_locks);\n\t}\n\n\tmmu_notifier_invalidate_range_end(&range);\n\n\treturn len + old_addr - old_end;\t/* how much done */\n}",
        "func": "unsigned long move_page_tables(struct vm_area_struct *vma,\n\t\tunsigned long old_addr, struct vm_area_struct *new_vma,\n\t\tunsigned long new_addr, unsigned long len,\n\t\tbool need_rmap_locks)\n{\n\tunsigned long extent, next, old_end;\n\tstruct mmu_notifier_range range;\n\tpmd_t *old_pmd, *new_pmd;\n\n\told_end = old_addr + len;\n\tflush_cache_range(vma, old_addr, old_end);\n\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_UNMAP, 0, vma, vma->vm_mm,\n\t\t\t\told_addr, old_end);\n\tmmu_notifier_invalidate_range_start(&range);\n\n\tfor (; old_addr < old_end; old_addr += extent, new_addr += extent) {\n\t\tcond_resched();\n\t\tnext = (old_addr + PMD_SIZE) & PMD_MASK;\n\t\t/* even if next overflowed, extent below will be ok */\n\t\textent = next - old_addr;\n\t\tif (extent > old_end - old_addr)\n\t\t\textent = old_end - old_addr;\n\t\told_pmd = get_old_pmd(vma->vm_mm, old_addr);\n\t\tif (!old_pmd)\n\t\t\tcontinue;\n\t\tnew_pmd = alloc_new_pmd(vma->vm_mm, vma, new_addr);\n\t\tif (!new_pmd)\n\t\t\tbreak;\n\t\tif (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd) || pmd_devmap(*old_pmd)) {\n\t\t\tif (extent == HPAGE_PMD_SIZE) {\n\t\t\t\tbool moved;\n\t\t\t\t/* See comment in move_ptes() */\n\t\t\t\tif (need_rmap_locks)\n\t\t\t\t\ttake_rmap_locks(vma);\n\t\t\t\tmoved = move_huge_pmd(vma, old_addr, new_addr,\n\t\t\t\t\t\t    old_end, old_pmd, new_pmd);\n\t\t\t\tif (need_rmap_locks)\n\t\t\t\t\tdrop_rmap_locks(vma);\n\t\t\t\tif (moved)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsplit_huge_pmd(vma, old_pmd, old_addr);\n\t\t\tif (pmd_trans_unstable(old_pmd))\n\t\t\t\tcontinue;\n\t\t} else if (extent == PMD_SIZE) {\n#ifdef CONFIG_HAVE_MOVE_PMD\n\t\t\t/*\n\t\t\t * If the extent is PMD-sized, try to speed the move by\n\t\t\t * moving at the PMD level if possible.\n\t\t\t */\n\t\t\tbool moved;\n\n\t\t\tif (need_rmap_locks)\n\t\t\t\ttake_rmap_locks(vma);\n\t\t\tmoved = move_normal_pmd(vma, old_addr, new_addr,\n\t\t\t\t\told_end, old_pmd, new_pmd);\n\t\t\tif (need_rmap_locks)\n\t\t\t\tdrop_rmap_locks(vma);\n\t\t\tif (moved)\n\t\t\t\tcontinue;\n#endif\n\t\t}\n\n\t\tif (pte_alloc(new_vma->vm_mm, new_pmd))\n\t\t\tbreak;\n\t\tnext = (new_addr + PMD_SIZE) & PMD_MASK;\n\t\tif (extent > next - new_addr)\n\t\t\textent = next - new_addr;\n\t\tmove_ptes(vma, old_pmd, old_addr, old_addr + extent, new_vma,\n\t\t\t  new_pmd, new_addr, need_rmap_locks);\n\t}\n\n\tmmu_notifier_invalidate_range_end(&range);\n\n\treturn len + old_addr - old_end;\t/* how much done */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,7 +27,7 @@\n \t\tnew_pmd = alloc_new_pmd(vma->vm_mm, vma, new_addr);\n \t\tif (!new_pmd)\n \t\t\tbreak;\n-\t\tif (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd)) {\n+\t\tif (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd) || pmd_devmap(*old_pmd)) {\n \t\t\tif (extent == HPAGE_PMD_SIZE) {\n \t\t\t\tbool moved;\n \t\t\t\t/* See comment in move_ptes() */",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd)) {"
            ],
            "added_lines": [
                "\t\tif (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd) || pmd_devmap(*old_pmd)) {"
            ]
        }
    }
]