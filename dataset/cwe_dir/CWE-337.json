[
    {
        "cve_id": "CVE-2016-15006",
        "func_name": "pfmonville/enigmaX/scramble",
        "description": "A vulnerability, which was classified as problematic, has been found in enigmaX up to 2.2. This issue affects the function getSeed of the file main.c of the component Scrambling Table Handler. The manipulation leads to predictable seed in pseudo-random number generator (prng). The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. Upgrading to version 2.3 is able to address this issue. The identifier of the patch is 922bf90ca14a681629ba0b807a997a81d70225b5. It is recommended to upgrade the affected component. The identifier VDB-217181 was assigned to this vulnerability.",
        "git_url": "https://github.com/pfmonville/enigmaX/commit/922bf90ca14a681629ba0b807a997a81d70225b5",
        "commit_title": "2.3",
        "commit_text": " + now the order of the scrambling tables when using a keyfile is defined by the keyfile and not only with the password. Even if someone has the password, without the keyfile it is impossible to do any frequency analysis attack ~ fix the scrambling when a keyfile is used (previously the 16 tables were the same) ~ some tweaks to descriptions",
        "func_before": "void scramble(FILE* keyFile){\n\tfor (int j = 0; j < 16; ++j)\n\t{\n\t\tchar temp = 0;\n\n\t\tfor (int i = 0; i < 256; ++i)\n\t\t{\n\t\t\tscrambleAsciiTables[j][i] = i;\n\t\t}\n\n\t\tif (keyFile != NULL){\n\t\t\tint size;\n\t\t\tchar extractedString[BUFFER_SIZE] = \"\";\n\t\t\twhile((size = fread(extractedString, 1, BUFFER_SIZE, keyFile)) > 0){\n\t\t\t\tfor (int i = 0; i < size; ++i)\n\t\t\t\t{\n\t\t\t\t\ttemp = scrambleAsciiTables[j][i%256];\n\t\t\t\t\tscrambleAsciiTables[j][i%256] = scrambleAsciiTables[j][(unsigned char)(extractedString[i])];\n\t\t\t\t\tscrambleAsciiTables[j][(unsigned char)(extractedString[i])] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t\trewind(keyFile);\n\t\t} else {\n\t\t\tunsigned char random256;\n\t\t\tfor (int i = 0; i < 10 * 256; ++i)\n\t\t\t{\n\t\t\t\trandom256 = generateNumber() ^ passPhrase[passIndex];\n\t\t\t\tpassIndex++;\n\t\t\t\tpassIndex %= 16384;\n\t\t\t\ttemp = scrambleAsciiTables[j][i%256];\n\t\t\t\tscrambleAsciiTables[j][i%256] = scrambleAsciiTables[j][random256];\n\t\t\t\tscrambleAsciiTables[j][random256] = temp;\n\t\t\t}\n\t\t}\n\t}\n}",
        "func": "void scramble(FILE* keyFile){\n\tprintf(\"scrambling substitution's tables...\\n\");\n\tfor (int j = 0; j < 16; ++j)\n\t{\n\t\tchar temp = 0;\n\n\t\tfor (int i = 0; i < 256; ++i)\n\t\t{\n\t\t\tscrambleAsciiTables[j][i] = i;\n\t\t}\n\n\t\tif (usingKeyFile){\n\t\t\tint size;\n\t\t\tchar extractedString[BUFFER_SIZE] = \"\";\n\t\t\tunsigned char random256;\n\t\t\twhile((size = fread(extractedString, 1, BUFFER_SIZE, keyFile)) > 0){\n\t\t\t\tfor (int i = 0; i < size; ++i)\n\t\t\t\t{\n\t\t\t\t\trandom256 = generateNumber() ^ extractedString[i];\n\t\t\t\t\ttemp = scrambleAsciiTables[j][i%256];\n\t\t\t\t\tscrambleAsciiTables[j][i%256] = scrambleAsciiTables[j][random256];\n\t\t\t\t\tscrambleAsciiTables[j][random256] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t\trewind(keyFile);\n\t\t} else {\n\t\t\tunsigned char random256;\n\t\t\tfor (int i = 0; i < 10 * 256; ++i)\n\t\t\t{\n\t\t\t\trandom256 = generateNumber() ^ passPhrase[passIndex];\n\t\t\t\tpassIndex++;\n\t\t\t\tpassIndex %= 16384;\n\t\t\t\ttemp = scrambleAsciiTables[j][i%256];\n\t\t\t\tscrambleAsciiTables[j][i%256] = scrambleAsciiTables[j][random256];\n\t\t\t\tscrambleAsciiTables[j][random256] = temp;\n\t\t\t}\n\t\t}\n\t}\n\tif(usingKeyFile){\n\t\tint j = 0;\n\t\tchar temp[BUFFER_SIZE];\n\t\twhile(j < BUFFER_SIZE){\n\t\t\tint charactersRead = fread(temp, 1, BUFFER_SIZE, keyFile);\n\t\t\tif(charactersRead == 0){\n\t\t\t\trewind(keyFile);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int i = 0; i < charactersRead; ++i)\n\t\t\t{\n\t\t\t\tscramblingTablesOrder[j] = temp[i] & (1+2+4+8);\n\t\t\t\tj++;\n\t\t\t\tif(j == BUFFER_SIZE){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,5 @@\n void scramble(FILE* keyFile){\n+\tprintf(\"scrambling substitution's tables...\\n\");\n \tfor (int j = 0; j < 16; ++j)\n \t{\n \t\tchar temp = 0;\n@@ -8,15 +9,17 @@\n \t\t\tscrambleAsciiTables[j][i] = i;\n \t\t}\n \n-\t\tif (keyFile != NULL){\n+\t\tif (usingKeyFile){\n \t\t\tint size;\n \t\t\tchar extractedString[BUFFER_SIZE] = \"\";\n+\t\t\tunsigned char random256;\n \t\t\twhile((size = fread(extractedString, 1, BUFFER_SIZE, keyFile)) > 0){\n \t\t\t\tfor (int i = 0; i < size; ++i)\n \t\t\t\t{\n+\t\t\t\t\trandom256 = generateNumber() ^ extractedString[i];\n \t\t\t\t\ttemp = scrambleAsciiTables[j][i%256];\n-\t\t\t\t\tscrambleAsciiTables[j][i%256] = scrambleAsciiTables[j][(unsigned char)(extractedString[i])];\n-\t\t\t\t\tscrambleAsciiTables[j][(unsigned char)(extractedString[i])] = temp;\n+\t\t\t\t\tscrambleAsciiTables[j][i%256] = scrambleAsciiTables[j][random256];\n+\t\t\t\t\tscrambleAsciiTables[j][random256] = temp;\n \t\t\t\t}\n \t\t\t}\n \t\t\trewind(keyFile);\n@@ -33,4 +36,23 @@\n \t\t\t}\n \t\t}\n \t}\n+\tif(usingKeyFile){\n+\t\tint j = 0;\n+\t\tchar temp[BUFFER_SIZE];\n+\t\twhile(j < BUFFER_SIZE){\n+\t\t\tint charactersRead = fread(temp, 1, BUFFER_SIZE, keyFile);\n+\t\t\tif(charactersRead == 0){\n+\t\t\t\trewind(keyFile);\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tfor (int i = 0; i < charactersRead; ++i)\n+\t\t\t{\n+\t\t\t\tscramblingTablesOrder[j] = temp[i] & (1+2+4+8);\n+\t\t\t\tj++;\n+\t\t\t\tif(j == BUFFER_SIZE){\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (keyFile != NULL){",
                "\t\t\t\t\tscrambleAsciiTables[j][i%256] = scrambleAsciiTables[j][(unsigned char)(extractedString[i])];",
                "\t\t\t\t\tscrambleAsciiTables[j][(unsigned char)(extractedString[i])] = temp;"
            ],
            "added_lines": [
                "\tprintf(\"scrambling substitution's tables...\\n\");",
                "\t\tif (usingKeyFile){",
                "\t\t\tunsigned char random256;",
                "\t\t\t\t\trandom256 = generateNumber() ^ extractedString[i];",
                "\t\t\t\t\tscrambleAsciiTables[j][i%256] = scrambleAsciiTables[j][random256];",
                "\t\t\t\t\tscrambleAsciiTables[j][random256] = temp;",
                "\tif(usingKeyFile){",
                "\t\tint j = 0;",
                "\t\tchar temp[BUFFER_SIZE];",
                "\t\twhile(j < BUFFER_SIZE){",
                "\t\t\tint charactersRead = fread(temp, 1, BUFFER_SIZE, keyFile);",
                "\t\t\tif(charactersRead == 0){",
                "\t\t\t\trewind(keyFile);",
                "\t\t\t\tcontinue;",
                "\t\t\t}",
                "\t\t\tfor (int i = 0; i < charactersRead; ++i)",
                "\t\t\t{",
                "\t\t\t\tscramblingTablesOrder[j] = temp[i] & (1+2+4+8);",
                "\t\t\t\tj++;",
                "\t\t\t\tif(j == BUFFER_SIZE){",
                "\t\t\t\t\tbreak;",
                "\t\t\t\t}",
                "\t\t\t}",
                "\t\t}",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-15006",
        "func_name": "pfmonville/enigmaX/main",
        "description": "A vulnerability, which was classified as problematic, has been found in enigmaX up to 2.2. This issue affects the function getSeed of the file main.c of the component Scrambling Table Handler. The manipulation leads to predictable seed in pseudo-random number generator (prng). The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. Upgrading to version 2.3 is able to address this issue. The identifier of the patch is 922bf90ca14a681629ba0b807a997a81d70225b5. It is recommended to upgrade the affected component. The identifier VDB-217181 was assigned to this vulnerability.",
        "git_url": "https://github.com/pfmonville/enigmaX/commit/922bf90ca14a681629ba0b807a997a81d70225b5",
        "commit_title": "2.3",
        "commit_text": " + now the order of the scrambling tables when using a keyfile is defined by the keyfile and not only with the password. Even if someone has the password, without the keyfile it is impossible to do any frequency analysis attack ~ fix the scrambling when a keyfile is used (previously the 16 tables were the same) ~ some tweaks to descriptions",
        "func_before": "int main(int argc, char const *argv[])\n{\n\tFILE* mainFile;\n\tFILE* keyFile = NULL;\n\n\tif ((progName = strrchr(argv[0], '/')) != NULL) {\n\t\t++progName;\n\t} else {\n\t\tprogName = argv[0];\n\t}\n\tif (argc < 2) {\n\t\tusage(1);\n\t} else if(argc >= 5 ) { \n\t\tprintf(\"Error: Too many arguments\\n\");\n\t\tusage(1);\n\t} else if (strcmp(argv[1], \"-h\") == 0 || strcmp(argv[1], \"--help\") == 0) {\n\t\tusage(0);\n\t}\n\n\tif (argc >= 3)\n\t{\n\t\t//test if the option -s is present\n\t\tif (strcmp(argv[2], \"-s\") == 0 || strcmp(argv[2], \"--standard\") == 0){\n\t\t\tscrambling = 0;\n\t\t\t//if there is a keyfile, warns that it will not be used \n\t\t\tif(argc >= 4){\n\t\t\t\tif((keyFile = fopen(argv[3], \"r\")) == NULL){\n\t\t\t\t\tperror(argv[3]);\n\t\t\t\t\tusage(1);\n\t\t\t\t}\n\t\t\t\tprintf(\"Warning: with the -s|--standard option, the keyfile will not bu used\\n\");\n\t\t\t\tkeyFile = NULL;\n\t\t\t}\n\t\t//else the option -i\n\t\t} else if (strcmp(argv[2], \"-i\") == 0 || strcmp(argv[2], \"--inverted\") == 0){\n\t\t\tisCodingInverted = 1;\n\t\t\t//if i is present, checks if there is a keyfile in the third argument\n\t\t\tif(argc >= 4){\n\t\t\t\tif((keyFile = fopen(argv[3], \"r\")) == NULL){\n\t\t\t\t\tperror(argv[3]);\n\t\t\t\t\tusage(1);\n\t\t\t\t}\n\t\t\t}\n\t\t//if no option is present test if the second argument is a keyfile\n\t\t} else if ((keyFile = fopen(argv[2], \"r\")) == NULL) {\n\t\t\tperror(argv[2]);\n\t\t\tusage(1);\n\t\t} else if(keyFile != NULL && argc >= 4){\n\t\t\tprintf(\"Error: Too many arguments\\n\");\n\t\t\tusage(1);\n\t\t}\n\t\t\n\t}\n\n\tif (argv[1][strlen(argv[1])-1] == '/' && argv[1][strlen(argv[1])-2] == '/')\n\t{\n\t\tprintf(\"error: several trailing '/' in the path of your file\\n\");\n\t\tprintf(\"exiting\\n\");\n\t\texit(1);\n\t}\n\n\t//outside their scope because we need to free them at the end\n\tchar* tarName = NULL;\n\tchar* dirName = NULL;\n\tchar *copyOfArgv1 = (char*) calloc(1, sizeof(char) * strlen(argv[1]));\n\tstrcpy(copyOfArgv1, argv[1]);\n\tif (isADirectory(copyOfArgv1)){\n\t\tchar command[1008] = {'\\0'};\n\t\t//we don't need that anymore\n\t\tprintf(\"regrouping the folder in one file using tar, may be long...\");\n\t\tfflush(stdout);\n\t\t// get the name of the folder in a string and get the path\n\t\tif ((fileName = strrchr(argv[1], '/')) != NULL) {\n\t\t\t//if the '/' is the last character in the string, delete it and get the fileName again\n\t\t\tif (strlen(fileName) == 1){\n\t\t\t\tdirName = (char*) calloc(1, sizeof(char) * (strlen(argv[1]) + 5));\n\t\t\t\tstrcpy(dirName, argv[1]);\n\t\t\t\t*(dirName+(fileName-argv[1])) = '\\0';\n\t\t\t\tif ((fileName = strrchr(dirName, '/')) != NULL){\n\t\t\t\t\t++fileName;\n\t\t\t\t\tstrncpy(pathToMainFile, dirName, fileName - dirName);\n\t\t\t\t\tpathToMainFile[fileName - dirName] = '\\0';\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfileName = dirName;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t++fileName;\n\t\t\t\tstrncpy(pathToMainFile, argv[1], fileName - argv[1]);\n\t\t\t\tpathToMainFile[fileName - argv[1]] = '\\0';\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfileName = argv[1];\n\t\t}\n\t\t// get the full path of the tarFile in a dynamic variable tarName\n\t\ttarName = (char*) calloc(1, sizeof(char) * (strlen(fileName) + 5));\n\t\tsprintf (tarName, \"%s.tar\", fileName);\n\n\t\t//all of the following is to make a clean string for the tar commands (taking care of spaces)\n\t\tchar* cleanFileName       = processTarString((char*)fileName);\n\t\tchar* cleanPathToMainFile = processTarString(pathToMainFile);\n\t\tchar* cleanTarName        = processTarString(tarName);\n\t\t\n\t\t// use of cd to prevent tar to archive all the path architecture \n\t\t// (ex: /usr/myname/my/path/theFolderWeWant/)\n\t\tsprintf (command, \"cd %s && tar -cf %s %s &>/dev/null\", cleanPathToMainFile, cleanTarName, cleanFileName); //&>/dev/null\n\n\t\t//free the temporary strings\n\t\tfree(cleanPathToMainFile);\n\t\tfree(cleanTarName);\n\t\tfree(cleanFileName);\n\n\t\t// make the archive of the folder with tar\n\t\tint status;\n\t\tif((status = system(command)) != 0){ //if problems when taring\n\t\t\tprintf(\"\\nerror: unable to tar your file\\n\");\n\t\t\tprintf(\"exiting\\n\");\n\t\t\texit(1);\n\t\t}else{\n\t\t\tprintf(\"\\rregrouping the folder in one file using tar... Done          \\n\");\t\t\t\n\t\t}\n\n\t\tfileName = tarName;\n\n\t\t// trying to open the new archive\n\t\tchar pathPlusName[strlen(pathToMainFile)+strlen(fileName)];\n\t\tsprintf(pathPlusName, \"%s%s\", pathToMainFile, fileName);\n\t\tif ((mainFile = fopen(pathPlusName, \"r\")) == NULL) {\n\t\t\tperror(pathPlusName);\n\t\t\tprintf(\"exiting\\n\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse{\n\t\tif ((fileName = strrchr(argv[1], '/')) != NULL) {\n\t\t\t++fileName;\n\t\t\tstrncpy(pathToMainFile, argv[1], fileName - argv[1]);\t\t\n\t\t} else {\n\t\t\tfileName = argv[1];\n\t\t}\n\t\tif ((mainFile = fopen(argv[1], \"r\")) == NULL) {\n\t\t\tperror(argv[1]);\n\t\t\tprintf(\"exiting\\n\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\tfree(copyOfArgv1);\n\n\tfseek(mainFile, 0, SEEK_END);\n\tlong mainFileSize = ftell(mainFile);\n\trewind(mainFile);\n\tnumberOfBuffer = ceilRound((float)mainFileSize / (float)(BUFFER_SIZE));\n\tif (numberOfBuffer < 1)\n\t{\n\t\tnumberOfBuffer = 1;\n\t}\n\n\tchar procedureResponse[2]; \n\tisCrypting = -1;\n\tdo{\n\t\tprintf(\"Crypt(C) or Decrypt(d):\");\n\t\treadString(procedureResponse, 2);\n\t\tprintf(\"\\033[F\\033[J\");\n\t\tif (procedureResponse[0] == 'C' || procedureResponse[0] == 'c') {\n\t\t\tisCrypting = 1;\n\t\t}\n\t\telse if(procedureResponse[0] == 'D' || procedureResponse[0] == 'd'){\n\t\t\tisCrypting = 0;\n\t\t}\n\t}while(isCrypting == -1);\n\t\n\tprintf(\"Password:\");\n\treadString(passPhrase, 16383);\n\tprintf(\"\\033[F\\033[J\");\n\tgetSeed(passPhrase);\n\tscramble(keyFile);\n\n\tif (isCrypting){\n\t\tcode(mainFile);\n\t}\n\telse{\n\t\tdecode(mainFile);\n\t}\n\tprintf(\"Done                                                                  \\n\");\n\tfclose(mainFile);\n\n\t//we can free (last use in code/decode)\n\tif(tarName != NULL){\n\t\tfree(tarName);\n\t}\n\tif(dirName != NULL){\n\t\tfree(dirName);\n\t}\n\n\treturn 0;\n}",
        "func": "int main(int argc, char const *argv[])\n{\n\tFILE* mainFile;\n\tFILE* keyFile = NULL;\n\n\tif ((progName = strrchr(argv[0], '/')) != NULL) {\n\t\t++progName;\n\t} else {\n\t\tprogName = argv[0];\n\t}\n\tif (argc < 2) {\n\t\tusage(1);\n\t} else if(argc >= 5 ) { \n\t\tprintf(\"Error: Too many arguments\\n\");\n\t\tusage(1);\n\t} else if (strcmp(argv[1], \"-h\") == 0 || strcmp(argv[1], \"--help\") == 0) {\n\t\tusage(0);\n\t}\n\n\tif (argc >= 3)\n\t{\n\t\t//test if the option -s is present\n\t\tif (strcmp(argv[2], \"-s\") == 0 || strcmp(argv[2], \"--standard\") == 0){\n\t\t\tscrambling = 0;\n\t\t\t//if there is a keyfile, warns that it will not be used \n\t\t\tif(argc >= 4){\n\t\t\t\tif((keyFile = fopen(argv[3], \"r\")) == NULL){\n\t\t\t\t\tperror(argv[3]);\n\t\t\t\t\tusage(1);\n\t\t\t\t}\n\t\t\t\tprintf(\"Warning: with the -s|--standard option, the keyfile will not bu used\\n\");\n\t\t\t\tkeyFile = NULL;\n\t\t\t}\n\t\t//else the option -i\n\t\t} else if (strcmp(argv[2], \"-i\") == 0 || strcmp(argv[2], \"--inverted\") == 0){\n\t\t\tisCodingInverted = 1;\n\t\t\t//if i is present, checks if there is a keyfile in the third argument\n\t\t\tif(argc >= 4){\n\t\t\t\tif((keyFile = fopen(argv[3], \"r\")) == NULL){\n\t\t\t\t\tperror(argv[3]);\n\t\t\t\t\tusage(1);\n\t\t\t\t}\n\t\t\t}\n\t\t//if no option is present test if the second argument is a keyfile\n\t\t} else if ((keyFile = fopen(argv[2], \"r\")) == NULL) {\n\t\t\tperror(argv[2]);\n\t\t\tusage(1);\n\t\t} else if(keyFile != NULL && argc >= 4){\n\t\t\tprintf(\"Error: Too many arguments\\n\");\n\t\t\tusage(1);\n\t\t}\n\n\t\tif(keyFile != NULL){\n\t\t\tusingKeyFile = 1;\n\t\t}\n\t\t\n\t}\n\n\tif (argv[1][strlen(argv[1])-1] == '/' && argv[1][strlen(argv[1])-2] == '/')\n\t{\n\t\tprintf(\"error: several trailing '/' in the path of your file\\n\");\n\t\tprintf(\"exiting\\n\");\n\t\texit(1);\n\t}\n\n\t//outside their scope because we need to free them at the end\n\tchar* tarName = NULL;\n\tchar* dirName = NULL;\n\tchar *copyOfArgv1 = (char*) calloc(1, sizeof(char) * strlen(argv[1]));\n\tstrcpy(copyOfArgv1, argv[1]);\n\tif (isADirectory(copyOfArgv1)){\n\t\tchar command[1008] = {'\\0'};\n\t\t//we don't need that anymore\n\t\tprintf(\"regrouping the folder in one file using tar, may be long...\");\n\t\tfflush(stdout);\n\t\t// get the name of the folder in a string and get the path\n\t\tif ((fileName = strrchr(argv[1], '/')) != NULL) {\n\t\t\t//if the '/' is the last character in the string, delete it and get the fileName again\n\t\t\tif (strlen(fileName) == 1){\n\t\t\t\tdirName = (char*) calloc(1, sizeof(char) * (strlen(argv[1]) + 5));\n\t\t\t\tstrcpy(dirName, argv[1]);\n\t\t\t\t*(dirName+(fileName-argv[1])) = '\\0';\n\t\t\t\tif ((fileName = strrchr(dirName, '/')) != NULL){\n\t\t\t\t\t++fileName;\n\t\t\t\t\tstrncpy(pathToMainFile, dirName, fileName - dirName);\n\t\t\t\t\tpathToMainFile[fileName - dirName] = '\\0';\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfileName = dirName;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t++fileName;\n\t\t\t\tstrncpy(pathToMainFile, argv[1], fileName - argv[1]);\n\t\t\t\tpathToMainFile[fileName - argv[1]] = '\\0';\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfileName = argv[1];\n\t\t}\n\t\t// get the full path of the tarFile in a dynamic variable tarName\n\t\ttarName = (char*) calloc(1, sizeof(char) * (strlen(fileName) + 5));\n\t\tsprintf (tarName, \"%s.tar\", fileName);\n\n\t\t//all of the following is to make a clean string for the tar commands (taking care of spaces)\n\t\tchar* cleanFileName       = processTarString((char*)fileName);\n\t\tchar* cleanPathToMainFile = processTarString(pathToMainFile);\n\t\tchar* cleanTarName        = processTarString(tarName);\n\t\t\n\t\t// use of cd to prevent tar to archive all the path architecture \n\t\t// (ex: /usr/myname/my/path/theFolderWeWant/)\n\t\tsprintf (command, \"cd %s && tar -cf %s %s &>/dev/null\", cleanPathToMainFile, cleanTarName, cleanFileName); //&>/dev/null\n\n\t\t//free the temporary strings\n\t\tfree(cleanPathToMainFile);\n\t\tfree(cleanTarName);\n\t\tfree(cleanFileName);\n\n\t\t// make the archive of the folder with tar\n\t\tint status;\n\t\tif((status = system(command)) != 0){ //if problems when taring\n\t\t\tprintf(\"\\nerror: unable to tar your file\\n\");\n\t\t\tprintf(\"exiting\\n\");\n\t\t\texit(1);\n\t\t}else{\n\t\t\tprintf(\"\\rregrouping the folder in one file using tar... Done          \\n\");\t\t\t\n\t\t}\n\n\t\tfileName = tarName;\n\n\t\t// trying to open the new archive\n\t\tchar pathPlusName[strlen(pathToMainFile)+strlen(fileName)];\n\t\tsprintf(pathPlusName, \"%s%s\", pathToMainFile, fileName);\n\t\tif ((mainFile = fopen(pathPlusName, \"r\")) == NULL) {\n\t\t\tperror(pathPlusName);\n\t\t\tprintf(\"exiting\\n\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\telse{\n\t\tif ((fileName = strrchr(argv[1], '/')) != NULL) {\n\t\t\t++fileName;\n\t\t\tstrncpy(pathToMainFile, argv[1], fileName - argv[1]);\t\t\n\t\t} else {\n\t\t\tfileName = argv[1];\n\t\t}\n\t\tif ((mainFile = fopen(argv[1], \"r\")) == NULL) {\n\t\t\tperror(argv[1]);\n\t\t\tprintf(\"exiting\\n\");\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\tfree(copyOfArgv1);\n\n\tfseek(mainFile, 0, SEEK_END);\n\tlong mainFileSize = ftell(mainFile);\n\trewind(mainFile);\n\tnumberOfBuffer = ceilRound((float)mainFileSize / (float)(BUFFER_SIZE));\n\tif (numberOfBuffer < 1)\n\t{\n\t\tnumberOfBuffer = 1;\n\t}\n\n\tchar procedureResponse[2]; \n\tisCrypting = -1;\n\tdo{\n\t\tprintf(\"Crypt(C) or Decrypt(d):\");\n\t\treadString(procedureResponse, 2);\n\t\tprintf(\"\\033[F\\033[J\");\n\t\tif (procedureResponse[0] == 'C' || procedureResponse[0] == 'c') {\n\t\t\tisCrypting = 1;\n\t\t}\n\t\telse if(procedureResponse[0] == 'D' || procedureResponse[0] == 'd'){\n\t\t\tisCrypting = 0;\n\t\t}\n\t}while(isCrypting == -1);\n\t\n\tprintf(\"Password:\");\n\treadString(passPhrase, 16383);\n\tprintf(\"\\033[F\\033[J\");\n\tgetSeed(passPhrase);\n\tscramble(keyFile);\n\n\tif (isCrypting){\n\t\tcode(mainFile);\n\t}\n\telse{\n\t\tdecode(mainFile);\n\t}\n\tprintf(\"Done                                                                  \\n\");\n\tfclose(mainFile);\n\n\t//we can free (last use in code/decode)\n\tif(tarName != NULL){\n\t\tfree(tarName);\n\t}\n\tif(dirName != NULL){\n\t\tfree(dirName);\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -48,6 +48,10 @@\n \t\t} else if(keyFile != NULL && argc >= 4){\n \t\t\tprintf(\"Error: Too many arguments\\n\");\n \t\t\tusage(1);\n+\t\t}\n+\n+\t\tif(keyFile != NULL){\n+\t\t\tusingKeyFile = 1;\n \t\t}\n \t\t\n \t}",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t}",
                "",
                "\t\tif(keyFile != NULL){",
                "\t\t\tusingKeyFile = 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-15006",
        "func_name": "pfmonville/enigmaX/codingXOR",
        "description": "A vulnerability, which was classified as problematic, has been found in enigmaX up to 2.2. This issue affects the function getSeed of the file main.c of the component Scrambling Table Handler. The manipulation leads to predictable seed in pseudo-random number generator (prng). The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. Upgrading to version 2.3 is able to address this issue. The identifier of the patch is 922bf90ca14a681629ba0b807a997a81d70225b5. It is recommended to upgrade the affected component. The identifier VDB-217181 was assigned to this vulnerability.",
        "git_url": "https://github.com/pfmonville/enigmaX/commit/922bf90ca14a681629ba0b807a997a81d70225b5",
        "commit_title": "2.3",
        "commit_text": " + now the order of the scrambling tables when using a keyfile is defined by the keyfile and not only with the password. Even if someone has the password, without the keyfile it is impossible to do any frequency analysis attack ~ fix the scrambling when a keyfile is used (previously the 16 tables were the same) ~ some tweaks to descriptions",
        "func_before": "void codingXOR(char* extractedString, char* keyString, char* xoredString, int bufferLength)\n{\n\tint i;\n\n\tif(isCodingInverted){\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = scrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n\t\t}\n\t}else{\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = scrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n\t\t}\n\t}\n}",
        "func": "void codingXOR(char* extractedString, char* keyString, char* xoredString, int bufferLength)\n{\n\tint i;\n\tchar* tablenumber;\n\n\tif(usingKeyFile){\n\t\ttablenumber = scramblingTablesOrder;\n\t}else{\n\t\ttablenumber = keyString;\n\t}\n\n\tif(isCodingInverted){\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = scrambleAsciiTables[tablenumber[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n\t\t}\n\t}else{\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = scrambleAsciiTables[tablenumber[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n\t\t}\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,16 +1,23 @@\n void codingXOR(char* extractedString, char* keyString, char* xoredString, int bufferLength)\n {\n \tint i;\n+\tchar* tablenumber;\n+\n+\tif(usingKeyFile){\n+\t\ttablenumber = scramblingTablesOrder;\n+\t}else{\n+\t\ttablenumber = keyString;\n+\t}\n \n \tif(isCodingInverted){\n \t\tfor (i = 0; i < bufferLength; ++i)\n \t\t{\n-\t\t\txoredString[i] = scrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n+\t\t\txoredString[i] = scrambleAsciiTables[tablenumber[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n \t\t}\n \t}else{\n \t\tfor (i = 0; i < bufferLength; ++i)\n \t\t{\n-\t\t\txoredString[i] = scrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n+\t\t\txoredString[i] = scrambleAsciiTables[tablenumber[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n \t\t}\n \t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\txoredString[i] = scrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];",
                "\t\t\txoredString[i] = scrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];"
            ],
            "added_lines": [
                "\tchar* tablenumber;",
                "",
                "\tif(usingKeyFile){",
                "\t\ttablenumber = scramblingTablesOrder;",
                "\t}else{",
                "\t\ttablenumber = keyString;",
                "\t}",
                "\t\t\txoredString[i] = scrambleAsciiTables[tablenumber[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];",
                "\t\t\txoredString[i] = scrambleAsciiTables[tablenumber[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-15006",
        "func_name": "pfmonville/enigmaX/decodingXOR",
        "description": "A vulnerability, which was classified as problematic, has been found in enigmaX up to 2.2. This issue affects the function getSeed of the file main.c of the component Scrambling Table Handler. The manipulation leads to predictable seed in pseudo-random number generator (prng). The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. Upgrading to version 2.3 is able to address this issue. The identifier of the patch is 922bf90ca14a681629ba0b807a997a81d70225b5. It is recommended to upgrade the affected component. The identifier VDB-217181 was assigned to this vulnerability.",
        "git_url": "https://github.com/pfmonville/enigmaX/commit/922bf90ca14a681629ba0b807a997a81d70225b5",
        "commit_title": "2.3",
        "commit_text": " + now the order of the scrambling tables when using a keyfile is defined by the keyfile and not only with the password. Even if someone has the password, without the keyfile it is impossible to do any frequency analysis attack ~ fix the scrambling when a keyfile is used (previously the 16 tables were the same) ~ some tweaks to descriptions",
        "func_before": "void decodingXOR(char* extractedString, char* keyString, char* xoredString, int bufferLength)\n{\n\tint i;\n\n\tif(isCodingInverted){\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n\t\t}\n\t}else{\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n\t\t}\n\t}\n}",
        "func": "void decodingXOR(char* extractedString, char* keyString, char* xoredString, int bufferLength)\n{\n\tint i;\n\tchar* tablenumber;\n\n\tif(usingKeyFile){\n\t\ttablenumber = scramblingTablesOrder;\n\t}else{\n\t\ttablenumber = keyString;\n\t}\n\n\tif(isCodingInverted){\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[tablenumber[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n\t\t}\n\t}else{\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[tablenumber[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n\t\t}\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,16 +1,23 @@\n void decodingXOR(char* extractedString, char* keyString, char* xoredString, int bufferLength)\n {\n \tint i;\n+\tchar* tablenumber;\n+\n+\tif(usingKeyFile){\n+\t\ttablenumber = scramblingTablesOrder;\n+\t}else{\n+\t\ttablenumber = keyString;\n+\t}\n \n \tif(isCodingInverted){\n \t\tfor (i = 0; i < bufferLength; ++i)\n \t\t{\n-\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n+\t\t\txoredString[i] = unscrambleAsciiTables[tablenumber[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n \t\t}\n \t}else{\n \t\tfor (i = 0; i < bufferLength; ++i)\n \t\t{\n-\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n+\t\t\txoredString[i] = unscrambleAsciiTables[tablenumber[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n \t\t}\n \t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];",
                "\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];"
            ],
            "added_lines": [
                "\tchar* tablenumber;",
                "",
                "\tif(usingKeyFile){",
                "\t\ttablenumber = scramblingTablesOrder;",
                "\t}else{",
                "\t\ttablenumber = keyString;",
                "\t}",
                "\t\t\txoredString[i] = unscrambleAsciiTables[tablenumber[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];",
                "\t\t\txoredString[i] = unscrambleAsciiTables[tablenumber[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-15006",
        "func_name": "pfmonville/enigmaX/usage",
        "description": "A vulnerability, which was classified as problematic, has been found in enigmaX up to 2.2. This issue affects the function getSeed of the file main.c of the component Scrambling Table Handler. The manipulation leads to predictable seed in pseudo-random number generator (prng). The attack may be initiated remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. Upgrading to version 2.3 is able to address this issue. The identifier of the patch is 922bf90ca14a681629ba0b807a997a81d70225b5. It is recommended to upgrade the affected component. The identifier VDB-217181 was assigned to this vulnerability.",
        "git_url": "https://github.com/pfmonville/enigmaX/commit/922bf90ca14a681629ba0b807a997a81d70225b5",
        "commit_title": "2.3",
        "commit_text": " + now the order of the scrambling tables when using a keyfile is defined by the keyfile and not only with the password. Even if someone has the password, without the keyfile it is impossible to do any frequency analysis attack ~ fix the scrambling when a keyfile is used (previously the 16 tables were the same) ~ some tweaks to descriptions",
        "func_before": "static void usage(int status)\n{\n\tFILE *dest = (status == 0) ? stdout : stderr;\n\n\tif(status == 0){\n\t\tfprintf(dest,\n\t\t\t\"%s(1)\\t\\t\\tcopyright <Pierre-François Monville>\\t\\t\\t%s(1)\\n\\nNAME\\n\\t%s -- crypt or decrypt any data\\n\\nSYNOPSIS\\n\\t%s [-h | --help] FILE [-s | --standard | KEYFILE]\\n\\nDESCRIPTION\\n\\t(FR) permet de chiffrer et de déchiffrer toutes les données entrées en paramètre le mot de passe demandé au début est hashé puis sert de graine pour le PRNG le PRNG permet de fournir une clé unique égale à la longueur du fichier à coder. La clé unique subit un xor avec le mot de passe (le mot de passe est répété autant de fois que nécéssaire). Le fichier subit un xor avec cette clé Puis un brouilleur est utilisé, il mélange la table des caractères (ascii) en utilisant le PRNG ou en utilisant le keyFile fourni.\\n\\t(EN) Can crypt and decrypt any data given in argument. The password asked is hashed to be used as a seed for the PRNG. The PRNG gives a unique key which has the same length as the source file. The key is xored with the password (the password is repeated as long as necessary). The file is then xored with this new key, then a scrambler is used. It scrambles the ascii table using the PRNG or the keyFile given\\n\\nOPTIONS\\n\\tthe options are as follows:\\n\\n\\t-h | --help\\tfurther help.\\n\\n\\t-s | --standard\\tput the scrambler on off.\\n\\n\\t-i | --inverted\\tinverts the coding/decoding process, first it xors then it scrambles.\\n\\nEXIT STATUS\\n\\tthe %s program exits 0 on success, and anything else if an error occurs.\\n\\nEXAMPLES\\n\\tthe command:\\t%s file1\\n\\n\\tlets you choose between crypting or decrypting then it will prompt for a password that crypt/decrypt file1 as xfile1 in the same folder, file1 is not modified.\\n\\n\\tthe command:\\t%s file2 keyfile1\\n\\n\\tlets you choose between crypting or decrypting, will prompt for the password that crypt/decrypt file2, uses keyfile1 to generate the scrambler then crypt/decrypt file2 as file2x in the same folder, file2 is not modified.\\n\\n\\tthe command:\\t%s file3 -s\\n\\n\\tlets you choose between crypting or decrypting, will prompt for a password that crypt/decrypt the file without using the scrambler, resulting in using the unique key only.\\n\", progName, progName, progName, progName, progName, progName, progName, progName);\n\t} else{\n\t\tfprintf(dest,\n\t\t\t\"Usage : %s [-h | --help] FILE [-s | --standard | -i | --inverted] [KEYFILE]\\nOptions :\\n  -h --help :\\t\\tfurther help\\n  -s --standard :\\tput the scrambler off\\n  -i --inverted :\\tinverts the coding/decoding process\\n  KEYFILE :\\t\\tpath to a keyfile that generates the scrambler instead of the password\\n\", progName);\n\t}\n\texit(status);\n}",
        "func": "static void usage(int status)\n{\n\tFILE *dest = (status == 0) ? stdout : stderr;\n\n\tif(status == 0){\n\t\tfprintf(dest,\n\t\t\t\"%s(1)\\t\\t\\tcopyright <Pierre-François Monville>\\t\\t\\t%s(1)\\n\\nNAME\\n\\t%s -- crypt or decrypt any data\\n\\nSYNOPSIS\\n\\t%s [-h | --help] FILE [-s | --standard | KEYFILE]\\n\\nDESCRIPTION\\n\\t(FR) permet de chiffrer et de déchiffrer toutes les données entrées en paramètre le mot de passe demandé au début est hashé puis sert de graine pour le PRNG le PRNG permet de fournir une clé unique égale à la longueur du fichier à coder. La clé unique subit un xor avec le mot de passe (le mot de passe est répété autant de fois que nécéssaire). Le fichier subit un xor avec cette clé Puis un brouilleur est utilisé, il mélange la table des caractères (ascii) en utilisant le PRNG ou en utilisant le keyFile fourni.\\n\\t(EN) Can crypt and decrypt any data given in argument. The password asked is hashed to be used as a seed for the PRNG. The PRNG gives a unique key which has the same length as the source file. The key is xored with the password (the password is repeated as long as necessary). The file is then xored with this new key, then a scrambler is used. It scrambles the ascii table using the PRNG or the keyFile given\\n\\nOPTIONS\\n\\tthe options are as follows:\\n\\n\\t-h | --help\\tfurther help.\\n\\n\\t-s | --standard\\tput the scrambler on off.\\n\\n\\t-i | --inverted\\tinverts the coding/decoding process, first it xors then it scrambles.\\n\\n\\tKEYFILE    \\tthe path to a file which will be used to scramble the substitution's tables and choose in which order they will be used instead of the PRNG only (starting at 2.5 ko for the keyfile is great, however not interesting to be too heavy) \\n\\nEXIT STATUS\\n\\tthe %s program exits 0 on success, and anything else if an error occurs.\\n\\nEXAMPLES\\n\\tthe command:\\t%s file1\\n\\n\\tlets you choose between crypting or decrypting then it will prompt for a password that crypt/decrypt file1 as xfile1 in the same folder, file1 is not modified.\\n\\n\\tthe command:\\t%s file2 keyfile1\\n\\n\\tlets you choose between crypting or decrypting, will prompt for the password that crypt/decrypt file2, uses keyfile1 to generate the scrambler then crypt/decrypt file2 as file2x in the same folder, file2 is not modified.\\n\\n\\tthe command:\\t%s file3 -s\\n\\n\\tlets you choose between crypting or decrypting, will prompt for a password that crypt/decrypt the file without using the scrambler, resulting in using the unique key only.\\n\", progName, progName, progName, progName, progName, progName, progName, progName);\n\t} else{\n\t\tfprintf(dest,\n\t\t\t\"Version : 2.3\\nUsage : %s [-h | --help] FILE [-s | --standard | -i | --inverted] [KEYFILE]\\nOptions :\\n  -h --help :\\t\\tfurther help\\n  -s --standard :\\tput the scrambler off\\n  -i --inverted :\\tinverts the coding/decoding process\\n  KEYFILE :\\t\\tpath to a keyfile that scrambles the substitution's tables and choose they order instead of the PRNG only\\n\", progName);\n\t}\n\texit(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,10 +4,10 @@\n \n \tif(status == 0){\n \t\tfprintf(dest,\n-\t\t\t\"%s(1)\\t\\t\\tcopyright <Pierre-François Monville>\\t\\t\\t%s(1)\\n\\nNAME\\n\\t%s -- crypt or decrypt any data\\n\\nSYNOPSIS\\n\\t%s [-h | --help] FILE [-s | --standard | KEYFILE]\\n\\nDESCRIPTION\\n\\t(FR) permet de chiffrer et de déchiffrer toutes les données entrées en paramètre le mot de passe demandé au début est hashé puis sert de graine pour le PRNG le PRNG permet de fournir une clé unique égale à la longueur du fichier à coder. La clé unique subit un xor avec le mot de passe (le mot de passe est répété autant de fois que nécéssaire). Le fichier subit un xor avec cette clé Puis un brouilleur est utilisé, il mélange la table des caractères (ascii) en utilisant le PRNG ou en utilisant le keyFile fourni.\\n\\t(EN) Can crypt and decrypt any data given in argument. The password asked is hashed to be used as a seed for the PRNG. The PRNG gives a unique key which has the same length as the source file. The key is xored with the password (the password is repeated as long as necessary). The file is then xored with this new key, then a scrambler is used. It scrambles the ascii table using the PRNG or the keyFile given\\n\\nOPTIONS\\n\\tthe options are as follows:\\n\\n\\t-h | --help\\tfurther help.\\n\\n\\t-s | --standard\\tput the scrambler on off.\\n\\n\\t-i | --inverted\\tinverts the coding/decoding process, first it xors then it scrambles.\\n\\nEXIT STATUS\\n\\tthe %s program exits 0 on success, and anything else if an error occurs.\\n\\nEXAMPLES\\n\\tthe command:\\t%s file1\\n\\n\\tlets you choose between crypting or decrypting then it will prompt for a password that crypt/decrypt file1 as xfile1 in the same folder, file1 is not modified.\\n\\n\\tthe command:\\t%s file2 keyfile1\\n\\n\\tlets you choose between crypting or decrypting, will prompt for the password that crypt/decrypt file2, uses keyfile1 to generate the scrambler then crypt/decrypt file2 as file2x in the same folder, file2 is not modified.\\n\\n\\tthe command:\\t%s file3 -s\\n\\n\\tlets you choose between crypting or decrypting, will prompt for a password that crypt/decrypt the file without using the scrambler, resulting in using the unique key only.\\n\", progName, progName, progName, progName, progName, progName, progName, progName);\n+\t\t\t\"%s(1)\\t\\t\\tcopyright <Pierre-François Monville>\\t\\t\\t%s(1)\\n\\nNAME\\n\\t%s -- crypt or decrypt any data\\n\\nSYNOPSIS\\n\\t%s [-h | --help] FILE [-s | --standard | KEYFILE]\\n\\nDESCRIPTION\\n\\t(FR) permet de chiffrer et de déchiffrer toutes les données entrées en paramètre le mot de passe demandé au début est hashé puis sert de graine pour le PRNG le PRNG permet de fournir une clé unique égale à la longueur du fichier à coder. La clé unique subit un xor avec le mot de passe (le mot de passe est répété autant de fois que nécéssaire). Le fichier subit un xor avec cette clé Puis un brouilleur est utilisé, il mélange la table des caractères (ascii) en utilisant le PRNG ou en utilisant le keyFile fourni.\\n\\t(EN) Can crypt and decrypt any data given in argument. The password asked is hashed to be used as a seed for the PRNG. The PRNG gives a unique key which has the same length as the source file. The key is xored with the password (the password is repeated as long as necessary). The file is then xored with this new key, then a scrambler is used. It scrambles the ascii table using the PRNG or the keyFile given\\n\\nOPTIONS\\n\\tthe options are as follows:\\n\\n\\t-h | --help\\tfurther help.\\n\\n\\t-s | --standard\\tput the scrambler on off.\\n\\n\\t-i | --inverted\\tinverts the coding/decoding process, first it xors then it scrambles.\\n\\n\\tKEYFILE    \\tthe path to a file which will be used to scramble the substitution's tables and choose in which order they will be used instead of the PRNG only (starting at 2.5 ko for the keyfile is great, however not interesting to be too heavy) \\n\\nEXIT STATUS\\n\\tthe %s program exits 0 on success, and anything else if an error occurs.\\n\\nEXAMPLES\\n\\tthe command:\\t%s file1\\n\\n\\tlets you choose between crypting or decrypting then it will prompt for a password that crypt/decrypt file1 as xfile1 in the same folder, file1 is not modified.\\n\\n\\tthe command:\\t%s file2 keyfile1\\n\\n\\tlets you choose between crypting or decrypting, will prompt for the password that crypt/decrypt file2, uses keyfile1 to generate the scrambler then crypt/decrypt file2 as file2x in the same folder, file2 is not modified.\\n\\n\\tthe command:\\t%s file3 -s\\n\\n\\tlets you choose between crypting or decrypting, will prompt for a password that crypt/decrypt the file without using the scrambler, resulting in using the unique key only.\\n\", progName, progName, progName, progName, progName, progName, progName, progName);\n \t} else{\n \t\tfprintf(dest,\n-\t\t\t\"Usage : %s [-h | --help] FILE [-s | --standard | -i | --inverted] [KEYFILE]\\nOptions :\\n  -h --help :\\t\\tfurther help\\n  -s --standard :\\tput the scrambler off\\n  -i --inverted :\\tinverts the coding/decoding process\\n  KEYFILE :\\t\\tpath to a keyfile that generates the scrambler instead of the password\\n\", progName);\n+\t\t\t\"Version : 2.3\\nUsage : %s [-h | --help] FILE [-s | --standard | -i | --inverted] [KEYFILE]\\nOptions :\\n  -h --help :\\t\\tfurther help\\n  -s --standard :\\tput the scrambler off\\n  -i --inverted :\\tinverts the coding/decoding process\\n  KEYFILE :\\t\\tpath to a keyfile that scrambles the substitution's tables and choose they order instead of the PRNG only\\n\", progName);\n \t}\n \texit(status);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\"%s(1)\\t\\t\\tcopyright <Pierre-François Monville>\\t\\t\\t%s(1)\\n\\nNAME\\n\\t%s -- crypt or decrypt any data\\n\\nSYNOPSIS\\n\\t%s [-h | --help] FILE [-s | --standard | KEYFILE]\\n\\nDESCRIPTION\\n\\t(FR) permet de chiffrer et de déchiffrer toutes les données entrées en paramètre le mot de passe demandé au début est hashé puis sert de graine pour le PRNG le PRNG permet de fournir une clé unique égale à la longueur du fichier à coder. La clé unique subit un xor avec le mot de passe (le mot de passe est répété autant de fois que nécéssaire). Le fichier subit un xor avec cette clé Puis un brouilleur est utilisé, il mélange la table des caractères (ascii) en utilisant le PRNG ou en utilisant le keyFile fourni.\\n\\t(EN) Can crypt and decrypt any data given in argument. The password asked is hashed to be used as a seed for the PRNG. The PRNG gives a unique key which has the same length as the source file. The key is xored with the password (the password is repeated as long as necessary). The file is then xored with this new key, then a scrambler is used. It scrambles the ascii table using the PRNG or the keyFile given\\n\\nOPTIONS\\n\\tthe options are as follows:\\n\\n\\t-h | --help\\tfurther help.\\n\\n\\t-s | --standard\\tput the scrambler on off.\\n\\n\\t-i | --inverted\\tinverts the coding/decoding process, first it xors then it scrambles.\\n\\nEXIT STATUS\\n\\tthe %s program exits 0 on success, and anything else if an error occurs.\\n\\nEXAMPLES\\n\\tthe command:\\t%s file1\\n\\n\\tlets you choose between crypting or decrypting then it will prompt for a password that crypt/decrypt file1 as xfile1 in the same folder, file1 is not modified.\\n\\n\\tthe command:\\t%s file2 keyfile1\\n\\n\\tlets you choose between crypting or decrypting, will prompt for the password that crypt/decrypt file2, uses keyfile1 to generate the scrambler then crypt/decrypt file2 as file2x in the same folder, file2 is not modified.\\n\\n\\tthe command:\\t%s file3 -s\\n\\n\\tlets you choose between crypting or decrypting, will prompt for a password that crypt/decrypt the file without using the scrambler, resulting in using the unique key only.\\n\", progName, progName, progName, progName, progName, progName, progName, progName);",
                "\t\t\t\"Usage : %s [-h | --help] FILE [-s | --standard | -i | --inverted] [KEYFILE]\\nOptions :\\n  -h --help :\\t\\tfurther help\\n  -s --standard :\\tput the scrambler off\\n  -i --inverted :\\tinverts the coding/decoding process\\n  KEYFILE :\\t\\tpath to a keyfile that generates the scrambler instead of the password\\n\", progName);"
            ],
            "added_lines": [
                "\t\t\t\"%s(1)\\t\\t\\tcopyright <Pierre-François Monville>\\t\\t\\t%s(1)\\n\\nNAME\\n\\t%s -- crypt or decrypt any data\\n\\nSYNOPSIS\\n\\t%s [-h | --help] FILE [-s | --standard | KEYFILE]\\n\\nDESCRIPTION\\n\\t(FR) permet de chiffrer et de déchiffrer toutes les données entrées en paramètre le mot de passe demandé au début est hashé puis sert de graine pour le PRNG le PRNG permet de fournir une clé unique égale à la longueur du fichier à coder. La clé unique subit un xor avec le mot de passe (le mot de passe est répété autant de fois que nécéssaire). Le fichier subit un xor avec cette clé Puis un brouilleur est utilisé, il mélange la table des caractères (ascii) en utilisant le PRNG ou en utilisant le keyFile fourni.\\n\\t(EN) Can crypt and decrypt any data given in argument. The password asked is hashed to be used as a seed for the PRNG. The PRNG gives a unique key which has the same length as the source file. The key is xored with the password (the password is repeated as long as necessary). The file is then xored with this new key, then a scrambler is used. It scrambles the ascii table using the PRNG or the keyFile given\\n\\nOPTIONS\\n\\tthe options are as follows:\\n\\n\\t-h | --help\\tfurther help.\\n\\n\\t-s | --standard\\tput the scrambler on off.\\n\\n\\t-i | --inverted\\tinverts the coding/decoding process, first it xors then it scrambles.\\n\\n\\tKEYFILE    \\tthe path to a file which will be used to scramble the substitution's tables and choose in which order they will be used instead of the PRNG only (starting at 2.5 ko for the keyfile is great, however not interesting to be too heavy) \\n\\nEXIT STATUS\\n\\tthe %s program exits 0 on success, and anything else if an error occurs.\\n\\nEXAMPLES\\n\\tthe command:\\t%s file1\\n\\n\\tlets you choose between crypting or decrypting then it will prompt for a password that crypt/decrypt file1 as xfile1 in the same folder, file1 is not modified.\\n\\n\\tthe command:\\t%s file2 keyfile1\\n\\n\\tlets you choose between crypting or decrypting, will prompt for the password that crypt/decrypt file2, uses keyfile1 to generate the scrambler then crypt/decrypt file2 as file2x in the same folder, file2 is not modified.\\n\\n\\tthe command:\\t%s file3 -s\\n\\n\\tlets you choose between crypting or decrypting, will prompt for a password that crypt/decrypt the file without using the scrambler, resulting in using the unique key only.\\n\", progName, progName, progName, progName, progName, progName, progName, progName);",
                "\t\t\t\"Version : 2.3\\nUsage : %s [-h | --help] FILE [-s | --standard | -i | --inverted] [KEYFILE]\\nOptions :\\n  -h --help :\\t\\tfurther help\\n  -s --standard :\\tput the scrambler off\\n  -i --inverted :\\tinverts the coding/decoding process\\n  KEYFILE :\\t\\tpath to a keyfile that scrambles the substitution's tables and choose they order instead of the PRNG only\\n\", progName);"
            ]
        }
    }
]