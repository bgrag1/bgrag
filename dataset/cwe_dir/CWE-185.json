[
    {
        "cve_id": "CVE-2019-12798",
        "func_name": "ArtifexSoftware/mujs/regcompx",
        "description": "An issue was discovered in Artifex MuJS 1.0.5. regcompx in regexp.c does not restrict regular expression program size, leading to an overflow of the parsed syntax list size.",
        "git_url": "https://github.com/ArtifexSoftware/mujs/commit/7f50591861525f76e3ec7a63392656ff8c030af9",
        "commit_title": "Bug 700429: Limit size of input regular expression program.",
        "commit_text": " The size of the parsed syntax list could overflow. Allowing it to be bigger than the compiled program makes no sense, so use the same size limit when parsing as when compiling.",
        "func_before": "Reprog *regcompx(void *(*alloc)(void *ctx, void *p, int n), void *ctx,\n\tconst char *pattern, int cflags, const char **errorp)\n{\n\tstruct cstate g;\n\tRenode *node;\n\tReinst *split, *jump;\n\tint i, n;\n\n\tg.pstart = NULL;\n\tg.prog = NULL;\n\n\tif (setjmp(g.kaboom)) {\n\t\tif (errorp) *errorp = g.error;\n\t\talloc(ctx, g.pstart, 0);\n\t\talloc(ctx, g.prog, 0);\n\t\treturn NULL;\n\t}\n\n\tg.prog = alloc(ctx, NULL, sizeof (Reprog));\n\tif (!g.prog)\n\t\tdie(&g, \"cannot allocate regular expression\");\n\tn = strlen(pattern) * 2;\n\tif (n > 0) {\n\t\tg.pstart = g.pend = alloc(ctx, NULL, sizeof (Renode) * n);\n\t\tif (!g.pstart)\n\t\t\tdie(&g, \"cannot allocate regular expression parse list\");\n\t}\n\n\tg.source = pattern;\n\tg.ncclass = 0;\n\tg.nsub = 1;\n\tfor (i = 0; i < MAXSUB; ++i)\n\t\tg.sub[i] = 0;\n\n\tg.prog->flags = cflags;\n\n\tnext(&g);\n\tnode = parsealt(&g);\n\tif (g.lookahead == ')')\n\t\tdie(&g, \"unmatched ')'\");\n\tif (g.lookahead != 0)\n\t\tdie(&g, \"syntax error\");\n\n#ifdef TEST\n\tdumpnode(node);\n\tputchar('\\n');\n#endif\n\n\tn = 6 + count(&g, node);\n\tif (n < 0 || n > MAXPROG)\n\t\tdie(&g, \"program too large\");\n\n\tg.prog->nsub = g.nsub;\n\tg.prog->start = g.prog->end = alloc(ctx, NULL, n * sizeof (Reinst));\n\tif (!g.prog->start)\n\t\tdie(&g, \"cannot allocate regular expression instruction list\");\n\n\tsplit = emit(g.prog, I_SPLIT);\n\tsplit->x = split + 3;\n\tsplit->y = split + 1;\n\temit(g.prog, I_ANYNL);\n\tjump = emit(g.prog, I_JUMP);\n\tjump->x = split;\n\temit(g.prog, I_LPAR);\n\tcompile(g.prog, node);\n\temit(g.prog, I_RPAR);\n\temit(g.prog, I_END);\n\n#ifdef TEST\n\tdumpprog(g.prog);\n#endif\n\n\talloc(ctx, g.pstart, 0);\n\n\tif (errorp) *errorp = NULL;\n\treturn g.prog;\n}",
        "func": "Reprog *regcompx(void *(*alloc)(void *ctx, void *p, int n), void *ctx,\n\tconst char *pattern, int cflags, const char **errorp)\n{\n\tstruct cstate g;\n\tRenode *node;\n\tReinst *split, *jump;\n\tint i, n;\n\n\tg.pstart = NULL;\n\tg.prog = NULL;\n\n\tif (setjmp(g.kaboom)) {\n\t\tif (errorp) *errorp = g.error;\n\t\talloc(ctx, g.pstart, 0);\n\t\talloc(ctx, g.prog, 0);\n\t\treturn NULL;\n\t}\n\n\tg.prog = alloc(ctx, NULL, sizeof (Reprog));\n\tif (!g.prog)\n\t\tdie(&g, \"cannot allocate regular expression\");\n\tn = strlen(pattern) * 2;\n\tif (n > MAXPROG)\n\t\tdie(&g, \"program too large\");\n\tif (n > 0) {\n\t\tg.pstart = g.pend = alloc(ctx, NULL, sizeof (Renode) * n);\n\t\tif (!g.pstart)\n\t\t\tdie(&g, \"cannot allocate regular expression parse list\");\n\t}\n\n\tg.source = pattern;\n\tg.ncclass = 0;\n\tg.nsub = 1;\n\tfor (i = 0; i < MAXSUB; ++i)\n\t\tg.sub[i] = 0;\n\n\tg.prog->flags = cflags;\n\n\tnext(&g);\n\tnode = parsealt(&g);\n\tif (g.lookahead == ')')\n\t\tdie(&g, \"unmatched ')'\");\n\tif (g.lookahead != 0)\n\t\tdie(&g, \"syntax error\");\n\n#ifdef TEST\n\tdumpnode(node);\n\tputchar('\\n');\n#endif\n\n\tn = 6 + count(&g, node);\n\tif (n < 0 || n > MAXPROG)\n\t\tdie(&g, \"program too large\");\n\n\tg.prog->nsub = g.nsub;\n\tg.prog->start = g.prog->end = alloc(ctx, NULL, n * sizeof (Reinst));\n\tif (!g.prog->start)\n\t\tdie(&g, \"cannot allocate regular expression instruction list\");\n\n\tsplit = emit(g.prog, I_SPLIT);\n\tsplit->x = split + 3;\n\tsplit->y = split + 1;\n\temit(g.prog, I_ANYNL);\n\tjump = emit(g.prog, I_JUMP);\n\tjump->x = split;\n\temit(g.prog, I_LPAR);\n\tcompile(g.prog, node);\n\temit(g.prog, I_RPAR);\n\temit(g.prog, I_END);\n\n#ifdef TEST\n\tdumpprog(g.prog);\n#endif\n\n\talloc(ctx, g.pstart, 0);\n\n\tif (errorp) *errorp = NULL;\n\treturn g.prog;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,6 +20,8 @@\n \tif (!g.prog)\n \t\tdie(&g, \"cannot allocate regular expression\");\n \tn = strlen(pattern) * 2;\n+\tif (n > MAXPROG)\n+\t\tdie(&g, \"program too large\");\n \tif (n > 0) {\n \t\tg.pstart = g.pend = alloc(ctx, NULL, sizeof (Renode) * n);\n \t\tif (!g.pstart)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (n > MAXPROG)",
                "\t\tdie(&g, \"program too large\");"
            ]
        }
    }
]