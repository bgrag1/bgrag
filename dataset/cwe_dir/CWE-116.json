[
    {
        "cve_id": "CVE-2018-18836",
        "func_name": "netdata/url_decode_r",
        "description": "An issue was discovered in Netdata 1.10.0. JSON injection exists via the api/v1/data tqx parameter because of web_client_api_request_v1_data in web/api/web_api_v1.c.",
        "git_url": "https://github.com/netdata/netdata/commit/92327c9ec211bd1616315abcb255861b130b97ca",
        "commit_title": "fixed vulnerabilities identified by red4sec.com (#4521)",
        "commit_text": "",
        "func_before": "char *url_decode_r(char *to, char *url, size_t size) {\n    char *s = url,           // source\n         *d = to,            // destination\n         *e = &to[size - 1]; // destination end\n\n    while(*s && d < e) {\n        if(unlikely(*s == '%')) {\n            if(likely(s[1] && s[2])) {\n                *d++ = from_hex(s[1]) << 4 | from_hex(s[2]);\n                s += 2;\n            }\n        }\n        else if(unlikely(*s == '+'))\n            *d++ = ' ';\n\n        else\n            *d++ = *s;\n\n        s++;\n    }\n\n    *d = '\\0';\n\n    return to;\n}",
        "func": "char *url_decode_r(char *to, char *url, size_t size) {\n    char *s = url,           // source\n         *d = to,            // destination\n         *e = &to[size - 1]; // destination end\n\n    while(*s && d < e) {\n        if(unlikely(*s == '%')) {\n            if(likely(s[1] && s[2])) {\n                char t = from_hex(s[1]) << 4 | from_hex(s[2]);\n                // avoid HTTP header injection\n                *d++ = (char)((isprint(t))? t : ' ');\n                s += 2;\n            }\n        }\n        else if(unlikely(*s == '+'))\n            *d++ = ' ';\n\n        else\n            *d++ = *s;\n\n        s++;\n    }\n\n    *d = '\\0';\n\n    return to;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,9 @@\n     while(*s && d < e) {\n         if(unlikely(*s == '%')) {\n             if(likely(s[1] && s[2])) {\n-                *d++ = from_hex(s[1]) << 4 | from_hex(s[2]);\n+                char t = from_hex(s[1]) << 4 | from_hex(s[2]);\n+                // avoid HTTP header injection\n+                *d++ = (char)((isprint(t))? t : ' ');\n                 s += 2;\n             }\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "                *d++ = from_hex(s[1]) << 4 | from_hex(s[2]);"
            ],
            "added_lines": [
                "                char t = from_hex(s[1]) << 4 | from_hex(s[2]);",
                "                // avoid HTTP header injection",
                "                *d++ = (char)((isprint(t))? t : ' ');"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-18836",
        "func_name": "netdata/web_client_api_request_v1_data",
        "description": "An issue was discovered in Netdata 1.10.0. JSON injection exists via the api/v1/data tqx parameter because of web_client_api_request_v1_data in web/api/web_api_v1.c.",
        "git_url": "https://github.com/netdata/netdata/commit/92327c9ec211bd1616315abcb255861b130b97ca",
        "commit_title": "fixed vulnerabilities identified by red4sec.com (#4521)",
        "commit_text": "",
        "func_before": "inline int web_client_api_request_v1_data(RRDHOST *host, struct web_client *w, char *url) {\n    debug(D_WEB_CLIENT, \"%llu: API v1 data with URL '%s'\", w->id, url);\n\n    int ret = 400;\n    BUFFER *dimensions = NULL;\n\n    buffer_flush(w->response.data);\n\n    char    *google_version = \"0.6\",\n            *google_reqId = \"0\",\n            *google_sig = \"0\",\n            *google_out = \"json\",\n            *responseHandler = NULL,\n            *outFileName = NULL;\n\n    time_t last_timestamp_in_data = 0, google_timestamp = 0;\n\n    char *chart = NULL\n    , *before_str = NULL\n    , *after_str = NULL\n    , *group_time_str = NULL\n    , *points_str = NULL;\n\n    int group = RRDR_GROUPING_AVERAGE;\n    uint32_t format = DATASOURCE_JSON;\n    uint32_t options = 0x00000000;\n\n    while(url) {\n        char *value = mystrsep(&url, \"?&\");\n        if(!value || !*value) continue;\n\n        char *name = mystrsep(&value, \"=\");\n        if(!name || !*name) continue;\n        if(!value || !*value) continue;\n\n        debug(D_WEB_CLIENT, \"%llu: API v1 data query param '%s' with value '%s'\", w->id, name, value);\n\n        // name and value are now the parameters\n        // they are not null and not empty\n\n        if(!strcmp(name, \"chart\")) chart = value;\n        else if(!strcmp(name, \"dimension\") || !strcmp(name, \"dim\") || !strcmp(name, \"dimensions\") || !strcmp(name, \"dims\")) {\n            if(!dimensions) dimensions = buffer_create(100);\n            buffer_strcat(dimensions, \"|\");\n            buffer_strcat(dimensions, value);\n        }\n        else if(!strcmp(name, \"after\")) after_str = value;\n        else if(!strcmp(name, \"before\")) before_str = value;\n        else if(!strcmp(name, \"points\")) points_str = value;\n        else if(!strcmp(name, \"gtime\")) group_time_str = value;\n        else if(!strcmp(name, \"group\")) {\n            group = web_client_api_request_v1_data_group(value, RRDR_GROUPING_AVERAGE);\n        }\n        else if(!strcmp(name, \"format\")) {\n            format = web_client_api_request_v1_data_format(value);\n        }\n        else if(!strcmp(name, \"options\")) {\n            options |= web_client_api_request_v1_data_options(value);\n        }\n        else if(!strcmp(name, \"callback\")) {\n            responseHandler = value;\n        }\n        else if(!strcmp(name, \"filename\")) {\n            outFileName = value;\n        }\n        else if(!strcmp(name, \"tqx\")) {\n            // parse Google Visualization API options\n            // https://developers.google.com/chart/interactive/docs/dev/implementing_data_source\n            char *tqx_name, *tqx_value;\n\n            while(value) {\n                tqx_value = mystrsep(&value, \";\");\n                if(!tqx_value || !*tqx_value) continue;\n\n                tqx_name = mystrsep(&tqx_value, \":\");\n                if(!tqx_name || !*tqx_name) continue;\n                if(!tqx_value || !*tqx_value) continue;\n\n                if(!strcmp(tqx_name, \"version\"))\n                    google_version = tqx_value;\n                else if(!strcmp(tqx_name, \"reqId\"))\n                    google_reqId = tqx_value;\n                else if(!strcmp(tqx_name, \"sig\")) {\n                    google_sig = tqx_value;\n                    google_timestamp = strtoul(google_sig, NULL, 0);\n                }\n                else if(!strcmp(tqx_name, \"out\")) {\n                    google_out = tqx_value;\n                    format = web_client_api_request_v1_data_google_format(google_out);\n                }\n                else if(!strcmp(tqx_name, \"responseHandler\"))\n                    responseHandler = tqx_value;\n                else if(!strcmp(tqx_name, \"outFileName\"))\n                    outFileName = tqx_value;\n            }\n        }\n    }\n\n    if(!chart || !*chart) {\n        buffer_sprintf(w->response.data, \"No chart id is given at the request.\");\n        goto cleanup;\n    }\n\n    RRDSET *st = rrdset_find(host, chart);\n    if(!st) st = rrdset_find_byname(host, chart);\n    if(!st) {\n        buffer_strcat(w->response.data, \"Chart is not found: \");\n        buffer_strcat_htmlescape(w->response.data, chart);\n        ret = 404;\n        goto cleanup;\n    }\n    st->last_accessed_time = now_realtime_sec();\n\n    long long before = (before_str && *before_str)?str2l(before_str):0;\n    long long after  = (after_str  && *after_str) ?str2l(after_str):0;\n    int       points = (points_str && *points_str)?str2i(points_str):0;\n    long      group_time = (group_time_str && *group_time_str)?str2l(group_time_str):0;\n\n    debug(D_WEB_CLIENT, \"%llu: API command 'data' for chart '%s', dimensions '%s', after '%lld', before '%lld', points '%d', group '%d', format '%u', options '0x%08x'\"\n          , w->id\n          , chart\n          , (dimensions)?buffer_tostring(dimensions):\"\"\n          , after\n          , before\n          , points\n          , group\n          , format\n          , options\n    );\n\n    if(outFileName && *outFileName) {\n        buffer_sprintf(w->response.header, \"Content-Disposition: attachment; filename=\\\"%s\\\"\\r\\n\", outFileName);\n        debug(D_WEB_CLIENT, \"%llu: generating outfilename header: '%s'\", w->id, outFileName);\n    }\n\n    if(format == DATASOURCE_DATATABLE_JSONP) {\n        if(responseHandler == NULL)\n            responseHandler = \"google.visualization.Query.setResponse\";\n\n        debug(D_WEB_CLIENT_ACCESS, \"%llu: GOOGLE JSON/JSONP: version = '%s', reqId = '%s', sig = '%s', out = '%s', responseHandler = '%s', outFileName = '%s'\",\n                w->id, google_version, google_reqId, google_sig, google_out, responseHandler, outFileName\n        );\n\n        buffer_sprintf(w->response.data,\n                \"%s({version:'%s',reqId:'%s',status:'ok',sig:'%ld',table:\",\n                responseHandler, google_version, google_reqId, st->last_updated.tv_sec);\n    }\n    else if(format == DATASOURCE_JSONP) {\n        if(responseHandler == NULL)\n            responseHandler = \"callback\";\n\n        buffer_strcat(w->response.data, responseHandler);\n        buffer_strcat(w->response.data, \"(\");\n    }\n\n    ret = rrdset2anything_api_v1(st, w->response.data, dimensions, format, points, after, before, group, group_time\n                                 , options, &last_timestamp_in_data);\n\n    if(format == DATASOURCE_DATATABLE_JSONP) {\n        if(google_timestamp < last_timestamp_in_data)\n            buffer_strcat(w->response.data, \"});\");\n\n        else {\n            // the client already has the latest data\n            buffer_flush(w->response.data);\n            buffer_sprintf(w->response.data,\n                    \"%s({version:'%s',reqId:'%s',status:'error',errors:[{reason:'not_modified',message:'Data not modified'}]});\",\n                    responseHandler, google_version, google_reqId);\n        }\n    }\n    else if(format == DATASOURCE_JSONP)\n        buffer_strcat(w->response.data, \");\");\n\n    cleanup:\n    buffer_free(dimensions);\n    return ret;\n}",
        "func": "inline int web_client_api_request_v1_data(RRDHOST *host, struct web_client *w, char *url) {\n    debug(D_WEB_CLIENT, \"%llu: API v1 data with URL '%s'\", w->id, url);\n\n    int ret = 400;\n    BUFFER *dimensions = NULL;\n\n    buffer_flush(w->response.data);\n\n    char    *google_version = \"0.6\",\n            *google_reqId = \"0\",\n            *google_sig = \"0\",\n            *google_out = \"json\",\n            *responseHandler = NULL,\n            *outFileName = NULL;\n\n    time_t last_timestamp_in_data = 0, google_timestamp = 0;\n\n    char *chart = NULL\n    , *before_str = NULL\n    , *after_str = NULL\n    , *group_time_str = NULL\n    , *points_str = NULL;\n\n    int group = RRDR_GROUPING_AVERAGE;\n    uint32_t format = DATASOURCE_JSON;\n    uint32_t options = 0x00000000;\n\n    while(url) {\n        char *value = mystrsep(&url, \"?&\");\n        if(!value || !*value) continue;\n\n        char *name = mystrsep(&value, \"=\");\n        if(!name || !*name) continue;\n        if(!value || !*value) continue;\n\n        debug(D_WEB_CLIENT, \"%llu: API v1 data query param '%s' with value '%s'\", w->id, name, value);\n\n        // name and value are now the parameters\n        // they are not null and not empty\n\n        if(!strcmp(name, \"chart\")) chart = value;\n        else if(!strcmp(name, \"dimension\") || !strcmp(name, \"dim\") || !strcmp(name, \"dimensions\") || !strcmp(name, \"dims\")) {\n            if(!dimensions) dimensions = buffer_create(100);\n            buffer_strcat(dimensions, \"|\");\n            buffer_strcat(dimensions, value);\n        }\n        else if(!strcmp(name, \"after\")) after_str = value;\n        else if(!strcmp(name, \"before\")) before_str = value;\n        else if(!strcmp(name, \"points\")) points_str = value;\n        else if(!strcmp(name, \"gtime\")) group_time_str = value;\n        else if(!strcmp(name, \"group\")) {\n            group = web_client_api_request_v1_data_group(value, RRDR_GROUPING_AVERAGE);\n        }\n        else if(!strcmp(name, \"format\")) {\n            format = web_client_api_request_v1_data_format(value);\n        }\n        else if(!strcmp(name, \"options\")) {\n            options |= web_client_api_request_v1_data_options(value);\n        }\n        else if(!strcmp(name, \"callback\")) {\n            responseHandler = value;\n        }\n        else if(!strcmp(name, \"filename\")) {\n            outFileName = value;\n        }\n        else if(!strcmp(name, \"tqx\")) {\n            // parse Google Visualization API options\n            // https://developers.google.com/chart/interactive/docs/dev/implementing_data_source\n            char *tqx_name, *tqx_value;\n\n            while(value) {\n                tqx_value = mystrsep(&value, \";\");\n                if(!tqx_value || !*tqx_value) continue;\n\n                tqx_name = mystrsep(&tqx_value, \":\");\n                if(!tqx_name || !*tqx_name) continue;\n                if(!tqx_value || !*tqx_value) continue;\n\n                if(!strcmp(tqx_name, \"version\"))\n                    google_version = tqx_value;\n                else if(!strcmp(tqx_name, \"reqId\"))\n                    google_reqId = tqx_value;\n                else if(!strcmp(tqx_name, \"sig\")) {\n                    google_sig = tqx_value;\n                    google_timestamp = strtoul(google_sig, NULL, 0);\n                }\n                else if(!strcmp(tqx_name, \"out\")) {\n                    google_out = tqx_value;\n                    format = web_client_api_request_v1_data_google_format(google_out);\n                }\n                else if(!strcmp(tqx_name, \"responseHandler\"))\n                    responseHandler = tqx_value;\n                else if(!strcmp(tqx_name, \"outFileName\"))\n                    outFileName = tqx_value;\n            }\n        }\n    }\n\n    // validate the google parameters given\n    fix_google_param(google_out);\n    fix_google_param(google_sig);\n    fix_google_param(google_reqId);\n    fix_google_param(google_version);\n    fix_google_param(responseHandler);\n    fix_google_param(outFileName);\n\n    if(!chart || !*chart) {\n        buffer_sprintf(w->response.data, \"No chart id is given at the request.\");\n        goto cleanup;\n    }\n\n    RRDSET *st = rrdset_find(host, chart);\n    if(!st) st = rrdset_find_byname(host, chart);\n    if(!st) {\n        buffer_strcat(w->response.data, \"Chart is not found: \");\n        buffer_strcat_htmlescape(w->response.data, chart);\n        ret = 404;\n        goto cleanup;\n    }\n    st->last_accessed_time = now_realtime_sec();\n\n    long long before = (before_str && *before_str)?str2l(before_str):0;\n    long long after  = (after_str  && *after_str) ?str2l(after_str):0;\n    int       points = (points_str && *points_str)?str2i(points_str):0;\n    long      group_time = (group_time_str && *group_time_str)?str2l(group_time_str):0;\n\n    debug(D_WEB_CLIENT, \"%llu: API command 'data' for chart '%s', dimensions '%s', after '%lld', before '%lld', points '%d', group '%d', format '%u', options '0x%08x'\"\n          , w->id\n          , chart\n          , (dimensions)?buffer_tostring(dimensions):\"\"\n          , after\n          , before\n          , points\n          , group\n          , format\n          , options\n    );\n\n    if(outFileName && *outFileName) {\n        buffer_sprintf(w->response.header, \"Content-Disposition: attachment; filename=\\\"%s\\\"\\r\\n\", outFileName);\n        debug(D_WEB_CLIENT, \"%llu: generating outfilename header: '%s'\", w->id, outFileName);\n    }\n\n    if(format == DATASOURCE_DATATABLE_JSONP) {\n        if(responseHandler == NULL)\n            responseHandler = \"google.visualization.Query.setResponse\";\n\n        debug(D_WEB_CLIENT_ACCESS, \"%llu: GOOGLE JSON/JSONP: version = '%s', reqId = '%s', sig = '%s', out = '%s', responseHandler = '%s', outFileName = '%s'\",\n                w->id, google_version, google_reqId, google_sig, google_out, responseHandler, outFileName\n        );\n\n        buffer_sprintf(w->response.data,\n                \"%s({version:'%s',reqId:'%s',status:'ok',sig:'%ld',table:\",\n                responseHandler, google_version, google_reqId, st->last_updated.tv_sec);\n    }\n    else if(format == DATASOURCE_JSONP) {\n        if(responseHandler == NULL)\n            responseHandler = \"callback\";\n\n        buffer_strcat(w->response.data, responseHandler);\n        buffer_strcat(w->response.data, \"(\");\n    }\n\n    ret = rrdset2anything_api_v1(st, w->response.data, dimensions, format, points, after, before, group, group_time\n                                 , options, &last_timestamp_in_data);\n\n    if(format == DATASOURCE_DATATABLE_JSONP) {\n        if(google_timestamp < last_timestamp_in_data)\n            buffer_strcat(w->response.data, \"});\");\n\n        else {\n            // the client already has the latest data\n            buffer_flush(w->response.data);\n            buffer_sprintf(w->response.data,\n                    \"%s({version:'%s',reqId:'%s',status:'error',errors:[{reason:'not_modified',message:'Data not modified'}]});\",\n                    responseHandler, google_version, google_reqId);\n        }\n    }\n    else if(format == DATASOURCE_JSONP)\n        buffer_strcat(w->response.data, \");\");\n\n    cleanup:\n    buffer_free(dimensions);\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -96,6 +96,14 @@\n         }\n     }\n \n+    // validate the google parameters given\n+    fix_google_param(google_out);\n+    fix_google_param(google_sig);\n+    fix_google_param(google_reqId);\n+    fix_google_param(google_version);\n+    fix_google_param(responseHandler);\n+    fix_google_param(outFileName);\n+\n     if(!chart || !*chart) {\n         buffer_sprintf(w->response.data, \"No chart id is given at the request.\");\n         goto cleanup;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    // validate the google parameters given",
                "    fix_google_param(google_out);",
                "    fix_google_param(google_sig);",
                "    fix_google_param(google_reqId);",
                "    fix_google_param(google_version);",
                "    fix_google_param(responseHandler);",
                "    fix_google_param(outFileName);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28101",
        "func_name": "flatpak/print_eol_info_message",
        "description": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they can hide those permissions from users of the `flatpak(1)` command-line interface by setting other permissions to crafted values that contain non-printable control characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line interface, or only install apps whose maintainers you trust.",
        "git_url": "https://github.com/flatpak/flatpak/commit/409e34187de2b2b2c4ef34c79f417be698830f6c",
        "commit_title": "cli-transaction: Escape any special characters in the EOL reason",
        "commit_text": " CVE-2023-28101, GHSA-h43h-fwqx-mpp8 ",
        "func_before": "static void\nprint_eol_info_message (FlatpakDir        *dir,\n                        FlatpakDecomposed *ref,\n                        const char        *ref_name,\n                        const char        *rebased_to_ref,\n                        const char        *reason)\n{\n  gboolean is_pinned = flatpak_dir_ref_is_pinned (dir, flatpak_decomposed_get_ref (ref));\n  g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);\n  const char *on = \"\";\n  const char *off = \"\";\n\n  if (flatpak_fancy_output ())\n    {\n      on = FLATPAK_ANSI_BOLD_ON;\n      off = FLATPAK_ANSI_BOLD_OFF;\n    }\n\n  /* Here we go to great lengths not to split the sentences. See\n   * https://wiki.gnome.org/TranslationProject/DevGuidelines/Never%20split%20sentences\n   */\n  if (rebased_to_ref)\n    {\n      g_autoptr(FlatpakDecomposed) eolr_decomposed = NULL;\n      g_autofree char *eolr_name = NULL;\n      const char *eolr_branch;\n\n      eolr_decomposed = flatpak_decomposed_new_from_ref (rebased_to_ref, NULL);\n\n      /* These are guarantees from FlatpakTransaction */\n      g_assert (eolr_decomposed != NULL);\n      g_assert (flatpak_decomposed_get_kind (ref) == flatpak_decomposed_get_kind (eolr_decomposed));\n\n      eolr_name = flatpak_decomposed_dup_id (eolr_decomposed);\n      eolr_branch = flatpak_decomposed_get_branch (eolr_decomposed);\n\n      if (is_pinned)\n        {\n          /* Only runtimes can be pinned */\n          g_print (_(\"\\nInfo: (pinned) runtime %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\\n\"),\n                   on, ref_name, off, on, ref_branch, off, on, eolr_name, off, on, eolr_branch, off);\n        }\n      else\n        {\n          if (flatpak_decomposed_is_runtime (ref))\n            g_print (_(\"\\nInfo: runtime %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\\n\"),\n                     on, ref_name, off, on, ref_branch, off, on, eolr_name, off, on, eolr_branch, off);\n          else\n            g_print (_(\"\\nInfo: app %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\\n\"),\n                     on, ref_name, off, on, ref_branch, off, on, eolr_name, off, on, eolr_branch, off);\n        }\n    }\n  else if (reason)\n    {\n      if (is_pinned)\n        {\n          /* Only runtimes can be pinned */\n          g_print (_(\"\\nInfo: (pinned) runtime %s%s%s branch %s%s%s is end-of-life, with reason:\\n\"),\n                   on, ref_name, off, on, ref_branch, off);\n        }\n      else\n        {\n          if (flatpak_decomposed_is_runtime (ref))\n            g_print (_(\"\\nInfo: runtime %s%s%s branch %s%s%s is end-of-life, with reason:\\n\"),\n                     on, ref_name, off, on, ref_branch, off);\n          else\n            g_print (_(\"\\nInfo: app %s%s%s branch %s%s%s is end-of-life, with reason:\\n\"),\n                     on, ref_name, off, on, ref_branch, off);\n        }\n      g_print (\"   %s\\n\", reason);\n    }\n}",
        "func": "static void\nprint_eol_info_message (FlatpakDir        *dir,\n                        FlatpakDecomposed *ref,\n                        const char        *ref_name,\n                        const char        *rebased_to_ref,\n                        const char        *reason)\n{\n  gboolean is_pinned = flatpak_dir_ref_is_pinned (dir, flatpak_decomposed_get_ref (ref));\n  g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);\n  const char *on = \"\";\n  const char *off = \"\";\n\n  if (flatpak_fancy_output ())\n    {\n      on = FLATPAK_ANSI_BOLD_ON;\n      off = FLATPAK_ANSI_BOLD_OFF;\n    }\n\n  /* Here we go to great lengths not to split the sentences. See\n   * https://wiki.gnome.org/TranslationProject/DevGuidelines/Never%20split%20sentences\n   */\n  if (rebased_to_ref)\n    {\n      g_autoptr(FlatpakDecomposed) eolr_decomposed = NULL;\n      g_autofree char *eolr_name = NULL;\n      const char *eolr_branch;\n\n      eolr_decomposed = flatpak_decomposed_new_from_ref (rebased_to_ref, NULL);\n\n      /* These are guarantees from FlatpakTransaction */\n      g_assert (eolr_decomposed != NULL);\n      g_assert (flatpak_decomposed_get_kind (ref) == flatpak_decomposed_get_kind (eolr_decomposed));\n\n      eolr_name = flatpak_decomposed_dup_id (eolr_decomposed);\n      eolr_branch = flatpak_decomposed_get_branch (eolr_decomposed);\n\n      if (is_pinned)\n        {\n          /* Only runtimes can be pinned */\n          g_print (_(\"\\nInfo: (pinned) runtime %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\\n\"),\n                   on, ref_name, off, on, ref_branch, off, on, eolr_name, off, on, eolr_branch, off);\n        }\n      else\n        {\n          if (flatpak_decomposed_is_runtime (ref))\n            g_print (_(\"\\nInfo: runtime %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\\n\"),\n                     on, ref_name, off, on, ref_branch, off, on, eolr_name, off, on, eolr_branch, off);\n          else\n            g_print (_(\"\\nInfo: app %s%s%s branch %s%s%s is end-of-life, in favor of %s%s%s branch %s%s%s\\n\"),\n                     on, ref_name, off, on, ref_branch, off, on, eolr_name, off, on, eolr_branch, off);\n        }\n    }\n  else if (reason)\n    {\n      g_autofree char *escaped_reason = flatpak_escape_string (reason,\n                                                               FLATPAK_ESCAPE_ALLOW_NEWLINES |\n                                                               FLATPAK_ESCAPE_DO_NOT_QUOTE);\n      if (is_pinned)\n        {\n          /* Only runtimes can be pinned */\n          g_print (_(\"\\nInfo: (pinned) runtime %s%s%s branch %s%s%s is end-of-life, with reason:\\n\"),\n                   on, ref_name, off, on, ref_branch, off);\n        }\n      else\n        {\n          if (flatpak_decomposed_is_runtime (ref))\n            g_print (_(\"\\nInfo: runtime %s%s%s branch %s%s%s is end-of-life, with reason:\\n\"),\n                     on, ref_name, off, on, ref_branch, off);\n          else\n            g_print (_(\"\\nInfo: app %s%s%s branch %s%s%s is end-of-life, with reason:\\n\"),\n                     on, ref_name, off, on, ref_branch, off);\n        }\n      g_print (\"   %s\\n\", escaped_reason);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -52,6 +52,9 @@\n     }\n   else if (reason)\n     {\n+      g_autofree char *escaped_reason = flatpak_escape_string (reason,\n+                                                               FLATPAK_ESCAPE_ALLOW_NEWLINES |\n+                                                               FLATPAK_ESCAPE_DO_NOT_QUOTE);\n       if (is_pinned)\n         {\n           /* Only runtimes can be pinned */\n@@ -67,6 +70,6 @@\n             g_print (_(\"\\nInfo: app %s%s%s branch %s%s%s is end-of-life, with reason:\\n\"),\n                      on, ref_name, off, on, ref_branch, off);\n         }\n-      g_print (\"   %s\\n\", reason);\n+      g_print (\"   %s\\n\", escaped_reason);\n     }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      g_print (\"   %s\\n\", reason);"
            ],
            "added_lines": [
                "      g_autofree char *escaped_reason = flatpak_escape_string (reason,",
                "                                                               FLATPAK_ESCAPE_ALLOW_NEWLINES |",
                "                                                               FLATPAK_ESCAPE_DO_NOT_QUOTE);",
                "      g_print (\"   %s\\n\", escaped_reason);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28101",
        "func_name": "flatpak/flatpak_builtin_info",
        "description": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they can hide those permissions from users of the `flatpak(1)` command-line interface by setting other permissions to crafted values that contain non-printable control characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line interface, or only install apps whose maintainers you trust.",
        "git_url": "https://github.com/flatpak/flatpak/commit/6cac99dafe6003c8a4bd5666341c217876536869",
        "commit_title": "Ensure special characters in permissions and metadata are escaped",
        "commit_text": " This prevents someone from placing special characters in order to manipulate the appearance of the permissions list.  CVE-2023-28101, GHSA-h43h-fwqx-mpp8 ",
        "func_before": "gboolean\nflatpak_builtin_info (int argc, char **argv, GCancellable *cancellable, GError **error)\n{\n  g_autoptr(GOptionContext) context = NULL;\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n  g_autoptr(FlatpakDir) dir = NULL;\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autoptr(FlatpakDeploy) deploy = NULL;\n  g_autoptr(GFile) deploy_dir = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  const char *commit = NULL;\n  const char *alt_id = NULL;\n  const char *eol;\n  const char *eol_rebase;\n  const char *name;\n  const char *summary;\n  const char *version;\n  const char *license;\n  const char *pref = NULL;\n  const char *default_branch = NULL;\n  const char *origin = NULL;\n  guint64 size;\n  gboolean search_all = FALSE;\n  gboolean first = TRUE;\n  FlatpakKinds kinds;\n  const char *path;\n  g_autofree char *formatted_size = NULL;\n  gboolean friendly = TRUE;\n  g_autofree const char **subpaths = NULL;\n  int len = 0;\n  int rows, cols;\n  int width;\n\n  context = g_option_context_new (_(\"NAME [BRANCH] - Get info about an installed app or runtime\"));\n  g_option_context_set_translation_domain (context, GETTEXT_PACKAGE);\n\n  if (!flatpak_option_context_parse (context, options, &argc, &argv, FLATPAK_BUILTIN_FLAG_NO_DIR, NULL, cancellable, error))\n    return FALSE;\n\n  if (argc < 2)\n    return usage_error (context, _(\"NAME must be specified\"), error);\n  pref = argv[1];\n\n  if (argc >= 3)\n    default_branch = argv[2];\n\n  if (argc > 3)\n    return usage_error (context, _(\"Too many arguments\"), error);\n\n  kinds = FLATPAK_KINDS_APP | FLATPAK_KINDS_RUNTIME;\n\n  if (!opt_user && !opt_system && opt_installations == NULL)\n    search_all = TRUE;\n\n  dir = flatpak_find_installed_pref (pref, kinds, opt_arch, default_branch,\n                                     search_all, opt_user, opt_system, opt_installations,\n                                     &ref, cancellable, error);\n  if (dir == NULL)\n    return FALSE;\n\n  deploy_data = flatpak_dir_get_deploy_data (dir, ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);\n  if (deploy_data == NULL)\n    return FALSE;\n\n  deploy = flatpak_dir_load_deployed (dir, ref, NULL, cancellable, error);\n  if (deploy == NULL)\n    return FALSE;\n\n  commit = flatpak_deploy_data_get_commit (deploy_data);\n  alt_id = flatpak_deploy_data_get_alt_id (deploy_data);\n  origin = flatpak_deploy_data_get_origin (deploy_data);\n  size = flatpak_deploy_data_get_installed_size (deploy_data);\n  formatted_size = g_format_size (size);\n  deploy_dir = flatpak_deploy_get_dir (deploy);\n  path = flatpak_file_get_path_cached (deploy_dir);\n  subpaths = flatpak_deploy_data_get_subpaths (deploy_data);\n  eol = flatpak_deploy_data_get_eol (deploy_data);\n  eol_rebase = flatpak_deploy_data_get_eol_rebase (deploy_data);\n  name = flatpak_deploy_data_get_appdata_name (deploy_data);\n  summary = flatpak_deploy_data_get_appdata_summary (deploy_data);\n  version = flatpak_deploy_data_get_appdata_version (deploy_data);\n  license = flatpak_deploy_data_get_appdata_license (deploy_data);\n\n  metakey = flatpak_deploy_get_metadata (deploy);\n\n  if (opt_show_ref || opt_show_origin || opt_show_commit || opt_show_size || opt_show_metadata || opt_show_permissions ||\n      opt_file_access || opt_show_location || opt_show_runtime || opt_show_sdk)\n    friendly = FALSE;\n\n  if (friendly)\n    {\n      g_autoptr(GVariant) commit_v = NULL;\n      VarMetadataRef commit_metadata;\n      guint64 timestamp;\n      g_autofree char *formatted_timestamp = NULL;\n      const gchar *subject = NULL;\n      g_autofree char *parent = NULL;\n      g_autofree char *latest = NULL;\n      const char *xa_metadata = NULL;\n      const char *collection_id = NULL;\n\n      flatpak_get_window_size (&rows, &cols);\n\n      if (name)\n        {\n          if (summary)\n            print_wrapped (MIN (cols, 80), \"\\n%s - %s\\n\", name, summary);\n          else\n            print_wrapped (MIN (cols, 80), \"\\n%s\\n\", name);\n        }\n\n      latest = flatpak_dir_read_latest (dir, origin, flatpak_decomposed_get_ref (ref), NULL, NULL, NULL);\n      if (latest == NULL)\n        latest = g_strdup (_(\"ref not present in origin\"));\n\n      if (ostree_repo_load_commit (flatpak_dir_get_repo (dir), commit, &commit_v, NULL, NULL))\n        {\n          VarCommitRef var_commit = var_commit_from_gvariant (commit_v);\n\n          subject = var_commit_get_subject (var_commit);\n          parent = ostree_commit_get_parent (commit_v);\n          timestamp = ostree_commit_get_timestamp (commit_v);\n\n          formatted_timestamp = format_timestamp (timestamp);\n\n          commit_metadata = var_commit_get_metadata (var_commit);\n          xa_metadata = var_metadata_lookup_string (commit_metadata, \"xa.metadata\", NULL);\n          if (xa_metadata == NULL)\n            g_printerr (_(\"Warning: Commit has no flatpak metadata\\n\"));\n\n          collection_id = var_metadata_lookup_string (commit_metadata, \"ostree.collection-binding\", NULL);\n        }\n\n      len = 0;\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Ref:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Arch:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Branch:\"), -1));\n      if (version)\n        len = MAX (len, g_utf8_strlen (_(\"Version:\"), -1));\n      if (license)\n        len = MAX (len, g_utf8_strlen (_(\"License:\"), -1));\n      if (collection_id != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Collection:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installation:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      if (flatpak_decomposed_is_app (ref))\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Runtime:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Sdk:\"), -1));\n        }\n      if (formatted_timestamp)\n        len = MAX (len, g_utf8_strlen (_(\"Date:\"), -1));\n      if (subject)\n        len = MAX (len, g_utf8_strlen (_(\"Subject:\"), -1));\n      if (strcmp (commit, latest) != 0)\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Active commit:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Latest commit:\"), -1));\n        }\n      else\n        len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      if (parent)\n        len = MAX (len, g_utf8_strlen (_(\"Parent:\"), -1));\n      if (alt_id)\n        len = MAX (len, g_utf8_strlen (_(\"Alt-id:\"), -1));\n      if (eol)\n        len = MAX (len, g_utf8_strlen (_(\"End-of-life:\"), -1));\n      if (eol_rebase)\n        len = MAX (len, g_utf8_strlen (_(\"End-of-life-rebase:\"), -1));\n      if (subpaths[0] != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Subdirectories:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Extension:\"), -1));\n\n      width = cols - (len + 1);\n\n      print_aligned_take (len, _(\"ID:\"), flatpak_decomposed_dup_id (ref));\n      print_aligned (len, _(\"Ref:\"), flatpak_decomposed_get_ref (ref));\n      print_aligned_take (len, _(\"Arch:\"), flatpak_decomposed_dup_arch (ref));\n      print_aligned_take (len, _(\"Branch:\"), flatpak_decomposed_dup_branch (ref));\n      if (version)\n        print_aligned (len, _(\"Version:\"), version);\n      if (license)\n        print_aligned (len, _(\"License:\"), license);\n      print_aligned (len, _(\"Origin:\"), origin ? origin : \"-\");\n      if (collection_id)\n        print_aligned (len, _(\"Collection:\"), collection_id);\n      print_aligned (len, _(\"Installation:\"), flatpak_dir_get_name_cached (dir));\n      print_aligned (len, _(\"Installed:\"), formatted_size);\n      if (flatpak_decomposed_is_app (ref))\n        {\n          g_autofree char *runtime = NULL;\n          runtime = g_key_file_get_string (metakey,\n                                           FLATPAK_METADATA_GROUP_APPLICATION,\n                                           FLATPAK_METADATA_KEY_RUNTIME,\n                                           error);\n          print_aligned (len, _(\"Runtime:\"), runtime ? runtime : \"-\");\n        }\n      if (flatpak_decomposed_is_app (ref))\n        {\n          g_autofree char *sdk = NULL;\n          sdk = g_key_file_get_string (metakey,\n                                       FLATPAK_METADATA_GROUP_APPLICATION,\n                                       FLATPAK_METADATA_KEY_SDK,\n                                       error);\n          print_aligned (len, _(\"Sdk:\"), sdk ? sdk : \"-\");\n        }\n      g_print (\"\\n\");\n\n      if (strcmp (commit, latest) != 0)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (commit, width);\n          print_aligned (len, _(\"Active commit:\"), formatted_commit);\n          g_free (formatted_commit);\n          formatted_commit = ellipsize_string (latest, width);\n          print_aligned (len, _(\"Latest commit:\"), formatted_commit);\n        }\n      else\n        {\n          g_autofree char *formatted_commit = ellipsize_string (commit, width);\n          print_aligned (len, _(\"Commit:\"), formatted_commit);\n        }\n      if (parent)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (parent, width);\n          print_aligned (len, _(\"Parent:\"), formatted_commit);\n        }\n      if (subject)\n        print_aligned (len, _(\"Subject:\"), subject);\n      if (formatted_timestamp)\n        print_aligned (len, _(\"Date:\"), formatted_timestamp);\n      if (subpaths[0] != NULL)\n        {\n          g_autofree char *s = g_strjoinv (\",\", (char **) subpaths);\n          print_aligned (len, _(\"Subdirectories:\"), s);\n        }\n\n      if (alt_id)\n        print_aligned (len, _(\"Alt-id:\"), alt_id);\n      if (eol)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol, width);\n          print_aligned (len, _(\"End-of-life:\"), formatted_eol);\n        }\n      if (eol_rebase)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol_rebase, width);\n          print_aligned (len, _(\"End-of-life-rebase:\"), formatted_eol);\n        }\n    }\n  else\n    {\n      if (opt_show_ref)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", flatpak_decomposed_get_ref (ref));\n        }\n\n      if (opt_show_origin)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", origin ? origin : \"-\");\n        }\n\n      if (opt_show_commit)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", commit);\n        }\n\n      if (opt_show_size)\n        {\n          maybe_print_space (&first);\n          g_print (\"%\" G_GUINT64_FORMAT, size);\n        }\n\n      if (opt_show_location)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", path);\n        }\n\n      if (opt_show_runtime)\n        {\n          g_autofree char *runtime = NULL;\n          maybe_print_space (&first);\n\n          runtime = g_key_file_get_string (metakey,\n                                           flatpak_decomposed_get_kind_metadata_group (ref),\n                                           FLATPAK_METADATA_KEY_RUNTIME,\n                                           NULL);\n          g_print (\"%s\", runtime ? runtime : \"-\");\n        }\n\n      if (opt_show_sdk)\n        {\n          g_autofree char *sdk = NULL;\n          maybe_print_space (&first);\n\n          sdk = g_key_file_get_string (metakey,\n                                       flatpak_decomposed_get_kind_metadata_group (ref),\n                                       FLATPAK_METADATA_KEY_SDK,\n                                       NULL);\n          g_print (\"%s\", sdk ? sdk : \"-\");\n        }\n\n      if (!first)\n        g_print (\"\\n\");\n\n      if (opt_show_metadata)\n        {\n          g_autoptr(GFile) file = NULL;\n          g_autofree char *data = NULL;\n          gsize data_size;\n\n          file = g_file_get_child (deploy_dir, \"metadata\");\n\n          if (!g_file_load_contents (file, cancellable, &data, &data_size, NULL, error))\n            return FALSE;\n\n          g_print (\"%s\", data);\n        }\n\n      if (opt_show_permissions || opt_file_access)\n        {\n          g_autoptr(FlatpakContext) app_context = NULL;\n          g_autoptr(GKeyFile) keyfile = NULL;\n          g_autofree gchar *contents = NULL;\n\n          app_context = flatpak_context_load_for_deploy (deploy, error);\n          if (app_context == NULL)\n            return FALSE;\n\n          if (opt_show_permissions)\n            {\n              keyfile = g_key_file_new ();\n              flatpak_context_save_metadata (app_context, TRUE, keyfile);\n              contents = g_key_file_to_data (keyfile, NULL, error);\n              if (contents == NULL)\n                return FALSE;\n\n              g_print (\"%s\", contents);\n            }\n\n          if (opt_file_access)\n            {\n              g_autofree char *id = flatpak_decomposed_dup_id (ref);\n              g_autoptr(FlatpakExports) exports = flatpak_context_get_exports (app_context, id);\n              FlatpakFilesystemMode mode;\n\n              mode = flatpak_exports_path_get_mode (exports, opt_file_access);\n              if (mode == 0)\n                g_print (\"hidden\\n\");\n              else if (mode == FLATPAK_FILESYSTEM_MODE_READ_ONLY)\n                g_print (\"read-only\\n\");\n              else\n                g_print (\"read-write\\n\");\n            }\n        }\n    }\n\n  if (opt_show_extensions)\n    {\n      GList *extensions, *l;\n      g_autofree char *ref_arch = flatpak_decomposed_dup_arch (ref);\n      g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);\n\n      len = MAX (len, g_utf8_strlen (_(\"Extension:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Origin:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Subpaths:\"), -1));\n\n      flatpak_get_window_size (&rows, &cols);\n      width = cols - (len + 1);\n\n      extensions = flatpak_list_extensions (metakey, ref_arch, ref_branch);\n      for (l = extensions; l; l = l->next)\n        {\n          FlatpakExtension *ext = l->data;\n          g_autofree const char **ext_subpaths = NULL;\n          g_autoptr(GBytes) ext_deploy_data = NULL;\n          g_autofree char *formatted = NULL;\n          g_autofree char *ext_formatted_size = NULL;\n          g_autofree char *formatted_commit = NULL;\n\n          if (ext->is_unmaintained)\n            {\n              formatted_commit = g_strdup (_(\"unmaintained\"));\n              origin = NULL;\n              size = 0;\n              ext_formatted_size = g_strdup (_(\"unknown\"));\n              ext_subpaths = NULL;\n            }\n          else\n            {\n              ext_deploy_data = flatpak_dir_get_deploy_data (dir, ext->ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);\n              if (ext_deploy_data == NULL)\n                return FALSE;\n\n              commit = flatpak_deploy_data_get_commit (ext_deploy_data);\n              formatted_commit = ellipsize_string (commit, width);\n              origin = flatpak_deploy_data_get_origin (ext_deploy_data);\n              size = flatpak_deploy_data_get_installed_size (ext_deploy_data);\n              formatted = g_format_size (size);\n              ext_subpaths = flatpak_deploy_data_get_subpaths (ext_deploy_data);\n              if (ext_subpaths && ext_subpaths[0] && size > 0)\n                ext_formatted_size = g_strconcat (\"<\", formatted, NULL);\n              else\n                ext_formatted_size = g_steal_pointer (&formatted);\n            }\n\n          g_print (\"\\n\");\n          print_aligned (len, _(\"Extension:\"), flatpak_decomposed_get_ref (ext->ref));\n          print_aligned (len, _(\"ID:\"), ext->id);\n          print_aligned (len, _(\"Origin:\"), origin ? origin : \"-\");\n          print_aligned (len, _(\"Commit:\"), formatted_commit);\n          print_aligned (len, _(\"Installed:\"), ext_formatted_size);\n\n          if (ext_subpaths && ext_subpaths[0])\n            {\n              g_autofree char *s = g_strjoinv (\",\", (char **) ext_subpaths);\n              print_aligned (len, _(\"Subpaths:\"), s);\n            }\n        }\n\n      g_list_free_full (extensions, (GDestroyNotify) flatpak_extension_free);\n    }\n\n  return TRUE;\n}",
        "func": "gboolean\nflatpak_builtin_info (int argc, char **argv, GCancellable *cancellable, GError **error)\n{\n  g_autoptr(GOptionContext) context = NULL;\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n  g_autoptr(FlatpakDir) dir = NULL;\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autoptr(FlatpakDeploy) deploy = NULL;\n  g_autoptr(GFile) deploy_dir = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  const char *commit = NULL;\n  const char *alt_id = NULL;\n  const char *eol;\n  const char *eol_rebase;\n  const char *name;\n  const char *summary;\n  const char *version;\n  const char *license;\n  const char *pref = NULL;\n  const char *default_branch = NULL;\n  const char *origin = NULL;\n  guint64 size;\n  gboolean search_all = FALSE;\n  gboolean first = TRUE;\n  FlatpakKinds kinds;\n  const char *path;\n  g_autofree char *formatted_size = NULL;\n  gboolean friendly = TRUE;\n  g_autofree const char **subpaths = NULL;\n  int len = 0;\n  int rows, cols;\n  int width;\n\n  context = g_option_context_new (_(\"NAME [BRANCH] - Get info about an installed app or runtime\"));\n  g_option_context_set_translation_domain (context, GETTEXT_PACKAGE);\n\n  if (!flatpak_option_context_parse (context, options, &argc, &argv, FLATPAK_BUILTIN_FLAG_NO_DIR, NULL, cancellable, error))\n    return FALSE;\n\n  if (argc < 2)\n    return usage_error (context, _(\"NAME must be specified\"), error);\n  pref = argv[1];\n\n  if (argc >= 3)\n    default_branch = argv[2];\n\n  if (argc > 3)\n    return usage_error (context, _(\"Too many arguments\"), error);\n\n  kinds = FLATPAK_KINDS_APP | FLATPAK_KINDS_RUNTIME;\n\n  if (!opt_user && !opt_system && opt_installations == NULL)\n    search_all = TRUE;\n\n  dir = flatpak_find_installed_pref (pref, kinds, opt_arch, default_branch,\n                                     search_all, opt_user, opt_system, opt_installations,\n                                     &ref, cancellable, error);\n  if (dir == NULL)\n    return FALSE;\n\n  deploy_data = flatpak_dir_get_deploy_data (dir, ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);\n  if (deploy_data == NULL)\n    return FALSE;\n\n  deploy = flatpak_dir_load_deployed (dir, ref, NULL, cancellable, error);\n  if (deploy == NULL)\n    return FALSE;\n\n  commit = flatpak_deploy_data_get_commit (deploy_data);\n  alt_id = flatpak_deploy_data_get_alt_id (deploy_data);\n  origin = flatpak_deploy_data_get_origin (deploy_data);\n  size = flatpak_deploy_data_get_installed_size (deploy_data);\n  formatted_size = g_format_size (size);\n  deploy_dir = flatpak_deploy_get_dir (deploy);\n  path = flatpak_file_get_path_cached (deploy_dir);\n  subpaths = flatpak_deploy_data_get_subpaths (deploy_data);\n  eol = flatpak_deploy_data_get_eol (deploy_data);\n  eol_rebase = flatpak_deploy_data_get_eol_rebase (deploy_data);\n  name = flatpak_deploy_data_get_appdata_name (deploy_data);\n  summary = flatpak_deploy_data_get_appdata_summary (deploy_data);\n  version = flatpak_deploy_data_get_appdata_version (deploy_data);\n  license = flatpak_deploy_data_get_appdata_license (deploy_data);\n\n  metakey = flatpak_deploy_get_metadata (deploy);\n\n  if (opt_show_ref || opt_show_origin || opt_show_commit || opt_show_size || opt_show_metadata || opt_show_permissions ||\n      opt_file_access || opt_show_location || opt_show_runtime || opt_show_sdk)\n    friendly = FALSE;\n\n  if (friendly)\n    {\n      g_autoptr(GVariant) commit_v = NULL;\n      VarMetadataRef commit_metadata;\n      guint64 timestamp;\n      g_autofree char *formatted_timestamp = NULL;\n      const gchar *subject = NULL;\n      g_autofree char *parent = NULL;\n      g_autofree char *latest = NULL;\n      const char *xa_metadata = NULL;\n      const char *collection_id = NULL;\n\n      flatpak_get_window_size (&rows, &cols);\n\n      if (name)\n        {\n          if (summary)\n            print_wrapped (MIN (cols, 80), \"\\n%s - %s\\n\", name, summary);\n          else\n            print_wrapped (MIN (cols, 80), \"\\n%s\\n\", name);\n        }\n\n      latest = flatpak_dir_read_latest (dir, origin, flatpak_decomposed_get_ref (ref), NULL, NULL, NULL);\n      if (latest == NULL)\n        latest = g_strdup (_(\"ref not present in origin\"));\n\n      if (ostree_repo_load_commit (flatpak_dir_get_repo (dir), commit, &commit_v, NULL, NULL))\n        {\n          VarCommitRef var_commit = var_commit_from_gvariant (commit_v);\n\n          subject = var_commit_get_subject (var_commit);\n          parent = ostree_commit_get_parent (commit_v);\n          timestamp = ostree_commit_get_timestamp (commit_v);\n\n          formatted_timestamp = format_timestamp (timestamp);\n\n          commit_metadata = var_commit_get_metadata (var_commit);\n          xa_metadata = var_metadata_lookup_string (commit_metadata, \"xa.metadata\", NULL);\n          if (xa_metadata == NULL)\n            g_printerr (_(\"Warning: Commit has no flatpak metadata\\n\"));\n\n          collection_id = var_metadata_lookup_string (commit_metadata, \"ostree.collection-binding\", NULL);\n        }\n\n      len = 0;\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Ref:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Arch:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Branch:\"), -1));\n      if (version)\n        len = MAX (len, g_utf8_strlen (_(\"Version:\"), -1));\n      if (license)\n        len = MAX (len, g_utf8_strlen (_(\"License:\"), -1));\n      if (collection_id != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Collection:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installation:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      if (flatpak_decomposed_is_app (ref))\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Runtime:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Sdk:\"), -1));\n        }\n      if (formatted_timestamp)\n        len = MAX (len, g_utf8_strlen (_(\"Date:\"), -1));\n      if (subject)\n        len = MAX (len, g_utf8_strlen (_(\"Subject:\"), -1));\n      if (strcmp (commit, latest) != 0)\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Active commit:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Latest commit:\"), -1));\n        }\n      else\n        len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      if (parent)\n        len = MAX (len, g_utf8_strlen (_(\"Parent:\"), -1));\n      if (alt_id)\n        len = MAX (len, g_utf8_strlen (_(\"Alt-id:\"), -1));\n      if (eol)\n        len = MAX (len, g_utf8_strlen (_(\"End-of-life:\"), -1));\n      if (eol_rebase)\n        len = MAX (len, g_utf8_strlen (_(\"End-of-life-rebase:\"), -1));\n      if (subpaths[0] != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Subdirectories:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Extension:\"), -1));\n\n      width = cols - (len + 1);\n\n      print_aligned_take (len, _(\"ID:\"), flatpak_decomposed_dup_id (ref));\n      print_aligned (len, _(\"Ref:\"), flatpak_decomposed_get_ref (ref));\n      print_aligned_take (len, _(\"Arch:\"), flatpak_decomposed_dup_arch (ref));\n      print_aligned_take (len, _(\"Branch:\"), flatpak_decomposed_dup_branch (ref));\n      if (version)\n        print_aligned (len, _(\"Version:\"), version);\n      if (license)\n        print_aligned (len, _(\"License:\"), license);\n      print_aligned (len, _(\"Origin:\"), origin ? origin : \"-\");\n      if (collection_id)\n        print_aligned (len, _(\"Collection:\"), collection_id);\n      print_aligned (len, _(\"Installation:\"), flatpak_dir_get_name_cached (dir));\n      print_aligned (len, _(\"Installed:\"), formatted_size);\n      if (flatpak_decomposed_is_app (ref))\n        {\n          g_autofree char *runtime = NULL;\n          runtime = g_key_file_get_string (metakey,\n                                           FLATPAK_METADATA_GROUP_APPLICATION,\n                                           FLATPAK_METADATA_KEY_RUNTIME,\n                                           error);\n          print_aligned (len, _(\"Runtime:\"), runtime ? runtime : \"-\");\n        }\n      if (flatpak_decomposed_is_app (ref))\n        {\n          g_autofree char *sdk = NULL;\n          sdk = g_key_file_get_string (metakey,\n                                       FLATPAK_METADATA_GROUP_APPLICATION,\n                                       FLATPAK_METADATA_KEY_SDK,\n                                       error);\n          print_aligned (len, _(\"Sdk:\"), sdk ? sdk : \"-\");\n        }\n      g_print (\"\\n\");\n\n      if (strcmp (commit, latest) != 0)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (commit, width);\n          print_aligned (len, _(\"Active commit:\"), formatted_commit);\n          g_free (formatted_commit);\n          formatted_commit = ellipsize_string (latest, width);\n          print_aligned (len, _(\"Latest commit:\"), formatted_commit);\n        }\n      else\n        {\n          g_autofree char *formatted_commit = ellipsize_string (commit, width);\n          print_aligned (len, _(\"Commit:\"), formatted_commit);\n        }\n      if (parent)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (parent, width);\n          print_aligned (len, _(\"Parent:\"), formatted_commit);\n        }\n      if (subject)\n        print_aligned (len, _(\"Subject:\"), subject);\n      if (formatted_timestamp)\n        print_aligned (len, _(\"Date:\"), formatted_timestamp);\n      if (subpaths[0] != NULL)\n        {\n          g_autofree char *s = g_strjoinv (\",\", (char **) subpaths);\n          print_aligned (len, _(\"Subdirectories:\"), s);\n        }\n\n      if (alt_id)\n        print_aligned (len, _(\"Alt-id:\"), alt_id);\n      if (eol)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol, width);\n          print_aligned (len, _(\"End-of-life:\"), formatted_eol);\n        }\n      if (eol_rebase)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol_rebase, width);\n          print_aligned (len, _(\"End-of-life-rebase:\"), formatted_eol);\n        }\n    }\n  else\n    {\n      if (opt_show_ref)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", flatpak_decomposed_get_ref (ref));\n        }\n\n      if (opt_show_origin)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", origin ? origin : \"-\");\n        }\n\n      if (opt_show_commit)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", commit);\n        }\n\n      if (opt_show_size)\n        {\n          maybe_print_space (&first);\n          g_print (\"%\" G_GUINT64_FORMAT, size);\n        }\n\n      if (opt_show_location)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", path);\n        }\n\n      if (opt_show_runtime)\n        {\n          g_autofree char *runtime = NULL;\n          maybe_print_space (&first);\n\n          runtime = g_key_file_get_string (metakey,\n                                           flatpak_decomposed_get_kind_metadata_group (ref),\n                                           FLATPAK_METADATA_KEY_RUNTIME,\n                                           NULL);\n          g_print (\"%s\", runtime ? runtime : \"-\");\n        }\n\n      if (opt_show_sdk)\n        {\n          g_autofree char *sdk = NULL;\n          maybe_print_space (&first);\n\n          sdk = g_key_file_get_string (metakey,\n                                       flatpak_decomposed_get_kind_metadata_group (ref),\n                                       FLATPAK_METADATA_KEY_SDK,\n                                       NULL);\n          g_print (\"%s\", sdk ? sdk : \"-\");\n        }\n\n      if (!first)\n        g_print (\"\\n\");\n\n      if (opt_show_metadata)\n        {\n          g_autoptr(GFile) file = NULL;\n          g_autofree char *data = NULL;\n          gsize data_size;\n\n          file = g_file_get_child (deploy_dir, \"metadata\");\n\n          if (!g_file_load_contents (file, cancellable, &data, &data_size, NULL, error))\n            return FALSE;\n\n          flatpak_print_escaped_string (data,\n                                        FLATPAK_ESCAPE_ALLOW_NEWLINES\n                                        | FLATPAK_ESCAPE_DO_NOT_QUOTE);\n        }\n\n      if (opt_show_permissions || opt_file_access)\n        {\n          g_autoptr(FlatpakContext) app_context = NULL;\n          g_autoptr(GKeyFile) keyfile = NULL;\n          g_autofree gchar *contents = NULL;\n\n          app_context = flatpak_context_load_for_deploy (deploy, error);\n          if (app_context == NULL)\n            return FALSE;\n\n          if (opt_show_permissions)\n            {\n              keyfile = g_key_file_new ();\n              flatpak_context_save_metadata (app_context, TRUE, keyfile);\n              contents = g_key_file_to_data (keyfile, NULL, error);\n              if (contents == NULL)\n                return FALSE;\n\n              flatpak_print_escaped_string (contents,\n                                            FLATPAK_ESCAPE_ALLOW_NEWLINES\n                                            | FLATPAK_ESCAPE_DO_NOT_QUOTE);\n            }\n\n          if (opt_file_access)\n            {\n              g_autofree char *id = flatpak_decomposed_dup_id (ref);\n              g_autoptr(FlatpakExports) exports = flatpak_context_get_exports (app_context, id);\n              FlatpakFilesystemMode mode;\n\n              mode = flatpak_exports_path_get_mode (exports, opt_file_access);\n              if (mode == 0)\n                g_print (\"hidden\\n\");\n              else if (mode == FLATPAK_FILESYSTEM_MODE_READ_ONLY)\n                g_print (\"read-only\\n\");\n              else\n                g_print (\"read-write\\n\");\n            }\n        }\n    }\n\n  if (opt_show_extensions)\n    {\n      GList *extensions, *l;\n      g_autofree char *ref_arch = flatpak_decomposed_dup_arch (ref);\n      g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);\n\n      len = MAX (len, g_utf8_strlen (_(\"Extension:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Origin:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Subpaths:\"), -1));\n\n      flatpak_get_window_size (&rows, &cols);\n      width = cols - (len + 1);\n\n      extensions = flatpak_list_extensions (metakey, ref_arch, ref_branch);\n      for (l = extensions; l; l = l->next)\n        {\n          FlatpakExtension *ext = l->data;\n          g_autofree const char **ext_subpaths = NULL;\n          g_autoptr(GBytes) ext_deploy_data = NULL;\n          g_autofree char *formatted = NULL;\n          g_autofree char *ext_formatted_size = NULL;\n          g_autofree char *formatted_commit = NULL;\n\n          if (ext->is_unmaintained)\n            {\n              formatted_commit = g_strdup (_(\"unmaintained\"));\n              origin = NULL;\n              size = 0;\n              ext_formatted_size = g_strdup (_(\"unknown\"));\n              ext_subpaths = NULL;\n            }\n          else\n            {\n              ext_deploy_data = flatpak_dir_get_deploy_data (dir, ext->ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);\n              if (ext_deploy_data == NULL)\n                return FALSE;\n\n              commit = flatpak_deploy_data_get_commit (ext_deploy_data);\n              formatted_commit = ellipsize_string (commit, width);\n              origin = flatpak_deploy_data_get_origin (ext_deploy_data);\n              size = flatpak_deploy_data_get_installed_size (ext_deploy_data);\n              formatted = g_format_size (size);\n              ext_subpaths = flatpak_deploy_data_get_subpaths (ext_deploy_data);\n              if (ext_subpaths && ext_subpaths[0] && size > 0)\n                ext_formatted_size = g_strconcat (\"<\", formatted, NULL);\n              else\n                ext_formatted_size = g_steal_pointer (&formatted);\n            }\n\n          g_print (\"\\n\");\n          print_aligned (len, _(\"Extension:\"), flatpak_decomposed_get_ref (ext->ref));\n          print_aligned (len, _(\"ID:\"), ext->id);\n          print_aligned (len, _(\"Origin:\"), origin ? origin : \"-\");\n          print_aligned (len, _(\"Commit:\"), formatted_commit);\n          print_aligned (len, _(\"Installed:\"), ext_formatted_size);\n\n          if (ext_subpaths && ext_subpaths[0])\n            {\n              g_autofree char *s = g_strjoinv (\",\", (char **) ext_subpaths);\n              print_aligned (len, _(\"Subpaths:\"), s);\n            }\n        }\n\n      g_list_free_full (extensions, (GDestroyNotify) flatpak_extension_free);\n    }\n\n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -318,7 +318,9 @@\n           if (!g_file_load_contents (file, cancellable, &data, &data_size, NULL, error))\n             return FALSE;\n \n-          g_print (\"%s\", data);\n+          flatpak_print_escaped_string (data,\n+                                        FLATPAK_ESCAPE_ALLOW_NEWLINES\n+                                        | FLATPAK_ESCAPE_DO_NOT_QUOTE);\n         }\n \n       if (opt_show_permissions || opt_file_access)\n@@ -339,7 +341,9 @@\n               if (contents == NULL)\n                 return FALSE;\n \n-              g_print (\"%s\", contents);\n+              flatpak_print_escaped_string (contents,\n+                                            FLATPAK_ESCAPE_ALLOW_NEWLINES\n+                                            | FLATPAK_ESCAPE_DO_NOT_QUOTE);\n             }\n \n           if (opt_file_access)",
        "diff_line_info": {
            "deleted_lines": [
                "          g_print (\"%s\", data);",
                "              g_print (\"%s\", contents);"
            ],
            "added_lines": [
                "          flatpak_print_escaped_string (data,",
                "                                        FLATPAK_ESCAPE_ALLOW_NEWLINES",
                "                                        | FLATPAK_ESCAPE_DO_NOT_QUOTE);",
                "              flatpak_print_escaped_string (contents,",
                "                                            FLATPAK_ESCAPE_ALLOW_NEWLINES",
                "                                            | FLATPAK_ESCAPE_DO_NOT_QUOTE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28101",
        "func_name": "flatpak/print_perm_line",
        "description": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they can hide those permissions from users of the `flatpak(1)` command-line interface by setting other permissions to crafted values that contain non-printable control characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line interface, or only install apps whose maintainers you trust.",
        "git_url": "https://github.com/flatpak/flatpak/commit/6cac99dafe6003c8a4bd5666341c217876536869",
        "commit_title": "Ensure special characters in permissions and metadata are escaped",
        "commit_text": " This prevents someone from placing special characters in order to manipulate the appearance of the permissions list.  CVE-2023-28101, GHSA-h43h-fwqx-mpp8 ",
        "func_before": "static void\nprint_perm_line (int        idx,\n                 GPtrArray *items,\n                 int        cols)\n{\n  g_autoptr(GString) res = g_string_new (NULL);\n  int i;\n\n  g_string_append_printf (res, \"    [%d] %s\", idx, (char *) items->pdata[0]);\n\n  for (i = 1; i < items->len; i++)\n    {\n      char *p;\n      int len;\n\n      p = strrchr (res->str, '\\n');\n      if (!p)\n        p = res->str;\n\n      len = (res->str + strlen (res->str)) - p;\n      if (len + strlen ((char *) items->pdata[i]) + 2 >= cols)\n        g_string_append_printf (res, \",\\n        %s\", (char *) items->pdata[i]);\n      else\n        g_string_append_printf (res, \", %s\", (char *) items->pdata[i]);\n    }\n\n  g_print (\"%s\\n\", res->str);\n}",
        "func": "static void\nprint_perm_line (int        idx,\n                 GPtrArray *items,\n                 int        cols)\n{\n  g_autoptr(GString) res = g_string_new (NULL);\n  g_autofree char *escaped_first_perm = NULL;\n  int i;\n\n  escaped_first_perm = flatpak_escape_string (items->pdata[0], FLATPAK_ESCAPE_DEFAULT);\n  g_string_append_printf (res, \"    [%d] %s\", idx, escaped_first_perm);\n\n  for (i = 1; i < items->len; i++)\n    {\n      g_autofree char *escaped = flatpak_escape_string (items->pdata[i],\n                                                        FLATPAK_ESCAPE_DEFAULT);\n      char *p;\n      int len;\n\n      p = strrchr (res->str, '\\n');\n      if (!p)\n        p = res->str;\n\n      len = (res->str + strlen (res->str)) - p;\n      if (len + strlen (escaped) + 2 >= cols)\n        g_string_append_printf (res, \",\\n        %s\", escaped);\n      else\n        g_string_append_printf (res, \", %s\", escaped);\n    }\n\n  g_print (\"%s\\n\", res->str);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,12 +4,16 @@\n                  int        cols)\n {\n   g_autoptr(GString) res = g_string_new (NULL);\n+  g_autofree char *escaped_first_perm = NULL;\n   int i;\n \n-  g_string_append_printf (res, \"    [%d] %s\", idx, (char *) items->pdata[0]);\n+  escaped_first_perm = flatpak_escape_string (items->pdata[0], FLATPAK_ESCAPE_DEFAULT);\n+  g_string_append_printf (res, \"    [%d] %s\", idx, escaped_first_perm);\n \n   for (i = 1; i < items->len; i++)\n     {\n+      g_autofree char *escaped = flatpak_escape_string (items->pdata[i],\n+                                                        FLATPAK_ESCAPE_DEFAULT);\n       char *p;\n       int len;\n \n@@ -18,10 +22,10 @@\n         p = res->str;\n \n       len = (res->str + strlen (res->str)) - p;\n-      if (len + strlen ((char *) items->pdata[i]) + 2 >= cols)\n-        g_string_append_printf (res, \",\\n        %s\", (char *) items->pdata[i]);\n+      if (len + strlen (escaped) + 2 >= cols)\n+        g_string_append_printf (res, \",\\n        %s\", escaped);\n       else\n-        g_string_append_printf (res, \", %s\", (char *) items->pdata[i]);\n+        g_string_append_printf (res, \", %s\", escaped);\n     }\n \n   g_print (\"%s\\n\", res->str);",
        "diff_line_info": {
            "deleted_lines": [
                "  g_string_append_printf (res, \"    [%d] %s\", idx, (char *) items->pdata[0]);",
                "      if (len + strlen ((char *) items->pdata[i]) + 2 >= cols)",
                "        g_string_append_printf (res, \",\\n        %s\", (char *) items->pdata[i]);",
                "        g_string_append_printf (res, \", %s\", (char *) items->pdata[i]);"
            ],
            "added_lines": [
                "  g_autofree char *escaped_first_perm = NULL;",
                "  escaped_first_perm = flatpak_escape_string (items->pdata[0], FLATPAK_ESCAPE_DEFAULT);",
                "  g_string_append_printf (res, \"    [%d] %s\", idx, escaped_first_perm);",
                "      g_autofree char *escaped = flatpak_escape_string (items->pdata[i],",
                "                                                        FLATPAK_ESCAPE_DEFAULT);",
                "      if (len + strlen (escaped) + 2 >= cols)",
                "        g_string_append_printf (res, \",\\n        %s\", escaped);",
                "        g_string_append_printf (res, \", %s\", escaped);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28101",
        "func_name": "flatpak/load_kernel_module_list",
        "description": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they can hide those permissions from users of the `flatpak(1)` command-line interface by setting other permissions to crafted values that contain non-printable control characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line interface, or only install apps whose maintainers you trust.",
        "git_url": "https://github.com/flatpak/flatpak/commit/6cac99dafe6003c8a4bd5666341c217876536869",
        "commit_title": "Ensure special characters in permissions and metadata are escaped",
        "commit_text": " This prevents someone from placing special characters in order to manipulate the appearance of the permissions list.  CVE-2023-28101, GHSA-h43h-fwqx-mpp8 ",
        "func_before": "static GHashTable *\nload_kernel_module_list (void)\n{\n  GHashTable *modules = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  g_autofree char *modules_data = NULL;\n  g_autoptr(GError) error = NULL;\n  char *start, *end;\n  \n  if (!g_file_get_contents (\"/proc/modules\", &modules_data, NULL, &error))\n    {\n      g_info (\"Failed to read /proc/modules: %s\", error->message);\n      return modules;\n    }\n\n  /* /proc/modules is a table of modules.\n   * Columns are split by spaces and rows by newlines.\n   * The first column is the name. */\n  start = modules_data;\n  while (TRUE)\n    {\n      end = strchr (start, ' ');\n      if (end == NULL)\n        break;\n\n      g_hash_table_add (modules, g_strndup (start, (end - start)));\n\n      start = strchr (end, '\\n');\n      if (start == NULL)\n        break;\n\n      start++;\n    }\n\n  return modules;\n}",
        "func": "static GHashTable *\nload_kernel_module_list (void)\n{\n  GHashTable *modules = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  g_autofree char *modules_data = NULL;\n  g_autoptr(GError) error = NULL;\n  char *start, *end;\n\n  if (!g_file_get_contents (\"/proc/modules\", &modules_data, NULL, &error))\n    {\n      g_info (\"Failed to read /proc/modules: %s\", error->message);\n      return modules;\n    }\n\n  /* /proc/modules is a table of modules.\n   * Columns are split by spaces and rows by newlines.\n   * The first column is the name. */\n  start = modules_data;\n  while (TRUE)\n    {\n      end = strchr (start, ' ');\n      if (end == NULL)\n        break;\n\n      g_hash_table_add (modules, g_strndup (start, (end - start)));\n\n      start = strchr (end, '\\n');\n      if (start == NULL)\n        break;\n\n      start++;\n    }\n\n  return modules;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n   g_autofree char *modules_data = NULL;\n   g_autoptr(GError) error = NULL;\n   char *start, *end;\n-  \n+\n   if (!g_file_get_contents (\"/proc/modules\", &modules_data, NULL, &error))\n     {\n       g_info (\"Failed to read /proc/modules: %s\", error->message);",
        "diff_line_info": {
            "deleted_lines": [
                "  "
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28101",
        "func_name": "flatpak/flatpak_builtin_remote_info",
        "description": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they can hide those permissions from users of the `flatpak(1)` command-line interface by setting other permissions to crafted values that contain non-printable control characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line interface, or only install apps whose maintainers you trust.",
        "git_url": "https://github.com/flatpak/flatpak/commit/6cac99dafe6003c8a4bd5666341c217876536869",
        "commit_title": "Ensure special characters in permissions and metadata are escaped",
        "commit_text": " This prevents someone from placing special characters in order to manipulate the appearance of the permissions list.  CVE-2023-28101, GHSA-h43h-fwqx-mpp8 ",
        "func_before": "gboolean\nflatpak_builtin_remote_info (int argc, char **argv, GCancellable *cancellable, GError **error)\n{\n  g_autoptr(GOptionContext) context = NULL;\n  g_autoptr(GPtrArray) dirs = NULL;\n  g_autoptr(FlatpakDir) preferred_dir = NULL;\n  g_autoptr(GVariant) commit_v = NULL;\n  const char *remote;\n  const char *pref;\n  g_autofree char *default_branch = NULL;\n  FlatpakKinds kinds;\n  FlatpakKinds matched_kinds;\n  g_autofree char *match_id = NULL;\n  g_autofree char *match_arch = NULL;\n  g_autofree char *match_branch = NULL;\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n  g_autofree char *commit = NULL;\n  g_autofree char *parent = NULL;\n  g_autoptr(FlatpakRemoteState) state = NULL;\n  gboolean friendly = TRUE;\n  const char *xa_metadata = NULL;\n  const char *collection_id = NULL;\n  const char *eol = NULL;\n  const char *eol_rebase = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  guint64 installed_size = 0;\n  guint64 download_size = 0;\n  g_autofree char *formatted_installed_size = NULL;\n  g_autofree char *formatted_download_size = NULL;\n  const gchar *subject = NULL;\n  guint64 timestamp;\n  g_autofree char *formatted_timestamp = NULL;\n  VarMetadataRef sparse_cache;\n\n  context = g_option_context_new (_(\" REMOTE REF - Show information about an application or runtime in a remote\"));\n  g_option_context_set_translation_domain (context, GETTEXT_PACKAGE);\n\n  if (!flatpak_option_context_parse (context, options, &argc, &argv,\n                                     FLATPAK_BUILTIN_FLAG_STANDARD_DIRS, &dirs, cancellable, error))\n    return FALSE;\n\n  if (!opt_app && !opt_runtime)\n    opt_app = opt_runtime = TRUE;\n\n  if (argc < 3)\n    return usage_error (context, _(\"REMOTE and REF must be specified\"), error);\n\n  remote = argv[1];\n  pref = argv[2];\n\n  if (!flatpak_resolve_duplicate_remotes (dirs, remote, &preferred_dir, cancellable, error))\n    return FALSE;\n\n  default_branch = flatpak_dir_get_remote_default_branch (preferred_dir, remote);\n  kinds = flatpak_kinds_from_bools (opt_app, opt_runtime);\n\n  if (!flatpak_split_partial_ref_arg (pref, kinds, opt_arch, NULL,\n                                      &matched_kinds, &match_id, &match_arch, &match_branch, error))\n    return FALSE;\n\n  state = get_remote_state (preferred_dir, remote, opt_cached, opt_sideloaded, match_arch, NULL, NULL, error);\n  if (state == NULL)\n    return FALSE;\n\n  ref = flatpak_dir_find_remote_ref (preferred_dir, state, match_id, match_branch, default_branch, match_arch,\n                                     matched_kinds, cancellable, error);\n  if (ref == NULL)\n    return FALSE;\n\n  if (opt_cached)\n    {\n      if (opt_commit)\n        commit = g_strdup (opt_commit);\n      else if (!flatpak_remote_state_lookup_ref (state, flatpak_decomposed_get_ref (ref),\n                                                 &commit, NULL, NULL, NULL, error))\n        {\n          g_assert (error == NULL || *error != NULL);\n          return FALSE;\n        }\n    }\n  else\n    {\n      commit_v = flatpak_remote_state_load_ref_commit (state, preferred_dir, flatpak_decomposed_get_ref (ref),\n                                                       opt_commit, NULL, &commit, cancellable, error);\n      if (commit_v == NULL)\n        return FALSE;\n    }\n\n  if (flatpak_remote_state_lookup_sparse_cache (state, flatpak_decomposed_get_ref (ref),\n                                                &sparse_cache, NULL))\n    {\n      eol = var_metadata_lookup_string (sparse_cache, FLATPAK_SPARSE_CACHE_KEY_ENDOFLINE, NULL);\n      eol_rebase = var_metadata_lookup_string (sparse_cache, FLATPAK_SPARSE_CACHE_KEY_ENDOFLINE_REBASE, NULL);\n    }\n\n  if (opt_show_ref || opt_show_commit || opt_show_parent || opt_show_metadata || opt_show_runtime || opt_show_sdk)\n    friendly = FALSE;\n\n  if (friendly)\n    {\n      int len;\n      int rows, cols;\n      int width;\n      g_autoptr(AsMetadata) mdata = as_metadata_new ();\n      AsComponent *app = NULL;\n      const char *version = NULL;\n      const char *license = NULL;\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n\n      flatpak_get_window_size (&rows, &cols);\n\n      flatpak_dir_load_appstream_store (preferred_dir, remote, id, mdata, NULL, NULL);\n      app = as_store_find_app (mdata, flatpak_decomposed_get_ref (ref));\n      if (app)\n        {\n          const char *name = as_component_get_name (app);\n          const char *comment = as_component_get_summary (app);\n\n          print_wrapped (MIN (cols, 80), \"\\n%s - %s\\n\", name, comment);\n\n          version = as_app_get_version (app);\n          license = as_component_get_project_license (app);\n        }\n\n      if (commit_v)\n        {\n          VarCommitRef var_commit = var_commit_from_gvariant (commit_v);\n          VarMetadataRef commit_metadata;\n\n          subject = var_commit_get_subject (var_commit);\n          parent = ostree_commit_get_parent (commit_v);\n          timestamp = ostree_commit_get_timestamp (commit_v);\n\n          commit_metadata = var_commit_get_metadata (var_commit);\n          xa_metadata = var_metadata_lookup_string (commit_metadata, \"xa.metadata\", NULL);\n\n          if (xa_metadata == NULL)\n            g_printerr (_(\"Warning: Commit has no flatpak metadata\\n\"));\n          else\n            {\n              metakey = g_key_file_new ();\n              if (!g_key_file_load_from_data (metakey, xa_metadata, -1, 0, error))\n                return FALSE;\n            }\n\n          collection_id = var_metadata_lookup_string (commit_metadata, \"ostree.collection-binding\", NULL);\n\n          installed_size = GUINT64_FROM_BE (var_metadata_lookup_uint64 (commit_metadata, \"xa.installed-size\", 0));\n          download_size = GUINT64_FROM_BE (var_metadata_lookup_uint64 (commit_metadata, \"xa.download-size\", 0));\n\n          formatted_installed_size = g_format_size (installed_size);\n          formatted_download_size = g_format_size (download_size);\n          formatted_timestamp = format_timestamp (timestamp);\n        }\n\n      len = 0;\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Ref:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Arch:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Branch:\"), -1));\n      if (version != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Version:\"), -1));\n      if (license != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"License:\"), -1));\n      if (collection_id != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Collection:\"), -1));\n      if (formatted_download_size)\n        len = MAX (len, g_utf8_strlen (_(\"Download:\"), -1));\n      if (formatted_installed_size)\n        len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      if (flatpak_decomposed_is_app (ref) == 0 && metakey != NULL)\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Runtime:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Sdk:\"), -1));\n        }\n      if (formatted_timestamp)\n        len = MAX (len, g_utf8_strlen (_(\"Date:\"), -1));\n      if (subject)\n        len = MAX (len, g_utf8_strlen (_(\"Subject:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      if (parent)\n        len = MAX (len, g_utf8_strlen (_(\"Parent:\"), -1));\n      if (eol)\n        len = MAX (len, strlen (_(\"End-of-life:\")));\n      if (eol_rebase)\n        len = MAX (len, strlen (_(\"End-of-life-rebase:\")));\n      if (opt_log)\n        len = MAX (len, g_utf8_strlen (_(\"History:\"), -1));\n\n      width = cols - (len + 1);\n\n      print_aligned (len, _(\"ID:\"), id);\n      print_aligned (len, _(\"Ref:\"), flatpak_decomposed_get_ref (ref));\n      print_aligned_take (len, _(\"Arch:\"), flatpak_decomposed_dup_arch (ref));\n      print_aligned_take (len, _(\"Branch:\"), flatpak_decomposed_dup_branch (ref));\n      if (version != NULL)\n        print_aligned (len, _(\"Version:\"), version);\n      if (license != NULL)\n        print_aligned (len, _(\"License:\"), license);\n      if (collection_id != NULL)\n        print_aligned (len, _(\"Collection:\"), collection_id);\n      if (formatted_download_size)\n        print_aligned (len, _(\"Download:\"), formatted_download_size);\n      if (formatted_installed_size)\n        print_aligned (len, _(\"Installed:\"), formatted_installed_size);\n      if (flatpak_decomposed_is_app (ref) && metakey != NULL)\n        {\n          g_autofree char *runtime = g_key_file_get_string (metakey, \"Application\", \"runtime\", error);\n          print_aligned (len, _(\"Runtime:\"), runtime ? runtime : \"-\");\n        }\n      if (flatpak_decomposed_is_app (ref) && metakey != NULL)\n        {\n          g_autofree char *sdk = g_key_file_get_string (metakey, \"Application\", \"sdk\", error);\n          print_aligned (len, _(\"Sdk:\"), sdk ? sdk : \"-\");\n        }\n      g_print (\"\\n\");\n      {\n        g_autofree char *formatted_commit = ellipsize_string (commit, width);\n        print_aligned (len, _(\"Commit:\"), formatted_commit);\n      }\n      if (parent)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (parent, width);\n          print_aligned (len, _(\"Parent:\"), formatted_commit);\n        }\n      if (eol)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol, width);\n          print_aligned (len, _(\"End-of-life:\"), formatted_eol);\n        }\n      if (eol_rebase)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol_rebase, width);\n          print_aligned (len, _(\"End-of-life-rebase:\"), formatted_eol);\n        }\n\n      if (subject)\n        print_aligned (len, _(\"Subject:\"), subject);\n      if (formatted_timestamp)\n        print_aligned (len, _(\"Date:\"), formatted_timestamp);\n\n      if (opt_log)\n        {\n          g_autofree char *p = g_strdup (parent);\n\n          print_aligned (len, _(\"History:\"), \"\\n\");\n\n          while (p)\n            {\n              g_autofree char *p_parent = NULL;\n              const gchar *p_subject;\n              guint64 p_timestamp;\n              g_autofree char *p_formatted_timestamp = NULL;\n              g_autoptr(GVariant) p_commit_v = NULL;\n              VarCommitRef p_commit;\n\n              p_commit_v = flatpak_remote_state_load_ref_commit (state, preferred_dir, flatpak_decomposed_get_ref (ref),\n                                                                 p, NULL, NULL, cancellable, NULL);\n              if (p_commit_v == NULL)\n                break;\n\n              p_parent = ostree_commit_get_parent (p_commit_v);\n              p_timestamp = ostree_commit_get_timestamp (p_commit_v);\n              p_formatted_timestamp = format_timestamp (p_timestamp);\n\n              p_commit = var_commit_from_gvariant (p_commit_v);\n              p_subject = var_commit_get_subject (p_commit);\n\n              print_aligned (len, _(\" Commit:\"), p);\n              print_aligned (len, _(\" Subject:\"), p_subject);\n              print_aligned (len, _(\" Date:\"), p_formatted_timestamp);\n\n              g_free (p);\n              p = g_steal_pointer (&p_parent);\n              if (p)\n                g_print (\"\\n\");\n            }\n        }\n    }\n  else\n    {\n      g_autoptr(GVariant) c_v = NULL;\n      g_autofree char *c = g_strdup (commit);\n\n      if (commit_v)\n        c_v = g_variant_ref (commit_v);\n\n      do\n        {\n          g_autofree char *p = NULL;\n          g_autoptr(GVariant) c_m = NULL;\n          gboolean first = TRUE;\n\n          if (c_v)\n            {\n              c_m = g_variant_get_child_value (c_v, 0);\n              p = ostree_commit_get_parent (c_v);\n            }\n\n          if (c_m)\n            {\n              g_variant_lookup (c_m, \"xa.metadata\", \"&s\", &xa_metadata);\n              if (xa_metadata == NULL)\n                g_printerr (_(\"Warning: Commit %s has no flatpak metadata\\n\"), c);\n              else\n                {\n                  metakey = g_key_file_new ();\n                  if (!g_key_file_load_from_data (metakey, xa_metadata, -1, 0, error))\n                    return FALSE;\n                }\n            }\n\n          if (opt_show_ref)\n            {\n              maybe_print_space (&first);\n              g_print (\"%s\", flatpak_decomposed_get_ref (ref));\n            }\n\n          if (opt_show_commit)\n            {\n              maybe_print_space (&first);\n              g_print (\"%s\", c);\n            }\n\n          if (opt_show_parent)\n            {\n              maybe_print_space (&first);\n              g_print (\"%s\", p ? p : \"-\");\n            }\n\n          if (opt_show_runtime)\n            {\n              g_autofree char *runtime = NULL;\n              maybe_print_space (&first);\n\n              if (metakey)\n                runtime = g_key_file_get_string (metakey, flatpak_decomposed_get_kind_metadata_group (ref), \"runtime\", NULL);\n              g_print (\"%s\", runtime ? runtime : \"-\");\n            }\n\n          if (opt_show_sdk)\n            {\n              g_autofree char *sdk = NULL;\n              maybe_print_space (&first);\n\n              if (metakey)\n                sdk = g_key_file_get_string (metakey, flatpak_decomposed_get_kind_metadata_group (ref), \"sdk\", NULL);\n              g_print (\"%s\", sdk ? sdk : \"-\");\n            }\n\n          if (!first)\n            g_print (\"\\n\");\n\n          if (opt_show_metadata)\n            {\n              g_print (\"%s\", xa_metadata ? xa_metadata : \"\");\n              if (xa_metadata == NULL || !g_str_has_suffix (xa_metadata, \"\\n\"))\n                g_print (\"\\n\");\n            }\n\n          g_free (c);\n          c = g_steal_pointer (&p);\n\n          if (c_v)\n            g_variant_unref (c_v);\n          c_v = NULL;\n\n          if (c && opt_log)\n            c_v = flatpak_remote_state_load_ref_commit (state, preferred_dir,\n                                                        flatpak_decomposed_get_ref (ref),\n                                                        c, NULL, NULL, cancellable, NULL);\n        }\n      while (c_v != NULL);\n    }\n\n  return TRUE;\n}",
        "func": "gboolean\nflatpak_builtin_remote_info (int argc, char **argv, GCancellable *cancellable, GError **error)\n{\n  g_autoptr(GOptionContext) context = NULL;\n  g_autoptr(GPtrArray) dirs = NULL;\n  g_autoptr(FlatpakDir) preferred_dir = NULL;\n  g_autoptr(GVariant) commit_v = NULL;\n  const char *remote;\n  const char *pref;\n  g_autofree char *default_branch = NULL;\n  FlatpakKinds kinds;\n  FlatpakKinds matched_kinds;\n  g_autofree char *match_id = NULL;\n  g_autofree char *match_arch = NULL;\n  g_autofree char *match_branch = NULL;\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n  g_autofree char *commit = NULL;\n  g_autofree char *parent = NULL;\n  g_autoptr(FlatpakRemoteState) state = NULL;\n  gboolean friendly = TRUE;\n  const char *xa_metadata = NULL;\n  const char *collection_id = NULL;\n  const char *eol = NULL;\n  const char *eol_rebase = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  guint64 installed_size = 0;\n  guint64 download_size = 0;\n  g_autofree char *formatted_installed_size = NULL;\n  g_autofree char *formatted_download_size = NULL;\n  const gchar *subject = NULL;\n  guint64 timestamp;\n  g_autofree char *formatted_timestamp = NULL;\n  VarMetadataRef sparse_cache;\n\n  context = g_option_context_new (_(\" REMOTE REF - Show information about an application or runtime in a remote\"));\n  g_option_context_set_translation_domain (context, GETTEXT_PACKAGE);\n\n  if (!flatpak_option_context_parse (context, options, &argc, &argv,\n                                     FLATPAK_BUILTIN_FLAG_STANDARD_DIRS, &dirs, cancellable, error))\n    return FALSE;\n\n  if (!opt_app && !opt_runtime)\n    opt_app = opt_runtime = TRUE;\n\n  if (argc < 3)\n    return usage_error (context, _(\"REMOTE and REF must be specified\"), error);\n\n  remote = argv[1];\n  pref = argv[2];\n\n  if (!flatpak_resolve_duplicate_remotes (dirs, remote, &preferred_dir, cancellable, error))\n    return FALSE;\n\n  default_branch = flatpak_dir_get_remote_default_branch (preferred_dir, remote);\n  kinds = flatpak_kinds_from_bools (opt_app, opt_runtime);\n\n  if (!flatpak_split_partial_ref_arg (pref, kinds, opt_arch, NULL,\n                                      &matched_kinds, &match_id, &match_arch, &match_branch, error))\n    return FALSE;\n\n  state = get_remote_state (preferred_dir, remote, opt_cached, opt_sideloaded, match_arch, NULL, NULL, error);\n  if (state == NULL)\n    return FALSE;\n\n  ref = flatpak_dir_find_remote_ref (preferred_dir, state, match_id, match_branch, default_branch, match_arch,\n                                     matched_kinds, cancellable, error);\n  if (ref == NULL)\n    return FALSE;\n\n  if (opt_cached)\n    {\n      if (opt_commit)\n        commit = g_strdup (opt_commit);\n      else if (!flatpak_remote_state_lookup_ref (state, flatpak_decomposed_get_ref (ref),\n                                                 &commit, NULL, NULL, NULL, error))\n        {\n          g_assert (error == NULL || *error != NULL);\n          return FALSE;\n        }\n    }\n  else\n    {\n      commit_v = flatpak_remote_state_load_ref_commit (state, preferred_dir, flatpak_decomposed_get_ref (ref),\n                                                       opt_commit, NULL, &commit, cancellable, error);\n      if (commit_v == NULL)\n        return FALSE;\n    }\n\n  if (flatpak_remote_state_lookup_sparse_cache (state, flatpak_decomposed_get_ref (ref),\n                                                &sparse_cache, NULL))\n    {\n      eol = var_metadata_lookup_string (sparse_cache, FLATPAK_SPARSE_CACHE_KEY_ENDOFLINE, NULL);\n      eol_rebase = var_metadata_lookup_string (sparse_cache, FLATPAK_SPARSE_CACHE_KEY_ENDOFLINE_REBASE, NULL);\n    }\n\n  if (opt_show_ref || opt_show_commit || opt_show_parent || opt_show_metadata || opt_show_runtime || opt_show_sdk)\n    friendly = FALSE;\n\n  if (friendly)\n    {\n      int len;\n      int rows, cols;\n      int width;\n      g_autoptr(AsMetadata) mdata = as_metadata_new ();\n      AsComponent *app = NULL;\n      const char *version = NULL;\n      const char *license = NULL;\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n\n      flatpak_get_window_size (&rows, &cols);\n\n      flatpak_dir_load_appstream_store (preferred_dir, remote, id, mdata, NULL, NULL);\n      app = as_store_find_app (mdata, flatpak_decomposed_get_ref (ref));\n      if (app)\n        {\n          const char *name = as_component_get_name (app);\n          const char *comment = as_component_get_summary (app);\n\n          print_wrapped (MIN (cols, 80), \"\\n%s - %s\\n\", name, comment);\n\n          version = as_app_get_version (app);\n          license = as_component_get_project_license (app);\n        }\n\n      if (commit_v)\n        {\n          VarCommitRef var_commit = var_commit_from_gvariant (commit_v);\n          VarMetadataRef commit_metadata;\n\n          subject = var_commit_get_subject (var_commit);\n          parent = ostree_commit_get_parent (commit_v);\n          timestamp = ostree_commit_get_timestamp (commit_v);\n\n          commit_metadata = var_commit_get_metadata (var_commit);\n          xa_metadata = var_metadata_lookup_string (commit_metadata, \"xa.metadata\", NULL);\n\n          if (xa_metadata == NULL)\n            g_printerr (_(\"Warning: Commit has no flatpak metadata\\n\"));\n          else\n            {\n              metakey = g_key_file_new ();\n              if (!g_key_file_load_from_data (metakey, xa_metadata, -1, 0, error))\n                return FALSE;\n            }\n\n          collection_id = var_metadata_lookup_string (commit_metadata, \"ostree.collection-binding\", NULL);\n\n          installed_size = GUINT64_FROM_BE (var_metadata_lookup_uint64 (commit_metadata, \"xa.installed-size\", 0));\n          download_size = GUINT64_FROM_BE (var_metadata_lookup_uint64 (commit_metadata, \"xa.download-size\", 0));\n\n          formatted_installed_size = g_format_size (installed_size);\n          formatted_download_size = g_format_size (download_size);\n          formatted_timestamp = format_timestamp (timestamp);\n        }\n\n      len = 0;\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Ref:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Arch:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Branch:\"), -1));\n      if (version != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Version:\"), -1));\n      if (license != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"License:\"), -1));\n      if (collection_id != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Collection:\"), -1));\n      if (formatted_download_size)\n        len = MAX (len, g_utf8_strlen (_(\"Download:\"), -1));\n      if (formatted_installed_size)\n        len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      if (flatpak_decomposed_is_app (ref) == 0 && metakey != NULL)\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Runtime:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Sdk:\"), -1));\n        }\n      if (formatted_timestamp)\n        len = MAX (len, g_utf8_strlen (_(\"Date:\"), -1));\n      if (subject)\n        len = MAX (len, g_utf8_strlen (_(\"Subject:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      if (parent)\n        len = MAX (len, g_utf8_strlen (_(\"Parent:\"), -1));\n      if (eol)\n        len = MAX (len, strlen (_(\"End-of-life:\")));\n      if (eol_rebase)\n        len = MAX (len, strlen (_(\"End-of-life-rebase:\")));\n      if (opt_log)\n        len = MAX (len, g_utf8_strlen (_(\"History:\"), -1));\n\n      width = cols - (len + 1);\n\n      print_aligned (len, _(\"ID:\"), id);\n      print_aligned (len, _(\"Ref:\"), flatpak_decomposed_get_ref (ref));\n      print_aligned_take (len, _(\"Arch:\"), flatpak_decomposed_dup_arch (ref));\n      print_aligned_take (len, _(\"Branch:\"), flatpak_decomposed_dup_branch (ref));\n      if (version != NULL)\n        print_aligned (len, _(\"Version:\"), version);\n      if (license != NULL)\n        print_aligned (len, _(\"License:\"), license);\n      if (collection_id != NULL)\n        print_aligned (len, _(\"Collection:\"), collection_id);\n      if (formatted_download_size)\n        print_aligned (len, _(\"Download:\"), formatted_download_size);\n      if (formatted_installed_size)\n        print_aligned (len, _(\"Installed:\"), formatted_installed_size);\n      if (flatpak_decomposed_is_app (ref) && metakey != NULL)\n        {\n          g_autofree char *runtime = g_key_file_get_string (metakey, \"Application\", \"runtime\", error);\n          print_aligned (len, _(\"Runtime:\"), runtime ? runtime : \"-\");\n        }\n      if (flatpak_decomposed_is_app (ref) && metakey != NULL)\n        {\n          g_autofree char *sdk = g_key_file_get_string (metakey, \"Application\", \"sdk\", error);\n          print_aligned (len, _(\"Sdk:\"), sdk ? sdk : \"-\");\n        }\n      g_print (\"\\n\");\n      {\n        g_autofree char *formatted_commit = ellipsize_string (commit, width);\n        print_aligned (len, _(\"Commit:\"), formatted_commit);\n      }\n      if (parent)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (parent, width);\n          print_aligned (len, _(\"Parent:\"), formatted_commit);\n        }\n      if (eol)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol, width);\n          print_aligned (len, _(\"End-of-life:\"), formatted_eol);\n        }\n      if (eol_rebase)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol_rebase, width);\n          print_aligned (len, _(\"End-of-life-rebase:\"), formatted_eol);\n        }\n\n      if (subject)\n        print_aligned (len, _(\"Subject:\"), subject);\n      if (formatted_timestamp)\n        print_aligned (len, _(\"Date:\"), formatted_timestamp);\n\n      if (opt_log)\n        {\n          g_autofree char *p = g_strdup (parent);\n\n          print_aligned (len, _(\"History:\"), \"\\n\");\n\n          while (p)\n            {\n              g_autofree char *p_parent = NULL;\n              const gchar *p_subject;\n              guint64 p_timestamp;\n              g_autofree char *p_formatted_timestamp = NULL;\n              g_autoptr(GVariant) p_commit_v = NULL;\n              VarCommitRef p_commit;\n\n              p_commit_v = flatpak_remote_state_load_ref_commit (state, preferred_dir, flatpak_decomposed_get_ref (ref),\n                                                                 p, NULL, NULL, cancellable, NULL);\n              if (p_commit_v == NULL)\n                break;\n\n              p_parent = ostree_commit_get_parent (p_commit_v);\n              p_timestamp = ostree_commit_get_timestamp (p_commit_v);\n              p_formatted_timestamp = format_timestamp (p_timestamp);\n\n              p_commit = var_commit_from_gvariant (p_commit_v);\n              p_subject = var_commit_get_subject (p_commit);\n\n              print_aligned (len, _(\" Commit:\"), p);\n              print_aligned (len, _(\" Subject:\"), p_subject);\n              print_aligned (len, _(\" Date:\"), p_formatted_timestamp);\n\n              g_free (p);\n              p = g_steal_pointer (&p_parent);\n              if (p)\n                g_print (\"\\n\");\n            }\n        }\n    }\n  else\n    {\n      g_autoptr(GVariant) c_v = NULL;\n      g_autofree char *c = g_strdup (commit);\n\n      if (commit_v)\n        c_v = g_variant_ref (commit_v);\n\n      do\n        {\n          g_autofree char *p = NULL;\n          g_autoptr(GVariant) c_m = NULL;\n          gboolean first = TRUE;\n\n          if (c_v)\n            {\n              c_m = g_variant_get_child_value (c_v, 0);\n              p = ostree_commit_get_parent (c_v);\n            }\n\n          if (c_m)\n            {\n              g_variant_lookup (c_m, \"xa.metadata\", \"&s\", &xa_metadata);\n              if (xa_metadata == NULL)\n                g_printerr (_(\"Warning: Commit %s has no flatpak metadata\\n\"), c);\n              else\n                {\n                  metakey = g_key_file_new ();\n                  if (!g_key_file_load_from_data (metakey, xa_metadata, -1, 0, error))\n                    return FALSE;\n                }\n            }\n\n          if (opt_show_ref)\n            {\n              maybe_print_space (&first);\n              g_print (\"%s\", flatpak_decomposed_get_ref (ref));\n            }\n\n          if (opt_show_commit)\n            {\n              maybe_print_space (&first);\n              g_print (\"%s\", c);\n            }\n\n          if (opt_show_parent)\n            {\n              maybe_print_space (&first);\n              g_print (\"%s\", p ? p : \"-\");\n            }\n\n          if (opt_show_runtime)\n            {\n              g_autofree char *runtime = NULL;\n              maybe_print_space (&first);\n\n              if (metakey)\n                runtime = g_key_file_get_string (metakey, flatpak_decomposed_get_kind_metadata_group (ref), \"runtime\", NULL);\n              g_print (\"%s\", runtime ? runtime : \"-\");\n            }\n\n          if (opt_show_sdk)\n            {\n              g_autofree char *sdk = NULL;\n              maybe_print_space (&first);\n\n              if (metakey)\n                sdk = g_key_file_get_string (metakey, flatpak_decomposed_get_kind_metadata_group (ref), \"sdk\", NULL);\n              g_print (\"%s\", sdk ? sdk : \"-\");\n            }\n\n          if (!first)\n            g_print (\"\\n\");\n\n          if (opt_show_metadata)\n            {\n              if (xa_metadata != NULL)\n                flatpak_print_escaped_string (xa_metadata,\n                                              FLATPAK_ESCAPE_ALLOW_NEWLINES\n                                              | FLATPAK_ESCAPE_DO_NOT_QUOTE);\n              if (xa_metadata == NULL || !g_str_has_suffix (xa_metadata, \"\\n\"))\n                g_print (\"\\n\");\n            }\n\n          g_free (c);\n          c = g_steal_pointer (&p);\n\n          if (c_v)\n            g_variant_unref (c_v);\n          c_v = NULL;\n\n          if (c && opt_log)\n            c_v = flatpak_remote_state_load_ref_commit (state, preferred_dir,\n                                                        flatpak_decomposed_get_ref (ref),\n                                                        c, NULL, NULL, cancellable, NULL);\n        }\n      while (c_v != NULL);\n    }\n\n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -353,7 +353,10 @@\n \n           if (opt_show_metadata)\n             {\n-              g_print (\"%s\", xa_metadata ? xa_metadata : \"\");\n+              if (xa_metadata != NULL)\n+                flatpak_print_escaped_string (xa_metadata,\n+                                              FLATPAK_ESCAPE_ALLOW_NEWLINES\n+                                              | FLATPAK_ESCAPE_DO_NOT_QUOTE);\n               if (xa_metadata == NULL || !g_str_has_suffix (xa_metadata, \"\\n\"))\n                 g_print (\"\\n\");\n             }",
        "diff_line_info": {
            "deleted_lines": [
                "              g_print (\"%s\", xa_metadata ? xa_metadata : \"\");"
            ],
            "added_lines": [
                "              if (xa_metadata != NULL)",
                "                flatpak_print_escaped_string (xa_metadata,",
                "                                              FLATPAK_ESCAPE_ALLOW_NEWLINES",
                "                                              | FLATPAK_ESCAPE_DO_NOT_QUOTE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28101",
        "func_name": "flatpak/option_persist_cb",
        "description": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they can hide those permissions from users of the `flatpak(1)` command-line interface by setting other permissions to crafted values that contain non-printable control characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line interface, or only install apps whose maintainers you trust.",
        "git_url": "https://github.com/flatpak/flatpak/commit/7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c",
        "commit_title": "Reject paths given to --filesystem/--persist with special characters",
        "commit_text": " There isn't much in the way of legit reasons for this, but it's a potential security footgun when displaying the text.  CVE-2023-28101, GHSA-h43h-fwqx-mpp8  Co-authored-by: Simon McVittie <smcv@collabora.com>",
        "func_before": "static gboolean\noption_persist_cb (const gchar *option_name,\n                   const gchar *value,\n                   gpointer     data,\n                   GError     **error)\n{\n  FlatpakContext *context = data;\n\n  flatpak_context_set_persistent (context, value);\n  return TRUE;\n}",
        "func": "static gboolean\noption_persist_cb (const gchar *option_name,\n                   const gchar *value,\n                   gpointer     data,\n                   GError     **error)\n{\n  FlatpakContext *context = data;\n\n  return flatpak_context_set_persistent (context, value, error);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,5 @@\n {\n   FlatpakContext *context = data;\n \n-  flatpak_context_set_persistent (context, value);\n-  return TRUE;\n+  return flatpak_context_set_persistent (context, value, error);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  flatpak_context_set_persistent (context, value);",
                "  return TRUE;"
            ],
            "added_lines": [
                "  return flatpak_context_set_persistent (context, value, error);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28101",
        "func_name": "flatpak/flatpak_context_load_metadata",
        "description": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they can hide those permissions from users of the `flatpak(1)` command-line interface by setting other permissions to crafted values that contain non-printable control characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line interface, or only install apps whose maintainers you trust.",
        "git_url": "https://github.com/flatpak/flatpak/commit/7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c",
        "commit_title": "Reject paths given to --filesystem/--persist with special characters",
        "commit_text": " There isn't much in the way of legit reasons for this, but it's a potential security footgun when displaying the text.  CVE-2023-28101, GHSA-h43h-fwqx-mpp8  Co-authored-by: Simon McVittie <smcv@collabora.com>",
        "func_before": "gboolean\nflatpak_context_load_metadata (FlatpakContext *context,\n                               GKeyFile       *metakey,\n                               GError        **error)\n{\n  gboolean remove;\n  g_auto(GStrv) groups = NULL;\n  gsize i;\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SHARED, NULL))\n    {\n      g_auto(GStrv) shares = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                         FLATPAK_METADATA_KEY_SHARED, NULL, error);\n      if (shares == NULL)\n        return FALSE;\n\n      for (i = 0; shares[i] != NULL; i++)\n        {\n          FlatpakContextShares share;\n\n          share = flatpak_context_share_from_string (parse_negated (shares[i], &remove), NULL);\n          if (share == 0)\n            g_info (\"Unknown share type %s\", shares[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_shares (context, share);\n              else\n                flatpak_context_add_shares (context, share);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SOCKETS, NULL))\n    {\n      g_auto(GStrv) sockets = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                          FLATPAK_METADATA_KEY_SOCKETS, NULL, error);\n      if (sockets == NULL)\n        return FALSE;\n\n      for (i = 0; sockets[i] != NULL; i++)\n        {\n          FlatpakContextSockets socket = flatpak_context_socket_from_string (parse_negated (sockets[i], &remove), NULL);\n          if (socket == 0)\n            g_info (\"Unknown socket type %s\", sockets[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_sockets (context, socket);\n              else\n                flatpak_context_add_sockets (context, socket);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_DEVICES, NULL))\n    {\n      g_auto(GStrv) devices = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                          FLATPAK_METADATA_KEY_DEVICES, NULL, error);\n      if (devices == NULL)\n        return FALSE;\n\n\n      for (i = 0; devices[i] != NULL; i++)\n        {\n          FlatpakContextDevices device = flatpak_context_device_from_string (parse_negated (devices[i], &remove), NULL);\n          if (device == 0)\n            g_info (\"Unknown device type %s\", devices[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_devices (context, device);\n              else\n                flatpak_context_add_devices (context, device);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FEATURES, NULL))\n    {\n      g_auto(GStrv) features = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                           FLATPAK_METADATA_KEY_FEATURES, NULL, error);\n      if (features == NULL)\n        return FALSE;\n\n\n      for (i = 0; features[i] != NULL; i++)\n        {\n          FlatpakContextFeatures feature = flatpak_context_feature_from_string (parse_negated (features[i], &remove), NULL);\n          if (feature == 0)\n            g_info (\"Unknown feature type %s\", features[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_features (context, feature);\n              else\n                flatpak_context_add_features (context, feature);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FILESYSTEMS, NULL))\n    {\n      g_auto(GStrv) filesystems = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                              FLATPAK_METADATA_KEY_FILESYSTEMS, NULL, error);\n      if (filesystems == NULL)\n        return FALSE;\n\n      for (i = 0; filesystems[i] != NULL; i++)\n        {\n          const char *fs = parse_negated (filesystems[i], &remove);\n          g_autofree char *filesystem = NULL;\n          FlatpakFilesystemMode mode;\n\n          if (!flatpak_context_parse_filesystem (fs, remove,\n                                                 &filesystem, &mode, NULL))\n            g_info (\"Unknown filesystem type %s\", filesystems[i]);\n          else\n            {\n              g_assert (mode == FLATPAK_FILESYSTEM_MODE_NONE || !remove);\n              flatpak_context_take_filesystem (context, g_steal_pointer (&filesystem), mode);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_PERSISTENT, NULL))\n    {\n      g_auto(GStrv) persistent = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                             FLATPAK_METADATA_KEY_PERSISTENT, NULL, error);\n      if (persistent == NULL)\n        return FALSE;\n\n      for (i = 0; persistent[i] != NULL; i++)\n        flatpak_context_set_persistent (context, persistent[i]);\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, key, NULL);\n          FlatpakPolicy policy;\n\n          if (!flatpak_verify_dbus_name (key, error))\n            return FALSE;\n\n          policy = flatpak_policy_from_string (value, NULL);\n          if ((int) policy != -1)\n            flatpak_context_set_session_bus_policy (context, key, policy);\n        }\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, key, NULL);\n          FlatpakPolicy policy;\n\n          if (!flatpak_verify_dbus_name (key, error))\n            return FALSE;\n\n          policy = flatpak_policy_from_string (value, NULL);\n          if ((int) policy != -1)\n            flatpak_context_set_system_bus_policy (context, key, policy);\n        }\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, key, NULL);\n\n          flatpak_context_set_env_var (context, key, value);\n        }\n    }\n\n  /* unset-environment is higher precedence than Environment, so that\n   * we can put unset keys in both places. Old versions of Flatpak will\n   * interpret the empty string as unset; new versions will obey\n   * unset-environment. */\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT, NULL))\n    {\n      g_auto(GStrv) vars = NULL;\n      gsize vars_count;\n\n      vars = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                         FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT,\n                                         &vars_count, error);\n\n      if (vars == NULL)\n        return FALSE;\n\n      for (i = 0; i < vars_count; i++)\n        {\n          const char *var = vars[i];\n\n          flatpak_context_set_env_var (context, var, NULL);\n        }\n    }\n\n  groups = g_key_file_get_groups (metakey, NULL);\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      const char *group = groups[i];\n      const char *subsystem;\n      int j;\n\n      if (g_str_has_prefix (group, FLATPAK_METADATA_GROUP_PREFIX_POLICY))\n        {\n          g_auto(GStrv) keys = NULL;\n          subsystem = group + strlen (FLATPAK_METADATA_GROUP_PREFIX_POLICY);\n          keys = g_key_file_get_keys (metakey, group, NULL, NULL);\n          for (j = 0; keys != NULL && keys[j] != NULL; j++)\n            {\n              const char *key = keys[j];\n              g_autofree char *policy_key = g_strdup_printf (\"%s.%s\", subsystem, key);\n              g_auto(GStrv) values = NULL;\n              int k;\n\n              values = g_key_file_get_string_list (metakey, group, key, NULL, NULL);\n              for (k = 0; values != NULL && values[k] != NULL; k++)\n                flatpak_context_apply_generic_policy (context, policy_key,\n                                                      values[k]);\n            }\n        }\n    }\n\n  return TRUE;\n}",
        "func": "gboolean\nflatpak_context_load_metadata (FlatpakContext *context,\n                               GKeyFile       *metakey,\n                               GError        **error)\n{\n  gboolean remove;\n  g_auto(GStrv) groups = NULL;\n  gsize i;\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SHARED, NULL))\n    {\n      g_auto(GStrv) shares = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                         FLATPAK_METADATA_KEY_SHARED, NULL, error);\n      if (shares == NULL)\n        return FALSE;\n\n      for (i = 0; shares[i] != NULL; i++)\n        {\n          FlatpakContextShares share;\n\n          share = flatpak_context_share_from_string (parse_negated (shares[i], &remove), NULL);\n          if (share == 0)\n            g_info (\"Unknown share type %s\", shares[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_shares (context, share);\n              else\n                flatpak_context_add_shares (context, share);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SOCKETS, NULL))\n    {\n      g_auto(GStrv) sockets = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                          FLATPAK_METADATA_KEY_SOCKETS, NULL, error);\n      if (sockets == NULL)\n        return FALSE;\n\n      for (i = 0; sockets[i] != NULL; i++)\n        {\n          FlatpakContextSockets socket = flatpak_context_socket_from_string (parse_negated (sockets[i], &remove), NULL);\n          if (socket == 0)\n            g_info (\"Unknown socket type %s\", sockets[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_sockets (context, socket);\n              else\n                flatpak_context_add_sockets (context, socket);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_DEVICES, NULL))\n    {\n      g_auto(GStrv) devices = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                          FLATPAK_METADATA_KEY_DEVICES, NULL, error);\n      if (devices == NULL)\n        return FALSE;\n\n\n      for (i = 0; devices[i] != NULL; i++)\n        {\n          FlatpakContextDevices device = flatpak_context_device_from_string (parse_negated (devices[i], &remove), NULL);\n          if (device == 0)\n            g_info (\"Unknown device type %s\", devices[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_devices (context, device);\n              else\n                flatpak_context_add_devices (context, device);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FEATURES, NULL))\n    {\n      g_auto(GStrv) features = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                           FLATPAK_METADATA_KEY_FEATURES, NULL, error);\n      if (features == NULL)\n        return FALSE;\n\n\n      for (i = 0; features[i] != NULL; i++)\n        {\n          FlatpakContextFeatures feature = flatpak_context_feature_from_string (parse_negated (features[i], &remove), NULL);\n          if (feature == 0)\n            g_info (\"Unknown feature type %s\", features[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_features (context, feature);\n              else\n                flatpak_context_add_features (context, feature);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FILESYSTEMS, NULL))\n    {\n      g_auto(GStrv) filesystems = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                              FLATPAK_METADATA_KEY_FILESYSTEMS, NULL, error);\n      if (filesystems == NULL)\n        return FALSE;\n\n      for (i = 0; filesystems[i] != NULL; i++)\n        {\n          const char *fs = parse_negated (filesystems[i], &remove);\n          g_autofree char *filesystem = NULL;\n          g_autoptr(GError) local_error = NULL;\n          FlatpakFilesystemMode mode;\n\n          if (!flatpak_context_parse_filesystem (fs, remove,\n                                                 &filesystem, &mode, &local_error))\n            {\n              if (g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA))\n                {\n                  /* Invalid characters, so just hard-fail. */\n                  g_propagate_error (error, g_steal_pointer (&local_error));\n                  return FALSE;\n                }\n              else\n                {\n                  g_info (\"Unknown filesystem type %s\", filesystems[i]);\n                  g_clear_error (&local_error);\n                }\n            }\n          else\n            {\n              g_assert (mode == FLATPAK_FILESYSTEM_MODE_NONE || !remove);\n              flatpak_context_take_filesystem (context, g_steal_pointer (&filesystem), mode);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_PERSISTENT, NULL))\n    {\n      g_auto(GStrv) persistent = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                             FLATPAK_METADATA_KEY_PERSISTENT, NULL, error);\n      if (persistent == NULL)\n        return FALSE;\n\n      for (i = 0; persistent[i] != NULL; i++)\n        if (!flatpak_context_set_persistent (context, persistent[i], error))\n          return FALSE;\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, key, NULL);\n          FlatpakPolicy policy;\n\n          if (!flatpak_verify_dbus_name (key, error))\n            return FALSE;\n\n          policy = flatpak_policy_from_string (value, NULL);\n          if ((int) policy != -1)\n            flatpak_context_set_session_bus_policy (context, key, policy);\n        }\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, key, NULL);\n          FlatpakPolicy policy;\n\n          if (!flatpak_verify_dbus_name (key, error))\n            return FALSE;\n\n          policy = flatpak_policy_from_string (value, NULL);\n          if ((int) policy != -1)\n            flatpak_context_set_system_bus_policy (context, key, policy);\n        }\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, key, NULL);\n\n          flatpak_context_set_env_var (context, key, value);\n        }\n    }\n\n  /* unset-environment is higher precedence than Environment, so that\n   * we can put unset keys in both places. Old versions of Flatpak will\n   * interpret the empty string as unset; new versions will obey\n   * unset-environment. */\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT, NULL))\n    {\n      g_auto(GStrv) vars = NULL;\n      gsize vars_count;\n\n      vars = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                         FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT,\n                                         &vars_count, error);\n\n      if (vars == NULL)\n        return FALSE;\n\n      for (i = 0; i < vars_count; i++)\n        {\n          const char *var = vars[i];\n\n          flatpak_context_set_env_var (context, var, NULL);\n        }\n    }\n\n  groups = g_key_file_get_groups (metakey, NULL);\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      const char *group = groups[i];\n      const char *subsystem;\n      int j;\n\n      if (g_str_has_prefix (group, FLATPAK_METADATA_GROUP_PREFIX_POLICY))\n        {\n          g_auto(GStrv) keys = NULL;\n          subsystem = group + strlen (FLATPAK_METADATA_GROUP_PREFIX_POLICY);\n          keys = g_key_file_get_keys (metakey, group, NULL, NULL);\n          for (j = 0; keys != NULL && keys[j] != NULL; j++)\n            {\n              const char *key = keys[j];\n              g_autofree char *policy_key = g_strdup_printf (\"%s.%s\", subsystem, key);\n              g_auto(GStrv) values = NULL;\n              int k;\n\n              values = g_key_file_get_string_list (metakey, group, key, NULL, NULL);\n              for (k = 0; values != NULL && values[k] != NULL; k++)\n                flatpak_context_apply_generic_policy (context, policy_key,\n                                                      values[k]);\n            }\n        }\n    }\n\n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -110,11 +110,24 @@\n         {\n           const char *fs = parse_negated (filesystems[i], &remove);\n           g_autofree char *filesystem = NULL;\n+          g_autoptr(GError) local_error = NULL;\n           FlatpakFilesystemMode mode;\n \n           if (!flatpak_context_parse_filesystem (fs, remove,\n-                                                 &filesystem, &mode, NULL))\n-            g_info (\"Unknown filesystem type %s\", filesystems[i]);\n+                                                 &filesystem, &mode, &local_error))\n+            {\n+              if (g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA))\n+                {\n+                  /* Invalid characters, so just hard-fail. */\n+                  g_propagate_error (error, g_steal_pointer (&local_error));\n+                  return FALSE;\n+                }\n+              else\n+                {\n+                  g_info (\"Unknown filesystem type %s\", filesystems[i]);\n+                  g_clear_error (&local_error);\n+                }\n+            }\n           else\n             {\n               g_assert (mode == FLATPAK_FILESYSTEM_MODE_NONE || !remove);\n@@ -131,7 +144,8 @@\n         return FALSE;\n \n       for (i = 0; persistent[i] != NULL; i++)\n-        flatpak_context_set_persistent (context, persistent[i]);\n+        if (!flatpak_context_set_persistent (context, persistent[i], error))\n+          return FALSE;\n     }\n \n   if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY))",
        "diff_line_info": {
            "deleted_lines": [
                "                                                 &filesystem, &mode, NULL))",
                "            g_info (\"Unknown filesystem type %s\", filesystems[i]);",
                "        flatpak_context_set_persistent (context, persistent[i]);"
            ],
            "added_lines": [
                "          g_autoptr(GError) local_error = NULL;",
                "                                                 &filesystem, &mode, &local_error))",
                "            {",
                "              if (g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA))",
                "                {",
                "                  /* Invalid characters, so just hard-fail. */",
                "                  g_propagate_error (error, g_steal_pointer (&local_error));",
                "                  return FALSE;",
                "                }",
                "              else",
                "                {",
                "                  g_info (\"Unknown filesystem type %s\", filesystems[i]);",
                "                  g_clear_error (&local_error);",
                "                }",
                "            }",
                "        if (!flatpak_context_set_persistent (context, persistent[i], error))",
                "          return FALSE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28101",
        "func_name": "flatpak/flatpak_context_set_persistent",
        "description": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they can hide those permissions from users of the `flatpak(1)` command-line interface by setting other permissions to crafted values that contain non-printable control characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line interface, or only install apps whose maintainers you trust.",
        "git_url": "https://github.com/flatpak/flatpak/commit/7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c",
        "commit_title": "Reject paths given to --filesystem/--persist with special characters",
        "commit_text": " There isn't much in the way of legit reasons for this, but it's a potential security footgun when displaying the text.  CVE-2023-28101, GHSA-h43h-fwqx-mpp8  Co-authored-by: Simon McVittie <smcv@collabora.com>",
        "func_before": "static void\nflatpak_context_set_persistent (FlatpakContext *context,\n                                const char     *path)\n{\n  g_hash_table_insert (context->persistent, g_strdup (path), GINT_TO_POINTER (1));\n}",
        "func": "static gboolean\nflatpak_context_set_persistent (FlatpakContext *context,\n                                const char     *path,\n                                GError        **error)\n{\n  if (!flatpak_validate_path_characters (path, error))\n    return FALSE;\n\n  g_hash_table_insert (context->persistent, g_strdup (path), GINT_TO_POINTER (1));\n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,11 @@\n-static void\n+static gboolean\n flatpak_context_set_persistent (FlatpakContext *context,\n-                                const char     *path)\n+                                const char     *path,\n+                                GError        **error)\n {\n+  if (!flatpak_validate_path_characters (path, error))\n+    return FALSE;\n+\n   g_hash_table_insert (context->persistent, g_strdup (path), GINT_TO_POINTER (1));\n+  return TRUE;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static void",
                "                                const char     *path)"
            ],
            "added_lines": [
                "static gboolean",
                "                                const char     *path,",
                "                                GError        **error)",
                "  if (!flatpak_validate_path_characters (path, error))",
                "    return FALSE;",
                "",
                "  return TRUE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28101",
        "func_name": "flatpak/flatpak_context_parse_filesystem",
        "description": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they can hide those permissions from users of the `flatpak(1)` command-line interface by setting other permissions to crafted values that contain non-printable control characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line interface, or only install apps whose maintainers you trust.",
        "git_url": "https://github.com/flatpak/flatpak/commit/7fe63f2e8f1fd2dafc31d45154cf0b191ebec66c",
        "commit_title": "Reject paths given to --filesystem/--persist with special characters",
        "commit_text": " There isn't much in the way of legit reasons for this, but it's a potential security footgun when displaying the text.  CVE-2023-28101, GHSA-h43h-fwqx-mpp8  Co-authored-by: Simon McVittie <smcv@collabora.com>",
        "func_before": "gboolean\nflatpak_context_parse_filesystem (const char             *filesystem_and_mode,\n                                  gboolean                negated,\n                                  char                  **filesystem_out,\n                                  FlatpakFilesystemMode  *mode_out,\n                                  GError                **error)\n{\n  g_autofree char *filesystem = NULL;\n  char *slash;\n\n  filesystem = parse_filesystem_flags (filesystem_and_mode, negated, mode_out, error);\n  if (filesystem == NULL)\n    return FALSE;\n\n  slash = strchr (filesystem, '/');\n\n  /* Forbid /../ in paths */\n  if (slash != NULL)\n    {\n      if (g_str_has_prefix (slash + 1, \"../\") ||\n          g_str_has_suffix (slash + 1, \"/..\") ||\n          strstr (slash + 1, \"/../\") != NULL)\n        {\n          g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,\n                       _(\"Filesystem location \\\"%s\\\" contains \\\"..\\\"\"),\n                       filesystem);\n          return FALSE;\n        }\n\n      /* Convert \"//\" and \"/./\" to \"/\" */\n      for (; slash != NULL; slash = strchr (slash + 1, '/'))\n        {\n          while (TRUE)\n            {\n              if (slash[1] == '/')\n                memmove (slash + 1, slash + 2, strlen (slash + 2) + 1);\n              else if (slash[1] == '.' && slash[2] == '/')\n                memmove (slash + 1, slash + 3, strlen (slash + 3) + 1);\n              else\n                break;\n            }\n        }\n\n      /* Eliminate trailing \"/.\" or \"/\". */\n      while (TRUE)\n        {\n          slash = strrchr (filesystem, '/');\n\n          if (slash != NULL &&\n              ((slash != filesystem && slash[1] == '\\0') ||\n               (slash[1] == '.' && slash[2] == '\\0')))\n            *slash = '\\0';\n          else\n            break;\n        }\n\n      if (filesystem[0] == '/' && filesystem[1] == '\\0')\n        {\n          /* We don't allow --filesystem=/ as equivalent to host, because\n           * it doesn't do what you'd think: --filesystem=host mounts some\n           * host directories in /run/host, not in the root. */\n          g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,\n                       _(\"--filesystem=/ is not available, \"\n                         \"use --filesystem=host for a similar result\"));\n          return FALSE;\n        }\n    }\n\n  if (g_strv_contains (flatpak_context_special_filesystems, filesystem) ||\n      get_xdg_user_dir_from_string (filesystem, NULL, NULL, NULL) ||\n      g_str_has_prefix (filesystem, \"~/\") ||\n      g_str_has_prefix (filesystem, \"/\"))\n    {\n      if (filesystem_out != NULL)\n        *filesystem_out = g_steal_pointer (&filesystem);\n\n      return TRUE;\n    }\n\n  if (strcmp (filesystem, \"~\") == 0)\n    {\n      if (filesystem_out != NULL)\n        *filesystem_out = g_strdup (\"home\");\n\n      return TRUE;\n    }\n\n  if (g_str_has_prefix (filesystem, \"home/\"))\n    {\n      if (filesystem_out != NULL)\n        *filesystem_out = g_strconcat (\"~/\", filesystem + 5, NULL);\n\n      return TRUE;\n    }\n\n  g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n               _(\"Unknown filesystem location %s, valid locations are: host, host-os, host-etc, home, xdg-*[/], ~/dir, /dir\"), filesystem);\n  return FALSE;\n}",
        "func": "gboolean\nflatpak_context_parse_filesystem (const char             *filesystem_and_mode,\n                                  gboolean                negated,\n                                  char                  **filesystem_out,\n                                  FlatpakFilesystemMode  *mode_out,\n                                  GError                **error)\n{\n  g_autofree char *filesystem = NULL;\n  char *slash;\n\n  if (!flatpak_validate_path_characters (filesystem_and_mode, error))\n    return FALSE;\n\n  filesystem = parse_filesystem_flags (filesystem_and_mode, negated, mode_out, error);\n  if (filesystem == NULL)\n    return FALSE;\n\n  slash = strchr (filesystem, '/');\n\n  /* Forbid /../ in paths */\n  if (slash != NULL)\n    {\n      if (g_str_has_prefix (slash + 1, \"../\") ||\n          g_str_has_suffix (slash + 1, \"/..\") ||\n          strstr (slash + 1, \"/../\") != NULL)\n        {\n          g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,\n                       _(\"Filesystem location \\\"%s\\\" contains \\\"..\\\"\"),\n                       filesystem);\n          return FALSE;\n        }\n\n      /* Convert \"//\" and \"/./\" to \"/\" */\n      for (; slash != NULL; slash = strchr (slash + 1, '/'))\n        {\n          while (TRUE)\n            {\n              if (slash[1] == '/')\n                memmove (slash + 1, slash + 2, strlen (slash + 2) + 1);\n              else if (slash[1] == '.' && slash[2] == '/')\n                memmove (slash + 1, slash + 3, strlen (slash + 3) + 1);\n              else\n                break;\n            }\n        }\n\n      /* Eliminate trailing \"/.\" or \"/\". */\n      while (TRUE)\n        {\n          slash = strrchr (filesystem, '/');\n\n          if (slash != NULL &&\n              ((slash != filesystem && slash[1] == '\\0') ||\n               (slash[1] == '.' && slash[2] == '\\0')))\n            *slash = '\\0';\n          else\n            break;\n        }\n\n      if (filesystem[0] == '/' && filesystem[1] == '\\0')\n        {\n          /* We don't allow --filesystem=/ as equivalent to host, because\n           * it doesn't do what you'd think: --filesystem=host mounts some\n           * host directories in /run/host, not in the root. */\n          g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_BAD_VALUE,\n                       _(\"--filesystem=/ is not available, \"\n                         \"use --filesystem=host for a similar result\"));\n          return FALSE;\n        }\n    }\n\n  if (g_strv_contains (flatpak_context_special_filesystems, filesystem) ||\n      get_xdg_user_dir_from_string (filesystem, NULL, NULL, NULL) ||\n      g_str_has_prefix (filesystem, \"~/\") ||\n      g_str_has_prefix (filesystem, \"/\"))\n    {\n      if (filesystem_out != NULL)\n        *filesystem_out = g_steal_pointer (&filesystem);\n\n      return TRUE;\n    }\n\n  if (strcmp (filesystem, \"~\") == 0)\n    {\n      if (filesystem_out != NULL)\n        *filesystem_out = g_strdup (\"home\");\n\n      return TRUE;\n    }\n\n  if (g_str_has_prefix (filesystem, \"home/\"))\n    {\n      if (filesystem_out != NULL)\n        *filesystem_out = g_strconcat (\"~/\", filesystem + 5, NULL);\n\n      return TRUE;\n    }\n\n  g_set_error (error, G_OPTION_ERROR, G_OPTION_ERROR_FAILED,\n               _(\"Unknown filesystem location %s, valid locations are: host, host-os, host-etc, home, xdg-*[/], ~/dir, /dir\"), filesystem);\n  return FALSE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,9 @@\n {\n   g_autofree char *filesystem = NULL;\n   char *slash;\n+\n+  if (!flatpak_validate_path_characters (filesystem_and_mode, error))\n+    return FALSE;\n \n   filesystem = parse_filesystem_flags (filesystem_and_mode, negated, mode_out, error);\n   if (filesystem == NULL)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  if (!flatpak_validate_path_characters (filesystem_and_mode, error))",
                "    return FALSE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31669",
        "func_name": "WebAssembly/wabt/WastParser::ParseCodeMetadataAnnotation",
        "description": "WebAssembly wat2wasm v1.0.32 allows attackers to cause a libc++abi.dylib crash by putting '@' before a quote (\").",
        "git_url": "https://github.com/WebAssembly/wabt/commit/44491a4b0fdb2d2bd87a151fd169da3343954edd",
        "commit_title": "Improve lexing and parsing of invalid annotations (again)",
        "commit_text": " This adds a bounds-check to WastLexer::GetText to handle the case when the offset is earlier than token_start (e.g. because GetStringToken found a newline in the string and reset token_start to point at it).  Also revises GetIdToken -> GetIdChars to stop skipping the initial char in an annotation delimiter, which is an idchar+ but not an id token.  Also fixes the WastParser to handle EOF when reading for the end of an annotation, both for code metadata annotations and other kinds. Previously this produced an infinite loop (but only with --enable-annotations).  Fixes #2165",
        "func_before": "Result WastParser::ParseCodeMetadataAnnotation(ExprList* exprs) {\n  WABT_TRACE(ParseCodeMetadataAnnotation);\n  Token tk = Consume();\n  std::string_view name = tk.text();\n  name.remove_prefix(sizeof(\"metadata.code.\") - 1);\n  std::string data_text;\n  CHECK_RESULT(ParseQuotedText(&data_text, false));\n  std::vector<uint8_t> data(data_text.begin(), data_text.end());\n  exprs->push_back(std::make_unique<CodeMetadataExpr>(name, std::move(data)));\n  TokenType rpar = Peek();\n  WABT_USE(rpar);\n  assert(rpar == TokenType::Rpar);\n  Consume();\n  return Result::Ok;\n}",
        "func": "Result WastParser::ParseCodeMetadataAnnotation(ExprList* exprs) {\n  WABT_TRACE(ParseCodeMetadataAnnotation);\n  Token tk = Consume();\n  std::string_view name = tk.text();\n  name.remove_prefix(sizeof(\"metadata.code.\") - 1);\n  std::string data_text;\n  CHECK_RESULT(ParseQuotedText(&data_text, false));\n  std::vector<uint8_t> data(data_text.begin(), data_text.end());\n  exprs->push_back(std::make_unique<CodeMetadataExpr>(name, std::move(data)));\n  EXPECT(Rpar);\n  return Result::Ok;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,9 +7,6 @@\n   CHECK_RESULT(ParseQuotedText(&data_text, false));\n   std::vector<uint8_t> data(data_text.begin(), data_text.end());\n   exprs->push_back(std::make_unique<CodeMetadataExpr>(name, std::move(data)));\n-  TokenType rpar = Peek();\n-  WABT_USE(rpar);\n-  assert(rpar == TokenType::Rpar);\n-  Consume();\n+  EXPECT(Rpar);\n   return Result::Ok;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  TokenType rpar = Peek();",
                "  WABT_USE(rpar);",
                "  assert(rpar == TokenType::Rpar);",
                "  Consume();"
            ],
            "added_lines": [
                "  EXPECT(Rpar);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31669",
        "func_name": "WebAssembly/wabt/WastParser::Peek",
        "description": "WebAssembly wat2wasm v1.0.32 allows attackers to cause a libc++abi.dylib crash by putting '@' before a quote (\").",
        "git_url": "https://github.com/WebAssembly/wabt/commit/44491a4b0fdb2d2bd87a151fd169da3343954edd",
        "commit_title": "Improve lexing and parsing of invalid annotations (again)",
        "commit_text": " This adds a bounds-check to WastLexer::GetText to handle the case when the offset is earlier than token_start (e.g. because GetStringToken found a newline in the string and reset token_start to point at it).  Also revises GetIdToken -> GetIdChars to stop skipping the initial char in an annotation delimiter, which is an idchar+ but not an id token.  Also fixes the WastParser to handle EOF when reading for the end of an annotation, both for code metadata annotations and other kinds. Previously this produced an infinite loop (but only with --enable-annotations).  Fixes #2165",
        "func_before": "TokenType WastParser::Peek(size_t n) {\n  while (tokens_.size() <= n) {\n    Token cur = lexer_->GetToken();\n    if (cur.token_type() != TokenType::LparAnn) {\n      tokens_.push_back(cur);\n    } else {\n      // Custom annotation. For now, discard until matching Rpar, unless it is\n      // a code metadata annotation. In that case, we know how to parse it.\n      if (!options_->features.annotations_enabled()) {\n        Error(cur.loc, \"annotations not enabled: %s\", cur.to_string().c_str());\n        tokens_.push_back(Token(cur.loc, TokenType::Invalid));\n        continue;\n      }\n      if (options_->features.code_metadata_enabled() &&\n          cur.text().find(\"metadata.code.\") == 0) {\n        tokens_.push_back(cur);\n        continue;\n      }\n      int indent = 1;\n      while (indent > 0) {\n        cur = lexer_->GetToken();\n        switch (cur.token_type()) {\n          case TokenType::Lpar:\n          case TokenType::LparAnn:\n            indent++;\n            break;\n\n          case TokenType::Rpar:\n            indent--;\n            break;\n\n          default:\n            break;\n        }\n      }\n    }\n  }\n  return tokens_.at(n).token_type();\n}",
        "func": "TokenType WastParser::Peek(size_t n) {\n  while (tokens_.size() <= n) {\n    Token cur = lexer_->GetToken();\n    if (cur.token_type() != TokenType::LparAnn) {\n      tokens_.push_back(cur);\n    } else {\n      // Custom annotation. For now, discard until matching Rpar, unless it is\n      // a code metadata annotation. In that case, we know how to parse it.\n      if (!options_->features.annotations_enabled()) {\n        Error(cur.loc, \"annotations not enabled: %s\", cur.to_string().c_str());\n        tokens_.push_back(Token(cur.loc, TokenType::Invalid));\n        continue;\n      }\n      if (options_->features.code_metadata_enabled() &&\n          cur.text().find(\"metadata.code.\") == 0) {\n        tokens_.push_back(cur);\n        continue;\n      }\n      int indent = 1;\n      while (indent > 0) {\n        cur = lexer_->GetToken();\n        switch (cur.token_type()) {\n          case TokenType::Lpar:\n          case TokenType::LparAnn:\n            indent++;\n            break;\n\n          case TokenType::Rpar:\n            indent--;\n            break;\n\n          case TokenType::Eof:\n            indent = 0;\n            Error(cur.loc, \"unterminated annotation\");\n            break;\n\n          default:\n            break;\n        }\n      }\n    }\n  }\n  return tokens_.at(n).token_type();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,6 +29,11 @@\n             indent--;\n             break;\n \n+          case TokenType::Eof:\n+            indent = 0;\n+            Error(cur.loc, \"unterminated annotation\");\n+            break;\n+\n           default:\n             break;\n         }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "          case TokenType::Eof:",
                "            indent = 0;",
                "            Error(cur.loc, \"unterminated annotation\");",
                "            break;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31669",
        "func_name": "WebAssembly/wabt/WastLexer::GetToken",
        "description": "WebAssembly wat2wasm v1.0.32 allows attackers to cause a libc++abi.dylib crash by putting '@' before a quote (\").",
        "git_url": "https://github.com/WebAssembly/wabt/commit/44491a4b0fdb2d2bd87a151fd169da3343954edd",
        "commit_title": "Improve lexing and parsing of invalid annotations (again)",
        "commit_text": " This adds a bounds-check to WastLexer::GetText to handle the case when the offset is earlier than token_start (e.g. because GetStringToken found a newline in the string and reset token_start to point at it).  Also revises GetIdToken -> GetIdChars to stop skipping the initial char in an annotation delimiter, which is an idchar+ but not an id token.  Also fixes the WastParser to handle EOF when reading for the end of an annotation, both for code metadata annotations and other kinds. Previously this produced an infinite loop (but only with --enable-annotations).  Fixes #2165",
        "func_before": "Token WastLexer::GetToken() {\n  while (true) {\n    token_start_ = cursor_;\n    switch (PeekChar()) {\n      case kEof:\n        return BareToken(TokenType::Eof);\n\n      case '(':\n        if (MatchString(\"(;\")) {\n          if (ReadBlockComment()) {\n            continue;\n          }\n          return BareToken(TokenType::Eof);\n        } else if (MatchString(\"(@\")) {\n          GetIdToken();\n          // offset=2 to skip the \"(@\" prefix\n          return TextToken(TokenType::LparAnn, 2);\n        } else {\n          ReadChar();\n          return BareToken(TokenType::Lpar);\n        }\n        break;\n\n      case ')':\n        ReadChar();\n        return BareToken(TokenType::Rpar);\n\n      case ';':\n        if (MatchString(\";;\")) {\n          if (ReadLineComment()) {\n            continue;\n          }\n          return BareToken(TokenType::Eof);\n        } else {\n          ReadChar();\n          ERROR(\"unexpected char\");\n          continue;\n        }\n        break;\n\n      case ' ':\n      case '\\t':\n      case '\\r':\n      case '\\n':\n        ReadWhitespace();\n        continue;\n\n      case '\"':\n        return GetStringToken();\n\n      case '+':\n      case '-':\n        ReadChar();\n        switch (PeekChar()) {\n          case 'i':\n            return GetInfToken();\n\n          case 'n':\n            return GetNanToken();\n\n          case '0':\n            return MatchString(\"0x\") ? GetHexNumberToken(TokenType::Int)\n                                     : GetNumberToken(TokenType::Int);\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            return GetNumberToken(TokenType::Int);\n\n          default:\n            return GetReservedToken();\n        }\n        break;\n\n      case '0':\n        return MatchString(\"0x\") ? GetHexNumberToken(TokenType::Nat)\n                                 : GetNumberToken(TokenType::Nat);\n\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        return GetNumberToken(TokenType::Nat);\n\n      case '$':\n        return GetIdToken();\n\n      case 'a':\n        return GetNameEqNumToken(\"align=\", TokenType::AlignEqNat);\n\n      case 'i':\n        return GetInfToken();\n\n      case 'n':\n        return GetNanToken();\n\n      case 'o':\n        return GetNameEqNumToken(\"offset=\", TokenType::OffsetEqNat);\n\n      default:\n        if (IsKeyword(PeekChar())) {\n          return GetKeywordToken();\n        } else if (IsIdChar(PeekChar())) {\n          return GetReservedToken();\n        } else {\n          ReadChar();\n          ERROR(\"unexpected char\");\n          continue;\n        }\n    }\n  }\n}",
        "func": "Token WastLexer::GetToken() {\n  while (true) {\n    token_start_ = cursor_;\n    switch (PeekChar()) {\n      case kEof:\n        return BareToken(TokenType::Eof);\n\n      case '(':\n        if (MatchString(\"(;\")) {\n          if (ReadBlockComment()) {\n            continue;\n          }\n          return BareToken(TokenType::Eof);\n        } else if (MatchString(\"(@\")) {\n          GetIdChars();\n          // offset=2 to skip the \"(@\" prefix\n          return TextToken(TokenType::LparAnn, 2);\n        } else {\n          ReadChar();\n          return BareToken(TokenType::Lpar);\n        }\n        break;\n\n      case ')':\n        ReadChar();\n        return BareToken(TokenType::Rpar);\n\n      case ';':\n        if (MatchString(\";;\")) {\n          if (ReadLineComment()) {\n            continue;\n          }\n          return BareToken(TokenType::Eof);\n        } else {\n          ReadChar();\n          ERROR(\"unexpected char\");\n          continue;\n        }\n        break;\n\n      case ' ':\n      case '\\t':\n      case '\\r':\n      case '\\n':\n        ReadWhitespace();\n        continue;\n\n      case '\"':\n        return GetStringToken();\n\n      case '+':\n      case '-':\n        ReadChar();\n        switch (PeekChar()) {\n          case 'i':\n            return GetInfToken();\n\n          case 'n':\n            return GetNanToken();\n\n          case '0':\n            return MatchString(\"0x\") ? GetHexNumberToken(TokenType::Int)\n                                     : GetNumberToken(TokenType::Int);\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            return GetNumberToken(TokenType::Int);\n\n          default:\n            return GetReservedToken();\n        }\n        break;\n\n      case '0':\n        return MatchString(\"0x\") ? GetHexNumberToken(TokenType::Nat)\n                                 : GetNumberToken(TokenType::Nat);\n\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        return GetNumberToken(TokenType::Nat);\n\n      case '$':\n        return GetIdChars();  // Initial $ is idchar, so this produces id token\n\n      case 'a':\n        return GetNameEqNumToken(\"align=\", TokenType::AlignEqNat);\n\n      case 'i':\n        return GetInfToken();\n\n      case 'n':\n        return GetNanToken();\n\n      case 'o':\n        return GetNameEqNumToken(\"offset=\", TokenType::OffsetEqNat);\n\n      default:\n        if (IsKeyword(PeekChar())) {\n          return GetKeywordToken();\n        } else if (IsIdChar(PeekChar())) {\n          return GetReservedToken();\n        } else {\n          ReadChar();\n          ERROR(\"unexpected char\");\n          continue;\n        }\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n           }\n           return BareToken(TokenType::Eof);\n         } else if (MatchString(\"(@\")) {\n-          GetIdToken();\n+          GetIdChars();\n           // offset=2 to skip the \"(@\" prefix\n           return TextToken(TokenType::LparAnn, 2);\n         } else {\n@@ -93,7 +93,7 @@\n         return GetNumberToken(TokenType::Nat);\n \n       case '$':\n-        return GetIdToken();\n+        return GetIdChars();  // Initial $ is idchar, so this produces id token\n \n       case 'a':\n         return GetNameEqNumToken(\"align=\", TokenType::AlignEqNat);",
        "diff_line_info": {
            "deleted_lines": [
                "          GetIdToken();",
                "        return GetIdToken();"
            ],
            "added_lines": [
                "          GetIdChars();",
                "        return GetIdChars();  // Initial $ is idchar, so this produces id token"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31669",
        "func_name": "WebAssembly/wabt/WastLexer::GetText",
        "description": "WebAssembly wat2wasm v1.0.32 allows attackers to cause a libc++abi.dylib crash by putting '@' before a quote (\").",
        "git_url": "https://github.com/WebAssembly/wabt/commit/44491a4b0fdb2d2bd87a151fd169da3343954edd",
        "commit_title": "Improve lexing and parsing of invalid annotations (again)",
        "commit_text": " This adds a bounds-check to WastLexer::GetText to handle the case when the offset is earlier than token_start (e.g. because GetStringToken found a newline in the string and reset token_start to point at it).  Also revises GetIdToken -> GetIdChars to stop skipping the initial char in an annotation delimiter, which is an idchar+ but not an id token.  Also fixes the WastParser to handle EOF when reading for the end of an annotation, both for code metadata annotations and other kinds. Previously this produced an infinite loop (but only with --enable-annotations).  Fixes #2165",
        "func_before": "std::string_view WastLexer::GetText(size_t offset) {\n  return std::string_view(token_start_ + offset,\n                          (cursor_ - token_start_) - offset);\n}",
        "func": "std::string_view WastLexer::GetText(size_t offset) {\n  // Bounds checks are necessary because token_start may have been moved\n  // (e.g. if GetStringToken found a newline and reset token_start to\n  // point at it).\n\n  if (token_start_ + offset >= buffer_end_)\n    return {};\n\n  if (cursor_ <= token_start_ + offset)\n    return {};\n\n  return std::string_view(token_start_ + offset,\n                          (cursor_ - token_start_) - offset);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,14 @@\n std::string_view WastLexer::GetText(size_t offset) {\n+  // Bounds checks are necessary because token_start may have been moved\n+  // (e.g. if GetStringToken found a newline and reset token_start to\n+  // point at it).\n+\n+  if (token_start_ + offset >= buffer_end_)\n+    return {};\n+\n+  if (cursor_ <= token_start_ + offset)\n+    return {};\n+\n   return std::string_view(token_start_ + offset,\n                           (cursor_ - token_start_) - offset);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  // Bounds checks are necessary because token_start may have been moved",
                "  // (e.g. if GetStringToken found a newline and reset token_start to",
                "  // point at it).",
                "",
                "  if (token_start_ + offset >= buffer_end_)",
                "    return {};",
                "",
                "  if (cursor_ <= token_start_ + offset)",
                "    return {};",
                ""
            ]
        }
    }
]