[
    {
        "cve_id": "CVE-2019-10131",
        "func_name": "ImageMagick/format8BIM",
        "description": "An off-by-one read vulnerability was discovered in ImageMagick before version 7.0.7-28 in the formatIPTCfromBuffer function in coders/meta.c. A local attacker may use this flaw to read beyond the end of the buffer or to crash the program.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/cb1214c124e1bd61f7dd551b94a794864861592e",
        "commit_title": "...",
        "commit_text": "",
        "func_before": "static int format8BIM(Image *ifile, Image *ofile)\n{\n  char\n    temp[MagickPathExtent];\n\n  unsigned int\n    foundOSType;\n\n  int\n    ID,\n    resCount,\n    i,\n    c;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *PString,\n    *str;\n\n  resCount=0;\n  foundOSType=0; /* found the OSType */\n  (void) foundOSType;\n  c=ReadBlobByte(ifile);\n  while (c != EOF)\n  {\n    if (c == '8')\n      {\n        unsigned char\n          buffer[5];\n\n        buffer[0]=(unsigned char) c;\n        for (i=1; i<4; i++)\n        {\n          c=ReadBlobByte(ifile);\n          if (c == EOF)\n            return(-1);\n          buffer[i] = (unsigned char) c;\n        }\n        buffer[4]=0;\n        if (strcmp((const char *)buffer, \"8BIM\") == 0)\n          foundOSType=1;\n        else\n          continue;\n      }\n    else\n      {\n        c=ReadBlobByte(ifile);\n        continue;\n      }\n    /*\n      We found the OSType (8BIM) and now grab the ID, PString, and Size fields.\n    */\n    ID=ReadBlobMSBSignedShort(ifile);\n    if (ID < 0)\n      return(-1);\n    {\n      unsigned char\n        plen;\n\n      c=ReadBlobByte(ifile);\n      if (c == EOF)\n        return(-1);\n      plen = (unsigned char) c;\n      PString=(unsigned char *) AcquireQuantumMemory((size_t) (plen+\n        MagickPathExtent),sizeof(*PString));\n      if (PString == (unsigned char *) NULL)\n        return 0;\n      for (i=0; i<plen; i++)\n      {\n        c=ReadBlobByte(ifile);\n        if (c == EOF)\n          {\n            PString=(unsigned char *) RelinquishMagickMemory(PString);\n            return -1;\n          }\n        PString[i] = (unsigned char) c;\n      }\n      PString[ plen ] = 0;\n      if ((plen & 0x01) == 0)\n      {\n        c=ReadBlobByte(ifile);\n        if (c == EOF)\n          {\n            PString=(unsigned char *) RelinquishMagickMemory(PString);\n            return -1;\n          }\n      }\n    }\n    count=(ssize_t) ReadBlobMSBSignedLong(ifile);\n    if ((count < 0) || (count > GetBlobSize(ifile)))\n      {\n        PString=(unsigned char *) RelinquishMagickMemory(PString);\n        return -1;\n      }\n    /* make a buffer to hold the data and snag it from the input stream */\n    str=(unsigned char *) AcquireQuantumMemory((size_t) count,sizeof(*str));\n    if (str == (unsigned char *) NULL)\n      {\n        PString=(unsigned char *) RelinquishMagickMemory(PString);\n        return 0;\n      }\n    for (i=0; i < (ssize_t) count; i++)\n    {\n      c=ReadBlobByte(ifile);\n      if (c == EOF)\n        {\n          str=(unsigned char *) RelinquishMagickMemory(str);\n          PString=(unsigned char *) RelinquishMagickMemory(PString);\n          return -1;\n        }\n      str[i]=(unsigned char) c;\n    }\n\n    /* we currently skip thumbnails, since it does not make\n     * any sense preserving them in a real world application\n     */\n    if (ID != THUMBNAIL_ID)\n      {\n        /* now finish up by formatting this binary data into\n         * ASCII equivalent\n         */\n        if (strlen((const char *)PString) > 0)\n          (void) FormatLocaleString(temp,MagickPathExtent,\"8BIM#%d#%s=\",ID,\n            PString);\n        else\n          (void) FormatLocaleString(temp,MagickPathExtent,\"8BIM#%d=\",ID);\n        (void) WriteBlobString(ofile,temp);\n        if (ID == IPTC_ID)\n          {\n            formatString(ofile, \"IPTC\", 4);\n            formatIPTCfromBuffer(ofile, (char *)str, (ssize_t) count);\n          }\n        else\n          formatString(ofile, (char *)str, (ssize_t) count);\n      }\n    str=(unsigned char *) RelinquishMagickMemory(str);\n    PString=(unsigned char *) RelinquishMagickMemory(PString);\n    resCount++;\n    c=ReadBlobByte(ifile);\n  }\n  return resCount;\n}",
        "func": "static int format8BIM(Image *ifile, Image *ofile)\n{\n  char\n    temp[MagickPathExtent];\n\n  unsigned int\n    foundOSType;\n\n  int\n    ID,\n    resCount,\n    i,\n    c;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *PString,\n    *str;\n\n  resCount=0;\n  foundOSType=0; /* found the OSType */\n  (void) foundOSType;\n  c=ReadBlobByte(ifile);\n  while (c != EOF)\n  {\n    if (c == '8')\n      {\n        unsigned char\n          buffer[5];\n\n        buffer[0]=(unsigned char) c;\n        for (i=1; i<4; i++)\n        {\n          c=ReadBlobByte(ifile);\n          if (c == EOF)\n            return(-1);\n          buffer[i] = (unsigned char) c;\n        }\n        buffer[4]=0;\n        if (strcmp((const char *)buffer, \"8BIM\") == 0)\n          foundOSType=1;\n        else\n          continue;\n      }\n    else\n      {\n        c=ReadBlobByte(ifile);\n        continue;\n      }\n    /*\n      We found the OSType (8BIM) and now grab the ID, PString, and Size fields.\n    */\n    ID=ReadBlobMSBSignedShort(ifile);\n    if (ID < 0)\n      return(-1);\n    {\n      unsigned char\n        plen;\n\n      c=ReadBlobByte(ifile);\n      if (c == EOF)\n        return(-1);\n      plen = (unsigned char) c;\n      PString=(unsigned char *) AcquireQuantumMemory((size_t) (plen+\n        MagickPathExtent),sizeof(*PString));\n      if (PString == (unsigned char *) NULL)\n        return 0;\n      for (i=0; i<plen; i++)\n      {\n        c=ReadBlobByte(ifile);\n        if (c == EOF)\n          {\n            PString=(unsigned char *) RelinquishMagickMemory(PString);\n            return -1;\n          }\n        PString[i] = (unsigned char) c;\n      }\n      PString[ plen ] = 0;\n      if ((plen & 0x01) == 0)\n      {\n        c=ReadBlobByte(ifile);\n        if (c == EOF)\n          {\n            PString=(unsigned char *) RelinquishMagickMemory(PString);\n            return -1;\n          }\n      }\n    }\n    count=(ssize_t) ReadBlobMSBSignedLong(ifile);\n    if ((count < 0) || (count > GetBlobSize(ifile)))\n      {\n        PString=(unsigned char *) RelinquishMagickMemory(PString);\n        return -1;\n      }\n    /* make a buffer to hold the data and snag it from the input stream */\n    str=(unsigned char *) AcquireQuantumMemory((size_t) count+1,sizeof(*str));\n    if (str == (unsigned char *) NULL)\n      {\n        PString=(unsigned char *) RelinquishMagickMemory(PString);\n        return 0;\n      }\n    for (i=0; i < (ssize_t) count; i++)\n    {\n      c=ReadBlobByte(ifile);\n      if (c == EOF)\n        {\n          str=(unsigned char *) RelinquishMagickMemory(str);\n          PString=(unsigned char *) RelinquishMagickMemory(PString);\n          return -1;\n        }\n      str[i]=(unsigned char) c;\n    }\n\n    /* we currently skip thumbnails, since it does not make\n     * any sense preserving them in a real world application\n     */\n    if (ID != THUMBNAIL_ID)\n      {\n        /* now finish up by formatting this binary data into\n         * ASCII equivalent\n         */\n        if (strlen((const char *)PString) > 0)\n          (void) FormatLocaleString(temp,MagickPathExtent,\"8BIM#%d#%s=\",ID,\n            PString);\n        else\n          (void) FormatLocaleString(temp,MagickPathExtent,\"8BIM#%d=\",ID);\n        (void) WriteBlobString(ofile,temp);\n        if (ID == IPTC_ID)\n          {\n            formatString(ofile, \"IPTC\", 4);\n            formatIPTCfromBuffer(ofile, (char *)str, (ssize_t) count);\n          }\n        else\n          formatString(ofile, (char *)str, (ssize_t) count);\n      }\n    str=(unsigned char *) RelinquishMagickMemory(str);\n    PString=(unsigned char *) RelinquishMagickMemory(PString);\n    resCount++;\n    c=ReadBlobByte(ifile);\n  }\n  return resCount;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -95,7 +95,7 @@\n         return -1;\n       }\n     /* make a buffer to hold the data and snag it from the input stream */\n-    str=(unsigned char *) AcquireQuantumMemory((size_t) count,sizeof(*str));\n+    str=(unsigned char *) AcquireQuantumMemory((size_t) count+1,sizeof(*str));\n     if (str == (unsigned char *) NULL)\n       {\n         PString=(unsigned char *) RelinquishMagickMemory(PString);",
        "diff_line_info": {
            "deleted_lines": [
                "    str=(unsigned char *) AcquireQuantumMemory((size_t) count,sizeof(*str));"
            ],
            "added_lines": [
                "    str=(unsigned char *) AcquireQuantumMemory((size_t) count+1,sizeof(*str));"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-5331",
        "func_name": "torvalds/linux/radeon_atom_get_tv_timings",
        "description": "In the Linux kernel before 2.6.34, a range check issue in drivers/gpu/drm/radeon/atombios.c could cause an off by one (buffer overflow) problem. NOTE: At least one Linux maintainer believes that this CVE is incorrectly assigned and should be rejected because the value is hard coded and are not user-controllable where it is used",
        "git_url": "https://github.com/torvalds/linux/commit/0031c41be5c529f8329e327b63cde92ba1284842",
        "commit_title": "drivers/gpu/drm/radeon/radeon_atombios.c: range check issues",
        "commit_text": " This change makes the array larger, \"MAX_SUPPORTED_TV_TIMING_V1_2\" is 3 and the original size \"MAX_SUPPORTED_TV_TIMING\" is 2.  Also there were checks that were off by one. ",
        "func_before": "bool radeon_atom_get_tv_timings(struct radeon_device *rdev, int index,\n\t\t\t\tstruct drm_display_mode *mode)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tATOM_ANALOG_TV_INFO *tv_info;\n\tATOM_ANALOG_TV_INFO_V1_2 *tv_info_v1_2;\n\tATOM_DTD_FORMAT *dtd_timings;\n\tint data_index = GetIndexIntoMasterTable(DATA, AnalogTV_Info);\n\tu8 frev, crev;\n\tu16 data_offset, misc;\n\n\tif (!atom_parse_data_header(mode_info->atom_context, data_index, NULL,\n\t\t\t\t    &frev, &crev, &data_offset))\n\t\treturn false;\n\n\tswitch (crev) {\n\tcase 1:\n\t\ttv_info = (ATOM_ANALOG_TV_INFO *)(mode_info->atom_context->bios + data_offset);\n\t\tif (index > MAX_SUPPORTED_TV_TIMING)\n\t\t\treturn false;\n\n\t\tmode->crtc_htotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Total);\n\t\tmode->crtc_hdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Disp);\n\t\tmode->crtc_hsync_start = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncStart);\n\t\tmode->crtc_hsync_end = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncStart) +\n\t\t\tle16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncWidth);\n\n\t\tmode->crtc_vtotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_Total);\n\t\tmode->crtc_vdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_Disp);\n\t\tmode->crtc_vsync_start = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart);\n\t\tmode->crtc_vsync_end = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart) +\n\t\t\tle16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncWidth);\n\n\t\tmode->flags = 0;\n\t\tmisc = le16_to_cpu(tv_info->aModeTimings[index].susModeMiscInfo.usAccess);\n\t\tif (misc & ATOM_VSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NVSYNC;\n\t\tif (misc & ATOM_HSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NHSYNC;\n\t\tif (misc & ATOM_COMPOSITESYNC)\n\t\t\tmode->flags |= DRM_MODE_FLAG_CSYNC;\n\t\tif (misc & ATOM_INTERLACE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_INTERLACE;\n\t\tif (misc & ATOM_DOUBLE_CLOCK_MODE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_DBLSCAN;\n\n\t\tmode->clock = le16_to_cpu(tv_info->aModeTimings[index].usPixelClock) * 10;\n\n\t\tif (index == 1) {\n\t\t\t/* PAL timings appear to have wrong values for totals */\n\t\t\tmode->crtc_htotal -= 1;\n\t\t\tmode->crtc_vtotal -= 1;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\ttv_info_v1_2 = (ATOM_ANALOG_TV_INFO_V1_2 *)(mode_info->atom_context->bios + data_offset);\n\t\tif (index > MAX_SUPPORTED_TV_TIMING_V1_2)\n\t\t\treturn false;\n\n\t\tdtd_timings = &tv_info_v1_2->aModeTimings[index];\n\t\tmode->crtc_htotal = le16_to_cpu(dtd_timings->usHActive) +\n\t\t\tle16_to_cpu(dtd_timings->usHBlanking_Time);\n\t\tmode->crtc_hdisplay = le16_to_cpu(dtd_timings->usHActive);\n\t\tmode->crtc_hsync_start = le16_to_cpu(dtd_timings->usHActive) +\n\t\t\tle16_to_cpu(dtd_timings->usHSyncOffset);\n\t\tmode->crtc_hsync_end = mode->crtc_hsync_start +\n\t\t\tle16_to_cpu(dtd_timings->usHSyncWidth);\n\n\t\tmode->crtc_vtotal = le16_to_cpu(dtd_timings->usVActive) +\n\t\t\tle16_to_cpu(dtd_timings->usVBlanking_Time);\n\t\tmode->crtc_vdisplay = le16_to_cpu(dtd_timings->usVActive);\n\t\tmode->crtc_vsync_start = le16_to_cpu(dtd_timings->usVActive) +\n\t\t\tle16_to_cpu(dtd_timings->usVSyncOffset);\n\t\tmode->crtc_vsync_end = mode->crtc_vsync_start +\n\t\t\tle16_to_cpu(dtd_timings->usVSyncWidth);\n\n\t\tmode->flags = 0;\n\t\tmisc = le16_to_cpu(dtd_timings->susModeMiscInfo.usAccess);\n\t\tif (misc & ATOM_VSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NVSYNC;\n\t\tif (misc & ATOM_HSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NHSYNC;\n\t\tif (misc & ATOM_COMPOSITESYNC)\n\t\t\tmode->flags |= DRM_MODE_FLAG_CSYNC;\n\t\tif (misc & ATOM_INTERLACE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_INTERLACE;\n\t\tif (misc & ATOM_DOUBLE_CLOCK_MODE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_DBLSCAN;\n\n\t\tmode->clock = le16_to_cpu(dtd_timings->usPixClk) * 10;\n\t\tbreak;\n\t}\n\treturn true;\n}",
        "func": "bool radeon_atom_get_tv_timings(struct radeon_device *rdev, int index,\n\t\t\t\tstruct drm_display_mode *mode)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tATOM_ANALOG_TV_INFO *tv_info;\n\tATOM_ANALOG_TV_INFO_V1_2 *tv_info_v1_2;\n\tATOM_DTD_FORMAT *dtd_timings;\n\tint data_index = GetIndexIntoMasterTable(DATA, AnalogTV_Info);\n\tu8 frev, crev;\n\tu16 data_offset, misc;\n\n\tif (!atom_parse_data_header(mode_info->atom_context, data_index, NULL,\n\t\t\t\t    &frev, &crev, &data_offset))\n\t\treturn false;\n\n\tswitch (crev) {\n\tcase 1:\n\t\ttv_info = (ATOM_ANALOG_TV_INFO *)(mode_info->atom_context->bios + data_offset);\n\t\tif (index >= MAX_SUPPORTED_TV_TIMING)\n\t\t\treturn false;\n\n\t\tmode->crtc_htotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Total);\n\t\tmode->crtc_hdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Disp);\n\t\tmode->crtc_hsync_start = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncStart);\n\t\tmode->crtc_hsync_end = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncStart) +\n\t\t\tle16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncWidth);\n\n\t\tmode->crtc_vtotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_Total);\n\t\tmode->crtc_vdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_Disp);\n\t\tmode->crtc_vsync_start = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart);\n\t\tmode->crtc_vsync_end = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart) +\n\t\t\tle16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncWidth);\n\n\t\tmode->flags = 0;\n\t\tmisc = le16_to_cpu(tv_info->aModeTimings[index].susModeMiscInfo.usAccess);\n\t\tif (misc & ATOM_VSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NVSYNC;\n\t\tif (misc & ATOM_HSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NHSYNC;\n\t\tif (misc & ATOM_COMPOSITESYNC)\n\t\t\tmode->flags |= DRM_MODE_FLAG_CSYNC;\n\t\tif (misc & ATOM_INTERLACE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_INTERLACE;\n\t\tif (misc & ATOM_DOUBLE_CLOCK_MODE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_DBLSCAN;\n\n\t\tmode->clock = le16_to_cpu(tv_info->aModeTimings[index].usPixelClock) * 10;\n\n\t\tif (index == 1) {\n\t\t\t/* PAL timings appear to have wrong values for totals */\n\t\t\tmode->crtc_htotal -= 1;\n\t\t\tmode->crtc_vtotal -= 1;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\ttv_info_v1_2 = (ATOM_ANALOG_TV_INFO_V1_2 *)(mode_info->atom_context->bios + data_offset);\n\t\tif (index >= MAX_SUPPORTED_TV_TIMING_V1_2)\n\t\t\treturn false;\n\n\t\tdtd_timings = &tv_info_v1_2->aModeTimings[index];\n\t\tmode->crtc_htotal = le16_to_cpu(dtd_timings->usHActive) +\n\t\t\tle16_to_cpu(dtd_timings->usHBlanking_Time);\n\t\tmode->crtc_hdisplay = le16_to_cpu(dtd_timings->usHActive);\n\t\tmode->crtc_hsync_start = le16_to_cpu(dtd_timings->usHActive) +\n\t\t\tle16_to_cpu(dtd_timings->usHSyncOffset);\n\t\tmode->crtc_hsync_end = mode->crtc_hsync_start +\n\t\t\tle16_to_cpu(dtd_timings->usHSyncWidth);\n\n\t\tmode->crtc_vtotal = le16_to_cpu(dtd_timings->usVActive) +\n\t\t\tle16_to_cpu(dtd_timings->usVBlanking_Time);\n\t\tmode->crtc_vdisplay = le16_to_cpu(dtd_timings->usVActive);\n\t\tmode->crtc_vsync_start = le16_to_cpu(dtd_timings->usVActive) +\n\t\t\tle16_to_cpu(dtd_timings->usVSyncOffset);\n\t\tmode->crtc_vsync_end = mode->crtc_vsync_start +\n\t\t\tle16_to_cpu(dtd_timings->usVSyncWidth);\n\n\t\tmode->flags = 0;\n\t\tmisc = le16_to_cpu(dtd_timings->susModeMiscInfo.usAccess);\n\t\tif (misc & ATOM_VSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NVSYNC;\n\t\tif (misc & ATOM_HSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NHSYNC;\n\t\tif (misc & ATOM_COMPOSITESYNC)\n\t\t\tmode->flags |= DRM_MODE_FLAG_CSYNC;\n\t\tif (misc & ATOM_INTERLACE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_INTERLACE;\n\t\tif (misc & ATOM_DOUBLE_CLOCK_MODE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_DBLSCAN;\n\n\t\tmode->clock = le16_to_cpu(dtd_timings->usPixClk) * 10;\n\t\tbreak;\n\t}\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,7 @@\n \tswitch (crev) {\n \tcase 1:\n \t\ttv_info = (ATOM_ANALOG_TV_INFO *)(mode_info->atom_context->bios + data_offset);\n-\t\tif (index > MAX_SUPPORTED_TV_TIMING)\n+\t\tif (index >= MAX_SUPPORTED_TV_TIMING)\n \t\t\treturn false;\n \n \t\tmode->crtc_htotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Total);\n@@ -54,7 +54,7 @@\n \t\tbreak;\n \tcase 2:\n \t\ttv_info_v1_2 = (ATOM_ANALOG_TV_INFO_V1_2 *)(mode_info->atom_context->bios + data_offset);\n-\t\tif (index > MAX_SUPPORTED_TV_TIMING_V1_2)\n+\t\tif (index >= MAX_SUPPORTED_TV_TIMING_V1_2)\n \t\t\treturn false;\n \n \t\tdtd_timings = &tv_info_v1_2->aModeTimings[index];",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (index > MAX_SUPPORTED_TV_TIMING)",
                "\t\tif (index > MAX_SUPPORTED_TV_TIMING_V1_2)"
            ],
            "added_lines": [
                "\t\tif (index >= MAX_SUPPORTED_TV_TIMING)",
                "\t\tif (index >= MAX_SUPPORTED_TV_TIMING_V1_2)"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-14323",
        "func_name": "troglobit/ssdp-responder/ssdp_recv",
        "description": "SSDP Responder 1.x through 1.5 mishandles incoming network messages, leading to a stack-based buffer overflow by 1 byte. This results in a crash of the server, but only when strict stack checking is enabled. This is caused by an off-by-one error in ssdp_recv in ssdpd.c.",
        "git_url": "https://github.com/troglobit/ssdp-responder/commit/ce04b1f29a137198182f60bbb628d5ceb8171765",
        "commit_title": "Fix #1: Ensure recv buf is always NUL terminated",
        "commit_text": "",
        "func_before": "static void ssdp_recv(int sd)\n{\n\tssize_t len;\n\tstruct sockaddr sa;\n\tsocklen_t salen;\n\tchar buf[MAX_PKT_SIZE];\n\n\tmemset(buf, 0, sizeof(buf));\n\tlen = recvfrom(sd, buf, sizeof(buf), MSG_DONTWAIT, &sa, &salen);\n\tif (len > 0) {\n\t\tbuf[len] = 0;\n\n\t\tif (sa.sa_family != AF_INET)\n\t\t\treturn;\n\n\t\tif (strstr(buf, \"M-SEARCH *\")) {\n\t\t\tsize_t i;\n\t\t\tchar *ptr, *type;\n\t\t\tstruct ifsock *ifs;\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&sa;\n\n\t\t\tifs = find_outbound(&sa);\n\t\t\tif (!ifs) {\n\t\t\t\tlogit(LOG_DEBUG, \"No matching socket for client %s\", inet_ntoa(sin->sin_addr));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlogit(LOG_DEBUG, \"Matching socket for client %s\", inet_ntoa(sin->sin_addr));\n\n\t\t\ttype = strcasestr(buf, \"\\r\\nST:\");\n\t\t\tif (!type) {\n\t\t\t\tlogit(LOG_DEBUG, \"No Search Type (ST:) found in M-SEARCH *, assuming \" SSDP_ST_ALL);\n\t\t\t\ttype = SSDP_ST_ALL;\n\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttype = strchr(type, ':');\n\t\t\tif (!type)\n\t\t\t\treturn;\n\t\t\ttype++;\n\t\t\twhile (isspace(*type))\n\t\t\t\ttype++;\n\n\t\t\tptr = strstr(type, \"\\r\\n\");\n\t\t\tif (!ptr)\n\t\t\t\treturn;\n\t\t\t*ptr = 0;\n\n\t\t\tfor (i = 0; supported_types[i]; i++) {\n\t\t\t\tif (!strcmp(supported_types[i], type)) {\n\t\t\t\t\tlogit(LOG_DEBUG, \"M-SEARCH * ST: %s from %s port %d\", type,\n\t\t\t\t\t      inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogit(LOG_DEBUG, \"M-SEARCH * for unsupported ST: %s from %s\", type,\n\t\t\t      inet_ntoa(sin->sin_addr));\n\t\t}\n\t}\n}",
        "func": "static void ssdp_recv(int sd)\n{\n\tssize_t len;\n\tstruct sockaddr sa;\n\tsocklen_t salen;\n\tchar buf[MAX_PKT_SIZE + 1];\n\n\tmemset(buf, 0, sizeof(buf));\n\tlen = recvfrom(sd, buf, sizeof(buf) - 1, MSG_DONTWAIT, &sa, &salen);\n\tif (len > 0) {\n\t\tif (sa.sa_family != AF_INET)\n\t\t\treturn;\n\n\t\tif (strstr(buf, \"M-SEARCH *\")) {\n\t\t\tsize_t i;\n\t\t\tchar *ptr, *type;\n\t\t\tstruct ifsock *ifs;\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&sa;\n\n\t\t\tifs = find_outbound(&sa);\n\t\t\tif (!ifs) {\n\t\t\t\tlogit(LOG_DEBUG, \"No matching socket for client %s\", inet_ntoa(sin->sin_addr));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlogit(LOG_DEBUG, \"Matching socket for client %s\", inet_ntoa(sin->sin_addr));\n\n\t\t\ttype = strcasestr(buf, \"\\r\\nST:\");\n\t\t\tif (!type) {\n\t\t\t\tlogit(LOG_DEBUG, \"No Search Type (ST:) found in M-SEARCH *, assuming \" SSDP_ST_ALL);\n\t\t\t\ttype = SSDP_ST_ALL;\n\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttype = strchr(type, ':');\n\t\t\tif (!type)\n\t\t\t\treturn;\n\t\t\ttype++;\n\t\t\twhile (isspace(*type))\n\t\t\t\ttype++;\n\n\t\t\tptr = strstr(type, \"\\r\\n\");\n\t\t\tif (!ptr)\n\t\t\t\treturn;\n\t\t\t*ptr = 0;\n\n\t\t\tfor (i = 0; supported_types[i]; i++) {\n\t\t\t\tif (!strcmp(supported_types[i], type)) {\n\t\t\t\t\tlogit(LOG_DEBUG, \"M-SEARCH * ST: %s from %s port %d\", type,\n\t\t\t\t\t      inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlogit(LOG_DEBUG, \"M-SEARCH * for unsupported ST: %s from %s\", type,\n\t\t\t      inet_ntoa(sin->sin_addr));\n\t\t}\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,13 +3,11 @@\n \tssize_t len;\n \tstruct sockaddr sa;\n \tsocklen_t salen;\n-\tchar buf[MAX_PKT_SIZE];\n+\tchar buf[MAX_PKT_SIZE + 1];\n \n \tmemset(buf, 0, sizeof(buf));\n-\tlen = recvfrom(sd, buf, sizeof(buf), MSG_DONTWAIT, &sa, &salen);\n+\tlen = recvfrom(sd, buf, sizeof(buf) - 1, MSG_DONTWAIT, &sa, &salen);\n \tif (len > 0) {\n-\t\tbuf[len] = 0;\n-\n \t\tif (sa.sa_family != AF_INET)\n \t\t\treturn;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tchar buf[MAX_PKT_SIZE];",
                "\tlen = recvfrom(sd, buf, sizeof(buf), MSG_DONTWAIT, &sa, &salen);",
                "\t\tbuf[len] = 0;",
                ""
            ],
            "added_lines": [
                "\tchar buf[MAX_PKT_SIZE + 1];",
                "\tlen = recvfrom(sd, buf, sizeof(buf) - 1, MSG_DONTWAIT, &sa, &salen);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18423",
        "func_name": "xen-project/xen/p2m_get_root_pointer",
        "description": "An issue was discovered in Xen through 4.12.x allowing ARM guest OS users to cause a denial of service via a XENMEM_add_to_physmap hypercall. p2m->max_mapped_gfn is used by the functions p2m_resolve_translation_fault() and p2m_get_entry() to sanity check guest physical frame. The rest of the code in the two functions will assume that there is a valid root table and check that with BUG_ON(). The function p2m_get_root_pointer() will ignore the unused top bits of a guest physical frame. This means that the function p2m_set_entry() will alias the frame. However, p2m->max_mapped_gfn will be updated using the original frame. It would be possible to set p2m->max_mapped_gfn high enough to cover a frame that would lead p2m_get_root_pointer() to return NULL in p2m_get_entry() and p2m_resolve_translation_fault(). Additionally, the sanity check on p2m->max_mapped_gfn is off-by-one allowing \"highest mapped + 1\" to be considered valid. However, p2m_get_root_pointer() will return NULL. The problem could be triggered with a specially crafted hypercall XENMEM_add_to_physmap{, _batch} followed by an access to an address (via hypercall or direct access) that passes the sanity check but cause p2m_get_root_pointer() to return NULL. A malicious guest administrator may cause a hypervisor crash, resulting in a Denial of Service (DoS). Xen version 4.8 and newer are vulnerable. Only Arm systems are vulnerable. x86 systems are not affected.",
        "git_url": "https://github.com/xen-project/xen/commit/88aaf40eeff771c546ad3bbb02000171648a89f7",
        "commit_title": "xen/arm: p2m: Avoid aliasing guest physical frame",
        "commit_text": " The P2M helpers implementation is quite lax and will end up to ignore the unused top bits of a guest physical frame.  This effectively means that p2m_set_entry() will create a mapping for a different frame (it is always equal to gfn & (mask unused bits)). Yet p2m->max_mapped_gfn will be updated using the original frame.  At the moment, p2m_get_entry() and p2m_resolve_translation_fault() assume that p2m_get_root_pointer() will always return a non-NULL pointer when the GFN is smaller than p2m->max_mapped_gfn.  Unfortunately, because of the aliasing described above, it would be possible to set p2m->max_mapped_gfn high enough so it covers frame that would lead p2m_get_root_pointer() to return NULL.  As we don't sanity check the guest physical frame provided by a guest, a malicious guest could craft a series of hypercalls that will hit the BUG_ON() and therefore DoS Xen.  To prevent aliasing, the function p2m_get_root_pointer() is now reworked to return NULL If any of the unused top bits are not zero. The caller can then decide what's the appropriate action to do. Since the two paths (i.e. P2M_ROOT_PAGES == 1 and P2M_ROOT_PAGES != 1) are now very similarly, take the opportunity to consolidate them making the code a bit simpler.  With this change, p2m_get_entry() will not try to insert a mapping as the root pointer is invalid.  Note that root_table is now switch to unsigned long as unsigned int is not enough to hold part of a GFN.  This is part of XSA-301. ",
        "func_before": "static lpae_t *p2m_get_root_pointer(struct p2m_domain *p2m,\n                                    gfn_t gfn)\n{\n    unsigned int root_table;\n\n    if ( P2M_ROOT_PAGES == 1 )\n        return __map_domain_page(p2m->root);\n\n    /*\n     * Concatenated root-level tables. The table number will be the\n     * offset at the previous level. It is not possible to\n     * concatenate a level-0 root.\n     */\n    ASSERT(P2M_ROOT_LEVEL > 0);\n\n    root_table = gfn_x(gfn) >> (level_orders[P2M_ROOT_LEVEL - 1]);\n    root_table &= LPAE_ENTRY_MASK;\n\n    if ( root_table >= P2M_ROOT_PAGES )\n        return NULL;\n\n    return __map_domain_page(p2m->root + root_table);\n}",
        "func": "static lpae_t *p2m_get_root_pointer(struct p2m_domain *p2m,\n                                    gfn_t gfn)\n{\n    unsigned long root_table;\n\n    /*\n     * While the root table index is the offset from the previous level,\n     * we can't use (P2M_ROOT_LEVEL - 1) because the root level might be\n     * 0. Yet we still want to check if all the unused bits are zeroed.\n     */\n    root_table = gfn_x(gfn) >> (level_orders[P2M_ROOT_LEVEL] + LPAE_SHIFT);\n    if ( root_table >= P2M_ROOT_PAGES )\n        return NULL;\n\n    return __map_domain_page(p2m->root + root_table);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,21 +1,14 @@\n static lpae_t *p2m_get_root_pointer(struct p2m_domain *p2m,\n                                     gfn_t gfn)\n {\n-    unsigned int root_table;\n-\n-    if ( P2M_ROOT_PAGES == 1 )\n-        return __map_domain_page(p2m->root);\n+    unsigned long root_table;\n \n     /*\n-     * Concatenated root-level tables. The table number will be the\n-     * offset at the previous level. It is not possible to\n-     * concatenate a level-0 root.\n+     * While the root table index is the offset from the previous level,\n+     * we can't use (P2M_ROOT_LEVEL - 1) because the root level might be\n+     * 0. Yet we still want to check if all the unused bits are zeroed.\n      */\n-    ASSERT(P2M_ROOT_LEVEL > 0);\n-\n-    root_table = gfn_x(gfn) >> (level_orders[P2M_ROOT_LEVEL - 1]);\n-    root_table &= LPAE_ENTRY_MASK;\n-\n+    root_table = gfn_x(gfn) >> (level_orders[P2M_ROOT_LEVEL] + LPAE_SHIFT);\n     if ( root_table >= P2M_ROOT_PAGES )\n         return NULL;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    unsigned int root_table;",
                "",
                "    if ( P2M_ROOT_PAGES == 1 )",
                "        return __map_domain_page(p2m->root);",
                "     * Concatenated root-level tables. The table number will be the",
                "     * offset at the previous level. It is not possible to",
                "     * concatenate a level-0 root.",
                "    ASSERT(P2M_ROOT_LEVEL > 0);",
                "",
                "    root_table = gfn_x(gfn) >> (level_orders[P2M_ROOT_LEVEL - 1]);",
                "    root_table &= LPAE_ENTRY_MASK;",
                ""
            ],
            "added_lines": [
                "    unsigned long root_table;",
                "     * While the root table index is the offset from the previous level,",
                "     * we can't use (P2M_ROOT_LEVEL - 1) because the root level might be",
                "     * 0. Yet we still want to check if all the unused bits are zeroed.",
                "    root_table = gfn_x(gfn) >> (level_orders[P2M_ROOT_LEVEL] + LPAE_SHIFT);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18423",
        "func_name": "xen-project/xen/p2m_cache_flush_range",
        "description": "An issue was discovered in Xen through 4.12.x allowing ARM guest OS users to cause a denial of service via a XENMEM_add_to_physmap hypercall. p2m->max_mapped_gfn is used by the functions p2m_resolve_translation_fault() and p2m_get_entry() to sanity check guest physical frame. The rest of the code in the two functions will assume that there is a valid root table and check that with BUG_ON(). The function p2m_get_root_pointer() will ignore the unused top bits of a guest physical frame. This means that the function p2m_set_entry() will alias the frame. However, p2m->max_mapped_gfn will be updated using the original frame. It would be possible to set p2m->max_mapped_gfn high enough to cover a frame that would lead p2m_get_root_pointer() to return NULL in p2m_get_entry() and p2m_resolve_translation_fault(). Additionally, the sanity check on p2m->max_mapped_gfn is off-by-one allowing \"highest mapped + 1\" to be considered valid. However, p2m_get_root_pointer() will return NULL. The problem could be triggered with a specially crafted hypercall XENMEM_add_to_physmap{, _batch} followed by an access to an address (via hypercall or direct access) that passes the sanity check but cause p2m_get_root_pointer() to return NULL. A malicious guest administrator may cause a hypervisor crash, resulting in a Denial of Service (DoS). Xen version 4.8 and newer are vulnerable. Only Arm systems are vulnerable. x86 systems are not affected.",
        "git_url": "https://github.com/xen-project/xen/commit/6e8e163b46d0823526f1afbbe6f66c668fc811d1",
        "commit_title": "xen/arm: p2m: Avoid off-by-one check on p2m->max_mapped_gfn",
        "commit_text": " The code base is using inconsistently the field p2m->max_mapped_gfn. Some of the useres expect that p2m->max_guest_gfn contain the highest mapped GFN while others expect highest + 1.  p2m->max_guest_gfn is set as highest + 1, because of that the sanity check on the GFN in p2m_resolved_translation_fault() and p2m_get_entry() can be bypassed when GFN == p2m->max_guest_gfn.  p2m_get_root_pointer(p2m->max_guest_gfn) may return NULL if it is outside of address range supported and therefore the BUG_ON() could be hit.  The current value hold in p2m->max_mapped_gfn is inconsistent with the expectation of the common code (see domain_get_maximum_gpfn()) and also the documentation of the field.  Rather than changing the check in p2m_translation_fault() and p2m_get_entry(), p2m->max_mapped_gfn is now containing the highest mapped GFN and the callers assuming \"highest + 1\" are now adjusted.  Take the opportunity to use 1UL rather than 1 as page_order could theoritically big enough to overflow a 32-bit integer.  Lastly, the documentation of the field max_guest_gfn to reflect how it is computed.  This is part of XSA-301. ",
        "func_before": "int p2m_cache_flush_range(struct domain *d, gfn_t *pstart, gfn_t end)\n{\n    struct p2m_domain *p2m = p2m_get_hostp2m(d);\n    gfn_t next_block_gfn;\n    gfn_t start = *pstart;\n    mfn_t mfn = INVALID_MFN;\n    p2m_type_t t;\n    unsigned int order;\n    int rc = 0;\n    /* Counter for preemption */\n    unsigned short count = 0;\n\n    /*\n     * The operation cache flush will invalidate the RAM assigned to the\n     * guest in a given range. It will not modify the page table and\n     * flushing the cache whilst the page is used by another CPU is\n     * fine. So using read-lock is fine here.\n     */\n    p2m_read_lock(p2m);\n\n    start = gfn_max(start, p2m->lowest_mapped_gfn);\n    end = gfn_min(end, p2m->max_mapped_gfn);\n\n    next_block_gfn = start;\n\n    while ( gfn_x(start) < gfn_x(end) )\n    {\n       /*\n         * Cleaning the cache for the P2M may take a long time. So we\n         * need to be able to preempt. We will arbitrarily preempt every\n         * time count reach 512 or above.\n         *\n         * The count will be incremented by:\n         *  - 1 on region skipped\n         *  - 10 for each page requiring a flush\n         */\n        if ( count >= 512 )\n        {\n            if ( softirq_pending(smp_processor_id()) )\n            {\n                rc = -ERESTART;\n                break;\n            }\n            count = 0;\n        }\n\n        /*\n         * We want to flush page by page as:\n         *  - it may not be possible to map the full block (can be up to 1GB)\n         *    in Xen memory\n         *  - we may want to do fine grain preemption as flushing multiple\n         *    page in one go may take a long time\n         *\n         * As p2m_get_entry is able to return the size of the mapping\n         * in the p2m, it is pointless to execute it for each page.\n         *\n         * We can optimize it by tracking the gfn of the next\n         * block. So we will only call p2m_get_entry for each block (can\n         * be up to 1GB).\n         */\n        if ( gfn_eq(start, next_block_gfn) )\n        {\n            bool valid;\n\n            mfn = p2m_get_entry(p2m, start, &t, NULL, &order, &valid);\n            next_block_gfn = gfn_next_boundary(start, order);\n\n            if ( mfn_eq(mfn, INVALID_MFN) || !p2m_is_any_ram(t) || !valid )\n            {\n                count++;\n                start = next_block_gfn;\n                continue;\n            }\n        }\n\n        count += 10;\n\n        flush_page_to_ram(mfn_x(mfn), false);\n\n        start = gfn_add(start, 1);\n        mfn = mfn_add(mfn, 1);\n    }\n\n    if ( rc != -ERESTART )\n        invalidate_icache();\n\n    p2m_read_unlock(p2m);\n\n    *pstart = start;\n\n    return rc;\n}",
        "func": "int p2m_cache_flush_range(struct domain *d, gfn_t *pstart, gfn_t end)\n{\n    struct p2m_domain *p2m = p2m_get_hostp2m(d);\n    gfn_t next_block_gfn;\n    gfn_t start = *pstart;\n    mfn_t mfn = INVALID_MFN;\n    p2m_type_t t;\n    unsigned int order;\n    int rc = 0;\n    /* Counter for preemption */\n    unsigned short count = 0;\n\n    /*\n     * The operation cache flush will invalidate the RAM assigned to the\n     * guest in a given range. It will not modify the page table and\n     * flushing the cache whilst the page is used by another CPU is\n     * fine. So using read-lock is fine here.\n     */\n    p2m_read_lock(p2m);\n\n    start = gfn_max(start, p2m->lowest_mapped_gfn);\n    end = gfn_min(end, gfn_add(p2m->max_mapped_gfn, 1));\n\n    next_block_gfn = start;\n\n    while ( gfn_x(start) < gfn_x(end) )\n    {\n       /*\n         * Cleaning the cache for the P2M may take a long time. So we\n         * need to be able to preempt. We will arbitrarily preempt every\n         * time count reach 512 or above.\n         *\n         * The count will be incremented by:\n         *  - 1 on region skipped\n         *  - 10 for each page requiring a flush\n         */\n        if ( count >= 512 )\n        {\n            if ( softirq_pending(smp_processor_id()) )\n            {\n                rc = -ERESTART;\n                break;\n            }\n            count = 0;\n        }\n\n        /*\n         * We want to flush page by page as:\n         *  - it may not be possible to map the full block (can be up to 1GB)\n         *    in Xen memory\n         *  - we may want to do fine grain preemption as flushing multiple\n         *    page in one go may take a long time\n         *\n         * As p2m_get_entry is able to return the size of the mapping\n         * in the p2m, it is pointless to execute it for each page.\n         *\n         * We can optimize it by tracking the gfn of the next\n         * block. So we will only call p2m_get_entry for each block (can\n         * be up to 1GB).\n         */\n        if ( gfn_eq(start, next_block_gfn) )\n        {\n            bool valid;\n\n            mfn = p2m_get_entry(p2m, start, &t, NULL, &order, &valid);\n            next_block_gfn = gfn_next_boundary(start, order);\n\n            if ( mfn_eq(mfn, INVALID_MFN) || !p2m_is_any_ram(t) || !valid )\n            {\n                count++;\n                start = next_block_gfn;\n                continue;\n            }\n        }\n\n        count += 10;\n\n        flush_page_to_ram(mfn_x(mfn), false);\n\n        start = gfn_add(start, 1);\n        mfn = mfn_add(mfn, 1);\n    }\n\n    if ( rc != -ERESTART )\n        invalidate_icache();\n\n    p2m_read_unlock(p2m);\n\n    *pstart = start;\n\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,7 +19,7 @@\n     p2m_read_lock(p2m);\n \n     start = gfn_max(start, p2m->lowest_mapped_gfn);\n-    end = gfn_min(end, p2m->max_mapped_gfn);\n+    end = gfn_min(end, gfn_add(p2m->max_mapped_gfn, 1));\n \n     next_block_gfn = start;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    end = gfn_min(end, p2m->max_mapped_gfn);"
            ],
            "added_lines": [
                "    end = gfn_min(end, gfn_add(p2m->max_mapped_gfn, 1));"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18423",
        "func_name": "xen-project/xen/relinquish_p2m_mapping",
        "description": "An issue was discovered in Xen through 4.12.x allowing ARM guest OS users to cause a denial of service via a XENMEM_add_to_physmap hypercall. p2m->max_mapped_gfn is used by the functions p2m_resolve_translation_fault() and p2m_get_entry() to sanity check guest physical frame. The rest of the code in the two functions will assume that there is a valid root table and check that with BUG_ON(). The function p2m_get_root_pointer() will ignore the unused top bits of a guest physical frame. This means that the function p2m_set_entry() will alias the frame. However, p2m->max_mapped_gfn will be updated using the original frame. It would be possible to set p2m->max_mapped_gfn high enough to cover a frame that would lead p2m_get_root_pointer() to return NULL in p2m_get_entry() and p2m_resolve_translation_fault(). Additionally, the sanity check on p2m->max_mapped_gfn is off-by-one allowing \"highest mapped + 1\" to be considered valid. However, p2m_get_root_pointer() will return NULL. The problem could be triggered with a specially crafted hypercall XENMEM_add_to_physmap{, _batch} followed by an access to an address (via hypercall or direct access) that passes the sanity check but cause p2m_get_root_pointer() to return NULL. A malicious guest administrator may cause a hypervisor crash, resulting in a Denial of Service (DoS). Xen version 4.8 and newer are vulnerable. Only Arm systems are vulnerable. x86 systems are not affected.",
        "git_url": "https://github.com/xen-project/xen/commit/6e8e163b46d0823526f1afbbe6f66c668fc811d1",
        "commit_title": "xen/arm: p2m: Avoid off-by-one check on p2m->max_mapped_gfn",
        "commit_text": " The code base is using inconsistently the field p2m->max_mapped_gfn. Some of the useres expect that p2m->max_guest_gfn contain the highest mapped GFN while others expect highest + 1.  p2m->max_guest_gfn is set as highest + 1, because of that the sanity check on the GFN in p2m_resolved_translation_fault() and p2m_get_entry() can be bypassed when GFN == p2m->max_guest_gfn.  p2m_get_root_pointer(p2m->max_guest_gfn) may return NULL if it is outside of address range supported and therefore the BUG_ON() could be hit.  The current value hold in p2m->max_mapped_gfn is inconsistent with the expectation of the common code (see domain_get_maximum_gpfn()) and also the documentation of the field.  Rather than changing the check in p2m_translation_fault() and p2m_get_entry(), p2m->max_mapped_gfn is now containing the highest mapped GFN and the callers assuming \"highest + 1\" are now adjusted.  Take the opportunity to use 1UL rather than 1 as page_order could theoritically big enough to overflow a 32-bit integer.  Lastly, the documentation of the field max_guest_gfn to reflect how it is computed.  This is part of XSA-301. ",
        "func_before": "int relinquish_p2m_mapping(struct domain *d)\n{\n    struct p2m_domain *p2m = p2m_get_hostp2m(d);\n    unsigned long count = 0;\n    p2m_type_t t;\n    int rc = 0;\n    unsigned int order;\n    gfn_t start, end;\n\n    p2m_write_lock(p2m);\n\n    start = p2m->lowest_mapped_gfn;\n    end = p2m->max_mapped_gfn;\n\n    for ( ; gfn_x(start) < gfn_x(end);\n          start = gfn_next_boundary(start, order) )\n    {\n        mfn_t mfn = p2m_get_entry(p2m, start, &t, NULL, &order, NULL);\n\n        count++;\n        /*\n         * Arbitrarily preempt every 512 iterations.\n         */\n        if ( !(count % 512) && hypercall_preempt_check() )\n        {\n            rc = -ERESTART;\n            break;\n        }\n\n        /*\n         * p2m_set_entry will take care of removing reference on page\n         * when it is necessary and removing the mapping in the p2m.\n         */\n        if ( !mfn_eq(mfn, INVALID_MFN) )\n        {\n            /*\n             * For valid mapping, the start will always be aligned as\n             * entry will be removed whilst relinquishing.\n             */\n            rc = __p2m_set_entry(p2m, start, order, INVALID_MFN,\n                                 p2m_invalid, p2m_access_rwx);\n            if ( unlikely(rc) )\n            {\n                printk(XENLOG_G_ERR \"Unable to remove mapping gfn=%#\"PRI_gfn\" order=%u from the p2m of domain %d\\n\", gfn_x(start), order, d->domain_id);\n                break;\n            }\n        }\n    }\n\n    /*\n     * Update lowest_mapped_gfn so on the next call we still start where\n     * we stopped.\n     */\n    p2m->lowest_mapped_gfn = start;\n\n    p2m_write_unlock(p2m);\n\n    return rc;\n}",
        "func": "int relinquish_p2m_mapping(struct domain *d)\n{\n    struct p2m_domain *p2m = p2m_get_hostp2m(d);\n    unsigned long count = 0;\n    p2m_type_t t;\n    int rc = 0;\n    unsigned int order;\n    gfn_t start, end;\n\n    p2m_write_lock(p2m);\n\n    start = p2m->lowest_mapped_gfn;\n    end = gfn_add(p2m->max_mapped_gfn, 1);\n\n    for ( ; gfn_x(start) < gfn_x(end);\n          start = gfn_next_boundary(start, order) )\n    {\n        mfn_t mfn = p2m_get_entry(p2m, start, &t, NULL, &order, NULL);\n\n        count++;\n        /*\n         * Arbitrarily preempt every 512 iterations.\n         */\n        if ( !(count % 512) && hypercall_preempt_check() )\n        {\n            rc = -ERESTART;\n            break;\n        }\n\n        /*\n         * p2m_set_entry will take care of removing reference on page\n         * when it is necessary and removing the mapping in the p2m.\n         */\n        if ( !mfn_eq(mfn, INVALID_MFN) )\n        {\n            /*\n             * For valid mapping, the start will always be aligned as\n             * entry will be removed whilst relinquishing.\n             */\n            rc = __p2m_set_entry(p2m, start, order, INVALID_MFN,\n                                 p2m_invalid, p2m_access_rwx);\n            if ( unlikely(rc) )\n            {\n                printk(XENLOG_G_ERR \"Unable to remove mapping gfn=%#\"PRI_gfn\" order=%u from the p2m of domain %d\\n\", gfn_x(start), order, d->domain_id);\n                break;\n            }\n        }\n    }\n\n    /*\n     * Update lowest_mapped_gfn so on the next call we still start where\n     * we stopped.\n     */\n    p2m->lowest_mapped_gfn = start;\n\n    p2m_write_unlock(p2m);\n\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n     p2m_write_lock(p2m);\n \n     start = p2m->lowest_mapped_gfn;\n-    end = p2m->max_mapped_gfn;\n+    end = gfn_add(p2m->max_mapped_gfn, 1);\n \n     for ( ; gfn_x(start) < gfn_x(end);\n           start = gfn_next_boundary(start, order) )",
        "diff_line_info": {
            "deleted_lines": [
                "    end = p2m->max_mapped_gfn;"
            ],
            "added_lines": [
                "    end = gfn_add(p2m->max_mapped_gfn, 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18423",
        "func_name": "xen-project/xen/__p2m_set_entry",
        "description": "An issue was discovered in Xen through 4.12.x allowing ARM guest OS users to cause a denial of service via a XENMEM_add_to_physmap hypercall. p2m->max_mapped_gfn is used by the functions p2m_resolve_translation_fault() and p2m_get_entry() to sanity check guest physical frame. The rest of the code in the two functions will assume that there is a valid root table and check that with BUG_ON(). The function p2m_get_root_pointer() will ignore the unused top bits of a guest physical frame. This means that the function p2m_set_entry() will alias the frame. However, p2m->max_mapped_gfn will be updated using the original frame. It would be possible to set p2m->max_mapped_gfn high enough to cover a frame that would lead p2m_get_root_pointer() to return NULL in p2m_get_entry() and p2m_resolve_translation_fault(). Additionally, the sanity check on p2m->max_mapped_gfn is off-by-one allowing \"highest mapped + 1\" to be considered valid. However, p2m_get_root_pointer() will return NULL. The problem could be triggered with a specially crafted hypercall XENMEM_add_to_physmap{, _batch} followed by an access to an address (via hypercall or direct access) that passes the sanity check but cause p2m_get_root_pointer() to return NULL. A malicious guest administrator may cause a hypervisor crash, resulting in a Denial of Service (DoS). Xen version 4.8 and newer are vulnerable. Only Arm systems are vulnerable. x86 systems are not affected.",
        "git_url": "https://github.com/xen-project/xen/commit/6e8e163b46d0823526f1afbbe6f66c668fc811d1",
        "commit_title": "xen/arm: p2m: Avoid off-by-one check on p2m->max_mapped_gfn",
        "commit_text": " The code base is using inconsistently the field p2m->max_mapped_gfn. Some of the useres expect that p2m->max_guest_gfn contain the highest mapped GFN while others expect highest + 1.  p2m->max_guest_gfn is set as highest + 1, because of that the sanity check on the GFN in p2m_resolved_translation_fault() and p2m_get_entry() can be bypassed when GFN == p2m->max_guest_gfn.  p2m_get_root_pointer(p2m->max_guest_gfn) may return NULL if it is outside of address range supported and therefore the BUG_ON() could be hit.  The current value hold in p2m->max_mapped_gfn is inconsistent with the expectation of the common code (see domain_get_maximum_gpfn()) and also the documentation of the field.  Rather than changing the check in p2m_translation_fault() and p2m_get_entry(), p2m->max_mapped_gfn is now containing the highest mapped GFN and the callers assuming \"highest + 1\" are now adjusted.  Take the opportunity to use 1UL rather than 1 as page_order could theoritically big enough to overflow a 32-bit integer.  Lastly, the documentation of the field max_guest_gfn to reflect how it is computed.  This is part of XSA-301. ",
        "func_before": "static int __p2m_set_entry(struct p2m_domain *p2m,\n                           gfn_t sgfn,\n                           unsigned int page_order,\n                           mfn_t smfn,\n                           p2m_type_t t,\n                           p2m_access_t a)\n{\n    unsigned int level = 0;\n    unsigned int target = 3 - (page_order / LPAE_SHIFT);\n    lpae_t *entry, *table, orig_pte;\n    int rc;\n    /* A mapping is removed if the MFN is invalid. */\n    bool removing_mapping = mfn_eq(smfn, INVALID_MFN);\n    DECLARE_OFFSETS(offsets, gfn_to_gaddr(sgfn));\n\n    ASSERT(p2m_is_write_locked(p2m));\n\n    /*\n     * Check if the level target is valid: we only support\n     * 4K - 2M - 1G mapping.\n     */\n    ASSERT(target > 0 && target <= 3);\n\n    table = p2m_get_root_pointer(p2m, sgfn);\n    if ( !table )\n        return -EINVAL;\n\n    for ( level = P2M_ROOT_LEVEL; level < target; level++ )\n    {\n        /*\n         * Don't try to allocate intermediate page table if the mapping\n         * is about to be removed.\n         */\n        rc = p2m_next_level(p2m, removing_mapping,\n                            level, &table, offsets[level]);\n        if ( rc == GUEST_TABLE_MAP_FAILED )\n        {\n            /*\n             * We are here because p2m_next_level has failed to map\n             * the intermediate page table (e.g the table does not exist\n             * and they p2m tree is read-only). It is a valid case\n             * when removing a mapping as it may not exist in the\n             * page table. In this case, just ignore it.\n             */\n            rc = removing_mapping ?  0 : -ENOENT;\n            goto out;\n        }\n        else if ( rc != GUEST_TABLE_NORMAL_PAGE )\n            break;\n    }\n\n    entry = table + offsets[level];\n\n    /*\n     * If we are here with level < target, we must be at a leaf node,\n     * and we need to break up the superpage.\n     */\n    if ( level < target )\n    {\n        /* We need to split the original page. */\n        lpae_t split_pte = *entry;\n\n        ASSERT(p2m_is_superpage(*entry, level));\n\n        if ( !p2m_split_superpage(p2m, &split_pte, level, target, offsets) )\n        {\n            /*\n             * The current super-page is still in-place, so re-increment\n             * the stats.\n             */\n            p2m->stats.mappings[level]++;\n\n            /* Free the allocated sub-tree */\n            p2m_free_entry(p2m, split_pte, level);\n\n            rc = -ENOMEM;\n            goto out;\n        }\n\n        /*\n         * Follow the break-before-sequence to update the entry.\n         * For more details see (D4.7.1 in ARM DDI 0487A.j).\n         */\n        p2m_remove_pte(entry, p2m->clean_pte);\n        p2m_force_tlb_flush_sync(p2m);\n\n        p2m_write_pte(entry, split_pte, p2m->clean_pte);\n\n        /* then move to the level we want to make real changes */\n        for ( ; level < target; level++ )\n        {\n            rc = p2m_next_level(p2m, true, level, &table, offsets[level]);\n\n            /*\n             * The entry should be found and either be a table\n             * or a superpage if level 3 is not targeted\n             */\n            ASSERT(rc == GUEST_TABLE_NORMAL_PAGE ||\n                   (rc == GUEST_TABLE_SUPER_PAGE && target < 3));\n        }\n\n        entry = table + offsets[level];\n    }\n\n    /*\n     * We should always be there with the correct level because\n     * all the intermediate tables have been installed if necessary.\n     */\n    ASSERT(level == target);\n\n    orig_pte = *entry;\n\n    /*\n     * The radix-tree can only work on 4KB. This is only used when\n     * memaccess is enabled and during shutdown.\n     */\n    ASSERT(!p2m->mem_access_enabled || page_order == 0 ||\n           p2m->domain->is_dying);\n    /*\n     * The access type should always be p2m_access_rwx when the mapping\n     * is removed.\n     */\n    ASSERT(!mfn_eq(INVALID_MFN, smfn) || (a == p2m_access_rwx));\n    /*\n     * Update the mem access permission before update the P2M. So we\n     * don't have to revert the mapping if it has failed.\n     */\n    rc = p2m_mem_access_radix_set(p2m, sgfn, a);\n    if ( rc )\n        goto out;\n\n    /*\n     * Always remove the entry in order to follow the break-before-make\n     * sequence when updating the translation table (D4.7.1 in ARM DDI\n     * 0487A.j).\n     */\n    if ( lpae_is_valid(orig_pte) )\n        p2m_remove_pte(entry, p2m->clean_pte);\n\n    if ( removing_mapping )\n        /* Flush can be deferred if the entry is removed */\n        p2m->need_flush |= !!lpae_is_valid(orig_pte);\n    else\n    {\n        lpae_t pte = mfn_to_p2m_entry(smfn, t, a);\n\n        if ( level < 3 )\n            pte.p2m.table = 0; /* Superpage entry */\n\n        /*\n         * It is necessary to flush the TLB before writing the new entry\n         * to keep coherency when the previous entry was valid.\n         *\n         * Although, it could be defered when only the permissions are\n         * changed (e.g in case of memaccess).\n         */\n        if ( lpae_is_valid(orig_pte) )\n        {\n            if ( likely(!p2m->mem_access_enabled) ||\n                 P2M_CLEAR_PERM(pte) != P2M_CLEAR_PERM(orig_pte) )\n                p2m_force_tlb_flush_sync(p2m);\n            else\n                p2m->need_flush = true;\n        }\n        else if ( !p2m_is_valid(orig_pte) ) /* new mapping */\n            p2m->stats.mappings[level]++;\n\n        p2m_write_pte(entry, pte, p2m->clean_pte);\n\n        p2m->max_mapped_gfn = gfn_max(p2m->max_mapped_gfn,\n                                      gfn_add(sgfn, 1 << page_order));\n        p2m->lowest_mapped_gfn = gfn_min(p2m->lowest_mapped_gfn, sgfn);\n    }\n\n    if ( is_iommu_enabled(p2m->domain) &&\n         (lpae_is_valid(orig_pte) || lpae_is_valid(*entry)) )\n    {\n        unsigned int flush_flags = 0;\n\n        if ( lpae_is_valid(orig_pte) )\n            flush_flags |= IOMMU_FLUSHF_modified;\n        if ( lpae_is_valid(*entry) )\n            flush_flags |= IOMMU_FLUSHF_added;\n\n        rc = iommu_iotlb_flush(p2m->domain, _dfn(gfn_x(sgfn)),\n                               1UL << page_order, flush_flags);\n    }\n    else\n        rc = 0;\n\n    /*\n     * Free the entry only if the original pte was valid and the base\n     * is different (to avoid freeing when permission is changed).\n     */\n    if ( p2m_is_valid(orig_pte) &&\n         !mfn_eq(lpae_get_mfn(*entry), lpae_get_mfn(orig_pte)) )\n        p2m_free_entry(p2m, orig_pte, level);\n\nout:\n    unmap_domain_page(table);\n\n    return rc;\n}",
        "func": "static int __p2m_set_entry(struct p2m_domain *p2m,\n                           gfn_t sgfn,\n                           unsigned int page_order,\n                           mfn_t smfn,\n                           p2m_type_t t,\n                           p2m_access_t a)\n{\n    unsigned int level = 0;\n    unsigned int target = 3 - (page_order / LPAE_SHIFT);\n    lpae_t *entry, *table, orig_pte;\n    int rc;\n    /* A mapping is removed if the MFN is invalid. */\n    bool removing_mapping = mfn_eq(smfn, INVALID_MFN);\n    DECLARE_OFFSETS(offsets, gfn_to_gaddr(sgfn));\n\n    ASSERT(p2m_is_write_locked(p2m));\n\n    /*\n     * Check if the level target is valid: we only support\n     * 4K - 2M - 1G mapping.\n     */\n    ASSERT(target > 0 && target <= 3);\n\n    table = p2m_get_root_pointer(p2m, sgfn);\n    if ( !table )\n        return -EINVAL;\n\n    for ( level = P2M_ROOT_LEVEL; level < target; level++ )\n    {\n        /*\n         * Don't try to allocate intermediate page table if the mapping\n         * is about to be removed.\n         */\n        rc = p2m_next_level(p2m, removing_mapping,\n                            level, &table, offsets[level]);\n        if ( rc == GUEST_TABLE_MAP_FAILED )\n        {\n            /*\n             * We are here because p2m_next_level has failed to map\n             * the intermediate page table (e.g the table does not exist\n             * and they p2m tree is read-only). It is a valid case\n             * when removing a mapping as it may not exist in the\n             * page table. In this case, just ignore it.\n             */\n            rc = removing_mapping ?  0 : -ENOENT;\n            goto out;\n        }\n        else if ( rc != GUEST_TABLE_NORMAL_PAGE )\n            break;\n    }\n\n    entry = table + offsets[level];\n\n    /*\n     * If we are here with level < target, we must be at a leaf node,\n     * and we need to break up the superpage.\n     */\n    if ( level < target )\n    {\n        /* We need to split the original page. */\n        lpae_t split_pte = *entry;\n\n        ASSERT(p2m_is_superpage(*entry, level));\n\n        if ( !p2m_split_superpage(p2m, &split_pte, level, target, offsets) )\n        {\n            /*\n             * The current super-page is still in-place, so re-increment\n             * the stats.\n             */\n            p2m->stats.mappings[level]++;\n\n            /* Free the allocated sub-tree */\n            p2m_free_entry(p2m, split_pte, level);\n\n            rc = -ENOMEM;\n            goto out;\n        }\n\n        /*\n         * Follow the break-before-sequence to update the entry.\n         * For more details see (D4.7.1 in ARM DDI 0487A.j).\n         */\n        p2m_remove_pte(entry, p2m->clean_pte);\n        p2m_force_tlb_flush_sync(p2m);\n\n        p2m_write_pte(entry, split_pte, p2m->clean_pte);\n\n        /* then move to the level we want to make real changes */\n        for ( ; level < target; level++ )\n        {\n            rc = p2m_next_level(p2m, true, level, &table, offsets[level]);\n\n            /*\n             * The entry should be found and either be a table\n             * or a superpage if level 3 is not targeted\n             */\n            ASSERT(rc == GUEST_TABLE_NORMAL_PAGE ||\n                   (rc == GUEST_TABLE_SUPER_PAGE && target < 3));\n        }\n\n        entry = table + offsets[level];\n    }\n\n    /*\n     * We should always be there with the correct level because\n     * all the intermediate tables have been installed if necessary.\n     */\n    ASSERT(level == target);\n\n    orig_pte = *entry;\n\n    /*\n     * The radix-tree can only work on 4KB. This is only used when\n     * memaccess is enabled and during shutdown.\n     */\n    ASSERT(!p2m->mem_access_enabled || page_order == 0 ||\n           p2m->domain->is_dying);\n    /*\n     * The access type should always be p2m_access_rwx when the mapping\n     * is removed.\n     */\n    ASSERT(!mfn_eq(INVALID_MFN, smfn) || (a == p2m_access_rwx));\n    /*\n     * Update the mem access permission before update the P2M. So we\n     * don't have to revert the mapping if it has failed.\n     */\n    rc = p2m_mem_access_radix_set(p2m, sgfn, a);\n    if ( rc )\n        goto out;\n\n    /*\n     * Always remove the entry in order to follow the break-before-make\n     * sequence when updating the translation table (D4.7.1 in ARM DDI\n     * 0487A.j).\n     */\n    if ( lpae_is_valid(orig_pte) )\n        p2m_remove_pte(entry, p2m->clean_pte);\n\n    if ( removing_mapping )\n        /* Flush can be deferred if the entry is removed */\n        p2m->need_flush |= !!lpae_is_valid(orig_pte);\n    else\n    {\n        lpae_t pte = mfn_to_p2m_entry(smfn, t, a);\n\n        if ( level < 3 )\n            pte.p2m.table = 0; /* Superpage entry */\n\n        /*\n         * It is necessary to flush the TLB before writing the new entry\n         * to keep coherency when the previous entry was valid.\n         *\n         * Although, it could be defered when only the permissions are\n         * changed (e.g in case of memaccess).\n         */\n        if ( lpae_is_valid(orig_pte) )\n        {\n            if ( likely(!p2m->mem_access_enabled) ||\n                 P2M_CLEAR_PERM(pte) != P2M_CLEAR_PERM(orig_pte) )\n                p2m_force_tlb_flush_sync(p2m);\n            else\n                p2m->need_flush = true;\n        }\n        else if ( !p2m_is_valid(orig_pte) ) /* new mapping */\n            p2m->stats.mappings[level]++;\n\n        p2m_write_pte(entry, pte, p2m->clean_pte);\n\n        p2m->max_mapped_gfn = gfn_max(p2m->max_mapped_gfn,\n                                      gfn_add(sgfn, (1UL << page_order) - 1));\n        p2m->lowest_mapped_gfn = gfn_min(p2m->lowest_mapped_gfn, sgfn);\n    }\n\n    if ( is_iommu_enabled(p2m->domain) &&\n         (lpae_is_valid(orig_pte) || lpae_is_valid(*entry)) )\n    {\n        unsigned int flush_flags = 0;\n\n        if ( lpae_is_valid(orig_pte) )\n            flush_flags |= IOMMU_FLUSHF_modified;\n        if ( lpae_is_valid(*entry) )\n            flush_flags |= IOMMU_FLUSHF_added;\n\n        rc = iommu_iotlb_flush(p2m->domain, _dfn(gfn_x(sgfn)),\n                               1UL << page_order, flush_flags);\n    }\n    else\n        rc = 0;\n\n    /*\n     * Free the entry only if the original pte was valid and the base\n     * is different (to avoid freeing when permission is changed).\n     */\n    if ( p2m_is_valid(orig_pte) &&\n         !mfn_eq(lpae_get_mfn(*entry), lpae_get_mfn(orig_pte)) )\n        p2m_free_entry(p2m, orig_pte, level);\n\nout:\n    unmap_domain_page(table);\n\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -168,7 +168,7 @@\n         p2m_write_pte(entry, pte, p2m->clean_pte);\n \n         p2m->max_mapped_gfn = gfn_max(p2m->max_mapped_gfn,\n-                                      gfn_add(sgfn, 1 << page_order));\n+                                      gfn_add(sgfn, (1UL << page_order) - 1));\n         p2m->lowest_mapped_gfn = gfn_min(p2m->lowest_mapped_gfn, sgfn);\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "                                      gfn_add(sgfn, 1 << page_order));"
            ],
            "added_lines": [
                "                                      gfn_add(sgfn, (1UL << page_order) - 1));"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18423",
        "func_name": "xen-project/xen/p2m_resolve_translation_fault",
        "description": "An issue was discovered in Xen through 4.12.x allowing ARM guest OS users to cause a denial of service via a XENMEM_add_to_physmap hypercall. p2m->max_mapped_gfn is used by the functions p2m_resolve_translation_fault() and p2m_get_entry() to sanity check guest physical frame. The rest of the code in the two functions will assume that there is a valid root table and check that with BUG_ON(). The function p2m_get_root_pointer() will ignore the unused top bits of a guest physical frame. This means that the function p2m_set_entry() will alias the frame. However, p2m->max_mapped_gfn will be updated using the original frame. It would be possible to set p2m->max_mapped_gfn high enough to cover a frame that would lead p2m_get_root_pointer() to return NULL in p2m_get_entry() and p2m_resolve_translation_fault(). Additionally, the sanity check on p2m->max_mapped_gfn is off-by-one allowing \"highest mapped + 1\" to be considered valid. However, p2m_get_root_pointer() will return NULL. The problem could be triggered with a specially crafted hypercall XENMEM_add_to_physmap{, _batch} followed by an access to an address (via hypercall or direct access) that passes the sanity check but cause p2m_get_root_pointer() to return NULL. A malicious guest administrator may cause a hypervisor crash, resulting in a Denial of Service (DoS). Xen version 4.8 and newer are vulnerable. Only Arm systems are vulnerable. x86 systems are not affected.",
        "git_url": "https://github.com/xen-project/xen/commit/31b4f4ab6634f85163656b470dffc6d974917853",
        "commit_title": "xen/arm: p2m: Don't check the return of p2m_get_root_pointer() with BUG_ON()",
        "commit_text": " It turns out that the BUG_ON() was actually reachable with well-crafted hypercalls. The BUG_ON() is here to prevent catch logical error, so crashing Xen is a bit over the top.  While all the holes should now be fixed, it would be better to downgrade the BUG_ON() to something less fatal to prevent any more DoS.  The BUG_ON() in p2m_get_entry() is now replaced by ASSERT_UNREACHABLE() to catch mistake in debug build and return INVALID_MFN for production build. The interface also requires to set page_order to give an idea of the size of \"hole\". So 'level' is now set so we report a hole of size of the an entry of the root page-table. This stays inline with what happen when the GFN is higher than p2m->max_mapped_gfn.  The BUG_ON() in p2m_resolve_translation_fault() is now replaced by ASSERT_UNREACHABLE() to catch mistake in debug build and just report a fault for producion build.  This is part of XSA-301. ",
        "func_before": "bool p2m_resolve_translation_fault(struct domain *d, gfn_t gfn)\n{\n    struct p2m_domain *p2m = p2m_get_hostp2m(d);\n    unsigned int level = 0;\n    bool resolved = false;\n    lpae_t entry, *table;\n\n    /* Convenience aliases */\n    DECLARE_OFFSETS(offsets, gfn_to_gaddr(gfn));\n\n    p2m_write_lock(p2m);\n\n    /* This gfn is higher than the highest the p2m map currently holds */\n    if ( gfn_x(gfn) > gfn_x(p2m->max_mapped_gfn) )\n        goto out;\n\n    table = p2m_get_root_pointer(p2m, gfn);\n    /*\n     * The table should always be non-NULL because the gfn is below\n     * p2m->max_mapped_gfn and the root table pages are always present.\n     */\n    BUG_ON(table == NULL);\n\n    /*\n     * Go down the page-tables until an entry has the valid bit unset or\n     * a block/page entry has been hit.\n     */\n    for ( level = P2M_ROOT_LEVEL; level <= 3; level++ )\n    {\n        int rc;\n\n        entry = table[offsets[level]];\n\n        if ( level == 3 )\n            break;\n\n        /* Stop as soon as we hit an entry with the valid bit unset. */\n        if ( !lpae_is_valid(entry) )\n            break;\n\n        rc = p2m_next_level(p2m, true, level, &table, offsets[level]);\n        if ( rc == GUEST_TABLE_MAP_FAILED )\n            goto out_unmap;\n        else if ( rc != GUEST_TABLE_NORMAL_PAGE )\n            break;\n    }\n\n    /*\n     * If the valid bit of the entry is set, it means someone was playing with\n     * the Stage-2 page table. Nothing to do and mark the fault as resolved.\n     */\n    if ( lpae_is_valid(entry) )\n    {\n        resolved = true;\n        goto out_unmap;\n    }\n\n    /*\n     * The valid bit is unset. If the entry is still not valid then the fault\n     * cannot be resolved, exit and report it.\n     */\n    if ( !p2m_is_valid(entry) )\n        goto out_unmap;\n\n    /*\n     * Now we have an entry with valid bit unset, but still valid from\n     * the P2M point of view.\n     *\n     * If an entry is pointing to a table, each entry of the table will\n     * have there valid bit cleared. This allows a function to clear the\n     * full p2m with just a couple of write. The valid bit will then be\n     * propagated on the fault.\n     * If an entry is pointing to a block/page, no work to do for now.\n     */\n    if ( lpae_is_table(entry, level) )\n        p2m_invalidate_table(p2m, lpae_get_mfn(entry));\n\n    /*\n     * Now that the work on the entry is done, set the valid bit to prevent\n     * another fault on that entry.\n     */\n    resolved = true;\n    entry.p2m.valid = 1;\n\n    p2m_write_pte(table + offsets[level], entry, p2m->clean_pte);\n\n    /*\n     * No need to flush the TLBs as the modified entry had the valid bit\n     * unset.\n     */\n\nout_unmap:\n    unmap_domain_page(table);\n\nout:\n    p2m_write_unlock(p2m);\n\n    return resolved;\n}",
        "func": "bool p2m_resolve_translation_fault(struct domain *d, gfn_t gfn)\n{\n    struct p2m_domain *p2m = p2m_get_hostp2m(d);\n    unsigned int level = 0;\n    bool resolved = false;\n    lpae_t entry, *table;\n\n    /* Convenience aliases */\n    DECLARE_OFFSETS(offsets, gfn_to_gaddr(gfn));\n\n    p2m_write_lock(p2m);\n\n    /* This gfn is higher than the highest the p2m map currently holds */\n    if ( gfn_x(gfn) > gfn_x(p2m->max_mapped_gfn) )\n        goto out;\n\n    table = p2m_get_root_pointer(p2m, gfn);\n    /*\n     * The table should always be non-NULL because the gfn is below\n     * p2m->max_mapped_gfn and the root table pages are always present.\n     */\n    if ( !table )\n    {\n        ASSERT_UNREACHABLE();\n        goto out;\n    }\n\n    /*\n     * Go down the page-tables until an entry has the valid bit unset or\n     * a block/page entry has been hit.\n     */\n    for ( level = P2M_ROOT_LEVEL; level <= 3; level++ )\n    {\n        int rc;\n\n        entry = table[offsets[level]];\n\n        if ( level == 3 )\n            break;\n\n        /* Stop as soon as we hit an entry with the valid bit unset. */\n        if ( !lpae_is_valid(entry) )\n            break;\n\n        rc = p2m_next_level(p2m, true, level, &table, offsets[level]);\n        if ( rc == GUEST_TABLE_MAP_FAILED )\n            goto out_unmap;\n        else if ( rc != GUEST_TABLE_NORMAL_PAGE )\n            break;\n    }\n\n    /*\n     * If the valid bit of the entry is set, it means someone was playing with\n     * the Stage-2 page table. Nothing to do and mark the fault as resolved.\n     */\n    if ( lpae_is_valid(entry) )\n    {\n        resolved = true;\n        goto out_unmap;\n    }\n\n    /*\n     * The valid bit is unset. If the entry is still not valid then the fault\n     * cannot be resolved, exit and report it.\n     */\n    if ( !p2m_is_valid(entry) )\n        goto out_unmap;\n\n    /*\n     * Now we have an entry with valid bit unset, but still valid from\n     * the P2M point of view.\n     *\n     * If an entry is pointing to a table, each entry of the table will\n     * have there valid bit cleared. This allows a function to clear the\n     * full p2m with just a couple of write. The valid bit will then be\n     * propagated on the fault.\n     * If an entry is pointing to a block/page, no work to do for now.\n     */\n    if ( lpae_is_table(entry, level) )\n        p2m_invalidate_table(p2m, lpae_get_mfn(entry));\n\n    /*\n     * Now that the work on the entry is done, set the valid bit to prevent\n     * another fault on that entry.\n     */\n    resolved = true;\n    entry.p2m.valid = 1;\n\n    p2m_write_pte(table + offsets[level], entry, p2m->clean_pte);\n\n    /*\n     * No need to flush the TLBs as the modified entry had the valid bit\n     * unset.\n     */\n\nout_unmap:\n    unmap_domain_page(table);\n\nout:\n    p2m_write_unlock(p2m);\n\n    return resolved;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,7 +19,11 @@\n      * The table should always be non-NULL because the gfn is below\n      * p2m->max_mapped_gfn and the root table pages are always present.\n      */\n-    BUG_ON(table == NULL);\n+    if ( !table )\n+    {\n+        ASSERT_UNREACHABLE();\n+        goto out;\n+    }\n \n     /*\n      * Go down the page-tables until an entry has the valid bit unset or",
        "diff_line_info": {
            "deleted_lines": [
                "    BUG_ON(table == NULL);"
            ],
            "added_lines": [
                "    if ( !table )",
                "    {",
                "        ASSERT_UNREACHABLE();",
                "        goto out;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18423",
        "func_name": "xen-project/xen/p2m_get_entry",
        "description": "An issue was discovered in Xen through 4.12.x allowing ARM guest OS users to cause a denial of service via a XENMEM_add_to_physmap hypercall. p2m->max_mapped_gfn is used by the functions p2m_resolve_translation_fault() and p2m_get_entry() to sanity check guest physical frame. The rest of the code in the two functions will assume that there is a valid root table and check that with BUG_ON(). The function p2m_get_root_pointer() will ignore the unused top bits of a guest physical frame. This means that the function p2m_set_entry() will alias the frame. However, p2m->max_mapped_gfn will be updated using the original frame. It would be possible to set p2m->max_mapped_gfn high enough to cover a frame that would lead p2m_get_root_pointer() to return NULL in p2m_get_entry() and p2m_resolve_translation_fault(). Additionally, the sanity check on p2m->max_mapped_gfn is off-by-one allowing \"highest mapped + 1\" to be considered valid. However, p2m_get_root_pointer() will return NULL. The problem could be triggered with a specially crafted hypercall XENMEM_add_to_physmap{, _batch} followed by an access to an address (via hypercall or direct access) that passes the sanity check but cause p2m_get_root_pointer() to return NULL. A malicious guest administrator may cause a hypervisor crash, resulting in a Denial of Service (DoS). Xen version 4.8 and newer are vulnerable. Only Arm systems are vulnerable. x86 systems are not affected.",
        "git_url": "https://github.com/xen-project/xen/commit/31b4f4ab6634f85163656b470dffc6d974917853",
        "commit_title": "xen/arm: p2m: Don't check the return of p2m_get_root_pointer() with BUG_ON()",
        "commit_text": " It turns out that the BUG_ON() was actually reachable with well-crafted hypercalls. The BUG_ON() is here to prevent catch logical error, so crashing Xen is a bit over the top.  While all the holes should now be fixed, it would be better to downgrade the BUG_ON() to something less fatal to prevent any more DoS.  The BUG_ON() in p2m_get_entry() is now replaced by ASSERT_UNREACHABLE() to catch mistake in debug build and return INVALID_MFN for production build. The interface also requires to set page_order to give an idea of the size of \"hole\". So 'level' is now set so we report a hole of size of the an entry of the root page-table. This stays inline with what happen when the GFN is higher than p2m->max_mapped_gfn.  The BUG_ON() in p2m_resolve_translation_fault() is now replaced by ASSERT_UNREACHABLE() to catch mistake in debug build and just report a fault for producion build.  This is part of XSA-301. ",
        "func_before": "mfn_t p2m_get_entry(struct p2m_domain *p2m, gfn_t gfn,\n                    p2m_type_t *t, p2m_access_t *a,\n                    unsigned int *page_order,\n                    bool *valid)\n{\n    paddr_t addr = gfn_to_gaddr(gfn);\n    unsigned int level = 0;\n    lpae_t entry, *table;\n    int rc;\n    mfn_t mfn = INVALID_MFN;\n    p2m_type_t _t;\n    DECLARE_OFFSETS(offsets, addr);\n\n    ASSERT(p2m_is_locked(p2m));\n    BUILD_BUG_ON(THIRD_MASK != PAGE_MASK);\n\n    /* Allow t to be NULL */\n    t = t ?: &_t;\n\n    *t = p2m_invalid;\n\n    if ( valid )\n        *valid = false;\n\n    /* XXX: Check if the mapping is lower than the mapped gfn */\n\n    /* This gfn is higher than the highest the p2m map currently holds */\n    if ( gfn_x(gfn) > gfn_x(p2m->max_mapped_gfn) )\n    {\n        for ( level = P2M_ROOT_LEVEL; level < 3; level++ )\n            if ( (gfn_x(gfn) & (level_masks[level] >> PAGE_SHIFT)) >\n                 gfn_x(p2m->max_mapped_gfn) )\n                break;\n\n        goto out;\n    }\n\n    table = p2m_get_root_pointer(p2m, gfn);\n\n    /*\n     * the table should always be non-NULL because the gfn is below\n     * p2m->max_mapped_gfn and the root table pages are always present.\n     */\n    BUG_ON(table == NULL);\n\n    for ( level = P2M_ROOT_LEVEL; level < 3; level++ )\n    {\n        rc = p2m_next_level(p2m, true, level, &table, offsets[level]);\n        if ( rc == GUEST_TABLE_MAP_FAILED )\n            goto out_unmap;\n        else if ( rc != GUEST_TABLE_NORMAL_PAGE )\n            break;\n    }\n\n    entry = table[offsets[level]];\n\n    if ( p2m_is_valid(entry) )\n    {\n        *t = entry.p2m.type;\n\n        if ( a )\n            *a = p2m_mem_access_radix_get(p2m, gfn);\n\n        mfn = lpae_get_mfn(entry);\n        /*\n         * The entry may point to a superpage. Find the MFN associated\n         * to the GFN.\n         */\n        mfn = mfn_add(mfn, gfn_x(gfn) & ((1UL << level_orders[level]) - 1));\n\n        if ( valid )\n            *valid = lpae_is_valid(entry);\n    }\n\nout_unmap:\n    unmap_domain_page(table);\n\nout:\n    if ( page_order )\n        *page_order = level_orders[level];\n\n    return mfn;\n}",
        "func": "mfn_t p2m_get_entry(struct p2m_domain *p2m, gfn_t gfn,\n                    p2m_type_t *t, p2m_access_t *a,\n                    unsigned int *page_order,\n                    bool *valid)\n{\n    paddr_t addr = gfn_to_gaddr(gfn);\n    unsigned int level = 0;\n    lpae_t entry, *table;\n    int rc;\n    mfn_t mfn = INVALID_MFN;\n    p2m_type_t _t;\n    DECLARE_OFFSETS(offsets, addr);\n\n    ASSERT(p2m_is_locked(p2m));\n    BUILD_BUG_ON(THIRD_MASK != PAGE_MASK);\n\n    /* Allow t to be NULL */\n    t = t ?: &_t;\n\n    *t = p2m_invalid;\n\n    if ( valid )\n        *valid = false;\n\n    /* XXX: Check if the mapping is lower than the mapped gfn */\n\n    /* This gfn is higher than the highest the p2m map currently holds */\n    if ( gfn_x(gfn) > gfn_x(p2m->max_mapped_gfn) )\n    {\n        for ( level = P2M_ROOT_LEVEL; level < 3; level++ )\n            if ( (gfn_x(gfn) & (level_masks[level] >> PAGE_SHIFT)) >\n                 gfn_x(p2m->max_mapped_gfn) )\n                break;\n\n        goto out;\n    }\n\n    table = p2m_get_root_pointer(p2m, gfn);\n\n    /*\n     * the table should always be non-NULL because the gfn is below\n     * p2m->max_mapped_gfn and the root table pages are always present.\n     */\n    if ( !table )\n    {\n        ASSERT_UNREACHABLE();\n        level = P2M_ROOT_LEVEL;\n        goto out;\n    }\n\n    for ( level = P2M_ROOT_LEVEL; level < 3; level++ )\n    {\n        rc = p2m_next_level(p2m, true, level, &table, offsets[level]);\n        if ( rc == GUEST_TABLE_MAP_FAILED )\n            goto out_unmap;\n        else if ( rc != GUEST_TABLE_NORMAL_PAGE )\n            break;\n    }\n\n    entry = table[offsets[level]];\n\n    if ( p2m_is_valid(entry) )\n    {\n        *t = entry.p2m.type;\n\n        if ( a )\n            *a = p2m_mem_access_radix_get(p2m, gfn);\n\n        mfn = lpae_get_mfn(entry);\n        /*\n         * The entry may point to a superpage. Find the MFN associated\n         * to the GFN.\n         */\n        mfn = mfn_add(mfn, gfn_x(gfn) & ((1UL << level_orders[level]) - 1));\n\n        if ( valid )\n            *valid = lpae_is_valid(entry);\n    }\n\nout_unmap:\n    unmap_domain_page(table);\n\nout:\n    if ( page_order )\n        *page_order = level_orders[level];\n\n    return mfn;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -41,7 +41,12 @@\n      * the table should always be non-NULL because the gfn is below\n      * p2m->max_mapped_gfn and the root table pages are always present.\n      */\n-    BUG_ON(table == NULL);\n+    if ( !table )\n+    {\n+        ASSERT_UNREACHABLE();\n+        level = P2M_ROOT_LEVEL;\n+        goto out;\n+    }\n \n     for ( level = P2M_ROOT_LEVEL; level < 3; level++ )\n     {",
        "diff_line_info": {
            "deleted_lines": [
                "    BUG_ON(table == NULL);"
            ],
            "added_lines": [
                "    if ( !table )",
                "    {",
                "        ASSERT_UNREACHABLE();",
                "        level = P2M_ROOT_LEVEL;",
                "        goto out;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-34970",
        "func_name": "CrowCpp/Crow/qs_parse",
        "description": "Crow before 1.0+4 has a heap-based buffer overflow via the function qs_parse in query_string.h. On successful exploitation this vulnerability allows attackers to remotely execute arbitrary code in the context of the vulnerable service.",
        "git_url": "https://github.com/CrowCpp/Crow/commit/79eec91f00b5fb7df890d4e84b2f048b0841e044",
        "commit_title": "Fixed issue where an index in qs_parse is incorrectly incremented beyond the maximum possible value",
        "commit_text": "",
        "func_before": "inline int qs_parse(char* qs, char* qs_kv[], int qs_kv_size, bool parse_url = true)\n{\n    int i, j;\n    char * substr_ptr;\n\n    for(i=0; i<qs_kv_size; i++)  qs_kv[i] = NULL;\n\n    // find the beginning of the k/v substrings or the fragment\n    substr_ptr = parse_url ? qs + strcspn(qs, \"?#\") : qs;\n    if (parse_url)\n    {\n        if (substr_ptr[0] != '\\0')\n            substr_ptr++;\n        else\n            return 0; // no query or fragment\n    }\n\n    i=0;\n    while(i<qs_kv_size)\n    {\n        qs_kv[i] = substr_ptr;\n        j = strcspn(substr_ptr, \"&\");\n        if ( substr_ptr[j] == '\\0' ) {  break;  }\n        substr_ptr += j + 1;\n        i++;\n    }\n    i++;  // x &'s -> means x iterations of this loop -> means *x+1* k/v pairs\n\n    // we only decode the values in place, the keys could have '='s in them\n    // which will hose our ability to distinguish keys from values later\n    for(j=0; j<i; j++)\n    {\n        substr_ptr = qs_kv[j] + strcspn(qs_kv[j], \"=&#\");\n        if ( substr_ptr[0] == '&' || substr_ptr[0] == '\\0')  // blank value: skip decoding\n            substr_ptr[0] = '\\0';\n        else\n            qs_decode(++substr_ptr);\n    }\n\n#ifdef _qsSORTING\n// TODO: qsort qs_kv, using qs_strncmp() for the comparison\n#endif\n\n    return i;\n    }",
        "func": "inline int qs_parse(char* qs, char* qs_kv[], int qs_kv_size, bool parse_url = true)\n{\n    int i, j;\n    char * substr_ptr;\n\n    for(i=0; i<qs_kv_size; i++)  qs_kv[i] = NULL;\n\n    // find the beginning of the k/v substrings or the fragment\n    substr_ptr = parse_url ? qs + strcspn(qs, \"?#\") : qs;\n    if (parse_url)\n    {\n        if (substr_ptr[0] != '\\0')\n            substr_ptr++;\n        else\n            return 0; // no query or fragment\n    }\n\n    i=0;\n    while(i<qs_kv_size)\n    {\n        qs_kv[i] = substr_ptr;\n        j = strcspn(substr_ptr, \"&\");\n        if ( substr_ptr[j] == '\\0' ) { i++; break;  } // x &'s -> means x iterations of this loop -> means *x+1* k/v pairs\n        substr_ptr += j + 1;\n        i++;\n    }\n\n    // we only decode the values in place, the keys could have '='s in them\n    // which will hose our ability to distinguish keys from values later\n    for(j=0; j<i; j++)\n    {\n        substr_ptr = qs_kv[j] + strcspn(qs_kv[j], \"=&#\");\n        if ( substr_ptr[0] == '&' || substr_ptr[0] == '\\0')  // blank value: skip decoding\n            substr_ptr[0] = '\\0';\n        else\n            qs_decode(++substr_ptr);\n    }\n\n#ifdef _qsSORTING\n// TODO: qsort qs_kv, using qs_strncmp() for the comparison\n#endif\n\n    return i;\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,11 +20,10 @@\n     {\n         qs_kv[i] = substr_ptr;\n         j = strcspn(substr_ptr, \"&\");\n-        if ( substr_ptr[j] == '\\0' ) {  break;  }\n+        if ( substr_ptr[j] == '\\0' ) { i++; break;  } // x &'s -> means x iterations of this loop -> means *x+1* k/v pairs\n         substr_ptr += j + 1;\n         i++;\n     }\n-    i++;  // x &'s -> means x iterations of this loop -> means *x+1* k/v pairs\n \n     // we only decode the values in place, the keys could have '='s in them\n     // which will hose our ability to distinguish keys from values later",
        "diff_line_info": {
            "deleted_lines": [
                "        if ( substr_ptr[j] == '\\0' ) {  break;  }",
                "    i++;  // x &'s -> means x iterations of this loop -> means *x+1* k/v pairs"
            ],
            "added_lines": [
                "        if ( substr_ptr[j] == '\\0' ) { i++; break;  } // x &'s -> means x iterations of this loop -> means *x+1* k/v pairs"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27793",
        "func_name": "radareorg/radare2/r_cmd_java_call",
        "description": "An off-by-one overflow flaw was found in radare2 due to mismatched array length in core_java.c. This could allow an attacker to cause a crash, and perform a denail of service attack.",
        "git_url": "https://github.com/radareorg/radare2/commit/ced0223c7a1b3b5344af315715cd28fe7c0d9ebc",
        "commit_title": "Fix unmatched array length in core_java.c (issue #16304) (#16313)",
        "commit_text": "",
        "func_before": "static int r_cmd_java_call(void *user, const char *input) {\n\tRCore *core = (RCore *) user;\n\tint res = false;\n\tut32 i = 0;\n\tif (strncmp (input, \"java\", 4)) {\n\t\treturn false;\n\t}\n\tif (input[4] != ' ') {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\tfor (; i < END_CMDS; i++) {\n\t\t//IFDBG r_cons_printf (\"Checking cmd: %s %d %s\\n\", JAVA_CMDS[i].name, JAVA_CMDS[i].name_len, p);\n\t\tIFDBG r_cons_printf (\"Checking cmd: %s %d\\n\", JAVA_CMDS[i].name,\n\t\t\tstrncmp (input+5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len));\n\t\tif (!strncmp (input + 5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len)) {\n\t\t\tconst char *cmd = input + 5 + JAVA_CMDS[i].name_len;\n\t\t\tif (*cmd && *cmd == ' ') {\n\t\t\t\tcmd++;\n\t\t\t}\n\t\t\t//IFDBG r_cons_printf (\"Executing cmd: %s (%s)\\n\", JAVA_CMDS[i].name, cmd+5+JAVA_CMDS[i].name_len );\n\t\t\tres =  JAVA_CMDS[i].handler (core, cmd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!res) {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\treturn true;\n}",
        "func": "static int r_cmd_java_call(void *user, const char *input) {\n\tRCore *core = (RCore *) user;\n\tint res = false;\n\tut32 i = 0;\n\tif (strncmp (input, \"java\", 4)) {\n\t\treturn false;\n\t}\n\tif (input[4] != ' ') {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\tfor (; i < END_CMDS - 1; i++) {\n\t\t//IFDBG r_cons_printf (\"Checking cmd: %s %d %s\\n\", JAVA_CMDS[i].name, JAVA_CMDS[i].name_len, p);\n\t\tIFDBG r_cons_printf (\"Checking cmd: %s %d\\n\", JAVA_CMDS[i].name,\n\t\t\tstrncmp (input+5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len));\n\t\tif (!strncmp (input + 5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len)) {\n\t\t\tconst char *cmd = input + 5 + JAVA_CMDS[i].name_len;\n\t\t\tif (*cmd && *cmd == ' ') {\n\t\t\t\tcmd++;\n\t\t\t}\n\t\t\t//IFDBG r_cons_printf (\"Executing cmd: %s (%s)\\n\", JAVA_CMDS[i].name, cmd+5+JAVA_CMDS[i].name_len );\n\t\t\tres =  JAVA_CMDS[i].handler (core, cmd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!res) {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n \tif (input[4] != ' ') {\n \t\treturn r_cmd_java_handle_help (core, input);\n \t}\n-\tfor (; i < END_CMDS; i++) {\n+\tfor (; i < END_CMDS - 1; i++) {\n \t\t//IFDBG r_cons_printf (\"Checking cmd: %s %d %s\\n\", JAVA_CMDS[i].name, JAVA_CMDS[i].name_len, p);\n \t\tIFDBG r_cons_printf (\"Checking cmd: %s %d\\n\", JAVA_CMDS[i].name,\n \t\t\tstrncmp (input+5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len));",
        "diff_line_info": {
            "deleted_lines": [
                "\tfor (; i < END_CMDS; i++) {"
            ],
            "added_lines": [
                "\tfor (; i < END_CMDS - 1; i++) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3999",
        "func_name": "glibc/__getcwd_generic",
        "description": "A flaw was found in glibc. An off-by-one buffer overflow and underflow in getcwd() may lead to memory corruption when the size of the buffer is exactly 1. A local attacker who can control the input buffer and size passed to getcwd() in a setuid program could use this flaw to potentially execute arbitrary code and escalate their privileges on the system.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=glibc.git;h=23e0e8f5f1fb5ed150253d986ecccdc90c2dcd5e",
        "commit_title": "",
        "commit_text": "getcwd: Set errno to ERANGE for size == 1 (CVE-2021-3999)  No valid path returned by getcwd would fit into 1 byte, so reject the size early and return NULL with errno set to ERANGE.  This change is prompted by CVE-2021-3999, which describes a single byte buffer underflow and overflow when all of the following conditions are met:  - The buffer size (i.e. the second argument of getcwd) is 1 byte - The current working directory is too long - '/' is also mounted on the current working directory  Sequence of events:  - In sysdeps/unix/sysv/linux/getcwd.c, the syscall returns ENAMETOOLONG   because the linux kernel checks for name length before it checks   buffer size  - The code falls back to the generic getcwd in sysdeps/posix  - In the generic func, the buf[0] is set to '\\0' on line 250  - this while loop on line 262 is bypassed:      while (!(thisdev == rootdev && thisino == rootino))    since the rootfs (/) is bind mounted onto the directory and the flow   goes on to line 449, where it puts a '/' in the byte before the   buffer.  - Finally on line 458, it moves 2 bytes (the underflowed byte and the   '\\0') to the buf[0] and buf[1], resulting in a 1 byte buffer overflow.  - buf is returned on line 469 and errno is not set.  This resolves BZ #28769.  ",
        "func_before": "GETCWD_RETURN_TYPE\n__getcwd_generic (char *buf, size_t size)\n{\n  /* Lengths of big file name components and entire file names, and a\n     deep level of file name nesting.  These numbers are not upper\n     bounds; they are merely large values suitable for initial\n     allocations, designed to be large enough for most real-world\n     uses.  */\n  enum\n    {\n      BIG_FILE_NAME_COMPONENT_LENGTH = 255,\n      BIG_FILE_NAME_LENGTH = MIN (4095, PATH_MAX - 1),\n      DEEP_NESTING = 100\n    };\n\n#if HAVE_OPENAT_SUPPORT\n  int fd = AT_FDCWD;\n  bool fd_needs_closing = false;\n#else\n  char dots[DEEP_NESTING * sizeof \"..\" + BIG_FILE_NAME_COMPONENT_LENGTH + 1];\n  char *dotlist = dots;\n  size_t dotsize = sizeof dots;\n  size_t dotlen = 0;\n#endif\n  DIR *dirstream = NULL;\n  dev_t rootdev, thisdev;\n  ino_t rootino, thisino;\n  char *dir;\n  register char *dirp;\n  struct __stat64_t64 st;\n  size_t allocated = size;\n  size_t used;\n\n#if HAVE_MINIMALLY_WORKING_GETCWD\n  /* If AT_FDCWD is not defined, the algorithm below is O(N**2) and\n     this is much slower than the system getcwd (at least on\n     GNU/Linux).  So trust the system getcwd's results unless they\n     look suspicious.\n\n     Use the system getcwd even if we have openat support, since the\n     system getcwd works even when a parent is unreadable, while the\n     openat-based approach does not.\n\n     But on AIX 5.1..7.1, the system getcwd is not even minimally\n     working: If the current directory name is slightly longer than\n     PATH_MAX, it omits the first directory component and returns\n     this wrong result with errno = 0.  */\n\n# undef getcwd\n  dir = getcwd_system (buf, size);\n  if (dir || (size && errno == ERANGE))\n    return dir;\n\n  /* Solaris getcwd (NULL, 0) fails with errno == EINVAL, but it has\n     internal magic that lets it work even if an ancestor directory is\n     inaccessible, which is better in many cases.  So in this case try\n     again with a buffer that's almost always big enough.  */\n  if (errno == EINVAL && buf == NULL && size == 0)\n    {\n      char big_buffer[BIG_FILE_NAME_LENGTH + 1];\n      dir = getcwd_system (big_buffer, sizeof big_buffer);\n      if (dir)\n        return strdup (dir);\n    }\n\n# if HAVE_PARTLY_WORKING_GETCWD\n  /* The system getcwd works, except it sometimes fails when it\n     shouldn't, setting errno to ERANGE, ENAMETOOLONG, or ENOENT.    */\n  if (errno != ERANGE && errno != ENAMETOOLONG && errno != ENOENT)\n    return NULL;\n# endif\n#endif\n  if (size == 0)\n    {\n      if (buf != NULL)\n        {\n          __set_errno (EINVAL);\n          return NULL;\n        }\n\n      allocated = BIG_FILE_NAME_LENGTH + 1;\n    }\n\n  if (buf == NULL)\n    {\n      dir = malloc (allocated);\n      if (dir == NULL)\n        return NULL;\n    }\n  else\n    dir = buf;\n\n  dirp = dir + allocated;\n  *--dirp = '\\0';\n\n  if (__lstat64_time64 (\".\", &st) < 0)\n    goto lose;\n  thisdev = st.st_dev;\n  thisino = st.st_ino;\n\n  if (__lstat64_time64 (\"/\", &st) < 0)\n    goto lose;\n  rootdev = st.st_dev;\n  rootino = st.st_ino;\n\n  while (!(thisdev == rootdev && thisino == rootino))\n    {\n      struct dirent64 *d;\n      dev_t dotdev;\n      ino_t dotino;\n      bool mount_point;\n      int parent_status;\n      size_t dirroom;\n      size_t namlen;\n      bool use_d_ino = true;\n\n      /* Look at the parent directory.  */\n#if HAVE_OPENAT_SUPPORT\n      fd = __openat64 (fd, \"..\", O_RDONLY);\n      if (fd < 0)\n        goto lose;\n      fd_needs_closing = true;\n      parent_status = __fstat64_time64 (fd, &st);\n#else\n      dotlist[dotlen++] = '.';\n      dotlist[dotlen++] = '.';\n      dotlist[dotlen] = '\\0';\n      parent_status = __lstat64_time64 (dotlist, &st);\n#endif\n      if (parent_status != 0)\n        goto lose;\n\n      if (dirstream && __closedir (dirstream) != 0)\n        {\n          dirstream = NULL;\n          goto lose;\n        }\n\n      /* Figure out if this directory is a mount point.  */\n      dotdev = st.st_dev;\n      dotino = st.st_ino;\n      mount_point = dotdev != thisdev;\n\n      /* Search for the last directory.  */\n#if HAVE_OPENAT_SUPPORT\n      dirstream = __fdopendir (fd);\n      if (dirstream == NULL)\n        goto lose;\n      fd_needs_closing = false;\n#else\n      dirstream = __opendir (dotlist);\n      if (dirstream == NULL)\n        goto lose;\n      dotlist[dotlen++] = '/';\n#endif\n      for (;;)\n        {\n          /* Clear errno to distinguish EOF from error if readdir returns\n             NULL.  */\n          __set_errno (0);\n          d = __readdir64 (dirstream);\n\n          /* When we've iterated through all directory entries without finding\n             one with a matching d_ino, rewind the stream and consider each\n             name again, but this time, using lstat.  This is necessary in a\n             chroot on at least one system (glibc-2.3.6 + linux 2.6.12), where\n             .., ../.., ../../.., etc. all had the same device number, yet the\n             d_ino values for entries in / did not match those obtained\n             via lstat.  */\n          if (d == NULL && errno == 0 && use_d_ino)\n            {\n              use_d_ino = false;\n              __rewinddir (dirstream);\n              d = __readdir64 (dirstream);\n            }\n\n          if (d == NULL)\n            {\n              if (errno == 0)\n                /* EOF on dirstream, which can mean e.g., that the current\n                   directory has been removed.  */\n                __set_errno (ENOENT);\n              goto lose;\n            }\n          if (d->d_name[0] == '.' &&\n              (d->d_name[1] == '\\0' ||\n               (d->d_name[1] == '.' && d->d_name[2] == '\\0')))\n            continue;\n\n          if (use_d_ino)\n            {\n              bool match = (MATCHING_INO (d, thisino) || mount_point);\n              if (! match)\n                continue;\n            }\n\n          {\n            int entry_status;\n#if HAVE_OPENAT_SUPPORT\n            entry_status = __fstatat64_time64 (fd, d->d_name, &st,\n\t\t\t\t\t       AT_SYMLINK_NOFOLLOW);\n#else\n            /* Compute size needed for this file name, or for the file\n               name \"..\" in the same directory, whichever is larger.\n               Room for \"..\" might be needed the next time through\n               the outer loop.  */\n            size_t name_alloc = _D_ALLOC_NAMLEN (d);\n            size_t filesize = dotlen + MAX (sizeof \"..\", name_alloc);\n\n            if (filesize < dotlen)\n              goto memory_exhausted;\n\n            if (dotsize < filesize)\n              {\n                /* My, what a deep directory tree you have, Grandma.  */\n                size_t newsize = MAX (filesize, dotsize * 2);\n                size_t i;\n                if (newsize < dotsize)\n                  goto memory_exhausted;\n                if (dotlist != dots)\n                  free (dotlist);\n                dotlist = malloc (newsize);\n                if (dotlist == NULL)\n                  goto lose;\n                dotsize = newsize;\n\n                i = 0;\n                do\n                  {\n                    dotlist[i++] = '.';\n                    dotlist[i++] = '.';\n                    dotlist[i++] = '/';\n                  }\n                while (i < dotlen);\n              }\n\n            memcpy (dotlist + dotlen, d->d_name, _D_ALLOC_NAMLEN (d));\n            entry_status = __lstat64_time64 (dotlist, &st);\n#endif\n            /* We don't fail here if we cannot stat() a directory entry.\n               This can happen when (network) file systems fail.  If this\n               entry is in fact the one we are looking for we will find\n               out soon as we reach the end of the directory without\n               having found anything.  */\n            if (entry_status == 0 && S_ISDIR (st.st_mode)\n                && st.st_dev == thisdev && st.st_ino == thisino)\n              break;\n          }\n        }\n\n      dirroom = dirp - dir;\n      namlen = _D_EXACT_NAMLEN (d);\n\n      if (dirroom <= namlen)\n        {\n          if (size != 0)\n            {\n              __set_errno (ERANGE);\n              goto lose;\n            }\n          else\n            {\n              char *tmp;\n              size_t oldsize = allocated;\n\n              allocated += MAX (allocated, namlen);\n              if (allocated < oldsize\n                  || ! (tmp = realloc (dir, allocated)))\n                goto memory_exhausted;\n\n              /* Move current contents up to the end of the buffer.\n                 This is guaranteed to be non-overlapping.  */\n              dirp = memcpy (tmp + allocated - (oldsize - dirroom),\n                             tmp + dirroom,\n                             oldsize - dirroom);\n              dir = tmp;\n            }\n        }\n      dirp -= namlen;\n      memcpy (dirp, d->d_name, namlen);\n      *--dirp = '/';\n\n      thisdev = dotdev;\n      thisino = dotino;\n    }\n\n  if (dirstream && __closedir (dirstream) != 0)\n    {\n      dirstream = NULL;\n      goto lose;\n    }\n\n  if (dirp == &dir[allocated - 1])\n    *--dirp = '/';\n\n#if ! HAVE_OPENAT_SUPPORT\n  if (dotlist != dots)\n    free (dotlist);\n#endif\n\n  used = dir + allocated - dirp;\n  memmove (dir, dirp, used);\n\n  if (size == 0)\n    /* Ensure that the buffer is only as large as necessary.  */\n    buf = (used < allocated ? realloc (dir, used) : dir);\n\n  if (buf == NULL)\n    /* Either buf was NULL all along, or 'realloc' failed but\n       we still have the original string.  */\n    buf = dir;\n\n  return buf;\n\n memory_exhausted:\n  __set_errno (ENOMEM);\n lose:\n  {\n    int save = errno;\n    if (dirstream)\n      __closedir (dirstream);\n#if HAVE_OPENAT_SUPPORT\n    if (fd_needs_closing)\n       __close_nocancel_nostatus (fd);\n#else\n    if (dotlist != dots)\n      free (dotlist);\n#endif\n    if (buf == NULL)\n      free (dir);\n    __set_errno (save);\n  }\n  return NULL;\n}",
        "func": "GETCWD_RETURN_TYPE\n__getcwd_generic (char *buf, size_t size)\n{\n  /* Lengths of big file name components and entire file names, and a\n     deep level of file name nesting.  These numbers are not upper\n     bounds; they are merely large values suitable for initial\n     allocations, designed to be large enough for most real-world\n     uses.  */\n  enum\n    {\n      BIG_FILE_NAME_COMPONENT_LENGTH = 255,\n      BIG_FILE_NAME_LENGTH = MIN (4095, PATH_MAX - 1),\n      DEEP_NESTING = 100\n    };\n\n#if HAVE_OPENAT_SUPPORT\n  int fd = AT_FDCWD;\n  bool fd_needs_closing = false;\n#else\n  char dots[DEEP_NESTING * sizeof \"..\" + BIG_FILE_NAME_COMPONENT_LENGTH + 1];\n  char *dotlist = dots;\n  size_t dotsize = sizeof dots;\n  size_t dotlen = 0;\n#endif\n  DIR *dirstream = NULL;\n  dev_t rootdev, thisdev;\n  ino_t rootino, thisino;\n  char *dir;\n  register char *dirp;\n  struct __stat64_t64 st;\n  size_t allocated = size;\n  size_t used;\n\n  /* A size of 1 byte is never useful.  */\n  if (allocated == 1)\n    {\n      __set_errno (ERANGE);\n      return NULL;\n    }\n\n#if HAVE_MINIMALLY_WORKING_GETCWD\n  /* If AT_FDCWD is not defined, the algorithm below is O(N**2) and\n     this is much slower than the system getcwd (at least on\n     GNU/Linux).  So trust the system getcwd's results unless they\n     look suspicious.\n\n     Use the system getcwd even if we have openat support, since the\n     system getcwd works even when a parent is unreadable, while the\n     openat-based approach does not.\n\n     But on AIX 5.1..7.1, the system getcwd is not even minimally\n     working: If the current directory name is slightly longer than\n     PATH_MAX, it omits the first directory component and returns\n     this wrong result with errno = 0.  */\n\n# undef getcwd\n  dir = getcwd_system (buf, size);\n  if (dir || (size && errno == ERANGE))\n    return dir;\n\n  /* Solaris getcwd (NULL, 0) fails with errno == EINVAL, but it has\n     internal magic that lets it work even if an ancestor directory is\n     inaccessible, which is better in many cases.  So in this case try\n     again with a buffer that's almost always big enough.  */\n  if (errno == EINVAL && buf == NULL && size == 0)\n    {\n      char big_buffer[BIG_FILE_NAME_LENGTH + 1];\n      dir = getcwd_system (big_buffer, sizeof big_buffer);\n      if (dir)\n        return strdup (dir);\n    }\n\n# if HAVE_PARTLY_WORKING_GETCWD\n  /* The system getcwd works, except it sometimes fails when it\n     shouldn't, setting errno to ERANGE, ENAMETOOLONG, or ENOENT.    */\n  if (errno != ERANGE && errno != ENAMETOOLONG && errno != ENOENT)\n    return NULL;\n# endif\n#endif\n  if (size == 0)\n    {\n      if (buf != NULL)\n        {\n          __set_errno (EINVAL);\n          return NULL;\n        }\n\n      allocated = BIG_FILE_NAME_LENGTH + 1;\n    }\n\n  if (buf == NULL)\n    {\n      dir = malloc (allocated);\n      if (dir == NULL)\n        return NULL;\n    }\n  else\n    dir = buf;\n\n  dirp = dir + allocated;\n  *--dirp = '\\0';\n\n  if (__lstat64_time64 (\".\", &st) < 0)\n    goto lose;\n  thisdev = st.st_dev;\n  thisino = st.st_ino;\n\n  if (__lstat64_time64 (\"/\", &st) < 0)\n    goto lose;\n  rootdev = st.st_dev;\n  rootino = st.st_ino;\n\n  while (!(thisdev == rootdev && thisino == rootino))\n    {\n      struct dirent64 *d;\n      dev_t dotdev;\n      ino_t dotino;\n      bool mount_point;\n      int parent_status;\n      size_t dirroom;\n      size_t namlen;\n      bool use_d_ino = true;\n\n      /* Look at the parent directory.  */\n#if HAVE_OPENAT_SUPPORT\n      fd = __openat64 (fd, \"..\", O_RDONLY);\n      if (fd < 0)\n        goto lose;\n      fd_needs_closing = true;\n      parent_status = __fstat64_time64 (fd, &st);\n#else\n      dotlist[dotlen++] = '.';\n      dotlist[dotlen++] = '.';\n      dotlist[dotlen] = '\\0';\n      parent_status = __lstat64_time64 (dotlist, &st);\n#endif\n      if (parent_status != 0)\n        goto lose;\n\n      if (dirstream && __closedir (dirstream) != 0)\n        {\n          dirstream = NULL;\n          goto lose;\n        }\n\n      /* Figure out if this directory is a mount point.  */\n      dotdev = st.st_dev;\n      dotino = st.st_ino;\n      mount_point = dotdev != thisdev;\n\n      /* Search for the last directory.  */\n#if HAVE_OPENAT_SUPPORT\n      dirstream = __fdopendir (fd);\n      if (dirstream == NULL)\n        goto lose;\n      fd_needs_closing = false;\n#else\n      dirstream = __opendir (dotlist);\n      if (dirstream == NULL)\n        goto lose;\n      dotlist[dotlen++] = '/';\n#endif\n      for (;;)\n        {\n          /* Clear errno to distinguish EOF from error if readdir returns\n             NULL.  */\n          __set_errno (0);\n          d = __readdir64 (dirstream);\n\n          /* When we've iterated through all directory entries without finding\n             one with a matching d_ino, rewind the stream and consider each\n             name again, but this time, using lstat.  This is necessary in a\n             chroot on at least one system (glibc-2.3.6 + linux 2.6.12), where\n             .., ../.., ../../.., etc. all had the same device number, yet the\n             d_ino values for entries in / did not match those obtained\n             via lstat.  */\n          if (d == NULL && errno == 0 && use_d_ino)\n            {\n              use_d_ino = false;\n              __rewinddir (dirstream);\n              d = __readdir64 (dirstream);\n            }\n\n          if (d == NULL)\n            {\n              if (errno == 0)\n                /* EOF on dirstream, which can mean e.g., that the current\n                   directory has been removed.  */\n                __set_errno (ENOENT);\n              goto lose;\n            }\n          if (d->d_name[0] == '.' &&\n              (d->d_name[1] == '\\0' ||\n               (d->d_name[1] == '.' && d->d_name[2] == '\\0')))\n            continue;\n\n          if (use_d_ino)\n            {\n              bool match = (MATCHING_INO (d, thisino) || mount_point);\n              if (! match)\n                continue;\n            }\n\n          {\n            int entry_status;\n#if HAVE_OPENAT_SUPPORT\n            entry_status = __fstatat64_time64 (fd, d->d_name, &st,\n\t\t\t\t\t       AT_SYMLINK_NOFOLLOW);\n#else\n            /* Compute size needed for this file name, or for the file\n               name \"..\" in the same directory, whichever is larger.\n               Room for \"..\" might be needed the next time through\n               the outer loop.  */\n            size_t name_alloc = _D_ALLOC_NAMLEN (d);\n            size_t filesize = dotlen + MAX (sizeof \"..\", name_alloc);\n\n            if (filesize < dotlen)\n              goto memory_exhausted;\n\n            if (dotsize < filesize)\n              {\n                /* My, what a deep directory tree you have, Grandma.  */\n                size_t newsize = MAX (filesize, dotsize * 2);\n                size_t i;\n                if (newsize < dotsize)\n                  goto memory_exhausted;\n                if (dotlist != dots)\n                  free (dotlist);\n                dotlist = malloc (newsize);\n                if (dotlist == NULL)\n                  goto lose;\n                dotsize = newsize;\n\n                i = 0;\n                do\n                  {\n                    dotlist[i++] = '.';\n                    dotlist[i++] = '.';\n                    dotlist[i++] = '/';\n                  }\n                while (i < dotlen);\n              }\n\n            memcpy (dotlist + dotlen, d->d_name, _D_ALLOC_NAMLEN (d));\n            entry_status = __lstat64_time64 (dotlist, &st);\n#endif\n            /* We don't fail here if we cannot stat() a directory entry.\n               This can happen when (network) file systems fail.  If this\n               entry is in fact the one we are looking for we will find\n               out soon as we reach the end of the directory without\n               having found anything.  */\n            if (entry_status == 0 && S_ISDIR (st.st_mode)\n                && st.st_dev == thisdev && st.st_ino == thisino)\n              break;\n          }\n        }\n\n      dirroom = dirp - dir;\n      namlen = _D_EXACT_NAMLEN (d);\n\n      if (dirroom <= namlen)\n        {\n          if (size != 0)\n            {\n              __set_errno (ERANGE);\n              goto lose;\n            }\n          else\n            {\n              char *tmp;\n              size_t oldsize = allocated;\n\n              allocated += MAX (allocated, namlen);\n              if (allocated < oldsize\n                  || ! (tmp = realloc (dir, allocated)))\n                goto memory_exhausted;\n\n              /* Move current contents up to the end of the buffer.\n                 This is guaranteed to be non-overlapping.  */\n              dirp = memcpy (tmp + allocated - (oldsize - dirroom),\n                             tmp + dirroom,\n                             oldsize - dirroom);\n              dir = tmp;\n            }\n        }\n      dirp -= namlen;\n      memcpy (dirp, d->d_name, namlen);\n      *--dirp = '/';\n\n      thisdev = dotdev;\n      thisino = dotino;\n    }\n\n  if (dirstream && __closedir (dirstream) != 0)\n    {\n      dirstream = NULL;\n      goto lose;\n    }\n\n  if (dirp == &dir[allocated - 1])\n    *--dirp = '/';\n\n#if ! HAVE_OPENAT_SUPPORT\n  if (dotlist != dots)\n    free (dotlist);\n#endif\n\n  used = dir + allocated - dirp;\n  memmove (dir, dirp, used);\n\n  if (size == 0)\n    /* Ensure that the buffer is only as large as necessary.  */\n    buf = (used < allocated ? realloc (dir, used) : dir);\n\n  if (buf == NULL)\n    /* Either buf was NULL all along, or 'realloc' failed but\n       we still have the original string.  */\n    buf = dir;\n\n  return buf;\n\n memory_exhausted:\n  __set_errno (ENOMEM);\n lose:\n  {\n    int save = errno;\n    if (dirstream)\n      __closedir (dirstream);\n#if HAVE_OPENAT_SUPPORT\n    if (fd_needs_closing)\n       __close_nocancel_nostatus (fd);\n#else\n    if (dotlist != dots)\n      free (dotlist);\n#endif\n    if (buf == NULL)\n      free (dir);\n    __set_errno (save);\n  }\n  return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,6 +30,13 @@\n   struct __stat64_t64 st;\n   size_t allocated = size;\n   size_t used;\n+\n+  /* A size of 1 byte is never useful.  */\n+  if (allocated == 1)\n+    {\n+      __set_errno (ERANGE);\n+      return NULL;\n+    }\n \n #if HAVE_MINIMALLY_WORKING_GETCWD\n   /* If AT_FDCWD is not defined, the algorithm below is O(N**2) and",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  /* A size of 1 byte is never useful.  */",
                "  if (allocated == 1)",
                "    {",
                "      __set_errno (ERANGE);",
                "      return NULL;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-39274",
        "func_name": "Lora-net/LoRaMac-node/ProcessRadioRxDone",
        "description": "LoRaMac-node is a reference implementation and documentation of a LoRa network node. Versions of LoRaMac-node prior to 4.7.0 are vulnerable to a buffer overflow. Improper size validation of the incoming radio frames can lead to an 65280-byte out-of-bounds write. The function `ProcessRadioRxDone` implicitly expects incoming radio frames to have at least a payload of one byte or more. An empty payload leads to a 1-byte out-of-bounds read of user controlled content when the payload buffer is reused. This allows an attacker to craft a FRAME_TYPE_PROPRIETARY frame with size -1 which results in an 65280-byte out-of-bounds memcopy likely with partially controlled attacker data. Corrupting a large part if the data section is likely to cause a DoS. If the large out-of-bounds write does not immediately crash the attacker may gain control over the execution due to now controlling large parts of the data section. Users are advised to upgrade either by updating their package or by manually applying the patch commit `e851b079`.",
        "git_url": "https://github.com/Lora-net/LoRaMac-node/commit/e851b079c82ba1bcf3f4d291ab69a571b0bf458a",
        "commit_title": "Fixed potential buffer overflow in `ProcessRadioRxDone`",
        "commit_text": "",
        "func_before": "static void ProcessRadioRxDone( void )\n{\n    LoRaMacHeader_t macHdr;\n    ApplyCFListParams_t applyCFList;\n    GetPhyParams_t getPhy;\n    PhyParam_t phyParam;\n    LoRaMacCryptoStatus_t macCryptoStatus = LORAMAC_CRYPTO_ERROR;\n\n    LoRaMacMessageData_t macMsgData;\n    LoRaMacMessageJoinAccept_t macMsgJoinAccept;\n    uint8_t *payload = RxDoneParams.Payload;\n    uint16_t size = RxDoneParams.Size;\n    int16_t rssi = RxDoneParams.Rssi;\n    int8_t snr = RxDoneParams.Snr;\n\n    uint8_t pktHeaderLen = 0;\n\n    uint32_t downLinkCounter = 0;\n    uint32_t address = Nvm.MacGroup2.DevAddr;\n    uint8_t multicast = 0;\n    AddressIdentifier_t addrID = UNICAST_DEV_ADDR;\n    FCntIdentifier_t fCntID;\n    uint8_t macCmdPayload[2] = { 0 };\n    Mlme_t joinType = MLME_JOIN;\n\n    LoRaMacRadioEvents.Events.RxProcessPending = 0;\n\n    MacCtx.McpsConfirm.AckReceived = false;\n    MacCtx.McpsIndication.Rssi = rssi;\n    MacCtx.McpsIndication.Snr = snr;\n    MacCtx.McpsIndication.RxSlot = MacCtx.RxSlot;\n    MacCtx.McpsIndication.Port = 0;\n    MacCtx.McpsIndication.Multicast = 0;\n    MacCtx.McpsIndication.IsUplinkTxPending = 0;\n    MacCtx.McpsIndication.Buffer = NULL;\n    MacCtx.McpsIndication.BufferSize = 0;\n    MacCtx.McpsIndication.RxData = false;\n    MacCtx.McpsIndication.AckReceived = false;\n    MacCtx.McpsIndication.DownLinkCounter = 0;\n    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;\n    MacCtx.McpsIndication.DevAddress = 0;\n    MacCtx.McpsIndication.DeviceTimeAnsReceived = false;\n    MacCtx.McpsIndication.ResponseTimeout = 0;\n\n    Radio.Sleep( );\n\n    if( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 )\n    {\n        TimerStop( &MacCtx.RxWindowTimer2 );\n    }\n\n    // This function must be called even if we are not in class b mode yet.\n    if( LoRaMacClassBRxBeacon( payload, size ) == true )\n    {\n        MacCtx.MlmeIndication.BeaconInfo.Rssi = rssi;\n        MacCtx.MlmeIndication.BeaconInfo.Snr = snr;\n        return;\n    }\n    // Check if we expect a ping or a multicast slot.\n    if( Nvm.MacGroup2.DeviceClass == CLASS_B )\n    {\n        if( LoRaMacClassBIsPingExpected( ) == true )\n        {\n            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\n            LoRaMacClassBPingSlotTimerEvent( NULL );\n            MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT;\n        }\n        else if( LoRaMacClassBIsMulticastExpected( ) == true )\n        {\n            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\n            LoRaMacClassBMulticastSlotTimerEvent( NULL );\n            MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;\n        }\n    }\n\n    macHdr.Value = payload[pktHeaderLen++];\n\n    // Accept frames of LoRaWAN Major Version 1 only\n    if( macHdr.Bits.Major != 0 )\n    {\n        MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n        PrepareRxDoneAbort( );\n        return;\n    }\n\n    switch( macHdr.Bits.MType )\n    {\n        case FRAME_TYPE_JOIN_ACCEPT:\n        {\n            // Check if the received frame size is valid\n            if( size < LORAMAC_JOIN_ACCEPT_FRAME_MIN_SIZE )\n            {\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                PrepareRxDoneAbort( );\n                return;\n            }\n            macMsgJoinAccept.Buffer = payload;\n            macMsgJoinAccept.BufSize = size;\n\n            // Abort in case if the device is already joined and no rejoin request is ongoing.\n            if( ( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE ) && ( Nvm.MacGroup2.IsRejoinAcceptPending == false ) )\n            {\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                PrepareRxDoneAbort( );\n                return;\n            }\n            macCryptoStatus = LoRaMacCryptoHandleJoinAccept( JOIN_REQ, SecureElementGetJoinEui( ), &macMsgJoinAccept );\n\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\n            {\n                macCryptoStatus = LoRaMacCryptoHandleJoinAccept( REJOIN_REQ_0, SecureElementGetJoinEui( ), &macMsgJoinAccept );\n                joinType = MLME_REJOIN_0;\n            }\n\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\n            {\n                macCryptoStatus = LoRaMacCryptoHandleJoinAccept( REJOIN_REQ_1, SecureElementGetJoinEui( ), &macMsgJoinAccept );\n                joinType = MLME_REJOIN_1;\n            }\n\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\n            {\n                macCryptoStatus = LoRaMacCryptoHandleJoinAccept( REJOIN_REQ_2, SecureElementGetJoinEui( ), &macMsgJoinAccept );\n                joinType = MLME_REJOIN_2;\n            }\n\n            VerifyParams_t verifyRxDr;\n            bool rxDrValid = false;\n            verifyRxDr.DatarateParams.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;\n            verifyRxDr.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\n            rxDrValid = RegionVerify( Nvm.MacGroup2.Region, &verifyRxDr, PHY_RX_DR );\n\n            if( ( LORAMAC_CRYPTO_SUCCESS == macCryptoStatus ) && ( rxDrValid == true ) )\n            {\n                // Network ID\n                Nvm.MacGroup2.NetID = ( uint32_t ) macMsgJoinAccept.NetID[0];\n                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[1] << 8 );\n                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );\n\n                // Device Address\n                Nvm.MacGroup2.DevAddr = macMsgJoinAccept.DevAddr;\n\n                // DLSettings\n                Nvm.MacGroup2.MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;\n                Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;\n                Nvm.MacGroup2.MacParams.RxCChannel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;\n\n                // RxDelay\n                Nvm.MacGroup2.MacParams.ReceiveDelay1 = macMsgJoinAccept.RxDelay;\n                if( Nvm.MacGroup2.MacParams.ReceiveDelay1 == 0 )\n                {\n                    Nvm.MacGroup2.MacParams.ReceiveDelay1 = 1;\n                }\n                Nvm.MacGroup2.MacParams.ReceiveDelay1 *= 1000;\n                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;\n\n                // Reset NbTrans to default value\n                Nvm.MacGroup2.MacParams.ChannelsNbTrans = 1;\n\n                // Is Networkserver's LoRaWAN Version before 1.1.0 ?\n                if( macMsgJoinAccept.DLSettings.Bits.OptNeg == 0 )\n                {\n                    Nvm.MacGroup2.Version.Value = LORAMAC_FALLBACK_VERSION;\n                }\n                else\n                {\n                    Nvm.MacGroup2.Version.Value = LORAMAC_VERSION;\n                }\n\n                // Apply CF list\n                applyCFList.Payload = macMsgJoinAccept.CFList;\n                // Size of the regular payload is 12. Plus 1 byte MHDR and 4 bytes MIC\n                applyCFList.Size = size - 17;\n                // Apply the last tx channel\n                applyCFList.JoinChannel = MacCtx.Channel;\n\n                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );\n\n                Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_OTAA;\n\n                // Add a RekeyInd MAC command to confirm the security key update.\n                if( Nvm.MacGroup2.Version.Fields.Minor >= 1 )\n                {\n                    Nvm.MacGroup1.RekeyIndUplinksCounter = 0;\n                    macCmdPayload[0] = Nvm.MacGroup2.Version.Fields.Minor;\n                    LoRaMacCommandsAddCmd( MOTE_MAC_REKEY_IND, macCmdPayload, 1 );\n                }\n\n                // MLME handling\n                if( LoRaMacConfirmQueueIsCmdActive( joinType ) == true )\n                {\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, joinType );\n                }\n\n                // Rejoin handling\n                if( Nvm.MacGroup2.IsRejoinAcceptPending == true )\n                {\n                    Nvm.MacGroup2.IsRejoinAcceptPending = false;\n\n                    // Stop in any case the ForceRejoinReqCycleTimer\n                    TimerStop( &MacCtx.ForceRejoinReqCycleTimer );\n                }\n\n                // Reset MAC parameters for specific re-join types\n                if( ( joinType == MLME_REJOIN_0 ) || ( joinType == MLME_REJOIN_1 ) )\n                {\n                    ResetMacParameters( true );\n                }\n            }\n            else\n            {\n                // MLME handling\n                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )\n                {\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );\n                }\n            }\n            break;\n        }\n        case FRAME_TYPE_DATA_CONFIRMED_DOWN:\n            MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;\n            // Intentional fall through\n        case FRAME_TYPE_DATA_UNCONFIRMED_DOWN:\n            // Check if the received payload size is valid\n            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\n            getPhy.Datarate = MacCtx.McpsIndication.RxDatarate;\n            getPhy.Attribute = PHY_MAX_PAYLOAD;\n            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\n            if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||\n                ( size < LORAMAC_FRAME_PAYLOAD_MIN_SIZE ) )\n            {\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                PrepareRxDoneAbort( );\n                return;\n            }\n            macMsgData.Buffer = payload;\n            macMsgData.BufSize = size;\n            macMsgData.FRMPayload = MacCtx.RxPayload;\n            macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;\n\n            if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )\n            {\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                PrepareRxDoneAbort( );\n                return;\n            }\n\n            // Handle Class B\n            // Check if we expect a ping or a multicast slot.\n            if( Nvm.MacGroup2.DeviceClass == CLASS_B )\n            {\n                if( LoRaMacClassBIsPingExpected( ) == true )\n                {\n                    LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\n                    LoRaMacClassBPingSlotTimerEvent( NULL );\n                    MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT;\n                    LoRaMacClassBSetFPendingBit( macMsgData.FHDR.DevAddr, ( uint8_t ) macMsgData.FHDR.FCtrl.Bits.FPending );\n                }\n                else if( LoRaMacClassBIsMulticastExpected( ) == true )\n                {\n                    LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\n                    LoRaMacClassBMulticastSlotTimerEvent( NULL );\n                    MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;\n                    LoRaMacClassBSetFPendingBit( macMsgData.FHDR.DevAddr, ( uint8_t ) macMsgData.FHDR.FCtrl.Bits.FPending );\n                }\n            }\n\n            // Store device address\n            MacCtx.McpsIndication.DevAddress = macMsgData.FHDR.DevAddr;\n\n            FType_t fType;\n            if( LORAMAC_STATUS_OK != DetermineFrameType( &macMsgData, &fType ) )\n            {\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                PrepareRxDoneAbort( );\n                return;\n            }\n\n            //Check if it is a multicast message\n            multicast = 0;\n            downLinkCounter = 0;\n            for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )\n            {\n                if( ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) &&\n                    ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true ) )\n                {\n                    multicast = 1;\n                    addrID = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.GroupID;\n                    downLinkCounter = *( Nvm.MacGroup2.MulticastChannelList[i].DownLinkCounter );\n                    address = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address;\n                    if( Nvm.MacGroup2.DeviceClass == CLASS_C )\n                    {\n                        MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;\n                    }\n                    break;\n                }\n            }\n\n            // Filter messages according to multicast downlink exceptions\n            if( ( multicast == 1 ) && ( ( fType != FRAME_TYPE_D ) ||\n                                        ( macMsgData.FHDR.FCtrl.Bits.Ack != 0 ) ||\n                                        ( macMsgData.FHDR.FCtrl.Bits.AdrAckReq != 0 ) ) )\n            {\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                PrepareRxDoneAbort( );\n                return;\n            }\n\n            // Get downlink frame counter value\n            macCryptoStatus = GetFCntDown( addrID, fType, &macMsgData, Nvm.MacGroup2.Version, &fCntID, &downLinkCounter );\n            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )\n            {\n                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED )\n                {\n                    // Catch the case of repeated downlink frame counter\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;\n                }\n                else\n                {\n                    // Other errors\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                }\n                MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;\n                PrepareRxDoneAbort( );\n                return;\n            }\n\n            macCryptoStatus = LoRaMacCryptoUnsecureMessage( addrID, address, fCntID, downLinkCounter, &macMsgData );\n            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )\n            {\n                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_ADDRESS )\n                {\n                    // We are not the destination of this frame.\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ADDRESS_FAIL;\n                }\n                else\n                {\n                    // MIC calculation fail\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL;\n                }\n                PrepareRxDoneAbort( );\n                return;\n            }\n\n            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;\n            MacCtx.McpsIndication.Multicast = multicast;\n            MacCtx.McpsIndication.Buffer = NULL;\n            MacCtx.McpsIndication.BufferSize = 0;\n            MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;\n            MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;\n\n            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;\n            MacCtx.McpsConfirm.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;\n\n            // Reset ADR ACK Counter only, when RX1 or RX2 slot\n            if( ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 ) ||\n                ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_2 ) )\n            {\n                Nvm.MacGroup1.AdrAckCounter = 0;\n                Nvm.MacGroup2.DownlinkReceived = true;\n            }\n\n            // MCPS Indication and ack requested handling\n            if( multicast == 1 )\n            {\n                MacCtx.McpsIndication.McpsIndication = MCPS_MULTICAST;\n            }\n            else\n            {\n                if( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN )\n                {\n                    Nvm.MacGroup1.SrvAckRequested = true;\n                    if( Nvm.MacGroup2.Version.Fields.Minor == 0 )\n                    {\n                        Nvm.MacGroup1.LastRxMic = macMsgData.MIC;\n                    }\n                    MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;\n\n                    // Handle response timeout for class c and class b downlinks\n                    if( ( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_1 ) &&\n                        ( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_2 ) )\n                    {\n                        // Calculate timeout\n                        MacCtx.McpsIndication.ResponseTimeout = REGION_COMMON_CLASS_B_C_RESP_TIMEOUT;\n                        MacCtx.ResponseTimeoutStartTime = RxDoneParams.LastRxDone;\n                    }\n                }\n                else\n                {\n                    Nvm.MacGroup1.SrvAckRequested = false;\n                    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;\n                }\n            }\n\n            // Set the pending status\n            if( ( ( ( Nvm.MacGroup1.SrvAckRequested == true ) || ( macMsgData.FHDR.FCtrl.Bits.FPending > 0 ) ) && ( Nvm.MacGroup2.DeviceClass == CLASS_A ) ) ||\n                ( MacCtx.McpsIndication.ResponseTimeout > 0 ) )\n            {\n                MacCtx.McpsIndication.IsUplinkTxPending = 1;\n            }\n\n            RemoveMacCommands( MacCtx.McpsIndication.RxSlot, macMsgData.FHDR.FCtrl, MacCtx.McpsConfirm.McpsRequest );\n\n            switch( fType )\n            {\n                case FRAME_TYPE_A:\n                {  /* +----------+------+-------+--------------+\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\n                    * +----------+------+-------+--------------+\n                    * |    > 0   |   X  |  > 0  |       X      |\n                    * +----------+------+-------+--------------+\n                    */\n\n                    // Decode MAC commands in FOpts field\n                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.McpsIndication.RxSlot );\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\n                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;\n                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;\n                    MacCtx.McpsIndication.RxData = true;\n                    break;\n                }\n                case FRAME_TYPE_B:\n                {  /* +----------+------+-------+--------------+\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\n                    * +----------+------+-------+--------------+\n                    * |    > 0   |   X  |   -   |       -      |\n                    * +----------+------+-------+--------------+\n                    */\n\n                    // Decode MAC commands in FOpts field\n                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.McpsIndication.RxSlot );\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\n                    break;\n                }\n                case FRAME_TYPE_C:\n                {  /* +----------+------+-------+--------------+\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\n                    * +----------+------+-------+--------------+\n                    * |    = 0   |   -  |  = 0  | MAC commands |\n                    * +----------+------+-------+--------------+\n                    */\n\n                    // Decode MAC commands in FRMPayload\n                    ProcessMacCommands( macMsgData.FRMPayload, 0, macMsgData.FRMPayloadSize, snr, MacCtx.McpsIndication.RxSlot );\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\n                    break;\n                }\n                case FRAME_TYPE_D:\n                {  /* +----------+------+-------+--------------+\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\n                    * +----------+------+-------+--------------+\n                    * |    = 0   |   -  |  > 0  |       X      |\n                    * +----------+------+-------+--------------+\n                    */\n\n                    // No MAC commands just application payload\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\n                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;\n                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;\n                    MacCtx.McpsIndication.RxData = true;\n                    break;\n                }\n                default:\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                    PrepareRxDoneAbort( );\n                    break;\n            }\n\n            // Rejoin handling\n            if( Nvm.MacGroup2.IsRejoinAcceptPending == true )\n            {\n                Nvm.MacGroup2.IsRejoinAcceptPending = false;\n\n                // Stop in any case the ForceRejoinReqCycleTimer\n                TimerStop( &MacCtx.ForceRejoinReqCycleTimer );\n\n                // If the rejoin was trigged by MLME, set confirmation status\n                if( MacCtx.MacFlags.Bits.MlmeReq == 1 )\n                {\n                    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;\n                }\n            }\n\n            if( ( macMsgData.FPort == LORAMAC_CERT_FPORT ) && (Nvm.MacGroup2.IsCertPortOn == false ) )\n            { // Do not notify the upper layer of data reception on FPort LORAMAC_CERT_FPORT if the port\n              // handling is disabled.\n                MacCtx.McpsIndication.Port = macMsgData.FPort;\n                MacCtx.McpsIndication.Buffer = NULL;\n                MacCtx.McpsIndication.BufferSize = 0;\n                MacCtx.McpsIndication.RxData = false;\n            }\n\n            // Provide always an indication, skip the callback to the user application,\n            // in case of a confirmed downlink retransmission.\n            MacCtx.MacFlags.Bits.McpsInd = 1;\n\n            break;\n        case FRAME_TYPE_PROPRIETARY:\n            memcpy1( MacCtx.RxPayload, &payload[pktHeaderLen], size - pktHeaderLen );\n\n            MacCtx.McpsIndication.McpsIndication = MCPS_PROPRIETARY;\n            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;\n            MacCtx.McpsIndication.Buffer = MacCtx.RxPayload;\n            MacCtx.McpsIndication.BufferSize = size - pktHeaderLen;\n\n            MacCtx.MacFlags.Bits.McpsInd = 1;\n            break;\n        default:\n            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n            PrepareRxDoneAbort( );\n            break;\n    }\n\n    // Verify if we need to disable the RetransmitTimeoutTimer\n    // Only aplies if downlink is received on Rx1 or Rx2 windows.\n    if( ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 ) ||\n        ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_2 ) )\n    {\n        if( MacCtx.NodeAckRequested == true )\n        {\n            if( MacCtx.McpsConfirm.AckReceived == true )\n            {\n                OnRetransmitTimeoutTimerEvent( NULL );\n            }\n        }\n    }\n\n    if( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_CLASS_C )\n    {\n        MacCtx.MacFlags.Bits.MacDone = 1;\n    }\n\n    UpdateRxSlotIdleState( );\n}",
        "func": "static void ProcessRadioRxDone( void )\n{\n    LoRaMacHeader_t macHdr;\n    ApplyCFListParams_t applyCFList;\n    GetPhyParams_t getPhy;\n    PhyParam_t phyParam;\n    LoRaMacCryptoStatus_t macCryptoStatus = LORAMAC_CRYPTO_ERROR;\n\n    LoRaMacMessageData_t macMsgData;\n    LoRaMacMessageJoinAccept_t macMsgJoinAccept;\n    uint8_t *payload = RxDoneParams.Payload;\n    uint16_t size = RxDoneParams.Size;\n    int16_t rssi = RxDoneParams.Rssi;\n    int8_t snr = RxDoneParams.Snr;\n\n    uint8_t pktHeaderLen = 0;\n\n    uint32_t downLinkCounter = 0;\n    uint32_t address = Nvm.MacGroup2.DevAddr;\n    uint8_t multicast = 0;\n    AddressIdentifier_t addrID = UNICAST_DEV_ADDR;\n    FCntIdentifier_t fCntID;\n    uint8_t macCmdPayload[2] = { 0 };\n    Mlme_t joinType = MLME_JOIN;\n\n    LoRaMacRadioEvents.Events.RxProcessPending = 0;\n\n    MacCtx.McpsConfirm.AckReceived = false;\n    MacCtx.McpsIndication.Rssi = rssi;\n    MacCtx.McpsIndication.Snr = snr;\n    MacCtx.McpsIndication.RxSlot = MacCtx.RxSlot;\n    MacCtx.McpsIndication.Port = 0;\n    MacCtx.McpsIndication.Multicast = 0;\n    MacCtx.McpsIndication.IsUplinkTxPending = 0;\n    MacCtx.McpsIndication.Buffer = NULL;\n    MacCtx.McpsIndication.BufferSize = 0;\n    MacCtx.McpsIndication.RxData = false;\n    MacCtx.McpsIndication.AckReceived = false;\n    MacCtx.McpsIndication.DownLinkCounter = 0;\n    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;\n    MacCtx.McpsIndication.DevAddress = 0;\n    MacCtx.McpsIndication.DeviceTimeAnsReceived = false;\n    MacCtx.McpsIndication.ResponseTimeout = 0;\n\n    Radio.Sleep( );\n\n    if( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 )\n    {\n        TimerStop( &MacCtx.RxWindowTimer2 );\n    }\n\n    // This function must be called even if we are not in class b mode yet.\n    if( LoRaMacClassBRxBeacon( payload, size ) == true )\n    {\n        MacCtx.MlmeIndication.BeaconInfo.Rssi = rssi;\n        MacCtx.MlmeIndication.BeaconInfo.Snr = snr;\n        return;\n    }\n    // Check if we expect a ping or a multicast slot.\n    if( Nvm.MacGroup2.DeviceClass == CLASS_B )\n    {\n        if( LoRaMacClassBIsPingExpected( ) == true )\n        {\n            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\n            LoRaMacClassBPingSlotTimerEvent( NULL );\n            MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT;\n        }\n        else if( LoRaMacClassBIsMulticastExpected( ) == true )\n        {\n            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\n            LoRaMacClassBMulticastSlotTimerEvent( NULL );\n            MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;\n        }\n    }\n\n    // Abort on empty radio frames\n    if( size == 0 )\n    {\n        MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n        PrepareRxDoneAbort( );\n        return;\n    }\n\n    macHdr.Value = payload[pktHeaderLen++];\n\n    // Accept frames of LoRaWAN Major Version 1 only\n    if( macHdr.Bits.Major != 0 )\n    {\n        MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n        PrepareRxDoneAbort( );\n        return;\n    }\n\n    switch( macHdr.Bits.MType )\n    {\n        case FRAME_TYPE_JOIN_ACCEPT:\n        {\n            // Check if the received frame size is valid\n            if( size < LORAMAC_JOIN_ACCEPT_FRAME_MIN_SIZE )\n            {\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                PrepareRxDoneAbort( );\n                return;\n            }\n            macMsgJoinAccept.Buffer = payload;\n            macMsgJoinAccept.BufSize = size;\n\n            // Abort in case if the device is already joined and no rejoin request is ongoing.\n            if( ( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE ) && ( Nvm.MacGroup2.IsRejoinAcceptPending == false ) )\n            {\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                PrepareRxDoneAbort( );\n                return;\n            }\n            macCryptoStatus = LoRaMacCryptoHandleJoinAccept( JOIN_REQ, SecureElementGetJoinEui( ), &macMsgJoinAccept );\n\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\n            {\n                macCryptoStatus = LoRaMacCryptoHandleJoinAccept( REJOIN_REQ_0, SecureElementGetJoinEui( ), &macMsgJoinAccept );\n                joinType = MLME_REJOIN_0;\n            }\n\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\n            {\n                macCryptoStatus = LoRaMacCryptoHandleJoinAccept( REJOIN_REQ_1, SecureElementGetJoinEui( ), &macMsgJoinAccept );\n                joinType = MLME_REJOIN_1;\n            }\n\n            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )\n            {\n                macCryptoStatus = LoRaMacCryptoHandleJoinAccept( REJOIN_REQ_2, SecureElementGetJoinEui( ), &macMsgJoinAccept );\n                joinType = MLME_REJOIN_2;\n            }\n\n            VerifyParams_t verifyRxDr;\n            bool rxDrValid = false;\n            verifyRxDr.DatarateParams.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;\n            verifyRxDr.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\n            rxDrValid = RegionVerify( Nvm.MacGroup2.Region, &verifyRxDr, PHY_RX_DR );\n\n            if( ( LORAMAC_CRYPTO_SUCCESS == macCryptoStatus ) && ( rxDrValid == true ) )\n            {\n                // Network ID\n                Nvm.MacGroup2.NetID = ( uint32_t ) macMsgJoinAccept.NetID[0];\n                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[1] << 8 );\n                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );\n\n                // Device Address\n                Nvm.MacGroup2.DevAddr = macMsgJoinAccept.DevAddr;\n\n                // DLSettings\n                Nvm.MacGroup2.MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;\n                Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;\n                Nvm.MacGroup2.MacParams.RxCChannel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;\n\n                // RxDelay\n                Nvm.MacGroup2.MacParams.ReceiveDelay1 = macMsgJoinAccept.RxDelay;\n                if( Nvm.MacGroup2.MacParams.ReceiveDelay1 == 0 )\n                {\n                    Nvm.MacGroup2.MacParams.ReceiveDelay1 = 1;\n                }\n                Nvm.MacGroup2.MacParams.ReceiveDelay1 *= 1000;\n                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;\n\n                // Reset NbTrans to default value\n                Nvm.MacGroup2.MacParams.ChannelsNbTrans = 1;\n\n                // Is Networkserver's LoRaWAN Version before 1.1.0 ?\n                if( macMsgJoinAccept.DLSettings.Bits.OptNeg == 0 )\n                {\n                    Nvm.MacGroup2.Version.Value = LORAMAC_FALLBACK_VERSION;\n                }\n                else\n                {\n                    Nvm.MacGroup2.Version.Value = LORAMAC_VERSION;\n                }\n\n                // Apply CF list\n                applyCFList.Payload = macMsgJoinAccept.CFList;\n                // Size of the regular payload is 12. Plus 1 byte MHDR and 4 bytes MIC\n                applyCFList.Size = size - 17;\n                // Apply the last tx channel\n                applyCFList.JoinChannel = MacCtx.Channel;\n\n                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );\n\n                Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_OTAA;\n\n                // Add a RekeyInd MAC command to confirm the security key update.\n                if( Nvm.MacGroup2.Version.Fields.Minor >= 1 )\n                {\n                    Nvm.MacGroup1.RekeyIndUplinksCounter = 0;\n                    macCmdPayload[0] = Nvm.MacGroup2.Version.Fields.Minor;\n                    LoRaMacCommandsAddCmd( MOTE_MAC_REKEY_IND, macCmdPayload, 1 );\n                }\n\n                // MLME handling\n                if( LoRaMacConfirmQueueIsCmdActive( joinType ) == true )\n                {\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, joinType );\n                }\n\n                // Rejoin handling\n                if( Nvm.MacGroup2.IsRejoinAcceptPending == true )\n                {\n                    Nvm.MacGroup2.IsRejoinAcceptPending = false;\n\n                    // Stop in any case the ForceRejoinReqCycleTimer\n                    TimerStop( &MacCtx.ForceRejoinReqCycleTimer );\n                }\n\n                // Reset MAC parameters for specific re-join types\n                if( ( joinType == MLME_REJOIN_0 ) || ( joinType == MLME_REJOIN_1 ) )\n                {\n                    ResetMacParameters( true );\n                }\n            }\n            else\n            {\n                // MLME handling\n                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )\n                {\n                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );\n                }\n            }\n            break;\n        }\n        case FRAME_TYPE_DATA_CONFIRMED_DOWN:\n            MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;\n            // Intentional fall through\n        case FRAME_TYPE_DATA_UNCONFIRMED_DOWN:\n            // Check if the received payload size is valid\n            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;\n            getPhy.Datarate = MacCtx.McpsIndication.RxDatarate;\n            getPhy.Attribute = PHY_MAX_PAYLOAD;\n            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );\n            if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||\n                ( size < LORAMAC_FRAME_PAYLOAD_MIN_SIZE ) )\n            {\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                PrepareRxDoneAbort( );\n                return;\n            }\n            macMsgData.Buffer = payload;\n            macMsgData.BufSize = size;\n            macMsgData.FRMPayload = MacCtx.RxPayload;\n            macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;\n\n            if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )\n            {\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                PrepareRxDoneAbort( );\n                return;\n            }\n\n            // Handle Class B\n            // Check if we expect a ping or a multicast slot.\n            if( Nvm.MacGroup2.DeviceClass == CLASS_B )\n            {\n                if( LoRaMacClassBIsPingExpected( ) == true )\n                {\n                    LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\n                    LoRaMacClassBPingSlotTimerEvent( NULL );\n                    MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT;\n                    LoRaMacClassBSetFPendingBit( macMsgData.FHDR.DevAddr, ( uint8_t ) macMsgData.FHDR.FCtrl.Bits.FPending );\n                }\n                else if( LoRaMacClassBIsMulticastExpected( ) == true )\n                {\n                    LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );\n                    LoRaMacClassBMulticastSlotTimerEvent( NULL );\n                    MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;\n                    LoRaMacClassBSetFPendingBit( macMsgData.FHDR.DevAddr, ( uint8_t ) macMsgData.FHDR.FCtrl.Bits.FPending );\n                }\n            }\n\n            // Store device address\n            MacCtx.McpsIndication.DevAddress = macMsgData.FHDR.DevAddr;\n\n            FType_t fType;\n            if( LORAMAC_STATUS_OK != DetermineFrameType( &macMsgData, &fType ) )\n            {\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                PrepareRxDoneAbort( );\n                return;\n            }\n\n            //Check if it is a multicast message\n            multicast = 0;\n            downLinkCounter = 0;\n            for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )\n            {\n                if( ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) &&\n                    ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true ) )\n                {\n                    multicast = 1;\n                    addrID = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.GroupID;\n                    downLinkCounter = *( Nvm.MacGroup2.MulticastChannelList[i].DownLinkCounter );\n                    address = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address;\n                    if( Nvm.MacGroup2.DeviceClass == CLASS_C )\n                    {\n                        MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;\n                    }\n                    break;\n                }\n            }\n\n            // Filter messages according to multicast downlink exceptions\n            if( ( multicast == 1 ) && ( ( fType != FRAME_TYPE_D ) ||\n                                        ( macMsgData.FHDR.FCtrl.Bits.Ack != 0 ) ||\n                                        ( macMsgData.FHDR.FCtrl.Bits.AdrAckReq != 0 ) ) )\n            {\n                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                PrepareRxDoneAbort( );\n                return;\n            }\n\n            // Get downlink frame counter value\n            macCryptoStatus = GetFCntDown( addrID, fType, &macMsgData, Nvm.MacGroup2.Version, &fCntID, &downLinkCounter );\n            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )\n            {\n                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED )\n                {\n                    // Catch the case of repeated downlink frame counter\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;\n                }\n                else\n                {\n                    // Other errors\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                }\n                MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;\n                PrepareRxDoneAbort( );\n                return;\n            }\n\n            macCryptoStatus = LoRaMacCryptoUnsecureMessage( addrID, address, fCntID, downLinkCounter, &macMsgData );\n            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )\n            {\n                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_ADDRESS )\n                {\n                    // We are not the destination of this frame.\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ADDRESS_FAIL;\n                }\n                else\n                {\n                    // MIC calculation fail\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL;\n                }\n                PrepareRxDoneAbort( );\n                return;\n            }\n\n            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;\n            MacCtx.McpsIndication.Multicast = multicast;\n            MacCtx.McpsIndication.Buffer = NULL;\n            MacCtx.McpsIndication.BufferSize = 0;\n            MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;\n            MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;\n\n            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;\n            MacCtx.McpsConfirm.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;\n\n            // Reset ADR ACK Counter only, when RX1 or RX2 slot\n            if( ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 ) ||\n                ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_2 ) )\n            {\n                Nvm.MacGroup1.AdrAckCounter = 0;\n                Nvm.MacGroup2.DownlinkReceived = true;\n            }\n\n            // MCPS Indication and ack requested handling\n            if( multicast == 1 )\n            {\n                MacCtx.McpsIndication.McpsIndication = MCPS_MULTICAST;\n            }\n            else\n            {\n                if( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN )\n                {\n                    Nvm.MacGroup1.SrvAckRequested = true;\n                    if( Nvm.MacGroup2.Version.Fields.Minor == 0 )\n                    {\n                        Nvm.MacGroup1.LastRxMic = macMsgData.MIC;\n                    }\n                    MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;\n\n                    // Handle response timeout for class c and class b downlinks\n                    if( ( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_1 ) &&\n                        ( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_2 ) )\n                    {\n                        // Calculate timeout\n                        MacCtx.McpsIndication.ResponseTimeout = REGION_COMMON_CLASS_B_C_RESP_TIMEOUT;\n                        MacCtx.ResponseTimeoutStartTime = RxDoneParams.LastRxDone;\n                    }\n                }\n                else\n                {\n                    Nvm.MacGroup1.SrvAckRequested = false;\n                    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;\n                }\n            }\n\n            // Set the pending status\n            if( ( ( ( Nvm.MacGroup1.SrvAckRequested == true ) || ( macMsgData.FHDR.FCtrl.Bits.FPending > 0 ) ) && ( Nvm.MacGroup2.DeviceClass == CLASS_A ) ) ||\n                ( MacCtx.McpsIndication.ResponseTimeout > 0 ) )\n            {\n                MacCtx.McpsIndication.IsUplinkTxPending = 1;\n            }\n\n            RemoveMacCommands( MacCtx.McpsIndication.RxSlot, macMsgData.FHDR.FCtrl, MacCtx.McpsConfirm.McpsRequest );\n\n            switch( fType )\n            {\n                case FRAME_TYPE_A:\n                {  /* +----------+------+-------+--------------+\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\n                    * +----------+------+-------+--------------+\n                    * |    > 0   |   X  |  > 0  |       X      |\n                    * +----------+------+-------+--------------+\n                    */\n\n                    // Decode MAC commands in FOpts field\n                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.McpsIndication.RxSlot );\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\n                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;\n                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;\n                    MacCtx.McpsIndication.RxData = true;\n                    break;\n                }\n                case FRAME_TYPE_B:\n                {  /* +----------+------+-------+--------------+\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\n                    * +----------+------+-------+--------------+\n                    * |    > 0   |   X  |   -   |       -      |\n                    * +----------+------+-------+--------------+\n                    */\n\n                    // Decode MAC commands in FOpts field\n                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.McpsIndication.RxSlot );\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\n                    break;\n                }\n                case FRAME_TYPE_C:\n                {  /* +----------+------+-------+--------------+\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\n                    * +----------+------+-------+--------------+\n                    * |    = 0   |   -  |  = 0  | MAC commands |\n                    * +----------+------+-------+--------------+\n                    */\n\n                    // Decode MAC commands in FRMPayload\n                    ProcessMacCommands( macMsgData.FRMPayload, 0, macMsgData.FRMPayloadSize, snr, MacCtx.McpsIndication.RxSlot );\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\n                    break;\n                }\n                case FRAME_TYPE_D:\n                {  /* +----------+------+-------+--------------+\n                    * | FOptsLen | Fopt | FPort |  FRMPayload  |\n                    * +----------+------+-------+--------------+\n                    * |    = 0   |   -  |  > 0  |       X      |\n                    * +----------+------+-------+--------------+\n                    */\n\n                    // No MAC commands just application payload\n                    MacCtx.McpsIndication.Port = macMsgData.FPort;\n                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;\n                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;\n                    MacCtx.McpsIndication.RxData = true;\n                    break;\n                }\n                default:\n                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n                    PrepareRxDoneAbort( );\n                    break;\n            }\n\n            // Rejoin handling\n            if( Nvm.MacGroup2.IsRejoinAcceptPending == true )\n            {\n                Nvm.MacGroup2.IsRejoinAcceptPending = false;\n\n                // Stop in any case the ForceRejoinReqCycleTimer\n                TimerStop( &MacCtx.ForceRejoinReqCycleTimer );\n\n                // If the rejoin was trigged by MLME, set confirmation status\n                if( MacCtx.MacFlags.Bits.MlmeReq == 1 )\n                {\n                    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;\n                }\n            }\n\n            if( ( macMsgData.FPort == LORAMAC_CERT_FPORT ) && (Nvm.MacGroup2.IsCertPortOn == false ) )\n            { // Do not notify the upper layer of data reception on FPort LORAMAC_CERT_FPORT if the port\n              // handling is disabled.\n                MacCtx.McpsIndication.Port = macMsgData.FPort;\n                MacCtx.McpsIndication.Buffer = NULL;\n                MacCtx.McpsIndication.BufferSize = 0;\n                MacCtx.McpsIndication.RxData = false;\n            }\n\n            // Provide always an indication, skip the callback to the user application,\n            // in case of a confirmed downlink retransmission.\n            MacCtx.MacFlags.Bits.McpsInd = 1;\n\n            break;\n        case FRAME_TYPE_PROPRIETARY:\n            memcpy1( MacCtx.RxPayload, &payload[pktHeaderLen], size - pktHeaderLen );\n\n            MacCtx.McpsIndication.McpsIndication = MCPS_PROPRIETARY;\n            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;\n            MacCtx.McpsIndication.Buffer = MacCtx.RxPayload;\n            MacCtx.McpsIndication.BufferSize = size - pktHeaderLen;\n\n            MacCtx.MacFlags.Bits.McpsInd = 1;\n            break;\n        default:\n            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n            PrepareRxDoneAbort( );\n            break;\n    }\n\n    // Verify if we need to disable the RetransmitTimeoutTimer\n    // Only aplies if downlink is received on Rx1 or Rx2 windows.\n    if( ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 ) ||\n        ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_2 ) )\n    {\n        if( MacCtx.NodeAckRequested == true )\n        {\n            if( MacCtx.McpsConfirm.AckReceived == true )\n            {\n                OnRetransmitTimeoutTimerEvent( NULL );\n            }\n        }\n    }\n\n    if( MacCtx.McpsIndication.RxSlot != RX_SLOT_WIN_CLASS_C )\n    {\n        MacCtx.MacFlags.Bits.MacDone = 1;\n    }\n\n    UpdateRxSlotIdleState( );\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -73,6 +73,14 @@\n         }\n     }\n \n+    // Abort on empty radio frames\n+    if( size == 0 )\n+    {\n+        MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;\n+        PrepareRxDoneAbort( );\n+        return;\n+    }\n+\n     macHdr.Value = payload[pktHeaderLen++];\n \n     // Accept frames of LoRaWAN Major Version 1 only",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    // Abort on empty radio frames",
                "    if( size == 0 )",
                "    {",
                "        MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;",
                "        PrepareRxDoneAbort( );",
                "        return;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3821",
        "func_name": "systemd/format_timespan",
        "description": "An off-by-one Error issue was discovered in Systemd in format_timespan() function of time-util.c. An attacker could supply specific values for time and accuracy that leads to buffer overrun in format_timespan(), leading to a Denial of Service.",
        "git_url": "https://github.com/systemd/systemd/commit/9102c625a673a3246d7e73d8737f3494446bad4e",
        "commit_title": "time-util: fix buffer-over-run",
        "commit_text": " Fixes #23928.",
        "func_before": "char *format_timespan(char *buf, size_t l, usec_t t, usec_t accuracy) {\n        static const struct {\n                const char *suffix;\n                usec_t usec;\n        } table[] = {\n                { \"y\",     USEC_PER_YEAR   },\n                { \"month\", USEC_PER_MONTH  },\n                { \"w\",     USEC_PER_WEEK   },\n                { \"d\",     USEC_PER_DAY    },\n                { \"h\",     USEC_PER_HOUR   },\n                { \"min\",   USEC_PER_MINUTE },\n                { \"s\",     USEC_PER_SEC    },\n                { \"ms\",    USEC_PER_MSEC   },\n                { \"us\",    1               },\n        };\n\n        char *p = buf;\n        bool something = false;\n\n        assert(buf);\n        assert(l > 0);\n\n        if (t == USEC_INFINITY) {\n                strncpy(p, \"infinity\", l-1);\n                p[l-1] = 0;\n                return p;\n        }\n\n        if (t <= 0) {\n                strncpy(p, \"0\", l-1);\n                p[l-1] = 0;\n                return p;\n        }\n\n        /* The result of this function can be parsed with parse_sec */\n\n        for (size_t i = 0; i < ELEMENTSOF(table); i++) {\n                int k = 0;\n                size_t n;\n                bool done = false;\n                usec_t a, b;\n\n                if (t <= 0)\n                        break;\n\n                if (t < accuracy && something)\n                        break;\n\n                if (t < table[i].usec)\n                        continue;\n\n                if (l <= 1)\n                        break;\n\n                a = t / table[i].usec;\n                b = t % table[i].usec;\n\n                /* Let's see if we should shows this in dot notation */\n                if (t < USEC_PER_MINUTE && b > 0) {\n                        signed char j = 0;\n\n                        for (usec_t cc = table[i].usec; cc > 1; cc /= 10)\n                                j++;\n\n                        for (usec_t cc = accuracy; cc > 1; cc /= 10) {\n                                b /= 10;\n                                j--;\n                        }\n\n                        if (j > 0) {\n                                k = snprintf(p, l,\n                                             \"%s\"USEC_FMT\".%0*\"PRI_USEC\"%s\",\n                                             p > buf ? \" \" : \"\",\n                                             a,\n                                             j,\n                                             b,\n                                             table[i].suffix);\n\n                                t = 0;\n                                done = true;\n                        }\n                }\n\n                /* No? Then let's show it normally */\n                if (!done) {\n                        k = snprintf(p, l,\n                                     \"%s\"USEC_FMT\"%s\",\n                                     p > buf ? \" \" : \"\",\n                                     a,\n                                     table[i].suffix);\n\n                        t = b;\n                }\n\n                n = MIN((size_t) k, l);\n\n                l -= n;\n                p += n;\n\n                something = true;\n        }\n\n        *p = 0;\n\n        return buf;\n}",
        "func": "char *format_timespan(char *buf, size_t l, usec_t t, usec_t accuracy) {\n        static const struct {\n                const char *suffix;\n                usec_t usec;\n        } table[] = {\n                { \"y\",     USEC_PER_YEAR   },\n                { \"month\", USEC_PER_MONTH  },\n                { \"w\",     USEC_PER_WEEK   },\n                { \"d\",     USEC_PER_DAY    },\n                { \"h\",     USEC_PER_HOUR   },\n                { \"min\",   USEC_PER_MINUTE },\n                { \"s\",     USEC_PER_SEC    },\n                { \"ms\",    USEC_PER_MSEC   },\n                { \"us\",    1               },\n        };\n\n        char *p = buf;\n        bool something = false;\n\n        assert(buf);\n        assert(l > 0);\n\n        if (t == USEC_INFINITY) {\n                strncpy(p, \"infinity\", l-1);\n                p[l-1] = 0;\n                return p;\n        }\n\n        if (t <= 0) {\n                strncpy(p, \"0\", l-1);\n                p[l-1] = 0;\n                return p;\n        }\n\n        /* The result of this function can be parsed with parse_sec */\n\n        for (size_t i = 0; i < ELEMENTSOF(table); i++) {\n                int k = 0;\n                size_t n;\n                bool done = false;\n                usec_t a, b;\n\n                if (t <= 0)\n                        break;\n\n                if (t < accuracy && something)\n                        break;\n\n                if (t < table[i].usec)\n                        continue;\n\n                if (l <= 1)\n                        break;\n\n                a = t / table[i].usec;\n                b = t % table[i].usec;\n\n                /* Let's see if we should shows this in dot notation */\n                if (t < USEC_PER_MINUTE && b > 0) {\n                        signed char j = 0;\n\n                        for (usec_t cc = table[i].usec; cc > 1; cc /= 10)\n                                j++;\n\n                        for (usec_t cc = accuracy; cc > 1; cc /= 10) {\n                                b /= 10;\n                                j--;\n                        }\n\n                        if (j > 0) {\n                                k = snprintf(p, l,\n                                             \"%s\"USEC_FMT\".%0*\"PRI_USEC\"%s\",\n                                             p > buf ? \" \" : \"\",\n                                             a,\n                                             j,\n                                             b,\n                                             table[i].suffix);\n\n                                t = 0;\n                                done = true;\n                        }\n                }\n\n                /* No? Then let's show it normally */\n                if (!done) {\n                        k = snprintf(p, l,\n                                     \"%s\"USEC_FMT\"%s\",\n                                     p > buf ? \" \" : \"\",\n                                     a,\n                                     table[i].suffix);\n\n                        t = b;\n                }\n\n                n = MIN((size_t) k, l-1);\n\n                l -= n;\n                p += n;\n\n                something = true;\n        }\n\n        *p = 0;\n\n        return buf;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -92,7 +92,7 @@\n                         t = b;\n                 }\n \n-                n = MIN((size_t) k, l);\n+                n = MIN((size_t) k, l-1);\n \n                 l -= n;\n                 p += n;",
        "diff_line_info": {
            "deleted_lines": [
                "                n = MIN((size_t) k, l);"
            ],
            "added_lines": [
                "                n = MIN((size_t) k, l-1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14502",
        "func_name": "libarchive/read_header",
        "description": "read_header in archive_read_support_format_rar.c in libarchive 3.3.2 suffers from an off-by-one error for UTF-16 names in RAR archives, leading to an out-of-bounds read in archive_read_format_rar_read_header.",
        "git_url": "https://github.com/libarchive/libarchive/commit/5562545b5562f6d12a4ef991fae158bf4ccf92b6",
        "commit_title": "Avoid a read off-by-one error for UTF16 names in RAR archives.",
        "commit_text": " Reported-By: OSS-Fuzz issue 573",
        "func_before": "static int\nread_header(struct archive_read *a, struct archive_entry *entry,\n            char head_type)\n{\n  const void *h;\n  const char *p, *endp;\n  struct rar *rar;\n  struct rar_header rar_header;\n  struct rar_file_header file_header;\n  int64_t header_size;\n  unsigned filename_size, end;\n  char *filename;\n  char *strp;\n  char packed_size[8];\n  char unp_size[8];\n  int ttime;\n  struct archive_string_conv *sconv, *fn_sconv;\n  unsigned long crc32_val;\n  int ret = (ARCHIVE_OK), ret2;\n\n  rar = (struct rar *)(a->format->data);\n\n  /* Setup a string conversion object for non-rar-unicode filenames. */\n  sconv = rar->opt_sconv;\n  if (sconv == NULL) {\n    if (!rar->init_default_conversion) {\n      rar->sconv_default =\n          archive_string_default_conversion_for_read(\n            &(a->archive));\n      rar->init_default_conversion = 1;\n    }\n    sconv = rar->sconv_default;\n  }\n\n\n  if ((h = __archive_read_ahead(a, 7, NULL)) == NULL)\n    return (ARCHIVE_FATAL);\n  p = h;\n  memcpy(&rar_header, p, sizeof(rar_header));\n  rar->file_flags = archive_le16dec(rar_header.flags);\n  header_size = archive_le16dec(rar_header.size);\n  if (header_size < (int64_t)sizeof(file_header) + 7) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Invalid header size\");\n    return (ARCHIVE_FATAL);\n  }\n  crc32_val = crc32(0, (const unsigned char *)p + 2, 7 - 2);\n  __archive_read_consume(a, 7);\n\n  if (!(rar->file_flags & FHD_SOLID))\n  {\n    rar->compression_method = 0;\n    rar->packed_size = 0;\n    rar->unp_size = 0;\n    rar->mtime = 0;\n    rar->ctime = 0;\n    rar->atime = 0;\n    rar->arctime = 0;\n    rar->mode = 0;\n    memset(&rar->salt, 0, sizeof(rar->salt));\n    rar->atime = 0;\n    rar->ansec = 0;\n    rar->ctime = 0;\n    rar->cnsec = 0;\n    rar->mtime = 0;\n    rar->mnsec = 0;\n    rar->arctime = 0;\n    rar->arcnsec = 0;\n  }\n  else\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"RAR solid archive support unavailable.\");\n    return (ARCHIVE_FATAL);\n  }\n\n  if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)\n    return (ARCHIVE_FATAL);\n\n  /* File Header CRC check. */\n  crc32_val = crc32(crc32_val, h, (unsigned)(header_size - 7));\n  if ((crc32_val & 0xffff) != archive_le16dec(rar_header.crc)) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Header CRC error\");\n    return (ARCHIVE_FATAL);\n  }\n  /* If no CRC error, Go on parsing File Header. */\n  p = h;\n  endp = p + header_size - 7;\n  memcpy(&file_header, p, sizeof(file_header));\n  p += sizeof(file_header);\n\n  rar->compression_method = file_header.method;\n\n  ttime = archive_le32dec(file_header.file_time);\n  rar->mtime = get_time(ttime);\n\n  rar->file_crc = archive_le32dec(file_header.file_crc);\n\n  if (rar->file_flags & FHD_PASSWORD)\n  {\n\tarchive_entry_set_is_data_encrypted(entry, 1);\n\trar->has_encrypted_entries = 1;\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"RAR encryption support unavailable.\");\n    /* Since it is only the data part itself that is encrypted we can at least\n       extract information about the currently processed entry and don't need\n       to return ARCHIVE_FATAL here. */\n    /*return (ARCHIVE_FATAL);*/\n  }\n\n  if (rar->file_flags & FHD_LARGE)\n  {\n    memcpy(packed_size, file_header.pack_size, 4);\n    memcpy(packed_size + 4, p, 4); /* High pack size */\n    p += 4;\n    memcpy(unp_size, file_header.unp_size, 4);\n    memcpy(unp_size + 4, p, 4); /* High unpack size */\n    p += 4;\n    rar->packed_size = archive_le64dec(&packed_size);\n    rar->unp_size = archive_le64dec(&unp_size);\n  }\n  else\n  {\n    rar->packed_size = archive_le32dec(file_header.pack_size);\n    rar->unp_size = archive_le32dec(file_header.unp_size);\n  }\n\n  if (rar->packed_size < 0 || rar->unp_size < 0)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Invalid sizes specified.\");\n    return (ARCHIVE_FATAL);\n  }\n\n  rar->bytes_remaining = rar->packed_size;\n\n  /* TODO: RARv3 subblocks contain comments. For now the complete block is\n   * consumed at the end.\n   */\n  if (head_type == NEWSUB_HEAD) {\n    size_t distance = p - (const char *)h;\n    header_size += rar->packed_size;\n    /* Make sure we have the extended data. */\n    if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)\n        return (ARCHIVE_FATAL);\n    p = h;\n    endp = p + header_size - 7;\n    p += distance;\n  }\n\n  filename_size = archive_le16dec(file_header.name_size);\n  if (p + filename_size > endp) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Invalid filename size\");\n    return (ARCHIVE_FATAL);\n  }\n  if (rar->filename_allocated < filename_size * 2 + 2) {\n    char *newptr;\n    size_t newsize = filename_size * 2 + 2;\n    newptr = realloc(rar->filename, newsize);\n    if (newptr == NULL) {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Couldn't allocate memory.\");\n      return (ARCHIVE_FATAL);\n    }\n    rar->filename = newptr;\n    rar->filename_allocated = newsize;\n  }\n  filename = rar->filename;\n  memcpy(filename, p, filename_size);\n  filename[filename_size] = '\\0';\n  if (rar->file_flags & FHD_UNICODE)\n  {\n    if (filename_size != strlen(filename))\n    {\n      unsigned char highbyte, flagbits, flagbyte;\n      unsigned fn_end, offset;\n\n      end = filename_size;\n      fn_end = filename_size * 2;\n      filename_size = 0;\n      offset = (unsigned)strlen(filename) + 1;\n      highbyte = *(p + offset++);\n      flagbits = 0;\n      flagbyte = 0;\n      while (offset < end && filename_size < fn_end)\n      {\n        if (!flagbits)\n        {\n          flagbyte = *(p + offset++);\n          flagbits = 8;\n        }\n\n        flagbits -= 2;\n        switch((flagbyte >> flagbits) & 3)\n        {\n          case 0:\n            filename[filename_size++] = '\\0';\n            filename[filename_size++] = *(p + offset++);\n            break;\n          case 1:\n            filename[filename_size++] = highbyte;\n            filename[filename_size++] = *(p + offset++);\n            break;\n          case 2:\n            filename[filename_size++] = *(p + offset + 1);\n            filename[filename_size++] = *(p + offset);\n            offset += 2;\n            break;\n          case 3:\n          {\n            char extra, high;\n            uint8_t length = *(p + offset++);\n\n            if (length & 0x80) {\n              extra = *(p + offset++);\n              high = (char)highbyte;\n            } else\n              extra = high = 0;\n            length = (length & 0x7f) + 2;\n            while (length && filename_size < fn_end) {\n              unsigned cp = filename_size >> 1;\n              filename[filename_size++] = high;\n              filename[filename_size++] = p[cp] + extra;\n              length--;\n            }\n          }\n          break;\n        }\n      }\n      if (filename_size > fn_end) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n          \"Invalid filename\");\n        return (ARCHIVE_FATAL);\n      }\n      filename[filename_size++] = '\\0';\n      filename[filename_size++] = '\\0';\n\n      /* Decoded unicode form is UTF-16BE, so we have to update a string\n       * conversion object for it. */\n      if (rar->sconv_utf16be == NULL) {\n        rar->sconv_utf16be = archive_string_conversion_from_charset(\n           &a->archive, \"UTF-16BE\", 1);\n        if (rar->sconv_utf16be == NULL)\n          return (ARCHIVE_FATAL);\n      }\n      fn_sconv = rar->sconv_utf16be;\n\n      strp = filename;\n      while (memcmp(strp, \"\\x00\\x00\", 2))\n      {\n        if (!memcmp(strp, \"\\x00\\\\\", 2))\n          *(strp + 1) = '/';\n        strp += 2;\n      }\n      p += offset;\n    } else {\n      /*\n       * If FHD_UNICODE is set but no unicode data, this file name form\n       * is UTF-8, so we have to update a string conversion object for\n       * it accordingly.\n       */\n      if (rar->sconv_utf8 == NULL) {\n        rar->sconv_utf8 = archive_string_conversion_from_charset(\n           &a->archive, \"UTF-8\", 1);\n        if (rar->sconv_utf8 == NULL)\n          return (ARCHIVE_FATAL);\n      }\n      fn_sconv = rar->sconv_utf8;\n      while ((strp = strchr(filename, '\\\\')) != NULL)\n        *strp = '/';\n      p += filename_size;\n    }\n  }\n  else\n  {\n    fn_sconv = sconv;\n    while ((strp = strchr(filename, '\\\\')) != NULL)\n      *strp = '/';\n    p += filename_size;\n  }\n\n  /* Split file in multivolume RAR. No more need to process header. */\n  if (rar->filename_save &&\n    filename_size == rar->filename_save_size &&\n    !memcmp(rar->filename, rar->filename_save, filename_size + 1))\n  {\n    __archive_read_consume(a, header_size - 7);\n    rar->cursor++;\n    if (rar->cursor >= rar->nodes)\n    {\n      rar->nodes++;\n      if ((rar->dbo =\n        realloc(rar->dbo, sizeof(*rar->dbo) * rar->nodes)) == NULL)\n      {\n        archive_set_error(&a->archive, ENOMEM, \"Couldn't allocate memory.\");\n        return (ARCHIVE_FATAL);\n      }\n      rar->dbo[rar->cursor].header_size = header_size;\n      rar->dbo[rar->cursor].start_offset = -1;\n      rar->dbo[rar->cursor].end_offset = -1;\n    }\n    if (rar->dbo[rar->cursor].start_offset < 0)\n    {\n      rar->dbo[rar->cursor].start_offset = a->filter->position;\n      rar->dbo[rar->cursor].end_offset = rar->dbo[rar->cursor].start_offset +\n        rar->packed_size;\n    }\n    return ret;\n  }\n\n  rar->filename_save = (char*)realloc(rar->filename_save,\n                                      filename_size + 1);\n  memcpy(rar->filename_save, rar->filename, filename_size + 1);\n  rar->filename_save_size = filename_size;\n\n  /* Set info for seeking */\n  free(rar->dbo);\n  if ((rar->dbo = calloc(1, sizeof(*rar->dbo))) == NULL)\n  {\n    archive_set_error(&a->archive, ENOMEM, \"Couldn't allocate memory.\");\n    return (ARCHIVE_FATAL);\n  }\n  rar->dbo[0].header_size = header_size;\n  rar->dbo[0].start_offset = -1;\n  rar->dbo[0].end_offset = -1;\n  rar->cursor = 0;\n  rar->nodes = 1;\n\n  if (rar->file_flags & FHD_SALT)\n  {\n    if (p + 8 > endp) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n        \"Invalid header size\");\n      return (ARCHIVE_FATAL);\n    }\n    memcpy(rar->salt, p, 8);\n    p += 8;\n  }\n\n  if (rar->file_flags & FHD_EXTTIME) {\n    if (read_exttime(p, rar, endp) < 0) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n        \"Invalid header size\");\n      return (ARCHIVE_FATAL);\n    }\n  }\n\n  __archive_read_consume(a, header_size - 7);\n  rar->dbo[0].start_offset = a->filter->position;\n  rar->dbo[0].end_offset = rar->dbo[0].start_offset + rar->packed_size;\n\n  switch(file_header.host_os)\n  {\n  case OS_MSDOS:\n  case OS_OS2:\n  case OS_WIN32:\n    rar->mode = archive_le32dec(file_header.file_attr);\n    if (rar->mode & FILE_ATTRIBUTE_DIRECTORY)\n      rar->mode = AE_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;\n    else\n      rar->mode = AE_IFREG;\n    rar->mode |= S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;\n    break;\n\n  case OS_UNIX:\n  case OS_MAC_OS:\n  case OS_BEOS:\n    rar->mode = archive_le32dec(file_header.file_attr);\n    break;\n\n  default:\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Unknown file attributes from RAR file's host OS\");\n    return (ARCHIVE_FATAL);\n  }\n\n  rar->bytes_uncopied = rar->bytes_unconsumed = 0;\n  rar->lzss.position = rar->offset = 0;\n  rar->offset_seek = 0;\n  rar->dictionary_size = 0;\n  rar->offset_outgoing = 0;\n  rar->br.cache_avail = 0;\n  rar->br.avail_in = 0;\n  rar->crc_calculated = 0;\n  rar->entry_eof = 0;\n  rar->valid = 1;\n  rar->is_ppmd_block = 0;\n  rar->start_new_table = 1;\n  free(rar->unp_buffer);\n  rar->unp_buffer = NULL;\n  rar->unp_offset = 0;\n  rar->unp_buffer_size = UNP_BUFFER_SIZE;\n  memset(rar->lengthtable, 0, sizeof(rar->lengthtable));\n  __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context, &g_szalloc);\n  rar->ppmd_valid = rar->ppmd_eod = 0;\n\n  /* Don't set any archive entries for non-file header types */\n  if (head_type == NEWSUB_HEAD)\n    return ret;\n\n  archive_entry_set_mtime(entry, rar->mtime, rar->mnsec);\n  archive_entry_set_ctime(entry, rar->ctime, rar->cnsec);\n  archive_entry_set_atime(entry, rar->atime, rar->ansec);\n  archive_entry_set_size(entry, rar->unp_size);\n  archive_entry_set_mode(entry, rar->mode);\n\n  if (archive_entry_copy_pathname_l(entry, filename, filename_size, fn_sconv))\n  {\n    if (errno == ENOMEM)\n    {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Can't allocate memory for Pathname\");\n      return (ARCHIVE_FATAL);\n    }\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Pathname cannot be converted from %s to current locale.\",\n                      archive_string_conversion_charset_name(fn_sconv));\n    ret = (ARCHIVE_WARN);\n  }\n\n  if (((rar->mode) & AE_IFMT) == AE_IFLNK)\n  {\n    /* Make sure a symbolic-link file does not have its body. */\n    rar->bytes_remaining = 0;\n    archive_entry_set_size(entry, 0);\n\n    /* Read a symbolic-link name. */\n    if ((ret2 = read_symlink_stored(a, entry, sconv)) < (ARCHIVE_WARN))\n      return ret2;\n    if (ret > ret2)\n      ret = ret2;\n  }\n\n  if (rar->bytes_remaining == 0)\n    rar->entry_eof = 1;\n\n  return ret;\n}",
        "func": "static int\nread_header(struct archive_read *a, struct archive_entry *entry,\n            char head_type)\n{\n  const void *h;\n  const char *p, *endp;\n  struct rar *rar;\n  struct rar_header rar_header;\n  struct rar_file_header file_header;\n  int64_t header_size;\n  unsigned filename_size, end;\n  char *filename;\n  char *strp;\n  char packed_size[8];\n  char unp_size[8];\n  int ttime;\n  struct archive_string_conv *sconv, *fn_sconv;\n  unsigned long crc32_val;\n  int ret = (ARCHIVE_OK), ret2;\n\n  rar = (struct rar *)(a->format->data);\n\n  /* Setup a string conversion object for non-rar-unicode filenames. */\n  sconv = rar->opt_sconv;\n  if (sconv == NULL) {\n    if (!rar->init_default_conversion) {\n      rar->sconv_default =\n          archive_string_default_conversion_for_read(\n            &(a->archive));\n      rar->init_default_conversion = 1;\n    }\n    sconv = rar->sconv_default;\n  }\n\n\n  if ((h = __archive_read_ahead(a, 7, NULL)) == NULL)\n    return (ARCHIVE_FATAL);\n  p = h;\n  memcpy(&rar_header, p, sizeof(rar_header));\n  rar->file_flags = archive_le16dec(rar_header.flags);\n  header_size = archive_le16dec(rar_header.size);\n  if (header_size < (int64_t)sizeof(file_header) + 7) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Invalid header size\");\n    return (ARCHIVE_FATAL);\n  }\n  crc32_val = crc32(0, (const unsigned char *)p + 2, 7 - 2);\n  __archive_read_consume(a, 7);\n\n  if (!(rar->file_flags & FHD_SOLID))\n  {\n    rar->compression_method = 0;\n    rar->packed_size = 0;\n    rar->unp_size = 0;\n    rar->mtime = 0;\n    rar->ctime = 0;\n    rar->atime = 0;\n    rar->arctime = 0;\n    rar->mode = 0;\n    memset(&rar->salt, 0, sizeof(rar->salt));\n    rar->atime = 0;\n    rar->ansec = 0;\n    rar->ctime = 0;\n    rar->cnsec = 0;\n    rar->mtime = 0;\n    rar->mnsec = 0;\n    rar->arctime = 0;\n    rar->arcnsec = 0;\n  }\n  else\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"RAR solid archive support unavailable.\");\n    return (ARCHIVE_FATAL);\n  }\n\n  if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)\n    return (ARCHIVE_FATAL);\n\n  /* File Header CRC check. */\n  crc32_val = crc32(crc32_val, h, (unsigned)(header_size - 7));\n  if ((crc32_val & 0xffff) != archive_le16dec(rar_header.crc)) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Header CRC error\");\n    return (ARCHIVE_FATAL);\n  }\n  /* If no CRC error, Go on parsing File Header. */\n  p = h;\n  endp = p + header_size - 7;\n  memcpy(&file_header, p, sizeof(file_header));\n  p += sizeof(file_header);\n\n  rar->compression_method = file_header.method;\n\n  ttime = archive_le32dec(file_header.file_time);\n  rar->mtime = get_time(ttime);\n\n  rar->file_crc = archive_le32dec(file_header.file_crc);\n\n  if (rar->file_flags & FHD_PASSWORD)\n  {\n\tarchive_entry_set_is_data_encrypted(entry, 1);\n\trar->has_encrypted_entries = 1;\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"RAR encryption support unavailable.\");\n    /* Since it is only the data part itself that is encrypted we can at least\n       extract information about the currently processed entry and don't need\n       to return ARCHIVE_FATAL here. */\n    /*return (ARCHIVE_FATAL);*/\n  }\n\n  if (rar->file_flags & FHD_LARGE)\n  {\n    memcpy(packed_size, file_header.pack_size, 4);\n    memcpy(packed_size + 4, p, 4); /* High pack size */\n    p += 4;\n    memcpy(unp_size, file_header.unp_size, 4);\n    memcpy(unp_size + 4, p, 4); /* High unpack size */\n    p += 4;\n    rar->packed_size = archive_le64dec(&packed_size);\n    rar->unp_size = archive_le64dec(&unp_size);\n  }\n  else\n  {\n    rar->packed_size = archive_le32dec(file_header.pack_size);\n    rar->unp_size = archive_le32dec(file_header.unp_size);\n  }\n\n  if (rar->packed_size < 0 || rar->unp_size < 0)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Invalid sizes specified.\");\n    return (ARCHIVE_FATAL);\n  }\n\n  rar->bytes_remaining = rar->packed_size;\n\n  /* TODO: RARv3 subblocks contain comments. For now the complete block is\n   * consumed at the end.\n   */\n  if (head_type == NEWSUB_HEAD) {\n    size_t distance = p - (const char *)h;\n    header_size += rar->packed_size;\n    /* Make sure we have the extended data. */\n    if ((h = __archive_read_ahead(a, (size_t)header_size - 7, NULL)) == NULL)\n        return (ARCHIVE_FATAL);\n    p = h;\n    endp = p + header_size - 7;\n    p += distance;\n  }\n\n  filename_size = archive_le16dec(file_header.name_size);\n  if (p + filename_size > endp) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n      \"Invalid filename size\");\n    return (ARCHIVE_FATAL);\n  }\n  if (rar->filename_allocated < filename_size * 2 + 2) {\n    char *newptr;\n    size_t newsize = filename_size * 2 + 2;\n    newptr = realloc(rar->filename, newsize);\n    if (newptr == NULL) {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Couldn't allocate memory.\");\n      return (ARCHIVE_FATAL);\n    }\n    rar->filename = newptr;\n    rar->filename_allocated = newsize;\n  }\n  filename = rar->filename;\n  memcpy(filename, p, filename_size);\n  filename[filename_size] = '\\0';\n  if (rar->file_flags & FHD_UNICODE)\n  {\n    if (filename_size != strlen(filename))\n    {\n      unsigned char highbyte, flagbits, flagbyte;\n      unsigned fn_end, offset;\n\n      end = filename_size;\n      fn_end = filename_size * 2;\n      filename_size = 0;\n      offset = (unsigned)strlen(filename) + 1;\n      highbyte = *(p + offset++);\n      flagbits = 0;\n      flagbyte = 0;\n      while (offset < end && filename_size < fn_end)\n      {\n        if (!flagbits)\n        {\n          flagbyte = *(p + offset++);\n          flagbits = 8;\n        }\n\n        flagbits -= 2;\n        switch((flagbyte >> flagbits) & 3)\n        {\n          case 0:\n            filename[filename_size++] = '\\0';\n            filename[filename_size++] = *(p + offset++);\n            break;\n          case 1:\n            filename[filename_size++] = highbyte;\n            filename[filename_size++] = *(p + offset++);\n            break;\n          case 2:\n            filename[filename_size++] = *(p + offset + 1);\n            filename[filename_size++] = *(p + offset);\n            offset += 2;\n            break;\n          case 3:\n          {\n            char extra, high;\n            uint8_t length = *(p + offset++);\n\n            if (length & 0x80) {\n              extra = *(p + offset++);\n              high = (char)highbyte;\n            } else\n              extra = high = 0;\n            length = (length & 0x7f) + 2;\n            while (length && filename_size < fn_end) {\n              unsigned cp = filename_size >> 1;\n              filename[filename_size++] = high;\n              filename[filename_size++] = p[cp] + extra;\n              length--;\n            }\n          }\n          break;\n        }\n      }\n      if (filename_size > fn_end) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n          \"Invalid filename\");\n        return (ARCHIVE_FATAL);\n      }\n      filename[filename_size++] = '\\0';\n      /*\n       * Do not increment filename_size here as the computations below\n       * add the space for the terminating NUL explicitly.\n       */\n      filename[filename_size] = '\\0';\n\n      /* Decoded unicode form is UTF-16BE, so we have to update a string\n       * conversion object for it. */\n      if (rar->sconv_utf16be == NULL) {\n        rar->sconv_utf16be = archive_string_conversion_from_charset(\n           &a->archive, \"UTF-16BE\", 1);\n        if (rar->sconv_utf16be == NULL)\n          return (ARCHIVE_FATAL);\n      }\n      fn_sconv = rar->sconv_utf16be;\n\n      strp = filename;\n      while (memcmp(strp, \"\\x00\\x00\", 2))\n      {\n        if (!memcmp(strp, \"\\x00\\\\\", 2))\n          *(strp + 1) = '/';\n        strp += 2;\n      }\n      p += offset;\n    } else {\n      /*\n       * If FHD_UNICODE is set but no unicode data, this file name form\n       * is UTF-8, so we have to update a string conversion object for\n       * it accordingly.\n       */\n      if (rar->sconv_utf8 == NULL) {\n        rar->sconv_utf8 = archive_string_conversion_from_charset(\n           &a->archive, \"UTF-8\", 1);\n        if (rar->sconv_utf8 == NULL)\n          return (ARCHIVE_FATAL);\n      }\n      fn_sconv = rar->sconv_utf8;\n      while ((strp = strchr(filename, '\\\\')) != NULL)\n        *strp = '/';\n      p += filename_size;\n    }\n  }\n  else\n  {\n    fn_sconv = sconv;\n    while ((strp = strchr(filename, '\\\\')) != NULL)\n      *strp = '/';\n    p += filename_size;\n  }\n\n  /* Split file in multivolume RAR. No more need to process header. */\n  if (rar->filename_save &&\n    filename_size == rar->filename_save_size &&\n    !memcmp(rar->filename, rar->filename_save, filename_size + 1))\n  {\n    __archive_read_consume(a, header_size - 7);\n    rar->cursor++;\n    if (rar->cursor >= rar->nodes)\n    {\n      rar->nodes++;\n      if ((rar->dbo =\n        realloc(rar->dbo, sizeof(*rar->dbo) * rar->nodes)) == NULL)\n      {\n        archive_set_error(&a->archive, ENOMEM, \"Couldn't allocate memory.\");\n        return (ARCHIVE_FATAL);\n      }\n      rar->dbo[rar->cursor].header_size = header_size;\n      rar->dbo[rar->cursor].start_offset = -1;\n      rar->dbo[rar->cursor].end_offset = -1;\n    }\n    if (rar->dbo[rar->cursor].start_offset < 0)\n    {\n      rar->dbo[rar->cursor].start_offset = a->filter->position;\n      rar->dbo[rar->cursor].end_offset = rar->dbo[rar->cursor].start_offset +\n        rar->packed_size;\n    }\n    return ret;\n  }\n\n  rar->filename_save = (char*)realloc(rar->filename_save,\n                                      filename_size + 1);\n  memcpy(rar->filename_save, rar->filename, filename_size + 1);\n  rar->filename_save_size = filename_size;\n\n  /* Set info for seeking */\n  free(rar->dbo);\n  if ((rar->dbo = calloc(1, sizeof(*rar->dbo))) == NULL)\n  {\n    archive_set_error(&a->archive, ENOMEM, \"Couldn't allocate memory.\");\n    return (ARCHIVE_FATAL);\n  }\n  rar->dbo[0].header_size = header_size;\n  rar->dbo[0].start_offset = -1;\n  rar->dbo[0].end_offset = -1;\n  rar->cursor = 0;\n  rar->nodes = 1;\n\n  if (rar->file_flags & FHD_SALT)\n  {\n    if (p + 8 > endp) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n        \"Invalid header size\");\n      return (ARCHIVE_FATAL);\n    }\n    memcpy(rar->salt, p, 8);\n    p += 8;\n  }\n\n  if (rar->file_flags & FHD_EXTTIME) {\n    if (read_exttime(p, rar, endp) < 0) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n        \"Invalid header size\");\n      return (ARCHIVE_FATAL);\n    }\n  }\n\n  __archive_read_consume(a, header_size - 7);\n  rar->dbo[0].start_offset = a->filter->position;\n  rar->dbo[0].end_offset = rar->dbo[0].start_offset + rar->packed_size;\n\n  switch(file_header.host_os)\n  {\n  case OS_MSDOS:\n  case OS_OS2:\n  case OS_WIN32:\n    rar->mode = archive_le32dec(file_header.file_attr);\n    if (rar->mode & FILE_ATTRIBUTE_DIRECTORY)\n      rar->mode = AE_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;\n    else\n      rar->mode = AE_IFREG;\n    rar->mode |= S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;\n    break;\n\n  case OS_UNIX:\n  case OS_MAC_OS:\n  case OS_BEOS:\n    rar->mode = archive_le32dec(file_header.file_attr);\n    break;\n\n  default:\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Unknown file attributes from RAR file's host OS\");\n    return (ARCHIVE_FATAL);\n  }\n\n  rar->bytes_uncopied = rar->bytes_unconsumed = 0;\n  rar->lzss.position = rar->offset = 0;\n  rar->offset_seek = 0;\n  rar->dictionary_size = 0;\n  rar->offset_outgoing = 0;\n  rar->br.cache_avail = 0;\n  rar->br.avail_in = 0;\n  rar->crc_calculated = 0;\n  rar->entry_eof = 0;\n  rar->valid = 1;\n  rar->is_ppmd_block = 0;\n  rar->start_new_table = 1;\n  free(rar->unp_buffer);\n  rar->unp_buffer = NULL;\n  rar->unp_offset = 0;\n  rar->unp_buffer_size = UNP_BUFFER_SIZE;\n  memset(rar->lengthtable, 0, sizeof(rar->lengthtable));\n  __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context, &g_szalloc);\n  rar->ppmd_valid = rar->ppmd_eod = 0;\n\n  /* Don't set any archive entries for non-file header types */\n  if (head_type == NEWSUB_HEAD)\n    return ret;\n\n  archive_entry_set_mtime(entry, rar->mtime, rar->mnsec);\n  archive_entry_set_ctime(entry, rar->ctime, rar->cnsec);\n  archive_entry_set_atime(entry, rar->atime, rar->ansec);\n  archive_entry_set_size(entry, rar->unp_size);\n  archive_entry_set_mode(entry, rar->mode);\n\n  if (archive_entry_copy_pathname_l(entry, filename, filename_size, fn_sconv))\n  {\n    if (errno == ENOMEM)\n    {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Can't allocate memory for Pathname\");\n      return (ARCHIVE_FATAL);\n    }\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Pathname cannot be converted from %s to current locale.\",\n                      archive_string_conversion_charset_name(fn_sconv));\n    ret = (ARCHIVE_WARN);\n  }\n\n  if (((rar->mode) & AE_IFMT) == AE_IFLNK)\n  {\n    /* Make sure a symbolic-link file does not have its body. */\n    rar->bytes_remaining = 0;\n    archive_entry_set_size(entry, 0);\n\n    /* Read a symbolic-link name. */\n    if ((ret2 = read_symlink_stored(a, entry, sconv)) < (ARCHIVE_WARN))\n      return ret2;\n    if (ret > ret2)\n      ret = ret2;\n  }\n\n  if (rar->bytes_remaining == 0)\n    rar->entry_eof = 1;\n\n  return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -235,7 +235,11 @@\n         return (ARCHIVE_FATAL);\n       }\n       filename[filename_size++] = '\\0';\n-      filename[filename_size++] = '\\0';\n+      /*\n+       * Do not increment filename_size here as the computations below\n+       * add the space for the terminating NUL explicitly.\n+       */\n+      filename[filename_size] = '\\0';\n \n       /* Decoded unicode form is UTF-16BE, so we have to update a string\n        * conversion object for it. */",
        "diff_line_info": {
            "deleted_lines": [
                "      filename[filename_size++] = '\\0';"
            ],
            "added_lines": [
                "      /*",
                "       * Do not increment filename_size here as the computations below",
                "       * add the space for the terminating NUL explicitly.",
                "       */",
                "      filename[filename_size] = '\\0';"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-10160",
        "func_name": "php/php-src/phar_parse_pharfile",
        "description": "Off-by-one error in the phar_parse_pharfile function in ext/phar/phar.c in PHP before 5.6.30 and 7.0.x before 7.0.15 allows remote attackers to cause a denial of service (memory corruption) or possibly execute arbitrary code via a crafted PHAR archive with an alias mismatch.",
        "git_url": "https://github.com/php/php-src/commit/b28b8b2fee6dfa6fcd13305c581bb835689ac3be",
        "commit_title": "Fix bug #73768 - Memory corruption when loading hostile phar",
        "commit_text": "",
        "func_before": "static int phar_parse_pharfile(php_stream *fp, char *fname, int fname_len, char *alias, int alias_len, long halt_offset, phar_archive_data** pphar, php_uint32 compression, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar b32[4], *buffer, *endbuffer, *savebuf;\n\tphar_archive_data *mydata = NULL;\n\tphar_entry_info entry;\n\tphp_uint32 manifest_len, manifest_count, manifest_flags, manifest_index, tmp_len, sig_flags;\n\tphp_uint16 manifest_ver;\n\tphp_uint32 len;\n\tlong offset;\n\tint sig_len, register_alias = 0, temp_alias = 0;\n\tchar *signature = NULL;\n\n\tif (pphar) {\n\t\t*pphar = NULL;\n\t}\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\t/* check for ?>\\n and increment accordingly */\n\tif (-1 == php_stream_seek(fp, halt_offset, SEEK_SET)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"cannot seek to __HALT_COMPILER(); location in phar \\\"%s\\\"\")\n\t}\n\n\tbuffer = b32;\n\n\tif (3 != php_stream_read(fp, buffer, 3)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at stub end)\")\n\t}\n\n\tif ((*buffer == ' ' || *buffer == '\\n') && *(buffer + 1) == '?' && *(buffer + 2) == '>') {\n\t\tint nextchar;\n\t\thalt_offset += 3;\n\t\tif (EOF == (nextchar = php_stream_getc(fp))) {\n\t\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at stub end)\")\n\t\t}\n\n\t\tif ((char) nextchar == '\\r') {\n\t\t\t/* if we have an \\r we require an \\n as well */\n\t\t\tif (EOF == (nextchar = php_stream_getc(fp)) || (char)nextchar != '\\n') {\n\t\t\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at stub end)\")\n\t\t\t}\n\t\t\t++halt_offset;\n\t\t}\n\n\t\tif ((char) nextchar == '\\n') {\n\t\t\t++halt_offset;\n\t\t}\n\t}\n\n\t/* make sure we are at the right location to read the manifest */\n\tif (-1 == php_stream_seek(fp, halt_offset, SEEK_SET)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"cannot seek to __HALT_COMPILER(); location in phar \\\"%s\\\"\")\n\t}\n\n\t/* read in manifest */\n\tbuffer = b32;\n\n\tif (4 != php_stream_read(fp, buffer, 4)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at manifest length)\")\n\t}\n\n\tPHAR_GET_32(buffer, manifest_len);\n\n\tif (manifest_len > 1048576 * 100) {\n\t\t/* prevent serious memory issues by limiting manifest to at most 100 MB in length */\n\t\tMAPPHAR_ALLOC_FAIL(\"manifest cannot be larger than 100 MB in phar \\\"%s\\\"\")\n\t}\n\n\tbuffer = (char *)emalloc(manifest_len);\n\tsavebuf = buffer;\n\tendbuffer = buffer + manifest_len;\n\n\tif (manifest_len < 10 || manifest_len != php_stream_read(fp, buffer, manifest_len)) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest header)\")\n\t}\n\n\t/* extract the number of entries */\n\tPHAR_GET_32(buffer, manifest_count);\n\n\tif (manifest_count == 0) {\n\t\tMAPPHAR_FAIL(\"in phar \\\"%s\\\", manifest claims to have zero entries.  Phars must have at least 1 entry\");\n\t}\n\n\t/* extract API version, lowest nibble currently unused */\n\tmanifest_ver = (((unsigned char)buffer[0]) << 8)\n\t\t\t\t + ((unsigned char)buffer[1]);\n\tbuffer += 2;\n\n\tif ((manifest_ver & PHAR_API_VER_MASK) < PHAR_API_MIN_READ) {\n\t\tefree(savebuf);\n\t\tphp_stream_close(fp);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" is API version %1.u.%1.u.%1.u, and cannot be processed\", fname, manifest_ver >> 12, (manifest_ver >> 8) & 0xF, (manifest_ver >> 4) & 0x0F);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tPHAR_GET_32(buffer, manifest_flags);\n\n\tmanifest_flags &= ~PHAR_HDR_COMPRESSION_MASK;\n\tmanifest_flags &= ~PHAR_FILE_COMPRESSION_MASK;\n\t/* remember whether this entire phar was compressed with gz/bzip2 */\n\tmanifest_flags |= compression;\n\n\t/* The lowest nibble contains the phar wide flags. The compression flags can */\n\t/* be ignored on reading because it is being generated anyways. */\n\tif (manifest_flags & PHAR_HDR_SIGNATURE) {\n\t\tchar sig_buf[8], *sig_ptr = sig_buf;\n\t\toff_t read_len;\n\t\tsize_t end_of_phar;\n\n\t\tif (-1 == php_stream_seek(fp, -8, SEEK_END)\n\t\t|| (read_len = php_stream_tell(fp)) < 20\n\t\t|| 8 != php_stream_read(fp, sig_buf, 8)\n\t\t|| memcmp(sig_buf+4, \"GBMB\", 4)) {\n\t\t\tefree(savebuf);\n\t\t\tphp_stream_close(fp);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tPHAR_GET_32(sig_ptr, sig_flags);\n\n\t\tswitch(sig_flags) {\n\t\t\tcase PHAR_SIG_OPENSSL: {\n\t\t\t\tphp_uint32 signature_len;\n\t\t\t\tchar *sig;\n\t\t\t\toff_t whence;\n\n\t\t\t\t/* we store the signature followed by the signature length */\n\t\t\t\tif (-1 == php_stream_seek(fp, -12, SEEK_CUR)\n\t\t\t\t|| 4 != php_stream_read(fp, sig_buf, 4)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" openssl signature length could not be read\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tsig_ptr = sig_buf;\n\t\t\t\tPHAR_GET_32(sig_ptr, signature_len);\n\t\t\t\tsig = (char *) emalloc(signature_len);\n\t\t\t\twhence = signature_len + 4;\n\t\t\t\twhence = -whence;\n\n\t\t\t\tif (-1 == php_stream_seek(fp, whence, SEEK_CUR)\n\t\t\t\t|| !(end_of_phar = php_stream_tell(fp))\n\t\t\t\t|| signature_len != php_stream_read(fp, sig, signature_len)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tefree(sig);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" openssl signature could not be read\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, end_of_phar, PHAR_SIG_OPENSSL, sig, signature_len, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tefree(sig);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" openssl signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tefree(sig);\n\t\t\t}\n\t\t\tbreak;\n#if PHAR_HASH_OK\n\t\t\tcase PHAR_SIG_SHA512: {\n\t\t\t\tunsigned char digest[64];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 64), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA512, (char *)digest, 64, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" SHA512 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PHAR_SIG_SHA256: {\n\t\t\t\tunsigned char digest[32];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 32), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA256, (char *)digest, 32, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" SHA256 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#else\n\t\t\tcase PHAR_SIG_SHA512:\n\t\t\tcase PHAR_SIG_SHA256:\n\t\t\t\tefree(savebuf);\n\t\t\t\tphp_stream_close(fp);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a unsupported signature\", fname);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n#endif\n\t\t\tcase PHAR_SIG_SHA1: {\n\t\t\t\tunsigned char digest[20];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 20), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA1, (char *)digest, 20, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" SHA1 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PHAR_SIG_MD5: {\n\t\t\t\tunsigned char digest[16];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 16), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_MD5, (char *)digest, 16, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" MD5 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tefree(savebuf);\n\t\t\t\tphp_stream_close(fp);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken or unsupported signature\", fname);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t}\n\t} else if (PHAR_G(require_hash)) {\n\t\tefree(savebuf);\n\t\tphp_stream_close(fp);\n\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" does not have a signature\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t} else {\n\t\tsig_flags = 0;\n\t\tsig_len = 0;\n\t}\n\n\t/* extract alias */\n\tPHAR_GET_32(buffer, tmp_len);\n\n\tif (buffer + tmp_len > endbuffer) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (buffer overrun)\");\n\t}\n\n\tif (manifest_len < 10 + tmp_len) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest header)\")\n\t}\n\n\t/* tmp_len = 0 says alias length is 0, which means the alias is not stored in the phar */\n\tif (tmp_len) {\n\t\t/* if the alias is stored we enforce it (implicit overrides explicit) */\n\t\tif (alias && alias_len && (alias_len != (int)tmp_len || strncmp(alias, buffer, tmp_len)))\n\t\t{\n\t\t\tbuffer[tmp_len] = '\\0';\n\t\t\tphp_stream_close(fp);\n\n\t\t\tif (signature) {\n\t\t\t\tefree(signature);\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"cannot load phar \\\"%s\\\" with implicit alias \\\"%s\\\" under different alias \\\"%s\\\"\", fname, buffer, alias);\n\t\t\t}\n\n\t\t\tefree(savebuf);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\talias_len = tmp_len;\n\t\talias = buffer;\n\t\tbuffer += tmp_len;\n\t\tregister_alias = 1;\n\t} else if (!alias_len || !alias) {\n\t\t/* if we neither have an explicit nor an implicit alias, we use the filename */\n\t\talias = NULL;\n\t\talias_len = 0;\n\t\tregister_alias = 0;\n\t} else if (alias_len) {\n\t\tregister_alias = 1;\n\t\ttemp_alias = 1;\n\t}\n\n\t/* we have 5 32-bit items plus 1 byte at least */\n\tif (manifest_count > ((manifest_len - 10 - tmp_len) / (5 * 4 + 1))) {\n\t\t/* prevent serious memory issues */\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (too many manifest entries for size of manifest)\")\n\t}\n\n\tmydata = pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));\n\tmydata->is_persistent = PHAR_G(persist);\n\n\t/* check whether we have meta data, zero check works regardless of byte order */\n\tPHAR_GET_32(buffer, len);\n\tif (mydata->is_persistent) {\n\t\tmydata->metadata_len = len;\n\t\tif(!len) {\n\t\t\t/* FIXME: not sure why this is needed but removing it breaks tests */\n\t\t\tPHAR_GET_32(buffer, len);\n\t\t}\n\t}\n\tif(len > endbuffer - buffer) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (trying to read past buffer end)\");\n\t}\n\tif (phar_parse_metadata(&buffer, &mydata->metadata, len TSRMLS_CC) == FAILURE) {\n\t\tMAPPHAR_FAIL(\"unable to read phar metadata in .phar file \\\"%s\\\"\");\n\t}\n\tbuffer += len;\n\n\t/* set up our manifest */\n\tzend_hash_init(&mydata->manifest, manifest_count,\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)mydata->is_persistent);\n\tzend_hash_init(&mydata->mounted_dirs, 5,\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tzend_hash_init(&mydata->virtual_dirs, manifest_count * 2,\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tmydata->fname = pestrndup(fname, fname_len, mydata->is_persistent);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(mydata->fname, fname_len);\n#endif\n\tmydata->fname_len = fname_len;\n\toffset = halt_offset + manifest_len + 4;\n\tmemset(&entry, 0, sizeof(phar_entry_info));\n\tentry.phar = mydata;\n\tentry.fp_type = PHAR_FP;\n\tentry.is_persistent = mydata->is_persistent;\n\n\tfor (manifest_index = 0; manifest_index < manifest_count; ++manifest_index) {\n\t\tif (buffer + 24 > endbuffer) {\n\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest entry)\")\n\t\t}\n\n\t\tPHAR_GET_32(buffer, entry.filename_len);\n\n\t\tif (entry.filename_len == 0) {\n\t\t\tMAPPHAR_FAIL(\"zero-length filename encountered in phar \\\"%s\\\"\");\n\t\t}\n\n\t\tif (entry.is_persistent) {\n\t\t\tentry.manifest_pos = manifest_index;\n\t\t}\n\n\t\tif (entry.filename_len > endbuffer - buffer - 20) {\n\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest entry)\");\n\t\t}\n\n\t\tif ((manifest_ver & PHAR_API_VER_MASK) >= PHAR_API_MIN_DIR && buffer[entry.filename_len - 1] == '/') {\n\t\t\tentry.is_dir = 1;\n\t\t} else {\n\t\t\tentry.is_dir = 0;\n\t\t}\n\n\t\tphar_add_virtual_dirs(mydata, buffer, entry.filename_len TSRMLS_CC);\n\t\tentry.filename = pestrndup(buffer, entry.filename_len, entry.is_persistent);\n\t\tbuffer += entry.filename_len;\n\t\tPHAR_GET_32(buffer, entry.uncompressed_filesize);\n\t\tPHAR_GET_32(buffer, entry.timestamp);\n\n\t\tif (offset == halt_offset + (int)manifest_len + 4) {\n\t\t\tmydata->min_timestamp = entry.timestamp;\n\t\t\tmydata->max_timestamp = entry.timestamp;\n\t\t} else {\n\t\t\tif (mydata->min_timestamp > entry.timestamp) {\n\t\t\t\tmydata->min_timestamp = entry.timestamp;\n\t\t\t} else if (mydata->max_timestamp < entry.timestamp) {\n\t\t\t\tmydata->max_timestamp = entry.timestamp;\n\t\t\t}\n\t\t}\n\n\t\tPHAR_GET_32(buffer, entry.compressed_filesize);\n\t\tPHAR_GET_32(buffer, entry.crc32);\n\t\tPHAR_GET_32(buffer, entry.flags);\n\n\t\tif (entry.is_dir) {\n\t\t\tentry.filename_len--;\n\t\t\tentry.flags |= PHAR_ENT_PERM_DEF_DIR;\n\t\t}\n\n\t\tPHAR_GET_32(buffer, len);\n\t\tif (entry.is_persistent) {\n\t\t\tentry.metadata_len = len;\n\t\t} else {\n\t\t\tentry.metadata_len = 0;\n\t\t}\n\t\tif (len > endbuffer - buffer) {\n\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest entry)\");\n\t\t}\n\t\tif (phar_parse_metadata(&buffer, &entry.metadata, len TSRMLS_CC) == FAILURE) {\n\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\tMAPPHAR_FAIL(\"unable to read file metadata in .phar file \\\"%s\\\"\");\n\t\t}\n\t\tbuffer += len;\n\n\t\tentry.offset = entry.offset_abs = offset;\n\t\toffset += entry.compressed_filesize;\n\n\t\tswitch (entry.flags & PHAR_ENT_COMPRESSION_MASK) {\n\t\t\tcase PHAR_ENT_COMPRESSED_GZ:\n\t\t\t\tif (!PHAR_G(has_zlib)) {\n\t\t\t\t\tif (entry.metadata) {\n\t\t\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\t\t\tfree(entry.metadata);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzval_ptr_dtor(&entry.metadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tMAPPHAR_FAIL(\"zlib extension is required for gz compressed .phar file \\\"%s\\\"\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PHAR_ENT_COMPRESSED_BZ2:\n\t\t\t\tif (!PHAR_G(has_bz2)) {\n\t\t\t\t\tif (entry.metadata) {\n\t\t\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\t\t\tfree(entry.metadata);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzval_ptr_dtor(&entry.metadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tMAPPHAR_FAIL(\"bz2 extension is required for bzip2 compressed .phar file \\\"%s\\\"\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (entry.uncompressed_filesize != entry.compressed_filesize) {\n\t\t\t\t\tif (entry.metadata) {\n\t\t\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\t\t\tfree(entry.metadata);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzval_ptr_dtor(&entry.metadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (compressed and uncompressed size does not match for uncompressed entry)\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tmanifest_flags |= (entry.flags & PHAR_ENT_COMPRESSION_MASK);\n\t\t/* if signature matched, no need to check CRC32 for each file */\n\t\tentry.is_crc_checked = (manifest_flags & PHAR_HDR_SIGNATURE ? 1 : 0);\n\t\tphar_set_inode(&entry TSRMLS_CC);\n\t\tzend_hash_add(&mydata->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info), NULL);\n\t}\n\n\tsnprintf(mydata->version, sizeof(mydata->version), \"%u.%u.%u\", manifest_ver >> 12, (manifest_ver >> 8) & 0xF, (manifest_ver >> 4) & 0xF);\n\tmydata->internal_file_start = halt_offset + manifest_len + 4;\n\tmydata->halt_offset = halt_offset;\n\tmydata->flags = manifest_flags;\n\tendbuffer = strrchr(mydata->fname, '/');\n\n\tif (endbuffer) {\n\t\tmydata->ext = memchr(endbuffer, '.', (mydata->fname + fname_len) - endbuffer);\n\t\tif (mydata->ext == endbuffer) {\n\t\t\tmydata->ext = memchr(endbuffer + 1, '.', (mydata->fname + fname_len) - endbuffer - 1);\n\t\t}\n\t\tif (mydata->ext) {\n\t\t\tmydata->ext_len = (mydata->fname + mydata->fname_len) - mydata->ext;\n\t\t}\n\t}\n\n\tmydata->alias = alias ?\n\t\tpestrndup(alias, alias_len, mydata->is_persistent) :\n\t\tpestrndup(mydata->fname, fname_len, mydata->is_persistent);\n\tmydata->alias_len = alias ? alias_len : fname_len;\n\tmydata->sig_flags = sig_flags;\n\tmydata->fp = fp;\n\tmydata->sig_len = sig_len;\n\tmydata->signature = signature;\n\tphar_request_initialize(TSRMLS_C);\n\n\tif (register_alias) {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tmydata->is_temporary_alias = temp_alias;\n\n\t\tif (!phar_validate_alias(mydata->alias, mydata->alias_len)) {\n\t\t\tsignature = NULL;\n\t\t\tfp = NULL;\n\t\t\tMAPPHAR_FAIL(\"Cannot open archive \\\"%s\\\", invalid alias\");\n\t\t}\n\n\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\tsignature = NULL;\n\t\t\t\tfp = NULL;\n\t\t\t\tMAPPHAR_FAIL(\"Cannot open archive \\\"%s\\\", alias is already in use by existing archive\");\n\t\t\t}\n\t\t}\n\n\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&mydata, sizeof(phar_archive_data*), NULL);\n\t} else {\n\t\tmydata->is_temporary_alias = 1;\n\t}\n\n\tzend_hash_add(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len, (void*)&mydata, sizeof(phar_archive_data*),  NULL);\n\tefree(savebuf);\n\n\tif (pphar) {\n\t\t*pphar = mydata;\n\t}\n\n\treturn SUCCESS;\n}",
        "func": "static int phar_parse_pharfile(php_stream *fp, char *fname, int fname_len, char *alias, int alias_len, long halt_offset, phar_archive_data** pphar, php_uint32 compression, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar b32[4], *buffer, *endbuffer, *savebuf;\n\tphar_archive_data *mydata = NULL;\n\tphar_entry_info entry;\n\tphp_uint32 manifest_len, manifest_count, manifest_flags, manifest_index, tmp_len, sig_flags;\n\tphp_uint16 manifest_ver;\n\tphp_uint32 len;\n\tlong offset;\n\tint sig_len, register_alias = 0, temp_alias = 0;\n\tchar *signature = NULL;\n\n\tif (pphar) {\n\t\t*pphar = NULL;\n\t}\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\t/* check for ?>\\n and increment accordingly */\n\tif (-1 == php_stream_seek(fp, halt_offset, SEEK_SET)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"cannot seek to __HALT_COMPILER(); location in phar \\\"%s\\\"\")\n\t}\n\n\tbuffer = b32;\n\n\tif (3 != php_stream_read(fp, buffer, 3)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at stub end)\")\n\t}\n\n\tif ((*buffer == ' ' || *buffer == '\\n') && *(buffer + 1) == '?' && *(buffer + 2) == '>') {\n\t\tint nextchar;\n\t\thalt_offset += 3;\n\t\tif (EOF == (nextchar = php_stream_getc(fp))) {\n\t\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at stub end)\")\n\t\t}\n\n\t\tif ((char) nextchar == '\\r') {\n\t\t\t/* if we have an \\r we require an \\n as well */\n\t\t\tif (EOF == (nextchar = php_stream_getc(fp)) || (char)nextchar != '\\n') {\n\t\t\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at stub end)\")\n\t\t\t}\n\t\t\t++halt_offset;\n\t\t}\n\n\t\tif ((char) nextchar == '\\n') {\n\t\t\t++halt_offset;\n\t\t}\n\t}\n\n\t/* make sure we are at the right location to read the manifest */\n\tif (-1 == php_stream_seek(fp, halt_offset, SEEK_SET)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"cannot seek to __HALT_COMPILER(); location in phar \\\"%s\\\"\")\n\t}\n\n\t/* read in manifest */\n\tbuffer = b32;\n\n\tif (4 != php_stream_read(fp, buffer, 4)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at manifest length)\")\n\t}\n\n\tPHAR_GET_32(buffer, manifest_len);\n\n\tif (manifest_len > 1048576 * 100) {\n\t\t/* prevent serious memory issues by limiting manifest to at most 100 MB in length */\n\t\tMAPPHAR_ALLOC_FAIL(\"manifest cannot be larger than 100 MB in phar \\\"%s\\\"\")\n\t}\n\n\tbuffer = (char *)emalloc(manifest_len);\n\tsavebuf = buffer;\n\tendbuffer = buffer + manifest_len;\n\n\tif (manifest_len < 10 || manifest_len != php_stream_read(fp, buffer, manifest_len)) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest header)\")\n\t}\n\n\t/* extract the number of entries */\n\tPHAR_GET_32(buffer, manifest_count);\n\n\tif (manifest_count == 0) {\n\t\tMAPPHAR_FAIL(\"in phar \\\"%s\\\", manifest claims to have zero entries.  Phars must have at least 1 entry\");\n\t}\n\n\t/* extract API version, lowest nibble currently unused */\n\tmanifest_ver = (((unsigned char)buffer[0]) << 8)\n\t\t\t\t + ((unsigned char)buffer[1]);\n\tbuffer += 2;\n\n\tif ((manifest_ver & PHAR_API_VER_MASK) < PHAR_API_MIN_READ) {\n\t\tefree(savebuf);\n\t\tphp_stream_close(fp);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" is API version %1.u.%1.u.%1.u, and cannot be processed\", fname, manifest_ver >> 12, (manifest_ver >> 8) & 0xF, (manifest_ver >> 4) & 0x0F);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tPHAR_GET_32(buffer, manifest_flags);\n\n\tmanifest_flags &= ~PHAR_HDR_COMPRESSION_MASK;\n\tmanifest_flags &= ~PHAR_FILE_COMPRESSION_MASK;\n\t/* remember whether this entire phar was compressed with gz/bzip2 */\n\tmanifest_flags |= compression;\n\n\t/* The lowest nibble contains the phar wide flags. The compression flags can */\n\t/* be ignored on reading because it is being generated anyways. */\n\tif (manifest_flags & PHAR_HDR_SIGNATURE) {\n\t\tchar sig_buf[8], *sig_ptr = sig_buf;\n\t\toff_t read_len;\n\t\tsize_t end_of_phar;\n\n\t\tif (-1 == php_stream_seek(fp, -8, SEEK_END)\n\t\t|| (read_len = php_stream_tell(fp)) < 20\n\t\t|| 8 != php_stream_read(fp, sig_buf, 8)\n\t\t|| memcmp(sig_buf+4, \"GBMB\", 4)) {\n\t\t\tefree(savebuf);\n\t\t\tphp_stream_close(fp);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tPHAR_GET_32(sig_ptr, sig_flags);\n\n\t\tswitch(sig_flags) {\n\t\t\tcase PHAR_SIG_OPENSSL: {\n\t\t\t\tphp_uint32 signature_len;\n\t\t\t\tchar *sig;\n\t\t\t\toff_t whence;\n\n\t\t\t\t/* we store the signature followed by the signature length */\n\t\t\t\tif (-1 == php_stream_seek(fp, -12, SEEK_CUR)\n\t\t\t\t|| 4 != php_stream_read(fp, sig_buf, 4)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" openssl signature length could not be read\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tsig_ptr = sig_buf;\n\t\t\t\tPHAR_GET_32(sig_ptr, signature_len);\n\t\t\t\tsig = (char *) emalloc(signature_len);\n\t\t\t\twhence = signature_len + 4;\n\t\t\t\twhence = -whence;\n\n\t\t\t\tif (-1 == php_stream_seek(fp, whence, SEEK_CUR)\n\t\t\t\t|| !(end_of_phar = php_stream_tell(fp))\n\t\t\t\t|| signature_len != php_stream_read(fp, sig, signature_len)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tefree(sig);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" openssl signature could not be read\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, end_of_phar, PHAR_SIG_OPENSSL, sig, signature_len, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tefree(sig);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" openssl signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tefree(sig);\n\t\t\t}\n\t\t\tbreak;\n#if PHAR_HASH_OK\n\t\t\tcase PHAR_SIG_SHA512: {\n\t\t\t\tunsigned char digest[64];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 64), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA512, (char *)digest, 64, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" SHA512 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PHAR_SIG_SHA256: {\n\t\t\t\tunsigned char digest[32];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 32), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA256, (char *)digest, 32, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" SHA256 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#else\n\t\t\tcase PHAR_SIG_SHA512:\n\t\t\tcase PHAR_SIG_SHA256:\n\t\t\t\tefree(savebuf);\n\t\t\t\tphp_stream_close(fp);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a unsupported signature\", fname);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n#endif\n\t\t\tcase PHAR_SIG_SHA1: {\n\t\t\t\tunsigned char digest[20];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 20), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA1, (char *)digest, 20, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" SHA1 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PHAR_SIG_MD5: {\n\t\t\t\tunsigned char digest[16];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 16), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_MD5, (char *)digest, 16, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" MD5 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tefree(savebuf);\n\t\t\t\tphp_stream_close(fp);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken or unsupported signature\", fname);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t}\n\t} else if (PHAR_G(require_hash)) {\n\t\tefree(savebuf);\n\t\tphp_stream_close(fp);\n\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" does not have a signature\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t} else {\n\t\tsig_flags = 0;\n\t\tsig_len = 0;\n\t}\n\n\t/* extract alias */\n\tPHAR_GET_32(buffer, tmp_len);\n\n\tif (buffer + tmp_len > endbuffer) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (buffer overrun)\");\n\t}\n\n\tif (manifest_len < 10 + tmp_len) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest header)\")\n\t}\n\n\t/* tmp_len = 0 says alias length is 0, which means the alias is not stored in the phar */\n\tif (tmp_len) {\n\t\t/* if the alias is stored we enforce it (implicit overrides explicit) */\n\t\tif (alias && alias_len && (alias_len != (int)tmp_len || strncmp(alias, buffer, tmp_len)))\n\t\t{\n\t\t\tphp_stream_close(fp);\n\n\t\t\tif (signature) {\n\t\t\t\tefree(signature);\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"cannot load phar \\\"%s\\\" with implicit alias \\\"%.*s\\\" under different alias \\\"%s\\\"\", fname, tmp_len, buffer, alias);\n\t\t\t}\n\n\t\t\tefree(savebuf);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\talias_len = tmp_len;\n\t\talias = buffer;\n\t\tbuffer += tmp_len;\n\t\tregister_alias = 1;\n\t} else if (!alias_len || !alias) {\n\t\t/* if we neither have an explicit nor an implicit alias, we use the filename */\n\t\talias = NULL;\n\t\talias_len = 0;\n\t\tregister_alias = 0;\n\t} else if (alias_len) {\n\t\tregister_alias = 1;\n\t\ttemp_alias = 1;\n\t}\n\n\t/* we have 5 32-bit items plus 1 byte at least */\n\tif (manifest_count > ((manifest_len - 10 - tmp_len) / (5 * 4 + 1))) {\n\t\t/* prevent serious memory issues */\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (too many manifest entries for size of manifest)\")\n\t}\n\n\tmydata = pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));\n\tmydata->is_persistent = PHAR_G(persist);\n\n\t/* check whether we have meta data, zero check works regardless of byte order */\n\tPHAR_GET_32(buffer, len);\n\tif (mydata->is_persistent) {\n\t\tmydata->metadata_len = len;\n\t\tif(!len) {\n\t\t\t/* FIXME: not sure why this is needed but removing it breaks tests */\n\t\t\tPHAR_GET_32(buffer, len);\n\t\t}\n\t}\n\tif(len > endbuffer - buffer) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (trying to read past buffer end)\");\n\t}\n\tif (phar_parse_metadata(&buffer, &mydata->metadata, len TSRMLS_CC) == FAILURE) {\n\t\tMAPPHAR_FAIL(\"unable to read phar metadata in .phar file \\\"%s\\\"\");\n\t}\n\tbuffer += len;\n\n\t/* set up our manifest */\n\tzend_hash_init(&mydata->manifest, manifest_count,\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)mydata->is_persistent);\n\tzend_hash_init(&mydata->mounted_dirs, 5,\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tzend_hash_init(&mydata->virtual_dirs, manifest_count * 2,\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tmydata->fname = pestrndup(fname, fname_len, mydata->is_persistent);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(mydata->fname, fname_len);\n#endif\n\tmydata->fname_len = fname_len;\n\toffset = halt_offset + manifest_len + 4;\n\tmemset(&entry, 0, sizeof(phar_entry_info));\n\tentry.phar = mydata;\n\tentry.fp_type = PHAR_FP;\n\tentry.is_persistent = mydata->is_persistent;\n\n\tfor (manifest_index = 0; manifest_index < manifest_count; ++manifest_index) {\n\t\tif (buffer + 24 > endbuffer) {\n\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest entry)\")\n\t\t}\n\n\t\tPHAR_GET_32(buffer, entry.filename_len);\n\n\t\tif (entry.filename_len == 0) {\n\t\t\tMAPPHAR_FAIL(\"zero-length filename encountered in phar \\\"%s\\\"\");\n\t\t}\n\n\t\tif (entry.is_persistent) {\n\t\t\tentry.manifest_pos = manifest_index;\n\t\t}\n\n\t\tif (entry.filename_len > endbuffer - buffer - 20) {\n\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest entry)\");\n\t\t}\n\n\t\tif ((manifest_ver & PHAR_API_VER_MASK) >= PHAR_API_MIN_DIR && buffer[entry.filename_len - 1] == '/') {\n\t\t\tentry.is_dir = 1;\n\t\t} else {\n\t\t\tentry.is_dir = 0;\n\t\t}\n\n\t\tphar_add_virtual_dirs(mydata, buffer, entry.filename_len TSRMLS_CC);\n\t\tentry.filename = pestrndup(buffer, entry.filename_len, entry.is_persistent);\n\t\tbuffer += entry.filename_len;\n\t\tPHAR_GET_32(buffer, entry.uncompressed_filesize);\n\t\tPHAR_GET_32(buffer, entry.timestamp);\n\n\t\tif (offset == halt_offset + (int)manifest_len + 4) {\n\t\t\tmydata->min_timestamp = entry.timestamp;\n\t\t\tmydata->max_timestamp = entry.timestamp;\n\t\t} else {\n\t\t\tif (mydata->min_timestamp > entry.timestamp) {\n\t\t\t\tmydata->min_timestamp = entry.timestamp;\n\t\t\t} else if (mydata->max_timestamp < entry.timestamp) {\n\t\t\t\tmydata->max_timestamp = entry.timestamp;\n\t\t\t}\n\t\t}\n\n\t\tPHAR_GET_32(buffer, entry.compressed_filesize);\n\t\tPHAR_GET_32(buffer, entry.crc32);\n\t\tPHAR_GET_32(buffer, entry.flags);\n\n\t\tif (entry.is_dir) {\n\t\t\tentry.filename_len--;\n\t\t\tentry.flags |= PHAR_ENT_PERM_DEF_DIR;\n\t\t}\n\n\t\tPHAR_GET_32(buffer, len);\n\t\tif (entry.is_persistent) {\n\t\t\tentry.metadata_len = len;\n\t\t} else {\n\t\t\tentry.metadata_len = 0;\n\t\t}\n\t\tif (len > endbuffer - buffer) {\n\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest entry)\");\n\t\t}\n\t\tif (phar_parse_metadata(&buffer, &entry.metadata, len TSRMLS_CC) == FAILURE) {\n\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\tMAPPHAR_FAIL(\"unable to read file metadata in .phar file \\\"%s\\\"\");\n\t\t}\n\t\tbuffer += len;\n\n\t\tentry.offset = entry.offset_abs = offset;\n\t\toffset += entry.compressed_filesize;\n\n\t\tswitch (entry.flags & PHAR_ENT_COMPRESSION_MASK) {\n\t\t\tcase PHAR_ENT_COMPRESSED_GZ:\n\t\t\t\tif (!PHAR_G(has_zlib)) {\n\t\t\t\t\tif (entry.metadata) {\n\t\t\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\t\t\tfree(entry.metadata);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzval_ptr_dtor(&entry.metadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tMAPPHAR_FAIL(\"zlib extension is required for gz compressed .phar file \\\"%s\\\"\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PHAR_ENT_COMPRESSED_BZ2:\n\t\t\t\tif (!PHAR_G(has_bz2)) {\n\t\t\t\t\tif (entry.metadata) {\n\t\t\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\t\t\tfree(entry.metadata);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzval_ptr_dtor(&entry.metadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tMAPPHAR_FAIL(\"bz2 extension is required for bzip2 compressed .phar file \\\"%s\\\"\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (entry.uncompressed_filesize != entry.compressed_filesize) {\n\t\t\t\t\tif (entry.metadata) {\n\t\t\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\t\t\tfree(entry.metadata);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzval_ptr_dtor(&entry.metadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (compressed and uncompressed size does not match for uncompressed entry)\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tmanifest_flags |= (entry.flags & PHAR_ENT_COMPRESSION_MASK);\n\t\t/* if signature matched, no need to check CRC32 for each file */\n\t\tentry.is_crc_checked = (manifest_flags & PHAR_HDR_SIGNATURE ? 1 : 0);\n\t\tphar_set_inode(&entry TSRMLS_CC);\n\t\tzend_hash_add(&mydata->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info), NULL);\n\t}\n\n\tsnprintf(mydata->version, sizeof(mydata->version), \"%u.%u.%u\", manifest_ver >> 12, (manifest_ver >> 8) & 0xF, (manifest_ver >> 4) & 0xF);\n\tmydata->internal_file_start = halt_offset + manifest_len + 4;\n\tmydata->halt_offset = halt_offset;\n\tmydata->flags = manifest_flags;\n\tendbuffer = strrchr(mydata->fname, '/');\n\n\tif (endbuffer) {\n\t\tmydata->ext = memchr(endbuffer, '.', (mydata->fname + fname_len) - endbuffer);\n\t\tif (mydata->ext == endbuffer) {\n\t\t\tmydata->ext = memchr(endbuffer + 1, '.', (mydata->fname + fname_len) - endbuffer - 1);\n\t\t}\n\t\tif (mydata->ext) {\n\t\t\tmydata->ext_len = (mydata->fname + mydata->fname_len) - mydata->ext;\n\t\t}\n\t}\n\n\tmydata->alias = alias ?\n\t\tpestrndup(alias, alias_len, mydata->is_persistent) :\n\t\tpestrndup(mydata->fname, fname_len, mydata->is_persistent);\n\tmydata->alias_len = alias ? alias_len : fname_len;\n\tmydata->sig_flags = sig_flags;\n\tmydata->fp = fp;\n\tmydata->sig_len = sig_len;\n\tmydata->signature = signature;\n\tphar_request_initialize(TSRMLS_C);\n\n\tif (register_alias) {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tmydata->is_temporary_alias = temp_alias;\n\n\t\tif (!phar_validate_alias(mydata->alias, mydata->alias_len)) {\n\t\t\tsignature = NULL;\n\t\t\tfp = NULL;\n\t\t\tMAPPHAR_FAIL(\"Cannot open archive \\\"%s\\\", invalid alias\");\n\t\t}\n\n\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\tsignature = NULL;\n\t\t\t\tfp = NULL;\n\t\t\t\tMAPPHAR_FAIL(\"Cannot open archive \\\"%s\\\", alias is already in use by existing archive\");\n\t\t\t}\n\t\t}\n\n\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&mydata, sizeof(phar_archive_data*), NULL);\n\t} else {\n\t\tmydata->is_temporary_alias = 1;\n\t}\n\n\tzend_hash_add(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len, (void*)&mydata, sizeof(phar_archive_data*),  NULL);\n\tefree(savebuf);\n\n\tif (pphar) {\n\t\t*pphar = mydata;\n\t}\n\n\treturn SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -332,7 +332,6 @@\n \t\t/* if the alias is stored we enforce it (implicit overrides explicit) */\n \t\tif (alias && alias_len && (alias_len != (int)tmp_len || strncmp(alias, buffer, tmp_len)))\n \t\t{\n-\t\t\tbuffer[tmp_len] = '\\0';\n \t\t\tphp_stream_close(fp);\n \n \t\t\tif (signature) {\n@@ -340,7 +339,7 @@\n \t\t\t}\n \n \t\t\tif (error) {\n-\t\t\t\tspprintf(error, 0, \"cannot load phar \\\"%s\\\" with implicit alias \\\"%s\\\" under different alias \\\"%s\\\"\", fname, buffer, alias);\n+\t\t\t\tspprintf(error, 0, \"cannot load phar \\\"%s\\\" with implicit alias \\\"%.*s\\\" under different alias \\\"%s\\\"\", fname, tmp_len, buffer, alias);\n \t\t\t}\n \n \t\t\tefree(savebuf);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tbuffer[tmp_len] = '\\0';",
                "\t\t\t\tspprintf(error, 0, \"cannot load phar \\\"%s\\\" with implicit alias \\\"%s\\\" under different alias \\\"%s\\\"\", fname, buffer, alias);"
            ],
            "added_lines": [
                "\t\t\t\tspprintf(error, 0, \"cannot load phar \\\"%s\\\" with implicit alias \\\"%.*s\\\" under different alias \\\"%s\\\"\", fname, tmp_len, buffer, alias);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-38429",
        "func_name": "torvalds/linux/ksmbd_conn_handler_loop",
        "description": "An issue was discovered in the Linux kernel before 6.3.4. fs/ksmbd/connection.c in ksmbd has an off-by-one error in memory allocation (because of ksmbd_smb2_check_message) that may lead to out-of-bounds access.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/fs/ksmbd?h=443d61d1fa9faa60ef925513d83742902390100f",
        "commit_title": "ksmbd_smb2_check_message allows client to return one byte more, so we",
        "commit_text": "need to allocate additional memory in ksmbd_conn_handler_loop to avoid out-of-bound access.  Cc: stable@vger.kernel.org ",
        "func_before": "int ksmbd_conn_handler_loop(void *p)\n{\n\tstruct ksmbd_conn *conn = (struct ksmbd_conn *)p;\n\tstruct ksmbd_transport *t = conn->transport;\n\tunsigned int pdu_size, max_allowed_pdu_size;\n\tchar hdr_buf[4] = {0,};\n\tint size;\n\n\tmutex_init(&conn->srv_mutex);\n\t__module_get(THIS_MODULE);\n\n\tif (t->ops->prepare && t->ops->prepare(t))\n\t\tgoto out;\n\n\tconn->last_active = jiffies;\n\twhile (ksmbd_conn_alive(conn)) {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\n\t\tkvfree(conn->request_buf);\n\t\tconn->request_buf = NULL;\n\n\t\tsize = t->ops->read(t, hdr_buf, sizeof(hdr_buf), -1);\n\t\tif (size != sizeof(hdr_buf))\n\t\t\tbreak;\n\n\t\tpdu_size = get_rfc1002_len(hdr_buf);\n\t\tksmbd_debug(CONN, \"RFC1002 header %u bytes\\n\", pdu_size);\n\n\t\tif (ksmbd_conn_good(conn))\n\t\t\tmax_allowed_pdu_size =\n\t\t\t\tSMB3_MAX_MSGSIZE + conn->vals->max_write_size;\n\t\telse\n\t\t\tmax_allowed_pdu_size = SMB3_MAX_MSGSIZE;\n\n\t\tif (pdu_size > max_allowed_pdu_size) {\n\t\t\tpr_err_ratelimited(\"PDU length(%u) exceeded maximum allowed pdu size(%u) on connection(%d)\\n\",\n\t\t\t\t\tpdu_size, max_allowed_pdu_size,\n\t\t\t\t\tREAD_ONCE(conn->status));\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Check maximum pdu size(0x00FFFFFF).\n\t\t */\n\t\tif (pdu_size > MAX_STREAM_PROT_LEN)\n\t\t\tbreak;\n\n\t\t/* 4 for rfc1002 length field */\n\t\tsize = pdu_size + 4;\n\t\tconn->request_buf = kvmalloc(size, GFP_KERNEL);\n\t\tif (!conn->request_buf)\n\t\t\tbreak;\n\n\t\tmemcpy(conn->request_buf, hdr_buf, sizeof(hdr_buf));\n\t\tif (!ksmbd_smb_request(conn))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * We already read 4 bytes to find out PDU size, now\n\t\t * read in PDU\n\t\t */\n\t\tsize = t->ops->read(t, conn->request_buf + 4, pdu_size, 2);\n\t\tif (size < 0) {\n\t\t\tpr_err(\"sock_read failed: %d\\n\", size);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (size != pdu_size) {\n\t\t\tpr_err(\"PDU error. Read: %d, Expected: %d\\n\",\n\t\t\t       size, pdu_size);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!default_conn_ops.process_fn) {\n\t\t\tpr_err(\"No connection request callback\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (default_conn_ops.process_fn(conn)) {\n\t\t\tpr_err(\"Cannot handle request\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tksmbd_conn_set_releasing(conn);\n\t/* Wait till all reference dropped to the Server object*/\n\twait_event(conn->r_count_q, atomic_read(&conn->r_count) == 0);\n\n\tif (IS_ENABLED(CONFIG_UNICODE))\n\t\tutf8_unload(conn->um);\n\tunload_nls(conn->local_nls);\n\tif (default_conn_ops.terminate_fn)\n\t\tdefault_conn_ops.terminate_fn(conn);\n\tt->ops->disconnect(t);\n\tmodule_put(THIS_MODULE);\n\treturn 0;\n}",
        "func": "int ksmbd_conn_handler_loop(void *p)\n{\n\tstruct ksmbd_conn *conn = (struct ksmbd_conn *)p;\n\tstruct ksmbd_transport *t = conn->transport;\n\tunsigned int pdu_size, max_allowed_pdu_size;\n\tchar hdr_buf[4] = {0,};\n\tint size;\n\n\tmutex_init(&conn->srv_mutex);\n\t__module_get(THIS_MODULE);\n\n\tif (t->ops->prepare && t->ops->prepare(t))\n\t\tgoto out;\n\n\tconn->last_active = jiffies;\n\twhile (ksmbd_conn_alive(conn)) {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\n\t\tkvfree(conn->request_buf);\n\t\tconn->request_buf = NULL;\n\n\t\tsize = t->ops->read(t, hdr_buf, sizeof(hdr_buf), -1);\n\t\tif (size != sizeof(hdr_buf))\n\t\t\tbreak;\n\n\t\tpdu_size = get_rfc1002_len(hdr_buf);\n\t\tksmbd_debug(CONN, \"RFC1002 header %u bytes\\n\", pdu_size);\n\n\t\tif (ksmbd_conn_good(conn))\n\t\t\tmax_allowed_pdu_size =\n\t\t\t\tSMB3_MAX_MSGSIZE + conn->vals->max_write_size;\n\t\telse\n\t\t\tmax_allowed_pdu_size = SMB3_MAX_MSGSIZE;\n\n\t\tif (pdu_size > max_allowed_pdu_size) {\n\t\t\tpr_err_ratelimited(\"PDU length(%u) exceeded maximum allowed pdu size(%u) on connection(%d)\\n\",\n\t\t\t\t\tpdu_size, max_allowed_pdu_size,\n\t\t\t\t\tREAD_ONCE(conn->status));\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Check maximum pdu size(0x00FFFFFF).\n\t\t */\n\t\tif (pdu_size > MAX_STREAM_PROT_LEN)\n\t\t\tbreak;\n\n\t\t/* 4 for rfc1002 length field */\n\t\t/* 1 for implied bcc[0] */\n\t\tsize = pdu_size + 4 + 1;\n\t\tconn->request_buf = kvmalloc(size, GFP_KERNEL);\n\t\tif (!conn->request_buf)\n\t\t\tbreak;\n\n\t\tmemcpy(conn->request_buf, hdr_buf, sizeof(hdr_buf));\n\t\tif (!ksmbd_smb_request(conn))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * We already read 4 bytes to find out PDU size, now\n\t\t * read in PDU\n\t\t */\n\t\tsize = t->ops->read(t, conn->request_buf + 4, pdu_size, 2);\n\t\tif (size < 0) {\n\t\t\tpr_err(\"sock_read failed: %d\\n\", size);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (size != pdu_size) {\n\t\t\tpr_err(\"PDU error. Read: %d, Expected: %d\\n\",\n\t\t\t       size, pdu_size);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!default_conn_ops.process_fn) {\n\t\t\tpr_err(\"No connection request callback\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (default_conn_ops.process_fn(conn)) {\n\t\t\tpr_err(\"Cannot handle request\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tksmbd_conn_set_releasing(conn);\n\t/* Wait till all reference dropped to the Server object*/\n\twait_event(conn->r_count_q, atomic_read(&conn->r_count) == 0);\n\n\tif (IS_ENABLED(CONFIG_UNICODE))\n\t\tutf8_unload(conn->um);\n\tunload_nls(conn->local_nls);\n\tif (default_conn_ops.terminate_fn)\n\t\tdefault_conn_ops.terminate_fn(conn);\n\tt->ops->disconnect(t);\n\tmodule_put(THIS_MODULE);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -47,7 +47,8 @@\n \t\t\tbreak;\n \n \t\t/* 4 for rfc1002 length field */\n-\t\tsize = pdu_size + 4;\n+\t\t/* 1 for implied bcc[0] */\n+\t\tsize = pdu_size + 4 + 1;\n \t\tconn->request_buf = kvmalloc(size, GFP_KERNEL);\n \t\tif (!conn->request_buf)\n \t\t\tbreak;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tsize = pdu_size + 4;"
            ],
            "added_lines": [
                "\t\t/* 1 for implied bcc[0] */",
                "\t\tsize = pdu_size + 4 + 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-9209",
        "func_name": "wireshark/dissect_ber_GeneralizedTime",
        "description": "In Wireshark 2.4.0 to 2.4.12 and 2.6.0 to 2.6.6, the ASN.1 BER and related dissectors could crash. This was addressed in epan/dissectors/packet-ber.c by preventing a buffer overflow associated with excessive digits in time values.",
        "git_url": "https://github.com/wireshark/wireshark/commit/f8fbe9f934d65b2694fa74622e5eb2e1dc8cd20b",
        "commit_title": "BER: don't use invalid time offsets.",
        "commit_text": " 4 digits values could overflow the destination buffer. Skip them since they're invalid and can only from tainted data.  Bug: 15447 (cherry picked from commit cb47fe6b05a70776fdd6df4a84be26f8361587ea)",
        "func_before": "int\ndissect_ber_GeneralizedTime(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id)\n{\n    char          str[35];\n    int           tmp_int;\n    const guint8 *tmpstr;\n    char         *strptr;\n    char          first_delim[2];\n    int           first_digits;\n    char          second_delim[2];\n    int           second_digits;\n    int           ret;\n    gint8         ber_class;\n    gboolean      pc;\n    gint32        tag;\n    int           identifier_offset;\n    int           identifier_len;\n    guint32       len;\n    int           len_offset;\n    int           len_len;\n    int           end_offset;\n    int           hoffset;\n    proto_item   *cause;\n\n    if (!implicit_tag) {\n        hoffset = offset;\n        identifier_offset = offset;\n        offset = dissect_ber_identifier(actx->pinfo, tree, tvb, offset, &ber_class, &pc, &tag);\n        identifier_len = offset - identifier_offset;\n        len_offset = offset;\n        offset = dissect_ber_length(actx->pinfo, tree, tvb, offset, &len, NULL);\n        len_len = offset - len_offset;\n        end_offset = offset+len;\n\n        /* sanity check. we only handle universal/generalized time */\n        if ( (ber_class != BER_CLASS_UNI)\n          || (tag != BER_UNI_TAG_GeneralizedTime)) {\n            tvb_ensure_bytes_exist(tvb, hoffset, 2);\n            cause = proto_tree_add_expert_format(\n                tree, actx->pinfo, &ei_ber_expected_generalized_time,\n                tvb, identifier_offset, identifier_len,\n                \"BER Error: GeneralizedTime expected but class:%s(%d) %s tag:%d was unexpected\",\n                val_to_str_const(ber_class, ber_class_codes, \"Unknown\"),\n                ber_class,\n                pc ? ber_pc_codes_short.true_string : ber_pc_codes_short.false_string,\n                tag);\n            if (decode_unexpected) {\n                proto_tree *unknown_tree = proto_item_add_subtree(cause, ett_ber_unknown);\n                dissect_unknown_ber(actx->pinfo, tvb, hoffset, unknown_tree);\n            }\n            return end_offset;\n        }\n    } else {\n        len = tvb_reported_length_remaining(tvb, offset);\n        len_offset = 0;\n        len_len = 0;\n        end_offset = offset+len;\n    }\n\n    if ((len < 14) || (len > 23)) {\n        cause = proto_tree_add_expert_format(\n            tree, actx->pinfo, &ei_ber_error_length,\n            tvb, len_offset, len_len,\n            \"BER Error: GeneralizedTime invalid length: %u\",\n            len);\n        if (decode_unexpected) {\n            proto_tree *unknown_tree = proto_item_add_subtree(cause, ett_ber_unknown);\n            dissect_unknown_ber(actx->pinfo, tvb, offset, unknown_tree);\n        }\n        return end_offset;\n    }\n\n    tmpstr = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, len, ENC_ASCII);\n    strptr = str;\n    /* those fields are allways present */\n    strptr += g_snprintf(str, 20, \"%.4s-%.2s-%.2s %.2s:%.2s:%.2s\",\n                         tmpstr, tmpstr+4, tmpstr+6, tmpstr+8,\n                         tmpstr+10, tmpstr+12);\n\n    first_delim[0]  = 0;\n    second_delim[0] = 0;\n    ret = sscanf( tmpstr, \"%14d%1[.,+-Z]%4d%1[+-Z]%4d\", &tmp_int, first_delim, &first_digits, second_delim, &second_digits);\n    /* tmp_int does not contain valid value because of overflow but we use it just for format checking */\n    if (ret < 1) {\n        /* Nothing matched */\n        goto invalid;\n    }\n\n    if (ret >= 2) {\n        /*\n         * We saw the date+time and the first delimiter.\n         *\n         * Either:\n         *\n         *    it's '.' or ',', in which case we have a fraction of a\n         *    minute or hour;\n         *\n         *    it's '+' or '-', in which case we have an offset from UTC;\n         *\n         *    it's 'Z', in which case the time is UTC.\n         */\n        switch (first_delim[0]) {\n        case '.':\n        case ',':\n            /*\n             * Fraction of a minute or an hour.\n             */\n            if (ret == 2) {\n                /*\n                 * We saw the decimal sign, but didn't see the fraction.\n                 */\n                goto invalid;\n            }\n            strptr += g_snprintf(strptr, 5, \"%c%.3d\", first_delim[0], first_digits);\n            if (ret >= 4) {\n                /*\n                 * We saw the fraction and the second delimiter.\n                 *\n                 * Either:\n                 *\n                 *    it's '+' or '-', in which case we have an offset\n                 *    from UTC;\n                 *\n                 *    it's 'Z', in which case the time is UTC.\n                 */\n                switch (second_delim[0]) {\n                case '+':\n                case '-':\n                    if (ret == 4) {\n                        /*\n                         * We saw the + or -, but didn't see the offset\n                         * from UTC.\n                         */\n                        goto invalid;\n                    }\n                    g_snprintf(strptr, 12, \" (UTC%c%.4d)\", second_delim[0], second_digits);\n                    break;\n                case 'Z':\n                    g_snprintf(strptr, 7, \" (UTC)\");\n                    break;\n                default:\n                    /* handle the malformed field */\n                    break;\n                }\n            }\n            break;\n        case '+':\n        case '-':\n            /*\n             * Offset from UTC.\n             */\n            if (ret == 2) {\n                /*\n                 * We saw the + or -1, but didn't see the offset.\n                 */\n                goto invalid;\n            }\n            g_snprintf(strptr, 12, \" (UTC%c%.4d)\", first_delim[0], first_digits);\n            break;\n        case 'Z':\n            g_snprintf(strptr, 7, \" (UTC)\");\n            break;\n        default:\n            /* handle the malformed field */\n            break;\n        }\n    }\n\n    if (hf_id >= 0) {\n        proto_tree_add_string(tree, hf_id, tvb, offset, len, str);\n    }\n\n    offset+=len;\n    return offset;\n\ninvalid:\n    cause = proto_tree_add_expert_format(\n        tree, actx->pinfo, &ei_ber_invalid_format_generalized_time,\n        tvb, offset, len,\n        \"BER Error: GeneralizedTime invalid format: %s\",\n        tmpstr);\n    if (decode_unexpected) {\n        proto_tree *unknown_tree = proto_item_add_subtree(cause, ett_ber_unknown);\n        dissect_unknown_ber(actx->pinfo, tvb, offset, unknown_tree);\n    }\n    return end_offset;\n}",
        "func": "int\ndissect_ber_GeneralizedTime(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id)\n{\n    char          str[35];\n    int           tmp_int;\n    const guint8 *tmpstr;\n    char         *strptr;\n    char          first_delim[2];\n    int           first_digits;\n    char          second_delim[2];\n    int           second_digits;\n    int           ret;\n    gint8         ber_class;\n    gboolean      pc;\n    gint32        tag;\n    int           identifier_offset;\n    int           identifier_len;\n    guint32       len;\n    int           len_offset;\n    int           len_len;\n    int           end_offset;\n    int           hoffset;\n    proto_item   *cause;\n\n    if (!implicit_tag) {\n        hoffset = offset;\n        identifier_offset = offset;\n        offset = dissect_ber_identifier(actx->pinfo, tree, tvb, offset, &ber_class, &pc, &tag);\n        identifier_len = offset - identifier_offset;\n        len_offset = offset;\n        offset = dissect_ber_length(actx->pinfo, tree, tvb, offset, &len, NULL);\n        len_len = offset - len_offset;\n        end_offset = offset+len;\n\n        /* sanity check. we only handle universal/generalized time */\n        if ( (ber_class != BER_CLASS_UNI)\n          || (tag != BER_UNI_TAG_GeneralizedTime)) {\n            tvb_ensure_bytes_exist(tvb, hoffset, 2);\n            cause = proto_tree_add_expert_format(\n                tree, actx->pinfo, &ei_ber_expected_generalized_time,\n                tvb, identifier_offset, identifier_len,\n                \"BER Error: GeneralizedTime expected but class:%s(%d) %s tag:%d was unexpected\",\n                val_to_str_const(ber_class, ber_class_codes, \"Unknown\"),\n                ber_class,\n                pc ? ber_pc_codes_short.true_string : ber_pc_codes_short.false_string,\n                tag);\n            if (decode_unexpected) {\n                proto_tree *unknown_tree = proto_item_add_subtree(cause, ett_ber_unknown);\n                dissect_unknown_ber(actx->pinfo, tvb, hoffset, unknown_tree);\n            }\n            return end_offset;\n        }\n    } else {\n        len = tvb_reported_length_remaining(tvb, offset);\n        len_offset = 0;\n        len_len = 0;\n        end_offset = offset+len;\n    }\n\n    if ((len < 14) || (len > 23)) {\n        cause = proto_tree_add_expert_format(\n            tree, actx->pinfo, &ei_ber_error_length,\n            tvb, len_offset, len_len,\n            \"BER Error: GeneralizedTime invalid length: %u\",\n            len);\n        if (decode_unexpected) {\n            proto_tree *unknown_tree = proto_item_add_subtree(cause, ett_ber_unknown);\n            dissect_unknown_ber(actx->pinfo, tvb, offset, unknown_tree);\n        }\n        return end_offset;\n    }\n\n    tmpstr = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, len, ENC_ASCII);\n    strptr = str;\n    /* those fields are allways present */\n    strptr += g_snprintf(str, 20, \"%.4s-%.2s-%.2s %.2s:%.2s:%.2s\",\n                         tmpstr, tmpstr+4, tmpstr+6, tmpstr+8,\n                         tmpstr+10, tmpstr+12);\n\n    first_delim[0]  = 0;\n    second_delim[0] = 0;\n    ret = sscanf(tmpstr, \"%14d%1[.,+-Z]%4d%1[+-Z]%4d\", &tmp_int, first_delim, &first_digits, second_delim, &second_digits);\n    /* tmp_int does not contain valid value because of overflow but we use it just for format checking */\n    if (ret < 1) {\n        /* Nothing matched */\n        goto invalid;\n    }\n\n    if (ret >= 2) {\n        /*\n         * We saw the date+time and the first delimiter.\n         *\n         * Either:\n         *\n         *    it's '.' or ',', in which case we have a fraction of a\n         *    minute or hour;\n         *\n         *    it's '+' or '-', in which case we have an offset from UTC;\n         *\n         *    it's 'Z', in which case the time is UTC.\n         */\n        switch (first_delim[0]) {\n        case '.':\n        case ',':\n            /*\n             * Fraction of a minute or an hour.\n             */\n            if (ret == 2 || first_digits < 0 || first_digits > 999) {\n                /*\n                 * We saw the decimal sign, but didn't see the fraction\n                 * or\n                 * we got a number outside the valid range.\n                 */\n                goto invalid;\n            }\n            strptr += g_snprintf(strptr, 5, \"%c%.3d\", first_delim[0], first_digits);\n            if (ret >= 4) {\n                /*\n                 * We saw the fraction and the second delimiter.\n                 *\n                 * Either:\n                 *\n                 *    it's '+' or '-', in which case we have an offset\n                 *    from UTC;\n                 *\n                 *    it's 'Z', in which case the time is UTC.\n                 */\n                switch (second_delim[0]) {\n                case '+':\n                case '-':\n                    if (ret == 4) {\n                        /*\n                         * We saw the + or -, but didn't see the offset\n                         * from UTC.\n                         */\n                        goto invalid;\n                    }\n                    g_snprintf(strptr, 12, \" (UTC%c%.4d)\", second_delim[0], second_digits);\n                    break;\n                case 'Z':\n                    g_snprintf(strptr, 7, \" (UTC)\");\n                    break;\n                default:\n                    /* handle the malformed field */\n                    break;\n                }\n            }\n            break;\n        case '+':\n        case '-':\n            /*\n             * Offset from UTC.\n             */\n            if (ret == 2) {\n                /*\n                 * We saw the + or -1, but didn't see the offset.\n                 */\n                goto invalid;\n            }\n            g_snprintf(strptr, 12, \" (UTC%c%.4d)\", first_delim[0], first_digits);\n            break;\n        case 'Z':\n            g_snprintf(strptr, 7, \" (UTC)\");\n            break;\n        default:\n            /* handle the malformed field */\n            break;\n        }\n    }\n\n    if (hf_id >= 0) {\n        proto_tree_add_string(tree, hf_id, tvb, offset, len, str);\n    }\n\n    offset+=len;\n    return offset;\n\ninvalid:\n    cause = proto_tree_add_expert_format(\n        tree, actx->pinfo, &ei_ber_invalid_format_generalized_time,\n        tvb, offset, len,\n        \"BER Error: GeneralizedTime invalid format: %s\",\n        tmpstr);\n    if (decode_unexpected) {\n        proto_tree *unknown_tree = proto_item_add_subtree(cause, ett_ber_unknown);\n        dissect_unknown_ber(actx->pinfo, tvb, offset, unknown_tree);\n    }\n    return end_offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -79,7 +79,7 @@\n \n     first_delim[0]  = 0;\n     second_delim[0] = 0;\n-    ret = sscanf( tmpstr, \"%14d%1[.,+-Z]%4d%1[+-Z]%4d\", &tmp_int, first_delim, &first_digits, second_delim, &second_digits);\n+    ret = sscanf(tmpstr, \"%14d%1[.,+-Z]%4d%1[+-Z]%4d\", &tmp_int, first_delim, &first_digits, second_delim, &second_digits);\n     /* tmp_int does not contain valid value because of overflow but we use it just for format checking */\n     if (ret < 1) {\n         /* Nothing matched */\n@@ -105,9 +105,11 @@\n             /*\n              * Fraction of a minute or an hour.\n              */\n-            if (ret == 2) {\n+            if (ret == 2 || first_digits < 0 || first_digits > 999) {\n                 /*\n-                 * We saw the decimal sign, but didn't see the fraction.\n+                 * We saw the decimal sign, but didn't see the fraction\n+                 * or\n+                 * we got a number outside the valid range.\n                  */\n                 goto invalid;\n             }",
        "diff_line_info": {
            "deleted_lines": [
                "    ret = sscanf( tmpstr, \"%14d%1[.,+-Z]%4d%1[+-Z]%4d\", &tmp_int, first_delim, &first_digits, second_delim, &second_digits);",
                "            if (ret == 2) {",
                "                 * We saw the decimal sign, but didn't see the fraction."
            ],
            "added_lines": [
                "    ret = sscanf(tmpstr, \"%14d%1[.,+-Z]%4d%1[+-Z]%4d\", &tmp_int, first_delim, &first_digits, second_delim, &second_digits);",
                "            if (ret == 2 || first_digits < 0 || first_digits > 999) {",
                "                 * We saw the decimal sign, but didn't see the fraction",
                "                 * or",
                "                 * we got a number outside the valid range."
            ]
        }
    },
    {
        "cve_id": "CVE-2011-2695",
        "func_name": "torvalds/linux/ext4_ext_next_leaf_block",
        "description": "Multiple off-by-one errors in the ext4 subsystem in the Linux kernel before 3.0-rc5 allow local users to cause a denial of service (BUG_ON and system crash) by accessing a sparse file in extent format with a write operation involving a block number corresponding to the largest possible 32-bit unsigned integer.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=f17722f917b2f21497deb6edc62fb1683daa08e6",
        "commit_title": "Kazuya Mio reported that he was able to hit BUG_ON(next == lblock)",
        "commit_text": "in ext4_ext_put_gap_in_cache() while creating a sparse file in extent format and fill the tail of file up to its end. We will hit the BUG_ON when we write the last block (2^32-1) into the sparse file.  The root cause of the problem lies in the fact that we specifically set s_maxbytes so that block at s_maxbytes fit into on-disk extent format, which is 32 bit long. However, we are not storing start and end block number, but rather start block number and length in blocks. It means that in order to cover extent from 0 to EXT_MAX_BLOCK we need EXT_MAX_BLOCK+1 to fit into len (because we counting block 0 as well) - and it does not.  The only way to fix it without changing the meaning of the struct ext4_extent members is, as Kazuya Mio suggested, to lower s_maxbytes by one fs block so we can cover the whole extent we can get by the on-disk extent format.  Also in many places EXT_MAX_BLOCK is used as length instead of maximum logical block number as the name suggests, it is all a bit messy. So this commit renames it to EXT_MAX_BLOCKS and change its usage in some places to actually be maximum number of blocks in the extent.  The bug which this commit fixes can be reproduced as follows:   dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-2))  sync  dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-1))  ",
        "func_before": "static ext4_lblk_t ext4_ext_next_leaf_block(struct inode *inode,\n\t\t\t\t\tstruct ext4_ext_path *path)\n{\n\tint depth;\n\n\tBUG_ON(path == NULL);\n\tdepth = path->p_depth;\n\n\t/* zero-tree has no leaf blocks at all */\n\tif (depth == 0)\n\t\treturn EXT_MAX_BLOCK;\n\n\t/* go to index block */\n\tdepth--;\n\n\twhile (depth >= 0) {\n\t\tif (path[depth].p_idx !=\n\t\t\t\tEXT_LAST_INDEX(path[depth].p_hdr))\n\t\t\treturn (ext4_lblk_t)\n\t\t\t\tle32_to_cpu(path[depth].p_idx[1].ei_block);\n\t\tdepth--;\n\t}\n\n\treturn EXT_MAX_BLOCK;\n}",
        "func": "static ext4_lblk_t ext4_ext_next_leaf_block(struct inode *inode,\n\t\t\t\t\tstruct ext4_ext_path *path)\n{\n\tint depth;\n\n\tBUG_ON(path == NULL);\n\tdepth = path->p_depth;\n\n\t/* zero-tree has no leaf blocks at all */\n\tif (depth == 0)\n\t\treturn EXT_MAX_BLOCKS;\n\n\t/* go to index block */\n\tdepth--;\n\n\twhile (depth >= 0) {\n\t\tif (path[depth].p_idx !=\n\t\t\t\tEXT_LAST_INDEX(path[depth].p_hdr))\n\t\t\treturn (ext4_lblk_t)\n\t\t\t\tle32_to_cpu(path[depth].p_idx[1].ei_block);\n\t\tdepth--;\n\t}\n\n\treturn EXT_MAX_BLOCKS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n \n \t/* zero-tree has no leaf blocks at all */\n \tif (depth == 0)\n-\t\treturn EXT_MAX_BLOCK;\n+\t\treturn EXT_MAX_BLOCKS;\n \n \t/* go to index block */\n \tdepth--;\n@@ -21,5 +21,5 @@\n \t\tdepth--;\n \t}\n \n-\treturn EXT_MAX_BLOCK;\n+\treturn EXT_MAX_BLOCKS;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treturn EXT_MAX_BLOCK;",
                "\treturn EXT_MAX_BLOCK;"
            ],
            "added_lines": [
                "\t\treturn EXT_MAX_BLOCKS;",
                "\treturn EXT_MAX_BLOCKS;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-2695",
        "func_name": "torvalds/linux/ext4_ext_put_gap_in_cache",
        "description": "Multiple off-by-one errors in the ext4 subsystem in the Linux kernel before 3.0-rc5 allow local users to cause a denial of service (BUG_ON and system crash) by accessing a sparse file in extent format with a write operation involving a block number corresponding to the largest possible 32-bit unsigned integer.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=f17722f917b2f21497deb6edc62fb1683daa08e6",
        "commit_title": "Kazuya Mio reported that he was able to hit BUG_ON(next == lblock)",
        "commit_text": "in ext4_ext_put_gap_in_cache() while creating a sparse file in extent format and fill the tail of file up to its end. We will hit the BUG_ON when we write the last block (2^32-1) into the sparse file.  The root cause of the problem lies in the fact that we specifically set s_maxbytes so that block at s_maxbytes fit into on-disk extent format, which is 32 bit long. However, we are not storing start and end block number, but rather start block number and length in blocks. It means that in order to cover extent from 0 to EXT_MAX_BLOCK we need EXT_MAX_BLOCK+1 to fit into len (because we counting block 0 as well) - and it does not.  The only way to fix it without changing the meaning of the struct ext4_extent members is, as Kazuya Mio suggested, to lower s_maxbytes by one fs block so we can cover the whole extent we can get by the on-disk extent format.  Also in many places EXT_MAX_BLOCK is used as length instead of maximum logical block number as the name suggests, it is all a bit messy. So this commit renames it to EXT_MAX_BLOCKS and change its usage in some places to actually be maximum number of blocks in the extent.  The bug which this commit fixes can be reproduced as follows:   dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-2))  sync  dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-1))  ",
        "func_before": "static void\next4_ext_put_gap_in_cache(struct inode *inode, struct ext4_ext_path *path,\n\t\t\t\text4_lblk_t block)\n{\n\tint depth = ext_depth(inode);\n\tunsigned long len;\n\text4_lblk_t lblock;\n\tstruct ext4_extent *ex;\n\n\tex = path[depth].p_ext;\n\tif (ex == NULL) {\n\t\t/* there is no extent yet, so gap is [0;-] */\n\t\tlblock = 0;\n\t\tlen = EXT_MAX_BLOCK;\n\t\text_debug(\"cache gap(whole file):\");\n\t} else if (block < le32_to_cpu(ex->ee_block)) {\n\t\tlblock = block;\n\t\tlen = le32_to_cpu(ex->ee_block) - block;\n\t\text_debug(\"cache gap(before): %u [%u:%u]\",\n\t\t\t\tblock,\n\t\t\t\tle32_to_cpu(ex->ee_block),\n\t\t\t\t ext4_ext_get_actual_len(ex));\n\t} else if (block >= le32_to_cpu(ex->ee_block)\n\t\t\t+ ext4_ext_get_actual_len(ex)) {\n\t\text4_lblk_t next;\n\t\tlblock = le32_to_cpu(ex->ee_block)\n\t\t\t+ ext4_ext_get_actual_len(ex);\n\n\t\tnext = ext4_ext_next_allocated_block(path);\n\t\text_debug(\"cache gap(after): [%u:%u] %u\",\n\t\t\t\tle32_to_cpu(ex->ee_block),\n\t\t\t\text4_ext_get_actual_len(ex),\n\t\t\t\tblock);\n\t\tBUG_ON(next == lblock);\n\t\tlen = next - lblock;\n\t} else {\n\t\tlblock = len = 0;\n\t\tBUG();\n\t}\n\n\text_debug(\" -> %u:%lu\\n\", lblock, len);\n\text4_ext_put_in_cache(inode, lblock, len, 0);\n}",
        "func": "static void\next4_ext_put_gap_in_cache(struct inode *inode, struct ext4_ext_path *path,\n\t\t\t\text4_lblk_t block)\n{\n\tint depth = ext_depth(inode);\n\tunsigned long len;\n\text4_lblk_t lblock;\n\tstruct ext4_extent *ex;\n\n\tex = path[depth].p_ext;\n\tif (ex == NULL) {\n\t\t/* there is no extent yet, so gap is [0;-] */\n\t\tlblock = 0;\n\t\tlen = EXT_MAX_BLOCKS;\n\t\text_debug(\"cache gap(whole file):\");\n\t} else if (block < le32_to_cpu(ex->ee_block)) {\n\t\tlblock = block;\n\t\tlen = le32_to_cpu(ex->ee_block) - block;\n\t\text_debug(\"cache gap(before): %u [%u:%u]\",\n\t\t\t\tblock,\n\t\t\t\tle32_to_cpu(ex->ee_block),\n\t\t\t\t ext4_ext_get_actual_len(ex));\n\t} else if (block >= le32_to_cpu(ex->ee_block)\n\t\t\t+ ext4_ext_get_actual_len(ex)) {\n\t\text4_lblk_t next;\n\t\tlblock = le32_to_cpu(ex->ee_block)\n\t\t\t+ ext4_ext_get_actual_len(ex);\n\n\t\tnext = ext4_ext_next_allocated_block(path);\n\t\text_debug(\"cache gap(after): [%u:%u] %u\",\n\t\t\t\tle32_to_cpu(ex->ee_block),\n\t\t\t\text4_ext_get_actual_len(ex),\n\t\t\t\tblock);\n\t\tBUG_ON(next == lblock);\n\t\tlen = next - lblock;\n\t} else {\n\t\tlblock = len = 0;\n\t\tBUG();\n\t}\n\n\text_debug(\" -> %u:%lu\\n\", lblock, len);\n\text4_ext_put_in_cache(inode, lblock, len, 0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n \tif (ex == NULL) {\n \t\t/* there is no extent yet, so gap is [0;-] */\n \t\tlblock = 0;\n-\t\tlen = EXT_MAX_BLOCK;\n+\t\tlen = EXT_MAX_BLOCKS;\n \t\text_debug(\"cache gap(whole file):\");\n \t} else if (block < le32_to_cpu(ex->ee_block)) {\n \t\tlblock = block;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tlen = EXT_MAX_BLOCK;"
            ],
            "added_lines": [
                "\t\tlen = EXT_MAX_BLOCKS;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-2695",
        "func_name": "torvalds/linux/ext4_fiemap",
        "description": "Multiple off-by-one errors in the ext4 subsystem in the Linux kernel before 3.0-rc5 allow local users to cause a denial of service (BUG_ON and system crash) by accessing a sparse file in extent format with a write operation involving a block number corresponding to the largest possible 32-bit unsigned integer.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=f17722f917b2f21497deb6edc62fb1683daa08e6",
        "commit_title": "Kazuya Mio reported that he was able to hit BUG_ON(next == lblock)",
        "commit_text": "in ext4_ext_put_gap_in_cache() while creating a sparse file in extent format and fill the tail of file up to its end. We will hit the BUG_ON when we write the last block (2^32-1) into the sparse file.  The root cause of the problem lies in the fact that we specifically set s_maxbytes so that block at s_maxbytes fit into on-disk extent format, which is 32 bit long. However, we are not storing start and end block number, but rather start block number and length in blocks. It means that in order to cover extent from 0 to EXT_MAX_BLOCK we need EXT_MAX_BLOCK+1 to fit into len (because we counting block 0 as well) - and it does not.  The only way to fix it without changing the meaning of the struct ext4_extent members is, as Kazuya Mio suggested, to lower s_maxbytes by one fs block so we can cover the whole extent we can get by the on-disk extent format.  Also in many places EXT_MAX_BLOCK is used as length instead of maximum logical block number as the name suggests, it is all a bit messy. So this commit renames it to EXT_MAX_BLOCKS and change its usage in some places to actually be maximum number of blocks in the extent.  The bug which this commit fixes can be reproduced as follows:   dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-2))  sync  dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-1))  ",
        "func_before": "int ext4_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t__u64 start, __u64 len)\n{\n\text4_lblk_t start_blk;\n\tint error = 0;\n\n\t/* fallback to generic here if not in extents fmt */\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn generic_block_fiemap(inode, fieinfo, start, len,\n\t\t\text4_get_block);\n\n\tif (fiemap_check_flags(fieinfo, EXT4_FIEMAP_FLAGS))\n\t\treturn -EBADR;\n\n\tif (fieinfo->fi_flags & FIEMAP_FLAG_XATTR) {\n\t\terror = ext4_xattr_fiemap(inode, fieinfo);\n\t} else {\n\t\text4_lblk_t len_blks;\n\t\t__u64 last_blk;\n\n\t\tstart_blk = start >> inode->i_sb->s_blocksize_bits;\n\t\tlast_blk = (start + len - 1) >> inode->i_sb->s_blocksize_bits;\n\t\tif (last_blk >= EXT_MAX_BLOCK)\n\t\t\tlast_blk = EXT_MAX_BLOCK-1;\n\t\tlen_blks = ((ext4_lblk_t) last_blk) - start_blk + 1;\n\n\t\t/*\n\t\t * Walk the extent tree gathering extent information.\n\t\t * ext4_ext_fiemap_cb will push extents back to user.\n\t\t */\n\t\terror = ext4_ext_walk_space(inode, start_blk, len_blks,\n\t\t\t\t\t  ext4_ext_fiemap_cb, fieinfo);\n\t}\n\n\treturn error;\n}",
        "func": "int ext4_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t__u64 start, __u64 len)\n{\n\text4_lblk_t start_blk;\n\tint error = 0;\n\n\t/* fallback to generic here if not in extents fmt */\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn generic_block_fiemap(inode, fieinfo, start, len,\n\t\t\text4_get_block);\n\n\tif (fiemap_check_flags(fieinfo, EXT4_FIEMAP_FLAGS))\n\t\treturn -EBADR;\n\n\tif (fieinfo->fi_flags & FIEMAP_FLAG_XATTR) {\n\t\terror = ext4_xattr_fiemap(inode, fieinfo);\n\t} else {\n\t\text4_lblk_t len_blks;\n\t\t__u64 last_blk;\n\n\t\tstart_blk = start >> inode->i_sb->s_blocksize_bits;\n\t\tlast_blk = (start + len - 1) >> inode->i_sb->s_blocksize_bits;\n\t\tif (last_blk >= EXT_MAX_BLOCKS)\n\t\t\tlast_blk = EXT_MAX_BLOCKS-1;\n\t\tlen_blks = ((ext4_lblk_t) last_blk) - start_blk + 1;\n\n\t\t/*\n\t\t * Walk the extent tree gathering extent information.\n\t\t * ext4_ext_fiemap_cb will push extents back to user.\n\t\t */\n\t\terror = ext4_ext_walk_space(inode, start_blk, len_blks,\n\t\t\t\t\t  ext4_ext_fiemap_cb, fieinfo);\n\t}\n\n\treturn error;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,8 +20,8 @@\n \n \t\tstart_blk = start >> inode->i_sb->s_blocksize_bits;\n \t\tlast_blk = (start + len - 1) >> inode->i_sb->s_blocksize_bits;\n-\t\tif (last_blk >= EXT_MAX_BLOCK)\n-\t\t\tlast_blk = EXT_MAX_BLOCK-1;\n+\t\tif (last_blk >= EXT_MAX_BLOCKS)\n+\t\t\tlast_blk = EXT_MAX_BLOCKS-1;\n \t\tlen_blks = ((ext4_lblk_t) last_blk) - start_blk + 1;\n \n \t\t/*",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (last_blk >= EXT_MAX_BLOCK)",
                "\t\t\tlast_blk = EXT_MAX_BLOCK-1;"
            ],
            "added_lines": [
                "\t\tif (last_blk >= EXT_MAX_BLOCKS)",
                "\t\t\tlast_blk = EXT_MAX_BLOCKS-1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-2695",
        "func_name": "torvalds/linux/ext4_ext_walk_space",
        "description": "Multiple off-by-one errors in the ext4 subsystem in the Linux kernel before 3.0-rc5 allow local users to cause a denial of service (BUG_ON and system crash) by accessing a sparse file in extent format with a write operation involving a block number corresponding to the largest possible 32-bit unsigned integer.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=f17722f917b2f21497deb6edc62fb1683daa08e6",
        "commit_title": "Kazuya Mio reported that he was able to hit BUG_ON(next == lblock)",
        "commit_text": "in ext4_ext_put_gap_in_cache() while creating a sparse file in extent format and fill the tail of file up to its end. We will hit the BUG_ON when we write the last block (2^32-1) into the sparse file.  The root cause of the problem lies in the fact that we specifically set s_maxbytes so that block at s_maxbytes fit into on-disk extent format, which is 32 bit long. However, we are not storing start and end block number, but rather start block number and length in blocks. It means that in order to cover extent from 0 to EXT_MAX_BLOCK we need EXT_MAX_BLOCK+1 to fit into len (because we counting block 0 as well) - and it does not.  The only way to fix it without changing the meaning of the struct ext4_extent members is, as Kazuya Mio suggested, to lower s_maxbytes by one fs block so we can cover the whole extent we can get by the on-disk extent format.  Also in many places EXT_MAX_BLOCK is used as length instead of maximum logical block number as the name suggests, it is all a bit messy. So this commit renames it to EXT_MAX_BLOCKS and change its usage in some places to actually be maximum number of blocks in the extent.  The bug which this commit fixes can be reproduced as follows:   dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-2))  sync  dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-1))  ",
        "func_before": "static int ext4_ext_walk_space(struct inode *inode, ext4_lblk_t block,\n\t\t\t       ext4_lblk_t num, ext_prepare_callback func,\n\t\t\t       void *cbdata)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_ext_cache cbex;\n\tstruct ext4_extent *ex;\n\text4_lblk_t next, start = 0, end = 0;\n\text4_lblk_t last = block + num;\n\tint depth, exists, err = 0;\n\n\tBUG_ON(func == NULL);\n\tBUG_ON(inode == NULL);\n\n\twhile (block < last && block != EXT_MAX_BLOCK) {\n\t\tnum = last - block;\n\t\t/* find extent for this block */\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\t\tpath = ext4_ext_find_extent(inode, block, path);\n\t\tup_read(&EXT4_I(inode)->i_data_sem);\n\t\tif (IS_ERR(path)) {\n\t\t\terr = PTR_ERR(path);\n\t\t\tpath = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tdepth = ext_depth(inode);\n\t\tif (unlikely(path[depth].p_hdr == NULL)) {\n\t\t\tEXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tex = path[depth].p_ext;\n\t\tnext = ext4_ext_next_allocated_block(path);\n\n\t\texists = 0;\n\t\tif (!ex) {\n\t\t\t/* there is no extent yet, so try to allocate\n\t\t\t * all requested space */\n\t\t\tstart = block;\n\t\t\tend = block + num;\n\t\t} else if (le32_to_cpu(ex->ee_block) > block) {\n\t\t\t/* need to allocate space before found extent */\n\t\t\tstart = block;\n\t\t\tend = le32_to_cpu(ex->ee_block);\n\t\t\tif (block + num < end)\n\t\t\t\tend = block + num;\n\t\t} else if (block >= le32_to_cpu(ex->ee_block)\n\t\t\t\t\t+ ext4_ext_get_actual_len(ex)) {\n\t\t\t/* need to allocate space after found extent */\n\t\t\tstart = block;\n\t\t\tend = block + num;\n\t\t\tif (end >= next)\n\t\t\t\tend = next;\n\t\t} else if (block >= le32_to_cpu(ex->ee_block)) {\n\t\t\t/*\n\t\t\t * some part of requested space is covered\n\t\t\t * by found extent\n\t\t\t */\n\t\t\tstart = block;\n\t\t\tend = le32_to_cpu(ex->ee_block)\n\t\t\t\t+ ext4_ext_get_actual_len(ex);\n\t\t\tif (block + num < end)\n\t\t\t\tend = block + num;\n\t\t\texists = 1;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t\tBUG_ON(end <= start);\n\n\t\tif (!exists) {\n\t\t\tcbex.ec_block = start;\n\t\t\tcbex.ec_len = end - start;\n\t\t\tcbex.ec_start = 0;\n\t\t} else {\n\t\t\tcbex.ec_block = le32_to_cpu(ex->ee_block);\n\t\t\tcbex.ec_len = ext4_ext_get_actual_len(ex);\n\t\t\tcbex.ec_start = ext4_ext_pblock(ex);\n\t\t}\n\n\t\tif (unlikely(cbex.ec_len == 0)) {\n\t\t\tEXT4_ERROR_INODE(inode, \"cbex.ec_len == 0\");\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\terr = func(inode, path, &cbex, ex, cbdata);\n\t\text4_ext_drop_refs(path);\n\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tif (err == EXT_REPEAT)\n\t\t\tcontinue;\n\t\telse if (err == EXT_BREAK) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ext_depth(inode) != depth) {\n\t\t\t/* depth was changed. we have to realloc path */\n\t\t\tkfree(path);\n\t\t\tpath = NULL;\n\t\t}\n\n\t\tblock = cbex.ec_block + cbex.ec_len;\n\t}\n\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tkfree(path);\n\t}\n\n\treturn err;\n}",
        "func": "static int ext4_ext_walk_space(struct inode *inode, ext4_lblk_t block,\n\t\t\t       ext4_lblk_t num, ext_prepare_callback func,\n\t\t\t       void *cbdata)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_ext_cache cbex;\n\tstruct ext4_extent *ex;\n\text4_lblk_t next, start = 0, end = 0;\n\text4_lblk_t last = block + num;\n\tint depth, exists, err = 0;\n\n\tBUG_ON(func == NULL);\n\tBUG_ON(inode == NULL);\n\n\twhile (block < last && block != EXT_MAX_BLOCKS) {\n\t\tnum = last - block;\n\t\t/* find extent for this block */\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\t\tpath = ext4_ext_find_extent(inode, block, path);\n\t\tup_read(&EXT4_I(inode)->i_data_sem);\n\t\tif (IS_ERR(path)) {\n\t\t\terr = PTR_ERR(path);\n\t\t\tpath = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tdepth = ext_depth(inode);\n\t\tif (unlikely(path[depth].p_hdr == NULL)) {\n\t\t\tEXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tex = path[depth].p_ext;\n\t\tnext = ext4_ext_next_allocated_block(path);\n\n\t\texists = 0;\n\t\tif (!ex) {\n\t\t\t/* there is no extent yet, so try to allocate\n\t\t\t * all requested space */\n\t\t\tstart = block;\n\t\t\tend = block + num;\n\t\t} else if (le32_to_cpu(ex->ee_block) > block) {\n\t\t\t/* need to allocate space before found extent */\n\t\t\tstart = block;\n\t\t\tend = le32_to_cpu(ex->ee_block);\n\t\t\tif (block + num < end)\n\t\t\t\tend = block + num;\n\t\t} else if (block >= le32_to_cpu(ex->ee_block)\n\t\t\t\t\t+ ext4_ext_get_actual_len(ex)) {\n\t\t\t/* need to allocate space after found extent */\n\t\t\tstart = block;\n\t\t\tend = block + num;\n\t\t\tif (end >= next)\n\t\t\t\tend = next;\n\t\t} else if (block >= le32_to_cpu(ex->ee_block)) {\n\t\t\t/*\n\t\t\t * some part of requested space is covered\n\t\t\t * by found extent\n\t\t\t */\n\t\t\tstart = block;\n\t\t\tend = le32_to_cpu(ex->ee_block)\n\t\t\t\t+ ext4_ext_get_actual_len(ex);\n\t\t\tif (block + num < end)\n\t\t\t\tend = block + num;\n\t\t\texists = 1;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t\tBUG_ON(end <= start);\n\n\t\tif (!exists) {\n\t\t\tcbex.ec_block = start;\n\t\t\tcbex.ec_len = end - start;\n\t\t\tcbex.ec_start = 0;\n\t\t} else {\n\t\t\tcbex.ec_block = le32_to_cpu(ex->ee_block);\n\t\t\tcbex.ec_len = ext4_ext_get_actual_len(ex);\n\t\t\tcbex.ec_start = ext4_ext_pblock(ex);\n\t\t}\n\n\t\tif (unlikely(cbex.ec_len == 0)) {\n\t\t\tEXT4_ERROR_INODE(inode, \"cbex.ec_len == 0\");\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\terr = func(inode, path, &cbex, ex, cbdata);\n\t\text4_ext_drop_refs(path);\n\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tif (err == EXT_REPEAT)\n\t\t\tcontinue;\n\t\telse if (err == EXT_BREAK) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ext_depth(inode) != depth) {\n\t\t\t/* depth was changed. we have to realloc path */\n\t\t\tkfree(path);\n\t\t\tpath = NULL;\n\t\t}\n\n\t\tblock = cbex.ec_block + cbex.ec_len;\n\t}\n\n\tif (path) {\n\t\text4_ext_drop_refs(path);\n\t\tkfree(path);\n\t}\n\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n \tBUG_ON(func == NULL);\n \tBUG_ON(inode == NULL);\n \n-\twhile (block < last && block != EXT_MAX_BLOCK) {\n+\twhile (block < last && block != EXT_MAX_BLOCKS) {\n \t\tnum = last - block;\n \t\t/* find extent for this block */\n \t\tdown_read(&EXT4_I(inode)->i_data_sem);",
        "diff_line_info": {
            "deleted_lines": [
                "\twhile (block < last && block != EXT_MAX_BLOCK) {"
            ],
            "added_lines": [
                "\twhile (block < last && block != EXT_MAX_BLOCKS) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-2695",
        "func_name": "torvalds/linux/ext4_ext_insert_extent",
        "description": "Multiple off-by-one errors in the ext4 subsystem in the Linux kernel before 3.0-rc5 allow local users to cause a denial of service (BUG_ON and system crash) by accessing a sparse file in extent format with a write operation involving a block number corresponding to the largest possible 32-bit unsigned integer.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=f17722f917b2f21497deb6edc62fb1683daa08e6",
        "commit_title": "Kazuya Mio reported that he was able to hit BUG_ON(next == lblock)",
        "commit_text": "in ext4_ext_put_gap_in_cache() while creating a sparse file in extent format and fill the tail of file up to its end. We will hit the BUG_ON when we write the last block (2^32-1) into the sparse file.  The root cause of the problem lies in the fact that we specifically set s_maxbytes so that block at s_maxbytes fit into on-disk extent format, which is 32 bit long. However, we are not storing start and end block number, but rather start block number and length in blocks. It means that in order to cover extent from 0 to EXT_MAX_BLOCK we need EXT_MAX_BLOCK+1 to fit into len (because we counting block 0 as well) - and it does not.  The only way to fix it without changing the meaning of the struct ext4_extent members is, as Kazuya Mio suggested, to lower s_maxbytes by one fs block so we can cover the whole extent we can get by the on-disk extent format.  Also in many places EXT_MAX_BLOCK is used as length instead of maximum logical block number as the name suggests, it is all a bit messy. So this commit renames it to EXT_MAX_BLOCKS and change its usage in some places to actually be maximum number of blocks in the extent.  The bug which this commit fixes can be reproduced as follows:   dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-2))  sync  dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-1))  ",
        "func_before": "int ext4_ext_insert_extent(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_ext_path *path,\n\t\t\t\tstruct ext4_extent *newext, int flag)\n{\n\tstruct ext4_extent_header *eh;\n\tstruct ext4_extent *ex, *fex;\n\tstruct ext4_extent *nearex; /* nearest extent */\n\tstruct ext4_ext_path *npath = NULL;\n\tint depth, len, err;\n\text4_lblk_t next;\n\tunsigned uninitialized = 0;\n\tint flags = 0;\n\n\tif (unlikely(ext4_ext_get_actual_len(newext) == 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"ext4_ext_get_actual_len(newext) == 0\");\n\t\treturn -EIO;\n\t}\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tif (unlikely(path[depth].p_hdr == NULL)) {\n\t\tEXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);\n\t\treturn -EIO;\n\t}\n\n\t/* try to insert block into found extent and return */\n\tif (ex && !(flag & EXT4_GET_BLOCKS_PRE_IO)\n\t\t&& ext4_can_extents_be_merged(inode, ex, newext)) {\n\t\text_debug(\"append [%d]%d block to %d:[%d]%d (from %llu)\\n\",\n\t\t\t  ext4_ext_is_uninitialized(newext),\n\t\t\t  ext4_ext_get_actual_len(newext),\n\t\t\t  le32_to_cpu(ex->ee_block),\n\t\t\t  ext4_ext_is_uninitialized(ex),\n\t\t\t  ext4_ext_get_actual_len(ex),\n\t\t\t  ext4_ext_pblock(ex));\n\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t/*\n\t\t * ext4_can_extents_be_merged should have checked that either\n\t\t * both extents are uninitialized, or both aren't. Thus we\n\t\t * need to check only one of them here.\n\t\t */\n\t\tif (ext4_ext_is_uninitialized(ex))\n\t\t\tuninitialized = 1;\n\t\tex->ee_len = cpu_to_le16(ext4_ext_get_actual_len(ex)\n\t\t\t\t\t+ ext4_ext_get_actual_len(newext));\n\t\tif (uninitialized)\n\t\t\text4_ext_mark_uninitialized(ex);\n\t\teh = path[depth].p_hdr;\n\t\tnearex = ex;\n\t\tgoto merge;\n\t}\n\nrepeat:\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max))\n\t\tgoto has_space;\n\n\t/* probably next leaf has space for us? */\n\tfex = EXT_LAST_EXTENT(eh);\n\tnext = ext4_ext_next_leaf_block(inode, path);\n\tif (le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block)\n\t    && next != EXT_MAX_BLOCK) {\n\t\text_debug(\"next leaf block - %d\\n\", next);\n\t\tBUG_ON(npath != NULL);\n\t\tnpath = ext4_ext_find_extent(inode, next, NULL);\n\t\tif (IS_ERR(npath))\n\t\t\treturn PTR_ERR(npath);\n\t\tBUG_ON(npath->p_depth != path->p_depth);\n\t\teh = npath[depth].p_hdr;\n\t\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)) {\n\t\t\text_debug(\"next leaf isn't full(%d)\\n\",\n\t\t\t\t  le16_to_cpu(eh->eh_entries));\n\t\t\tpath = npath;\n\t\t\tgoto repeat;\n\t\t}\n\t\text_debug(\"next leaf has no free space(%d,%d)\\n\",\n\t\t\t  le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\n\t}\n\n\t/*\n\t * There is no free space in the found leaf.\n\t * We're gonna add a new leaf in the tree.\n\t */\n\tif (flag & EXT4_GET_BLOCKS_PUNCH_OUT_EXT)\n\t\tflags = EXT4_MB_USE_ROOT_BLOCKS;\n\terr = ext4_ext_create_new_leaf(handle, inode, flags, path, newext);\n\tif (err)\n\t\tgoto cleanup;\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\nhas_space:\n\tnearex = path[depth].p_ext;\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (!nearex) {\n\t\t/* there is no extent in this leaf, create first one */\n\t\text_debug(\"first extent in the leaf: %d:%llu:[%d]%d\\n\",\n\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\text4_ext_pblock(newext),\n\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\text4_ext_get_actual_len(newext));\n\t\tpath[depth].p_ext = EXT_FIRST_EXTENT(eh);\n\t} else if (le32_to_cpu(newext->ee_block)\n\t\t\t   > le32_to_cpu(nearex->ee_block)) {\n/*\t\tBUG_ON(newext->ee_block == nearex->ee_block); */\n\t\tif (nearex != EXT_LAST_EXTENT(eh)) {\n\t\t\tlen = EXT_MAX_EXTENT(eh) - nearex;\n\t\t\tlen = (len - 1) * sizeof(struct ext4_extent);\n\t\t\tlen = len < 0 ? 0 : len;\n\t\t\text_debug(\"insert %d:%llu:[%d]%d after: nearest 0x%p, \"\n\t\t\t\t\t\"move %d from 0x%p to 0x%p\\n\",\n\t\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\t\text4_ext_pblock(newext),\n\t\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\t\tnearex, len, nearex + 1, nearex + 2);\n\t\t\tmemmove(nearex + 2, nearex + 1, len);\n\t\t}\n\t\tpath[depth].p_ext = nearex + 1;\n\t} else {\n\t\tBUG_ON(newext->ee_block == nearex->ee_block);\n\t\tlen = (EXT_MAX_EXTENT(eh) - nearex) * sizeof(struct ext4_extent);\n\t\tlen = len < 0 ? 0 : len;\n\t\text_debug(\"insert %d:%llu:[%d]%d before: nearest 0x%p, \"\n\t\t\t\t\"move %d from 0x%p to 0x%p\\n\",\n\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\text4_ext_pblock(newext),\n\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\tnearex, len, nearex + 1, nearex + 2);\n\t\tmemmove(nearex + 1, nearex, len);\n\t\tpath[depth].p_ext = nearex;\n\t}\n\n\tle16_add_cpu(&eh->eh_entries, 1);\n\tnearex = path[depth].p_ext;\n\tnearex->ee_block = newext->ee_block;\n\text4_ext_store_pblock(nearex, ext4_ext_pblock(newext));\n\tnearex->ee_len = newext->ee_len;\n\nmerge:\n\t/* try to merge extents to the right */\n\tif (!(flag & EXT4_GET_BLOCKS_PRE_IO))\n\t\text4_ext_try_to_merge(inode, path, nearex);\n\n\t/* try to merge extents to the left */\n\n\t/* time to correct all indexes above */\n\terr = ext4_ext_correct_indexes(handle, inode, path);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = ext4_ext_dirty(handle, inode, path + depth);\n\ncleanup:\n\tif (npath) {\n\t\text4_ext_drop_refs(npath);\n\t\tkfree(npath);\n\t}\n\text4_ext_invalidate_cache(inode);\n\treturn err;\n}",
        "func": "int ext4_ext_insert_extent(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_ext_path *path,\n\t\t\t\tstruct ext4_extent *newext, int flag)\n{\n\tstruct ext4_extent_header *eh;\n\tstruct ext4_extent *ex, *fex;\n\tstruct ext4_extent *nearex; /* nearest extent */\n\tstruct ext4_ext_path *npath = NULL;\n\tint depth, len, err;\n\text4_lblk_t next;\n\tunsigned uninitialized = 0;\n\tint flags = 0;\n\n\tif (unlikely(ext4_ext_get_actual_len(newext) == 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"ext4_ext_get_actual_len(newext) == 0\");\n\t\treturn -EIO;\n\t}\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tif (unlikely(path[depth].p_hdr == NULL)) {\n\t\tEXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);\n\t\treturn -EIO;\n\t}\n\n\t/* try to insert block into found extent and return */\n\tif (ex && !(flag & EXT4_GET_BLOCKS_PRE_IO)\n\t\t&& ext4_can_extents_be_merged(inode, ex, newext)) {\n\t\text_debug(\"append [%d]%d block to %d:[%d]%d (from %llu)\\n\",\n\t\t\t  ext4_ext_is_uninitialized(newext),\n\t\t\t  ext4_ext_get_actual_len(newext),\n\t\t\t  le32_to_cpu(ex->ee_block),\n\t\t\t  ext4_ext_is_uninitialized(ex),\n\t\t\t  ext4_ext_get_actual_len(ex),\n\t\t\t  ext4_ext_pblock(ex));\n\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t/*\n\t\t * ext4_can_extents_be_merged should have checked that either\n\t\t * both extents are uninitialized, or both aren't. Thus we\n\t\t * need to check only one of them here.\n\t\t */\n\t\tif (ext4_ext_is_uninitialized(ex))\n\t\t\tuninitialized = 1;\n\t\tex->ee_len = cpu_to_le16(ext4_ext_get_actual_len(ex)\n\t\t\t\t\t+ ext4_ext_get_actual_len(newext));\n\t\tif (uninitialized)\n\t\t\text4_ext_mark_uninitialized(ex);\n\t\teh = path[depth].p_hdr;\n\t\tnearex = ex;\n\t\tgoto merge;\n\t}\n\nrepeat:\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max))\n\t\tgoto has_space;\n\n\t/* probably next leaf has space for us? */\n\tfex = EXT_LAST_EXTENT(eh);\n\tnext = ext4_ext_next_leaf_block(inode, path);\n\tif (le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block)\n\t    && next != EXT_MAX_BLOCKS) {\n\t\text_debug(\"next leaf block - %d\\n\", next);\n\t\tBUG_ON(npath != NULL);\n\t\tnpath = ext4_ext_find_extent(inode, next, NULL);\n\t\tif (IS_ERR(npath))\n\t\t\treturn PTR_ERR(npath);\n\t\tBUG_ON(npath->p_depth != path->p_depth);\n\t\teh = npath[depth].p_hdr;\n\t\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)) {\n\t\t\text_debug(\"next leaf isn't full(%d)\\n\",\n\t\t\t\t  le16_to_cpu(eh->eh_entries));\n\t\t\tpath = npath;\n\t\t\tgoto repeat;\n\t\t}\n\t\text_debug(\"next leaf has no free space(%d,%d)\\n\",\n\t\t\t  le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\n\t}\n\n\t/*\n\t * There is no free space in the found leaf.\n\t * We're gonna add a new leaf in the tree.\n\t */\n\tif (flag & EXT4_GET_BLOCKS_PUNCH_OUT_EXT)\n\t\tflags = EXT4_MB_USE_ROOT_BLOCKS;\n\terr = ext4_ext_create_new_leaf(handle, inode, flags, path, newext);\n\tif (err)\n\t\tgoto cleanup;\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\nhas_space:\n\tnearex = path[depth].p_ext;\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (!nearex) {\n\t\t/* there is no extent in this leaf, create first one */\n\t\text_debug(\"first extent in the leaf: %d:%llu:[%d]%d\\n\",\n\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\text4_ext_pblock(newext),\n\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\text4_ext_get_actual_len(newext));\n\t\tpath[depth].p_ext = EXT_FIRST_EXTENT(eh);\n\t} else if (le32_to_cpu(newext->ee_block)\n\t\t\t   > le32_to_cpu(nearex->ee_block)) {\n/*\t\tBUG_ON(newext->ee_block == nearex->ee_block); */\n\t\tif (nearex != EXT_LAST_EXTENT(eh)) {\n\t\t\tlen = EXT_MAX_EXTENT(eh) - nearex;\n\t\t\tlen = (len - 1) * sizeof(struct ext4_extent);\n\t\t\tlen = len < 0 ? 0 : len;\n\t\t\text_debug(\"insert %d:%llu:[%d]%d after: nearest 0x%p, \"\n\t\t\t\t\t\"move %d from 0x%p to 0x%p\\n\",\n\t\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\t\text4_ext_pblock(newext),\n\t\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\t\tnearex, len, nearex + 1, nearex + 2);\n\t\t\tmemmove(nearex + 2, nearex + 1, len);\n\t\t}\n\t\tpath[depth].p_ext = nearex + 1;\n\t} else {\n\t\tBUG_ON(newext->ee_block == nearex->ee_block);\n\t\tlen = (EXT_MAX_EXTENT(eh) - nearex) * sizeof(struct ext4_extent);\n\t\tlen = len < 0 ? 0 : len;\n\t\text_debug(\"insert %d:%llu:[%d]%d before: nearest 0x%p, \"\n\t\t\t\t\"move %d from 0x%p to 0x%p\\n\",\n\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\text4_ext_pblock(newext),\n\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\tnearex, len, nearex + 1, nearex + 2);\n\t\tmemmove(nearex + 1, nearex, len);\n\t\tpath[depth].p_ext = nearex;\n\t}\n\n\tle16_add_cpu(&eh->eh_entries, 1);\n\tnearex = path[depth].p_ext;\n\tnearex->ee_block = newext->ee_block;\n\text4_ext_store_pblock(nearex, ext4_ext_pblock(newext));\n\tnearex->ee_len = newext->ee_len;\n\nmerge:\n\t/* try to merge extents to the right */\n\tif (!(flag & EXT4_GET_BLOCKS_PRE_IO))\n\t\text4_ext_try_to_merge(inode, path, nearex);\n\n\t/* try to merge extents to the left */\n\n\t/* time to correct all indexes above */\n\terr = ext4_ext_correct_indexes(handle, inode, path);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = ext4_ext_dirty(handle, inode, path + depth);\n\ncleanup:\n\tif (npath) {\n\t\text4_ext_drop_refs(npath);\n\t\tkfree(npath);\n\t}\n\text4_ext_invalidate_cache(inode);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -62,7 +62,7 @@\n \tfex = EXT_LAST_EXTENT(eh);\n \tnext = ext4_ext_next_leaf_block(inode, path);\n \tif (le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block)\n-\t    && next != EXT_MAX_BLOCK) {\n+\t    && next != EXT_MAX_BLOCKS) {\n \t\text_debug(\"next leaf block - %d\\n\", next);\n \t\tBUG_ON(npath != NULL);\n \t\tnpath = ext4_ext_find_extent(inode, next, NULL);",
        "diff_line_info": {
            "deleted_lines": [
                "\t    && next != EXT_MAX_BLOCK) {"
            ],
            "added_lines": [
                "\t    && next != EXT_MAX_BLOCKS) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-2695",
        "func_name": "torvalds/linux/ext4_ext_truncate",
        "description": "Multiple off-by-one errors in the ext4 subsystem in the Linux kernel before 3.0-rc5 allow local users to cause a denial of service (BUG_ON and system crash) by accessing a sparse file in extent format with a write operation involving a block number corresponding to the largest possible 32-bit unsigned integer.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=f17722f917b2f21497deb6edc62fb1683daa08e6",
        "commit_title": "Kazuya Mio reported that he was able to hit BUG_ON(next == lblock)",
        "commit_text": "in ext4_ext_put_gap_in_cache() while creating a sparse file in extent format and fill the tail of file up to its end. We will hit the BUG_ON when we write the last block (2^32-1) into the sparse file.  The root cause of the problem lies in the fact that we specifically set s_maxbytes so that block at s_maxbytes fit into on-disk extent format, which is 32 bit long. However, we are not storing start and end block number, but rather start block number and length in blocks. It means that in order to cover extent from 0 to EXT_MAX_BLOCK we need EXT_MAX_BLOCK+1 to fit into len (because we counting block 0 as well) - and it does not.  The only way to fix it without changing the meaning of the struct ext4_extent members is, as Kazuya Mio suggested, to lower s_maxbytes by one fs block so we can cover the whole extent we can get by the on-disk extent format.  Also in many places EXT_MAX_BLOCK is used as length instead of maximum logical block number as the name suggests, it is all a bit messy. So this commit renames it to EXT_MAX_BLOCKS and change its usage in some places to actually be maximum number of blocks in the extent.  The bug which this commit fixes can be reproduced as follows:   dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-2))  sync  dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-1))  ",
        "func_before": "void ext4_ext_truncate(struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct super_block *sb = inode->i_sb;\n\text4_lblk_t last_block;\n\thandle_t *handle;\n\tint err = 0;\n\n\t/*\n\t * finish any pending end_io work so we won't run the risk of\n\t * converting any truncated blocks to initialized later\n\t */\n\text4_flush_completed_IO(inode);\n\n\t/*\n\t * probably first extent we're gonna free will be last in block\n\t */\n\terr = ext4_writepage_trans_blocks(inode);\n\thandle = ext4_journal_start(inode, err);\n\tif (IS_ERR(handle))\n\t\treturn;\n\n\tif (inode->i_size & (sb->s_blocksize - 1))\n\t\text4_block_truncate_page(handle, mapping, inode->i_size);\n\n\tif (ext4_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_ext_invalidate_cache(inode);\n\n\text4_discard_preallocations(inode);\n\n\t/*\n\t * TODO: optimization is possible here.\n\t * Probably we need not scan at all,\n\t * because page truncation is enough.\n\t */\n\n\t/* we have to know where to truncate from in crash case */\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\text4_mark_inode_dirty(handle, inode);\n\n\tlast_block = (inode->i_size + sb->s_blocksize - 1)\n\t\t\t>> EXT4_BLOCK_SIZE_BITS(sb);\n\terr = ext4_ext_remove_space(inode, last_block, EXT_MAX_BLOCK);\n\n\t/* In a multi-transaction truncate, we only make the final\n\t * transaction synchronous.\n\t */\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\nout_stop:\n\t/*\n\t * If this was a simple ftruncate() and the file will remain alive,\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext4_delete_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text4_orphan_del(handle, inode);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\text4_journal_stop(handle);\n}",
        "func": "void ext4_ext_truncate(struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct super_block *sb = inode->i_sb;\n\text4_lblk_t last_block;\n\thandle_t *handle;\n\tint err = 0;\n\n\t/*\n\t * finish any pending end_io work so we won't run the risk of\n\t * converting any truncated blocks to initialized later\n\t */\n\text4_flush_completed_IO(inode);\n\n\t/*\n\t * probably first extent we're gonna free will be last in block\n\t */\n\terr = ext4_writepage_trans_blocks(inode);\n\thandle = ext4_journal_start(inode, err);\n\tif (IS_ERR(handle))\n\t\treturn;\n\n\tif (inode->i_size & (sb->s_blocksize - 1))\n\t\text4_block_truncate_page(handle, mapping, inode->i_size);\n\n\tif (ext4_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_ext_invalidate_cache(inode);\n\n\text4_discard_preallocations(inode);\n\n\t/*\n\t * TODO: optimization is possible here.\n\t * Probably we need not scan at all,\n\t * because page truncation is enough.\n\t */\n\n\t/* we have to know where to truncate from in crash case */\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\text4_mark_inode_dirty(handle, inode);\n\n\tlast_block = (inode->i_size + sb->s_blocksize - 1)\n\t\t\t>> EXT4_BLOCK_SIZE_BITS(sb);\n\terr = ext4_ext_remove_space(inode, last_block, EXT_MAX_BLOCKS - 1);\n\n\t/* In a multi-transaction truncate, we only make the final\n\t * transaction synchronous.\n\t */\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\nout_stop:\n\t/*\n\t * If this was a simple ftruncate() and the file will remain alive,\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext4_delete_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text4_orphan_del(handle, inode);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\text4_journal_stop(handle);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -43,7 +43,7 @@\n \n \tlast_block = (inode->i_size + sb->s_blocksize - 1)\n \t\t\t>> EXT4_BLOCK_SIZE_BITS(sb);\n-\terr = ext4_ext_remove_space(inode, last_block, EXT_MAX_BLOCK);\n+\terr = ext4_ext_remove_space(inode, last_block, EXT_MAX_BLOCKS - 1);\n \n \t/* In a multi-transaction truncate, we only make the final\n \t * transaction synchronous.",
        "diff_line_info": {
            "deleted_lines": [
                "\terr = ext4_ext_remove_space(inode, last_block, EXT_MAX_BLOCK);"
            ],
            "added_lines": [
                "\terr = ext4_ext_remove_space(inode, last_block, EXT_MAX_BLOCKS - 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-2695",
        "func_name": "torvalds/linux/ext4_ext_check_overlap",
        "description": "Multiple off-by-one errors in the ext4 subsystem in the Linux kernel before 3.0-rc5 allow local users to cause a denial of service (BUG_ON and system crash) by accessing a sparse file in extent format with a write operation involving a block number corresponding to the largest possible 32-bit unsigned integer.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=f17722f917b2f21497deb6edc62fb1683daa08e6",
        "commit_title": "Kazuya Mio reported that he was able to hit BUG_ON(next == lblock)",
        "commit_text": "in ext4_ext_put_gap_in_cache() while creating a sparse file in extent format and fill the tail of file up to its end. We will hit the BUG_ON when we write the last block (2^32-1) into the sparse file.  The root cause of the problem lies in the fact that we specifically set s_maxbytes so that block at s_maxbytes fit into on-disk extent format, which is 32 bit long. However, we are not storing start and end block number, but rather start block number and length in blocks. It means that in order to cover extent from 0 to EXT_MAX_BLOCK we need EXT_MAX_BLOCK+1 to fit into len (because we counting block 0 as well) - and it does not.  The only way to fix it without changing the meaning of the struct ext4_extent members is, as Kazuya Mio suggested, to lower s_maxbytes by one fs block so we can cover the whole extent we can get by the on-disk extent format.  Also in many places EXT_MAX_BLOCK is used as length instead of maximum logical block number as the name suggests, it is all a bit messy. So this commit renames it to EXT_MAX_BLOCKS and change its usage in some places to actually be maximum number of blocks in the extent.  The bug which this commit fixes can be reproduced as follows:   dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-2))  sync  dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-1))  ",
        "func_before": "static unsigned int ext4_ext_check_overlap(struct inode *inode,\n\t\t\t\t\t   struct ext4_extent *newext,\n\t\t\t\t\t   struct ext4_ext_path *path)\n{\n\text4_lblk_t b1, b2;\n\tunsigned int depth, len1;\n\tunsigned int ret = 0;\n\n\tb1 = le32_to_cpu(newext->ee_block);\n\tlen1 = ext4_ext_get_actual_len(newext);\n\tdepth = ext_depth(inode);\n\tif (!path[depth].p_ext)\n\t\tgoto out;\n\tb2 = le32_to_cpu(path[depth].p_ext->ee_block);\n\n\t/*\n\t * get the next allocated block if the extent in the path\n\t * is before the requested block(s)\n\t */\n\tif (b2 < b1) {\n\t\tb2 = ext4_ext_next_allocated_block(path);\n\t\tif (b2 == EXT_MAX_BLOCK)\n\t\t\tgoto out;\n\t}\n\n\t/* check for wrap through zero on extent logical start block*/\n\tif (b1 + len1 < b1) {\n\t\tlen1 = EXT_MAX_BLOCK - b1;\n\t\tnewext->ee_len = cpu_to_le16(len1);\n\t\tret = 1;\n\t}\n\n\t/* check for overlap */\n\tif (b1 + len1 > b2) {\n\t\tnewext->ee_len = cpu_to_le16(b2 - b1);\n\t\tret = 1;\n\t}\nout:\n\treturn ret;\n}",
        "func": "static unsigned int ext4_ext_check_overlap(struct inode *inode,\n\t\t\t\t\t   struct ext4_extent *newext,\n\t\t\t\t\t   struct ext4_ext_path *path)\n{\n\text4_lblk_t b1, b2;\n\tunsigned int depth, len1;\n\tunsigned int ret = 0;\n\n\tb1 = le32_to_cpu(newext->ee_block);\n\tlen1 = ext4_ext_get_actual_len(newext);\n\tdepth = ext_depth(inode);\n\tif (!path[depth].p_ext)\n\t\tgoto out;\n\tb2 = le32_to_cpu(path[depth].p_ext->ee_block);\n\n\t/*\n\t * get the next allocated block if the extent in the path\n\t * is before the requested block(s)\n\t */\n\tif (b2 < b1) {\n\t\tb2 = ext4_ext_next_allocated_block(path);\n\t\tif (b2 == EXT_MAX_BLOCKS)\n\t\t\tgoto out;\n\t}\n\n\t/* check for wrap through zero on extent logical start block*/\n\tif (b1 + len1 < b1) {\n\t\tlen1 = EXT_MAX_BLOCKS - b1;\n\t\tnewext->ee_len = cpu_to_le16(len1);\n\t\tret = 1;\n\t}\n\n\t/* check for overlap */\n\tif (b1 + len1 > b2) {\n\t\tnewext->ee_len = cpu_to_le16(b2 - b1);\n\t\tret = 1;\n\t}\nout:\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,13 +19,13 @@\n \t */\n \tif (b2 < b1) {\n \t\tb2 = ext4_ext_next_allocated_block(path);\n-\t\tif (b2 == EXT_MAX_BLOCK)\n+\t\tif (b2 == EXT_MAX_BLOCKS)\n \t\t\tgoto out;\n \t}\n \n \t/* check for wrap through zero on extent logical start block*/\n \tif (b1 + len1 < b1) {\n-\t\tlen1 = EXT_MAX_BLOCK - b1;\n+\t\tlen1 = EXT_MAX_BLOCKS - b1;\n \t\tnewext->ee_len = cpu_to_le16(len1);\n \t\tret = 1;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (b2 == EXT_MAX_BLOCK)",
                "\t\tlen1 = EXT_MAX_BLOCK - b1;"
            ],
            "added_lines": [
                "\t\tif (b2 == EXT_MAX_BLOCKS)",
                "\t\tlen1 = EXT_MAX_BLOCKS - b1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-2695",
        "func_name": "torvalds/linux/ext4_ext_next_allocated_block",
        "description": "Multiple off-by-one errors in the ext4 subsystem in the Linux kernel before 3.0-rc5 allow local users to cause a denial of service (BUG_ON and system crash) by accessing a sparse file in extent format with a write operation involving a block number corresponding to the largest possible 32-bit unsigned integer.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=f17722f917b2f21497deb6edc62fb1683daa08e6",
        "commit_title": "Kazuya Mio reported that he was able to hit BUG_ON(next == lblock)",
        "commit_text": "in ext4_ext_put_gap_in_cache() while creating a sparse file in extent format and fill the tail of file up to its end. We will hit the BUG_ON when we write the last block (2^32-1) into the sparse file.  The root cause of the problem lies in the fact that we specifically set s_maxbytes so that block at s_maxbytes fit into on-disk extent format, which is 32 bit long. However, we are not storing start and end block number, but rather start block number and length in blocks. It means that in order to cover extent from 0 to EXT_MAX_BLOCK we need EXT_MAX_BLOCK+1 to fit into len (because we counting block 0 as well) - and it does not.  The only way to fix it without changing the meaning of the struct ext4_extent members is, as Kazuya Mio suggested, to lower s_maxbytes by one fs block so we can cover the whole extent we can get by the on-disk extent format.  Also in many places EXT_MAX_BLOCK is used as length instead of maximum logical block number as the name suggests, it is all a bit messy. So this commit renames it to EXT_MAX_BLOCKS and change its usage in some places to actually be maximum number of blocks in the extent.  The bug which this commit fixes can be reproduced as follows:   dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-2))  sync  dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-1))  ",
        "func_before": "static ext4_lblk_t\next4_ext_next_allocated_block(struct ext4_ext_path *path)\n{\n\tint depth;\n\n\tBUG_ON(path == NULL);\n\tdepth = path->p_depth;\n\n\tif (depth == 0 && path->p_ext == NULL)\n\t\treturn EXT_MAX_BLOCK;\n\n\twhile (depth >= 0) {\n\t\tif (depth == path->p_depth) {\n\t\t\t/* leaf */\n\t\t\tif (path[depth].p_ext !=\n\t\t\t\t\tEXT_LAST_EXTENT(path[depth].p_hdr))\n\t\t\t  return le32_to_cpu(path[depth].p_ext[1].ee_block);\n\t\t} else {\n\t\t\t/* index */\n\t\t\tif (path[depth].p_idx !=\n\t\t\t\t\tEXT_LAST_INDEX(path[depth].p_hdr))\n\t\t\t  return le32_to_cpu(path[depth].p_idx[1].ei_block);\n\t\t}\n\t\tdepth--;\n\t}\n\n\treturn EXT_MAX_BLOCK;\n}",
        "func": "static ext4_lblk_t\next4_ext_next_allocated_block(struct ext4_ext_path *path)\n{\n\tint depth;\n\n\tBUG_ON(path == NULL);\n\tdepth = path->p_depth;\n\n\tif (depth == 0 && path->p_ext == NULL)\n\t\treturn EXT_MAX_BLOCKS;\n\n\twhile (depth >= 0) {\n\t\tif (depth == path->p_depth) {\n\t\t\t/* leaf */\n\t\t\tif (path[depth].p_ext !=\n\t\t\t\t\tEXT_LAST_EXTENT(path[depth].p_hdr))\n\t\t\t  return le32_to_cpu(path[depth].p_ext[1].ee_block);\n\t\t} else {\n\t\t\t/* index */\n\t\t\tif (path[depth].p_idx !=\n\t\t\t\t\tEXT_LAST_INDEX(path[depth].p_hdr))\n\t\t\t  return le32_to_cpu(path[depth].p_idx[1].ei_block);\n\t\t}\n\t\tdepth--;\n\t}\n\n\treturn EXT_MAX_BLOCKS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n \tdepth = path->p_depth;\n \n \tif (depth == 0 && path->p_ext == NULL)\n-\t\treturn EXT_MAX_BLOCK;\n+\t\treturn EXT_MAX_BLOCKS;\n \n \twhile (depth >= 0) {\n \t\tif (depth == path->p_depth) {\n@@ -24,5 +24,5 @@\n \t\tdepth--;\n \t}\n \n-\treturn EXT_MAX_BLOCK;\n+\treturn EXT_MAX_BLOCKS;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treturn EXT_MAX_BLOCK;",
                "\treturn EXT_MAX_BLOCK;"
            ],
            "added_lines": [
                "\t\treturn EXT_MAX_BLOCKS;",
                "\treturn EXT_MAX_BLOCKS;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-2695",
        "func_name": "torvalds/linux/ext4_ext_rm_leaf",
        "description": "Multiple off-by-one errors in the ext4 subsystem in the Linux kernel before 3.0-rc5 allow local users to cause a denial of service (BUG_ON and system crash) by accessing a sparse file in extent format with a write operation involving a block number corresponding to the largest possible 32-bit unsigned integer.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=f17722f917b2f21497deb6edc62fb1683daa08e6",
        "commit_title": "Kazuya Mio reported that he was able to hit BUG_ON(next == lblock)",
        "commit_text": "in ext4_ext_put_gap_in_cache() while creating a sparse file in extent format and fill the tail of file up to its end. We will hit the BUG_ON when we write the last block (2^32-1) into the sparse file.  The root cause of the problem lies in the fact that we specifically set s_maxbytes so that block at s_maxbytes fit into on-disk extent format, which is 32 bit long. However, we are not storing start and end block number, but rather start block number and length in blocks. It means that in order to cover extent from 0 to EXT_MAX_BLOCK we need EXT_MAX_BLOCK+1 to fit into len (because we counting block 0 as well) - and it does not.  The only way to fix it without changing the meaning of the struct ext4_extent members is, as Kazuya Mio suggested, to lower s_maxbytes by one fs block so we can cover the whole extent we can get by the on-disk extent format.  Also in many places EXT_MAX_BLOCK is used as length instead of maximum logical block number as the name suggests, it is all a bit messy. So this commit renames it to EXT_MAX_BLOCKS and change its usage in some places to actually be maximum number of blocks in the extent.  The bug which this commit fixes can be reproduced as follows:   dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-2))  sync  dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-1))  ",
        "func_before": "static int\next4_ext_rm_leaf(handle_t *handle, struct inode *inode,\n\t\tstruct ext4_ext_path *path, ext4_lblk_t start,\n\t\text4_lblk_t end)\n{\n\tint err = 0, correct_index = 0;\n\tint depth = ext_depth(inode), credits;\n\tstruct ext4_extent_header *eh;\n\text4_lblk_t a, b, block;\n\tunsigned num;\n\text4_lblk_t ex_ee_block;\n\tunsigned short ex_ee_len;\n\tunsigned uninitialized = 0;\n\tstruct ext4_extent *ex;\n\tstruct ext4_map_blocks map;\n\n\t/* the header must be checked already in ext4_ext_remove_space() */\n\text_debug(\"truncate since %u in leaf\\n\", start);\n\tif (!path[depth].p_hdr)\n\t\tpath[depth].p_hdr = ext_block_hdr(path[depth].p_bh);\n\teh = path[depth].p_hdr;\n\tif (unlikely(path[depth].p_hdr == NULL)) {\n\t\tEXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);\n\t\treturn -EIO;\n\t}\n\t/* find where to start removing */\n\tex = EXT_LAST_EXTENT(eh);\n\n\tex_ee_block = le32_to_cpu(ex->ee_block);\n\tex_ee_len = ext4_ext_get_actual_len(ex);\n\n\twhile (ex >= EXT_FIRST_EXTENT(eh) &&\n\t\t\tex_ee_block + ex_ee_len > start) {\n\n\t\tif (ext4_ext_is_uninitialized(ex))\n\t\t\tuninitialized = 1;\n\t\telse\n\t\t\tuninitialized = 0;\n\n\t\text_debug(\"remove ext %u:[%d]%d\\n\", ex_ee_block,\n\t\t\t uninitialized, ex_ee_len);\n\t\tpath[depth].p_ext = ex;\n\n\t\ta = ex_ee_block > start ? ex_ee_block : start;\n\t\tb = ex_ee_block+ex_ee_len - 1 < end ?\n\t\t\tex_ee_block+ex_ee_len - 1 : end;\n\n\t\text_debug(\"  border %u:%u\\n\", a, b);\n\n\t\t/* If this extent is beyond the end of the hole, skip it */\n\t\tif (end <= ex_ee_block) {\n\t\t\tex--;\n\t\t\tex_ee_block = le32_to_cpu(ex->ee_block);\n\t\t\tex_ee_len = ext4_ext_get_actual_len(ex);\n\t\t\tcontinue;\n\t\t} else if (a != ex_ee_block &&\n\t\t\tb != ex_ee_block + ex_ee_len - 1) {\n\t\t\t/*\n\t\t\t * If this is a truncate, then this condition should\n\t\t\t * never happen because at least one of the end points\n\t\t\t * needs to be on the edge of the extent.\n\t\t\t */\n\t\t\tif (end == EXT_MAX_BLOCK) {\n\t\t\t\text_debug(\"  bad truncate %u:%u\\n\",\n\t\t\t\t\t\tstart, end);\n\t\t\t\tblock = 0;\n\t\t\t\tnum = 0;\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * else this is a hole punch, so the extent needs to\n\t\t\t * be split since neither edge of the hole is on the\n\t\t\t * extent edge\n\t\t\t */\n\t\t\telse{\n\t\t\t\tmap.m_pblk = ext4_ext_pblock(ex);\n\t\t\t\tmap.m_lblk = ex_ee_block;\n\t\t\t\tmap.m_len = b - ex_ee_block;\n\n\t\t\t\terr = ext4_split_extent(handle,\n\t\t\t\t\tinode, path, &map, 0,\n\t\t\t\t\tEXT4_GET_BLOCKS_PUNCH_OUT_EXT |\n\t\t\t\t\tEXT4_GET_BLOCKS_PRE_IO);\n\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tex_ee_len = ext4_ext_get_actual_len(ex);\n\n\t\t\t\tb = ex_ee_block+ex_ee_len - 1 < end ?\n\t\t\t\t\tex_ee_block+ex_ee_len - 1 : end;\n\n\t\t\t\t/* Then remove tail of this extent */\n\t\t\t\tblock = ex_ee_block;\n\t\t\t\tnum = a - block;\n\t\t\t}\n\t\t} else if (a != ex_ee_block) {\n\t\t\t/* remove tail of the extent */\n\t\t\tblock = ex_ee_block;\n\t\t\tnum = a - block;\n\t\t} else if (b != ex_ee_block + ex_ee_len - 1) {\n\t\t\t/* remove head of the extent */\n\t\t\tblock = b;\n\t\t\tnum =  ex_ee_block + ex_ee_len - b;\n\n\t\t\t/*\n\t\t\t * If this is a truncate, this condition\n\t\t\t * should never happen\n\t\t\t */\n\t\t\tif (end == EXT_MAX_BLOCK) {\n\t\t\t\text_debug(\"  bad truncate %u:%u\\n\",\n\t\t\t\t\tstart, end);\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/* remove whole extent: excellent! */\n\t\t\tblock = ex_ee_block;\n\t\t\tnum = 0;\n\t\t\tif (a != ex_ee_block) {\n\t\t\t\text_debug(\"  bad truncate %u:%u\\n\",\n\t\t\t\t\tstart, end);\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (b != ex_ee_block + ex_ee_len - 1) {\n\t\t\t\text_debug(\"  bad truncate %u:%u\\n\",\n\t\t\t\t\tstart, end);\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * 3 for leaf, sb, and inode plus 2 (bmap and group\n\t\t * descriptor) for each block group; assume two block\n\t\t * groups plus ex_ee_len/blocks_per_block_group for\n\t\t * the worst case\n\t\t */\n\t\tcredits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));\n\t\tif (ex == EXT_FIRST_EXTENT(eh)) {\n\t\t\tcorrect_index = 1;\n\t\t\tcredits += (ext_depth(inode)) + 1;\n\t\t}\n\t\tcredits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n\n\t\terr = ext4_ext_truncate_extend_restart(handle, inode, credits);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ext4_remove_blocks(handle, inode, ex, a, b);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (num == 0) {\n\t\t\t/* this extent is removed; mark slot entirely unused */\n\t\t\text4_ext_store_pblock(ex, 0);\n\t\t} else if (block != ex_ee_block) {\n\t\t\t/*\n\t\t\t * If this was a head removal, then we need to update\n\t\t\t * the physical block since it is now at a different\n\t\t\t * location\n\t\t\t */\n\t\t\text4_ext_store_pblock(ex, ext4_ext_pblock(ex) + (b-a));\n\t\t}\n\n\t\tex->ee_block = cpu_to_le32(block);\n\t\tex->ee_len = cpu_to_le16(num);\n\t\t/*\n\t\t * Do not mark uninitialized if all the blocks in the\n\t\t * extent have been removed.\n\t\t */\n\t\tif (uninitialized && num)\n\t\t\text4_ext_mark_uninitialized(ex);\n\n\t\terr = ext4_ext_dirty(handle, inode, path + depth);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * If the extent was completely released,\n\t\t * we need to remove it from the leaf\n\t\t */\n\t\tif (num == 0) {\n\t\t\tif (end != EXT_MAX_BLOCK) {\n\t\t\t\t/*\n\t\t\t\t * For hole punching, we need to scoot all the\n\t\t\t\t * extents up when an extent is removed so that\n\t\t\t\t * we dont have blank extents in the middle\n\t\t\t\t */\n\t\t\t\tmemmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *\n\t\t\t\t\tsizeof(struct ext4_extent));\n\n\t\t\t\t/* Now get rid of the one at the end */\n\t\t\t\tmemset(EXT_LAST_EXTENT(eh), 0,\n\t\t\t\t\tsizeof(struct ext4_extent));\n\t\t\t}\n\t\t\tle16_add_cpu(&eh->eh_entries, -1);\n\t\t}\n\n\t\text_debug(\"new extent: %u:%u:%llu\\n\", block, num,\n\t\t\t\text4_ext_pblock(ex));\n\t\tex--;\n\t\tex_ee_block = le32_to_cpu(ex->ee_block);\n\t\tex_ee_len = ext4_ext_get_actual_len(ex);\n\t}\n\n\tif (correct_index && eh->eh_entries)\n\t\terr = ext4_ext_correct_indexes(handle, inode, path);\n\n\t/* if this leaf is free, then we should\n\t * remove it from index block above */\n\tif (err == 0 && eh->eh_entries == 0 && path[depth].p_bh != NULL)\n\t\terr = ext4_ext_rm_idx(handle, inode, path + depth);\n\nout:\n\treturn err;\n}",
        "func": "static int\next4_ext_rm_leaf(handle_t *handle, struct inode *inode,\n\t\tstruct ext4_ext_path *path, ext4_lblk_t start,\n\t\text4_lblk_t end)\n{\n\tint err = 0, correct_index = 0;\n\tint depth = ext_depth(inode), credits;\n\tstruct ext4_extent_header *eh;\n\text4_lblk_t a, b, block;\n\tunsigned num;\n\text4_lblk_t ex_ee_block;\n\tunsigned short ex_ee_len;\n\tunsigned uninitialized = 0;\n\tstruct ext4_extent *ex;\n\tstruct ext4_map_blocks map;\n\n\t/* the header must be checked already in ext4_ext_remove_space() */\n\text_debug(\"truncate since %u in leaf\\n\", start);\n\tif (!path[depth].p_hdr)\n\t\tpath[depth].p_hdr = ext_block_hdr(path[depth].p_bh);\n\teh = path[depth].p_hdr;\n\tif (unlikely(path[depth].p_hdr == NULL)) {\n\t\tEXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);\n\t\treturn -EIO;\n\t}\n\t/* find where to start removing */\n\tex = EXT_LAST_EXTENT(eh);\n\n\tex_ee_block = le32_to_cpu(ex->ee_block);\n\tex_ee_len = ext4_ext_get_actual_len(ex);\n\n\twhile (ex >= EXT_FIRST_EXTENT(eh) &&\n\t\t\tex_ee_block + ex_ee_len > start) {\n\n\t\tif (ext4_ext_is_uninitialized(ex))\n\t\t\tuninitialized = 1;\n\t\telse\n\t\t\tuninitialized = 0;\n\n\t\text_debug(\"remove ext %u:[%d]%d\\n\", ex_ee_block,\n\t\t\t uninitialized, ex_ee_len);\n\t\tpath[depth].p_ext = ex;\n\n\t\ta = ex_ee_block > start ? ex_ee_block : start;\n\t\tb = ex_ee_block+ex_ee_len - 1 < end ?\n\t\t\tex_ee_block+ex_ee_len - 1 : end;\n\n\t\text_debug(\"  border %u:%u\\n\", a, b);\n\n\t\t/* If this extent is beyond the end of the hole, skip it */\n\t\tif (end <= ex_ee_block) {\n\t\t\tex--;\n\t\t\tex_ee_block = le32_to_cpu(ex->ee_block);\n\t\t\tex_ee_len = ext4_ext_get_actual_len(ex);\n\t\t\tcontinue;\n\t\t} else if (a != ex_ee_block &&\n\t\t\tb != ex_ee_block + ex_ee_len - 1) {\n\t\t\t/*\n\t\t\t * If this is a truncate, then this condition should\n\t\t\t * never happen because at least one of the end points\n\t\t\t * needs to be on the edge of the extent.\n\t\t\t */\n\t\t\tif (end == EXT_MAX_BLOCKS - 1) {\n\t\t\t\text_debug(\"  bad truncate %u:%u\\n\",\n\t\t\t\t\t\tstart, end);\n\t\t\t\tblock = 0;\n\t\t\t\tnum = 0;\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * else this is a hole punch, so the extent needs to\n\t\t\t * be split since neither edge of the hole is on the\n\t\t\t * extent edge\n\t\t\t */\n\t\t\telse{\n\t\t\t\tmap.m_pblk = ext4_ext_pblock(ex);\n\t\t\t\tmap.m_lblk = ex_ee_block;\n\t\t\t\tmap.m_len = b - ex_ee_block;\n\n\t\t\t\terr = ext4_split_extent(handle,\n\t\t\t\t\tinode, path, &map, 0,\n\t\t\t\t\tEXT4_GET_BLOCKS_PUNCH_OUT_EXT |\n\t\t\t\t\tEXT4_GET_BLOCKS_PRE_IO);\n\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tex_ee_len = ext4_ext_get_actual_len(ex);\n\n\t\t\t\tb = ex_ee_block+ex_ee_len - 1 < end ?\n\t\t\t\t\tex_ee_block+ex_ee_len - 1 : end;\n\n\t\t\t\t/* Then remove tail of this extent */\n\t\t\t\tblock = ex_ee_block;\n\t\t\t\tnum = a - block;\n\t\t\t}\n\t\t} else if (a != ex_ee_block) {\n\t\t\t/* remove tail of the extent */\n\t\t\tblock = ex_ee_block;\n\t\t\tnum = a - block;\n\t\t} else if (b != ex_ee_block + ex_ee_len - 1) {\n\t\t\t/* remove head of the extent */\n\t\t\tblock = b;\n\t\t\tnum =  ex_ee_block + ex_ee_len - b;\n\n\t\t\t/*\n\t\t\t * If this is a truncate, this condition\n\t\t\t * should never happen\n\t\t\t */\n\t\t\tif (end == EXT_MAX_BLOCKS - 1) {\n\t\t\t\text_debug(\"  bad truncate %u:%u\\n\",\n\t\t\t\t\tstart, end);\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t/* remove whole extent: excellent! */\n\t\t\tblock = ex_ee_block;\n\t\t\tnum = 0;\n\t\t\tif (a != ex_ee_block) {\n\t\t\t\text_debug(\"  bad truncate %u:%u\\n\",\n\t\t\t\t\tstart, end);\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (b != ex_ee_block + ex_ee_len - 1) {\n\t\t\t\text_debug(\"  bad truncate %u:%u\\n\",\n\t\t\t\t\tstart, end);\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * 3 for leaf, sb, and inode plus 2 (bmap and group\n\t\t * descriptor) for each block group; assume two block\n\t\t * groups plus ex_ee_len/blocks_per_block_group for\n\t\t * the worst case\n\t\t */\n\t\tcredits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));\n\t\tif (ex == EXT_FIRST_EXTENT(eh)) {\n\t\t\tcorrect_index = 1;\n\t\t\tcredits += (ext_depth(inode)) + 1;\n\t\t}\n\t\tcredits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n\n\t\terr = ext4_ext_truncate_extend_restart(handle, inode, credits);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ext4_remove_blocks(handle, inode, ex, a, b);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (num == 0) {\n\t\t\t/* this extent is removed; mark slot entirely unused */\n\t\t\text4_ext_store_pblock(ex, 0);\n\t\t} else if (block != ex_ee_block) {\n\t\t\t/*\n\t\t\t * If this was a head removal, then we need to update\n\t\t\t * the physical block since it is now at a different\n\t\t\t * location\n\t\t\t */\n\t\t\text4_ext_store_pblock(ex, ext4_ext_pblock(ex) + (b-a));\n\t\t}\n\n\t\tex->ee_block = cpu_to_le32(block);\n\t\tex->ee_len = cpu_to_le16(num);\n\t\t/*\n\t\t * Do not mark uninitialized if all the blocks in the\n\t\t * extent have been removed.\n\t\t */\n\t\tif (uninitialized && num)\n\t\t\text4_ext_mark_uninitialized(ex);\n\n\t\terr = ext4_ext_dirty(handle, inode, path + depth);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * If the extent was completely released,\n\t\t * we need to remove it from the leaf\n\t\t */\n\t\tif (num == 0) {\n\t\t\tif (end != EXT_MAX_BLOCKS - 1) {\n\t\t\t\t/*\n\t\t\t\t * For hole punching, we need to scoot all the\n\t\t\t\t * extents up when an extent is removed so that\n\t\t\t\t * we dont have blank extents in the middle\n\t\t\t\t */\n\t\t\t\tmemmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *\n\t\t\t\t\tsizeof(struct ext4_extent));\n\n\t\t\t\t/* Now get rid of the one at the end */\n\t\t\t\tmemset(EXT_LAST_EXTENT(eh), 0,\n\t\t\t\t\tsizeof(struct ext4_extent));\n\t\t\t}\n\t\t\tle16_add_cpu(&eh->eh_entries, -1);\n\t\t}\n\n\t\text_debug(\"new extent: %u:%u:%llu\\n\", block, num,\n\t\t\t\text4_ext_pblock(ex));\n\t\tex--;\n\t\tex_ee_block = le32_to_cpu(ex->ee_block);\n\t\tex_ee_len = ext4_ext_get_actual_len(ex);\n\t}\n\n\tif (correct_index && eh->eh_entries)\n\t\terr = ext4_ext_correct_indexes(handle, inode, path);\n\n\t/* if this leaf is free, then we should\n\t * remove it from index block above */\n\tif (err == 0 && eh->eh_entries == 0 && path[depth].p_bh != NULL)\n\t\terr = ext4_ext_rm_idx(handle, inode, path + depth);\n\nout:\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -60,7 +60,7 @@\n \t\t\t * never happen because at least one of the end points\n \t\t\t * needs to be on the edge of the extent.\n \t\t\t */\n-\t\t\tif (end == EXT_MAX_BLOCK) {\n+\t\t\tif (end == EXT_MAX_BLOCKS - 1) {\n \t\t\t\text_debug(\"  bad truncate %u:%u\\n\",\n \t\t\t\t\t\tstart, end);\n \t\t\t\tblock = 0;\n@@ -108,7 +108,7 @@\n \t\t\t * If this is a truncate, this condition\n \t\t\t * should never happen\n \t\t\t */\n-\t\t\tif (end == EXT_MAX_BLOCK) {\n+\t\t\tif (end == EXT_MAX_BLOCKS - 1) {\n \t\t\t\text_debug(\"  bad truncate %u:%u\\n\",\n \t\t\t\t\tstart, end);\n \t\t\t\terr = -EIO;\n@@ -188,7 +188,7 @@\n \t\t * we need to remove it from the leaf\n \t\t */\n \t\tif (num == 0) {\n-\t\t\tif (end != EXT_MAX_BLOCK) {\n+\t\t\tif (end != EXT_MAX_BLOCKS - 1) {\n \t\t\t\t/*\n \t\t\t\t * For hole punching, we need to scoot all the\n \t\t\t\t * extents up when an extent is removed so that",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif (end == EXT_MAX_BLOCK) {",
                "\t\t\tif (end == EXT_MAX_BLOCK) {",
                "\t\t\tif (end != EXT_MAX_BLOCK) {"
            ],
            "added_lines": [
                "\t\t\tif (end == EXT_MAX_BLOCKS - 1) {",
                "\t\t\tif (end == EXT_MAX_BLOCKS - 1) {",
                "\t\t\tif (end != EXT_MAX_BLOCKS - 1) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-2695",
        "func_name": "torvalds/linux/ext4_max_size",
        "description": "Multiple off-by-one errors in the ext4 subsystem in the Linux kernel before 3.0-rc5 allow local users to cause a denial of service (BUG_ON and system crash) by accessing a sparse file in extent format with a write operation involving a block number corresponding to the largest possible 32-bit unsigned integer.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=f17722f917b2f21497deb6edc62fb1683daa08e6",
        "commit_title": "Kazuya Mio reported that he was able to hit BUG_ON(next == lblock)",
        "commit_text": "in ext4_ext_put_gap_in_cache() while creating a sparse file in extent format and fill the tail of file up to its end. We will hit the BUG_ON when we write the last block (2^32-1) into the sparse file.  The root cause of the problem lies in the fact that we specifically set s_maxbytes so that block at s_maxbytes fit into on-disk extent format, which is 32 bit long. However, we are not storing start and end block number, but rather start block number and length in blocks. It means that in order to cover extent from 0 to EXT_MAX_BLOCK we need EXT_MAX_BLOCK+1 to fit into len (because we counting block 0 as well) - and it does not.  The only way to fix it without changing the meaning of the struct ext4_extent members is, as Kazuya Mio suggested, to lower s_maxbytes by one fs block so we can cover the whole extent we can get by the on-disk extent format.  Also in many places EXT_MAX_BLOCK is used as length instead of maximum logical block number as the name suggests, it is all a bit messy. So this commit renames it to EXT_MAX_BLOCKS and change its usage in some places to actually be maximum number of blocks in the extent.  The bug which this commit fixes can be reproduced as follows:   dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-2))  sync  dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-1))  ",
        "func_before": "static loff_t ext4_max_size(int blkbits, int has_huge_files)\n{\n\tloff_t res;\n\tloff_t upper_limit = MAX_LFS_FILESIZE;\n\n\t/* small i_blocks in vfs inode? */\n\tif (!has_huge_files || sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t/*\n\t\t * CONFIG_LBDAF is not enabled implies the inode\n\t\t * i_block represent total blocks in 512 bytes\n\t\t * 32 == size of vfs inode i_blocks * 8\n\t\t */\n\t\tupper_limit = (1LL << 32) - 1;\n\n\t\t/* total blocks in file system block size */\n\t\tupper_limit >>= (blkbits - 9);\n\t\tupper_limit <<= blkbits;\n\t}\n\n\t/* 32-bit extent-start container, ee_block */\n\tres = 1LL << 32;\n\tres <<= blkbits;\n\tres -= 1;\n\n\t/* Sanity check against vm- & vfs- imposed limits */\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\treturn res;\n}",
        "func": "static loff_t ext4_max_size(int blkbits, int has_huge_files)\n{\n\tloff_t res;\n\tloff_t upper_limit = MAX_LFS_FILESIZE;\n\n\t/* small i_blocks in vfs inode? */\n\tif (!has_huge_files || sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t/*\n\t\t * CONFIG_LBDAF is not enabled implies the inode\n\t\t * i_block represent total blocks in 512 bytes\n\t\t * 32 == size of vfs inode i_blocks * 8\n\t\t */\n\t\tupper_limit = (1LL << 32) - 1;\n\n\t\t/* total blocks in file system block size */\n\t\tupper_limit >>= (blkbits - 9);\n\t\tupper_limit <<= blkbits;\n\t}\n\n\t/*\n\t * 32-bit extent-start container, ee_block. We lower the maxbytes\n\t * by one fs block, so ee_len can cover the extent of maximum file\n\t * size\n\t */\n\tres = (1LL << 32) - 1;\n\tres <<= blkbits;\n\n\t/* Sanity check against vm- & vfs- imposed limits */\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,10 +17,13 @@\n \t\tupper_limit <<= blkbits;\n \t}\n \n-\t/* 32-bit extent-start container, ee_block */\n-\tres = 1LL << 32;\n+\t/*\n+\t * 32-bit extent-start container, ee_block. We lower the maxbytes\n+\t * by one fs block, so ee_len can cover the extent of maximum file\n+\t * size\n+\t */\n+\tres = (1LL << 32) - 1;\n \tres <<= blkbits;\n-\tres -= 1;\n \n \t/* Sanity check against vm- & vfs- imposed limits */\n \tif (res > upper_limit)",
        "diff_line_info": {
            "deleted_lines": [
                "\t/* 32-bit extent-start container, ee_block */",
                "\tres = 1LL << 32;",
                "\tres -= 1;"
            ],
            "added_lines": [
                "\t/*",
                "\t * 32-bit extent-start container, ee_block. We lower the maxbytes",
                "\t * by one fs block, so ee_len can cover the extent of maximum file",
                "\t * size",
                "\t */",
                "\tres = (1LL << 32) - 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-2695",
        "func_name": "torvalds/linux/mext_check_arguments",
        "description": "Multiple off-by-one errors in the ext4 subsystem in the Linux kernel before 3.0-rc5 allow local users to cause a denial of service (BUG_ON and system crash) by accessing a sparse file in extent format with a write operation involving a block number corresponding to the largest possible 32-bit unsigned integer.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=f17722f917b2f21497deb6edc62fb1683daa08e6",
        "commit_title": "Kazuya Mio reported that he was able to hit BUG_ON(next == lblock)",
        "commit_text": "in ext4_ext_put_gap_in_cache() while creating a sparse file in extent format and fill the tail of file up to its end. We will hit the BUG_ON when we write the last block (2^32-1) into the sparse file.  The root cause of the problem lies in the fact that we specifically set s_maxbytes so that block at s_maxbytes fit into on-disk extent format, which is 32 bit long. However, we are not storing start and end block number, but rather start block number and length in blocks. It means that in order to cover extent from 0 to EXT_MAX_BLOCK we need EXT_MAX_BLOCK+1 to fit into len (because we counting block 0 as well) - and it does not.  The only way to fix it without changing the meaning of the struct ext4_extent members is, as Kazuya Mio suggested, to lower s_maxbytes by one fs block so we can cover the whole extent we can get by the on-disk extent format.  Also in many places EXT_MAX_BLOCK is used as length instead of maximum logical block number as the name suggests, it is all a bit messy. So this commit renames it to EXT_MAX_BLOCKS and change its usage in some places to actually be maximum number of blocks in the extent.  The bug which this commit fixes can be reproduced as follows:   dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-2))  sync  dd if=/dev/zero of=/mnt/mp1/file bs=<blocksize> count=1 seek=$((2**32-1))  ",
        "func_before": "static int\nmext_check_arguments(struct inode *orig_inode,\n\t\t     struct inode *donor_inode, __u64 orig_start,\n\t\t     __u64 donor_start, __u64 *len)\n{\n\text4_lblk_t orig_blocks, donor_blocks;\n\tunsigned int blkbits = orig_inode->i_blkbits;\n\tunsigned int blocksize = 1 << blkbits;\n\n\tif (donor_inode->i_mode & (S_ISUID|S_ISGID)) {\n\t\text4_debug(\"ext4 move extent: suid or sgid is set\"\n\t\t\t   \" to donor file [ino:orig %lu, donor %lu]\\n\",\n\t\t\t   orig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_IMMUTABLE(donor_inode) || IS_APPEND(donor_inode))\n\t\treturn -EPERM;\n\n\t/* Ext4 move extent does not support swapfile */\n\tif (IS_SWAPFILE(orig_inode) || IS_SWAPFILE(donor_inode)) {\n\t\text4_debug(\"ext4 move extent: The argument files should \"\n\t\t\t\"not be swapfile [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Files should be in the same ext4 FS */\n\tif (orig_inode->i_sb != donor_inode->i_sb) {\n\t\text4_debug(\"ext4 move extent: The argument files \"\n\t\t\t\"should be in same FS [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ext4 move extent supports only extent based file */\n\tif (!(ext4_test_inode_flag(orig_inode, EXT4_INODE_EXTENTS))) {\n\t\text4_debug(\"ext4 move extent: orig file is not extents \"\n\t\t\t\"based file [ino:orig %lu]\\n\", orig_inode->i_ino);\n\t\treturn -EOPNOTSUPP;\n\t} else if (!(ext4_test_inode_flag(donor_inode, EXT4_INODE_EXTENTS))) {\n\t\text4_debug(\"ext4 move extent: donor file is not extents \"\n\t\t\t\"based file [ino:donor %lu]\\n\", donor_inode->i_ino);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif ((!orig_inode->i_size) || (!donor_inode->i_size)) {\n\t\text4_debug(\"ext4 move extent: File size is 0 byte\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Start offset should be same */\n\tif (orig_start != donor_start) {\n\t\text4_debug(\"ext4 move extent: orig and donor's start \"\n\t\t\t\"offset are not same [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((orig_start > EXT_MAX_BLOCK) ||\n\t    (donor_start > EXT_MAX_BLOCK) ||\n\t    (*len > EXT_MAX_BLOCK) ||\n\t    (orig_start + *len > EXT_MAX_BLOCK))  {\n\t\text4_debug(\"ext4 move extent: Can't handle over [%u] blocks \"\n\t\t\t\"[ino:orig %lu, donor %lu]\\n\", EXT_MAX_BLOCK,\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\tif (orig_inode->i_size > donor_inode->i_size) {\n\t\tdonor_blocks = (donor_inode->i_size + blocksize - 1) >> blkbits;\n\t\t/* TODO: eliminate this artificial restriction */\n\t\tif (orig_start >= donor_blocks) {\n\t\t\text4_debug(\"ext4 move extent: orig start offset \"\n\t\t\t\"[%llu] should be less than donor file blocks \"\n\t\t\t\"[%u] [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_start, donor_blocks,\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* TODO: eliminate this artificial restriction */\n\t\tif (orig_start + *len > donor_blocks) {\n\t\t\text4_debug(\"ext4 move extent: End offset [%llu] should \"\n\t\t\t\t\"be less than donor file blocks [%u].\"\n\t\t\t\t\"So adjust length from %llu to %llu \"\n\t\t\t\t\"[ino:orig %lu, donor %lu]\\n\",\n\t\t\t\torig_start + *len, donor_blocks,\n\t\t\t\t*len, donor_blocks - orig_start,\n\t\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\t\t*len = donor_blocks - orig_start;\n\t\t}\n\t} else {\n\t\torig_blocks = (orig_inode->i_size + blocksize - 1) >> blkbits;\n\t\tif (orig_start >= orig_blocks) {\n\t\t\text4_debug(\"ext4 move extent: start offset [%llu] \"\n\t\t\t\t\"should be less than original file blocks \"\n\t\t\t\t\"[%u] [ino:orig %lu, donor %lu]\\n\",\n\t\t\t\t orig_start, orig_blocks,\n\t\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (orig_start + *len > orig_blocks) {\n\t\t\text4_debug(\"ext4 move extent: Adjust length \"\n\t\t\t\t\"from %llu to %llu. Because it should be \"\n\t\t\t\t\"less than original file blocks \"\n\t\t\t\t\"[ino:orig %lu, donor %lu]\\n\",\n\t\t\t\t*len, orig_blocks - orig_start,\n\t\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\t\t*len = orig_blocks - orig_start;\n\t\t}\n\t}\n\n\tif (!*len) {\n\t\text4_debug(\"ext4 move extent: len should not be 0 \"\n\t\t\t\"[ino:orig %lu, donor %lu]\\n\", orig_inode->i_ino,\n\t\t\tdonor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
        "func": "static int\nmext_check_arguments(struct inode *orig_inode,\n\t\t     struct inode *donor_inode, __u64 orig_start,\n\t\t     __u64 donor_start, __u64 *len)\n{\n\text4_lblk_t orig_blocks, donor_blocks;\n\tunsigned int blkbits = orig_inode->i_blkbits;\n\tunsigned int blocksize = 1 << blkbits;\n\n\tif (donor_inode->i_mode & (S_ISUID|S_ISGID)) {\n\t\text4_debug(\"ext4 move extent: suid or sgid is set\"\n\t\t\t   \" to donor file [ino:orig %lu, donor %lu]\\n\",\n\t\t\t   orig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_IMMUTABLE(donor_inode) || IS_APPEND(donor_inode))\n\t\treturn -EPERM;\n\n\t/* Ext4 move extent does not support swapfile */\n\tif (IS_SWAPFILE(orig_inode) || IS_SWAPFILE(donor_inode)) {\n\t\text4_debug(\"ext4 move extent: The argument files should \"\n\t\t\t\"not be swapfile [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Files should be in the same ext4 FS */\n\tif (orig_inode->i_sb != donor_inode->i_sb) {\n\t\text4_debug(\"ext4 move extent: The argument files \"\n\t\t\t\"should be in same FS [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Ext4 move extent supports only extent based file */\n\tif (!(ext4_test_inode_flag(orig_inode, EXT4_INODE_EXTENTS))) {\n\t\text4_debug(\"ext4 move extent: orig file is not extents \"\n\t\t\t\"based file [ino:orig %lu]\\n\", orig_inode->i_ino);\n\t\treturn -EOPNOTSUPP;\n\t} else if (!(ext4_test_inode_flag(donor_inode, EXT4_INODE_EXTENTS))) {\n\t\text4_debug(\"ext4 move extent: donor file is not extents \"\n\t\t\t\"based file [ino:donor %lu]\\n\", donor_inode->i_ino);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif ((!orig_inode->i_size) || (!donor_inode->i_size)) {\n\t\text4_debug(\"ext4 move extent: File size is 0 byte\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Start offset should be same */\n\tif (orig_start != donor_start) {\n\t\text4_debug(\"ext4 move extent: orig and donor's start \"\n\t\t\t\"offset are not same [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((orig_start >= EXT_MAX_BLOCKS) ||\n\t    (donor_start >= EXT_MAX_BLOCKS) ||\n\t    (*len > EXT_MAX_BLOCKS) ||\n\t    (orig_start + *len >= EXT_MAX_BLOCKS))  {\n\t\text4_debug(\"ext4 move extent: Can't handle over [%u] blocks \"\n\t\t\t\"[ino:orig %lu, donor %lu]\\n\", EXT_MAX_BLOCKS,\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\tif (orig_inode->i_size > donor_inode->i_size) {\n\t\tdonor_blocks = (donor_inode->i_size + blocksize - 1) >> blkbits;\n\t\t/* TODO: eliminate this artificial restriction */\n\t\tif (orig_start >= donor_blocks) {\n\t\t\text4_debug(\"ext4 move extent: orig start offset \"\n\t\t\t\"[%llu] should be less than donor file blocks \"\n\t\t\t\"[%u] [ino:orig %lu, donor %lu]\\n\",\n\t\t\torig_start, donor_blocks,\n\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* TODO: eliminate this artificial restriction */\n\t\tif (orig_start + *len > donor_blocks) {\n\t\t\text4_debug(\"ext4 move extent: End offset [%llu] should \"\n\t\t\t\t\"be less than donor file blocks [%u].\"\n\t\t\t\t\"So adjust length from %llu to %llu \"\n\t\t\t\t\"[ino:orig %lu, donor %lu]\\n\",\n\t\t\t\torig_start + *len, donor_blocks,\n\t\t\t\t*len, donor_blocks - orig_start,\n\t\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\t\t*len = donor_blocks - orig_start;\n\t\t}\n\t} else {\n\t\torig_blocks = (orig_inode->i_size + blocksize - 1) >> blkbits;\n\t\tif (orig_start >= orig_blocks) {\n\t\t\text4_debug(\"ext4 move extent: start offset [%llu] \"\n\t\t\t\t\"should be less than original file blocks \"\n\t\t\t\t\"[%u] [ino:orig %lu, donor %lu]\\n\",\n\t\t\t\t orig_start, orig_blocks,\n\t\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (orig_start + *len > orig_blocks) {\n\t\t\text4_debug(\"ext4 move extent: Adjust length \"\n\t\t\t\t\"from %llu to %llu. Because it should be \"\n\t\t\t\t\"less than original file blocks \"\n\t\t\t\t\"[ino:orig %lu, donor %lu]\\n\",\n\t\t\t\t*len, orig_blocks - orig_start,\n\t\t\t\torig_inode->i_ino, donor_inode->i_ino);\n\t\t\t*len = orig_blocks - orig_start;\n\t\t}\n\t}\n\n\tif (!*len) {\n\t\text4_debug(\"ext4 move extent: len should not be 0 \"\n\t\t\t\"[ino:orig %lu, donor %lu]\\n\", orig_inode->i_ino,\n\t\t\tdonor_inode->i_ino);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -57,12 +57,12 @@\n \t\treturn -EINVAL;\n \t}\n \n-\tif ((orig_start > EXT_MAX_BLOCK) ||\n-\t    (donor_start > EXT_MAX_BLOCK) ||\n-\t    (*len > EXT_MAX_BLOCK) ||\n-\t    (orig_start + *len > EXT_MAX_BLOCK))  {\n+\tif ((orig_start >= EXT_MAX_BLOCKS) ||\n+\t    (donor_start >= EXT_MAX_BLOCKS) ||\n+\t    (*len > EXT_MAX_BLOCKS) ||\n+\t    (orig_start + *len >= EXT_MAX_BLOCKS))  {\n \t\text4_debug(\"ext4 move extent: Can't handle over [%u] blocks \"\n-\t\t\t\"[ino:orig %lu, donor %lu]\\n\", EXT_MAX_BLOCK,\n+\t\t\t\"[ino:orig %lu, donor %lu]\\n\", EXT_MAX_BLOCKS,\n \t\t\torig_inode->i_ino, donor_inode->i_ino);\n \t\treturn -EINVAL;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\tif ((orig_start > EXT_MAX_BLOCK) ||",
                "\t    (donor_start > EXT_MAX_BLOCK) ||",
                "\t    (*len > EXT_MAX_BLOCK) ||",
                "\t    (orig_start + *len > EXT_MAX_BLOCK))  {",
                "\t\t\t\"[ino:orig %lu, donor %lu]\\n\", EXT_MAX_BLOCK,"
            ],
            "added_lines": [
                "\tif ((orig_start >= EXT_MAX_BLOCKS) ||",
                "\t    (donor_start >= EXT_MAX_BLOCKS) ||",
                "\t    (*len > EXT_MAX_BLOCKS) ||",
                "\t    (orig_start + *len >= EXT_MAX_BLOCKS))  {",
                "\t\t\t\"[ino:orig %lu, donor %lu]\\n\", EXT_MAX_BLOCKS,"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0818",
        "func_name": "gpac/gf_text_get_utf8_line",
        "description": "Off-by-one Error in GitHub repository gpac/gpac prior to v2.3.0-DEV.",
        "git_url": "https://github.com/gpac/gpac/commit/377ab25f3e502db2934a9cf4b54739e1c89a02ff",
        "commit_title": "fix a5efec8 to cover more cases (#2397)",
        "commit_text": "",
        "func_before": "char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[2048];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = gf_fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\tif (unicode_type<=1) {\n\t\tj=0;\n\t\tlen = (u32) strlen(szLine);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ((szLine[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tszLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[i] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xe0) == 0xc0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\ti+=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tszLineConv[j] = szLine[i];\n\t\t\tj++;\n\n\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv) - 1) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TXTIn] Line too long to convert to utf8 (len: %d)\\n\", len));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tszLineConv[j] = 0;\n\t\tstrcpy(szLine, szLineConv);\n\t\treturn sOK;\n\t}\n\n#ifdef GPAC_BIG_ENDIAN\n\tif (unicode_type==3)\n#else\n\tif (unicode_type==2)\n#endif\n\t{\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tif (!szLine[i] && !szLine[i+1]) break;\n\t\t\tc = szLine[i+1];\n\t\t\tszLine[i+1] = szLine[i];\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);\n\tif (i == GF_UTF8_FAIL) i = 0;\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \\0 after a \\n*/\n\tif (unicode_type==3) gf_fgetc(txt_in);\n\treturn sOK;\n}",
        "func": "char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[2048];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = gf_fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\tif (unicode_type<=1) {\n\t\tj=0;\n\t\tlen = (u32) strlen(szLine);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ((szLine[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tszLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[i] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xe0) == 0xc0) {\n\t\t\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tif (j+1 >= GF_ARRAY_LENGTH(szLineConv))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tif (j+2 >= GF_ARRAY_LENGTH(szLineConv))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\ti+=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv))\n\t\t\t\tbreak;\n\n\t\t\tszLineConv[j] = szLine[i];\n\t\t\tj++;\n\n\n\t\t}\n\t\tif ( j >= GF_ARRAY_LENGTH(szLineConv) ) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TXTIn] Line too long to convert to utf8 (len: %d)\\n\", len));\n\t\t\tj = GF_ARRAY_LENGTH(szLineConv) -1 ;\n\t\t}\n\t\tszLineConv[j] = 0;\n\t\tstrcpy(szLine, szLineConv);\n\t\treturn sOK;\n\t}\n\n#ifdef GPAC_BIG_ENDIAN\n\tif (unicode_type==3)\n#else\n\tif (unicode_type==2)\n#endif\n\t{\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tif (!szLine[i] && !szLine[i+1]) break;\n\t\t\tc = szLine[i+1];\n\t\t\tszLine[i+1] = szLine[i];\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);\n\tif (i == GF_UTF8_FAIL) i = 0;\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \\0 after a \\n*/\n\tif (unicode_type==3) gf_fgetc(txt_in);\n\treturn sOK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,18 +15,24 @@\n \t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n \t\t\t\t/*non UTF8 (likely some win-CP)*/\n \t\t\t\tif ((szLine[i+1] & 0xc0) != 0x80) {\n+\t\t\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv))\n+\t\t\t\t\t\tbreak;\n \t\t\t\t\tszLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );\n \t\t\t\t\tj++;\n \t\t\t\t\tszLine[i] &= 0xbf;\n \t\t\t\t}\n \t\t\t\t/*UTF8 2 bytes char*/\n \t\t\t\telse if ( (szLine[i] & 0xe0) == 0xc0) {\n+\t\t\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv))\n+\t\t\t\t\t\tbreak;\n \t\t\t\t\tszLineConv[j] = szLine[i];\n \t\t\t\t\ti++;\n \t\t\t\t\tj++;\n \t\t\t\t}\n \t\t\t\t/*UTF8 3 bytes char*/\n \t\t\t\telse if ( (szLine[i] & 0xf0) == 0xe0) {\n+\t\t\t\t\tif (j+1 >= GF_ARRAY_LENGTH(szLineConv))\n+\t\t\t\t\t\tbreak;\n \t\t\t\t\tszLineConv[j] = szLine[i];\n \t\t\t\t\ti++;\n \t\t\t\t\tj++;\n@@ -36,6 +42,8 @@\n \t\t\t\t}\n \t\t\t\t/*UTF8 4 bytes char*/\n \t\t\t\telse if ( (szLine[i] & 0xf8) == 0xf0) {\n+\t\t\t\t\tif (j+2 >= GF_ARRAY_LENGTH(szLineConv))\n+\t\t\t\t\t\tbreak;\n \t\t\t\t\tszLineConv[j] = szLine[i];\n \t\t\t\t\ti++;\n \t\t\t\t\tj++;\n@@ -50,14 +58,18 @@\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv))\n+\t\t\t\tbreak;\n+\n \t\t\tszLineConv[j] = szLine[i];\n \t\t\tj++;\n \n-\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv) - 1) {\n-\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TXTIn] Line too long to convert to utf8 (len: %d)\\n\", len));\n-\t\t\t\tbreak;\n-\t\t\t}\n \n+\t\t}\n+\t\tif ( j >= GF_ARRAY_LENGTH(szLineConv) ) {\n+\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TXTIn] Line too long to convert to utf8 (len: %d)\\n\", len));\n+\t\t\tj = GF_ARRAY_LENGTH(szLineConv) -1 ;\n \t\t}\n \t\tszLineConv[j] = 0;\n \t\tstrcpy(szLine, szLineConv);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv) - 1) {",
                "\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TXTIn] Line too long to convert to utf8 (len: %d)\\n\", len));",
                "\t\t\t\tbreak;",
                "\t\t\t}"
            ],
            "added_lines": [
                "\t\t\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv))",
                "\t\t\t\t\t\tbreak;",
                "\t\t\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv))",
                "\t\t\t\t\t\tbreak;",
                "\t\t\t\t\tif (j+1 >= GF_ARRAY_LENGTH(szLineConv))",
                "\t\t\t\t\t\tbreak;",
                "\t\t\t\t\tif (j+2 >= GF_ARRAY_LENGTH(szLineConv))",
                "\t\t\t\t\t\tbreak;",
                "",
                "\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv))",
                "\t\t\t\tbreak;",
                "",
                "\t\t}",
                "\t\tif ( j >= GF_ARRAY_LENGTH(szLineConv) ) {",
                "\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TXTIn] Line too long to convert to utf8 (len: %d)\\n\", len));",
                "\t\t\tj = GF_ARRAY_LENGTH(szLineConv) -1 ;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25050",
        "func_name": "merbanan/rtl_433/somfy_iohc_decode",
        "description": "rtl_433 21.12 was discovered to contain a stack overflow in the function somfy_iohc_decode(). This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted file.",
        "git_url": "https://github.com/merbanan/rtl_433/commit/2dad7b9fc67a1d0bfbe520fbd821678b8f8cc7a8",
        "commit_title": "minor: Fix overflow in Clipsal-CMR113 and Somfy-IOHC reported by aug5t7",
        "commit_text": "",
        "func_before": "static int somfy_iohc_decode(r_device *decoder, bitbuffer_t *bitbuffer)\n{\n    uint8_t const preamble_pattern[] = {0x57, 0xfd, 0x99};\n\n    uint8_t b[19 + 15]; // 19 byte + up 15 byte payload\n\n    if (bitbuffer->num_rows != 1)\n        return DECODE_ABORT_EARLY;\n\n    int offset = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;\n    if (offset >= bitbuffer->bits_per_row[0] - 19 * 10)\n        return DECODE_ABORT_EARLY;\n\n    int num_bits = bitbuffer->bits_per_row[0] - offset;\n\n    int len = extract_bytes_uart(bitbuffer->bb[0], offset, num_bits, b);\n    if (len < 19)\n        return DECODE_ABORT_LENGTH;\n\n    if ((b[0] & 0xf0) != 0xf0)\n        return DECODE_ABORT_EARLY;\n\n    int msg_len = b[0] & 0xf; // should be 6 or 8\n    if (len < 19 + msg_len)\n        return DECODE_ABORT_LENGTH;\n\n    // calculate and verify checksum\n    if (crc16lsb(b, len, 0x8408, 0x0000) != 0) // unreflected poly 0x1021\n        return DECODE_FAIL_MIC;\n    bitrow_printf(b, len * 8, \"%s: offset %d, num_bits %d, len %d, msg_len %d\\n\", __func__, offset, num_bits, len, msg_len);\n\n    int msg_type = (b[0]);\n    int dst_id   = ((unsigned)b[4] << 24) | (b[3] << 16) | (b[2] << 8) | (b[1]); // assume Little-Endian\n    int src_id   = ((unsigned)b[8] << 24) | (b[7] << 16) | (b[6] << 8) | (b[5]); // assume Little-Endian\n    int counter  = (b[len - 10] << 8) | (b[len - 9]);\n    char msg_str[15 * 2 + 1];\n    bitrow_snprint(&b[9], msg_len * 8, msg_str, 15 * 2 + 1);\n    char mac_str[13];\n    bitrow_snprint(&b[len - 8], 6 * 8, mac_str, 13);\n\n    /* clang-format off */\n    data_t *data = data_make(\n            \"model\",            \"\",                 DATA_STRING, \"Somfy-IOHC\",\n            \"id\",               \"\",                 DATA_FORMAT, \"%08x\", DATA_INT, src_id,\n            \"dst_id\",           \"Dest ID\",          DATA_FORMAT, \"%08x\", DATA_INT, dst_id,\n            \"msg_type\",         \"Msg type\",         DATA_FORMAT, \"%02x\", DATA_INT, msg_type,\n            \"msg\",              \"Message\",          DATA_STRING, msg_str,\n            \"counter\",          \"Counter\",          DATA_INT,    counter,\n            \"mac\",              \"MAC\",              DATA_STRING, mac_str,\n            \"mic\",              \"Integrity\",        DATA_STRING, \"CRC\",\n            NULL);\n    /* clang-format on */\n\n    decoder_output_data(decoder, data);\n    return 1;\n}",
        "func": "static int somfy_iohc_decode(r_device *decoder, bitbuffer_t *bitbuffer)\n{\n    uint8_t const preamble_pattern[] = {0x57, 0xfd, 0x99};\n\n    uint8_t b[19 + 15]; // 19 byte + up 15 byte payload\n\n    if (bitbuffer->num_rows != 1)\n        return DECODE_ABORT_EARLY;\n\n    unsigned offset = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;\n    if (offset + 19 * 10 >= bitbuffer->bits_per_row[0])\n        return DECODE_ABORT_EARLY;\n\n    unsigned num_bits = bitbuffer->bits_per_row[0] - offset;\n    num_bits = MIN(num_bits, sizeof (b) * 8);\n\n    int len = extract_bytes_uart(bitbuffer->bb[0], offset, num_bits, b);\n    if (len < 19)\n        return DECODE_ABORT_LENGTH;\n\n    if ((b[0] & 0xf0) != 0xf0)\n        return DECODE_ABORT_EARLY;\n\n    int msg_len = b[0] & 0xf; // should be 6 or 8\n    if (len < 19 + msg_len)\n        return DECODE_ABORT_LENGTH;\n\n    // calculate and verify checksum\n    if (crc16lsb(b, len, 0x8408, 0x0000) != 0) // unreflected poly 0x1021\n        return DECODE_FAIL_MIC;\n    bitrow_printf(b, len * 8, \"%s: offset %u, num_bits %u, len %d, msg_len %d\\n\", __func__, offset, num_bits, len, msg_len);\n\n    int msg_type = (b[0]);\n    int dst_id   = ((unsigned)b[4] << 24) | (b[3] << 16) | (b[2] << 8) | (b[1]); // assume Little-Endian\n    int src_id   = ((unsigned)b[8] << 24) | (b[7] << 16) | (b[6] << 8) | (b[5]); // assume Little-Endian\n    int counter  = (b[len - 10] << 8) | (b[len - 9]);\n    char msg_str[15 * 2 + 1];\n    bitrow_snprint(&b[9], msg_len * 8, msg_str, 15 * 2 + 1);\n    char mac_str[13];\n    bitrow_snprint(&b[len - 8], 6 * 8, mac_str, 13);\n\n    /* clang-format off */\n    data_t *data = data_make(\n            \"model\",            \"\",                 DATA_STRING, \"Somfy-IOHC\",\n            \"id\",               \"\",                 DATA_FORMAT, \"%08x\", DATA_INT, src_id,\n            \"dst_id\",           \"Dest ID\",          DATA_FORMAT, \"%08x\", DATA_INT, dst_id,\n            \"msg_type\",         \"Msg type\",         DATA_FORMAT, \"%02x\", DATA_INT, msg_type,\n            \"msg\",              \"Message\",          DATA_STRING, msg_str,\n            \"counter\",          \"Counter\",          DATA_INT,    counter,\n            \"mac\",              \"MAC\",              DATA_STRING, mac_str,\n            \"mic\",              \"Integrity\",        DATA_STRING, \"CRC\",\n            NULL);\n    /* clang-format on */\n\n    decoder_output_data(decoder, data);\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,11 +7,12 @@\n     if (bitbuffer->num_rows != 1)\n         return DECODE_ABORT_EARLY;\n \n-    int offset = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;\n-    if (offset >= bitbuffer->bits_per_row[0] - 19 * 10)\n+    unsigned offset = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;\n+    if (offset + 19 * 10 >= bitbuffer->bits_per_row[0])\n         return DECODE_ABORT_EARLY;\n \n-    int num_bits = bitbuffer->bits_per_row[0] - offset;\n+    unsigned num_bits = bitbuffer->bits_per_row[0] - offset;\n+    num_bits = MIN(num_bits, sizeof (b) * 8);\n \n     int len = extract_bytes_uart(bitbuffer->bb[0], offset, num_bits, b);\n     if (len < 19)\n@@ -27,7 +28,7 @@\n     // calculate and verify checksum\n     if (crc16lsb(b, len, 0x8408, 0x0000) != 0) // unreflected poly 0x1021\n         return DECODE_FAIL_MIC;\n-    bitrow_printf(b, len * 8, \"%s: offset %d, num_bits %d, len %d, msg_len %d\\n\", __func__, offset, num_bits, len, msg_len);\n+    bitrow_printf(b, len * 8, \"%s: offset %u, num_bits %u, len %d, msg_len %d\\n\", __func__, offset, num_bits, len, msg_len);\n \n     int msg_type = (b[0]);\n     int dst_id   = ((unsigned)b[4] << 24) | (b[3] << 16) | (b[2] << 8) | (b[1]); // assume Little-Endian",
        "diff_line_info": {
            "deleted_lines": [
                "    int offset = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;",
                "    if (offset >= bitbuffer->bits_per_row[0] - 19 * 10)",
                "    int num_bits = bitbuffer->bits_per_row[0] - offset;",
                "    bitrow_printf(b, len * 8, \"%s: offset %d, num_bits %d, len %d, msg_len %d\\n\", __func__, offset, num_bits, len, msg_len);"
            ],
            "added_lines": [
                "    unsigned offset = bitbuffer_search(bitbuffer, 0, 0, preamble_pattern, 24) + 24;",
                "    if (offset + 19 * 10 >= bitbuffer->bits_per_row[0])",
                "    unsigned num_bits = bitbuffer->bits_per_row[0] - offset;",
                "    num_bits = MIN(num_bits, sizeof (b) * 8);",
                "    bitrow_printf(b, len * 8, \"%s: offset %u, num_bits %u, len %d, msg_len %d\\n\", __func__, offset, num_bits, len, msg_len);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7329",
        "func_name": "wireshark/s7comm_decode_response_write_data",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-s7comm.c had an infinite loop that was addressed by correcting off-by-one errors.",
        "git_url": "https://github.com/wireshark/wireshark/commit/d8a0cbc4f2979e0b1cadbe79f0b8b4ecb92477be",
        "commit_title": "S7comm: fix range check to prevent infinite loop when upper bound is 255",
        "commit_text": " While we are at it, fix identification of not last element in a few places  Bug: 14423 (cherry picked from commit 5d99febe66e96b55a1defa58a906be254bad3a51) Conflicts: \tepan/dissectors/packet-s7comm.c (cherry picked from commit d24db8ddcdd4cdd5c1ea859da93681b4cc98b399)",
        "func_before": "static guint32\ns7comm_decode_response_write_data(tvbuff_t *tvb,\n                                  proto_tree *tree,\n                                  guint8 item_count,\n                                  guint32 offset)\n{\n    guint8 ret_val = 0;\n    guint8 i = 0;\n    proto_item *item = NULL;\n    proto_tree *item_tree = NULL;\n\n    for (i = 1; i <= item_count; i++) {\n        ret_val = tvb_get_guint8(tvb, offset);\n        /* Insert a new tree for every item */\n        item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, 1, ENC_NA);\n        item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n        proto_item_append_text(item, \" [%d]: (%s)\", i, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n        proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n        offset += 1;\n    }\n    return offset;\n}",
        "func": "static guint32\ns7comm_decode_response_write_data(tvbuff_t *tvb,\n                                  proto_tree *tree,\n                                  guint8 item_count,\n                                  guint32 offset)\n{\n    guint8 ret_val = 0;\n    guint8 i = 0;\n    proto_item *item = NULL;\n    proto_tree *item_tree = NULL;\n\n    for (i = 0; i < item_count; i++) {\n        ret_val = tvb_get_guint8(tvb, offset);\n        /* Insert a new tree for every item */\n        item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, 1, ENC_NA);\n        item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n        proto_item_append_text(item, \" [%d]: (%s)\", i+1, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n        proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n        offset += 1;\n    }\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,12 +9,12 @@\n     proto_item *item = NULL;\n     proto_tree *item_tree = NULL;\n \n-    for (i = 1; i <= item_count; i++) {\n+    for (i = 0; i < item_count; i++) {\n         ret_val = tvb_get_guint8(tvb, offset);\n         /* Insert a new tree for every item */\n         item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, 1, ENC_NA);\n         item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n-        proto_item_append_text(item, \" [%d]: (%s)\", i, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n+        proto_item_append_text(item, \" [%d]: (%s)\", i+1, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n         proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n         offset += 1;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    for (i = 1; i <= item_count; i++) {",
                "        proto_item_append_text(item, \" [%d]: (%s)\", i, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));"
            ],
            "added_lines": [
                "    for (i = 0; i < item_count; i++) {",
                "        proto_item_append_text(item, \" [%d]: (%s)\", i+1, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7329",
        "func_name": "wireshark/s7comm_decode_req_resp",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-s7comm.c had an infinite loop that was addressed by correcting off-by-one errors.",
        "git_url": "https://github.com/wireshark/wireshark/commit/d8a0cbc4f2979e0b1cadbe79f0b8b4ecb92477be",
        "commit_title": "S7comm: fix range check to prevent infinite loop when upper bound is 255",
        "commit_text": " While we are at it, fix identification of not last element in a few places  Bug: 14423 (cherry picked from commit 5d99febe66e96b55a1defa58a906be254bad3a51) Conflicts: \tepan/dissectors/packet-s7comm.c (cherry picked from commit d24db8ddcdd4cdd5c1ea859da93681b4cc98b399)",
        "func_before": "static guint32\ns7comm_decode_req_resp(tvbuff_t *tvb,\n                       packet_info *pinfo,\n                       proto_tree *tree,\n                       guint16 plength,\n                       guint16 dlength,\n                       guint32 offset,\n                       guint8 rosctr)\n{\n    proto_item *item = NULL;\n    proto_tree *param_tree = NULL;\n    proto_tree *data_tree = NULL;\n    guint8 function = 0;\n    guint8 item_count = 0;\n    guint8 i;\n    guint32 offset_old;\n    guint32 len;\n\n    if (plength > 0) {\n        /* Add parameter tree */\n        item = proto_tree_add_item(tree, hf_s7comm_param, tvb, offset, plength, ENC_NA);\n        param_tree = proto_item_add_subtree(item, ett_s7comm_param);\n        /* Analyze function */\n        function = tvb_get_guint8(tvb, offset);\n        /* add param.function to info column */\n        col_append_fstr(pinfo->cinfo, COL_INFO, \" Function:[%s]\", val_to_str(function, param_functionnames, \"Unknown function: 0x%02x\"));\n        proto_tree_add_uint(param_tree, hf_s7comm_param_service, tvb, offset, 1, function);\n        /* show param.function code at the tree */\n        proto_item_append_text(param_tree, \": (%s)\", val_to_str(function, param_functionnames, \"Unknown function: 0x%02x\"));\n        offset += 1;\n\n        if (rosctr == S7COMM_ROSCTR_JOB) {\n            switch (function){\n                case S7COMM_SERV_READVAR:\n                case S7COMM_SERV_WRITEVAR:\n                    item_count = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(param_tree, hf_s7comm_param_itemcount, tvb, offset, 1, item_count);\n                    offset += 1;\n                    /* parse item data */\n                    for (i = 0; i < item_count; i++) {\n                        offset_old = offset;\n                        offset = s7comm_decode_param_item(tvb, offset, param_tree, i);\n                        /* if length is not a multiple of 2 and this is not the last item, then add a fill-byte */\n                        len = offset - offset_old;\n                        if ((len % 2) && (i < item_count)) {\n                            offset += 1;\n                        }\n                    }\n                    /* in write-function there is a data part */\n                    if ((function == S7COMM_SERV_WRITEVAR) && (dlength > 0)) {\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        /* Add returned data to data-tree */\n                        offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n                    }\n                    break;\n                case S7COMM_SERV_SETUPCOMM:\n                    offset = s7comm_decode_pdu_setup_communication(tvb, param_tree, offset);\n                    break;\n                /* Special functions */\n                case S7COMM_FUNCREQUESTDOWNLOAD:\n                case S7COMM_FUNCDOWNLOADBLOCK:\n                case S7COMM_FUNCDOWNLOADENDED:\n                case S7COMM_FUNCSTARTUPLOAD:\n                case S7COMM_FUNCUPLOAD:\n                case S7COMM_FUNCENDUPLOAD:\n                    offset = s7comm_decode_plc_controls_updownload(tvb, pinfo, tree, param_tree, plength, dlength, offset -1, rosctr);\n                    break;\n                case S7COMM_FUNCPISERVICE:\n                    offset = s7comm_decode_pi_service(tvb, pinfo, param_tree, plength, offset -1);\n                    break;\n                case S7COMM_FUNC_PLC_STOP:\n                    offset = s7comm_decode_plc_controls_param_hex29(tvb, param_tree, offset -1);\n                    break;\n\n                default:\n                    /* Print unknown part as raw bytes */\n                    if (plength > 1) {\n                        proto_tree_add_item(param_tree, hf_s7comm_param_data, tvb, offset, plength - 1, ENC_NA);\n                    }\n                    offset += plength - 1; /* 1 byte function code */\n                    if (dlength > 0) {\n                        /* Add data tree\n                         * First 2 bytes in data seem to be a length indicator of (dlength -4 ), so next 2 bytes\n                         * seem to indicate something else. But I'm not sure, so leave it as it is.....\n                         */\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        proto_tree_add_item(data_tree, hf_s7comm_readresponse_data, tvb, offset, dlength, ENC_NA);\n                        offset += dlength;\n                    }\n                    break;\n            }\n        } else if (rosctr == S7COMM_ROSCTR_ACK_DATA) {\n            switch (function){\n                case S7COMM_SERV_READVAR:\n                case S7COMM_SERV_WRITEVAR:\n                    /* This is a read-response, so the requested data may follow when address in request was ok */\n                    item_count = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(param_tree, hf_s7comm_param_itemcount, tvb, offset, 1, item_count);\n                    offset += 1;\n                    /* Add data tree */\n                    item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                    data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                    /* Add returned data to data-tree */\n                    if ((function == S7COMM_SERV_READVAR) && (dlength > 0)) {\n                        offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n                    } else if ((function == S7COMM_SERV_WRITEVAR) && (dlength > 0)) {\n                        offset = s7comm_decode_response_write_data(tvb, data_tree, item_count, offset);\n                    }\n                    break;\n                case S7COMM_SERV_SETUPCOMM:\n                    offset = s7comm_decode_pdu_setup_communication(tvb, param_tree, offset);\n                    break;\n                case S7COMM_FUNCREQUESTDOWNLOAD:\n                case S7COMM_FUNCDOWNLOADBLOCK:\n                case S7COMM_FUNCDOWNLOADENDED:\n                case S7COMM_FUNCSTARTUPLOAD:\n                case S7COMM_FUNCUPLOAD:\n                case S7COMM_FUNCENDUPLOAD:\n                    offset = s7comm_decode_plc_controls_updownload(tvb, pinfo, tree, param_tree, plength, dlength, offset -1, rosctr);\n                    break;\n                case S7COMM_FUNCPISERVICE:\n                    if (plength >= 2) {\n                        proto_tree_add_bitmask(param_tree, tvb, offset, hf_s7comm_data_blockcontrol_functionstatus,\n                            ett_s7comm_data_blockcontrol_status, s7comm_data_blockcontrol_status_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    break;\n                default:\n                    /* Print unknown part as raw bytes */\n                    if (plength > 1) {\n                        proto_tree_add_item(param_tree, hf_s7comm_param_data, tvb, offset, plength - 1, ENC_NA);\n                    }\n                    offset += plength - 1; /* 1 byte function code */\n                    if (dlength > 0) {\n                        /* Add data tree\n                         * First 2 bytes in data seem to be a length indicator of (dlength -4 ), so next 2 bytes\n                         * seem to indicate something else. But I'm not sure, so leave it as it is.....\n                         */\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        proto_tree_add_item(data_tree, hf_s7comm_readresponse_data, tvb, offset, dlength, ENC_NA);\n                        offset += dlength;\n                    }\n                    break;\n            }\n        }\n    }\n    return offset;\n}",
        "func": "static guint32\ns7comm_decode_req_resp(tvbuff_t *tvb,\n                       packet_info *pinfo,\n                       proto_tree *tree,\n                       guint16 plength,\n                       guint16 dlength,\n                       guint32 offset,\n                       guint8 rosctr)\n{\n    proto_item *item = NULL;\n    proto_tree *param_tree = NULL;\n    proto_tree *data_tree = NULL;\n    guint8 function = 0;\n    guint8 item_count = 0;\n    guint8 i;\n    guint32 offset_old;\n    guint32 len;\n\n    if (plength > 0) {\n        /* Add parameter tree */\n        item = proto_tree_add_item(tree, hf_s7comm_param, tvb, offset, plength, ENC_NA);\n        param_tree = proto_item_add_subtree(item, ett_s7comm_param);\n        /* Analyze function */\n        function = tvb_get_guint8(tvb, offset);\n        /* add param.function to info column */\n        col_append_fstr(pinfo->cinfo, COL_INFO, \" Function:[%s]\", val_to_str(function, param_functionnames, \"Unknown function: 0x%02x\"));\n        proto_tree_add_uint(param_tree, hf_s7comm_param_service, tvb, offset, 1, function);\n        /* show param.function code at the tree */\n        proto_item_append_text(param_tree, \": (%s)\", val_to_str(function, param_functionnames, \"Unknown function: 0x%02x\"));\n        offset += 1;\n\n        if (rosctr == S7COMM_ROSCTR_JOB) {\n            switch (function){\n                case S7COMM_SERV_READVAR:\n                case S7COMM_SERV_WRITEVAR:\n                    item_count = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(param_tree, hf_s7comm_param_itemcount, tvb, offset, 1, item_count);\n                    offset += 1;\n                    /* parse item data */\n                    for (i = 0; i < item_count; i++) {\n                        offset_old = offset;\n                        offset = s7comm_decode_param_item(tvb, offset, param_tree, i);\n                        /* if length is not a multiple of 2 and this is not the last item, then add a fill-byte */\n                        len = offset - offset_old;\n                        if ((len % 2) && (i < (item_count-1))) {\n                            offset += 1;\n                        }\n                    }\n                    /* in write-function there is a data part */\n                    if ((function == S7COMM_SERV_WRITEVAR) && (dlength > 0)) {\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        /* Add returned data to data-tree */\n                        offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n                    }\n                    break;\n                case S7COMM_SERV_SETUPCOMM:\n                    offset = s7comm_decode_pdu_setup_communication(tvb, param_tree, offset);\n                    break;\n                /* Special functions */\n                case S7COMM_FUNCREQUESTDOWNLOAD:\n                case S7COMM_FUNCDOWNLOADBLOCK:\n                case S7COMM_FUNCDOWNLOADENDED:\n                case S7COMM_FUNCSTARTUPLOAD:\n                case S7COMM_FUNCUPLOAD:\n                case S7COMM_FUNCENDUPLOAD:\n                    offset = s7comm_decode_plc_controls_updownload(tvb, pinfo, tree, param_tree, plength, dlength, offset -1, rosctr);\n                    break;\n                case S7COMM_FUNCPISERVICE:\n                    offset = s7comm_decode_pi_service(tvb, pinfo, param_tree, plength, offset -1);\n                    break;\n                case S7COMM_FUNC_PLC_STOP:\n                    offset = s7comm_decode_plc_controls_param_hex29(tvb, param_tree, offset -1);\n                    break;\n\n                default:\n                    /* Print unknown part as raw bytes */\n                    if (plength > 1) {\n                        proto_tree_add_item(param_tree, hf_s7comm_param_data, tvb, offset, plength - 1, ENC_NA);\n                    }\n                    offset += plength - 1; /* 1 byte function code */\n                    if (dlength > 0) {\n                        /* Add data tree\n                         * First 2 bytes in data seem to be a length indicator of (dlength -4 ), so next 2 bytes\n                         * seem to indicate something else. But I'm not sure, so leave it as it is.....\n                         */\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        proto_tree_add_item(data_tree, hf_s7comm_readresponse_data, tvb, offset, dlength, ENC_NA);\n                        offset += dlength;\n                    }\n                    break;\n            }\n        } else if (rosctr == S7COMM_ROSCTR_ACK_DATA) {\n            switch (function){\n                case S7COMM_SERV_READVAR:\n                case S7COMM_SERV_WRITEVAR:\n                    /* This is a read-response, so the requested data may follow when address in request was ok */\n                    item_count = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(param_tree, hf_s7comm_param_itemcount, tvb, offset, 1, item_count);\n                    offset += 1;\n                    /* Add data tree */\n                    item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                    data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                    /* Add returned data to data-tree */\n                    if ((function == S7COMM_SERV_READVAR) && (dlength > 0)) {\n                        offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n                    } else if ((function == S7COMM_SERV_WRITEVAR) && (dlength > 0)) {\n                        offset = s7comm_decode_response_write_data(tvb, data_tree, item_count, offset);\n                    }\n                    break;\n                case S7COMM_SERV_SETUPCOMM:\n                    offset = s7comm_decode_pdu_setup_communication(tvb, param_tree, offset);\n                    break;\n                case S7COMM_FUNCREQUESTDOWNLOAD:\n                case S7COMM_FUNCDOWNLOADBLOCK:\n                case S7COMM_FUNCDOWNLOADENDED:\n                case S7COMM_FUNCSTARTUPLOAD:\n                case S7COMM_FUNCUPLOAD:\n                case S7COMM_FUNCENDUPLOAD:\n                    offset = s7comm_decode_plc_controls_updownload(tvb, pinfo, tree, param_tree, plength, dlength, offset -1, rosctr);\n                    break;\n                case S7COMM_FUNCPISERVICE:\n                    if (plength >= 2) {\n                        proto_tree_add_bitmask(param_tree, tvb, offset, hf_s7comm_data_blockcontrol_functionstatus,\n                            ett_s7comm_data_blockcontrol_status, s7comm_data_blockcontrol_status_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    break;\n                default:\n                    /* Print unknown part as raw bytes */\n                    if (plength > 1) {\n                        proto_tree_add_item(param_tree, hf_s7comm_param_data, tvb, offset, plength - 1, ENC_NA);\n                    }\n                    offset += plength - 1; /* 1 byte function code */\n                    if (dlength > 0) {\n                        /* Add data tree\n                         * First 2 bytes in data seem to be a length indicator of (dlength -4 ), so next 2 bytes\n                         * seem to indicate something else. But I'm not sure, so leave it as it is.....\n                         */\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        proto_tree_add_item(data_tree, hf_s7comm_readresponse_data, tvb, offset, dlength, ENC_NA);\n                        offset += dlength;\n                    }\n                    break;\n            }\n        }\n    }\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -42,7 +42,7 @@\n                         offset = s7comm_decode_param_item(tvb, offset, param_tree, i);\n                         /* if length is not a multiple of 2 and this is not the last item, then add a fill-byte */\n                         len = offset - offset_old;\n-                        if ((len % 2) && (i < item_count)) {\n+                        if ((len % 2) && (i < (item_count-1))) {\n                             offset += 1;\n                         }\n                     }",
        "diff_line_info": {
            "deleted_lines": [
                "                        if ((len % 2) && (i < item_count)) {"
            ],
            "added_lines": [
                "                        if ((len % 2) && (i < (item_count-1))) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7329",
        "func_name": "wireshark/s7comm_decode_ud_cyclic_subfunc",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-s7comm.c had an infinite loop that was addressed by correcting off-by-one errors.",
        "git_url": "https://github.com/wireshark/wireshark/commit/d8a0cbc4f2979e0b1cadbe79f0b8b4ecb92477be",
        "commit_title": "S7comm: fix range check to prevent infinite loop when upper bound is 255",
        "commit_text": " While we are at it, fix identification of not last element in a few places  Bug: 14423 (cherry picked from commit 5d99febe66e96b55a1defa58a906be254bad3a51) Conflicts: \tepan/dissectors/packet-s7comm.c (cherry picked from commit d24db8ddcdd4cdd5c1ea859da93681b4cc98b399)",
        "func_before": "static guint32\ns7comm_decode_ud_cyclic_subfunc(tvbuff_t *tvb,\n                                proto_tree *data_tree,\n                                guint8 type,                /* Type of data (request/response) */\n                                guint8 subfunc,             /* Subfunction */\n                                guint16 dlength,            /* length of data part given in header */\n                                guint32 offset)             /* Offset on data part +4 */\n{\n    gboolean know_data = FALSE;\n    guint32 offset_old;\n    guint32 len_item;\n    guint8 item_count;\n    guint8 i;\n\n    switch (subfunc)\n    {\n        case S7COMM_UD_SUBF_CYCLIC_MEM:\n            item_count = tvb_get_guint8(tvb, offset + 1);     /* first byte reserved??? */\n            proto_tree_add_uint(data_tree, hf_s7comm_param_itemcount, tvb, offset, 2, item_count);\n            offset += 2;\n            if (type == S7COMM_UD_TYPE_REQ) {                   /* Request to PLC to send cyclic data */\n                proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_timebase, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_time, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                /* parse item data */\n                for (i = 0; i < item_count; i++) {\n                    offset_old = offset;\n                    offset = s7comm_decode_param_item(tvb, offset, data_tree, i);\n                    /* if length is not a multiple of 2 and this is not the last item, then add a fill-byte */\n                    len_item = offset - offset_old;\n                    if ((len_item % 2) && (i < item_count)) {\n                        offset += 1;\n                    }\n                }\n\n            } else if (type == S7COMM_UD_TYPE_RES || type == S7COMM_UD_TYPE_PUSH) {   /* Response from PLC with the requested data */\n                /* parse item data */\n                offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n            }\n            know_data = TRUE;\n            break;\n    }\n\n    if (know_data == FALSE && dlength > 4) {\n        proto_tree_add_item(data_tree, hf_s7comm_userdata_data, tvb, offset, dlength - 4, ENC_NA);\n        offset += dlength;\n    }\n    return offset;\n}",
        "func": "static guint32\ns7comm_decode_ud_cyclic_subfunc(tvbuff_t *tvb,\n                                proto_tree *data_tree,\n                                guint8 type,                /* Type of data (request/response) */\n                                guint8 subfunc,             /* Subfunction */\n                                guint16 dlength,            /* length of data part given in header */\n                                guint32 offset)             /* Offset on data part +4 */\n{\n    gboolean know_data = FALSE;\n    guint32 offset_old;\n    guint32 len_item;\n    guint8 item_count;\n    guint8 i;\n\n    switch (subfunc)\n    {\n        case S7COMM_UD_SUBF_CYCLIC_MEM:\n            item_count = tvb_get_guint8(tvb, offset + 1);     /* first byte reserved??? */\n            proto_tree_add_uint(data_tree, hf_s7comm_param_itemcount, tvb, offset, 2, item_count);\n            offset += 2;\n            if (type == S7COMM_UD_TYPE_REQ) {                   /* Request to PLC to send cyclic data */\n                proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_timebase, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_time, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                /* parse item data */\n                for (i = 0; i < item_count; i++) {\n                    offset_old = offset;\n                    offset = s7comm_decode_param_item(tvb, offset, data_tree, i);\n                    /* if length is not a multiple of 2 and this is not the last item, then add a fill-byte */\n                    len_item = offset - offset_old;\n                    if ((len_item % 2) && (i < (item_count-1))) {\n                        offset += 1;\n                    }\n                }\n\n            } else if (type == S7COMM_UD_TYPE_RES || type == S7COMM_UD_TYPE_PUSH) {   /* Response from PLC with the requested data */\n                /* parse item data */\n                offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n            }\n            know_data = TRUE;\n            break;\n    }\n\n    if (know_data == FALSE && dlength > 4) {\n        proto_tree_add_item(data_tree, hf_s7comm_userdata_data, tvb, offset, dlength - 4, ENC_NA);\n        offset += dlength;\n    }\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,7 +29,7 @@\n                     offset = s7comm_decode_param_item(tvb, offset, data_tree, i);\n                     /* if length is not a multiple of 2 and this is not the last item, then add a fill-byte */\n                     len_item = offset - offset_old;\n-                    if ((len_item % 2) && (i < item_count)) {\n+                    if ((len_item % 2) && (i < (item_count-1))) {\n                         offset += 1;\n                     }\n                 }",
        "diff_line_info": {
            "deleted_lines": [
                "                    if ((len_item % 2) && (i < item_count)) {"
            ],
            "added_lines": [
                "                    if ((len_item % 2) && (i < (item_count-1))) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7329",
        "func_name": "wireshark/s7comm_decode_response_read_data",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-s7comm.c had an infinite loop that was addressed by correcting off-by-one errors.",
        "git_url": "https://github.com/wireshark/wireshark/commit/d8a0cbc4f2979e0b1cadbe79f0b8b4ecb92477be",
        "commit_title": "S7comm: fix range check to prevent infinite loop when upper bound is 255",
        "commit_text": " While we are at it, fix identification of not last element in a few places  Bug: 14423 (cherry picked from commit 5d99febe66e96b55a1defa58a906be254bad3a51) Conflicts: \tepan/dissectors/packet-s7comm.c (cherry picked from commit d24db8ddcdd4cdd5c1ea859da93681b4cc98b399)",
        "func_before": "static guint32\ns7comm_decode_response_read_data(tvbuff_t *tvb,\n                                 proto_tree *tree,\n                                 guint8 item_count,\n                                 guint32 offset)\n{\n    guint8 ret_val = 0;\n    guint8 tsize = 0;\n    guint16 len = 0, len2 = 0;\n    guint16 head_len = 4;           /* 1 byte res-code, 1 byte transp-size, 2 bytes len */\n    guint8 i = 0;\n    proto_item *item = NULL;\n    proto_tree *item_tree = NULL;\n\n    for (i = 1; i <= item_count; i++) {\n        ret_val = tvb_get_guint8(tvb, offset);\n        if (ret_val == S7COMM_ITEM_RETVAL_RESERVED ||\n            ret_val == S7COMM_ITEM_RETVAL_DATA_OK ||\n            ret_val == S7COMM_ITEM_RETVAL_DATA_ERR\n            ) {\n            tsize = tvb_get_guint8(tvb, offset + 1);\n            len = tvb_get_ntohs(tvb, offset + 2);\n            /* calculate length in bytes */\n            if (tsize == S7COMM_DATA_TRANSPORT_SIZE_BBIT ||\n                tsize == S7COMM_DATA_TRANSPORT_SIZE_BBYTE ||\n                tsize == S7COMM_DATA_TRANSPORT_SIZE_BINT\n                ) {     /* given length is in number of bits */\n                if (len % 8) { /* len is not a multiple of 8, then round up to next number */\n                    len /= 8;\n                    len = len + 1;\n                } else {\n                    len /= 8;\n                }\n            }\n\n            /* the PLC places extra bytes at the end of all but last result, if length is not a multiple of 2 */\n            if ((len % 2) && (i < item_count)) {\n                len2 = len + 1;\n            } else {\n                len2 = len;\n            }\n        }\n        /* Insert a new tree for every item */\n        item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, len + head_len, ENC_NA);\n        item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n        proto_item_append_text(item, \" [%d]: (%s)\", i, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n\n        proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n        proto_tree_add_uint(item_tree, hf_s7comm_data_transport_size, tvb, offset + 1, 1, tsize);\n        proto_tree_add_uint(item_tree, hf_s7comm_data_length, tvb, offset + 2, 2, len);\n        offset += head_len;\n\n        if (ret_val == S7COMM_ITEM_RETVAL_DATA_OK || ret_val == S7COMM_ITEM_RETVAL_RESERVED) {\n            proto_tree_add_item(item_tree, hf_s7comm_readresponse_data, tvb, offset, len, ENC_NA);\n            offset += len;\n            if (len != len2) {\n                proto_tree_add_item(item_tree, hf_s7comm_data_fillbyte, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n            }\n        }\n    }\n    return offset;\n}",
        "func": "static guint32\ns7comm_decode_response_read_data(tvbuff_t *tvb,\n                                 proto_tree *tree,\n                                 guint8 item_count,\n                                 guint32 offset)\n{\n    guint8 ret_val = 0;\n    guint8 tsize = 0;\n    guint16 len = 0, len2 = 0;\n    guint16 head_len = 4;           /* 1 byte res-code, 1 byte transp-size, 2 bytes len */\n    guint8 i = 0;\n    proto_item *item = NULL;\n    proto_tree *item_tree = NULL;\n\n    for (i = 0; i < item_count; i++) {\n        ret_val = tvb_get_guint8(tvb, offset);\n        if (ret_val == S7COMM_ITEM_RETVAL_RESERVED ||\n            ret_val == S7COMM_ITEM_RETVAL_DATA_OK ||\n            ret_val == S7COMM_ITEM_RETVAL_DATA_ERR\n            ) {\n            tsize = tvb_get_guint8(tvb, offset + 1);\n            len = tvb_get_ntohs(tvb, offset + 2);\n            /* calculate length in bytes */\n            if (tsize == S7COMM_DATA_TRANSPORT_SIZE_BBIT ||\n                tsize == S7COMM_DATA_TRANSPORT_SIZE_BBYTE ||\n                tsize == S7COMM_DATA_TRANSPORT_SIZE_BINT\n                ) {     /* given length is in number of bits */\n                if (len % 8) { /* len is not a multiple of 8, then round up to next number */\n                    len /= 8;\n                    len = len + 1;\n                } else {\n                    len /= 8;\n                }\n            }\n\n            /* the PLC places extra bytes at the end of all but last result, if length is not a multiple of 2 */\n            if ((len % 2) && (i < (item_count-1))) {\n                len2 = len + 1;\n            } else {\n                len2 = len;\n            }\n        }\n        /* Insert a new tree for every item */\n        item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, len + head_len, ENC_NA);\n        item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n        proto_item_append_text(item, \" [%d]: (%s)\", i+1, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n\n        proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n        proto_tree_add_uint(item_tree, hf_s7comm_data_transport_size, tvb, offset + 1, 1, tsize);\n        proto_tree_add_uint(item_tree, hf_s7comm_data_length, tvb, offset + 2, 2, len);\n        offset += head_len;\n\n        if (ret_val == S7COMM_ITEM_RETVAL_DATA_OK || ret_val == S7COMM_ITEM_RETVAL_RESERVED) {\n            proto_tree_add_item(item_tree, hf_s7comm_readresponse_data, tvb, offset, len, ENC_NA);\n            offset += len;\n            if (len != len2) {\n                proto_tree_add_item(item_tree, hf_s7comm_data_fillbyte, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n            }\n        }\n    }\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n     proto_item *item = NULL;\n     proto_tree *item_tree = NULL;\n \n-    for (i = 1; i <= item_count; i++) {\n+    for (i = 0; i < item_count; i++) {\n         ret_val = tvb_get_guint8(tvb, offset);\n         if (ret_val == S7COMM_ITEM_RETVAL_RESERVED ||\n             ret_val == S7COMM_ITEM_RETVAL_DATA_OK ||\n@@ -34,7 +34,7 @@\n             }\n \n             /* the PLC places extra bytes at the end of all but last result, if length is not a multiple of 2 */\n-            if ((len % 2) && (i < item_count)) {\n+            if ((len % 2) && (i < (item_count-1))) {\n                 len2 = len + 1;\n             } else {\n                 len2 = len;\n@@ -43,7 +43,7 @@\n         /* Insert a new tree for every item */\n         item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, len + head_len, ENC_NA);\n         item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n-        proto_item_append_text(item, \" [%d]: (%s)\", i, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n+        proto_item_append_text(item, \" [%d]: (%s)\", i+1, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n \n         proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n         proto_tree_add_uint(item_tree, hf_s7comm_data_transport_size, tvb, offset + 1, 1, tsize);",
        "diff_line_info": {
            "deleted_lines": [
                "    for (i = 1; i <= item_count; i++) {",
                "            if ((len % 2) && (i < item_count)) {",
                "        proto_item_append_text(item, \" [%d]: (%s)\", i, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));"
            ],
            "added_lines": [
                "    for (i = 0; i < item_count; i++) {",
                "            if ((len % 2) && (i < (item_count-1))) {",
                "        proto_item_append_text(item, \" [%d]: (%s)\", i+1, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7329",
        "func_name": "wireshark/s7comm_decode_ud_cpu_alarm_main",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-s7comm.c had an infinite loop that was addressed by correcting off-by-one errors.",
        "git_url": "https://github.com/wireshark/wireshark/commit/d8a0cbc4f2979e0b1cadbe79f0b8b4ecb92477be",
        "commit_title": "S7comm: fix range check to prevent infinite loop when upper bound is 255",
        "commit_text": " While we are at it, fix identification of not last element in a few places  Bug: 14423 (cherry picked from commit 5d99febe66e96b55a1defa58a906be254bad3a51) Conflicts: \tepan/dissectors/packet-s7comm.c (cherry picked from commit d24db8ddcdd4cdd5c1ea859da93681b4cc98b399)",
        "func_before": "static guint32\ns7comm_decode_ud_cpu_alarm_main(tvbuff_t *tvb,\n                                packet_info *pinfo,\n                                proto_tree *data_tree,\n                                guint8 type,                /* Type of data (request/response) */\n                                guint8 subfunc,             /* Subfunction */\n                                guint32 offset)             /* Offset on data part +4 */\n{\n    guint32 start_offset;\n    guint32 asc_start_offset;\n    guint32 msg_obj_start_offset;\n    guint32 ev_id;\n    proto_item *msg_item = NULL;\n    proto_tree *msg_item_tree = NULL;\n    proto_item *msg_obj_item = NULL;\n    proto_tree *msg_obj_item_tree = NULL;\n    proto_item *msg_work_item = NULL;\n    proto_tree *msg_work_item_tree = NULL;\n    guint8 nr_objects;\n    guint8 i;\n    guint8 syntax_id;\n    guint8 nr_of_additional_values;\n    guint8 signalstate;\n    guint8 sig_nr;\n    guint8 ret_val;\n    guint8 querytype;\n    guint8 varspec_length;\n\n    start_offset = offset;\n\n    msg_item = proto_tree_add_item(data_tree, hf_s7comm_cpu_alarm_message_item, tvb, offset, 0, ENC_NA);\n    msg_item_tree = proto_item_add_subtree(msg_item, ett_s7comm_cpu_alarm_message);\n\n    if (subfunc == S7COMM_UD_SUBF_CPU_ALARM8_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMACK_IND ||\n        subfunc == S7COMM_UD_SUBF_CPU_ALARMSQ_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMS_IND ||\n        subfunc == S7COMM_UD_SUBF_CPU_NOTIFY_IND || subfunc == S7COMM_UD_SUBF_CPU_NOTIFY8_IND) {\n        msg_work_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_timestamp_coming, tvb, offset, 8, ENC_NA);\n        msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_timestamp);\n        offset = s7comm_add_timestamp_to_tree(tvb, msg_work_item_tree, offset, TRUE, FALSE);\n    }\n    proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_function, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n    nr_objects = tvb_get_guint8(tvb, offset);\n    proto_tree_add_uint(msg_item_tree, hf_s7comm_cpu_alarm_message_nr_objects, tvb, offset, 1, nr_objects);\n    offset += 1;\n    for (i = 1; i <= nr_objects; i++) {\n        msg_obj_start_offset = offset;\n        msg_obj_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_obj_item, tvb, offset, 0, ENC_NA);\n        msg_obj_item_tree = proto_item_add_subtree(msg_obj_item, ett_s7comm_cpu_alarm_message_object);\n        proto_item_append_text(msg_obj_item_tree, \" [%d]\", i);\n        if (type == S7COMM_UD_TYPE_REQ || type == S7COMM_UD_TYPE_PUSH) {\n            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_item_varspec, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset += 1;\n            varspec_length = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_varspec_length, tvb, offset, 1, varspec_length);\n            offset += 1;\n            syntax_id = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_syntax_id, tvb, offset, 1, syntax_id);\n            offset += 1;\n            switch (syntax_id) {\n                case S7COMM_SYNTAXID_ALARM_LOCKFREESET:\n                case S7COMM_SYNTAXID_ALARM_INDSET:\n                case S7COMM_SYNTAXID_NOTIFY_INDSET:\n                case S7COMM_SYNTAXID_ALARM_ACKSET:\n                    nr_of_additional_values = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_nr_add_values, tvb, offset, 1, nr_of_additional_values);\n                    offset += 1;\n                    ev_id = tvb_get_ntohl(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ev_id);\n                    offset += 4;\n                    proto_item_append_text(msg_obj_item_tree, \": EventID=0x%08x\", ev_id);\n                    col_append_fstr(pinfo->cinfo, COL_INFO, \" EventID=0x%08x\", ev_id);\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        signalstate = tvb_get_guint8(tvb, offset);\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_eventstate,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        /* show SIG with True values for a quick overview in info-column */\n                        if (signalstate > 0) {\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \" On=[\");\n                            for (sig_nr = 0; sig_nr < 8; sig_nr++) {\n                                if (signalstate & 0x01) {\n                                    signalstate >>= 1;\n                                    if (signalstate == 0) {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \"SIG_%d\", sig_nr + 1);\n                                    } else {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \"SIG_%d,\", sig_nr + 1);\n                                    }\n                                } else {\n                                    signalstate >>= 1;\n                                }\n                            }\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \"]\");\n                        }\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_state,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_ALARM_ACKSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_going,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_coming,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_going,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_coming,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_lastchanged,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_event_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        if (nr_of_additional_values > 0) {\n                            asc_start_offset = offset;\n                            msg_work_item = proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_associated_value, tvb, offset, 0, ENC_NA);\n                            msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_associated_value);\n                            offset = s7comm_decode_response_read_data(tvb, msg_work_item_tree, nr_of_additional_values, offset);\n                            proto_item_set_len(msg_work_item_tree, offset - asc_start_offset);\n                        }\n                    }\n                    break;\n                case S7COMM_SYNTAXID_ALARM_QUERYREQSET:\n                    proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown1, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset += 1;\n                    querytype = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_querytype, tvb, offset, 1, querytype);\n                    offset += 1;\n                    proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown2, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset += 1;\n                    ev_id = tvb_get_ntohl(tvb, offset);\n                    /* there is a querytype=8, which only occurs when a previous SZL request 0x131 index 0x10 has a missing flag in funk_1 */\n                    switch (querytype) {\n                        case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYALARMTYPE:\n                            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_alarmtype, tvb, offset, 4, ENC_BIG_ENDIAN);\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \" ByAlarmtype=%s\",\n                                val_to_str(ev_id, alarm_message_query_alarmtype_names, \"Unknown Alarmtype: %u\"));\n                            break;\n                        case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYEVENTID:\n                            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ENC_BIG_ENDIAN);\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \" ByEventID=0x%08x\", ev_id);\n                            break;\n                        default:\n                            break;\n                    }\n                    offset += 4;\n                    break;\n                default:\n                    /* for current unknown syntax id, set offset to end of dataset. The varspec_length includes\n                     * the byte for the syntax_id, so minus one.\n                     */\n                    offset += (varspec_length - 1);\n                    break;\n            }\n        } else if (type == S7COMM_UD_TYPE_RES) {\n            ret_val = tvb_get_guint8(tvb, offset);\n            proto_item_append_text(msg_obj_item_tree, \": (%s)\", val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n            offset += 1;\n        }\n        proto_item_set_len(msg_obj_item_tree, offset - msg_obj_start_offset);\n    }\n    proto_item_set_len(msg_item_tree, offset - start_offset);\n    return offset;\n}",
        "func": "static guint32\ns7comm_decode_ud_cpu_alarm_main(tvbuff_t *tvb,\n                                packet_info *pinfo,\n                                proto_tree *data_tree,\n                                guint8 type,                /* Type of data (request/response) */\n                                guint8 subfunc,             /* Subfunction */\n                                guint32 offset)             /* Offset on data part +4 */\n{\n    guint32 start_offset;\n    guint32 asc_start_offset;\n    guint32 msg_obj_start_offset;\n    guint32 ev_id;\n    proto_item *msg_item = NULL;\n    proto_tree *msg_item_tree = NULL;\n    proto_item *msg_obj_item = NULL;\n    proto_tree *msg_obj_item_tree = NULL;\n    proto_item *msg_work_item = NULL;\n    proto_tree *msg_work_item_tree = NULL;\n    guint8 nr_objects;\n    guint8 i;\n    guint8 syntax_id;\n    guint8 nr_of_additional_values;\n    guint8 signalstate;\n    guint8 sig_nr;\n    guint8 ret_val;\n    guint8 querytype;\n    guint8 varspec_length;\n\n    start_offset = offset;\n\n    msg_item = proto_tree_add_item(data_tree, hf_s7comm_cpu_alarm_message_item, tvb, offset, 0, ENC_NA);\n    msg_item_tree = proto_item_add_subtree(msg_item, ett_s7comm_cpu_alarm_message);\n\n    if (subfunc == S7COMM_UD_SUBF_CPU_ALARM8_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMACK_IND ||\n        subfunc == S7COMM_UD_SUBF_CPU_ALARMSQ_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMS_IND ||\n        subfunc == S7COMM_UD_SUBF_CPU_NOTIFY_IND || subfunc == S7COMM_UD_SUBF_CPU_NOTIFY8_IND) {\n        msg_work_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_timestamp_coming, tvb, offset, 8, ENC_NA);\n        msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_timestamp);\n        offset = s7comm_add_timestamp_to_tree(tvb, msg_work_item_tree, offset, TRUE, FALSE);\n    }\n    proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_function, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n    nr_objects = tvb_get_guint8(tvb, offset);\n    proto_tree_add_uint(msg_item_tree, hf_s7comm_cpu_alarm_message_nr_objects, tvb, offset, 1, nr_objects);\n    offset += 1;\n    for (i = 0; i < nr_objects; i++) {\n        msg_obj_start_offset = offset;\n        msg_obj_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_obj_item, tvb, offset, 0, ENC_NA);\n        msg_obj_item_tree = proto_item_add_subtree(msg_obj_item, ett_s7comm_cpu_alarm_message_object);\n        proto_item_append_text(msg_obj_item_tree, \" [%d]\", i+1);\n        if (type == S7COMM_UD_TYPE_REQ || type == S7COMM_UD_TYPE_PUSH) {\n            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_item_varspec, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset += 1;\n            varspec_length = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_varspec_length, tvb, offset, 1, varspec_length);\n            offset += 1;\n            syntax_id = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_syntax_id, tvb, offset, 1, syntax_id);\n            offset += 1;\n            switch (syntax_id) {\n                case S7COMM_SYNTAXID_ALARM_LOCKFREESET:\n                case S7COMM_SYNTAXID_ALARM_INDSET:\n                case S7COMM_SYNTAXID_NOTIFY_INDSET:\n                case S7COMM_SYNTAXID_ALARM_ACKSET:\n                    nr_of_additional_values = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_nr_add_values, tvb, offset, 1, nr_of_additional_values);\n                    offset += 1;\n                    ev_id = tvb_get_ntohl(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ev_id);\n                    offset += 4;\n                    proto_item_append_text(msg_obj_item_tree, \": EventID=0x%08x\", ev_id);\n                    col_append_fstr(pinfo->cinfo, COL_INFO, \" EventID=0x%08x\", ev_id);\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        signalstate = tvb_get_guint8(tvb, offset);\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_eventstate,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        /* show SIG with True values for a quick overview in info-column */\n                        if (signalstate > 0) {\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \" On=[\");\n                            for (sig_nr = 0; sig_nr < 8; sig_nr++) {\n                                if (signalstate & 0x01) {\n                                    signalstate >>= 1;\n                                    if (signalstate == 0) {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \"SIG_%d\", sig_nr + 1);\n                                    } else {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \"SIG_%d,\", sig_nr + 1);\n                                    }\n                                } else {\n                                    signalstate >>= 1;\n                                }\n                            }\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \"]\");\n                        }\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_state,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_ALARM_ACKSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_going,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_coming,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_going,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_coming,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_lastchanged,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_event_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        if (nr_of_additional_values > 0) {\n                            asc_start_offset = offset;\n                            msg_work_item = proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_associated_value, tvb, offset, 0, ENC_NA);\n                            msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_associated_value);\n                            offset = s7comm_decode_response_read_data(tvb, msg_work_item_tree, nr_of_additional_values, offset);\n                            proto_item_set_len(msg_work_item_tree, offset - asc_start_offset);\n                        }\n                    }\n                    break;\n                case S7COMM_SYNTAXID_ALARM_QUERYREQSET:\n                    proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown1, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset += 1;\n                    querytype = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_querytype, tvb, offset, 1, querytype);\n                    offset += 1;\n                    proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown2, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset += 1;\n                    ev_id = tvb_get_ntohl(tvb, offset);\n                    /* there is a querytype=8, which only occurs when a previous SZL request 0x131 index 0x10 has a missing flag in funk_1 */\n                    switch (querytype) {\n                        case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYALARMTYPE:\n                            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_alarmtype, tvb, offset, 4, ENC_BIG_ENDIAN);\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \" ByAlarmtype=%s\",\n                                val_to_str(ev_id, alarm_message_query_alarmtype_names, \"Unknown Alarmtype: %u\"));\n                            break;\n                        case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYEVENTID:\n                            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ENC_BIG_ENDIAN);\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \" ByEventID=0x%08x\", ev_id);\n                            break;\n                        default:\n                            break;\n                    }\n                    offset += 4;\n                    break;\n                default:\n                    /* for current unknown syntax id, set offset to end of dataset. The varspec_length includes\n                     * the byte for the syntax_id, so minus one.\n                     */\n                    offset += (varspec_length - 1);\n                    break;\n            }\n        } else if (type == S7COMM_UD_TYPE_RES) {\n            ret_val = tvb_get_guint8(tvb, offset);\n            proto_item_append_text(msg_obj_item_tree, \": (%s)\", val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n            offset += 1;\n        }\n        proto_item_set_len(msg_obj_item_tree, offset - msg_obj_start_offset);\n    }\n    proto_item_set_len(msg_item_tree, offset - start_offset);\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -43,11 +43,11 @@\n     nr_objects = tvb_get_guint8(tvb, offset);\n     proto_tree_add_uint(msg_item_tree, hf_s7comm_cpu_alarm_message_nr_objects, tvb, offset, 1, nr_objects);\n     offset += 1;\n-    for (i = 1; i <= nr_objects; i++) {\n+    for (i = 0; i < nr_objects; i++) {\n         msg_obj_start_offset = offset;\n         msg_obj_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_obj_item, tvb, offset, 0, ENC_NA);\n         msg_obj_item_tree = proto_item_add_subtree(msg_obj_item, ett_s7comm_cpu_alarm_message_object);\n-        proto_item_append_text(msg_obj_item_tree, \" [%d]\", i);\n+        proto_item_append_text(msg_obj_item_tree, \" [%d]\", i+1);\n         if (type == S7COMM_UD_TYPE_REQ || type == S7COMM_UD_TYPE_PUSH) {\n             proto_tree_add_item(msg_obj_item_tree, hf_s7comm_item_varspec, tvb, offset, 1, ENC_BIG_ENDIAN);\n             offset += 1;",
        "diff_line_info": {
            "deleted_lines": [
                "    for (i = 1; i <= nr_objects; i++) {",
                "        proto_item_append_text(msg_obj_item_tree, \" [%d]\", i);"
            ],
            "added_lines": [
                "    for (i = 0; i < nr_objects; i++) {",
                "        proto_item_append_text(msg_obj_item_tree, \" [%d]\", i+1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-5388",
        "func_name": "qemu/pci_read",
        "description": "Off-by-one error in the pci_read function in the ACPI PCI hotplug interface (hw/acpi/pcihp.c) in QEMU allows local guest users to obtain sensitive information and have other unspecified impact related to a crafted PCI device that triggers memory corruption.",
        "git_url": "https://github.com/qemu/qemu/commit/fa365d7cd11185237471823a5a33d36765454e16",
        "commit_title": "pcihp: fix possible array out of bounds",
        "commit_text": " Prevent out-of-bounds array access on acpi_pcihp_pci_status.  Cc: qemu-stable@nongnu.org",
        "func_before": "static uint64_t pci_read(void *opaque, hwaddr addr, unsigned int size)\n{\n    AcpiPciHpState *s = opaque;\n    uint32_t val = 0;\n    int bsel = s->hotplug_select;\n\n    if (bsel < 0 || bsel > ACPI_PCIHP_MAX_HOTPLUG_BUS) {\n        return 0;\n    }\n\n    switch (addr) {\n    case PCI_UP_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].up;\n        if (!s->legacy_piix) {\n            s->acpi_pcihp_pci_status[bsel].up = 0;\n        }\n        ACPI_PCIHP_DPRINTF(\"pci_up_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_DOWN_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].down;\n        ACPI_PCIHP_DPRINTF(\"pci_down_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_EJ_BASE:\n        /* No feature defined yet */\n        ACPI_PCIHP_DPRINTF(\"pci_features_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_RMV_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].hotplug_enable;\n        ACPI_PCIHP_DPRINTF(\"pci_rmv_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_SEL_BASE:\n        val = s->hotplug_select;\n        ACPI_PCIHP_DPRINTF(\"pci_sel_read %\" PRIu32 \"\\n\", val);\n    default:\n        break;\n    }\n\n    return val;\n}",
        "func": "static uint64_t pci_read(void *opaque, hwaddr addr, unsigned int size)\n{\n    AcpiPciHpState *s = opaque;\n    uint32_t val = 0;\n    int bsel = s->hotplug_select;\n\n    if (bsel < 0 || bsel >= ACPI_PCIHP_MAX_HOTPLUG_BUS) {\n        return 0;\n    }\n\n    switch (addr) {\n    case PCI_UP_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].up;\n        if (!s->legacy_piix) {\n            s->acpi_pcihp_pci_status[bsel].up = 0;\n        }\n        ACPI_PCIHP_DPRINTF(\"pci_up_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_DOWN_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].down;\n        ACPI_PCIHP_DPRINTF(\"pci_down_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_EJ_BASE:\n        /* No feature defined yet */\n        ACPI_PCIHP_DPRINTF(\"pci_features_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_RMV_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].hotplug_enable;\n        ACPI_PCIHP_DPRINTF(\"pci_rmv_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_SEL_BASE:\n        val = s->hotplug_select;\n        ACPI_PCIHP_DPRINTF(\"pci_sel_read %\" PRIu32 \"\\n\", val);\n    default:\n        break;\n    }\n\n    return val;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n     uint32_t val = 0;\n     int bsel = s->hotplug_select;\n \n-    if (bsel < 0 || bsel > ACPI_PCIHP_MAX_HOTPLUG_BUS) {\n+    if (bsel < 0 || bsel >= ACPI_PCIHP_MAX_HOTPLUG_BUS) {\n         return 0;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    if (bsel < 0 || bsel > ACPI_PCIHP_MAX_HOTPLUG_BUS) {"
            ],
            "added_lines": [
                "    if (bsel < 0 || bsel >= ACPI_PCIHP_MAX_HOTPLUG_BUS) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-2955",
        "func_name": "kernel/git/linville/wireless/ioctl_standard_iw_point",
        "description": "The cfg80211_wext_giwessid function in net/wireless/wext-compat.c in the Linux kernel before 2.6.36-rc3-next-20100831 does not properly initialize certain structure members, which allows local users to leverage an off-by-one error in the ioctl_standard_iw_point function in net/wireless/wext-core.c, and obtain potentially sensitive information from kernel heap memory, via vectors involving an SIOCGIWESSID ioctl call that specifies a large buffer size.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/linville/wireless.git;a=commit;h=42da2f948d949efd0111309f5827bf0298bcc9a4",
        "commit_title": "Wireless extensions have an unfortunate, undocumented",
        "commit_text": "requirement which requires drivers to always fill iwp->length when returning a successful status. When a driver doesn't do this, it leads to a kernel heap content leak when userspace offers a larger buffer than would have been necessary.  Arguably, this is a driver bug, as it should, if it returns 0, fill iwp->length, even if it separately indicated that the buffer contents was not valid.  However, we can also at least avoid the memory content leak if the driver doesn't do this by setting the iwp length to max_tokens, which then reflects how big the buffer is that the driver may fill, regardless of how big the userspace buffer is.  To illustrate the point, this patch also fixes a corresponding cfg80211 bug (since this requirement isn't documented nor was ever pointed out by anyone during code review, I don't trust all drivers nor all cfg80211 handlers to implement it correctly).  Cc: stable@kernel.org [all the way back] ",
        "func_before": "static int ioctl_standard_iw_point(struct iw_point *iwp, unsigned int cmd,\n\t\t\t\t   const struct iw_ioctl_description *descr,\n\t\t\t\t   iw_handler handler, struct net_device *dev,\n\t\t\t\t   struct iw_request_info *info)\n{\n\tint err, extra_size, user_length = 0, essid_compat = 0;\n\tchar *extra;\n\n\t/* Calculate space needed by arguments. Always allocate\n\t * for max space.\n\t */\n\textra_size = descr->max_tokens * descr->token_size;\n\n\t/* Check need for ESSID compatibility for WE < 21 */\n\tswitch (cmd) {\n\tcase SIOCSIWESSID:\n\tcase SIOCGIWESSID:\n\tcase SIOCSIWNICKN:\n\tcase SIOCGIWNICKN:\n\t\tif (iwp->length == descr->max_tokens + 1)\n\t\t\tessid_compat = 1;\n\t\telse if (IW_IS_SET(cmd) && (iwp->length != 0)) {\n\t\t\tchar essid[IW_ESSID_MAX_SIZE + 1];\n\t\t\tunsigned int len;\n\t\t\tlen = iwp->length * descr->token_size;\n\n\t\t\tif (len > IW_ESSID_MAX_SIZE)\n\t\t\t\treturn -EFAULT;\n\n\t\t\terr = copy_from_user(essid, iwp->pointer, len);\n\t\t\tif (err)\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (essid[iwp->length - 1] == '\\0')\n\t\t\t\tessid_compat = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tiwp->length -= essid_compat;\n\n\t/* Check what user space is giving us */\n\tif (IW_IS_SET(cmd)) {\n\t\t/* Check NULL pointer */\n\t\tif (!iwp->pointer && iwp->length != 0)\n\t\t\treturn -EFAULT;\n\t\t/* Check if number of token fits within bounds */\n\t\tif (iwp->length > descr->max_tokens)\n\t\t\treturn -E2BIG;\n\t\tif (iwp->length < descr->min_tokens)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t/* Check NULL pointer */\n\t\tif (!iwp->pointer)\n\t\t\treturn -EFAULT;\n\t\t/* Save user space buffer size for checking */\n\t\tuser_length = iwp->length;\n\n\t\t/* Don't check if user_length > max to allow forward\n\t\t * compatibility. The test user_length < min is\n\t\t * implied by the test at the end.\n\t\t */\n\n\t\t/* Support for very large requests */\n\t\tif ((descr->flags & IW_DESCR_FLAG_NOMAX) &&\n\t\t    (user_length > descr->max_tokens)) {\n\t\t\t/* Allow userspace to GET more than max so\n\t\t\t * we can support any size GET requests.\n\t\t\t * There is still a limit : -ENOMEM.\n\t\t\t */\n\t\t\textra_size = user_length * descr->token_size;\n\n\t\t\t/* Note : user_length is originally a __u16,\n\t\t\t * and token_size is controlled by us,\n\t\t\t * so extra_size won't get negative and\n\t\t\t * won't overflow...\n\t\t\t */\n\t\t}\n\t}\n\n\t/* kzalloc() ensures NULL-termination for essid_compat. */\n\textra = kzalloc(extra_size, GFP_KERNEL);\n\tif (!extra)\n\t\treturn -ENOMEM;\n\n\t/* If it is a SET, get all the extra data in here */\n\tif (IW_IS_SET(cmd) && (iwp->length != 0)) {\n\t\tif (copy_from_user(extra, iwp->pointer,\n\t\t\t\t   iwp->length *\n\t\t\t\t   descr->token_size)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cmd == SIOCSIWENCODEEXT) {\n\t\t\tstruct iw_encode_ext *ee = (void *) extra;\n\n\t\t\tif (iwp->length < sizeof(*ee) + ee->key_len)\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\terr = handler(dev, info, (union iwreq_data *) iwp, extra);\n\n\tiwp->length += essid_compat;\n\n\t/* If we have something to return to the user */\n\tif (!err && IW_IS_GET(cmd)) {\n\t\t/* Check if there is enough buffer up there */\n\t\tif (user_length < iwp->length) {\n\t\t\terr = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (copy_to_user(iwp->pointer, extra,\n\t\t\t\t iwp->length *\n\t\t\t\t descr->token_size)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Generate an event to notify listeners of the change */\n\tif ((descr->flags & IW_DESCR_FLAG_EVENT) &&\n\t    ((err == 0) || (err == -EIWCOMMIT))) {\n\t\tunion iwreq_data *data = (union iwreq_data *) iwp;\n\n\t\tif (descr->flags & IW_DESCR_FLAG_RESTRICT)\n\t\t\t/* If the event is restricted, don't\n\t\t\t * export the payload.\n\t\t\t */\n\t\t\twireless_send_event(dev, cmd, data, NULL);\n\t\telse\n\t\t\twireless_send_event(dev, cmd, data, extra);\n\t}\n\nout:\n\tkfree(extra);\n\treturn err;\n}",
        "func": "static int ioctl_standard_iw_point(struct iw_point *iwp, unsigned int cmd,\n\t\t\t\t   const struct iw_ioctl_description *descr,\n\t\t\t\t   iw_handler handler, struct net_device *dev,\n\t\t\t\t   struct iw_request_info *info)\n{\n\tint err, extra_size, user_length = 0, essid_compat = 0;\n\tchar *extra;\n\n\t/* Calculate space needed by arguments. Always allocate\n\t * for max space.\n\t */\n\textra_size = descr->max_tokens * descr->token_size;\n\n\t/* Check need for ESSID compatibility for WE < 21 */\n\tswitch (cmd) {\n\tcase SIOCSIWESSID:\n\tcase SIOCGIWESSID:\n\tcase SIOCSIWNICKN:\n\tcase SIOCGIWNICKN:\n\t\tif (iwp->length == descr->max_tokens + 1)\n\t\t\tessid_compat = 1;\n\t\telse if (IW_IS_SET(cmd) && (iwp->length != 0)) {\n\t\t\tchar essid[IW_ESSID_MAX_SIZE + 1];\n\t\t\tunsigned int len;\n\t\t\tlen = iwp->length * descr->token_size;\n\n\t\t\tif (len > IW_ESSID_MAX_SIZE)\n\t\t\t\treturn -EFAULT;\n\n\t\t\terr = copy_from_user(essid, iwp->pointer, len);\n\t\t\tif (err)\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (essid[iwp->length - 1] == '\\0')\n\t\t\t\tessid_compat = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tiwp->length -= essid_compat;\n\n\t/* Check what user space is giving us */\n\tif (IW_IS_SET(cmd)) {\n\t\t/* Check NULL pointer */\n\t\tif (!iwp->pointer && iwp->length != 0)\n\t\t\treturn -EFAULT;\n\t\t/* Check if number of token fits within bounds */\n\t\tif (iwp->length > descr->max_tokens)\n\t\t\treturn -E2BIG;\n\t\tif (iwp->length < descr->min_tokens)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t/* Check NULL pointer */\n\t\tif (!iwp->pointer)\n\t\t\treturn -EFAULT;\n\t\t/* Save user space buffer size for checking */\n\t\tuser_length = iwp->length;\n\n\t\t/* Don't check if user_length > max to allow forward\n\t\t * compatibility. The test user_length < min is\n\t\t * implied by the test at the end.\n\t\t */\n\n\t\t/* Support for very large requests */\n\t\tif ((descr->flags & IW_DESCR_FLAG_NOMAX) &&\n\t\t    (user_length > descr->max_tokens)) {\n\t\t\t/* Allow userspace to GET more than max so\n\t\t\t * we can support any size GET requests.\n\t\t\t * There is still a limit : -ENOMEM.\n\t\t\t */\n\t\t\textra_size = user_length * descr->token_size;\n\n\t\t\t/* Note : user_length is originally a __u16,\n\t\t\t * and token_size is controlled by us,\n\t\t\t * so extra_size won't get negative and\n\t\t\t * won't overflow...\n\t\t\t */\n\t\t}\n\t}\n\n\t/* kzalloc() ensures NULL-termination for essid_compat. */\n\textra = kzalloc(extra_size, GFP_KERNEL);\n\tif (!extra)\n\t\treturn -ENOMEM;\n\n\t/* If it is a SET, get all the extra data in here */\n\tif (IW_IS_SET(cmd) && (iwp->length != 0)) {\n\t\tif (copy_from_user(extra, iwp->pointer,\n\t\t\t\t   iwp->length *\n\t\t\t\t   descr->token_size)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cmd == SIOCSIWENCODEEXT) {\n\t\t\tstruct iw_encode_ext *ee = (void *) extra;\n\n\t\t\tif (iwp->length < sizeof(*ee) + ee->key_len)\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (IW_IS_GET(cmd) && !(descr->flags & IW_DESCR_FLAG_NOMAX)) {\n\t\t/*\n\t\t * If this is a GET, but not NOMAX, it means that the extra\n\t\t * data is not bounded by userspace, but by max_tokens. Thus\n\t\t * set the length to max_tokens. This matches the extra data\n\t\t * allocation.\n\t\t * The driver should fill it with the number of tokens it\n\t\t * provided, and it may check iwp->length rather than having\n\t\t * knowledge of max_tokens. If the driver doesn't change the\n\t\t * iwp->length, this ioctl just copies back max_token tokens\n\t\t * filled with zeroes. Hopefully the driver isn't claiming\n\t\t * them to be valid data.\n\t\t */\n\t\tiwp->length = descr->max_tokens;\n\t}\n\n\terr = handler(dev, info, (union iwreq_data *) iwp, extra);\n\n\tiwp->length += essid_compat;\n\n\t/* If we have something to return to the user */\n\tif (!err && IW_IS_GET(cmd)) {\n\t\t/* Check if there is enough buffer up there */\n\t\tif (user_length < iwp->length) {\n\t\t\terr = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (copy_to_user(iwp->pointer, extra,\n\t\t\t\t iwp->length *\n\t\t\t\t descr->token_size)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Generate an event to notify listeners of the change */\n\tif ((descr->flags & IW_DESCR_FLAG_EVENT) &&\n\t    ((err == 0) || (err == -EIWCOMMIT))) {\n\t\tunion iwreq_data *data = (union iwreq_data *) iwp;\n\n\t\tif (descr->flags & IW_DESCR_FLAG_RESTRICT)\n\t\t\t/* If the event is restricted, don't\n\t\t\t * export the payload.\n\t\t\t */\n\t\t\twireless_send_event(dev, cmd, data, NULL);\n\t\telse\n\t\t\twireless_send_event(dev, cmd, data, extra);\n\t}\n\nout:\n\tkfree(extra);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -102,6 +102,22 @@\n \t\t}\n \t}\n \n+\tif (IW_IS_GET(cmd) && !(descr->flags & IW_DESCR_FLAG_NOMAX)) {\n+\t\t/*\n+\t\t * If this is a GET, but not NOMAX, it means that the extra\n+\t\t * data is not bounded by userspace, but by max_tokens. Thus\n+\t\t * set the length to max_tokens. This matches the extra data\n+\t\t * allocation.\n+\t\t * The driver should fill it with the number of tokens it\n+\t\t * provided, and it may check iwp->length rather than having\n+\t\t * knowledge of max_tokens. If the driver doesn't change the\n+\t\t * iwp->length, this ioctl just copies back max_token tokens\n+\t\t * filled with zeroes. Hopefully the driver isn't claiming\n+\t\t * them to be valid data.\n+\t\t */\n+\t\tiwp->length = descr->max_tokens;\n+\t}\n+\n \terr = handler(dev, info, (union iwreq_data *) iwp, extra);\n \n \tiwp->length += essid_compat;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (IW_IS_GET(cmd) && !(descr->flags & IW_DESCR_FLAG_NOMAX)) {",
                "\t\t/*",
                "\t\t * If this is a GET, but not NOMAX, it means that the extra",
                "\t\t * data is not bounded by userspace, but by max_tokens. Thus",
                "\t\t * set the length to max_tokens. This matches the extra data",
                "\t\t * allocation.",
                "\t\t * The driver should fill it with the number of tokens it",
                "\t\t * provided, and it may check iwp->length rather than having",
                "\t\t * knowledge of max_tokens. If the driver doesn't change the",
                "\t\t * iwp->length, this ioctl just copies back max_token tokens",
                "\t\t * filled with zeroes. Hopefully the driver isn't claiming",
                "\t\t * them to be valid data.",
                "\t\t */",
                "\t\tiwp->length = descr->max_tokens;",
                "\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2010-2955",
        "func_name": "kernel/git/linville/wireless/cfg80211_wext_giwessid",
        "description": "The cfg80211_wext_giwessid function in net/wireless/wext-compat.c in the Linux kernel before 2.6.36-rc3-next-20100831 does not properly initialize certain structure members, which allows local users to leverage an off-by-one error in the ioctl_standard_iw_point function in net/wireless/wext-core.c, and obtain potentially sensitive information from kernel heap memory, via vectors involving an SIOCGIWESSID ioctl call that specifies a large buffer size.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/linville/wireless.git;a=commit;h=42da2f948d949efd0111309f5827bf0298bcc9a4",
        "commit_title": "Wireless extensions have an unfortunate, undocumented",
        "commit_text": "requirement which requires drivers to always fill iwp->length when returning a successful status. When a driver doesn't do this, it leads to a kernel heap content leak when userspace offers a larger buffer than would have been necessary.  Arguably, this is a driver bug, as it should, if it returns 0, fill iwp->length, even if it separately indicated that the buffer contents was not valid.  However, we can also at least avoid the memory content leak if the driver doesn't do this by setting the iwp length to max_tokens, which then reflects how big the buffer is that the driver may fill, regardless of how big the userspace buffer is.  To illustrate the point, this patch also fixes a corresponding cfg80211 bug (since this requirement isn't documented nor was ever pointed out by anyone during code review, I don't trust all drivers nor all cfg80211 handlers to implement it correctly).  Cc: stable@kernel.org [all the way back] ",
        "func_before": "int cfg80211_wext_giwessid(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   struct iw_point *data, char *ssid)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\treturn cfg80211_ibss_wext_giwessid(dev, info, data, ssid);\n\tcase NL80211_IFTYPE_STATION:\n\t\treturn cfg80211_mgd_wext_giwessid(dev, info, data, ssid);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}",
        "func": "int cfg80211_wext_giwessid(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   struct iw_point *data, char *ssid)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\tdata->flags = 0;\n\tdata->length = 0;\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\treturn cfg80211_ibss_wext_giwessid(dev, info, data, ssid);\n\tcase NL80211_IFTYPE_STATION:\n\t\treturn cfg80211_mgd_wext_giwessid(dev, info, data, ssid);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,9 @@\n \t\t\t   struct iw_point *data, char *ssid)\n {\n \tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n+\n+\tdata->flags = 0;\n+\tdata->length = 0;\n \n \tswitch (wdev->iftype) {\n \tcase NL80211_IFTYPE_ADHOC:",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tdata->flags = 0;",
                "\tdata->length = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19906",
        "func_name": "cyrusimap/cyrus-sasl/_sasl_add_string",
        "description": "cyrus-sasl (aka Cyrus SASL) 2.1.27 has an out-of-bounds write leading to unauthenticated remote denial-of-service in OpenLDAP via a malformed LDAP packet. The OpenLDAP crash is ultimately caused by an off-by-one error in _sasl_add_string in common.c in cyrus-sasl.",
        "git_url": "https://github.com/cyrusimap/cyrus-sasl/commit/dcc9f51cbd4ed622cfb0f9b1c141eb2ffe3b12f1",
        "commit_title": "Fix #587",
        "commit_text": " Off by one error in common.c, CVE-2019-19906.  Thanks to Stephan Zeisberg for reporting",
        "func_before": "int _sasl_add_string(char **out, size_t *alloclen,\n\t\t     size_t *outlen, const char *add)\n{\n  size_t addlen;\n\n  if (add==NULL) add = \"(null)\";\n\n  addlen=strlen(add); /* only compute once */\n  if (_buf_alloc(out, alloclen, (*outlen)+addlen)!=SASL_OK)\n    return SASL_NOMEM;\n\n  strncpy(*out + *outlen, add, addlen);\n  *outlen += addlen;\n\n  return SASL_OK;\n}",
        "func": "int _sasl_add_string(char **out, size_t *alloclen,\n\t\t     size_t *outlen, const char *add)\n{\n  size_t addlen;\n\n  if (add==NULL) add = \"(null)\";\n\n  addlen=strlen(add)+1; /* only compute once */\n  if (_buf_alloc(out, alloclen, (*outlen)+addlen)!=SASL_OK)\n    return SASL_NOMEM;\n\n  strncpy(*out + *outlen, add, addlen);\n  *outlen += addlen;\n\n  return SASL_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \n   if (add==NULL) add = \"(null)\";\n \n-  addlen=strlen(add); /* only compute once */\n+  addlen=strlen(add)+1; /* only compute once */\n   if (_buf_alloc(out, alloclen, (*outlen)+addlen)!=SASL_OK)\n     return SASL_NOMEM;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  addlen=strlen(add); /* only compute once */"
            ],
            "added_lines": [
                "  addlen=strlen(add)+1; /* only compute once */"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-2618",
        "func_name": "torvalds/linux/selinux_setprocattr",
        "description": "A flaw was found in the Linux kernel's handling of clearing SELinux attributes on /proc/pid/attr files before 4.9.10. An empty (null) write to this file can crash the system by causing the system to attempt to access unmapped kernel memory.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=0c461cb727d146c9ef2d3e86214f498b78b7d125",
        "commit_title": "SELinux tries to support setting/clearing of /proc/pid/attr attributes",
        "commit_text": "from the shell by ignoring terminating newlines and treating an attribute value that begins with a NUL or newline as an attempt to clear the attribute.  However, the test for clearing attributes has always been wrong; it has an off-by-one error, and this could further lead to reading past the end of the allocated buffer since commit bb646cdb12e75d82258c2f2e7746d5952d3e321a (\"proc_pid_attr_write(): switch to memdup_user()\").  Fix the off-by-one error.  Even with this fix, setting and clearing /proc/pid/attr attributes from the shell is not straightforward since the interface does not support multiple write() calls (so shells that write the value and newline separately will set and then immediately clear the attribute, requiring use of echo -n to set the attribute), whereas trying to use echo -n \"\" to clear the attribute causes the shell to skip the write() call altogether since POSIX says that a zero-length write causes no side effects. Thus, one must use echo -n to set and echo without -n to clear, as in the following example: $ echo -n unconfined_u:object_r:user_home_t:s0 > /proc/$$/attr/fscreate $ cat /proc/$$/attr/fscreate unconfined_u:object_r:user_home_t:s0 $ echo \"\" > /proc/$$/attr/fscreate $ cat /proc/$$/attr/fscreate  Note the use of /proc/$$ rather than /proc/self, as otherwise the cat command will read its own attribute value, not that of the shell.  There are no users of this facility to my knowledge; possibly we should just get rid of it.  UPDATE: Upon further investigation it appears that a local process with the process:setfscreate permission can cause a kernel panic as a result of this bug.  This patch fixes CVE-2017-2618.  [PM: added the update about CVE-2017-2618 to the commit description] Cc: stable@vger.kernel.org # 3.5: d6ea83ec6864e  ",
        "func_before": "static int selinux_setprocattr(struct task_struct *p,\n\t\t\t       char *name, void *value, size_t size)\n{\n\tstruct task_security_struct *tsec;\n\tstruct cred *new;\n\tu32 sid = 0, ptsid;\n\tint error;\n\tchar *str = value;\n\n\tif (current != p) {\n\t\t/* SELinux only allows a process to change its own\n\t\t   security attributes. */\n\t\treturn -EACCES;\n\t}\n\n\t/*\n\t * Basic control over ability to set these attributes at all.\n\t * current == p, but we'll pass them separately in case the\n\t * above restriction is ever removed.\n\t */\n\tif (!strcmp(name, \"exec\"))\n\t\terror = current_has_perm(p, PROCESS__SETEXEC);\n\telse if (!strcmp(name, \"fscreate\"))\n\t\terror = current_has_perm(p, PROCESS__SETFSCREATE);\n\telse if (!strcmp(name, \"keycreate\"))\n\t\terror = current_has_perm(p, PROCESS__SETKEYCREATE);\n\telse if (!strcmp(name, \"sockcreate\"))\n\t\terror = current_has_perm(p, PROCESS__SETSOCKCREATE);\n\telse if (!strcmp(name, \"current\"))\n\t\terror = current_has_perm(p, PROCESS__SETCURRENT);\n\telse\n\t\terror = -EINVAL;\n\tif (error)\n\t\treturn error;\n\n\t/* Obtain a SID for the context, if one was specified. */\n\tif (size && str[1] && str[1] != '\\n') {\n\t\tif (str[size-1] == '\\n') {\n\t\t\tstr[size-1] = 0;\n\t\t\tsize--;\n\t\t}\n\t\terror = security_context_to_sid(value, size, &sid, GFP_KERNEL);\n\t\tif (error == -EINVAL && !strcmp(name, \"fscreate\")) {\n\t\t\tif (!capable(CAP_MAC_ADMIN)) {\n\t\t\t\tstruct audit_buffer *ab;\n\t\t\t\tsize_t audit_size;\n\n\t\t\t\t/* We strip a nul only if it is at the end, otherwise the\n\t\t\t\t * context contains a nul and we should audit that */\n\t\t\t\tif (str[size - 1] == '\\0')\n\t\t\t\t\taudit_size = size - 1;\n\t\t\t\telse\n\t\t\t\t\taudit_size = size;\n\t\t\t\tab = audit_log_start(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR);\n\t\t\t\taudit_log_format(ab, \"op=fscreate invalid_context=\");\n\t\t\t\taudit_log_n_untrustedstring(ab, value, audit_size);\n\t\t\t\taudit_log_end(ab);\n\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\terror = security_context_to_sid_force(value, size,\n\t\t\t\t\t\t\t      &sid);\n\t\t}\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t/* Permission checking based on the specified context is\n\t   performed during the actual operation (execve,\n\t   open/mkdir/...), when we know the full context of the\n\t   operation.  See selinux_bprm_set_creds for the execve\n\t   checks and may_create for the file creation checks. The\n\t   operation will then fail if the context is not permitted. */\n\ttsec = new->security;\n\tif (!strcmp(name, \"exec\")) {\n\t\ttsec->exec_sid = sid;\n\t} else if (!strcmp(name, \"fscreate\")) {\n\t\ttsec->create_sid = sid;\n\t} else if (!strcmp(name, \"keycreate\")) {\n\t\terror = may_create_key(sid, p);\n\t\tif (error)\n\t\t\tgoto abort_change;\n\t\ttsec->keycreate_sid = sid;\n\t} else if (!strcmp(name, \"sockcreate\")) {\n\t\ttsec->sockcreate_sid = sid;\n\t} else if (!strcmp(name, \"current\")) {\n\t\terror = -EINVAL;\n\t\tif (sid == 0)\n\t\t\tgoto abort_change;\n\n\t\t/* Only allow single threaded processes to change context */\n\t\terror = -EPERM;\n\t\tif (!current_is_single_threaded()) {\n\t\t\terror = security_bounded_transition(tsec->sid, sid);\n\t\t\tif (error)\n\t\t\t\tgoto abort_change;\n\t\t}\n\n\t\t/* Check permissions for the transition. */\n\t\terror = avc_has_perm(tsec->sid, sid, SECCLASS_PROCESS,\n\t\t\t\t     PROCESS__DYNTRANSITION, NULL);\n\t\tif (error)\n\t\t\tgoto abort_change;\n\n\t\t/* Check for ptracing, and update the task SID if ok.\n\t\t   Otherwise, leave SID unchanged and fail. */\n\t\tptsid = ptrace_parent_sid(p);\n\t\tif (ptsid != 0) {\n\t\t\terror = avc_has_perm(ptsid, sid, SECCLASS_PROCESS,\n\t\t\t\t\t     PROCESS__PTRACE, NULL);\n\t\t\tif (error)\n\t\t\t\tgoto abort_change;\n\t\t}\n\n\t\ttsec->sid = sid;\n\t} else {\n\t\terror = -EINVAL;\n\t\tgoto abort_change;\n\t}\n\n\tcommit_creds(new);\n\treturn size;\n\nabort_change:\n\tabort_creds(new);\n\treturn error;\n}",
        "func": "static int selinux_setprocattr(struct task_struct *p,\n\t\t\t       char *name, void *value, size_t size)\n{\n\tstruct task_security_struct *tsec;\n\tstruct cred *new;\n\tu32 sid = 0, ptsid;\n\tint error;\n\tchar *str = value;\n\n\tif (current != p) {\n\t\t/* SELinux only allows a process to change its own\n\t\t   security attributes. */\n\t\treturn -EACCES;\n\t}\n\n\t/*\n\t * Basic control over ability to set these attributes at all.\n\t * current == p, but we'll pass them separately in case the\n\t * above restriction is ever removed.\n\t */\n\tif (!strcmp(name, \"exec\"))\n\t\terror = current_has_perm(p, PROCESS__SETEXEC);\n\telse if (!strcmp(name, \"fscreate\"))\n\t\terror = current_has_perm(p, PROCESS__SETFSCREATE);\n\telse if (!strcmp(name, \"keycreate\"))\n\t\terror = current_has_perm(p, PROCESS__SETKEYCREATE);\n\telse if (!strcmp(name, \"sockcreate\"))\n\t\terror = current_has_perm(p, PROCESS__SETSOCKCREATE);\n\telse if (!strcmp(name, \"current\"))\n\t\terror = current_has_perm(p, PROCESS__SETCURRENT);\n\telse\n\t\terror = -EINVAL;\n\tif (error)\n\t\treturn error;\n\n\t/* Obtain a SID for the context, if one was specified. */\n\tif (size && str[0] && str[0] != '\\n') {\n\t\tif (str[size-1] == '\\n') {\n\t\t\tstr[size-1] = 0;\n\t\t\tsize--;\n\t\t}\n\t\terror = security_context_to_sid(value, size, &sid, GFP_KERNEL);\n\t\tif (error == -EINVAL && !strcmp(name, \"fscreate\")) {\n\t\t\tif (!capable(CAP_MAC_ADMIN)) {\n\t\t\t\tstruct audit_buffer *ab;\n\t\t\t\tsize_t audit_size;\n\n\t\t\t\t/* We strip a nul only if it is at the end, otherwise the\n\t\t\t\t * context contains a nul and we should audit that */\n\t\t\t\tif (str[size - 1] == '\\0')\n\t\t\t\t\taudit_size = size - 1;\n\t\t\t\telse\n\t\t\t\t\taudit_size = size;\n\t\t\t\tab = audit_log_start(current->audit_context, GFP_ATOMIC, AUDIT_SELINUX_ERR);\n\t\t\t\taudit_log_format(ab, \"op=fscreate invalid_context=\");\n\t\t\t\taudit_log_n_untrustedstring(ab, value, audit_size);\n\t\t\t\taudit_log_end(ab);\n\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\terror = security_context_to_sid_force(value, size,\n\t\t\t\t\t\t\t      &sid);\n\t\t}\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t/* Permission checking based on the specified context is\n\t   performed during the actual operation (execve,\n\t   open/mkdir/...), when we know the full context of the\n\t   operation.  See selinux_bprm_set_creds for the execve\n\t   checks and may_create for the file creation checks. The\n\t   operation will then fail if the context is not permitted. */\n\ttsec = new->security;\n\tif (!strcmp(name, \"exec\")) {\n\t\ttsec->exec_sid = sid;\n\t} else if (!strcmp(name, \"fscreate\")) {\n\t\ttsec->create_sid = sid;\n\t} else if (!strcmp(name, \"keycreate\")) {\n\t\terror = may_create_key(sid, p);\n\t\tif (error)\n\t\t\tgoto abort_change;\n\t\ttsec->keycreate_sid = sid;\n\t} else if (!strcmp(name, \"sockcreate\")) {\n\t\ttsec->sockcreate_sid = sid;\n\t} else if (!strcmp(name, \"current\")) {\n\t\terror = -EINVAL;\n\t\tif (sid == 0)\n\t\t\tgoto abort_change;\n\n\t\t/* Only allow single threaded processes to change context */\n\t\terror = -EPERM;\n\t\tif (!current_is_single_threaded()) {\n\t\t\terror = security_bounded_transition(tsec->sid, sid);\n\t\t\tif (error)\n\t\t\t\tgoto abort_change;\n\t\t}\n\n\t\t/* Check permissions for the transition. */\n\t\terror = avc_has_perm(tsec->sid, sid, SECCLASS_PROCESS,\n\t\t\t\t     PROCESS__DYNTRANSITION, NULL);\n\t\tif (error)\n\t\t\tgoto abort_change;\n\n\t\t/* Check for ptracing, and update the task SID if ok.\n\t\t   Otherwise, leave SID unchanged and fail. */\n\t\tptsid = ptrace_parent_sid(p);\n\t\tif (ptsid != 0) {\n\t\t\terror = avc_has_perm(ptsid, sid, SECCLASS_PROCESS,\n\t\t\t\t\t     PROCESS__PTRACE, NULL);\n\t\t\tif (error)\n\t\t\t\tgoto abort_change;\n\t\t}\n\n\t\ttsec->sid = sid;\n\t} else {\n\t\terror = -EINVAL;\n\t\tgoto abort_change;\n\t}\n\n\tcommit_creds(new);\n\treturn size;\n\nabort_change:\n\tabort_creds(new);\n\treturn error;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,7 +34,7 @@\n \t\treturn error;\n \n \t/* Obtain a SID for the context, if one was specified. */\n-\tif (size && str[1] && str[1] != '\\n') {\n+\tif (size && str[0] && str[0] != '\\n') {\n \t\tif (str[size-1] == '\\n') {\n \t\t\tstr[size-1] = 0;\n \t\t\tsize--;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (size && str[1] && str[1] != '\\n') {"
            ],
            "added_lines": [
                "\tif (size && str[0] && str[0] != '\\n') {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14679",
        "func_name": "kyz/libmspack/read_chunk",
        "description": "An issue was discovered in mspack/chmd.c in libmspack before 0.7alpha. There is an off-by-one error in the CHM PMGI/PMGL chunk number validity checks, which could lead to denial of service (uninitialized data dereference and application crash).",
        "git_url": "https://github.com/kyz/libmspack/commit/72e70a921f0f07fee748aec2274b30784e1d312a",
        "commit_title": "Fix off-by-one bounds check on CHM PMGI/PMGL chunk numbers and",
        "commit_text": "reject empty filenames. Thanks to Hanno Bck for reporting",
        "func_before": "static unsigned char *read_chunk(struct mschm_decompressor_p *self,\n\t\t\t\t struct mschmd_header *chm,\n\t\t\t\t struct mspack_file *fh,\n\t\t\t\t unsigned int chunk_num)\n{\n    struct mspack_system *sys = self->system;\n    unsigned char *buf;\n\n    /* check arguments - most are already checked by chmd_fast_find */\n    if (chunk_num > chm->num_chunks) return NULL;\n    \n    /* ensure chunk cache is available */\n    if (!chm->chunk_cache) {\n\tsize_t size = sizeof(unsigned char *) * chm->num_chunks;\n\tif (!(chm->chunk_cache = (unsigned char **) sys->alloc(sys, size))) {\n\t    self->error = MSPACK_ERR_NOMEMORY;\n\t    return NULL;\n\t}\n\tmemset(chm->chunk_cache, 0, size);\n    }\n\n    /* try to answer out of chunk cache */\n    if (chm->chunk_cache[chunk_num]) return chm->chunk_cache[chunk_num];\n\n    /* need to read chunk - allocate memory for it */\n    if (!(buf = (unsigned char *) sys->alloc(sys, chm->chunk_size))) {\n\tself->error = MSPACK_ERR_NOMEMORY;\n\treturn NULL;\n    }\n\n    /* seek to block and read it */\n    if (sys->seek(fh, (off_t) (chm->dir_offset + (chunk_num * chm->chunk_size)),\n\t\t      MSPACK_SYS_SEEK_START))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n    if (sys->read(fh, buf, (int)chm->chunk_size) != (int)chm->chunk_size) {\n\tself->error = MSPACK_ERR_READ;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* check the signature. Is is PMGL or PMGI? */\n    if (!((buf[0] == 0x50) && (buf[1] == 0x4D) && (buf[2] == 0x47) &&\n\t  ((buf[3] == 0x4C) || (buf[3] == 0x49))))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* all OK. Store chunk in cache and return it */\n    return chm->chunk_cache[chunk_num] = buf;\n}",
        "func": "static unsigned char *read_chunk(struct mschm_decompressor_p *self,\n\t\t\t\t struct mschmd_header *chm,\n\t\t\t\t struct mspack_file *fh,\n\t\t\t\t unsigned int chunk_num)\n{\n    struct mspack_system *sys = self->system;\n    unsigned char *buf;\n\n    /* check arguments - most are already checked by chmd_fast_find */\n    if (chunk_num >= chm->num_chunks) return NULL;\n    \n    /* ensure chunk cache is available */\n    if (!chm->chunk_cache) {\n\tsize_t size = sizeof(unsigned char *) * chm->num_chunks;\n\tif (!(chm->chunk_cache = (unsigned char **) sys->alloc(sys, size))) {\n\t    self->error = MSPACK_ERR_NOMEMORY;\n\t    return NULL;\n\t}\n\tmemset(chm->chunk_cache, 0, size);\n    }\n\n    /* try to answer out of chunk cache */\n    if (chm->chunk_cache[chunk_num]) return chm->chunk_cache[chunk_num];\n\n    /* need to read chunk - allocate memory for it */\n    if (!(buf = (unsigned char *) sys->alloc(sys, chm->chunk_size))) {\n\tself->error = MSPACK_ERR_NOMEMORY;\n\treturn NULL;\n    }\n\n    /* seek to block and read it */\n    if (sys->seek(fh, (off_t) (chm->dir_offset + (chunk_num * chm->chunk_size)),\n\t\t      MSPACK_SYS_SEEK_START))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n    if (sys->read(fh, buf, (int)chm->chunk_size) != (int)chm->chunk_size) {\n\tself->error = MSPACK_ERR_READ;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* check the signature. Is is PMGL or PMGI? */\n    if (!((buf[0] == 0x50) && (buf[1] == 0x4D) && (buf[2] == 0x47) &&\n\t  ((buf[3] == 0x4C) || (buf[3] == 0x49))))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* all OK. Store chunk in cache and return it */\n    return chm->chunk_cache[chunk_num] = buf;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n     unsigned char *buf;\n \n     /* check arguments - most are already checked by chmd_fast_find */\n-    if (chunk_num > chm->num_chunks) return NULL;\n+    if (chunk_num >= chm->num_chunks) return NULL;\n     \n     /* ensure chunk cache is available */\n     if (!chm->chunk_cache) {",
        "diff_line_info": {
            "deleted_lines": [
                "    if (chunk_num > chm->num_chunks) return NULL;"
            ],
            "added_lines": [
                "    if (chunk_num >= chm->num_chunks) return NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14679",
        "func_name": "kyz/libmspack/chmd_read_headers",
        "description": "An issue was discovered in mspack/chmd.c in libmspack before 0.7alpha. There is an off-by-one error in the CHM PMGI/PMGL chunk number validity checks, which could lead to denial of service (uninitialized data dereference and application crash).",
        "git_url": "https://github.com/kyz/libmspack/commit/72e70a921f0f07fee748aec2274b30784e1d312a",
        "commit_title": "Fix off-by-one bounds check on CHM PMGI/PMGL chunk numbers and",
        "commit_text": "reject empty filenames. Thanks to Hanno Bck for reporting",
        "func_before": "static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,\n\t\t\t     struct mschmd_header *chm, int entire)\n{\n  unsigned int section, name_len, x, errors, num_chunks;\n  unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;\n  struct mschmd_file *fi, *link = NULL;\n  off_t offset, length;\n  int num_entries;\n\n  /* initialise pointers */\n  chm->files         = NULL;\n  chm->sysfiles      = NULL;\n  chm->chunk_cache   = NULL;\n  chm->sec0.base.chm = chm;\n  chm->sec0.base.id  = 0;\n  chm->sec1.base.chm = chm;\n  chm->sec1.base.id  = 1;\n  chm->sec1.content  = NULL;\n  chm->sec1.control  = NULL;\n  chm->sec1.spaninfo = NULL;\n  chm->sec1.rtable   = NULL;\n\n  /* read the first header */\n  if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* check ITSF signature */\n  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  /* check both header GUIDs */\n  if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {\n    D((\"incorrect GUIDs\"))\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  chm->version   = EndGetI32(&buf[chmhead_Version]);\n  chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);\n  chm->language  = EndGetI32(&buf[chmhead_LanguageID]);\n  if (chm->version > 3) {\n    sys->message(fh, \"WARNING; CHM version > 3\");\n  }\n\n  /* read the header section table */\n  if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* chmhst3_OffsetCS0 does not exist in version 1 or 2 CHM files.\n   * The offset will be corrected later, once HS1 is read.\n   */\n  if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||\n      read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||\n      read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))\n  {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 0 */\n  if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 0 */\n  if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n  if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 1 */\n  if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 1 */\n  if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  chm->dir_offset = sys->tell(fh);\n  chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);\n  chm->density    = EndGetI32(&buf[chmhs1_Density]);\n  chm->depth      = EndGetI32(&buf[chmhs1_Depth]);\n  chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);\n  chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);\n  chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);\n  chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);\n\n  if (chm->version < 3) {\n    /* versions before 3 don't have chmhst3_OffsetCS0 */\n    chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);\n  }\n\n  /* check if content offset or file size is wrong */\n  if (chm->sec0.offset > chm->length) {\n    D((\"content section begins after file has ended\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  \n  /* ensure there are chunks and that chunk size is\n   * large enough for signature and num_entries */\n  if (chm->chunk_size < (pmgl_Entries + 2)) {\n    D((\"chunk size not large enough\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->num_chunks == 0) {\n    D((\"no chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* The chunk_cache data structure is not great; large values for num_chunks\n   * or num_chunks*chunk_size can exhaust all memory. Until a better chunk\n   * cache is implemented, put arbitrary limits on num_chunks and chunk size.\n   */\n  if (chm->num_chunks > 100000) {\n    D((\"more than 100,000 chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }   \n  if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {\n    D((\"chunks larger than entire file\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* common sense checks on header section 1 fields */\n  if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {\n    sys->message(fh, \"WARNING; chunk size is not a power of two\");\n  }\n  if (chm->first_pmgl != 0) {\n    sys->message(fh, \"WARNING; first PMGL chunk is not zero\");\n  }\n  if (chm->first_pmgl > chm->last_pmgl) {\n    D((\"first pmgl chunk is after last pmgl chunk\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->index_root != 0xFFFFFFFF && chm->index_root > chm->num_chunks) {\n    D((\"index_root outside valid range\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* if we are doing a quick read, stop here! */\n  if (!entire) {\n    return MSPACK_ERR_OK;\n  }\n\n  /* seek to the first PMGL chunk, and reduce the number of chunks to read */\n  if ((x = chm->first_pmgl) != 0) {\n    if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {\n      return MSPACK_ERR_SEEK;\n    }\n  }\n  num_chunks = chm->last_pmgl - x + 1;\n\n  if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {\n    return MSPACK_ERR_NOMEMORY;\n  }\n\n  /* read and process all chunks from FirstPMGL to LastPMGL */\n  errors = 0;\n  while (num_chunks--) {\n    /* read next chunk */\n    if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {\n      sys->free(chunk);\n      return MSPACK_ERR_READ;\n    }\n\n    /* process only directory (PMGL) chunks */\n    if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;\n\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {\n      sys->message(fh, \"WARNING; PMGL quickref area is too small\");\n    }\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) > \n\t((int)chm->chunk_size - pmgl_Entries))\n    {\n      sys->message(fh, \"WARNING; PMGL quickref area is too large\");\n    }\n\n    p = &chunk[pmgl_Entries];\n    end = &chunk[chm->chunk_size - 2];\n    num_entries = EndGetI16(end);\n\n    while (num_entries--) {\n      READ_ENCINT(name_len);\n      if (name_len > (unsigned int) (end - p)) goto chunk_end;\n      name = p; p += name_len;\n      READ_ENCINT(section);\n      READ_ENCINT(offset);\n      READ_ENCINT(length);\n\n      /* empty files and directory names are stored as a file entry at\n       * offset 0 with length 0. We want to keep empty files, but not\n       * directory names, which end with a \"/\" */\n      if ((offset == 0) && (length == 0)) {\n\tif ((name_len > 0) && (name[name_len-1] == '/')) continue;\n      }\n\n      if (section > 1) {\n\tsys->message(fh, \"invalid section number '%u'.\", section);\n\tcontinue;\n      }\n\n      if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {\n\tsys->free(chunk);\n\treturn MSPACK_ERR_NOMEMORY;\n      }\n\n      fi->next     = NULL;\n      fi->filename = (char *) &fi[1];\n      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)\n\t\t                     : (struct mschmd_section *) (&chm->sec1));\n      fi->offset   = offset;\n      fi->length   = length;\n      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n\t/* system file */\n\tif (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) {\n\t  if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) {\n\t    chm->sec1.content = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) {\n\t    chm->sec1.control = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {\n\t    chm->sec1.spaninfo = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) {\n\t    chm->sec1.rtable = fi;\n\t  }\n\t}\n\tfi->next = chm->sysfiles;\n\tchm->sysfiles = fi;\n      }\n      else {\n\t/* normal file */\n\tif (link) link->next = fi; else chm->files = fi;\n\tlink = fi;\n      }\n    }\n\n    /* this is reached either when num_entries runs out, or if\n     * reading data from the chunk reached a premature end of chunk */\n  chunk_end:\n    if (num_entries >= 0) {\n      D((\"chunk ended before all entries could be read\"))\n      errors++;\n    }\n\n  }\n  sys->free(chunk);\n  return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;\n}",
        "func": "static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,\n\t\t\t     struct mschmd_header *chm, int entire)\n{\n  unsigned int section, name_len, x, errors, num_chunks;\n  unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;\n  struct mschmd_file *fi, *link = NULL;\n  off_t offset, length;\n  int num_entries;\n\n  /* initialise pointers */\n  chm->files         = NULL;\n  chm->sysfiles      = NULL;\n  chm->chunk_cache   = NULL;\n  chm->sec0.base.chm = chm;\n  chm->sec0.base.id  = 0;\n  chm->sec1.base.chm = chm;\n  chm->sec1.base.id  = 1;\n  chm->sec1.content  = NULL;\n  chm->sec1.control  = NULL;\n  chm->sec1.spaninfo = NULL;\n  chm->sec1.rtable   = NULL;\n\n  /* read the first header */\n  if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* check ITSF signature */\n  if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  /* check both header GUIDs */\n  if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {\n    D((\"incorrect GUIDs\"))\n    return MSPACK_ERR_SIGNATURE;\n  }\n\n  chm->version   = EndGetI32(&buf[chmhead_Version]);\n  chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);\n  chm->language  = EndGetI32(&buf[chmhead_LanguageID]);\n  if (chm->version > 3) {\n    sys->message(fh, \"WARNING; CHM version > 3\");\n  }\n\n  /* read the header section table */\n  if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  /* chmhst3_OffsetCS0 does not exist in version 1 or 2 CHM files.\n   * The offset will be corrected later, once HS1 is read.\n   */\n  if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||\n      read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||\n      read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))\n  {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 0 */\n  if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 0 */\n  if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n  if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* seek to header section 1 */\n  if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {\n    return MSPACK_ERR_SEEK;\n  }\n\n  /* read header section 1 */\n  if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {\n    return MSPACK_ERR_READ;\n  }\n\n  chm->dir_offset = sys->tell(fh);\n  chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);\n  chm->density    = EndGetI32(&buf[chmhs1_Density]);\n  chm->depth      = EndGetI32(&buf[chmhs1_Depth]);\n  chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);\n  chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);\n  chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);\n  chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);\n\n  if (chm->version < 3) {\n    /* versions before 3 don't have chmhst3_OffsetCS0 */\n    chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);\n  }\n\n  /* check if content offset or file size is wrong */\n  if (chm->sec0.offset > chm->length) {\n    D((\"content section begins after file has ended\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  \n  /* ensure there are chunks and that chunk size is\n   * large enough for signature and num_entries */\n  if (chm->chunk_size < (pmgl_Entries + 2)) {\n    D((\"chunk size not large enough\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->num_chunks == 0) {\n    D((\"no chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* The chunk_cache data structure is not great; large values for num_chunks\n   * or num_chunks*chunk_size can exhaust all memory. Until a better chunk\n   * cache is implemented, put arbitrary limits on num_chunks and chunk size.\n   */\n  if (chm->num_chunks > 100000) {\n    D((\"more than 100,000 chunks\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }   \n  if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {\n    D((\"chunks larger than entire file\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* common sense checks on header section 1 fields */\n  if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {\n    sys->message(fh, \"WARNING; chunk size is not a power of two\");\n  }\n  if (chm->first_pmgl != 0) {\n    sys->message(fh, \"WARNING; first PMGL chunk is not zero\");\n  }\n  if (chm->first_pmgl > chm->last_pmgl) {\n    D((\"first pmgl chunk is after last pmgl chunk\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n  if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) {\n    D((\"index_root outside valid range\"))\n    return MSPACK_ERR_DATAFORMAT;\n  }\n\n  /* if we are doing a quick read, stop here! */\n  if (!entire) {\n    return MSPACK_ERR_OK;\n  }\n\n  /* seek to the first PMGL chunk, and reduce the number of chunks to read */\n  if ((x = chm->first_pmgl) != 0) {\n    if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {\n      return MSPACK_ERR_SEEK;\n    }\n  }\n  num_chunks = chm->last_pmgl - x + 1;\n\n  if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {\n    return MSPACK_ERR_NOMEMORY;\n  }\n\n  /* read and process all chunks from FirstPMGL to LastPMGL */\n  errors = 0;\n  while (num_chunks--) {\n    /* read next chunk */\n    if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {\n      sys->free(chunk);\n      return MSPACK_ERR_READ;\n    }\n\n    /* process only directory (PMGL) chunks */\n    if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;\n\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {\n      sys->message(fh, \"WARNING; PMGL quickref area is too small\");\n    }\n    if (EndGetI32(&chunk[pmgl_QuickRefSize]) > \n\t((int)chm->chunk_size - pmgl_Entries))\n    {\n      sys->message(fh, \"WARNING; PMGL quickref area is too large\");\n    }\n\n    p = &chunk[pmgl_Entries];\n    end = &chunk[chm->chunk_size - 2];\n    num_entries = EndGetI16(end);\n\n    while (num_entries--) {\n      READ_ENCINT(name_len);\n      if (name_len > (unsigned int) (end - p)) goto chunk_end;\n      /* consider blank filenames to be an error */\n      if (name_len == 0) goto chunk_end;\n      name = p; p += name_len;\n\n      READ_ENCINT(section);\n      READ_ENCINT(offset);\n      READ_ENCINT(length);\n\n      /* empty files and directory names are stored as a file entry at\n       * offset 0 with length 0. We want to keep empty files, but not\n       * directory names, which end with a \"/\" */\n      if ((offset == 0) && (length == 0)) {\n\tif ((name_len > 0) && (name[name_len-1] == '/')) continue;\n      }\n\n      if (section > 1) {\n\tsys->message(fh, \"invalid section number '%u'.\", section);\n\tcontinue;\n      }\n\n      if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {\n\tsys->free(chunk);\n\treturn MSPACK_ERR_NOMEMORY;\n      }\n\n      fi->next     = NULL;\n      fi->filename = (char *) &fi[1];\n      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)\n\t\t                     : (struct mschmd_section *) (&chm->sec1));\n      fi->offset   = offset;\n      fi->length   = length;\n      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n\t/* system file */\n\tif (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) {\n\t  if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) {\n\t    chm->sec1.content = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) {\n\t    chm->sec1.control = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {\n\t    chm->sec1.spaninfo = fi;\n\t  }\n\t  else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) {\n\t    chm->sec1.rtable = fi;\n\t  }\n\t}\n\tfi->next = chm->sysfiles;\n\tchm->sysfiles = fi;\n      }\n      else {\n\t/* normal file */\n\tif (link) link->next = fi; else chm->files = fi;\n\tlink = fi;\n      }\n    }\n\n    /* this is reached either when num_entries runs out, or if\n     * reading data from the chunk reached a premature end of chunk */\n  chunk_end:\n    if (num_entries >= 0) {\n      D((\"chunk ended before all entries could be read\"))\n      errors++;\n    }\n\n  }\n  sys->free(chunk);\n  return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -136,7 +136,7 @@\n     D((\"first pmgl chunk is after last pmgl chunk\"))\n     return MSPACK_ERR_DATAFORMAT;\n   }\n-  if (chm->index_root != 0xFFFFFFFF && chm->index_root > chm->num_chunks) {\n+  if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) {\n     D((\"index_root outside valid range\"))\n     return MSPACK_ERR_DATAFORMAT;\n   }\n@@ -186,7 +186,10 @@\n     while (num_entries--) {\n       READ_ENCINT(name_len);\n       if (name_len > (unsigned int) (end - p)) goto chunk_end;\n+      /* consider blank filenames to be an error */\n+      if (name_len == 0) goto chunk_end;\n       name = p; p += name_len;\n+\n       READ_ENCINT(section);\n       READ_ENCINT(offset);\n       READ_ENCINT(length);",
        "diff_line_info": {
            "deleted_lines": [
                "  if (chm->index_root != 0xFFFFFFFF && chm->index_root > chm->num_chunks) {"
            ],
            "added_lines": [
                "  if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) {",
                "      /* consider blank filenames to be an error */",
                "      if (name_len == 0) goto chunk_end;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14599",
        "func_name": "xorg/lib/libX11/XGetFontPath",
        "description": "An issue was discovered in libX11 through 1.6.5. The function XListExtensions in ListExt.c is vulnerable to an off-by-one error caused by malicious server responses, leading to DoS or possibly unspecified other impact.",
        "git_url": "https://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=b469da1430cdcee06e31c6251b83aede072a1ff0",
        "commit_title": "The functions XGetFontPath, XListExtensions, and XListFonts are",
        "commit_text": "vulnerable to an off-by-one override on malicious server responses.  The server replies consist of chunks consisting of a length byte followed by actual string, which is not NUL-terminated.  While parsing the response, the length byte is overridden with '\\0', thus the memory area can be used as storage of C strings later on. To be able to NUL-terminate the last string, the buffer is reserved with an additional byte of space.  For a boundary check, the variable chend (end of ch) was introduced, pointing at the end of the buffer which ch initially points to. Unfortunately there is a difference in handling \"the end of ch\".  While chend points at the first byte that must not be written to, the for-loop uses chend as the last byte that can be written to.  Therefore, an off-by-one can occur.  I have refactored the code so chend actually points to the last byte that can be written to without an out of boundary access. As it is not possible to achieve \"ch + length < chend\" and \"ch + length + 1 > chend\" with the corrected chend meaning, I removed the inner if-check.  ",
        "func_before": "char **XGetFontPath(\n    register Display *dpy,\n    int *npaths)\t/* RETURN */\n{\n\txGetFontPathReply rep;\n\tunsigned long nbytes = 0;\n\tchar **flist = NULL;\n\tchar *ch = NULL;\n\tchar *chend;\n\tint count = 0;\n\tregister unsigned i;\n\tregister int length;\n\t_X_UNUSED register xReq *req;\n\n\tLockDisplay(dpy);\n\tGetEmptyReq (GetFontPath, req);\n\t(void) _XReply (dpy, (xReply *) &rep, 0, xFalse);\n\n\tif (rep.nPaths) {\n\t    flist = Xmalloc(rep.nPaths * sizeof (char *));\n\t    if (rep.length < (INT_MAX >> 2)) {\n\t\tnbytes = (unsigned long) rep.length << 2;\n\t\tch = Xmalloc (nbytes + 1);\n                /* +1 to leave room for last null-terminator */\n\t    }\n\n\t    if ((! flist) || (! ch)) {\n\t\tXfree(flist);\n\t\tXfree(ch);\n\t\t_XEatDataWords(dpy, rep.length);\n\t\tUnlockDisplay(dpy);\n\t\tSyncHandle();\n\t\treturn (char **) NULL;\n\t    }\n\n\t    _XReadPad (dpy, ch, nbytes);\n\t    /*\n\t     * unpack into null terminated strings.\n\t     */\n\t    chend = ch + (nbytes + 1);\n\t    length = *ch;\n\t    for (i = 0; i < rep.nPaths; i++) {\n\t\tif (ch + length < chend) {\n\t\t    flist[i] = ch+1;  /* skip over length */\n\t\t    ch += length + 1; /* find next length ... */\n\t\t    length = *ch;\n\t\t    *ch = '\\0'; /* and replace with null-termination */\n\t\t    count++;\n\t\t} else\n\t\t    flist[i] = NULL;\n\t    }\n\t}\n\t*npaths = count;\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (flist);\n}",
        "func": "char **XGetFontPath(\n    register Display *dpy,\n    int *npaths)\t/* RETURN */\n{\n\txGetFontPathReply rep;\n\tunsigned long nbytes = 0;\n\tchar **flist = NULL;\n\tchar *ch = NULL;\n\tchar *chend;\n\tint count = 0;\n\tregister unsigned i;\n\tregister int length;\n\t_X_UNUSED register xReq *req;\n\n\tLockDisplay(dpy);\n\tGetEmptyReq (GetFontPath, req);\n\t(void) _XReply (dpy, (xReply *) &rep, 0, xFalse);\n\n\tif (rep.nPaths) {\n\t    flist = Xmalloc(rep.nPaths * sizeof (char *));\n\t    if (rep.length < (INT_MAX >> 2)) {\n\t\tnbytes = (unsigned long) rep.length << 2;\n\t\tch = Xmalloc (nbytes + 1);\n                /* +1 to leave room for last null-terminator */\n\t    }\n\n\t    if ((! flist) || (! ch)) {\n\t\tXfree(flist);\n\t\tXfree(ch);\n\t\t_XEatDataWords(dpy, rep.length);\n\t\tUnlockDisplay(dpy);\n\t\tSyncHandle();\n\t\treturn (char **) NULL;\n\t    }\n\n\t    _XReadPad (dpy, ch, nbytes);\n\t    /*\n\t     * unpack into null terminated strings.\n\t     */\n\t    chend = ch + nbytes;\n\t    length = *ch;\n\t    for (i = 0; i < rep.nPaths; i++) {\n\t\tif (ch + length < chend) {\n\t\t    flist[i] = ch+1;  /* skip over length */\n\t\t    ch += length + 1; /* find next length ... */\n\t\t    length = *ch;\n\t\t    *ch = '\\0'; /* and replace with null-termination */\n\t\t    count++;\n\t\t} else\n\t\t    flist[i] = NULL;\n\t    }\n\t}\n\t*npaths = count;\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (flist);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,7 +37,7 @@\n \t    /*\n \t     * unpack into null terminated strings.\n \t     */\n-\t    chend = ch + (nbytes + 1);\n+\t    chend = ch + nbytes;\n \t    length = *ch;\n \t    for (i = 0; i < rep.nPaths; i++) {\n \t\tif (ch + length < chend) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t    chend = ch + (nbytes + 1);"
            ],
            "added_lines": [
                "\t    chend = ch + nbytes;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14599",
        "func_name": "xorg/lib/libX11/XListFonts",
        "description": "An issue was discovered in libX11 through 1.6.5. The function XListExtensions in ListExt.c is vulnerable to an off-by-one error caused by malicious server responses, leading to DoS or possibly unspecified other impact.",
        "git_url": "https://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=b469da1430cdcee06e31c6251b83aede072a1ff0",
        "commit_title": "The functions XGetFontPath, XListExtensions, and XListFonts are",
        "commit_text": "vulnerable to an off-by-one override on malicious server responses.  The server replies consist of chunks consisting of a length byte followed by actual string, which is not NUL-terminated.  While parsing the response, the length byte is overridden with '\\0', thus the memory area can be used as storage of C strings later on. To be able to NUL-terminate the last string, the buffer is reserved with an additional byte of space.  For a boundary check, the variable chend (end of ch) was introduced, pointing at the end of the buffer which ch initially points to. Unfortunately there is a difference in handling \"the end of ch\".  While chend points at the first byte that must not be written to, the for-loop uses chend as the last byte that can be written to.  Therefore, an off-by-one can occur.  I have refactored the code so chend actually points to the last byte that can be written to without an out of boundary access. As it is not possible to achieve \"ch + length < chend\" and \"ch + length + 1 > chend\" with the corrected chend meaning, I removed the inner if-check.  ",
        "func_before": "char **\nXListFonts(\nregister Display *dpy,\n_Xconst char *pattern,  /* null-terminated */\nint maxNames,\nint *actualCount)\t/* RETURN */\n{\n    register long nbytes;\n    register unsigned i;\n    register int length;\n    char **flist = NULL;\n    char *ch = NULL;\n    char *chstart;\n    char *chend;\n    int count = 0;\n    xListFontsReply rep;\n    register xListFontsReq *req;\n    unsigned long rlen = 0;\n\n    LockDisplay(dpy);\n    GetReq(ListFonts, req);\n    req->maxNames = maxNames;\n    nbytes = req->nbytes = pattern ? strlen (pattern) : 0;\n    req->length += (nbytes + 3) >> 2;\n    _XSend (dpy, pattern, nbytes);\n    /* use _XSend instead of Data, since following _XReply will flush buffer */\n\n    if (!_XReply (dpy, (xReply *)&rep, 0, xFalse)) {\n\t*actualCount = 0;\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (char **) NULL;\n    }\n\n    if (rep.nFonts) {\n\tflist = Xmalloc (rep.nFonts * sizeof(char *));\n\tif (rep.length > 0 && rep.length < (INT_MAX >> 2)) {\n\t    rlen = rep.length << 2;\n\t    ch = Xmalloc(rlen + 1);\n\t    /* +1 to leave room for last null-terminator */\n\t}\n\n\tif ((! flist) || (! ch)) {\n\t    Xfree(flist);\n\t    Xfree(ch);\n\t    _XEatDataWords(dpy, rep.length);\n\t    *actualCount = 0;\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return (char **) NULL;\n\t}\n\n\t_XReadPad (dpy, ch, rlen);\n\t/*\n\t * unpack into null terminated strings.\n\t */\n\tchstart = ch;\n\tchend = ch + (rlen + 1);\n\tlength = *(unsigned char *)ch;\n\t*ch = 1; /* make sure it is non-zero for XFreeFontNames */\n\tfor (i = 0; i < rep.nFonts; i++) {\n\t    if (ch + length < chend) {\n\t\tflist[i] = ch + 1;  /* skip over length */\n\t\tch += length + 1;  /* find next length ... */\n\t\tif (ch <= chend) {\n\t\t    length = *(unsigned char *)ch;\n\t\t    *ch = '\\0';  /* and replace with null-termination */\n\t\t    count++;\n\t\t} else {\n                    Xfree(chstart);\n                    Xfree(flist);\n                    flist = NULL;\n                    count = 0;\n                    break;\n\t\t}\n\t    } else {\n                Xfree(chstart);\n                Xfree(flist);\n                flist = NULL;\n                count = 0;\n                break;\n            }\n\t}\n    }\n    *actualCount = count;\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (flist);\n}",
        "func": "char **\nXListFonts(\nregister Display *dpy,\n_Xconst char *pattern,  /* null-terminated */\nint maxNames,\nint *actualCount)\t/* RETURN */\n{\n    register long nbytes;\n    register unsigned i;\n    register int length;\n    char **flist = NULL;\n    char *ch = NULL;\n    char *chstart;\n    char *chend;\n    int count = 0;\n    xListFontsReply rep;\n    register xListFontsReq *req;\n    unsigned long rlen = 0;\n\n    LockDisplay(dpy);\n    GetReq(ListFonts, req);\n    req->maxNames = maxNames;\n    nbytes = req->nbytes = pattern ? strlen (pattern) : 0;\n    req->length += (nbytes + 3) >> 2;\n    _XSend (dpy, pattern, nbytes);\n    /* use _XSend instead of Data, since following _XReply will flush buffer */\n\n    if (!_XReply (dpy, (xReply *)&rep, 0, xFalse)) {\n\t*actualCount = 0;\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (char **) NULL;\n    }\n\n    if (rep.nFonts) {\n\tflist = Xmalloc (rep.nFonts * sizeof(char *));\n\tif (rep.length > 0 && rep.length < (INT_MAX >> 2)) {\n\t    rlen = rep.length << 2;\n\t    ch = Xmalloc(rlen + 1);\n\t    /* +1 to leave room for last null-terminator */\n\t}\n\n\tif ((! flist) || (! ch)) {\n\t    Xfree(flist);\n\t    Xfree(ch);\n\t    _XEatDataWords(dpy, rep.length);\n\t    *actualCount = 0;\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return (char **) NULL;\n\t}\n\n\t_XReadPad (dpy, ch, rlen);\n\t/*\n\t * unpack into null terminated strings.\n\t */\n\tchstart = ch;\n\tchend = ch + rlen;\n\tlength = *(unsigned char *)ch;\n\t*ch = 1; /* make sure it is non-zero for XFreeFontNames */\n\tfor (i = 0; i < rep.nFonts; i++) {\n\t    if (ch + length < chend) {\n\t\tflist[i] = ch + 1;  /* skip over length */\n\t\tch += length + 1;  /* find next length ... */\n\t\tlength = *(unsigned char *)ch;\n\t\t*ch = '\\0';  /* and replace with null-termination */\n\t\tcount++;\n\t    } else {\n                Xfree(chstart);\n                Xfree(flist);\n                flist = NULL;\n                count = 0;\n                break;\n            }\n\t}\n    }\n    *actualCount = count;\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (flist);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -55,24 +55,16 @@\n \t * unpack into null terminated strings.\n \t */\n \tchstart = ch;\n-\tchend = ch + (rlen + 1);\n+\tchend = ch + rlen;\n \tlength = *(unsigned char *)ch;\n \t*ch = 1; /* make sure it is non-zero for XFreeFontNames */\n \tfor (i = 0; i < rep.nFonts; i++) {\n \t    if (ch + length < chend) {\n \t\tflist[i] = ch + 1;  /* skip over length */\n \t\tch += length + 1;  /* find next length ... */\n-\t\tif (ch <= chend) {\n-\t\t    length = *(unsigned char *)ch;\n-\t\t    *ch = '\\0';  /* and replace with null-termination */\n-\t\t    count++;\n-\t\t} else {\n-                    Xfree(chstart);\n-                    Xfree(flist);\n-                    flist = NULL;\n-                    count = 0;\n-                    break;\n-\t\t}\n+\t\tlength = *(unsigned char *)ch;\n+\t\t*ch = '\\0';  /* and replace with null-termination */\n+\t\tcount++;\n \t    } else {\n                 Xfree(chstart);\n                 Xfree(flist);",
        "diff_line_info": {
            "deleted_lines": [
                "\tchend = ch + (rlen + 1);",
                "\t\tif (ch <= chend) {",
                "\t\t    length = *(unsigned char *)ch;",
                "\t\t    *ch = '\\0';  /* and replace with null-termination */",
                "\t\t    count++;",
                "\t\t} else {",
                "                    Xfree(chstart);",
                "                    Xfree(flist);",
                "                    flist = NULL;",
                "                    count = 0;",
                "                    break;",
                "\t\t}"
            ],
            "added_lines": [
                "\tchend = ch + rlen;",
                "\t\tlength = *(unsigned char *)ch;",
                "\t\t*ch = '\\0';  /* and replace with null-termination */",
                "\t\tcount++;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14599",
        "func_name": "xorg/lib/libX11/XListExtensions",
        "description": "An issue was discovered in libX11 through 1.6.5. The function XListExtensions in ListExt.c is vulnerable to an off-by-one error caused by malicious server responses, leading to DoS or possibly unspecified other impact.",
        "git_url": "https://cgit.freedesktop.org/xorg/lib/libX11/commit/?id=b469da1430cdcee06e31c6251b83aede072a1ff0",
        "commit_title": "The functions XGetFontPath, XListExtensions, and XListFonts are",
        "commit_text": "vulnerable to an off-by-one override on malicious server responses.  The server replies consist of chunks consisting of a length byte followed by actual string, which is not NUL-terminated.  While parsing the response, the length byte is overridden with '\\0', thus the memory area can be used as storage of C strings later on. To be able to NUL-terminate the last string, the buffer is reserved with an additional byte of space.  For a boundary check, the variable chend (end of ch) was introduced, pointing at the end of the buffer which ch initially points to. Unfortunately there is a difference in handling \"the end of ch\".  While chend points at the first byte that must not be written to, the for-loop uses chend as the last byte that can be written to.  Therefore, an off-by-one can occur.  I have refactored the code so chend actually points to the last byte that can be written to without an out of boundary access. As it is not possible to achieve \"ch + length < chend\" and \"ch + length + 1 > chend\" with the corrected chend meaning, I removed the inner if-check.  ",
        "func_before": "char **XListExtensions(\n    register Display *dpy,\n    int *nextensions)\t/* RETURN */\n{\n\txListExtensionsReply rep;\n\tchar **list = NULL;\n\tchar *ch = NULL;\n\tchar *chend;\n\tint count = 0;\n\tregister unsigned i;\n\tregister int length;\n\t_X_UNUSED register xReq *req;\n\tunsigned long rlen = 0;\n\n\tLockDisplay(dpy);\n\tGetEmptyReq (ListExtensions, req);\n\n\tif (! _XReply (dpy, (xReply *) &rep, 0, xFalse)) {\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return (char **) NULL;\n\t}\n\n\tif (rep.nExtensions) {\n\t    list = Xmalloc (rep.nExtensions * sizeof (char *));\n\t    if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {\n\t\trlen = rep.length << 2;\n\t\tch = Xmalloc (rlen + 1);\n                /* +1 to leave room for last null-terminator */\n\t    }\n\n\t    if ((!list) || (!ch)) {\n\t\tXfree(list);\n\t\tXfree(ch);\n\t\t_XEatDataWords(dpy, rep.length);\n\t\tUnlockDisplay(dpy);\n\t\tSyncHandle();\n\t\treturn (char **) NULL;\n\t    }\n\n\t    _XReadPad (dpy, ch, rlen);\n\t    /*\n\t     * unpack into null terminated strings.\n\t     */\n\t    chend = ch + (rlen + 1);\n\t    length = *ch;\n\t    for (i = 0; i < rep.nExtensions; i++) {\n\t\tif (ch + length < chend) {\n\t\t    list[i] = ch+1;  /* skip over length */\n\t\t    ch += length + 1; /* find next length ... */\n\t\t    if (ch <= chend) {\n\t\t\tlength = *ch;\n\t\t\t*ch = '\\0'; /* and replace with null-termination */\n\t\t\tcount++;\n\t\t    } else {\n\t\t\tlist[i] = NULL;\n\t\t    }\n\t\t} else\n\t\t    list[i] = NULL;\n\t    }\n\t}\n\n\t*nextensions = count;\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (list);\n}",
        "func": "char **XListExtensions(\n    register Display *dpy,\n    int *nextensions)\t/* RETURN */\n{\n\txListExtensionsReply rep;\n\tchar **list = NULL;\n\tchar *ch = NULL;\n\tchar *chend;\n\tint count = 0;\n\tregister unsigned i;\n\tregister int length;\n\t_X_UNUSED register xReq *req;\n\tunsigned long rlen = 0;\n\n\tLockDisplay(dpy);\n\tGetEmptyReq (ListExtensions, req);\n\n\tif (! _XReply (dpy, (xReply *) &rep, 0, xFalse)) {\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return (char **) NULL;\n\t}\n\n\tif (rep.nExtensions) {\n\t    list = Xmalloc (rep.nExtensions * sizeof (char *));\n\t    if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {\n\t\trlen = rep.length << 2;\n\t\tch = Xmalloc (rlen + 1);\n                /* +1 to leave room for last null-terminator */\n\t    }\n\n\t    if ((!list) || (!ch)) {\n\t\tXfree(list);\n\t\tXfree(ch);\n\t\t_XEatDataWords(dpy, rep.length);\n\t\tUnlockDisplay(dpy);\n\t\tSyncHandle();\n\t\treturn (char **) NULL;\n\t    }\n\n\t    _XReadPad (dpy, ch, rlen);\n\t    /*\n\t     * unpack into null terminated strings.\n\t     */\n\t    chend = ch + rlen;\n\t    length = *ch;\n\t    for (i = 0; i < rep.nExtensions; i++) {\n\t\tif (ch + length < chend) {\n\t\t    list[i] = ch+1;  /* skip over length */\n\t\t    ch += length + 1; /* find next length ... */\n\t\t    length = *ch;\n\t\t    *ch = '\\0'; /* and replace with null-termination */\n\t\t    count++;\n\t\t} else\n\t\t    list[i] = NULL;\n\t    }\n\t}\n\n\t*nextensions = count;\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (list);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -42,19 +42,15 @@\n \t    /*\n \t     * unpack into null terminated strings.\n \t     */\n-\t    chend = ch + (rlen + 1);\n+\t    chend = ch + rlen;\n \t    length = *ch;\n \t    for (i = 0; i < rep.nExtensions; i++) {\n \t\tif (ch + length < chend) {\n \t\t    list[i] = ch+1;  /* skip over length */\n \t\t    ch += length + 1; /* find next length ... */\n-\t\t    if (ch <= chend) {\n-\t\t\tlength = *ch;\n-\t\t\t*ch = '\\0'; /* and replace with null-termination */\n-\t\t\tcount++;\n-\t\t    } else {\n-\t\t\tlist[i] = NULL;\n-\t\t    }\n+\t\t    length = *ch;\n+\t\t    *ch = '\\0'; /* and replace with null-termination */\n+\t\t    count++;\n \t\t} else\n \t\t    list[i] = NULL;\n \t    }",
        "diff_line_info": {
            "deleted_lines": [
                "\t    chend = ch + (rlen + 1);",
                "\t\t    if (ch <= chend) {",
                "\t\t\tlength = *ch;",
                "\t\t\t*ch = '\\0'; /* and replace with null-termination */",
                "\t\t\tcount++;",
                "\t\t    } else {",
                "\t\t\tlist[i] = NULL;",
                "\t\t    }"
            ],
            "added_lines": [
                "\t    chend = ch + rlen;",
                "\t\t    length = *ch;",
                "\t\t    *ch = '\\0'; /* and replace with null-termination */",
                "\t\t    count++;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5800",
        "func_name": "LibRaw/sinar_4shot_load_raw",
        "description": "An off-by-one error within the \"LibRaw::kodak_ycbcr_load_raw()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.7 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/8682ad204392b914ab1cc6ebcca9c27c19c1a4b4",
        "commit_title": "0.18.17",
        "commit_text": "",
        "func_before": "void CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image) {\n    shot = LIM (shot_select, 1, 4) - 1;\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n  pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n  merror (pixel, \"sinar_4shot_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (shot=0; shot < 4; shot++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    for (row=0; row < raw_height; row++) {\n      read_shorts (pixel, raw_width);\n      if ((r = row-top_margin - (shot >> 1 & 1)) >= height) continue;\n      for (col=0; col < raw_width; col++) {\n\tif ((c = col-left_margin - (shot & 1)) >= width) continue;\n\timage[r*width+c][(row & 1)*3 ^ (~col & 1)] = pixel[col];\n      }\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    free(pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  mix_green = 1;\n}",
        "func": "void CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image) {\n    shot = LIM (shot_select, 1, 4) - 1;\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  else if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n  merror (pixel, \"sinar_4shot_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (shot=0; shot < 4; shot++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    for (row=0; row < raw_height; row++) {\n      read_shorts (pixel, raw_width);\n      if ((r = row-top_margin - (shot >> 1 & 1)) >= height) continue;\n      for (col=0; col < raw_width; col++) {\n\tif ((c = col-left_margin - (shot & 1)) >= width) continue;\n\timage[r*width+c][(row & 1)*3 ^ (~col & 1)] = pixel[col];\n      }\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    free(pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  mix_green = 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,10 @@\n     unpacked_load_raw();\n     return;\n   }\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  else if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n   merror (pixel, \"sinar_4shot_load_raw()\");\n #ifdef LIBRAW_LIBRARY_BUILD",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  else if(!image)",
                "    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5800",
        "func_name": "LibRaw/foveon_sd_load_raw",
        "description": "An off-by-one error within the \"LibRaw::kodak_ycbcr_load_raw()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.7 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/8682ad204392b914ab1cc6ebcca9c27c19c1a4b4",
        "commit_title": "0.18.17",
        "commit_text": "",
        "func_before": "void CLASS foveon_sd_load_raw()\n{\n  struct decode *dindex;\n  short diff[1024];\n  unsigned bitbuf=0;\n  int pred[3], row, col, bit=-1, c, i;\n\n  read_shorts ((ushort *) diff, 1024);\n  if (!load_flags) foveon_decoder (1024, 0);\n\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset (pred, 0, sizeof pred);\n    if (!bit && !load_flags && atoi(model+2) < 14) get4();\n    for (col=bit=0; col < width; col++) {\n      if (load_flags) {\n\tbitbuf = get4();\n\tFORC3 pred[2-c] += diff[bitbuf >> c*10 & 0x3ff];\n      }\n      else FORC3 {\n\tfor (dindex=first_decode; dindex->branch[0]; ) {\n\t  if ((bit = (bit-1) & 31) == 31)\n\t    for (i=0; i < 4; i++)\n\t      bitbuf = (bitbuf << 8) + fgetc(ifp);\n\t  dindex = dindex->branch[bitbuf >> bit & 1];\n\t}\n\tpred[c] += diff[dindex->leaf];\n\tif (pred[c] >> 16 && ~pred[c] >> 16) derror();\n      }\n      FORC3 image[row*width+col][c] = pred[c];\n    }\n  }\n}",
        "func": "void CLASS foveon_sd_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  struct decode *dindex;\n  short diff[1024];\n  unsigned bitbuf=0;\n  int pred[3], row, col, bit=-1, c, i;\n\n  read_shorts ((ushort *) diff, 1024);\n  if (!load_flags) foveon_decoder (1024, 0);\n\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    memset (pred, 0, sizeof pred);\n    if (!bit && !load_flags && atoi(model+2) < 14) get4();\n    for (col=bit=0; col < width; col++) {\n      if (load_flags) {\n\tbitbuf = get4();\n\tFORC3 pred[2-c] += diff[bitbuf >> c*10 & 0x3ff];\n      }\n      else FORC3 {\n\tfor (dindex=first_decode; dindex->branch[0]; ) {\n\t  if ((bit = (bit-1) & 31) == 31)\n\t    for (i=0; i < 4; i++)\n\t      bitbuf = (bitbuf << 8) + fgetc(ifp);\n\t  dindex = dindex->branch[bitbuf >> bit & 1];\n\t}\n\tpred[c] += diff[dindex->leaf];\n\tif (pred[c] >> 16 && ~pred[c] >> 16) derror();\n      }\n      FORC3 image[row*width+col][c] = pred[c];\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,9 @@\n void CLASS foveon_sd_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   struct decode *dindex;\n   short diff[1024];\n   unsigned bitbuf=0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  if(!image)",
                "    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5800",
        "func_name": "LibRaw/kodak_rgb_load_raw",
        "description": "An off-by-one error within the \"LibRaw::kodak_ycbcr_load_raw()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.7 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/8682ad204392b914ab1cc6ebcca9c27c19c1a4b4",
        "commit_title": "0.18.17",
        "commit_text": "",
        "func_before": "void CLASS kodak_rgb_load_raw()\n{\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3],ret;\n  ushort *ip=image[0];\n\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=256) {\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len*3);\n      memset (rgb, 0, sizeof rgb);\n      for (bp=buf, i=0; i < len; i++, ip+=4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(load_flags == 12)\n          {\n            FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n          }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}",
        "func": "void CLASS kodak_rgb_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3],ret;\n  ushort *ip=image[0];\n\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=256) {\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len*3);\n      memset (rgb, 0, sizeof rgb);\n      for (bp=buf, i=0; i < len; i++, ip+=4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(load_flags == 12)\n          {\n            FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n          }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,9 @@\n void CLASS kodak_rgb_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   short buf[768], *bp;\n   int row, col, len, c, i, rgb[3],ret;\n   ushort *ip=image[0];",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  if(!image)",
                "    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5800",
        "func_name": "LibRaw/nikon_yuv_load_raw",
        "description": "An off-by-one error within the \"LibRaw::kodak_ycbcr_load_raw()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.7 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/8682ad204392b914ab1cc6ebcca9c27c19c1a4b4",
        "commit_title": "0.18.17",
        "commit_text": "",
        "func_before": "void CLASS nikon_yuv_load_raw()\n{\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf=0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c]>0.001f?cam_mul[c]:1.f; }",
        "func": "void CLASS nikon_yuv_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf=0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c]>0.001f?cam_mul[c]:1.f; }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,9 @@\n void CLASS nikon_yuv_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   int row, col, yuv[4], rgb[3], b, c;\n   UINT64 bitbuf=0;\n   float cmul[4];",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  if(!image)",
                "    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5800",
        "func_name": "LibRaw/kodak_c330_load_raw",
        "description": "An off-by-one error within the \"LibRaw::kodak_ycbcr_load_raw()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.7 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/8682ad204392b914ab1cc6ebcca9c27c19c1a4b4",
        "commit_title": "0.18.17",
        "commit_text": "",
        "func_before": "void CLASS kodak_c330_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *) calloc (raw_width, 2*sizeof *pixel);\n  merror (pixel, \"kodak_c330_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (pixel, raw_width, 2, ifp) < 2) derror();\n    if (load_flags && (row & 31) == 31)\n      fseek (ifp, raw_width*32, SEEK_CUR);\n    for (col=0; col < width; col++) {\n      y  = pixel[col*2];\n      cb = pixel[(col*2 & -4) | 1] - 128;\n      cr = pixel[(col*2 & -4) | 3] - 128;\n      rgb[1] = y - ((cb + cr + 2) >> 2);\n      rgb[2] = rgb[1] + cb;\n      rgb[0] = rgb[1] + cr;\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = curve[0xff];\n}",
        "func": "void CLASS kodak_c330_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *) calloc (raw_width, 2*sizeof *pixel);\n  merror (pixel, \"kodak_c330_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (pixel, raw_width, 2, ifp) < 2) derror();\n    if (load_flags && (row & 31) == 31)\n      fseek (ifp, raw_width*32, SEEK_CUR);\n    for (col=0; col < width; col++) {\n      y  = pixel[col*2];\n      cb = pixel[(col*2 & -4) | 1] - 128;\n      cr = pixel[(col*2 & -4) | 3] - 128;\n      rgb[1] = y - ((cb + cr + 2) >> 2);\n      rgb[2] = rgb[1] + cb;\n      rgb[0] = rgb[1] + cr;\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = curve[0xff];\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,9 @@\n void CLASS kodak_c330_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   uchar *pixel;\n   int row, col, y, cb, cr, rgb[3], c;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  if(!image)",
                "    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5800",
        "func_name": "LibRaw/kodak_radc_load_raw",
        "description": "An off-by-one error within the \"LibRaw::kodak_ycbcr_load_raw()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.7 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/8682ad204392b914ab1cc6ebcca9c27c19c1a4b4",
        "commit_title": "0.18.17",
        "commit_text": "",
        "func_before": "void CLASS kodak_radc_load_raw()\n{\n  static const signed char src[] = {\n    1,1, 2,3, 3,4, 4,2, 5,7, 6,5, 7,6, 7,8,\n    1,0, 2,1, 3,3, 4,4, 5,2, 6,7, 7,6, 8,5, 8,8,\n    2,1, 2,3, 3,0, 3,2, 3,4, 4,6, 5,5, 6,7, 6,8,\n    2,0, 2,1, 2,3, 3,2, 4,4, 5,6, 6,7, 7,5, 7,8,\n    2,1, 2,4, 3,0, 3,2, 3,3, 4,7, 5,5, 6,6, 6,8,\n    2,3, 3,1, 3,2, 3,4, 3,5, 3,6, 4,7, 5,0, 5,8,\n    2,3, 2,6, 3,0, 3,1, 4,4, 4,5, 4,7, 5,2, 5,8,\n    2,4, 2,7, 3,3, 3,6, 4,1, 4,2, 4,5, 5,0, 5,8,\n    2,6, 3,1, 3,3, 3,5, 3,7, 3,8, 4,0, 5,2, 5,4,\n    2,0, 2,1, 3,2, 3,3, 4,4, 4,5, 5,6, 5,7, 4,8,\n    1,0, 2,2, 2,-2,\n    1,-3, 1,3,\n    2,-17, 2,-5, 2,5, 2,17,\n    2,-7, 2,2, 2,9, 2,18,\n    2,-18, 2,-9, 2,-2, 2,7,\n    2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,\n    2,-1, 2,13, 2,26, 3,39, 4,-16, 5,55, 6,-37, 6,76,\n    2,-26, 2,-13, 2,1, 3,-39, 4,16, 5,-55, 6,-76, 6,37\n  };\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = { 16,16,16 }, mul[3], buf[3][3][386];\n  static const ushort pt[] =\n    { 0,0, 1280,1344, 2320,3616, 3328,8000, 4095,16383, 65535,16383 };\n\n  for (i=2; i < 12; i+=2)\n    for (c=pt[i-2]; c <= pt[i]; c++)\n      curve[c] = (float)\n\t(c-pt[i-2]) / (pt[i]-pt[i-2]) * (pt[i+1]-pt[i-1]) + pt[i-1] + 0.5;\n  for (s=i=0; i < sizeof src; i+=2)\n    FORC(256 >> src[i])\n      ((ushort *)huff)[s++] = src[i] << 8 | (uchar) src[i+1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8-s) << 8 | c >> s << s | 1 << (s-1);\n  getbits(-1);\n  for (i=0; i < sizeof(buf)/sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row=0; row < height; row+=4) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(!mul[0] || !mul[1] || !mul[2])\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    FORC3 {\n      val = ((0x1000000/last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10:12;\n      x = ~((~0u) << (s-1));\n      val <<= 12-s;\n      for (i=0; i < sizeof(buf[0])/sizeof(short); i++)\n\t((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r=0; r <= !c; r++) {\n\tbuf[c][1][width/2] = buf[c][2][width/2] = mul[c] << 7;\n\tfor (tree=1, col=width/2; col > 0; ) {\n\t  if ((tree = radc_token(tree))) {\n\t    col -= 2;\n\t    if (tree == 8)\n\t      FORYX buf[c][y][x] = (uchar) radc_token(18) * mul[c];\n\t    else\n\t      FORYX buf[c][y][x] = radc_token(tree+10) * 16 + PREDICTOR;\n\t  } else\n\t    do {\n\t      nreps = (col > 2) ? radc_token(9) + 1 : 1;\n\t      for (rep=0; rep < 8 && rep < nreps && col > 0; rep++) {\n\t\tcol -= 2;\n\t\tFORYX buf[c][y][x] = PREDICTOR;\n\t\tif (rep & 1) {\n\t\t  step = radc_token(10) << 4;\n\t\t  FORYX buf[c][y][x] += step;\n\t\t}\n\t      }\n\t    } while (nreps == 9);\n\t}\n\tfor (y=0; y < 2; y++)\n\t  for (x=0; x < width/2; x++) {\n\t    val = (buf[c][y+1][x] << 4) / mul[c];\n\t    if (val < 0) val = 0;\n\t    if (c) RAW(row+y*2+c-1,x*2+2-c) = val;\n\t    else   RAW(row+r*2+y,x*2+y) = val;\n\t  }\n\tmemcpy (buf[c][0]+!c, buf[c][2], sizeof buf[c][0]-2*!c);\n      }\n    }\n    for (y=row; y < row+4; y++)\n      for (x=0; x < width; x++)\n\tif ((x+y) & 1) {\n\t  r = x ? x-1 : x+1;\n\t  s = x+1 < width ? x+1 : x-1;\n\t  val = (RAW(y,x)-2048)*2 + (RAW(y,r)+RAW(y,s))/2;\n\t  if (val < 0) val = 0;\n\t  RAW(y,x) = val;\n\t}\n  }",
        "func": "void CLASS kodak_radc_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  // All kodak radc images are 768x512\n  if(width>768 || raw_width>768 || height > 512 || raw_height>512 )\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  static const signed char src[] = {\n    1,1, 2,3, 3,4, 4,2, 5,7, 6,5, 7,6, 7,8,\n    1,0, 2,1, 3,3, 4,4, 5,2, 6,7, 7,6, 8,5, 8,8,\n    2,1, 2,3, 3,0, 3,2, 3,4, 4,6, 5,5, 6,7, 6,8,\n    2,0, 2,1, 2,3, 3,2, 4,4, 5,6, 6,7, 7,5, 7,8,\n    2,1, 2,4, 3,0, 3,2, 3,3, 4,7, 5,5, 6,6, 6,8,\n    2,3, 3,1, 3,2, 3,4, 3,5, 3,6, 4,7, 5,0, 5,8,\n    2,3, 2,6, 3,0, 3,1, 4,4, 4,5, 4,7, 5,2, 5,8,\n    2,4, 2,7, 3,3, 3,6, 4,1, 4,2, 4,5, 5,0, 5,8,\n    2,6, 3,1, 3,3, 3,5, 3,7, 3,8, 4,0, 5,2, 5,4,\n    2,0, 2,1, 3,2, 3,3, 4,4, 4,5, 5,6, 5,7, 4,8,\n    1,0, 2,2, 2,-2,\n    1,-3, 1,3,\n    2,-17, 2,-5, 2,5, 2,17,\n    2,-7, 2,2, 2,9, 2,18,\n    2,-18, 2,-9, 2,-2, 2,7,\n    2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,\n    2,-1, 2,13, 2,26, 3,39, 4,-16, 5,55, 6,-37, 6,76,\n    2,-26, 2,-13, 2,1, 3,-39, 4,16, 5,-55, 6,-76, 6,37\n  };\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = { 16,16,16 }, mul[3], buf[3][3][386];\n  static const ushort pt[] =\n    { 0,0, 1280,1344, 2320,3616, 3328,8000, 4095,16383, 65535,16383 };\n\n  for (i=2; i < 12; i+=2)\n    for (c=pt[i-2]; c <= pt[i]; c++)\n      curve[c] = (float)\n\t(c-pt[i-2]) / (pt[i]-pt[i-2]) * (pt[i+1]-pt[i-1]) + pt[i-1] + 0.5;\n  for (s=i=0; i < sizeof src; i+=2)\n    FORC(256 >> src[i])\n      ((ushort *)huff)[s++] = src[i] << 8 | (uchar) src[i+1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8-s) << 8 | c >> s << s | 1 << (s-1);\n  getbits(-1);\n  for (i=0; i < sizeof(buf)/sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row=0; row < height; row+=4) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(!mul[0] || !mul[1] || !mul[2])\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    FORC3 {\n      val = ((0x1000000/last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10:12;\n      x = ~((~0u) << (s-1));\n      val <<= 12-s;\n      for (i=0; i < sizeof(buf[0])/sizeof(short); i++)\n\t((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r=0; r <= !c; r++) {\n\tbuf[c][1][width/2] = buf[c][2][width/2] = mul[c] << 7;\n\tfor (tree=1, col=width/2; col > 0; ) {\n\t  if ((tree = radc_token(tree))) {\n\t    col -= 2;\n\t    if (tree == 8)\n\t      FORYX buf[c][y][x] = (uchar) radc_token(18) * mul[c];\n\t    else\n\t      FORYX buf[c][y][x] = radc_token(tree+10) * 16 + PREDICTOR;\n\t  } else\n\t    do {\n\t      nreps = (col > 2) ? radc_token(9) + 1 : 1;\n\t      for (rep=0; rep < 8 && rep < nreps && col > 0; rep++) {\n\t\tcol -= 2;\n\t\tFORYX buf[c][y][x] = PREDICTOR;\n\t\tif (rep & 1) {\n\t\t  step = radc_token(10) << 4;\n\t\t  FORYX buf[c][y][x] += step;\n\t\t}\n\t      }\n\t    } while (nreps == 9);\n\t}\n\tfor (y=0; y < 2; y++)\n\t  for (x=0; x < width/2; x++) {\n\t    val = (buf[c][y+1][x] << 4) / mul[c];\n\t    if (val < 0) val = 0;\n\t    if (c) RAW(row+y*2+c-1,x*2+2-c) = val;\n\t    else   RAW(row+r*2+y,x*2+y) = val;\n\t  }\n\tmemcpy (buf[c][0]+!c, buf[c][2], sizeof buf[c][0]-2*!c);\n      }\n    }\n    for (y=row; y < row+4; y++)\n      for (x=0; x < width; x++)\n\tif ((x+y) & 1) {\n\t  r = x ? x-1 : x+1;\n\t  s = x+1 < width ? x+1 : x-1;\n\t  val = (RAW(y,x)-2048)*2 + (RAW(y,r)+RAW(y,s))/2;\n\t  if (val < 0) val = 0;\n\t  RAW(y,x) = val;\n\t}\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,10 @@\n void CLASS kodak_radc_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  // All kodak radc images are 768x512\n+  if(width>768 || raw_width>768 || height > 512 || raw_height>512 )\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   static const signed char src[] = {\n     1,1, 2,3, 3,4, 4,2, 5,7, 6,5, 7,6, 7,8,\n     1,0, 2,1, 3,3, 4,4, 5,2, 6,7, 7,6, 8,5, 8,8,",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  // All kodak radc images are 768x512",
                "  if(width>768 || raw_width>768 || height > 512 || raw_height>512 )",
                "    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5800",
        "func_name": "LibRaw/kodak_ycbcr_load_raw",
        "description": "An off-by-one error within the \"LibRaw::kodak_ycbcr_load_raw()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.7 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/8682ad204392b914ab1cc6ebcca9c27c19c1a4b4",
        "commit_title": "0.18.17",
        "commit_text": "",
        "func_before": "void CLASS kodak_ycbcr_load_raw()\n{\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  if (!image) return;\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17)?load_flags:10;\n  for (row=0; row < height; row+=2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=128) {\n      len = MIN (128, width-col);\n      kodak_65000_decode (buf, len*3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp=buf, i=0; i < len; i+=2, bp+=2) {\n\tcb += bp[4];\n\tcr += bp[5];\n\trgb[1] = -((cb + cr + 2) >> 2);\n\trgb[2] = rgb[1] + cb;\n\trgb[0] = rgb[1] + cr;\n\tfor (j=0; j < 2; j++)\n\t  for (k=0; k < 2; k++) {\n\t    if ((y[j][k] = y[j][k^1] + *bp++) >> bits) derror();\n\t    ip = image[(row+j)*width + col+i+k];\n\t    FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];\n\t  }\n      }\n    }\n  }\n}",
        "func": "void CLASS kodak_ycbcr_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  if (!image) return;\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17)?load_flags:10;\n  for (row=0; row < height; row+=2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=128) {\n      len = MIN (128, width-col);\n      kodak_65000_decode (buf, len*3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp=buf, i=0; i < len; i+=2, bp+=2) {\n\tcb += bp[4];\n\tcr += bp[5];\n\trgb[1] = -((cb + cr + 2) >> 2);\n\trgb[2] = rgb[1] + cb;\n\trgb[0] = rgb[1] + cr;\n\tfor (j=0; j < 2; j++)\n\t  for (k=0; k < 2; k++) {\n\t    if ((y[j][k] = y[j][k^1] + *bp++) >> bits) derror();\n\t    ip = image[(row+j)*width + col+i+k];\n\t    FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];\n\t  }\n      }\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,9 @@\n void CLASS kodak_ycbcr_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   short buf[384], *bp;\n   int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n   ushort *ip;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  if(!image)",
                "    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5800",
        "func_name": "LibRaw/kodak_c603_load_raw",
        "description": "An off-by-one error within the \"LibRaw::kodak_ycbcr_load_raw()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.7 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/8682ad204392b914ab1cc6ebcca9c27c19c1a4b4",
        "commit_title": "0.18.17",
        "commit_text": "",
        "func_before": "void CLASS kodak_c603_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *) calloc (raw_width, 3*sizeof *pixel);\n  merror (pixel, \"kodak_c603_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (~row & 1)\n      if (fread (pixel, raw_width, 3, ifp) < 3) derror();\n    for (col=0; col < width; col++) {\n      y  = pixel[width*2*(row & 1) + col];\n      cb = pixel[width + (col & -2)]   - 128;\n      cr = pixel[width + (col & -2)+1] - 128;\n      rgb[1] = y - ((cb + cr + 2) >> 2);\n      rgb[2] = rgb[1] + cb;\n      rgb[0] = rgb[1] + cr;\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = curve[0xff];\n}",
        "func": "void CLASS kodak_c603_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *) calloc (raw_width, 3*sizeof *pixel);\n  merror (pixel, \"kodak_c603_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (~row & 1)\n      if (fread (pixel, raw_width, 3, ifp) < 3) derror();\n    for (col=0; col < width; col++) {\n      y  = pixel[width*2*(row & 1) + col];\n      cb = pixel[width + (col & -2)]   - 128;\n      cr = pixel[width + (col & -2)+1] - 128;\n      rgb[1] = y - ((cb + cr + 2) >> 2);\n      rgb[2] = rgb[1] + cb;\n      rgb[0] = rgb[1] + cr;\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = curve[0xff];\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,9 @@\n void CLASS kodak_c603_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   uchar *pixel;\n   int row, col, y, cb, cr, rgb[3], c;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  if(!image)",
                "    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5800",
        "func_name": "LibRaw/kodak_thumb_load_raw",
        "description": "An off-by-one error within the \"LibRaw::kodak_ycbcr_load_raw()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.7 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/8682ad204392b914ab1cc6ebcca9c27c19c1a4b4",
        "commit_title": "0.18.17",
        "commit_text": "",
        "func_before": "void CLASS kodak_thumb_load_raw()\n{\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}",
        "func": "void CLASS kodak_thumb_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,9 @@\n void CLASS kodak_thumb_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   int row, col;\n   colors = thumb_misc >> 5;\n   for (row=0; row < height; row++)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  if(!image)",
                "    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5800",
        "func_name": "LibRaw/foveon_dp_load_raw",
        "description": "An off-by-one error within the \"LibRaw::kodak_ycbcr_load_raw()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.7 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/8682ad204392b914ab1cc6ebcca9c27c19c1a4b4",
        "commit_title": "0.18.17",
        "commit_text": "",
        "func_before": "void CLASS foveon_dp_load_raw()\n{\n  unsigned c, roff[4], row, col, diff;\n  ushort huff[512], vpred[2][2], hpred[2];\n\n  fseek (ifp, 8, SEEK_CUR);\n  foveon_huff (huff);\n  roff[0] = 48;\n  FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16);\n  FORC3 {\n    fseek (ifp, data_offset+roff[c], SEEK_SET);\n    getbits(-1);\n    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;\n    for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      for (col=0; col < width; col++) {\n       diff = ljpeg_diff(huff);\n       if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n       else hpred[col & 1] += diff;\n       image[row*width+col][c] = hpred[col & 1];\n      }\n    }\n  }\n}",
        "func": "void CLASS foveon_dp_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  unsigned c, roff[4], row, col, diff;\n  ushort huff[512], vpred[2][2], hpred[2];\n\n  fseek (ifp, 8, SEEK_CUR);\n  foveon_huff (huff);\n  roff[0] = 48;\n  FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16);\n  FORC3 {\n    fseek (ifp, data_offset+roff[c], SEEK_SET);\n    getbits(-1);\n    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;\n    for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      for (col=0; col < width; col++) {\n       diff = ljpeg_diff(huff);\n       if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n       else hpred[col & 1] += diff;\n       image[row*width+col][c] = hpred[col & 1];\n      }\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,9 @@\n void CLASS foveon_dp_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   unsigned c, roff[4], row, col, diff;\n   ushort huff[512], vpred[2][2], hpred[2];\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  if(!image)",
                "    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5800",
        "func_name": "LibRaw/sinar_4shot_load_raw",
        "description": "An off-by-one error within the \"LibRaw::kodak_ycbcr_load_raw()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.7 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/8682ad204392b914ab1cc6ebcca9c27c19c1a4b4",
        "commit_title": "0.18.17",
        "commit_text": "",
        "func_before": "void CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image) {\n    shot = LIM (shot_select, 1, 4) - 1;\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n  pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n  merror (pixel, \"sinar_4shot_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (shot=0; shot < 4; shot++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    for (row=0; row < raw_height; row++) {\n      read_shorts (pixel, raw_width);\n      if ((r = row-top_margin - (shot >> 1 & 1)) >= height) continue;\n      for (col=0; col < raw_width; col++) {\n\tif ((c = col-left_margin - (shot & 1)) >= width) continue;\n\timage[r*width+c][(row & 1)*3 ^ (~col & 1)] = pixel[col];\n      }\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    free(pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  mix_green = 1;\n}",
        "func": "void CLASS sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n\n  if (raw_image) {\n    shot = LIM (shot_select, 1, 4) - 1;\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  else if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n  merror (pixel, \"sinar_4shot_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (shot=0; shot < 4; shot++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, data_offset + shot*4, SEEK_SET);\n    fseek (ifp, get4(), SEEK_SET);\n    for (row=0; row < raw_height; row++) {\n      read_shorts (pixel, raw_width);\n      if ((r = row-top_margin - (shot >> 1 & 1)) >= height) continue;\n      for (col=0; col < raw_width; col++) {\n\tif ((c = col-left_margin - (shot & 1)) >= width) continue;\n\timage[r*width+c][(row & 1)*3 ^ (~col & 1)] = pixel[col];\n      }\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    free(pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  mix_green = 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,10 @@\n     unpacked_load_raw();\n     return;\n   }\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  else if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   pixel = (ushort *) calloc (raw_width, sizeof *pixel);\n   merror (pixel, \"sinar_4shot_load_raw()\");\n #ifdef LIBRAW_LIBRARY_BUILD",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  else if(!image)",
                "    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5800",
        "func_name": "LibRaw/kodak_rgb_load_raw",
        "description": "An off-by-one error within the \"LibRaw::kodak_ycbcr_load_raw()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.7 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/8682ad204392b914ab1cc6ebcca9c27c19c1a4b4",
        "commit_title": "0.18.17",
        "commit_text": "",
        "func_before": "void CLASS kodak_rgb_load_raw()\n{\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3],ret;\n  ushort *ip=image[0];\n\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=256) {\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len*3);\n      memset (rgb, 0, sizeof rgb);\n      for (bp=buf, i=0; i < len; i++, ip+=4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(load_flags == 12)\n          {\n            FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n          }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}",
        "func": "void CLASS kodak_rgb_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  short buf[768], *bp;\n  int row, col, len, c, i, rgb[3],ret;\n  ushort *ip=image[0];\n\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=256) {\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len*3);\n      memset (rgb, 0, sizeof rgb);\n      for (bp=buf, i=0; i < len; i++, ip+=4)\n#ifdef LIBRAW_LIBRARY_BUILD\n        if(load_flags == 12)\n          {\n            FORC3 ip[c] = ret ? (*bp++) : (rgb[c] += *bp++);\n          }\n        else\n#endif\n          FORC3 if ((ip[c] = ret ? (*bp++) : (rgb[c] += *bp++)) >> 12) derror();\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,9 @@\n void CLASS kodak_rgb_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   short buf[768], *bp;\n   int row, col, len, c, i, rgb[3],ret;\n   ushort *ip=image[0];",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  if(!image)",
                "    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5800",
        "func_name": "LibRaw/nikon_yuv_load_raw",
        "description": "An off-by-one error within the \"LibRaw::kodak_ycbcr_load_raw()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.7 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/8682ad204392b914ab1cc6ebcca9c27c19c1a4b4",
        "commit_title": "0.18.17",
        "commit_text": "",
        "func_before": "void CLASS nikon_yuv_load_raw()\n{\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf=0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c]>0.001f?cam_mul[c]:1.f; }",
        "func": "void CLASS nikon_yuv_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  int row, col, yuv[4], rgb[3], b, c;\n  UINT64 bitbuf=0;\n  float cmul[4];\n  FORC4 { cmul[c] = cam_mul[c]>0.001f?cam_mul[c]:1.f; }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,9 @@\n void CLASS nikon_yuv_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   int row, col, yuv[4], rgb[3], b, c;\n   UINT64 bitbuf=0;\n   float cmul[4];",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  if(!image)",
                "    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5800",
        "func_name": "LibRaw/kodak_c330_load_raw",
        "description": "An off-by-one error within the \"LibRaw::kodak_ycbcr_load_raw()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.7 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/8682ad204392b914ab1cc6ebcca9c27c19c1a4b4",
        "commit_title": "0.18.17",
        "commit_text": "",
        "func_before": "void CLASS kodak_c330_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *) calloc (raw_width, 2*sizeof *pixel);\n  merror (pixel, \"kodak_c330_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (pixel, raw_width, 2, ifp) < 2) derror();\n    if (load_flags && (row & 31) == 31)\n      fseek (ifp, raw_width*32, SEEK_CUR);\n    for (col=0; col < width; col++) {\n      y  = pixel[col*2];\n      cb = pixel[(col*2 & -4) | 1] - 128;\n      cr = pixel[(col*2 & -4) | 3] - 128;\n      rgb[1] = y - ((cb + cr + 2) >> 2);\n      rgb[2] = rgb[1] + cb;\n      rgb[0] = rgb[1] + cr;\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = curve[0xff];\n}",
        "func": "void CLASS kodak_c330_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *) calloc (raw_width, 2*sizeof *pixel);\n  merror (pixel, \"kodak_c330_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (fread (pixel, raw_width, 2, ifp) < 2) derror();\n    if (load_flags && (row & 31) == 31)\n      fseek (ifp, raw_width*32, SEEK_CUR);\n    for (col=0; col < width; col++) {\n      y  = pixel[col*2];\n      cb = pixel[(col*2 & -4) | 1] - 128;\n      cr = pixel[(col*2 & -4) | 3] - 128;\n      rgb[1] = y - ((cb + cr + 2) >> 2);\n      rgb[2] = rgb[1] + cb;\n      rgb[0] = rgb[1] + cr;\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = curve[0xff];\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,9 @@\n void CLASS kodak_c330_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   uchar *pixel;\n   int row, col, y, cb, cr, rgb[3], c;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  if(!image)",
                "    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5800",
        "func_name": "LibRaw/kodak_ycbcr_load_raw",
        "description": "An off-by-one error within the \"LibRaw::kodak_ycbcr_load_raw()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.7 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/8682ad204392b914ab1cc6ebcca9c27c19c1a4b4",
        "commit_title": "0.18.17",
        "commit_text": "",
        "func_before": "void CLASS kodak_ycbcr_load_raw()\n{\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  if (!image) return;\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17)?load_flags:10;\n  for (row=0; row < height; row+=2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=128) {\n      len = MIN (128, width-col);\n      kodak_65000_decode (buf, len*3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp=buf, i=0; i < len; i+=2, bp+=2) {\n\tcb += bp[4];\n\tcr += bp[5];\n\trgb[1] = -((cb + cr + 2) >> 2);\n\trgb[2] = rgb[1] + cb;\n\trgb[0] = rgb[1] + cr;\n\tfor (j=0; j < 2; j++)\n\t  for (k=0; k < 2; k++) {\n\t    if ((y[j][k] = y[j][k^1] + *bp++) >> bits) derror();\n\t    ip = image[(row+j)*width + col+i+k];\n\t    FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];\n\t  }\n      }\n    }\n  }\n}",
        "func": "void CLASS kodak_ycbcr_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  short buf[384], *bp;\n  int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n  ushort *ip;\n\n  if (!image) return;\n  unsigned int bits = (load_flags && load_flags > 9 && load_flags < 17)?load_flags:10;\n  for (row=0; row < height; row+=2)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=128) {\n      len = MIN (128, width-col);\n      kodak_65000_decode (buf, len*3);\n      y[0][1] = y[1][1] = cb = cr = 0;\n      for (bp=buf, i=0; i < len; i+=2, bp+=2) {\n\tcb += bp[4];\n\tcr += bp[5];\n\trgb[1] = -((cb + cr + 2) >> 2);\n\trgb[2] = rgb[1] + cb;\n\trgb[0] = rgb[1] + cr;\n\tfor (j=0; j < 2; j++)\n\t  for (k=0; k < 2; k++) {\n\t    if ((y[j][k] = y[j][k^1] + *bp++) >> bits) derror();\n\t    ip = image[(row+j)*width + col+i+k];\n\t    FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];\n\t  }\n      }\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,9 @@\n void CLASS kodak_ycbcr_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   short buf[384], *bp;\n   int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n   ushort *ip;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  if(!image)",
                "    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5800",
        "func_name": "LibRaw/kodak_c603_load_raw",
        "description": "An off-by-one error within the \"LibRaw::kodak_ycbcr_load_raw()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.7 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/8682ad204392b914ab1cc6ebcca9c27c19c1a4b4",
        "commit_title": "0.18.17",
        "commit_text": "",
        "func_before": "void CLASS kodak_c603_load_raw()\n{\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *) calloc (raw_width, 3*sizeof *pixel);\n  merror (pixel, \"kodak_c603_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (~row & 1)\n      if (fread (pixel, raw_width, 3, ifp) < 3) derror();\n    for (col=0; col < width; col++) {\n      y  = pixel[width*2*(row & 1) + col];\n      cb = pixel[width + (col & -2)]   - 128;\n      cr = pixel[width + (col & -2)+1] - 128;\n      rgb[1] = y - ((cb + cr + 2) >> 2);\n      rgb[2] = rgb[1] + cb;\n      rgb[0] = rgb[1] + cr;\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = curve[0xff];\n}",
        "func": "void CLASS kodak_c603_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  uchar *pixel;\n  int row, col, y, cb, cr, rgb[3], c;\n\n  pixel = (uchar *) calloc (raw_width, 3*sizeof *pixel);\n  merror (pixel, \"kodak_c603_load_raw()\");\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    if (~row & 1)\n      if (fread (pixel, raw_width, 3, ifp) < 3) derror();\n    for (col=0; col < width; col++) {\n      y  = pixel[width*2*(row & 1) + col];\n      cb = pixel[width + (col & -2)]   - 128;\n      cr = pixel[width + (col & -2)+1] - 128;\n      rgb[1] = y - ((cb + cr + 2) >> 2);\n      rgb[2] = rgb[1] + cb;\n      rgb[0] = rgb[1] + cr;\n      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch(...) {\n    free (pixel);\n    throw;\n  }\n#endif\n  free (pixel);\n  maximum = curve[0xff];\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,9 @@\n void CLASS kodak_c603_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   uchar *pixel;\n   int row, col, y, cb, cr, rgb[3], c;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  if(!image)",
                "    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5800",
        "func_name": "LibRaw/kodak_thumb_load_raw",
        "description": "An off-by-one error within the \"LibRaw::kodak_ycbcr_load_raw()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.7 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/8682ad204392b914ab1cc6ebcca9c27c19c1a4b4",
        "commit_title": "0.18.17",
        "commit_text": "",
        "func_before": "void CLASS kodak_thumb_load_raw()\n{\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}",
        "func": "void CLASS kodak_thumb_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,9 @@\n void CLASS kodak_thumb_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   int row, col;\n   colors = thumb_misc >> 5;\n   for (row=0; row < height; row++)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  if(!image)",
                "    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5800",
        "func_name": "LibRaw/kodak_radc_load_raw",
        "description": "An off-by-one error within the \"LibRaw::kodak_ycbcr_load_raw()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.7 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/8682ad204392b914ab1cc6ebcca9c27c19c1a4b4",
        "commit_title": "0.18.17",
        "commit_text": "",
        "func_before": "void CLASS kodak_radc_load_raw()\n{\n  static const signed char src[] = {\n    1,1, 2,3, 3,4, 4,2, 5,7, 6,5, 7,6, 7,8,\n    1,0, 2,1, 3,3, 4,4, 5,2, 6,7, 7,6, 8,5, 8,8,\n    2,1, 2,3, 3,0, 3,2, 3,4, 4,6, 5,5, 6,7, 6,8,\n    2,0, 2,1, 2,3, 3,2, 4,4, 5,6, 6,7, 7,5, 7,8,\n    2,1, 2,4, 3,0, 3,2, 3,3, 4,7, 5,5, 6,6, 6,8,\n    2,3, 3,1, 3,2, 3,4, 3,5, 3,6, 4,7, 5,0, 5,8,\n    2,3, 2,6, 3,0, 3,1, 4,4, 4,5, 4,7, 5,2, 5,8,\n    2,4, 2,7, 3,3, 3,6, 4,1, 4,2, 4,5, 5,0, 5,8,\n    2,6, 3,1, 3,3, 3,5, 3,7, 3,8, 4,0, 5,2, 5,4,\n    2,0, 2,1, 3,2, 3,3, 4,4, 4,5, 5,6, 5,7, 4,8,\n    1,0, 2,2, 2,-2,\n    1,-3, 1,3,\n    2,-17, 2,-5, 2,5, 2,17,\n    2,-7, 2,2, 2,9, 2,18,\n    2,-18, 2,-9, 2,-2, 2,7,\n    2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,\n    2,-1, 2,13, 2,26, 3,39, 4,-16, 5,55, 6,-37, 6,76,\n    2,-26, 2,-13, 2,1, 3,-39, 4,16, 5,-55, 6,-76, 6,37\n  };\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = { 16,16,16 }, mul[3], buf[3][3][386];\n  static const ushort pt[] =\n    { 0,0, 1280,1344, 2320,3616, 3328,8000, 4095,16383, 65535,16383 };\n\n  for (i=2; i < 12; i+=2)\n    for (c=pt[i-2]; c <= pt[i]; c++)\n      curve[c] = (float)\n\t(c-pt[i-2]) / (pt[i]-pt[i-2]) * (pt[i+1]-pt[i-1]) + pt[i-1] + 0.5;\n  for (s=i=0; i < sizeof src; i+=2)\n    FORC(256 >> src[i])\n      ((ushort *)huff)[s++] = src[i] << 8 | (uchar) src[i+1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8-s) << 8 | c >> s << s | 1 << (s-1);\n  getbits(-1);\n  for (i=0; i < sizeof(buf)/sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row=0; row < height; row+=4) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(!mul[0] || !mul[1] || !mul[2])\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    FORC3 {\n      val = ((0x1000000/last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10:12;\n      x = ~((~0u) << (s-1));\n      val <<= 12-s;\n      for (i=0; i < sizeof(buf[0])/sizeof(short); i++)\n\t((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r=0; r <= !c; r++) {\n\tbuf[c][1][width/2] = buf[c][2][width/2] = mul[c] << 7;\n\tfor (tree=1, col=width/2; col > 0; ) {\n\t  if ((tree = radc_token(tree))) {\n\t    col -= 2;\n\t    if (tree == 8)\n\t      FORYX buf[c][y][x] = (uchar) radc_token(18) * mul[c];\n\t    else\n\t      FORYX buf[c][y][x] = radc_token(tree+10) * 16 + PREDICTOR;\n\t  } else\n\t    do {\n\t      nreps = (col > 2) ? radc_token(9) + 1 : 1;\n\t      for (rep=0; rep < 8 && rep < nreps && col > 0; rep++) {\n\t\tcol -= 2;\n\t\tFORYX buf[c][y][x] = PREDICTOR;\n\t\tif (rep & 1) {\n\t\t  step = radc_token(10) << 4;\n\t\t  FORYX buf[c][y][x] += step;\n\t\t}\n\t      }\n\t    } while (nreps == 9);\n\t}\n\tfor (y=0; y < 2; y++)\n\t  for (x=0; x < width/2; x++) {\n\t    val = (buf[c][y+1][x] << 4) / mul[c];\n\t    if (val < 0) val = 0;\n\t    if (c) RAW(row+y*2+c-1,x*2+2-c) = val;\n\t    else   RAW(row+r*2+y,x*2+y) = val;\n\t  }\n\tmemcpy (buf[c][0]+!c, buf[c][2], sizeof buf[c][0]-2*!c);\n      }\n    }\n    for (y=row; y < row+4; y++)\n      for (x=0; x < width; x++)\n\tif ((x+y) & 1) {\n\t  r = x ? x-1 : x+1;\n\t  s = x+1 < width ? x+1 : x-1;\n\t  val = (RAW(y,x)-2048)*2 + (RAW(y,r)+RAW(y,s))/2;\n\t  if (val < 0) val = 0;\n\t  RAW(y,x) = val;\n\t}\n  }",
        "func": "void CLASS kodak_radc_load_raw()\n{\n#ifdef LIBRAW_LIBRARY_BUILD\n  // All kodak radc images are 768x512\n  if(width>768 || raw_width>768 || height > 512 || raw_height>512 )\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  static const signed char src[] = {\n    1,1, 2,3, 3,4, 4,2, 5,7, 6,5, 7,6, 7,8,\n    1,0, 2,1, 3,3, 4,4, 5,2, 6,7, 7,6, 8,5, 8,8,\n    2,1, 2,3, 3,0, 3,2, 3,4, 4,6, 5,5, 6,7, 6,8,\n    2,0, 2,1, 2,3, 3,2, 4,4, 5,6, 6,7, 7,5, 7,8,\n    2,1, 2,4, 3,0, 3,2, 3,3, 4,7, 5,5, 6,6, 6,8,\n    2,3, 3,1, 3,2, 3,4, 3,5, 3,6, 4,7, 5,0, 5,8,\n    2,3, 2,6, 3,0, 3,1, 4,4, 4,5, 4,7, 5,2, 5,8,\n    2,4, 2,7, 3,3, 3,6, 4,1, 4,2, 4,5, 5,0, 5,8,\n    2,6, 3,1, 3,3, 3,5, 3,7, 3,8, 4,0, 5,2, 5,4,\n    2,0, 2,1, 3,2, 3,3, 4,4, 4,5, 5,6, 5,7, 4,8,\n    1,0, 2,2, 2,-2,\n    1,-3, 1,3,\n    2,-17, 2,-5, 2,5, 2,17,\n    2,-7, 2,2, 2,9, 2,18,\n    2,-18, 2,-9, 2,-2, 2,7,\n    2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,\n    2,-1, 2,13, 2,26, 3,39, 4,-16, 5,55, 6,-37, 6,76,\n    2,-26, 2,-13, 2,1, 3,-39, 4,16, 5,-55, 6,-76, 6,37\n  };\n  ushort huff[19][256];\n  int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;\n  short last[3] = { 16,16,16 }, mul[3], buf[3][3][386];\n  static const ushort pt[] =\n    { 0,0, 1280,1344, 2320,3616, 3328,8000, 4095,16383, 65535,16383 };\n\n  for (i=2; i < 12; i+=2)\n    for (c=pt[i-2]; c <= pt[i]; c++)\n      curve[c] = (float)\n\t(c-pt[i-2]) / (pt[i]-pt[i-2]) * (pt[i+1]-pt[i-1]) + pt[i-1] + 0.5;\n  for (s=i=0; i < sizeof src; i+=2)\n    FORC(256 >> src[i])\n      ((ushort *)huff)[s++] = src[i] << 8 | (uchar) src[i+1];\n  s = kodak_cbpp == 243 ? 2 : 3;\n  FORC(256) huff[18][c] = (8-s) << 8 | c >> s << s | 1 << (s-1);\n  getbits(-1);\n  for (i=0; i < sizeof(buf)/sizeof(short); i++)\n    ((short *)buf)[i] = 2048;\n  for (row=0; row < height; row+=4) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    FORC3 mul[c] = getbits(6);\n#ifdef LIBRAW_LIBRARY_BUILD\n    if(!mul[0] || !mul[1] || !mul[2])\n      throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n    FORC3 {\n      val = ((0x1000000/last[c] + 0x7ff) >> 12) * mul[c];\n      s = val > 65564 ? 10:12;\n      x = ~((~0u) << (s-1));\n      val <<= 12-s;\n      for (i=0; i < sizeof(buf[0])/sizeof(short); i++)\n\t((short *)buf[c])[i] = (((short *)buf[c])[i] * val + x) >> s;\n      last[c] = mul[c];\n      for (r=0; r <= !c; r++) {\n\tbuf[c][1][width/2] = buf[c][2][width/2] = mul[c] << 7;\n\tfor (tree=1, col=width/2; col > 0; ) {\n\t  if ((tree = radc_token(tree))) {\n\t    col -= 2;\n\t    if (tree == 8)\n\t      FORYX buf[c][y][x] = (uchar) radc_token(18) * mul[c];\n\t    else\n\t      FORYX buf[c][y][x] = radc_token(tree+10) * 16 + PREDICTOR;\n\t  } else\n\t    do {\n\t      nreps = (col > 2) ? radc_token(9) + 1 : 1;\n\t      for (rep=0; rep < 8 && rep < nreps && col > 0; rep++) {\n\t\tcol -= 2;\n\t\tFORYX buf[c][y][x] = PREDICTOR;\n\t\tif (rep & 1) {\n\t\t  step = radc_token(10) << 4;\n\t\t  FORYX buf[c][y][x] += step;\n\t\t}\n\t      }\n\t    } while (nreps == 9);\n\t}\n\tfor (y=0; y < 2; y++)\n\t  for (x=0; x < width/2; x++) {\n\t    val = (buf[c][y+1][x] << 4) / mul[c];\n\t    if (val < 0) val = 0;\n\t    if (c) RAW(row+y*2+c-1,x*2+2-c) = val;\n\t    else   RAW(row+r*2+y,x*2+y) = val;\n\t  }\n\tmemcpy (buf[c][0]+!c, buf[c][2], sizeof buf[c][0]-2*!c);\n      }\n    }\n    for (y=row; y < row+4; y++)\n      for (x=0; x < width; x++)\n\tif ((x+y) & 1) {\n\t  r = x ? x-1 : x+1;\n\t  s = x+1 < width ? x+1 : x-1;\n\t  val = (RAW(y,x)-2048)*2 + (RAW(y,r)+RAW(y,s))/2;\n\t  if (val < 0) val = 0;\n\t  RAW(y,x) = val;\n\t}\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,10 @@\n void CLASS kodak_radc_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  // All kodak radc images are 768x512\n+  if(width>768 || raw_width>768 || height > 512 || raw_height>512 )\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   static const signed char src[] = {\n     1,1, 2,3, 3,4, 4,2, 5,7, 6,5, 7,6, 7,8,\n     1,0, 2,1, 3,3, 4,4, 5,2, 6,7, 7,6, 8,5, 8,8,",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  // All kodak radc images are 768x512",
                "  if(width>768 || raw_width>768 || height > 512 || raw_height>512 )",
                "    throw LIBRAW_EXCEPTION_IO_CORRUPT;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5800",
        "func_name": "LibRaw/LibRaw::unpack",
        "description": "An off-by-one error within the \"LibRaw::kodak_ycbcr_load_raw()\" function (internal/dcraw_common.cpp) in LibRaw versions prior to 0.18.7 can be exploited to cause a heap-based buffer overflow and subsequently cause a crash.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/8682ad204392b914ab1cc6ebcca9c27c19c1a4b4",
        "commit_title": "0.18.17",
        "commit_text": "",
        "func_before": "int LibRaw::unpack(void)\n{\n  CHECK_ORDER_HIGH(LIBRAW_PROGRESS_LOAD_RAW);\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  try {\n\n    if(!libraw_internal_data.internal_data.input)\n      return LIBRAW_INPUT_CLOSED;\n\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,0,2);\n    if (O.shot_select >= P1.raw_count)\n      return LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE;\n\n    if(!load_raw)\n      return LIBRAW_UNSPECIFIED_ERROR;\n\n    // already allocated ?\n    if(imgdata.image)\n      {\n        free(imgdata.image);\n        imgdata.image = 0;\n      }\n    if(imgdata.rawdata.raw_alloc)\n      {\n        free(imgdata.rawdata.raw_alloc);\n        imgdata.rawdata.raw_alloc = 0;\n      }\n    if (libraw_internal_data.unpacker_data.meta_length)\n      {\n        libraw_internal_data.internal_data.meta_data =\n          (char *) malloc (libraw_internal_data.unpacker_data.meta_length);\n        merror (libraw_internal_data.internal_data.meta_data, \"LibRaw::unpack()\");\n      }\n\n    libraw_decoder_info_t decoder_info;\n    get_decoder_info(&decoder_info);\n\n    int save_iwidth = S.iwidth, save_iheight = S.iheight, save_shrink = IO.shrink;\n\n    int rwidth = S.raw_width, rheight = S.raw_height;\n    if( !IO.fuji_width)\n      {\n        // adjust non-Fuji allocation\n        if(rwidth < S.width + S.left_margin)\n          rwidth = S.width + S.left_margin;\n        if(rheight < S.height + S.top_margin)\n          rheight = S.height + S.top_margin;\n      }\n\n    imgdata.rawdata.raw_image = 0;\n    imgdata.rawdata.color4_image = 0;\n    imgdata.rawdata.color3_image = 0;\n\timgdata.rawdata.float_image = 0;\n\timgdata.rawdata.float3_image = 0;\n\n#ifdef USE_DNGSDK\n\tif(imgdata.idata.dng_version && dnghost && valid_for_dngsdk() && load_raw != &LibRaw::pentax_4shot_load_raw)\n\t{\n\t\tint rr = try_dngsdk();\n\t}\n#endif\n\n#ifdef USE_RAWSPEED\n\tif(!raw_was_read())\n\t{\n\t\tint rawspeed_enabled = 1;\n\n\t\tif(imgdata.idata.dng_version && libraw_internal_data.unpacker_data.tiff_samples == 2)\n\t\t\trawspeed_enabled = 0;\n\n\t\tif(imgdata.idata.raw_count > 1)\n\t\t\trawspeed_enabled = 0;\n\n\t\t// Disable rawspeed for double-sized Oly files\n\t\tif(!strncasecmp(imgdata.idata.make,\"Olympus\",7) &&\n\t\t\t( ( imgdata.sizes.raw_width > 6000) || !strncasecmp(imgdata.idata.model,\"SH-2\",4) || !strncasecmp(imgdata.idata.model,\"SH-3\",4) || !strncasecmp(imgdata.idata.model,\"TG-4\",4))\n\t\t\t)\n\t\t\trawspeed_enabled = 0;\n\n\t\tif(imgdata.idata.dng_version && imgdata.idata.filters==0 && libraw_internal_data.unpacker_data.tiff_bps == 8) // Disable for 8 bit\n\t\t\trawspeed_enabled = 0;\n\n\t\tif(load_raw == &LibRaw::packed_load_raw && !strncasecmp(imgdata.idata.make,\"Nikon\",5) && !strncasecmp(imgdata.idata.model,\"E\",1) )\n\t\t\trawspeed_enabled = 0;\n\n\t\t// RawSpeed Supported,\n\t\tif(O.use_rawspeed  && rawspeed_enabled\n\t\t\t&& !(is_sraw() && (O.raw_processing_options & (LIBRAW_PROCESSING_SRAW_NO_RGB | LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)))\n\t\t\t&& (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) && _rawspeed_camerameta)\n\t\t{\n\t\t\tint rr = try_rawspeed();\n\t\t}\n\t}\n#endif\n    if(!raw_was_read()) //RawSpeed failed or not run\n      {\n        // Not allocated on RawSpeed call, try call LibRaow\n\t\tint zero_rawimage = 0;\n        if(decoder_info.decoder_flags &  LIBRAW_DECODER_OWNALLOC)\n          {\n            // x3f foveon decoder and DNG float\n            // Do nothing! Decoder will allocate data internally\n          }\n        else if(imgdata.idata.filters || P1.colors == 1) // Bayer image or single color -> decode to raw_image\n          {\n            imgdata.rawdata.raw_alloc = malloc(rwidth*(rheight+8)*sizeof(imgdata.rawdata.raw_image[0]));\n            imgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;\n            if(!S.raw_pitch)\n                S.raw_pitch = S.raw_width*2; // Bayer case, not set before\n          }\n        else // NO LEGACY FLAG if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n          {\n            // sRAW and old Foveon decoders only, so extra buffer size is just 1/4\n            S.iwidth = S.width;\n            S.iheight= S.height;\n            IO.shrink = 0;\n\t\t\tif(!S.raw_pitch)\n\t\t\t\tS.raw_pitch = (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS) ? S.raw_width*8 : S.width*8;\n            // allocate image as temporary buffer, size\n            imgdata.rawdata.raw_alloc = 0;\n            imgdata.image = (ushort (*)[4]) calloc(unsigned(S.raw_width)*unsigned(S.raw_height),sizeof(*imgdata.image));\n\t\t\tif(!(decoder_info.decoder_flags &  LIBRAW_DECODER_ADOBECOPYPIXEL))\n\t\t\t{\n\t\t\t\timgdata.rawdata.raw_image = (ushort*) imgdata.image ;\n\t\t\t\tzero_rawimage = 1;\n\t\t\t}\n          }\n        ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n\n        unsigned m_save = C.maximum;\n        if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))\n          C.maximum=65535;\n        (this->*load_raw)();\n\t\tif(zero_rawimage)\n\t\t\timgdata.rawdata.raw_image = 0;\n        if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))\n          C.maximum = m_save;\n        if(decoder_info.decoder_flags &  LIBRAW_DECODER_OWNALLOC)\n          {\n            // x3f foveon decoder only: do nothing\n\n          }\n        else if (!(imgdata.idata.filters || P1.colors == 1) ) // legacy decoder, ownalloc handled above\n          {\n            // successfully decoded legacy image, attach image to raw_alloc\n            imgdata.rawdata.raw_alloc = imgdata.image;\n\t\t    imgdata.rawdata.color4_image = (ushort (*)[4]) imgdata.rawdata.raw_alloc;\n            imgdata.image = 0;\n            // Restore saved values. Note: Foveon have masked frame\n            // Other 4-color legacy data: no borders\n\t\t\tif(!(libraw_internal_data.unpacker_data.load_flags & 256))\n\t\t\t{\n\t\t\t\tS.raw_width = S.width;\n\t\t\t\tS.left_margin = 0;\n\t\t\t\tS.raw_height = S.height;\n\t\t\t\tS.top_margin = 0;\n\t\t\t}\n          }\n      }\n\n    if(imgdata.rawdata.raw_image)\n      crop_masked_pixels(); // calculate black levels\n\n    // recover image sizes\n    S.iwidth = save_iwidth;\n    S.iheight = save_iheight;\n    IO.shrink = save_shrink;\n\n    // adjust black to possible maximum\n    unsigned int i = C.cblack[3];\n    unsigned int c;\n    for(c=0;c<3;c++)\n      if (i > C.cblack[c]) i = C.cblack[c];\n    for (c=0;c<4;c++)\n      C.cblack[c] -= i;\n    C.black += i;\n\n    // Save color,sizes and internal data into raw_image fields\n    memmove(&imgdata.rawdata.color,&imgdata.color,sizeof(imgdata.color));\n    memmove(&imgdata.rawdata.sizes,&imgdata.sizes,sizeof(imgdata.sizes));\n    memmove(&imgdata.rawdata.iparams,&imgdata.idata,sizeof(imgdata.idata));\n    memmove(&imgdata.rawdata.ioparams,&libraw_internal_data.internal_output_params,sizeof(libraw_internal_data.internal_output_params));\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_LOAD_RAW);\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,1,2);\n\n    return 0;\n  }\n  catch ( LibRaw_exceptions err) {\n    EXCEPTION_HANDLER(err);\n  }\n  catch (std::exception ee) {\n    EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);\n  }\n}",
        "func": "int LibRaw::unpack(void)\n{\n  CHECK_ORDER_HIGH(LIBRAW_PROGRESS_LOAD_RAW);\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  try {\n\n    if(!libraw_internal_data.internal_data.input)\n      return LIBRAW_INPUT_CLOSED;\n\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,0,2);\n    if (O.shot_select >= P1.raw_count)\n      return LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE;\n\n    if(!load_raw)\n      return LIBRAW_UNSPECIFIED_ERROR;\n\n    // already allocated ?\n    if(imgdata.image)\n      {\n        free(imgdata.image);\n        imgdata.image = 0;\n      }\n    if(imgdata.rawdata.raw_alloc)\n      {\n        free(imgdata.rawdata.raw_alloc);\n        imgdata.rawdata.raw_alloc = 0;\n      }\n    if (libraw_internal_data.unpacker_data.meta_length)\n      {\n        libraw_internal_data.internal_data.meta_data =\n          (char *) malloc (libraw_internal_data.unpacker_data.meta_length);\n        merror (libraw_internal_data.internal_data.meta_data, \"LibRaw::unpack()\");\n      }\n\n    libraw_decoder_info_t decoder_info;\n    get_decoder_info(&decoder_info);\n\n    int save_iwidth = S.iwidth, save_iheight = S.iheight, save_shrink = IO.shrink;\n\n    int rwidth = S.raw_width, rheight = S.raw_height;\n    if( !IO.fuji_width)\n      {\n        // adjust non-Fuji allocation\n        if(rwidth < S.width + S.left_margin)\n          rwidth = S.width + S.left_margin;\n        if(rheight < S.height + S.top_margin)\n          rheight = S.height + S.top_margin;\n      }\n\n    imgdata.rawdata.raw_image = 0;\n    imgdata.rawdata.color4_image = 0;\n    imgdata.rawdata.color3_image = 0;\n\timgdata.rawdata.float_image = 0;\n\timgdata.rawdata.float3_image = 0;\n\n#ifdef USE_DNGSDK\n\tif(imgdata.idata.dng_version && dnghost && valid_for_dngsdk() && load_raw != &LibRaw::pentax_4shot_load_raw)\n\t{\n\t\tint rr = try_dngsdk();\n\t}\n#endif\n\n#ifdef USE_RAWSPEED\n\tif(!raw_was_read())\n\t{\n\t\tint rawspeed_enabled = 1;\n\n\t\tif(imgdata.idata.dng_version && libraw_internal_data.unpacker_data.tiff_samples == 2)\n\t\t\trawspeed_enabled = 0;\n\n\t\tif(imgdata.idata.raw_count > 1)\n\t\t\trawspeed_enabled = 0;\n\n\t\t// Disable rawspeed for double-sized Oly files\n\t\tif(!strncasecmp(imgdata.idata.make,\"Olympus\",7) &&\n\t\t\t( ( imgdata.sizes.raw_width > 6000) || !strncasecmp(imgdata.idata.model,\"SH-2\",4) || !strncasecmp(imgdata.idata.model,\"SH-3\",4) || !strncasecmp(imgdata.idata.model,\"TG-4\",4))\n\t\t\t)\n\t\t\trawspeed_enabled = 0;\n\n\t\tif(imgdata.idata.dng_version && imgdata.idata.filters==0 && libraw_internal_data.unpacker_data.tiff_bps == 8) // Disable for 8 bit\n\t\t\trawspeed_enabled = 0;\n\n\t\tif(load_raw == &LibRaw::packed_load_raw && !strncasecmp(imgdata.idata.make,\"Nikon\",5) && !strncasecmp(imgdata.idata.model,\"E\",1) )\n\t\t\trawspeed_enabled = 0;\n\n\t\t// RawSpeed Supported,\n\t\tif(O.use_rawspeed  && rawspeed_enabled\n\t\t\t&& !(is_sraw() && (O.raw_processing_options & (LIBRAW_PROCESSING_SRAW_NO_RGB | LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE)))\n\t\t\t&& (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) && _rawspeed_camerameta)\n\t\t{\n\t\t\tint rr = try_rawspeed();\n\t\t}\n\t}\n#endif\n    if(!raw_was_read()) //RawSpeed failed or not run\n      {\n        // Not allocated on RawSpeed call, try call LibRaow\n\t\tint zero_rawimage = 0;\n        if(decoder_info.decoder_flags &  LIBRAW_DECODER_OWNALLOC)\n          {\n            // x3f foveon decoder and DNG float\n            // Do nothing! Decoder will allocate data internally\n          }\n        else if(imgdata.idata.filters || P1.colors == 1) // Bayer image or single color -> decode to raw_image\n          {\n            imgdata.rawdata.raw_alloc = malloc(rwidth*(rheight+8)*sizeof(imgdata.rawdata.raw_image[0]));\n            imgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc;\n            if(!S.raw_pitch)\n                S.raw_pitch = S.raw_width*2; // Bayer case, not set before\n          }\n        else // NO LEGACY FLAG if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n          {\n            // sRAW and old Foveon decoders only, so extra buffer size is just 1/4\n            S.iwidth = S.width;\n            S.iheight= S.height;\n            IO.shrink = 0;\n\t\t\tif(!S.raw_pitch)\n\t\t\t\tS.raw_pitch = (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS) ? S.raw_width*8 : S.width*8;\n            // allocate image as temporary buffer, size\n            imgdata.rawdata.raw_alloc = 0;\n            imgdata.image = (ushort (*)[4]) calloc(unsigned(MAX(S.width,S.raw_width))*unsigned(MAX(S.height,S.raw_height)),sizeof(*imgdata.image));\n\t\t\tif(!(decoder_info.decoder_flags &  LIBRAW_DECODER_ADOBECOPYPIXEL))\n\t\t\t{\n\t\t\t\timgdata.rawdata.raw_image = (ushort*) imgdata.image ;\n\t\t\t\tzero_rawimage = 1;\n\t\t\t}\n          }\n        ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n\n        unsigned m_save = C.maximum;\n        if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))\n          C.maximum=65535;\n        (this->*load_raw)();\n\t\tif(zero_rawimage)\n\t\t\timgdata.rawdata.raw_image = 0;\n        if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))\n          C.maximum = m_save;\n        if(decoder_info.decoder_flags &  LIBRAW_DECODER_OWNALLOC)\n          {\n            // x3f foveon decoder only: do nothing\n\n          }\n        else if (!(imgdata.idata.filters || P1.colors == 1) ) // legacy decoder, ownalloc handled above\n          {\n            // successfully decoded legacy image, attach image to raw_alloc\n            imgdata.rawdata.raw_alloc = imgdata.image;\n\t\t    imgdata.rawdata.color4_image = (ushort (*)[4]) imgdata.rawdata.raw_alloc;\n            imgdata.image = 0;\n            // Restore saved values. Note: Foveon have masked frame\n            // Other 4-color legacy data: no borders\n\t\t\tif(!(libraw_internal_data.unpacker_data.load_flags & 256))\n\t\t\t{\n\t\t\t\tS.raw_width = S.width;\n\t\t\t\tS.left_margin = 0;\n\t\t\t\tS.raw_height = S.height;\n\t\t\t\tS.top_margin = 0;\n\t\t\t}\n          }\n      }\n\n    if(imgdata.rawdata.raw_image)\n      crop_masked_pixels(); // calculate black levels\n\n    // recover image sizes\n    S.iwidth = save_iwidth;\n    S.iheight = save_iheight;\n    IO.shrink = save_shrink;\n\n    // adjust black to possible maximum\n    unsigned int i = C.cblack[3];\n    unsigned int c;\n    for(c=0;c<3;c++)\n      if (i > C.cblack[c]) i = C.cblack[c];\n    for (c=0;c<4;c++)\n      C.cblack[c] -= i;\n    C.black += i;\n\n    // Save color,sizes and internal data into raw_image fields\n    memmove(&imgdata.rawdata.color,&imgdata.color,sizeof(imgdata.color));\n    memmove(&imgdata.rawdata.sizes,&imgdata.sizes,sizeof(imgdata.sizes));\n    memmove(&imgdata.rawdata.iparams,&imgdata.idata,sizeof(imgdata.idata));\n    memmove(&imgdata.rawdata.ioparams,&libraw_internal_data.internal_output_params,sizeof(libraw_internal_data.internal_output_params));\n\n    SET_PROC_FLAG(LIBRAW_PROGRESS_LOAD_RAW);\n    RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,1,2);\n\n    return 0;\n  }\n  catch ( LibRaw_exceptions err) {\n    EXCEPTION_HANDLER(err);\n  }\n  catch (std::exception ee) {\n    EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -118,7 +118,7 @@\n \t\t\t\tS.raw_pitch = (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS) ? S.raw_width*8 : S.width*8;\n             // allocate image as temporary buffer, size\n             imgdata.rawdata.raw_alloc = 0;\n-            imgdata.image = (ushort (*)[4]) calloc(unsigned(S.raw_width)*unsigned(S.raw_height),sizeof(*imgdata.image));\n+            imgdata.image = (ushort (*)[4]) calloc(unsigned(MAX(S.width,S.raw_width))*unsigned(MAX(S.height,S.raw_height)),sizeof(*imgdata.image));\n \t\t\tif(!(decoder_info.decoder_flags &  LIBRAW_DECODER_ADOBECOPYPIXEL))\n \t\t\t{\n \t\t\t\timgdata.rawdata.raw_image = (ushort*) imgdata.image ;",
        "diff_line_info": {
            "deleted_lines": [
                "            imgdata.image = (ushort (*)[4]) calloc(unsigned(S.raw_width)*unsigned(S.raw_height),sizeof(*imgdata.image));"
            ],
            "added_lines": [
                "            imgdata.image = (ushort (*)[4]) calloc(unsigned(MAX(S.width,S.raw_width))*unsigned(MAX(S.height,S.raw_height)),sizeof(*imgdata.image));"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-46853",
        "func_name": "memcached/_process_request_metaflags",
        "description": "In Memcached before 1.6.22, an off-by-one error exists when processing proxy requests in proxy mode, if \\n is used instead of \\r\\n.",
        "git_url": "https://github.com/memcached/memcached/commit/6987918e9a3094ec4fc8976f01f769f624d790fa",
        "commit_title": "proxy: fix off-by-one if \\r is missing",
        "commit_text": " A bunch of the parser assumed we only had \\r\\n, but I didn't actually have that strictness set. Some commands worked and some broke in subtle ways when just \"\\n\" was being submitted.  I'm not 100% confident in this change yet so I'm opening a PR to stage it while I run some more thorough tests.",
        "func_before": "static int _process_request_metaflags(mcp_parser_t *pr, int token) {\n    if (pr->ntokens <= token) {\n        pr->t.meta.flags = 0; // no flags found.\n        return 0;\n    }\n    const char *cur = pr->request + pr->tokens[token];\n    const char *end = pr->request + pr->reqlen - 2;\n\n    // We blindly convert flags into bits, since the range of possible\n    // flags is deliberately < 64.\n    int state = 0;\n    while (cur != end) {\n        switch (state) {\n            case 0:\n                if (*cur == ' ') {\n                    cur++;\n                } else {\n                    if (*cur < 65 || *cur > 122) {\n                        return -1;\n                    }\n                    P_DEBUG(\"%s: setting meta flag: %d\\n\", __func__, *cur - 65);\n                    pr->t.meta.flags |= (uint64_t)1 << (*cur - 65);\n                    state = 1;\n                }\n                break;\n            case 1:\n                if (*cur != ' ') {\n                    cur++;\n                } else {\n                    state = 0;\n                }\n                break;\n        }\n    }\n\n    // not too great hack for noreply detection: this can be flattened out\n    // once a few other contexts are fixed and we detect the noreply from the\n    // coroutine start instead.\n    if (pr->t.meta.flags & ((uint64_t)1 << 48)) {\n        pr->noreply = true;\n    }\n\n    return 0;\n}",
        "func": "static int _process_request_metaflags(mcp_parser_t *pr, int token) {\n    if (pr->ntokens <= token) {\n        pr->t.meta.flags = 0; // no flags found.\n        return 0;\n    }\n    const char *cur = pr->request + pr->tokens[token];\n    const char *end = pr->request + pr->endlen;\n\n    // We blindly convert flags into bits, since the range of possible\n    // flags is deliberately < 64.\n    int state = 0;\n    while (cur != end) {\n        switch (state) {\n            case 0:\n                if (*cur == ' ') {\n                    cur++;\n                } else {\n                    if (*cur < 65 || *cur > 122) {\n                        return -1;\n                    }\n                    P_DEBUG(\"%s: setting meta flag: %d\\n\", __func__, *cur - 65);\n                    pr->t.meta.flags |= (uint64_t)1 << (*cur - 65);\n                    state = 1;\n                }\n                break;\n            case 1:\n                if (*cur != ' ') {\n                    cur++;\n                } else {\n                    state = 0;\n                }\n                break;\n        }\n    }\n\n    // not too great hack for noreply detection: this can be flattened out\n    // once a few other contexts are fixed and we detect the noreply from the\n    // coroutine start instead.\n    if (pr->t.meta.flags & ((uint64_t)1 << 48)) {\n        pr->noreply = true;\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n         return 0;\n     }\n     const char *cur = pr->request + pr->tokens[token];\n-    const char *end = pr->request + pr->reqlen - 2;\n+    const char *end = pr->request + pr->endlen;\n \n     // We blindly convert flags into bits, since the range of possible\n     // flags is deliberately < 64.",
        "diff_line_info": {
            "deleted_lines": [
                "    const char *end = pr->request + pr->reqlen - 2;"
            ],
            "added_lines": [
                "    const char *end = pr->request + pr->endlen;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-46853",
        "func_name": "memcached/process_request",
        "description": "In Memcached before 1.6.22, an off-by-one error exists when processing proxy requests in proxy mode, if \\n is used instead of \\r\\n.",
        "git_url": "https://github.com/memcached/memcached/commit/6987918e9a3094ec4fc8976f01f769f624d790fa",
        "commit_title": "proxy: fix off-by-one if \\r is missing",
        "commit_text": " A bunch of the parser assumed we only had \\r\\n, but I didn't actually have that strictness set. Some commands worked and some broke in subtle ways when just \"\\n\" was being submitted.  I'm not 100% confident in this change yet so I'm opening a PR to stage it while I run some more thorough tests.",
        "func_before": "int process_request(mcp_parser_t *pr, const char *command, size_t cmdlen) {\n    // we want to \"parse in place\" as much as possible, which allows us to\n    // forward an unmodified request without having to rebuild it.\n\n    const char *cm = command;\n    size_t cl = 0;\n    // min command length is 2, plus the \"\\r\\n\"\n    if (cmdlen < 4) {\n        return -1;\n    }\n\n    const char *s = memchr(command, ' ', cmdlen-2);\n    if (s != NULL) {\n        cl = s - command;\n    } else {\n        cl = cmdlen - 2;\n    }\n    pr->keytoken = 0;\n    pr->has_space = false;\n    pr->parsed = cl + 1;\n    pr->request = command;\n    pr->reqlen = cmdlen;\n    int token_max = PARSER_MAX_TOKENS;\n\n    int cmd = -1;\n    int type = CMD_TYPE_GENERIC;\n    int ret = 0;\n\n    switch (cl) {\n        case 0:\n        case 1:\n            // falls through with cmd as -1. should error.\n            break;\n        case 2:\n            if (cm[0] == 'm') {\n                type = CMD_TYPE_META;\n                switch (cm[1]) {\n                    case 'g':\n                        cmd = CMD_MG;\n                        ret = _process_request_meta(pr);\n                        break;\n                    case 's':\n                        cmd = CMD_MS;\n                        ret = _process_request_mset(pr);\n                        break;\n                    case 'd':\n                        cmd = CMD_MD;\n                        ret = _process_request_meta(pr);\n                        break;\n                    case 'n':\n                        // TODO: do we route/handle NOP's at all?\n                        // they should simply reflect to the client.\n                        cmd = CMD_MN;\n                        break;\n                    case 'a':\n                        cmd = CMD_MA;\n                        ret = _process_request_meta(pr);\n                        break;\n                    case 'e':\n                        cmd = CMD_ME;\n                        // TODO: not much special processing here; binary keys\n                        ret = _process_request_meta(pr);\n                        break;\n                }\n            }\n            break;\n        case 3:\n            if (cm[0] == 'g') {\n                if (cm[1] == 'e' && cm[2] == 't') {\n                    cmd = CMD_GET;\n                    type = CMD_TYPE_GET;\n                    token_max = 2; // don't chew through multigets.\n                    ret = _process_request_simple(pr, 2, 2);\n                }\n                if (cm[1] == 'a' && cm[2] == 't') {\n                    type = CMD_TYPE_GET;\n                    cmd = CMD_GAT;\n                    token_max = 2; // don't chew through multigets.\n                    ret = _process_request_gat(pr);\n                }\n            } else if (cm[0] == 's' && cm[1] == 'e' && cm[2] == 't') {\n                cmd = CMD_SET;\n                ret = _process_request_storage(pr, token_max);\n            } else if (cm[0] == 'a' && cm[1] == 'd' && cm[2] == 'd') {\n                cmd = CMD_ADD;\n                ret = _process_request_storage(pr, token_max);\n            } else if (cm[0] == 'c' && cm[1] == 'a' && cm[2] == 's') {\n                cmd = CMD_CAS;\n                ret = _process_request_storage(pr, token_max);\n            }\n            break;\n        case 4:\n            if (strncmp(cm, \"gets\", 4) == 0) {\n                cmd = CMD_GETS;\n                type = CMD_TYPE_GET;\n                token_max = 2; // don't chew through multigets.\n                ret = _process_request_simple(pr, 2, 2);\n            } else if (strncmp(cm, \"incr\", 4) == 0) {\n                cmd = CMD_INCR;\n                ret = _process_request_simple(pr, 3, 4);\n            } else if (strncmp(cm, \"decr\", 4) == 0) {\n                cmd = CMD_DECR;\n                ret = _process_request_simple(pr, 3, 4);\n            } else if (strncmp(cm, \"gats\", 4) == 0) {\n                cmd = CMD_GATS;\n                type = CMD_TYPE_GET;\n                ret = _process_request_gat(pr);\n            } else if (strncmp(cm, \"quit\", 4) == 0) {\n                cmd = CMD_QUIT;\n            }\n            break;\n        case 5:\n            if (strncmp(cm, \"touch\", 5) == 0) {\n                cmd = CMD_TOUCH;\n                ret = _process_request_simple(pr, 3, 4);\n            } else if (strncmp(cm, \"stats\", 5) == 0) {\n                cmd = CMD_STATS;\n                // Don't process a key; fetch via arguments.\n                _process_tokenize(pr, token_max);\n            } else if (strncmp(cm, \"watch\", 5) == 0) {\n                cmd = CMD_WATCH;\n                _process_tokenize(pr, token_max);\n            }\n            break;\n        case 6:\n            if (strncmp(cm, \"delete\", 6) == 0) {\n                cmd = CMD_DELETE;\n                ret = _process_request_simple(pr, 2, 4);\n            } else if (strncmp(cm, \"append\", 6) == 0) {\n                cmd = CMD_APPEND;\n                ret = _process_request_storage(pr, token_max);\n            }\n            break;\n        case 7:\n            if (strncmp(cm, \"replace\", 7) == 0) {\n                cmd = CMD_REPLACE;\n                ret = _process_request_storage(pr, token_max);\n            } else if (strncmp(cm, \"prepend\", 7) == 0) {\n                cmd = CMD_PREPEND;\n                ret = _process_request_storage(pr, token_max);\n            } else if (strncmp(cm, \"version\", 7) == 0) {\n                cmd = CMD_VERSION;\n                _process_tokenize(pr, token_max);\n            }\n            break;\n    }\n\n    // TODO: log more specific error code.\n    if (cmd == -1 || ret != 0) {\n        return -1;\n    }\n\n    pr->command = cmd;\n    pr->cmd_type = type;\n\n    return 0;\n}",
        "func": "int process_request(mcp_parser_t *pr, const char *command, size_t cmdlen) {\n    // we want to \"parse in place\" as much as possible, which allows us to\n    // forward an unmodified request without having to rebuild it.\n\n    const char *cm = command;\n    size_t cl = 0;\n    // min command length is 2, plus the \"\\r\\n\"\n    if (cmdlen < 4) {\n        return -1;\n    }\n\n    // Commands can end with bare '\\n's. Depressingly I intended to be strict\n    // with a \\r\\n requirement but never did this and need backcompat.\n    // In this case we _know_ \\n is at cmdlen because we can't enter this\n    // function otherwise.\n    if (cm[cmdlen-2] == '\\r') {\n        pr->endlen = cmdlen - 2;\n    } else {\n        pr->endlen = cmdlen - 1;\n    }\n\n    const char *s = memchr(command, ' ', pr->endlen);\n    if (s != NULL) {\n        cl = s - command;\n    } else {\n        cl = pr->endlen;\n    }\n    pr->keytoken = 0;\n    pr->has_space = false;\n    pr->parsed = cl;\n    pr->request = command;\n    pr->reqlen = cmdlen;\n    int token_max = PARSER_MAX_TOKENS;\n\n    int cmd = -1;\n    int type = CMD_TYPE_GENERIC;\n    int ret = 0;\n\n    switch (cl) {\n        case 0:\n        case 1:\n            // falls through with cmd as -1. should error.\n            break;\n        case 2:\n            if (cm[0] == 'm') {\n                type = CMD_TYPE_META;\n                switch (cm[1]) {\n                    case 'g':\n                        cmd = CMD_MG;\n                        ret = _process_request_meta(pr);\n                        break;\n                    case 's':\n                        cmd = CMD_MS;\n                        ret = _process_request_mset(pr);\n                        break;\n                    case 'd':\n                        cmd = CMD_MD;\n                        ret = _process_request_meta(pr);\n                        break;\n                    case 'n':\n                        // TODO: do we route/handle NOP's at all?\n                        // they should simply reflect to the client.\n                        cmd = CMD_MN;\n                        break;\n                    case 'a':\n                        cmd = CMD_MA;\n                        ret = _process_request_meta(pr);\n                        break;\n                    case 'e':\n                        cmd = CMD_ME;\n                        // TODO: not much special processing here; binary keys\n                        ret = _process_request_meta(pr);\n                        break;\n                }\n            }\n            break;\n        case 3:\n            if (cm[0] == 'g') {\n                if (cm[1] == 'e' && cm[2] == 't') {\n                    cmd = CMD_GET;\n                    type = CMD_TYPE_GET;\n                    token_max = 2; // don't chew through multigets.\n                    ret = _process_request_simple(pr, 2, 2);\n                }\n                if (cm[1] == 'a' && cm[2] == 't') {\n                    type = CMD_TYPE_GET;\n                    cmd = CMD_GAT;\n                    token_max = 2; // don't chew through multigets.\n                    ret = _process_request_gat(pr);\n                }\n            } else if (cm[0] == 's' && cm[1] == 'e' && cm[2] == 't') {\n                cmd = CMD_SET;\n                ret = _process_request_storage(pr, token_max);\n            } else if (cm[0] == 'a' && cm[1] == 'd' && cm[2] == 'd') {\n                cmd = CMD_ADD;\n                ret = _process_request_storage(pr, token_max);\n            } else if (cm[0] == 'c' && cm[1] == 'a' && cm[2] == 's') {\n                cmd = CMD_CAS;\n                ret = _process_request_storage(pr, token_max);\n            }\n            break;\n        case 4:\n            if (strncmp(cm, \"gets\", 4) == 0) {\n                cmd = CMD_GETS;\n                type = CMD_TYPE_GET;\n                token_max = 2; // don't chew through multigets.\n                ret = _process_request_simple(pr, 2, 2);\n            } else if (strncmp(cm, \"incr\", 4) == 0) {\n                cmd = CMD_INCR;\n                ret = _process_request_simple(pr, 3, 4);\n            } else if (strncmp(cm, \"decr\", 4) == 0) {\n                cmd = CMD_DECR;\n                ret = _process_request_simple(pr, 3, 4);\n            } else if (strncmp(cm, \"gats\", 4) == 0) {\n                cmd = CMD_GATS;\n                type = CMD_TYPE_GET;\n                ret = _process_request_gat(pr);\n            } else if (strncmp(cm, \"quit\", 4) == 0) {\n                cmd = CMD_QUIT;\n            }\n            break;\n        case 5:\n            if (strncmp(cm, \"touch\", 5) == 0) {\n                cmd = CMD_TOUCH;\n                ret = _process_request_simple(pr, 3, 4);\n            } else if (strncmp(cm, \"stats\", 5) == 0) {\n                cmd = CMD_STATS;\n                // Don't process a key; fetch via arguments.\n                _process_tokenize(pr, token_max);\n            } else if (strncmp(cm, \"watch\", 5) == 0) {\n                cmd = CMD_WATCH;\n                _process_tokenize(pr, token_max);\n            }\n            break;\n        case 6:\n            if (strncmp(cm, \"delete\", 6) == 0) {\n                cmd = CMD_DELETE;\n                ret = _process_request_simple(pr, 2, 4);\n            } else if (strncmp(cm, \"append\", 6) == 0) {\n                cmd = CMD_APPEND;\n                ret = _process_request_storage(pr, token_max);\n            }\n            break;\n        case 7:\n            if (strncmp(cm, \"replace\", 7) == 0) {\n                cmd = CMD_REPLACE;\n                ret = _process_request_storage(pr, token_max);\n            } else if (strncmp(cm, \"prepend\", 7) == 0) {\n                cmd = CMD_PREPEND;\n                ret = _process_request_storage(pr, token_max);\n            } else if (strncmp(cm, \"version\", 7) == 0) {\n                cmd = CMD_VERSION;\n                _process_tokenize(pr, token_max);\n            }\n            break;\n    }\n\n    // TODO: log more specific error code.\n    if (cmd == -1 || ret != 0) {\n        return -1;\n    }\n\n    pr->command = cmd;\n    pr->cmd_type = type;\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,15 +9,25 @@\n         return -1;\n     }\n \n-    const char *s = memchr(command, ' ', cmdlen-2);\n+    // Commands can end with bare '\\n's. Depressingly I intended to be strict\n+    // with a \\r\\n requirement but never did this and need backcompat.\n+    // In this case we _know_ \\n is at cmdlen because we can't enter this\n+    // function otherwise.\n+    if (cm[cmdlen-2] == '\\r') {\n+        pr->endlen = cmdlen - 2;\n+    } else {\n+        pr->endlen = cmdlen - 1;\n+    }\n+\n+    const char *s = memchr(command, ' ', pr->endlen);\n     if (s != NULL) {\n         cl = s - command;\n     } else {\n-        cl = cmdlen - 2;\n+        cl = pr->endlen;\n     }\n     pr->keytoken = 0;\n     pr->has_space = false;\n-    pr->parsed = cl + 1;\n+    pr->parsed = cl;\n     pr->request = command;\n     pr->reqlen = cmdlen;\n     int token_max = PARSER_MAX_TOKENS;",
        "diff_line_info": {
            "deleted_lines": [
                "    const char *s = memchr(command, ' ', cmdlen-2);",
                "        cl = cmdlen - 2;",
                "    pr->parsed = cl + 1;"
            ],
            "added_lines": [
                "    // Commands can end with bare '\\n's. Depressingly I intended to be strict",
                "    // with a \\r\\n requirement but never did this and need backcompat.",
                "    // In this case we _know_ \\n is at cmdlen because we can't enter this",
                "    // function otherwise.",
                "    if (cm[cmdlen-2] == '\\r') {",
                "        pr->endlen = cmdlen - 2;",
                "    } else {",
                "        pr->endlen = cmdlen - 1;",
                "    }",
                "",
                "    const char *s = memchr(command, ' ', pr->endlen);",
                "        cl = pr->endlen;",
                "    pr->parsed = cl;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-46853",
        "func_name": "memcached/_process_request_next_key",
        "description": "In Memcached before 1.6.22, an off-by-one error exists when processing proxy requests in proxy mode, if \\n is used instead of \\r\\n.",
        "git_url": "https://github.com/memcached/memcached/commit/6987918e9a3094ec4fc8976f01f769f624d790fa",
        "commit_title": "proxy: fix off-by-one if \\r is missing",
        "commit_text": " A bunch of the parser assumed we only had \\r\\n, but I didn't actually have that strictness set. Some commands worked and some broke in subtle ways when just \"\\n\" was being submitted.  I'm not 100% confident in this change yet so I'm opening a PR to stage it while I run some more thorough tests.",
        "func_before": "size_t _process_request_next_key(mcp_parser_t *pr) {\n    const char *cur = pr->request + pr->parsed;\n    int remain = pr->reqlen - pr->parsed - 2;\n\n    // chew off any leading whitespace.\n    while (remain) {\n        if (*cur == ' ') {\n            remain--;\n            cur++;\n            pr->parsed++;\n        } else {\n            break;\n        }\n    }\n\n    const char *s = memchr(cur, ' ', remain);\n    if (s != NULL) {\n        pr->klen = s - cur;\n        pr->parsed += s - cur;\n    } else {\n        pr->klen = remain;\n        pr->parsed += remain;\n    }\n\n    return cur - pr->request;\n}",
        "func": "size_t _process_request_next_key(mcp_parser_t *pr) {\n    const char *cur = pr->request + pr->parsed;\n    int remain = pr->endlen - pr->parsed;\n\n    // chew off any leading whitespace.\n    while (remain) {\n        if (*cur == ' ') {\n            remain--;\n            cur++;\n            pr->parsed++;\n        } else {\n            break;\n        }\n    }\n\n    const char *s = memchr(cur, ' ', remain);\n    if (s != NULL) {\n        pr->klen = s - cur;\n        pr->parsed += s - cur;\n    } else {\n        pr->klen = remain;\n        pr->parsed += remain;\n    }\n\n    return cur - pr->request;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n size_t _process_request_next_key(mcp_parser_t *pr) {\n     const char *cur = pr->request + pr->parsed;\n-    int remain = pr->reqlen - pr->parsed - 2;\n+    int remain = pr->endlen - pr->parsed;\n \n     // chew off any leading whitespace.\n     while (remain) {",
        "diff_line_info": {
            "deleted_lines": [
                "    int remain = pr->reqlen - pr->parsed - 2;"
            ],
            "added_lines": [
                "    int remain = pr->endlen - pr->parsed;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-46853",
        "func_name": "memcached/_process_tokenize",
        "description": "In Memcached before 1.6.22, an off-by-one error exists when processing proxy requests in proxy mode, if \\n is used instead of \\r\\n.",
        "git_url": "https://github.com/memcached/memcached/commit/6987918e9a3094ec4fc8976f01f769f624d790fa",
        "commit_title": "proxy: fix off-by-one if \\r is missing",
        "commit_text": " A bunch of the parser assumed we only had \\r\\n, but I didn't actually have that strictness set. Some commands worked and some broke in subtle ways when just \"\\n\" was being submitted.  I'm not 100% confident in this change yet so I'm opening a PR to stage it while I run some more thorough tests.",
        "func_before": "static int _process_tokenize(mcp_parser_t *pr, const size_t max) {\n    const char *s = pr->request;\n    int len = pr->reqlen - 2;\n\n    // since multigets can be huge, we can't purely judge reqlen against this\n    // limit, but we also can't index past it since the tokens are shorts.\n    if (len > PARSER_MAXLEN) {\n        len = PARSER_MAXLEN;\n    }\n    const char *end = s + len;\n    int curtoken = 0;\n\n    int state = 0;\n    while (s != end) {\n        switch (state) {\n            case 0:\n                // scanning for first non-space to find a token.\n                if (*s != ' ') {\n                    pr->tokens[curtoken] = s - pr->request;\n                    if (++curtoken == max) {\n                        s++;\n                        state = 2;\n                        break;\n                    }\n                    state = 1;\n                }\n                s++;\n                break;\n            case 1:\n                // advance over a token\n                if (*s != ' ') {\n                    s++;\n                } else {\n                    state = 0;\n                }\n                break;\n            case 2:\n                // hit max tokens before end of the line.\n                // keep advancing so we can place endcap token.\n                if (*s == ' ') {\n                    goto endloop;\n                }\n                s++;\n                break;\n        }\n    }\nendloop:\n\n    // endcap token so we can quickly find the length of any token by looking\n    // at the next one.\n    pr->tokens[curtoken] = s - pr->request;\n    pr->ntokens = curtoken;\n    P_DEBUG(\"%s: cur_tokens: %d\\n\", __func__, curtoken);\n\n    return 0;\n}",
        "func": "static int _process_tokenize(mcp_parser_t *pr, const size_t max) {\n    const char *s = pr->request;\n    int len = pr->endlen;\n\n    // since multigets can be huge, we can't purely judge reqlen against this\n    // limit, but we also can't index past it since the tokens are shorts.\n    if (len > PARSER_MAXLEN) {\n        len = PARSER_MAXLEN;\n    }\n    const char *end = s + len;\n    int curtoken = 0;\n\n    int state = 0;\n    while (s != end) {\n        switch (state) {\n            case 0:\n                // scanning for first non-space to find a token.\n                if (*s != ' ') {\n                    pr->tokens[curtoken] = s - pr->request;\n                    if (++curtoken == max) {\n                        s++;\n                        state = 2;\n                        break;\n                    }\n                    state = 1;\n                }\n                s++;\n                break;\n            case 1:\n                // advance over a token\n                if (*s != ' ') {\n                    s++;\n                } else {\n                    state = 0;\n                }\n                break;\n            case 2:\n                // hit max tokens before end of the line.\n                // keep advancing so we can place endcap token.\n                if (*s == ' ') {\n                    goto endloop;\n                }\n                s++;\n                break;\n        }\n    }\nendloop:\n\n    // endcap token so we can quickly find the length of any token by looking\n    // at the next one.\n    pr->tokens[curtoken] = s - pr->request;\n    pr->ntokens = curtoken;\n    P_DEBUG(\"%s: cur_tokens: %d\\n\", __func__, curtoken);\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static int _process_tokenize(mcp_parser_t *pr, const size_t max) {\n     const char *s = pr->request;\n-    int len = pr->reqlen - 2;\n+    int len = pr->endlen;\n \n     // since multigets can be huge, we can't purely judge reqlen against this\n     // limit, but we also can't index past it since the tokens are shorts.",
        "diff_line_info": {
            "deleted_lines": [
                "    int len = pr->reqlen - 2;"
            ],
            "added_lines": [
                "    int len = pr->endlen;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-31875",
        "func_name": "418sec/mjs/mjs_json_parse",
        "description": "In mjs_json.c in Cesanta MongooseOS mJS 1.26, a maliciously formed JSON string can trigger an off-by-one heap-based buffer overflow in mjs_json_parse, which can potentially lead to redirection of control flow. NOTE: the original reporter disputes the significance of this finding because \"there isnt very much of an opportunity to exploit this reliably for an information leak, so there isnt any real security impact.\"",
        "git_url": "https://github.com/418sec/mjs/commit/a883c9ae6a140c226d21188dbc993671ada4c088",
        "commit_title": "Fix culprit for JSON heap overflow",
        "commit_text": "",
        "func_before": "MJS_PRIVATE mjs_err_t\nmjs_json_parse(struct mjs *mjs, const char *str, size_t len, mjs_val_t *res) {\n  struct json_parse_ctx *ctx =\n      (struct json_parse_ctx *) calloc(sizeof(struct json_parse_ctx), 1);\n  int json_res;\n  enum mjs_err rcode = MJS_OK;\n\n  ctx->mjs = mjs;\n  ctx->result = MJS_UNDEFINED;\n  ctx->frame = NULL;\n  ctx->rcode = MJS_OK;\n\n  mjs_own(mjs, &ctx->result);\n\n  {\n    /*\n     * We have to reallocate the buffer before invoking json_walk, because\n     * frozen_cb can create new strings, which can result in the reallocation\n     * of mjs string mbuf, invalidating the `str` pointer.\n     */\n    char *stmp = malloc(len);\n    memcpy(stmp, str, len);\n    json_res = json_walk(stmp, len, frozen_cb, ctx);\n    free(stmp);\n    stmp = NULL;\n\n    /* str might have been invalidated, so null it out */\n    str = NULL;\n  }\n\n  if (ctx->rcode != MJS_OK) {\n    rcode = ctx->rcode;\n    mjs_prepend_errorf(mjs, rcode, \"invalid JSON string\");\n  } else if (json_res < 0) {\n    /* There was an error during parsing */\n    rcode = MJS_TYPE_ERROR;\n    mjs_prepend_errorf(mjs, rcode, \"invalid JSON string\");\n  } else {\n    /* Expression is parsed successfully */\n    *res = ctx->result;\n\n    /* There should be no allocated frames */\n    assert(ctx->frame == NULL);\n  }\n\n  if (rcode != MJS_OK) {\n    /* There might be some allocated frames in case of malformed JSON */\n    while (ctx->frame != NULL) {\n      ctx->frame = free_json_frame(ctx, ctx->frame);\n    }\n  }\n\n  mjs_disown(mjs, &ctx->result);\n  free(ctx);\n\n  return rcode;\n}",
        "func": "MJS_PRIVATE mjs_err_t\nmjs_json_parse(struct mjs *mjs, const char *str, size_t len, mjs_val_t *res) {\n  struct json_parse_ctx *ctx =\n      (struct json_parse_ctx *) calloc(sizeof(struct json_parse_ctx), 1);\n  int json_res;\n  enum mjs_err rcode = MJS_OK;\n\n  ctx->mjs = mjs;\n  ctx->result = MJS_UNDEFINED;\n  ctx->frame = NULL;\n  ctx->rcode = MJS_OK;\n\n  mjs_own(mjs, &ctx->result);\n\n  {\n    /*\n     * We have to reallocate the buffer before invoking json_walk, because\n     * frozen_cb can create new strings, which can result in the reallocation\n     * of mjs string mbuf, invalidating the `str` pointer.\n     */\n    char *stmp = malloc(len + 1);\n    memcpy(stmp, str, len);\n    stmp[len] = '\\0';\n\n    json_res = json_walk(stmp, len, frozen_cb, ctx);\n    free(stmp);\n    stmp = NULL;\n\n    /* str might have been invalidated, so null it out */\n    str = NULL;\n  }\n\n  if (ctx->rcode != MJS_OK) {\n    rcode = ctx->rcode;\n    mjs_prepend_errorf(mjs, rcode, \"invalid JSON string\");\n  } else if (json_res < 0) {\n    /* There was an error during parsing */\n    rcode = MJS_TYPE_ERROR;\n    mjs_prepend_errorf(mjs, rcode, \"invalid JSON string\");\n  } else {\n    /* Expression is parsed successfully */\n    *res = ctx->result;\n\n    /* There should be no allocated frames */\n    assert(ctx->frame == NULL);\n  }\n\n  if (rcode != MJS_OK) {\n    /* There might be some allocated frames in case of malformed JSON */\n    while (ctx->frame != NULL) {\n      ctx->frame = free_json_frame(ctx, ctx->frame);\n    }\n  }\n\n  mjs_disown(mjs, &ctx->result);\n  free(ctx);\n\n  return rcode;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,8 +18,10 @@\n      * frozen_cb can create new strings, which can result in the reallocation\n      * of mjs string mbuf, invalidating the `str` pointer.\n      */\n-    char *stmp = malloc(len);\n+    char *stmp = malloc(len + 1);\n     memcpy(stmp, str, len);\n+    stmp[len] = '\\0';\n+\n     json_res = json_walk(stmp, len, frozen_cb, ctx);\n     free(stmp);\n     stmp = NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "    char *stmp = malloc(len);"
            ],
            "added_lines": [
                "    char *stmp = malloc(len + 1);",
                "    stmp[len] = '\\0';",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-29529",
        "func_name": "tensorflow/ComputeInterpolationWeights",
        "description": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a heap buffer overflow in `tf.raw_ops.QuantizedResizeBilinear` by manipulating input values so that float rounding results in off-by-one error in accessing image elements. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/44b7f486c0143f68b56c34e2d01e146ee445134a/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L62-L66) computes two integers (representing the upper and lower bounds for interpolation) by ceiling and flooring a floating point value. For some values of `in`, `interpolation->upper[i]` might be smaller than `interpolation->lower[i]`. This is an issue if `interpolation->upper[i]` is capped at `in_size-1` as it means that `interpolation->lower[i]` points outside of the image. Then, in the interpolation code(https://github.com/tensorflow/tensorflow/blob/44b7f486c0143f68b56c34e2d01e146ee445134a/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L245-L264), this would result in heap buffer overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/f851613f8f0fb0c838d160ced13c134f778e3ce7",
        "commit_title": "Fix heap buffer overflow caused by rounding.",
        "commit_text": " This was hard to fix. Due to the way we compute the pixels that influence an output pixel in resized images, for certain input configuration we might have issued a read to a pixel that is outside of boundary of the original image. This is because of floating errors that affected truncation results.  PiperOrigin-RevId: 369757871",
        "func_before": "inline void ComputeInterpolationWeights(\n    const int64 out_size, const int64 in_size, const float scale,\n    const int resolution, InterpolationCache<T_SCALE>* interpolation) {\n  const Scaler scaler;\n  interpolation->lower.resize(out_size + 1);\n  interpolation->upper.resize(out_size + 1);\n  interpolation->lerp.resize(out_size + 1);\n  interpolation->ilerp.resize(out_size + 1);\n\n  interpolation->lower[out_size] = 0;\n  interpolation->upper[out_size] = 0;\n  for (int64 i = out_size - 1; i >= 0; --i) {\n    const float in = scaler(i, scale);\n    const float in_f = std::floor(in);\n    interpolation->lower[i] =\n        std::max(static_cast<int64>(in_f), static_cast<int64>(0));\n    interpolation->upper[i] =\n        std::min(static_cast<int64>(std::ceil(in)), in_size - 1);\n    interpolation->lerp[i] = in - in_f;\n    interpolation->ilerp[i] =\n        static_cast<T_SCALE>((in - in_f) * (1 << resolution));\n  }\n}",
        "func": "inline void ComputeInterpolationWeights(\n    const int64 out_size, const int64 in_size, const float scale,\n    const int resolution, InterpolationCache<T_SCALE>* interpolation) {\n  const Scaler scaler;\n  interpolation->lower.resize(out_size + 1);\n  interpolation->upper.resize(out_size + 1);\n  interpolation->lerp.resize(out_size + 1);\n  interpolation->ilerp.resize(out_size + 1);\n\n  interpolation->lower[out_size] = 0;\n  interpolation->upper[out_size] = 0;\n  for (int64 i = out_size - 1; i >= 0; --i) {\n    const float in = scaler(i, scale);\n    const float in_f = std::floor(in);\n    interpolation->lower[i] =\n        std::max(static_cast<int64>(in_f), static_cast<int64>(0));\n    interpolation->upper[i] =\n        std::min(static_cast<int64>(std::ceil(in)), in_size - 1);\n    interpolation->lower[i] =\n        std::min(interpolation->lower[i], interpolation->upper[i]);\n    interpolation->lerp[i] = in - in_f;\n    interpolation->ilerp[i] =\n        static_cast<T_SCALE>((in - in_f) * (1 << resolution));\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,6 +16,8 @@\n         std::max(static_cast<int64>(in_f), static_cast<int64>(0));\n     interpolation->upper[i] =\n         std::min(static_cast<int64>(std::ceil(in)), in_size - 1);\n+    interpolation->lower[i] =\n+        std::min(interpolation->lower[i], interpolation->upper[i]);\n     interpolation->lerp[i] = in - in_f;\n     interpolation->ilerp[i] =\n         static_cast<T_SCALE>((in - in_f) * (1 << resolution));",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    interpolation->lower[i] =",
                "        std::min(interpolation->lower[i], interpolation->upper[i]);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-30546",
        "func_name": "contiki-ng/storage_put_index",
        "description": "Contiki-NG is an operating system for Internet of Things devices. An off-by-one error can be triggered in the Antelope database management system in the Contiki-NG operating system in versions 4.8 and prior. The problem exists in the Contiki File System (CFS) backend for the storage of data (file os/storage/antelope/storage-cfs.c). In the functions `storage_get_index` and `storage_put_index`, a buffer for merging two strings is allocated with one byte less than the maximum size of the merged strings, causing subsequent function calls to the cfs_open function to read from memory beyond the buffer size. The vulnerability has been patched in the \"develop\" branch of Contiki-NG, and is expected to be included in the next release. As a workaround, the problem can be fixed by applying the patch in Contiki-NG pull request #2425.",
        "git_url": "https://github.com/contiki-ng/contiki-ng/commit/406ae7da30fb5fadacf0d646a4dc4ac0513a2dec",
        "commit_title": "antelope,storage-cfs: Fix length of filename array",
        "commit_text": "",
        "func_before": "db_result_t\nstorage_put_index(index_t *index)\n{\n  char filename[INDEX_NAME_LENGTH];\n  int fd;\n  int r;\n  struct index_record record;\n  db_result_t result;\n\n  merge_strings(filename, index->rel->name, INDEX_NAME_SUFFIX);\n\n  fd = cfs_open(filename, CFS_WRITE | CFS_APPEND);\n  if(fd < 0) {\n    return DB_STORAGE_ERROR;\n  }\n\n  strcpy(record.attribute_name, index->attr->name);\n  memcpy(record.file_name, index->descriptor_file, sizeof(record.file_name));\n  record.type = index->type;\n\n  result = DB_OK;\n  r = cfs_write(fd, &record, sizeof(record));\n  if(r < sizeof(record)) {\n    result = DB_STORAGE_ERROR;\n  } else {\n    PRINTF(\"DB: Wrote an index record for %s.%s, type %d\\n\",\n      index->rel->name, index->attr->name, record.type);\n  }\n\n  cfs_close(fd);\n\n  return result;\n}",
        "func": "db_result_t\nstorage_put_index(index_t *index)\n{\n  char filename[INDEX_NAME_LENGTH + 1];\n  int fd;\n  int r;\n  struct index_record record;\n  db_result_t result;\n\n  merge_strings(filename, index->rel->name, INDEX_NAME_SUFFIX);\n\n  fd = cfs_open(filename, CFS_WRITE | CFS_APPEND);\n  if(fd < 0) {\n    return DB_STORAGE_ERROR;\n  }\n\n  strcpy(record.attribute_name, index->attr->name);\n  memcpy(record.file_name, index->descriptor_file, sizeof(record.file_name));\n  record.type = index->type;\n\n  result = DB_OK;\n  r = cfs_write(fd, &record, sizeof(record));\n  if(r < sizeof(record)) {\n    result = DB_STORAGE_ERROR;\n  } else {\n    PRINTF(\"DB: Wrote an index record for %s.%s, type %d\\n\",\n      index->rel->name, index->attr->name, record.type);\n  }\n\n  cfs_close(fd);\n\n  return result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n db_result_t\n storage_put_index(index_t *index)\n {\n-  char filename[INDEX_NAME_LENGTH];\n+  char filename[INDEX_NAME_LENGTH + 1];\n   int fd;\n   int r;\n   struct index_record record;",
        "diff_line_info": {
            "deleted_lines": [
                "  char filename[INDEX_NAME_LENGTH];"
            ],
            "added_lines": [
                "  char filename[INDEX_NAME_LENGTH + 1];"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-30546",
        "func_name": "contiki-ng/storage_get_index",
        "description": "Contiki-NG is an operating system for Internet of Things devices. An off-by-one error can be triggered in the Antelope database management system in the Contiki-NG operating system in versions 4.8 and prior. The problem exists in the Contiki File System (CFS) backend for the storage of data (file os/storage/antelope/storage-cfs.c). In the functions `storage_get_index` and `storage_put_index`, a buffer for merging two strings is allocated with one byte less than the maximum size of the merged strings, causing subsequent function calls to the cfs_open function to read from memory beyond the buffer size. The vulnerability has been patched in the \"develop\" branch of Contiki-NG, and is expected to be included in the next release. As a workaround, the problem can be fixed by applying the patch in Contiki-NG pull request #2425.",
        "git_url": "https://github.com/contiki-ng/contiki-ng/commit/406ae7da30fb5fadacf0d646a4dc4ac0513a2dec",
        "commit_title": "antelope,storage-cfs: Fix length of filename array",
        "commit_text": "",
        "func_before": "db_result_t\nstorage_get_index(index_t *index, relation_t *rel, attribute_t *attr)\n{\n  char filename[INDEX_NAME_LENGTH];\n  int fd;\n  int r;\n  struct index_record record;\n  db_result_t result;\n\n  merge_strings(filename, rel->name, INDEX_NAME_SUFFIX);\n\n  fd = cfs_open(filename, CFS_READ);\n  if(fd < 0) {\n    return DB_STORAGE_ERROR;\n  }\n\n  for(result = DB_STORAGE_ERROR;;) {\n    r = cfs_read(fd, &record, sizeof(record));\n    if(r < sizeof(record)) {\n      break;\n    }\n    if(strcmp(attr->name, record.attribute_name) == 0) {\n      PRINTF(\"DB: Found the index record for %s.%s: type %d, filename %s\\n\",\n\trel->name, attr->name, record.type, record.file_name);\n      index->type = record.type;\n      memcpy(index->descriptor_file, record.file_name,\n\t     sizeof(index->descriptor_file));\n      result = DB_OK;\n    }\n  }\n\n  cfs_close(fd);\n\n  return result;\n}",
        "func": "db_result_t\nstorage_get_index(index_t *index, relation_t *rel, attribute_t *attr)\n{\n  char filename[INDEX_NAME_LENGTH + 1];\n  int fd;\n  int r;\n  struct index_record record;\n  db_result_t result;\n\n  merge_strings(filename, rel->name, INDEX_NAME_SUFFIX);\n\n  fd = cfs_open(filename, CFS_READ);\n  if(fd < 0) {\n    return DB_STORAGE_ERROR;\n  }\n\n  for(result = DB_STORAGE_ERROR;;) {\n    r = cfs_read(fd, &record, sizeof(record));\n    if(r < sizeof(record)) {\n      break;\n    }\n    if(strcmp(attr->name, record.attribute_name) == 0) {\n      PRINTF(\"DB: Found the index record for %s.%s: type %d, filename %s\\n\",\n\trel->name, attr->name, record.type, record.file_name);\n      index->type = record.type;\n      memcpy(index->descriptor_file, record.file_name,\n\t     sizeof(index->descriptor_file));\n      result = DB_OK;\n    }\n  }\n\n  cfs_close(fd);\n\n  return result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n db_result_t\n storage_get_index(index_t *index, relation_t *rel, attribute_t *attr)\n {\n-  char filename[INDEX_NAME_LENGTH];\n+  char filename[INDEX_NAME_LENGTH + 1];\n   int fd;\n   int r;\n   struct index_record record;",
        "diff_line_info": {
            "deleted_lines": [
                "  char filename[INDEX_NAME_LENGTH];"
            ],
            "added_lines": [
                "  char filename[INDEX_NAME_LENGTH + 1];"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-23849",
        "func_name": "torvalds/linux/rds_recv_track_latency",
        "description": "In rds_recv_track_latency in net/rds/af_rds.c in the Linux kernel through 6.7.1, there is an off-by-one error for an RDS_MSG_RX_DGRAM_TRACE_MAX comparison, resulting in out-of-bounds access.",
        "git_url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=13e788deb7348cc88df34bed736c3b3b9927ea52",
        "commit_title": "Syzcaller UBSAN crash occurs in rds_cmsg_recv(),",
        "commit_text": "which reads inc->i_rx_lat_trace[j + 1] with index 4 (3 + 1), but with array size of 4 (RDS_RX_MAX_TRACES). Here 'j' is assigned from rs->rs_rx_trace[i] and in-turn from trace.rx_trace_pos[i] in rds_recv_track_latency(), with both arrays sized 3 (RDS_MSG_RX_DGRAM_TRACE_MAX). So fix the off-by-one bounds check in rds_recv_track_latency() to prevent a potential crash in rds_cmsg_recv().  Found by syzcaller: ================================================================= UBSAN: array-index-out-of-bounds in net/rds/recv.c:585:39 index 4 is out of range for type 'u64 [4]' CPU: 1 PID: 8058 Comm: syz-executor228 Not tainted 6.6.0-gd2f51b3516da #1 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014 Call Trace:  <TASK>  __dump_stack lib/dump_stack.c:88 [inline]  dump_stack_lvl+0x136/0x150 lib/dump_stack.c:106  ubsan_epilogue lib/ubsan.c:217 [inline]  __ubsan_handle_out_of_bounds+0xd5/0x130 lib/ubsan.c:348  rds_cmsg_recv+0x60d/0x700 net/rds/recv.c:585  rds_recvmsg+0x3fb/0x1610 net/rds/recv.c:716  sock_recvmsg_nosec net/socket.c:1044 [inline]  sock_recvmsg+0xe2/0x160 net/socket.c:1066  __sys_recvfrom+0x1b6/0x2f0 net/socket.c:2246  __do_sys_recvfrom net/socket.c:2264 [inline]  __se_sys_recvfrom net/socket.c:2260 [inline]  __x64_sys_recvfrom+0xe0/0x1b0 net/socket.c:2260  do_syscall_x64 arch/x86/entry/common.c:51 [inline]  do_syscall_64+0x40/0x110 arch/x86/entry/common.c:82  entry_SYSCALL_64_after_hwframe+0x63/0x6b ==================================================================  Closes: https://lore.kernel.org/linux-rdma/CALGdzuoVdq-wtQ4Az9iottBqC5cv9ZhcE5q8N7LfYFvkRsOVcw@mail.gmail.com/ ",
        "func_before": "static int rds_recv_track_latency(struct rds_sock *rs, sockptr_t optval,\n\t\t\t\t  int optlen)\n{\n\tstruct rds_rx_trace_so trace;\n\tint i;\n\n\tif (optlen != sizeof(struct rds_rx_trace_so))\n\t\treturn -EFAULT;\n\n\tif (copy_from_sockptr(&trace, optval, sizeof(trace)))\n\t\treturn -EFAULT;\n\n\tif (trace.rx_traces > RDS_MSG_RX_DGRAM_TRACE_MAX)\n\t\treturn -EFAULT;\n\n\trs->rs_rx_traces = trace.rx_traces;\n\tfor (i = 0; i < rs->rs_rx_traces; i++) {\n\t\tif (trace.rx_trace_pos[i] > RDS_MSG_RX_DGRAM_TRACE_MAX) {\n\t\t\trs->rs_rx_traces = 0;\n\t\t\treturn -EFAULT;\n\t\t}\n\t\trs->rs_rx_trace[i] = trace.rx_trace_pos[i];\n\t}\n\n\treturn 0;\n}",
        "func": "static int rds_recv_track_latency(struct rds_sock *rs, sockptr_t optval,\n\t\t\t\t  int optlen)\n{\n\tstruct rds_rx_trace_so trace;\n\tint i;\n\n\tif (optlen != sizeof(struct rds_rx_trace_so))\n\t\treturn -EFAULT;\n\n\tif (copy_from_sockptr(&trace, optval, sizeof(trace)))\n\t\treturn -EFAULT;\n\n\tif (trace.rx_traces > RDS_MSG_RX_DGRAM_TRACE_MAX)\n\t\treturn -EFAULT;\n\n\trs->rs_rx_traces = trace.rx_traces;\n\tfor (i = 0; i < rs->rs_rx_traces; i++) {\n\t\tif (trace.rx_trace_pos[i] >= RDS_MSG_RX_DGRAM_TRACE_MAX) {\n\t\t\trs->rs_rx_traces = 0;\n\t\t\treturn -EFAULT;\n\t\t}\n\t\trs->rs_rx_trace[i] = trace.rx_trace_pos[i];\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n \n \trs->rs_rx_traces = trace.rx_traces;\n \tfor (i = 0; i < rs->rs_rx_traces; i++) {\n-\t\tif (trace.rx_trace_pos[i] > RDS_MSG_RX_DGRAM_TRACE_MAX) {\n+\t\tif (trace.rx_trace_pos[i] >= RDS_MSG_RX_DGRAM_TRACE_MAX) {\n \t\t\trs->rs_rx_traces = 0;\n \t\t\treturn -EFAULT;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (trace.rx_trace_pos[i] > RDS_MSG_RX_DGRAM_TRACE_MAX) {"
            ],
            "added_lines": [
                "\t\tif (trace.rx_trace_pos[i] >= RDS_MSG_RX_DGRAM_TRACE_MAX) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-7044",
        "func_name": "wireshark/dissect_wassp_sub_tlv",
        "description": "In Wireshark 3.2.x before 3.2.1, the WASSP dissector could crash. This was addressed in epan/dissectors/packet-wassp.c by using >= and <= to resolve off-by-one errors.",
        "git_url": "https://github.com/wireshark/wireshark/commit/f90a3720b73ca140403315126e2a478c4f70ca03",
        "commit_title": "WASSP: Fix a couple of off-by-one errors.",
        "commit_text": " Fix a couple of array length comparisons.  Bug: 16324 (cherry picked from commit 71b59b18e4bb61d0e6da8bb2b26c87750570ae40)",
        "func_before": "int dissect_wassp_sub_tlv(proto_tree *wassp_tree, tvbuff_t *tvb, packet_info *pinfo, int offset, int in_len, int which_tab, int ru_msg_type)\n{\n\tproto_item *tlvi;\n\tproto_item *ti;\n\tproto_tree *tmp_tree;\n\tchar *label;\n\tguint32 value;\n\tguint16 tlv_type = EID_PARSE_ERROR;\n\tguint16 length = 0, org_offset = offset;\n\tWASSP_SUBTLV_DECODER_INFO_t *tmp_decr = NULL;\n\tguint32 i, tableNo;\n\tint suboffset;\n\n\tif (which_tab >= TAB_MAX)\n\t{\n\t\treturn offset;\n\t}\n\n\ttmp_decr = (WASSP_SUBTLV_DECODER_INFO_t*)&wassp_decr_info[which_tab];\n\n\tif (tvb_reported_length_remaining(tvb, offset) > 0)\n\t{\n\t\tti = proto_tree_add_item(wassp_tree, hf_wassp_sub_tree, tvb, offset, in_len, ENC_NA);\n\t\tproto_item_append_text(ti, \" : %s\", tmp_decr->subtree_name);\n\t\ttmp_tree = proto_item_add_subtree(ti, *((int*)(WASSP_SUBTLV_GET_ETTNUM(tmp_decr))));\n\n\t\twhile (((value = tvb_reported_length_remaining(tvb, offset)) >= 4) && (offset - org_offset < in_len))\n\t\t{\n\t\t\ttlv_type = tvb_get_ntohs(tvb, offset + TLV_TYPE);\n\t\t\tlength = tvb_get_ntohs(tvb, offset + TLV_LENGTH);\n\t\t\tif (tlv_type > WASSP_SUBTLV_GET_MAXENTRY(tmp_decr))\n\t\t\t{\n\t\t\t\tproto_tree_add_uint_format_value(tmp_tree, hf_wassp_tlv_unknown, tvb, offset, 4, tlv_type, \"Unknow Wassp TLV (%d)\", tlv_type);\n\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_tlv_length, tvb, offset + TLV_LENGTH, 2, ENC_BIG_ENDIAN);\n\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_tlv_value_octext, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\t\toffset += length;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlabel = (char*)wassp_match_strval(tmp_decr, tlv_type);\n\t\t\tlabel = (label == NULL) ? \"Unknown Type\" : label;\n\n\t\t\tif (length > value)\n\t\t\t{\n\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_tlv_invalid, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\ttlv_type = EID_PARSE_ERROR;\n\t\t\t}\n\t\t\telse if (length < 4)\n\t\t\t{\n\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_tlv_invalid, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\ttlv_type = EID_PARSE_ERROR;\n\t\t\t}\n\t\t\telse if (length == 4)\n\t\t\t{\n\t\t\t\tif ((which_tab == TAB_RSS_DATA_ARRAY) && (tlv_type == EID_RSS_DATA_BLOCK))\n\t\t\t\t{\n\t\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_tlv_value_octext, tvb, offset, length, ENC_NA);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttlvi = proto_tree_add_item(tmp_tree, hf_wassp_tlv_value, tvb, offset, length, ENC_NA);\n\t\t\t\t\tproto_item_append_text(tlvi, \" : %s (%d)\", label, tlv_type);\n\t\t\t\t}\n\t\t\t\toffset += length;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ((which_tab == TAB_RSS_DATA_ARRAY) && (tlv_type == EID_RSS_DATA_BLOCK))\n\t\t\t\t{\n\t\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_tlv_value_octext, tvb, offset, length, ENC_NA);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttlvi = proto_tree_add_item(tmp_tree, hf_wassp_tlv_value, tvb, offset, length, ENC_NA);\n\t\t\t\t\tproto_item_append_text(tlvi, \" : %s (%d)\", label, tlv_type);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttlvi =   proto_tree_add_item(tmp_tree, hf_wassp_tlv_type_sub, tvb, offset + TLV_TYPE, 2, ENC_NA);\n\t\t\tproto_item_append_text(tlvi, \" : %s (%d)\", label, tlv_type);\n\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_tlv_length, tvb, offset + TLV_LENGTH, 2, ENC_BIG_ENDIAN);\n\n\t\t\tif (tlv_type == EID_PARSE_ERROR)\n\t\t\t{\n\t\t\t\tproto_tree_add_item(wassp_tree, hf_wassp_tlv_invalid, tvb, offset, value, ENC_BIG_ENDIAN);\n\t\t\t\toffset += length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (WASSP_SUBTLV_GET_ENTRY_IDX_TYPE(tmp_decr, tlv_type) != TLV_TYPE_BLOCK_TLV)\n\t\t\t\t{\n\t\t\t\t\tproto_tree_add_item(tmp_tree, wassp_type_converter(WASSP_SUBTLV_GET_ENTRY_IDX_TYPE(tmp_decr, tlv_type)), tvb, offset + TLV_VALUE, length - 4, FALSE);\n\t\t\t\t\tif ((which_tab == TAB_CONFIG_SITE) && (tlv_type == EID_SITE_TOPOLOGY_BLOCK))\n\t\t\t\t\t{\n\t\t\t\t\t\tsuboffset = offset + 4;\n\t\t\t\t\t\tfor (i = 0; i < (guint32)(length / 4 - 1); i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_topologykey, tvb, suboffset, 2, ENC_BIG_ENDIAN);\n\t\t\t\t\t\t\tsuboffset += 2;\n\t\t\t\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_topology_mode, tvb, suboffset, 2, ENC_BIG_ENDIAN);\n\t\t\t\t\t\t\tsuboffset += 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (which_tab == VNS_CONFIG_BLOCK)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tlv_type == EID_V_COS)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdecode_cos_struct(tmp_tree, tvb, offset + 4 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (tlv_type == EID_V_RATE_LIMIT_RESOURCE_TBL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdecode_rate_limit_struct(tmp_tree,tvb,  offset + 4,length-4 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (which_tab == TAB_CONFIG_FILTER || which_tab == TAB_FILTER_CONFIG_STRUCT_BLOCK)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tlv_type == EID_V_FILTER_RULES || tlv_type == EID_FILTER_RULES || tlv_type == EID_V_SITE_FILTER_RULES )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (length < 20)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdecode_filter_rule_octext_string(tmp_tree, tvb, offset + 4, length );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif (which_tab == TAB_SCAN_PROFILE_BLOCK)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tlv_type == EID_CHANNEL_LIST)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdecode_Channel_list(tmp_tree, tvb, offset + 4,  length -4 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (which_tab == TAB_SURVEILLANCE_DATA_BLOCK)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tlv_type == EID_SCAN_RSS_RSSI)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsuboffset = offset + 4;\n\t\t\t\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_rss, tvb, suboffset, 2, ENC_BIG_ENDIAN);\n\t\t\t\t\t\t\tsuboffset += 2;\n\t\t\t\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_rssi, tvb, suboffset, 2, ENC_BIG_ENDIAN);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (tlv_type == EID_PARAMS)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsuboffset = offset + 4;\n\t\t\t\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_threatstate, tvb, suboffset, 1, ENC_BIG_ENDIAN);\n\t\t\t\t\t\t\tsuboffset += 1;\n\t\t\t\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_radioparams, tvb, suboffset, 1, ENC_BIG_ENDIAN);\n\t\t\t\t\t\t\tsuboffset += 1;\n\t\t\t\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_channelfreq, tvb, suboffset, 2, ENC_BIG_ENDIAN);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif (which_tab == CONFIG_GLOBAL_BLOCK)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tlv_type == EID_ON_DEMAND_ARRAY || tlv_type == EID_DYN_ON_DEMAND_ARRAY)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdecode_mac_list_struct(tmp_tree, tvb, offset + 4,  length -4 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (which_tab == TAB_DETECTED_ROGUE_BLOCK)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tlv_type == EID_DNS_IP_ADDR)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdecode_ipv4_list_struct(tmp_tree, tvb, offset + 4,  length -4 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\toffset += length;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\n\t\t\t\t\ttableNo = WASSP_SUBTLV_GET_ENTRY_IDX_TABIDX(tmp_decr, tlv_type);\n\t\t\t\t\tif ((tableNo == RADIO_CONFIG_BLOCK) && (ru_msg_type == WASSP_RU_Ack))\n\t\t\t\t\t{\n\t\t\t\t\t\toffset = dissect_wassp_sub_tlv(tmp_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_RU_ACK_RADIO_CONFIG, ru_msg_type);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\toffset = dissect_wassp_sub_tlv(tmp_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, tableNo, ru_msg_type);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\treturn offset;\n}",
        "func": "int dissect_wassp_sub_tlv(proto_tree *wassp_tree, tvbuff_t *tvb, packet_info *pinfo, int offset, int in_len, int which_tab, int ru_msg_type)\n{\n\tproto_item *tlvi;\n\tproto_item *ti;\n\tproto_tree *tmp_tree;\n\tconst char *label;\n\tguint32 value;\n\tguint16 tlv_type = EID_PARSE_ERROR;\n\tguint16 length = 0, org_offset = offset;\n\tconst WASSP_SUBTLV_DECODER_INFO_t *tmp_decr = NULL;\n\tguint32 i, tableNo;\n\tint suboffset;\n\n\tif (which_tab >= TAB_MAX)\n\t{\n\t\treturn offset;\n\t}\n\n\ttmp_decr = &wassp_decr_info[which_tab];\n\n\tif (tvb_reported_length_remaining(tvb, offset) > 0)\n\t{\n\t\tti = proto_tree_add_item(wassp_tree, hf_wassp_sub_tree, tvb, offset, in_len, ENC_NA);\n\t\tproto_item_append_text(ti, \" : %s\", tmp_decr->subtree_name);\n\t\ttmp_tree = proto_item_add_subtree(ti, *((int*)(WASSP_SUBTLV_GET_ETTNUM(tmp_decr))));\n\n\t\twhile (((value = tvb_reported_length_remaining(tvb, offset)) >= 4) && (offset - org_offset < in_len))\n\t\t{\n\t\t\ttlv_type = tvb_get_ntohs(tvb, offset + TLV_TYPE);\n\t\t\tlength = tvb_get_ntohs(tvb, offset + TLV_LENGTH);\n\t\t\tif (tlv_type >= WASSP_SUBTLV_GET_MAXENTRY(tmp_decr))\n\t\t\t{\n\t\t\t\tproto_tree_add_uint_format_value(tmp_tree, hf_wassp_tlv_unknown, tvb, offset, 4, tlv_type, \"Unknow Wassp TLV (%d)\", tlv_type);\n\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_tlv_length, tvb, offset + TLV_LENGTH, 2, ENC_BIG_ENDIAN);\n\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_tlv_value_octext, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\t\toffset += length;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlabel = wassp_match_strval(tmp_decr, tlv_type);\n\t\t\tlabel = (label == NULL) ? \"Unknown Type\" : label;\n\n\t\t\tif (length > value)\n\t\t\t{\n\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_tlv_invalid, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\ttlv_type = EID_PARSE_ERROR;\n\t\t\t}\n\t\t\telse if (length < 4)\n\t\t\t{\n\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_tlv_invalid, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\ttlv_type = EID_PARSE_ERROR;\n\t\t\t}\n\t\t\telse if (length == 4)\n\t\t\t{\n\t\t\t\tif ((which_tab == TAB_RSS_DATA_ARRAY) && (tlv_type == EID_RSS_DATA_BLOCK))\n\t\t\t\t{\n\t\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_tlv_value_octext, tvb, offset, length, ENC_NA);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttlvi = proto_tree_add_item(tmp_tree, hf_wassp_tlv_value, tvb, offset, length, ENC_NA);\n\t\t\t\t\tproto_item_append_text(tlvi, \" : %s (%d)\", label, tlv_type);\n\t\t\t\t}\n\t\t\t\toffset += length;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ((which_tab == TAB_RSS_DATA_ARRAY) && (tlv_type == EID_RSS_DATA_BLOCK))\n\t\t\t\t{\n\t\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_tlv_value_octext, tvb, offset, length, ENC_NA);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttlvi = proto_tree_add_item(tmp_tree, hf_wassp_tlv_value, tvb, offset, length, ENC_NA);\n\t\t\t\t\tproto_item_append_text(tlvi, \" : %s (%d)\", label, tlv_type);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttlvi =   proto_tree_add_item(tmp_tree, hf_wassp_tlv_type_sub, tvb, offset + TLV_TYPE, 2, ENC_NA);\n\t\t\tproto_item_append_text(tlvi, \" : %s (%d)\", label, tlv_type);\n\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_tlv_length, tvb, offset + TLV_LENGTH, 2, ENC_BIG_ENDIAN);\n\n\t\t\tif (tlv_type == EID_PARSE_ERROR)\n\t\t\t{\n\t\t\t\tproto_tree_add_item(wassp_tree, hf_wassp_tlv_invalid, tvb, offset, value, ENC_BIG_ENDIAN);\n\t\t\t\toffset += length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (WASSP_SUBTLV_GET_ENTRY_IDX_TYPE(tmp_decr, tlv_type) != TLV_TYPE_BLOCK_TLV)\n\t\t\t\t{\n\t\t\t\t\tproto_tree_add_item(tmp_tree, wassp_type_converter(WASSP_SUBTLV_GET_ENTRY_IDX_TYPE(tmp_decr, tlv_type)), tvb, offset + TLV_VALUE, length - 4, FALSE);\n\t\t\t\t\tif ((which_tab == TAB_CONFIG_SITE) && (tlv_type == EID_SITE_TOPOLOGY_BLOCK))\n\t\t\t\t\t{\n\t\t\t\t\t\tsuboffset = offset + 4;\n\t\t\t\t\t\tfor (i = 0; i < (guint32)(length / 4 - 1); i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_topologykey, tvb, suboffset, 2, ENC_BIG_ENDIAN);\n\t\t\t\t\t\t\tsuboffset += 2;\n\t\t\t\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_topology_mode, tvb, suboffset, 2, ENC_BIG_ENDIAN);\n\t\t\t\t\t\t\tsuboffset += 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (which_tab == VNS_CONFIG_BLOCK)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tlv_type == EID_V_COS)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdecode_cos_struct(tmp_tree, tvb, offset + 4 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (tlv_type == EID_V_RATE_LIMIT_RESOURCE_TBL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdecode_rate_limit_struct(tmp_tree,tvb,  offset + 4,length-4 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (which_tab == TAB_CONFIG_FILTER || which_tab == TAB_FILTER_CONFIG_STRUCT_BLOCK)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tlv_type == EID_V_FILTER_RULES || tlv_type == EID_FILTER_RULES || tlv_type == EID_V_SITE_FILTER_RULES )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (length < 20)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdecode_filter_rule_octext_string(tmp_tree, tvb, offset + 4, length );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif (which_tab == TAB_SCAN_PROFILE_BLOCK)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tlv_type == EID_CHANNEL_LIST)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdecode_Channel_list(tmp_tree, tvb, offset + 4,  length -4 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (which_tab == TAB_SURVEILLANCE_DATA_BLOCK)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tlv_type == EID_SCAN_RSS_RSSI)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsuboffset = offset + 4;\n\t\t\t\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_rss, tvb, suboffset, 2, ENC_BIG_ENDIAN);\n\t\t\t\t\t\t\tsuboffset += 2;\n\t\t\t\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_rssi, tvb, suboffset, 2, ENC_BIG_ENDIAN);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (tlv_type == EID_PARAMS)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsuboffset = offset + 4;\n\t\t\t\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_threatstate, tvb, suboffset, 1, ENC_BIG_ENDIAN);\n\t\t\t\t\t\t\tsuboffset += 1;\n\t\t\t\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_radioparams, tvb, suboffset, 1, ENC_BIG_ENDIAN);\n\t\t\t\t\t\t\tsuboffset += 1;\n\t\t\t\t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_channelfreq, tvb, suboffset, 2, ENC_BIG_ENDIAN);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif (which_tab == CONFIG_GLOBAL_BLOCK)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tlv_type == EID_ON_DEMAND_ARRAY || tlv_type == EID_DYN_ON_DEMAND_ARRAY)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdecode_mac_list_struct(tmp_tree, tvb, offset + 4,  length -4 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (which_tab == TAB_DETECTED_ROGUE_BLOCK)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tlv_type == EID_DNS_IP_ADDR)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdecode_ipv4_list_struct(tmp_tree, tvb, offset + 4,  length -4 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\toffset += length;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\n\t\t\t\t\ttableNo = WASSP_SUBTLV_GET_ENTRY_IDX_TABIDX(tmp_decr, tlv_type);\n\t\t\t\t\tif ((tableNo == RADIO_CONFIG_BLOCK) && (ru_msg_type == WASSP_RU_Ack))\n\t\t\t\t\t{\n\t\t\t\t\t\toffset = dissect_wassp_sub_tlv(tmp_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_RU_ACK_RADIO_CONFIG, ru_msg_type);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\toffset = dissect_wassp_sub_tlv(tmp_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, tableNo, ru_msg_type);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\treturn offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,11 +3,11 @@\n \tproto_item *tlvi;\n \tproto_item *ti;\n \tproto_tree *tmp_tree;\n-\tchar *label;\n+\tconst char *label;\n \tguint32 value;\n \tguint16 tlv_type = EID_PARSE_ERROR;\n \tguint16 length = 0, org_offset = offset;\n-\tWASSP_SUBTLV_DECODER_INFO_t *tmp_decr = NULL;\n+\tconst WASSP_SUBTLV_DECODER_INFO_t *tmp_decr = NULL;\n \tguint32 i, tableNo;\n \tint suboffset;\n \n@@ -16,7 +16,7 @@\n \t\treturn offset;\n \t}\n \n-\ttmp_decr = (WASSP_SUBTLV_DECODER_INFO_t*)&wassp_decr_info[which_tab];\n+\ttmp_decr = &wassp_decr_info[which_tab];\n \n \tif (tvb_reported_length_remaining(tvb, offset) > 0)\n \t{\n@@ -28,7 +28,7 @@\n \t\t{\n \t\t\ttlv_type = tvb_get_ntohs(tvb, offset + TLV_TYPE);\n \t\t\tlength = tvb_get_ntohs(tvb, offset + TLV_LENGTH);\n-\t\t\tif (tlv_type > WASSP_SUBTLV_GET_MAXENTRY(tmp_decr))\n+\t\t\tif (tlv_type >= WASSP_SUBTLV_GET_MAXENTRY(tmp_decr))\n \t\t\t{\n \t\t\t\tproto_tree_add_uint_format_value(tmp_tree, hf_wassp_tlv_unknown, tvb, offset, 4, tlv_type, \"Unknow Wassp TLV (%d)\", tlv_type);\n \t\t\t\tproto_tree_add_item(tmp_tree, hf_wassp_tlv_length, tvb, offset + TLV_LENGTH, 2, ENC_BIG_ENDIAN);\n@@ -37,7 +37,7 @@\n \t\t\t\tcontinue;\n \t\t\t}\n \n-\t\t\tlabel = (char*)wassp_match_strval(tmp_decr, tlv_type);\n+\t\t\tlabel = wassp_match_strval(tmp_decr, tlv_type);\n \t\t\tlabel = (label == NULL) ? \"Unknown Type\" : label;\n \n \t\t\tif (length > value)",
        "diff_line_info": {
            "deleted_lines": [
                "\tchar *label;",
                "\tWASSP_SUBTLV_DECODER_INFO_t *tmp_decr = NULL;",
                "\ttmp_decr = (WASSP_SUBTLV_DECODER_INFO_t*)&wassp_decr_info[which_tab];",
                "\t\t\tif (tlv_type > WASSP_SUBTLV_GET_MAXENTRY(tmp_decr))",
                "\t\t\tlabel = (char*)wassp_match_strval(tmp_decr, tlv_type);"
            ],
            "added_lines": [
                "\tconst char *label;",
                "\tconst WASSP_SUBTLV_DECODER_INFO_t *tmp_decr = NULL;",
                "\ttmp_decr = &wassp_decr_info[which_tab];",
                "\t\t\tif (tlv_type >= WASSP_SUBTLV_GET_MAXENTRY(tmp_decr))",
                "\t\t\tlabel = wassp_match_strval(tmp_decr, tlv_type);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-7044",
        "func_name": "wireshark/wassp_match_strval",
        "description": "In Wireshark 3.2.x before 3.2.1, the WASSP dissector could crash. This was addressed in epan/dissectors/packet-wassp.c by using >= and <= to resolve off-by-one errors.",
        "git_url": "https://github.com/wireshark/wireshark/commit/f90a3720b73ca140403315126e2a478c4f70ca03",
        "commit_title": "WASSP: Fix a couple of off-by-one errors.",
        "commit_text": " Fix a couple of array length comparisons.  Bug: 16324 (cherry picked from commit 71b59b18e4bb61d0e6da8bb2b26c87750570ae40)",
        "func_before": "static const char* wassp_match_strval(WASSP_SUBTLV_DECODER_INFO_t *in_ptr, int in_type)\n{\n\tif (in_ptr == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\tif (in_ptr->max_entry < in_type)\n\t{\n\t\treturn NULL;\n\t}\n\n\treturn in_ptr->entry[in_type].name;\n}",
        "func": "static const char* wassp_match_strval(const WASSP_SUBTLV_DECODER_INFO_t *in_ptr, int in_type)\n{\n\tif (in_ptr == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\tif (in_ptr->max_entry <= in_type)\n\t{\n\t\treturn NULL;\n\t}\n\n\treturn in_ptr->entry[in_type].name;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,10 @@\n-static const char* wassp_match_strval(WASSP_SUBTLV_DECODER_INFO_t *in_ptr, int in_type)\n+static const char* wassp_match_strval(const WASSP_SUBTLV_DECODER_INFO_t *in_ptr, int in_type)\n {\n \tif (in_ptr == NULL)\n \t{\n \t\treturn NULL;\n \t}\n-\tif (in_ptr->max_entry < in_type)\n+\tif (in_ptr->max_entry <= in_type)\n \t{\n \t\treturn NULL;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "static const char* wassp_match_strval(WASSP_SUBTLV_DECODER_INFO_t *in_ptr, int in_type)",
                "\tif (in_ptr->max_entry < in_type)"
            ],
            "added_lines": [
                "static const char* wassp_match_strval(const WASSP_SUBTLV_DECODER_INFO_t *in_ptr, int in_type)",
                "\tif (in_ptr->max_entry <= in_type)"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-7044",
        "func_name": "wireshark/dissect_wassp_tlv",
        "description": "In Wireshark 3.2.x before 3.2.1, the WASSP dissector could crash. This was addressed in epan/dissectors/packet-wassp.c by using >= and <= to resolve off-by-one errors.",
        "git_url": "https://github.com/wireshark/wireshark/commit/f90a3720b73ca140403315126e2a478c4f70ca03",
        "commit_title": "WASSP: Fix a couple of off-by-one errors.",
        "commit_text": " Fix a couple of array length comparisons.  Bug: 16324 (cherry picked from commit 71b59b18e4bb61d0e6da8bb2b26c87750570ae40)",
        "func_before": "int dissect_wassp_tlv(proto_tree *wassp_tree, tvbuff_t *tvb, packet_info *pinfo, int offset, wassp_ru_msg_t rumsg_type)\n{\n\tproto_item *tlvi = NULL;\n\tproto_tree *tlv_tree;\n\tguint16 tlv_type = WASSP_RU_UNUSED_0;\n\tguint16 length;\n\tguint32 value;\n\tint suboffset;\n\twassp_ru_msg_t ru_msg_type = rumsg_type;\n\tchar *label;\n\n\n\n\tSET_WASSP_TLV_VERSION(0);\n\twhile ((value = tvb_reported_length_remaining(tvb, offset)) >= 4)\n\t{\n\t\ttlv_type = tvb_get_ntohs(tvb, offset + TLV_TYPE);\n\t\tlength = tvb_get_ntohs(tvb, offset + TLV_LENGTH);\n\t\tlabel = (char*)try_val_to_str(tlv_type, wassp_tlv_types);\n\t\tlabel = (label == NULL) ? \"Unknown Type\" : label;\n\n\t\tif (length > value)\n\t\t{\n\t\t\ttlvi = proto_tree_add_item(wassp_tree, hf_wassp_tlv_invalid, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\ttlv_type = EID_UNUSED_0;\n\t\t}\n\t\telse if (length < 4)\n\t\t{\n\t\t\ttlvi = proto_tree_add_item(wassp_tree, hf_wassp_tlv_invalid, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\ttlv_type = EID_UNUSED_0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttlvi = proto_tree_add_item(wassp_tree, hf_wassp_tlv_value, tvb, offset, length, ENC_NA);\n\t\t\tproto_item_append_text(tlvi, \" : %s (%d)\", label, tlv_type);\n\n\t\t}\n\n\t\ttlv_tree = proto_item_add_subtree(tlvi, ett_wassp_tlv);\n\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_type_main, tvb, offset + TLV_TYPE, 2, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_length, tvb, offset + TLV_LENGTH, 2, ENC_BIG_ENDIAN);\n\n\t\tswitch (tlv_type)\n\t\t{\n\t\tcase EID_UNUSED_0:                  // 0\n\t\t\toffset += 4;\n\t\t\tbreak;\n\n\t\tcase EID_STATUS:                    // 1\n\t\t\tru_msg_type = (wassp_ru_msg_t) tvb_get_guint8(tvb, WASSP_HDR_TYPE);\n\n\t\t\t/*this is an action TLV*/\n\t\t\tif (WASSP_RU_SW_Version_Validate_Rsp == ru_msg_type)\n\t\t\t{\n\t\t\t\tproto_item_append_text(tlvi, \" (upgrade action)\");\n\t\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_eid_action, tvb, offset + TLV_VALUE, length - 4, ENC_BIG_ENDIAN);\n\t\t\t}\n\t\t\telse  /*assume status TLV*/\n\t\t\t{\n\t\t\t\tproto_item_append_text(tlvi, \" (status)\");\n\t\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_eid_status, tvb, offset + TLV_VALUE, length - 4, ENC_BIG_ENDIAN);\n\t\t\t}\n\t\t\toffset += length;\n\t\t\tbreak;\n\n\t\t/* display as string */\n\t\tcase EID_RU_SW_VERSION:                       // 2\n\t\tcase EID_RU_SERIAL_NUMBER:                    // 3\n\t\tcase EID_IMAGE_PATH:                          // 9\n\t\tcase EID_RANDOM_NUMBER:                       // 14\n\t\tcase EID_RU_MODEL:                            // 17\n\t\tcase EID_RU_TRAP:                             // 24\n\t\tcase EID_RU_SSID_NAME:                        // 37\n\t\tcase EID_AC_REG_CHALLENGE:                    // 41\n\t\tcase EID_AC_REG_RESPONSE:                     // 42\n\t\tcase EID_STATS:                               // 43\n\t\tcase EID_CERTIFICATE:                         // 44\n\t\tcase EID_RADIO_INFO:                          // 51\n\t\tcase EID_NETWORK_INFO:                        // 52\n\t\tcase EID_PRODUCT_ID:                          // 54\n\t\tcase EID_RADIO_INFO_ACK:                      // 55\n\t\tcase EID_SSID:                                // 58\n\t\tcase EID_MU_PMKID_LIST:                       // 72\n\t\tcase EID_MU_PMK_BP:                           // 73\n\t\tcase EID_MU_PMKID_BP:                         // 74\n\t\tcase EID_LOG_FILE:                            // 83\n\t\tcase EID_ALARM_DESCRIPTION:                   // 85\n\t\tcase EID_RU_BACKUP_VERSION:                   // 93\n\t\tcase EID_AC_SW_VERSION:                       // 94\n\t\tcase EID_MCAST_LAMG_LIST:                     // 95\n\t\tcase EID_FILTER_NAME:                         // 96\n\t\tcase EID_SENSOR_IMG_VERSION:                  // 104\n\t\tcase EID_RATECTRL_NAME_UL:                    // 111\n\t\tcase EID_RATECTRL_NAME_DL:                    // 112\n\t\tcase EID_POLICY_NAME:                         // 113\n\t\tcase EID_SIAPP_AP_NAME:                       // 120\n\t\tcase EID_SIAPP_USER_IDENTITY:                 // 151\n\t\tcase EID_MU_FILTER_POLICY_NAME:               // 162\n\t\tcase EID_MU_TOPOLOGY_POLICY_NAME:             // 163\n\t\tcase EID_MU_COS_POLICY_NAME:                  // 164\n\t\tcase EID_SITE_NAME:                           // 175\n\t\tcase EID_SSS_SSID:                            // 191\n\t\tcase EID_POLICY_ZONE_NAME:                    // 193\n\t\tcase EID_MU_USER_NAME:                        // 196\n\t\tcase EID_SCAN_SSID:                           // 237\n\t\tcase EID_THREAT_NAME:                         // 248\n\t\tcase EID_LOCATION:                            // 249\n\t\tcase EID_MU_EVENT_STRING:                     // 254\n\t\tcase EID_LOCATOR_FLOOR_NAME:                  // 288\n\t\tcase EID_MU_RFS_NAME:                         // 296\n\t\tcase EID_MU_URL:                              // 301\n\t\tcase EID_MU_ACCT_SESSION_ID_STRING:           // 304\n\t\tcase EID_MU_ACCT_POLICY_NAME:                 // 305\n\t\tcase EID_MU_TUNNEL_PRIVATE_GROUP_ID_STRING:   // 309\n\t\tcase EID_MU_USER_ID_STRING:                   // 310\n\t\tcase EID_MU_LOCATION:                         // 331\n\t\tcase EID_AREA_NAME:                           // 335\n\t\tcase EID_CUI:                                 // 363\n\t\tcase EID_WFA_HS20_URL:                        // 368\n\t\tcase EID_DHCP_HOST_NAME:                      // 382\n\t\tcase EID_MU_ECP_PW:                           // 385\n\t\tcase EID_MU_ECP_TOKEN:                        // 386\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_string, tvb, offset + TLV_VALUE, length - 4, ENC_ASCII|ENC_NA);\n\t\t\toffset += length;\n\t\t\tbreak;\n\n\t\t/* display as octext string */\n\t\tcase EID_RU_REG_CHALLENGE:                      // 4\n\t\tcase EID_RU_REG_RESPONSE:                       // 5\n\t\tcase EID_RU_VNSID:                              // 7\n\t\tcase EID_SESSION_KEY:                           // 12\n\t\tcase EID_RU_PREAUTH:                            // 39\n\t\tcase EID_RU_PMK:                                // 40\n\t\tcase EID_SIAPP_PMKID:                           // 115\n\t\tcase EID_SIAPP_PMK_REAUTH:                      // 116\n\t\tcase EID_SIAPP_PMK_LIFETIME:                    // 117\n\t\tcase EID_SIAPP_PMKID_FLAG:                      // 118\n\t\tcase EID_SIAPP_MU_PMK:                          // 119\n\t\tcase EID_SIAPP_CLUSTER_ACS_REQ:                 // 122\n\t\tcase EID_SIAPP_PACKET_RETRIES:                  // 124\n\t\tcase EID_SIAPP_ASSOC_IN_WLAN:                   // 125\n\t\tcase EID_SIAPP_ASSOC_IN_CLUSTER:                // 126\n\t\tcase EID_SIAPP_REASSOC_IN_CLUSTER:              // 127\n\t\tcase EID_SIAPP_NEWAP_BSSID:                     // 129\n\t\tcase EID_SIAPP_OLDAP_BSSID:                     // 130\n\t\tcase EID_SIAPP_RAD_CACS_REQ:                    // 131\n\t\tcase EID_SIAPP_CLIENT_COUNT:                    // 133\n\t\tcase EID_SIAPP_MU_TransmittedFrameCount:        // 135\n\t\tcase EID_SIAPP_MU_ReceivedFrameCount:           // 136\n\t\tcase EID_SIAPP_MU_TransmittedBytes:             // 137\n\t\tcase EID_SIAPP_MU_ReceivedBytes:                // 138\n\t\tcase EID_SIAPP_MU_UL_DroppedRateControlPackets: // 139\n\t\tcase EID_SIAPP_MU_DL_DroppedRateControlPackets: // 140\n\t\tcase EID_SIAPP_MU_DL_DroppedBufferFullPackets:  // 141\n\t\tcase EID_SIAPP_MU_DL_LostRetriesPackets:        // 142\n\t\tcase EID_SIAPP_MU_UL_DroppedRateControlBytes:   // 143\n\t\tcase EID_SIAPP_MU_DL_DroppedRateControlBytes:   // 144\n\t\tcase EID_SIAPP_MU_DL_DroppedBufferFullBytes:    // 145\n\t\tcase EID_SIAPP_MU_DL_LostRetriesBytes:          // 146\n\t\tcase EID_SIAPP_BP_BSSID:                        // 147\n\t\tcase EID_SIAPP_RADIO_ID:                        // 148\n\t\tcase EID_SIAPP_PREAUTH_REQ:                     // 150\n\t\tcase EID_SIAPP_LOADBAL_LOADGROUP_ID:            // 154\n\t\tcase EID_MU_ACCOUNTING_CLASS:                   // 169\n\t\tcase EID_SSS_TS64_MU_UPDATE:                    // 183\n\t\tcase EID_SSS_TS64_AP_CURRENT:                   // 184\n\t\tcase EID_SSS_AP_HOMEHASH:                       // 186\n\t\tcase EID_EVENT_ARRAY:                           // 189\n\t\tcase EID_INFORM_MU_PMK:                         // 199\n\t\tcase EID_ARP_PROXY:                             // 201\n\t\tcase EID_MCAST_FILTER_RULES:                    // 202\n\t\tcase EID_AP_PARAMS:                             // 203\n\t\tcase EID_THREAT_STATS_F:                        // 220\n\t\tcase EID_THREAT_PATTERN:                        // 224\n\t\tcase EID_LOCATOR_LOC_POINT:                     // 265\n\t\tcase EID_MU_EVENT_DETAILS:                      // 266\n\t\tcase EID_MU_EVENT_LOC_BLOCK:                    // 268\n\t\tcase EID_AP_REDIRECT:                           // 291\n\t\tcase EID_MU_CVLAN_BAP:                          // 292\n\t\tcase EID_MU_SESSION_ID:                         // 295\n\t\tcase EID_MU_FLAGS:                              // 297\n\t\tcase EID_MU_ASSOC_TIME:                         // 298\n\t\tcase EID_MU_ACTIVE_TIME:                        // 299\n\t\tcase EID_REPORT_REQ:                            // 300\n\t\tcase EID_MU_SESSION_LIFETIME:                   // 302\n\t\tcase EID_MU_REAUTH_TIMER:                       // 303\n\t\tcase EID_MU_ACCT_START_TIME:                    // 306\n\t\tcase EID_MU_ACCT_CLASS:                         // 307\n\t\tcase EID_MU_LOGIN_LAT_GROUP:                    // 308\n\t\tcase EID_MU_DEFENDED_STATE:                     // 311\n\t\tcase EID_MU_MOD_MASK:                           // 312\n\t\tcase EID_LOCATOR_TRACKED:                       // 313\n\t\tcase EID_PORT:                                  // 314\n\t\tcase EID_RETRIES_COUNT:                         // 315\n\t\tcase EID_MODULATION_TYPE:                       // 316\n\t\tcase EID_ROGUE_DETECTION:                       // 319\n\t\tcase EID_TTL:                                   // 324\n\t\tcase EID_LOCATOR_STATE_DATA:                    // 326\n\t\tcase EID_LOCATOR_POINT_SET:                     // 327\n\t\tcase EID_FILTER_RULE_FIXED_APP_ID:              // 328\n\t\tcase EID_MU_AREA_BLOCK:                         // 330\n\t\tcase EID_IN_SERVICE_AP_LIST:                    // 334\n\t\tcase EID_OUT_SERVICE_AP_LIST:                   // 335\n\t\tcase EID_LAST_RD_AP:                            // 336\n\t\tcase EID_ROGUE_INFO:                            // 337\n\t\tcase EID_MU_PMK_R1:                             // 339\n\t\tcase EID_SIAPP_R0KHID:                          // 340\n\t\tcase EID_SIAPP_R1KHID:                          // 341\n\t\tcase EID_SIAPP_FT_NONCE:                        // 342\n\t\tcase EID_SIAPP_FT_PMKR0NAME:                    // 343\n\t\tcase EID_SIAPP_FT_R1KHID:                       // 344\n\t\tcase EID_SIAPP_FT_S1KHID:                       // 345\n\t\tcase EID_SIAPP_FT_PMKR1:                        // 346\n\t\tcase EID_SIAPP_FT_PMKR1NAME:                    // 347\n\t\tcase EID_SIAPP_FT_PAIRWISE:                     // 348\n\t\tcase EID_SIAPP_FT_LIFETIME:                     // 349\n\t\tcase EID_MU_POWER_CAP:                          // 350\n\t\tcase EID_PERIODIC_NEIGHBOUR_REPORT:             // 352\n\t\tcase EID_NEIGHBOUR_ENTRY:                       // 354\n\t\tcase EID_MU_PMK_R0NAME:                         // 362\n\t\tcase EID_IPV6_ADDR:                             // 373\n\t\tcase EID_MU_DEV_IDENTITY:                       // 376\n\t\tcase EID_NEIGHBOUR_ENTRY_2:                     // 383\n\t\tcase EID_CHANNEL_ENTRY:                         // 384\n\t\tcase EID_PKT_F_WIRELESS:                        // 391\n\t\tcase EID_PKT_F_WIREDCLIENT:                     // 392\n\t\tcase EID_PKT_F_DIRECTION:                       // 393\n\t\tcase EID_PKT_F_IP_ARRAY:                        // 396\n\t\tcase EID_PKT_F_RADIO:                           // 394\n\t\tcase EID_VSA_SSID_ID:                           // 400\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_octext, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\toffset += length;\n\t\t\tbreak;\n\n\t\t/* display as IP address format */\n\t\tcase EID_AC_IPADDR:                    // 6\n\t\tcase EID_TFTP_SERVER:                  // 8\n\t\tcase EID_STATIC_BP_IPADDR:             // 30\n\t\tcase EID_STATIC_BP_NETMASK:            // 31\n\t\tcase EID_STATIC_BP_GATEWAY:            // 32\n\t\tcase EID_STATIC_BM_IPADDR:             // 33\n\t\tcase EID_AP_IPADDR:                    // 89\n\t\tcase EID_AP_NETMASK:                   // 90\n\t\tcase EID_AP_GATEWAY:                   // 91\n\t\tcase EID_MU_IP_ADDR:                   // 173\n\t\tcase EID_PEER_SITE_IP:                 // 176\n\t\tcase EID_COLLECTOR_IP_ADDR:            // 200\n\t\tcase EID_IP_ADDR_TX:                   // 322\n\t\tcase EID_IP_ADDR_RX:                   // 323\n\t\tcase EID_GW_IP_ADDR:                   // 325\n\t\tcase EID_STATIC_VSA_IPADDR:            // 387\n\t\tcase EID_STATIC_VSA_NETMASK:           // 388\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_ip, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\toffset += length;\n\t\t\tbreak;\n\n\t\tcase EID_CONFIG:                       // 10\n\t\tcase EID_ALARM:                        // 38\n\t\t\t/* Dissect SNMP encoded configuration */\n\t\t\tdissector_try_uint(wassp_dissector_table, WASSP_SNMP, tvb_new_subset_length_caplen(tvb, offset + TLV_VALUE, -1, length - 4), pinfo, tlv_tree);\n\t\t\toffset += length;\n\t\t\tbreak;\n\n\t\tcase EID_RU_STATE:                     // 11\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_eid_rustate, tvb, offset + TLV_VALUE, length - 4, ENC_BIG_ENDIAN);\n\t\t\tproto_item_append_text(tlvi, \": %s\",\n\t\t\t\t\t       (tvb_get_guint8(tvb, offset + TLV_VALUE) ?\n\t\t\t\t\t\twassp_eid_rustate_types.true_string :\n\t\t\t\t\t\twassp_eid_rustate_types.false_string));\n\t\t\toffset += length;\n\t\t\tbreak;\n\n\t\t/* display as int */\n\t\tcase EID_RU_PROTOCOL:                     // 13\n\t\tcase EID_STANDBY_TIMEOUT:                 // 15\n\t\tcase EID_RU_CHALLENGE_ID:                 // 16\n\t\tcase EID_RU_SCAN_MODE:                    // 18\n\t\tcase EID_RU_SCAN_TYPE:                    // 19\n\t\tcase EID_RU_SCAN_INTERVAL:                // 20\n\t\tcase EID_RU_RADIO_TYPE:                   // 21\n\t\tcase EID_RU_CHANNEL_DWELL_TIME:           // 22\n\t\tcase EID_RU_CHANNEL_LIST:                 // 23\n\t\tcase EID_RU_SCAN_TIMES:                   // 25\n\t\tcase EID_RU_SCAN_DELAY:                   // 26\n\t\tcase EID_RU_SCAN_REQ_ID:                  // 27\n\t\tcase EID_STATIC_CONFIG:                   // 28\n\t\tcase EID_LOCAL_BRIDGING:                  // 29\n\t\tcase EID_RU_CAPABILITY:                   // 36\n\t\tcase EID_RADIO_ID:                        // 45\n\t\tcase EID_REQ_ID:                          // 46\n\t\tcase EID_NETWORK_ID:                      // 47\n\t\tcase EID_TIME:                            // 49\n\t\tcase EID_NUM_RADIOS:                      // 50\n\t\tcase EID_VENDOR_ID:                       // 53\n\t\tcase EID_SECURE_TUNNEL:                   // 56\n\t\tcase EID_MU_TOPOLOGY_ID:                  // 57\n\t\tcase EID_SNMP_ERROR_STATUS:               // 60\n\t\tcase EID_SNMP_ERROR_INDEX:                // 61\n\t\tcase EID_RU_REAUTH_TIMER:                 // 62\n\t\tcase EID_AP_IMG_TO_RAM:                   // 63\n\t\tcase EID_AP_IMG_ROLE:                     // 64\n\t\tcase EID_STATS_REQUEST_TYPE:              // 67\n\t\tcase EID_STATS_LAST:                      // 68\n\t\tcase EID_COUNTDOWN_TIME:                  // 75\n\t\tcase EID_WASSP_VLAN_TAG:                  // 76\n\t\tcase EID_SSID_ID:                         // 77\n\t\tcase EID_PORT_OPEN_FLAG:                  // 80\n\t\tcase EID_WASSP_TUNNEL_TYPE:               // 81\n\t\tcase EID_LOG_TYPE:                        // 82\n\t\tcase EID_ALARM_SEVERITY:                  // 84\n\t\tcase EID_AP_DHCP_MODE:                    // 88\n\t\tcase EID_AUTH_STATE:                      // 98\n\t\tcase EID_MU_DISC_AFTER_AUTH:              // 99\n\t\tcase EID_TRANS_ID:                        // 101\n\t\tcase EID_TIMEZONE_OFFSET:                 // 102\n\t\tcase EID_SENSOR_FORCE_DOWNLOAD:           // 103\n\t\tcase EID_BRIDGE_MODE:                     // 105\n\t\tcase EID_MU_VLAN_TAG:                     // 106\n\t\tcase EID_RATECTRL_CIR_UL:                 // 107\n\t\tcase EID_RATECTRL_CIR_DL:                 // 108\n\t\tcase EID_RATECTRL_CBS_UL:                 // 109\n\t\tcase EID_RATECTRL_CBS_DL:                 // 110\n\t\tcase EID_SIAPP_LOADBAL_PKT_TYPE:          // 153\n\t\tcase EID_SIAPP_LOADBAL_LOAD_VALUE:        // 155\n\t\tcase EID_SIAPP_FILTER_COS:                // 157\n\t\tcase EID_UCAST_FILTER_DISABLE:            // 160\n\t\tcase EID_MU_INFORM_REASON:                // 161\n\t\tcase EID_MU_FILTER_KEY:                   // 165\n\t\tcase EID_MU_TOPOLOGY_KEY:                 // 166\n\t\tcase EID_MU_COS_KEY:                      // 167\n\t\tcase EID_MU_SESSION_TIMEOUT:              // 168\n\t\tcase EID_MU_LOGIN_LAT_PORT:               // 170\n\t\tcase EID_MU_IDLE_TIMEOUT:                 // 171\n\t\tcase EID_MU_ACCT_INTERIM_INTERVAL:        // 172\n\t\tcase EID_MU_TERMINATE_ACTION:             // 174\n\t\tcase EID_INTERFERENCE_EVENTS_ENABLE:      // 177\n\t\tcase EID_EVENT_TYPE:                      // 178\n\t\tcase EID_EVENT_CHANNEL:                   // 179\n\t\tcase EID_EVENT_VALUE:                     // 180\n\t\tcase EID_SSS_MU_ASSOC_TIME:               // 182\n\t\tcase EID_SSS_MU_AUTH_STATE:               // 185\n\t\tcase EID_TIME_FIRST_DETECTED:             // 187\n\t\tcase EID_TIME_LAST_REPORTED:              // 188\n\t\tcase EID_SSS_DEFAULT_SESSION_TIMEOUT:     // 190\n\t\tcase EID_SSS_PRIVACY_TYPE:                // 192\n\t\tcase EID_RU_AC_EVENT_COMPONENT_ID:        // 194\n\t\tcase EID_MU_AUTH_STATE:                   // 195\n\t\tcase EID_BULK_TYPE:                       // 197\n\t\tcase EID_SENT_TIME:                       // 198\n\t\tcase EID_SCAN_PROFILE_ID:                 // 209\n\t\tcase EID_ACTION_REQ:                      // 210\n\t\tcase EID_COUNTERMEASURES_MAX_CH:          // 212\n\t\tcase EID_COUNTERMEASURES_SET:             // 213\n\t\tcase EID_SEQ_NUM:                         // 215\n\t\tcase EID_THREAT_TYPE:                     // 218\n\t\tcase EID_THREAT_ID:                       // 219\n\t\tcase EID_THREAT_FR_SFR:                   // 221\n\t\tcase EID_THREAT_ALERT_TH_DUR:             // 225\n\t\tcase EID_THREAT_CLEAR_TH_DUR:             // 226\n\t\tcase EID_THREAT_PRIORITY:                 // 227\n\t\tcase EID_THREAT_MITIGATION_LIST:          // 228\n\t\tcase EID_PARAMS:                          // 235\n\t\tcase EID_MU_EVENT_TYPE:                   // 260\n\t\tcase EID_SSS_MU_IS_PORT_CLOSED:           // 229\n\t\tcase EID_FULL_UPDATE:                     // 230\n\t\tcase EID_REASON:                          // 231\n\t\tcase EID_SCAN_CAP:                        // 238\n\t\tcase EID_THREAT_CLASSIFICATION:           // 239\n\t\tcase EID_STATE:                           // 242\n\t\tcase EID_DROP_FR_CNT:                     // 243\n\t\tcase EID_STOP_ROAM_CNT:                   // 244\n\t\tcase EID_SPOOF_CNT:                       // 245\n\t\tcase EID_ENCRYPTION_TYPE:                 // 250\n\t\tcase EID_COMPONENT_ID:                    // 253\n\t\tcase EID_BYPASS_BMCAST:                   // 255\n\t\tcase EID_GETTIMEOFDAY:                    // 256\n\t\tcase EID_COUNTRY_ID:                      // 257\n\t\tcase EID_LOCATOR_FLOOR_ID:                // 261\n\t\tcase EID_LOCATOR_LOC_TYPE:                // 262\n\t\tcase EID_MU_EVENT_FROM_AP:                // 267\n\t\tcase EID_LOCATOR_LOC_AP_DISTANCE:         // 269\n\t\tcase EID_LOCATOR_LOC_PRECISION:           // 270\n\t\tcase EID_LOCATOR_MU_ACTION:               // 273\n\t\tcase EID_EFFECTIVE_EGRESS_VLAN:           // 274\n\t\tcase EID_REBOOT_ACK:                      // 275\n\t\tcase EID_AUTH_FLAG:                       // 277\n\t\tcase EID_ROAMED_FLAG:                     // 278\n\t\tcase EID_MU_RSS:                          // 279\n\t\tcase EID_FILTER_RULES_VER:                // 280\n\t\tcase EID_FILTER_TYPE:                     // 281\n\t\tcase EID_DEFAULT_ACTION_TYPE:             // 284\n\t\tcase EID_DEFAULT_CONTAIN_TO_VLAN:         // 285\n\t\tcase EID_DEFAULT_BRIDGE_MODE:             // 286\n\t\tcase EID_INVALID_POLICY:                  // 287\n\t\tcase EID_AP_FLAGS:                        // 289\n\t\tcase EID_AP_PVID:                         // 290\n\t\tcase EID_MU_LOCATION_TS:                  // 332\n\t\tcase EID_MU_IS_FT:                        // 338\n\t\tcase EID_TIMESTAMP:                       // 353\n\t\tcase EID_MU_REQ:                          // 355\n\t\tcase EID_RU_REQ:                          // 356\n\t\tcase EID_NEIGHBOUR_REQ:                   // 357\n\t\tcase EID_SSS_FT_ASSOC:                    // 358\n\t\tcase EID_DEFAULT_MIRRORN:                 // 359\n\t\tcase EID_FILTER_RULE_EXT_ACT_FLAGS:       // 360\n\t\tcase EID_TOPO_GROUP_MAPPING:              // 361\n\t\tcase EID_SSS_CAPINFO:                     // 364\n\t\tcase EID_SSS_CAPPOWER:                    // 365\n\t\tcase EID_WFA_VSA:                         // 366\n\t\tcase EID_WFA_HS20_REMED_METHOD:           // 367\n\t\tcase EID_WFA_HS20_DEAUTH_CODE:            // 369\n\t\tcase EID_WFA_HS20_REAUTH_DELAY:           // 370\n\t\tcase EID_WFA_HS20_SWT:                    // 371\n\t\tcase EID_POWER_STATUS:                    // 372\n\t\tcase EID_FILTER_RULES_APP_SIG_GROUP_ID:   // 374\n\t\tcase EID_FILTER_RULES_APP_SIG_DISP_ID:    // 375\n\t\tcase EID_APPL_STATS_REQ:                  // 377\n\t\tcase EID_PKT_CAPTURE_STATUS:              // 389\n\t\tcase EID_PKT_CAPTURE_FILTERS:             // 390\n\t\tcase EID_PKT_F_FLAGS:                     // 395\n\t\tcase EID_PKT_F_PROTOCOL:                  // 398\n\t\tcase EID_PKT_F_PORT:                      // 399\n\t\tcase EID_MU_AUTH_TYPE:                    // 401\n\t\tcase EID_PKT_F_MAX_PKT_COUNT:             // 402\n\t\tcase EID_PKT_F_FLAG_2:                    // 403\n\t\tcase EID_IMAGE_PORT:                      // 404\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_int, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\toffset += length;\n\t\t\tbreak;\n\t\t/* display as Mac address */\n\t\tcase EID_BP_BPSSID:                 // 34\n\t\tcase EID_BP_WIRED_MACADDR:          // 35\n\t\tcase EID_SIAPP_MACADDR:             // 149\n\t\tcase EID_SIAPP_AC_MGMT_MAC:         // 156\n\t\tcase EID_MAC_ADDR:                  // 208\n\t\tcase EID_SCAN_BSSID:                // 233\n\t\tcase EID_MU_BSSID:                  // 276\n\t\tcase EID_MAC_ADDR_TX:               // 320\n\t\tcase EID_MAC_ADDR_RX:               // 321\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_macaddr, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\toffset += length;\n\t\t\tbreak;\n\t\tcase EID_MU_MAC:                    // 48\n\t\tcase EID_PKT_F_MAC:                 // 397\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_mu_mac, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\toffset += length;\n\t\t\tbreak;\n\n\t\t/*  call sub tlv  */\n\t\tcase EID_EVENT_BLOCK:                                // 59\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, EVENT_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_AP_STATS_BLOCK:                             // 65\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, AP_STATS_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_MU_RF_STATS_BLOCK:                          // 66\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, MU_RF_STATS_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_TLV_CONFIG:                                 // 69\n\t\tcase EID_BSSID2IP_BLOCK:                             // 92\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, CONFIG_GLOBAL_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_CONFIG_ERROR_BLOCK:                         // 70\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, CONFIG_ERROR_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_CONFIG_MODIFIED_BLOCK:                      // 71\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_CONFIG_MODIFIED, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_BULK_MU_BLOCK:                              // 78\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, BULK_MU_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_MU_BLOCK:                                   // 79\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, MU_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_BULK_VNS_BLOCK:                             // 86\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, BULK_VNS_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_VNS_BLOCK:                                  // 87\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, VNS_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SIAPP_PMK_BLOCK:                            // 114\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_SIAPP_PMK_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SIAPP_RADIO_CONFIG_BLOCK:                   // 121\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_SIAPP_RADIO_CONFIG_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SIAPP_SIAPP_MU_STATS_BLOCK:                 // 123\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_SIAPP_MU_STATS_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SIAPP_THIN_BLOCK:                           // 128\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_SIAPP_THIN_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SIAPP_RADIOBLOCK:                           // 132\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_SIAPP_MU_STATS_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SIAPP_BLOCK:                                // 134\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_SIAPP_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SIAPP_LOADBAL_BLOCK:                        // 152\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, VNS_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SSS_MU_BLOCK:                               // 181\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_SSS_MU_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_ASSOC_SSID_ARRAY:                           // 204\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_ASSOC_SSID_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_ASSOC_SSID_BLOCK:                           // 205\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_ASSOC_SSID_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_AP_LIST_BLOCK:                              // 206\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_AP_LIST_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_AP_LIST_ARRAY:                              // 207\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_AP_LIST_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SCAN_PROFILE_BLOCK:                         // 214\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_SCAN_PROFILE_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_THREAT_DEF_ARRAY:                           // 216\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_THREAT_DEF_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_THREAT_DEF_BLOCK:                           // 217\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_THREAT_DEF_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_THREAT_PATTERN_ARRAY:                       // 222\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_THREAT_PATTERN_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_THREAT_PATTERN_BLOCK:                       // 223\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_THREAT_PATTERN_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SURVEILLANCE_DATA_ARRAY:                    // 231\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_SURVEILLANCE_DATA_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SURVEILLANCE_DATA_BLOCK:                    // 232\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_SURVEILLANCE_DATA_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_THREAT_DATA_ARRAY:                          // 239\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_THREAT_DATA_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_THREAT_DATA_BLOCK:                          // 240\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_THREAT_DATA_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_THREAT_CLASSIFY_ARRAY:                      // 245\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_THREAT_CLASSIFY_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_THREAT_CLASSIFY_BLOCK:                      // 246\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_THREAT_CLASSIFY_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_MU_EVENT_ARRAY:                             // 251\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_MU_EVENT_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_MU_EVENT_BLOCK:                             // 252\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_MU_EVENT_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_COUNTRY_ARRAY:                              // 258\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_COUNTRY_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_COUNTRY_BLOCK:                              // 259\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_COUNTRY_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_LOCATOR_LOC_BLOCK:                          // 263\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_LOCATOR_LOC_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_LOCATOR_LOC_ARRAY:                          // 264\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_LOCATOR_LOC_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_RSS_DATA_ARRAY:                             // 271\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_RSS_DATA_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_RSS_DATA_BLOCK:                             // 272\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_RSS_DATA_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_MCAST_FILTER_BLOCK:                         // 282\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_MCAST_FILTER_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_MCAST_FILTER_BLOCK_ENTRY:                   // 283\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_MCAST_FILTER_BLOCK_ENTRY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_MU_SESSION_ARRAY:                           // 293\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_MU_SESSION_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_MU_SESSION_BLOCK:                           // 294\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_MU_SESSION_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_DETECTED_ROGUE_ARRAY:                       // 317\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_DETECTED_ROGUE_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_DETECTED_ROGUE_BLOCK:                       // 318\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_DETECTED_ROGUE_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_FILTER_RULES_EXT_BLOCK:                     // 329\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_FILTER_RULES_EXT_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_TOPOLOGY_ARRAY:                             // 379\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_TOPOLOGY_ARRAY_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_TOPOLOGY_STRUCT:                            // 380\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_TOPOLOGY_STRUCT_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_FILTER_CONFIG_STRUCT:                       // 381\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_FILTER_CONFIG_STRUCT_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\n\t\tcase EID_FILTER_RULES:                              // 97\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_octext, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\tdecode_filter_rule_octext_string(tlv_tree, tvb, offset + 4, length );\n\t\t\toffset += length;\n\t\t\tbreak;\n\t\tcase EID_MU_MAC_LIST:                              // 100\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_octext, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\tdecode_mac_list_struct(tlv_tree, tvb, offset + 4,  length -4 );\n\t\t\toffset += length;\n\t\t\tbreak;\n\t\tcase EID_COS:                                      // 158\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_octext, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\tdecode_cos_struct(tlv_tree, tvb, offset + 4 );\n\t\t\toffset += length;\n\t\t\tbreak;\n\t\tcase EID_RATE_LIMIT_RESOURCE_TBL:                  // 159\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_octext, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\tdecode_rate_limit_struct(tlv_tree,tvb,  offset + 4,length-4 );\n\t\t\toffset += length;\n\t\t\tbreak;\n\t\tcase EID_CHANNEL_LIST:                             // 211\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_octext, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\tdecode_Channel_list(tlv_tree, tvb, offset + 4,  length -4 );\n\t\t\toffset += length;\n\t\t\tbreak;\n\t\tcase EID_DNS_IP_ADDR:                              // 333\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_octext, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\tdecode_ipv4_list_struct(tlv_tree, tvb, offset + 4,  length -4 );\n\t\t\toffset += length;\n\t\t\tbreak;\n\t\tcase EID_MU_APPL_STATS_BLOCK:                      // 378\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_octext, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\tdecode_mu_appl_stats_block(tlv_tree, tvb, offset + 4 );\n\t\t\toffset += length;\n\t\t\tbreak;\n\n\t\tcase EID_SCAN_RSS_RSSI:                            // 236\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_int, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\tsuboffset = offset + 4;\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_rss, tvb, suboffset, 2, ENC_BIG_ENDIAN);\n\t\t\tsuboffset += 2;\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_rssi, tvb, suboffset, 2, ENC_BIG_ENDIAN);\n\t\t\toffset += length;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* If tlv isn't in the list, then just display the raw data*/\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_octext, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\tcall_dissector(data_handle, tvb_new_subset_length_caplen(tvb, offset + TLV_VALUE, -1, length - 4), pinfo, wassp_tree);\n\t\t\toffset += length;\n\t\t}\n\n\t\tif (tlv_type == EID_UNUSED_0)\n\t\t{\n\t\t\tproto_tree_add_item(wassp_tree, hf_wassp_tlv_invalid, tvb, offset, value, ENC_BIG_ENDIAN);\n\t\t\toffset += length;\n\t\t}\n\t}\n\treturn offset;\n}",
        "func": "int dissect_wassp_tlv(proto_tree *wassp_tree, tvbuff_t *tvb, packet_info *pinfo, int offset, wassp_ru_msg_t rumsg_type)\n{\n\tproto_item *tlvi = NULL;\n\tproto_tree *tlv_tree;\n\tguint16 tlv_type = WASSP_RU_UNUSED_0;\n\tguint16 length;\n\tguint32 value;\n\tint suboffset;\n\twassp_ru_msg_t ru_msg_type = rumsg_type;\n\tconst char *label;\n\n\n\n\tSET_WASSP_TLV_VERSION(0);\n\twhile ((value = tvb_reported_length_remaining(tvb, offset)) >= 4)\n\t{\n\t\ttlv_type = tvb_get_ntohs(tvb, offset + TLV_TYPE);\n\t\tlength = tvb_get_ntohs(tvb, offset + TLV_LENGTH);\n\t\tlabel = try_val_to_str(tlv_type, wassp_tlv_types);\n\t\tlabel = (label == NULL) ? \"Unknown Type\" : label;\n\n\t\tif (length > value)\n\t\t{\n\t\t\ttlvi = proto_tree_add_item(wassp_tree, hf_wassp_tlv_invalid, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\ttlv_type = EID_UNUSED_0;\n\t\t}\n\t\telse if (length < 4)\n\t\t{\n\t\t\ttlvi = proto_tree_add_item(wassp_tree, hf_wassp_tlv_invalid, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\ttlv_type = EID_UNUSED_0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttlvi = proto_tree_add_item(wassp_tree, hf_wassp_tlv_value, tvb, offset, length, ENC_NA);\n\t\t\tproto_item_append_text(tlvi, \" : %s (%d)\", label, tlv_type);\n\n\t\t}\n\n\t\ttlv_tree = proto_item_add_subtree(tlvi, ett_wassp_tlv);\n\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_type_main, tvb, offset + TLV_TYPE, 2, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_length, tvb, offset + TLV_LENGTH, 2, ENC_BIG_ENDIAN);\n\n\t\tswitch (tlv_type)\n\t\t{\n\t\tcase EID_UNUSED_0:                  // 0\n\t\t\toffset += 4;\n\t\t\tbreak;\n\n\t\tcase EID_STATUS:                    // 1\n\t\t\tru_msg_type = (wassp_ru_msg_t) tvb_get_guint8(tvb, WASSP_HDR_TYPE);\n\n\t\t\t/*this is an action TLV*/\n\t\t\tif (WASSP_RU_SW_Version_Validate_Rsp == ru_msg_type)\n\t\t\t{\n\t\t\t\tproto_item_append_text(tlvi, \" (upgrade action)\");\n\t\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_eid_action, tvb, offset + TLV_VALUE, length - 4, ENC_BIG_ENDIAN);\n\t\t\t}\n\t\t\telse  /*assume status TLV*/\n\t\t\t{\n\t\t\t\tproto_item_append_text(tlvi, \" (status)\");\n\t\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_eid_status, tvb, offset + TLV_VALUE, length - 4, ENC_BIG_ENDIAN);\n\t\t\t}\n\t\t\toffset += length;\n\t\t\tbreak;\n\n\t\t/* display as string */\n\t\tcase EID_RU_SW_VERSION:                       // 2\n\t\tcase EID_RU_SERIAL_NUMBER:                    // 3\n\t\tcase EID_IMAGE_PATH:                          // 9\n\t\tcase EID_RANDOM_NUMBER:                       // 14\n\t\tcase EID_RU_MODEL:                            // 17\n\t\tcase EID_RU_TRAP:                             // 24\n\t\tcase EID_RU_SSID_NAME:                        // 37\n\t\tcase EID_AC_REG_CHALLENGE:                    // 41\n\t\tcase EID_AC_REG_RESPONSE:                     // 42\n\t\tcase EID_STATS:                               // 43\n\t\tcase EID_CERTIFICATE:                         // 44\n\t\tcase EID_RADIO_INFO:                          // 51\n\t\tcase EID_NETWORK_INFO:                        // 52\n\t\tcase EID_PRODUCT_ID:                          // 54\n\t\tcase EID_RADIO_INFO_ACK:                      // 55\n\t\tcase EID_SSID:                                // 58\n\t\tcase EID_MU_PMKID_LIST:                       // 72\n\t\tcase EID_MU_PMK_BP:                           // 73\n\t\tcase EID_MU_PMKID_BP:                         // 74\n\t\tcase EID_LOG_FILE:                            // 83\n\t\tcase EID_ALARM_DESCRIPTION:                   // 85\n\t\tcase EID_RU_BACKUP_VERSION:                   // 93\n\t\tcase EID_AC_SW_VERSION:                       // 94\n\t\tcase EID_MCAST_LAMG_LIST:                     // 95\n\t\tcase EID_FILTER_NAME:                         // 96\n\t\tcase EID_SENSOR_IMG_VERSION:                  // 104\n\t\tcase EID_RATECTRL_NAME_UL:                    // 111\n\t\tcase EID_RATECTRL_NAME_DL:                    // 112\n\t\tcase EID_POLICY_NAME:                         // 113\n\t\tcase EID_SIAPP_AP_NAME:                       // 120\n\t\tcase EID_SIAPP_USER_IDENTITY:                 // 151\n\t\tcase EID_MU_FILTER_POLICY_NAME:               // 162\n\t\tcase EID_MU_TOPOLOGY_POLICY_NAME:             // 163\n\t\tcase EID_MU_COS_POLICY_NAME:                  // 164\n\t\tcase EID_SITE_NAME:                           // 175\n\t\tcase EID_SSS_SSID:                            // 191\n\t\tcase EID_POLICY_ZONE_NAME:                    // 193\n\t\tcase EID_MU_USER_NAME:                        // 196\n\t\tcase EID_SCAN_SSID:                           // 237\n\t\tcase EID_THREAT_NAME:                         // 248\n\t\tcase EID_LOCATION:                            // 249\n\t\tcase EID_MU_EVENT_STRING:                     // 254\n\t\tcase EID_LOCATOR_FLOOR_NAME:                  // 288\n\t\tcase EID_MU_RFS_NAME:                         // 296\n\t\tcase EID_MU_URL:                              // 301\n\t\tcase EID_MU_ACCT_SESSION_ID_STRING:           // 304\n\t\tcase EID_MU_ACCT_POLICY_NAME:                 // 305\n\t\tcase EID_MU_TUNNEL_PRIVATE_GROUP_ID_STRING:   // 309\n\t\tcase EID_MU_USER_ID_STRING:                   // 310\n\t\tcase EID_MU_LOCATION:                         // 331\n\t\tcase EID_AREA_NAME:                           // 335\n\t\tcase EID_CUI:                                 // 363\n\t\tcase EID_WFA_HS20_URL:                        // 368\n\t\tcase EID_DHCP_HOST_NAME:                      // 382\n\t\tcase EID_MU_ECP_PW:                           // 385\n\t\tcase EID_MU_ECP_TOKEN:                        // 386\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_string, tvb, offset + TLV_VALUE, length - 4, ENC_ASCII|ENC_NA);\n\t\t\toffset += length;\n\t\t\tbreak;\n\n\t\t/* display as octext string */\n\t\tcase EID_RU_REG_CHALLENGE:                      // 4\n\t\tcase EID_RU_REG_RESPONSE:                       // 5\n\t\tcase EID_RU_VNSID:                              // 7\n\t\tcase EID_SESSION_KEY:                           // 12\n\t\tcase EID_RU_PREAUTH:                            // 39\n\t\tcase EID_RU_PMK:                                // 40\n\t\tcase EID_SIAPP_PMKID:                           // 115\n\t\tcase EID_SIAPP_PMK_REAUTH:                      // 116\n\t\tcase EID_SIAPP_PMK_LIFETIME:                    // 117\n\t\tcase EID_SIAPP_PMKID_FLAG:                      // 118\n\t\tcase EID_SIAPP_MU_PMK:                          // 119\n\t\tcase EID_SIAPP_CLUSTER_ACS_REQ:                 // 122\n\t\tcase EID_SIAPP_PACKET_RETRIES:                  // 124\n\t\tcase EID_SIAPP_ASSOC_IN_WLAN:                   // 125\n\t\tcase EID_SIAPP_ASSOC_IN_CLUSTER:                // 126\n\t\tcase EID_SIAPP_REASSOC_IN_CLUSTER:              // 127\n\t\tcase EID_SIAPP_NEWAP_BSSID:                     // 129\n\t\tcase EID_SIAPP_OLDAP_BSSID:                     // 130\n\t\tcase EID_SIAPP_RAD_CACS_REQ:                    // 131\n\t\tcase EID_SIAPP_CLIENT_COUNT:                    // 133\n\t\tcase EID_SIAPP_MU_TransmittedFrameCount:        // 135\n\t\tcase EID_SIAPP_MU_ReceivedFrameCount:           // 136\n\t\tcase EID_SIAPP_MU_TransmittedBytes:             // 137\n\t\tcase EID_SIAPP_MU_ReceivedBytes:                // 138\n\t\tcase EID_SIAPP_MU_UL_DroppedRateControlPackets: // 139\n\t\tcase EID_SIAPP_MU_DL_DroppedRateControlPackets: // 140\n\t\tcase EID_SIAPP_MU_DL_DroppedBufferFullPackets:  // 141\n\t\tcase EID_SIAPP_MU_DL_LostRetriesPackets:        // 142\n\t\tcase EID_SIAPP_MU_UL_DroppedRateControlBytes:   // 143\n\t\tcase EID_SIAPP_MU_DL_DroppedRateControlBytes:   // 144\n\t\tcase EID_SIAPP_MU_DL_DroppedBufferFullBytes:    // 145\n\t\tcase EID_SIAPP_MU_DL_LostRetriesBytes:          // 146\n\t\tcase EID_SIAPP_BP_BSSID:                        // 147\n\t\tcase EID_SIAPP_RADIO_ID:                        // 148\n\t\tcase EID_SIAPP_PREAUTH_REQ:                     // 150\n\t\tcase EID_SIAPP_LOADBAL_LOADGROUP_ID:            // 154\n\t\tcase EID_MU_ACCOUNTING_CLASS:                   // 169\n\t\tcase EID_SSS_TS64_MU_UPDATE:                    // 183\n\t\tcase EID_SSS_TS64_AP_CURRENT:                   // 184\n\t\tcase EID_SSS_AP_HOMEHASH:                       // 186\n\t\tcase EID_EVENT_ARRAY:                           // 189\n\t\tcase EID_INFORM_MU_PMK:                         // 199\n\t\tcase EID_ARP_PROXY:                             // 201\n\t\tcase EID_MCAST_FILTER_RULES:                    // 202\n\t\tcase EID_AP_PARAMS:                             // 203\n\t\tcase EID_THREAT_STATS_F:                        // 220\n\t\tcase EID_THREAT_PATTERN:                        // 224\n\t\tcase EID_LOCATOR_LOC_POINT:                     // 265\n\t\tcase EID_MU_EVENT_DETAILS:                      // 266\n\t\tcase EID_MU_EVENT_LOC_BLOCK:                    // 268\n\t\tcase EID_AP_REDIRECT:                           // 291\n\t\tcase EID_MU_CVLAN_BAP:                          // 292\n\t\tcase EID_MU_SESSION_ID:                         // 295\n\t\tcase EID_MU_FLAGS:                              // 297\n\t\tcase EID_MU_ASSOC_TIME:                         // 298\n\t\tcase EID_MU_ACTIVE_TIME:                        // 299\n\t\tcase EID_REPORT_REQ:                            // 300\n\t\tcase EID_MU_SESSION_LIFETIME:                   // 302\n\t\tcase EID_MU_REAUTH_TIMER:                       // 303\n\t\tcase EID_MU_ACCT_START_TIME:                    // 306\n\t\tcase EID_MU_ACCT_CLASS:                         // 307\n\t\tcase EID_MU_LOGIN_LAT_GROUP:                    // 308\n\t\tcase EID_MU_DEFENDED_STATE:                     // 311\n\t\tcase EID_MU_MOD_MASK:                           // 312\n\t\tcase EID_LOCATOR_TRACKED:                       // 313\n\t\tcase EID_PORT:                                  // 314\n\t\tcase EID_RETRIES_COUNT:                         // 315\n\t\tcase EID_MODULATION_TYPE:                       // 316\n\t\tcase EID_ROGUE_DETECTION:                       // 319\n\t\tcase EID_TTL:                                   // 324\n\t\tcase EID_LOCATOR_STATE_DATA:                    // 326\n\t\tcase EID_LOCATOR_POINT_SET:                     // 327\n\t\tcase EID_FILTER_RULE_FIXED_APP_ID:              // 328\n\t\tcase EID_MU_AREA_BLOCK:                         // 330\n\t\tcase EID_IN_SERVICE_AP_LIST:                    // 334\n\t\tcase EID_OUT_SERVICE_AP_LIST:                   // 335\n\t\tcase EID_LAST_RD_AP:                            // 336\n\t\tcase EID_ROGUE_INFO:                            // 337\n\t\tcase EID_MU_PMK_R1:                             // 339\n\t\tcase EID_SIAPP_R0KHID:                          // 340\n\t\tcase EID_SIAPP_R1KHID:                          // 341\n\t\tcase EID_SIAPP_FT_NONCE:                        // 342\n\t\tcase EID_SIAPP_FT_PMKR0NAME:                    // 343\n\t\tcase EID_SIAPP_FT_R1KHID:                       // 344\n\t\tcase EID_SIAPP_FT_S1KHID:                       // 345\n\t\tcase EID_SIAPP_FT_PMKR1:                        // 346\n\t\tcase EID_SIAPP_FT_PMKR1NAME:                    // 347\n\t\tcase EID_SIAPP_FT_PAIRWISE:                     // 348\n\t\tcase EID_SIAPP_FT_LIFETIME:                     // 349\n\t\tcase EID_MU_POWER_CAP:                          // 350\n\t\tcase EID_PERIODIC_NEIGHBOUR_REPORT:             // 352\n\t\tcase EID_NEIGHBOUR_ENTRY:                       // 354\n\t\tcase EID_MU_PMK_R0NAME:                         // 362\n\t\tcase EID_IPV6_ADDR:                             // 373\n\t\tcase EID_MU_DEV_IDENTITY:                       // 376\n\t\tcase EID_NEIGHBOUR_ENTRY_2:                     // 383\n\t\tcase EID_CHANNEL_ENTRY:                         // 384\n\t\tcase EID_PKT_F_WIRELESS:                        // 391\n\t\tcase EID_PKT_F_WIREDCLIENT:                     // 392\n\t\tcase EID_PKT_F_DIRECTION:                       // 393\n\t\tcase EID_PKT_F_IP_ARRAY:                        // 396\n\t\tcase EID_PKT_F_RADIO:                           // 394\n\t\tcase EID_VSA_SSID_ID:                           // 400\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_octext, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\toffset += length;\n\t\t\tbreak;\n\n\t\t/* display as IP address format */\n\t\tcase EID_AC_IPADDR:                    // 6\n\t\tcase EID_TFTP_SERVER:                  // 8\n\t\tcase EID_STATIC_BP_IPADDR:             // 30\n\t\tcase EID_STATIC_BP_NETMASK:            // 31\n\t\tcase EID_STATIC_BP_GATEWAY:            // 32\n\t\tcase EID_STATIC_BM_IPADDR:             // 33\n\t\tcase EID_AP_IPADDR:                    // 89\n\t\tcase EID_AP_NETMASK:                   // 90\n\t\tcase EID_AP_GATEWAY:                   // 91\n\t\tcase EID_MU_IP_ADDR:                   // 173\n\t\tcase EID_PEER_SITE_IP:                 // 176\n\t\tcase EID_COLLECTOR_IP_ADDR:            // 200\n\t\tcase EID_IP_ADDR_TX:                   // 322\n\t\tcase EID_IP_ADDR_RX:                   // 323\n\t\tcase EID_GW_IP_ADDR:                   // 325\n\t\tcase EID_STATIC_VSA_IPADDR:            // 387\n\t\tcase EID_STATIC_VSA_NETMASK:           // 388\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_ip, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\toffset += length;\n\t\t\tbreak;\n\n\t\tcase EID_CONFIG:                       // 10\n\t\tcase EID_ALARM:                        // 38\n\t\t\t/* Dissect SNMP encoded configuration */\n\t\t\tdissector_try_uint(wassp_dissector_table, WASSP_SNMP, tvb_new_subset_length_caplen(tvb, offset + TLV_VALUE, -1, length - 4), pinfo, tlv_tree);\n\t\t\toffset += length;\n\t\t\tbreak;\n\n\t\tcase EID_RU_STATE:                     // 11\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_eid_rustate, tvb, offset + TLV_VALUE, length - 4, ENC_BIG_ENDIAN);\n\t\t\tproto_item_append_text(tlvi, \": %s\",\n\t\t\t\t\t       (tvb_get_guint8(tvb, offset + TLV_VALUE) ?\n\t\t\t\t\t\twassp_eid_rustate_types.true_string :\n\t\t\t\t\t\twassp_eid_rustate_types.false_string));\n\t\t\toffset += length;\n\t\t\tbreak;\n\n\t\t/* display as int */\n\t\tcase EID_RU_PROTOCOL:                     // 13\n\t\tcase EID_STANDBY_TIMEOUT:                 // 15\n\t\tcase EID_RU_CHALLENGE_ID:                 // 16\n\t\tcase EID_RU_SCAN_MODE:                    // 18\n\t\tcase EID_RU_SCAN_TYPE:                    // 19\n\t\tcase EID_RU_SCAN_INTERVAL:                // 20\n\t\tcase EID_RU_RADIO_TYPE:                   // 21\n\t\tcase EID_RU_CHANNEL_DWELL_TIME:           // 22\n\t\tcase EID_RU_CHANNEL_LIST:                 // 23\n\t\tcase EID_RU_SCAN_TIMES:                   // 25\n\t\tcase EID_RU_SCAN_DELAY:                   // 26\n\t\tcase EID_RU_SCAN_REQ_ID:                  // 27\n\t\tcase EID_STATIC_CONFIG:                   // 28\n\t\tcase EID_LOCAL_BRIDGING:                  // 29\n\t\tcase EID_RU_CAPABILITY:                   // 36\n\t\tcase EID_RADIO_ID:                        // 45\n\t\tcase EID_REQ_ID:                          // 46\n\t\tcase EID_NETWORK_ID:                      // 47\n\t\tcase EID_TIME:                            // 49\n\t\tcase EID_NUM_RADIOS:                      // 50\n\t\tcase EID_VENDOR_ID:                       // 53\n\t\tcase EID_SECURE_TUNNEL:                   // 56\n\t\tcase EID_MU_TOPOLOGY_ID:                  // 57\n\t\tcase EID_SNMP_ERROR_STATUS:               // 60\n\t\tcase EID_SNMP_ERROR_INDEX:                // 61\n\t\tcase EID_RU_REAUTH_TIMER:                 // 62\n\t\tcase EID_AP_IMG_TO_RAM:                   // 63\n\t\tcase EID_AP_IMG_ROLE:                     // 64\n\t\tcase EID_STATS_REQUEST_TYPE:              // 67\n\t\tcase EID_STATS_LAST:                      // 68\n\t\tcase EID_COUNTDOWN_TIME:                  // 75\n\t\tcase EID_WASSP_VLAN_TAG:                  // 76\n\t\tcase EID_SSID_ID:                         // 77\n\t\tcase EID_PORT_OPEN_FLAG:                  // 80\n\t\tcase EID_WASSP_TUNNEL_TYPE:               // 81\n\t\tcase EID_LOG_TYPE:                        // 82\n\t\tcase EID_ALARM_SEVERITY:                  // 84\n\t\tcase EID_AP_DHCP_MODE:                    // 88\n\t\tcase EID_AUTH_STATE:                      // 98\n\t\tcase EID_MU_DISC_AFTER_AUTH:              // 99\n\t\tcase EID_TRANS_ID:                        // 101\n\t\tcase EID_TIMEZONE_OFFSET:                 // 102\n\t\tcase EID_SENSOR_FORCE_DOWNLOAD:           // 103\n\t\tcase EID_BRIDGE_MODE:                     // 105\n\t\tcase EID_MU_VLAN_TAG:                     // 106\n\t\tcase EID_RATECTRL_CIR_UL:                 // 107\n\t\tcase EID_RATECTRL_CIR_DL:                 // 108\n\t\tcase EID_RATECTRL_CBS_UL:                 // 109\n\t\tcase EID_RATECTRL_CBS_DL:                 // 110\n\t\tcase EID_SIAPP_LOADBAL_PKT_TYPE:          // 153\n\t\tcase EID_SIAPP_LOADBAL_LOAD_VALUE:        // 155\n\t\tcase EID_SIAPP_FILTER_COS:                // 157\n\t\tcase EID_UCAST_FILTER_DISABLE:            // 160\n\t\tcase EID_MU_INFORM_REASON:                // 161\n\t\tcase EID_MU_FILTER_KEY:                   // 165\n\t\tcase EID_MU_TOPOLOGY_KEY:                 // 166\n\t\tcase EID_MU_COS_KEY:                      // 167\n\t\tcase EID_MU_SESSION_TIMEOUT:              // 168\n\t\tcase EID_MU_LOGIN_LAT_PORT:               // 170\n\t\tcase EID_MU_IDLE_TIMEOUT:                 // 171\n\t\tcase EID_MU_ACCT_INTERIM_INTERVAL:        // 172\n\t\tcase EID_MU_TERMINATE_ACTION:             // 174\n\t\tcase EID_INTERFERENCE_EVENTS_ENABLE:      // 177\n\t\tcase EID_EVENT_TYPE:                      // 178\n\t\tcase EID_EVENT_CHANNEL:                   // 179\n\t\tcase EID_EVENT_VALUE:                     // 180\n\t\tcase EID_SSS_MU_ASSOC_TIME:               // 182\n\t\tcase EID_SSS_MU_AUTH_STATE:               // 185\n\t\tcase EID_TIME_FIRST_DETECTED:             // 187\n\t\tcase EID_TIME_LAST_REPORTED:              // 188\n\t\tcase EID_SSS_DEFAULT_SESSION_TIMEOUT:     // 190\n\t\tcase EID_SSS_PRIVACY_TYPE:                // 192\n\t\tcase EID_RU_AC_EVENT_COMPONENT_ID:        // 194\n\t\tcase EID_MU_AUTH_STATE:                   // 195\n\t\tcase EID_BULK_TYPE:                       // 197\n\t\tcase EID_SENT_TIME:                       // 198\n\t\tcase EID_SCAN_PROFILE_ID:                 // 209\n\t\tcase EID_ACTION_REQ:                      // 210\n\t\tcase EID_COUNTERMEASURES_MAX_CH:          // 212\n\t\tcase EID_COUNTERMEASURES_SET:             // 213\n\t\tcase EID_SEQ_NUM:                         // 215\n\t\tcase EID_THREAT_TYPE:                     // 218\n\t\tcase EID_THREAT_ID:                       // 219\n\t\tcase EID_THREAT_FR_SFR:                   // 221\n\t\tcase EID_THREAT_ALERT_TH_DUR:             // 225\n\t\tcase EID_THREAT_CLEAR_TH_DUR:             // 226\n\t\tcase EID_THREAT_PRIORITY:                 // 227\n\t\tcase EID_THREAT_MITIGATION_LIST:          // 228\n\t\tcase EID_PARAMS:                          // 235\n\t\tcase EID_MU_EVENT_TYPE:                   // 260\n\t\tcase EID_SSS_MU_IS_PORT_CLOSED:           // 229\n\t\tcase EID_FULL_UPDATE:                     // 230\n\t\tcase EID_REASON:                          // 231\n\t\tcase EID_SCAN_CAP:                        // 238\n\t\tcase EID_THREAT_CLASSIFICATION:           // 239\n\t\tcase EID_STATE:                           // 242\n\t\tcase EID_DROP_FR_CNT:                     // 243\n\t\tcase EID_STOP_ROAM_CNT:                   // 244\n\t\tcase EID_SPOOF_CNT:                       // 245\n\t\tcase EID_ENCRYPTION_TYPE:                 // 250\n\t\tcase EID_COMPONENT_ID:                    // 253\n\t\tcase EID_BYPASS_BMCAST:                   // 255\n\t\tcase EID_GETTIMEOFDAY:                    // 256\n\t\tcase EID_COUNTRY_ID:                      // 257\n\t\tcase EID_LOCATOR_FLOOR_ID:                // 261\n\t\tcase EID_LOCATOR_LOC_TYPE:                // 262\n\t\tcase EID_MU_EVENT_FROM_AP:                // 267\n\t\tcase EID_LOCATOR_LOC_AP_DISTANCE:         // 269\n\t\tcase EID_LOCATOR_LOC_PRECISION:           // 270\n\t\tcase EID_LOCATOR_MU_ACTION:               // 273\n\t\tcase EID_EFFECTIVE_EGRESS_VLAN:           // 274\n\t\tcase EID_REBOOT_ACK:                      // 275\n\t\tcase EID_AUTH_FLAG:                       // 277\n\t\tcase EID_ROAMED_FLAG:                     // 278\n\t\tcase EID_MU_RSS:                          // 279\n\t\tcase EID_FILTER_RULES_VER:                // 280\n\t\tcase EID_FILTER_TYPE:                     // 281\n\t\tcase EID_DEFAULT_ACTION_TYPE:             // 284\n\t\tcase EID_DEFAULT_CONTAIN_TO_VLAN:         // 285\n\t\tcase EID_DEFAULT_BRIDGE_MODE:             // 286\n\t\tcase EID_INVALID_POLICY:                  // 287\n\t\tcase EID_AP_FLAGS:                        // 289\n\t\tcase EID_AP_PVID:                         // 290\n\t\tcase EID_MU_LOCATION_TS:                  // 332\n\t\tcase EID_MU_IS_FT:                        // 338\n\t\tcase EID_TIMESTAMP:                       // 353\n\t\tcase EID_MU_REQ:                          // 355\n\t\tcase EID_RU_REQ:                          // 356\n\t\tcase EID_NEIGHBOUR_REQ:                   // 357\n\t\tcase EID_SSS_FT_ASSOC:                    // 358\n\t\tcase EID_DEFAULT_MIRRORN:                 // 359\n\t\tcase EID_FILTER_RULE_EXT_ACT_FLAGS:       // 360\n\t\tcase EID_TOPO_GROUP_MAPPING:              // 361\n\t\tcase EID_SSS_CAPINFO:                     // 364\n\t\tcase EID_SSS_CAPPOWER:                    // 365\n\t\tcase EID_WFA_VSA:                         // 366\n\t\tcase EID_WFA_HS20_REMED_METHOD:           // 367\n\t\tcase EID_WFA_HS20_DEAUTH_CODE:            // 369\n\t\tcase EID_WFA_HS20_REAUTH_DELAY:           // 370\n\t\tcase EID_WFA_HS20_SWT:                    // 371\n\t\tcase EID_POWER_STATUS:                    // 372\n\t\tcase EID_FILTER_RULES_APP_SIG_GROUP_ID:   // 374\n\t\tcase EID_FILTER_RULES_APP_SIG_DISP_ID:    // 375\n\t\tcase EID_APPL_STATS_REQ:                  // 377\n\t\tcase EID_PKT_CAPTURE_STATUS:              // 389\n\t\tcase EID_PKT_CAPTURE_FILTERS:             // 390\n\t\tcase EID_PKT_F_FLAGS:                     // 395\n\t\tcase EID_PKT_F_PROTOCOL:                  // 398\n\t\tcase EID_PKT_F_PORT:                      // 399\n\t\tcase EID_MU_AUTH_TYPE:                    // 401\n\t\tcase EID_PKT_F_MAX_PKT_COUNT:             // 402\n\t\tcase EID_PKT_F_FLAG_2:                    // 403\n\t\tcase EID_IMAGE_PORT:                      // 404\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_int, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\toffset += length;\n\t\t\tbreak;\n\t\t/* display as Mac address */\n\t\tcase EID_BP_BPSSID:                 // 34\n\t\tcase EID_BP_WIRED_MACADDR:          // 35\n\t\tcase EID_SIAPP_MACADDR:             // 149\n\t\tcase EID_SIAPP_AC_MGMT_MAC:         // 156\n\t\tcase EID_MAC_ADDR:                  // 208\n\t\tcase EID_SCAN_BSSID:                // 233\n\t\tcase EID_MU_BSSID:                  // 276\n\t\tcase EID_MAC_ADDR_TX:               // 320\n\t\tcase EID_MAC_ADDR_RX:               // 321\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_macaddr, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\toffset += length;\n\t\t\tbreak;\n\t\tcase EID_MU_MAC:                    // 48\n\t\tcase EID_PKT_F_MAC:                 // 397\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_mu_mac, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\toffset += length;\n\t\t\tbreak;\n\n\t\t/*  call sub tlv  */\n\t\tcase EID_EVENT_BLOCK:                                // 59\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, EVENT_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_AP_STATS_BLOCK:                             // 65\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, AP_STATS_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_MU_RF_STATS_BLOCK:                          // 66\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, MU_RF_STATS_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_TLV_CONFIG:                                 // 69\n\t\tcase EID_BSSID2IP_BLOCK:                             // 92\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, CONFIG_GLOBAL_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_CONFIG_ERROR_BLOCK:                         // 70\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, CONFIG_ERROR_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_CONFIG_MODIFIED_BLOCK:                      // 71\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_CONFIG_MODIFIED, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_BULK_MU_BLOCK:                              // 78\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, BULK_MU_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_MU_BLOCK:                                   // 79\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, MU_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_BULK_VNS_BLOCK:                             // 86\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, BULK_VNS_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_VNS_BLOCK:                                  // 87\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, VNS_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SIAPP_PMK_BLOCK:                            // 114\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_SIAPP_PMK_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SIAPP_RADIO_CONFIG_BLOCK:                   // 121\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_SIAPP_RADIO_CONFIG_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SIAPP_SIAPP_MU_STATS_BLOCK:                 // 123\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_SIAPP_MU_STATS_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SIAPP_THIN_BLOCK:                           // 128\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_SIAPP_THIN_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SIAPP_RADIOBLOCK:                           // 132\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_SIAPP_MU_STATS_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SIAPP_BLOCK:                                // 134\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_SIAPP_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SIAPP_LOADBAL_BLOCK:                        // 152\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, VNS_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SSS_MU_BLOCK:                               // 181\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_SSS_MU_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_ASSOC_SSID_ARRAY:                           // 204\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_ASSOC_SSID_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_ASSOC_SSID_BLOCK:                           // 205\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_ASSOC_SSID_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_AP_LIST_BLOCK:                              // 206\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_AP_LIST_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_AP_LIST_ARRAY:                              // 207\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_AP_LIST_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SCAN_PROFILE_BLOCK:                         // 214\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_SCAN_PROFILE_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_THREAT_DEF_ARRAY:                           // 216\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_THREAT_DEF_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_THREAT_DEF_BLOCK:                           // 217\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_THREAT_DEF_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_THREAT_PATTERN_ARRAY:                       // 222\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_THREAT_PATTERN_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_THREAT_PATTERN_BLOCK:                       // 223\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_THREAT_PATTERN_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SURVEILLANCE_DATA_ARRAY:                    // 231\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_SURVEILLANCE_DATA_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_SURVEILLANCE_DATA_BLOCK:                    // 232\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_SURVEILLANCE_DATA_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_THREAT_DATA_ARRAY:                          // 239\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_THREAT_DATA_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_THREAT_DATA_BLOCK:                          // 240\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_THREAT_DATA_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_THREAT_CLASSIFY_ARRAY:                      // 245\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_THREAT_CLASSIFY_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_THREAT_CLASSIFY_BLOCK:                      // 246\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_THREAT_CLASSIFY_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_MU_EVENT_ARRAY:                             // 251\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_MU_EVENT_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_MU_EVENT_BLOCK:                             // 252\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_MU_EVENT_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_COUNTRY_ARRAY:                              // 258\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_COUNTRY_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_COUNTRY_BLOCK:                              // 259\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_COUNTRY_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_LOCATOR_LOC_BLOCK:                          // 263\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_LOCATOR_LOC_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_LOCATOR_LOC_ARRAY:                          // 264\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_LOCATOR_LOC_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_RSS_DATA_ARRAY:                             // 271\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_RSS_DATA_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_RSS_DATA_BLOCK:                             // 272\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_RSS_DATA_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_MCAST_FILTER_BLOCK:                         // 282\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_MCAST_FILTER_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_MCAST_FILTER_BLOCK_ENTRY:                   // 283\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_MCAST_FILTER_BLOCK_ENTRY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_MU_SESSION_ARRAY:                           // 293\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_MU_SESSION_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_MU_SESSION_BLOCK:                           // 294\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_MU_SESSION_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_DETECTED_ROGUE_ARRAY:                       // 317\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_DETECTED_ROGUE_ARRAY, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_DETECTED_ROGUE_BLOCK:                       // 318\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_DETECTED_ROGUE_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_FILTER_RULES_EXT_BLOCK:                     // 329\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_FILTER_RULES_EXT_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_TOPOLOGY_ARRAY:                             // 379\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_TOPOLOGY_ARRAY_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_TOPOLOGY_STRUCT:                            // 380\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_TOPOLOGY_STRUCT_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\t\tcase EID_FILTER_CONFIG_STRUCT:                       // 381\n\t\t\toffset = dissect_wassp_sub_tlv(tlv_tree, tvb, pinfo, offset + TLV_VALUE, length - TLV_VALUE, TAB_FILTER_CONFIG_STRUCT_BLOCK, ru_msg_type);\n\t\t\tbreak;\n\n\t\tcase EID_FILTER_RULES:                              // 97\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_octext, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\tdecode_filter_rule_octext_string(tlv_tree, tvb, offset + 4, length );\n\t\t\toffset += length;\n\t\t\tbreak;\n\t\tcase EID_MU_MAC_LIST:                              // 100\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_octext, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\tdecode_mac_list_struct(tlv_tree, tvb, offset + 4,  length -4 );\n\t\t\toffset += length;\n\t\t\tbreak;\n\t\tcase EID_COS:                                      // 158\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_octext, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\tdecode_cos_struct(tlv_tree, tvb, offset + 4 );\n\t\t\toffset += length;\n\t\t\tbreak;\n\t\tcase EID_RATE_LIMIT_RESOURCE_TBL:                  // 159\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_octext, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\tdecode_rate_limit_struct(tlv_tree,tvb,  offset + 4,length-4 );\n\t\t\toffset += length;\n\t\t\tbreak;\n\t\tcase EID_CHANNEL_LIST:                             // 211\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_octext, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\tdecode_Channel_list(tlv_tree, tvb, offset + 4,  length -4 );\n\t\t\toffset += length;\n\t\t\tbreak;\n\t\tcase EID_DNS_IP_ADDR:                              // 333\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_octext, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\tdecode_ipv4_list_struct(tlv_tree, tvb, offset + 4,  length -4 );\n\t\t\toffset += length;\n\t\t\tbreak;\n\t\tcase EID_MU_APPL_STATS_BLOCK:                      // 378\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_octext, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\tdecode_mu_appl_stats_block(tlv_tree, tvb, offset + 4 );\n\t\t\toffset += length;\n\t\t\tbreak;\n\n\t\tcase EID_SCAN_RSS_RSSI:                            // 236\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_int, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\tsuboffset = offset + 4;\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_rss, tvb, suboffset, 2, ENC_BIG_ENDIAN);\n\t\t\tsuboffset += 2;\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_rssi, tvb, suboffset, 2, ENC_BIG_ENDIAN);\n\t\t\toffset += length;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* If tlv isn't in the list, then just display the raw data*/\n\t\t\tproto_tree_add_item(tlv_tree, hf_wassp_tlv_value_octext, tvb, offset + TLV_VALUE, length - 4, ENC_NA);\n\t\t\tcall_dissector(data_handle, tvb_new_subset_length_caplen(tvb, offset + TLV_VALUE, -1, length - 4), pinfo, wassp_tree);\n\t\t\toffset += length;\n\t\t}\n\n\t\tif (tlv_type == EID_UNUSED_0)\n\t\t{\n\t\t\tproto_tree_add_item(wassp_tree, hf_wassp_tlv_invalid, tvb, offset, value, ENC_BIG_ENDIAN);\n\t\t\toffset += length;\n\t\t}\n\t}\n\treturn offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n \tguint32 value;\n \tint suboffset;\n \twassp_ru_msg_t ru_msg_type = rumsg_type;\n-\tchar *label;\n+\tconst char *label;\n \n \n \n@@ -16,7 +16,7 @@\n \t{\n \t\ttlv_type = tvb_get_ntohs(tvb, offset + TLV_TYPE);\n \t\tlength = tvb_get_ntohs(tvb, offset + TLV_LENGTH);\n-\t\tlabel = (char*)try_val_to_str(tlv_type, wassp_tlv_types);\n+\t\tlabel = try_val_to_str(tlv_type, wassp_tlv_types);\n \t\tlabel = (label == NULL) ? \"Unknown Type\" : label;\n \n \t\tif (length > value)",
        "diff_line_info": {
            "deleted_lines": [
                "\tchar *label;",
                "\t\tlabel = (char*)try_val_to_str(tlv_type, wassp_tlv_types);"
            ],
            "added_lines": [
                "\tconst char *label;",
                "\t\tlabel = try_val_to_str(tlv_type, wassp_tlv_types);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-8443",
        "func_name": "ossec/ossec-hids/OS_CleanMSG",
        "description": "In OSSEC-HIDS 2.7 through 3.5.0, the server component responsible for log analysis (ossec-analysisd) is vulnerable to an off-by-one heap-based buffer overflow during the cleaning of crafted syslog msgs (received from authenticated remote agents and delivered to the analysisd processing queue by ossec-remoted).",
        "git_url": "https://github.com/ossec/ossec-hids/commit/353ef15e4d3c5dfa8f1cc100651656cf7013c6a9",
        "commit_title": "analysisd: fix off-by-one in OS_CleanMSG.",
        "commit_text": " When removing the '[ID xx facility.severity]' substring of a syslog message in `OS_CleanMSG` care needs to be taken to stay within the bounds of the msg buffer when advancing past the `] ` in the msg.  Prev. to this commit the `pieces` pointer is incremented by 2 when there may be only 1 character remaining before the null terminator.",
        "func_before": "int OS_CleanMSG(char *msg, Eventinfo *lf)\n{\n    size_t loglen;\n    char *pieces;\n    struct tm *p;\n\n    /* The message is formatted in the following way:\n     * id:location:message.\n     */\n\n    /* Ignore the id of the message in here */\n    msg += 2;\n\n    /* Set pieces as the message */\n    pieces = strchr(msg, ':');\n    if (!pieces) {\n        merror(FORMAT_ERROR, ARGV0);\n        return (-1);\n    }\n\n    /* Is this from an agent? */\n    if ( *msg == '(' )\n    {   /* look past '->' for the first ':' */\n        pieces = strchr(strstr(msg, \"->\"), ':');\n        if(!pieces)\n        {\n            merror(FORMAT_ERROR, ARGV0);\n            return(-1);\n        }\n    }\n\n    *pieces = '\\0';\n    pieces++;\n\n    os_strdup(msg, lf->location);\n\n    /* Get the log length */\n    loglen = strlen(pieces) + 1;\n\n    /* Assign the values in the structure (lf->full_log) */\n    os_malloc((2 * loglen) + 1, lf->full_log);\n\n    /* Set the whole message at full_log */\n    strncpy(lf->full_log, pieces, loglen);\n\n    /* Log is the one used for parsing in the decoders and rules */\n    lf->log = lf->full_log + loglen;\n    strncpy(lf->log, pieces, loglen);\n\n    /* check if month contains an umlaut and repair\n     * umlauts are non-ASCII and use 2 slots in the char array\n     * repair to only one slot so we can detect the correct date format in the next step\n     * ex: Mr 02 17:30:52\n     */\n    if (pieces[1] == (char) 195) {\n        if (pieces[2] == (char) 164) {\n            pieces[0] = '\\0';\n            pieces[1] = 'M';\n            pieces[2] = 'a';\n            pieces++;\n        }\n    }\n\n    /* Check for the syslog date format\n     * ( ex: Dec 29 10:00:01\n     *   or  2015-04-16 21:51:02,805 for proftpd 1.3.5\n     *   or  2007-06-14T15:48:55-04:00 for syslog-ng isodate\n     *   or  2007-06-14T15:48:55.3352-04:00 for syslog-ng isodate with up to 6 optional fraction of a second\n     *   or  2009-05-22T09:36:46.214994-07:00 for rsyslog\n     *   or  2015 Dec 29 10:00:01 )\n     */\n    if (\n        (   /* ex: Dec 29 10:00:01 */\n            (loglen > 17) &&\n            (pieces[3] == ' ') &&\n            (pieces[6] == ' ') &&\n            (pieces[9] == ':') &&\n            (pieces[12] == ':') &&\n            (pieces[15] == ' ') && (lf->log += 16)\n        )\n        ||\n        (   /* ex: 2015-04-16 21:51:02,805 */\n            (loglen > 24) &&\n            (pieces[4] == '-') &&\n            (pieces[7] == '-') &&\n            (pieces[10] == ' ') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') &&\n            (pieces[19] == ',') &&\n            (lf->log += 23)\n        )\n        ||\n        (\n            (loglen > 33) &&\n            (pieces[4] == '-') &&\n            (pieces[7] == '-') &&\n            (pieces[10] == 'T') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') &&\n            (   /* ex: 2007-06-14T15:48:55-04:00 */\n                (\n                    (pieces[22] == ':') &&\n                    (pieces[25] == ' ') && (lf->log += 26)\n                )\n                ||\n                /* ex: 2007-06-14T15:48:55.3-04:00 or 2009-05-22T09:36:46,214994-07:00 */\n                (\n                    (\n                        (pieces[19] == '.') || (pieces[19] == ',')\n                    )\n                    &&\n                    (\n                        ( (pieces[24] == ':') && (lf->log += 27) ) ||\n                        ( (pieces[25] == ':') && (lf->log += 28) ) ||\n                        ( (pieces[26] == ':') && (lf->log += 29) ) ||\n                        ( (pieces[27] == ':') && (lf->log += 30) ) ||\n                        ( (pieces[28] == ':') && (lf->log += 31) ) ||\n                        ( (pieces[29] == ':') && (lf->log += 32) )\n                    )\n                )\n            )\n        )\n        ||\n        (   /* ex: 2015 Dec 29 10:00:01 */\n            (loglen > 21) &&\n            (isdigit(pieces[0])) &&\n            (pieces[4] == ' ') &&\n            (pieces[8] == ' ') &&\n            (pieces[11] == ' ') &&\n            (pieces[14] == ':') &&\n            (pieces[17] == ':') &&\n            (pieces[20] == ' ') && (lf->log += 21)\n        )\n        ||\n        (\n            /* ex: 2019:11:06-00:08:03 */\n            (loglen > 20) &&\n            (isdigit(pieces[0])) &&\n            (pieces[4] == ':') &&\n            (pieces[7] == ':') &&\n            (pieces[10] == '-') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') && (lf->log += 20)\n        )\n    ) {\n        /* Check for an extra space in here */\n        if (*lf->log == ' ') {\n            lf->log++;\n        }\n\n\n        /* Hostname */\n        pieces = lf->hostname = lf->log;\n\n\n        /* Check for a valid hostname */\n        while (isValidChar(*pieces) == 1) {\n            pieces++;\n        }\n\n        /* Check if it is a syslog without hostname (common on Solaris) */\n        if (*pieces == ':' && pieces[1] == ' ') {\n            /* Getting solaris 8/9 messages without hostname.\n             * In these cases, the process_name should be there.\n             * http://www.ossec.net/wiki/index.php/Log_Samples_Solaris\n             */\n            lf->program_name = lf->hostname;\n            lf->hostname = NULL;\n\n            /* End the program name string */\n            *pieces = '\\0';\n\n            pieces += 2;\n            lf->log = pieces;\n        }\n\n        /* Extract the hostname */\n        else if (*pieces != ' ') {\n            /* Invalid hostname */\n            lf->hostname = NULL;\n            pieces = NULL;\n        } else {\n            /* End the hostname string */\n            *pieces = '\\0';\n\n            /* Move pieces to the beginning of the log message */\n            pieces++;\n            lf->log = pieces;\n\n            /* Get program_name */\n            lf->program_name = pieces;\n\n            /* Extract program_name */\n            /* Valid names:\n             * p_name:\n             * p_name[pid]:\n             * p_name[pid]: [ID xx facility.severity]\n             * auth|security:info p_name:\n             */\n            while (isValidChar(*pieces) == 1) {\n                pieces++;\n            }\n\n            /* Check for the first format: p_name: */\n            if ((*pieces == ':') && (pieces[1] == ' ')) {\n                *pieces = '\\0';\n                pieces += 2;\n            }\n\n            /* Check for the second format: p_name[pid]: */\n            else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {\n                *pieces = '\\0';\n                pieces += 2;\n                while (isdigit((int)*pieces)) {\n                    pieces++;\n                }\n\n                if ((*pieces == ']') && (pieces[1] == ':') && (pieces[2] == ' ')) {\n                    pieces += 3;\n                }\n                /* Some systems are not terminating the program name with\n                 * a ':'. Working around this in here...\n                 */\n                else if ((*pieces == ']') && (pieces[1] == ' ')) {\n                    pieces += 2;\n                } else {\n                    /* Fix for some weird log formats */\n                    pieces--;\n                    while (isdigit((int)*pieces)) {\n                        pieces--;\n                    }\n\n                    if (*pieces == '\\0') {\n                        *pieces = '[';\n                    }\n                    pieces = NULL;\n                    lf->program_name = NULL;\n                }\n            }\n            /* AIX syslog */\n            else if ((*pieces == '|') && islower((int)pieces[1])) {\n                pieces += 2;\n\n                /* Remove facility */\n                while (isalnum((int)*pieces)) {\n                    pieces++;\n                }\n\n                if (*pieces == ':') {\n                    /* Remove severity */\n                    pieces++;\n                    while (isalnum((int)*pieces)) {\n                        pieces++;\n                    }\n\n                    if (*pieces == ' ') {\n                        pieces++;\n                        lf->program_name = pieces;\n\n\n                        /* Get program name again */\n                        while (isValidChar(*pieces) == 1) {\n                            pieces++;\n                        }\n\n                        /* Check for the first format: p_name: */\n                        if ((*pieces == ':') && (pieces[1] == ' ')) {\n                            *pieces = '\\0';\n                            pieces += 2;\n                        }\n\n                        /* Check for the second format: p_name[pid]: */\n                        else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {\n                            *pieces = '\\0';\n                            pieces += 2;\n                            while (isdigit((int)*pieces)) {\n                                pieces++;\n                            }\n\n                            if ((*pieces == ']') && (pieces[1] == ':') &&\n                                    (pieces[2] == ' ')) {\n                                pieces += 3;\n                            } else {\n                                pieces = NULL;\n                            }\n                        }\n                    } else {\n                        pieces = NULL;\n                        lf->program_name = NULL;\n                    }\n                }\n                /* Invalid AIX */\n                else {\n                    pieces = NULL;\n                    lf->program_name = NULL;\n                }\n            } else {\n                pieces = NULL;\n                lf->program_name = NULL;\n            }\n        }\n\n        /* Remove [ID xx facility.severity] */\n        if (pieces) {\n            /* Set log after program name */\n            lf->log = pieces;\n\n            if ((pieces[0] == '[') &&\n                    (pieces[1] == 'I') &&\n                    (pieces[2] == 'D') &&\n                    (pieces[3] == ' ')) {\n                pieces += 4;\n\n                /* Going after the ] */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    pieces += 2;\n                    lf->log = pieces;\n                }\n            }\n        }\n\n        /* Get program name size */\n        if (lf->program_name) {\n            lf->p_name_size = strlen(lf->program_name);\n        }\n    }\n\n    /* xferlog date format\n     * Mon Apr 17 18:27:14 2006 1 64.160.42.130\n     */\n    else if ((loglen > 28) &&\n             (pieces[3] == ' ') &&\n             (pieces[7] == ' ') &&\n             (pieces[10] == ' ') &&\n             (pieces[13] == ':') &&\n             (pieces[16] == ':') &&\n             (pieces[19] == ' ') &&\n             (pieces[24] == ' ') &&\n             (pieces[26] == ' ')) {\n        /* Move log to the beginning of the message */\n        lf->log += 24;\n    }\n\n    /* Check for snort date format\n     * ex: 01/28-09:13:16.240702  [**]\n     */\n    else if ( (loglen > 24) &&\n              (pieces[2] == '/') &&\n              (pieces[5] == '-') &&\n              (pieces[8] == ':') &&\n              (pieces[11] == ':') &&\n              (pieces[14] == '.') &&\n              (pieces[21] == ' ') ) {\n        lf->log += 23;\n    }\n\n    /* Check for suricata (new) date format\n     * ex: 01/28/1979-09:13:16.240702  [**]\n     */\n    else if ( (loglen > 26) &&\n              (pieces[2] == '/') &&\n              (pieces[5] == '/') &&\n              (pieces[10] == '-') &&\n              (pieces[13] == ':') &&\n              (pieces[16] == ':') &&\n              (pieces[19] == '.') &&\n              (pieces[26] == ' ') ) {\n        lf->log += 28;\n    }\n\n\n    /* Check for apache log format */\n    /* [Fri Feb 11 18:06:35 2004] [warn] */\n    else if ( (loglen > 27) &&\n              (pieces[0] == '[') &&\n              (pieces[4] == ' ') &&\n              (pieces[8] == ' ') &&\n              (pieces[11] == ' ') &&\n              (pieces[14] == ':') &&\n              (pieces[17] == ':') &&\n              (pieces[20] == ' ') &&\n              (pieces[25] == ']') ) {\n        lf->log += 27;\n    }\n\n    /* Check for the osx asl log format.\n     * Examples:\n     * [Time 2006.12.28 15:53:55 UTC] [Facility auth] [Sender sshd] [PID 483] [Message error: PAM: Authentication failure for username from 192.168.0.2] [Level 3] [UID -2] [GID -2] [Host Hostname]\n     * [Time 2006.11.02 14:02:11 UTC] [Facility auth] [Sender sshd] [PID 856]\n     [Message refused connect from 59.124.44.34] [Level 4] [UID -2] [GID -2]\n     [Host robert-wyatts-emac]\n     */\n    else if ((loglen > 26) &&\n             (pieces[0] == '[')  &&\n             (pieces[1] == 'T')  &&\n             (pieces[5] == ' ')  &&\n             (pieces[10] == '.') &&\n             (pieces[13] == '.') &&\n             (pieces[16] == ' ') &&\n             (pieces[19] == ':')) {\n        /* Do not read more than 1 message entry -> log tampering */\n        short unsigned int done_message = 0;\n\n        /* Remove the date */\n        lf->log += 25;\n\n        /* Get the desired values */\n        pieces = strchr(lf->log, '[');\n        while (pieces) {\n            pieces++;\n\n            /* Get the sender (set to program name) */\n            if ((strncmp(pieces, \"Sender \", 7) == 0) &&\n                    (lf->program_name == NULL)) {\n                pieces += 7;\n                lf->program_name = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n\n                    /* Set program_name size */\n                    lf->p_name_size = strlen(lf->program_name);\n\n                    pieces++;\n                }\n                /* Invalid program name */\n                else {\n                    lf->program_name = NULL;\n                    break;\n                }\n            }\n\n            /* Get message */\n            else if ((strncmp(pieces, \"Message \", 8) == 0) &&\n                     (done_message == 0)) {\n                pieces += 8;\n                done_message = 1;\n\n                lf->log = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n                    pieces++;\n                }\n                /* Invalid log closure */\n                else {\n                    break;\n                }\n            }\n\n            /* Get hostname */\n            else if (strncmp(pieces, \"Host \", 5) == 0) {\n                pieces += 5;\n                lf->hostname = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n                    pieces++;\n                }\n\n                /* Invalid hostname */\n                else {\n                    lf->hostname = NULL;\n                }\n                break;\n            }\n\n            /* Get next entry */\n            pieces = strchr(pieces, '[');\n        }\n    }\n\n    /* Check for squid date format\n     * 1140804070.368  11623\n     * seconds from 00:00:00 1970-01-01 UTC\n     */\n    else if ((loglen > 32) &&\n             (pieces[0] == '1') &&\n             (isdigit((int)pieces[1])) &&\n             (isdigit((int)pieces[2])) &&\n             (isdigit((int)pieces[3])) &&\n             (pieces[10] == '.') &&\n             (isdigit((int)pieces[13])) &&\n             (pieces[14] == ' ') &&\n             ((pieces[21] == ' ') || (pieces[22] == ' '))) {\n        lf->log += 14;\n\n        /* We need to start at the size of the event */\n        while (*lf->log == ' ') {\n            lf->log++;\n        }\n    }\n\n    /* Every message must be in the format\n     * hostname->location or\n     * (agent) ip->location.\n     */\n\n    /* Set hostname for local messages */\n    if (lf->location[0] == '(') {\n        /* Messages from an agent */\n        lf->hostname = lf->location;\n    } else if (lf->hostname == NULL) {\n        lf->hostname = __shost;\n    }\n\n    /* Set up the event data */\n    lf->time = c_time;\n    p = localtime(&c_time);\n\n    /* Assign hour, day, year and month values */\n    lf->day = p->tm_mday;\n    lf->year = p->tm_year + 1900;\n    strncpy(lf->mon, month[p->tm_mon], 3);\n    snprintf(lf->hour, 9, \"%02d:%02d:%02d\",\n             p->tm_hour,\n             p->tm_min,\n             p->tm_sec);\n\n    /* Set the global hour/weekday */\n    __crt_hour = p->tm_hour;\n    __crt_wday = p->tm_wday;\n\n#ifdef TESTRULE\n    if (!alert_only) {\n        print_out(\"**Phase 1: Completed pre-decoding.\");\n        print_out(\"       full event: '%s'\", lf->full_log);\n        print_out(\"       hostname: '%s'\", lf->hostname);\n        print_out(\"       program_name: '%s'\", lf->program_name);\n        print_out(\"       log: '%s'\", lf->log);\n    }\n#endif\n    return (0);\n}",
        "func": "int OS_CleanMSG(char *msg, Eventinfo *lf)\n{\n    size_t loglen;\n    char *pieces;\n    struct tm *p;\n\n    /* The message is formatted in the following way:\n     * id:location:message.\n     */\n\n    /* Ignore the id of the message in here */\n    msg += 2;\n\n    /* Set pieces as the message */\n    pieces = strchr(msg, ':');\n    if (!pieces) {\n        merror(FORMAT_ERROR, ARGV0);\n        return (-1);\n    }\n\n    /* Is this from an agent? */\n    if ( *msg == '(' )\n    {   /* look past '->' for the first ':' */\n        pieces = strchr(strstr(msg, \"->\"), ':');\n        if(!pieces)\n        {\n            merror(FORMAT_ERROR, ARGV0);\n            return(-1);\n        }\n    }\n\n    *pieces = '\\0';\n    pieces++;\n\n    os_strdup(msg, lf->location);\n\n    /* Get the log length */\n    loglen = strlen(pieces) + 1;\n\n    /* Assign the values in the structure (lf->full_log) */\n    os_malloc((2 * loglen) + 1, lf->full_log);\n\n    /* Set the whole message at full_log */\n    strncpy(lf->full_log, pieces, loglen);\n\n    /* Log is the one used for parsing in the decoders and rules */\n    lf->log = lf->full_log + loglen;\n    strncpy(lf->log, pieces, loglen);\n\n    /* check if month contains an umlaut and repair\n     * umlauts are non-ASCII and use 2 slots in the char array\n     * repair to only one slot so we can detect the correct date format in the next step\n     * ex: Mr 02 17:30:52\n     */\n    if (pieces[1] == (char) 195) {\n        if (pieces[2] == (char) 164) {\n            pieces[0] = '\\0';\n            pieces[1] = 'M';\n            pieces[2] = 'a';\n            pieces++;\n        }\n    }\n\n    /* Check for the syslog date format\n     * ( ex: Dec 29 10:00:01\n     *   or  2015-04-16 21:51:02,805 for proftpd 1.3.5\n     *   or  2007-06-14T15:48:55-04:00 for syslog-ng isodate\n     *   or  2007-06-14T15:48:55.3352-04:00 for syslog-ng isodate with up to 6 optional fraction of a second\n     *   or  2009-05-22T09:36:46.214994-07:00 for rsyslog\n     *   or  2015 Dec 29 10:00:01 )\n     */\n    if (\n        (   /* ex: Dec 29 10:00:01 */\n            (loglen > 17) &&\n            (pieces[3] == ' ') &&\n            (pieces[6] == ' ') &&\n            (pieces[9] == ':') &&\n            (pieces[12] == ':') &&\n            (pieces[15] == ' ') && (lf->log += 16)\n        )\n        ||\n        (   /* ex: 2015-04-16 21:51:02,805 */\n            (loglen > 24) &&\n            (pieces[4] == '-') &&\n            (pieces[7] == '-') &&\n            (pieces[10] == ' ') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') &&\n            (pieces[19] == ',') &&\n            (lf->log += 23)\n        )\n        ||\n        (\n            (loglen > 33) &&\n            (pieces[4] == '-') &&\n            (pieces[7] == '-') &&\n            (pieces[10] == 'T') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') &&\n            (   /* ex: 2007-06-14T15:48:55-04:00 */\n                (\n                    (pieces[22] == ':') &&\n                    (pieces[25] == ' ') && (lf->log += 26)\n                )\n                ||\n                /* ex: 2007-06-14T15:48:55.3-04:00 or 2009-05-22T09:36:46,214994-07:00 */\n                (\n                    (\n                        (pieces[19] == '.') || (pieces[19] == ',')\n                    )\n                    &&\n                    (\n                        ( (pieces[24] == ':') && (lf->log += 27) ) ||\n                        ( (pieces[25] == ':') && (lf->log += 28) ) ||\n                        ( (pieces[26] == ':') && (lf->log += 29) ) ||\n                        ( (pieces[27] == ':') && (lf->log += 30) ) ||\n                        ( (pieces[28] == ':') && (lf->log += 31) ) ||\n                        ( (pieces[29] == ':') && (lf->log += 32) )\n                    )\n                )\n            )\n        )\n        ||\n        (   /* ex: 2015 Dec 29 10:00:01 */\n            (loglen > 21) &&\n            (isdigit(pieces[0])) &&\n            (pieces[4] == ' ') &&\n            (pieces[8] == ' ') &&\n            (pieces[11] == ' ') &&\n            (pieces[14] == ':') &&\n            (pieces[17] == ':') &&\n            (pieces[20] == ' ') && (lf->log += 21)\n        )\n        ||\n        (\n            /* ex: 2019:11:06-00:08:03 */\n            (loglen > 20) &&\n            (isdigit(pieces[0])) &&\n            (pieces[4] == ':') &&\n            (pieces[7] == ':') &&\n            (pieces[10] == '-') &&\n            (pieces[13] == ':') &&\n            (pieces[16] == ':') && (lf->log += 20)\n        )\n    ) {\n        /* Check for an extra space in here */\n        if (*lf->log == ' ') {\n            lf->log++;\n        }\n\n\n        /* Hostname */\n        pieces = lf->hostname = lf->log;\n\n\n        /* Check for a valid hostname */\n        while (isValidChar(*pieces) == 1) {\n            pieces++;\n        }\n\n        /* Check if it is a syslog without hostname (common on Solaris) */\n        if (*pieces == ':' && pieces[1] == ' ') {\n            /* Getting solaris 8/9 messages without hostname.\n             * In these cases, the process_name should be there.\n             * http://www.ossec.net/wiki/index.php/Log_Samples_Solaris\n             */\n            lf->program_name = lf->hostname;\n            lf->hostname = NULL;\n\n            /* End the program name string */\n            *pieces = '\\0';\n\n            pieces += 2;\n            lf->log = pieces;\n        }\n\n        /* Extract the hostname */\n        else if (*pieces != ' ') {\n            /* Invalid hostname */\n            lf->hostname = NULL;\n            pieces = NULL;\n        } else {\n            /* End the hostname string */\n            *pieces = '\\0';\n\n            /* Move pieces to the beginning of the log message */\n            pieces++;\n            lf->log = pieces;\n\n            /* Get program_name */\n            lf->program_name = pieces;\n\n            /* Extract program_name */\n            /* Valid names:\n             * p_name:\n             * p_name[pid]:\n             * p_name[pid]: [ID xx facility.severity]\n             * auth|security:info p_name:\n             */\n            while (isValidChar(*pieces) == 1) {\n                pieces++;\n            }\n\n            /* Check for the first format: p_name: */\n            if ((*pieces == ':') && (pieces[1] == ' ')) {\n                *pieces = '\\0';\n                pieces += 2;\n            }\n\n            /* Check for the second format: p_name[pid]: */\n            else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {\n                *pieces = '\\0';\n                pieces += 2;\n                while (isdigit((int)*pieces)) {\n                    pieces++;\n                }\n\n                if ((*pieces == ']') && (pieces[1] == ':') && (pieces[2] == ' ')) {\n                    pieces += 3;\n                }\n                /* Some systems are not terminating the program name with\n                 * a ':'. Working around this in here...\n                 */\n                else if ((*pieces == ']') && (pieces[1] == ' ')) {\n                    pieces += 2;\n                } else {\n                    /* Fix for some weird log formats */\n                    pieces--;\n                    while (isdigit((int)*pieces)) {\n                        pieces--;\n                    }\n\n                    if (*pieces == '\\0') {\n                        *pieces = '[';\n                    }\n                    pieces = NULL;\n                    lf->program_name = NULL;\n                }\n            }\n            /* AIX syslog */\n            else if ((*pieces == '|') && islower((int)pieces[1])) {\n                pieces += 2;\n\n                /* Remove facility */\n                while (isalnum((int)*pieces)) {\n                    pieces++;\n                }\n\n                if (*pieces == ':') {\n                    /* Remove severity */\n                    pieces++;\n                    while (isalnum((int)*pieces)) {\n                        pieces++;\n                    }\n\n                    if (*pieces == ' ') {\n                        pieces++;\n                        lf->program_name = pieces;\n\n\n                        /* Get program name again */\n                        while (isValidChar(*pieces) == 1) {\n                            pieces++;\n                        }\n\n                        /* Check for the first format: p_name: */\n                        if ((*pieces == ':') && (pieces[1] == ' ')) {\n                            *pieces = '\\0';\n                            pieces += 2;\n                        }\n\n                        /* Check for the second format: p_name[pid]: */\n                        else if ((*pieces == '[') && (isdigit((int)pieces[1]))) {\n                            *pieces = '\\0';\n                            pieces += 2;\n                            while (isdigit((int)*pieces)) {\n                                pieces++;\n                            }\n\n                            if ((*pieces == ']') && (pieces[1] == ':') &&\n                                    (pieces[2] == ' ')) {\n                                pieces += 3;\n                            } else {\n                                pieces = NULL;\n                            }\n                        }\n                    } else {\n                        pieces = NULL;\n                        lf->program_name = NULL;\n                    }\n                }\n                /* Invalid AIX */\n                else {\n                    pieces = NULL;\n                    lf->program_name = NULL;\n                }\n            } else {\n                pieces = NULL;\n                lf->program_name = NULL;\n            }\n        }\n\n        /* Remove [ID xx facility.severity] */\n        if (pieces) {\n            /* Set log after program name */\n            lf->log = pieces;\n\n            if ((pieces[0] == '[') &&\n                    (pieces[1] == 'I') &&\n                    (pieces[2] == 'D') &&\n                    (pieces[3] == ' ')) {\n                pieces += 4;\n\n                /* Going after the \"] \" */\n                pieces = strstr(pieces, \"] \");\n                if (pieces) {\n                    pieces += 2;\n                    lf->log = pieces;\n                }\n            }\n        }\n\n        /* Get program name size */\n        if (lf->program_name) {\n            lf->p_name_size = strlen(lf->program_name);\n        }\n    }\n\n    /* xferlog date format\n     * Mon Apr 17 18:27:14 2006 1 64.160.42.130\n     */\n    else if ((loglen > 28) &&\n             (pieces[3] == ' ') &&\n             (pieces[7] == ' ') &&\n             (pieces[10] == ' ') &&\n             (pieces[13] == ':') &&\n             (pieces[16] == ':') &&\n             (pieces[19] == ' ') &&\n             (pieces[24] == ' ') &&\n             (pieces[26] == ' ')) {\n        /* Move log to the beginning of the message */\n        lf->log += 24;\n    }\n\n    /* Check for snort date format\n     * ex: 01/28-09:13:16.240702  [**]\n     */\n    else if ( (loglen > 24) &&\n              (pieces[2] == '/') &&\n              (pieces[5] == '-') &&\n              (pieces[8] == ':') &&\n              (pieces[11] == ':') &&\n              (pieces[14] == '.') &&\n              (pieces[21] == ' ') ) {\n        lf->log += 23;\n    }\n\n    /* Check for suricata (new) date format\n     * ex: 01/28/1979-09:13:16.240702  [**]\n     */\n    else if ( (loglen > 26) &&\n              (pieces[2] == '/') &&\n              (pieces[5] == '/') &&\n              (pieces[10] == '-') &&\n              (pieces[13] == ':') &&\n              (pieces[16] == ':') &&\n              (pieces[19] == '.') &&\n              (pieces[26] == ' ') ) {\n        lf->log += 28;\n    }\n\n\n    /* Check for apache log format */\n    /* [Fri Feb 11 18:06:35 2004] [warn] */\n    else if ( (loglen > 27) &&\n              (pieces[0] == '[') &&\n              (pieces[4] == ' ') &&\n              (pieces[8] == ' ') &&\n              (pieces[11] == ' ') &&\n              (pieces[14] == ':') &&\n              (pieces[17] == ':') &&\n              (pieces[20] == ' ') &&\n              (pieces[25] == ']') ) {\n        lf->log += 27;\n    }\n\n    /* Check for the osx asl log format.\n     * Examples:\n     * [Time 2006.12.28 15:53:55 UTC] [Facility auth] [Sender sshd] [PID 483] [Message error: PAM: Authentication failure for username from 192.168.0.2] [Level 3] [UID -2] [GID -2] [Host Hostname]\n     * [Time 2006.11.02 14:02:11 UTC] [Facility auth] [Sender sshd] [PID 856]\n     [Message refused connect from 59.124.44.34] [Level 4] [UID -2] [GID -2]\n     [Host robert-wyatts-emac]\n     */\n    else if ((loglen > 26) &&\n             (pieces[0] == '[')  &&\n             (pieces[1] == 'T')  &&\n             (pieces[5] == ' ')  &&\n             (pieces[10] == '.') &&\n             (pieces[13] == '.') &&\n             (pieces[16] == ' ') &&\n             (pieces[19] == ':')) {\n        /* Do not read more than 1 message entry -> log tampering */\n        short unsigned int done_message = 0;\n\n        /* Remove the date */\n        lf->log += 25;\n\n        /* Get the desired values */\n        pieces = strchr(lf->log, '[');\n        while (pieces) {\n            pieces++;\n\n            /* Get the sender (set to program name) */\n            if ((strncmp(pieces, \"Sender \", 7) == 0) &&\n                    (lf->program_name == NULL)) {\n                pieces += 7;\n                lf->program_name = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n\n                    /* Set program_name size */\n                    lf->p_name_size = strlen(lf->program_name);\n\n                    pieces++;\n                }\n                /* Invalid program name */\n                else {\n                    lf->program_name = NULL;\n                    break;\n                }\n            }\n\n            /* Get message */\n            else if ((strncmp(pieces, \"Message \", 8) == 0) &&\n                     (done_message == 0)) {\n                pieces += 8;\n                done_message = 1;\n\n                lf->log = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n                    pieces++;\n                }\n                /* Invalid log closure */\n                else {\n                    break;\n                }\n            }\n\n            /* Get hostname */\n            else if (strncmp(pieces, \"Host \", 5) == 0) {\n                pieces += 5;\n                lf->hostname = pieces;\n\n                /* Get the closing brackets */\n                pieces = strchr(pieces, ']');\n                if (pieces) {\n                    *pieces = '\\0';\n                    pieces++;\n                }\n\n                /* Invalid hostname */\n                else {\n                    lf->hostname = NULL;\n                }\n                break;\n            }\n\n            /* Get next entry */\n            pieces = strchr(pieces, '[');\n        }\n    }\n\n    /* Check for squid date format\n     * 1140804070.368  11623\n     * seconds from 00:00:00 1970-01-01 UTC\n     */\n    else if ((loglen > 32) &&\n             (pieces[0] == '1') &&\n             (isdigit((int)pieces[1])) &&\n             (isdigit((int)pieces[2])) &&\n             (isdigit((int)pieces[3])) &&\n             (pieces[10] == '.') &&\n             (isdigit((int)pieces[13])) &&\n             (pieces[14] == ' ') &&\n             ((pieces[21] == ' ') || (pieces[22] == ' '))) {\n        lf->log += 14;\n\n        /* We need to start at the size of the event */\n        while (*lf->log == ' ') {\n            lf->log++;\n        }\n    }\n\n    /* Every message must be in the format\n     * hostname->location or\n     * (agent) ip->location.\n     */\n\n    /* Set hostname for local messages */\n    if (lf->location[0] == '(') {\n        /* Messages from an agent */\n        lf->hostname = lf->location;\n    } else if (lf->hostname == NULL) {\n        lf->hostname = __shost;\n    }\n\n    /* Set up the event data */\n    lf->time = c_time;\n    p = localtime(&c_time);\n\n    /* Assign hour, day, year and month values */\n    lf->day = p->tm_mday;\n    lf->year = p->tm_year + 1900;\n    strncpy(lf->mon, month[p->tm_mon], 3);\n    snprintf(lf->hour, 9, \"%02d:%02d:%02d\",\n             p->tm_hour,\n             p->tm_min,\n             p->tm_sec);\n\n    /* Set the global hour/weekday */\n    __crt_hour = p->tm_hour;\n    __crt_wday = p->tm_wday;\n\n#ifdef TESTRULE\n    if (!alert_only) {\n        print_out(\"**Phase 1: Completed pre-decoding.\");\n        print_out(\"       full event: '%s'\", lf->full_log);\n        print_out(\"       hostname: '%s'\", lf->hostname);\n        print_out(\"       program_name: '%s'\", lf->program_name);\n        print_out(\"       log: '%s'\", lf->log);\n    }\n#endif\n    return (0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -311,8 +311,8 @@\n                     (pieces[3] == ' ')) {\n                 pieces += 4;\n \n-                /* Going after the ] */\n-                pieces = strchr(pieces, ']');\n+                /* Going after the \"] \" */\n+                pieces = strstr(pieces, \"] \");\n                 if (pieces) {\n                     pieces += 2;\n                     lf->log = pieces;",
        "diff_line_info": {
            "deleted_lines": [
                "                /* Going after the ] */",
                "                pieces = strchr(pieces, ']');"
            ],
            "added_lines": [
                "                /* Going after the \"] \" */",
                "                pieces = strstr(pieces, \"] \");"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-29040",
        "func_name": "xen-project/xen/xenmem_add_to_physmap",
        "description": "An issue was discovered in Xen through 4.14.x allowing x86 HVM guest OS users to cause a denial of service (stack corruption), cause a data leak, or possibly gain privileges because of an off-by-one error. NOTE: this issue is caused by an incorrect fix for CVE-2020-27671.",
        "git_url": "https://github.com/xen-project/xen/commit/9b156bcc3ffcc7949edd4460b718a241e87ae302",
        "commit_title": "memory: fix off-by-one in XSA-346 change",
        "commit_text": " The comparison against ARRAY_SIZE() needs to be >= in order to avoid overrunning the pages[] array.  This is XSA-355. ",
        "func_before": "int xenmem_add_to_physmap(struct domain *d, struct xen_add_to_physmap *xatp,\n                          unsigned int start)\n{\n    unsigned int done = 0;\n    long rc = 0;\n    union add_to_physmap_extra extra = {};\n    struct page_info *pages[16];\n\n    ASSERT(paging_mode_translate(d));\n\n    if ( xatp->space == XENMAPSPACE_gmfn_foreign )\n        extra.foreign_domid = DOMID_INVALID;\n\n    if ( xatp->space != XENMAPSPACE_gmfn_range )\n        return xenmem_add_to_physmap_one(d, xatp->space, extra,\n                                         xatp->idx, _gfn(xatp->gpfn));\n\n    if ( xatp->size < start )\n        return -EILSEQ;\n\n    xatp->idx += start;\n    xatp->gpfn += start;\n    xatp->size -= start;\n\n    if ( is_iommu_enabled(d) )\n    {\n       this_cpu(iommu_dont_flush_iotlb) = 1;\n       extra.ppage = &pages[0];\n    }\n\n    while ( xatp->size > done )\n    {\n        rc = xenmem_add_to_physmap_one(d, XENMAPSPACE_gmfn, extra,\n                                       xatp->idx, _gfn(xatp->gpfn));\n        if ( rc < 0 )\n            break;\n\n        xatp->idx++;\n        xatp->gpfn++;\n\n        if ( extra.ppage )\n            ++extra.ppage;\n\n        /* Check for continuation if it's not the last iteration. */\n        if ( (++done > ARRAY_SIZE(pages) && extra.ppage) ||\n             (xatp->size > done && hypercall_preempt_check()) )\n        {\n            rc = start + done;\n            break;\n        }\n    }\n\n    if ( is_iommu_enabled(d) )\n    {\n        int ret;\n        unsigned int i;\n\n        this_cpu(iommu_dont_flush_iotlb) = 0;\n\n        ret = iommu_iotlb_flush(d, _dfn(xatp->idx - done), done,\n                                IOMMU_FLUSHF_modified);\n        if ( unlikely(ret) && rc >= 0 )\n            rc = ret;\n\n        /*\n         * Now that the IOMMU TLB flush was done for the original GFN, drop\n         * the page references. The 2nd flush below is fine to make later, as\n         * whoever removes the page again from its new GFN will have to do\n         * another flush anyway.\n         */\n        for ( i = 0; i < done; ++i )\n            put_page(pages[i]);\n\n        ret = iommu_iotlb_flush(d, _dfn(xatp->gpfn - done), done,\n                                IOMMU_FLUSHF_added | IOMMU_FLUSHF_modified);\n        if ( unlikely(ret) && rc >= 0 )\n            rc = ret;\n    }\n\n    return rc;\n}",
        "func": "int xenmem_add_to_physmap(struct domain *d, struct xen_add_to_physmap *xatp,\n                          unsigned int start)\n{\n    unsigned int done = 0;\n    long rc = 0;\n    union add_to_physmap_extra extra = {};\n    struct page_info *pages[16];\n\n    ASSERT(paging_mode_translate(d));\n\n    if ( xatp->space == XENMAPSPACE_gmfn_foreign )\n        extra.foreign_domid = DOMID_INVALID;\n\n    if ( xatp->space != XENMAPSPACE_gmfn_range )\n        return xenmem_add_to_physmap_one(d, xatp->space, extra,\n                                         xatp->idx, _gfn(xatp->gpfn));\n\n    if ( xatp->size < start )\n        return -EILSEQ;\n\n    xatp->idx += start;\n    xatp->gpfn += start;\n    xatp->size -= start;\n\n    if ( is_iommu_enabled(d) )\n    {\n       this_cpu(iommu_dont_flush_iotlb) = 1;\n       extra.ppage = &pages[0];\n    }\n\n    while ( xatp->size > done )\n    {\n        rc = xenmem_add_to_physmap_one(d, XENMAPSPACE_gmfn, extra,\n                                       xatp->idx, _gfn(xatp->gpfn));\n        if ( rc < 0 )\n            break;\n\n        xatp->idx++;\n        xatp->gpfn++;\n\n        if ( extra.ppage )\n            ++extra.ppage;\n\n        /* Check for continuation if it's not the last iteration. */\n        if ( (++done >= ARRAY_SIZE(pages) && extra.ppage) ||\n             (xatp->size > done && hypercall_preempt_check()) )\n        {\n            rc = start + done;\n            break;\n        }\n    }\n\n    if ( is_iommu_enabled(d) )\n    {\n        int ret;\n        unsigned int i;\n\n        this_cpu(iommu_dont_flush_iotlb) = 0;\n\n        ret = iommu_iotlb_flush(d, _dfn(xatp->idx - done), done,\n                                IOMMU_FLUSHF_modified);\n        if ( unlikely(ret) && rc >= 0 )\n            rc = ret;\n\n        /*\n         * Now that the IOMMU TLB flush was done for the original GFN, drop\n         * the page references. The 2nd flush below is fine to make later, as\n         * whoever removes the page again from its new GFN will have to do\n         * another flush anyway.\n         */\n        for ( i = 0; i < done; ++i )\n            put_page(pages[i]);\n\n        ret = iommu_iotlb_flush(d, _dfn(xatp->gpfn - done), done,\n                                IOMMU_FLUSHF_added | IOMMU_FLUSHF_modified);\n        if ( unlikely(ret) && rc >= 0 )\n            rc = ret;\n    }\n\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -42,7 +42,7 @@\n             ++extra.ppage;\n \n         /* Check for continuation if it's not the last iteration. */\n-        if ( (++done > ARRAY_SIZE(pages) && extra.ppage) ||\n+        if ( (++done >= ARRAY_SIZE(pages) && extra.ppage) ||\n              (xatp->size > done && hypercall_preempt_check()) )\n         {\n             rc = start + done;",
        "diff_line_info": {
            "deleted_lines": [
                "        if ( (++done > ARRAY_SIZE(pages) && extra.ppage) ||"
            ],
            "added_lines": [
                "        if ( (++done >= ARRAY_SIZE(pages) && extra.ppage) ||"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-47517",
        "func_name": "davehorton/sofia-sip/url_canonize2",
        "description": "An issue was discovered in the libsofia-sip fork in drachtio-server before 0.8.19. It allows remote attackers to cause a denial of service (daemon crash) via a crafted UDP message that causes a url_canonize2 heap-based buffer over-read because of an off-by-one error.",
        "git_url": "https://github.com/davehorton/sofia-sip/commit/22c1bd191f0acbf11f0c0fbea1845d9bf9dcd47e",
        "commit_title": "fix off-by-one access triggered eg by Contact: %",
        "commit_text": "",
        "func_before": "static\nchar *url_canonize2(char *d, char const * const s, size_t n,\n\t\t    unsigned syn33,\n\t\t    unsigned m32, unsigned m64, unsigned m96)\n{\n  size_t i = 0;\n\n  if (d == s)\n    for (;s[i] && i < n; d++, i++)\n      if (s[i] == '%')\n\tbreak;\n\n  for (;s[i] && i < n; d++, i++) {\n    unsigned char c = s[i], h1, h2;\n\n    if (c != '%') {\n      if (!IS_SYN33(syn33, c) && IS_EXCLUDED(c, m32, m64, m96))\n\treturn NULL;\n      *d = c;\n      continue;\n    }\n\n    h1 = s[i + 1], h2 = s[i + 2];\n\n    if (!IS_HEX(h1) || !IS_HEX(h2)) {\n      *d = '\\0';\n      return NULL;\n    }\n\n#define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n    c = (UNHEX(h1) << 4) | UNHEX(h2);\n\n    if (!IS_EXCLUDED(c, m32, m64, m96)) {\n      /* Convert hex to normal character */\n      *d = c, i += 2;\n      continue;\n    }\n\n    /* Convert hex to uppercase */\n    if (h1 >= 'a' /* && h1 <= 'f' */)\n      h1 = h1 - 'a' + 'A';\n    if (h2 >= 'a' /* && h2 <= 'f' */)\n      h2 = h2 - 'a' + 'A';\n\n    d[0] = '%', d[1] = h1, d[2] = h2;\n\n    d +=2, i += 2;\n#undef    UNHEX\n  }\n\n  *d = '\\0';\n\n  return d;\n}",
        "func": "static\nchar *url_canonize2(char *d, char const * const s, size_t n,\n\t\t    unsigned syn33,\n\t\t    unsigned m32, unsigned m64, unsigned m96)\n{\n  size_t i = 0;\n\n  if (d == s)\n    for (;s[i] && i < n; d++, i++)\n      if (s[i] == '%')\n\tbreak;\n\n  for (;s[i] && i < n; d++, i++) {\n    unsigned char c = s[i], h1, h2;\n\n    if (c != '%') {\n      if (!IS_SYN33(syn33, c) && IS_EXCLUDED(c, m32, m64, m96))\n\treturn NULL;\n      *d = c;\n      continue;\n    }\n\n    if (i >= strlen(s) - 1) return NULL;\n    h1 = s[i + 1], h2 = s[i + 2];\n\n    if (!IS_HEX(h1) || !IS_HEX(h2)) {\n      *d = '\\0';\n      return NULL;\n    }\n\n#define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n    c = (UNHEX(h1) << 4) | UNHEX(h2);\n\n    if (!IS_EXCLUDED(c, m32, m64, m96)) {\n      /* Convert hex to normal character */\n      *d = c, i += 2;\n      continue;\n    }\n\n    /* Convert hex to uppercase */\n    if (h1 >= 'a' /* && h1 <= 'f' */)\n      h1 = h1 - 'a' + 'A';\n    if (h2 >= 'a' /* && h2 <= 'f' */)\n      h2 = h2 - 'a' + 'A';\n\n    d[0] = '%', d[1] = h1, d[2] = h2;\n\n    d +=2, i += 2;\n#undef    UNHEX\n  }\n\n  *d = '\\0';\n\n  return d;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,6 +20,7 @@\n       continue;\n     }\n \n+    if (i >= strlen(s) - 1) return NULL;\n     h1 = s[i + 1], h2 = s[i + 2];\n \n     if (!IS_HEX(h1) || !IS_HEX(h2)) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (i >= strlen(s) - 1) return NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-47517",
        "func_name": "davehorton/sofia-sip/url_canonize2",
        "description": "An issue was discovered in the libsofia-sip fork in drachtio-server before 0.8.19. It allows remote attackers to cause a denial of service (daemon crash) via a crafted UDP message that causes a url_canonize2 heap-based buffer over-read because of an off-by-one error.",
        "git_url": "https://github.com/davehorton/sofia-sip/commit/bfc79d85c8f3a4798a3305fb98f5a11c11d0d29f",
        "commit_title": "better fix for prev commit",
        "commit_text": "",
        "func_before": "static\nchar *url_canonize2(char *d, char const * const s, size_t n,\n\t\t    unsigned syn33,\n\t\t    unsigned m32, unsigned m64, unsigned m96)\n{\n  size_t i = 0;\n\n  if (d == s)\n    for (;s[i] && i < n; d++, i++)\n      if (s[i] == '%')\n\tbreak;\n\n  for (;s[i] && i < n; d++, i++) {\n    unsigned char c = s[i], h1, h2;\n\n    if (c != '%') {\n      if (!IS_SYN33(syn33, c) && IS_EXCLUDED(c, m32, m64, m96))\n\treturn NULL;\n      *d = c;\n      continue;\n    }\n\n    if (i >= strlen(s) - 1) return NULL;\n    h1 = s[i + 1], h2 = s[i + 2];\n\n    if (!IS_HEX(h1) || !IS_HEX(h2)) {\n      *d = '\\0';\n      return NULL;\n    }\n\n#define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n    c = (UNHEX(h1) << 4) | UNHEX(h2);\n\n    if (!IS_EXCLUDED(c, m32, m64, m96)) {\n      /* Convert hex to normal character */\n      *d = c, i += 2;\n      continue;\n    }\n\n    /* Convert hex to uppercase */\n    if (h1 >= 'a' /* && h1 <= 'f' */)\n      h1 = h1 - 'a' + 'A';\n    if (h2 >= 'a' /* && h2 <= 'f' */)\n      h2 = h2 - 'a' + 'A';\n\n    d[0] = '%', d[1] = h1, d[2] = h2;\n\n    d +=2, i += 2;\n#undef    UNHEX\n  }\n\n  *d = '\\0';\n\n  return d;\n}",
        "func": "static\nchar *url_canonize2(char *d, char const * const s, size_t n,\n\t\t    unsigned syn33,\n\t\t    unsigned m32, unsigned m64, unsigned m96)\n{\n  size_t i = 0;\n\n  if (d == s)\n    for (;s[i] && i < n; d++, i++)\n      if (s[i] == '%')\n\tbreak;\n\n  for (;s[i] && i < n; d++, i++) {\n    unsigned char c = s[i], h1, h2;\n\n    if (c != '%') {\n      if (!IS_SYN33(syn33, c) && IS_EXCLUDED(c, m32, m64, m96))\n\treturn NULL;\n      *d = c;\n      continue;\n    }\n\n    h1 = s[i + 1];\n    if (!h1) {\n        *d = '\\0';\n        return NULL;\n    }\n    h2 = s[i + 2];\n\n    if (!IS_HEX(h1) || !IS_HEX(h2)) {\n      *d = '\\0';\n      return NULL;\n    }\n\n#define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n    c = (UNHEX(h1) << 4) | UNHEX(h2);\n\n    if (!IS_EXCLUDED(c, m32, m64, m96)) {\n      /* Convert hex to normal character */\n      *d = c, i += 2;\n      continue;\n    }\n\n    /* Convert hex to uppercase */\n    if (h1 >= 'a' /* && h1 <= 'f' */)\n      h1 = h1 - 'a' + 'A';\n    if (h2 >= 'a' /* && h2 <= 'f' */)\n      h2 = h2 - 'a' + 'A';\n\n    d[0] = '%', d[1] = h1, d[2] = h2;\n\n    d +=2, i += 2;\n#undef    UNHEX\n  }\n\n  *d = '\\0';\n\n  return d;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,8 +20,12 @@\n       continue;\n     }\n \n-    if (i >= strlen(s) - 1) return NULL;\n-    h1 = s[i + 1], h2 = s[i + 2];\n+    h1 = s[i + 1];\n+    if (!h1) {\n+        *d = '\\0';\n+        return NULL;\n+    }\n+    h2 = s[i + 2];\n \n     if (!IS_HEX(h1) || !IS_HEX(h2)) {\n       *d = '\\0';",
        "diff_line_info": {
            "deleted_lines": [
                "    if (i >= strlen(s) - 1) return NULL;",
                "    h1 = s[i + 1], h2 = s[i + 2];"
            ],
            "added_lines": [
                "    h1 = s[i + 1];",
                "    if (!h1) {",
                "        *d = '\\0';",
                "        return NULL;",
                "    }",
                "    h2 = s[i + 2];"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-8828",
        "func_name": "kamailio/tmx_check_pretran",
        "description": "A Buffer Overflow issue was discovered in Kamailio before 4.4.7, 5.0.x before 5.0.6, and 5.1.x before 5.1.2. A specially crafted REGISTER message with a malformed branch or From tag triggers an off-by-one heap-based buffer overflow in the tmx_check_pretran function in modules/tmx/tmx_pretran.c.",
        "git_url": "https://github.com/kamailio/kamailio/commit/e1d8008a09d9390ebaf698abe8909e10dfec4097",
        "commit_title": "tmx: allocate space to store ending 0 for branch value",
        "commit_text": " - reported by Alfred Farrugia and Sandro Gauci",
        "func_before": "int tmx_check_pretran(sip_msg_t *msg)\n{\n\tunsigned int chid;\n\tunsigned int slotid;\n\tint dsize;\n\tstruct via_param *vbr;\n\tstr scallid;\n\tstr scseqmet;\n\tstr scseqnum;\n\tstr sftag;\n\tstr svbranch = {NULL, 0};\n\tpretran_t *it;\n\n\tif(_tmx_ptran_table==NULL) {\n\t\tLM_ERR(\"pretran hash table not initialized yet\\n\");\n\t\treturn -1;\n\t}\n\tif(get_route_type()!=REQUEST_ROUTE) {\n\t\tLM_ERR(\"invalid usage - not in request route\\n\");\n\t\treturn -1;\n\t}\n\tif(msg->first_line.type!=SIP_REQUEST) {\n\t\tLM_ERR(\"invalid usage - not a sip request\\n\");\n\t\treturn -1;\n\t}\n\tif(parse_headers(msg, HDR_FROM_F|HDR_VIA1_F|HDR_CALLID_F|HDR_CSEQ_F, 0)<0) {\n\t\tLM_ERR(\"failed to parse required headers\\n\");\n\t\treturn -1;\n\t}\n\tif(msg->cseq==NULL || msg->cseq->parsed==NULL) {\n\t\tLM_ERR(\"failed to parse cseq headers\\n\");\n\t\treturn -1;\n\t}\n\tif(get_cseq(msg)->method_id==METHOD_ACK\n\t\t\t|| get_cseq(msg)->method_id==METHOD_CANCEL) {\n\t\tLM_DBG(\"no pre-transaction management for ACK or CANCEL\\n\");\n\t\treturn -1;\n\t}\n\tif (msg->via1==0) {\n\t\tLM_ERR(\"failed to get Via header\\n\");\n\t\treturn -1;\n\t}\n\tif (parse_from_header(msg)<0 || get_from(msg)->tag_value.len==0) {\n\t\tLM_ERR(\"failed to get From header\\n\");\n\t\treturn -1;\n\t}\n\tif (msg->callid==NULL || msg->callid->body.s==NULL) {\n\t\tLM_ERR(\"failed to parse callid headers\\n\");\n\t\treturn -1;\n\t}\n\n\tvbr = msg->via1->branch;\n\n\tscallid = msg->callid->body;\n\ttrim(&scallid);\n\tscseqmet = get_cseq(msg)->method;\n\ttrim(&scseqmet);\n\tscseqnum = get_cseq(msg)->number;\n\ttrim(&scseqnum);\n\tsftag = get_from(msg)->tag_value;\n\ttrim(&sftag);\n\n\tchid = get_hash1_raw(msg->callid->body.s, msg->callid->body.len);\n\tslotid = chid & (_tmx_ptran_size-1);\n\n\tif(unlikely(_tmx_proc_ptran == NULL)) {\n\t\t_tmx_proc_ptran = (pretran_t*)shm_malloc(sizeof(pretran_t));\n\t\tif(_tmx_proc_ptran == NULL) {\n\t\t\tLM_ERR(\"not enough memory for pretran structure\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tmemset(_tmx_proc_ptran, 0, sizeof(pretran_t));\n\t\t_tmx_proc_ptran->pid = my_pid();\n\t}\n\tdsize = scallid.len + scseqnum.len + scseqmet.len\n\t\t+ sftag.len + 4;\n\tif(likely(vbr!=NULL)) {\n\t\tsvbranch = vbr->value;\n\t\ttrim(&svbranch);\n\t\tdsize += svbranch.len;\n\t}\n\tif(dsize<256) dsize = 256;\n\n\ttmx_pretran_unlink();\n\n\tif(dsize > _tmx_proc_ptran->dbuf.len) {\n\t\tif(_tmx_proc_ptran->dbuf.s) shm_free(_tmx_proc_ptran->dbuf.s);\n\t\t_tmx_proc_ptran->dbuf.s = (char*)shm_malloc(dsize);\n\t\tif(_tmx_proc_ptran->dbuf.s==NULL) {\n\t\t\tLM_ERR(\"not enough memory for pretran data\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\t_tmx_proc_ptran->dbuf.len = dsize;\n\t}\n\t_tmx_proc_ptran->hid = chid;\n\t_tmx_proc_ptran->cseqmetid = (get_cseq(msg))->method_id;\n\n\t_tmx_proc_ptran->callid.s = _tmx_proc_ptran->dbuf.s;\n\tmemcpy(_tmx_proc_ptran->callid.s, scallid.s, scallid.len);\n\t_tmx_proc_ptran->callid.len = scallid.len;\n\t_tmx_proc_ptran->callid.s[_tmx_proc_ptran->callid.len] = '\\0';\n\n\t_tmx_proc_ptran->ftag.s = _tmx_proc_ptran->callid.s\n\t\t+ _tmx_proc_ptran->callid.len + 1;\n\tmemcpy(_tmx_proc_ptran->ftag.s, sftag.s, sftag.len);\n\t_tmx_proc_ptran->ftag.len = sftag.len;\n\t_tmx_proc_ptran->ftag.s[_tmx_proc_ptran->ftag.len] = '\\0';\n\n\t_tmx_proc_ptran->cseqnum.s = _tmx_proc_ptran->ftag.s\n\t\t+ _tmx_proc_ptran->ftag.len + 1;\n\tmemcpy(_tmx_proc_ptran->cseqnum.s, scseqnum.s, scseqnum.len);\n\t_tmx_proc_ptran->cseqnum.len = scseqnum.len;\n\t_tmx_proc_ptran->cseqnum.s[_tmx_proc_ptran->cseqnum.len] = '\\0';\n\n\t_tmx_proc_ptran->cseqmet.s = _tmx_proc_ptran->cseqnum.s\n\t\t+ _tmx_proc_ptran->cseqnum.len + 1;\n\tmemcpy(_tmx_proc_ptran->cseqmet.s, scseqmet.s, scseqmet.len);\n\t_tmx_proc_ptran->cseqmet.len = scseqmet.len;\n\t_tmx_proc_ptran->cseqmet.s[_tmx_proc_ptran->cseqmet.len] = '\\0';\n\n\tif(likely(vbr!=NULL)) {\n\t\t_tmx_proc_ptran->vbranch.s = _tmx_proc_ptran->cseqmet.s\n\t\t\t+ _tmx_proc_ptran->cseqmet.len + 1;\n\t\tmemcpy(_tmx_proc_ptran->vbranch.s, svbranch.s, svbranch.len);\n\t\t_tmx_proc_ptran->vbranch.len = svbranch.len;\n\t\t_tmx_proc_ptran->vbranch.s[_tmx_proc_ptran->vbranch.len] = '\\0';\n\t} else {\n\t\t_tmx_proc_ptran->vbranch.s = NULL;\n\t\t_tmx_proc_ptran->vbranch.len = 0;\n\t}\n\n\tlock_get(&_tmx_ptran_table[slotid].lock);\n\tit = _tmx_ptran_table[slotid].plist;\n\ttmx_pretran_link_safe(slotid);\n\tfor(; it!=NULL; it=it->next) {\n\t\tif(_tmx_proc_ptran->hid != it->hid\n\t\t\t\t|| _tmx_proc_ptran->cseqmetid != it->cseqmetid\n\t\t\t\t|| _tmx_proc_ptran->callid.len != it->callid.len\n\t\t\t\t|| _tmx_proc_ptran->ftag.len != it->ftag.len\n\t\t\t\t|| _tmx_proc_ptran->cseqmet.len != it->cseqmet.len\n\t\t\t\t|| _tmx_proc_ptran->cseqnum.len != it->cseqnum.len)\n\t\t\tcontinue;\n\t\tif(_tmx_proc_ptran->vbranch.s != NULL && it->vbranch.s != NULL) {\n\t\t\tif(_tmx_proc_ptran->vbranch.len != it->vbranch.len)\n\t\t\t\tcontinue;\n\t\t\t/* shortcut - check last char in Via branch\n\t\t\t * - kamailio/ser adds there branch index => in case of paralel\n\t\t\t *   forking by previous hop, catch it here quickly */\n\t\t\tif(_tmx_proc_ptran->vbranch.s[it->vbranch.len-1]\n\t\t\t\t\t!= it->vbranch.s[it->vbranch.len-1])\n\t\t\t\tcontinue;\n\t\t\tif(memcmp(_tmx_proc_ptran->vbranch.s,\n\t\t\t\t\t\tit->vbranch.s, it->vbranch.len)!=0)\n\t\t\t\tcontinue;\n\t\t\t/* shall stop by matching magic cookie?\n\t\t\t *  if (vbr && vbr->value.s && vbr->value.len > MCOOKIE_LEN\n\t\t\t *  && memcmp(vbr->value.s, MCOOKIE, MCOOKIE_LEN)==0) {\n\t\t\t *  LM_DBG(\"rfc3261 cookie found in Via branch\\n\");\n\t\t\t *  }\n\t\t\t */\n\t\t}\n\t\tif(memcmp(_tmx_proc_ptran->callid.s,\n\t\t\t\t\tit->callid.s, it->callid.len)!=0\n\t\t\t\t|| memcmp(_tmx_proc_ptran->ftag.s,\n\t\t\t\t\tit->ftag.s, it->ftag.len)!=0\n\t\t\t\t|| memcmp(_tmx_proc_ptran->cseqnum.s,\n\t\t\t\t\tit->cseqnum.s, it->cseqnum.len)!=0)\n\t\t\tcontinue;\n\t\tif((it->cseqmetid==METHOD_OTHER || it->cseqmetid==METHOD_UNDEF)\n\t\t\t\t&& memcmp(_tmx_proc_ptran->cseqmet.s,\n\t\t\t\t\tit->cseqmet.s, it->cseqmet.len)!=0)\n\t\t\tcontinue;\n\t\tLM_DBG(\"matched another pre-transaction by pid %d for [%.*s]\\n\",\n\t\t\t\tit->pid, it->callid.len, it->callid.s);\n\t\tlock_release(&_tmx_ptran_table[slotid].lock);\n\t\treturn 1;\n\t}\n\tlock_release(&_tmx_ptran_table[slotid].lock);\n\treturn 0;\n}",
        "func": "int tmx_check_pretran(sip_msg_t *msg)\n{\n\tunsigned int chid;\n\tunsigned int slotid;\n\tint dsize;\n\tstruct via_param *vbr;\n\tstr scallid;\n\tstr scseqmet;\n\tstr scseqnum;\n\tstr sftag;\n\tstr svbranch = {NULL, 0};\n\tpretran_t *it;\n\n\tif(_tmx_ptran_table==NULL) {\n\t\tLM_ERR(\"pretran hash table not initialized yet\\n\");\n\t\treturn -1;\n\t}\n\tif(get_route_type()!=REQUEST_ROUTE) {\n\t\tLM_ERR(\"invalid usage - not in request route\\n\");\n\t\treturn -1;\n\t}\n\tif(msg->first_line.type!=SIP_REQUEST) {\n\t\tLM_ERR(\"invalid usage - not a sip request\\n\");\n\t\treturn -1;\n\t}\n\tif(parse_headers(msg, HDR_FROM_F|HDR_VIA1_F|HDR_CALLID_F|HDR_CSEQ_F, 0)<0) {\n\t\tLM_ERR(\"failed to parse required headers\\n\");\n\t\treturn -1;\n\t}\n\tif(msg->cseq==NULL || msg->cseq->parsed==NULL) {\n\t\tLM_ERR(\"failed to parse cseq headers\\n\");\n\t\treturn -1;\n\t}\n\tif(get_cseq(msg)->method_id==METHOD_ACK\n\t\t\t|| get_cseq(msg)->method_id==METHOD_CANCEL) {\n\t\tLM_DBG(\"no pre-transaction management for ACK or CANCEL\\n\");\n\t\treturn -1;\n\t}\n\tif (msg->via1==0) {\n\t\tLM_ERR(\"failed to get Via header\\n\");\n\t\treturn -1;\n\t}\n\tif (parse_from_header(msg)<0 || get_from(msg)->tag_value.len==0) {\n\t\tLM_ERR(\"failed to get From header\\n\");\n\t\treturn -1;\n\t}\n\tif (msg->callid==NULL || msg->callid->body.s==NULL) {\n\t\tLM_ERR(\"failed to parse callid headers\\n\");\n\t\treturn -1;\n\t}\n\n\tvbr = msg->via1->branch;\n\n\tscallid = msg->callid->body;\n\ttrim(&scallid);\n\tscseqmet = get_cseq(msg)->method;\n\ttrim(&scseqmet);\n\tscseqnum = get_cseq(msg)->number;\n\ttrim(&scseqnum);\n\tsftag = get_from(msg)->tag_value;\n\ttrim(&sftag);\n\n\tchid = get_hash1_raw(msg->callid->body.s, msg->callid->body.len);\n\tslotid = chid & (_tmx_ptran_size-1);\n\n\tif(unlikely(_tmx_proc_ptran == NULL)) {\n\t\t_tmx_proc_ptran = (pretran_t*)shm_malloc(sizeof(pretran_t));\n\t\tif(_tmx_proc_ptran == NULL) {\n\t\t\tLM_ERR(\"not enough memory for pretran structure\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tmemset(_tmx_proc_ptran, 0, sizeof(pretran_t));\n\t\t_tmx_proc_ptran->pid = my_pid();\n\t}\n\tdsize = scallid.len + scseqnum.len + scseqmet.len\n\t\t+ sftag.len + 4;\n\tif(likely(vbr!=NULL)) {\n\t\tsvbranch = vbr->value;\n\t\ttrim(&svbranch);\n\t\tdsize += svbranch.len + 1;\n\t}\n\tif(dsize<256) dsize = 256;\n\n\ttmx_pretran_unlink();\n\n\tif(dsize > _tmx_proc_ptran->dbuf.len) {\n\t\tif(_tmx_proc_ptran->dbuf.s) shm_free(_tmx_proc_ptran->dbuf.s);\n\t\t_tmx_proc_ptran->dbuf.s = (char*)shm_malloc(dsize);\n\t\tif(_tmx_proc_ptran->dbuf.s==NULL) {\n\t\t\tLM_ERR(\"not enough memory for pretran data\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\t_tmx_proc_ptran->dbuf.len = dsize;\n\t}\n\t_tmx_proc_ptran->hid = chid;\n\t_tmx_proc_ptran->cseqmetid = (get_cseq(msg))->method_id;\n\n\t_tmx_proc_ptran->callid.s = _tmx_proc_ptran->dbuf.s;\n\tmemcpy(_tmx_proc_ptran->callid.s, scallid.s, scallid.len);\n\t_tmx_proc_ptran->callid.len = scallid.len;\n\t_tmx_proc_ptran->callid.s[_tmx_proc_ptran->callid.len] = '\\0';\n\n\t_tmx_proc_ptran->ftag.s = _tmx_proc_ptran->callid.s\n\t\t+ _tmx_proc_ptran->callid.len + 1;\n\tmemcpy(_tmx_proc_ptran->ftag.s, sftag.s, sftag.len);\n\t_tmx_proc_ptran->ftag.len = sftag.len;\n\t_tmx_proc_ptran->ftag.s[_tmx_proc_ptran->ftag.len] = '\\0';\n\n\t_tmx_proc_ptran->cseqnum.s = _tmx_proc_ptran->ftag.s\n\t\t+ _tmx_proc_ptran->ftag.len + 1;\n\tmemcpy(_tmx_proc_ptran->cseqnum.s, scseqnum.s, scseqnum.len);\n\t_tmx_proc_ptran->cseqnum.len = scseqnum.len;\n\t_tmx_proc_ptran->cseqnum.s[_tmx_proc_ptran->cseqnum.len] = '\\0';\n\n\t_tmx_proc_ptran->cseqmet.s = _tmx_proc_ptran->cseqnum.s\n\t\t+ _tmx_proc_ptran->cseqnum.len + 1;\n\tmemcpy(_tmx_proc_ptran->cseqmet.s, scseqmet.s, scseqmet.len);\n\t_tmx_proc_ptran->cseqmet.len = scseqmet.len;\n\t_tmx_proc_ptran->cseqmet.s[_tmx_proc_ptran->cseqmet.len] = '\\0';\n\n\tif(likely(vbr!=NULL)) {\n\t\t_tmx_proc_ptran->vbranch.s = _tmx_proc_ptran->cseqmet.s\n\t\t\t+ _tmx_proc_ptran->cseqmet.len + 1;\n\t\tmemcpy(_tmx_proc_ptran->vbranch.s, svbranch.s, svbranch.len);\n\t\t_tmx_proc_ptran->vbranch.len = svbranch.len;\n\t\t_tmx_proc_ptran->vbranch.s[_tmx_proc_ptran->vbranch.len] = '\\0';\n\t} else {\n\t\t_tmx_proc_ptran->vbranch.s = NULL;\n\t\t_tmx_proc_ptran->vbranch.len = 0;\n\t}\n\n\tlock_get(&_tmx_ptran_table[slotid].lock);\n\tit = _tmx_ptran_table[slotid].plist;\n\ttmx_pretran_link_safe(slotid);\n\tfor(; it!=NULL; it=it->next) {\n\t\tif(_tmx_proc_ptran->hid != it->hid\n\t\t\t\t|| _tmx_proc_ptran->cseqmetid != it->cseqmetid\n\t\t\t\t|| _tmx_proc_ptran->callid.len != it->callid.len\n\t\t\t\t|| _tmx_proc_ptran->ftag.len != it->ftag.len\n\t\t\t\t|| _tmx_proc_ptran->cseqmet.len != it->cseqmet.len\n\t\t\t\t|| _tmx_proc_ptran->cseqnum.len != it->cseqnum.len)\n\t\t\tcontinue;\n\t\tif(_tmx_proc_ptran->vbranch.s != NULL && it->vbranch.s != NULL) {\n\t\t\tif(_tmx_proc_ptran->vbranch.len != it->vbranch.len)\n\t\t\t\tcontinue;\n\t\t\t/* shortcut - check last char in Via branch\n\t\t\t * - kamailio/ser adds there branch index => in case of paralel\n\t\t\t *   forking by previous hop, catch it here quickly */\n\t\t\tif(_tmx_proc_ptran->vbranch.s[it->vbranch.len-1]\n\t\t\t\t\t!= it->vbranch.s[it->vbranch.len-1])\n\t\t\t\tcontinue;\n\t\t\tif(memcmp(_tmx_proc_ptran->vbranch.s,\n\t\t\t\t\t\tit->vbranch.s, it->vbranch.len)!=0)\n\t\t\t\tcontinue;\n\t\t\t/* shall stop by matching magic cookie?\n\t\t\t *  if (vbr && vbr->value.s && vbr->value.len > MCOOKIE_LEN\n\t\t\t *  && memcmp(vbr->value.s, MCOOKIE, MCOOKIE_LEN)==0) {\n\t\t\t *  LM_DBG(\"rfc3261 cookie found in Via branch\\n\");\n\t\t\t *  }\n\t\t\t */\n\t\t}\n\t\tif(memcmp(_tmx_proc_ptran->callid.s,\n\t\t\t\t\tit->callid.s, it->callid.len)!=0\n\t\t\t\t|| memcmp(_tmx_proc_ptran->ftag.s,\n\t\t\t\t\tit->ftag.s, it->ftag.len)!=0\n\t\t\t\t|| memcmp(_tmx_proc_ptran->cseqnum.s,\n\t\t\t\t\tit->cseqnum.s, it->cseqnum.len)!=0)\n\t\t\tcontinue;\n\t\tif((it->cseqmetid==METHOD_OTHER || it->cseqmetid==METHOD_UNDEF)\n\t\t\t\t&& memcmp(_tmx_proc_ptran->cseqmet.s,\n\t\t\t\t\tit->cseqmet.s, it->cseqmet.len)!=0)\n\t\t\tcontinue;\n\t\tLM_DBG(\"matched another pre-transaction by pid %d for [%.*s]\\n\",\n\t\t\t\tit->pid, it->callid.len, it->callid.s);\n\t\tlock_release(&_tmx_ptran_table[slotid].lock);\n\t\treturn 1;\n\t}\n\tlock_release(&_tmx_ptran_table[slotid].lock);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -77,7 +77,7 @@\n \tif(likely(vbr!=NULL)) {\n \t\tsvbranch = vbr->value;\n \t\ttrim(&svbranch);\n-\t\tdsize += svbranch.len;\n+\t\tdsize += svbranch.len + 1;\n \t}\n \tif(dsize<256) dsize = 256;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tdsize += svbranch.len;"
            ],
            "added_lines": [
                "\t\tdsize += svbranch.len + 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-10062",
        "func_name": "zephyrproject-rtos/zephyr/packet_length_decode",
        "description": "An off-by-one error in the Zephyr project MQTT packet length decoder can result in memory corruption and possible remote code execution. NCC-ZEP-031 This issue affects: zephyrproject-rtos zephyr version 2.2.0 and later versions.",
        "git_url": "https://github.com/zephyrproject-rtos/zephyr/commit/11b7a37d9a0b438270421b224221d91929843de4",
        "commit_title": "net: mqtt: Fix packet length decryption",
        "commit_text": " The standard allows up to 4 bytes of packet length data, while current implementation parsed up to 5 bytes.  Add additional unit test, which verifies that error is reported in case of invalid packet length. ",
        "func_before": "int packet_length_decode(struct buf_ctx *buf, u32_t *length)\n{\n\tu8_t shift = 0U;\n\tu8_t bytes = 0U;\n\n\t*length = 0U;\n\tdo {\n\t\tif (bytes > MQTT_MAX_LENGTH_BYTES) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (buf->cur >= buf->end) {\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\t*length += ((u32_t)*(buf->cur) & MQTT_LENGTH_VALUE_MASK)\n\t\t\t\t\t\t\t\t<< shift;\n\t\tshift += MQTT_LENGTH_SHIFT;\n\t\tbytes++;\n\t} while ((*(buf->cur++) & MQTT_LENGTH_CONTINUATION_BIT) != 0U);\n\n\tMQTT_TRC(\"length:0x%08x\", *length);\n\n\treturn 0;\n}",
        "func": "static int packet_length_decode(struct buf_ctx *buf, u32_t *length)\n{\n\tu8_t shift = 0U;\n\tu8_t bytes = 0U;\n\n\t*length = 0U;\n\tdo {\n\t\tif (bytes >= MQTT_MAX_LENGTH_BYTES) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (buf->cur >= buf->end) {\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\t*length += ((u32_t)*(buf->cur) & MQTT_LENGTH_VALUE_MASK)\n\t\t\t\t\t\t\t\t<< shift;\n\t\tshift += MQTT_LENGTH_SHIFT;\n\t\tbytes++;\n\t} while ((*(buf->cur++) & MQTT_LENGTH_CONTINUATION_BIT) != 0U);\n\n\tif (*length > MQTT_MAX_PAYLOAD_SIZE) {\n\t\treturn -EINVAL;\n\t}\n\n\tMQTT_TRC(\"length:0x%08x\", *length);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,11 @@\n-int packet_length_decode(struct buf_ctx *buf, u32_t *length)\n+static int packet_length_decode(struct buf_ctx *buf, u32_t *length)\n {\n \tu8_t shift = 0U;\n \tu8_t bytes = 0U;\n \n \t*length = 0U;\n \tdo {\n-\t\tif (bytes > MQTT_MAX_LENGTH_BYTES) {\n+\t\tif (bytes >= MQTT_MAX_LENGTH_BYTES) {\n \t\t\treturn -EINVAL;\n \t\t}\n \n@@ -19,6 +19,10 @@\n \t\tbytes++;\n \t} while ((*(buf->cur++) & MQTT_LENGTH_CONTINUATION_BIT) != 0U);\n \n+\tif (*length > MQTT_MAX_PAYLOAD_SIZE) {\n+\t\treturn -EINVAL;\n+\t}\n+\n \tMQTT_TRC(\"length:0x%08x\", *length);\n \n \treturn 0;",
        "diff_line_info": {
            "deleted_lines": [
                "int packet_length_decode(struct buf_ctx *buf, u32_t *length)",
                "\t\tif (bytes > MQTT_MAX_LENGTH_BYTES) {"
            ],
            "added_lines": [
                "static int packet_length_decode(struct buf_ctx *buf, u32_t *length)",
                "\t\tif (bytes >= MQTT_MAX_LENGTH_BYTES) {",
                "\tif (*length > MQTT_MAX_PAYLOAD_SIZE) {",
                "\t\treturn -EINVAL;",
                "\t}",
                ""
            ]
        }
    }
]