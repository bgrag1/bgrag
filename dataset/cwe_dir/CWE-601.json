[
    {
        "cve_id": "CVE-2019-13038",
        "func_name": "Uninett/mod_auth_mellon/auth_mellon_dir_merge",
        "description": "mod_auth_mellon through 0.14.2 has an Open Redirect via the login?ReturnTo= substring, as demonstrated by omitting the // after http: in the target URL.",
        "git_url": "https://github.com/Uninett/mod_auth_mellon/commit/9d28908e28ef70a12196c215503fb0075e1fd7f3",
        "commit_title": "Add MellonRedirectDomains option.",
        "commit_text": " Limit the domains that we will redirect to after login / logout to a set of trusted domains. By default we only allow redirects to the current domain.  This change breaks backwards compatibility with any site that relies on redirects to separate domains.  Fixes #35",
        "func_before": "void *auth_mellon_dir_merge(apr_pool_t *p, void *base, void *add)\n{\n    am_dir_cfg_rec *base_cfg = (am_dir_cfg_rec *)base;\n    am_dir_cfg_rec *add_cfg = (am_dir_cfg_rec *)add;\n    am_dir_cfg_rec *new_cfg;\n\n    new_cfg = (am_dir_cfg_rec *)apr_palloc(p, sizeof(*new_cfg));\n\n    apr_pool_cleanup_register(p, new_cfg, auth_mellon_free_server,\n                              auth_mellon_free_server);\n\n\n    new_cfg->enable_mellon = (add_cfg->enable_mellon != am_enable_default ?\n                              add_cfg->enable_mellon :\n                              base_cfg->enable_mellon);\n\n\n    new_cfg->varname = (add_cfg->varname != default_cookie_name ?\n                        add_cfg->varname :\n                        base_cfg->varname);\n\n\n    new_cfg->secure = (add_cfg->secure != default_secure_cookie ?\n                        add_cfg->secure :\n                        base_cfg->secure);\n\n    new_cfg->merge_env_vars = (add_cfg->merge_env_vars != default_merge_env_vars ?\n                               add_cfg->merge_env_vars :\n                               base_cfg->merge_env_vars);\n\n    new_cfg->env_vars_index_start = (add_cfg->env_vars_index_start != default_env_vars_index_start ?\n                               add_cfg->env_vars_index_start :\n                               base_cfg->env_vars_index_start);\n\n    new_cfg->env_vars_count_in_n = (add_cfg->env_vars_count_in_n != default_env_vars_count_in_n ?\n                               add_cfg->env_vars_count_in_n :\n                               base_cfg->env_vars_count_in_n);\n\n    new_cfg->cookie_domain = (add_cfg->cookie_domain != NULL ?\n                        add_cfg->cookie_domain :\n                        base_cfg->cookie_domain);\n\n    new_cfg->cookie_path = (add_cfg->cookie_path != NULL ?\n                        add_cfg->cookie_path :\n                        base_cfg->cookie_path);\n\n    new_cfg->cond = apr_array_copy(p,\n                                   (!apr_is_empty_array(add_cfg->cond)) ?\n                                   add_cfg->cond :\n                                   base_cfg->cond);\n\n    new_cfg->envattr = apr_hash_copy(p,\n                                     (apr_hash_count(add_cfg->envattr) > 0) ?\n                                     add_cfg->envattr :\n                                     base_cfg->envattr);\n\n    new_cfg->userattr = (add_cfg->userattr != default_user_attribute ?\n                         add_cfg->userattr :\n                         base_cfg->userattr);\n\n    new_cfg->idpattr = (add_cfg->idpattr != NULL ?\n                        add_cfg->idpattr :\n                        base_cfg->idpattr);\n\n    new_cfg->dump_session = (add_cfg->dump_session != default_dump_session ?\n                             add_cfg->dump_session :\n                             base_cfg->dump_session);\n\n    new_cfg->dump_saml_response = \n        (add_cfg->dump_saml_response != default_dump_saml_response ?\n         add_cfg->dump_saml_response :\n         base_cfg->dump_saml_response);\n\n    new_cfg->endpoint_path = (\n        add_cfg->endpoint_path != default_endpoint_path ?\n        add_cfg->endpoint_path :\n        base_cfg->endpoint_path\n        );\n\n    new_cfg->session_length = (add_cfg->session_length != -1 ?\n                               add_cfg->session_length :\n                               base_cfg->session_length);\n\n    new_cfg->no_cookie_error_page = (add_cfg->no_cookie_error_page != NULL ?\n                                     add_cfg->no_cookie_error_page :\n                                     base_cfg->no_cookie_error_page);\n\n    new_cfg->no_success_error_page = (add_cfg->no_success_error_page != NULL ?\n                                     add_cfg->no_success_error_page :\n                                     base_cfg->no_success_error_page);\n\n\n    new_cfg->sp_metadata_file = (add_cfg->sp_metadata_file ?\n                                 add_cfg->sp_metadata_file :\n                                 base_cfg->sp_metadata_file);\n\n    new_cfg->sp_private_key_file = (add_cfg->sp_private_key_file ?\n                                    add_cfg->sp_private_key_file :\n                                    base_cfg->sp_private_key_file);\n\n    new_cfg->sp_cert_file = (add_cfg->sp_cert_file ?\n                             add_cfg->sp_cert_file :\n                             base_cfg->sp_cert_file);\n\n    new_cfg->idp_metadata = (add_cfg->idp_metadata->nelts ?\n                             add_cfg->idp_metadata :\n                             base_cfg->idp_metadata);\n\n    new_cfg->idp_public_key_file = (add_cfg->idp_public_key_file ?\n                                    add_cfg->idp_public_key_file :\n                                    base_cfg->idp_public_key_file);\n\n    new_cfg->idp_ca_file = (add_cfg->idp_ca_file ?\n                            add_cfg->idp_ca_file :\n                            base_cfg->idp_ca_file);\n\n    new_cfg->idp_ignore = add_cfg->idp_ignore != NULL ?\n                          add_cfg->idp_ignore :\n                          base_cfg->idp_ignore;\n\n    new_cfg->sp_entity_id = (add_cfg->sp_entity_id ?\n                             add_cfg->sp_entity_id :\n                             base_cfg->sp_entity_id);\n\n    new_cfg->sp_org_name = apr_hash_copy(p,\n                          (apr_hash_count(add_cfg->sp_org_name) > 0) ?\n                           add_cfg->sp_org_name : \n                           base_cfg->sp_org_name);\n\n    new_cfg->sp_org_display_name = apr_hash_copy(p,\n                          (apr_hash_count(add_cfg->sp_org_display_name) > 0) ?\n                           add_cfg->sp_org_display_name : \n                           base_cfg->sp_org_display_name);\n\n    new_cfg->sp_org_url = apr_hash_copy(p,\n                          (apr_hash_count(add_cfg->sp_org_url) > 0) ?\n                           add_cfg->sp_org_url : \n                           base_cfg->sp_org_url);\n\n    new_cfg->login_path = (add_cfg->login_path != default_login_path ?\n                           add_cfg->login_path :\n                           base_cfg->login_path);\n\n    new_cfg->discovery_url = (add_cfg->discovery_url ?\n                              add_cfg->discovery_url :\n                              base_cfg->discovery_url);\n\n    new_cfg->probe_discovery_timeout = \n                           (add_cfg->probe_discovery_timeout != -1 ?\n                            add_cfg->probe_discovery_timeout :\n                            base_cfg->probe_discovery_timeout);\n\n    new_cfg->probe_discovery_idp = apr_table_copy(p,\n                           (!apr_is_empty_table(add_cfg->probe_discovery_idp)) ?\n                            add_cfg->probe_discovery_idp : \n                            base_cfg->probe_discovery_idp);\n\n\n    if (cfg_can_inherit_lasso_server(add_cfg)) {\n        new_cfg->inherit_server_from = base_cfg->inherit_server_from;\n    } else {\n        apr_thread_mutex_create(&new_cfg->server_mutex,\n                                APR_THREAD_MUTEX_DEFAULT, p);\n        new_cfg->inherit_server_from = new_cfg;\n    }\n\n    new_cfg->server = NULL;\n\n    new_cfg->authn_context_class_ref = (add_cfg->authn_context_class_ref->nelts ?\n                             add_cfg->authn_context_class_ref :\n                             base_cfg->authn_context_class_ref);\n\n    new_cfg->do_not_verify_logout_signature = apr_hash_copy(p, \n                             (apr_hash_count(add_cfg->do_not_verify_logout_signature) > 0) ?\n                             add_cfg->do_not_verify_logout_signature :\n                             base_cfg->do_not_verify_logout_signature);\n\n    new_cfg->subject_confirmation_data_address_check =\n        CFG_MERGE(add_cfg, base_cfg, subject_confirmation_data_address_check);\n    new_cfg->post_replay = CFG_MERGE(add_cfg, base_cfg, post_replay);\n\n    new_cfg->ecp_send_idplist = CFG_MERGE(add_cfg, base_cfg, ecp_send_idplist);\n\n    return new_cfg;\n}",
        "func": "void *auth_mellon_dir_merge(apr_pool_t *p, void *base, void *add)\n{\n    am_dir_cfg_rec *base_cfg = (am_dir_cfg_rec *)base;\n    am_dir_cfg_rec *add_cfg = (am_dir_cfg_rec *)add;\n    am_dir_cfg_rec *new_cfg;\n\n    new_cfg = (am_dir_cfg_rec *)apr_palloc(p, sizeof(*new_cfg));\n\n    apr_pool_cleanup_register(p, new_cfg, auth_mellon_free_server,\n                              auth_mellon_free_server);\n\n\n    new_cfg->enable_mellon = (add_cfg->enable_mellon != am_enable_default ?\n                              add_cfg->enable_mellon :\n                              base_cfg->enable_mellon);\n\n\n    new_cfg->varname = (add_cfg->varname != default_cookie_name ?\n                        add_cfg->varname :\n                        base_cfg->varname);\n\n\n    new_cfg->secure = (add_cfg->secure != default_secure_cookie ?\n                        add_cfg->secure :\n                        base_cfg->secure);\n\n    new_cfg->merge_env_vars = (add_cfg->merge_env_vars != default_merge_env_vars ?\n                               add_cfg->merge_env_vars :\n                               base_cfg->merge_env_vars);\n\n    new_cfg->env_vars_index_start = (add_cfg->env_vars_index_start != default_env_vars_index_start ?\n                               add_cfg->env_vars_index_start :\n                               base_cfg->env_vars_index_start);\n\n    new_cfg->env_vars_count_in_n = (add_cfg->env_vars_count_in_n != default_env_vars_count_in_n ?\n                               add_cfg->env_vars_count_in_n :\n                               base_cfg->env_vars_count_in_n);\n\n    new_cfg->cookie_domain = (add_cfg->cookie_domain != NULL ?\n                        add_cfg->cookie_domain :\n                        base_cfg->cookie_domain);\n\n    new_cfg->cookie_path = (add_cfg->cookie_path != NULL ?\n                        add_cfg->cookie_path :\n                        base_cfg->cookie_path);\n\n    new_cfg->cond = apr_array_copy(p,\n                                   (!apr_is_empty_array(add_cfg->cond)) ?\n                                   add_cfg->cond :\n                                   base_cfg->cond);\n\n    new_cfg->envattr = apr_hash_copy(p,\n                                     (apr_hash_count(add_cfg->envattr) > 0) ?\n                                     add_cfg->envattr :\n                                     base_cfg->envattr);\n\n    new_cfg->userattr = (add_cfg->userattr != default_user_attribute ?\n                         add_cfg->userattr :\n                         base_cfg->userattr);\n\n    new_cfg->idpattr = (add_cfg->idpattr != NULL ?\n                        add_cfg->idpattr :\n                        base_cfg->idpattr);\n\n    new_cfg->dump_session = (add_cfg->dump_session != default_dump_session ?\n                             add_cfg->dump_session :\n                             base_cfg->dump_session);\n\n    new_cfg->dump_saml_response = \n        (add_cfg->dump_saml_response != default_dump_saml_response ?\n         add_cfg->dump_saml_response :\n         base_cfg->dump_saml_response);\n\n    new_cfg->endpoint_path = (\n        add_cfg->endpoint_path != default_endpoint_path ?\n        add_cfg->endpoint_path :\n        base_cfg->endpoint_path\n        );\n\n    new_cfg->session_length = (add_cfg->session_length != -1 ?\n                               add_cfg->session_length :\n                               base_cfg->session_length);\n\n    new_cfg->no_cookie_error_page = (add_cfg->no_cookie_error_page != NULL ?\n                                     add_cfg->no_cookie_error_page :\n                                     base_cfg->no_cookie_error_page);\n\n    new_cfg->no_success_error_page = (add_cfg->no_success_error_page != NULL ?\n                                     add_cfg->no_success_error_page :\n                                     base_cfg->no_success_error_page);\n\n\n    new_cfg->sp_metadata_file = (add_cfg->sp_metadata_file ?\n                                 add_cfg->sp_metadata_file :\n                                 base_cfg->sp_metadata_file);\n\n    new_cfg->sp_private_key_file = (add_cfg->sp_private_key_file ?\n                                    add_cfg->sp_private_key_file :\n                                    base_cfg->sp_private_key_file);\n\n    new_cfg->sp_cert_file = (add_cfg->sp_cert_file ?\n                             add_cfg->sp_cert_file :\n                             base_cfg->sp_cert_file);\n\n    new_cfg->idp_metadata = (add_cfg->idp_metadata->nelts ?\n                             add_cfg->idp_metadata :\n                             base_cfg->idp_metadata);\n\n    new_cfg->idp_public_key_file = (add_cfg->idp_public_key_file ?\n                                    add_cfg->idp_public_key_file :\n                                    base_cfg->idp_public_key_file);\n\n    new_cfg->idp_ca_file = (add_cfg->idp_ca_file ?\n                            add_cfg->idp_ca_file :\n                            base_cfg->idp_ca_file);\n\n    new_cfg->idp_ignore = add_cfg->idp_ignore != NULL ?\n                          add_cfg->idp_ignore :\n                          base_cfg->idp_ignore;\n\n    new_cfg->sp_entity_id = (add_cfg->sp_entity_id ?\n                             add_cfg->sp_entity_id :\n                             base_cfg->sp_entity_id);\n\n    new_cfg->sp_org_name = apr_hash_copy(p,\n                          (apr_hash_count(add_cfg->sp_org_name) > 0) ?\n                           add_cfg->sp_org_name : \n                           base_cfg->sp_org_name);\n\n    new_cfg->sp_org_display_name = apr_hash_copy(p,\n                          (apr_hash_count(add_cfg->sp_org_display_name) > 0) ?\n                           add_cfg->sp_org_display_name : \n                           base_cfg->sp_org_display_name);\n\n    new_cfg->sp_org_url = apr_hash_copy(p,\n                          (apr_hash_count(add_cfg->sp_org_url) > 0) ?\n                           add_cfg->sp_org_url : \n                           base_cfg->sp_org_url);\n\n    new_cfg->login_path = (add_cfg->login_path != default_login_path ?\n                           add_cfg->login_path :\n                           base_cfg->login_path);\n\n    new_cfg->discovery_url = (add_cfg->discovery_url ?\n                              add_cfg->discovery_url :\n                              base_cfg->discovery_url);\n\n    new_cfg->probe_discovery_timeout = \n                           (add_cfg->probe_discovery_timeout != -1 ?\n                            add_cfg->probe_discovery_timeout :\n                            base_cfg->probe_discovery_timeout);\n\n    new_cfg->probe_discovery_idp = apr_table_copy(p,\n                           (!apr_is_empty_table(add_cfg->probe_discovery_idp)) ?\n                            add_cfg->probe_discovery_idp : \n                            base_cfg->probe_discovery_idp);\n\n\n    if (cfg_can_inherit_lasso_server(add_cfg)) {\n        new_cfg->inherit_server_from = base_cfg->inherit_server_from;\n    } else {\n        apr_thread_mutex_create(&new_cfg->server_mutex,\n                                APR_THREAD_MUTEX_DEFAULT, p);\n        new_cfg->inherit_server_from = new_cfg;\n    }\n\n    new_cfg->server = NULL;\n\n    new_cfg->authn_context_class_ref = (add_cfg->authn_context_class_ref->nelts ?\n                             add_cfg->authn_context_class_ref :\n                             base_cfg->authn_context_class_ref);\n\n    new_cfg->do_not_verify_logout_signature = apr_hash_copy(p, \n                             (apr_hash_count(add_cfg->do_not_verify_logout_signature) > 0) ?\n                             add_cfg->do_not_verify_logout_signature :\n                             base_cfg->do_not_verify_logout_signature);\n\n    new_cfg->subject_confirmation_data_address_check =\n        CFG_MERGE(add_cfg, base_cfg, subject_confirmation_data_address_check);\n    new_cfg->post_replay = CFG_MERGE(add_cfg, base_cfg, post_replay);\n\n    new_cfg->ecp_send_idplist = CFG_MERGE(add_cfg, base_cfg, ecp_send_idplist);\n\n    new_cfg->redirect_domains =\n        (add_cfg->redirect_domains != default_redirect_domains ?\n         add_cfg->redirect_domains :\n         base_cfg->redirect_domains);\n\n    return new_cfg;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -181,5 +181,10 @@\n \n     new_cfg->ecp_send_idplist = CFG_MERGE(add_cfg, base_cfg, ecp_send_idplist);\n \n+    new_cfg->redirect_domains =\n+        (add_cfg->redirect_domains != default_redirect_domains ?\n+         add_cfg->redirect_domains :\n+         base_cfg->redirect_domains);\n+\n     return new_cfg;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    new_cfg->redirect_domains =",
                "        (add_cfg->redirect_domains != default_redirect_domains ?",
                "         add_cfg->redirect_domains :",
                "         base_cfg->redirect_domains);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13038",
        "func_name": "Uninett/mod_auth_mellon/auth_mellon_dir_config",
        "description": "mod_auth_mellon through 0.14.2 has an Open Redirect via the login?ReturnTo= substring, as demonstrated by omitting the // after http: in the target URL.",
        "git_url": "https://github.com/Uninett/mod_auth_mellon/commit/9d28908e28ef70a12196c215503fb0075e1fd7f3",
        "commit_title": "Add MellonRedirectDomains option.",
        "commit_text": " Limit the domains that we will redirect to after login / logout to a set of trusted domains. By default we only allow redirects to the current domain.  This change breaks backwards compatibility with any site that relies on redirects to separate domains.  Fixes #35",
        "func_before": "void *auth_mellon_dir_config(apr_pool_t *p, char *d)\n{\n    am_dir_cfg_rec *dir = apr_palloc(p, sizeof(*dir));\n\n    apr_pool_cleanup_register(p, dir, auth_mellon_free_server,\n                              auth_mellon_free_server);\n\n    dir->enable_mellon = am_enable_default;\n\n    dir->varname = default_cookie_name;\n    dir->secure = default_secure_cookie;\n    dir->merge_env_vars = default_merge_env_vars;\n    dir->env_vars_index_start = default_env_vars_index_start;\n    dir->env_vars_count_in_n = default_env_vars_count_in_n;\n    dir->cond = apr_array_make(p, 0, sizeof(am_cond_t));\n    dir->cookie_domain = NULL;\n    dir->cookie_path = NULL;\n    dir->envattr   = apr_hash_make(p);\n    dir->userattr  = default_user_attribute;\n    dir->idpattr  = NULL;\n    dir->dump_session = default_dump_session;\n    dir->dump_saml_response = default_dump_saml_response;\n\n    dir->endpoint_path = default_endpoint_path;\n\n    dir->session_length = -1; /* -1 means use default. */\n\n    dir->no_cookie_error_page = NULL;\n    dir->no_success_error_page = NULL;\n\n    dir->sp_metadata_file = NULL;\n    dir->sp_private_key_file = NULL;\n    dir->sp_cert_file = NULL;\n    dir->idp_metadata = apr_array_make(p, 0, sizeof(am_metadata_t));\n    dir->idp_public_key_file = NULL;\n    dir->idp_ca_file = NULL;\n    dir->idp_ignore = NULL;\n    dir->login_path = default_login_path;\n    dir->discovery_url = NULL;\n    dir->probe_discovery_timeout = -1; /* -1 means no probe discovery */\n    dir->probe_discovery_idp = apr_table_make(p, 0);\n\n    dir->sp_entity_id = NULL;\n    dir->sp_org_name = apr_hash_make(p);\n    dir->sp_org_display_name = apr_hash_make(p);\n    dir->sp_org_url = apr_hash_make(p);\n\n    apr_thread_mutex_create(&dir->server_mutex, APR_THREAD_MUTEX_DEFAULT, p);\n    dir->inherit_server_from = dir;\n    dir->server = NULL;\n    dir->authn_context_class_ref = apr_array_make(p, 0, sizeof(char *));\n    dir->subject_confirmation_data_address_check = inherit_subject_confirmation_data_address_check;\n    dir->do_not_verify_logout_signature = apr_hash_make(p);\n    dir->post_replay = inherit_post_replay;\n\n    dir->ecp_send_idplist = inherit_ecp_send_idplist;\n\n    return dir;\n}",
        "func": "void *auth_mellon_dir_config(apr_pool_t *p, char *d)\n{\n    am_dir_cfg_rec *dir = apr_palloc(p, sizeof(*dir));\n\n    apr_pool_cleanup_register(p, dir, auth_mellon_free_server,\n                              auth_mellon_free_server);\n\n    dir->enable_mellon = am_enable_default;\n\n    dir->varname = default_cookie_name;\n    dir->secure = default_secure_cookie;\n    dir->merge_env_vars = default_merge_env_vars;\n    dir->env_vars_index_start = default_env_vars_index_start;\n    dir->env_vars_count_in_n = default_env_vars_count_in_n;\n    dir->cond = apr_array_make(p, 0, sizeof(am_cond_t));\n    dir->cookie_domain = NULL;\n    dir->cookie_path = NULL;\n    dir->envattr   = apr_hash_make(p);\n    dir->userattr  = default_user_attribute;\n    dir->idpattr  = NULL;\n    dir->dump_session = default_dump_session;\n    dir->dump_saml_response = default_dump_saml_response;\n\n    dir->endpoint_path = default_endpoint_path;\n\n    dir->session_length = -1; /* -1 means use default. */\n\n    dir->no_cookie_error_page = NULL;\n    dir->no_success_error_page = NULL;\n\n    dir->sp_metadata_file = NULL;\n    dir->sp_private_key_file = NULL;\n    dir->sp_cert_file = NULL;\n    dir->idp_metadata = apr_array_make(p, 0, sizeof(am_metadata_t));\n    dir->idp_public_key_file = NULL;\n    dir->idp_ca_file = NULL;\n    dir->idp_ignore = NULL;\n    dir->login_path = default_login_path;\n    dir->discovery_url = NULL;\n    dir->probe_discovery_timeout = -1; /* -1 means no probe discovery */\n    dir->probe_discovery_idp = apr_table_make(p, 0);\n\n    dir->sp_entity_id = NULL;\n    dir->sp_org_name = apr_hash_make(p);\n    dir->sp_org_display_name = apr_hash_make(p);\n    dir->sp_org_url = apr_hash_make(p);\n\n    apr_thread_mutex_create(&dir->server_mutex, APR_THREAD_MUTEX_DEFAULT, p);\n    dir->inherit_server_from = dir;\n    dir->server = NULL;\n    dir->authn_context_class_ref = apr_array_make(p, 0, sizeof(char *));\n    dir->subject_confirmation_data_address_check = inherit_subject_confirmation_data_address_check;\n    dir->do_not_verify_logout_signature = apr_hash_make(p);\n    dir->post_replay = inherit_post_replay;\n    dir->redirect_domains = default_redirect_domains;\n\n    dir->ecp_send_idplist = inherit_ecp_send_idplist;\n\n    return dir;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -52,6 +52,7 @@\n     dir->subject_confirmation_data_address_check = inherit_subject_confirmation_data_address_check;\n     dir->do_not_verify_logout_signature = apr_hash_make(p);\n     dir->post_replay = inherit_post_replay;\n+    dir->redirect_domains = default_redirect_domains;\n \n     dir->ecp_send_idplist = inherit_ecp_send_idplist;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    dir->redirect_domains = default_redirect_domains;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13038",
        "func_name": "Uninett/mod_auth_mellon/am_handle_reply_common",
        "description": "mod_auth_mellon through 0.14.2 has an Open Redirect via the login?ReturnTo= substring, as demonstrated by omitting the // after http: in the target URL.",
        "git_url": "https://github.com/Uninett/mod_auth_mellon/commit/9d28908e28ef70a12196c215503fb0075e1fd7f3",
        "commit_title": "Add MellonRedirectDomains option.",
        "commit_text": " Limit the domains that we will redirect to after login / logout to a set of trusted domains. By default we only allow redirects to the current domain.  This change breaks backwards compatibility with any site that relies on redirects to separate domains.  Fixes #35",
        "func_before": "static int am_handle_reply_common(request_rec *r, LassoLogin *login,\n                                  char *relay_state, char *saml_response,\n                                  bool is_paos)\n{\n    char *url;\n    char *chr;\n    const char *name_id;\n    LassoSamlp2Response *response;\n    LassoSaml2Assertion *assertion;\n    const char *in_response_to;\n    am_dir_cfg_rec *dir_cfg;\n    am_cache_entry_t *session;\n    int rc;\n    const char *idp;\n\n    url = am_reconstruct_url(r);\n    chr = strchr(url, '?');\n    if (! chr) {\n        chr = strchr(url, ';');\n    }\n    if (chr) {\n        *chr = '\\0';\n    }\n\n\n    dir_cfg = am_get_dir_cfg(r);\n\n    if(LASSO_PROFILE(login)->nameIdentifier == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"No acceptable name identifier found in\"\n                      \" SAML 2.0 response.\");\n        lasso_login_destroy(login);\n        return HTTP_BAD_REQUEST;\n    }\n\n    name_id = LASSO_SAML2_NAME_ID(LASSO_PROFILE(login)->nameIdentifier)\n        ->content;\n\n    response = LASSO_SAMLP2_RESPONSE(LASSO_PROFILE(login)->response);\n\n    if (response->parent.Destination) {\n        if (strcmp(response->parent.Destination, url)) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"Invalid Destination on Response. Should be: %s\",\n                          url);\n            lasso_login_destroy(login);\n            return HTTP_BAD_REQUEST;\n        }\n    }\n\n    if (g_list_length(response->Assertion) == 0) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"No Assertion in response.\");\n        lasso_login_destroy(login);\n        return HTTP_BAD_REQUEST;\n    }\n    if (g_list_length(response->Assertion) > 1) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"More than one Assertion in response.\");\n        lasso_login_destroy(login);\n        return HTTP_BAD_REQUEST;\n    }\n    assertion = g_list_first(response->Assertion)->data;\n    if (!LASSO_IS_SAML2_ASSERTION(assertion)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Wrong type of Assertion node.\");\n        lasso_login_destroy(login);\n        return HTTP_BAD_REQUEST;\n    }\n\n    rc = am_validate_subject(r, assertion, url);\n    if (rc != OK) {\n        lasso_login_destroy(login);\n        return rc;\n    }\n\n    rc = am_validate_conditions(r, assertion,\n        LASSO_PROVIDER(LASSO_PROFILE(login)->server)->ProviderID);\n\n    if (rc != OK) {\n        lasso_login_destroy(login);\n        return rc;\n    }\n\n    in_response_to = response->parent.InResponseTo;\n\n\n    if (!is_paos) {\n        if(in_response_to != NULL) {\n            /* This is SP-initiated login. Check that we have a cookie. */\n            if(am_cookie_get(r) == NULL) {\n                /* Missing cookie. */\n                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,\n                              \"User has disabled cookies, or has lost\"\n                              \" the cookie before returning from the SAML2\"\n                              \" login server.\");\n                if(dir_cfg->no_cookie_error_page != NULL) {\n                    apr_table_setn(r->headers_out, \"Location\",\n                                   dir_cfg->no_cookie_error_page);\n                    lasso_login_destroy(login);\n                    return HTTP_SEE_OTHER;\n                } else {\n                    /* Return 400 Bad Request when the user hasn't set a\n                     * no-cookie error page.\n                     */\n                    lasso_login_destroy(login);\n                    return HTTP_BAD_REQUEST;\n                }\n            }\n        }\n    }\n\n    /* Check AuthnContextClassRef */\n    rc = am_validate_authn_context_class_ref(r, assertion);\n    if (rc != OK) {\n        lasso_login_destroy(login);\n        return rc;\n    }\n\n    /* Create a new session. */\n    session = am_new_request_session(r);\n    if(session == NULL) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,\n                    \"am_new_request_session() failed\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    rc = add_attributes(session, r, name_id, assertion);\n    if(rc != OK) {\n        am_release_request_session(r, session);\n        lasso_login_destroy(login);\n        return rc;\n    }\n\n    /* If requested, save the IdP ProviderId */\n    if(dir_cfg->idpattr != NULL) {\n        idp = LASSO_PROFILE(login)->remote_providerID;\n        if(idp != NULL) {\n            rc = am_cache_env_append(session, dir_cfg->idpattr, idp);\n            if(rc != OK) {\n                am_release_request_session(r, session);\n                lasso_login_destroy(login);\n                return rc;\n            }\n        }\n    }\n\n    rc = lasso_login_accept_sso(login);\n    if(rc < 0) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Unable to accept SSO message.\"\n                      \" Lasso error: [%i] %s\", rc, lasso_strerror(rc));\n        am_release_request_session(r, session);\n        lasso_login_destroy(login);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n\n    /* Save the profile state. */\n    rc = am_save_lasso_profile_state(r, session, LASSO_PROFILE(login),\n                                     saml_response);\n    if(rc != OK) {\n        am_release_request_session(r, session);\n        lasso_login_destroy(login);\n        return rc;\n    }\n\n    /* Mark user as logged in. */\n    session->logged_in = 1;\n\n    am_release_request_session(r, session);\n    lasso_login_destroy(login);\n\n\n    /* No RelayState - we don't know what to do. Use default login path. */\n    if(relay_state == NULL || strlen(relay_state) == 0) {\n       dir_cfg = am_get_dir_cfg(r);\n       apr_table_setn(r->headers_out, \"Location\", dir_cfg->login_path);\n       return HTTP_SEE_OTHER;\n    }\n\n    rc = am_urldecode(relay_state);\n    if (rc != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r,\n                      \"Could not urldecode RelayState value.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    /* Check for bad characters in RelayState. */\n    rc = am_check_url(r, relay_state);\n    if (rc != OK) {\n        return rc;\n    }\n\n    apr_table_setn(r->headers_out, \"Location\",\n                   relay_state);\n\n    /* HTTP_SEE_OTHER should be a redirect where the browser doesn't repeat\n     * the POST data to the new page.\n     */\n    return HTTP_SEE_OTHER;\n}",
        "func": "static int am_handle_reply_common(request_rec *r, LassoLogin *login,\n                                  char *relay_state, char *saml_response,\n                                  bool is_paos)\n{\n    char *url;\n    char *chr;\n    const char *name_id;\n    LassoSamlp2Response *response;\n    LassoSaml2Assertion *assertion;\n    const char *in_response_to;\n    am_dir_cfg_rec *dir_cfg;\n    am_cache_entry_t *session;\n    int rc;\n    const char *idp;\n\n    url = am_reconstruct_url(r);\n    chr = strchr(url, '?');\n    if (! chr) {\n        chr = strchr(url, ';');\n    }\n    if (chr) {\n        *chr = '\\0';\n    }\n\n\n    dir_cfg = am_get_dir_cfg(r);\n\n    if(LASSO_PROFILE(login)->nameIdentifier == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"No acceptable name identifier found in\"\n                      \" SAML 2.0 response.\");\n        lasso_login_destroy(login);\n        return HTTP_BAD_REQUEST;\n    }\n\n    name_id = LASSO_SAML2_NAME_ID(LASSO_PROFILE(login)->nameIdentifier)\n        ->content;\n\n    response = LASSO_SAMLP2_RESPONSE(LASSO_PROFILE(login)->response);\n\n    if (response->parent.Destination) {\n        if (strcmp(response->parent.Destination, url)) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"Invalid Destination on Response. Should be: %s\",\n                          url);\n            lasso_login_destroy(login);\n            return HTTP_BAD_REQUEST;\n        }\n    }\n\n    if (g_list_length(response->Assertion) == 0) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"No Assertion in response.\");\n        lasso_login_destroy(login);\n        return HTTP_BAD_REQUEST;\n    }\n    if (g_list_length(response->Assertion) > 1) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"More than one Assertion in response.\");\n        lasso_login_destroy(login);\n        return HTTP_BAD_REQUEST;\n    }\n    assertion = g_list_first(response->Assertion)->data;\n    if (!LASSO_IS_SAML2_ASSERTION(assertion)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Wrong type of Assertion node.\");\n        lasso_login_destroy(login);\n        return HTTP_BAD_REQUEST;\n    }\n\n    rc = am_validate_subject(r, assertion, url);\n    if (rc != OK) {\n        lasso_login_destroy(login);\n        return rc;\n    }\n\n    rc = am_validate_conditions(r, assertion,\n        LASSO_PROVIDER(LASSO_PROFILE(login)->server)->ProviderID);\n\n    if (rc != OK) {\n        lasso_login_destroy(login);\n        return rc;\n    }\n\n    in_response_to = response->parent.InResponseTo;\n\n\n    if (!is_paos) {\n        if(in_response_to != NULL) {\n            /* This is SP-initiated login. Check that we have a cookie. */\n            if(am_cookie_get(r) == NULL) {\n                /* Missing cookie. */\n                ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,\n                              \"User has disabled cookies, or has lost\"\n                              \" the cookie before returning from the SAML2\"\n                              \" login server.\");\n                if(dir_cfg->no_cookie_error_page != NULL) {\n                    apr_table_setn(r->headers_out, \"Location\",\n                                   dir_cfg->no_cookie_error_page);\n                    lasso_login_destroy(login);\n                    return HTTP_SEE_OTHER;\n                } else {\n                    /* Return 400 Bad Request when the user hasn't set a\n                     * no-cookie error page.\n                     */\n                    lasso_login_destroy(login);\n                    return HTTP_BAD_REQUEST;\n                }\n            }\n        }\n    }\n\n    /* Check AuthnContextClassRef */\n    rc = am_validate_authn_context_class_ref(r, assertion);\n    if (rc != OK) {\n        lasso_login_destroy(login);\n        return rc;\n    }\n\n    /* Create a new session. */\n    session = am_new_request_session(r);\n    if(session == NULL) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, 0, NULL,\n                    \"am_new_request_session() failed\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    rc = add_attributes(session, r, name_id, assertion);\n    if(rc != OK) {\n        am_release_request_session(r, session);\n        lasso_login_destroy(login);\n        return rc;\n    }\n\n    /* If requested, save the IdP ProviderId */\n    if(dir_cfg->idpattr != NULL) {\n        idp = LASSO_PROFILE(login)->remote_providerID;\n        if(idp != NULL) {\n            rc = am_cache_env_append(session, dir_cfg->idpattr, idp);\n            if(rc != OK) {\n                am_release_request_session(r, session);\n                lasso_login_destroy(login);\n                return rc;\n            }\n        }\n    }\n\n    rc = lasso_login_accept_sso(login);\n    if(rc < 0) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Unable to accept SSO message.\"\n                      \" Lasso error: [%i] %s\", rc, lasso_strerror(rc));\n        am_release_request_session(r, session);\n        lasso_login_destroy(login);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n\n    /* Save the profile state. */\n    rc = am_save_lasso_profile_state(r, session, LASSO_PROFILE(login),\n                                     saml_response);\n    if(rc != OK) {\n        am_release_request_session(r, session);\n        lasso_login_destroy(login);\n        return rc;\n    }\n\n    /* Mark user as logged in. */\n    session->logged_in = 1;\n\n    am_release_request_session(r, session);\n    lasso_login_destroy(login);\n\n\n    /* No RelayState - we don't know what to do. Use default login path. */\n    if(relay_state == NULL || strlen(relay_state) == 0) {\n       dir_cfg = am_get_dir_cfg(r);\n       apr_table_setn(r->headers_out, \"Location\", dir_cfg->login_path);\n       return HTTP_SEE_OTHER;\n    }\n\n    rc = am_urldecode(relay_state);\n    if (rc != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r,\n                      \"Could not urldecode RelayState value.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    /* Check for bad characters in RelayState. */\n    rc = am_check_url(r, relay_state);\n    if (rc != OK) {\n        return rc;\n    }\n\n    rc = am_validate_redirect_url(r, relay_state);\n    if (rc != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Invalid target domain in logout response RelayState parameter.\");\n        return rc;\n    }\n\n    apr_table_setn(r->headers_out, \"Location\",\n                   relay_state);\n\n    /* HTTP_SEE_OTHER should be a redirect where the browser doesn't repeat\n     * the POST data to the new page.\n     */\n    return HTTP_SEE_OTHER;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -192,6 +192,13 @@\n         return rc;\n     }\n \n+    rc = am_validate_redirect_url(r, relay_state);\n+    if (rc != OK) {\n+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n+                      \"Invalid target domain in logout response RelayState parameter.\");\n+        return rc;\n+    }\n+\n     apr_table_setn(r->headers_out, \"Location\",\n                    relay_state);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    rc = am_validate_redirect_url(r, relay_state);",
                "    if (rc != OK) {",
                "        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,",
                "                      \"Invalid target domain in logout response RelayState parameter.\");",
                "        return rc;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13038",
        "func_name": "Uninett/mod_auth_mellon/am_handle_logout_response",
        "description": "mod_auth_mellon through 0.14.2 has an Open Redirect via the login?ReturnTo= substring, as demonstrated by omitting the // after http: in the target URL.",
        "git_url": "https://github.com/Uninett/mod_auth_mellon/commit/9d28908e28ef70a12196c215503fb0075e1fd7f3",
        "commit_title": "Add MellonRedirectDomains option.",
        "commit_text": " Limit the domains that we will redirect to after login / logout to a set of trusted domains. By default we only allow redirects to the current domain.  This change breaks backwards compatibility with any site that relies on redirects to separate domains.  Fixes #35",
        "func_before": "static int am_handle_logout_response(request_rec *r, LassoLogout *logout)\n{\n    gint res;\n    int rc;\n    am_cache_entry_t *session;\n    char *return_to;\n    am_dir_cfg_rec *cfg = am_get_dir_cfg(r);\n\n    res = lasso_logout_process_response_msg(logout, r->args);\n#ifdef HAVE_lasso_profile_set_signature_verify_hint\n    if(res != 0 && res != LASSO_DS_ERROR_SIGNATURE_NOT_FOUND) {\n        if (apr_hash_get(cfg->do_not_verify_logout_signature,\n                         logout->parent.remote_providerID,\n                         APR_HASH_KEY_STRING)) {\n            lasso_profile_set_signature_verify_hint(&logout->parent,\n                LASSO_PROFILE_SIGNATURE_VERIFY_HINT_IGNORE);\n            res = lasso_logout_process_response_msg(logout, r->args);\n        }\n    }\n#endif\n    if(res != 0) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Unable to process logout response.\"\n                      \" Lasso error: [%i] %s\", res, lasso_strerror(res));\n\n        lasso_logout_destroy(logout);\n        return HTTP_BAD_REQUEST;\n    }\n\n    lasso_logout_destroy(logout);\n\n    /* Delete the session. */\n    session = am_get_request_session(r);\n    if(session != NULL) {\n        am_delete_request_session(r, session);\n    }\n\n    return_to = am_extract_query_parameter(r->pool, r->args, \"RelayState\");\n    if(return_to == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"No RelayState parameter to logout response handler.\"\n                      \" It is possible that your IdP doesn't support the\"\n                      \" RelayState parameter.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    rc = am_urldecode(return_to);\n    if(rc != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r,\n                      \"Could not urldecode RelayState value in logout\"\n                      \" response.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    /* Check for bad characters in RelayState. */\n    rc = am_check_url(r, return_to);\n    if (rc != OK) {\n        return rc;\n    }\n\n    apr_table_setn(r->headers_out, \"Location\", return_to);\n    return HTTP_SEE_OTHER;\n}",
        "func": "static int am_handle_logout_response(request_rec *r, LassoLogout *logout)\n{\n    gint res;\n    int rc;\n    am_cache_entry_t *session;\n    char *return_to;\n    am_dir_cfg_rec *cfg = am_get_dir_cfg(r);\n\n    res = lasso_logout_process_response_msg(logout, r->args);\n#ifdef HAVE_lasso_profile_set_signature_verify_hint\n    if(res != 0 && res != LASSO_DS_ERROR_SIGNATURE_NOT_FOUND) {\n        if (apr_hash_get(cfg->do_not_verify_logout_signature,\n                         logout->parent.remote_providerID,\n                         APR_HASH_KEY_STRING)) {\n            lasso_profile_set_signature_verify_hint(&logout->parent,\n                LASSO_PROFILE_SIGNATURE_VERIFY_HINT_IGNORE);\n            res = lasso_logout_process_response_msg(logout, r->args);\n        }\n    }\n#endif\n    if(res != 0) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Unable to process logout response.\"\n                      \" Lasso error: [%i] %s\", res, lasso_strerror(res));\n\n        lasso_logout_destroy(logout);\n        return HTTP_BAD_REQUEST;\n    }\n\n    lasso_logout_destroy(logout);\n\n    /* Delete the session. */\n    session = am_get_request_session(r);\n    if(session != NULL) {\n        am_delete_request_session(r, session);\n    }\n\n    return_to = am_extract_query_parameter(r->pool, r->args, \"RelayState\");\n    if(return_to == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"No RelayState parameter to logout response handler.\"\n                      \" It is possible that your IdP doesn't support the\"\n                      \" RelayState parameter.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    rc = am_urldecode(return_to);\n    if(rc != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r,\n                      \"Could not urldecode RelayState value in logout\"\n                      \" response.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    /* Check for bad characters in RelayState. */\n    rc = am_check_url(r, return_to);\n    if (rc != OK) {\n        return rc;\n    }\n\n    /* Make sure that it is a valid redirect URL. */\n    rc = am_validate_redirect_url(r, return_to);\n    if (rc != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Invalid target domain in logout response RelayState parameter.\");\n        return rc;\n    }\n\n    apr_table_setn(r->headers_out, \"Location\", return_to);\n    return HTTP_SEE_OTHER;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -58,6 +58,14 @@\n         return rc;\n     }\n \n+    /* Make sure that it is a valid redirect URL. */\n+    rc = am_validate_redirect_url(r, return_to);\n+    if (rc != OK) {\n+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n+                      \"Invalid target domain in logout response RelayState parameter.\");\n+        return rc;\n+    }\n+\n     apr_table_setn(r->headers_out, \"Location\", return_to);\n     return HTTP_SEE_OTHER;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    /* Make sure that it is a valid redirect URL. */",
                "    rc = am_validate_redirect_url(r, return_to);",
                "    if (rc != OK) {",
                "        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,",
                "                      \"Invalid target domain in logout response RelayState parameter.\");",
                "        return rc;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13038",
        "func_name": "Uninett/mod_auth_mellon/am_init_logout_request",
        "description": "mod_auth_mellon through 0.14.2 has an Open Redirect via the login?ReturnTo= substring, as demonstrated by omitting the // after http: in the target URL.",
        "git_url": "https://github.com/Uninett/mod_auth_mellon/commit/9d28908e28ef70a12196c215503fb0075e1fd7f3",
        "commit_title": "Add MellonRedirectDomains option.",
        "commit_text": " Limit the domains that we will redirect to after login / logout to a set of trusted domains. By default we only allow redirects to the current domain.  This change breaks backwards compatibility with any site that relies on redirects to separate domains.  Fixes #35",
        "func_before": "static int am_init_logout_request(request_rec *r, LassoLogout *logout)\n{\n    char *return_to;\n    int rc;\n    am_cache_entry_t *mellon_session;\n    gint res;\n    char *redirect_to;\n    LassoProfile *profile;\n    LassoSession *session;\n    GList *assertion_list;\n    LassoNode *assertion_n;\n    LassoSaml2Assertion *assertion;\n    LassoSaml2AuthnStatement *authnStatement;\n    LassoSamlp2LogoutRequest *request;\n\n    return_to = am_extract_query_parameter(r->pool, r->args, \"ReturnTo\");\n    rc = am_urldecode(return_to);\n    if (rc != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r,\n                      \"Could not urldecode ReturnTo value.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    /* Disable the the local session (in case the IdP doesn't respond). */\n    mellon_session = am_get_request_session(r);\n    if(mellon_session != NULL) {\n        am_restore_lasso_profile_state(r, &logout->parent, mellon_session);\n        mellon_session->logged_in = 0;\n        am_release_request_session(r, mellon_session);\n    }\n\n    /* Create the logout request message. */\n    res = lasso_logout_init_request(logout, NULL, LASSO_HTTP_METHOD_REDIRECT);\n    /* Early non failing return. */\n    if (res != 0) {\n        if(res == LASSO_PROFILE_ERROR_SESSION_NOT_FOUND) {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,\n                          \"User attempted to initiate logout without being\"\n                          \" loggged in.\");\n        } else if (res == LASSO_LOGOUT_ERROR_UNSUPPORTED_PROFILE || res == LASSO_PROFILE_ERROR_UNSUPPORTED_PROFILE) {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, \"Current identity provider \"\n                            \"does not support single logout. Destroying local session only.\");\n\n        } else if(res != 0) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"Unable to create logout request.\"\n                          \" Lasso error: [%i] %s\", res, lasso_strerror(res));\n\n            lasso_logout_destroy(logout);\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n        lasso_logout_destroy(logout);\n        /* Check for bad characters in ReturnTo. */\n        rc = am_check_url(r, return_to);\n        if (rc != OK) {\n            return rc;\n        }\n        /* Redirect to the page the user should be sent to after logout. */\n        apr_table_setn(r->headers_out, \"Location\", return_to);\n        return HTTP_SEE_OTHER;\n    }\n\n    profile = LASSO_PROFILE(logout);\n\n    /* We need to set the SessionIndex in the LogoutRequest to the SessionIndex\n     * we received during the login operation. This is not needed since release\n     * 2.3.0.\n     */\n    if (lasso_check_version(2, 3, 0, LASSO_CHECK_VERSION_NUMERIC) == 0) {\n        session = lasso_profile_get_session(profile);\n        assertion_list = lasso_session_get_assertions(\n            session, profile->remote_providerID);\n        if(! assertion_list ||\n                        LASSO_IS_SAML2_ASSERTION(assertion_list->data) == FALSE) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"No assertions found for the current session.\");\n            lasso_logout_destroy(logout);\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n        /* We currently only look at the first assertion in the list\n         * lasso_session_get_assertions returns.\n         */\n        assertion_n = assertion_list->data;\n\n        assertion = LASSO_SAML2_ASSERTION(assertion_n);\n\n        /* We assume that the first authnStatement contains the data we want. */\n        authnStatement = LASSO_SAML2_AUTHN_STATEMENT(assertion->AuthnStatement->data);\n\n        if(!authnStatement) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"No AuthnStatement found in the current assertion.\");\n            lasso_logout_destroy(logout);\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        if(authnStatement->SessionIndex) {\n            request = LASSO_SAMLP2_LOGOUT_REQUEST(profile->request);\n            request->SessionIndex = g_strdup(authnStatement->SessionIndex);\n        }\n    }\n\n\n    /* Set the RelayState parameter to the return url (if we have one). */\n    if(return_to) {\n        profile->msg_relayState = g_strdup(return_to);\n    }\n\n    /* Serialize the request message into a url which we can redirect to. */\n    res = lasso_logout_build_request_msg(logout);\n    if(res != 0) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Unable to serialize lasso logout message.\"\n                      \" Lasso error: [%i] %s\", res, lasso_strerror(res));\n\n        lasso_logout_destroy(logout);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    /* Set the redirect url. */\n    redirect_to = apr_pstrdup(r->pool, LASSO_PROFILE(logout)->msg_url);\n\n    /* Check if the lasso library added the RelayState. If lasso didn't add\n     * a RelayState parameter, then we add one ourself. This should hopefully\n     * be removed in the future.\n     */\n    if(return_to != NULL\n       && strstr(redirect_to, \"&RelayState=\") == NULL\n       && strstr(redirect_to, \"?RelayState=\") == NULL) {\n        /* The url didn't contain the relaystate parameter. */\n        redirect_to = apr_pstrcat(\n            r->pool, redirect_to, \"&RelayState=\",\n            am_urlencode(r->pool, return_to),\n            NULL\n            );\n    }\n\n    apr_table_setn(r->headers_out, \"Location\", redirect_to);\n\n    lasso_logout_destroy(logout);\n\n    /* Redirect (without including POST data if this was a POST request. */\n    return HTTP_SEE_OTHER;\n}",
        "func": "static int am_init_logout_request(request_rec *r, LassoLogout *logout)\n{\n    char *return_to;\n    int rc;\n    am_cache_entry_t *mellon_session;\n    gint res;\n    char *redirect_to;\n    LassoProfile *profile;\n    LassoSession *session;\n    GList *assertion_list;\n    LassoNode *assertion_n;\n    LassoSaml2Assertion *assertion;\n    LassoSaml2AuthnStatement *authnStatement;\n    LassoSamlp2LogoutRequest *request;\n\n    return_to = am_extract_query_parameter(r->pool, r->args, \"ReturnTo\");\n    rc = am_urldecode(return_to);\n    if (rc != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r,\n                      \"Could not urldecode ReturnTo value.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    rc = am_validate_redirect_url(r, return_to);\n    if (rc != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Invalid target domain in logout request ReturnTo parameter.\");\n        return rc;\n    }\n\n    /* Disable the the local session (in case the IdP doesn't respond). */\n    mellon_session = am_get_request_session(r);\n    if(mellon_session != NULL) {\n        am_restore_lasso_profile_state(r, &logout->parent, mellon_session);\n        mellon_session->logged_in = 0;\n        am_release_request_session(r, mellon_session);\n    }\n\n    /* Create the logout request message. */\n    res = lasso_logout_init_request(logout, NULL, LASSO_HTTP_METHOD_REDIRECT);\n    /* Early non failing return. */\n    if (res != 0) {\n        if(res == LASSO_PROFILE_ERROR_SESSION_NOT_FOUND) {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,\n                          \"User attempted to initiate logout without being\"\n                          \" loggged in.\");\n        } else if (res == LASSO_LOGOUT_ERROR_UNSUPPORTED_PROFILE || res == LASSO_PROFILE_ERROR_UNSUPPORTED_PROFILE) {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, \"Current identity provider \"\n                            \"does not support single logout. Destroying local session only.\");\n\n        } else if(res != 0) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"Unable to create logout request.\"\n                          \" Lasso error: [%i] %s\", res, lasso_strerror(res));\n\n            lasso_logout_destroy(logout);\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n        lasso_logout_destroy(logout);\n        /* Check for bad characters in ReturnTo. */\n        rc = am_check_url(r, return_to);\n        if (rc != OK) {\n            return rc;\n        }\n        /* Redirect to the page the user should be sent to after logout. */\n        apr_table_setn(r->headers_out, \"Location\", return_to);\n        return HTTP_SEE_OTHER;\n    }\n\n    profile = LASSO_PROFILE(logout);\n\n    /* We need to set the SessionIndex in the LogoutRequest to the SessionIndex\n     * we received during the login operation. This is not needed since release\n     * 2.3.0.\n     */\n    if (lasso_check_version(2, 3, 0, LASSO_CHECK_VERSION_NUMERIC) == 0) {\n        session = lasso_profile_get_session(profile);\n        assertion_list = lasso_session_get_assertions(\n            session, profile->remote_providerID);\n        if(! assertion_list ||\n                        LASSO_IS_SAML2_ASSERTION(assertion_list->data) == FALSE) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"No assertions found for the current session.\");\n            lasso_logout_destroy(logout);\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n        /* We currently only look at the first assertion in the list\n         * lasso_session_get_assertions returns.\n         */\n        assertion_n = assertion_list->data;\n\n        assertion = LASSO_SAML2_ASSERTION(assertion_n);\n\n        /* We assume that the first authnStatement contains the data we want. */\n        authnStatement = LASSO_SAML2_AUTHN_STATEMENT(assertion->AuthnStatement->data);\n\n        if(!authnStatement) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"No AuthnStatement found in the current assertion.\");\n            lasso_logout_destroy(logout);\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n\n        if(authnStatement->SessionIndex) {\n            request = LASSO_SAMLP2_LOGOUT_REQUEST(profile->request);\n            request->SessionIndex = g_strdup(authnStatement->SessionIndex);\n        }\n    }\n\n\n    /* Set the RelayState parameter to the return url (if we have one). */\n    if(return_to) {\n        profile->msg_relayState = g_strdup(return_to);\n    }\n\n    /* Serialize the request message into a url which we can redirect to. */\n    res = lasso_logout_build_request_msg(logout);\n    if(res != 0) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Unable to serialize lasso logout message.\"\n                      \" Lasso error: [%i] %s\", res, lasso_strerror(res));\n\n        lasso_logout_destroy(logout);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    /* Set the redirect url. */\n    redirect_to = apr_pstrdup(r->pool, LASSO_PROFILE(logout)->msg_url);\n\n    /* Check if the lasso library added the RelayState. If lasso didn't add\n     * a RelayState parameter, then we add one ourself. This should hopefully\n     * be removed in the future.\n     */\n    if(return_to != NULL\n       && strstr(redirect_to, \"&RelayState=\") == NULL\n       && strstr(redirect_to, \"?RelayState=\") == NULL) {\n        /* The url didn't contain the relaystate parameter. */\n        redirect_to = apr_pstrcat(\n            r->pool, redirect_to, \"&RelayState=\",\n            am_urlencode(r->pool, return_to),\n            NULL\n            );\n    }\n\n    apr_table_setn(r->headers_out, \"Location\", redirect_to);\n\n    lasso_logout_destroy(logout);\n\n    /* Redirect (without including POST data if this was a POST request. */\n    return HTTP_SEE_OTHER;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,6 +19,13 @@\n         ap_log_rerror(APLOG_MARK, APLOG_ERR, rc, r,\n                       \"Could not urldecode ReturnTo value.\");\n         return HTTP_BAD_REQUEST;\n+    }\n+\n+    rc = am_validate_redirect_url(r, return_to);\n+    if (rc != OK) {\n+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n+                      \"Invalid target domain in logout request ReturnTo parameter.\");\n+        return rc;\n     }\n \n     /* Disable the the local session (in case the IdP doesn't respond). */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    }",
                "",
                "    rc = am_validate_redirect_url(r, return_to);",
                "    if (rc != OK) {",
                "        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,",
                "                      \"Invalid target domain in logout request ReturnTo parameter.\");",
                "        return rc;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13038",
        "func_name": "Uninett/mod_auth_mellon/am_handle_login",
        "description": "mod_auth_mellon through 0.14.2 has an Open Redirect via the login?ReturnTo= substring, as demonstrated by omitting the // after http: in the target URL.",
        "git_url": "https://github.com/Uninett/mod_auth_mellon/commit/9d28908e28ef70a12196c215503fb0075e1fd7f3",
        "commit_title": "Add MellonRedirectDomains option.",
        "commit_text": " Limit the domains that we will redirect to after login / logout to a set of trusted domains. By default we only allow redirects to the current domain.  This change breaks backwards compatibility with any site that relies on redirects to separate domains.  Fixes #35",
        "func_before": "static int am_handle_login(request_rec *r)\n{\n    am_dir_cfg_rec *cfg = am_get_dir_cfg(r);\n    char *idp_param;\n    const char *idp;\n    char *return_to;\n    int is_passive;\n    int ret;\n\n    return_to = am_extract_query_parameter(r->pool, r->args, \"ReturnTo\");\n    if(return_to == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Missing required ReturnTo parameter.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    ret = am_urldecode(return_to);\n    if(ret != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Error urldecoding ReturnTo parameter.\");\n        return ret;\n    }\n\n    idp_param = am_extract_query_parameter(r->pool, r->args, \"IdP\");\n    if(idp_param != NULL) {\n        ret = am_urldecode(idp_param);\n        if(ret != OK) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"Error urldecoding IdP parameter.\");\n            return ret;\n        }\n    }\n\n    ret = am_get_boolean_query_parameter(r, \"IsPassive\", &is_passive, FALSE);\n    if (ret != OK) {\n        return ret;\n    }\n\n    if(idp_param != NULL) {\n        idp = idp_param;\n    } else if(cfg->discovery_url) {\n        if(is_passive) {\n            /* We cannot currently do discovery with passive authentication requests. */\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"Discovery service with passive authentication request unsupported.\");\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n        return am_start_disco(r, return_to);\n    } else {\n        /* No discovery service -- just use the default IdP. */\n        idp = am_get_idp(r);\n    }\n\n    return am_send_login_authn_request(r, idp, return_to, is_passive);\n}",
        "func": "static int am_handle_login(request_rec *r)\n{\n    am_dir_cfg_rec *cfg = am_get_dir_cfg(r);\n    char *idp_param;\n    const char *idp;\n    char *return_to;\n    int is_passive;\n    int ret;\n\n    return_to = am_extract_query_parameter(r->pool, r->args, \"ReturnTo\");\n    if(return_to == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Missing required ReturnTo parameter.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    ret = am_urldecode(return_to);\n    if(ret != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Error urldecoding ReturnTo parameter.\");\n        return ret;\n    }\n\n    ret = am_validate_redirect_url(r, return_to);\n    if(ret != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Invalid target domain in login request ReturnTo parameter.\");\n        return ret;\n    }\n\n    idp_param = am_extract_query_parameter(r->pool, r->args, \"IdP\");\n    if(idp_param != NULL) {\n        ret = am_urldecode(idp_param);\n        if(ret != OK) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"Error urldecoding IdP parameter.\");\n            return ret;\n        }\n    }\n\n    ret = am_get_boolean_query_parameter(r, \"IsPassive\", &is_passive, FALSE);\n    if (ret != OK) {\n        return ret;\n    }\n\n    if(idp_param != NULL) {\n        idp = idp_param;\n    } else if(cfg->discovery_url) {\n        if(is_passive) {\n            /* We cannot currently do discovery with passive authentication requests. */\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                          \"Discovery service with passive authentication request unsupported.\");\n            return HTTP_INTERNAL_SERVER_ERROR;\n        }\n        return am_start_disco(r, return_to);\n    } else {\n        /* No discovery service -- just use the default IdP. */\n        idp = am_get_idp(r);\n    }\n\n    return am_send_login_authn_request(r, idp, return_to, is_passive);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,6 +18,13 @@\n     if(ret != OK) {\n         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                       \"Error urldecoding ReturnTo parameter.\");\n+        return ret;\n+    }\n+\n+    ret = am_validate_redirect_url(r, return_to);\n+    if(ret != OK) {\n+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n+                      \"Invalid target domain in login request ReturnTo parameter.\");\n         return ret;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        return ret;",
                "    }",
                "",
                "    ret = am_validate_redirect_url(r, return_to);",
                "    if(ret != OK) {",
                "        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,",
                "                      \"Invalid target domain in login request ReturnTo parameter.\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13038",
        "func_name": "Uninett/mod_auth_mellon/am_handle_probe_discovery",
        "description": "mod_auth_mellon through 0.14.2 has an Open Redirect via the login?ReturnTo= substring, as demonstrated by omitting the // after http: in the target URL.",
        "git_url": "https://github.com/Uninett/mod_auth_mellon/commit/9d28908e28ef70a12196c215503fb0075e1fd7f3",
        "commit_title": "Add MellonRedirectDomains option.",
        "commit_text": " Limit the domains that we will redirect to after login / logout to a set of trusted domains. By default we only allow redirects to the current domain.  This change breaks backwards compatibility with any site that relies on redirects to separate domains.  Fixes #35",
        "func_before": "static int am_handle_probe_discovery(request_rec *r) {\n    am_dir_cfg_rec *cfg = am_get_dir_cfg(r);\n    LassoServer *server;\n    const char *disco_idp = NULL;\n    int timeout;\n    char *return_to;\n    char *idp_param;\n    char *redirect_url;\n    int ret;\n\n    server = am_get_lasso_server(r);\n    if(server == NULL) {\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    /*\n     * If built-in IdP discovery is not configured, return error.\n     * For now we only have the get-metadata metadata method, so this\n     * information is not saved in configuration nor it is checked here.\n     */\n    timeout = cfg->probe_discovery_timeout;\n    if (timeout == -1) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"probe discovery handler invoked but not \"\n                      \"configured. Plase set MellonProbeDiscoveryTimeout.\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    /*\n     * Check for mandatory arguments early to avoid sending \n     * probles for nothing.\n     */\n    return_to = am_extract_query_parameter(r->pool, r->args, \"return\");\n    if(return_to == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Missing required return parameter.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    ret = am_urldecode(return_to);\n    if (ret != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, ret, r,\n                      \"Could not urldecode return value.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    idp_param = am_extract_query_parameter(r->pool, r->args, \"returnIDParam\");\n    if(idp_param == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Missing required returnIDParam parameter.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    ret = am_urldecode(idp_param);\n    if (ret != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, ret, r,\n                      \"Could not urldecode returnIDParam value.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    /*\n     * Proceed with built-in IdP discovery. \n     *\n     * First try sending probes to IdP configured for discovery.\n     * Second send probes for all configured IdP\n     * The first to answer is chosen.\n     * If none answer, use the first configured IdP\n     */\n    if (!apr_is_empty_table(cfg->probe_discovery_idp)) {\n        const apr_array_header_t *header;\n        apr_table_entry_t *elts;\n        const char *url;\n        const char *idp;\n        int i;\n\n        header = apr_table_elts(cfg->probe_discovery_idp);\n        elts = (apr_table_entry_t *)header->elts;\n\n        for (i = 0; i < header->nelts; i++) { \n            idp = elts[i].key;\n            url = elts[i].val;\n\n            if (am_probe_url(r, url, timeout) == OK) {\n                disco_idp = idp;\n                break;\n            }\n        }\n    } else {\n        GList *iter;\n        GList *idp_list;\n        const char *idp;\n\n        idp_list = g_hash_table_get_keys(server->providers);\n        for (iter = idp_list; iter != NULL; iter = iter->next) {\n            idp = iter->data;\n    \n            if (am_probe_url(r, idp, timeout) == OK) {\n                disco_idp = idp;\n                break;\n            }\n        }\n        g_list_free(idp_list);\n    }\n\n    /* \n     * On failure, try default\n     */\n    if (disco_idp == NULL) {\n        disco_idp = am_first_idp(r);\n        if (disco_idp == NULL) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \n                          \"probeDiscovery found no usable IdP.\");\n            return HTTP_INTERNAL_SERVER_ERROR;\n        } else {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, \"probeDiscovery \"\n                          \"failed, trying default IdP %s\", disco_idp); \n        }\n    } else {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                      \"probeDiscovery using %s\", disco_idp);\n    }\n\n    redirect_url = apr_psprintf(r->pool, \"%s%s%s=%s\", return_to, \n                                strchr(return_to, '?') ? \"&\" : \"?\",\n                                am_urlencode(r->pool, idp_param), \n                                am_urlencode(r->pool, disco_idp));\n\n    apr_table_setn(r->headers_out, \"Location\", redirect_url);\n\n    return HTTP_SEE_OTHER;\n}",
        "func": "static int am_handle_probe_discovery(request_rec *r) {\n    am_dir_cfg_rec *cfg = am_get_dir_cfg(r);\n    LassoServer *server;\n    const char *disco_idp = NULL;\n    int timeout;\n    char *return_to;\n    char *idp_param;\n    char *redirect_url;\n    int ret;\n\n    server = am_get_lasso_server(r);\n    if(server == NULL) {\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    /*\n     * If built-in IdP discovery is not configured, return error.\n     * For now we only have the get-metadata metadata method, so this\n     * information is not saved in configuration nor it is checked here.\n     */\n    timeout = cfg->probe_discovery_timeout;\n    if (timeout == -1) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"probe discovery handler invoked but not \"\n                      \"configured. Plase set MellonProbeDiscoveryTimeout.\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    /*\n     * Check for mandatory arguments early to avoid sending \n     * probles for nothing.\n     */\n    return_to = am_extract_query_parameter(r->pool, r->args, \"return\");\n    if(return_to == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Missing required return parameter.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    ret = am_urldecode(return_to);\n    if (ret != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, ret, r,\n                      \"Could not urldecode return value.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    ret = am_validate_redirect_url(r, return_to);\n    if (ret != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Invalid target domain in probe discovery return parameter.\");\n        return ret;\n    }\n\n    idp_param = am_extract_query_parameter(r->pool, r->args, \"returnIDParam\");\n    if(idp_param == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Missing required returnIDParam parameter.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    ret = am_urldecode(idp_param);\n    if (ret != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, ret, r,\n                      \"Could not urldecode returnIDParam value.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    /*\n     * Proceed with built-in IdP discovery. \n     *\n     * First try sending probes to IdP configured for discovery.\n     * Second send probes for all configured IdP\n     * The first to answer is chosen.\n     * If none answer, use the first configured IdP\n     */\n    if (!apr_is_empty_table(cfg->probe_discovery_idp)) {\n        const apr_array_header_t *header;\n        apr_table_entry_t *elts;\n        const char *url;\n        const char *idp;\n        int i;\n\n        header = apr_table_elts(cfg->probe_discovery_idp);\n        elts = (apr_table_entry_t *)header->elts;\n\n        for (i = 0; i < header->nelts; i++) { \n            idp = elts[i].key;\n            url = elts[i].val;\n\n            if (am_probe_url(r, url, timeout) == OK) {\n                disco_idp = idp;\n                break;\n            }\n        }\n    } else {\n        GList *iter;\n        GList *idp_list;\n        const char *idp;\n\n        idp_list = g_hash_table_get_keys(server->providers);\n        for (iter = idp_list; iter != NULL; iter = iter->next) {\n            idp = iter->data;\n    \n            if (am_probe_url(r, idp, timeout) == OK) {\n                disco_idp = idp;\n                break;\n            }\n        }\n        g_list_free(idp_list);\n    }\n\n    /* \n     * On failure, try default\n     */\n    if (disco_idp == NULL) {\n        disco_idp = am_first_idp(r);\n        if (disco_idp == NULL) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \n                          \"probeDiscovery found no usable IdP.\");\n            return HTTP_INTERNAL_SERVER_ERROR;\n        } else {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, \"probeDiscovery \"\n                          \"failed, trying default IdP %s\", disco_idp); \n        }\n    } else {\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                      \"probeDiscovery using %s\", disco_idp);\n    }\n\n    redirect_url = apr_psprintf(r->pool, \"%s%s%s=%s\", return_to, \n                                strchr(return_to, '?') ? \"&\" : \"?\",\n                                am_urlencode(r->pool, idp_param), \n                                am_urlencode(r->pool, disco_idp));\n\n    apr_table_setn(r->headers_out, \"Location\", redirect_url);\n\n    return HTTP_SEE_OTHER;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -42,6 +42,13 @@\n         ap_log_rerror(APLOG_MARK, APLOG_ERR, ret, r,\n                       \"Could not urldecode return value.\");\n         return HTTP_BAD_REQUEST;\n+    }\n+\n+    ret = am_validate_redirect_url(r, return_to);\n+    if (ret != OK) {\n+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n+                      \"Invalid target domain in probe discovery return parameter.\");\n+        return ret;\n     }\n \n     idp_param = am_extract_query_parameter(r->pool, r->args, \"returnIDParam\");",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    }",
                "",
                "    ret = am_validate_redirect_url(r, return_to);",
                "    if (ret != OK) {",
                "        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,",
                "                      \"Invalid target domain in probe discovery return parameter.\");",
                "        return ret;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13038",
        "func_name": "Uninett/mod_auth_mellon/am_handle_repost",
        "description": "mod_auth_mellon through 0.14.2 has an Open Redirect via the login?ReturnTo= substring, as demonstrated by omitting the // after http: in the target URL.",
        "git_url": "https://github.com/Uninett/mod_auth_mellon/commit/9d28908e28ef70a12196c215503fb0075e1fd7f3",
        "commit_title": "Add MellonRedirectDomains option.",
        "commit_text": " Limit the domains that we will redirect to after login / logout to a set of trusted domains. By default we only allow redirects to the current domain.  This change breaks backwards compatibility with any site that relies on redirects to separate domains.  Fixes #35",
        "func_before": "static int am_handle_repost(request_rec *r)\n{\n    am_mod_cfg_rec *mod_cfg;\n    const char *query;\n    const char *enctype;\n    char *charset;\n    char *psf_id;\n    char *cp;\n    char *psf_filename;\n    char *post_data;\n    const char *post_form;\n    char *output;\n    char *return_url;\n    const char *(*post_mkform)(request_rec *, const char *);\n\n    if (am_cookie_get(r) == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \n                      \"Repost query without a session\");\n        return HTTP_FORBIDDEN;\n    }\n\n    mod_cfg = am_get_mod_cfg(r->server);\n\n    if (!mod_cfg->post_dir) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Repost query without MellonPostDirectory.\");\n        return HTTP_NOT_FOUND;\n    }\n\n    query = r->parsed_uri.query;\n\n    enctype = am_extract_query_parameter(r->pool, query, \"enctype\");\n    if (enctype == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \n                      \"Bad repost query: missing enctype\");\n        return HTTP_BAD_REQUEST;\n    }\n    if (strcmp(enctype, \"urlencoded\") == 0) {\n        enctype = \"application/x-www-form-urlencoded\";\n        post_mkform = am_post_mkform_urlencoded;\n    } else if (strcmp(enctype, \"multipart\") == 0) {\n        enctype = \"multipart/form-data\";\n        post_mkform = am_post_mkform_multipart;\n    } else {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \n                      \"Bad repost query: invalid enctype \\\"%s\\\".\", enctype);\n        return HTTP_BAD_REQUEST;\n    }\n\n    charset = am_extract_query_parameter(r->pool, query, \"charset\");\n    if (charset != NULL) {\n        if (am_urldecode(charset) != OK) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \n                          \"Bad repost query: invalid charset \\\"%s\\\"\", charset);\n            return HTTP_BAD_REQUEST;\n        }\n    \n        /* Check that charset is sane */\n        for (cp = charset; *cp; cp++) {\n            if (!apr_isalnum(*cp) && (*cp != '-') && (*cp != '_')) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \n                              \"Bad repost query: invalid charset \\\"%s\\\"\", charset);\n                return HTTP_BAD_REQUEST;\n            }\n        }\n    }\n\n    psf_id = am_extract_query_parameter(r->pool, query, \"id\");\n    if (psf_id == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \n                      \"Bad repost query: missing id\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    /* Check that Id is sane */\n    for (cp = psf_id; *cp; cp++) {\n        if (!apr_isalnum(*cp)) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \n                          \"Bad repost query: invalid id \\\"%s\\\"\", psf_id);\n            return HTTP_BAD_REQUEST;\n        }\n    }\n    \n    \n    return_url = am_extract_query_parameter(r->pool, query, \"ReturnTo\");\n    if (return_url == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Invalid or missing query ReturnTo parameter.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    if (am_urldecode(return_url) != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \"Bad repost query: return\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    psf_filename = apr_psprintf(r->pool, \"%s/%s\", mod_cfg->post_dir, psf_id);\n    post_data = am_getfile(r->pool, r->server, psf_filename);\n    if (post_data == NULL) {\n        /* Unable to load repost data. Just redirect us instead. */\n        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,\n                      \"Bad repost query: cannot find \\\"%s\\\"\", psf_filename);\n        apr_table_setn(r->headers_out, \"Location\", return_url);\n        return HTTP_SEE_OTHER;\n    }\n\n    if ((post_form = (*post_mkform)(r, post_data)) == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \"am_post_mkform() failed\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    if (charset != NULL) {\n         ap_set_content_type(r, apr_psprintf(r->pool,\n                             \"text/html; charset=\\\"%s\\\"\", charset));\n         charset = apr_psprintf(r->pool, \" accept-charset=\\\"%s\\\"\", charset);\n    } else {\n         ap_set_content_type(r, \"text/html\");\n         charset = (char *)\"\";\n    }\n\n    output = apr_psprintf(r->pool,\n      \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\">\\n\"\n      \"<html>\\n\"\n      \" <head>\\n\" \n      \"  <title>SAML rePOST request</title>\\n\" \n      \" </head>\\n\" \n      \" <body onload=\\\"document.getElementById('form').submit();\\\">\\n\" \n      \"  <noscript>\\n\"\n      \"   Your browser does not support Javascript, \\n\"\n      \"   you must click the button below to proceed.\\n\"\n      \"  </noscript>\\n\"\n      \"   <form id=\\\"form\\\" method=\\\"POST\\\" action=\\\"%s\\\" enctype=\\\"%s\\\"%s>\\n%s\"\n      \"    <noscript>\\n\"\n      \"     <input type=\\\"submit\\\">\\n\"\n      \"    </noscript>\\n\"\n      \"   </form>\\n\"\n      \" </body>\\n\" \n      \"</html>\\n\",\n      am_htmlencode(r, return_url), enctype, charset, post_form);\n\n    ap_rputs(output, r);\n    return OK;\n}",
        "func": "static int am_handle_repost(request_rec *r)\n{\n    am_mod_cfg_rec *mod_cfg;\n    const char *query;\n    const char *enctype;\n    char *charset;\n    char *psf_id;\n    char *cp;\n    char *psf_filename;\n    char *post_data;\n    const char *post_form;\n    char *output;\n    char *return_url;\n    const char *(*post_mkform)(request_rec *, const char *);\n    int rc;\n\n    if (am_cookie_get(r) == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \n                      \"Repost query without a session\");\n        return HTTP_FORBIDDEN;\n    }\n\n    mod_cfg = am_get_mod_cfg(r->server);\n\n    if (!mod_cfg->post_dir) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Repost query without MellonPostDirectory.\");\n        return HTTP_NOT_FOUND;\n    }\n\n    query = r->parsed_uri.query;\n\n    enctype = am_extract_query_parameter(r->pool, query, \"enctype\");\n    if (enctype == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \n                      \"Bad repost query: missing enctype\");\n        return HTTP_BAD_REQUEST;\n    }\n    if (strcmp(enctype, \"urlencoded\") == 0) {\n        enctype = \"application/x-www-form-urlencoded\";\n        post_mkform = am_post_mkform_urlencoded;\n    } else if (strcmp(enctype, \"multipart\") == 0) {\n        enctype = \"multipart/form-data\";\n        post_mkform = am_post_mkform_multipart;\n    } else {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \n                      \"Bad repost query: invalid enctype \\\"%s\\\".\", enctype);\n        return HTTP_BAD_REQUEST;\n    }\n\n    charset = am_extract_query_parameter(r->pool, query, \"charset\");\n    if (charset != NULL) {\n        if (am_urldecode(charset) != OK) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \n                          \"Bad repost query: invalid charset \\\"%s\\\"\", charset);\n            return HTTP_BAD_REQUEST;\n        }\n    \n        /* Check that charset is sane */\n        for (cp = charset; *cp; cp++) {\n            if (!apr_isalnum(*cp) && (*cp != '-') && (*cp != '_')) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \n                              \"Bad repost query: invalid charset \\\"%s\\\"\", charset);\n                return HTTP_BAD_REQUEST;\n            }\n        }\n    }\n\n    psf_id = am_extract_query_parameter(r->pool, query, \"id\");\n    if (psf_id == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \n                      \"Bad repost query: missing id\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    /* Check that Id is sane */\n    for (cp = psf_id; *cp; cp++) {\n        if (!apr_isalnum(*cp)) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \n                          \"Bad repost query: invalid id \\\"%s\\\"\", psf_id);\n            return HTTP_BAD_REQUEST;\n        }\n    }\n    \n    \n    return_url = am_extract_query_parameter(r->pool, query, \"ReturnTo\");\n    if (return_url == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Invalid or missing query ReturnTo parameter.\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    if (am_urldecode(return_url) != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \"Bad repost query: return\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    rc = am_validate_redirect_url(r, return_url);\n    if (rc != OK) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Invalid target domain in repost request ReturnTo parameter.\");\n        return rc;\n    }\n\n    psf_filename = apr_psprintf(r->pool, \"%s/%s\", mod_cfg->post_dir, psf_id);\n    post_data = am_getfile(r->pool, r->server, psf_filename);\n    if (post_data == NULL) {\n        /* Unable to load repost data. Just redirect us instead. */\n        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,\n                      \"Bad repost query: cannot find \\\"%s\\\"\", psf_filename);\n        apr_table_setn(r->headers_out, \"Location\", return_url);\n        return HTTP_SEE_OTHER;\n    }\n\n    if ((post_form = (*post_mkform)(r, post_data)) == NULL) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \"am_post_mkform() failed\");\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    if (charset != NULL) {\n         ap_set_content_type(r, apr_psprintf(r->pool,\n                             \"text/html; charset=\\\"%s\\\"\", charset));\n         charset = apr_psprintf(r->pool, \" accept-charset=\\\"%s\\\"\", charset);\n    } else {\n         ap_set_content_type(r, \"text/html\");\n         charset = (char *)\"\";\n    }\n\n    output = apr_psprintf(r->pool,\n      \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\">\\n\"\n      \"<html>\\n\"\n      \" <head>\\n\" \n      \"  <title>SAML rePOST request</title>\\n\" \n      \" </head>\\n\" \n      \" <body onload=\\\"document.getElementById('form').submit();\\\">\\n\" \n      \"  <noscript>\\n\"\n      \"   Your browser does not support Javascript, \\n\"\n      \"   you must click the button below to proceed.\\n\"\n      \"  </noscript>\\n\"\n      \"   <form id=\\\"form\\\" method=\\\"POST\\\" action=\\\"%s\\\" enctype=\\\"%s\\\"%s>\\n%s\"\n      \"    <noscript>\\n\"\n      \"     <input type=\\\"submit\\\">\\n\"\n      \"    </noscript>\\n\"\n      \"   </form>\\n\"\n      \" </body>\\n\" \n      \"</html>\\n\",\n      am_htmlencode(r, return_url), enctype, charset, post_form);\n\n    ap_rputs(output, r);\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,7 @@\n     char *output;\n     char *return_url;\n     const char *(*post_mkform)(request_rec *, const char *);\n+    int rc;\n \n     if (am_cookie_get(r) == NULL) {\n         ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, \n@@ -94,6 +95,13 @@\n         return HTTP_BAD_REQUEST;\n     }\n \n+    rc = am_validate_redirect_url(r, return_url);\n+    if (rc != OK) {\n+        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n+                      \"Invalid target domain in repost request ReturnTo parameter.\");\n+        return rc;\n+    }\n+\n     psf_filename = apr_psprintf(r->pool, \"%s/%s\", mod_cfg->post_dir, psf_id);\n     post_data = am_getfile(r->pool, r->server, psf_filename);\n     if (post_data == NULL) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    int rc;",
                "    rc = am_validate_redirect_url(r, return_url);",
                "    if (rc != OK) {",
                "        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,",
                "                      \"Invalid target domain in repost request ReturnTo parameter.\");",
                "        return rc;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3639",
        "func_name": "latchset/mod_auth_mellon/am_check_url",
        "description": "A flaw was found in mod_auth_mellon where it does not sanitize logout URLs properly. This issue could be used by an attacker to facilitate phishing attacks by tricking users into visiting a trusted web application URL that redirects to an external and potentially malicious server. The highest threat from this liability is to confidentiality and integrity.",
        "git_url": "https://github.com/latchset/mod_auth_mellon/commit/42a11261b9dad2e48d70bdff7c53dd57a12db6f5",
        "commit_title": "Prevent redirect to URLs that begin with '///'",
        "commit_text": " Visiting a logout URL like this:     https://rp.example.co.jp/mellon/logout?ReturnTo=///fishing-site.example.com/logout.html would have redirected the user to fishing-site.example.com  With the patch, this URL would be rejected. ",
        "func_before": "int am_check_url(request_rec *r, const char *url)\n{\n    const char *i;\n\n    for (i = url; *i; i++) {\n        if (*i >= 0 && *i < ' ') {\n            /* Deny all control-characters. */\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"Control character detected in URL.\");\n            return HTTP_BAD_REQUEST;\n        }\n        if (*i == '\\\\') {\n            /* Reject backslash character, as it can be used to bypass\n             * redirect URL validation. */\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"Backslash character detected in URL.\");\n            return HTTP_BAD_REQUEST;\n        }\n    }\n\n    return OK;\n}",
        "func": "int am_check_url(request_rec *r, const char *url)\n{\n    const char *i;\n\n    if (url == NULL) {\n        return HTTP_BAD_REQUEST;\n    }\n\n    for (i = url; *i; i++) {\n        if (*i >= 0 && *i < ' ') {\n            /* Deny all control-characters. */\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"Control character detected in URL.\");\n            return HTTP_BAD_REQUEST;\n        }\n        if (*i == '\\\\') {\n            /* Reject backslash character, as it can be used to bypass\n             * redirect URL validation. */\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"Backslash character detected in URL.\");\n            return HTTP_BAD_REQUEST;\n        }\n    }\n\n    if (strstr(url, \"///\") == url) {\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"URL starts with '///'\");\n        return HTTP_BAD_REQUEST;\n    }\n\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,10 @@\n int am_check_url(request_rec *r, const char *url)\n {\n     const char *i;\n+\n+    if (url == NULL) {\n+        return HTTP_BAD_REQUEST;\n+    }\n \n     for (i = url; *i; i++) {\n         if (*i >= 0 && *i < ' ') {\n@@ -18,5 +22,11 @@\n         }\n     }\n \n+    if (strstr(url, \"///\") == url) {\n+        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n+                          \"URL starts with '///'\");\n+        return HTTP_BAD_REQUEST;\n+    }\n+\n     return OK;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if (url == NULL) {",
                "        return HTTP_BAD_REQUEST;",
                "    }",
                "    if (strstr(url, \"///\") == url) {",
                "        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,",
                "                          \"URL starts with '///'\");",
                "        return HTTP_BAD_REQUEST;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-3877",
        "func_name": "Uninett/mod_auth_mellon/am_check_url",
        "description": "A vulnerability was found in mod_auth_mellon before v0.14.2. An open redirect in the logout URL allows requests with backslashes to pass through by assuming that it is a relative URL, while the browsers silently convert backslash characters into forward slashes treating them as an absolute URL. This mismatch allows an attacker to bypass the redirect URL validation logic in apr_uri_parse function.",
        "git_url": "https://github.com/Uninett/mod_auth_mellon/commit/62041428a32de402e0be6ba45fe12df6a83bedb8",
        "commit_title": "Fix redirect URL validation bypass",
        "commit_text": " It turns out that browsers silently convert backslash characters into forward slashes, while apr_uri_parse() does not.  This mismatch allows an attacker to bypass the redirect URL validation by using an URL like:    https://sp.example.org/mellon/logout?ReturnTo=https:%5c%5cmalicious.example.org/  mod_auth_mellon will assume that it is a relative URL and allow the request to pass through, while the browsers will use it as an absolute url and redirect to https://malicious.example.org/ .  This patch fixes this issue by rejecting all redirect URLs with backslashes.",
        "func_before": "int am_check_url(request_rec *r, const char *url)\n{\n    const char *i;\n\n    for (i = url; *i; i++) {\n        if (*i >= 0 && *i < ' ') {\n            /* Deny all control-characters. */\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"Control character detected in URL.\");\n            return HTTP_BAD_REQUEST;\n        }\n    }\n\n    return OK;\n}",
        "func": "int am_check_url(request_rec *r, const char *url)\n{\n    const char *i;\n\n    for (i = url; *i; i++) {\n        if (*i >= 0 && *i < ' ') {\n            /* Deny all control-characters. */\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"Control character detected in URL.\");\n            return HTTP_BAD_REQUEST;\n        }\n        if (*i == '\\\\') {\n            /* Reject backslash character, as it can be used to bypass\n             * redirect URL validation. */\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"Backslash character detected in URL.\");\n            return HTTP_BAD_REQUEST;\n        }\n    }\n\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,6 +9,13 @@\n                           \"Control character detected in URL.\");\n             return HTTP_BAD_REQUEST;\n         }\n+        if (*i == '\\\\') {\n+            /* Reject backslash character, as it can be used to bypass\n+             * redirect URL validation. */\n+            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n+                          \"Backslash character detected in URL.\");\n+            return HTTP_BAD_REQUEST;\n+        }\n     }\n \n     return OK;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (*i == '\\\\') {",
                "            /* Reject backslash character, as it can be used to bypass",
                "             * redirect URL validation. */",
                "            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,",
                "                          \"Backslash character detected in URL.\");",
                "            return HTTP_BAD_REQUEST;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39191",
        "func_name": "OpenIDC/mod_auth_openidc/oidc_handle_discovery_response",
        "description": "mod_auth_openidc is an authentication/authorization module for the Apache 2.x HTTP server that functions as an OpenID Connect Relying Party, authenticating users against an OpenID Connect Provider. In versions prior to 2.4.9.4, the 3rd-party init SSO functionality of mod_auth_openidc was reported to be vulnerable to an open redirect attack by supplying a crafted URL in the `target_link_uri` parameter. A patch in version 2.4.9.4 made it so that the `OIDCRedirectURLsAllowed` setting must be applied to the `target_link_uri` parameter. There are no known workarounds aside from upgrading to a patched version.",
        "git_url": "https://github.com/OpenIDC/mod_auth_openidc/commit/03e6bfb446f4e3f27c003d30d6a433e5dd8e2b3d",
        "commit_title": "apply OIDCRedirectURLsAllowed setting to target_link_uri",
        "commit_text": " closes #672; thanks @Meheni release 2.4.9.4 ",
        "func_before": "static int oidc_handle_discovery_response(request_rec *r, oidc_cfg *c) {\n\n\t/* variables to hold the values returned in the response */\n\tchar *issuer = NULL, *target_link_uri = NULL, *login_hint = NULL,\n\t\t\t*auth_request_params = NULL, *csrf_cookie, *csrf_query = NULL,\n\t\t\t*user = NULL, *path_scopes;\n\toidc_provider_t *provider = NULL;\n\n\toidc_util_get_request_parameter(r, OIDC_DISC_OP_PARAM, &issuer);\n\toidc_util_get_request_parameter(r, OIDC_DISC_USER_PARAM, &user);\n\toidc_util_get_request_parameter(r, OIDC_DISC_RT_PARAM, &target_link_uri);\n\toidc_util_get_request_parameter(r, OIDC_DISC_LH_PARAM, &login_hint);\n\toidc_util_get_request_parameter(r, OIDC_DISC_SC_PARAM, &path_scopes);\n\toidc_util_get_request_parameter(r, OIDC_DISC_AR_PARAM,\n\t\t\t&auth_request_params);\n\toidc_util_get_request_parameter(r, OIDC_CSRF_NAME, &csrf_query);\n\tcsrf_cookie = oidc_util_get_cookie(r, OIDC_CSRF_NAME);\n\n\t/* do CSRF protection if not 3rd party initiated SSO */\n\tif (csrf_cookie) {\n\n\t\t/* clean CSRF cookie */\n\t\toidc_util_set_cookie(r, OIDC_CSRF_NAME, \"\", 0,\n\t\t\t\tOIDC_COOKIE_EXT_SAME_SITE_NONE(r));\n\n\t\t/* compare CSRF cookie value with query parameter value */\n\t\tif ((csrf_query == NULL)\n\t\t\t\t|| apr_strnatcmp(csrf_query, csrf_cookie) != 0) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"CSRF protection failed, no Discovery and dynamic client registration will be allowed\");\n\t\t\tcsrf_cookie = NULL;\n\t\t}\n\t}\n\n\t// TODO: trim issuer/accountname/domain input and do more input validation\n\n\toidc_debug(r,\n\t\t\t\"issuer=\\\"%s\\\", target_link_uri=\\\"%s\\\", login_hint=\\\"%s\\\", user=\\\"%s\\\"\",\n\t\t\tissuer, target_link_uri, login_hint, user);\n\n\tif (target_link_uri == NULL) {\n\t\tif (c->default_sso_url == NULL) {\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"SSO to this module without specifying a \\\"target_link_uri\\\" parameter is not possible because \" OIDCDefaultURL \" is not set.\",\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t}\n\t\ttarget_link_uri = c->default_sso_url;\n\t}\n\n\t/* do open redirect prevention */\n\tif (oidc_target_link_uri_matches_configuration(r, c, target_link_uri)\n\t\t\t== FALSE) {\n\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\"Invalid Request\",\n\t\t\t\t\"\\\"target_link_uri\\\" parameter does not match configuration settings, aborting to prevent an open redirect.\",\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t}\n\n\t/* see if this is a static setup */\n\tif (c->metadata_dir == NULL) {\n\t\tif ((oidc_provider_static_config(r, c, &provider) == TRUE)\n\t\t\t\t&& (issuer != NULL)) {\n\t\t\tif (apr_strnatcmp(provider->issuer, issuer) != 0) {\n\t\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\t\"The \\\"iss\\\" value must match the configured providers' one (%s != %s).\",\n\t\t\t\t\t\t\t\tissuer, c->provider.issuer),\n\t\t\t\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t\t}\n\t\t}\n\t\treturn oidc_authenticate_user(r, c, NULL, target_link_uri, login_hint,\n\t\t\t\tNULL, NULL, auth_request_params, path_scopes);\n\t}\n\n\t/* find out if the user entered an account name or selected an OP manually */\n\tif (user != NULL) {\n\n\t\tif (login_hint == NULL)\n\t\t\tlogin_hint = apr_pstrdup(r->pool, user);\n\n\t\t/* normalize the user identifier */\n\t\tif (strstr(user, \"https://\") != user)\n\t\t\tuser = apr_psprintf(r->pool, \"https://%s\", user);\n\n\t\t/* got an user identifier as input, perform OP discovery with that */\n\t\tif (oidc_proto_url_based_discovery(r, c, user, &issuer) == FALSE) {\n\n\t\t\t/* something did not work out, show a user facing error */\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"Could not resolve the provided user identifier to an OpenID Connect provider; check your syntax.\",\n\t\t\t\t\tHTTP_NOT_FOUND);\n\t\t}\n\n\t\t/* issuer is set now, so let's continue as planned */\n\n\t} else if (strstr(issuer, OIDC_STR_AT) != NULL) {\n\n\t\tif (login_hint == NULL) {\n\t\t\tlogin_hint = apr_pstrdup(r->pool, issuer);\n\t\t\t//char *p = strstr(issuer, OIDC_STR_AT);\n\t\t\t//*p = '\\0';\n\t\t}\n\n\t\t/* got an account name as input, perform OP discovery with that */\n\t\tif (oidc_proto_account_based_discovery(r, c, issuer, &issuer)\n\t\t\t\t== FALSE) {\n\n\t\t\t/* something did not work out, show a user facing error */\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"Could not resolve the provided account name to an OpenID Connect provider; check your syntax.\",\n\t\t\t\t\tHTTP_NOT_FOUND);\n\t\t}\n\n\t\t/* issuer is set now, so let's continue as planned */\n\n\t}\n\n\t/* strip trailing '/' */\n\tint n = strlen(issuer);\n\tif (issuer[n - 1] == OIDC_CHAR_FORWARD_SLASH)\n\t\tissuer[n - 1] = '\\0';\n\n\t/* try and get metadata from the metadata directories for the selected OP */\n\tif ((oidc_metadata_get(r, c, issuer, &provider, csrf_cookie != NULL) == TRUE)\n\t\t\t&& (provider != NULL)) {\n\n\t\t/* now we've got a selected OP, send the user there to authenticate */\n\t\treturn oidc_authenticate_user(r, c, provider, target_link_uri,\n\t\t\t\tlogin_hint, NULL, NULL, auth_request_params, path_scopes);\n\t}\n\n\t/* something went wrong */\n\treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n\t\t\t\"Could not find valid provider metadata for the selected OpenID Connect provider; contact the administrator\",\n\t\t\tHTTP_NOT_FOUND);\n}",
        "func": "static int oidc_handle_discovery_response(request_rec *r, oidc_cfg *c) {\n\n\t/* variables to hold the values returned in the response */\n\tchar *issuer = NULL, *target_link_uri = NULL, *login_hint = NULL,\n\t\t\t*auth_request_params = NULL, *csrf_cookie, *csrf_query = NULL,\n\t\t\t*user = NULL, *path_scopes;\n\toidc_provider_t *provider = NULL;\n\tchar *error_str = NULL;\n\tchar *error_description = NULL;\n\n\toidc_util_get_request_parameter(r, OIDC_DISC_OP_PARAM, &issuer);\n\toidc_util_get_request_parameter(r, OIDC_DISC_USER_PARAM, &user);\n\toidc_util_get_request_parameter(r, OIDC_DISC_RT_PARAM, &target_link_uri);\n\toidc_util_get_request_parameter(r, OIDC_DISC_LH_PARAM, &login_hint);\n\toidc_util_get_request_parameter(r, OIDC_DISC_SC_PARAM, &path_scopes);\n\toidc_util_get_request_parameter(r, OIDC_DISC_AR_PARAM,\n\t\t\t&auth_request_params);\n\toidc_util_get_request_parameter(r, OIDC_CSRF_NAME, &csrf_query);\n\tcsrf_cookie = oidc_util_get_cookie(r, OIDC_CSRF_NAME);\n\n\t/* do CSRF protection if not 3rd party initiated SSO */\n\tif (csrf_cookie) {\n\n\t\t/* clean CSRF cookie */\n\t\toidc_util_set_cookie(r, OIDC_CSRF_NAME, \"\", 0,\n\t\t\t\tOIDC_COOKIE_EXT_SAME_SITE_NONE(r));\n\n\t\t/* compare CSRF cookie value with query parameter value */\n\t\tif ((csrf_query == NULL)\n\t\t\t\t|| apr_strnatcmp(csrf_query, csrf_cookie) != 0) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"CSRF protection failed, no Discovery and dynamic client registration will be allowed\");\n\t\t\tcsrf_cookie = NULL;\n\t\t}\n\t}\n\n\t// TODO: trim issuer/accountname/domain input and do more input validation\n\n\toidc_debug(r,\n\t\t\t\"issuer=\\\"%s\\\", target_link_uri=\\\"%s\\\", login_hint=\\\"%s\\\", user=\\\"%s\\\"\",\n\t\t\tissuer, target_link_uri, login_hint, user);\n\n\tif (target_link_uri == NULL) {\n\t\tif (c->default_sso_url == NULL) {\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"SSO to this module without specifying a \\\"target_link_uri\\\" parameter is not possible because \" OIDCDefaultURL \" is not set.\",\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t}\n\t\ttarget_link_uri = c->default_sso_url;\n\t}\n\n\t/* do open redirect prevention, step 1 */\n\tif (oidc_target_link_uri_matches_configuration(r, c, target_link_uri)\n\t\t\t== FALSE) {\n\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\"Invalid Request\",\n\t\t\t\t\"\\\"target_link_uri\\\" parameter does not match configuration settings, aborting to prevent an open redirect.\",\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t}\n\n\t/* do input validation on the target_link_uri parameter value, step 2 */\n\tif (oidc_validate_redirect_url(r, c, target_link_uri, TRUE, &error_str,\n\t\t\t&error_description) == FALSE) {\n\t\treturn oidc_util_html_send_error(r, c->error_template, error_str,\n\t\t\t\terror_description,\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t}\n\n\t/* see if this is a static setup */\n\tif (c->metadata_dir == NULL) {\n\t\tif ((oidc_provider_static_config(r, c, &provider) == TRUE)\n\t\t\t\t&& (issuer != NULL)) {\n\t\t\tif (apr_strnatcmp(provider->issuer, issuer) != 0) {\n\t\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\t\"The \\\"iss\\\" value must match the configured providers' one (%s != %s).\",\n\t\t\t\t\t\t\t\tissuer, c->provider.issuer),\n\t\t\t\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t\t}\n\t\t}\n\t\treturn oidc_authenticate_user(r, c, NULL, target_link_uri, login_hint,\n\t\t\t\tNULL, NULL, auth_request_params, path_scopes);\n\t}\n\n\t/* find out if the user entered an account name or selected an OP manually */\n\tif (user != NULL) {\n\n\t\tif (login_hint == NULL)\n\t\t\tlogin_hint = apr_pstrdup(r->pool, user);\n\n\t\t/* normalize the user identifier */\n\t\tif (strstr(user, \"https://\") != user)\n\t\t\tuser = apr_psprintf(r->pool, \"https://%s\", user);\n\n\t\t/* got an user identifier as input, perform OP discovery with that */\n\t\tif (oidc_proto_url_based_discovery(r, c, user, &issuer) == FALSE) {\n\n\t\t\t/* something did not work out, show a user facing error */\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"Could not resolve the provided user identifier to an OpenID Connect provider; check your syntax.\",\n\t\t\t\t\tHTTP_NOT_FOUND);\n\t\t}\n\n\t\t/* issuer is set now, so let's continue as planned */\n\n\t} else if (strstr(issuer, OIDC_STR_AT) != NULL) {\n\n\t\tif (login_hint == NULL) {\n\t\t\tlogin_hint = apr_pstrdup(r->pool, issuer);\n\t\t\t//char *p = strstr(issuer, OIDC_STR_AT);\n\t\t\t//*p = '\\0';\n\t\t}\n\n\t\t/* got an account name as input, perform OP discovery with that */\n\t\tif (oidc_proto_account_based_discovery(r, c, issuer, &issuer)\n\t\t\t\t== FALSE) {\n\n\t\t\t/* something did not work out, show a user facing error */\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"Could not resolve the provided account name to an OpenID Connect provider; check your syntax.\",\n\t\t\t\t\tHTTP_NOT_FOUND);\n\t\t}\n\n\t\t/* issuer is set now, so let's continue as planned */\n\n\t}\n\n\t/* strip trailing '/' */\n\tint n = strlen(issuer);\n\tif (issuer[n - 1] == OIDC_CHAR_FORWARD_SLASH)\n\t\tissuer[n - 1] = '\\0';\n\n\t/* try and get metadata from the metadata directories for the selected OP */\n\tif ((oidc_metadata_get(r, c, issuer, &provider, csrf_cookie != NULL) == TRUE)\n\t\t\t&& (provider != NULL)) {\n\n\t\t/* now we've got a selected OP, send the user there to authenticate */\n\t\treturn oidc_authenticate_user(r, c, provider, target_link_uri,\n\t\t\t\tlogin_hint, NULL, NULL, auth_request_params, path_scopes);\n\t}\n\n\t/* something went wrong */\n\treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n\t\t\t\"Could not find valid provider metadata for the selected OpenID Connect provider; contact the administrator\",\n\t\t\tHTTP_NOT_FOUND);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,8 @@\n \t\t\t*auth_request_params = NULL, *csrf_cookie, *csrf_query = NULL,\n \t\t\t*user = NULL, *path_scopes;\n \toidc_provider_t *provider = NULL;\n+\tchar *error_str = NULL;\n+\tchar *error_description = NULL;\n \n \toidc_util_get_request_parameter(r, OIDC_DISC_OP_PARAM, &issuer);\n \toidc_util_get_request_parameter(r, OIDC_DISC_USER_PARAM, &user);\n@@ -48,12 +50,20 @@\n \t\ttarget_link_uri = c->default_sso_url;\n \t}\n \n-\t/* do open redirect prevention */\n+\t/* do open redirect prevention, step 1 */\n \tif (oidc_target_link_uri_matches_configuration(r, c, target_link_uri)\n \t\t\t== FALSE) {\n \t\treturn oidc_util_html_send_error(r, c->error_template,\n \t\t\t\t\"Invalid Request\",\n \t\t\t\t\"\\\"target_link_uri\\\" parameter does not match configuration settings, aborting to prevent an open redirect.\",\n+\t\t\t\tHTTP_UNAUTHORIZED);\n+\t}\n+\n+\t/* do input validation on the target_link_uri parameter value, step 2 */\n+\tif (oidc_validate_redirect_url(r, c, target_link_uri, TRUE, &error_str,\n+\t\t\t&error_description) == FALSE) {\n+\t\treturn oidc_util_html_send_error(r, c->error_template, error_str,\n+\t\t\t\terror_description,\n \t\t\t\tHTTP_UNAUTHORIZED);\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t/* do open redirect prevention */"
            ],
            "added_lines": [
                "\tchar *error_str = NULL;",
                "\tchar *error_description = NULL;",
                "\t/* do open redirect prevention, step 1 */",
                "\t\t\t\tHTTP_UNAUTHORIZED);",
                "\t}",
                "",
                "\t/* do input validation on the target_link_uri parameter value, step 2 */",
                "\tif (oidc_validate_redirect_url(r, c, target_link_uri, TRUE, &error_str,",
                "\t\t\t&error_description) == FALSE) {",
                "\t\treturn oidc_util_html_send_error(r, c->error_template, error_str,",
                "\t\t\t\terror_description,"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-14857",
        "func_name": "OpenIDC/mod_auth_openidc/oidc_handle_logout",
        "description": "A flaw was found in mod_auth_openidc before version 2.4.0.1. An open redirect issue exists in URLs with trailing slashes similar to CVE-2019-3877 in mod_auth_mellon.",
        "git_url": "https://github.com/OpenIDC/mod_auth_openidc/commit/5c15dfb08106c2451c2c44ce7ace6813c216ba75",
        "commit_title": "improve validation of the post-logout URL; closes #449",
        "commit_text": " - to avoid an open redirect; thanks AIMOTO Norihito - release 2.4.0.1 ",
        "func_before": "static int oidc_handle_logout(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\toidc_provider_t *provider = NULL;\n\t/* pickup the command or URL where the user wants to go after logout */\n\tchar *url = NULL;\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_LOGOUT, &url);\n\n\toidc_debug(r, \"enter (url=%s)\", url);\n\n\tif (oidc_is_front_channel_logout(url)) {\n\t\treturn oidc_handle_logout_request(r, c, session, url);\n\t} else if (oidc_is_back_channel_logout(url)) {\n\t\treturn oidc_handle_logout_backchannel(r, c);\n\t}\n\n\tif ((url == NULL) || (apr_strnatcmp(url, \"\") == 0)) {\n\n\t\turl = c->default_slo_url;\n\n\t} else {\n\n\t\t/* do input validation on the logout parameter value */\n\n\t\tconst char *error_description = NULL;\n\t\tapr_uri_t uri;\n\n\t\tif (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {\n\t\t\tconst char *error_description = apr_psprintf(r->pool,\n\t\t\t\t\t\"Logout URL malformed: %s\", url);\n\t\t\toidc_error(r, \"%s\", error_description);\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Malformed URL\", error_description,\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\n\t\t}\n\n\t\tconst char *c_host = oidc_get_current_url_host(r);\n\t\tif ((uri.hostname != NULL)\n\t\t\t\t&& ((strstr(c_host, uri.hostname) == NULL)\n\t\t\t\t\t\t|| (strstr(uri.hostname, c_host) == NULL))) {\n\t\t\terror_description =\n\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n\t\t\toidc_error(r, \"%s\", error_description);\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\", error_description,\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t}\n\n\t\t/* validate the URL to prevent HTTP header splitting */\n\t\tif (((strstr(url, \"\\n\") != NULL) || strstr(url, \"\\r\") != NULL)) {\n\t\t\terror_description =\n\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\"logout value \\\"%s\\\" contains illegal \\\"\\n\\\" or \\\"\\r\\\" character(s)\",\n\t\t\t\t\t\t\turl);\n\t\t\toidc_error(r, \"%s\", error_description);\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\", error_description,\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t}\n\t}\n\n\toidc_get_provider_from_session(r, c, session, &provider);\n\n\tif ((provider != NULL) && (provider->end_session_endpoint != NULL)) {\n\n\t\tconst char *id_token_hint = oidc_session_get_idtoken(r, session);\n\n\t\tchar *logout_request = apr_pstrdup(r->pool,\n\t\t\t\tprovider->end_session_endpoint);\n\t\tif (id_token_hint != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool, \"%s%sid_token_hint=%s\",\n\t\t\t\t\tlogout_request, strchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, id_token_hint));\n\t\t}\n\n\t\tif (url != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool,\n\t\t\t\t\t\"%s%spost_logout_redirect_uri=%s\", logout_request,\n\t\t\t\t\tstrchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, url));\n\t\t}\n\t\turl = logout_request;\n\t}\n\n\treturn oidc_handle_logout_request(r, c, session, url);\n}",
        "func": "static int oidc_handle_logout(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\toidc_provider_t *provider = NULL;\n\t/* pickup the command or URL where the user wants to go after logout */\n\tchar *url = NULL;\n\tchar *error_str = NULL;\n\tchar *error_description = NULL;\n\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_LOGOUT, &url);\n\n\toidc_debug(r, \"enter (url=%s)\", url);\n\n\tif (oidc_is_front_channel_logout(url)) {\n\t\treturn oidc_handle_logout_request(r, c, session, url);\n\t} else if (oidc_is_back_channel_logout(url)) {\n\t\treturn oidc_handle_logout_backchannel(r, c);\n\t}\n\n\tif ((url == NULL) || (apr_strnatcmp(url, \"\") == 0)) {\n\n\t\turl = c->default_slo_url;\n\n\t} else {\n\n\t\t/* do input validation on the logout parameter value */\n\t\tif (oidc_validate_post_logout_url(r, url, &error_str,\n\t\t\t\t&error_description) == FALSE) {\n\t\t\treturn oidc_util_html_send_error(r, c->error_template, error_str,\n\t\t\t\t\terror_description,\n\t\t\t\t\tHTTP_BAD_REQUEST);\n\t\t}\n\t}\n\n\toidc_get_provider_from_session(r, c, session, &provider);\n\n\tif ((provider != NULL) && (provider->end_session_endpoint != NULL)) {\n\n\t\tconst char *id_token_hint = oidc_session_get_idtoken(r, session);\n\n\t\tchar *logout_request = apr_pstrdup(r->pool,\n\t\t\t\tprovider->end_session_endpoint);\n\t\tif (id_token_hint != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool, \"%s%sid_token_hint=%s\",\n\t\t\t\t\tlogout_request, strchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, id_token_hint));\n\t\t}\n\n\t\tif (url != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool,\n\t\t\t\t\t\"%s%spost_logout_redirect_uri=%s\", logout_request,\n\t\t\t\t\tstrchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, url));\n\t\t}\n\t\turl = logout_request;\n\t}\n\n\treturn oidc_handle_logout_request(r, c, session, url);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,9 @@\n \toidc_provider_t *provider = NULL;\n \t/* pickup the command or URL where the user wants to go after logout */\n \tchar *url = NULL;\n+\tchar *error_str = NULL;\n+\tchar *error_description = NULL;\n+\n \toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_LOGOUT, &url);\n \n \toidc_debug(r, \"enter (url=%s)\", url);\n@@ -21,44 +24,11 @@\n \t} else {\n \n \t\t/* do input validation on the logout parameter value */\n-\n-\t\tconst char *error_description = NULL;\n-\t\tapr_uri_t uri;\n-\n-\t\tif (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {\n-\t\t\tconst char *error_description = apr_psprintf(r->pool,\n-\t\t\t\t\t\"Logout URL malformed: %s\", url);\n-\t\t\toidc_error(r, \"%s\", error_description);\n-\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n-\t\t\t\t\t\"Malformed URL\", error_description,\n-\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n-\n-\t\t}\n-\n-\t\tconst char *c_host = oidc_get_current_url_host(r);\n-\t\tif ((uri.hostname != NULL)\n-\t\t\t\t&& ((strstr(c_host, uri.hostname) == NULL)\n-\t\t\t\t\t\t|| (strstr(uri.hostname, c_host) == NULL))) {\n-\t\t\terror_description =\n-\t\t\t\t\tapr_psprintf(r->pool,\n-\t\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n-\t\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n-\t\t\toidc_error(r, \"%s\", error_description);\n-\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n-\t\t\t\t\t\"Invalid Request\", error_description,\n-\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n-\t\t}\n-\n-\t\t/* validate the URL to prevent HTTP header splitting */\n-\t\tif (((strstr(url, \"\\n\") != NULL) || strstr(url, \"\\r\") != NULL)) {\n-\t\t\terror_description =\n-\t\t\t\t\tapr_psprintf(r->pool,\n-\t\t\t\t\t\t\t\"logout value \\\"%s\\\" contains illegal \\\"\\n\\\" or \\\"\\r\\\" character(s)\",\n-\t\t\t\t\t\t\turl);\n-\t\t\toidc_error(r, \"%s\", error_description);\n-\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n-\t\t\t\t\t\"Invalid Request\", error_description,\n-\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n+\t\tif (oidc_validate_post_logout_url(r, url, &error_str,\n+\t\t\t\t&error_description) == FALSE) {\n+\t\t\treturn oidc_util_html_send_error(r, c->error_template, error_str,\n+\t\t\t\t\terror_description,\n+\t\t\t\t\tHTTP_BAD_REQUEST);\n \t\t}\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "\t\tconst char *error_description = NULL;",
                "\t\tapr_uri_t uri;",
                "",
                "\t\tif (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {",
                "\t\t\tconst char *error_description = apr_psprintf(r->pool,",
                "\t\t\t\t\t\"Logout URL malformed: %s\", url);",
                "\t\t\toidc_error(r, \"%s\", error_description);",
                "\t\t\treturn oidc_util_html_send_error(r, c->error_template,",
                "\t\t\t\t\t\"Malformed URL\", error_description,",
                "\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);",
                "",
                "\t\t}",
                "",
                "\t\tconst char *c_host = oidc_get_current_url_host(r);",
                "\t\tif ((uri.hostname != NULL)",
                "\t\t\t\t&& ((strstr(c_host, uri.hostname) == NULL)",
                "\t\t\t\t\t\t|| (strstr(uri.hostname, c_host) == NULL))) {",
                "\t\t\terror_description =",
                "\t\t\t\t\tapr_psprintf(r->pool,",
                "\t\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",",
                "\t\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);",
                "\t\t\toidc_error(r, \"%s\", error_description);",
                "\t\t\treturn oidc_util_html_send_error(r, c->error_template,",
                "\t\t\t\t\t\"Invalid Request\", error_description,",
                "\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);",
                "\t\t}",
                "",
                "\t\t/* validate the URL to prevent HTTP header splitting */",
                "\t\tif (((strstr(url, \"\\n\") != NULL) || strstr(url, \"\\r\") != NULL)) {",
                "\t\t\terror_description =",
                "\t\t\t\t\tapr_psprintf(r->pool,",
                "\t\t\t\t\t\t\t\"logout value \\\"%s\\\" contains illegal \\\"\\n\\\" or \\\"\\r\\\" character(s)\",",
                "\t\t\t\t\t\t\turl);",
                "\t\t\toidc_error(r, \"%s\", error_description);",
                "\t\t\treturn oidc_util_html_send_error(r, c->error_template,",
                "\t\t\t\t\t\"Invalid Request\", error_description,",
                "\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);"
            ],
            "added_lines": [
                "\tchar *error_str = NULL;",
                "\tchar *error_description = NULL;",
                "",
                "\t\tif (oidc_validate_post_logout_url(r, url, &error_str,",
                "\t\t\t\t&error_description) == FALSE) {",
                "\t\t\treturn oidc_util_html_send_error(r, c->error_template, error_str,",
                "\t\t\t\t\terror_description,",
                "\t\t\t\t\tHTTP_BAD_REQUEST);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-14857",
        "func_name": "OpenIDC/mod_auth_openidc/oidc_validate_post_logout_url",
        "description": "A flaw was found in mod_auth_openidc before version 2.4.0.1. An open redirect issue exists in URLs with trailing slashes similar to CVE-2019-3877 in mod_auth_mellon.",
        "git_url": "https://github.com/OpenIDC/mod_auth_openidc/commit/ce37080c6aea30aabae8b4a9b4eea7808445cc8e",
        "commit_title": "2.4.0.2 oops",
        "commit_text": "",
        "func_before": "static apr_byte_t oidc_validate_post_logout_url(request_rec *r, const char *url,\n\t\tchar **err_str, char **err_desc) {\n\tapr_uri_t uri;\n\tconst char *c_host = NULL;\n\n\tif (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc = apr_psprintf(r->pool, \"Logout URL malformed: %s\", url);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\n\tc_host = oidc_get_current_url_host(r);\n\tif ((uri.hostname != NULL)\n\t\t\t&& ((strstr(c_host, uri.hostname) == NULL)\n\t\t\t\t\t|| (strstr(uri.hostname, c_host) == NULL))) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t} else if (strstr(url, \"/\") != url) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"No hostname was parsed and it does not seem to be relative, i.e starting with '/': %s\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\n\t/* validate the URL to prevent HTTP header splitting */\n\tif (((strstr(url, \"\\n\") != NULL) || strstr(url, \"\\r\") != NULL)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" contains illegal \\\"\\n\\\" or \\\"\\r\\\" character(s)\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
        "func": "static apr_byte_t oidc_validate_post_logout_url(request_rec *r, const char *url,\n\t\tchar **err_str, char **err_desc) {\n\tapr_uri_t uri;\n\tconst char *c_host = NULL;\n\n\tif (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc = apr_psprintf(r->pool, \"Logout URL malformed: %s\", url);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\n\tc_host = oidc_get_current_url_host(r);\n\tif ((uri.hostname != NULL)\n\t\t\t&& ((strstr(c_host, uri.hostname) == NULL)\n\t\t\t\t\t|| (strstr(uri.hostname, c_host) == NULL))) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t} else if ((uri.hostname == NULL) && (strstr(url, \"/\") != url)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"No hostname was parsed and it does not seem to be relative, i.e starting with '/': %s\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\n\t/* validate the URL to prevent HTTP header splitting */\n\tif (((strstr(url, \"\\n\") != NULL) || strstr(url, \"\\r\") != NULL)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" contains illegal \\\"\\n\\\" or \\\"\\r\\\" character(s)\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,7 @@\n \t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n \t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n \t\treturn FALSE;\n-\t} else if (strstr(url, \"/\") != url) {\n+\t} else if ((uri.hostname == NULL) && (strstr(url, \"/\") != url)) {\n \t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n \t\t*err_desc =\n \t\t\t\tapr_psprintf(r->pool,",
        "diff_line_info": {
            "deleted_lines": [
                "\t} else if (strstr(url, \"/\") != url) {"
            ],
            "added_lines": [
                "\t} else if ((uri.hostname == NULL) && (strstr(url, \"/\") != url)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52263",
        "func_name": "brave/brave-core/BraveContentBrowserClient::HandleURLOverrideRewrite",
        "description": "Brave Browser before 1.59.40 does not properly restrict the schema for WebUI factory and redirect. This is related to browser/brave_content_browser_client.cc and browser/ui/webui/brave_web_ui_controller_factory.cc.",
        "git_url": "https://github.com/brave/brave-core/commit/9da202f7f4bc80b6975909b684bbc0764a31c4e9",
        "commit_title": "Further restrict the schema for WebUI factory and redirect",
        "commit_text": " Fixes https://github.com/brave/brave-browser/issues/32449 Contains follow up feedback for https://girave-browser/issthub.com/brave/bues/32425",
        "func_before": "bool BraveContentBrowserClient::HandleURLOverrideRewrite(\n    GURL* url,\n    content::BrowserContext* browser_context) {\n  if (url->host() == chrome::kChromeUISyncHost) {\n    GURL::Replacements replacements;\n    replacements.SetSchemeStr(content::kChromeUIScheme);\n    replacements.SetHostStr(chrome::kChromeUISettingsHost);\n    replacements.SetPathStr(kBraveSyncPath);\n    *url = url->ReplaceComponents(replacements);\n    return true;\n  }\n\n#if !BUILDFLAG(IS_ANDROID)\n  if (url->host() == kAdblockHost) {\n    GURL::Replacements replacements;\n    replacements.SetSchemeStr(content::kChromeUIScheme);\n    replacements.SetHostStr(chrome::kChromeUISettingsHost);\n    replacements.SetPathStr(kContentFiltersPath);\n    *url = url->ReplaceComponents(replacements);\n    return false;\n  }\n#endif\n\n  // no special win10 welcome page\n  if (url->host() == chrome::kChromeUIWelcomeHost) {\n    *url = GURL(chrome::kChromeUIWelcomeURL);\n    return true;\n  }\n\n#if BUILDFLAG(ETHEREUM_REMOTE_CLIENT_ENABLED) && BUILDFLAG(ENABLE_EXTENSIONS)\n  auto* prefs = user_prefs::UserPrefs::Get(browser_context);\n  brave_wallet::mojom::DefaultWallet default_wallet =\n      brave_wallet::GetDefaultEthereumWallet(prefs);\n  if (!brave_wallet::IsNativeWalletEnabled() ||\n      default_wallet == brave_wallet::mojom::DefaultWallet::CryptoWallets) {\n    // If the Crypto Wallets extension is loaded, then it replaces the WebUI\n    auto* service =\n        EthereumRemoteClientServiceFactory::GetForContext(browser_context);\n    if (service->IsCryptoWalletsReady() &&\n        url->SchemeIs(content::kChromeUIScheme) &&\n        url->host() == ethereum_remote_client_host) {\n      auto* registry = extensions::ExtensionRegistry::Get(browser_context);\n      if (registry && registry->ready_extensions().GetByID(\n                          ethereum_remote_client_extension_id)) {\n        *url = GURL(ethereum_remote_client_base_url);\n        return true;\n      }\n    }\n  }\n#endif\n\n  return false;\n}",
        "func": "bool BraveContentBrowserClient::HandleURLOverrideRewrite(\n    GURL* url,\n    content::BrowserContext* browser_context) {\n  // Some of these rewrites are for WebUI pages with URL that has moved.\n  // After rewrite happens, GetWebUIFactoryFunction() will work as expected.\n  // (see browser\\ui\\webui\\brave_web_ui_controller_factory.cc for more info)\n  //\n  // Scope of schema is intentionally narrower than content::HasWebUIScheme(url)\n  // which also allows both `chrome-untrusted` and `chrome-devtools`.\n  if (!url->SchemeIs(content::kBraveUIScheme) &&\n      !url->SchemeIs(content::kChromeUIScheme)) {\n    return false;\n  }\n\n  // brave://sync => brave://settings/braveSync\n  if (url->host() == chrome::kChromeUISyncHost) {\n    GURL::Replacements replacements;\n    replacements.SetSchemeStr(content::kChromeUIScheme);\n    replacements.SetHostStr(chrome::kChromeUISettingsHost);\n    replacements.SetPathStr(kBraveSyncPath);\n    *url = url->ReplaceComponents(replacements);\n    return true;\n  }\n\n#if !BUILDFLAG(IS_ANDROID)\n  // brave://adblock => brave://settings/shields/filters\n  if (url->host() == kAdblockHost) {\n    GURL::Replacements replacements;\n    replacements.SetSchemeStr(content::kChromeUIScheme);\n    replacements.SetHostStr(chrome::kChromeUISettingsHost);\n    replacements.SetPathStr(kContentFiltersPath);\n    *url = url->ReplaceComponents(replacements);\n    return false;\n  }\n#endif\n\n  // no special win10 welcome page\n  if (url->host() == chrome::kChromeUIWelcomeHost) {\n    *url = GURL(chrome::kChromeUIWelcomeURL);\n    return true;\n  }\n\n#if BUILDFLAG(ETHEREUM_REMOTE_CLIENT_ENABLED) && BUILDFLAG(ENABLE_EXTENSIONS)\n  auto* prefs = user_prefs::UserPrefs::Get(browser_context);\n  brave_wallet::mojom::DefaultWallet default_wallet =\n      brave_wallet::GetDefaultEthereumWallet(prefs);\n  if (!brave_wallet::IsNativeWalletEnabled() ||\n      default_wallet == brave_wallet::mojom::DefaultWallet::CryptoWallets) {\n    // If the Crypto Wallets extension is loaded, then it replaces the WebUI\n    auto* service =\n        EthereumRemoteClientServiceFactory::GetForContext(browser_context);\n    if (service->IsCryptoWalletsReady() &&\n        url->SchemeIs(content::kChromeUIScheme) &&\n        url->host() == ethereum_remote_client_host) {\n      auto* registry = extensions::ExtensionRegistry::Get(browser_context);\n      if (registry && registry->ready_extensions().GetByID(\n                          ethereum_remote_client_extension_id)) {\n        *url = GURL(ethereum_remote_client_base_url);\n        return true;\n      }\n    }\n  }\n#endif\n\n  return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,18 @@\n bool BraveContentBrowserClient::HandleURLOverrideRewrite(\n     GURL* url,\n     content::BrowserContext* browser_context) {\n+  // Some of these rewrites are for WebUI pages with URL that has moved.\n+  // After rewrite happens, GetWebUIFactoryFunction() will work as expected.\n+  // (see browser\\ui\\webui\\brave_web_ui_controller_factory.cc for more info)\n+  //\n+  // Scope of schema is intentionally narrower than content::HasWebUIScheme(url)\n+  // which also allows both `chrome-untrusted` and `chrome-devtools`.\n+  if (!url->SchemeIs(content::kBraveUIScheme) &&\n+      !url->SchemeIs(content::kChromeUIScheme)) {\n+    return false;\n+  }\n+\n+  // brave://sync => brave://settings/braveSync\n   if (url->host() == chrome::kChromeUISyncHost) {\n     GURL::Replacements replacements;\n     replacements.SetSchemeStr(content::kChromeUIScheme);\n@@ -11,6 +23,7 @@\n   }\n \n #if !BUILDFLAG(IS_ANDROID)\n+  // brave://adblock => brave://settings/shields/filters\n   if (url->host() == kAdblockHost) {\n     GURL::Replacements replacements;\n     replacements.SetSchemeStr(content::kChromeUIScheme);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  // Some of these rewrites are for WebUI pages with URL that has moved.",
                "  // After rewrite happens, GetWebUIFactoryFunction() will work as expected.",
                "  // (see browser\\ui\\webui\\brave_web_ui_controller_factory.cc for more info)",
                "  //",
                "  // Scope of schema is intentionally narrower than content::HasWebUIScheme(url)",
                "  // which also allows both `chrome-untrusted` and `chrome-devtools`.",
                "  if (!url->SchemeIs(content::kBraveUIScheme) &&",
                "      !url->SchemeIs(content::kChromeUIScheme)) {",
                "    return false;",
                "  }",
                "",
                "  // brave://sync => brave://settings/braveSync",
                "  // brave://adblock => brave://settings/shields/filters"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52263",
        "func_name": "brave/brave-core/GetWebUIFactoryFunction",
        "description": "Brave Browser before 1.59.40 does not properly restrict the schema for WebUI factory and redirect. This is related to browser/brave_content_browser_client.cc and browser/ui/webui/brave_web_ui_controller_factory.cc.",
        "git_url": "https://github.com/brave/brave-core/commit/9da202f7f4bc80b6975909b684bbc0764a31c4e9",
        "commit_title": "Further restrict the schema for WebUI factory and redirect",
        "commit_text": " Fixes https://github.com/brave/brave-browser/issues/32449 Contains follow up feedback for https://girave-browser/issthub.com/brave/bues/32425",
        "func_before": "WebUIFactoryFunction GetWebUIFactoryFunction(WebUI* web_ui,\n                                             Profile* profile,\n                                             const GURL& url) {\n  // This will get called a lot to check all URLs, so do a quick check of other\n  // schemes to filter out most URLs.\n  if (!content::HasWebUIScheme(url)) {\n    return nullptr;\n  }\n\n  if (url.host_piece() == kAdblockHost ||\n      url.host_piece() == kAdblockInternalsHost ||\n      url.host_piece() == kWebcompatReporterHost ||\n      (url.host_piece() == kSkusInternalsHost &&\n       base::FeatureList::IsEnabled(skus::features::kSkusFeature)) ||\n#if BUILDFLAG(ENABLE_IPFS_INTERNALS_WEBUI)\n      (url.host_piece() == kIPFSWebUIHost &&\n       ipfs::IpfsServiceFactory::IsIpfsEnabled(profile)) ||\n#endif  // BUILDFLAG(ENABLE_IPFS_INTERNALS_WEBUI)\n#if BUILDFLAG(IS_ANDROID)\n      (url.is_valid() && url.host_piece() == kWalletPageHost &&\n       (url.path() == kWalletSwapPagePath ||\n        url.path() == kWalletSendPagePath || url.path() == kWalletBuyPagePath ||\n        url.path() == kWalletDepositPagePath)) ||\n#else\n      (base::FeatureList::IsEnabled(\n           brave_news::features::kBraveNewsFeedUpdate) &&\n       url.host_piece() == kBraveNewsInternalsHost) ||\n      ((url.host_piece() == kWalletPanelHost ||\n        url.host_piece() == kWalletPageHost) &&\n       brave_wallet::IsAllowedForContext(profile)) ||\n      url.host_piece() == kBraveRewardsPanelHost ||\n      url.host_piece() == kBraveTipPanelHost ||\n      url.host_piece() == kSpeedreaderPanelHost ||\n      // On Android New Tab is a native page implemented in Java, so no need in\n      // WebUI.\n      url.host_piece() == chrome::kChromeUINewTabHost ||\n      url.host_piece() == chrome::kChromeUISettingsHost ||\n      ((url.host_piece() == kWelcomeHost ||\n        url.host_piece() == chrome::kChromeUIWelcomeURL) &&\n       !profile->IsGuestSession()) ||\n      url.host_piece() == kShieldsPanelHost ||\n      (url.host_piece() == kCookieListOptInHost &&\n       base::FeatureList::IsEnabled(\n           brave_shields::features::kBraveAdblockCookieListOptIn)) ||\n#endif  // BUILDFLAG(IS_ANDROID)\n#if BUILDFLAG(ENABLE_TOR)\n      url.host_piece() == kTorInternalsHost ||\n#endif\n      url.host_piece() == kRewardsPageHost ||\n      url.host_piece() == kRewardsInternalsHost) {\n    return &NewWebUI;\n  }\n\n  return nullptr;\n}",
        "func": "WebUIFactoryFunction GetWebUIFactoryFunction(WebUI* web_ui,\n                                             Profile* profile,\n                                             const GURL& url) {\n  // This will get called a lot to check all URLs, so do a quick check of other\n  // schemes to filter out most URLs.\n  //\n  // This has a narrow scoper scope than content::HasWebUIScheme(url) which also\n  // allows both `chrome-untrusted` and `chrome-devtools`.\n  if (!url.SchemeIs(content::kBraveUIScheme) &&\n      !url.SchemeIs(content::kChromeUIScheme)) {\n    return nullptr;\n  }\n\n  if (url.host_piece() == kAdblockHost ||\n      url.host_piece() == kAdblockInternalsHost ||\n      url.host_piece() == kWebcompatReporterHost ||\n      (url.host_piece() == kSkusInternalsHost &&\n       base::FeatureList::IsEnabled(skus::features::kSkusFeature)) ||\n#if BUILDFLAG(ENABLE_IPFS_INTERNALS_WEBUI)\n      (url.host_piece() == kIPFSWebUIHost &&\n       ipfs::IpfsServiceFactory::IsIpfsEnabled(profile)) ||\n#endif  // BUILDFLAG(ENABLE_IPFS_INTERNALS_WEBUI)\n#if BUILDFLAG(IS_ANDROID)\n      (url.is_valid() && url.host_piece() == kWalletPageHost &&\n       (url.path() == kWalletSwapPagePath ||\n        url.path() == kWalletSendPagePath || url.path() == kWalletBuyPagePath ||\n        url.path() == kWalletDepositPagePath)) ||\n#else\n      (base::FeatureList::IsEnabled(\n           brave_news::features::kBraveNewsFeedUpdate) &&\n       url.host_piece() == kBraveNewsInternalsHost) ||\n      ((url.host_piece() == kWalletPanelHost ||\n        url.host_piece() == kWalletPageHost) &&\n       brave_wallet::IsAllowedForContext(profile)) ||\n      url.host_piece() == kBraveRewardsPanelHost ||\n      url.host_piece() == kBraveTipPanelHost ||\n      url.host_piece() == kSpeedreaderPanelHost ||\n      // On Android New Tab is a native page implemented in Java, so no need in\n      // WebUI.\n      url.host_piece() == chrome::kChromeUINewTabHost ||\n      url.host_piece() == chrome::kChromeUISettingsHost ||\n      ((url.host_piece() == kWelcomeHost ||\n        url.host_piece() == chrome::kChromeUIWelcomeURL) &&\n       !profile->IsGuestSession()) ||\n      url.host_piece() == kShieldsPanelHost ||\n      (url.host_piece() == kCookieListOptInHost &&\n       base::FeatureList::IsEnabled(\n           brave_shields::features::kBraveAdblockCookieListOptIn)) ||\n#endif  // BUILDFLAG(IS_ANDROID)\n#if BUILDFLAG(ENABLE_TOR)\n      url.host_piece() == kTorInternalsHost ||\n#endif\n      url.host_piece() == kRewardsPageHost ||\n      url.host_piece() == kRewardsInternalsHost) {\n    return &NewWebUI;\n  }\n\n  return nullptr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,11 @@\n                                              const GURL& url) {\n   // This will get called a lot to check all URLs, so do a quick check of other\n   // schemes to filter out most URLs.\n-  if (!content::HasWebUIScheme(url)) {\n+  //\n+  // This has a narrow scoper scope than content::HasWebUIScheme(url) which also\n+  // allows both `chrome-untrusted` and `chrome-devtools`.\n+  if (!url.SchemeIs(content::kBraveUIScheme) &&\n+      !url.SchemeIs(content::kChromeUIScheme)) {\n     return nullptr;\n   }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  if (!content::HasWebUIScheme(url)) {"
            ],
            "added_lines": [
                "  //",
                "  // This has a narrow scoper scope than content::HasWebUIScheme(url) which also",
                "  // allows both `chrome-untrusted` and `chrome-devtools`.",
                "  if (!url.SchemeIs(content::kBraveUIScheme) &&",
                "      !url.SchemeIs(content::kChromeUIScheme)) {"
            ]
        }
    }
]