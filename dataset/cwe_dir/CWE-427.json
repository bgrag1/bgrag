[
    {
        "cve_id": "CVE-2022-32168",
        "func_name": "notepad-plus-plus/MiniDumper::writeDump",
        "description": "Notepad++ versions 8.4.1 and before are vulnerable to DLL hijacking where an attacker can replace the vulnerable dll (UxTheme.dll) with his own dll and run arbitrary code in the context of Notepad++.",
        "git_url": "https://github.com/notepad-plus-plus/notepad-plus-plus/commit/85d7215d9b3e0d5a8433fc31aec4f2966821051e",
        "commit_title": "Fixes security vulnerability",
        "commit_text": " Fix #12113, close #12114",
        "func_before": "bool MiniDumper::writeDump(EXCEPTION_POINTERS * pExceptionInfo)\n{\n\tTCHAR szDumpPath[MAX_PATH];\n\tTCHAR szScratch[MAX_PATH];\n\tLPCTSTR szResult = NULL;\n\tbool retval = false;\n\n\tHMODULE hDll = ::LoadLibrary( TEXT(\"DBGHELP.DLL\") );\t//that wont work on older windows version than XP, #care :)\n\n\tif (hDll)\n\t{\n\t\tMINIDUMPWRITEDUMP pDump = (MINIDUMPWRITEDUMP)::GetProcAddress( hDll, \"MiniDumpWriteDump\" );\n\t\tif (pDump)\n\t\t{\n\t\t\t::GetModuleFileName(NULL, szDumpPath, MAX_PATH);\n\t\t\t::PathRemoveFileSpec(szDumpPath);\n\t\t\twcscat_s(szDumpPath, TEXT(\"\\\\NppDump.dmp\"));\n\n\t\t\t// ask the user if they want to save a dump file\n\t\t\tint msgret = ::MessageBox(NULL, TEXT(\"Do you want to save a dump file?\\r\\nDoing so can aid in developing Notepad++.\"), msgTitle, MB_YESNO);\n\t\t\tif (msgret == IDYES)\n\t\t\t{\n\t\t\t\t// create the file\n\t\t\t\tHANDLE hFile = ::CreateFile( szDumpPath, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS,\n\t\t\t\t\t\t\t\t\t\t\tFILE_ATTRIBUTE_NORMAL, NULL );\n\n\t\t\t\tif (hFile!=INVALID_HANDLE_VALUE)\n\t\t\t\t{\n\t\t\t\t\t_MINIDUMP_EXCEPTION_INFORMATION ExInfo;\n\n\t\t\t\t\tExInfo.ThreadId = ::GetCurrentThreadId();\n\t\t\t\t\tExInfo.ExceptionPointers = pExceptionInfo;\n\t\t\t\t\tExInfo.ClientPointers = NULL;\n\n\t\t\t\t\t// write the dump\n\t\t\t\t\tBOOL bOK = pDump( GetCurrentProcess(), GetCurrentProcessId(), hFile, MiniDumpNormal, &ExInfo, NULL, NULL );\n\t\t\t\t\tif (bOK)\n\t\t\t\t\t{\n\t\t\t\t\t\twsprintf( szScratch, TEXT(\"Saved dump file to '%s'\"), szDumpPath );\n\t\t\t\t\t\tszResult = szScratch;\n\t\t\t\t\t\tretval = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twsprintf( szScratch, TEXT(\"Failed to save dump file to '%s' (error %d)\"), szDumpPath, GetLastError() );\n\t\t\t\t\t\tszResult = szScratch;\n\t\t\t\t\t}\n\t\t\t\t\t::CloseHandle(hFile);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twsprintf( szScratch, TEXT(\"Failed to create dump file '%s' (error %d)\"), szDumpPath, GetLastError() );\n\t\t\t\t\tszResult = szScratch;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tszResult = TEXT(\"The debugging DLL is outdated,\\r\\nfind a recent copy of dbghelp.dll and install it.\");\n\t\t}\n\t\t::FreeLibrary(hDll);\n\t}\n\telse\n\t{\n\t\tszResult = TEXT(\"Unable to load the debugging DLL,\\r\\nfind a recent copy of dbghelp.dll and install it.\");\n\t}\n\n\tif (szResult)\n\t\t::MessageBox(NULL, szResult, msgTitle, MB_OK);\n\n\treturn retval;\n}",
        "func": "bool MiniDumper::writeDump(EXCEPTION_POINTERS * pExceptionInfo)\n{\n\tTCHAR szDumpPath[MAX_PATH];\n\tTCHAR szScratch[MAX_PATH];\n\tLPCTSTR szResult = NULL;\n\tbool retval = false;\n\n\tHMODULE hDll = ::LoadLibraryEx(TEXT(\"DBGHELP.DLL\"), nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);\t//that wont work on older windows version than XP, #care :)\n\n\tif (hDll)\n\t{\n\t\tMINIDUMPWRITEDUMP pDump = (MINIDUMPWRITEDUMP)::GetProcAddress( hDll, \"MiniDumpWriteDump\" );\n\t\tif (pDump)\n\t\t{\n\t\t\t::GetModuleFileName(NULL, szDumpPath, MAX_PATH);\n\t\t\t::PathRemoveFileSpec(szDumpPath);\n\t\t\twcscat_s(szDumpPath, TEXT(\"\\\\NppDump.dmp\"));\n\n\t\t\t// ask the user if they want to save a dump file\n\t\t\tint msgret = ::MessageBox(NULL, TEXT(\"Do you want to save a dump file?\\r\\nDoing so can aid in developing Notepad++.\"), msgTitle, MB_YESNO);\n\t\t\tif (msgret == IDYES)\n\t\t\t{\n\t\t\t\t// create the file\n\t\t\t\tHANDLE hFile = ::CreateFile( szDumpPath, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS,\n\t\t\t\t\t\t\t\t\t\t\tFILE_ATTRIBUTE_NORMAL, NULL );\n\n\t\t\t\tif (hFile!=INVALID_HANDLE_VALUE)\n\t\t\t\t{\n\t\t\t\t\t_MINIDUMP_EXCEPTION_INFORMATION ExInfo;\n\n\t\t\t\t\tExInfo.ThreadId = ::GetCurrentThreadId();\n\t\t\t\t\tExInfo.ExceptionPointers = pExceptionInfo;\n\t\t\t\t\tExInfo.ClientPointers = NULL;\n\n\t\t\t\t\t// write the dump\n\t\t\t\t\tBOOL bOK = pDump( GetCurrentProcess(), GetCurrentProcessId(), hFile, MiniDumpNormal, &ExInfo, NULL, NULL );\n\t\t\t\t\tif (bOK)\n\t\t\t\t\t{\n\t\t\t\t\t\twsprintf( szScratch, TEXT(\"Saved dump file to '%s'\"), szDumpPath );\n\t\t\t\t\t\tszResult = szScratch;\n\t\t\t\t\t\tretval = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twsprintf( szScratch, TEXT(\"Failed to save dump file to '%s' (error %d)\"), szDumpPath, GetLastError() );\n\t\t\t\t\t\tszResult = szScratch;\n\t\t\t\t\t}\n\t\t\t\t\t::CloseHandle(hFile);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twsprintf( szScratch, TEXT(\"Failed to create dump file '%s' (error %d)\"), szDumpPath, GetLastError() );\n\t\t\t\t\tszResult = szScratch;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tszResult = TEXT(\"The debugging DLL is outdated,\\r\\nfind a recent copy of dbghelp.dll and install it.\");\n\t\t}\n\t\t::FreeLibrary(hDll);\n\t}\n\telse\n\t{\n\t\tszResult = TEXT(\"Unable to load the debugging DLL,\\r\\nfind a recent copy of dbghelp.dll and install it.\");\n\t}\n\n\tif (szResult)\n\t\t::MessageBox(NULL, szResult, msgTitle, MB_OK);\n\n\treturn retval;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \tLPCTSTR szResult = NULL;\n \tbool retval = false;\n \n-\tHMODULE hDll = ::LoadLibrary( TEXT(\"DBGHELP.DLL\") );\t//that wont work on older windows version than XP, #care :)\n+\tHMODULE hDll = ::LoadLibraryEx(TEXT(\"DBGHELP.DLL\"), nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);\t//that wont work on older windows version than XP, #care :)\n \n \tif (hDll)\n \t{",
        "diff_line_info": {
            "deleted_lines": [
                "\tHMODULE hDll = ::LoadLibrary( TEXT(\"DBGHELP.DLL\") );\t//that wont work on older windows version than XP, #care :)"
            ],
            "added_lines": [
                "\tHMODULE hDll = ::LoadLibraryEx(TEXT(\"DBGHELP.DLL\"), nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);\t//that wont work on older windows version than XP, #care :)"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-32168",
        "func_name": "notepad-plus-plus/NppParameters::load",
        "description": "Notepad++ versions 8.4.1 and before are vulnerable to DLL hijacking where an attacker can replace the vulnerable dll (UxTheme.dll) with his own dll and run arbitrary code in the context of Notepad++.",
        "git_url": "https://github.com/notepad-plus-plus/notepad-plus-plus/commit/85d7215d9b3e0d5a8433fc31aec4f2966821051e",
        "commit_title": "Fixes security vulnerability",
        "commit_text": " Fix #12113, close #12114",
        "func_before": "bool NppParameters::load()\n{\n\tL_END = L_EXTERNAL;\n\tbool isAllLaoded = true;\n\n\t_isx64 = sizeof(void *) == 8;\n\n\t// Make localConf.xml path\n\tgeneric_string localConfPath(_nppPath);\n\tpathAppend(localConfPath, localConfFile);\n\n\t// Test if localConf.xml exist\n\t_isLocal = (PathFileExists(localConfPath.c_str()) == TRUE);\n\n\t// Under vista and windows 7, the usage of doLocalConf.xml is not allowed\n\t// if Notepad++ is installed in \"program files\" directory, because of UAC\n\tif (_isLocal)\n\t{\n\t\t// We check if OS is Vista or greater version\n\t\tif (_winVersion >= WV_VISTA)\n\t\t{\n\t\t\tgeneric_string progPath = getSpecialFolderLocation(CSIDL_PROGRAM_FILES);\n\t\t\tTCHAR nppDirLocation[MAX_PATH];\n\t\t\twcscpy_s(nppDirLocation, _nppPath.c_str());\n\t\t\t::PathRemoveFileSpec(nppDirLocation);\n\n\t\t\tif  (progPath == nppDirLocation)\n\t\t\t\t_isLocal = false;\n\t\t}\n\t}\n\n\t_pluginRootDir = _nppPath;\n\tpathAppend(_pluginRootDir, TEXT(\"plugins\"));\n\n\t//\n\t// the 3rd priority: general default configuration\n\t//\n\tgeneric_string nppPluginRootParent;\n\tif (_isLocal)\n\t{\n\t\t_userPath = nppPluginRootParent = _nppPath;\n\t\t_userPluginConfDir = _pluginRootDir;\n\t\tpathAppend(_userPluginConfDir, TEXT(\"Config\"));\n\t}\n\telse\n\t{\n\t\t_userPath = getSpecialFolderLocation(CSIDL_APPDATA);\n\n\t\tpathAppend(_userPath, TEXT(\"Notepad++\"));\n\t\tif (!PathFileExists(_userPath.c_str()))\n\t\t\t::CreateDirectory(_userPath.c_str(), NULL);\n\n\t\t_appdataNppDir = _userPluginConfDir = _userPath;\n\t\tpathAppend(_userPluginConfDir, TEXT(\"plugins\"));\n\t\tif (!PathFileExists(_userPluginConfDir.c_str()))\n\t\t\t::CreateDirectory(_userPluginConfDir.c_str(), NULL);\n\t\tpathAppend(_userPluginConfDir, TEXT(\"Config\"));\n\t\tif (!PathFileExists(_userPluginConfDir.c_str()))\n\t\t\t::CreateDirectory(_userPluginConfDir.c_str(), NULL);\n\n\t\t// For PluginAdmin to launch the wingup with UAC\n\t\tsetElevationRequired(true);\n\t}\n\n\t_pluginConfDir = _pluginRootDir; // for plugin list home\n\tpathAppend(_pluginConfDir, TEXT(\"Config\"));\n\n\tif (!PathFileExists(nppPluginRootParent.c_str()))\n\t\t::CreateDirectory(nppPluginRootParent.c_str(), NULL);\n\tif (!PathFileExists(_pluginRootDir.c_str()))\n\t\t::CreateDirectory(_pluginRootDir.c_str(), NULL);\n\n\t_sessionPath = _userPath; // Session stock the absolute file path, it should never be on cloud\n\n\t// Detection cloud settings\n\tgeneric_string cloudChoicePath{_userPath};\n\tcloudChoicePath += TEXT(\"\\\\cloud\\\\choice\");\n\n\t//\n\t// the 2nd priority: cloud Choice Path\n\t//\n\tif (::PathFileExists(cloudChoicePath.c_str()))\n\t{\n\t\t// Read cloud choice\n\t\tstd::string cloudChoiceStr = getFileContent(cloudChoicePath.c_str());\n\t\tWcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();\n\t\tstd::wstring cloudChoiceStrW = wmc.char2wchar(cloudChoiceStr.c_str(), SC_CP_UTF8);\n\n\t\tif (!cloudChoiceStrW.empty() && ::PathFileExists(cloudChoiceStrW.c_str()))\n\t\t{\n\t\t\t_userPath = cloudChoiceStrW;\n\t\t\t_nppGUI._cloudPath = cloudChoiceStrW;\n\t\t\t_initialCloudChoice = _nppGUI._cloudPath;\n\t\t}\n\t}\n\n\t//\n\t// the 1st priority: custom settings dir via command line argument\n\t//\n\tif (!_cmdSettingsDir.empty())\n\t{\n\t\tif (!::PathIsDirectory(_cmdSettingsDir.c_str()))\n\t\t{\n\t\t\t// The following text is not translatable.\n\t\t\t// _pNativeLangSpeaker is initialized AFTER _userPath being dterminated because nativeLang.xml is from from _userPath.\n\t\t\tgeneric_string errMsg = TEXT(\"The given path\\r\");\n\t\t\terrMsg += _cmdSettingsDir;\n\t\t\terrMsg += TEXT(\"\\nvia command line \\\"-settingsDir=\\\" is not a valid directory.\\rThis argument will be ignored.\");\n\t\t\t::MessageBox(NULL, errMsg.c_str(), TEXT(\"Invalid directory\"), MB_OK);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_userPath = _cmdSettingsDir;\n\t\t\t_sessionPath = _userPath; // reset session path\n\t\t}\n\t}\n\n\t//-------------------------------------//\n\t// Transparent function for w2k and xp //\n\t//-------------------------------------//\n\tHMODULE hUser32 = ::GetModuleHandle(TEXT(\"User32\"));\n\tif (hUser32)\n\t\t_transparentFuncAddr = (WNDPROC)::GetProcAddress(hUser32, \"SetLayeredWindowAttributes\");\n\n\t//---------------------------------------------//\n\t// Dlg theme texture function for xp and vista //\n\t//---------------------------------------------//\n\t_hUXTheme = ::LoadLibrary(TEXT(\"uxtheme.dll\"));\n\tif (_hUXTheme)\n\t\t_enableThemeDialogTextureFuncAddr = (WNDPROC)::GetProcAddress(_hUXTheme, \"EnableThemeDialogTexture\");\n\n\t//--------------------------//\n\t// langs.xml : for per user //\n\t//--------------------------//\n\tgeneric_string langs_xml_path(_userPath);\n\tpathAppend(langs_xml_path, TEXT(\"langs.xml\"));\n\n\tBOOL doRecover = FALSE;\n\tif (::PathFileExists(langs_xml_path.c_str()))\n\t{\n\t\tWIN32_FILE_ATTRIBUTE_DATA attributes;\n\n\t\tif (GetFileAttributesEx(langs_xml_path.c_str(), GetFileExInfoStandard, &attributes) != 0)\n\t\t{\n\t\t\tif (attributes.nFileSizeLow == 0 && attributes.nFileSizeHigh == 0)\n\t\t\t{\n\t\t\t\tif (_pNativeLangSpeaker)\n\t\t\t\t{\n\t\t\t\t\tdoRecover = _pNativeLangSpeaker->messageBox(\"LoadLangsFailed\",\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tTEXT(\"Load langs.xml failed!\\rDo you want to recover your langs.xml?\"),\n\t\t\t\t\t\tTEXT(\"Configurator\"),\n\t\t\t\t\t\tMB_YESNO);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdoRecover = ::MessageBox(NULL, TEXT(\"Load langs.xml failed!\\rDo you want to recover your langs.xml?\"), TEXT(\"Configurator\"), MB_YESNO);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tdoRecover = true;\n\n\tif (doRecover)\n\t{\n\t\tgeneric_string srcLangsPath(_nppPath);\n\t\tpathAppend(srcLangsPath, TEXT(\"langs.model.xml\"));\n\t\t::CopyFile(srcLangsPath.c_str(), langs_xml_path.c_str(), FALSE);\n\t}\n\n\t_pXmlDoc = new TiXmlDocument(langs_xml_path);\n\n\n\tbool loadOkay = _pXmlDoc->LoadFile();\n\tif (!loadOkay)\n\t{\n\t\tif (_pNativeLangSpeaker)\n\t\t{\n\t\t\t_pNativeLangSpeaker->messageBox(\"LoadLangsFailedFinal\",\n\t\t\t\tNULL,\n\t\t\t\tTEXT(\"Load langs.xml failed!\"),\n\t\t\t\tTEXT(\"Configurator\"),\n\t\t\t\tMB_OK);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t::MessageBox(NULL, TEXT(\"Load langs.xml failed!\"), TEXT(\"Configurator\"), MB_OK);\n\t\t}\n\n\t\tdelete _pXmlDoc;\n\t\t_pXmlDoc = nullptr;\n\t\tisAllLaoded = false;\n\t}\n\telse\n\t\tgetLangKeywordsFromXmlTree();\n\n\t//---------------------------//\n\t// config.xml : for per user //\n\t//---------------------------//\n\tgeneric_string configPath(_userPath);\n\tpathAppend(configPath, TEXT(\"config.xml\"));\n\n\tgeneric_string srcConfigPath(_nppPath);\n\tpathAppend(srcConfigPath, TEXT(\"config.model.xml\"));\n\n\tif (!::PathFileExists(configPath.c_str()))\n\t\t::CopyFile(srcConfigPath.c_str(), configPath.c_str(), FALSE);\n\n\t_pXmlUserDoc = new TiXmlDocument(configPath);\n\tloadOkay = _pXmlUserDoc->LoadFile();\n\t\n\tif (!loadOkay)\n\t{\n\t\tTiXmlDeclaration* decl = new TiXmlDeclaration(TEXT(\"1.0\"), TEXT(\"UTF-8\"), TEXT(\"\"));\n\t\t_pXmlUserDoc->LinkEndChild(decl);\n\t}\n\telse\n\t{\n\t\tgetUserParametersFromXmlTree();\n\t}\n\n\t//----------------------------//\n\t// stylers.xml : for per user //\n\t//----------------------------//\n\n\t_stylerPath = _userPath;\n\tpathAppend(_stylerPath, TEXT(\"stylers.xml\"));\n\n\tif (!PathFileExists(_stylerPath.c_str()))\n\t{\n\t\tgeneric_string srcStylersPath(_nppPath);\n\t\tpathAppend(srcStylersPath, TEXT(\"stylers.model.xml\"));\n\n\t\t::CopyFile(srcStylersPath.c_str(), _stylerPath.c_str(), TRUE);\n\t}\n\n\tif (_nppGUI._themeName.empty() || (!PathFileExists(_nppGUI._themeName.c_str())))\n\t\t_nppGUI._themeName.assign(_stylerPath);\n\n\t_pXmlUserStylerDoc = new TiXmlDocument(_nppGUI._themeName.c_str());\n\n\tloadOkay = _pXmlUserStylerDoc->LoadFile();\n\tif (!loadOkay)\n\t{\n\t\tif (_pNativeLangSpeaker)\n\t\t{\n\t\t\t_pNativeLangSpeaker->messageBox(\"LoadStylersFailed\",\n\t\t\t\tNULL,\n\t\t\t\tTEXT(\"Load \\\"$STR_REPLACE$\\\" failed!\"),\n\t\t\t\tTEXT(\"Load stylers.xml failed\"),\n\t\t\t\tMB_OK,\n\t\t\t\t0,\n\t\t\t\t_stylerPath.c_str());\n\t\t}\n\t\telse\n\t\t{\n\t\t\t::MessageBox(NULL, _stylerPath.c_str(), TEXT(\"Load stylers.xml failed\"), MB_OK);\n\t\t}\n\t\tdelete _pXmlUserStylerDoc;\n\t\t_pXmlUserStylerDoc = NULL;\n\t\tisAllLaoded = false;\n\t}\n\telse\n\t\tgetUserStylersFromXmlTree();\n\n\t_themeSwitcher._stylesXmlPath = _stylerPath;\n\t// Firstly, add the default theme\n\t_themeSwitcher.addDefaultThemeFromXml(_stylerPath);\n\n\t//-----------------------------------//\n\t// userDefineLang.xml : for per user //\n\t//-----------------------------------//\n\t_userDefineLangsFolderPath = _userDefineLangPath = _userPath;\n\tpathAppend(_userDefineLangPath, TEXT(\"userDefineLang.xml\"));\n\tpathAppend(_userDefineLangsFolderPath, TEXT(\"userDefineLangs\"));\n\n\tstd::vector<generic_string> udlFiles;\n\tgetFilesInFolder(udlFiles, TEXT(\"*.xml\"), _userDefineLangsFolderPath);\n\n\t_pXmlUserLangDoc = new TiXmlDocument(_userDefineLangPath);\n\tloadOkay = _pXmlUserLangDoc->LoadFile();\n\tif (!loadOkay)\n\t{\n\t\tdelete _pXmlUserLangDoc;\n\t\t_pXmlUserLangDoc = nullptr;\n\t\tisAllLaoded = false;\n\t}\n\telse\n\t{\n\t\tauto r = addUserDefineLangsFromXmlTree(_pXmlUserLangDoc);\n\t\tif (r.second - r.first > 0)\n\t\t\t_pXmlUserLangsDoc.push_back(UdlXmlFileState(_pXmlUserLangDoc, false, r));\n\t}\n\n\tfor (const auto& i : udlFiles)\n\t{\n\t\tauto udlDoc = new TiXmlDocument(i);\n\t\tloadOkay = udlDoc->LoadFile();\n\t\tif (!loadOkay)\n\t\t{\n\t\t\tdelete udlDoc;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauto r = addUserDefineLangsFromXmlTree(udlDoc);\n\t\t\tif (r.second - r.first > 0)\n\t\t\t\t_pXmlUserLangsDoc.push_back(UdlXmlFileState(udlDoc, false, r));\n\t\t}\n\t}\n\n\t//----------------------------------------------//\n\t// nativeLang.xml : for per user\t\t\t\t//\n\t// In case of absence of user's nativeLang.xml, //\n\t// We'll look in the Notepad++ Dir.\t\t\t //\n\t//----------------------------------------------//\n\n\tgeneric_string nativeLangPath;\n\tnativeLangPath = _userPath;\n\tpathAppend(nativeLangPath, TEXT(\"nativeLang.xml\"));\n\n\t// LocalizationSwitcher should use always user path\n\t_localizationSwitcher._nativeLangPath = nativeLangPath;\n\n\tif (!_startWithLocFileName.empty()) // localization argument detected, use user wished localization\n\t{\n\t\t// overwrite nativeLangPath variable\n\t\tnativeLangPath = _nppPath;\n\t\tpathAppend(nativeLangPath, TEXT(\"localization\\\\\"));\n\t\tpathAppend(nativeLangPath, _startWithLocFileName);\n\t}\n\telse // use %appdata% location, or (if absence then) npp installed location\n\t{\n\t\tif (!PathFileExists(nativeLangPath.c_str()))\n\t\t{\n\t\t\tnativeLangPath = _nppPath;\n\t\t\tpathAppend(nativeLangPath, TEXT(\"nativeLang.xml\"));\n\t\t}\n\t}\n\n\n\t_pXmlNativeLangDocA = new TiXmlDocumentA();\n\n\tloadOkay = _pXmlNativeLangDocA->LoadUnicodeFilePath(nativeLangPath.c_str());\n\tif (!loadOkay)\n\t{\n\t\tdelete _pXmlNativeLangDocA;\n\t\t_pXmlNativeLangDocA = nullptr;\n\t\tisAllLaoded = false;\n\t}\n\n\t//---------------------------------//\n\t// toolbarIcons.xml : for per user //\n\t//---------------------------------//\n\tgeneric_string toolbarIconsPath(_userPath);\n\tpathAppend(toolbarIconsPath, TEXT(\"toolbarIcons.xml\"));\n\n\t_pXmlToolIconsDoc = new TiXmlDocument(toolbarIconsPath);\n\tloadOkay = _pXmlToolIconsDoc->LoadFile();\n\tif (!loadOkay)\n\t{\n\t\tdelete _pXmlToolIconsDoc;\n\t\t_pXmlToolIconsDoc = nullptr;\n\t\tisAllLaoded = false;\n\t}\n\n\t//------------------------------//\n\t// shortcuts.xml : for per user //\n\t//------------------------------//\n\t_shortcutsPath = _userPath;\n\tpathAppend(_shortcutsPath, TEXT(\"shortcuts.xml\"));\n\n\tif (!PathFileExists(_shortcutsPath.c_str()))\n\t{\n\t\tgeneric_string srcShortcutsPath(_nppPath);\n\t\tpathAppend(srcShortcutsPath, TEXT(\"shortcuts.xml\"));\n\n\t\t::CopyFile(srcShortcutsPath.c_str(), _shortcutsPath.c_str(), TRUE);\n\t}\n\n\t_pXmlShortcutDoc = new TiXmlDocument(_shortcutsPath);\n\tloadOkay = _pXmlShortcutDoc->LoadFile();\n\tif (!loadOkay)\n\t{\n\t\tdelete _pXmlShortcutDoc;\n\t\t_pXmlShortcutDoc = nullptr;\n\t\tisAllLaoded = false;\n\t}\n\telse\n\t{\n\t\tgetShortcutsFromXmlTree();\n\t\tgetMacrosFromXmlTree();\n\t\tgetUserCmdsFromXmlTree();\n\n\t\t// fill out _scintillaModifiedKeys :\n\t\t// those user defined Scintilla key will be used remap Scintilla Key Array\n\t\tgetScintKeysFromXmlTree();\n\t}\n\n\t//---------------------------------//\n\t// contextMenu.xml : for per user //\n\t//---------------------------------//\n\t_contextMenuPath = _userPath;\n\tpathAppend(_contextMenuPath, TEXT(\"contextMenu.xml\"));\n\n\tif (!PathFileExists(_contextMenuPath.c_str()))\n\t{\n\t\tgeneric_string srcContextMenuPath(_nppPath);\n\t\tpathAppend(srcContextMenuPath, TEXT(\"contextMenu.xml\"));\n\n\t\t::CopyFile(srcContextMenuPath.c_str(), _contextMenuPath.c_str(), TRUE);\n\t}\n\n\t_pXmlContextMenuDocA = new TiXmlDocumentA();\n\tloadOkay = _pXmlContextMenuDocA->LoadUnicodeFilePath(_contextMenuPath.c_str());\n\tif (!loadOkay)\n\t{\n\t\tdelete _pXmlContextMenuDocA;\n\t\t_pXmlContextMenuDocA = nullptr;\n\t\tisAllLaoded = false;\n\t}\n\n\t//----------------------------//\n\t// session.xml : for per user //\n\t//----------------------------//\n\n\tpathAppend(_sessionPath, TEXT(\"session.xml\"));\n\n\t// Don't load session.xml if not required in order to speed up!!\n\tconst NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();\n\tif (nppGUI._rememberLastSession)\n\t{\n\t\tTiXmlDocument* pXmlSessionDoc = new TiXmlDocument(_sessionPath);\n\n\t\tloadOkay = pXmlSessionDoc->LoadFile();\n\t\tif (!loadOkay)\n\t\t\tisAllLaoded = false;\n\t\telse\n\t\t\tgetSessionFromXmlTree(pXmlSessionDoc, _session);\n\n\t\tdelete pXmlSessionDoc;\n\n\t\tfor (size_t i = 0, len = _pXmlExternalLexerDoc.size() ; i < len ; ++i)\n\t\t\tif (_pXmlExternalLexerDoc[i])\n\t\t\t\tdelete _pXmlExternalLexerDoc[i];\n\t}\n\n\t//-------------------------------------------------------------//\n\t// enableSelectFgColor.xml : for per user                      //\n\t// This empty xml file is optional - user adds this empty file //\n\t// manually in order to set selected text's foreground color.  //\n\t//-------------------------------------------------------------//\n\tgeneric_string enableSelectFgColorPath = _userPath;\n\tpathAppend(enableSelectFgColorPath, TEXT(\"enableSelectFgColor.xml\"));\n\n\tif (PathFileExists(enableSelectFgColorPath.c_str()))\n\t{\n\t\t_isSelectFgColorEnabled = true;\n\t}\n\n\n\tgeneric_string filePath, filePath2, issueFileName;\n\n\tfilePath = _nppPath;\n\tissueFileName = nppLogNetworkDriveIssue;\n\tissueFileName += TEXT(\".xml\");\n\tpathAppend(filePath, issueFileName);\n\t_doNppLogNetworkDriveIssue = (PathFileExists(filePath.c_str()) == TRUE);\n\tif (!_doNppLogNetworkDriveIssue)\n\t{\n\t\tfilePath2 = _userPath;\n\t\tpathAppend(filePath2, issueFileName);\n\t\t_doNppLogNetworkDriveIssue = (PathFileExists(filePath2.c_str()) == TRUE);\n\t}\n\n\tfilePath = _nppPath;\n\tissueFileName = nppLogNulContentCorruptionIssue;\n\tissueFileName += TEXT(\".xml\");\n\tpathAppend(filePath, issueFileName);\n\t_doNppLogNulContentCorruptionIssue = (PathFileExists(filePath.c_str()) == TRUE);\n\tif (!_doNppLogNulContentCorruptionIssue)\n\t{\n\t\tfilePath2 = _userPath;\n\t\tpathAppend(filePath2, issueFileName);\n\t\t_doNppLogNulContentCorruptionIssue = (PathFileExists(filePath2.c_str()) == TRUE);\n\t}\n\n\n\n\n\treturn isAllLaoded;\n}",
        "func": "bool NppParameters::load()\n{\n\tL_END = L_EXTERNAL;\n\tbool isAllLaoded = true;\n\n\t_isx64 = sizeof(void *) == 8;\n\n\t// Make localConf.xml path\n\tgeneric_string localConfPath(_nppPath);\n\tpathAppend(localConfPath, localConfFile);\n\n\t// Test if localConf.xml exist\n\t_isLocal = (PathFileExists(localConfPath.c_str()) == TRUE);\n\n\t// Under vista and windows 7, the usage of doLocalConf.xml is not allowed\n\t// if Notepad++ is installed in \"program files\" directory, because of UAC\n\tif (_isLocal)\n\t{\n\t\t// We check if OS is Vista or greater version\n\t\tif (_winVersion >= WV_VISTA)\n\t\t{\n\t\t\tgeneric_string progPath = getSpecialFolderLocation(CSIDL_PROGRAM_FILES);\n\t\t\tTCHAR nppDirLocation[MAX_PATH];\n\t\t\twcscpy_s(nppDirLocation, _nppPath.c_str());\n\t\t\t::PathRemoveFileSpec(nppDirLocation);\n\n\t\t\tif  (progPath == nppDirLocation)\n\t\t\t\t_isLocal = false;\n\t\t}\n\t}\n\n\t_pluginRootDir = _nppPath;\n\tpathAppend(_pluginRootDir, TEXT(\"plugins\"));\n\n\t//\n\t// the 3rd priority: general default configuration\n\t//\n\tgeneric_string nppPluginRootParent;\n\tif (_isLocal)\n\t{\n\t\t_userPath = nppPluginRootParent = _nppPath;\n\t\t_userPluginConfDir = _pluginRootDir;\n\t\tpathAppend(_userPluginConfDir, TEXT(\"Config\"));\n\t}\n\telse\n\t{\n\t\t_userPath = getSpecialFolderLocation(CSIDL_APPDATA);\n\n\t\tpathAppend(_userPath, TEXT(\"Notepad++\"));\n\t\tif (!PathFileExists(_userPath.c_str()))\n\t\t\t::CreateDirectory(_userPath.c_str(), NULL);\n\n\t\t_appdataNppDir = _userPluginConfDir = _userPath;\n\t\tpathAppend(_userPluginConfDir, TEXT(\"plugins\"));\n\t\tif (!PathFileExists(_userPluginConfDir.c_str()))\n\t\t\t::CreateDirectory(_userPluginConfDir.c_str(), NULL);\n\t\tpathAppend(_userPluginConfDir, TEXT(\"Config\"));\n\t\tif (!PathFileExists(_userPluginConfDir.c_str()))\n\t\t\t::CreateDirectory(_userPluginConfDir.c_str(), NULL);\n\n\t\t// For PluginAdmin to launch the wingup with UAC\n\t\tsetElevationRequired(true);\n\t}\n\n\t_pluginConfDir = _pluginRootDir; // for plugin list home\n\tpathAppend(_pluginConfDir, TEXT(\"Config\"));\n\n\tif (!PathFileExists(nppPluginRootParent.c_str()))\n\t\t::CreateDirectory(nppPluginRootParent.c_str(), NULL);\n\tif (!PathFileExists(_pluginRootDir.c_str()))\n\t\t::CreateDirectory(_pluginRootDir.c_str(), NULL);\n\n\t_sessionPath = _userPath; // Session stock the absolute file path, it should never be on cloud\n\n\t// Detection cloud settings\n\tgeneric_string cloudChoicePath{_userPath};\n\tcloudChoicePath += TEXT(\"\\\\cloud\\\\choice\");\n\n\t//\n\t// the 2nd priority: cloud Choice Path\n\t//\n\tif (::PathFileExists(cloudChoicePath.c_str()))\n\t{\n\t\t// Read cloud choice\n\t\tstd::string cloudChoiceStr = getFileContent(cloudChoicePath.c_str());\n\t\tWcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();\n\t\tstd::wstring cloudChoiceStrW = wmc.char2wchar(cloudChoiceStr.c_str(), SC_CP_UTF8);\n\n\t\tif (!cloudChoiceStrW.empty() && ::PathFileExists(cloudChoiceStrW.c_str()))\n\t\t{\n\t\t\t_userPath = cloudChoiceStrW;\n\t\t\t_nppGUI._cloudPath = cloudChoiceStrW;\n\t\t\t_initialCloudChoice = _nppGUI._cloudPath;\n\t\t}\n\t}\n\n\t//\n\t// the 1st priority: custom settings dir via command line argument\n\t//\n\tif (!_cmdSettingsDir.empty())\n\t{\n\t\tif (!::PathIsDirectory(_cmdSettingsDir.c_str()))\n\t\t{\n\t\t\t// The following text is not translatable.\n\t\t\t// _pNativeLangSpeaker is initialized AFTER _userPath being dterminated because nativeLang.xml is from from _userPath.\n\t\t\tgeneric_string errMsg = TEXT(\"The given path\\r\");\n\t\t\terrMsg += _cmdSettingsDir;\n\t\t\terrMsg += TEXT(\"\\nvia command line \\\"-settingsDir=\\\" is not a valid directory.\\rThis argument will be ignored.\");\n\t\t\t::MessageBox(NULL, errMsg.c_str(), TEXT(\"Invalid directory\"), MB_OK);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_userPath = _cmdSettingsDir;\n\t\t\t_sessionPath = _userPath; // reset session path\n\t\t}\n\t}\n\n\t//-------------------------------------//\n\t// Transparent function for w2k and xp //\n\t//-------------------------------------//\n\tHMODULE hUser32 = ::GetModuleHandle(TEXT(\"User32\"));\n\tif (hUser32)\n\t\t_transparentFuncAddr = (WNDPROC)::GetProcAddress(hUser32, \"SetLayeredWindowAttributes\");\n\n\t//---------------------------------------------//\n\t// Dlg theme texture function for xp and vista //\n\t//---------------------------------------------//\n\t_hUXTheme = ::LoadLibraryEx(TEXT(\"uxtheme.dll\"), nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);\n\tif (_hUXTheme)\n\t\t_enableThemeDialogTextureFuncAddr = (WNDPROC)::GetProcAddress(_hUXTheme, \"EnableThemeDialogTexture\");\n\n\t//--------------------------//\n\t// langs.xml : for per user //\n\t//--------------------------//\n\tgeneric_string langs_xml_path(_userPath);\n\tpathAppend(langs_xml_path, TEXT(\"langs.xml\"));\n\n\tBOOL doRecover = FALSE;\n\tif (::PathFileExists(langs_xml_path.c_str()))\n\t{\n\t\tWIN32_FILE_ATTRIBUTE_DATA attributes;\n\n\t\tif (GetFileAttributesEx(langs_xml_path.c_str(), GetFileExInfoStandard, &attributes) != 0)\n\t\t{\n\t\t\tif (attributes.nFileSizeLow == 0 && attributes.nFileSizeHigh == 0)\n\t\t\t{\n\t\t\t\tif (_pNativeLangSpeaker)\n\t\t\t\t{\n\t\t\t\t\tdoRecover = _pNativeLangSpeaker->messageBox(\"LoadLangsFailed\",\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tTEXT(\"Load langs.xml failed!\\rDo you want to recover your langs.xml?\"),\n\t\t\t\t\t\tTEXT(\"Configurator\"),\n\t\t\t\t\t\tMB_YESNO);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdoRecover = ::MessageBox(NULL, TEXT(\"Load langs.xml failed!\\rDo you want to recover your langs.xml?\"), TEXT(\"Configurator\"), MB_YESNO);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tdoRecover = true;\n\n\tif (doRecover)\n\t{\n\t\tgeneric_string srcLangsPath(_nppPath);\n\t\tpathAppend(srcLangsPath, TEXT(\"langs.model.xml\"));\n\t\t::CopyFile(srcLangsPath.c_str(), langs_xml_path.c_str(), FALSE);\n\t}\n\n\t_pXmlDoc = new TiXmlDocument(langs_xml_path);\n\n\n\tbool loadOkay = _pXmlDoc->LoadFile();\n\tif (!loadOkay)\n\t{\n\t\tif (_pNativeLangSpeaker)\n\t\t{\n\t\t\t_pNativeLangSpeaker->messageBox(\"LoadLangsFailedFinal\",\n\t\t\t\tNULL,\n\t\t\t\tTEXT(\"Load langs.xml failed!\"),\n\t\t\t\tTEXT(\"Configurator\"),\n\t\t\t\tMB_OK);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t::MessageBox(NULL, TEXT(\"Load langs.xml failed!\"), TEXT(\"Configurator\"), MB_OK);\n\t\t}\n\n\t\tdelete _pXmlDoc;\n\t\t_pXmlDoc = nullptr;\n\t\tisAllLaoded = false;\n\t}\n\telse\n\t\tgetLangKeywordsFromXmlTree();\n\n\t//---------------------------//\n\t// config.xml : for per user //\n\t//---------------------------//\n\tgeneric_string configPath(_userPath);\n\tpathAppend(configPath, TEXT(\"config.xml\"));\n\n\tgeneric_string srcConfigPath(_nppPath);\n\tpathAppend(srcConfigPath, TEXT(\"config.model.xml\"));\n\n\tif (!::PathFileExists(configPath.c_str()))\n\t\t::CopyFile(srcConfigPath.c_str(), configPath.c_str(), FALSE);\n\n\t_pXmlUserDoc = new TiXmlDocument(configPath);\n\tloadOkay = _pXmlUserDoc->LoadFile();\n\t\n\tif (!loadOkay)\n\t{\n\t\tTiXmlDeclaration* decl = new TiXmlDeclaration(TEXT(\"1.0\"), TEXT(\"UTF-8\"), TEXT(\"\"));\n\t\t_pXmlUserDoc->LinkEndChild(decl);\n\t}\n\telse\n\t{\n\t\tgetUserParametersFromXmlTree();\n\t}\n\n\t//----------------------------//\n\t// stylers.xml : for per user //\n\t//----------------------------//\n\n\t_stylerPath = _userPath;\n\tpathAppend(_stylerPath, TEXT(\"stylers.xml\"));\n\n\tif (!PathFileExists(_stylerPath.c_str()))\n\t{\n\t\tgeneric_string srcStylersPath(_nppPath);\n\t\tpathAppend(srcStylersPath, TEXT(\"stylers.model.xml\"));\n\n\t\t::CopyFile(srcStylersPath.c_str(), _stylerPath.c_str(), TRUE);\n\t}\n\n\tif (_nppGUI._themeName.empty() || (!PathFileExists(_nppGUI._themeName.c_str())))\n\t\t_nppGUI._themeName.assign(_stylerPath);\n\n\t_pXmlUserStylerDoc = new TiXmlDocument(_nppGUI._themeName.c_str());\n\n\tloadOkay = _pXmlUserStylerDoc->LoadFile();\n\tif (!loadOkay)\n\t{\n\t\tif (_pNativeLangSpeaker)\n\t\t{\n\t\t\t_pNativeLangSpeaker->messageBox(\"LoadStylersFailed\",\n\t\t\t\tNULL,\n\t\t\t\tTEXT(\"Load \\\"$STR_REPLACE$\\\" failed!\"),\n\t\t\t\tTEXT(\"Load stylers.xml failed\"),\n\t\t\t\tMB_OK,\n\t\t\t\t0,\n\t\t\t\t_stylerPath.c_str());\n\t\t}\n\t\telse\n\t\t{\n\t\t\t::MessageBox(NULL, _stylerPath.c_str(), TEXT(\"Load stylers.xml failed\"), MB_OK);\n\t\t}\n\t\tdelete _pXmlUserStylerDoc;\n\t\t_pXmlUserStylerDoc = NULL;\n\t\tisAllLaoded = false;\n\t}\n\telse\n\t\tgetUserStylersFromXmlTree();\n\n\t_themeSwitcher._stylesXmlPath = _stylerPath;\n\t// Firstly, add the default theme\n\t_themeSwitcher.addDefaultThemeFromXml(_stylerPath);\n\n\t//-----------------------------------//\n\t// userDefineLang.xml : for per user //\n\t//-----------------------------------//\n\t_userDefineLangsFolderPath = _userDefineLangPath = _userPath;\n\tpathAppend(_userDefineLangPath, TEXT(\"userDefineLang.xml\"));\n\tpathAppend(_userDefineLangsFolderPath, TEXT(\"userDefineLangs\"));\n\n\tstd::vector<generic_string> udlFiles;\n\tgetFilesInFolder(udlFiles, TEXT(\"*.xml\"), _userDefineLangsFolderPath);\n\n\t_pXmlUserLangDoc = new TiXmlDocument(_userDefineLangPath);\n\tloadOkay = _pXmlUserLangDoc->LoadFile();\n\tif (!loadOkay)\n\t{\n\t\tdelete _pXmlUserLangDoc;\n\t\t_pXmlUserLangDoc = nullptr;\n\t\tisAllLaoded = false;\n\t}\n\telse\n\t{\n\t\tauto r = addUserDefineLangsFromXmlTree(_pXmlUserLangDoc);\n\t\tif (r.second - r.first > 0)\n\t\t\t_pXmlUserLangsDoc.push_back(UdlXmlFileState(_pXmlUserLangDoc, false, r));\n\t}\n\n\tfor (const auto& i : udlFiles)\n\t{\n\t\tauto udlDoc = new TiXmlDocument(i);\n\t\tloadOkay = udlDoc->LoadFile();\n\t\tif (!loadOkay)\n\t\t{\n\t\t\tdelete udlDoc;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauto r = addUserDefineLangsFromXmlTree(udlDoc);\n\t\t\tif (r.second - r.first > 0)\n\t\t\t\t_pXmlUserLangsDoc.push_back(UdlXmlFileState(udlDoc, false, r));\n\t\t}\n\t}\n\n\t//----------------------------------------------//\n\t// nativeLang.xml : for per user\t\t\t\t//\n\t// In case of absence of user's nativeLang.xml, //\n\t// We'll look in the Notepad++ Dir.\t\t\t //\n\t//----------------------------------------------//\n\n\tgeneric_string nativeLangPath;\n\tnativeLangPath = _userPath;\n\tpathAppend(nativeLangPath, TEXT(\"nativeLang.xml\"));\n\n\t// LocalizationSwitcher should use always user path\n\t_localizationSwitcher._nativeLangPath = nativeLangPath;\n\n\tif (!_startWithLocFileName.empty()) // localization argument detected, use user wished localization\n\t{\n\t\t// overwrite nativeLangPath variable\n\t\tnativeLangPath = _nppPath;\n\t\tpathAppend(nativeLangPath, TEXT(\"localization\\\\\"));\n\t\tpathAppend(nativeLangPath, _startWithLocFileName);\n\t}\n\telse // use %appdata% location, or (if absence then) npp installed location\n\t{\n\t\tif (!PathFileExists(nativeLangPath.c_str()))\n\t\t{\n\t\t\tnativeLangPath = _nppPath;\n\t\t\tpathAppend(nativeLangPath, TEXT(\"nativeLang.xml\"));\n\t\t}\n\t}\n\n\n\t_pXmlNativeLangDocA = new TiXmlDocumentA();\n\n\tloadOkay = _pXmlNativeLangDocA->LoadUnicodeFilePath(nativeLangPath.c_str());\n\tif (!loadOkay)\n\t{\n\t\tdelete _pXmlNativeLangDocA;\n\t\t_pXmlNativeLangDocA = nullptr;\n\t\tisAllLaoded = false;\n\t}\n\n\t//---------------------------------//\n\t// toolbarIcons.xml : for per user //\n\t//---------------------------------//\n\tgeneric_string toolbarIconsPath(_userPath);\n\tpathAppend(toolbarIconsPath, TEXT(\"toolbarIcons.xml\"));\n\n\t_pXmlToolIconsDoc = new TiXmlDocument(toolbarIconsPath);\n\tloadOkay = _pXmlToolIconsDoc->LoadFile();\n\tif (!loadOkay)\n\t{\n\t\tdelete _pXmlToolIconsDoc;\n\t\t_pXmlToolIconsDoc = nullptr;\n\t\tisAllLaoded = false;\n\t}\n\n\t//------------------------------//\n\t// shortcuts.xml : for per user //\n\t//------------------------------//\n\t_shortcutsPath = _userPath;\n\tpathAppend(_shortcutsPath, TEXT(\"shortcuts.xml\"));\n\n\tif (!PathFileExists(_shortcutsPath.c_str()))\n\t{\n\t\tgeneric_string srcShortcutsPath(_nppPath);\n\t\tpathAppend(srcShortcutsPath, TEXT(\"shortcuts.xml\"));\n\n\t\t::CopyFile(srcShortcutsPath.c_str(), _shortcutsPath.c_str(), TRUE);\n\t}\n\n\t_pXmlShortcutDoc = new TiXmlDocument(_shortcutsPath);\n\tloadOkay = _pXmlShortcutDoc->LoadFile();\n\tif (!loadOkay)\n\t{\n\t\tdelete _pXmlShortcutDoc;\n\t\t_pXmlShortcutDoc = nullptr;\n\t\tisAllLaoded = false;\n\t}\n\telse\n\t{\n\t\tgetShortcutsFromXmlTree();\n\t\tgetMacrosFromXmlTree();\n\t\tgetUserCmdsFromXmlTree();\n\n\t\t// fill out _scintillaModifiedKeys :\n\t\t// those user defined Scintilla key will be used remap Scintilla Key Array\n\t\tgetScintKeysFromXmlTree();\n\t}\n\n\t//---------------------------------//\n\t// contextMenu.xml : for per user //\n\t//---------------------------------//\n\t_contextMenuPath = _userPath;\n\tpathAppend(_contextMenuPath, TEXT(\"contextMenu.xml\"));\n\n\tif (!PathFileExists(_contextMenuPath.c_str()))\n\t{\n\t\tgeneric_string srcContextMenuPath(_nppPath);\n\t\tpathAppend(srcContextMenuPath, TEXT(\"contextMenu.xml\"));\n\n\t\t::CopyFile(srcContextMenuPath.c_str(), _contextMenuPath.c_str(), TRUE);\n\t}\n\n\t_pXmlContextMenuDocA = new TiXmlDocumentA();\n\tloadOkay = _pXmlContextMenuDocA->LoadUnicodeFilePath(_contextMenuPath.c_str());\n\tif (!loadOkay)\n\t{\n\t\tdelete _pXmlContextMenuDocA;\n\t\t_pXmlContextMenuDocA = nullptr;\n\t\tisAllLaoded = false;\n\t}\n\n\t//----------------------------//\n\t// session.xml : for per user //\n\t//----------------------------//\n\n\tpathAppend(_sessionPath, TEXT(\"session.xml\"));\n\n\t// Don't load session.xml if not required in order to speed up!!\n\tconst NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();\n\tif (nppGUI._rememberLastSession)\n\t{\n\t\tTiXmlDocument* pXmlSessionDoc = new TiXmlDocument(_sessionPath);\n\n\t\tloadOkay = pXmlSessionDoc->LoadFile();\n\t\tif (!loadOkay)\n\t\t\tisAllLaoded = false;\n\t\telse\n\t\t\tgetSessionFromXmlTree(pXmlSessionDoc, _session);\n\n\t\tdelete pXmlSessionDoc;\n\n\t\tfor (size_t i = 0, len = _pXmlExternalLexerDoc.size() ; i < len ; ++i)\n\t\t\tif (_pXmlExternalLexerDoc[i])\n\t\t\t\tdelete _pXmlExternalLexerDoc[i];\n\t}\n\n\t//-------------------------------------------------------------//\n\t// enableSelectFgColor.xml : for per user                      //\n\t// This empty xml file is optional - user adds this empty file //\n\t// manually in order to set selected text's foreground color.  //\n\t//-------------------------------------------------------------//\n\tgeneric_string enableSelectFgColorPath = _userPath;\n\tpathAppend(enableSelectFgColorPath, TEXT(\"enableSelectFgColor.xml\"));\n\n\tif (PathFileExists(enableSelectFgColorPath.c_str()))\n\t{\n\t\t_isSelectFgColorEnabled = true;\n\t}\n\n\n\tgeneric_string filePath, filePath2, issueFileName;\n\n\tfilePath = _nppPath;\n\tissueFileName = nppLogNetworkDriveIssue;\n\tissueFileName += TEXT(\".xml\");\n\tpathAppend(filePath, issueFileName);\n\t_doNppLogNetworkDriveIssue = (PathFileExists(filePath.c_str()) == TRUE);\n\tif (!_doNppLogNetworkDriveIssue)\n\t{\n\t\tfilePath2 = _userPath;\n\t\tpathAppend(filePath2, issueFileName);\n\t\t_doNppLogNetworkDriveIssue = (PathFileExists(filePath2.c_str()) == TRUE);\n\t}\n\n\tfilePath = _nppPath;\n\tissueFileName = nppLogNulContentCorruptionIssue;\n\tissueFileName += TEXT(\".xml\");\n\tpathAppend(filePath, issueFileName);\n\t_doNppLogNulContentCorruptionIssue = (PathFileExists(filePath.c_str()) == TRUE);\n\tif (!_doNppLogNulContentCorruptionIssue)\n\t{\n\t\tfilePath2 = _userPath;\n\t\tpathAppend(filePath2, issueFileName);\n\t\t_doNppLogNulContentCorruptionIssue = (PathFileExists(filePath2.c_str()) == TRUE);\n\t}\n\n\n\n\n\treturn isAllLaoded;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -125,7 +125,7 @@\n \t//---------------------------------------------//\n \t// Dlg theme texture function for xp and vista //\n \t//---------------------------------------------//\n-\t_hUXTheme = ::LoadLibrary(TEXT(\"uxtheme.dll\"));\n+\t_hUXTheme = ::LoadLibraryEx(TEXT(\"uxtheme.dll\"), nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);\n \tif (_hUXTheme)\n \t\t_enableThemeDialogTextureFuncAddr = (WNDPROC)::GetProcAddress(_hUXTheme, \"EnableThemeDialogTexture\");\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t_hUXTheme = ::LoadLibrary(TEXT(\"uxtheme.dll\"));"
            ],
            "added_lines": [
                "\t_hUXTheme = ::LoadLibraryEx(TEXT(\"uxtheme.dll\"), nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26894",
        "func_name": "livecode/Initialize",
        "description": "LiveCode v9.6.1 on Windows allows local, low-privileged users to gain privileges by creating a malicious \"cmd.exe\" in the folder of the vulnerable LiveCode application. If the application is using LiveCode's \"shell()\" function, it will attempt to search for \"cmd.exe\" in the folder of the current application and run the malicious \"cmd.exe\".",
        "git_url": "https://github.com/livecode/livecode/commit/d8cb11f12c2e196d1d81c4036e60b6f5d74af0a4",
        "commit_title": "[[ Bug 22942 ]] Ensure the shellcommand defaults to COMSPEC on Windows",
        "commit_text": "",
        "func_before": "virtual bool Initialize(void)\n\t{\n\t\tIO_stdin = MCsystem -> OpenFd(STD_INPUT_HANDLE, kMCOpenFileModeRead);\n\t\tIO_stdout = MCsystem -> OpenFd(STD_OUTPUT_HANDLE, kMCOpenFileModeWrite);\n\t\tIO_stderr = MCsystem -> OpenFd(STD_ERROR_HANDLE, kMCOpenFileModeWrite);\n\n\t\tsetlocale(LC_CTYPE, MCnullstring);\n\t\tsetlocale(LC_COLLATE, MCnullstring);\n\n#ifdef _WINDOWS_SERVER\n\t\tWORD request = MAKEWORD(1, 1);\n\t\tWSADATA t_data;\n\t\tWSAStartup(request, &t_data);\n#endif // _WINDOWS_SERVER\n\n\t\t// MW-2004-11-28: The ctype array seems to have changed in the latest version of VC++\n\t\t((unsigned short *)_pctype)[160] &= ~_SPACE;\n\n\t\tMCinfinity = HUGE_VAL;\n\t\tMCS_time(); // force init\n\t\tif (timeBeginPeriod(1) == TIMERR_NOERROR)\n\t\t\tMCS_reset_time();\n\t\telse\n\t\t\tMClowrestimers = True;\n\n        MCExecContext ctxt(nil, nil, nil);\n\t\tMCStringRef t_key;\n\t\tt_key = MCSTR(\"HKEY_CURRENT_USER\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Internet Settings\\\\ProxyEnable\");\n        MCAutoStringRef t_type, t_error;\n        MCAutoValueRef t_value;\n        MCS_query_registry(t_key, &t_value, &t_type, &t_error);\n        \n        MCAutoNumberRef t_enabled;\n        if (*t_value != nil && ctxt.ConvertToNumber(*t_value, &t_enabled) && MCNumberFetchAsInteger(*t_enabled) == 1)\n\t\t{\n            MCStringRef t_key2;\n            t_key2 = MCSTR(\"HKEY_CURRENT_USER\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Internet Settings\\\\ProxyServer\");\n            MCAutoStringRef t_type2, t_error2;\n            MCAutoValueRef t_value2;\n\n\t\t\tMCS_query_registry(t_key2, &t_value2, &t_type2, &t_error2);\n\n\t\t\tif (*t_value2 != nil && !MCValueIsEmpty(*t_value2))\n\t\t\t{\n\t\t\t\tMCAutoStringRef t_http_proxy;\n\t\t\t\t/* UNCHECKED */ ctxt . ConvertToString(*t_value2, &t_http_proxy);\n\t\t\t\tMCValueAssign(MChttpproxy, *t_http_proxy);\n\t\t\t}\n\t\t}\n\n\t\t// On NT systems 'cmd.exe' is the command processor\n\t\tMCValueAssign(MCshellcmd, MCSTR(\"cmd.exe\"));\n\n\t\t// MW-2005-05-26: Store a global variable containing major OS version...\n\t\tOSVERSIONINFOA osv;\n\t\tmemset(&osv, 0, sizeof(OSVERSIONINFOA));\n\t\tosv.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);\n\t\tGetVersionExA(&osv);\n\t\tMCmajorosversion = osv . dwMajorVersion << 8 | osv . dwMinorVersion;\n\n\t\t// MW-2012-09-19: [[ Bug ]] Adjustment to tooltip metrics for Windows.\n\t\tif (MCmajorosversion >= 0x0500)\n\t\t{\n\t\t\tMCttsize = 11;\n\t\t\tMCValueAssign(MCttfont, MCSTR(\"Tahoma\"));\n\t\t}\n\t\telse if (MCmajorosversion >= 0x0600)\n\t\t{\n\t\t\tMCttsize = 11;\n\t\t\tMCValueAssign(MCttfont, MCSTR(\"Segoe UI\"));\n\t\t}\n\n\t\tOleInitialize(NULL); //for drag & drop\n\n\t\t// MW-2004-11-28: Install a signal handler for FP exceptions - these should be masked\n\t\t//   so it *should* be unnecessary but Win9x plays with the FP control word.\n\t\tsignal(SIGFPE, handle_fp_exception);\n\n\t\treturn true;\n\t}",
        "func": "virtual bool Initialize(void)\n\t{\n\t\tIO_stdin = MCsystem -> OpenFd(STD_INPUT_HANDLE, kMCOpenFileModeRead);\n\t\tIO_stdout = MCsystem -> OpenFd(STD_OUTPUT_HANDLE, kMCOpenFileModeWrite);\n\t\tIO_stderr = MCsystem -> OpenFd(STD_ERROR_HANDLE, kMCOpenFileModeWrite);\n\n\t\tsetlocale(LC_CTYPE, MCnullstring);\n\t\tsetlocale(LC_COLLATE, MCnullstring);\n\n#ifdef _WINDOWS_SERVER\n\t\tWORD request = MAKEWORD(1, 1);\n\t\tWSADATA t_data;\n\t\tWSAStartup(request, &t_data);\n#endif // _WINDOWS_SERVER\n\n\t\t// MW-2004-11-28: The ctype array seems to have changed in the latest version of VC++\n\t\t((unsigned short *)_pctype)[160] &= ~_SPACE;\n\n\t\tMCinfinity = HUGE_VAL;\n\t\tMCS_time(); // force init\n\t\tif (timeBeginPeriod(1) == TIMERR_NOERROR)\n\t\t\tMCS_reset_time();\n\t\telse\n\t\t\tMClowrestimers = True;\n\n        MCExecContext ctxt(nil, nil, nil);\n\t\tMCStringRef t_key;\n\t\tt_key = MCSTR(\"HKEY_CURRENT_USER\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Internet Settings\\\\ProxyEnable\");\n        MCAutoStringRef t_type, t_error;\n        MCAutoValueRef t_value;\n        MCS_query_registry(t_key, &t_value, &t_type, &t_error);\n        \n        MCAutoNumberRef t_enabled;\n        if (*t_value != nil && ctxt.ConvertToNumber(*t_value, &t_enabled) && MCNumberFetchAsInteger(*t_enabled) == 1)\n\t\t{\n            MCStringRef t_key2;\n            t_key2 = MCSTR(\"HKEY_CURRENT_USER\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Internet Settings\\\\ProxyServer\");\n            MCAutoStringRef t_type2, t_error2;\n            MCAutoValueRef t_value2;\n\n\t\t\tMCS_query_registry(t_key2, &t_value2, &t_type2, &t_error2);\n\n\t\t\tif (*t_value2 != nil && !MCValueIsEmpty(*t_value2))\n\t\t\t{\n\t\t\t\tMCAutoStringRef t_http_proxy;\n\t\t\t\t/* UNCHECKED */ ctxt . ConvertToString(*t_value2, &t_http_proxy);\n\t\t\t\tMCValueAssign(MChttpproxy, *t_http_proxy);\n\t\t\t}\n\t\t}\n\n\t\t/* Default the shellCommand to the value of the COMSPEC environment\n\t\t * variable. */\n\t\tMCAutoStringRef t_comspec;\n\t\tif (MCS_getenv(MCSTR(\"COMSPEC\"), &t_comspec))\n\t\t{\n\t\t\tMCValueAssign(MCshellcmd, *t_comspec);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMCValueAssign(MCshellcmd, kMCEmptyString);\n\t\t}\n\n\t\t// MW-2005-05-26: Store a global variable containing major OS version...\n\t\tOSVERSIONINFOA osv;\n\t\tmemset(&osv, 0, sizeof(OSVERSIONINFOA));\n\t\tosv.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);\n\t\tGetVersionExA(&osv);\n\t\tMCmajorosversion = osv . dwMajorVersion << 8 | osv . dwMinorVersion;\n\n\t\t// MW-2012-09-19: [[ Bug ]] Adjustment to tooltip metrics for Windows.\n\t\tif (MCmajorosversion >= 0x0500)\n\t\t{\n\t\t\tMCttsize = 11;\n\t\t\tMCValueAssign(MCttfont, MCSTR(\"Tahoma\"));\n\t\t}\n\t\telse if (MCmajorosversion >= 0x0600)\n\t\t{\n\t\t\tMCttsize = 11;\n\t\t\tMCValueAssign(MCttfont, MCSTR(\"Segoe UI\"));\n\t\t}\n\n\t\tOleInitialize(NULL); //for drag & drop\n\n\t\t// MW-2004-11-28: Install a signal handler for FP exceptions - these should be masked\n\t\t//   so it *should* be unnecessary but Win9x plays with the FP control word.\n\t\tsignal(SIGFPE, handle_fp_exception);\n\n\t\treturn true;\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -48,8 +48,17 @@\n \t\t\t}\n \t\t}\n \n-\t\t// On NT systems 'cmd.exe' is the command processor\n-\t\tMCValueAssign(MCshellcmd, MCSTR(\"cmd.exe\"));\n+\t\t/* Default the shellCommand to the value of the COMSPEC environment\n+\t\t * variable. */\n+\t\tMCAutoStringRef t_comspec;\n+\t\tif (MCS_getenv(MCSTR(\"COMSPEC\"), &t_comspec))\n+\t\t{\n+\t\t\tMCValueAssign(MCshellcmd, *t_comspec);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tMCValueAssign(MCshellcmd, kMCEmptyString);\n+\t\t}\n \n \t\t// MW-2005-05-26: Store a global variable containing major OS version...\n \t\tOSVERSIONINFOA osv;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t// On NT systems 'cmd.exe' is the command processor",
                "\t\tMCValueAssign(MCshellcmd, MCSTR(\"cmd.exe\"));"
            ],
            "added_lines": [
                "\t\t/* Default the shellCommand to the value of the COMSPEC environment",
                "\t\t * variable. */",
                "\t\tMCAutoStringRef t_comspec;",
                "\t\tif (MCS_getenv(MCSTR(\"COMSPEC\"), &t_comspec))",
                "\t\t{",
                "\t\t\tMCValueAssign(MCshellcmd, *t_comspec);",
                "\t\t}",
                "\t\telse",
                "\t\t{",
                "\t\t\tMCValueAssign(MCshellcmd, kMCEmptyString);",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26894",
        "func_name": "livecode/MCFilesEvalShell",
        "description": "LiveCode v9.6.1 on Windows allows local, low-privileged users to gain privileges by creating a malicious \"cmd.exe\" in the folder of the vulnerable LiveCode application. If the application is using LiveCode's \"shell()\" function, it will attempt to search for \"cmd.exe\" in the folder of the current application and run the malicious \"cmd.exe\".",
        "git_url": "https://github.com/livecode/livecode/commit/d8cb11f12c2e196d1d81c4036e60b6f5d74af0a4",
        "commit_title": "[[ Bug 22942 ]] Ensure the shellcommand defaults to COMSPEC on Windows",
        "commit_text": "",
        "func_before": "void MCFilesEvalShell(MCExecContext& ctxt, MCStringRef p_command, MCStringRef& r_output)\n{\n\tif (MCsecuremode & MC_SECUREMODE_PROCESS)\n\t{\n\t\tMCeerror->add(EE_SHELL_NOPERM, 0, 0, p_command);\n\t\tctxt . Throw();\n\t\treturn;\n\t}\n\n\tif (MCS_runcmd(p_command, r_output) != IO_NORMAL)\n\t{\n\t\tMCeerror->add(EE_SHELL_BADCOMMAND, 0, 0, p_command);\n\t\tctxt . Throw();\n\t\treturn;\n\t}\n}",
        "func": "void MCFilesEvalShell(MCExecContext& ctxt, MCStringRef p_command, MCStringRef& r_output)\n{\n\tif (MCsecuremode & MC_SECUREMODE_PROCESS)\n\t{\n\t\tMCeerror->add(EE_SHELL_NOPERM, 0, 0, p_command);\n\t\tctxt . Throw();\n\t\treturn;\n\t}\n\n\tif (MCStringIsEmpty(MCshellcmd))\n\t{\n\t\tMCeerror->add(EE_SHELL_BADCOMMAND, 0, 0, \"no shell\");\n\t\tctxt . Throw();\n\t\treturn;\n\t}\n\n\tif (MCS_runcmd(p_command, r_output) != IO_NORMAL)\n\t{\n\t\tMCeerror->add(EE_SHELL_BADCOMMAND, 0, 0, p_command);\n\t\tctxt . Throw();\n\t\treturn;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,13 @@\n \tif (MCsecuremode & MC_SECUREMODE_PROCESS)\n \t{\n \t\tMCeerror->add(EE_SHELL_NOPERM, 0, 0, p_command);\n+\t\tctxt . Throw();\n+\t\treturn;\n+\t}\n+\n+\tif (MCStringIsEmpty(MCshellcmd))\n+\t{\n+\t\tMCeerror->add(EE_SHELL_BADCOMMAND, 0, 0, \"no shell\");\n \t\tctxt . Throw();\n \t\treturn;\n \t}",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tctxt . Throw();",
                "\t\treturn;",
                "\t}",
                "",
                "\tif (MCStringIsEmpty(MCshellcmd))",
                "\t{",
                "\t\tMCeerror->add(EE_SHELL_BADCOMMAND, 0, 0, \"no shell\");"
            ]
        }
    }
]