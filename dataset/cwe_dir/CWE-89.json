[
    {
        "cve_id": "CVE-2013-7262",
        "func_name": "MapServer/msPostGISLayerSetTimeFilter",
        "description": "SQL injection vulnerability in the msPostGISLayerSetTimeFilter function in mappostgis.c in MapServer before 6.4.1, when a WMS-Time service is used, allows remote attackers to execute arbitrary SQL commands via a crafted string in a PostGIS TIME filter.",
        "git_url": "https://github.com/MapServer/MapServer/commit/3a10f6b829297dae63492a8c63385044bc6953ed",
        "commit_title": "Fix potential SQL Injection with postgis TIME filters (#4834)",
        "commit_text": "",
        "func_before": "int msPostGISLayerSetTimeFilter(layerObj *lp, const char *timestring, const char *timefield)\n{\n  char **atimes, **aranges = NULL;\n  int numtimes=0,i=0,numranges=0;\n  size_t buffer_size = 512;\n  char buffer[512], bufferTmp[512];\n\n  buffer[0] = '\\0';\n  bufferTmp[0] = '\\0';\n\n  if (!lp || !timestring || !timefield)\n    return MS_FALSE;\n\n  /* discrete time */\n  if (strstr(timestring, \",\") == NULL &&\n      strstr(timestring, \"/\") == NULL) { /* discrete time */\n    createPostgresTimeCompareSimple(timefield, timestring, buffer, buffer_size);\n  } else {\n\n    /* multiple times, or ranges */\n    atimes = msStringSplit (timestring, ',', &numtimes);\n    if (atimes == NULL || numtimes < 1)\n      return MS_FALSE;\n\n    strlcat(buffer, \"(\", buffer_size);\n    for(i=0; i<numtimes; i++) {\n      if(i!=0) {\n        strlcat(buffer, \" OR \", buffer_size);\n      }\n      strlcat(buffer, \"(\", buffer_size);\n      aranges = msStringSplit(atimes[i],  '/', &numranges);\n      if(!aranges) return MS_FALSE;\n      if(numranges == 1) {\n        /* we don't have range, just a simple time */\n        createPostgresTimeCompareSimple(timefield, atimes[i], bufferTmp, buffer_size);\n        strlcat(buffer, bufferTmp, buffer_size);\n      } else if(numranges == 2) {\n        /* we have a range */\n        createPostgresTimeCompareRange(timefield, aranges[0], aranges[1], bufferTmp, buffer_size);\n        strlcat(buffer, bufferTmp, buffer_size);\n      } else {\n        return MS_FALSE;\n      }\n      msFreeCharArray(aranges, numranges);\n      strlcat(buffer, \")\", buffer_size);\n    }\n    strlcat(buffer, \")\", buffer_size);\n    msFreeCharArray(atimes, numtimes);\n  }\n  if(!*buffer) {\n    return MS_FALSE;\n  }\n  if(lp->filteritem) free(lp->filteritem);\n  lp->filteritem = msStrdup(timefield);\n  if (&lp->filter) {\n    /* if the filter is set and it's a string type, concatenate it with\n       the time. If not just free it */\n    if (lp->filter.type == MS_EXPRESSION) {\n      snprintf(bufferTmp, buffer_size, \"(%s) and %s\", lp->filter.string, buffer);\n      loadExpressionString(&lp->filter, bufferTmp);\n    } else {\n      freeExpression(&lp->filter);\n      loadExpressionString(&lp->filter, buffer);\n    }\n  }\n\n\n  return MS_TRUE;\n}",
        "func": "int msPostGISLayerSetTimeFilter(layerObj *lp, const char *timestring, const char *timefield)\n{\n  char **atimes, **aranges = NULL;\n  int numtimes=0,i=0,numranges=0;\n  size_t buffer_size = 512;\n  char buffer[512], bufferTmp[512];\n\n  buffer[0] = '\\0';\n  bufferTmp[0] = '\\0';\n\n  if (!lp || !timestring || !timefield)\n    return MS_FALSE;\n\n  if( strchr(timestring,'\\'') || strchr(timestring, '\\\\') ) {\n     msSetError(MS_MISCERR, \"Invalid time filter.\", \"msPostGISLayerSetTimeFilter()\");\n     return MS_FALSE;\n  }\n\n  /* discrete time */\n  if (strstr(timestring, \",\") == NULL &&\n      strstr(timestring, \"/\") == NULL) { /* discrete time */\n    createPostgresTimeCompareSimple(timefield, timestring, buffer, buffer_size);\n  } else {\n\n    /* multiple times, or ranges */\n    atimes = msStringSplit (timestring, ',', &numtimes);\n    if (atimes == NULL || numtimes < 1)\n      return MS_FALSE;\n\n    strlcat(buffer, \"(\", buffer_size);\n    for(i=0; i<numtimes; i++) {\n      if(i!=0) {\n        strlcat(buffer, \" OR \", buffer_size);\n      }\n      strlcat(buffer, \"(\", buffer_size);\n      aranges = msStringSplit(atimes[i],  '/', &numranges);\n      if(!aranges) return MS_FALSE;\n      if(numranges == 1) {\n        /* we don't have range, just a simple time */\n        createPostgresTimeCompareSimple(timefield, atimes[i], bufferTmp, buffer_size);\n        strlcat(buffer, bufferTmp, buffer_size);\n      } else if(numranges == 2) {\n        /* we have a range */\n        createPostgresTimeCompareRange(timefield, aranges[0], aranges[1], bufferTmp, buffer_size);\n        strlcat(buffer, bufferTmp, buffer_size);\n      } else {\n        return MS_FALSE;\n      }\n      msFreeCharArray(aranges, numranges);\n      strlcat(buffer, \")\", buffer_size);\n    }\n    strlcat(buffer, \")\", buffer_size);\n    msFreeCharArray(atimes, numtimes);\n  }\n  if(!*buffer) {\n    return MS_FALSE;\n  }\n  if(lp->filteritem) free(lp->filteritem);\n  lp->filteritem = msStrdup(timefield);\n  if (&lp->filter) {\n    /* if the filter is set and it's a string type, concatenate it with\n       the time. If not just free it */\n    if (lp->filter.type == MS_EXPRESSION) {\n      snprintf(bufferTmp, buffer_size, \"(%s) and %s\", lp->filter.string, buffer);\n      loadExpressionString(&lp->filter, bufferTmp);\n    } else {\n      freeExpression(&lp->filter);\n      loadExpressionString(&lp->filter, buffer);\n    }\n  }\n\n\n  return MS_TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,11 @@\n \n   if (!lp || !timestring || !timefield)\n     return MS_FALSE;\n+\n+  if( strchr(timestring,'\\'') || strchr(timestring, '\\\\') ) {\n+     msSetError(MS_MISCERR, \"Invalid time filter.\", \"msPostGISLayerSetTimeFilter()\");\n+     return MS_FALSE;\n+  }\n \n   /* discrete time */\n   if (strstr(timestring, \",\") == NULL &&",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  if( strchr(timestring,'\\'') || strchr(timestring, '\\\\') ) {",
                "     msSetError(MS_MISCERR, \"Invalid time filter.\", \"msPostGISLayerSetTimeFilter()\");",
                "     return MS_FALSE;",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-10664",
        "func_name": "domoticz/CWebServer::GetFloorplanImage",
        "description": "Domoticz before 4.10578 allows SQL Injection via the idx parameter in CWebServer::GetFloorplanImage in WebServer.cpp.",
        "git_url": "https://github.com/domoticz/domoticz/commit/ee70db46f81afa582c96b887b73bcd2a86feda00",
        "commit_title": "Fixed possible SQL Injection Vulnerability (Thanks to Fabio Carretto!)",
        "commit_text": "",
        "func_before": "void CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)\n\t\t{\n\t\t\tstd::string idx = request::findValue(&req, \"idx\");\n\t\t\tif (idx == \"\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstd::vector<std::vector<std::string> > result;\n\t\t\tresult = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%s\", idx.c_str());\n\t\t\tif (result.empty())\n\t\t\t\treturn;\n\t\t\treply::set_content(&rep, result[0][0].begin(), result[0][0].end());\n\t\t\tstd::string oname = \"floorplan\";\n\t\t\tif (result[0][0].size() > 10)\n\t\t\t{\n\t\t\t\tif (result[0][0][0] == 'P')\n\t\t\t\t\toname += \".png\";\n\t\t\t\telse if (result[0][0][0] == -1)\n\t\t\t\t\toname += \".jpg\";\n\t\t\t\telse if (result[0][0][0] == 'B')\n\t\t\t\t\toname += \".bmp\";\n\t\t\t\telse if (result[0][0][0] == 'G')\n\t\t\t\t\toname += \".gif\";\n\t\t\t}\n\t\t\treply::add_header_attachment(&rep, oname);\n\t\t}",
        "func": "void CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)\n\t\t{\n\t\t\tstd::string idx = request::findValue(&req, \"idx\");\n\t\t\tif (idx == \"\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstd::vector<std::vector<std::string> > result;\n\t\t\tresult = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%d\", atol(idx.c_str()));\n\t\t\tif (result.empty())\n\t\t\t\treturn;\n\t\t\treply::set_content(&rep, result[0][0].begin(), result[0][0].end());\n\t\t\tstd::string oname = \"floorplan\";\n\t\t\tif (result[0][0].size() > 10)\n\t\t\t{\n\t\t\t\tif (result[0][0][0] == 'P')\n\t\t\t\t\toname += \".png\";\n\t\t\t\telse if (result[0][0][0] == -1)\n\t\t\t\t\toname += \".jpg\";\n\t\t\t\telse if (result[0][0][0] == 'B')\n\t\t\t\t\toname += \".bmp\";\n\t\t\t\telse if (result[0][0][0] == 'G')\n\t\t\t\t\toname += \".gif\";\n\t\t\t}\n\t\t\treply::add_header_attachment(&rep, oname);\n\t\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tstd::vector<std::vector<std::string> > result;\n-\t\t\tresult = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%s\", idx.c_str());\n+\t\t\tresult = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%d\", atol(idx.c_str()));\n \t\t\tif (result.empty())\n \t\t\t\treturn;\n \t\t\treply::set_content(&rep, result[0][0].begin(), result[0][0].end());",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tresult = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%s\", idx.c_str());"
            ],
            "added_lines": [
                "\t\t\tresult = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%d\", atol(idx.c_str()));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23214",
        "func_name": "postgres/ProcessStartupPacket",
        "description": "When the server is configured to use trust authentication with a clientcert requirement or to use cert authentication, a man-in-the-middle attacker can inject arbitrary SQL queries when a connection is first established, despite the use of SSL certificate verification and encryption.",
        "git_url": "https://github.com/postgres/postgres/commit/28e24125541545483093819efae9bca603441951",
        "commit_title": "Reject extraneous data after SSL or GSS encryption handshake.",
        "commit_text": " The server collects up to a bufferload of data whenever it reads data from the client socket.  When SSL or GSS encryption is requested during startup, any additional data received with the initial request message remained in the buffer, and would be treated as already-decrypted data once the encryption handshake completed. Thus, a man-in-the-middle with the ability to inject data into the TCP connection could stuff some cleartext data into the start of a supposedly encryption-protected database session.  This could be abused to send faked SQL commands to the server, although that would only work if the server did not demand any authentication data.  (However, a server relying on SSL certificate authentication might well not do so.)  To fix, throw a protocol-violation error if the internal buffer is not empty after the encryption handshake.  Our thanks to Jacob Champion for reporting this problem.  Security: CVE-2021-23214",
        "func_before": "static int\nProcessStartupPacket(Port *port, bool ssl_done, bool gss_done)\n{\n\tint32\t\tlen;\n\tchar\t   *buf;\n\tProtocolVersion proto;\n\tMemoryContext oldcontext;\n\n\tpq_startmsgread();\n\n\t/*\n\t * Grab the first byte of the length word separately, so that we can tell\n\t * whether we have no data at all or an incomplete packet.  (This might\n\t * sound inefficient, but it's not really, because of buffering in\n\t * pqcomm.c.)\n\t */\n\tif (pq_getbytes((char *) &len, 1) == EOF)\n\t{\n\t\t/*\n\t\t * If we get no data at all, don't clutter the log with a complaint;\n\t\t * such cases often occur for legitimate reasons.  An example is that\n\t\t * we might be here after responding to NEGOTIATE_SSL_CODE, and if the\n\t\t * client didn't like our response, it'll probably just drop the\n\t\t * connection.  Service-monitoring software also often just opens and\n\t\t * closes a connection without sending anything.  (So do port\n\t\t * scanners, which may be less benign, but it's not really our job to\n\t\t * notice those.)\n\t\t */\n\t\treturn STATUS_ERROR;\n\t}\n\n\tif (pq_getbytes(((char *) &len) + 1, 3) == EOF)\n\t{\n\t\t/* Got a partial length word, so bleat about that */\n\t\tif (!ssl_done && !gss_done)\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"incomplete startup packet\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\tlen = pg_ntoh32(len);\n\tlen -= 4;\n\n\tif (len < (int32) sizeof(ProtocolVersion) ||\n\t\tlen > MAX_STARTUP_PACKET_LENGTH)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg(\"invalid length of startup packet\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\t/*\n\t * Allocate space to hold the startup packet, plus one extra byte that's\n\t * initialized to be zero.  This ensures we will have null termination of\n\t * all strings inside the packet.\n\t */\n\tbuf = palloc(len + 1);\n\tbuf[len] = '\\0';\n\n\tif (pq_getbytes(buf, len) == EOF)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg(\"incomplete startup packet\")));\n\t\treturn STATUS_ERROR;\n\t}\n\tpq_endmsgread();\n\n\t/*\n\t * The first field is either a protocol version number or a special\n\t * request code.\n\t */\n\tport->proto = proto = pg_ntoh32(*((ProtocolVersion *) buf));\n\n\tif (proto == CANCEL_REQUEST_CODE)\n\t{\n\t\tprocessCancelRequest(port, buf);\n\t\t/* Not really an error, but we don't want to proceed further */\n\t\treturn STATUS_ERROR;\n\t}\n\n\tif (proto == NEGOTIATE_SSL_CODE && !ssl_done)\n\t{\n\t\tchar\t\tSSLok;\n\n#ifdef USE_SSL\n\t\t/* No SSL when disabled or on Unix sockets */\n\t\tif (!LoadedSSL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\t\tSSLok = 'N';\n\t\telse\n\t\t\tSSLok = 'S';\t\t/* Support for SSL */\n#else\n\t\tSSLok = 'N';\t\t\t/* No support for SSL */\n#endif\n\nretry1:\n\t\tif (send(port->sock, &SSLok, 1, 0) != 1)\n\t\t{\n\t\t\tif (errno == EINTR)\n\t\t\t\tgoto retry1;\t/* if interrupted, just retry */\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t errmsg(\"failed to send SSL negotiation response: %m\")));\n\t\t\treturn STATUS_ERROR;\t/* close the connection */\n\t\t}\n\n#ifdef USE_SSL\n\t\tif (SSLok == 'S' && secure_open_server(port) == -1)\n\t\t\treturn STATUS_ERROR;\n#endif\n\n\t\t/*\n\t\t * regular startup packet, cancel, etc packet should follow, but not\n\t\t * another SSL negotiation request, and a GSS request should only\n\t\t * follow if SSL was rejected (client may negotiate in either order)\n\t\t */\n\t\treturn ProcessStartupPacket(port, true, SSLok == 'S');\n\t}\n\telse if (proto == NEGOTIATE_GSS_CODE && !gss_done)\n\t{\n\t\tchar\t\tGSSok = 'N';\n\n#ifdef ENABLE_GSS\n\t\t/* No GSSAPI encryption when on Unix socket */\n\t\tif (!IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\t\tGSSok = 'G';\n#endif\n\n\t\twhile (send(port->sock, &GSSok, 1, 0) != 1)\n\t\t{\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t errmsg(\"failed to send GSSAPI negotiation response: %m\")));\n\t\t\treturn STATUS_ERROR;\t/* close the connection */\n\t\t}\n\n#ifdef ENABLE_GSS\n\t\tif (GSSok == 'G' && secure_open_gssapi(port) == -1)\n\t\t\treturn STATUS_ERROR;\n#endif\n\n\t\t/*\n\t\t * regular startup packet, cancel, etc packet should follow, but not\n\t\t * another GSS negotiation request, and an SSL request should only\n\t\t * follow if GSS was rejected (client may negotiate in either order)\n\t\t */\n\t\treturn ProcessStartupPacket(port, GSSok == 'G', true);\n\t}\n\n\t/* Could add additional special packet types here */\n\n\t/*\n\t * Set FrontendProtocol now so that ereport() knows what format to send if\n\t * we fail during startup.\n\t */\n\tFrontendProtocol = proto;\n\n\t/* Check that the major protocol version is in range. */\n\tif (PG_PROTOCOL_MAJOR(proto) < PG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST) ||\n\t\tPG_PROTOCOL_MAJOR(proto) > PG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST))\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"unsupported frontend protocol %u.%u: server supports %u.0 to %u.%u\",\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(proto), PG_PROTOCOL_MINOR(proto),\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST),\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST),\n\t\t\t\t\t\tPG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST))));\n\n\t/*\n\t * Now fetch parameters out of startup packet and save them into the Port\n\t * structure.  All data structures attached to the Port struct must be\n\t * allocated in TopMemoryContext so that they will remain available in a\n\t * running backend (even after PostmasterContext is destroyed).  We need\n\t * not worry about leaking this storage on failure, since we aren't in the\n\t * postmaster process anymore.\n\t */\n\toldcontext = MemoryContextSwitchTo(TopMemoryContext);\n\n\t/* Handle protocol version 3 startup packet */\n\t{\n\t\tint32\t\toffset = sizeof(ProtocolVersion);\n\t\tList\t   *unrecognized_protocol_options = NIL;\n\n\t\t/*\n\t\t * Scan packet body for name/option pairs.  We can assume any string\n\t\t * beginning within the packet body is null-terminated, thanks to\n\t\t * zeroing extra byte above.\n\t\t */\n\t\tport->guc_options = NIL;\n\n\t\twhile (offset < len)\n\t\t{\n\t\t\tchar\t   *nameptr = buf + offset;\n\t\t\tint32\t\tvaloffset;\n\t\t\tchar\t   *valptr;\n\n\t\t\tif (*nameptr == '\\0')\n\t\t\t\tbreak;\t\t\t/* found packet terminator */\n\t\t\tvaloffset = offset + strlen(nameptr) + 1;\n\t\t\tif (valoffset >= len)\n\t\t\t\tbreak;\t\t\t/* missing value, will complain below */\n\t\t\tvalptr = buf + valoffset;\n\n\t\t\tif (strcmp(nameptr, \"database\") == 0)\n\t\t\t\tport->database_name = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, \"user\") == 0)\n\t\t\t\tport->user_name = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, \"options\") == 0)\n\t\t\t\tport->cmdline_options = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, \"replication\") == 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Due to backward compatibility concerns the replication\n\t\t\t\t * parameter is a hybrid beast which allows the value to be\n\t\t\t\t * either boolean or the string 'database'. The latter\n\t\t\t\t * connects to a specific database which is e.g. required for\n\t\t\t\t * logical decoding while.\n\t\t\t\t */\n\t\t\t\tif (strcmp(valptr, \"database\") == 0)\n\t\t\t\t{\n\t\t\t\t\tam_walsender = true;\n\t\t\t\t\tam_db_walsender = true;\n\t\t\t\t}\n\t\t\t\telse if (!parse_bool(valptr, &am_walsender))\n\t\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"invalid value for parameter \\\"%s\\\": \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\"replication\",\n\t\t\t\t\t\t\t\t\tvalptr),\n\t\t\t\t\t\t\t errhint(\"Valid values are: \\\"false\\\", 0, \\\"true\\\", 1, \\\"database\\\".\")));\n\t\t\t}\n\t\t\telse if (strncmp(nameptr, \"_pq_.\", 5) == 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Any option beginning with _pq_. is reserved for use as a\n\t\t\t\t * protocol-level option, but at present no such options are\n\t\t\t\t * defined.\n\t\t\t\t */\n\t\t\t\tunrecognized_protocol_options =\n\t\t\t\t\tlappend(unrecognized_protocol_options, pstrdup(nameptr));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Assume it's a generic GUC option */\n\t\t\t\tport->guc_options = lappend(port->guc_options,\n\t\t\t\t\t\t\t\t\t\t\tpstrdup(nameptr));\n\t\t\t\tport->guc_options = lappend(port->guc_options,\n\t\t\t\t\t\t\t\t\t\t\tpstrdup(valptr));\n\n\t\t\t\t/*\n\t\t\t\t * Copy application_name to port if we come across it.  This\n\t\t\t\t * is done so we can log the application_name in the\n\t\t\t\t * connection authorization message.  Note that the GUC would\n\t\t\t\t * be used but we haven't gone through GUC setup yet.\n\t\t\t\t */\n\t\t\t\tif (strcmp(nameptr, \"application_name\") == 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *tmp_app_name = pstrdup(valptr);\n\n\t\t\t\t\tpg_clean_ascii(tmp_app_name);\n\n\t\t\t\t\tport->application_name = tmp_app_name;\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset = valoffset + strlen(valptr) + 1;\n\t\t}\n\n\t\t/*\n\t\t * If we didn't find a packet terminator exactly at the end of the\n\t\t * given packet length, complain.\n\t\t */\n\t\tif (offset != len - 1)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"invalid startup packet layout: expected terminator as last byte\")));\n\n\t\t/*\n\t\t * If the client requested a newer protocol version or if the client\n\t\t * requested any protocol options we didn't recognize, let them know\n\t\t * the newest minor protocol version we do support and the names of\n\t\t * any unrecognized options.\n\t\t */\n\t\tif (PG_PROTOCOL_MINOR(proto) > PG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST) ||\n\t\t\tunrecognized_protocol_options != NIL)\n\t\t\tSendNegotiateProtocolVersion(unrecognized_protocol_options);\n\t}\n\n\t/* Check a user name was given. */\n\tif (port->user_name == NULL || port->user_name[0] == '\\0')\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t errmsg(\"no PostgreSQL user name specified in startup packet\")));\n\n\t/* The database defaults to the user name. */\n\tif (port->database_name == NULL || port->database_name[0] == '\\0')\n\t\tport->database_name = pstrdup(port->user_name);\n\n\tif (Db_user_namespace)\n\t{\n\t\t/*\n\t\t * If user@, it is a global user, remove '@'. We only want to do this\n\t\t * if there is an '@' at the end and no earlier in the user string or\n\t\t * they may fake as a local user of another database attaching to this\n\t\t * database.\n\t\t */\n\t\tif (strchr(port->user_name, '@') ==\n\t\t\tport->user_name + strlen(port->user_name) - 1)\n\t\t\t*strchr(port->user_name, '@') = '\\0';\n\t\telse\n\t\t{\n\t\t\t/* Append '@' and dbname */\n\t\t\tport->user_name = psprintf(\"%s@%s\", port->user_name, port->database_name);\n\t\t}\n\t}\n\n\t/*\n\t * Truncate given database and user names to length of a Postgres name.\n\t * This avoids lookup failures when overlength names are given.\n\t */\n\tif (strlen(port->database_name) >= NAMEDATALEN)\n\t\tport->database_name[NAMEDATALEN - 1] = '\\0';\n\tif (strlen(port->user_name) >= NAMEDATALEN)\n\t\tport->user_name[NAMEDATALEN - 1] = '\\0';\n\n\tif (am_walsender)\n\t\tMyBackendType = B_WAL_SENDER;\n\telse\n\t\tMyBackendType = B_BACKEND;\n\n\t/*\n\t * Normal walsender backends, e.g. for streaming replication, are not\n\t * connected to a particular database. But walsenders used for logical\n\t * replication need to connect to a specific database. We allow streaming\n\t * replication commands to be issued even if connected to a database as it\n\t * can make sense to first make a basebackup and then stream changes\n\t * starting from that.\n\t */\n\tif (am_walsender && !am_db_walsender)\n\t\tport->database_name[0] = '\\0';\n\n\t/*\n\t * Done putting stuff in TopMemoryContext.\n\t */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/*\n\t * If we're going to reject the connection due to database state, say so\n\t * now instead of wasting cycles on an authentication exchange. (This also\n\t * allows a pg_ping utility to be written.)\n\t */\n\tswitch (port->canAcceptConnections)\n\t{\n\t\tcase CAC_STARTUP:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg(\"the database system is starting up\")));\n\t\t\tbreak;\n\t\tcase CAC_NOTCONSISTENT:\n\t\t\tif (EnableHotStandby)\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t\t errmsg(\"the database system is not yet accepting connections\"),\n\t\t\t\t\t\t errdetail(\"Consistent recovery state has not been yet reached.\")));\n\t\t\telse\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t\t errmsg(\"the database system is not accepting connections\"),\n\t\t\t\t\t\t errdetail(\"Hot standby mode is disabled.\")));\n\t\t\tbreak;\n\t\tcase CAC_SHUTDOWN:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg(\"the database system is shutting down\")));\n\t\t\tbreak;\n\t\tcase CAC_RECOVERY:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg(\"the database system is in recovery mode\")));\n\t\t\tbreak;\n\t\tcase CAC_TOOMANY:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_CONNECTIONS),\n\t\t\t\t\t errmsg(\"sorry, too many clients already\")));\n\t\t\tbreak;\n\t\tcase CAC_SUPERUSER:\n\t\t\t/* OK for now, will check in InitPostgres */\n\t\t\tbreak;\n\t\tcase CAC_OK:\n\t\t\tbreak;\n\t}\n\n\treturn STATUS_OK;\n}",
        "func": "static int\nProcessStartupPacket(Port *port, bool ssl_done, bool gss_done)\n{\n\tint32\t\tlen;\n\tchar\t   *buf;\n\tProtocolVersion proto;\n\tMemoryContext oldcontext;\n\n\tpq_startmsgread();\n\n\t/*\n\t * Grab the first byte of the length word separately, so that we can tell\n\t * whether we have no data at all or an incomplete packet.  (This might\n\t * sound inefficient, but it's not really, because of buffering in\n\t * pqcomm.c.)\n\t */\n\tif (pq_getbytes((char *) &len, 1) == EOF)\n\t{\n\t\t/*\n\t\t * If we get no data at all, don't clutter the log with a complaint;\n\t\t * such cases often occur for legitimate reasons.  An example is that\n\t\t * we might be here after responding to NEGOTIATE_SSL_CODE, and if the\n\t\t * client didn't like our response, it'll probably just drop the\n\t\t * connection.  Service-monitoring software also often just opens and\n\t\t * closes a connection without sending anything.  (So do port\n\t\t * scanners, which may be less benign, but it's not really our job to\n\t\t * notice those.)\n\t\t */\n\t\treturn STATUS_ERROR;\n\t}\n\n\tif (pq_getbytes(((char *) &len) + 1, 3) == EOF)\n\t{\n\t\t/* Got a partial length word, so bleat about that */\n\t\tif (!ssl_done && !gss_done)\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"incomplete startup packet\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\tlen = pg_ntoh32(len);\n\tlen -= 4;\n\n\tif (len < (int32) sizeof(ProtocolVersion) ||\n\t\tlen > MAX_STARTUP_PACKET_LENGTH)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg(\"invalid length of startup packet\")));\n\t\treturn STATUS_ERROR;\n\t}\n\n\t/*\n\t * Allocate space to hold the startup packet, plus one extra byte that's\n\t * initialized to be zero.  This ensures we will have null termination of\n\t * all strings inside the packet.\n\t */\n\tbuf = palloc(len + 1);\n\tbuf[len] = '\\0';\n\n\tif (pq_getbytes(buf, len) == EOF)\n\t{\n\t\tereport(COMMERROR,\n\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t errmsg(\"incomplete startup packet\")));\n\t\treturn STATUS_ERROR;\n\t}\n\tpq_endmsgread();\n\n\t/*\n\t * The first field is either a protocol version number or a special\n\t * request code.\n\t */\n\tport->proto = proto = pg_ntoh32(*((ProtocolVersion *) buf));\n\n\tif (proto == CANCEL_REQUEST_CODE)\n\t{\n\t\tprocessCancelRequest(port, buf);\n\t\t/* Not really an error, but we don't want to proceed further */\n\t\treturn STATUS_ERROR;\n\t}\n\n\tif (proto == NEGOTIATE_SSL_CODE && !ssl_done)\n\t{\n\t\tchar\t\tSSLok;\n\n#ifdef USE_SSL\n\t\t/* No SSL when disabled or on Unix sockets */\n\t\tif (!LoadedSSL || IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\t\tSSLok = 'N';\n\t\telse\n\t\t\tSSLok = 'S';\t\t/* Support for SSL */\n#else\n\t\tSSLok = 'N';\t\t\t/* No support for SSL */\n#endif\n\nretry1:\n\t\tif (send(port->sock, &SSLok, 1, 0) != 1)\n\t\t{\n\t\t\tif (errno == EINTR)\n\t\t\t\tgoto retry1;\t/* if interrupted, just retry */\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t errmsg(\"failed to send SSL negotiation response: %m\")));\n\t\t\treturn STATUS_ERROR;\t/* close the connection */\n\t\t}\n\n#ifdef USE_SSL\n\t\tif (SSLok == 'S' && secure_open_server(port) == -1)\n\t\t\treturn STATUS_ERROR;\n#endif\n\n\t\t/*\n\t\t * At this point we should have no data already buffered.  If we do,\n\t\t * it was received before we performed the SSL handshake, so it wasn't\n\t\t * encrypted and indeed may have been injected by a man-in-the-middle.\n\t\t * We report this case to the client.\n\t\t */\n\t\tif (pq_buffer_has_data())\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"received unencrypted data after SSL request\"),\n\t\t\t\t\t errdetail(\"This could be either a client-software bug or evidence of an attempted man-in-the-middle attack.\")));\n\n\t\t/*\n\t\t * regular startup packet, cancel, etc packet should follow, but not\n\t\t * another SSL negotiation request, and a GSS request should only\n\t\t * follow if SSL was rejected (client may negotiate in either order)\n\t\t */\n\t\treturn ProcessStartupPacket(port, true, SSLok == 'S');\n\t}\n\telse if (proto == NEGOTIATE_GSS_CODE && !gss_done)\n\t{\n\t\tchar\t\tGSSok = 'N';\n\n#ifdef ENABLE_GSS\n\t\t/* No GSSAPI encryption when on Unix socket */\n\t\tif (!IS_AF_UNIX(port->laddr.addr.ss_family))\n\t\t\tGSSok = 'G';\n#endif\n\n\t\twhile (send(port->sock, &GSSok, 1, 0) != 1)\n\t\t{\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tereport(COMMERROR,\n\t\t\t\t\t(errcode_for_socket_access(),\n\t\t\t\t\t errmsg(\"failed to send GSSAPI negotiation response: %m\")));\n\t\t\treturn STATUS_ERROR;\t/* close the connection */\n\t\t}\n\n#ifdef ENABLE_GSS\n\t\tif (GSSok == 'G' && secure_open_gssapi(port) == -1)\n\t\t\treturn STATUS_ERROR;\n#endif\n\n\t\t/*\n\t\t * At this point we should have no data already buffered.  If we do,\n\t\t * it was received before we performed the GSS handshake, so it wasn't\n\t\t * encrypted and indeed may have been injected by a man-in-the-middle.\n\t\t * We report this case to the client.\n\t\t */\n\t\tif (pq_buffer_has_data())\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"received unencrypted data after GSSAPI encryption request\"),\n\t\t\t\t\t errdetail(\"This could be either a client-software bug or evidence of an attempted man-in-the-middle attack.\")));\n\n\t\t/*\n\t\t * regular startup packet, cancel, etc packet should follow, but not\n\t\t * another GSS negotiation request, and an SSL request should only\n\t\t * follow if GSS was rejected (client may negotiate in either order)\n\t\t */\n\t\treturn ProcessStartupPacket(port, GSSok == 'G', true);\n\t}\n\n\t/* Could add additional special packet types here */\n\n\t/*\n\t * Set FrontendProtocol now so that ereport() knows what format to send if\n\t * we fail during startup.\n\t */\n\tFrontendProtocol = proto;\n\n\t/* Check that the major protocol version is in range. */\n\tif (PG_PROTOCOL_MAJOR(proto) < PG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST) ||\n\t\tPG_PROTOCOL_MAJOR(proto) > PG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST))\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"unsupported frontend protocol %u.%u: server supports %u.0 to %u.%u\",\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(proto), PG_PROTOCOL_MINOR(proto),\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST),\n\t\t\t\t\t\tPG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST),\n\t\t\t\t\t\tPG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST))));\n\n\t/*\n\t * Now fetch parameters out of startup packet and save them into the Port\n\t * structure.  All data structures attached to the Port struct must be\n\t * allocated in TopMemoryContext so that they will remain available in a\n\t * running backend (even after PostmasterContext is destroyed).  We need\n\t * not worry about leaking this storage on failure, since we aren't in the\n\t * postmaster process anymore.\n\t */\n\toldcontext = MemoryContextSwitchTo(TopMemoryContext);\n\n\t/* Handle protocol version 3 startup packet */\n\t{\n\t\tint32\t\toffset = sizeof(ProtocolVersion);\n\t\tList\t   *unrecognized_protocol_options = NIL;\n\n\t\t/*\n\t\t * Scan packet body for name/option pairs.  We can assume any string\n\t\t * beginning within the packet body is null-terminated, thanks to\n\t\t * zeroing extra byte above.\n\t\t */\n\t\tport->guc_options = NIL;\n\n\t\twhile (offset < len)\n\t\t{\n\t\t\tchar\t   *nameptr = buf + offset;\n\t\t\tint32\t\tvaloffset;\n\t\t\tchar\t   *valptr;\n\n\t\t\tif (*nameptr == '\\0')\n\t\t\t\tbreak;\t\t\t/* found packet terminator */\n\t\t\tvaloffset = offset + strlen(nameptr) + 1;\n\t\t\tif (valoffset >= len)\n\t\t\t\tbreak;\t\t\t/* missing value, will complain below */\n\t\t\tvalptr = buf + valoffset;\n\n\t\t\tif (strcmp(nameptr, \"database\") == 0)\n\t\t\t\tport->database_name = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, \"user\") == 0)\n\t\t\t\tport->user_name = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, \"options\") == 0)\n\t\t\t\tport->cmdline_options = pstrdup(valptr);\n\t\t\telse if (strcmp(nameptr, \"replication\") == 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Due to backward compatibility concerns the replication\n\t\t\t\t * parameter is a hybrid beast which allows the value to be\n\t\t\t\t * either boolean or the string 'database'. The latter\n\t\t\t\t * connects to a specific database which is e.g. required for\n\t\t\t\t * logical decoding while.\n\t\t\t\t */\n\t\t\t\tif (strcmp(valptr, \"database\") == 0)\n\t\t\t\t{\n\t\t\t\t\tam_walsender = true;\n\t\t\t\t\tam_db_walsender = true;\n\t\t\t\t}\n\t\t\t\telse if (!parse_bool(valptr, &am_walsender))\n\t\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t errmsg(\"invalid value for parameter \\\"%s\\\": \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\"replication\",\n\t\t\t\t\t\t\t\t\tvalptr),\n\t\t\t\t\t\t\t errhint(\"Valid values are: \\\"false\\\", 0, \\\"true\\\", 1, \\\"database\\\".\")));\n\t\t\t}\n\t\t\telse if (strncmp(nameptr, \"_pq_.\", 5) == 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Any option beginning with _pq_. is reserved for use as a\n\t\t\t\t * protocol-level option, but at present no such options are\n\t\t\t\t * defined.\n\t\t\t\t */\n\t\t\t\tunrecognized_protocol_options =\n\t\t\t\t\tlappend(unrecognized_protocol_options, pstrdup(nameptr));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Assume it's a generic GUC option */\n\t\t\t\tport->guc_options = lappend(port->guc_options,\n\t\t\t\t\t\t\t\t\t\t\tpstrdup(nameptr));\n\t\t\t\tport->guc_options = lappend(port->guc_options,\n\t\t\t\t\t\t\t\t\t\t\tpstrdup(valptr));\n\n\t\t\t\t/*\n\t\t\t\t * Copy application_name to port if we come across it.  This\n\t\t\t\t * is done so we can log the application_name in the\n\t\t\t\t * connection authorization message.  Note that the GUC would\n\t\t\t\t * be used but we haven't gone through GUC setup yet.\n\t\t\t\t */\n\t\t\t\tif (strcmp(nameptr, \"application_name\") == 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *tmp_app_name = pstrdup(valptr);\n\n\t\t\t\t\tpg_clean_ascii(tmp_app_name);\n\n\t\t\t\t\tport->application_name = tmp_app_name;\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset = valoffset + strlen(valptr) + 1;\n\t\t}\n\n\t\t/*\n\t\t * If we didn't find a packet terminator exactly at the end of the\n\t\t * given packet length, complain.\n\t\t */\n\t\tif (offset != len - 1)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n\t\t\t\t\t errmsg(\"invalid startup packet layout: expected terminator as last byte\")));\n\n\t\t/*\n\t\t * If the client requested a newer protocol version or if the client\n\t\t * requested any protocol options we didn't recognize, let them know\n\t\t * the newest minor protocol version we do support and the names of\n\t\t * any unrecognized options.\n\t\t */\n\t\tif (PG_PROTOCOL_MINOR(proto) > PG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST) ||\n\t\t\tunrecognized_protocol_options != NIL)\n\t\t\tSendNegotiateProtocolVersion(unrecognized_protocol_options);\n\t}\n\n\t/* Check a user name was given. */\n\tif (port->user_name == NULL || port->user_name[0] == '\\0')\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),\n\t\t\t\t errmsg(\"no PostgreSQL user name specified in startup packet\")));\n\n\t/* The database defaults to the user name. */\n\tif (port->database_name == NULL || port->database_name[0] == '\\0')\n\t\tport->database_name = pstrdup(port->user_name);\n\n\tif (Db_user_namespace)\n\t{\n\t\t/*\n\t\t * If user@, it is a global user, remove '@'. We only want to do this\n\t\t * if there is an '@' at the end and no earlier in the user string or\n\t\t * they may fake as a local user of another database attaching to this\n\t\t * database.\n\t\t */\n\t\tif (strchr(port->user_name, '@') ==\n\t\t\tport->user_name + strlen(port->user_name) - 1)\n\t\t\t*strchr(port->user_name, '@') = '\\0';\n\t\telse\n\t\t{\n\t\t\t/* Append '@' and dbname */\n\t\t\tport->user_name = psprintf(\"%s@%s\", port->user_name, port->database_name);\n\t\t}\n\t}\n\n\t/*\n\t * Truncate given database and user names to length of a Postgres name.\n\t * This avoids lookup failures when overlength names are given.\n\t */\n\tif (strlen(port->database_name) >= NAMEDATALEN)\n\t\tport->database_name[NAMEDATALEN - 1] = '\\0';\n\tif (strlen(port->user_name) >= NAMEDATALEN)\n\t\tport->user_name[NAMEDATALEN - 1] = '\\0';\n\n\tif (am_walsender)\n\t\tMyBackendType = B_WAL_SENDER;\n\telse\n\t\tMyBackendType = B_BACKEND;\n\n\t/*\n\t * Normal walsender backends, e.g. for streaming replication, are not\n\t * connected to a particular database. But walsenders used for logical\n\t * replication need to connect to a specific database. We allow streaming\n\t * replication commands to be issued even if connected to a database as it\n\t * can make sense to first make a basebackup and then stream changes\n\t * starting from that.\n\t */\n\tif (am_walsender && !am_db_walsender)\n\t\tport->database_name[0] = '\\0';\n\n\t/*\n\t * Done putting stuff in TopMemoryContext.\n\t */\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/*\n\t * If we're going to reject the connection due to database state, say so\n\t * now instead of wasting cycles on an authentication exchange. (This also\n\t * allows a pg_ping utility to be written.)\n\t */\n\tswitch (port->canAcceptConnections)\n\t{\n\t\tcase CAC_STARTUP:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg(\"the database system is starting up\")));\n\t\t\tbreak;\n\t\tcase CAC_NOTCONSISTENT:\n\t\t\tif (EnableHotStandby)\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t\t errmsg(\"the database system is not yet accepting connections\"),\n\t\t\t\t\t\t errdetail(\"Consistent recovery state has not been yet reached.\")));\n\t\t\telse\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t\t errmsg(\"the database system is not accepting connections\"),\n\t\t\t\t\t\t errdetail(\"Hot standby mode is disabled.\")));\n\t\t\tbreak;\n\t\tcase CAC_SHUTDOWN:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg(\"the database system is shutting down\")));\n\t\t\tbreak;\n\t\tcase CAC_RECOVERY:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CANNOT_CONNECT_NOW),\n\t\t\t\t\t errmsg(\"the database system is in recovery mode\")));\n\t\t\tbreak;\n\t\tcase CAC_TOOMANY:\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_CONNECTIONS),\n\t\t\t\t\t errmsg(\"sorry, too many clients already\")));\n\t\t\tbreak;\n\t\tcase CAC_SUPERUSER:\n\t\t\t/* OK for now, will check in InitPostgres */\n\t\t\tbreak;\n\t\tcase CAC_OK:\n\t\t\tbreak;\n\t}\n\n\treturn STATUS_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -112,6 +112,18 @@\n #endif\n \n \t\t/*\n+\t\t * At this point we should have no data already buffered.  If we do,\n+\t\t * it was received before we performed the SSL handshake, so it wasn't\n+\t\t * encrypted and indeed may have been injected by a man-in-the-middle.\n+\t\t * We report this case to the client.\n+\t\t */\n+\t\tif (pq_buffer_has_data())\n+\t\t\tereport(FATAL,\n+\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n+\t\t\t\t\t errmsg(\"received unencrypted data after SSL request\"),\n+\t\t\t\t\t errdetail(\"This could be either a client-software bug or evidence of an attempted man-in-the-middle attack.\")));\n+\n+\t\t/*\n \t\t * regular startup packet, cancel, etc packet should follow, but not\n \t\t * another SSL negotiation request, and a GSS request should only\n \t\t * follow if SSL was rejected (client may negotiate in either order)\n@@ -142,6 +154,18 @@\n \t\tif (GSSok == 'G' && secure_open_gssapi(port) == -1)\n \t\t\treturn STATUS_ERROR;\n #endif\n+\n+\t\t/*\n+\t\t * At this point we should have no data already buffered.  If we do,\n+\t\t * it was received before we performed the GSS handshake, so it wasn't\n+\t\t * encrypted and indeed may have been injected by a man-in-the-middle.\n+\t\t * We report this case to the client.\n+\t\t */\n+\t\tif (pq_buffer_has_data())\n+\t\t\tereport(FATAL,\n+\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),\n+\t\t\t\t\t errmsg(\"received unencrypted data after GSSAPI encryption request\"),\n+\t\t\t\t\t errdetail(\"This could be either a client-software bug or evidence of an attempted man-in-the-middle attack.\")));\n \n \t\t/*\n \t\t * regular startup packet, cancel, etc packet should follow, but not",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t * At this point we should have no data already buffered.  If we do,",
                "\t\t * it was received before we performed the SSL handshake, so it wasn't",
                "\t\t * encrypted and indeed may have been injected by a man-in-the-middle.",
                "\t\t * We report this case to the client.",
                "\t\t */",
                "\t\tif (pq_buffer_has_data())",
                "\t\t\tereport(FATAL,",
                "\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),",
                "\t\t\t\t\t errmsg(\"received unencrypted data after SSL request\"),",
                "\t\t\t\t\t errdetail(\"This could be either a client-software bug or evidence of an attempted man-in-the-middle attack.\")));",
                "",
                "\t\t/*",
                "",
                "\t\t/*",
                "\t\t * At this point we should have no data already buffered.  If we do,",
                "\t\t * it was received before we performed the GSS handshake, so it wasn't",
                "\t\t * encrypted and indeed may have been injected by a man-in-the-middle.",
                "\t\t * We report this case to the client.",
                "\t\t */",
                "\t\tif (pq_buffer_has_data())",
                "\t\t\tereport(FATAL,",
                "\t\t\t\t\t(errcode(ERRCODE_PROTOCOL_VIOLATION),",
                "\t\t\t\t\t errmsg(\"received unencrypted data after GSSAPI encryption request\"),",
                "\t\t\t\t\t errdetail(\"This could be either a client-software bug or evidence of an attempted man-in-the-middle attack.\")));"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31607",
        "func_name": "openlink/virtuoso-opensource/ddl_create_key",
        "description": "An issue in the __libc_malloc component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/ea8b2c975c6c96f36e34014d6c71a73761198ebe",
        "commit_title": "Fixed missing check for max number of key parts (fixes #1120)",
        "commit_text": "",
        "func_before": "void\nddl_create_key (query_instance_t * qi,\n    char *name, char *table, caddr_t * parts,\n\t\tint cluster_on_id, int is_object_id, int is_unique, int is_bitmap, caddr_t * opts)\n{\n  caddr_t tn, in;\n  client_connection_t *cli = qi->qi_client;\n  caddr_t parts_tmp[K_MAX_PARTS];\n\n  caddr_t parts_box;\n  key_id_t key_id;\n  int n_parts = BOX_ELEMENTS (parts);\n  int decl_parts = n_parts;\n  int parts_fill = n_parts, x;\n  local_cursor_t *lc_keys;\n  local_cursor_t *lc_key_parts;\n  int n_primary, prim_id;\n  char *szTheTableName;\n  dk_set_t to_free = NULL;\n\n  memcpy (parts_tmp, parts, box_length ((caddr_t) parts));\n\n  qr_rec_exec (find_primary_stmt, cli, &lc_keys, qi, NULL, 1,\n      \":0\", table, QRP_STR);\n  if (!lc_next (lc_keys))\n    {\n      lc_free (lc_keys);\n      sqlr_new_error (\"42S12\", \"SQ017\",\n\t  \"No primary key for %s. Specify qualifier and owner if you are not owner of the table.\", table);\n    }\n  n_primary = (int) unbox (lc_get_col (lc_keys, \"K.KEY_N_SIGNIFICANT\"));\n  prim_id = (int) unbox (lc_get_col (lc_keys, \"K.KEY_ID\"));\n  szTheTableName  = box_string((case_mode == CM_MSSQL) ? lc_get_col (lc_keys, \"K.KEY_TABLE\") : table);\n  lc_free (lc_keys);\n\n  ddl_check_duplicate_cols (NULL, parts);\n\n  qr_rec_exec (get_key_parts_stmt, cli, &lc_key_parts, qi, NULL, 2,\n      \":ID\", (ptrlong) prim_id, QRP_INT,\n      \":LIMIT\", (ptrlong) n_primary, QRP_INT);\n  while (lc_next (lc_key_parts))\n    {\n      /* oid_t col_id = unbox (lc_get_col (lc_key_parts, \"K.KP_COL\")); */\n      /* int nth = (int) unbox (lc_get_col (lc_key_parts, \"K.KP_NTH\")); */\n      char *c_name = box_string (lc_get_col (lc_key_parts, \"C.COLUMN\"));\n      if (KO_NO_PK (opts))\n\tgoto already_in;\n      for (x = 0; x < n_parts; x++)\n\tif (0 == CASEMODESTRCMP (c_name, parts[x]))\n\t  {\n\t    dk_free_box (c_name);\n\t    goto already_in;\n\t  }\n\n      dk_set_push (&to_free, c_name);\n      parts_tmp[parts_fill++] = c_name;\n    already_in:;\n    }\n  lc_free (lc_key_parts);\n\n  parts_box = dk_alloc_box (parts_fill * sizeof (caddr_t),\n      DV_ARRAY_OF_POINTER);\n  memcpy (parts_box, parts_tmp, parts_fill * sizeof (caddr_t));\n\n\n  ddl_insert_sec_key_parts (qi, (key_id_t) prim_id, szTheTableName, name, (caddr_t *) parts_box,\n      cluster_on_id, &key_id, is_object_id, is_unique, decl_parts);\n\n  dk_free_tree (list_to_array (to_free));\n  dk_free_box (parts_box);\n\n  ddl_key_options (qi, szTheTableName, key_id, opts);\n  if (is_unique)\n    ddl_key_opt (qi, szTheTableName, key_id);\n  ddl_table_changed (qi, szTheTableName);\n  tn = box_dv_short_string (table);\n  in = box_dv_short_string (name);\n  inx_opt_cluster (qi, tn, in, opts);\n  dk_free_box (tn);\n  dk_free_box (in);\n\n  {\n    dbe_table_t *tb = qi_name_to_table (qi, szTheTableName);\n    if (tb)\n      ddl_create_subtable_keys (qi, tb, name, key_id, key_id);\n  }\n  dk_free_box(szTheTableName);\n}",
        "func": "void\nddl_create_key (query_instance_t * qi,\n    char *name, char *table, caddr_t * parts,\n\t\tint cluster_on_id, int is_object_id, int is_unique, int is_bitmap, caddr_t * opts)\n{\n  caddr_t tn, in;\n  client_connection_t *cli = qi->qi_client;\n  caddr_t parts_tmp[K_MAX_PARTS];\n\n  caddr_t parts_box;\n  key_id_t key_id;\n  int n_parts = BOX_ELEMENTS (parts);\n  int decl_parts = n_parts;\n  int parts_fill = n_parts, x;\n  local_cursor_t *lc_keys;\n  local_cursor_t *lc_key_parts;\n  int n_primary, prim_id;\n  char *szTheTableName;\n  dk_set_t to_free = NULL;\n\n  if (n_parts > K_MAX_PARTS)\n    sqlr_new_error (\"42S12\", \"SQ017\", \"Too many key parts\");\n  memcpy (parts_tmp, parts, box_length ((caddr_t) parts));\n\n  qr_rec_exec (find_primary_stmt, cli, &lc_keys, qi, NULL, 1,\n      \":0\", table, QRP_STR);\n  if (!lc_next (lc_keys))\n    {\n      lc_free (lc_keys);\n      sqlr_new_error (\"42S12\", \"SQ017\",\n\t  \"No primary key for %s. Specify qualifier and owner if you are not owner of the table.\", table);\n    }\n  n_primary = (int) unbox (lc_get_col (lc_keys, \"K.KEY_N_SIGNIFICANT\"));\n  prim_id = (int) unbox (lc_get_col (lc_keys, \"K.KEY_ID\"));\n  szTheTableName  = box_string((case_mode == CM_MSSQL) ? lc_get_col (lc_keys, \"K.KEY_TABLE\") : table);\n  lc_free (lc_keys);\n\n  ddl_check_duplicate_cols (NULL, parts);\n\n  qr_rec_exec (get_key_parts_stmt, cli, &lc_key_parts, qi, NULL, 2,\n      \":ID\", (ptrlong) prim_id, QRP_INT,\n      \":LIMIT\", (ptrlong) n_primary, QRP_INT);\n  while (lc_next (lc_key_parts))\n    {\n      /* oid_t col_id = unbox (lc_get_col (lc_key_parts, \"K.KP_COL\")); */\n      /* int nth = (int) unbox (lc_get_col (lc_key_parts, \"K.KP_NTH\")); */\n      char *c_name = box_string (lc_get_col (lc_key_parts, \"C.COLUMN\"));\n      if (KO_NO_PK (opts))\n\tgoto already_in;\n      for (x = 0; x < n_parts; x++)\n\tif (0 == CASEMODESTRCMP (c_name, parts[x]))\n\t  {\n\t    dk_free_box (c_name);\n\t    goto already_in;\n\t  }\n\n      dk_set_push (&to_free, c_name);\n      parts_tmp[parts_fill++] = c_name;\n    already_in:;\n    }\n  lc_free (lc_key_parts);\n\n  parts_box = dk_alloc_box (parts_fill * sizeof (caddr_t),\n      DV_ARRAY_OF_POINTER);\n  memcpy (parts_box, parts_tmp, parts_fill * sizeof (caddr_t));\n\n\n  ddl_insert_sec_key_parts (qi, (key_id_t) prim_id, szTheTableName, name, (caddr_t *) parts_box,\n      cluster_on_id, &key_id, is_object_id, is_unique, decl_parts);\n\n  dk_free_tree (list_to_array (to_free));\n  dk_free_box (parts_box);\n\n  ddl_key_options (qi, szTheTableName, key_id, opts);\n  if (is_unique)\n    ddl_key_opt (qi, szTheTableName, key_id);\n  ddl_table_changed (qi, szTheTableName);\n  tn = box_dv_short_string (table);\n  in = box_dv_short_string (name);\n  inx_opt_cluster (qi, tn, in, opts);\n  dk_free_box (tn);\n  dk_free_box (in);\n\n  {\n    dbe_table_t *tb = qi_name_to_table (qi, szTheTableName);\n    if (tb)\n      ddl_create_subtable_keys (qi, tb, name, key_id, key_id);\n  }\n  dk_free_box(szTheTableName);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,6 +18,8 @@\n   char *szTheTableName;\n   dk_set_t to_free = NULL;\n \n+  if (n_parts > K_MAX_PARTS)\n+    sqlr_new_error (\"42S12\", \"SQ017\", \"Too many key parts\");\n   memcpy (parts_tmp, parts, box_length ((caddr_t) parts));\n \n   qr_rec_exec (find_primary_stmt, cli, &lc_keys, qi, NULL, 1,",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if (n_parts > K_MAX_PARTS)",
                "    sqlr_new_error (\"42S12\", \"SQ017\", \"Too many key parts\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31610",
        "func_name": "openlink/virtuoso-opensource/sqlc_table_from_view",
        "description": "An issue in the _IO_default_xsputn component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/2ed10333e6e973c2b3e1e60ba854ef0dd12afe07",
        "commit_title": "Fixed missing arguments in table def (fixes #1118)",
        "commit_text": "",
        "func_before": "ST *\nsqlc_table_from_view (query_t * view_qr, ST * view_def)\n{\n  if (view_qr)\n    return (sqlc_table_from_select_view  (view_qr, view_def));\n  else\n    {\n/*GK: enable that if proc view params to participate in 'select *' */\n#if 0\n      caddr_t *col_defs;\n      int inx;\n      int n_cols = BOX_ELEMENTS (view_def->_.view_def.exp->_.proc_table.cols);\n\n      col_defs = (caddr_t *) t_alloc_box (\n\t  n_cols * sizeof (caddr_t) +\n\t  + 2 * box_length (view_def->_.view_def.exp->_.proc_table.params),\n\t  DV_ARRAY_OF_POINTER);\n\n      for (inx = 0; inx < n_cols; inx++)\n\tcol_defs[inx] = t_box_copy_tree ((caddr_t) view_def->_.view_def.exp->_.proc_table.cols[inx]);\n\n      DO_BOX (caddr_t, param, inx, view_def->_.view_def.exp->_.proc_table.params)\n\t{\n\t  col_defs [n_cols + inx * 2] = t_box_copy_tree (param);\n\t  /* GK : = ANY */\n\t  col_defs [n_cols + inx * 2 + 1] =\n\t      (caddr_t) t_list (2,\n\t\t  t_list (2, (long) DV_ANY, (long) 0),\n\t\t  NULL);\n\t}\n      END_DO_BOX;\n      return ((ST*) t_list (3, TABLE_DEF, t_box_copy_tree (view_def->_.view_def.name),\n\t\t    (caddr_t) col_defs));\n#else\n      return ((ST*) t_list (3, TABLE_DEF, t_box_copy_tree (view_def->_.view_def.name),\n\t\t    t_box_copy_tree ((caddr_t) view_def->_.view_def.exp->_.proc_table.cols)));\n#endif\n    }\n}",
        "func": "ST *\nsqlc_table_from_view (query_t * view_qr, ST * view_def)\n{\n  if (view_qr)\n    return (sqlc_table_from_select_view  (view_qr, view_def));\n  else\n    {\n/*GK: enable that if proc view params to participate in 'select *' */\n#if 0\n      caddr_t *col_defs;\n      int inx;\n      int n_cols = BOX_ELEMENTS (view_def->_.view_def.exp->_.proc_table.cols);\n\n      col_defs = (caddr_t *) t_alloc_box (\n\t  n_cols * sizeof (caddr_t) +\n\t  + 2 * box_length (view_def->_.view_def.exp->_.proc_table.params),\n\t  DV_ARRAY_OF_POINTER);\n\n      for (inx = 0; inx < n_cols; inx++)\n\tcol_defs[inx] = t_box_copy_tree ((caddr_t) view_def->_.view_def.exp->_.proc_table.cols[inx]);\n\n      DO_BOX (caddr_t, param, inx, view_def->_.view_def.exp->_.proc_table.params)\n\t{\n\t  col_defs [n_cols + inx * 2] = t_box_copy_tree (param);\n\t  /* GK : = ANY */\n\t  col_defs [n_cols + inx * 2 + 1] =\n\t      (caddr_t) t_list (2,\n\t\t  t_list (2, (long) DV_ANY, (long) 0),\n\t\t  NULL);\n\t}\n      END_DO_BOX;\n      return ((ST*) t_list (3, TABLE_DEF, t_box_copy_tree (view_def->_.view_def.name),\n\t\t    (caddr_t) col_defs));\n#else\n      return ((ST*) t_list (5, TABLE_DEF, t_box_copy_tree (view_def->_.view_def.name),\n\t\t    t_box_copy_tree ((caddr_t) view_def->_.view_def.exp->_.proc_table.cols), 0, 0));\n#endif\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,8 +32,8 @@\n       return ((ST*) t_list (3, TABLE_DEF, t_box_copy_tree (view_def->_.view_def.name),\n \t\t    (caddr_t) col_defs));\n #else\n-      return ((ST*) t_list (3, TABLE_DEF, t_box_copy_tree (view_def->_.view_def.name),\n-\t\t    t_box_copy_tree ((caddr_t) view_def->_.view_def.exp->_.proc_table.cols)));\n+      return ((ST*) t_list (5, TABLE_DEF, t_box_copy_tree (view_def->_.view_def.name),\n+\t\t    t_box_copy_tree ((caddr_t) view_def->_.view_def.exp->_.proc_table.cols), 0, 0));\n #endif\n     }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      return ((ST*) t_list (3, TABLE_DEF, t_box_copy_tree (view_def->_.view_def.name),",
                "\t\t    t_box_copy_tree ((caddr_t) view_def->_.view_def.exp->_.proc_table.cols)));"
            ],
            "added_lines": [
                "      return ((ST*) t_list (5, TABLE_DEF, t_box_copy_tree (view_def->_.view_def.name),",
                "\t\t    t_box_copy_tree ((caddr_t) view_def->_.view_def.exp->_.proc_table.cols), 0, 0));"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31610",
        "func_name": "openlink/virtuoso-opensource/sqlc_table_from_select_view",
        "description": "An issue in the _IO_default_xsputn component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/2ed10333e6e973c2b3e1e60ba854ef0dd12afe07",
        "commit_title": "Fixed missing arguments in table def (fixes #1118)",
        "commit_text": "",
        "func_before": "ST *\nsqlc_table_from_select_view (query_t * view_qr, ST * view_def)\n{\n  int inx;\n  /* make a create table with the view's out cols and data types */\n  state_slot_t **sel_out = view_qr->qr_select_node->sel_out_slots;\n  int n_out = BOX_ELEMENTS (sqlp_union_tree_select (view_def->_.view_def.exp)->_.select_stmt.selection);\n  /* length of select list, not out box cause out bpx may have co and extras */\n  dk_set_t cols = NULL;\n  dk_set_t key_parts = NULL;\n\n  DO_BOX (state_slot_t *, ssl, inx, sel_out)\n  {\n    dtp_t sl_dtp;\n    uint32 sl_prec;\n    char sl_scale;\n    int col_is_indexable;\n    if (inx >= n_out)\n      break;\t\t\t/* only as many as in selection */\n    if (SSL_REF == ssl->ssl_type)\n      ssl = ((state_slot_ref_t*)ssl)->sslr_ssl;\n    sl_dtp = ssl->ssl_dtp;\n    sl_prec = ssl->ssl_prec;\n    sl_scale = ssl->ssl_scale;\n\n    if (!sl_dtp || !dtp_is_column_compatible (sl_dtp))\n      {\n\tsl_dtp = DV_LONG_STRING;\n\tsl_prec = 0;\n\tsl_scale = 0;\n      }\n    col_is_indexable = !(\n      (DV_BLOB == sl_dtp) || (DV_BLOB_WIDE == sl_dtp) ||\n      (DV_BLOB_BIN == sl_dtp) || (DV_BLOB_XPER == sl_dtp) );\n    t_dk_set_append_1 (&cols, (void *) t_box_string (ssl->ssl_name));\n    t_dk_set_append_1 (&cols,\n\tt_list (2, t_list (3, t_box_num (sl_dtp),\n\t    t_box_num (sl_prec),\n\t    t_box_num (sl_scale)),\n\t    NULL));\n    if (col_is_indexable)\n      t_dk_set_append_1 (&key_parts, (void *) t_box_string (ssl->ssl_name));\n  }\n  END_DO_BOX;\n  t_dk_set_append_1 (&cols, NULL);\n  t_dk_set_append_1 (&cols,\n      t_list (5, INDEX_DEF, NULL, NULL, t_list_to_array (key_parts), NULL));\n\n  return ((ST *) t_list (3,\n      TABLE_DEF,\n      t_box_string (view_def->_.view_def.name),\n      t_list_to_array (cols)));\n}",
        "func": "ST *\nsqlc_table_from_select_view (query_t * view_qr, ST * view_def)\n{\n  int inx;\n  /* make a create table with the view's out cols and data types */\n  state_slot_t **sel_out = view_qr->qr_select_node->sel_out_slots;\n  int n_out = BOX_ELEMENTS (sqlp_union_tree_select (view_def->_.view_def.exp)->_.select_stmt.selection);\n  /* length of select list, not out box cause out bpx may have co and extras */\n  dk_set_t cols = NULL;\n  dk_set_t key_parts = NULL;\n\n  DO_BOX (state_slot_t *, ssl, inx, sel_out)\n  {\n    dtp_t sl_dtp;\n    uint32 sl_prec;\n    char sl_scale;\n    int col_is_indexable;\n    if (inx >= n_out)\n      break;\t\t\t/* only as many as in selection */\n    if (SSL_REF == ssl->ssl_type)\n      ssl = ((state_slot_ref_t*)ssl)->sslr_ssl;\n    sl_dtp = ssl->ssl_dtp;\n    sl_prec = ssl->ssl_prec;\n    sl_scale = ssl->ssl_scale;\n\n    if (!sl_dtp || !dtp_is_column_compatible (sl_dtp))\n      {\n\tsl_dtp = DV_LONG_STRING;\n\tsl_prec = 0;\n\tsl_scale = 0;\n      }\n    col_is_indexable = !(\n      (DV_BLOB == sl_dtp) || (DV_BLOB_WIDE == sl_dtp) ||\n      (DV_BLOB_BIN == sl_dtp) || (DV_BLOB_XPER == sl_dtp) );\n    t_dk_set_append_1 (&cols, (void *) t_box_string (ssl->ssl_name));\n    t_dk_set_append_1 (&cols,\n\tt_list (2, t_list (3, t_box_num (sl_dtp),\n\t    t_box_num (sl_prec),\n\t    t_box_num (sl_scale)),\n\t    NULL));\n    if (col_is_indexable)\n      t_dk_set_append_1 (&key_parts, (void *) t_box_string (ssl->ssl_name));\n  }\n  END_DO_BOX;\n  t_dk_set_append_1 (&cols, NULL);\n  t_dk_set_append_1 (&cols,\n      t_list (5, INDEX_DEF, NULL, NULL, t_list_to_array (key_parts), NULL));\n\n  return ((ST *) t_list (5,\n      TABLE_DEF,\n      t_box_string (view_def->_.view_def.name),\n      t_list_to_array (cols), 0, 0));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -46,8 +46,8 @@\n   t_dk_set_append_1 (&cols,\n       t_list (5, INDEX_DEF, NULL, NULL, t_list_to_array (key_parts), NULL));\n \n-  return ((ST *) t_list (3,\n+  return ((ST *) t_list (5,\n       TABLE_DEF,\n       t_box_string (view_def->_.view_def.name),\n-      t_list_to_array (cols)));\n+      t_list_to_array (cols), 0, 0));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  return ((ST *) t_list (3,",
                "      t_list_to_array (cols)));"
            ],
            "added_lines": [
                "  return ((ST *) t_list (5,",
                "      t_list_to_array (cols), 0, 0));"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31613",
        "func_name": "openlink/virtuoso-opensource/box_deserialize_reusing",
        "description": "An issue in the __nss_database_lookup component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/171718c844530864cb375213c8b9cbc8ba079efc",
        "commit_title": "Added missing reuse check for dv bin (fixes #1121)",
        "commit_text": "",
        "func_before": "caddr_t\nbox_deserialize_reusing (db_buf_t string, caddr_t box)\n{\n  boxint n;\n  iri_id_t iid;\n  int len, head_len;\n  dtp_t old_dtp;\n  if (!IS_BOX_POINTER (box))\n    return box_deserialize_string ((caddr_t) string, INT32_MAX, 0);\n  old_dtp = box_tag (box);\n  switch (string[0])\n    {\n    case DV_SINGLE_FLOAT:\n      if (DV_SINGLE_FLOAT == old_dtp)\n\t{\n\t  EXT_TO_FLOAT (box, string + 1);\n\t  return box;\n\t}\n      goto no_reuse;\n    case DV_DOUBLE_FLOAT:\n      if (DV_DOUBLE_FLOAT == old_dtp)\n\t{\n\t  EXT_TO_DOUBLE (box, string + 1);\n\t  return box;\n\t}\n      goto no_reuse;\n    case DV_SHORT_INT:\n      n = (signed char) string[1];\n      goto int_data;\n    case DV_LONG_INT:\n      n = LONG_REF_NA (string + 1);\n      goto int_data;\n    case DV_INT64:\n      n = INT64_REF_NA (string + 1);\n    int_data:\n      if (DV_LONG_INT != old_dtp)\n\t{\n\t  dk_free_tree (box);\n\t  return box_num (n);\n\t}\n      *(int64 *) box = n;\n      return box;\n    case DV_DB_NULL:\n      if (DV_DB_NULL == old_dtp)\n\treturn box;\n      else\n\t{\n\t  dk_free_tree (box);\n\t  return dk_alloc_box (0, DV_DB_NULL);\n\t}\n    case DV_IRI_ID:\n      iid = (unsigned int32) LONG_REF_NA (string + 1);\n      goto iri_data;\n    case DV_IRI_ID_8:\n      iid = INT64_REF_NA (string + 1);\n    iri_data:\n      if (DV_IRI_ID == old_dtp)\n\t{\n\t  *(iri_id_t *) box = iid;\n\t  return box;\n\t}\n      dk_free_tree (box);\n      return box_iri_id (iid);\n    case DV_RDF:\n    case DV_RDF_ID:\n    case DV_RDF_ID_8:\n\t{\n\t  rdf_box_t * x = (rdf_box_t *)box_deserialize_string ((caddr_t)string, INT32_MAX, 0);\n\t  if (old_dtp == DV_RDF && NULL != x && 0 != x->rb_ro_id && x->rb_ro_id == ((rdf_box_t *)box)->rb_ro_id)\n\t    {\n\t      dk_free_box (x);\n\t      return box;\n\t    }\n\t  dk_free_tree (box);\n\t  return (caddr_t) x;\n\t}\n    case DV_SHORT_STRING_SERIAL:\n      len = (unsigned char) string[1];\n      head_len = 2;\n      goto str_data;\n    case DV_LONG_STRING:\n      len = LONG_REF_NA (string + 1);\n      head_len = 5;\n    str_data:\n      if (DV_STRING == old_dtp && ALIGN_STR ((len + 1)) == ALIGN_STR (box_length (box)))\n\t{\n\t  box_reuse (box, (caddr_t) string + head_len, len + 1, DV_STRING);\n\t  box[len] = 0;\n\t  return box;\n\t}\n      goto no_reuse;\n    case DV_DATETIME:\n      if (DV_DATETIME == old_dtp)\n\t{\n\t  memcpy_dt (box, string + 1);\n\t  return box;\n\t}\n      goto no_reuse;\n    default:\n    no_reuse:\n      {\n\t/* read first so that there's no ref to freed if throw from read */\n\tcaddr_t x = box_deserialize_string ((caddr_t) string, INT32_MAX, 0);\n\tdk_free_tree (box);\n\treturn x;\n      }\n    }\n}",
        "func": "caddr_t\nbox_deserialize_reusing (db_buf_t string, caddr_t box)\n{\n  boxint n;\n  iri_id_t iid;\n  int len, head_len;\n  dtp_t old_dtp;\n  if (!IS_BOX_POINTER (box))\n    return box_deserialize_string ((caddr_t) string, INT32_MAX, 0);\n  old_dtp = box_tag (box);\n  switch (string[0])\n    {\n    case DV_SINGLE_FLOAT:\n      if (DV_SINGLE_FLOAT == old_dtp)\n\t{\n\t  EXT_TO_FLOAT (box, string + 1);\n\t  return box;\n\t}\n      goto no_reuse;\n    case DV_DOUBLE_FLOAT:\n      if (DV_DOUBLE_FLOAT == old_dtp)\n\t{\n\t  EXT_TO_DOUBLE (box, string + 1);\n\t  return box;\n\t}\n      goto no_reuse;\n    case DV_SHORT_INT:\n      n = (signed char) string[1];\n      goto int_data;\n    case DV_LONG_INT:\n      n = LONG_REF_NA (string + 1);\n      goto int_data;\n    case DV_INT64:\n      n = INT64_REF_NA (string + 1);\n    int_data:\n      if (DV_LONG_INT != old_dtp)\n\t{\n\t  dk_free_tree (box);\n\t  return box_num (n);\n\t}\n      *(int64 *) box = n;\n      return box;\n    case DV_DB_NULL:\n      if (DV_DB_NULL == old_dtp)\n\treturn box;\n      else\n\t{\n\t  dk_free_tree (box);\n\t  return dk_alloc_box (0, DV_DB_NULL);\n\t}\n    case DV_IRI_ID:\n      iid = (unsigned int32) LONG_REF_NA (string + 1);\n      goto iri_data;\n    case DV_IRI_ID_8:\n      iid = INT64_REF_NA (string + 1);\n    iri_data:\n      if (DV_IRI_ID == old_dtp)\n\t{\n\t  *(iri_id_t *) box = iid;\n\t  return box;\n\t}\n      dk_free_tree (box);\n      return box_iri_id (iid);\n    case DV_RDF:\n    case DV_RDF_ID:\n    case DV_RDF_ID_8:\n\t{\n\t  rdf_box_t * x = (rdf_box_t *)box_deserialize_string ((caddr_t)string, INT32_MAX, 0);\n\t  if (old_dtp == DV_RDF && NULL != x && 0 != x->rb_ro_id && x->rb_ro_id == ((rdf_box_t *)box)->rb_ro_id)\n\t    {\n\t      dk_free_box (x);\n\t      return box;\n\t    }\n\t  dk_free_tree (box);\n\t  return (caddr_t) x;\n\t}\n    case DV_SHORT_STRING_SERIAL:\n      len = (unsigned char) string[1];\n      head_len = 2;\n      goto str_data;\n    case DV_LONG_STRING:\n      len = LONG_REF_NA (string + 1);\n      head_len = 5;\n    str_data:\n      if (DV_STRING == old_dtp && ALIGN_STR ((len + 1)) == ALIGN_STR (box_length (box)))\n\t{\n\t  box_reuse (box, (caddr_t) string + head_len, len + 1, DV_STRING);\n\t  box[len] = 0;\n\t  return box;\n\t}\n      goto no_reuse;\n    case DV_BIN:\n      len = (unsigned char) string[1];\n      head_len = 2;\n      goto bin_data;\n    case DV_LONG_BIN:\n      len = LONG_REF_NA (string + 1);\n      head_len = 5;\n    bin_data:\n      if (DV_BIN == old_dtp && ALIGN_STR ((len)) == ALIGN_STR (box_length (box)))\n\t{\n\t  box_reuse (box, (caddr_t)string + head_len, len, DV_BIN);\n\t  return box;\n\t}\n      goto no_reuse;\n    case DV_DATETIME:\n      if (DV_DATETIME == old_dtp)\n\t{\n\t  memcpy_dt (box, string + 1);\n\t  return box;\n\t}\n      goto no_reuse;\n    default:\n    no_reuse:\n      {\n\t/* read first so that there's no ref to freed if throw from read */\n\tcaddr_t x = box_deserialize_string ((caddr_t) string, INT32_MAX, 0);\n\tdk_free_tree (box);\n\treturn x;\n      }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -89,6 +89,20 @@\n \t  return box;\n \t}\n       goto no_reuse;\n+    case DV_BIN:\n+      len = (unsigned char) string[1];\n+      head_len = 2;\n+      goto bin_data;\n+    case DV_LONG_BIN:\n+      len = LONG_REF_NA (string + 1);\n+      head_len = 5;\n+    bin_data:\n+      if (DV_BIN == old_dtp && ALIGN_STR ((len)) == ALIGN_STR (box_length (box)))\n+\t{\n+\t  box_reuse (box, (caddr_t)string + head_len, len, DV_BIN);\n+\t  return box;\n+\t}\n+      goto no_reuse;\n     case DV_DATETIME:\n       if (DV_DATETIME == old_dtp)\n \t{",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    case DV_BIN:",
                "      len = (unsigned char) string[1];",
                "      head_len = 2;",
                "      goto bin_data;",
                "    case DV_LONG_BIN:",
                "      len = LONG_REF_NA (string + 1);",
                "      head_len = 5;",
                "    bin_data:",
                "      if (DV_BIN == old_dtp && ALIGN_STR ((len)) == ALIGN_STR (box_length (box)))",
                "\t{",
                "\t  box_reuse (box, (caddr_t)string + head_len, len, DV_BIN);",
                "\t  return box;",
                "\t}",
                "      goto no_reuse;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31614",
        "func_name": "openlink/virtuoso-opensource/setp_chash_distinct",
        "description": "An issue in the mp_box_deserialize_string function in openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) after running a SELECT statement.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/7c488ae70803b208a94bf12fee792195caddbf7d",
        "commit_title": "Fixed compare only up to cha key parts (fixes #1117)",
        "commit_text": "",
        "func_before": "int\nsetp_chash_distinct (setp_node_t * setp, caddr_t * inst)\n{\n  index_tree_t *tree;\n  hash_area_t *ha = setp->setp_ha;\n  int inx, n_slots = BOX_ELEMENTS (ha->ha_slots);\n  data_col_t *sets = QST_BOX (data_col_t *, inst, setp->setp_ssa.ssa_set_no->ssl_index);\n  chash_t *cha = NULL;\n  QNCAST (query_instance_t, qi, inst);\n\n  if (!enable_chash_distinct || (!cluster_enable && !setp->setp_set_no_in_key && 1 != sets->dc_n_values))\n    return 0;\n  qi->qi_set = 0;\n  tree = qst_tree (inst, ha->ha_tree, setp->setp_ssa.ssa_set_no);\n  if (tree)\n    {\n      cha = tree->it_hi->hi_chash;\n      if (!cha)\n\treturn 0;\n    }\n  if (cha && cha->cha_oversized)\n    goto no;\n  if (ha->ha_n_keys >= CHASH_GB_MAX_KEYS)\n    goto no;\n  for (inx = 0; inx < n_slots; inx++)\n    {\n      state_slot_t *ssl = ha->ha_slots[inx];\n      data_col_t *dc;\n      if (SSL_CONSTANT == ssl->ssl_type)\n\t{\n\t  if (inx < ha->ha_n_keys)\n\t    goto no;\n\t  continue;\n\t}\n      if (ssl->ssl_type < SSL_VEC)\n\tgoto no;\n      dc = QST_BOX (data_col_t *, inst, ssl->ssl_index);\n      if (cha && dc->dc_dtp != cha->cha_sqt[inx].sqt_dtp && !((DCT_BOXES & dc->dc_type) && DV_ANY == cha->cha_sqt[inx].sqt_dtp))\n\tgoto no;\n    }\n  if (!cha)\n    {\n      tree = cha_allocate (setp, inst, 0);\n      cha = tree->it_hi->hi_chash;\n    }\n  setp_chash_distinct_run (setp, inst, tree);\n  if (cha->cha_pool->mp_bytes > cha_max_gb_bytes && (cha->cha_pool->mp_bytes + mp_large_in_use) > c_max_large_vec)\n    cha->cha_oversized = 1;\n  return 1;\nno:\n  if (cha)\n    chash_to_memcache (inst, tree, ha);\n  return 0;\n}",
        "func": "int\nsetp_chash_distinct (setp_node_t * setp, caddr_t * inst)\n{\n  index_tree_t *tree;\n  hash_area_t *ha = setp->setp_ha;\n  int inx, n_slots = BOX_ELEMENTS (ha->ha_slots);\n  data_col_t *sets = QST_BOX (data_col_t *, inst, setp->setp_ssa.ssa_set_no->ssl_index);\n  chash_t *cha = NULL;\n  QNCAST (query_instance_t, qi, inst);\n\n  if (!enable_chash_distinct || (!cluster_enable && !setp->setp_set_no_in_key && 1 != sets->dc_n_values))\n    return 0;\n  qi->qi_set = 0;\n  tree = qst_tree (inst, ha->ha_tree, setp->setp_ssa.ssa_set_no);\n  if (tree)\n    {\n      cha = tree->it_hi->hi_chash;\n      if (!cha)\n\treturn 0;\n    }\n  if (cha && cha->cha_oversized)\n    goto no;\n  if (ha->ha_n_keys >= CHASH_GB_MAX_KEYS)\n    goto no;\n  for (inx = 0; inx < n_slots; inx++)\n    {\n      state_slot_t *ssl = ha->ha_slots[inx];\n      data_col_t *dc;\n      if (SSL_CONSTANT == ssl->ssl_type)\n\t{\n\t  if (inx < ha->ha_n_keys)\n\t    goto no;\n\t  continue;\n\t}\n      if (ssl->ssl_type < SSL_VEC)\n\tgoto no;\n      dc = QST_BOX (data_col_t *, inst, ssl->ssl_index);\n      if (cha && inx < cha->cha_n_keys && dc->dc_dtp != cha->cha_sqt[inx].sqt_dtp\n\t  && !((DCT_BOXES & dc->dc_type) && DV_ANY == cha->cha_sqt[inx].sqt_dtp))\n\tgoto no;\n    }\n  if (!cha)\n    {\n      tree = cha_allocate (setp, inst, 0);\n      cha = tree->it_hi->hi_chash;\n    }\n  setp_chash_distinct_run (setp, inst, tree);\n  if (cha->cha_pool->mp_bytes > cha_max_gb_bytes && (cha->cha_pool->mp_bytes + mp_large_in_use) > c_max_large_vec)\n    cha->cha_oversized = 1;\n  return 1;\nno:\n  if (cha)\n    chash_to_memcache (inst, tree, ha);\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,7 +35,8 @@\n       if (ssl->ssl_type < SSL_VEC)\n \tgoto no;\n       dc = QST_BOX (data_col_t *, inst, ssl->ssl_index);\n-      if (cha && dc->dc_dtp != cha->cha_sqt[inx].sqt_dtp && !((DCT_BOXES & dc->dc_type) && DV_ANY == cha->cha_sqt[inx].sqt_dtp))\n+      if (cha && inx < cha->cha_n_keys && dc->dc_dtp != cha->cha_sqt[inx].sqt_dtp\n+\t  && !((DCT_BOXES & dc->dc_type) && DV_ANY == cha->cha_sqt[inx].sqt_dtp))\n \tgoto no;\n     }\n   if (!cha)",
        "diff_line_info": {
            "deleted_lines": [
                "      if (cha && dc->dc_dtp != cha->cha_sqt[inx].sqt_dtp && !((DCT_BOXES & dc->dc_type) && DV_ANY == cha->cha_sqt[inx].sqt_dtp))"
            ],
            "added_lines": [
                "      if (cha && inx < cha->cha_n_keys && dc->dc_dtp != cha->cha_sqt[inx].sqt_dtp",
                "\t  && !((DCT_BOXES & dc->dc_type) && DV_ANY == cha->cha_sqt[inx].sqt_dtp))"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31615",
        "func_name": "openlink/virtuoso-opensource/sqlg_hash_source",
        "description": "An issue in the chash_array component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/d02925b18e3ad0244ae7c52acf92bfa686738eb2",
        "commit_title": "Fixed do not change col_dtp if already set before (fixes #1124)",
        "commit_text": "",
        "func_before": "data_source_t *\nsqlg_hash_source (sqlo_t * so, df_elt_t * tb_dfe, dk_set_t * pre_code)\n{\n  hash_area_t * ha_copy = (hash_area_t *) dk_alloc (sizeof (hash_area_t));\n  char ref_name[MAX_QUAL_NAME_LEN];\n  sql_comp_t * sc = so->so_sc;\n  int inx = 0;\n  dk_set_t col_refs = NULL;\n  dk_set_t ref_slots = NULL, out_slots = NULL;\n  int is_fill_dt = DFE_DT == tb_dfe->_.table.hash_filler->dfe_type;\n  op_table_t * ot = tb_dfe->_.table.ot;\n  setp_node_t * setp = ot->ot_hash_filler;\n  hash_area_t * ha = setp->setp_ha;\n  SQL_NODE_INIT (hash_source_t, hs, hash_source_input, hash_source_free);\n  hs->hs_cardinality = tb_dfe->dfe_arity;\n  hs->hs_filler = setp->setp_fref;\n  hs->hs_part_min = hs->hs_filler->fnr_hash_part_min;\n  hs->hs_part_max = hs->hs_filler->fnr_hash_part_max;\n  hs->hs_no_partition = dfe_is_in_hash_filler (tb_dfe);\n  hs->hs_cl_part_opt = sqlo_opt_value (ot->ot_opts, OPT_HASH_REPLICATION) ? HS_CL_REPLICATED \n    : sqlo_opt_value (ot->ot_opts, OPT_HASH_PARTITION) ? HS_CL_PART : 0;\n  hs->clb.clb_fill = cc_new_instance_slot (so->so_sc->sc_cc);\n  hs->hs_current_inx = cc_new_instance_slot (so->so_sc->sc_cc);\n  hs->hs_saved_hmk = cc_new_instance_slot (so->so_sc->sc_cc);\n  hs->hs_is_unique = tb_dfe->_.table.is_unique;\n  DO_SET (df_elt_t *, ref, &tb_dfe->_.table.hash_refs)\n    {\n      state_slot_t * ssl = scalar_exp_generate (so->so_sc,  ref->dfe_tree, pre_code);\n      if (ssl->ssl_type == SSL_CONSTANT)\n\t{\n\t  state_slot_t *ssl1 = ssl_new_variable (sc->sc_cc, \"\", DV_UNKNOWN);\n\t  ssl_copy_types (ssl1, ssl);\n\t  cv_artm (pre_code, (ao_func_t) box_identity, ssl1, ssl, NULL);\n\t  ssl = ssl1;\n\t}\n      dk_set_push (&ref_slots, (void*) ssl);\n    }\n  END_DO_SET();\n  ref_slots = dk_set_nreverse (ref_slots);\n  memcpy (ha_copy, ha, sizeof (hash_area_t));\n  ha_copy->ha_slots = (state_slot_t **) dk_set_to_array (ref_slots);\n  ha_copy->ha_non_null = box_copy (ha->ha_non_null);\n  ha_copy->ha_key_cols = (dbe_col_loc_t *) box_copy ((caddr_t) ha->ha_key_cols);\n  ha_copy->ha_cols = NULL;\n  hs->hs_ref_slots = (state_slot_t **) list_to_array (ref_slots);\n  hs->hs_ha = ha_copy;\n  if (enable_chash_join)\n    {\n      /* if selecting a col that is a key of the hash, alias the out col to the input col.  But not if outer join.  OK if inside outer dt cause out slots are then copies at end of dt */\n      DO_SET (df_elt_t *, out, &tb_dfe->_.table.out_cols)\n\t{\n\t  state_slot_t * ssl = sqlg_dfe_ssl (so, out);\n\t  dbe_col_loc_t cl;\n\t  ptrlong nth;\n\t  if (is_fill_dt)\n\t    {\n\t      snprintf (ref_name, sizeof (ref_name), \"%s.%s\", out->dfe_tree->_.col_ref.prefix, out->dfe_tree->_.col_ref.name);\n\t      setp_ha_find_col_ref (setp, ref_name, &cl, &nth);\n\t    }\n\t  else\n\t    setp_ha_find_col (setp, out->_.col.col, &cl, &nth);\n\t  if (nth < ha->ha_n_keys)\n\t    {\n\t      if (!tb_dfe->_.table.ot->ot_is_outer /* ssl->ssl_sqt.sqt_dtp != hs->hs_ref_slots[nth]->ssl_sqt.sqt_dtp */)\n\t\t{\n\t\t  cv_artm (pre_code, (ao_func_t) box_identity, ssl, hs->hs_ref_slots[nth], NULL);\n\t\t  if (DV_ANY == ssl->ssl_sqt.sqt_dtp)\n\t\t    ssl->ssl_sqt.sqt_col_dtp = DV_ANY;\n\t\t}\n\t      else\n\t\t{\n\t\t  hs->hs_ref_slots[nth]->ssl_sqt.sqt_col_dtp = ssl->ssl_sqt.sqt_col_dtp; /* hash filler col must have this set */\n\t\t  if (!tb_dfe->_.table.ot->ot_is_outer)\n\t    ssl_alias (ssl, hs->hs_ref_slots[nth]);\n\t  else\n\t\t    {\n\t\t      t_set_push (&hs->hs_out_aliases, (void*)ssl);\n\t\t      t_set_push (&hs->hs_out_aliases, (void*)(ptrlong)nth);\n\t\t    }\n\t\t}\n\t    }\n\t  else\n\t    box_set_nth ((caddr_t**)&hs->hs_out_slots, nth - ha->ha_n_keys, (caddr_t)ssl);\n\t}\n      END_DO_SET();\n    }\n  else\n    {\n  hs->hs_out_cols = (dbe_col_loc_t *) dk_alloc (sizeof (dbe_col_loc_t) * (1 + dk_set_length (tb_dfe->_.table.out_cols)));\n  hs->hs_out_cols_indexes = (ptrlong *) dk_alloc (sizeof (ptrlong) * (1 + dk_set_length (tb_dfe->_.table.out_cols)));\n\n  DO_SET (df_elt_t *, out, &tb_dfe->_.table.out_cols)\n    {\n      state_slot_t * ssl = sqlg_dfe_ssl (so, out);\n      dk_set_push (&out_slots, (void*) ssl);\n\t  dk_set_push (&col_refs, col_ref_func (ha->ha_key, out->_.col.col, ssl));\n\t  if (is_fill_dt)\n\t    {\n\t      snprintf (ref_name, sizeof (ref_name), \"%s.%s\", out->dfe_tree->_.col_ref.prefix, out->dfe_tree->_.col_ref.name);\n\t      setp_ha_find_col_ref (setp, ref_name, hs->hs_out_cols+inx, hs->hs_out_cols_indexes+inx);\n\t    }\n\t  else\n      setp_ha_find_col (setp, out->_.col.col, hs->hs_out_cols+inx, hs->hs_out_cols_indexes+inx);\n      inx++;\n    }\n  END_DO_SET();\n  hs->hs_out_cols[inx].cl_col_id = 0;\n  hs->hs_out_cols_indexes[inx] = -1;\n  hs->hs_out_slots = (state_slot_t **) list_to_array (dk_set_nreverse (out_slots));\n      hs->hs_col_ref = (col_ref_t*)list_to_array (dk_set_nreverse (col_refs));\n    }\n  hs->src_gen.src_after_test = sqlg_pred_body (so, tb_dfe->_.table.join_test);\n  hs->hs_is_outer = tb_dfe->_.table.ot->ot_is_outer;\n  hs->hs_after_join_test = sqlg_pred_body (so, tb_dfe->_.table.after_join_test);\n  return ((data_source_t*) hs);\n}",
        "func": "data_source_t *\nsqlg_hash_source (sqlo_t * so, df_elt_t * tb_dfe, dk_set_t * pre_code)\n{\n  hash_area_t * ha_copy = (hash_area_t *) dk_alloc (sizeof (hash_area_t));\n  char ref_name[MAX_QUAL_NAME_LEN];\n  sql_comp_t * sc = so->so_sc;\n  int inx = 0;\n  dk_set_t col_refs = NULL;\n  dk_set_t ref_slots = NULL, out_slots = NULL;\n  int is_fill_dt = DFE_DT == tb_dfe->_.table.hash_filler->dfe_type;\n  op_table_t * ot = tb_dfe->_.table.ot;\n  setp_node_t * setp = ot->ot_hash_filler;\n  hash_area_t * ha = setp->setp_ha;\n  SQL_NODE_INIT (hash_source_t, hs, hash_source_input, hash_source_free);\n  hs->hs_cardinality = tb_dfe->dfe_arity;\n  hs->hs_filler = setp->setp_fref;\n  hs->hs_part_min = hs->hs_filler->fnr_hash_part_min;\n  hs->hs_part_max = hs->hs_filler->fnr_hash_part_max;\n  hs->hs_no_partition = dfe_is_in_hash_filler (tb_dfe);\n  hs->hs_cl_part_opt = sqlo_opt_value (ot->ot_opts, OPT_HASH_REPLICATION) ? HS_CL_REPLICATED \n    : sqlo_opt_value (ot->ot_opts, OPT_HASH_PARTITION) ? HS_CL_PART : 0;\n  hs->clb.clb_fill = cc_new_instance_slot (so->so_sc->sc_cc);\n  hs->hs_current_inx = cc_new_instance_slot (so->so_sc->sc_cc);\n  hs->hs_saved_hmk = cc_new_instance_slot (so->so_sc->sc_cc);\n  hs->hs_is_unique = tb_dfe->_.table.is_unique;\n  DO_SET (df_elt_t *, ref, &tb_dfe->_.table.hash_refs)\n    {\n      state_slot_t * ssl = scalar_exp_generate (so->so_sc,  ref->dfe_tree, pre_code);\n      if (ssl->ssl_type == SSL_CONSTANT)\n\t{\n\t  state_slot_t *ssl1 = ssl_new_variable (sc->sc_cc, \"\", DV_UNKNOWN);\n\t  ssl_copy_types (ssl1, ssl);\n\t  cv_artm (pre_code, (ao_func_t) box_identity, ssl1, ssl, NULL);\n\t  ssl = ssl1;\n\t}\n      dk_set_push (&ref_slots, (void*) ssl);\n    }\n  END_DO_SET();\n  ref_slots = dk_set_nreverse (ref_slots);\n  memcpy (ha_copy, ha, sizeof (hash_area_t));\n  ha_copy->ha_slots = (state_slot_t **) dk_set_to_array (ref_slots);\n  ha_copy->ha_non_null = box_copy (ha->ha_non_null);\n  ha_copy->ha_key_cols = (dbe_col_loc_t *) box_copy ((caddr_t) ha->ha_key_cols);\n  ha_copy->ha_cols = NULL;\n  hs->hs_ref_slots = (state_slot_t **) list_to_array (ref_slots);\n  hs->hs_ha = ha_copy;\n  if (enable_chash_join)\n    {\n      /* if selecting a col that is a key of the hash, alias the out col to the input col.  But not if outer join.  OK if inside outer dt cause out slots are then copies at end of dt */\n      DO_SET (df_elt_t *, out, &tb_dfe->_.table.out_cols)\n\t{\n\t  state_slot_t * ssl = sqlg_dfe_ssl (so, out);\n\t  dbe_col_loc_t cl;\n\t  ptrlong nth;\n\t  if (is_fill_dt)\n\t    {\n\t      snprintf (ref_name, sizeof (ref_name), \"%s.%s\", out->dfe_tree->_.col_ref.prefix, out->dfe_tree->_.col_ref.name);\n\t      setp_ha_find_col_ref (setp, ref_name, &cl, &nth);\n\t    }\n\t  else\n\t    setp_ha_find_col (setp, out->_.col.col, &cl, &nth);\n\t  if (nth < ha->ha_n_keys)\n\t    {\n\t      if (!tb_dfe->_.table.ot->ot_is_outer /* ssl->ssl_sqt.sqt_dtp != hs->hs_ref_slots[nth]->ssl_sqt.sqt_dtp */)\n\t\t{\n\t\t  cv_artm (pre_code, (ao_func_t) box_identity, ssl, hs->hs_ref_slots[nth], NULL);\n\t\t  if (DV_ANY == ssl->ssl_sqt.sqt_dtp)\n\t\t    ssl->ssl_sqt.sqt_col_dtp = DV_ANY;\n\t\t}\n\t      else\n\t\t{\n                  if (NULL == hs->hs_ref_slots[nth]->ssl_column) /* if there is a col col_dtp is set already and dc fill fn for it, do next otherwise */\n                    hs->hs_ref_slots[nth]->ssl_sqt.sqt_col_dtp = ssl->ssl_sqt.sqt_col_dtp; /* hash filler col must have this set */\n\t\t  if (!tb_dfe->_.table.ot->ot_is_outer)\n\t    ssl_alias (ssl, hs->hs_ref_slots[nth]);\n\t  else\n\t\t    {\n\t\t      t_set_push (&hs->hs_out_aliases, (void*)ssl);\n\t\t      t_set_push (&hs->hs_out_aliases, (void*)(ptrlong)nth);\n\t\t    }\n\t\t}\n\t    }\n\t  else\n\t    box_set_nth ((caddr_t**)&hs->hs_out_slots, nth - ha->ha_n_keys, (caddr_t)ssl);\n\t}\n      END_DO_SET();\n    }\n  else\n    {\n  hs->hs_out_cols = (dbe_col_loc_t *) dk_alloc (sizeof (dbe_col_loc_t) * (1 + dk_set_length (tb_dfe->_.table.out_cols)));\n  hs->hs_out_cols_indexes = (ptrlong *) dk_alloc (sizeof (ptrlong) * (1 + dk_set_length (tb_dfe->_.table.out_cols)));\n\n  DO_SET (df_elt_t *, out, &tb_dfe->_.table.out_cols)\n    {\n      state_slot_t * ssl = sqlg_dfe_ssl (so, out);\n      dk_set_push (&out_slots, (void*) ssl);\n\t  dk_set_push (&col_refs, col_ref_func (ha->ha_key, out->_.col.col, ssl));\n\t  if (is_fill_dt)\n\t    {\n\t      snprintf (ref_name, sizeof (ref_name), \"%s.%s\", out->dfe_tree->_.col_ref.prefix, out->dfe_tree->_.col_ref.name);\n\t      setp_ha_find_col_ref (setp, ref_name, hs->hs_out_cols+inx, hs->hs_out_cols_indexes+inx);\n\t    }\n\t  else\n      setp_ha_find_col (setp, out->_.col.col, hs->hs_out_cols+inx, hs->hs_out_cols_indexes+inx);\n      inx++;\n    }\n  END_DO_SET();\n  hs->hs_out_cols[inx].cl_col_id = 0;\n  hs->hs_out_cols_indexes[inx] = -1;\n  hs->hs_out_slots = (state_slot_t **) list_to_array (dk_set_nreverse (out_slots));\n      hs->hs_col_ref = (col_ref_t*)list_to_array (dk_set_nreverse (col_refs));\n    }\n  hs->src_gen.src_after_test = sqlg_pred_body (so, tb_dfe->_.table.join_test);\n  hs->hs_is_outer = tb_dfe->_.table.ot->ot_is_outer;\n  hs->hs_after_join_test = sqlg_pred_body (so, tb_dfe->_.table.after_join_test);\n  return ((data_source_t*) hs);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -69,7 +69,8 @@\n \t\t}\n \t      else\n \t\t{\n-\t\t  hs->hs_ref_slots[nth]->ssl_sqt.sqt_col_dtp = ssl->ssl_sqt.sqt_col_dtp; /* hash filler col must have this set */\n+                  if (NULL == hs->hs_ref_slots[nth]->ssl_column) /* if there is a col col_dtp is set already and dc fill fn for it, do next otherwise */\n+                    hs->hs_ref_slots[nth]->ssl_sqt.sqt_col_dtp = ssl->ssl_sqt.sqt_col_dtp; /* hash filler col must have this set */\n \t\t  if (!tb_dfe->_.table.ot->ot_is_outer)\n \t    ssl_alias (ssl, hs->hs_ref_slots[nth]);\n \t  else",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t  hs->hs_ref_slots[nth]->ssl_sqt.sqt_col_dtp = ssl->ssl_sqt.sqt_col_dtp; /* hash filler col must have this set */"
            ],
            "added_lines": [
                "                  if (NULL == hs->hs_ref_slots[nth]->ssl_column) /* if there is a col col_dtp is set already and dc fill fn for it, do next otherwise */",
                "                    hs->hs_ref_slots[nth]->ssl_sqt.sqt_col_dtp = ssl->ssl_sqt.sqt_col_dtp; /* hash filler col must have this set */"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31616",
        "func_name": "openlink/virtuoso-opensource/bif_mod",
        "description": "An issue in the bif_mod component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/25fff0eaa85898004bb14909e9f29d16b2918792",
        "commit_title": "Fixed 64bit arith exception (fixes #1122)",
        "commit_text": "",
        "func_before": "caddr_t\nbif_mod (caddr_t * qst, caddr_t * err_ret, state_slot_t ** args)\n{\n  int isnull1 = 0, isnull2 = 0;\n  int64 long1 = bif_long_or_null_arg (qst, args, 0, \"mod\", &isnull1);\n  int64 long2 = bif_long_or_null_arg (qst, args, 1, \"mod\", &isnull2);\n\n  if (isnull1 || isnull2)\n    return (NEW_DB_NULL);\n  if (0 == long2)\n  {\n    sqlr_new_error (\"22012\", \"SR046\", \"Division by zero in mod(\" BOXINT_FMT \",\" BOXINT_FMT \")\",\n      (boxint)long1, (boxint)long2);\n  }\n\n  return (box_num (long1 % long2));\n}",
        "func": "caddr_t\nbif_mod (caddr_t * qst, caddr_t * err_ret, state_slot_t ** args)\n{\n  int isnull1 = 0, isnull2 = 0;\n  int64 long1 = bif_long_or_null_arg (qst, args, 0, \"mod\", &isnull1);\n  int64 long2 = bif_long_or_null_arg (qst, args, 1, \"mod\", &isnull2);\n\n  if (isnull1 || isnull2)\n    return (NEW_DB_NULL);\n  if (0 == long2)\n  {\n    sqlr_new_error (\"22012\", \"SR046\", \"Division by zero in mod(\" BOXINT_FMT \",\" BOXINT_FMT \")\",\n      (boxint)long1, (boxint)long2);\n  }\n  if (long1 <= INT64_MIN)\n    sqlr_new_error (\"22012\", \"SR046\", \"Out of range in mod(\" BOXINT_FMT \",\" BOXINT_FMT \")\",\n      (boxint)long1, (boxint)long2);\n\n  return (box_num (long1 % long2));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,9 @@\n     sqlr_new_error (\"22012\", \"SR046\", \"Division by zero in mod(\" BOXINT_FMT \",\" BOXINT_FMT \")\",\n       (boxint)long1, (boxint)long2);\n   }\n+  if (long1 <= INT64_MIN)\n+    sqlr_new_error (\"22012\", \"SR046\", \"Out of range in mod(\" BOXINT_FMT \",\" BOXINT_FMT \")\",\n+      (boxint)long1, (boxint)long2);\n \n   return (box_num (long1 % long2));\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if (long1 <= INT64_MIN)",
                "    sqlr_new_error (\"22012\", \"SR046\", \"Out of range in mod(\" BOXINT_FMT \",\" BOXINT_FMT \")\",",
                "      (boxint)long1, (boxint)long2);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31617",
        "func_name": "openlink/virtuoso-opensource/sqlg_simple_fun_ref",
        "description": "An issue in the dk_set_delete component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/2b64ad928ef5f75fc93091677a78abfbd17ea07f",
        "commit_title": "Fixed save/restore temp refs (fixes #1127)",
        "commit_text": "",
        "func_before": "void\nsqlg_simple_fun_ref (sqlo_t * so, data_source_t ** head, df_elt_t * tb_dfe, dk_set_t cum_code)\n{\n  dpipe_node_t * dp = NULL;\n  dk_set_t post_fref_code = NULL;\n\n  sql_comp_t * sc = so->so_sc;\n  op_table_t * ot = tb_dfe->_.sub.ot;\n\n  sc->sc_fun_ref_temps = NULL;\n  sc->sc_fun_ref_defaults = NULL;\n  sc->sc_fun_ref_default_ssls = NULL;\n\n  {\n    data_source_t * last = sql_node_last (*head);\n    SQL_NODE_INIT (fun_ref_node_t, fref, fun_ref_node_input, fun_ref_free);\n    sc->sc_fref = fref;\n    DO_SET (ST *, fref, &ot->ot_fun_refs)\n      {\n\tint ign;\n\tstate_slot_t * ssl = select_ref_generate (sc, fref, &post_fref_code, &cum_code, &ign);\n\tdf_elt_t * fref_dfe = sqlo_df (so, fref);\n\tfref_dfe->dfe_ssl = ssl;\n      }\n    END_DO_SET();\n    dp = sqlg_pre_code_dpipe (so, &cum_code, NULL);\n    if (dp)\n      {\n\tlast->src_continuations = dk_set_cons ((void*)dp, NULL);\n\tdp->src_gen.src_after_code = code_to_cv (so->so_sc, cum_code);\n\tdk_set_delete (&last->src_query->qr_nodes, (void*)dp);\n\tdk_set_ins_before (&last->src_query->qr_nodes, (void*)last, (void*)dp);\n      }\n    else\n      {\n\tlast->src_after_code = code_to_cv (so->so_sc, cum_code);\n      }\n    fref->src_gen.src_after_code = code_to_cv (sc, post_fref_code);\n    fref->fnr_default_values = dk_set_nreverse (sc->sc_fun_ref_defaults);\n    fref->fnr_default_ssls = dk_set_nreverse (sc->sc_fun_ref_default_ssls);\n    fref->fnr_temp_slots = sc->sc_fun_ref_temps;\n    sqlg_place_fref (sc, head, fref, tb_dfe);\n  }\n}",
        "func": "void\nsqlg_simple_fun_ref (sqlo_t * so, data_source_t ** head, df_elt_t * tb_dfe, dk_set_t cum_code)\n{\n  dpipe_node_t * dp = NULL;\n  dk_set_t post_fref_code = NULL;\n\n  sql_comp_t * sc = so->so_sc;\n  op_table_t * ot = tb_dfe->_.sub.ot;\n  dk_set_t temp_save = sc->sc_fun_ref_temps;\n  dk_set_t def_save = sc->sc_fun_ref_defaults;\n  dk_set_t def_ssls = sc->sc_fun_ref_default_ssls;\n\n  sc->sc_fun_ref_temps = NULL;\n  sc->sc_fun_ref_defaults = NULL;\n  sc->sc_fun_ref_default_ssls = NULL;\n\n  {\n    data_source_t * last = sql_node_last (*head);\n    SQL_NODE_INIT (fun_ref_node_t, fref, fun_ref_node_input, fun_ref_free);\n    sc->sc_fref = fref;\n    DO_SET (ST *, fref, &ot->ot_fun_refs)\n      {\n\tint ign;\n\tstate_slot_t * ssl = select_ref_generate (sc, fref, &post_fref_code, &cum_code, &ign);\n\tdf_elt_t * fref_dfe = sqlo_df (so, fref);\n\tfref_dfe->dfe_ssl = ssl;\n      }\n    END_DO_SET();\n    dp = sqlg_pre_code_dpipe (so, &cum_code, NULL);\n    if (dp)\n      {\n\tlast->src_continuations = dk_set_cons ((void*)dp, NULL);\n\tdp->src_gen.src_after_code = code_to_cv (so->so_sc, cum_code);\n\tdk_set_delete (&last->src_query->qr_nodes, (void*)dp);\n\tdk_set_ins_before (&last->src_query->qr_nodes, (void*)last, (void*)dp);\n      }\n    else\n      {\n\tlast->src_after_code = code_to_cv (so->so_sc, cum_code);\n      }\n    fref->src_gen.src_after_code = code_to_cv (sc, post_fref_code);\n    fref->fnr_default_values = dk_set_nreverse (sc->sc_fun_ref_defaults);\n    sc->sc_fun_ref_defaults = def_save;\n    fref->fnr_default_ssls = dk_set_nreverse (sc->sc_fun_ref_default_ssls);\n    sc->sc_fun_ref_default_ssls = def_ssls;\n    fref->fnr_temp_slots = sc->sc_fun_ref_temps;\n    sc->sc_fun_ref_temps = temp_save;\n    sqlg_place_fref (sc, head, fref, tb_dfe);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,9 @@\n \n   sql_comp_t * sc = so->so_sc;\n   op_table_t * ot = tb_dfe->_.sub.ot;\n+  dk_set_t temp_save = sc->sc_fun_ref_temps;\n+  dk_set_t def_save = sc->sc_fun_ref_defaults;\n+  dk_set_t def_ssls = sc->sc_fun_ref_default_ssls;\n \n   sc->sc_fun_ref_temps = NULL;\n   sc->sc_fun_ref_defaults = NULL;\n@@ -37,8 +40,11 @@\n       }\n     fref->src_gen.src_after_code = code_to_cv (sc, post_fref_code);\n     fref->fnr_default_values = dk_set_nreverse (sc->sc_fun_ref_defaults);\n+    sc->sc_fun_ref_defaults = def_save;\n     fref->fnr_default_ssls = dk_set_nreverse (sc->sc_fun_ref_default_ssls);\n+    sc->sc_fun_ref_default_ssls = def_ssls;\n     fref->fnr_temp_slots = sc->sc_fun_ref_temps;\n+    sc->sc_fun_ref_temps = temp_save;\n     sqlg_place_fref (sc, head, fref, tb_dfe);\n   }\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  dk_set_t temp_save = sc->sc_fun_ref_temps;",
                "  dk_set_t def_save = sc->sc_fun_ref_defaults;",
                "  dk_set_t def_ssls = sc->sc_fun_ref_default_ssls;",
                "    sc->sc_fun_ref_defaults = def_save;",
                "    sc->sc_fun_ref_default_ssls = def_ssls;",
                "    sc->sc_fun_ref_temps = temp_save;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31618",
        "func_name": "openlink/virtuoso-opensource/sqlc_union_dt_wrap",
        "description": "An issue in the sqlc_union_dt_wrap component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/030e47a29976709a50603e3f34e82278e5f462df",
        "commit_title": "Fixed non-terminal in union branch is not supported (fixes #1136)",
        "commit_text": "",
        "func_before": "ST *\nsqlc_union_dt_wrap (ST * tree)\n{\n  ST * left = sqlp_union_tree_select (tree);\n  ST * right = sqlp_union_tree_right (tree);\n  if (left != right)\n    {\n      ST * texp, * sel;\n      ST ** order =right->_.select_stmt.table_exp->_.table_exp.order_by;\n      ptrlong flags = right->_.select_stmt.table_exp->_.table_exp.flags;\n      caddr_t * opts = right->_.select_stmt.table_exp->_.table_exp.opts;\n      right->_.select_stmt.table_exp->_.table_exp.order_by = NULL;\n      right->_.select_stmt.table_exp->_.table_exp.opts = NULL;\n      texp = sqlp_infoschema_redirect (t_listst (9,\n\t    TABLE_EXP, t_list (1, t_list (3, DERIVED_TABLE, tree, t_box_string (\"__\"))),\n\t\t   NULL, NULL, NULL, order, flags,opts, NULL));\n      sel = (ST*) t_list (5, SELECT_STMT, NULL, sqlc_selection_names (left), NULL,\n\t\t\ttexp);\n      return sel;\n    }\n  else\n    return tree;\n}",
        "func": "ST *\nsqlc_union_dt_wrap (sql_comp_t * sc, ST * tree)\n{\n  ST * left = sqlp_union_tree_select (tree);\n  ST * right = sqlp_union_tree_right (tree);\n  ST * rtb_exp = right->_.select_stmt.table_exp;\n  if (!rtb_exp)\n     sqlc_new_error (sc->sc_cc, \"42S22\", \"SQ098\", \"Non-terminal query expression cannot be used in union.\");\n  if (left != right)\n    {\n      ST * texp, * sel;\n      ST ** order = right->_.select_stmt.table_exp->_.table_exp.order_by;\n      ptrlong flags = right->_.select_stmt.table_exp->_.table_exp.flags;\n      caddr_t * opts = right->_.select_stmt.table_exp->_.table_exp.opts;\n      right->_.select_stmt.table_exp->_.table_exp.order_by = NULL;\n      right->_.select_stmt.table_exp->_.table_exp.opts = NULL;\n      texp = sqlp_infoschema_redirect (t_listst (9,\n\t    TABLE_EXP, t_list (1, t_list (3, DERIVED_TABLE, tree, t_box_string (\"__\"))),\n\t\t   NULL, NULL, NULL, order, flags,opts, NULL));\n      sel = (ST*) t_list (5, SELECT_STMT, NULL, sqlc_selection_names (left), NULL,\n\t\t\ttexp);\n      return sel;\n    }\n  else\n    return tree;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,15 @@\n ST *\n-sqlc_union_dt_wrap (ST * tree)\n+sqlc_union_dt_wrap (sql_comp_t * sc, ST * tree)\n {\n   ST * left = sqlp_union_tree_select (tree);\n   ST * right = sqlp_union_tree_right (tree);\n+  ST * rtb_exp = right->_.select_stmt.table_exp;\n+  if (!rtb_exp)\n+     sqlc_new_error (sc->sc_cc, \"42S22\", \"SQ098\", \"Non-terminal query expression cannot be used in union.\");\n   if (left != right)\n     {\n       ST * texp, * sel;\n-      ST ** order =right->_.select_stmt.table_exp->_.table_exp.order_by;\n+      ST ** order = right->_.select_stmt.table_exp->_.table_exp.order_by;\n       ptrlong flags = right->_.select_stmt.table_exp->_.table_exp.flags;\n       caddr_t * opts = right->_.select_stmt.table_exp->_.table_exp.opts;\n       right->_.select_stmt.table_exp->_.table_exp.order_by = NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "sqlc_union_dt_wrap (ST * tree)",
                "      ST ** order =right->_.select_stmt.table_exp->_.table_exp.order_by;"
            ],
            "added_lines": [
                "sqlc_union_dt_wrap (sql_comp_t * sc, ST * tree)",
                "  ST * rtb_exp = right->_.select_stmt.table_exp;",
                "  if (!rtb_exp)",
                "     sqlc_new_error (sc->sc_cc, \"42S22\", \"SQ098\", \"Non-terminal query expression cannot be used in union.\");",
                "      ST ** order = right->_.select_stmt.table_exp->_.table_exp.order_by;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31618",
        "func_name": "openlink/virtuoso-opensource/sqlc_union_order",
        "description": "An issue in the sqlc_union_dt_wrap component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/030e47a29976709a50603e3f34e82278e5f462df",
        "commit_title": "Fixed non-terminal in union branch is not supported (fixes #1136)",
        "commit_text": "",
        "func_before": "void\nsqlc_union_order (sql_comp_t * sc, ST ** ptree)\n{\n  ST * out = sqlc_union_dt_wrap (*ptree);\n  if (out != *ptree)\n    {\n      *ptree = out;\n      sql_stmt_comp (sc, ptree);\n    }\n  else\n    sqlc_union_stmt (sc, ptree);\n}",
        "func": "void\nsqlc_union_order (sql_comp_t * sc, ST ** ptree)\n{\n  ST * out = sqlc_union_dt_wrap (sc, *ptree);\n  if (out != *ptree)\n    {\n      *ptree = out;\n      sql_stmt_comp (sc, ptree);\n    }\n  else\n    sqlc_union_stmt (sc, ptree);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n void\n sqlc_union_order (sql_comp_t * sc, ST ** ptree)\n {\n-  ST * out = sqlc_union_dt_wrap (*ptree);\n+  ST * out = sqlc_union_dt_wrap (sc, *ptree);\n   if (out != *ptree)\n     {\n       *ptree = out;",
        "diff_line_info": {
            "deleted_lines": [
                "  ST * out = sqlc_union_dt_wrap (*ptree);"
            ],
            "added_lines": [
                "  ST * out = sqlc_union_dt_wrap (sc, *ptree);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31618",
        "func_name": "openlink/virtuoso-opensource/sqlc_cursor",
        "description": "An issue in the sqlc_union_dt_wrap component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/030e47a29976709a50603e3f34e82278e5f462df",
        "commit_title": "Fixed non-terminal in union branch is not supported (fixes #1136)",
        "commit_text": "",
        "func_before": "void\nsqlc_cursor (sql_comp_t * sc, ST ** ptree, int cr_type)\n{\n  ST *tree = *ptree;\n  int is_id;\n  int cr_forced_static = 0;\n\n  sc->sc_no_remote = 1;\n\n  if (IS_UNION_ST (tree))\n    {\n      tree = sqlp_view_def (NULL, tree, 1);\n      tree = sqlc_union_dt_wrap (tree);\n      *ptree = tree;\n    }\n  sqlc_top_select_wrap_dt (sc, tree);\n  sql_stmt_comp (sc, ptree);\n  tree = *ptree;\n\n  if (sc->sc_so)\n    is_id = sqlo_cr_is_identifiable (sc->sc_so, tree);\n  else\n    is_id = sqlc_cr_is_identifiable (sc, tree);\n  if (!is_id)\n    cr_forced_static = 1;\n  {\n    NEW_VARZ (query_cursor_t, qc);\n    if (sc->sc_cc->cc_query->qr_cursor)\n      {\n\tqc_free (sc->sc_cc->cc_query->qr_cursor);\n\tfprintf (stderr, \"Freeing qc in sqlc_cursor\\n\");\n      }\n    sc->sc_cc->cc_query->qr_cursor = qc;\n    sc->sc_cc->cc_query->qr_cursor_type = cr_type;\n\n    if (sc->sc_so)\n      {\n\tif (!cr_forced_static\n\t    && -1 == sqlo_qc_make_cols (sc->sc_so, qc, tree))\n\t  cr_forced_static = 1;\n      }\n    else\n      {\n\tif (!cr_forced_static\n\t    && -1 == qc_make_cols (sc, qc, tree))\n\t  cr_forced_static = 1;\n      }\n    if (!cr_forced_static)\n      {\n\tqc->qc_cursor_type = cr_type;\n\tif (sc->sc_so)\n\t  sqlo_qc_make_stmts (sc->sc_so, qc);\n\telse\n\t  qc_make_stmts (sc, qc);\n      }\n    else\n      {\n\tqc_make_static (sc, qc, ptree);\n\ttree = *ptree;\n      }\n  }\n}",
        "func": "void\nsqlc_cursor (sql_comp_t * sc, ST ** ptree, int cr_type)\n{\n  ST *tree = *ptree;\n  int is_id;\n  int cr_forced_static = 0;\n\n  sc->sc_no_remote = 1;\n\n  if (IS_UNION_ST (tree))\n    {\n      tree = sqlp_view_def (NULL, tree, 1);\n      tree = sqlc_union_dt_wrap (sc, tree);\n      *ptree = tree;\n    }\n  sqlc_top_select_wrap_dt (sc, tree);\n  sql_stmt_comp (sc, ptree);\n  tree = *ptree;\n\n  if (sc->sc_so)\n    is_id = sqlo_cr_is_identifiable (sc->sc_so, tree);\n  else\n    is_id = sqlc_cr_is_identifiable (sc, tree);\n  if (!is_id)\n    cr_forced_static = 1;\n  {\n    NEW_VARZ (query_cursor_t, qc);\n    if (sc->sc_cc->cc_query->qr_cursor)\n      {\n\tqc_free (sc->sc_cc->cc_query->qr_cursor);\n\tfprintf (stderr, \"Freeing qc in sqlc_cursor\\n\");\n      }\n    sc->sc_cc->cc_query->qr_cursor = qc;\n    sc->sc_cc->cc_query->qr_cursor_type = cr_type;\n\n    if (sc->sc_so)\n      {\n\tif (!cr_forced_static\n\t    && -1 == sqlo_qc_make_cols (sc->sc_so, qc, tree))\n\t  cr_forced_static = 1;\n      }\n    else\n      {\n\tif (!cr_forced_static\n\t    && -1 == qc_make_cols (sc, qc, tree))\n\t  cr_forced_static = 1;\n      }\n    if (!cr_forced_static)\n      {\n\tqc->qc_cursor_type = cr_type;\n\tif (sc->sc_so)\n\t  sqlo_qc_make_stmts (sc->sc_so, qc);\n\telse\n\t  qc_make_stmts (sc, qc);\n      }\n    else\n      {\n\tqc_make_static (sc, qc, ptree);\n\ttree = *ptree;\n      }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n   if (IS_UNION_ST (tree))\n     {\n       tree = sqlp_view_def (NULL, tree, 1);\n-      tree = sqlc_union_dt_wrap (tree);\n+      tree = sqlc_union_dt_wrap (sc, tree);\n       *ptree = tree;\n     }\n   sqlc_top_select_wrap_dt (sc, tree);",
        "diff_line_info": {
            "deleted_lines": [
                "      tree = sqlc_union_dt_wrap (tree);"
            ],
            "added_lines": [
                "      tree = sqlc_union_dt_wrap (sc, tree);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31618",
        "func_name": "openlink/virtuoso-opensource/sqlp_convert_or_to_union",
        "description": "An issue in the sqlc_union_dt_wrap component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/030e47a29976709a50603e3f34e82278e5f462df",
        "commit_title": "Fixed non-terminal in union branch is not supported (fixes #1136)",
        "commit_text": "",
        "func_before": "static int\nsqlp_convert_or_to_union (sqlo_t * so, ST **ptree)\n{\n  ST *tree = *ptree;\n  if (sqlp_convert_or_to_inlist (so, ptree))\n    return 1;\n  if (ST_P (tree, SELECT_STMT) && BOX_ELEMENTS (tree) >= 5 &&\n      ST_P (tree->_.select_stmt.table_exp, TABLE_EXP) &&\n      ST_P (tree->_.select_stmt.table_exp->_.table_exp.where, BOP_OR) &&\n      !sqlp_tree_has_fun_ref (tree) &&\n      !tree->_.select_stmt.table_exp->_.table_exp.group_by &&\n      !tree->_.select_stmt.table_exp->_.table_exp.order_by)\n    {\n      ST *where = tree->_.select_stmt.table_exp->_.table_exp.where;\n      dk_set_t or_list = NULL;\n      ST *new_tree = NULL;\n      ST *orig_sel = (ST *) t_box_copy_tree ((caddr_t) tree->_.select_stmt.selection);\n      ST *corresponding_list = sqlp_collect_from_pkeys (so, tree);\n\n      if (!corresponding_list)\n\treturn 0;\n\n      tree->_.select_stmt.selection = (caddr_t *) sqlp_stars (\n\t        sqlp_wrapper_sqlxml ((ST **) t_listst (1, t_listst (3, COL_DOTTED, (long) 0, STAR))),\n\t  \ttree->_.select_stmt.table_exp->_.table_exp.from);\n\n      sqlc_make_or_list (where, &or_list);\n\n      if (sqlo_max_union_nesting > 0 && dk_set_length (or_list) > sqlo_max_union_nesting)\n\treturn 0;\n\n      DO_SET (ST *, clause, &or_list)\n\t{\n\t  ST *new_leaf = (ST *) t_box_copy_tree ( (caddr_t) tree);\n\n\t  new_leaf->_.select_stmt.table_exp->_.table_exp.where = clause;\n\n\t  if (new_tree)\n\t    new_tree = t_listst (5, UNION_ST,\n\t\tnew_leaf, new_tree, corresponding_list, NULL);\n\t  else\n\t    new_tree = new_leaf;\n\t}\n      END_DO_SET ();\n      new_tree = sqlp_view_def (NULL, new_tree, 1);\n      new_tree = sqlc_union_dt_wrap (new_tree);\n      sqlo_unor_replace_col_refs (so, &orig_sel, (ST *)new_tree->_.select_stmt.selection, sqlp_union_tree_select (tree));\n      new_tree->_.select_stmt.selection = (caddr_t *) orig_sel;\n      *ptree = new_tree;\n      return 1;\n    }\n  else if (DV_TYPE_OF (tree) == DV_ARRAY_OF_POINTER)\n    {\n      int inx, res = 0;\n      _DO_BOX (inx, ((caddr_t *)tree))\n\t{\n\t  res = res || sqlp_convert_or_to_union (so, &(((ST **)tree)[inx]));\n\t}\n      END_DO_BOX;\n      return res;\n    }\n  else\n    return 0;\n}",
        "func": "static int\nsqlp_convert_or_to_union (sqlo_t * so, ST **ptree)\n{\n  ST *tree = *ptree;\n  if (sqlp_convert_or_to_inlist (so, ptree))\n    return 1;\n  if (ST_P (tree, SELECT_STMT) && BOX_ELEMENTS (tree) >= 5 &&\n      ST_P (tree->_.select_stmt.table_exp, TABLE_EXP) &&\n      ST_P (tree->_.select_stmt.table_exp->_.table_exp.where, BOP_OR) &&\n      !sqlp_tree_has_fun_ref (tree) &&\n      !tree->_.select_stmt.table_exp->_.table_exp.group_by &&\n      !tree->_.select_stmt.table_exp->_.table_exp.order_by)\n    {\n      ST *where = tree->_.select_stmt.table_exp->_.table_exp.where;\n      dk_set_t or_list = NULL;\n      ST *new_tree = NULL;\n      ST *orig_sel = (ST *) t_box_copy_tree ((caddr_t) tree->_.select_stmt.selection);\n      ST *corresponding_list = sqlp_collect_from_pkeys (so, tree);\n\n      if (!corresponding_list)\n\treturn 0;\n\n      tree->_.select_stmt.selection = (caddr_t *) sqlp_stars (\n\t        sqlp_wrapper_sqlxml ((ST **) t_listst (1, t_listst (3, COL_DOTTED, (long) 0, STAR))),\n\t  \ttree->_.select_stmt.table_exp->_.table_exp.from);\n\n      sqlc_make_or_list (where, &or_list);\n\n      if (sqlo_max_union_nesting > 0 && dk_set_length (or_list) > sqlo_max_union_nesting)\n\treturn 0;\n\n      DO_SET (ST *, clause, &or_list)\n\t{\n\t  ST *new_leaf = (ST *) t_box_copy_tree ( (caddr_t) tree);\n\n\t  new_leaf->_.select_stmt.table_exp->_.table_exp.where = clause;\n\n\t  if (new_tree)\n\t    new_tree = t_listst (5, UNION_ST,\n\t\tnew_leaf, new_tree, corresponding_list, NULL);\n\t  else\n\t    new_tree = new_leaf;\n\t}\n      END_DO_SET ();\n      new_tree = sqlp_view_def (NULL, new_tree, 1);\n      new_tree = sqlc_union_dt_wrap (so->so_sc, new_tree);\n      sqlo_unor_replace_col_refs (so, &orig_sel, (ST *)new_tree->_.select_stmt.selection, sqlp_union_tree_select (tree));\n      new_tree->_.select_stmt.selection = (caddr_t *) orig_sel;\n      *ptree = new_tree;\n      return 1;\n    }\n  else if (DV_TYPE_OF (tree) == DV_ARRAY_OF_POINTER)\n    {\n      int inx, res = 0;\n      _DO_BOX (inx, ((caddr_t *)tree))\n\t{\n\t  res = res || sqlp_convert_or_to_union (so, &(((ST **)tree)[inx]));\n\t}\n      END_DO_BOX;\n      return res;\n    }\n  else\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -43,7 +43,7 @@\n \t}\n       END_DO_SET ();\n       new_tree = sqlp_view_def (NULL, new_tree, 1);\n-      new_tree = sqlc_union_dt_wrap (new_tree);\n+      new_tree = sqlc_union_dt_wrap (so->so_sc, new_tree);\n       sqlo_unor_replace_col_refs (so, &orig_sel, (ST *)new_tree->_.select_stmt.selection, sqlp_union_tree_select (tree));\n       new_tree->_.select_stmt.selection = (caddr_t *) orig_sel;\n       *ptree = new_tree;",
        "diff_line_info": {
            "deleted_lines": [
                "      new_tree = sqlc_union_dt_wrap (new_tree);"
            ],
            "added_lines": [
                "      new_tree = sqlc_union_dt_wrap (so->so_sc, new_tree);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31618",
        "func_name": "openlink/virtuoso-opensource/sqlo_top",
        "description": "An issue in the sqlc_union_dt_wrap component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/030e47a29976709a50603e3f34e82278e5f462df",
        "commit_title": "Fixed non-terminal in union branch is not supported (fixes #1136)",
        "commit_text": "",
        "func_before": "caddr_t\nsqlo_top (sql_comp_t * sc, ST ** volatile ptree, float * volatile score_ptr)\n{\n  ST * volatile tree = *ptree;\n  df_elt_t * volatile ret = NULL;\n  if (score_ptr)\n    *score_ptr = 0;\n  CATCH (CATCH_LISP_ERROR)\n    {\n      t_NEW_VARZ (sqlo_t, so);\n      SO_LIMITS (so);\n      so->so_is_select = 1;\n\n      if (ST_P (tree, UNION_ST) ||\n\t   ST_P (tree, UNION_ALL_ST) ||\n\t   ST_P (tree, EXCEPT_ST) ||\n\t   ST_P (tree, EXCEPT_ALL_ST) ||\n\t   ST_P (tree, INTERSECT_ST) ||\n\t   ST_P (tree, INTERSECT_ALL_ST))\n\t{\n\t  tree = sqlp_view_def (NULL, tree, 1);\n\t  tree = sqlc_union_dt_wrap (tree);\n\t  *ptree = tree;\n\t}\n      ret = sqlo_top_1 (so, sc, ptree);\n      tree = *ptree;\n      if (score_ptr)\n\t*score_ptr = ret->dfe_unit;\n    }\n  THROW_CODE\n    {\n      caddr_t * err = (caddr_t*) THR_ATTR (THREAD_CURRENT_THREAD, TA_SQLC_ERROR);\n\n      if (sqlo_print_debug_output)\n\t{\n\t  sqlo_print ((\"sql opt error%s: %s\\n\",\n\t\tERR_STATE (err), ERR_MESSAGE (err)));\n\t}\n      dk_free_tree ((box_t) err);\t/* IvAn/010801/LeakOnError */\n    }\n  END_CATCH;\n  return (caddr_t) (ret && ret->dfe_tree ? ret->dfe_tree : NULL);\n}",
        "func": "caddr_t\nsqlo_top (sql_comp_t * sc, ST ** volatile ptree, float * volatile score_ptr)\n{\n  ST * volatile tree = *ptree;\n  df_elt_t * volatile ret = NULL;\n  if (score_ptr)\n    *score_ptr = 0;\n  CATCH (CATCH_LISP_ERROR)\n    {\n      t_NEW_VARZ (sqlo_t, so);\n      SO_LIMITS (so);\n      so->so_is_select = 1;\n\n      if (ST_P (tree, UNION_ST) ||\n\t   ST_P (tree, UNION_ALL_ST) ||\n\t   ST_P (tree, EXCEPT_ST) ||\n\t   ST_P (tree, EXCEPT_ALL_ST) ||\n\t   ST_P (tree, INTERSECT_ST) ||\n\t   ST_P (tree, INTERSECT_ALL_ST))\n\t{\n\t  tree = sqlp_view_def (NULL, tree, 1);\n\t  tree = sqlc_union_dt_wrap (sc, tree);\n\t  *ptree = tree;\n\t}\n      ret = sqlo_top_1 (so, sc, ptree);\n      tree = *ptree;\n      if (score_ptr)\n\t*score_ptr = ret->dfe_unit;\n    }\n  THROW_CODE\n    {\n      caddr_t * err = (caddr_t*) THR_ATTR (THREAD_CURRENT_THREAD, TA_SQLC_ERROR);\n\n      if (sqlo_print_debug_output)\n\t{\n\t  sqlo_print ((\"sql opt error%s: %s\\n\",\n\t\tERR_STATE (err), ERR_MESSAGE (err)));\n\t}\n      dk_free_tree ((box_t) err);\t/* IvAn/010801/LeakOnError */\n    }\n  END_CATCH;\n  return (caddr_t) (ret && ret->dfe_tree ? ret->dfe_tree : NULL);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,7 +19,7 @@\n \t   ST_P (tree, INTERSECT_ALL_ST))\n \t{\n \t  tree = sqlp_view_def (NULL, tree, 1);\n-\t  tree = sqlc_union_dt_wrap (tree);\n+\t  tree = sqlc_union_dt_wrap (sc, tree);\n \t  *ptree = tree;\n \t}\n       ret = sqlo_top_1 (so, sc, ptree);",
        "diff_line_info": {
            "deleted_lines": [
                "\t  tree = sqlc_union_dt_wrap (tree);"
            ],
            "added_lines": [
                "\t  tree = sqlc_union_dt_wrap (sc, tree);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31618",
        "func_name": "openlink/virtuoso-opensource/sqlo_scope",
        "description": "An issue in the sqlc_union_dt_wrap component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/030e47a29976709a50603e3f34e82278e5f462df",
        "commit_title": "Fixed non-terminal in union branch is not supported (fixes #1136)",
        "commit_text": "",
        "func_before": "void\nsqlo_scope (sqlo_t * so, ST ** ptree)\n{\n  ST *tree;\n  if (!ptree || !*ptree)\n    return;\n  tree = *ptree;\n  if (SYMBOLP (tree))\n    return;\n  if (ST_P (tree, QUOTE))\n    return;\n  if (DV_ARRAY_OF_POINTER != DV_TYPE_OF (tree))\n    return;\n  if (THR_IS_STACK_OVERFLOW (THREAD_CURRENT_THREAD, &tree, 8000))\n    sqlc_error (so->so_sc->sc_cc, \".....\", \"Stack Overflow\");\n  if (DK_MEM_RESERVE)\n    sqlc_error (so->so_sc->sc_cc, \".....\", \"Out of memory\");\n  switch (tree->type)\n    {\n    case COL_DOTTED:\n      {\n\tCHECK_OBSERVER(ptree);\n\tsqlo_col_scope (so, tree);\n\tbreak;\n      }\n    case FUN_REF:\n      {\n\tint old_fun_refs_allowed = so->so_scope ? so->so_scope->sco_fun_refs_allowed : 0;\n\n\tif (so->so_scope && !so->so_scope->sco_fun_refs_allowed)\n\t  sqlc_error (so->so_sc->sc_cc, \"37000\", \"Aggregate function not allowed in context\");\n\n\tif (AMMSC_AVG == tree->_.fn_ref.fn_code)\n\t  {\n\t    ST * arg = tree->_.fn_ref.fn_arg;\n\t    ptrlong ad = tree->_.fn_ref.all_distinct;\n\t    ST * arg_copy = (ST*) t_box_copy_tree ((caddr_t) arg);\n\t    ST * new_tree;\n\t    if (sizeof (tree->_.bin_exp) > sizeof (tree->_.fn_ref))\n\t      GPF_T1 (\"the parse tree bin exp variant must fit inside the parse tree fun ref ariant\");\n\t    BIN_OP (new_tree, BOP_DIV,\n\t\tt_listst (7, FUN_REF, NULL, AMMSC_SUM, NULL, ad, arg, NULL),\n\t\tt_listst (7, FUN_REF, NULL, AMMSC_COUNT, NULL, ad, arg_copy, NULL));\n\t    *ptree = new_tree;\n\t    tree = new_tree;\n\t    sqlp_complete_fun_ref (tree->_.bin_exp.right);\n\t    sqlo_scope (so, ptree);\n\t    tree = *ptree;\n\t    return;\n\t  }\n\n\tif (AMMSC_COUNT == tree->_.fn_ref.fn_code)\n\t  sqlo_count_unq_preserving (tree);\n\tif (AMMSC_COUNT == tree->_.fn_ref.fn_code\n\t    && !tree->_.fn_ref.all_distinct\n\t    && !sqlo_has_col_ref (tree->_.fn_ref.fn_arg))\n\t  {\n\t    tree->_.fn_ref.fn_code = AMMSC_COUNTSUM;\n\t    if (DV_DB_NULL != DV_TYPE_OF (tree->_.fn_ref.fn_arg))\n\t      tree->_.fn_ref.fn_arg = (ST*) box_num (1);\n\t    else\n\t      tree->_.fn_ref.fn_arg = (ST*) box_num (0);\n\t    tree->_.fn_ref.fn_name = so->so_this_dt->ot_new_prefix;\n\t  }\n\t/*if (!sqlo_has_col_ref (tree->_.fn_ref.arg))*/\n\ttree->_.fn_ref.fn_name = so->so_this_dt->ot_new_prefix;\n\n\tif (so->so_scope)\n\t  so->so_scope->sco_fun_refs_allowed = 0;\n\tif (NULL != tree->_.fn_ref.fn_arg)\n\t  sqlo_scope (so, &(tree->_.fn_ref.fn_arg));\n\telse\n\t  {\n\t    int arginx;\n\t    _DO_BOX_FAST (arginx, tree->_.fn_ref.fn_arglist)\n\t      {\n\t\tsqlo_scope (so, &(tree->_.fn_ref.fn_arglist[arginx]));\n\t      }\n\t    END_DO_BOX_FAST;\n\t  }\n\tt_set_push (&so->so_this_dt->ot_fun_refs, (void*) tree);\n\tif (so->so_scope)\n\t  so->so_scope->sco_fun_refs_allowed = old_fun_refs_allowed;\n\tbreak;\n      }\n    case SCALAR_SUBQ:\n      sqlo_scalar_subq_scope (so, &(tree->_.bin_exp.left));\n      break;\n    case CALL_STMT:\n      {\n\tint inx;\n\tST *res;\n\tchar * call_name = tree->_.call.name;\n\tif (DV_ARRAY_OF_POINTER == DV_TYPE_OF (tree->_.call.name) && BOX_ELEMENTS (tree->_.call.name) == 1)\n\t  {\n\t    sqlo_scope (so, &(((ST **) tree->_.call.name)[0]));\n\t  }\n\telse\n\t  {\n\t    CHECK_METHOD_CALL (ptree);\n\t    if (KS_CAST_OK == sqlo_check_rdf_lit  (ptree))\n\t      return;\n\t  }\n\t/* mark qr to do lock if it is for SPARQL insert/delete triples */\n\tif (DV_STRINGP (call_name) &&\n\t    (!casemode_strcmp (call_name, \"DB.DBA.SPARQL_INSERT_DICT_CONTENT\") ||\n\t     !casemode_strcmp (call_name, \"DB.DBA.SPARQL_DELETE_DICT_CONTENT\") ||\n\t     !casemode_strcmp (call_name, \"DB.DBA.SPARUL_LOAD\") ||\n\t     !casemode_strcmp (call_name, \"DB.DBA.SPARUL_CLEAR\")))\n\t  so->so_sc->sc_cc->cc_query->qr_lock_mode = PL_EXCLUSIVE;\n\t_DO_BOX (inx, tree->_.call.params)\n\t  {\n\t    sqlo_scope (so, &(tree->_.call.params[inx]));\n\t  }\n\tEND_DO_BOX;\n\tres = sinv_check_inverses (tree, sqlc_client());\n\tif (call_name == uname_one_of_these)\n\t  res = sqlo_iri_in_opt (so, tree);\n\tif (res != tree)\n\t  {\n\t    *ptree = res;\n            tree = res;\n\t  }\n\tbreak;\n      }\n    case COMMA_EXP:\n    case SIMPLE_CASE:\n    case SEARCHED_CASE:\n    case COALESCE_EXP:\n      {\n\tint inx;\n\t_DO_BOX (inx, tree->_.comma_exp.exps)\n\t  {\n\t    sqlo_scope (so, &(tree->_.comma_exp.exps[inx]));\n\t  }\n\tEND_DO_BOX;\n\tbreak;\n      }\n    case ASG_STMT:\n      {\n\tCHECK_MUTATOR(ptree);\n\tsqlo_scope (so, (ST **) &(tree->_.op.arg_1));\n\tsqlo_scope (so, (ST **) &(tree->_.op.arg_2));\n\tbreak;\n      }\n    case KWD_PARAM:\n      sqlo_scope (so, &(tree->_.bin_exp.right));\n      break;\n    case SELECT_STMT:\n      sqlo_select_scope (so, ptree);\n      break;\n    case UNION_ST: case UNION_ALL_ST:\n    case EXCEPT_ST: case EXCEPT_ALL_ST:\n    case INTERSECT_ST: case INTERSECT_ALL_ST:\n\t{\n\t  ST *left;\n\t  if (IS_UNION_ST (tree->_.set_exp.left))\n\t    tree->_.set_exp.left = sqlc_union_dt_wrap (tree->_.set_exp.left);\n\t  if (IS_UNION_ST (tree->_.set_exp.right))\n\t    tree->_.set_exp.right = sqlc_union_dt_wrap (tree->_.set_exp.right);\n\t  left = sqlp_union_tree_select (tree);\n\t  sqlo_union_scope (so, ptree, left);\n\t  break;\n\t}\n    case ORDER_BY:\n      sqlo_scope (so, &(tree->_.o_spec.col));\n      break;\n    case PROC_TABLE:\n      if (DV_ARRAY_OF_POINTER == DV_TYPE_OF (tree->_.proc_table.proc))\n\t{\n\t  sqlo_scope (so, &(((ST **) tree->_.proc_table.proc)[0]));\n\t}\n      break;\n    default:\n      if (BIN_EXP_P (tree))\n\t{\n\t  ST *res;\n \t  so->so_bin_op_is_negate = tree->type == BOP_NOT ? 1 : 0;\n\t  sqlo_scope (so, &(tree->_.bin_exp.left));\n\t  sqlo_scope (so, &(tree->_.bin_exp.right));\n \t  so->so_bin_op_is_negate = 0;\n\t  res = sinv_check_exp (so, tree);\n\t  if (res != tree)\n\t    {\n\t      *ptree = res;\n\t      tree = res;\n\t      sqlo_check_rdf_lit (&tree->_.bin_exp.left);\n\t      sqlo_check_rdf_lit (&tree->_.bin_exp.right);\n\t    }\n\t  if (ST_P (tree, BOP_OR))\n\t    sqlo_bop_expand_or (so, tree);\n\t}\n      else if (SUBQ_P (tree))\n\t{\n \t  char so_bin_op_is_negate = so->so_bin_op_is_negate;\n\t  sqlo_scope (so, &(tree->_.subq.left));\n\t  sqlo_scope (so, &(tree->_.subq.subq));\n \t  so->so_bin_op_is_negate = so_bin_op_is_negate;\n\t  sqlo_subq_convert_to_exists (so, ptree);\n\t}\n\n    }\n}",
        "func": "void\nsqlo_scope (sqlo_t * so, ST ** ptree)\n{\n  ST *tree;\n  if (!ptree || !*ptree)\n    return;\n  tree = *ptree;\n  if (SYMBOLP (tree))\n    return;\n  if (ST_P (tree, QUOTE))\n    return;\n  if (DV_ARRAY_OF_POINTER != DV_TYPE_OF (tree))\n    return;\n  if (THR_IS_STACK_OVERFLOW (THREAD_CURRENT_THREAD, &tree, 8000))\n    sqlc_error (so->so_sc->sc_cc, \".....\", \"Stack Overflow\");\n  if (DK_MEM_RESERVE)\n    sqlc_error (so->so_sc->sc_cc, \".....\", \"Out of memory\");\n  switch (tree->type)\n    {\n    case COL_DOTTED:\n      {\n\tCHECK_OBSERVER(ptree);\n\tsqlo_col_scope (so, tree);\n\tbreak;\n      }\n    case FUN_REF:\n      {\n\tint old_fun_refs_allowed = so->so_scope ? so->so_scope->sco_fun_refs_allowed : 0;\n\n\tif (so->so_scope && !so->so_scope->sco_fun_refs_allowed)\n\t  sqlc_error (so->so_sc->sc_cc, \"37000\", \"Aggregate function not allowed in context\");\n\n\tif (AMMSC_AVG == tree->_.fn_ref.fn_code)\n\t  {\n\t    ST * arg = tree->_.fn_ref.fn_arg;\n\t    ptrlong ad = tree->_.fn_ref.all_distinct;\n\t    ST * arg_copy = (ST*) t_box_copy_tree ((caddr_t) arg);\n\t    ST * new_tree;\n\t    if (sizeof (tree->_.bin_exp) > sizeof (tree->_.fn_ref))\n\t      GPF_T1 (\"the parse tree bin exp variant must fit inside the parse tree fun ref ariant\");\n\t    BIN_OP (new_tree, BOP_DIV,\n\t\tt_listst (7, FUN_REF, NULL, AMMSC_SUM, NULL, ad, arg, NULL),\n\t\tt_listst (7, FUN_REF, NULL, AMMSC_COUNT, NULL, ad, arg_copy, NULL));\n\t    *ptree = new_tree;\n\t    tree = new_tree;\n\t    sqlp_complete_fun_ref (tree->_.bin_exp.right);\n\t    sqlo_scope (so, ptree);\n\t    tree = *ptree;\n\t    return;\n\t  }\n\n\tif (AMMSC_COUNT == tree->_.fn_ref.fn_code)\n\t  sqlo_count_unq_preserving (tree);\n\tif (AMMSC_COUNT == tree->_.fn_ref.fn_code\n\t    && !tree->_.fn_ref.all_distinct\n\t    && !sqlo_has_col_ref (tree->_.fn_ref.fn_arg))\n\t  {\n\t    tree->_.fn_ref.fn_code = AMMSC_COUNTSUM;\n\t    if (DV_DB_NULL != DV_TYPE_OF (tree->_.fn_ref.fn_arg))\n\t      tree->_.fn_ref.fn_arg = (ST*) box_num (1);\n\t    else\n\t      tree->_.fn_ref.fn_arg = (ST*) box_num (0);\n\t    tree->_.fn_ref.fn_name = so->so_this_dt->ot_new_prefix;\n\t  }\n\t/*if (!sqlo_has_col_ref (tree->_.fn_ref.arg))*/\n\ttree->_.fn_ref.fn_name = so->so_this_dt->ot_new_prefix;\n\n\tif (so->so_scope)\n\t  so->so_scope->sco_fun_refs_allowed = 0;\n\tif (NULL != tree->_.fn_ref.fn_arg)\n\t  sqlo_scope (so, &(tree->_.fn_ref.fn_arg));\n\telse\n\t  {\n\t    int arginx;\n\t    _DO_BOX_FAST (arginx, tree->_.fn_ref.fn_arglist)\n\t      {\n\t\tsqlo_scope (so, &(tree->_.fn_ref.fn_arglist[arginx]));\n\t      }\n\t    END_DO_BOX_FAST;\n\t  }\n\tt_set_push (&so->so_this_dt->ot_fun_refs, (void*) tree);\n\tif (so->so_scope)\n\t  so->so_scope->sco_fun_refs_allowed = old_fun_refs_allowed;\n\tbreak;\n      }\n    case SCALAR_SUBQ:\n      sqlo_scalar_subq_scope (so, &(tree->_.bin_exp.left));\n      break;\n    case CALL_STMT:\n      {\n\tint inx;\n\tST *res;\n\tchar * call_name = tree->_.call.name;\n\tif (DV_ARRAY_OF_POINTER == DV_TYPE_OF (tree->_.call.name) && BOX_ELEMENTS (tree->_.call.name) == 1)\n\t  {\n\t    sqlo_scope (so, &(((ST **) tree->_.call.name)[0]));\n\t  }\n\telse\n\t  {\n\t    CHECK_METHOD_CALL (ptree);\n\t    if (KS_CAST_OK == sqlo_check_rdf_lit  (ptree))\n\t      return;\n\t  }\n\t/* mark qr to do lock if it is for SPARQL insert/delete triples */\n\tif (DV_STRINGP (call_name) &&\n\t    (!casemode_strcmp (call_name, \"DB.DBA.SPARQL_INSERT_DICT_CONTENT\") ||\n\t     !casemode_strcmp (call_name, \"DB.DBA.SPARQL_DELETE_DICT_CONTENT\") ||\n\t     !casemode_strcmp (call_name, \"DB.DBA.SPARUL_LOAD\") ||\n\t     !casemode_strcmp (call_name, \"DB.DBA.SPARUL_CLEAR\")))\n\t  so->so_sc->sc_cc->cc_query->qr_lock_mode = PL_EXCLUSIVE;\n\t_DO_BOX (inx, tree->_.call.params)\n\t  {\n\t    sqlo_scope (so, &(tree->_.call.params[inx]));\n\t  }\n\tEND_DO_BOX;\n\tres = sinv_check_inverses (tree, sqlc_client());\n\tif (call_name == uname_one_of_these)\n\t  res = sqlo_iri_in_opt (so, tree);\n\tif (res != tree)\n\t  {\n\t    *ptree = res;\n            tree = res;\n\t  }\n\tbreak;\n      }\n    case COMMA_EXP:\n    case SIMPLE_CASE:\n    case SEARCHED_CASE:\n    case COALESCE_EXP:\n      {\n\tint inx;\n\t_DO_BOX (inx, tree->_.comma_exp.exps)\n\t  {\n\t    sqlo_scope (so, &(tree->_.comma_exp.exps[inx]));\n\t  }\n\tEND_DO_BOX;\n\tbreak;\n      }\n    case ASG_STMT:\n      {\n\tCHECK_MUTATOR(ptree);\n\tsqlo_scope (so, (ST **) &(tree->_.op.arg_1));\n\tsqlo_scope (so, (ST **) &(tree->_.op.arg_2));\n\tbreak;\n      }\n    case KWD_PARAM:\n      sqlo_scope (so, &(tree->_.bin_exp.right));\n      break;\n    case SELECT_STMT:\n      sqlo_select_scope (so, ptree);\n      break;\n    case UNION_ST: case UNION_ALL_ST:\n    case EXCEPT_ST: case EXCEPT_ALL_ST:\n    case INTERSECT_ST: case INTERSECT_ALL_ST:\n\t{\n\t  ST *left;\n\t  if (IS_UNION_ST (tree->_.set_exp.left))\n\t    tree->_.set_exp.left = sqlc_union_dt_wrap (so->so_sc, tree->_.set_exp.left);\n\t  if (IS_UNION_ST (tree->_.set_exp.right))\n\t    tree->_.set_exp.right = sqlc_union_dt_wrap (so->so_sc, tree->_.set_exp.right);\n\t  left = sqlp_union_tree_select (tree);\n\t  sqlo_union_scope (so, ptree, left);\n\t  break;\n\t}\n    case ORDER_BY:\n      sqlo_scope (so, &(tree->_.o_spec.col));\n      break;\n    case PROC_TABLE:\n      if (DV_ARRAY_OF_POINTER == DV_TYPE_OF (tree->_.proc_table.proc))\n\t{\n\t  sqlo_scope (so, &(((ST **) tree->_.proc_table.proc)[0]));\n\t}\n      break;\n    default:\n      if (BIN_EXP_P (tree))\n\t{\n\t  ST *res;\n \t  so->so_bin_op_is_negate = tree->type == BOP_NOT ? 1 : 0;\n\t  sqlo_scope (so, &(tree->_.bin_exp.left));\n\t  sqlo_scope (so, &(tree->_.bin_exp.right));\n \t  so->so_bin_op_is_negate = 0;\n\t  res = sinv_check_exp (so, tree);\n\t  if (res != tree)\n\t    {\n\t      *ptree = res;\n\t      tree = res;\n\t      sqlo_check_rdf_lit (&tree->_.bin_exp.left);\n\t      sqlo_check_rdf_lit (&tree->_.bin_exp.right);\n\t    }\n\t  if (ST_P (tree, BOP_OR))\n\t    sqlo_bop_expand_or (so, tree);\n\t}\n      else if (SUBQ_P (tree))\n\t{\n \t  char so_bin_op_is_negate = so->so_bin_op_is_negate;\n\t  sqlo_scope (so, &(tree->_.subq.left));\n\t  sqlo_scope (so, &(tree->_.subq.subq));\n \t  so->so_bin_op_is_negate = so_bin_op_is_negate;\n\t  sqlo_subq_convert_to_exists (so, ptree);\n\t}\n\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -155,9 +155,9 @@\n \t{\n \t  ST *left;\n \t  if (IS_UNION_ST (tree->_.set_exp.left))\n-\t    tree->_.set_exp.left = sqlc_union_dt_wrap (tree->_.set_exp.left);\n+\t    tree->_.set_exp.left = sqlc_union_dt_wrap (so->so_sc, tree->_.set_exp.left);\n \t  if (IS_UNION_ST (tree->_.set_exp.right))\n-\t    tree->_.set_exp.right = sqlc_union_dt_wrap (tree->_.set_exp.right);\n+\t    tree->_.set_exp.right = sqlc_union_dt_wrap (so->so_sc, tree->_.set_exp.right);\n \t  left = sqlp_union_tree_select (tree);\n \t  sqlo_union_scope (so, ptree, left);\n \t  break;",
        "diff_line_info": {
            "deleted_lines": [
                "\t    tree->_.set_exp.left = sqlc_union_dt_wrap (tree->_.set_exp.left);",
                "\t    tree->_.set_exp.right = sqlc_union_dt_wrap (tree->_.set_exp.right);"
            ],
            "added_lines": [
                "\t    tree->_.set_exp.left = sqlc_union_dt_wrap (so->so_sc, tree->_.set_exp.left);",
                "\t    tree->_.set_exp.right = sqlc_union_dt_wrap (so->so_sc, tree->_.set_exp.right);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31618",
        "func_name": "openlink/virtuoso-opensource/sqlo_add_table_ref",
        "description": "An issue in the sqlc_union_dt_wrap component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/030e47a29976709a50603e3f34e82278e5f462df",
        "commit_title": "Fixed non-terminal in union branch is not supported (fixes #1136)",
        "commit_text": "",
        "func_before": "void\nsqlo_add_table_ref (sqlo_t * so, ST ** tree_ret, dk_set_t *res)\n{\n  char tmp[10];\n  ST * tree = *tree_ret;\n  switch (tree->type)\n    {\n    case TABLE_REF:\n      {\n\tST * prev = tree->_.table_ref.table;\n\tif (ST_P (prev, SELECT_STMT))\n\t  {\n\t    tree->type = DERIVED_TABLE;\n\t    sqlp_view_def (NULL, tree->_.table_ref.table, 0);\n\t    sqlo_add_table_ref (so, tree_ret, res);\n\t    return;\n\t  }\n\tsqlo_add_table_ref (so, &tree->_.table_ref.table, res);\n\tif (prev != tree->_.table_ref.table)\n\t  *tree_ret = tree->_.table_ref.table;\n\tbreak;\n      }\n    case TABLE_DOTTED:\n      {\n\tST * with_view = sqlo_with_decl (so, tree);\n\tdbe_table_t *tb = with_view ? NULL : sch_name_to_table (wi_inst.wi_schema, tree->_.table.name);\n\tST * view;\n\tif (!tb && !with_view)\n\t  sqlc_error (so->so_sc->sc_cc, \"S0002\", \"No table %s\", tree->_.table.name);\n\tif (inside_view)\n\t  tree->_.table.name = t_box_copy (tb->tb_name);\n\tif (!with_view)\n\t  {\n\t    sqlc_table_used (so->so_sc, tb);\n\t    view = (ST*) sch_view_def (wi_inst.wi_schema, tb->tb_name);\n\t  }\n\telse\n\t  view = with_view;\n\tif (!view || inside_view)\n\t  {\n\t    remote_table_t * rt = find_remote_table (tb->tb_name, 0);\n\t    t_NEW_VARZ (op_table_t, ot);\n\t    ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts);\n\t    ot->ot_prefix = tree->_.table.prefix;\n\t    snprintf (tmp, sizeof (tmp), \"t%d\", so->so_name_ctr++);\n\t    ot->ot_new_prefix = t_box_string (tmp);\n\t    tree->_.table.prefix = ot->ot_new_prefix;\n\t    ot->ot_table = tb;\n\t    ot->ot_rds = rt ? rt->rt_rds : NULL;\n\t    ot->ot_u_id = (oid_t) unbox (tree->_.table.u_id);\n\t    ot->ot_g_id = (oid_t) unbox (tree->_.table.g_id);\n\t    if (ST_P (view, PROC_TABLE))\n\t      {\n\t\tot->ot_dt = view;\n\t\tsqlo_proc_table_cols (so, ot);\n\t\tot->ot_dt = NULL;\n\t\tot->ot_is_proc_view = 1;\n\t      }\n\t    sqlo_rls_add_condition (so, ot, res, tb);\n\t    t_set_push (&so->so_tables, (void*) ot);\n\t    sco_add_table (so->so_scope, ot);\n\t  }\n\telse\n\t  {\n\t    op_table_t * ot = NULL;\n\t    if (!with_view && !sec_tb_check (tb, (oid_t) unbox (tree->_.table.g_id), (oid_t) unbox (tree->_.table.u_id), GR_SELECT))\n\t      sqlc_new_error (so->so_sc->sc_cc, \"42000\", \"SQ070:SECURITY\", \"Must have select privileges on view %s\", tb->tb_name);\n\t    view = (ST*) t_box_copy_tree ((caddr_t) view);\n\t    if (ST_P (view, UNION_ST) ||\n\t\tST_P (view, UNION_ALL_ST) ||\n\t\tST_P (view, EXCEPT_ST) ||\n\t\tST_P (view, EXCEPT_ALL_ST) ||\n\t\tST_P (view, INTERSECT_ST) ||\n\t\tST_P (view, INTERSECT_ALL_ST))\n\t      {\n\t\tview = sqlp_view_def (NULL, view, 1);\n\t\tview = sqlc_union_dt_wrap (view);\n\t      }\n\t    sqlo_scope (so, &view);\n\t    if (ST_P (view, SELECT_STMT))\n\t      {\n\t\tot = (op_table_t *) so->so_tables->data;\n\t\tot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name;\n\t\tsco_add_table (so->so_scope, ot);\n\t      }\n\t    else\n\t      {\n\t\tt_NEW_VARZ (op_table_t, ot2);\n\t\tmemset (ot2, 0, sizeof (op_table_t));\n\t\tot = ot2;\n\t\tot->ot_dt = view;\n\t\tot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name;\n\t\tot->ot_new_prefix = sqlo_new_prefix (so);\n\t\tot->ot_left_sel = sqlp_union_tree_select (view);\n\t\tif (ST_P (view, PROC_TABLE))\n\t\t  {\n\t\t    sqlo_proc_table_cols (so, ot);\n\t\t    ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts);\n\t\t    ot->ot_is_proc_view = 1;\n\t\t  }\n\t\tsco_add_table (so->so_scope, ot);\n\t\tt_set_push (&so->so_tables, (void*) ot);\n\n\t      }\n\t    sqlo_rls_add_condition (so, ot, res, tb);\n\t    *tree_ret = (ST*) t_list (3, DERIVED_TABLE, ot->ot_dt, ot->ot_new_prefix);\n\t  }\n\tbreak;\n      }\n    case JOINED_TABLE:\n      {\n\tsql_scope_t *old_sco = so->so_scope;\n\tTNEW (sql_scope_t, sco);\n\top_table_t *right_ot, *left_ot;\n\ts_node_t *ptr;\n\tST *j_right;\n\tdk_set_t res_jt = NULL;\n\tint is_jtc, is_natural = (tree->_.join.is_natural &&\n\t    (!tree->_.join.cond || tree->_.join.cond == (ST *) STAR));\n\n\n\tmemset (sco, 0, sizeof (sql_scope_t));\n\tsco->sco_so = so;\n\tsco->sco_fun_refs_allowed = old_sco->sco_fun_refs_allowed;\n\tsco->sco_super = so->so_scope->sco_super;\n\tso->so_scope = sco;\n\n\tif (OJ_RIGHT == tree->_.join.type)\n\t  {\n\t    ST * tmp = tree->_.join.left;\n\t    tree->_.join.left = tree->_.join.right;\n\t    tree->_.join.right = tmp;\n\t    tree->_.join.type = OJ_LEFT;\n\t  }\n\tj_right = tree->_.join.left;\n\twhile (ST_P (j_right, TABLE_REF))\n\t  j_right = j_right->_.table_ref.table;\n\tis_jtc = ST_P (j_right, JOINED_TABLE);\n\tif (tree->_.join.type == OJ_FULL)\n\t  sco->sco_has_jt = 1;\n\tif (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)))\n\t  sco->sco_has_jt = 1;\n\tj_right = tree->_.join.right;\n\twhile (ST_P (j_right, TABLE_REF))\n\t  j_right = j_right->_.table_ref.table;\n\tis_jtc = ST_P (j_right, JOINED_TABLE);\n\tif (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)))\n\t  sco->sco_has_jt = 1;\n\tsqlo_add_table_ref (so, &tree->_.join.left, res);\n\tleft_ot = (op_table_t *) so->so_tables->data;\n\tsqlo_add_table_ref (so, &tree->_.join.right, is_jtc ? &res_jt : res);\n\tright_ot = (op_table_t *) so->so_tables->data;\n\tsqlo_natural_join_cond (so, left_ot, right_ot, tree);\n\tsqlo_scope (so, &(tree->_.join.cond));\n\t/* can be that the right subtree in a ij ends with oj in which case the right ot will be flagged outer. The cond in this case goes to to the top where, i.e. res, not to the join cond of the outer (optional) ot */\nif (J_INNER == tree->_.join.type && right_ot->ot_is_outer)\n  \t  t_st_and (&right_ot->ot_enclosing_where_cond, tree->_.join.cond); /*always ste, even if some joins may be made into dts later*/\n\n\telse\n\t  t_st_and (&right_ot->ot_join_cond, tree->_.join.cond); /*always ste, even if some joins may be made into dts later*/\n\tsco_merge (old_sco, sco);\n\tso->so_scope = old_sco;\n\tif (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)\n\t  right_ot->ot_is_outer = 1;\n\telse if (!sco->sco_has_jt && tree->_.join.type == J_INNER &&\n\t    !ST_P (left_ot->ot_dt, PROC_TABLE) &&\n\t    !ST_P (right_ot->ot_dt, PROC_TABLE))\n\t  {\n\t    t_set_push (res, tree);\n\t    break;\n\t  }\n\tbreak;\n      }\n    case DERIVED_TABLE:\n      {\n\top_table_t * ot;\n\tsqlo_scope (so, &(tree->_.table_ref.table));\n\tif (ST_P (tree->_.table_ref.table, SELECT_STMT))\n\t  {\n\t    ot = (op_table_t *) so->so_tables->data;\n\t    ot->ot_prefix = tree->_.table_ref.range;\n\t    tree->_.table_ref.range = ot->ot_new_prefix;\n/*\t    t_set_push (res, (void *) ot);*/\n\t    sco_add_table (so->so_scope, ot);\n\t    if (ot->ot_trans)\n\t      sqlo_trans_cols (so, ot);\n\t  }\n\telse\n\t  {\n\t    op_table_t *old_ot = so->so_tables ? (op_table_t *) so->so_tables->data : NULL;\n\t    t_NEW_VARZ (op_table_t, ot);\n\t    ot->ot_prefix = tree->_.table_ref.range;\n\t    ot->ot_dt = tree->_.table_ref.table;\n\t    ot->ot_new_prefix = sqlo_new_prefix (so);\n\t    tree->_.table_ref.range = ot->ot_new_prefix;\n\t    if (old_ot)\n\t      ot->ot_left_sel = old_ot->ot_left_sel;\n\t    else\n\t      ot->ot_left_sel = sqlp_union_tree_select (tree->_.table_ref.table);\n\t    if (ST_P (tree->_.table_ref.table, PROC_TABLE))\n\t      sqlo_proc_table_cols (so, ot);\n/*\t    t_set_push (res, (void *) ot);*/\n\t    sco_add_table (so->so_scope, ot);\n\t    t_set_push (&so->so_tables, (void*) ot);\n\t  }\n\tbreak;\n      }\n    }\n}",
        "func": "void\nsqlo_add_table_ref (sqlo_t * so, ST ** tree_ret, dk_set_t *res)\n{\n  char tmp[10];\n  ST * tree = *tree_ret;\n  switch (tree->type)\n    {\n    case TABLE_REF:\n      {\n\tST * prev = tree->_.table_ref.table;\n\tif (ST_P (prev, SELECT_STMT))\n\t  {\n\t    tree->type = DERIVED_TABLE;\n\t    sqlp_view_def (NULL, tree->_.table_ref.table, 0);\n\t    sqlo_add_table_ref (so, tree_ret, res);\n\t    return;\n\t  }\n\tsqlo_add_table_ref (so, &tree->_.table_ref.table, res);\n\tif (prev != tree->_.table_ref.table)\n\t  *tree_ret = tree->_.table_ref.table;\n\tbreak;\n      }\n    case TABLE_DOTTED:\n      {\n\tST * with_view = sqlo_with_decl (so, tree);\n\tdbe_table_t *tb = with_view ? NULL : sch_name_to_table (wi_inst.wi_schema, tree->_.table.name);\n\tST * view;\n\tif (!tb && !with_view)\n\t  sqlc_error (so->so_sc->sc_cc, \"S0002\", \"No table %s\", tree->_.table.name);\n\tif (inside_view)\n\t  tree->_.table.name = t_box_copy (tb->tb_name);\n\tif (!with_view)\n\t  {\n\t    sqlc_table_used (so->so_sc, tb);\n\t    view = (ST*) sch_view_def (wi_inst.wi_schema, tb->tb_name);\n\t  }\n\telse\n\t  view = with_view;\n\tif (!view || inside_view)\n\t  {\n\t    remote_table_t * rt = find_remote_table (tb->tb_name, 0);\n\t    t_NEW_VARZ (op_table_t, ot);\n\t    ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts);\n\t    ot->ot_prefix = tree->_.table.prefix;\n\t    snprintf (tmp, sizeof (tmp), \"t%d\", so->so_name_ctr++);\n\t    ot->ot_new_prefix = t_box_string (tmp);\n\t    tree->_.table.prefix = ot->ot_new_prefix;\n\t    ot->ot_table = tb;\n\t    ot->ot_rds = rt ? rt->rt_rds : NULL;\n\t    ot->ot_u_id = (oid_t) unbox (tree->_.table.u_id);\n\t    ot->ot_g_id = (oid_t) unbox (tree->_.table.g_id);\n\t    if (ST_P (view, PROC_TABLE))\n\t      {\n\t\tot->ot_dt = view;\n\t\tsqlo_proc_table_cols (so, ot);\n\t\tot->ot_dt = NULL;\n\t\tot->ot_is_proc_view = 1;\n\t      }\n\t    sqlo_rls_add_condition (so, ot, res, tb);\n\t    t_set_push (&so->so_tables, (void*) ot);\n\t    sco_add_table (so->so_scope, ot);\n\t  }\n\telse\n\t  {\n\t    op_table_t * ot = NULL;\n\t    if (!with_view && !sec_tb_check (tb, (oid_t) unbox (tree->_.table.g_id), (oid_t) unbox (tree->_.table.u_id), GR_SELECT))\n\t      sqlc_new_error (so->so_sc->sc_cc, \"42000\", \"SQ070:SECURITY\", \"Must have select privileges on view %s\", tb->tb_name);\n\t    view = (ST*) t_box_copy_tree ((caddr_t) view);\n\t    if (ST_P (view, UNION_ST) ||\n\t\tST_P (view, UNION_ALL_ST) ||\n\t\tST_P (view, EXCEPT_ST) ||\n\t\tST_P (view, EXCEPT_ALL_ST) ||\n\t\tST_P (view, INTERSECT_ST) ||\n\t\tST_P (view, INTERSECT_ALL_ST))\n\t      {\n\t\tview = sqlp_view_def (NULL, view, 1);\n\t\tview = sqlc_union_dt_wrap (so->so_sc, view);\n\t      }\n\t    sqlo_scope (so, &view);\n\t    if (ST_P (view, SELECT_STMT))\n\t      {\n\t\tot = (op_table_t *) so->so_tables->data;\n\t\tot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name;\n\t\tsco_add_table (so->so_scope, ot);\n\t      }\n\t    else\n\t      {\n\t\tt_NEW_VARZ (op_table_t, ot2);\n\t\tmemset (ot2, 0, sizeof (op_table_t));\n\t\tot = ot2;\n\t\tot->ot_dt = view;\n\t\tot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name;\n\t\tot->ot_new_prefix = sqlo_new_prefix (so);\n\t\tot->ot_left_sel = sqlp_union_tree_select (view);\n\t\tif (ST_P (view, PROC_TABLE))\n\t\t  {\n\t\t    sqlo_proc_table_cols (so, ot);\n\t\t    ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts);\n\t\t    ot->ot_is_proc_view = 1;\n\t\t  }\n\t\tsco_add_table (so->so_scope, ot);\n\t\tt_set_push (&so->so_tables, (void*) ot);\n\n\t      }\n\t    sqlo_rls_add_condition (so, ot, res, tb);\n\t    *tree_ret = (ST*) t_list (3, DERIVED_TABLE, ot->ot_dt, ot->ot_new_prefix);\n\t  }\n\tbreak;\n      }\n    case JOINED_TABLE:\n      {\n\tsql_scope_t *old_sco = so->so_scope;\n\tTNEW (sql_scope_t, sco);\n\top_table_t *right_ot, *left_ot;\n\ts_node_t *ptr;\n\tST *j_right;\n\tdk_set_t res_jt = NULL;\n\tint is_jtc, is_natural = (tree->_.join.is_natural &&\n\t    (!tree->_.join.cond || tree->_.join.cond == (ST *) STAR));\n\n\n\tmemset (sco, 0, sizeof (sql_scope_t));\n\tsco->sco_so = so;\n\tsco->sco_fun_refs_allowed = old_sco->sco_fun_refs_allowed;\n\tsco->sco_super = so->so_scope->sco_super;\n\tso->so_scope = sco;\n\n\tif (OJ_RIGHT == tree->_.join.type)\n\t  {\n\t    ST * tmp = tree->_.join.left;\n\t    tree->_.join.left = tree->_.join.right;\n\t    tree->_.join.right = tmp;\n\t    tree->_.join.type = OJ_LEFT;\n\t  }\n\tj_right = tree->_.join.left;\n\twhile (ST_P (j_right, TABLE_REF))\n\t  j_right = j_right->_.table_ref.table;\n\tis_jtc = ST_P (j_right, JOINED_TABLE);\n\tif (tree->_.join.type == OJ_FULL)\n\t  sco->sco_has_jt = 1;\n\tif (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)))\n\t  sco->sco_has_jt = 1;\n\tj_right = tree->_.join.right;\n\twhile (ST_P (j_right, TABLE_REF))\n\t  j_right = j_right->_.table_ref.table;\n\tis_jtc = ST_P (j_right, JOINED_TABLE);\n\tif (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)))\n\t  sco->sco_has_jt = 1;\n\tsqlo_add_table_ref (so, &tree->_.join.left, res);\n\tleft_ot = (op_table_t *) so->so_tables->data;\n\tsqlo_add_table_ref (so, &tree->_.join.right, is_jtc ? &res_jt : res);\n\tright_ot = (op_table_t *) so->so_tables->data;\n\tsqlo_natural_join_cond (so, left_ot, right_ot, tree);\n\tsqlo_scope (so, &(tree->_.join.cond));\n\t/* can be that the right subtree in a ij ends with oj in which case the right ot will be flagged outer. The cond in this case goes to to the top where, i.e. res, not to the join cond of the outer (optional) ot */\nif (J_INNER == tree->_.join.type && right_ot->ot_is_outer)\n  \t  t_st_and (&right_ot->ot_enclosing_where_cond, tree->_.join.cond); /*always ste, even if some joins may be made into dts later*/\n\n\telse\n\t  t_st_and (&right_ot->ot_join_cond, tree->_.join.cond); /*always ste, even if some joins may be made into dts later*/\n\tsco_merge (old_sco, sco);\n\tso->so_scope = old_sco;\n\tif (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)\n\t  right_ot->ot_is_outer = 1;\n\telse if (!sco->sco_has_jt && tree->_.join.type == J_INNER &&\n\t    !ST_P (left_ot->ot_dt, PROC_TABLE) &&\n\t    !ST_P (right_ot->ot_dt, PROC_TABLE))\n\t  {\n\t    t_set_push (res, tree);\n\t    break;\n\t  }\n\tbreak;\n      }\n    case DERIVED_TABLE:\n      {\n\top_table_t * ot;\n\tsqlo_scope (so, &(tree->_.table_ref.table));\n\tif (ST_P (tree->_.table_ref.table, SELECT_STMT))\n\t  {\n\t    ot = (op_table_t *) so->so_tables->data;\n\t    ot->ot_prefix = tree->_.table_ref.range;\n\t    tree->_.table_ref.range = ot->ot_new_prefix;\n/*\t    t_set_push (res, (void *) ot);*/\n\t    sco_add_table (so->so_scope, ot);\n\t    if (ot->ot_trans)\n\t      sqlo_trans_cols (so, ot);\n\t  }\n\telse\n\t  {\n\t    op_table_t *old_ot = so->so_tables ? (op_table_t *) so->so_tables->data : NULL;\n\t    t_NEW_VARZ (op_table_t, ot);\n\t    ot->ot_prefix = tree->_.table_ref.range;\n\t    ot->ot_dt = tree->_.table_ref.table;\n\t    ot->ot_new_prefix = sqlo_new_prefix (so);\n\t    tree->_.table_ref.range = ot->ot_new_prefix;\n\t    if (old_ot)\n\t      ot->ot_left_sel = old_ot->ot_left_sel;\n\t    else\n\t      ot->ot_left_sel = sqlp_union_tree_select (tree->_.table_ref.table);\n\t    if (ST_P (tree->_.table_ref.table, PROC_TABLE))\n\t      sqlo_proc_table_cols (so, ot);\n/*\t    t_set_push (res, (void *) ot);*/\n\t    sco_add_table (so->so_scope, ot);\n\t    t_set_push (&so->so_tables, (void*) ot);\n\t  }\n\tbreak;\n      }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -74,7 +74,7 @@\n \t\tST_P (view, INTERSECT_ALL_ST))\n \t      {\n \t\tview = sqlp_view_def (NULL, view, 1);\n-\t\tview = sqlc_union_dt_wrap (view);\n+\t\tview = sqlc_union_dt_wrap (so->so_sc, view);\n \t      }\n \t    sqlo_scope (so, &view);\n \t    if (ST_P (view, SELECT_STMT))",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tview = sqlc_union_dt_wrap (view);"
            ],
            "added_lines": [
                "\t\tview = sqlc_union_dt_wrap (so->so_sc, view);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31618",
        "func_name": "openlink/virtuoso-opensource/sqlo_expand_jts",
        "description": "An issue in the sqlc_union_dt_wrap component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/030e47a29976709a50603e3f34e82278e5f462df",
        "commit_title": "Fixed non-terminal in union branch is not supported (fixes #1136)",
        "commit_text": "",
        "func_before": "int\nsqlo_expand_jts (sqlo_t *so, ST **ptree, ST *select_stmt, int was_top)\n{\n  int res = 0;\n  ST *tree = *ptree;\n  if (THR_IS_STACK_OVERFLOW (THREAD_CURRENT_THREAD, &tree, 8000))\n    sqlc_error (so->so_sc->sc_cc, \".....\", \"Stack Overflow\");\n  if (DK_MEM_RESERVE)\n    sqlc_error (so->so_sc->sc_cc, \".....\", \"Out of memory\");\n  if (ST_P (tree, SELECT_STMT))\n    {\n      res += sqlo_expand_jts (so, &tree->_.select_stmt.table_exp, tree, select_stmt ? 0 : 1);\n      res += sqlo_expand_jts (so, (ST **) &tree->_.select_stmt.selection, tree, select_stmt ? 0 : 1);\n    }\n  else if (ST_P (tree, TABLE_REF) &&\n      ST_P (tree->_.table_ref.table, JOINED_TABLE) &&\n      tree->_.table_ref.table->_.join.type == OJ_FULL &&\n      !tree->_.table_ref.range)\n    { /* need to add an alias for the table as it'll be changed to select */\n      char buffer[20];\n      ST *left;\n      caddr_t jtm_prefix;\n\n      snprintf (buffer, sizeof (buffer), \"fjtc%d\", so->so_name_ctr++);\n      jtm_prefix = tree->_.table_ref.range = t_box_string (buffer);\n      res += sqlo_expand_jts (so, &tree->_.table_ref.table, select_stmt, was_top);\n      left = sqlp_union_tree_select (tree->_.table_ref.table->_.select_stmt.table_exp->_.table_exp.from[0]->_.table_ref.table);\n      sqlo_jt_replace_col_refs (&select_stmt, jtm_prefix,\n\t  (ST **)left->_.select_stmt.selection, tree, 0);\n      if (was_top)\n\t{\n\t  int inx;\n\t  ST **sel = (ST **)left->_.select_stmt.selection;\n\t  DO_BOX (ST *, sel_exp, inx, select_stmt->_.select_stmt.selection)\n\t    {\n\t      if (ST_COLUMN (sel_exp, COL_DOTTED) &&\n\t\t  !CASEMODESTRCMP (sel_exp->_.col_ref.prefix, jtm_prefix))\n\t\t{\n\t\t  int col_inx = atoi (sel_exp->_.col_ref.name + 5);\n\t\t  if (!col_inx || col_inx > BOX_ELEMENTS_INT (sel))\n\t\t    GPF_T1 (\"an unknown column detected in jt\");\n\t\t  ((ST **)select_stmt->_.select_stmt.selection)[inx] =\n\t\t      t_listst (5, BOP_AS, sel_exp, NULL,\n\t\t\t  sel[col_inx - 1]->_.as_exp.left->_.col_ref.name, NULL);\n\t\t}\n\t    }\n\t  END_DO_BOX;\n\t}\n    }\n  else if (ST_P (tree, JOINED_TABLE) && select_stmt)\n    {\n      res += sqlo_expand_jts (so, &tree->_.join.left, select_stmt, was_top);\n      res += sqlo_expand_jts (so, &tree->_.join.right, select_stmt, was_top);\n      if (0 == res && (J_INNER == tree->_.join.type || J_CROSS == tree->_.join.type))\n\treturn res;\n      if (OJ_LEFT != tree->_.join.type)\n\tres += sqlo_jt_dt_wrap (so, &tree->_.join.left, select_stmt, was_top, 1);\n      if (OJ_RIGHT != tree->_.join.type)\n\tres += sqlo_jt_dt_wrap (so, &tree->_.join.right, select_stmt, was_top, 1);\n\n      if (tree->_.join.type == OJ_FULL)\n\t{\n\t  ST *left_oj_tree = (ST *) t_box_copy_tree ((caddr_t) tree);\n\t  ST *right_oj_tree = (ST *) t_box_copy_tree ((caddr_t) tree);\n\n\t  left_oj_tree->_.join.type = OJ_LEFT;\n\t  right_oj_tree->_.join.type = OJ_RIGHT;\n\n\t  res += sqlo_jt_dt_wrap (so, &left_oj_tree, select_stmt, 1, 0);\n\t  res += sqlo_jt_dt_wrap (so, &right_oj_tree, select_stmt, 1, 0);\n\n\t  *ptree = t_listst (5, UNION_ST, left_oj_tree->_.table_ref.table,\n\t      right_oj_tree->_.table_ref.table, NULL, 0);\n\t  *ptree = sqlc_union_dt_wrap (*ptree);\n\t  res ++;\n\t}\n    }\n  else if (ST_P (tree, CALL_STMT))\n    {\n      int inx;\n      DO_BOX (ST *, par, inx, tree->_.call.params)\n\t{\n\t  res += sqlo_expand_jts (so, &par, select_stmt, was_top);\n\t}\n      END_DO_BOX;\n    }\n  else if (ST_P (tree, COALESCE_EXP) ||\n      ST_P (tree, SIMPLE_CASE) ||\n      ST_P (tree, SEARCHED_CASE) ||\n      ST_P (tree, COMMA_EXP))\n    {\n      int inx;\n      _DO_BOX (inx, tree->_.comma_exp.exps)\n\t{\n\t  res += sqlo_expand_jts (so, &(tree->_.comma_exp.exps[inx]), select_stmt, was_top);\n\t}\n      END_DO_BOX;\n    }\n  else if (ARRAYP (tree))\n    {\n      int inx;\n      for (inx = 0; inx < BOX_ELEMENTS_INT (tree); inx++)\n\tres += sqlo_expand_jts (so, &(((ST **)tree)[inx]), select_stmt, was_top);\n    }\n  return res;\n}",
        "func": "int\nsqlo_expand_jts (sqlo_t *so, ST **ptree, ST *select_stmt, int was_top)\n{\n  int res = 0;\n  ST *tree = *ptree;\n  if (THR_IS_STACK_OVERFLOW (THREAD_CURRENT_THREAD, &tree, 8000))\n    sqlc_error (so->so_sc->sc_cc, \".....\", \"Stack Overflow\");\n  if (DK_MEM_RESERVE)\n    sqlc_error (so->so_sc->sc_cc, \".....\", \"Out of memory\");\n  if (ST_P (tree, SELECT_STMT))\n    {\n      res += sqlo_expand_jts (so, &tree->_.select_stmt.table_exp, tree, select_stmt ? 0 : 1);\n      res += sqlo_expand_jts (so, (ST **) &tree->_.select_stmt.selection, tree, select_stmt ? 0 : 1);\n    }\n  else if (ST_P (tree, TABLE_REF) &&\n      ST_P (tree->_.table_ref.table, JOINED_TABLE) &&\n      tree->_.table_ref.table->_.join.type == OJ_FULL &&\n      !tree->_.table_ref.range)\n    { /* need to add an alias for the table as it'll be changed to select */\n      char buffer[20];\n      ST *left;\n      caddr_t jtm_prefix;\n\n      snprintf (buffer, sizeof (buffer), \"fjtc%d\", so->so_name_ctr++);\n      jtm_prefix = tree->_.table_ref.range = t_box_string (buffer);\n      res += sqlo_expand_jts (so, &tree->_.table_ref.table, select_stmt, was_top);\n      left = sqlp_union_tree_select (tree->_.table_ref.table->_.select_stmt.table_exp->_.table_exp.from[0]->_.table_ref.table);\n      sqlo_jt_replace_col_refs (&select_stmt, jtm_prefix,\n\t  (ST **)left->_.select_stmt.selection, tree, 0);\n      if (was_top)\n\t{\n\t  int inx;\n\t  ST **sel = (ST **)left->_.select_stmt.selection;\n\t  DO_BOX (ST *, sel_exp, inx, select_stmt->_.select_stmt.selection)\n\t    {\n\t      if (ST_COLUMN (sel_exp, COL_DOTTED) &&\n\t\t  !CASEMODESTRCMP (sel_exp->_.col_ref.prefix, jtm_prefix))\n\t\t{\n\t\t  int col_inx = atoi (sel_exp->_.col_ref.name + 5);\n\t\t  if (!col_inx || col_inx > BOX_ELEMENTS_INT (sel))\n\t\t    GPF_T1 (\"an unknown column detected in jt\");\n\t\t  ((ST **)select_stmt->_.select_stmt.selection)[inx] =\n\t\t      t_listst (5, BOP_AS, sel_exp, NULL,\n\t\t\t  sel[col_inx - 1]->_.as_exp.left->_.col_ref.name, NULL);\n\t\t}\n\t    }\n\t  END_DO_BOX;\n\t}\n    }\n  else if (ST_P (tree, JOINED_TABLE) && select_stmt)\n    {\n      res += sqlo_expand_jts (so, &tree->_.join.left, select_stmt, was_top);\n      res += sqlo_expand_jts (so, &tree->_.join.right, select_stmt, was_top);\n      if (0 == res && (J_INNER == tree->_.join.type || J_CROSS == tree->_.join.type))\n\treturn res;\n      if (OJ_LEFT != tree->_.join.type)\n\tres += sqlo_jt_dt_wrap (so, &tree->_.join.left, select_stmt, was_top, 1);\n      if (OJ_RIGHT != tree->_.join.type)\n\tres += sqlo_jt_dt_wrap (so, &tree->_.join.right, select_stmt, was_top, 1);\n\n      if (tree->_.join.type == OJ_FULL)\n\t{\n\t  ST *left_oj_tree = (ST *) t_box_copy_tree ((caddr_t) tree);\n\t  ST *right_oj_tree = (ST *) t_box_copy_tree ((caddr_t) tree);\n\n\t  left_oj_tree->_.join.type = OJ_LEFT;\n\t  right_oj_tree->_.join.type = OJ_RIGHT;\n\n\t  res += sqlo_jt_dt_wrap (so, &left_oj_tree, select_stmt, 1, 0);\n\t  res += sqlo_jt_dt_wrap (so, &right_oj_tree, select_stmt, 1, 0);\n\n\t  *ptree = t_listst (5, UNION_ST, left_oj_tree->_.table_ref.table,\n\t      right_oj_tree->_.table_ref.table, NULL, 0);\n\t  *ptree = sqlc_union_dt_wrap (so->so_sc, *ptree);\n\t  res ++;\n\t}\n    }\n  else if (ST_P (tree, CALL_STMT))\n    {\n      int inx;\n      DO_BOX (ST *, par, inx, tree->_.call.params)\n\t{\n\t  res += sqlo_expand_jts (so, &par, select_stmt, was_top);\n\t}\n      END_DO_BOX;\n    }\n  else if (ST_P (tree, COALESCE_EXP) ||\n      ST_P (tree, SIMPLE_CASE) ||\n      ST_P (tree, SEARCHED_CASE) ||\n      ST_P (tree, COMMA_EXP))\n    {\n      int inx;\n      _DO_BOX (inx, tree->_.comma_exp.exps)\n\t{\n\t  res += sqlo_expand_jts (so, &(tree->_.comma_exp.exps[inx]), select_stmt, was_top);\n\t}\n      END_DO_BOX;\n    }\n  else if (ARRAYP (tree))\n    {\n      int inx;\n      for (inx = 0; inx < BOX_ELEMENTS_INT (tree); inx++)\n\tres += sqlo_expand_jts (so, &(((ST **)tree)[inx]), select_stmt, was_top);\n    }\n  return res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -71,7 +71,7 @@\n \n \t  *ptree = t_listst (5, UNION_ST, left_oj_tree->_.table_ref.table,\n \t      right_oj_tree->_.table_ref.table, NULL, 0);\n-\t  *ptree = sqlc_union_dt_wrap (*ptree);\n+\t  *ptree = sqlc_union_dt_wrap (so->so_sc, *ptree);\n \t  res ++;\n \t}\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "\t  *ptree = sqlc_union_dt_wrap (*ptree);"
            ],
            "added_lines": [
                "\t  *ptree = sqlc_union_dt_wrap (so->so_sc, *ptree);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31620",
        "func_name": "openlink/virtuoso-opensource/sqlo_is_seq_in_oby_order",
        "description": "An issue in the dv_compare component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/a4997ed2499c4de8c95e2de9e2a07b60384fbbec",
        "commit_title": "Fixed issue placing simple functions inside control exp (fixes #1128)",
        "commit_text": "",
        "func_before": "int\nsqlo_is_seq_in_oby_order (sqlo_t * so, df_elt_t * dfe, df_elt_t * last_tb)\n{\n  op_table_t * from_ot = so->so_this_dt;\n  int n_ordered = from_ot ? dk_set_length (from_ot->ot_oby_ots) : -1;\n  int n_in_order = 0;\n  for (dfe = dfe; dfe; dfe = dfe->dfe_next)\n    {\n      if (dfe == last_tb)\n\treturn 1;\n      if (dfe->dfe_type == DFE_TABLE)\n\t{\n\t  if (dfe->_.table.hash_role == HR_REF && !dfe->_.table.is_unique)\n\t    return 0;\n\t  if (dfe->_.table.ot->ot_is_outer)\n\t    return 0; /* vectored outer puts all the nulls at the end, not in key order */\n\t  if (! (dfe->_.table.is_oby_order\n\t\t || dfe->_.table.is_unique))\n\t    return 0;\n\t  if (dfe->_.table.is_oby_order)\n\t    {\n\t      n_in_order++;\n\t      if (n_in_order == n_ordered)\n\t\treturn 1;\n\t    }\n\t}\n      else if (DFE_DT == dfe->dfe_type)\n\treturn 0; /* a dfe found before all ordered ones were found */\n    }\n  return 1;\n}",
        "func": "int\nsqlo_is_seq_in_oby_order (sqlo_t * so, df_elt_t * dfe, df_elt_t * last_tb)\n{\n  op_table_t * from_ot = so->so_this_dt;\n  int n_ordered = from_ot ? dk_set_length (from_ot->ot_oby_ots) : -1;\n  int n_in_order = 0;\n  for (; dfe; dfe = dfe->dfe_next)\n    {\n      if (dfe == last_tb)\n\treturn 1;\n      if (dfe->dfe_type == DFE_TABLE)\n\t{\n\t  if (dfe->_.table.hash_role == HR_REF && !dfe->_.table.is_unique)\n\t    return 0;\n\t  if (dfe->_.table.ot->ot_is_outer)\n\t    return 0; /* vectored outer puts all the nulls at the end, not in key order */\n\t  if (! (dfe->_.table.is_oby_order\n\t\t || dfe->_.table.is_unique))\n\t    return 0;\n\t  if (dfe->_.table.is_oby_order)\n\t    {\n\t      n_in_order++;\n\t      if (n_in_order == n_ordered)\n\t\treturn 1;\n\t    }\n\t}\n      else if (DFE_DT == dfe->dfe_type)\n\treturn 0; /* a dfe found before all ordered ones were found */\n    }\n  return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n   op_table_t * from_ot = so->so_this_dt;\n   int n_ordered = from_ot ? dk_set_length (from_ot->ot_oby_ots) : -1;\n   int n_in_order = 0;\n-  for (dfe = dfe; dfe; dfe = dfe->dfe_next)\n+  for (; dfe; dfe = dfe->dfe_next)\n     {\n       if (dfe == last_tb)\n \treturn 1;",
        "diff_line_info": {
            "deleted_lines": [
                "  for (dfe = dfe; dfe; dfe = dfe->dfe_next)"
            ],
            "added_lines": [
                "  for (; dfe; dfe = dfe->dfe_next)"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31620",
        "func_name": "openlink/virtuoso-opensource/sqlo_fun_ref_epilogue",
        "description": "An issue in the dv_compare component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/a4997ed2499c4de8c95e2de9e2a07b60384fbbec",
        "commit_title": "Fixed issue placing simple functions inside control exp (fixes #1128)",
        "commit_text": "",
        "func_before": "void\nsqlo_fun_ref_epilogue (sqlo_t * so, op_table_t * from_ot)\n{\n  int all_cols_p = 0;\n  dk_set_t having_preds = NULL;\n  df_elt_t * group_dfe = from_ot->ot_group_dfe;\n  ST * texp = from_ot->ot_dt->_.select_stmt.table_exp;\n  ST ** group = texp ? texp->_.table_exp.group_by : NULL;\n\n  if (from_ot->ot_invariant_preds && !from_ot->ot_invariant_placed)\n    {\n      df_elt_t * gen_pt = so->so_gen_pt;\n      df_elt_t * filter = sqlo_new_dfe (so, DFE_FILTER, NULL);\n      df_elt_t ** after_test;\n      filter->_.filter.invariant_of_ot = from_ot;\n      from_ot->ot_invariant_placed = 1;\n      so->so_gen_pt = from_ot->ot_work_dfe->_.sub.first;\n      after_test = sqlo_and_list_body (so, LOC_LOCAL, so->so_gen_pt, from_ot->ot_invariant_preds);\n      filter->_.filter.body = after_test;\n      filter->_.filter.preds = from_ot->ot_invariant_preds;\n      sqlo_place_dfe_after  (so, LOC_LOCAL, so->so_gen_pt, filter);\n      so->so_gen_pt = gen_pt;\n    }\n\n  if (!from_ot->ot_fun_refs && !group_dfe)\n    {\n      int is_dist = sqlo_early_distinct (so, from_ot);\n      if (sqlo_is_seq_in_oby_order  (so, from_ot->ot_work_dfe->_.sub.first, NULL))\n\treturn;\n      if (!from_ot->ot_oby_dfe || from_ot->ot_oby_dfe->dfe_is_placed)\n\treturn;\n      if (is_dist)\n\tso->so_place_code_forr_cond = 1;\n      sqlo_place_oby_specs (so, from_ot, from_ot->ot_oby_dfe->_.setp.specs);\n      so->so_place_code_forr_cond = 0;\n      sqlo_place_dfe_after (so, from_ot->ot_work_dfe->dfe_locus, so->so_gen_pt, from_ot->ot_oby_dfe);\n      return;\n    }\n  if (group_dfe)\n    {\n    group_dfe->dfe_locus = from_ot->ot_work_dfe->dfe_locus; /* if dt passed through then group too */\n      group_dfe->_.setp.is_being_placed = 1;\n    }\n  if (group)\n    {\n      int inx;\n      all_cols_p = sqlo_oby_exp_cols (so, from_ot->ot_dt, group);\n      sqlo_place_oby_specs (so, from_ot, group);\n      _DO_BOX (inx, texp->_.table_exp.group_by_full)\n\t{\n\t  sqlo_place_oby_specs (so, from_ot, texp->_.table_exp.group_by_full[inx]);\n\t}\n      END_DO_BOX;\n    }\n  if (from_ot->ot_group_dfe)\n    sqlo_place_dfe_after (so, from_ot->ot_work_dfe->dfe_locus,\n\t\t\t  from_ot->ot_work_dfe->_.sub.last, from_ot->ot_group_dfe);\n  DO_SET (ST *, fref, &from_ot->ot_fun_refs)\n    {\n      df_elt_t * fref_dfe = sqlo_df (so, fref);\n      df_elt_t * arg_dfe = NULL;\n      int locus_to_loclocal = 0;\n      if (AMMSC_USER != fref->_.fn_ref.fn_code)\n\targ_dfe = sqlo_df (so, fref->_.fn_ref.fn_arg);\n/*      if (group_dfe->_.setp.specs\n\t  && fref->_.fn_ref.all_distinct\n\t  && !IS_BOX_POINTER (from_ot->ot_work_dfe->dfe_locus))\n\tsqlc_new_error (so->so_sc->sc_cc, \"37000\", \"SQ111\", \"Distinct not allowed with an aggregate with group by.\");\n*/\n      fref_dfe->dfe_locus = from_ot->ot_work_dfe->dfe_locus;\n      if (AMMSC_USER == fref->_.fn_ref.fn_code)\n\t{\n\t  int argidx;\n\t  DO_BOX_FAST (ST *, arg, argidx, fref->_.fn_ref.fn_arglist)\n\t    {\n\t      df_elt_t * arg_dfe = sqlo_df (so, arg);\n\t      sqlo_place_exp (so, from_ot->ot_work_dfe, arg_dfe);\n\t      if (DFE_CONST != arg_dfe->dfe_type && arg_dfe->dfe_locus != from_ot->ot_work_dfe->dfe_locus)\n\t\tlocus_to_loclocal = 1;\n\t    }\n\t  END_DO_BOX_FAST;\n\t}\n      else\n\t{\n\t  if (IS_BOX_POINTER (from_ot->ot_work_dfe->dfe_locus) &&\n\t      AMMSC_COUNTSUM == fref->_.fn_ref.fn_code &&\n\t      ST_P (fref->_.fn_ref.fn_arg, SEARCHED_CASE))\n\t    {\n\t      ST *stree = fref->_.fn_ref.fn_arg;\n\t      if ((4 == BOX_ELEMENTS (stree->_.comma_exp.exps)) &&\n\t\t  ST_P (stree->_.comma_exp.exps [0], BOP_NULL) &&\n\t\t  ST_P (stree->_.comma_exp.exps [2], QUOTE) &&\n\t\t  (0 == unbox ((box_t) stree->_.comma_exp.exps [1])) &&\n\t\t  (1 == unbox ((box_t) stree->_.comma_exp.exps [3])))\n\t\t{\n\t\t  sqlo_place_exp (so, from_ot->ot_work_dfe,\n\t\t      sqlo_df (so, stree->_.comma_exp.exps [0]->_.bin_exp.left));\n\t\t  arg_dfe->dfe_locus = from_ot->ot_work_dfe->dfe_locus;\n\t\t}\n\t      else\n\t\tsqlo_place_exp (so, from_ot->ot_work_dfe, arg_dfe);\n\t    }\n\t  else\n\t    sqlo_place_exp (so, from_ot->ot_work_dfe, arg_dfe);\n\t  if (fref->_.fn_ref.fn_code == AMMSC_COUNT || fref->_.fn_ref.fn_code == AMMSC_COUNTSUM)\n\t    fref_dfe->dfe_sqt.sqt_dtp = DV_LONG_INT;\n\t  else\n\t    fref_dfe->dfe_sqt = arg_dfe->dfe_sqt;\n\t  if (DFE_CONST != arg_dfe->dfe_type && arg_dfe->dfe_locus != from_ot->ot_work_dfe->dfe_locus)\n\t    locus_to_loclocal = 1;\n\t}\n      if (arg_dfe)\n\tsqlg_find_aggregate_sqt (wi_inst.wi_schema, &(arg_dfe->dfe_sqt), fref, &(fref_dfe->dfe_sqt));\n      if (locus_to_loclocal)\n\t{\n\t  fref_dfe->dfe_locus = LOC_LOCAL;\n\t  group_dfe->dfe_locus = LOC_LOCAL;\n\t}\n      t_set_push (&group_dfe->_.setp.fun_refs, fref);\n    }\n  END_DO_SET();\n  if (group_dfe)\n    group_dfe->_.setp.is_being_placed = 0;\n\n  /* all the predicates not done so far are from the HAVING clause, even if not mentioned in the texp since they could hav been added to the ot from an enclosing context */\n  so->so_gen_pt = from_ot->ot_group_dfe;\n  DO_SET (df_elt_t *, pred, &from_ot->ot_preds)\n    {\n      if (!pred->dfe_is_placed)\n\tt_set_push (&having_preds, (void*) pred);\n    }\n  END_DO_SET();\n  if (having_preds)\n    {\n      df_elt_t * filter;\n      df_elt_t ** after_test = sqlo_and_list_body (so,\n\t\t\t\t\t\t   from_ot->ot_work_dfe ? from_ot->ot_work_dfe->dfe_locus : LOC_LOCAL,\n\t\t\t\t\t\t   from_ot->ot_group_dfe, having_preds);\n      if (enable_dfe_filter)\n\t{\n\t  filter = sqlo_new_dfe (so, DFE_FILTER, NULL);\n\t  filter->_.filter.body = after_test;\n\t  filter->_.filter.preds = having_preds;\n\t  sqlo_place_dfe_after  (so, group_dfe->dfe_locus, so->so_gen_pt,  filter);\n\t}\n      else\n\t{\n\t  group_dfe->_.setp.after_test = after_test;\n\t  group_dfe->_.setp.having_preds = having_preds;\n\t}\n    }\n  if (group_dfe && all_cols_p)\n    group_dfe->_.setp.is_linear = sqlo_is_group_linear (so, from_ot);\n  if (from_ot->ot_oby_dfe)\n    {\n      sqlo_place_oby_specs (so, from_ot, from_ot->ot_oby_dfe->_.setp.specs);\n      if (!from_ot->ot_oby_dfe->dfe_is_placed)\n\tsqlo_place_dfe_after (so, from_ot->ot_work_dfe->dfe_locus,\n\t    so->so_gen_pt->dfe_type == DFE_DT ? so->so_gen_pt->_.sub.last : so->so_gen_pt, from_ot->ot_oby_dfe);\n    }\n}",
        "func": "void\nsqlo_fun_ref_epilogue (sqlo_t * so, op_table_t * from_ot)\n{\n  int all_cols_p = 0;\n  dk_set_t having_preds = NULL;\n  df_elt_t * group_dfe = from_ot->ot_group_dfe;\n  ST * texp = from_ot->ot_dt->_.select_stmt.table_exp;\n  ST ** group = texp ? texp->_.table_exp.group_by : NULL;\n\n  if (from_ot->ot_invariant_preds && !from_ot->ot_invariant_placed)\n    {\n      df_elt_t * gen_pt = so->so_gen_pt;\n      df_elt_t * filter = sqlo_new_dfe (so, DFE_FILTER, NULL);\n      df_elt_t ** after_test;\n      filter->_.filter.invariant_of_ot = from_ot;\n      from_ot->ot_invariant_placed = 1;\n      so->so_gen_pt = from_ot->ot_work_dfe->_.sub.first;\n      after_test = sqlo_and_list_body (so, LOC_LOCAL, so->so_gen_pt, from_ot->ot_invariant_preds);\n      filter->_.filter.body = after_test;\n      filter->_.filter.preds = from_ot->ot_invariant_preds;\n      sqlo_place_dfe_after  (so, LOC_LOCAL, so->so_gen_pt, filter);\n      so->so_gen_pt = gen_pt;\n    }\n\n  if (!from_ot->ot_fun_refs && !group_dfe)\n    {\n      int is_dist = sqlo_early_distinct (so, from_ot);\n      if (sqlo_is_seq_in_oby_order  (so, from_ot->ot_work_dfe->_.sub.first, NULL))\n\treturn;\n      if (!from_ot->ot_oby_dfe || from_ot->ot_oby_dfe->dfe_is_placed)\n\treturn;\n      if (is_dist)\n\tso->so_place_code_forr_cond = 1;\n      sqlo_place_oby_specs (so, from_ot, from_ot->ot_oby_dfe->_.setp.specs);\n      so->so_place_code_forr_cond = 0;\n      sqlo_place_dfe_after (so, from_ot->ot_work_dfe->dfe_locus, so->so_gen_pt, from_ot->ot_oby_dfe);\n      return;\n    }\n  if (group_dfe)\n    {\n    group_dfe->dfe_locus = from_ot->ot_work_dfe->dfe_locus; /* if dt passed through then group too */\n      group_dfe->_.setp.is_being_placed = 1;\n    }\n  if (group)\n    {\n      int inx;\n      all_cols_p = sqlo_oby_exp_cols (so, from_ot->ot_dt, group);\n      sqlo_place_oby_specs (so, from_ot, group);\n      _DO_BOX (inx, texp->_.table_exp.group_by_full)\n\t{\n\t  sqlo_place_oby_specs (so, from_ot, texp->_.table_exp.group_by_full[inx]);\n\t}\n      END_DO_BOX;\n    }\n  if (from_ot->ot_group_dfe)\n    sqlo_place_dfe_after (so, from_ot->ot_work_dfe->dfe_locus,\n\t\t\t  from_ot->ot_work_dfe->_.sub.last, from_ot->ot_group_dfe);\n  DO_SET (ST *, fref, &from_ot->ot_fun_refs)\n    {\n      df_elt_t * fref_dfe = sqlo_df (so, fref);\n      df_elt_t * arg_dfe = NULL;\n      int locus_to_loclocal = 0;\n      if (AMMSC_USER != fref->_.fn_ref.fn_code)\n\targ_dfe = sqlo_df (so, fref->_.fn_ref.fn_arg);\n/*      if (group_dfe->_.setp.specs\n\t  && fref->_.fn_ref.all_distinct\n\t  && !IS_BOX_POINTER (from_ot->ot_work_dfe->dfe_locus))\n\tsqlc_new_error (so->so_sc->sc_cc, \"37000\", \"SQ111\", \"Distinct not allowed with an aggregate with group by.\");\n*/\n      fref_dfe->dfe_locus = from_ot->ot_work_dfe->dfe_locus;\n      if (AMMSC_USER == fref->_.fn_ref.fn_code)\n\t{\n\t  int argidx;\n\t  DO_BOX_FAST (ST *, arg, argidx, fref->_.fn_ref.fn_arglist)\n\t    {\n\t      df_elt_t * arg_dfe = sqlo_df (so, arg);\n\t      sqlo_place_exp (so, from_ot->ot_work_dfe, arg_dfe);\n\t      if (DFE_CONST != arg_dfe->dfe_type && arg_dfe->dfe_locus != from_ot->ot_work_dfe->dfe_locus)\n\t\tlocus_to_loclocal = 1;\n\t    }\n\t  END_DO_BOX_FAST;\n\t}\n      else\n\t{\n\t  if (IS_BOX_POINTER (from_ot->ot_work_dfe->dfe_locus) &&\n\t      AMMSC_COUNTSUM == fref->_.fn_ref.fn_code &&\n\t      ST_P (fref->_.fn_ref.fn_arg, SEARCHED_CASE))\n\t    {\n\t      ST *stree = fref->_.fn_ref.fn_arg;\n\t      if ((4 == BOX_ELEMENTS (stree->_.comma_exp.exps)) &&\n\t\t  ST_P (stree->_.comma_exp.exps [0], BOP_NULL) &&\n\t\t  ST_P (stree->_.comma_exp.exps [2], QUOTE) &&\n\t\t  (0 == unbox ((box_t) stree->_.comma_exp.exps [1])) &&\n\t\t  (1 == unbox ((box_t) stree->_.comma_exp.exps [3])))\n\t\t{\n\t\t  sqlo_place_exp (so, from_ot->ot_work_dfe,\n\t\t      sqlo_df (so, stree->_.comma_exp.exps [0]->_.bin_exp.left));\n\t\t  arg_dfe->dfe_locus = from_ot->ot_work_dfe->dfe_locus;\n\t\t}\n\t      else\n\t\tsqlo_place_exp (so, from_ot->ot_work_dfe, arg_dfe);\n\t    }\n\t  else\n            {\n              char prev = so->so_place_code_forr_cond;\n              if (DFE_VALUE_SUBQ == from_ot->ot_work_dfe->dfe_type && !group) /* simple fref */\n                so->so_place_code_forr_cond = 0;\n              sqlo_place_exp (so, from_ot->ot_work_dfe, arg_dfe);\n              so->so_place_code_forr_cond = prev;\n            }\n\t  if (fref->_.fn_ref.fn_code == AMMSC_COUNT || fref->_.fn_ref.fn_code == AMMSC_COUNTSUM)\n\t    fref_dfe->dfe_sqt.sqt_dtp = DV_LONG_INT;\n\t  else\n\t    fref_dfe->dfe_sqt = arg_dfe->dfe_sqt;\n\t  if (DFE_CONST != arg_dfe->dfe_type && arg_dfe->dfe_locus != from_ot->ot_work_dfe->dfe_locus)\n\t    locus_to_loclocal = 1;\n\t}\n      if (arg_dfe)\n\tsqlg_find_aggregate_sqt (wi_inst.wi_schema, &(arg_dfe->dfe_sqt), fref, &(fref_dfe->dfe_sqt));\n      if (locus_to_loclocal)\n\t{\n\t  fref_dfe->dfe_locus = LOC_LOCAL;\n\t  group_dfe->dfe_locus = LOC_LOCAL;\n\t}\n      t_set_push (&group_dfe->_.setp.fun_refs, fref);\n    }\n  END_DO_SET();\n  if (group_dfe)\n    group_dfe->_.setp.is_being_placed = 0;\n\n  /* all the predicates not done so far are from the HAVING clause, even if not mentioned in the texp since they could hav been added to the ot from an enclosing context */\n  so->so_gen_pt = from_ot->ot_group_dfe;\n  DO_SET (df_elt_t *, pred, &from_ot->ot_preds)\n    {\n      if (!pred->dfe_is_placed)\n\tt_set_push (&having_preds, (void*) pred);\n    }\n  END_DO_SET();\n  if (having_preds)\n    {\n      df_elt_t * filter;\n      df_elt_t ** after_test = sqlo_and_list_body (so,\n\t\t\t\t\t\t   from_ot->ot_work_dfe ? from_ot->ot_work_dfe->dfe_locus : LOC_LOCAL,\n\t\t\t\t\t\t   from_ot->ot_group_dfe, having_preds);\n      if (enable_dfe_filter)\n\t{\n\t  filter = sqlo_new_dfe (so, DFE_FILTER, NULL);\n\t  filter->_.filter.body = after_test;\n\t  filter->_.filter.preds = having_preds;\n\t  sqlo_place_dfe_after  (so, group_dfe->dfe_locus, so->so_gen_pt,  filter);\n\t}\n      else\n\t{\n\t  group_dfe->_.setp.after_test = after_test;\n\t  group_dfe->_.setp.having_preds = having_preds;\n\t}\n    }\n  if (group_dfe && all_cols_p)\n    group_dfe->_.setp.is_linear = sqlo_is_group_linear (so, from_ot);\n  if (from_ot->ot_oby_dfe)\n    {\n      sqlo_place_oby_specs (so, from_ot, from_ot->ot_oby_dfe->_.setp.specs);\n      if (!from_ot->ot_oby_dfe->dfe_is_placed)\n\tsqlo_place_dfe_after (so, from_ot->ot_work_dfe->dfe_locus,\n\t    so->so_gen_pt->dfe_type == DFE_DT ? so->so_gen_pt->_.sub.last : so->so_gen_pt, from_ot->ot_oby_dfe);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -101,7 +101,13 @@\n \t\tsqlo_place_exp (so, from_ot->ot_work_dfe, arg_dfe);\n \t    }\n \t  else\n-\t    sqlo_place_exp (so, from_ot->ot_work_dfe, arg_dfe);\n+            {\n+              char prev = so->so_place_code_forr_cond;\n+              if (DFE_VALUE_SUBQ == from_ot->ot_work_dfe->dfe_type && !group) /* simple fref */\n+                so->so_place_code_forr_cond = 0;\n+              sqlo_place_exp (so, from_ot->ot_work_dfe, arg_dfe);\n+              so->so_place_code_forr_cond = prev;\n+            }\n \t  if (fref->_.fn_ref.fn_code == AMMSC_COUNT || fref->_.fn_ref.fn_code == AMMSC_COUNTSUM)\n \t    fref_dfe->dfe_sqt.sqt_dtp = DV_LONG_INT;\n \t  else",
        "diff_line_info": {
            "deleted_lines": [
                "\t    sqlo_place_exp (so, from_ot->ot_work_dfe, arg_dfe);"
            ],
            "added_lines": [
                "            {",
                "              char prev = so->so_place_code_forr_cond;",
                "              if (DFE_VALUE_SUBQ == from_ot->ot_work_dfe->dfe_type && !group) /* simple fref */",
                "                so->so_place_code_forr_cond = 0;",
                "              sqlo_place_exp (so, from_ot->ot_work_dfe, arg_dfe);",
                "              so->so_place_code_forr_cond = prev;",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31621",
        "func_name": "openlink/virtuoso-opensource/kc_var_col",
        "description": "An issue in the kc_var_col component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/ec54f1c7b50df944ae4a8d3e29cd7eaf1cc97b21",
        "commit_title": "Fixed cannot add non-null column to existing data (fixes #1130)",
        "commit_text": "",
        "func_before": "void\nkc_var_col (dbe_key_t * key, buffer_desc_t * buf, db_buf_t row, dbe_col_loc_t * cl, db_buf_t * p1, row_size_t * l1, db_buf_t * p2, row_size_t* l2, unsigned short * offset)\n{\n  row_ver_t rv = IE_ROW_VERSION (row);\n  int off, len;\n  if (rv & cl->cl_row_version_mask)\n    {\n      int irow = SHORT_REF (row + cl->cl_pos[rv]);\n      row = buf->bd_buffer + buf->bd_content_map->pm_entries[irow & ROW_NO_MASK];\n      rv = IE_ROW_VERSION (row);\n      *offset = ((unsigned short)irow) >> COL_OFFSET_SHIFT;\n    }\n  else\n    *offset = 0;\n  len = cl->cl_pos[rv];\n  if (CL_FIRST_VAR == len)\n    {\n      if (key->key_version != IE_KEY_VERSION (row))\n\tkey = key->key_versions[IE_KEY_VERSION (row)];\n      off = 0 == IE_KEY_VERSION (row) ? key->key_key_var_start[rv] : key->key_row_var_start[rv];\n      len = SHORT_REF (row + key->key_length_area[rv]) - off;\n    }\n  else\n    {\n      len = -len;\n      off = SHORT_REF (row + len) & COL_VAR_LEN_MASK;\n      len = SHORT_REF (row + len + 2) - off;\n    }\n  if (len & COL_VAR_SUFFIX)\n    {\n      unsigned short irow;\n      short pref_len;\n      len &= COL_VAR_LEN_MASK;\n      irow = SHORT_REF_NA (row + off);\n      pref_len = irow >> COL_OFFSET_SHIFT;\n      if (15 == pref_len)\n\t{\n\t  *l1 = row[off + 2];\n\t  *p2 = row + off + 3;\n\t  *l2 = len - 3;\n\t}\n      else\n\t{\n\t  *l1 = pref_len;\n\t  *p2 = row + off + 2;\n\t  *l2 = len - 2;\n\t}\n      if ((irow & ROW_NO_MASK) >= buf->bd_content_map->pm_count)\n\t{\n\t  log_error (\"Row ref %u is out of range %u\", irow, buf->bd_content_map->pm_count);\n\t  GPF_T1 (\"prefix row ref out of pm range\");\n\t}\n      row = buf->bd_buffer + buf->bd_content_map->pm_entries[irow & ROW_NO_MASK];\n      rv = IE_ROW_VERSION (row);\n      /* now row is the row ref'd from the org row.  Get the offset of the col to get the prefix.  Note that if the suffix bit is set, it refers to the previous col, not this one.  To make sure that this col which is supposed not top be prefix compressed is not, look at the next word in the length area. */\n      if (cl->cl_pos[rv] == CL_FIRST_VAR)\n\t{\n\t  off = (0 == IE_KEY_VERSION (row) ? key->key_key_var_start[rv] : key->key_row_var_start[rv]);\n\t}\n      else\n\t{\n\t  off = COL_VAR_LEN_MASK & SHORT_REF (row - cl->cl_pos[rv]);\n\t}\n      *p1 = row + off;\n    }\n  else\n    {\n      *l1 = len;\n      *p1 = row + off;\n      *l2 = 0;\n    }\n}",
        "func": "void\nkc_var_col (dbe_key_t * key, buffer_desc_t * buf, db_buf_t row, dbe_col_loc_t * cl, db_buf_t * p1, row_size_t * l1, db_buf_t * p2, row_size_t* l2, unsigned short * offset)\n{\n  row_ver_t rv = IE_ROW_VERSION (row);\n  int off, len;\n  if (rv & cl->cl_row_version_mask)\n    {\n      int irow = SHORT_REF (row + cl->cl_pos[rv]);\n      row = buf->bd_buffer + buf->bd_content_map->pm_entries[irow & ROW_NO_MASK];\n      rv = IE_ROW_VERSION (row);\n      *offset = ((unsigned short)irow) >> COL_OFFSET_SHIFT;\n    }\n  else\n    *offset = 0;\n  len = cl->cl_pos[rv];\n  if (CL_FIRST_VAR == len)\n    {\n      key_ver_t kv = IE_KEY_VERSION (row);\n      if (KV_LEFT_DUMMY == kv)\n        {\n          dp_addr_t leaf = LONG_REF (row + LD_LEAF);\n          GPF_T1(\"Not supposed to have such layout\");\n        }\n      if (key->key_version != kv)\n\tkey = key->key_versions[IE_KEY_VERSION (row)];\n      off = 0 == IE_KEY_VERSION (row) ? key->key_key_var_start[rv] : key->key_row_var_start[rv];\n      len = SHORT_REF (row + key->key_length_area[rv]) - off;\n    }\n  else\n    {\n      len = -len;\n      off = SHORT_REF (row + len) & COL_VAR_LEN_MASK;\n      len = SHORT_REF (row + len + 2) - off;\n    }\n  if (len & COL_VAR_SUFFIX)\n    {\n      unsigned short irow;\n      short pref_len;\n      len &= COL_VAR_LEN_MASK;\n      irow = SHORT_REF_NA (row + off);\n      pref_len = irow >> COL_OFFSET_SHIFT;\n      if (15 == pref_len)\n\t{\n\t  *l1 = row[off + 2];\n\t  *p2 = row + off + 3;\n\t  *l2 = len - 3;\n\t}\n      else\n\t{\n\t  *l1 = pref_len;\n\t  *p2 = row + off + 2;\n\t  *l2 = len - 2;\n\t}\n      if ((irow & ROW_NO_MASK) >= buf->bd_content_map->pm_count)\n\t{\n\t  log_error (\"Row ref %u is out of range %u\", irow, buf->bd_content_map->pm_count);\n\t  GPF_T1 (\"prefix row ref out of pm range\");\n\t}\n      row = buf->bd_buffer + buf->bd_content_map->pm_entries[irow & ROW_NO_MASK];\n      rv = IE_ROW_VERSION (row);\n      /* now row is the row ref'd from the org row.  Get the offset of the col to get the prefix.  Note that if the suffix bit is set, it refers to the previous col, not this one.  To make sure that this col which is supposed not top be prefix compressed is not, look at the next word in the length area. */\n      if (cl->cl_pos[rv] == CL_FIRST_VAR)\n\t{\n\t  off = (0 == IE_KEY_VERSION (row) ? key->key_key_var_start[rv] : key->key_row_var_start[rv]);\n\t}\n      else\n\t{\n\t  off = COL_VAR_LEN_MASK & SHORT_REF (row - cl->cl_pos[rv]);\n\t}\n      *p1 = row + off;\n    }\n  else\n    {\n      *l1 = len;\n      *p1 = row + off;\n      *l2 = 0;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,13 @@\n   len = cl->cl_pos[rv];\n   if (CL_FIRST_VAR == len)\n     {\n-      if (key->key_version != IE_KEY_VERSION (row))\n+      key_ver_t kv = IE_KEY_VERSION (row);\n+      if (KV_LEFT_DUMMY == kv)\n+        {\n+          dp_addr_t leaf = LONG_REF (row + LD_LEAF);\n+          GPF_T1(\"Not supposed to have such layout\");\n+        }\n+      if (key->key_version != kv)\n \tkey = key->key_versions[IE_KEY_VERSION (row)];\n       off = 0 == IE_KEY_VERSION (row) ? key->key_key_var_start[rv] : key->key_row_var_start[rv];\n       len = SHORT_REF (row + key->key_length_area[rv]) - off;",
        "diff_line_info": {
            "deleted_lines": [
                "      if (key->key_version != IE_KEY_VERSION (row))"
            ],
            "added_lines": [
                "      key_ver_t kv = IE_KEY_VERSION (row);",
                "      if (KV_LEFT_DUMMY == kv)",
                "        {",
                "          dp_addr_t leaf = LONG_REF (row + LD_LEAF);",
                "          GPF_T1(\"Not supposed to have such layout\");",
                "        }",
                "      if (key->key_version != kv)"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31621",
        "func_name": "openlink/virtuoso-opensource/ddl_add_col",
        "description": "An issue in the kc_var_col component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/ec54f1c7b50df944ae4a8d3e29cd7eaf1cc97b21",
        "commit_title": "Fixed cannot add non-null column to existing data (fixes #1130)",
        "commit_text": "",
        "func_before": "void\nddl_add_col (query_instance_t * qi, const char *table, caddr_t * col, int if_not_exists)\n{\n  caddr_t err;\n  static query_t *add_col_proc;\n  client_connection_t *cli = qi->qi_client;\n  dbe_column_t *col_ref;\n  dbe_table_t *tb = qi_name_to_table (qi, table);\n\n  if (!add_col_proc)\n    add_col_proc = sql_compile_static (\"DB.DBA.add_col (?, ?,?)\",\n\tbootstrap_cli, &err, SQLC_DEFAULT);\n  if (!tb)\n    sqlr_new_error (\"42S02\", \"SQ018\", \"No table %s.\", table);\n  sql_error_if_remote_table (tb);\n  col_ref = tb_name_to_column (tb, col[0]);\n  if (col_ref && if_not_exists)\n    return;\n  AS_DBA (qi, err = qr_rec_exec (add_col_proc, cli, NULL, qi, NULL, 3,\n      \":0\", (0 == strcmp (tb->tb_name, \"DB.DBA.SYS_TRIGGERS\")) ? \"SYS_TRIGGERS\" : tb->tb_name, QRP_STR,\n      \":1\", col[0], QRP_STR,\n\t\t\t     \":2\", box_copy_tree ((caddr_t) col), QRP_RAW));\n\n  if (err != SQL_SUCCESS)\n    {\n      QI_POISON_TRX (qi);\t/* schema could be inconsistent, do not commit */\n      sqlr_resignal (err);\n    }\n}",
        "func": "void\nddl_add_col (query_instance_t * qi, const char *table, caddr_t * col, int if_not_exists)\n{\n  caddr_t err;\n  static query_t *add_col_proc;\n  client_connection_t *cli = qi->qi_client;\n  dbe_column_t *col_ref;\n  dbe_table_t *tb = qi_name_to_table (qi, table);\n  int not_empty;\n\n  if (!add_col_proc)\n    add_col_proc = sql_compile_static (\"DB.DBA.add_col (?, ?,?)\",\n\tbootstrap_cli, &err, SQLC_DEFAULT);\n  if (!tb)\n    sqlr_new_error (\"42S02\", \"SQ018\", \"No table %s.\", table);\n  sql_error_if_remote_table (tb);\n  col_ref = tb_name_to_column (tb, col[0]);\n  if (col_ref && if_not_exists)\n    return;\n  not_empty = count_exceed (qi, tb->tb_name, 0, NULL);\n  if (not_empty && ddl_col_opt_set (col, (caddr_t)(ptrlong)COL_NOT_NULL) && !ddl_col_opt_set (col, (caddr_t)(ptrlong)COL_DEFAULT))\n    sqlr_new_error (\"42000\", \"SQ018\", \"column '%s' of table '%s' contains null values\", col[0], table);\n  AS_DBA (qi, err = qr_rec_exec (add_col_proc, cli, NULL, qi, NULL, 3,\n      \":0\", (0 == strcmp (tb->tb_name, \"DB.DBA.SYS_TRIGGERS\")) ? \"SYS_TRIGGERS\" : tb->tb_name, QRP_STR,\n      \":1\", col[0], QRP_STR,\n      \":2\", box_copy_tree ((caddr_t) col), QRP_RAW));\n\n  if (err != SQL_SUCCESS)\n    {\n      QI_POISON_TRX (qi);\t/* schema could be inconsistent, do not commit */\n      sqlr_resignal (err);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,7 @@\n   client_connection_t *cli = qi->qi_client;\n   dbe_column_t *col_ref;\n   dbe_table_t *tb = qi_name_to_table (qi, table);\n+  int not_empty;\n \n   if (!add_col_proc)\n     add_col_proc = sql_compile_static (\"DB.DBA.add_col (?, ?,?)\",\n@@ -16,10 +17,13 @@\n   col_ref = tb_name_to_column (tb, col[0]);\n   if (col_ref && if_not_exists)\n     return;\n+  not_empty = count_exceed (qi, tb->tb_name, 0, NULL);\n+  if (not_empty && ddl_col_opt_set (col, (caddr_t)(ptrlong)COL_NOT_NULL) && !ddl_col_opt_set (col, (caddr_t)(ptrlong)COL_DEFAULT))\n+    sqlr_new_error (\"42000\", \"SQ018\", \"column '%s' of table '%s' contains null values\", col[0], table);\n   AS_DBA (qi, err = qr_rec_exec (add_col_proc, cli, NULL, qi, NULL, 3,\n       \":0\", (0 == strcmp (tb->tb_name, \"DB.DBA.SYS_TRIGGERS\")) ? \"SYS_TRIGGERS\" : tb->tb_name, QRP_STR,\n       \":1\", col[0], QRP_STR,\n-\t\t\t     \":2\", box_copy_tree ((caddr_t) col), QRP_RAW));\n+      \":2\", box_copy_tree ((caddr_t) col), QRP_RAW));\n \n   if (err != SQL_SUCCESS)\n     {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t     \":2\", box_copy_tree ((caddr_t) col), QRP_RAW));"
            ],
            "added_lines": [
                "  int not_empty;",
                "  not_empty = count_exceed (qi, tb->tb_name, 0, NULL);",
                "  if (not_empty && ddl_col_opt_set (col, (caddr_t)(ptrlong)COL_NOT_NULL) && !ddl_col_opt_set (col, (caddr_t)(ptrlong)COL_DEFAULT))",
                "    sqlr_new_error (\"42000\", \"SQ018\", \"column '%s' of table '%s' contains null values\", col[0], table);",
                "      \":2\", box_copy_tree ((caddr_t) col), QRP_RAW));"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31621",
        "func_name": "openlink/virtuoso-opensource/ddl_ensure_index",
        "description": "An issue in the kc_var_col component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/ec54f1c7b50df944ae4a8d3e29cd7eaf1cc97b21",
        "commit_title": "Fixed cannot add non-null column to existing data (fixes #1130)",
        "commit_text": "",
        "func_before": "void\nddl_ensure_index (const char *table, const char * index_name, const char *text)\n{\n  client_connection_t *old_cli = sqlc_client();\n  sqlc_set_client (NULL);\n  dbe_table_t * tb = sch_name_to_table (wi_inst.wi_schema, table);\n  dbe_key_t * key = tb ? tb_find_key (tb, index_name, NULL) : NULL;\n  if (!key)\n    {\n      caddr_t err = NULL;\n      query_t *obj_create = eql_compile_2 (text, bootstrap_cli, &err, SQLC_DEFAULT);\n      if (err)\n\t{\n\t  log_error (\"Error compiling a server init statement : %s: %s -- %s\",\n\t      ((caddr_t *) err)[QC_ERRNO], ((caddr_t *) err)[QC_ERROR_STRING],\n\t\t     err_first_line (text));\n\t  sqlc_set_client (old_cli);\n\t  dk_free_tree (err);\n\t  return;\n\t}\n      sqlc_set_client (bootstrap_cli);\n      first_id = DD_FIRST_PRIVATE_OID;\n      err = qr_quick_exec (obj_create, bootstrap_cli, \"\", NULL, 0);\n      if (err)\n\t{\n\t  if (err == (caddr_t) SQL_NO_DATA_FOUND)\n\t    log_error (\"Error executing a server init statement : NO DATA FOUND -- %s\",\n\t\t       err_first_line (text));\n\t  else\n\t    log_error (\"Error executing a server init statement : %s: %s -- %s\",\n\t\t((caddr_t *) err)[QC_ERRNO], ((caddr_t *) err)[QC_ERROR_STRING],\n\t\t       err_first_line (text));\n\t  dk_free_tree (err);\n\t  qr_free (obj_create);\n\t  sqlc_set_client (old_cli);\n\t  return;\n\t}\n      qr_free (obj_create);\n\n      first_id = DD_FIRST_FREE_OID;\n      sqlc_set_client (old_cli);\n      local_commit (bootstrap_cli);\n    }\n  else\n    sqlc_set_client (old_cli);\n}",
        "func": "void\nddl_ensure_index (const char *table, const char * index_name, const char *text)\n{\n  client_connection_t *old_cli = sqlc_client();\n  sqlc_set_client (NULL);\n  dbe_table_t * tb = sch_name_to_table (wi_inst.wi_schema, table);\n  dbe_key_t * key = tb ? tb_find_key (tb, index_name, 0) : NULL;\n  if (!key)\n    {\n      caddr_t err = NULL;\n      query_t *obj_create = eql_compile_2 (text, bootstrap_cli, &err, SQLC_DEFAULT);\n      if (err)\n\t{\n\t  log_error (\"Error compiling a server init statement : %s: %s -- %s\",\n\t      ((caddr_t *) err)[QC_ERRNO], ((caddr_t *) err)[QC_ERROR_STRING],\n\t\t     err_first_line (text));\n\t  sqlc_set_client (old_cli);\n\t  dk_free_tree (err);\n\t  return;\n\t}\n      sqlc_set_client (bootstrap_cli);\n      first_id = DD_FIRST_PRIVATE_OID;\n      err = qr_quick_exec (obj_create, bootstrap_cli, \"\", NULL, 0);\n      if (err)\n\t{\n\t  if (err == (caddr_t) SQL_NO_DATA_FOUND)\n\t    log_error (\"Error executing a server init statement : NO DATA FOUND -- %s\",\n\t\t       err_first_line (text));\n\t  else\n\t    log_error (\"Error executing a server init statement : %s: %s -- %s\",\n\t\t((caddr_t *) err)[QC_ERRNO], ((caddr_t *) err)[QC_ERROR_STRING],\n\t\t       err_first_line (text));\n\t  dk_free_tree (err);\n\t  qr_free (obj_create);\n\t  sqlc_set_client (old_cli);\n\t  return;\n\t}\n      qr_free (obj_create);\n\n      first_id = DD_FIRST_FREE_OID;\n      sqlc_set_client (old_cli);\n      local_commit (bootstrap_cli);\n    }\n  else\n    sqlc_set_client (old_cli);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n   client_connection_t *old_cli = sqlc_client();\n   sqlc_set_client (NULL);\n   dbe_table_t * tb = sch_name_to_table (wi_inst.wi_schema, table);\n-  dbe_key_t * key = tb ? tb_find_key (tb, index_name, NULL) : NULL;\n+  dbe_key_t * key = tb ? tb_find_key (tb, index_name, 0) : NULL;\n   if (!key)\n     {\n       caddr_t err = NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "  dbe_key_t * key = tb ? tb_find_key (tb, index_name, NULL) : NULL;"
            ],
            "added_lines": [
                "  dbe_key_t * key = tb ? tb_find_key (tb, index_name, 0) : NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31622",
        "func_name": "openlink/virtuoso-opensource/sqlc_delete_pos",
        "description": "An issue in the sqlc_make_policy_trig component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/db91dc5602a8cfde2e4e1d00387d5ba4b77389dc",
        "commit_title": "Fixed missing check for table in positioned delete (fixes #1135)",
        "commit_text": "",
        "func_before": "void\nsqlc_delete_pos (sql_comp_t * sc, ST * tree, subq_compilation_t * cursor_sqc, ST ** src_ret)\n{\n  dbe_table_t *tb = sch_name_to_table (wi_inst.wi_schema,\n      tree->_.delete_pos.table->_.table.name);\n  sqlc_table_used (sc, tb);\n  if (tb && (tb->tb_primary_key->key_is_col || find_remote_table (tb->tb_name, 0) || (tb->tb_primary_key->key_partition && !sqlo_opt_value (tree->_.delete_pos.opts, OPT_NO_CLUSTER))))\n    {\n      if (!src_ret)\n\tsqlc_new_error (sc->sc_cc, \"37000\", \"NOPOS\", \"Positioned statement is allowed only in procedures\");\n      *src_ret = sqlc_delete_cl_pos (sc, tree, cursor_sqc);\n      return;\n    }\n  else\n    {\n      trig_cols_t tc;\n      SQL_NODE_INIT (delete_node_t, del, delete_node_input, del_free);\n      if (tb && !sec_tb_check (tb, SC_G_ID (sc), SC_U_ID (sc), GR_DELETE))\n\tsqlc_new_error (sc->sc_cc, \"43000\", \"SQ108:SECURITY\", \"Permission denied for delete from %.300s (user ID = %lu)\", tb->tb_name, SC_U_ID (sc));\n\n      del->del_table = tb;\n      del->del_policy_qr = sqlc_make_policy_trig (sc->sc_cc, tb, TB_RLS_D);\n      del->del_place = cursor_sqc\n\t? cursor_sqc->sqc_ssl\n\t  : sqlc_make_co_node (sc, tree->_.delete_pos.cursor, tb);\n      if (!del->del_place)\n\tsqlc_new_error (sc->sc_cc, \"09000\", \"SQ109\",\n\t    \"Cursor with a sorted order by, distinct, grouping etc. \"\n\t    \"is not referenceable in 'delete from %.200s where current of ...'\", tb->tb_name );\n      tc_init (&tc, TRIG_DELETE, tb, NULL, NULL, NULL);\n      if (tc.tc_is_trigger)\n\t{\n\t  dk_set_t code = NULL;\n\t  state_slot_t ** slots;\n\t  sqlc_pl_selection (sc, tb, del->del_place, tc.tc_selection, &slots);\n\t  sqlc_trig_const_params (sc, slots, &code);\n\t  del->del_trigger_args = slots;\n\t  del->src_gen.src_pre_code = code_to_cv (sc, code);\n\t}\n      tc_free (&tc);\n      sql_node_append (&sc->sc_cc->cc_query->qr_head_node,\n\t  (data_source_t *) del);\n    }\n}",
        "func": "void\nsqlc_delete_pos (sql_comp_t * sc, ST * tree, subq_compilation_t * cursor_sqc, ST ** src_ret)\n{\n  dbe_table_t *tb = sch_name_to_table (wi_inst.wi_schema,\n      tree->_.delete_pos.table->_.table.name);\n  sqlc_table_used (sc, tb);\n  if (tb && (tb->tb_primary_key->key_is_col || find_remote_table (tb->tb_name, 0) || (tb->tb_primary_key->key_partition && !sqlo_opt_value (tree->_.delete_pos.opts, OPT_NO_CLUSTER))))\n    {\n      if (!src_ret)\n\tsqlc_new_error (sc->sc_cc, \"37000\", \"NOPOS\", \"Positioned statement is allowed only in procedures\");\n      *src_ret = sqlc_delete_cl_pos (sc, tree, cursor_sqc);\n      return;\n    }\n  else\n    {\n      trig_cols_t tc;\n      SQL_NODE_INIT (delete_node_t, del, delete_node_input, del_free);\n      if (tb && !sec_tb_check (tb, SC_G_ID (sc), SC_U_ID (sc), GR_DELETE))\n\tsqlc_new_error (sc->sc_cc, \"43000\", \"SQ108:SECURITY\", \"Permission denied for delete from %.300s (user ID = %lu)\", tb->tb_name, SC_U_ID (sc));\n      if (!tb)\n        sqlc_new_error (sc->sc_cc, \"42S02\", \"NOTBL\", \"No table '%s' for positioned statement\", tree->_.delete_pos.table->_.table.name);\n\n      del->del_table = tb;\n      del->del_policy_qr = sqlc_make_policy_trig (sc->sc_cc, tb, TB_RLS_D);\n      del->del_place = cursor_sqc\n\t? cursor_sqc->sqc_ssl\n\t  : sqlc_make_co_node (sc, tree->_.delete_pos.cursor, tb);\n      if (!del->del_place)\n\tsqlc_new_error (sc->sc_cc, \"09000\", \"SQ109\",\n\t    \"Cursor with a sorted order by, distinct, grouping etc. \"\n\t    \"is not referenceable in 'delete from %.200s where current of ...'\", tb->tb_name );\n      tc_init (&tc, TRIG_DELETE, tb, NULL, NULL, NULL);\n      if (tc.tc_is_trigger)\n\t{\n\t  dk_set_t code = NULL;\n\t  state_slot_t ** slots;\n\t  sqlc_pl_selection (sc, tb, del->del_place, tc.tc_selection, &slots);\n\t  sqlc_trig_const_params (sc, slots, &code);\n\t  del->del_trigger_args = slots;\n\t  del->src_gen.src_pre_code = code_to_cv (sc, code);\n\t}\n      tc_free (&tc);\n      sql_node_append (&sc->sc_cc->cc_query->qr_head_node,\n\t  (data_source_t *) del);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,8 @@\n       SQL_NODE_INIT (delete_node_t, del, delete_node_input, del_free);\n       if (tb && !sec_tb_check (tb, SC_G_ID (sc), SC_U_ID (sc), GR_DELETE))\n \tsqlc_new_error (sc->sc_cc, \"43000\", \"SQ108:SECURITY\", \"Permission denied for delete from %.300s (user ID = %lu)\", tb->tb_name, SC_U_ID (sc));\n+      if (!tb)\n+        sqlc_new_error (sc->sc_cc, \"42S02\", \"NOTBL\", \"No table '%s' for positioned statement\", tree->_.delete_pos.table->_.table.name);\n \n       del->del_table = tb;\n       del->del_policy_qr = sqlc_make_policy_trig (sc->sc_cc, tb, TB_RLS_D);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      if (!tb)",
                "        sqlc_new_error (sc->sc_cc, \"42S02\", \"NOTBL\", \"No table '%s' for positioned statement\", tree->_.delete_pos.table->_.table.name);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31624",
        "func_name": "openlink/virtuoso-opensource/sqlc_insert_view",
        "description": "An issue in the sinv_check_exp component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/311097fb1f23d0a1dd7dcdd2afecf6fe14665526",
        "commit_title": "Fixed check number of values vs cols when inserting into view (fixes #1134)",
        "commit_text": "",
        "func_before": "void\nsqlc_insert_view (sql_comp_t * sc, ST * view, ST * tree, dbe_table_t * tb)\n{\n  /*oid_t ref_g_id = unbox (tree->_.insert.table->_.table.g_id);\n  oid_t ref_u_id = unbox (tree->_.insert.table->_.table.u_id);*/\n\n  int inx;\n  ST **cols = tree->_.insert.cols;\n  dk_set_t aliases = NULL;\n  dk_set_t new_cols = NULL, new_vals = NULL;\n\n  if (!sqlc_view_is_updatable (view))\n    sqlc_new_error (sc->sc_cc, \"37000\", \"SQ114\",\n\t\"View %s is not updatable in insert.\", tb->tb_name);\n\n  /*dk_free_tree ((caddr_t) tree->_.insert.table);*/\n  tree->_.insert.table = (ST *) t_box_copy_tree (\n      (caddr_t) view->_.select_stmt.table_exp->_.table_exp.from[0]->_.table_ref.table);\n\n  _DO_BOX (inx, tree->_.insert.cols)\n    {\n      sqlc_col_to_view_scope (sc, &cols[inx], view, &aliases);\n      if (!ST_P (tree->_.insert.vals, SELECT_STMT))\n\tsinv_sqlo_check_col_val (&cols[inx],\n\t    &(tree->_.insert.vals->_.ins_vals.vals[inx]),\n\t    &new_cols, &new_vals);\n    }\n  END_DO_BOX;\n\n  if (new_cols)\n    {\n      ST ** new_cols_box = (ST **) t_alloc_box (\n\t  (BOX_ELEMENTS (cols) + dk_set_length (new_cols)) * sizeof (caddr_t),\n\t  DV_ARRAY_OF_POINTER);\n      ST ** new_vals_box = (ST **) t_alloc_box (\n\t  (BOX_ELEMENTS (cols) + dk_set_length (new_cols)) * sizeof (caddr_t),\n\t  DV_ARRAY_OF_POINTER);\n      memcpy (new_cols_box, cols, box_length (cols));\n      memcpy (new_vals_box, tree->_.insert.vals->_.ins_vals.vals, box_length (cols));\n      inx = BOX_ELEMENTS (cols);\n      DO_SET (ST *, new_col, &new_cols)\n\t{\n\t  new_cols_box[inx] = new_col;\n\t  new_vals_box[inx] = (ST *) new_vals->data;\n\t  new_vals = new_vals->next;\n\t  inx ++;\n\t}\n      END_DO_SET ();\n      tree->_.insert.cols = cols = new_cols_box;\n      tree->_.insert.vals->_.ins_vals.vals = new_vals_box;\n    }\n\n  _DO_BOX (inx, tree->_.insert.cols)\n    {\n      if (ST_COLUMN (cols[inx], COL_DOTTED))\n\t{\n\t  ST *c = (ST *) t_box_copy_tree (cols[inx]->_.col_ref.name);\n\t  /*dk_free_tree (cols[inx]);*/\n\t  cols[inx] = c;\n\t}\n      else\n\t{\n\t  sqlc_new_error (sc->sc_cc, \"37000\", \"SQ115\",\n\t      \"Non-updatable column in view %s (expression or constant)\",\n\t      tb->tb_name);\n\t}\n    }\n  END_DO_BOX;\n\n\n  sc->sc_col_ref_recs = t_NCONC (aliases, sc->sc_col_ref_recs);\n  sqlc_insert (sc, tree);\n}",
        "func": "void\nsqlc_insert_view (sql_comp_t * sc, ST * view, ST * tree, dbe_table_t * tb)\n{\n  /*oid_t ref_g_id = unbox (tree->_.insert.table->_.table.g_id);\n  oid_t ref_u_id = unbox (tree->_.insert.table->_.table.u_id);*/\n\n  int inx;\n  ST **cols = tree->_.insert.cols;\n  dk_set_t aliases = NULL;\n  dk_set_t new_cols = NULL, new_vals = NULL;\n\n  if (!sqlc_view_is_updatable (view))\n    sqlc_new_error (sc->sc_cc, \"37000\", \"SQ114\",\n\t\"View %s is not updatable in insert.\", tb->tb_name);\n\n  /*dk_free_tree ((caddr_t) tree->_.insert.table);*/\n  tree->_.insert.table = (ST *) t_box_copy_tree (\n      (caddr_t) view->_.select_stmt.table_exp->_.table_exp.from[0]->_.table_ref.table);\n\n  if (BOX_ELEMENTS_0(cols) != BOX_ELEMENTS_0(tree->_.insert.vals->_.ins_vals.vals))\n    sqlc_new_error (sc->sc_cc, \"21S01\", \"SQ099\",\n\t\"different number of cols and values in insert.\");\n\n  _DO_BOX (inx, tree->_.insert.cols)\n    {\n      sqlc_col_to_view_scope (sc, &cols[inx], view, &aliases);\n      if (!ST_P (tree->_.insert.vals, SELECT_STMT))\n\tsinv_sqlo_check_col_val (&cols[inx],\n\t    &(tree->_.insert.vals->_.ins_vals.vals[inx]),\n\t    &new_cols, &new_vals);\n    }\n  END_DO_BOX;\n\n  if (new_cols)\n    {\n      ST ** new_cols_box = (ST **) t_alloc_box (\n\t  (BOX_ELEMENTS (cols) + dk_set_length (new_cols)) * sizeof (caddr_t),\n\t  DV_ARRAY_OF_POINTER);\n      ST ** new_vals_box = (ST **) t_alloc_box (\n\t  (BOX_ELEMENTS (cols) + dk_set_length (new_cols)) * sizeof (caddr_t),\n\t  DV_ARRAY_OF_POINTER);\n      memcpy (new_cols_box, cols, box_length (cols));\n      memcpy (new_vals_box, tree->_.insert.vals->_.ins_vals.vals, box_length (cols));\n      inx = BOX_ELEMENTS (cols);\n      DO_SET (ST *, new_col, &new_cols)\n\t{\n\t  new_cols_box[inx] = new_col;\n\t  new_vals_box[inx] = (ST *) new_vals->data;\n\t  new_vals = new_vals->next;\n\t  inx ++;\n\t}\n      END_DO_SET ();\n      tree->_.insert.cols = cols = new_cols_box;\n      tree->_.insert.vals->_.ins_vals.vals = new_vals_box;\n    }\n\n  _DO_BOX (inx, tree->_.insert.cols)\n    {\n      if (ST_COLUMN (cols[inx], COL_DOTTED))\n\t{\n\t  ST *c = (ST *) t_box_copy_tree (cols[inx]->_.col_ref.name);\n\t  /*dk_free_tree (cols[inx]);*/\n\t  cols[inx] = c;\n\t}\n      else\n\t{\n\t  sqlc_new_error (sc->sc_cc, \"37000\", \"SQ115\",\n\t      \"Non-updatable column in view %s (expression or constant)\",\n\t      tb->tb_name);\n\t}\n    }\n  END_DO_BOX;\n\n\n  sc->sc_col_ref_recs = t_NCONC (aliases, sc->sc_col_ref_recs);\n  sqlc_insert (sc, tree);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,6 +16,10 @@\n   /*dk_free_tree ((caddr_t) tree->_.insert.table);*/\n   tree->_.insert.table = (ST *) t_box_copy_tree (\n       (caddr_t) view->_.select_stmt.table_exp->_.table_exp.from[0]->_.table_ref.table);\n+\n+  if (BOX_ELEMENTS_0(cols) != BOX_ELEMENTS_0(tree->_.insert.vals->_.ins_vals.vals))\n+    sqlc_new_error (sc->sc_cc, \"21S01\", \"SQ099\",\n+\t\"different number of cols and values in insert.\");\n \n   _DO_BOX (inx, tree->_.insert.cols)\n     {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  if (BOX_ELEMENTS_0(cols) != BOX_ELEMENTS_0(tree->_.insert.vals->_.ins_vals.vals))",
                "    sqlc_new_error (sc->sc_cc, \"21S01\", \"SQ099\",",
                "\t\"different number of cols and values in insert.\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31626",
        "func_name": "openlink/virtuoso-opensource/select_node_input_vec",
        "description": "An issue in the gpf_notice component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/4ad97c5a81067e3bdabe849f42f089edc9880131",
        "commit_title": "Fixed handling of aliases in output (fixes #1129)",
        "commit_text": "",
        "func_before": "void\nselect_node_input_vec (select_node_t * sel, caddr_t * inst, caddr_t * state)\n{\n  QNCAST (query_instance_t, qi, inst);\n  int quota = (int) (ptrlong) inst[sel->sel_out_quota];\n  int n_rows, row, skip = 0, top = 0, top_ctr = 0, fill = 0;\n  int pos_in_batch = QST_INT (inst, sel->sel_out_fill);\n  if (state)\n    {\n      QST_INT (inst, sel->src_gen.src_out_fill) = 0;\n    }\n  if (sel->src_gen.src_prev)\n    n_rows = QST_INT (inst, sel->src_gen.src_prev->src_out_fill);\n  else\n    n_rows = 1;\n  if (sel->sel_top)\n    {\n      top = unbox (qst_get (inst, sel->sel_top));\n      if (sel->sel_top_skip)\n\tskip = unbox (qst_get (inst, sel->sel_top_skip));\n      if (top < 0 || skip < 0)\n\tsqlr_new_error (\"42000\", \"TOPSK\", \"select skip, top has a negative top or skip value\");\n      top += skip;\n      top_ctr = unbox (qst_get (inst, sel->sel_row_ctr));\n    }\n  if (qi->qi_lc)\n    {\n      select_node_lc_input (sel, qi, n_rows, top, skip);\n      return;\n    }\n  if (CALLER_CLIENT != qi->qi_caller || !qi->qi_client->cli_session)\n    return;\n\n  if (top && top_ctr + n_rows < skip)\n    {\n      qst_set_long (inst, sel->sel_row_ctr, top_ctr + n_rows);\n      return;\n    }\n  if (top && top_ctr < skip)\n    {\n      int n_skipped = skip - top_ctr;\n      qst_set_long (inst, sel->sel_row_ctr, skip);\n      top_ctr = skip;\n      QST_INT (inst, sel->src_gen.src_out_fill) += n_skipped;\n    }\n  QST_INT (inst, sel->sel_client_batch_start) = QST_INT (inst, sel->src_gen.src_out_fill);\n  for (row = QST_INT (inst, sel->src_gen.src_out_fill); row < n_rows; row++)\n    {\n      int set_no;\n      qi->qi_set = row;\n      set_no = sel->sel_set_no ? unbox (qst_get (inst, sel->sel_set_no)) : 0;\n      if (!top || top_ctr < top)\n\t{\n\t  int is_full = qi->qi_prefetch_bytes && qi->qi_bytes_selected > qi->qi_prefetch_bytes;\n\t  int slots = sel->sel_n_value_slots;\n\t  int inx;\n\t  OFF_T b1 = 0, b2 = 0;\n\t  PRPC_ANSWER_START (qi->qi_thread, PARTIAL);\n\t  b1 = __ses->dks_bytes_sent;\n\t  dks_array_head (__ses, slots + 1, DV_ARRAY_OF_POINTER);\n\t  print_int (is_full ? QA_ROW_LAST_IN_BATCH : QA_ROW, __ses);\n\t  for (inx = 0; inx < slots; inx++)\n\t    {\n\t      caddr_t value = QST_GET (inst, sel->sel_out_slots[inx]);\n\t      print_object (value, __ses, NULL, NULL);\n\t    }\n\t  b2 = __ses->dks_bytes_sent;\n\t  PRPC_ANSWER_END (0);\n\t  qi->qi_bytes_selected += b2 - b1;\n\t  top_ctr++;\n\t  fill++;\n\t  pos_in_batch++;\n\t  if (top && top_ctr >= top)\n\t    {\n\t      subq_init (sel->src_gen.src_query, inst);\n\t      SRC_RETURN (((data_source_t *) sel), inst);\n\t      longjmp_splice (qi->qi_thread->thr_reset_ctx, RST_AT_END);\n\t    }\n\t  if (PREFETCH_ALL == quota)\n\t    continue;\n\t  if (is_full || pos_in_batch >= quota)\n\t    {\n\t      QST_INT (inst, sel->sel_out_fill) = 0;\n\t      QST_INT (inst, sel->src_gen.src_out_fill) = row + 1;\n\t      if (sel->sel_row_ctr)\n\t\tqst_set_long (inst, sel->sel_row_ctr, top_ctr);\n\t      SRC_IN_STATE (sel, inst) = (row < n_rows - 1) ? inst : NULL;\n\t      SRC_RETURN (((data_source_t *) sel), inst);\n\t      longjmp_splice (qi->qi_thread->thr_reset_ctx, RST_ENOUGH);\n\t    }\n\t}\n    }\n  QST_INT (inst, sel->sel_out_fill) = pos_in_batch;\n  if (sel->sel_top)\n    {\n      QST_INT (inst, sel->src_gen.src_out_fill) = top_ctr;\n      qst_set_long (inst, sel->sel_row_ctr, top_ctr);\n    }\n  SRC_IN_STATE (sel, inst) = NULL;\n}",
        "func": "void\nselect_node_input_vec (select_node_t * sel, caddr_t * inst, caddr_t * state)\n{\n  QNCAST (query_instance_t, qi, inst);\n  int quota = (int) (ptrlong) inst[sel->sel_out_quota];\n  int n_rows, row, skip = 0, top = 0, top_ctr = 0, fill = 0;\n  int pos_in_batch = QST_INT (inst, sel->sel_out_fill);\n  if (state)\n    {\n      QST_INT (inst, sel->src_gen.src_out_fill) = 0;\n    }\n  if (sel->src_gen.src_prev)\n    n_rows = QST_INT (inst, sel->src_gen.src_prev->src_out_fill);\n  else\n    n_rows = 1;\n  if (sel->sel_top)\n    {\n      top = unbox (qst_get (inst, sel->sel_top));\n      if (sel->sel_top_skip)\n\tskip = unbox (qst_get (inst, sel->sel_top_skip));\n      if (top < 0 || skip < 0)\n\tsqlr_new_error (\"42000\", \"TOPSK\", \"select skip, top has a negative top or skip value\");\n      top += skip;\n      top_ctr = unbox (qst_get (inst, sel->sel_row_ctr));\n    }\n  if (qi->qi_lc)\n    {\n      select_node_lc_input (sel, qi, n_rows, top, skip);\n      return;\n    }\n  if (CALLER_CLIENT != qi->qi_caller || !qi->qi_client->cli_session)\n    return;\n\n  if (top && top_ctr + n_rows < skip)\n    {\n      qst_set_long (inst, sel->sel_row_ctr, top_ctr + n_rows);\n      return;\n    }\n  if (top && top_ctr < skip)\n    {\n      int n_skipped = skip - top_ctr;\n      qst_set_long (inst, sel->sel_row_ctr, skip);\n      top_ctr = skip;\n      QST_INT (inst, sel->src_gen.src_out_fill) += n_skipped;\n    }\n  QST_INT (inst, sel->sel_client_batch_start) = QST_INT (inst, sel->src_gen.src_out_fill);\n  for (row = QST_INT (inst, sel->src_gen.src_out_fill); row < n_rows; row++)\n    {\n      int set_no;\n      qi->qi_set = row;\n      set_no = sel->sel_set_no ? unbox (qst_get (inst, sel->sel_set_no)) : 0;\n      if (!top || top_ctr < top)\n\t{\n\t  int is_full = qi->qi_prefetch_bytes && qi->qi_bytes_selected > qi->qi_prefetch_bytes;\n\t  int slots = sel->sel_n_value_slots;\n\t  int inx;\n\t  OFF_T b1 = 0, b2 = 0;\n\t  PRPC_ANSWER_START (qi->qi_thread, PARTIAL);\n\t  b1 = __ses->dks_bytes_sent;\n\t  dks_array_head (__ses, slots + 1, DV_ARRAY_OF_POINTER);\n\t  print_int (is_full ? QA_ROW_LAST_IN_BATCH : QA_ROW, __ses);\n\t  for (inx = 0; inx < slots; inx++)\n\t    {\n              state_slot_t * out_ssl = sel->sel_out_slots[inx];\n              caddr_t value;\n              if (out_ssl->ssl_is_alias && out_ssl->ssl_alias_of)\n                value = QST_GET (inst, out_ssl->ssl_alias_of);\n              else\n                value = QST_GET (inst, out_ssl);\n\t      print_object (value, __ses, NULL, NULL);\n\t    }\n\t  b2 = __ses->dks_bytes_sent;\n\t  PRPC_ANSWER_END (0);\n\t  qi->qi_bytes_selected += b2 - b1;\n\t  top_ctr++;\n\t  fill++;\n\t  pos_in_batch++;\n\t  if (top && top_ctr >= top)\n\t    {\n\t      subq_init (sel->src_gen.src_query, inst);\n\t      SRC_RETURN (((data_source_t *) sel), inst);\n\t      longjmp_splice (qi->qi_thread->thr_reset_ctx, RST_AT_END);\n\t    }\n\t  if (PREFETCH_ALL == quota)\n\t    continue;\n\t  if (is_full || pos_in_batch >= quota)\n\t    {\n\t      QST_INT (inst, sel->sel_out_fill) = 0;\n\t      QST_INT (inst, sel->src_gen.src_out_fill) = row + 1;\n\t      if (sel->sel_row_ctr)\n\t\tqst_set_long (inst, sel->sel_row_ctr, top_ctr);\n\t      SRC_IN_STATE (sel, inst) = (row < n_rows - 1) ? inst : NULL;\n\t      SRC_RETURN (((data_source_t *) sel), inst);\n\t      longjmp_splice (qi->qi_thread->thr_reset_ctx, RST_ENOUGH);\n\t    }\n\t}\n    }\n  QST_INT (inst, sel->sel_out_fill) = pos_in_batch;\n  if (sel->sel_top)\n    {\n      QST_INT (inst, sel->src_gen.src_out_fill) = top_ctr;\n      qst_set_long (inst, sel->sel_row_ctr, top_ctr);\n    }\n  SRC_IN_STATE (sel, inst) = NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -61,7 +61,12 @@\n \t  print_int (is_full ? QA_ROW_LAST_IN_BATCH : QA_ROW, __ses);\n \t  for (inx = 0; inx < slots; inx++)\n \t    {\n-\t      caddr_t value = QST_GET (inst, sel->sel_out_slots[inx]);\n+              state_slot_t * out_ssl = sel->sel_out_slots[inx];\n+              caddr_t value;\n+              if (out_ssl->ssl_is_alias && out_ssl->ssl_alias_of)\n+                value = QST_GET (inst, out_ssl->ssl_alias_of);\n+              else\n+                value = QST_GET (inst, out_ssl);\n \t      print_object (value, __ses, NULL, NULL);\n \t    }\n \t  b2 = __ses->dks_bytes_sent;",
        "diff_line_info": {
            "deleted_lines": [
                "\t      caddr_t value = QST_GET (inst, sel->sel_out_slots[inx]);"
            ],
            "added_lines": [
                "              state_slot_t * out_ssl = sel->sel_out_slots[inx];",
                "              caddr_t value;",
                "              if (out_ssl->ssl_is_alias && out_ssl->ssl_alias_of)",
                "                value = QST_GET (inst, out_ssl->ssl_alias_of);",
                "              else",
                "                value = QST_GET (inst, out_ssl);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31627",
        "func_name": "openlink/virtuoso-opensource/sqlo_implied_columns_of_contains",
        "description": "An issue in the strhash component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/ce61d6f568568b771d7e857408e3246d31135494",
        "commit_title": "Fixed first argument of CONTAINS() cannot be star (fixes #1140)",
        "commit_text": "",
        "func_before": "int\nsqlo_implied_columns_of_contains (sqlo_t *so, ST *tree, int add_score)\n{\n  ST **args;\n  int ctype;\n\n  if (DV_TYPE_OF (tree) != DV_ARRAY_OF_POINTER)\n    return 0;\n\n  if (BOX_ELEMENTS (tree) > 1 && NULL != (args = sqlc_contains_args (tree, &ctype)))\n    {\n      op_table_t *ot;\n      if (BOX_ELEMENTS(args) < 1 || !ST_COLUMN (args[0], COL_DOTTED))\n\tsqlc_error (so->so_sc->sc_cc, \"37000\",\n\t    \"The first argument of %s must be a column\", sqlo_spec_predicate_name (ctype));\n\n      ot = sco_is_defd (so->so_scope, args[0],\n\t  args[0]->_.col_ref.prefix ? SCO_THIS_QUAL : SCO_UNQUALIFIED, 1);\n      if (!ot || !ot->ot_table)\n\tsqlc_error (so->so_sc->sc_cc, \"37000\",\n\t    \"The first argument of %s must reference a column\", sqlo_spec_predicate_name (ctype));\n      if (ot->ot_contains_exp)\n\tsqlc_new_error (so->so_sc->sc_cc, \"37000\", \"SQ040\",\n\t    \"Can't have more than 1 %s for table %s\", sqlo_spec_predicate_name (ctype), ot->ot_table->tb_name);\n      ot->ot_contains_exp = tree;\n\n      args[0]->_.col_ref.prefix = ot->ot_prefix;\n      switch (ctype)\n        {\n        case 'c': case 'x':\n\t{\n\t  dbe_key_t *text_key;\n\t  if (sqlo_is_contains_vdb_tb (so, ot, ctype, args))\n\t    {\n\t      if (NULL == ot->ot_text_score)\n\t\tot->ot_text_score = sqlo_virtual_col_crr (so, ot, \"SCORE\", DV_LONG_INT, 1);\n\t    }\n\t  else\n\t    {\n\t      if (NULL == (text_key = tb_text_key (ot->ot_table)))\n\t\tsqlc_error (so->so_sc->sc_cc, \"37000\",\n\t\t    \"Table referenced in %s does not have a text index\", sqlo_spec_predicate_name (ctype));\n\t      if (ctype == 'x' || ctype == 'c')\n\t\tsqlo_check_ft_offband (so, ot, args, (char) ctype);\n\t      if (NULL == ot->ot_text_score && add_score)\n\t\tot->ot_text_score = sqlo_virtual_col_crr (so, ot, \"SCORE\", DV_LONG_INT, 1);\n\t      if ((ctype == 'x') || (NULL != ot->ot_main_range_out))\n\t\t{\n\t\t  sqlo_xpath_col (so, ot, args, -1, ctype);\n\t\t  if (NULL == ot->ot_main_range_out)\n\t\t    ot->ot_main_range_out = sqlo_virtual_col_crr (so, ot, \"xcontains_main_ranges\", DV_ARRAY_OF_POINTER, 1);\n\t\t  if (NULL == ot->ot_attr_range_out)\n\t\t    ot->ot_attr_range_out = sqlo_virtual_col_crr (so, ot, \"xcontains_attr_ranges\", DV_ARRAY_OF_POINTER, 1);\n\t\t}\n\t    }\n\t  break;\n\t}\n\tcase 'p': case 'q':\n\t  sqlo_xpath_col (so, ot, args, 2, ctype);\n\t  if (BOX_ELEMENTS(args) > 3)\n\t    sqlc_error (so->so_sc->sc_cc, \"37000\",\n\t      \"Too many arguments passed to %s\", sqlo_spec_predicate_name (ctype));\n\t  break;\n\tdefault: GPF_T;\n\t}\n      return 1;\n    }\n  if (ST_P (tree, BOP_AND))\n    {\n      if (!sqlo_implied_columns_of_contains (so, tree->_.bin_exp.left, add_score))\n\treturn sqlo_implied_columns_of_contains (so, tree->_.bin_exp.right, add_score);\n      else\n\treturn 1;\n    }\n  else\n    return 0;\n}",
        "func": "int\nsqlo_implied_columns_of_contains (sqlo_t *so, ST *tree, int add_score)\n{\n  ST **args;\n  int ctype;\n\n  if (DV_TYPE_OF (tree) != DV_ARRAY_OF_POINTER)\n    return 0;\n\n  if (BOX_ELEMENTS (tree) > 1 && NULL != (args = sqlc_contains_args (tree, &ctype)))\n    {\n      op_table_t *ot;\n      if (BOX_ELEMENTS(args) < 1 || !ST_COLUMN (args[0], COL_DOTTED))\n\tsqlc_error (so->so_sc->sc_cc, \"37000\",\n\t    \"The first argument of %s must be a column\", sqlo_spec_predicate_name (ctype));\n      if (args[0]->_.col_ref.name == STAR)\n        sqlc_new_error (so->so_sc->sc_cc, \"42000\", \"SQ064\", \"Illegal use of '*'.\");\n      ot = sco_is_defd (so->so_scope, args[0],\n\t  args[0]->_.col_ref.prefix ? SCO_THIS_QUAL : SCO_UNQUALIFIED, 1);\n      if (!ot || !ot->ot_table)\n\tsqlc_error (so->so_sc->sc_cc, \"37000\",\n\t    \"The first argument of %s must reference a column\", sqlo_spec_predicate_name (ctype));\n      if (ot->ot_contains_exp)\n\tsqlc_new_error (so->so_sc->sc_cc, \"37000\", \"SQ040\",\n\t    \"Can't have more than 1 %s for table %s\", sqlo_spec_predicate_name (ctype), ot->ot_table->tb_name);\n      ot->ot_contains_exp = tree;\n\n      args[0]->_.col_ref.prefix = ot->ot_prefix;\n      switch (ctype)\n        {\n        case 'c': case 'x':\n\t{\n\t  dbe_key_t *text_key;\n\t  if (sqlo_is_contains_vdb_tb (so, ot, ctype, args))\n\t    {\n\t      if (NULL == ot->ot_text_score)\n\t\tot->ot_text_score = sqlo_virtual_col_crr (so, ot, \"SCORE\", DV_LONG_INT, 1);\n\t    }\n\t  else\n\t    {\n\t      if (NULL == (text_key = tb_text_key (ot->ot_table)))\n\t\tsqlc_error (so->so_sc->sc_cc, \"37000\",\n\t\t    \"Table referenced in %s does not have a text index\", sqlo_spec_predicate_name (ctype));\n\t      if (ctype == 'x' || ctype == 'c')\n\t\tsqlo_check_ft_offband (so, ot, args, (char) ctype);\n\t      if (NULL == ot->ot_text_score && add_score)\n\t\tot->ot_text_score = sqlo_virtual_col_crr (so, ot, \"SCORE\", DV_LONG_INT, 1);\n\t      if ((ctype == 'x') || (NULL != ot->ot_main_range_out))\n\t\t{\n\t\t  sqlo_xpath_col (so, ot, args, -1, ctype);\n\t\t  if (NULL == ot->ot_main_range_out)\n\t\t    ot->ot_main_range_out = sqlo_virtual_col_crr (so, ot, \"xcontains_main_ranges\", DV_ARRAY_OF_POINTER, 1);\n\t\t  if (NULL == ot->ot_attr_range_out)\n\t\t    ot->ot_attr_range_out = sqlo_virtual_col_crr (so, ot, \"xcontains_attr_ranges\", DV_ARRAY_OF_POINTER, 1);\n\t\t}\n\t    }\n\t  break;\n\t}\n\tcase 'p': case 'q':\n\t  sqlo_xpath_col (so, ot, args, 2, ctype);\n\t  if (BOX_ELEMENTS(args) > 3)\n\t    sqlc_error (so->so_sc->sc_cc, \"37000\",\n\t      \"Too many arguments passed to %s\", sqlo_spec_predicate_name (ctype));\n\t  break;\n\tdefault: GPF_T;\n\t}\n      return 1;\n    }\n  if (ST_P (tree, BOP_AND))\n    {\n      if (!sqlo_implied_columns_of_contains (so, tree->_.bin_exp.left, add_score))\n\treturn sqlo_implied_columns_of_contains (so, tree->_.bin_exp.right, add_score);\n      else\n\treturn 1;\n    }\n  else\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,8 @@\n       if (BOX_ELEMENTS(args) < 1 || !ST_COLUMN (args[0], COL_DOTTED))\n \tsqlc_error (so->so_sc->sc_cc, \"37000\",\n \t    \"The first argument of %s must be a column\", sqlo_spec_predicate_name (ctype));\n-\n+      if (args[0]->_.col_ref.name == STAR)\n+        sqlc_new_error (so->so_sc->sc_cc, \"42000\", \"SQ064\", \"Illegal use of '*'.\");\n       ot = sco_is_defd (so->so_scope, args[0],\n \t  args[0]->_.col_ref.prefix ? SCO_THIS_QUAL : SCO_UNQUALIFIED, 1);\n       if (!ot || !ot->ot_table)",
        "diff_line_info": {
            "deleted_lines": [
                ""
            ],
            "added_lines": [
                "      if (args[0]->_.col_ref.name == STAR)",
                "        sqlc_new_error (so->so_sc->sc_cc, \"42000\", \"SQ064\", \"Illegal use of '*'.\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31630",
        "func_name": "openlink/virtuoso-opensource/sqlc_insert",
        "description": "An issue in the sqlo_query_spec component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/f9244141ce68dc4a3314fd4a0cd5bb3bdd6ab830",
        "commit_title": "Added check for non-terminals in WITH DATA (fixes #1138)",
        "commit_text": "",
        "func_before": "void\nsqlc_insert (sql_comp_t * sc, ST * tree)\n{\n  ST * fetch;\n  caddr_t * opts;\n  ST * tb_ref = tree->_.insert.table;\n  ST * vd;\n  dbe_table_t *tb = sch_name_to_table (wi_inst.wi_schema,\n      tb_ref->_.table.name);\n  sqlc_table_used (sc, tb);\n  if (tb && find_remote_table (tb->tb_name, 0))\n    {\n    }\n  if (!tb)\n    sqlc_new_error (sc->sc_cc, \"42S02\", \"SQ096\", \"No table %.300s.\",\n\t\ttree->_.insert.table->_.table.name);\n\n  if (!sec_tb_check (tb, (oid_t) unbox (tb_ref->_.table.g_id), (oid_t) unbox (tb_ref->_.table.u_id), GR_INSERT)\n      || (tree->_.insert.mode == INS_REPLACING &&\n\t  !sec_tb_check (tb, SC_G_ID (sc), SC_U_ID (sc), GR_DELETE)))\n    sqlc_new_error (sc->sc_cc, \"42000\", \"SQ097\",\n\t\"No insert or insert/delete permission for insert / insert replacing in table %.300s (user ID = %lu)\",\n        tb->tb_name, SC_U_ID (sc) );\n\n  if (INS_REPLACING == tree->_.insert.mode)\n    {\n      /* if no dependent part, ins replacing becomes ins soft */\n      dbe_key_t * key = tree->_.insert.key ? tb_find_key (tb, tree->_.insert.key, 0) : tb->tb_primary_key;\n      if (key && key->key_n_significant == dk_set_length (key->key_parts))\n\ttree->_.insert.mode = INS_SOFT;\n    }\n\n  if (!tree->_.insert.cols)\n    tree->_.insert.cols = (ST **) ins_tb_all_cols (tb);\n  if ((vd = (ST *)sch_view_def (wi_inst.wi_schema, tb->tb_name)) &&\n      !tb_is_trig_at (tb, TRIG_INSERT, TRIG_INSTEAD, NULL))\n    {\n      sqlc_insert_view (sc, vd, tree, tb);\n      return;\n    }\n\n  {\n      dk_set_t slots = NULL;\n      int inx;\n      state_slot_t **slots_ret;\n      dk_set_t code = NULL;\n      oid_t *col_ids;\n      SQL_NODE_INIT (insert_node_t, ins, insert_node_input, ins_free);\n\n      col_ids = (oid_t *) box_copy ((caddr_t) tree->_.insert.cols);\n      ins->ins_mode = (int) tree->_.insert.mode;\n      ins->ins_table = tb;\n      ins->ins_policy_qr = sqlc_make_policy_trig (sc->sc_cc, tb, TB_RLS_I);\n      ins->ins_key_only = box_copy (tree->_.insert.key);\n      DO_BOX (caddr_t, col_name, inx, tree->_.insert.cols)\n      {\n\tdbe_column_t *col = tb_name_to_column_misc (tb, col_name);\n\tif (!col)\n\t  sqlc_new_error (sc->sc_cc, \"42S22\", \"SQ098\", \"No column %s.\", col_name);\n\n\tcol_ids[inx] = col->col_id;\n      }\n      END_DO_BOX;\n      ins->ins_col_ids = col_ids;\n\n      if (ST_P (tree->_.insert.vals, SELECT_STMT))\n\t{\n\t  ST *sel = tree->_.insert.vals;\n\t  if (sc->sc_client->cli_row_autocommit || enable_mt_txn)\n\t    sc->sc_parallel_dml = 1;\n\t  sc->sc_cc->cc_query->qr_is_mt_insert = 1;\n\t  sqlc_top_select_dt (sc, sel);\n\t  sc->sc_is_update = SC_UPD_INS;\n\t  sc->sc_no_current_of = 1;\n\t    sqlo_query_spec (sc, SEL_IS_DISTINCT (sel),\n\t\tsel->_.select_stmt.selection,\n\t\tsel->_.select_stmt.table_exp,\n\t\t&sc->sc_cc->cc_query->qr_head_node,\n\t\t&slots_ret);\n\t  sql_node_append (&sc->sc_cc->cc_query->qr_head_node,\n\t      (data_source_t *) ins);\n\t  DO_BOX (state_slot_t *, sl, inx, slots_ret)\n\t  {\n\t    slots = NCONC (slots, CONS (sl, NULL));\n\t  }\n\t  END_DO_BOX;\n\t  dk_free_box ((caddr_t) slots_ret);\n\t}\n      else\n\t{\n\t  ST **vals = tree->_.insert.vals->_.ins_vals.vals;\n\t  SC_NO_EXCEPT (sc);\n\t  DO_BOX (ST *, exp, inx, vals)\n\t  {\n\t    sqlc_mark_pred_deps (sc, NULL, exp);\n\t    slots = NCONC (slots, CONS (scalar_exp_generate (sc, exp, &code),\n\t\tNULL));\n\t  }\n\t  END_DO_BOX;\n\t  SC_OLD_EXCEPT (sc);\n\t  sc->sc_cc->cc_query->qr_head_node = (data_source_t *) ins;\n\t}\n      ins->ins_values = slots;\n      opts = tree ? tree->_.insert.opts : NULL;\n      if (!sqlo_opt_value (opts, OPT_NO_IDENTITY))\n      sqlc_insert_autoincrements (sc, ins, &code);\n      if (!sqlo_opt_value (opts, OPT_NO_TRIGGER))\n\tsqlc_ins_triggers (sc, ins, &code);\n      if (dk_set_length (ins->ins_values) != BOX_ELEMENTS (ins->ins_col_ids))\n\tsqlc_new_error (sc->sc_cc, \"21S01\", \"SQ099\",\n\t    \"different number of cols and values in insert.\");\n      if (TB_MAX_COLS <= dk_set_length (ins->ins_table->tb_primary_key->key_parts))\n\tsqlc_new_error (sc->sc_cc, \"42000\", \"SQ100\",\n\t    \"A local table of over maximum columns may not be inserted\");\n      sqlc_ins_param_types (sc, ins);\n      sqlc_ins_keys (sc->sc_cc, ins);\n      sqlg_cl_insert (sc, sc->sc_cc, ins, tree, &code);\n      if (sqlo_opt_value (opts, OPT_VECTORED)\n\t  && !sc->sc_cc->cc_query->qr_proc_vectored)\n\tsc->sc_cc->cc_query->qr_proc_vectored = QR_VEC_STMT;\n\n      fetch = (ST*)sqlo_opt_value (opts, OPT_INS_FETCH);\n      if (fetch)\n\tsqlc_ins_fetch (sc, ins, fetch, &code);\n      sqlc_code_dpipe (sc, &code);\n      ins->src_gen.src_pre_code = code_to_cv (sc, code);\n      if (INS_REPLACING == ins->ins_mode && sc->sc_cc->cc_query->qr_proc_vectored)\n\t{\n\t  /* make a delete node */\n\t  dk_set_t save_crr = sc->sc_col_ref_recs;\n\t  static int del_inx;\n\t  char tmp[MAX_NAME_LEN];\n\t  state_slot_t * save_set_no = sc->sc_set_no_ssl;\n\t  ST * delete, * where = NULL;\n          dbe_key_t * key = ins->ins_key_only ? ins->ins_keys[0]->ik_key : ins->ins_table->tb_primary_key;\n\t  data_source_t * top = sc->sc_cc->cc_query->qr_head_node;\n\t  dk_set_t pars, del_pars;\n\t  snprintf (tmp, sizeof (tmp), \"del__%d\", del_inx++);\n\t  DO_BOX (caddr_t, col_name, inx, tree->_.insert.cols)\n\t    {\n\t      dbe_column_t *col = tb_name_to_column_misc (tb, col_name);\n\t      if (cl_list_find (key->key_key_fixed, col->col_id) || cl_list_find (key->key_key_var, col->col_id))\n\t\t{\n\t\t  ST * test;\n\t\t  ST * val = sqlc_ins_del_val (sc, ins,  inx);\n\t\t  BIN_OP (test, BOP_EQ,\n\t\t\t  (ST *) t_list (3, COL_DOTTED, t_sqlp_box_id_upcase (tmp), t_box_string (col->col_name)), val);\n\t\t  if (!where)\n\t\t    where = test;\n\t\t  else\n\t\t    {\n\t\t      ST * tmp = where;\n\t\t      BIN_OP (where, BOP_AND, tmp, test);\n\t\t    }\n\t\t}\n\t    }\n\t  END_DO_BOX;\n\n\t  delete = t_listst (2, DELETE_SRC, sqlp_infoschema_redirect (t_listst (9, TABLE_EXP,\n\t\t  t_list (1,\n\t\t    t_listbox (6, TABLE_DOTTED, t_box_string (ins->ins_table->tb_name), t_sqlp_box_id_upcase (tmp),\n\t\t      sqlp_view_u_id (), sqlp_view_g_id (), ins->ins_key_only ? t_list (2, OPT_INDEX, t_box_string (ins->ins_key_only)) : NULL /* table opt */) /* table */),\n\t\t  where, NULL, NULL, NULL, NULL,\n\t\t  ins->ins_key_only ? t_list (2, OPT_INDEX, t_box_string (ins->ins_key_only)) : NULL /* sql opt */, NULL)));\n\t  sc->sc_cc->cc_query->qr_head_node = NULL;\n\t  pars = sc->sc_cc->cc_query->qr_parms;\n\t  sc->sc_cc->cc_query->qr_parms = NULL;\n\t  sc->sc_set_no_ssl = NULL;\n\t  sqlc_delete_searched (sc, delete);\n\t  sc->sc_set_no_ssl = save_set_no;\n\t  ins->ins_del_node = sc->sc_cc->cc_query->qr_head_node;\n\t  sc->sc_cc->cc_query->qr_head_node = top;\n\t  del_pars = sc->sc_cc->cc_query->qr_parms;\n\t  sc->sc_cc->cc_query->qr_parms = pars;\n\t  sc->sc_col_ref_recs = save_crr;\n\t}\n  }\n}",
        "func": "void\nsqlc_insert (sql_comp_t * sc, ST * tree)\n{\n  ST * fetch;\n  caddr_t * opts;\n  ST * tb_ref = tree->_.insert.table;\n  ST * vd;\n  dbe_table_t *tb = sch_name_to_table (wi_inst.wi_schema,\n      tb_ref->_.table.name);\n  sqlc_table_used (sc, tb);\n  if (tb && find_remote_table (tb->tb_name, 0))\n    {\n    }\n  if (!tb)\n    sqlc_new_error (sc->sc_cc, \"42S02\", \"SQ096\", \"No table %.300s.\",\n\t\ttree->_.insert.table->_.table.name);\n\n  if (!sec_tb_check (tb, (oid_t) unbox (tb_ref->_.table.g_id), (oid_t) unbox (tb_ref->_.table.u_id), GR_INSERT)\n      || (tree->_.insert.mode == INS_REPLACING &&\n\t  !sec_tb_check (tb, SC_G_ID (sc), SC_U_ID (sc), GR_DELETE)))\n    sqlc_new_error (sc->sc_cc, \"42000\", \"SQ097\",\n\t\"No insert or insert/delete permission for insert / insert replacing in table %.300s (user ID = %lu)\",\n        tb->tb_name, SC_U_ID (sc) );\n\n  if (INS_REPLACING == tree->_.insert.mode)\n    {\n      /* if no dependent part, ins replacing becomes ins soft */\n      dbe_key_t * key = tree->_.insert.key ? tb_find_key (tb, tree->_.insert.key, 0) : tb->tb_primary_key;\n      if (key && key->key_n_significant == dk_set_length (key->key_parts))\n\ttree->_.insert.mode = INS_SOFT;\n    }\n\n  if (!tree->_.insert.cols)\n    tree->_.insert.cols = (ST **) ins_tb_all_cols (tb);\n  if ((vd = (ST *)sch_view_def (wi_inst.wi_schema, tb->tb_name)) &&\n      !tb_is_trig_at (tb, TRIG_INSERT, TRIG_INSTEAD, NULL))\n    {\n      sqlc_insert_view (sc, vd, tree, tb);\n      return;\n    }\n\n  {\n      dk_set_t slots = NULL;\n      int inx;\n      state_slot_t **slots_ret;\n      dk_set_t code = NULL;\n      oid_t *col_ids;\n      SQL_NODE_INIT (insert_node_t, ins, insert_node_input, ins_free);\n\n      col_ids = (oid_t *) box_copy ((caddr_t) tree->_.insert.cols);\n      ins->ins_mode = (int) tree->_.insert.mode;\n      ins->ins_table = tb;\n      ins->ins_policy_qr = sqlc_make_policy_trig (sc->sc_cc, tb, TB_RLS_I);\n      ins->ins_key_only = box_copy (tree->_.insert.key);\n      DO_BOX (caddr_t, col_name, inx, tree->_.insert.cols)\n      {\n\tdbe_column_t *col = tb_name_to_column_misc (tb, col_name);\n\tif (!col)\n\t  sqlc_new_error (sc->sc_cc, \"42S22\", \"SQ098\", \"No column %s.\", col_name);\n\n\tcol_ids[inx] = col->col_id;\n      }\n      END_DO_BOX;\n      ins->ins_col_ids = col_ids;\n\n      if (ST_P (tree->_.insert.vals, SELECT_STMT))\n\t{\n\t  ST *sel = tree->_.insert.vals;\n          if (!sel->_.select_stmt.table_exp)\n            sqlc_new_error (sc->sc_cc, \"42S22\", \"SQ098\", \"Non-terminal query expression cannot be used.\");\n\t  if (sc->sc_client->cli_row_autocommit || enable_mt_txn)\n\t    sc->sc_parallel_dml = 1;\n\t  sc->sc_cc->cc_query->qr_is_mt_insert = 1;\n\t  sqlc_top_select_dt (sc, sel);\n\t  sc->sc_is_update = SC_UPD_INS;\n\t  sc->sc_no_current_of = 1;\n\t    sqlo_query_spec (sc, SEL_IS_DISTINCT (sel),\n\t\tsel->_.select_stmt.selection,\n\t\tsel->_.select_stmt.table_exp,\n\t\t&sc->sc_cc->cc_query->qr_head_node,\n\t\t&slots_ret);\n\t  sql_node_append (&sc->sc_cc->cc_query->qr_head_node,\n\t      (data_source_t *) ins);\n\t  DO_BOX (state_slot_t *, sl, inx, slots_ret)\n\t  {\n\t    slots = NCONC (slots, CONS (sl, NULL));\n\t  }\n\t  END_DO_BOX;\n\t  dk_free_box ((caddr_t) slots_ret);\n\t}\n      else\n\t{\n\t  ST **vals = tree->_.insert.vals->_.ins_vals.vals;\n\t  SC_NO_EXCEPT (sc);\n\t  DO_BOX (ST *, exp, inx, vals)\n\t  {\n\t    sqlc_mark_pred_deps (sc, NULL, exp);\n\t    slots = NCONC (slots, CONS (scalar_exp_generate (sc, exp, &code),\n\t\tNULL));\n\t  }\n\t  END_DO_BOX;\n\t  SC_OLD_EXCEPT (sc);\n\t  sc->sc_cc->cc_query->qr_head_node = (data_source_t *) ins;\n\t}\n      ins->ins_values = slots;\n      opts = tree ? tree->_.insert.opts : NULL;\n      if (!sqlo_opt_value (opts, OPT_NO_IDENTITY))\n      sqlc_insert_autoincrements (sc, ins, &code);\n      if (!sqlo_opt_value (opts, OPT_NO_TRIGGER))\n\tsqlc_ins_triggers (sc, ins, &code);\n      if (dk_set_length (ins->ins_values) != BOX_ELEMENTS (ins->ins_col_ids))\n\tsqlc_new_error (sc->sc_cc, \"21S01\", \"SQ099\",\n\t    \"different number of cols and values in insert.\");\n      if (TB_MAX_COLS <= dk_set_length (ins->ins_table->tb_primary_key->key_parts))\n\tsqlc_new_error (sc->sc_cc, \"42000\", \"SQ100\",\n\t    \"A local table of over maximum columns may not be inserted\");\n      sqlc_ins_param_types (sc, ins);\n      sqlc_ins_keys (sc->sc_cc, ins);\n      sqlg_cl_insert (sc, sc->sc_cc, ins, tree, &code);\n      if (sqlo_opt_value (opts, OPT_VECTORED)\n\t  && !sc->sc_cc->cc_query->qr_proc_vectored)\n\tsc->sc_cc->cc_query->qr_proc_vectored = QR_VEC_STMT;\n\n      fetch = (ST*)sqlo_opt_value (opts, OPT_INS_FETCH);\n      if (fetch)\n\tsqlc_ins_fetch (sc, ins, fetch, &code);\n      sqlc_code_dpipe (sc, &code);\n      ins->src_gen.src_pre_code = code_to_cv (sc, code);\n      if (INS_REPLACING == ins->ins_mode && sc->sc_cc->cc_query->qr_proc_vectored)\n\t{\n\t  /* make a delete node */\n\t  dk_set_t save_crr = sc->sc_col_ref_recs;\n\t  static int del_inx;\n\t  char tmp[MAX_NAME_LEN];\n\t  state_slot_t * save_set_no = sc->sc_set_no_ssl;\n\t  ST * delete, * where = NULL;\n          dbe_key_t * key = ins->ins_key_only ? ins->ins_keys[0]->ik_key : ins->ins_table->tb_primary_key;\n\t  data_source_t * top = sc->sc_cc->cc_query->qr_head_node;\n\t  dk_set_t pars, del_pars;\n\t  snprintf (tmp, sizeof (tmp), \"del__%d\", del_inx++);\n\t  DO_BOX (caddr_t, col_name, inx, tree->_.insert.cols)\n\t    {\n\t      dbe_column_t *col = tb_name_to_column_misc (tb, col_name);\n\t      if (cl_list_find (key->key_key_fixed, col->col_id) || cl_list_find (key->key_key_var, col->col_id))\n\t\t{\n\t\t  ST * test;\n\t\t  ST * val = sqlc_ins_del_val (sc, ins,  inx);\n\t\t  BIN_OP (test, BOP_EQ,\n\t\t\t  (ST *) t_list (3, COL_DOTTED, t_sqlp_box_id_upcase (tmp), t_box_string (col->col_name)), val);\n\t\t  if (!where)\n\t\t    where = test;\n\t\t  else\n\t\t    {\n\t\t      ST * tmp = where;\n\t\t      BIN_OP (where, BOP_AND, tmp, test);\n\t\t    }\n\t\t}\n\t    }\n\t  END_DO_BOX;\n\n\t  delete = t_listst (2, DELETE_SRC, sqlp_infoschema_redirect (t_listst (9, TABLE_EXP,\n\t\t  t_list (1,\n\t\t    t_listbox (6, TABLE_DOTTED, t_box_string (ins->ins_table->tb_name), t_sqlp_box_id_upcase (tmp),\n\t\t      sqlp_view_u_id (), sqlp_view_g_id (), ins->ins_key_only ? t_list (2, OPT_INDEX, t_box_string (ins->ins_key_only)) : NULL /* table opt */) /* table */),\n\t\t  where, NULL, NULL, NULL, NULL,\n\t\t  ins->ins_key_only ? t_list (2, OPT_INDEX, t_box_string (ins->ins_key_only)) : NULL /* sql opt */, NULL)));\n\t  sc->sc_cc->cc_query->qr_head_node = NULL;\n\t  pars = sc->sc_cc->cc_query->qr_parms;\n\t  sc->sc_cc->cc_query->qr_parms = NULL;\n\t  sc->sc_set_no_ssl = NULL;\n\t  sqlc_delete_searched (sc, delete);\n\t  sc->sc_set_no_ssl = save_set_no;\n\t  ins->ins_del_node = sc->sc_cc->cc_query->qr_head_node;\n\t  sc->sc_cc->cc_query->qr_head_node = top;\n\t  del_pars = sc->sc_cc->cc_query->qr_parms;\n\t  sc->sc_cc->cc_query->qr_parms = pars;\n\t  sc->sc_col_ref_recs = save_crr;\n\t}\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -66,6 +66,8 @@\n       if (ST_P (tree->_.insert.vals, SELECT_STMT))\n \t{\n \t  ST *sel = tree->_.insert.vals;\n+          if (!sel->_.select_stmt.table_exp)\n+            sqlc_new_error (sc->sc_cc, \"42S22\", \"SQ098\", \"Non-terminal query expression cannot be used.\");\n \t  if (sc->sc_client->cli_row_autocommit || enable_mt_txn)\n \t    sc->sc_parallel_dml = 1;\n \t  sc->sc_cc->cc_query->qr_is_mt_insert = 1;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "          if (!sel->_.select_stmt.table_exp)",
                "            sqlc_new_error (sc->sc_cc, \"42S22\", \"SQ098\", \"Non-terminal query expression cannot be used.\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31631",
        "func_name": "openlink/virtuoso-opensource/sqlo_is_constant_pred_arg",
        "description": "An issue in the sqlo_preds_contradiction component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.",
        "git_url": "https://github.com/openlink/virtuoso-opensource/commit/c77cd981a82a7f6385b174eb818057b2f19d8c09",
        "commit_title": "Fixed missing check if column exists (fixes #1137)",
        "commit_text": "",
        "func_before": "int\nsqlo_is_constant_pred_arg (sqlo_t *so, df_elt_t *pred, df_elt_t *cmp, int cmp_to_find)\n{\n  unsigned inx;\n  df_elt_t *col = pred->_.bin.right->_.call.args[0];\n  collation_t * coll = DFE_COLUMN == col->dfe_type ? col->_.col.col->col_sqt.sqt_collation : NULL;\n  for (inx = 1; inx < BOX_ELEMENTS (pred->_.bin.right->_.call.args); inx++)\n    {\n      if (cmp_to_find == cmp_boxes ((caddr_t) pred->_.bin.right->_.call.args[inx]->dfe_tree,\n\t    (caddr_t) cmp->dfe_tree, coll, coll))\n\treturn 1;\n    }\n  return 0;\n}",
        "func": "int\nsqlo_is_constant_pred_arg (sqlo_t *so, df_elt_t *pred, df_elt_t *cmp, int cmp_to_find)\n{\n  unsigned inx;\n  df_elt_t *col = pred->_.bin.right->_.call.args[0];\n  collation_t * coll = DFE_COLUMN == col->dfe_type && NULL != col->_.col.col ? col->_.col.col->col_sqt.sqt_collation : NULL;\n  for (inx = 1; inx < BOX_ELEMENTS (pred->_.bin.right->_.call.args); inx++)\n    {\n      if (cmp_to_find == cmp_boxes ((caddr_t) pred->_.bin.right->_.call.args[inx]->dfe_tree,\n\t    (caddr_t) cmp->dfe_tree, coll, coll))\n\treturn 1;\n    }\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n {\n   unsigned inx;\n   df_elt_t *col = pred->_.bin.right->_.call.args[0];\n-  collation_t * coll = DFE_COLUMN == col->dfe_type ? col->_.col.col->col_sqt.sqt_collation : NULL;\n+  collation_t * coll = DFE_COLUMN == col->dfe_type && NULL != col->_.col.col ? col->_.col.col->col_sqt.sqt_collation : NULL;\n   for (inx = 1; inx < BOX_ELEMENTS (pred->_.bin.right->_.call.args); inx++)\n     {\n       if (cmp_to_find == cmp_boxes ((caddr_t) pred->_.bin.right->_.call.args[inx]->dfe_tree,",
        "diff_line_info": {
            "deleted_lines": [
                "  collation_t * coll = DFE_COLUMN == col->dfe_type ? col->_.col.col->col_sqt.sqt_collation : NULL;"
            ],
            "added_lines": [
                "  collation_t * coll = DFE_COLUMN == col->dfe_type && NULL != col->_.col.col ? col->_.col.col->col_sqt.sqt_collation : NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-4399",
        "func_name": "TicklishHoneyBee/nodau/db_update",
        "description": "A vulnerability was found in TicklishHoneyBee nodau. It has been rated as critical. Affected by this issue is some unknown functionality of the file src/db.c. The manipulation of the argument value/name leads to sql injection. The name of the patch is 7a7d737a3929f335b9717ddbd31db91151b69ad2. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-215252.",
        "git_url": "https://github.com/TicklishHoneyBee/nodau/commit/7a7d737a3929f335b9717ddbd31db91151b69ad2",
        "commit_title": "Use parametetrized SQL statement",
        "commit_text": " Move to parametetrized SQL statement allows using chars like \"'\" in notes and also avoid sql injection",
        "func_before": "int db_update(char* name, char* value)\n{\n\tchar* sql;\n\tint r = 0;\n\t/* create the sql statement using the name/text for this note\n\t * if it's meant to be encrypted, then crypt_key will be set */\n\tif (crypt_key) {\n\t\tvalue = note_encrypt(value,crypt_key);\n\t\tr = asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='true' WHERE name='%s'\", value, name);\n\t\tfree(value);\n\t\tif (r < 0)\n\t\t\treturn 1;\n\t}else{\n\t\tif (asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='false' WHERE name='%s'\", value, name) < 0)\n\t\t\treturn 1;\n\t}\n\n\t/* do it */\n\tr = sqlite3_exec(db_data.db, sql, NULL, 0, &db_data.error_msg);\n\tfree(sql);\n\treturn r;\n}",
        "func": "int db_update(char* name, char* value)\n{\n\tchar* sql;\n\tint r = 0;\n\t/* create the sql statement using the name/text for this note\n\t * if it's meant to be encrypted, then crypt_key will be set */\n\tif (crypt_key) {\n\t\tvalue = note_encrypt(value,crypt_key);\n\t\tif (asprintf(&sql, \"UPDATE nodau set text=?, encrypted='true' WHERE name=?\") < 0)\n\t\t\treturn 1;\n\t}else{\n\t\tif (asprintf(&sql, \"UPDATE nodau set text=?, encrypted='false' WHERE name=?\") < 0)\n\t\t\treturn 1;\n\t}\n\n\tsqlite3_stmt *compiled_statement;\n\tr = sqlite3_prepare_v2(db_data.db, sql, -1, &compiled_statement, NULL);\n\tif (r != SQLITE_OK)\n\t\treturn 1;\n\n\tr= sqlite3_bind_text(compiled_statement, 1, value, -1, NULL);\n\tr= sqlite3_bind_text(compiled_statement, 2, name, -1, NULL);\n\tif (r != SQLITE_OK)\n\t\treturn 1;\n\n\t/* do it */\n\tr = sqlite3_step(compiled_statement);\n\tif (r != SQLITE_DONE) {\n\t\tfprintf(stderr, \"Error #%d: %s\\n\", r, db_err());\n\t\treturn 1;\n\t}\n\tr = sqlite3_finalize(compiled_statement);\n\tif (r != SQLITE_OK)\n\t\tfprintf(stderr, \"Error #%d: %s\\n\", r, db_err());\n\n\tfree(sql);\n\tif (crypt_key)\n\t\tfree(value);\n\treturn r;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,17 +6,35 @@\n \t * if it's meant to be encrypted, then crypt_key will be set */\n \tif (crypt_key) {\n \t\tvalue = note_encrypt(value,crypt_key);\n-\t\tr = asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='true' WHERE name='%s'\", value, name);\n-\t\tfree(value);\n-\t\tif (r < 0)\n+\t\tif (asprintf(&sql, \"UPDATE nodau set text=?, encrypted='true' WHERE name=?\") < 0)\n \t\t\treturn 1;\n \t}else{\n-\t\tif (asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='false' WHERE name='%s'\", value, name) < 0)\n+\t\tif (asprintf(&sql, \"UPDATE nodau set text=?, encrypted='false' WHERE name=?\") < 0)\n \t\t\treturn 1;\n \t}\n \n+\tsqlite3_stmt *compiled_statement;\n+\tr = sqlite3_prepare_v2(db_data.db, sql, -1, &compiled_statement, NULL);\n+\tif (r != SQLITE_OK)\n+\t\treturn 1;\n+\n+\tr= sqlite3_bind_text(compiled_statement, 1, value, -1, NULL);\n+\tr= sqlite3_bind_text(compiled_statement, 2, name, -1, NULL);\n+\tif (r != SQLITE_OK)\n+\t\treturn 1;\n+\n \t/* do it */\n-\tr = sqlite3_exec(db_data.db, sql, NULL, 0, &db_data.error_msg);\n+\tr = sqlite3_step(compiled_statement);\n+\tif (r != SQLITE_DONE) {\n+\t\tfprintf(stderr, \"Error #%d: %s\\n\", r, db_err());\n+\t\treturn 1;\n+\t}\n+\tr = sqlite3_finalize(compiled_statement);\n+\tif (r != SQLITE_OK)\n+\t\tfprintf(stderr, \"Error #%d: %s\\n\", r, db_err());\n+\n \tfree(sql);\n+\tif (crypt_key)\n+\t\tfree(value);\n \treturn r;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tr = asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='true' WHERE name='%s'\", value, name);",
                "\t\tfree(value);",
                "\t\tif (r < 0)",
                "\t\tif (asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='false' WHERE name='%s'\", value, name) < 0)",
                "\tr = sqlite3_exec(db_data.db, sql, NULL, 0, &db_data.error_msg);"
            ],
            "added_lines": [
                "\t\tif (asprintf(&sql, \"UPDATE nodau set text=?, encrypted='true' WHERE name=?\") < 0)",
                "\t\tif (asprintf(&sql, \"UPDATE nodau set text=?, encrypted='false' WHERE name=?\") < 0)",
                "\tsqlite3_stmt *compiled_statement;",
                "\tr = sqlite3_prepare_v2(db_data.db, sql, -1, &compiled_statement, NULL);",
                "\tif (r != SQLITE_OK)",
                "\t\treturn 1;",
                "",
                "\tr= sqlite3_bind_text(compiled_statement, 1, value, -1, NULL);",
                "\tr= sqlite3_bind_text(compiled_statement, 2, name, -1, NULL);",
                "\tif (r != SQLITE_OK)",
                "\t\treturn 1;",
                "",
                "\tr = sqlite3_step(compiled_statement);",
                "\tif (r != SQLITE_DONE) {",
                "\t\tfprintf(stderr, \"Error #%d: %s\\n\", r, db_err());",
                "\t\treturn 1;",
                "\t}",
                "\tr = sqlite3_finalize(compiled_statement);",
                "\tif (r != SQLITE_OK)",
                "\t\tfprintf(stderr, \"Error #%d: %s\\n\", r, db_err());",
                "",
                "\tif (crypt_key)",
                "\t\tfree(value);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-4399",
        "func_name": "TicklishHoneyBee/nodau/edit_ext",
        "description": "A vulnerability was found in TicklishHoneyBee nodau. It has been rated as critical. Affected by this issue is some unknown functionality of the file src/db.c. The manipulation of the argument value/name leads to sql injection. The name of the patch is 7a7d737a3929f335b9717ddbd31db91151b69ad2. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-215252.",
        "git_url": "https://github.com/TicklishHoneyBee/nodau/commit/7a7d737a3929f335b9717ddbd31db91151b69ad2",
        "commit_title": "Use parametetrized SQL statement",
        "commit_text": " Move to parametetrized SQL statement allows using chars like \"'\" in notes and also avoid sql injection",
        "func_before": "static int edit_ext(char* editor, char* name, char* date, char* data)\n{\n\tint fd;\n\tint st;\n\tint sz;\n\tchar* b;\n\tchar* l;\n\tchar buff[512];\n\tpid_t pid;\n\n\tstrcpy(buff,\"/tmp/nodau.XXXXXX\");\n\tfd = mkstemp(buff);\n\n\tif (fd < 0)\n\t\treturn 1;\n\n\tpid = fork();\n\n\tif (pid < 0) {\n\t\treturn 1;\n\t}else if (pid) {\n\t\tclose(fd);\n\t\twaitpid(pid,&st,0);\n\t\tif (!st) {\n\t\t\tif ((fd = open(buff,O_RDONLY)) < 0)\n\t\t\t\treturn 1;\n\t\t\t/* find the file length */\n\t\t\tsz = lseek(fd,0,SEEK_END);\n\t\t\tlseek(fd,0,SEEK_SET);\n\t\t\tif (sz) {\n\t\t\t\t/* load the note into memory */\n\t\t\t\tb = alloca(sz+1);\n\t\t\t\tif (sz != read(fd,b,sz))\n\t\t\t\t\treturn 1;\n\t\t\t\tclose(fd);\n\t\t\t\t/* delete the file */\n\t\t\t\tremove(buff);\n\t\t\t\tb[sz] = 0;\n\t\t\t\t/* find the note data */\n\t\t\t\tl = strstr(b,\"-----\");\n\t\t\t\tif (l) {\n\t\t\t\t\t/* save the note */\n\t\t\t\t\tl += 6;\n\t\t\t\t\tif (db_update(name,l))\n\t\t\t\t\t\treturn 1;\n\n\t\t\t\t\t/* let the user know */\n\t\t\t\t\tprintf(\"%s saved\\n\",name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn st;\n\t}\n\n\tsz = strlen(name)+strlen(date)+strlen(data)+50;\n\tb = alloca(sz);\n\n\t/* insert data into file */\n\tsz = sprintf(\n\t\tb,\n\t\t\"%s (%s)\\nText above this line is ignored\\n-----\\n%s\",\n\t\tname,\n\t\tdate,\n\t\tdata\n\t);\n\tif (write(fd,b,sz) != sz) {\n\t\texit(1);\n\t}\n\tfsync(fd);\n\tclose(fd);\n\n\tst = execl(editor,editor,buff,(char*)NULL);\n\n\t/* we should only ever get here if something goes wrong with exec */\n\texit(st);\n\n\t/* and we shouldn't ever get here, but it stops the compiler complaining */\n\treturn 1;\n}",
        "func": "static int edit_ext(char* editor, char* name, char* date, char* data)\n{\n\tint fd;\n\tint st;\n\tint sz;\n\tchar* b;\n\tchar* l;\n\tchar buff[512];\n\tpid_t pid;\n\n\tstrcpy(buff,\"/tmp/nodau.XXXXXX\");\n\tfd = mkstemp(buff);\n\n\tif (fd < 0)\n\t\treturn 1;\n\n\tpid = fork();\n\n\tif (pid < 0) {\n\t\treturn 1;\n\t}else if (pid) {\n\t\tclose(fd);\n\t\twaitpid(pid,&st,0);\n\t\tif (!st) {\n\t\t\tif ((fd = open(buff,O_RDONLY)) < 0)\n\t\t\t\treturn 1;\n\t\t\t/* find the file length */\n\t\t\tsz = lseek(fd,0,SEEK_END);\n\t\t\tlseek(fd,0,SEEK_SET);\n\t\t\tif (sz) {\n\t\t\t\t/* load the note into memory */\n\t\t\t\tb = alloca(sz+1);\n\t\t\t\tif (sz != read(fd,b,sz))\n\t\t\t\t\treturn 1;\n\t\t\t\tclose(fd);\n\t\t\t\t/* delete the file */\n\t\t\t\tremove(buff);\n\t\t\t\tb[sz] = 0;\n\t\t\t\t/* find the note data */\n\t\t\t\tl = strstr(b,\"-----\");\n\t\t\t\tif (l) {\n\t\t\t\t\t/* save the note */\n\t\t\t\t\tl += 6;\n\t\t\t\t\tint r = db_update(name,l);\n\t\t\t\t\tif (r != SQLITE_DONE && r != SQLITE_OK)\n\t\t\t\t\t\treturn 1;\n\n\t\t\t\t\t/* let the user know */\n\t\t\t\t\tprintf(\"%s saved\\n\",name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn st;\n\t}\n\n\tsz = strlen(name)+strlen(date)+strlen(data)+50;\n\tb = alloca(sz);\n\n\t/* insert data into file */\n\tsz = sprintf(\n\t\tb,\n\t\t\"%s (%s)\\nText above this line is ignored\\n-----\\n%s\",\n\t\tname,\n\t\tdate,\n\t\tdata\n\t);\n\tif (write(fd,b,sz) != sz) {\n\t\texit(1);\n\t}\n\tfsync(fd);\n\tclose(fd);\n\n\tst = execl(editor,editor,buff,(char*)NULL);\n\n\t/* we should only ever get here if something goes wrong with exec */\n\texit(st);\n\n\t/* and we shouldn't ever get here, but it stops the compiler complaining */\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -41,7 +41,8 @@\n \t\t\t\tif (l) {\n \t\t\t\t\t/* save the note */\n \t\t\t\t\tl += 6;\n-\t\t\t\t\tif (db_update(name,l))\n+\t\t\t\t\tint r = db_update(name,l);\n+\t\t\t\t\tif (r != SQLITE_DONE && r != SQLITE_OK)\n \t\t\t\t\t\treturn 1;\n \n \t\t\t\t\t/* let the user know */",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\tif (db_update(name,l))"
            ],
            "added_lines": [
                "\t\t\t\t\tint r = db_update(name,l);",
                "\t\t\t\t\tif (r != SQLITE_DONE && r != SQLITE_OK)"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-0036",
        "func_name": "curl/pop3_parse_url_path",
        "description": "curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.",
        "git_url": "https://github.com/curl/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238",
        "commit_title": "URL sanitize: reject URLs containing bad data",
        "commit_text": " Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a decoded manner now use the new Curl_urldecode() function to reject URLs with embedded control codes (anything that is or decodes to a byte value less than 32).  URLs containing such codes could easily otherwise be used to do harm and allow users to do unintended actions with otherwise innocent tools and applications. Like for example using a URL like pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get a mail and instead this would delete one.  This flaw is considered a security vulnerability: CVE-2012-0036  Security advisory at: http://curl.haxx.se/docs/adv_20120124.html  Reported by: Dan Fandrich",
        "func_before": "static CURLcode pop3_parse_url_path(struct connectdata *conn)\n{\n  /* the pop3 struct is already inited in pop3_connect() */\n  struct pop3_conn *pop3c = &conn->proto.pop3c;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n\n  /* url decode the path and use this mailbox */\n  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n  if(!pop3c->mailbox)\n    return CURLE_OUT_OF_MEMORY;\n\n  return CURLE_OK;\n}",
        "func": "static CURLcode pop3_parse_url_path(struct connectdata *conn)\n{\n  /* the pop3 struct is already inited in pop3_connect() */\n  struct pop3_conn *pop3c = &conn->proto.pop3c;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n\n  /* url decode the path and use this mailbox */\n  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,9 +6,5 @@\n   const char *path = data->state.path;\n \n   /* url decode the path and use this mailbox */\n-  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n-  if(!pop3c->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);",
                "  if(!pop3c->mailbox)",
                "    return CURLE_OUT_OF_MEMORY;",
                "",
                "  return CURLE_OK;"
            ],
            "added_lines": [
                "  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-0036",
        "func_name": "curl/curl_easy_unescape",
        "description": "curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.",
        "git_url": "https://github.com/curl/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238",
        "commit_title": "URL sanitize: reject URLs containing bad data",
        "commit_text": " Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a decoded manner now use the new Curl_urldecode() function to reject URLs with embedded control codes (anything that is or decodes to a byte value less than 32).  URLs containing such codes could easily otherwise be used to do harm and allow users to do unintended actions with otherwise innocent tools and applications. Like for example using a URL like pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get a mail and instead this would delete one.  This flaw is considered a security vulnerability: CVE-2012-0036  Security advisory at: http://curl.haxx.se/docs/adv_20120124.html  Reported by: Dan Fandrich",
        "func_before": "char *curl_easy_unescape(CURL *handle, const char *string, int length,\n                         int *olen)\n{\n  int alloc = (length?length:(int)strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  int strindex=0;\n  unsigned long hex;\n  CURLcode res;\n\n  if(!ns)\n    return NULL;\n\n  while(--alloc > 0) {\n    in = *string;\n    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n      /* this is two hexadecimal digits following a '%' */\n      char hexstr[3];\n      char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n\n      hex = strtoul(hexstr, &ptr, 16);\n\n      in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n\n      res = Curl_convert_from_network(handle, &in, 1);\n      if(res) {\n        /* Curl_convert_from_network calls failf if unsuccessful */\n        free(ns);\n        return NULL;\n      }\n\n      string+=2;\n      alloc-=2;\n    }\n\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; /* terminate it */\n\n  if(olen)\n    /* store output size */\n    *olen = strindex;\n  return ns;\n}",
        "func": "char *curl_easy_unescape(CURL *handle, const char *string, int length,\n                         int *olen)\n{\n  char *str = NULL;\n  size_t inputlen = length;\n  size_t outputlen;\n  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n                                FALSE);\n  if(res)\n    return NULL;\n  if(olen)\n    *olen = curlx_uztosi(outputlen);\n  return str;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,48 +1,14 @@\n char *curl_easy_unescape(CURL *handle, const char *string, int length,\n                          int *olen)\n {\n-  int alloc = (length?length:(int)strlen(string))+1;\n-  char *ns = malloc(alloc);\n-  unsigned char in;\n-  int strindex=0;\n-  unsigned long hex;\n-  CURLcode res;\n-\n-  if(!ns)\n+  char *str = NULL;\n+  size_t inputlen = length;\n+  size_t outputlen;\n+  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,\n+                                FALSE);\n+  if(res)\n     return NULL;\n-\n-  while(--alloc > 0) {\n-    in = *string;\n-    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n-      /* this is two hexadecimal digits following a '%' */\n-      char hexstr[3];\n-      char *ptr;\n-      hexstr[0] = string[1];\n-      hexstr[1] = string[2];\n-      hexstr[2] = 0;\n-\n-      hex = strtoul(hexstr, &ptr, 16);\n-\n-      in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */\n-\n-      res = Curl_convert_from_network(handle, &in, 1);\n-      if(res) {\n-        /* Curl_convert_from_network calls failf if unsuccessful */\n-        free(ns);\n-        return NULL;\n-      }\n-\n-      string+=2;\n-      alloc-=2;\n-    }\n-\n-    ns[strindex++] = in;\n-    string++;\n-  }\n-  ns[strindex]=0; /* terminate it */\n-\n   if(olen)\n-    /* store output size */\n-    *olen = strindex;\n-  return ns;\n+    *olen = curlx_uztosi(outputlen);\n+  return str;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  int alloc = (length?length:(int)strlen(string))+1;",
                "  char *ns = malloc(alloc);",
                "  unsigned char in;",
                "  int strindex=0;",
                "  unsigned long hex;",
                "  CURLcode res;",
                "",
                "  if(!ns)",
                "",
                "  while(--alloc > 0) {",
                "    in = *string;",
                "    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {",
                "      /* this is two hexadecimal digits following a '%' */",
                "      char hexstr[3];",
                "      char *ptr;",
                "      hexstr[0] = string[1];",
                "      hexstr[1] = string[2];",
                "      hexstr[2] = 0;",
                "",
                "      hex = strtoul(hexstr, &ptr, 16);",
                "",
                "      in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */",
                "",
                "      res = Curl_convert_from_network(handle, &in, 1);",
                "      if(res) {",
                "        /* Curl_convert_from_network calls failf if unsuccessful */",
                "        free(ns);",
                "        return NULL;",
                "      }",
                "",
                "      string+=2;",
                "      alloc-=2;",
                "    }",
                "",
                "    ns[strindex++] = in;",
                "    string++;",
                "  }",
                "  ns[strindex]=0; /* terminate it */",
                "",
                "    /* store output size */",
                "    *olen = strindex;",
                "  return ns;"
            ],
            "added_lines": [
                "  char *str = NULL;",
                "  size_t inputlen = length;",
                "  size_t outputlen;",
                "  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,",
                "                                FALSE);",
                "  if(res)",
                "    *olen = curlx_uztosi(outputlen);",
                "  return str;"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-0036",
        "func_name": "curl/curl_easy_escape",
        "description": "curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.",
        "git_url": "https://github.com/curl/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238",
        "commit_title": "URL sanitize: reject URLs containing bad data",
        "commit_text": " Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a decoded manner now use the new Curl_urldecode() function to reject URLs with embedded control codes (anything that is or decodes to a byte value less than 32).  URLs containing such codes could easily otherwise be used to do harm and allow users to do unintended actions with otherwise innocent tools and applications. Like for example using a URL like pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get a mail and instead this would delete one.  This flaw is considered a security vulnerability: CVE-2012-0036  Security advisory at: http://curl.haxx.se/docs/adv_20120124.html  Reported by: Dan Fandrich",
        "func_before": "char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n{\n  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;\n  char *ns;\n  char *testing_ptr = NULL;\n  unsigned char in; /* we need to treat the characters unsigned */\n  size_t newlen = alloc;\n  int strindex=0;\n  size_t length;\n  CURLcode res;\n\n  ns = malloc(alloc);\n  if(!ns)\n    return NULL;\n\n  length = alloc-1;\n  while(length--) {\n    in = *string;\n\n    if(Curl_isunreserved(in))\n      /* just copy this */\n      ns[strindex++]=in;\n    else {\n      /* encode it */\n      newlen += 2; /* the size grows with two, since this'll become a %XX */\n      if(newlen > alloc) {\n        alloc *= 2;\n        testing_ptr = realloc(ns, alloc);\n        if(!testing_ptr) {\n          free( ns );\n          return NULL;\n        }\n        else {\n          ns = testing_ptr;\n        }\n      }\n\n      res = Curl_convert_to_network(handle, &in, 1);\n      if(res) {\n        /* Curl_convert_to_network calls failf if unsuccessful */\n        free(ns);\n        return NULL;\n      }\n\n      snprintf(&ns[strindex], 4, \"%%%02X\", in);\n\n      strindex+=3;\n    }\n    string++;\n  }\n  ns[strindex]=0; /* terminate it */\n  return ns;\n}",
        "func": "char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n{\n  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;\n  char *ns;\n  char *testing_ptr = NULL;\n  unsigned char in; /* we need to treat the characters unsigned */\n  size_t newlen = alloc;\n  size_t strindex=0;\n  size_t length;\n  CURLcode res;\n\n  ns = malloc(alloc);\n  if(!ns)\n    return NULL;\n\n  length = alloc-1;\n  while(length--) {\n    in = *string;\n\n    if(Curl_isunreserved(in))\n      /* just copy this */\n      ns[strindex++]=in;\n    else {\n      /* encode it */\n      newlen += 2; /* the size grows with two, since this'll become a %XX */\n      if(newlen > alloc) {\n        alloc *= 2;\n        testing_ptr = realloc(ns, alloc);\n        if(!testing_ptr) {\n          free( ns );\n          return NULL;\n        }\n        else {\n          ns = testing_ptr;\n        }\n      }\n\n      res = Curl_convert_to_network(handle, &in, 1);\n      if(res) {\n        /* Curl_convert_to_network calls failf if unsuccessful */\n        free(ns);\n        return NULL;\n      }\n\n      snprintf(&ns[strindex], 4, \"%%%02X\", in);\n\n      strindex+=3;\n    }\n    string++;\n  }\n  ns[strindex]=0; /* terminate it */\n  return ns;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n   char *testing_ptr = NULL;\n   unsigned char in; /* we need to treat the characters unsigned */\n   size_t newlen = alloc;\n-  int strindex=0;\n+  size_t strindex=0;\n   size_t length;\n   CURLcode res;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  int strindex=0;"
            ],
            "added_lines": [
                "  size_t strindex=0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-0036",
        "func_name": "curl/smtp_connect",
        "description": "curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.",
        "git_url": "https://github.com/curl/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238",
        "commit_title": "URL sanitize: reject URLs containing bad data",
        "commit_text": " Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a decoded manner now use the new Curl_urldecode() function to reject URLs with embedded control codes (anything that is or decodes to a byte value less than 32).  URLs containing such codes could easily otherwise be used to do harm and allow users to do unintended actions with otherwise innocent tools and applications. Like for example using a URL like pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get a mail and instead this would delete one.  This flaw is considered a security vulnerability: CVE-2012-0036  Security advisory at: http://curl.haxx.se/docs/adv_20120124.html  Reported by: Dan Fandrich",
        "func_before": "static CURLcode smtp_connect(struct connectdata *conn,\n                             bool *done) /* see description above */\n{\n  CURLcode result;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  struct SessionHandle *data = conn->data;\n  struct pingpong *pp = &smtpc->pp;\n  const char *path = conn->data->state.path;\n  int len;\n  char localhost[HOSTNAME_MAX + 1];\n\n  *done = FALSE; /* default to not done yet */\n\n  /* If there already is a protocol-specific struct allocated for this\n     sessionhandle, deal with it */\n  Curl_reset_reqproto(conn);\n\n  result = smtp_init(conn);\n  if(CURLE_OK != result)\n    return result;\n\n  /* We always support persistent connections on smtp */\n  conn->bits.close = FALSE;\n\n  pp->response_time = RESP_TIMEOUT; /* set default response time-out */\n  pp->statemach_act = smtp_statemach_act;\n  pp->endofresp = smtp_endofresp;\n  pp->conn = conn;\n\n  if(conn->bits.tunnel_proxy && conn->bits.httpproxy) {\n    /* for SMTP over HTTP proxy */\n    struct HTTP http_proxy;\n    struct FTP *smtp_save;\n\n    /* BLOCKING */\n    /* We want \"seamless\" SMTP operations through HTTP proxy tunnel */\n\n    /* Curl_proxyCONNECT is based on a pointer to a struct HTTP at the member\n     * conn->proto.http; we want SMTP through HTTP and we have to change the\n     * member temporarily for connecting to the HTTP proxy. After\n     * Curl_proxyCONNECT we have to set back the member to the original struct\n     * SMTP pointer\n     */\n    smtp_save = data->state.proto.smtp;\n    memset(&http_proxy, 0, sizeof(http_proxy));\n    data->state.proto.http = &http_proxy;\n\n    result = Curl_proxyCONNECT(conn, FIRSTSOCKET,\n                               conn->host.name, conn->remote_port);\n\n    data->state.proto.smtp = smtp_save;\n\n    if(CURLE_OK != result)\n      return result;\n  }\n\n  if((conn->handler->protocol & CURLPROTO_SMTPS) &&\n      data->state.used_interface != Curl_if_multi) {\n    /* SMTPS is simply smtp with SSL for the control channel */\n    /* now, perform the SSL initialization for this socket */\n    result = Curl_ssl_connect(conn, FIRSTSOCKET);\n    if(result)\n      return result;\n  }\n\n  Curl_pp_init(pp); /* init the response reader stuff */\n\n  pp->response_time = RESP_TIMEOUT; /* set default response time-out */\n  pp->statemach_act = smtp_statemach_act;\n  pp->endofresp = smtp_endofresp;\n  pp->conn = conn;\n\n  if(!*path) {\n    if(!Curl_gethostname(localhost, sizeof localhost))\n      path = localhost;\n    else\n      path = \"localhost\";\n  }\n\n  /* url decode the path and use it as domain with EHLO */\n  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n  if(!smtpc->domain)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* When we connect, we start in the state where we await the server greeting\n   */\n  state(conn, SMTP_SERVERGREET);\n\n  if(data->state.used_interface == Curl_if_multi)\n    result = smtp_multi_statemach(conn, done);\n  else {\n    result = smtp_easy_statemach(conn);\n    if(!result)\n      *done = TRUE;\n  }\n\n  return result;\n}",
        "func": "static CURLcode smtp_connect(struct connectdata *conn,\n                             bool *done) /* see description above */\n{\n  CURLcode result;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  struct SessionHandle *data = conn->data;\n  struct pingpong *pp = &smtpc->pp;\n  const char *path = conn->data->state.path;\n  char localhost[HOSTNAME_MAX + 1];\n\n  *done = FALSE; /* default to not done yet */\n\n  /* If there already is a protocol-specific struct allocated for this\n     sessionhandle, deal with it */\n  Curl_reset_reqproto(conn);\n\n  result = smtp_init(conn);\n  if(CURLE_OK != result)\n    return result;\n\n  /* We always support persistent connections on smtp */\n  conn->bits.close = FALSE;\n\n  pp->response_time = RESP_TIMEOUT; /* set default response time-out */\n  pp->statemach_act = smtp_statemach_act;\n  pp->endofresp = smtp_endofresp;\n  pp->conn = conn;\n\n  if(conn->bits.tunnel_proxy && conn->bits.httpproxy) {\n    /* for SMTP over HTTP proxy */\n    struct HTTP http_proxy;\n    struct FTP *smtp_save;\n\n    /* BLOCKING */\n    /* We want \"seamless\" SMTP operations through HTTP proxy tunnel */\n\n    /* Curl_proxyCONNECT is based on a pointer to a struct HTTP at the member\n     * conn->proto.http; we want SMTP through HTTP and we have to change the\n     * member temporarily for connecting to the HTTP proxy. After\n     * Curl_proxyCONNECT we have to set back the member to the original struct\n     * SMTP pointer\n     */\n    smtp_save = data->state.proto.smtp;\n    memset(&http_proxy, 0, sizeof(http_proxy));\n    data->state.proto.http = &http_proxy;\n\n    result = Curl_proxyCONNECT(conn, FIRSTSOCKET,\n                               conn->host.name, conn->remote_port);\n\n    data->state.proto.smtp = smtp_save;\n\n    if(CURLE_OK != result)\n      return result;\n  }\n\n  if((conn->handler->protocol & CURLPROTO_SMTPS) &&\n      data->state.used_interface != Curl_if_multi) {\n    /* SMTPS is simply smtp with SSL for the control channel */\n    /* now, perform the SSL initialization for this socket */\n    result = Curl_ssl_connect(conn, FIRSTSOCKET);\n    if(result)\n      return result;\n  }\n\n  Curl_pp_init(pp); /* init the response reader stuff */\n\n  pp->response_time = RESP_TIMEOUT; /* set default response time-out */\n  pp->statemach_act = smtp_statemach_act;\n  pp->endofresp = smtp_endofresp;\n  pp->conn = conn;\n\n  if(!*path) {\n    if(!Curl_gethostname(localhost, sizeof localhost))\n      path = localhost;\n    else\n      path = \"localhost\";\n  }\n\n  /* url decode the path and use it as domain with EHLO */\n  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n  if(result)\n    return result;\n\n  /* When we connect, we start in the state where we await the server greeting\n   */\n  state(conn, SMTP_SERVERGREET);\n\n  if(data->state.used_interface == Curl_if_multi)\n    result = smtp_multi_statemach(conn, done);\n  else {\n    result = smtp_easy_statemach(conn);\n    if(!result)\n      *done = TRUE;\n  }\n\n  return result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,6 @@\n   struct SessionHandle *data = conn->data;\n   struct pingpong *pp = &smtpc->pp;\n   const char *path = conn->data->state.path;\n-  int len;\n   char localhost[HOSTNAME_MAX + 1];\n \n   *done = FALSE; /* default to not done yet */\n@@ -78,9 +77,9 @@\n   }\n \n   /* url decode the path and use it as domain with EHLO */\n-  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n-  if(!smtpc->domain)\n-    return CURLE_OUT_OF_MEMORY;\n+  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n+  if(result)\n+    return result;\n \n   /* When we connect, we start in the state where we await the server greeting\n    */",
        "diff_line_info": {
            "deleted_lines": [
                "  int len;",
                "  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);",
                "  if(!smtpc->domain)",
                "    return CURLE_OUT_OF_MEMORY;"
            ],
            "added_lines": [
                "  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);",
                "  if(result)",
                "    return result;"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-0036",
        "func_name": "curl/imap_parse_url_path",
        "description": "curl and libcurl 7.2x before 7.24.0 do not properly consider special characters during extraction of a pathname from a URL, which allows remote attackers to conduct data-injection attacks via a crafted URL, as demonstrated by a CRLF injection attack on the (1) IMAP, (2) POP3, or (3) SMTP protocol.",
        "git_url": "https://github.com/curl/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238",
        "commit_title": "URL sanitize: reject URLs containing bad data",
        "commit_text": " Protocols (IMAP, POP3 and SMTP) that use the path part of a URL in a decoded manner now use the new Curl_urldecode() function to reject URLs with embedded control codes (anything that is or decodes to a byte value less than 32).  URLs containing such codes could easily otherwise be used to do harm and allow users to do unintended actions with otherwise innocent tools and applications. Like for example using a URL like pop3://pop3.example.com/1%0d%0aDELE%201 when the app wants a URL to get a mail and instead this would delete one.  This flaw is considered a security vulnerability: CVE-2012-0036  Security advisory at: http://curl.haxx.se/docs/adv_20120124.html  Reported by: Dan Fandrich",
        "func_before": "static CURLcode imap_parse_url_path(struct connectdata *conn)\n{\n  /* the imap struct is already inited in imap_connect() */\n  struct imap_conn *imapc = &conn->proto.imapc;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n  int len;\n\n  if(!*path)\n    path = \"INBOX\";\n\n  /* url decode the path and use this mailbox */\n  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n  if(!imapc->mailbox)\n    return CURLE_OUT_OF_MEMORY;\n\n  return CURLE_OK;\n}",
        "func": "static CURLcode imap_parse_url_path(struct connectdata *conn)\n{\n  /* the imap struct is already inited in imap_connect() */\n  struct imap_conn *imapc = &conn->proto.imapc;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n\n  if(!*path)\n    path = \"INBOX\";\n\n  /* url decode the path and use this mailbox */\n  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,15 +4,10 @@\n   struct imap_conn *imapc = &conn->proto.imapc;\n   struct SessionHandle *data = conn->data;\n   const char *path = data->state.path;\n-  int len;\n \n   if(!*path)\n     path = \"INBOX\";\n \n   /* url decode the path and use this mailbox */\n-  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n-  if(!imapc->mailbox)\n-    return CURLE_OUT_OF_MEMORY;\n-\n-  return CURLE_OK;\n+  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  int len;",
                "  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);",
                "  if(!imapc->mailbox)",
                "    return CURLE_OUT_OF_MEMORY;",
                "",
                "  return CURLE_OK;"
            ],
            "added_lines": [
                "  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);"
            ]
        }
    }
]