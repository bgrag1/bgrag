[
    {
        "cve_id": "CVE-2020-10751",
        "func_name": "torvalds/linux/selinux_netlink_send",
        "description": "A flaw was found in the Linux kernels SELinux LSM hook implementation before version 5.7, where it incorrectly assumed that an skb would only contain a single netlink message. The hook would incorrectly only validate the first netlink message in the skb and allow or deny the rest of the messages within the skb with the granted permission without further processing.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=fb73974172ffaaf57a7c42f35424d9aece1a5af6",
        "commit_title": "Fix the SELinux netlink_send hook to properly handle multiple netlink",
        "commit_text": "messages in a single sk_buff; each message is parsed and subject to SELinux access control.  Prior to this patch, SELinux only inspected the first message in the sk_buff.  Cc: stable@vger.kernel.org ",
        "func_before": "static int selinux_netlink_send(struct sock *sk, struct sk_buff *skb)\n{\n\tint err = 0;\n\tu32 perm;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\n\tif (skb->len < NLMSG_HDRLEN) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\tnlh = nlmsg_hdr(skb);\n\n\terr = selinux_nlmsg_lookup(sksec->sclass, nlh->nlmsg_type, &perm);\n\tif (err) {\n\t\tif (err == -EINVAL) {\n\t\t\tpr_warn_ratelimited(\"SELinux: unrecognized netlink\"\n\t\t\t       \" message: protocol=%hu nlmsg_type=%hu sclass=%s\"\n\t\t\t       \" pid=%d comm=%s\\n\",\n\t\t\t       sk->sk_protocol, nlh->nlmsg_type,\n\t\t\t       secclass_map[sksec->sclass - 1].name,\n\t\t\t       task_pid_nr(current), current->comm);\n\t\t\tif (!enforcing_enabled(&selinux_state) ||\n\t\t\t    security_get_allow_unknown(&selinux_state))\n\t\t\t\terr = 0;\n\t\t}\n\n\t\t/* Ignore */\n\t\tif (err == -ENOENT)\n\t\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\terr = sock_has_perm(sk, perm);\nout:\n\treturn err;\n}",
        "func": "static int selinux_netlink_send(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc = 0;\n\tunsigned int msg_len;\n\tunsigned int data_len = skb->len;\n\tunsigned char *data = skb->data;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tu16 sclass = sksec->sclass;\n\tu32 perm;\n\n\twhile (data_len >= nlmsg_total_size(0)) {\n\t\tnlh = (struct nlmsghdr *)data;\n\n\t\t/* NOTE: the nlmsg_len field isn't reliably set by some netlink\n\t\t *       users which means we can't reject skb's with bogus\n\t\t *       length fields; our solution is to follow what\n\t\t *       netlink_rcv_skb() does and simply skip processing at\n\t\t *       messages with length fields that are clearly junk\n\t\t */\n\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN || nlh->nlmsg_len > data_len)\n\t\t\treturn 0;\n\n\t\trc = selinux_nlmsg_lookup(sclass, nlh->nlmsg_type, &perm);\n\t\tif (rc == 0) {\n\t\t\trc = sock_has_perm(sk, perm);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t} else if (rc == -EINVAL) {\n\t\t\t/* -EINVAL is a missing msg/perm mapping */\n\t\t\tpr_warn_ratelimited(\"SELinux: unrecognized netlink\"\n\t\t\t\t\" message: protocol=%hu nlmsg_type=%hu sclass=%s\"\n\t\t\t\t\" pid=%d comm=%s\\n\",\n\t\t\t\tsk->sk_protocol, nlh->nlmsg_type,\n\t\t\t\tsecclass_map[sclass - 1].name,\n\t\t\t\ttask_pid_nr(current), current->comm);\n\t\t\tif (enforcing_enabled(&selinux_state) &&\n\t\t\t    !security_get_allow_unknown(&selinux_state))\n\t\t\t\treturn rc;\n\t\t\trc = 0;\n\t\t} else if (rc == -ENOENT) {\n\t\t\t/* -ENOENT is a missing socket/class mapping, ignore */\n\t\t\trc = 0;\n\t\t} else {\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* move to the next message after applying netlink padding */\n\t\tmsg_len = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (msg_len >= data_len)\n\t\t\treturn 0;\n\t\tdata_len -= msg_len;\n\t\tdata += msg_len;\n\t}\n\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,37 +1,57 @@\n static int selinux_netlink_send(struct sock *sk, struct sk_buff *skb)\n {\n-\tint err = 0;\n-\tu32 perm;\n+\tint rc = 0;\n+\tunsigned int msg_len;\n+\tunsigned int data_len = skb->len;\n+\tunsigned char *data = skb->data;\n \tstruct nlmsghdr *nlh;\n \tstruct sk_security_struct *sksec = sk->sk_security;\n+\tu16 sclass = sksec->sclass;\n+\tu32 perm;\n \n-\tif (skb->len < NLMSG_HDRLEN) {\n-\t\terr = -EINVAL;\n-\t\tgoto out;\n-\t}\n-\tnlh = nlmsg_hdr(skb);\n+\twhile (data_len >= nlmsg_total_size(0)) {\n+\t\tnlh = (struct nlmsghdr *)data;\n \n-\terr = selinux_nlmsg_lookup(sksec->sclass, nlh->nlmsg_type, &perm);\n-\tif (err) {\n-\t\tif (err == -EINVAL) {\n+\t\t/* NOTE: the nlmsg_len field isn't reliably set by some netlink\n+\t\t *       users which means we can't reject skb's with bogus\n+\t\t *       length fields; our solution is to follow what\n+\t\t *       netlink_rcv_skb() does and simply skip processing at\n+\t\t *       messages with length fields that are clearly junk\n+\t\t */\n+\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN || nlh->nlmsg_len > data_len)\n+\t\t\treturn 0;\n+\n+\t\trc = selinux_nlmsg_lookup(sclass, nlh->nlmsg_type, &perm);\n+\t\tif (rc == 0) {\n+\t\t\trc = sock_has_perm(sk, perm);\n+\t\t\tif (rc)\n+\t\t\t\treturn rc;\n+\t\t} else if (rc == -EINVAL) {\n+\t\t\t/* -EINVAL is a missing msg/perm mapping */\n \t\t\tpr_warn_ratelimited(\"SELinux: unrecognized netlink\"\n-\t\t\t       \" message: protocol=%hu nlmsg_type=%hu sclass=%s\"\n-\t\t\t       \" pid=%d comm=%s\\n\",\n-\t\t\t       sk->sk_protocol, nlh->nlmsg_type,\n-\t\t\t       secclass_map[sksec->sclass - 1].name,\n-\t\t\t       task_pid_nr(current), current->comm);\n-\t\t\tif (!enforcing_enabled(&selinux_state) ||\n-\t\t\t    security_get_allow_unknown(&selinux_state))\n-\t\t\t\terr = 0;\n+\t\t\t\t\" message: protocol=%hu nlmsg_type=%hu sclass=%s\"\n+\t\t\t\t\" pid=%d comm=%s\\n\",\n+\t\t\t\tsk->sk_protocol, nlh->nlmsg_type,\n+\t\t\t\tsecclass_map[sclass - 1].name,\n+\t\t\t\ttask_pid_nr(current), current->comm);\n+\t\t\tif (enforcing_enabled(&selinux_state) &&\n+\t\t\t    !security_get_allow_unknown(&selinux_state))\n+\t\t\t\treturn rc;\n+\t\t\trc = 0;\n+\t\t} else if (rc == -ENOENT) {\n+\t\t\t/* -ENOENT is a missing socket/class mapping, ignore */\n+\t\t\trc = 0;\n+\t\t} else {\n+\t\t\treturn rc;\n \t\t}\n \n-\t\t/* Ignore */\n-\t\tif (err == -ENOENT)\n-\t\t\terr = 0;\n-\t\tgoto out;\n+\t\t/* move to the next message after applying netlink padding */\n+\t\tmsg_len = NLMSG_ALIGN(nlh->nlmsg_len);\n+\t\tif (msg_len >= data_len)\n+\t\t\treturn 0;\n+\t\tdata_len -= msg_len;\n+\t\tdata += msg_len;\n \t}\n \n-\terr = sock_has_perm(sk, perm);\n-out:\n-\treturn err;\n+\treturn rc;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tint err = 0;",
                "\tu32 perm;",
                "\tif (skb->len < NLMSG_HDRLEN) {",
                "\t\terr = -EINVAL;",
                "\t\tgoto out;",
                "\t}",
                "\tnlh = nlmsg_hdr(skb);",
                "\terr = selinux_nlmsg_lookup(sksec->sclass, nlh->nlmsg_type, &perm);",
                "\tif (err) {",
                "\t\tif (err == -EINVAL) {",
                "\t\t\t       \" message: protocol=%hu nlmsg_type=%hu sclass=%s\"",
                "\t\t\t       \" pid=%d comm=%s\\n\",",
                "\t\t\t       sk->sk_protocol, nlh->nlmsg_type,",
                "\t\t\t       secclass_map[sksec->sclass - 1].name,",
                "\t\t\t       task_pid_nr(current), current->comm);",
                "\t\t\tif (!enforcing_enabled(&selinux_state) ||",
                "\t\t\t    security_get_allow_unknown(&selinux_state))",
                "\t\t\t\terr = 0;",
                "\t\t/* Ignore */",
                "\t\tif (err == -ENOENT)",
                "\t\t\terr = 0;",
                "\t\tgoto out;",
                "\terr = sock_has_perm(sk, perm);",
                "out:",
                "\treturn err;"
            ],
            "added_lines": [
                "\tint rc = 0;",
                "\tunsigned int msg_len;",
                "\tunsigned int data_len = skb->len;",
                "\tunsigned char *data = skb->data;",
                "\tu16 sclass = sksec->sclass;",
                "\tu32 perm;",
                "\twhile (data_len >= nlmsg_total_size(0)) {",
                "\t\tnlh = (struct nlmsghdr *)data;",
                "\t\t/* NOTE: the nlmsg_len field isn't reliably set by some netlink",
                "\t\t *       users which means we can't reject skb's with bogus",
                "\t\t *       length fields; our solution is to follow what",
                "\t\t *       netlink_rcv_skb() does and simply skip processing at",
                "\t\t *       messages with length fields that are clearly junk",
                "\t\t */",
                "\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN || nlh->nlmsg_len > data_len)",
                "\t\t\treturn 0;",
                "",
                "\t\trc = selinux_nlmsg_lookup(sclass, nlh->nlmsg_type, &perm);",
                "\t\tif (rc == 0) {",
                "\t\t\trc = sock_has_perm(sk, perm);",
                "\t\t\tif (rc)",
                "\t\t\t\treturn rc;",
                "\t\t} else if (rc == -EINVAL) {",
                "\t\t\t/* -EINVAL is a missing msg/perm mapping */",
                "\t\t\t\t\" message: protocol=%hu nlmsg_type=%hu sclass=%s\"",
                "\t\t\t\t\" pid=%d comm=%s\\n\",",
                "\t\t\t\tsk->sk_protocol, nlh->nlmsg_type,",
                "\t\t\t\tsecclass_map[sclass - 1].name,",
                "\t\t\t\ttask_pid_nr(current), current->comm);",
                "\t\t\tif (enforcing_enabled(&selinux_state) &&",
                "\t\t\t    !security_get_allow_unknown(&selinux_state))",
                "\t\t\t\treturn rc;",
                "\t\t\trc = 0;",
                "\t\t} else if (rc == -ENOENT) {",
                "\t\t\t/* -ENOENT is a missing socket/class mapping, ignore */",
                "\t\t\trc = 0;",
                "\t\t} else {",
                "\t\t\treturn rc;",
                "\t\t/* move to the next message after applying netlink padding */",
                "\t\tmsg_len = NLMSG_ALIGN(nlh->nlmsg_len);",
                "\t\tif (msg_len >= data_len)",
                "\t\t\treturn 0;",
                "\t\tdata_len -= msg_len;",
                "\t\tdata += msg_len;",
                "\treturn rc;"
            ]
        }
    }
]