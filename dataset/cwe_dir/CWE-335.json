[
    {
        "cve_id": "CVE-2018-12520",
        "func_name": "ntop/ntopng/HTTPserver::HTTPserver",
        "description": "An issue was discovered in ntopng 3.4 before 3.4.180617. The PRNG involved in the generation of session IDs is not seeded at program startup. This results in deterministic session IDs being allocated for active user sessions. An attacker with foreknowledge of the operating system and standard library in use by the host running the service and the username of the user whose session they're targeting can abuse the deterministic random number generation in order to hijack the user's session, thus escalating their access.",
        "git_url": "https://github.com/ntop/ntopng/commit/30610bda60cbfc058f90a1c0a17d0e8f4516221a",
        "commit_title": "Added code to randomize values returned by rand()",
        "commit_text": "",
        "func_before": "HTTPserver::HTTPserver(const char *_docs_dir, const char *_scripts_dir) {\n  struct mg_callbacks callbacks;\n  static char ports[256], ssl_cert_path[MAX_PATH] = { 0 }, access_log_path[MAX_PATH] = { 0 };\n  const char *http_binding_addr = ntop->getPrefs()->get_http_binding_address();\n  const char *https_binding_addr = ntop->getPrefs()->get_https_binding_address();\n  char tmpBuf[8];\n  bool use_ssl = false;\n  bool use_http = true;\n  struct stat statsBuf;\n  int stat_rc;\n\n  static char *http_options[] = {\n    (char*)\"listening_ports\", ports,\n    (char*)\"enable_directory_listing\", (char*)\"no\",\n    (char*)\"document_root\",  (char*)_docs_dir,\n    /* (char*)\"extra_mime_types\", (char*)\"\" */ /* see mongoose.c */\n    (char*)\"num_threads\", (char*)\"5\",\n    NULL, NULL, NULL, NULL,\n    NULL\n  };\n\n  docs_dir = strdup(_docs_dir), scripts_dir = strdup(_scripts_dir);\n  httpserver = this;\n  if(ntop->getPrefs()->get_http_port() == 0) use_http = false;\n\n  if(use_http) {\n    snprintf(ports, sizeof(ports), \"%s%s%d\",\n\t     http_binding_addr,\n\t     (http_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t     ntop->getPrefs()->get_http_port());\n  }\n\n  snprintf(ssl_cert_path, sizeof(ssl_cert_path), \"%s/ssl/%s\",\n\t   docs_dir, CONST_HTTPS_CERT_NAME);\n\n  stat_rc = stat(ssl_cert_path, &statsBuf);\n\n  if((ntop->getPrefs()->get_https_port() > 0) && (stat_rc == 0)) {\n    int i;\n\n    use_ssl = true;\n    if(use_http)\n      snprintf(ports, sizeof(ports), \"%s%s%d,%s%s%ds\",\n\t       http_binding_addr,\n\t       (http_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t       ntop->getPrefs()->get_http_port(),\n\t       https_binding_addr,\n\t       (https_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t       ntop->getPrefs()->get_https_port());\n    else\n      snprintf(ports, sizeof(ports), \"%s%s%ds\",\n\t       https_binding_addr,\n\t       (https_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t       ntop->getPrefs()->get_https_port());\n\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"Found SSL certificate %s\", ssl_cert_path);\n\n    for(i=0; http_options[i] != NULL; i++) ;\n\n    http_options[i] = (char*)\"ssl_certificate\", http_options[i+1] = ssl_cert_path;\n    ssl_enabled = true;\n  } else {\n    if(stat_rc != 0)\n      ntop->getTrace()->traceEvent(TRACE_NORMAL,\n\t\t\t\t   \"HTTPS Disabled: missing SSL certificate %s\", ssl_cert_path);\n    ntop->getTrace()->traceEvent(TRACE_NORMAL,\n\t\t\t\t \"Please read https://github.com/ntop/ntopng/blob/dev/doc/README.SSL if you want to enable SSL.\");\n    ssl_enabled = false;\n  }\n\n  /* Alternate HTTP port (required for Captive Portal) */\n  if(use_http && ntop->getPrefs()->get_alt_http_port()) {\n    snprintf(&ports[strlen(ports)], sizeof(ports) - strlen(ports) - 1, \",%s%s%d\",\n\t     http_binding_addr,\n\t     (http_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t     ntop->getPrefs()->get_alt_http_port());\n  }\n\n  if((!use_http) && (!use_ssl) & (!ssl_enabled)) {\n    if(stat_rc != 0)\n      ntop->getTrace()->traceEvent(TRACE_WARNING,\n\t\t\t\t   \"Unable to start HTTP server: HTTP is disabled and the SSL certificate is missing.\");\n    ntop->getTrace()->traceEvent(TRACE_WARNING,\n\t\t\t\t \"Starting the HTTP server on the default port\");\n    snprintf(ports, sizeof(ports), \"%d\", ntop->getPrefs()->get_http_port());\n    use_http = true;\n  }\n\n  ntop->getRedis()->get((char*)SPLASH_HTTP_PORT, tmpBuf, sizeof(tmpBuf), true);\n  if(tmpBuf[0] != '\\0') {\n    http_splash_port = atoi(tmpBuf);\n\n    if(http_splash_port > 0) {\n      snprintf(&ports[strlen(ports)], sizeof(ports) - strlen(ports) - 1, \",%s%s%d\",\n\t       http_binding_addr,\n\t       (http_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t       http_splash_port);\n\n      /* Mongoose uses network byte order */\n      http_splash_port = ntohs(http_splash_port);\n    } else\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"Ignoring HTTP splash port (%s)\", tmpBuf);\n  } else\n    http_splash_port = 0;\n\n  if(ntop->getPrefs()->is_access_log_enabled()) {\n    int i;\n\n    snprintf(access_log_path, sizeof(access_log_path), \"%s/ntopng_access.log\",\n\t     ntop->get_working_dir());\n\n    for(i=0; http_options[i] != NULL; i++)\n      ;\n\n    http_options[i] = (char*)\"access_log_file\", http_options[i+1] = access_log_path;\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"HTTP logs will be stored on %s\", access_log_path);\n  }\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.begin_request = handle_lua_request;\n  callbacks.log_message = handle_http_message;\n\n  /* mongoose */\n  http_prefix = ntop->getPrefs()->get_http_prefix(),\n    http_prefix_len = strlen(ntop->getPrefs()->get_http_prefix());\n\n  httpd_v4 = mg_start(&callbacks, NULL, (const char**)http_options);\n\n  if(httpd_v4 == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"Unable to start HTTP server (IPv4) on ports %s\", ports);\n    if (errno)\n      ntop->getTrace()->traceEvent(TRACE_ERROR, \"%s\", strerror(errno));\n    exit(-1);\n  }\n\n  /* ***************************** */\n\n  ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Web server dirs [%s][%s]\", docs_dir, scripts_dir);\n\n  if(use_http)\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"HTTP server listening on port(s) %s\",\n\t\t\t\t ports);\n\n  if(use_ssl & ssl_enabled)\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"HTTPS server listening on port %d\",\n\t\t\t\t ntop->getPrefs()->get_https_port());\n}",
        "func": "HTTPserver::HTTPserver(const char *_docs_dir, const char *_scripts_dir) {\n  struct mg_callbacks callbacks;\n  static char ports[256], ssl_cert_path[MAX_PATH] = { 0 }, access_log_path[MAX_PATH] = { 0 };\n  const char *http_binding_addr = ntop->getPrefs()->get_http_binding_address();\n  const char *https_binding_addr = ntop->getPrefs()->get_https_binding_address();\n  char tmpBuf[8];\n  bool use_ssl = false;\n  bool use_http = true;\n  struct stat statsBuf;\n  int stat_rc;\n  struct timeval tv;\n\n  /* Randomize data */\n  gettimeofday(&tv, NULL);\n  srand(tv.tv_sec + tv.tv_usec);\n  \n  static char *http_options[] = {\n    (char*)\"listening_ports\", ports,\n    (char*)\"enable_directory_listing\", (char*)\"no\",\n    (char*)\"document_root\",  (char*)_docs_dir,\n    /* (char*)\"extra_mime_types\", (char*)\"\" */ /* see mongoose.c */\n    (char*)\"num_threads\", (char*)\"5\",\n    NULL, NULL, NULL, NULL,\n    NULL\n  };\n\n  docs_dir = strdup(_docs_dir), scripts_dir = strdup(_scripts_dir);\n  httpserver = this;\n  if(ntop->getPrefs()->get_http_port() == 0) use_http = false;\n\n  if(use_http) {\n    snprintf(ports, sizeof(ports), \"%s%s%d\",\n\t     http_binding_addr,\n\t     (http_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t     ntop->getPrefs()->get_http_port());\n  }\n\n  snprintf(ssl_cert_path, sizeof(ssl_cert_path), \"%s/ssl/%s\",\n\t   docs_dir, CONST_HTTPS_CERT_NAME);\n\n  stat_rc = stat(ssl_cert_path, &statsBuf);\n\n  if((ntop->getPrefs()->get_https_port() > 0) && (stat_rc == 0)) {\n    int i;\n\n    use_ssl = true;\n    if(use_http)\n      snprintf(ports, sizeof(ports), \"%s%s%d,%s%s%ds\",\n\t       http_binding_addr,\n\t       (http_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t       ntop->getPrefs()->get_http_port(),\n\t       https_binding_addr,\n\t       (https_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t       ntop->getPrefs()->get_https_port());\n    else\n      snprintf(ports, sizeof(ports), \"%s%s%ds\",\n\t       https_binding_addr,\n\t       (https_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t       ntop->getPrefs()->get_https_port());\n\n    ntop->getTrace()->traceEvent(TRACE_INFO, \"Found SSL certificate %s\", ssl_cert_path);\n\n    for(i=0; http_options[i] != NULL; i++) ;\n\n    http_options[i] = (char*)\"ssl_certificate\", http_options[i+1] = ssl_cert_path;\n    ssl_enabled = true;\n  } else {\n    if(stat_rc != 0)\n      ntop->getTrace()->traceEvent(TRACE_NORMAL,\n\t\t\t\t   \"HTTPS Disabled: missing SSL certificate %s\", ssl_cert_path);\n    ntop->getTrace()->traceEvent(TRACE_NORMAL,\n\t\t\t\t \"Please read https://github.com/ntop/ntopng/blob/dev/doc/README.SSL if you want to enable SSL.\");\n    ssl_enabled = false;\n  }\n\n  /* Alternate HTTP port (required for Captive Portal) */\n  if(use_http && ntop->getPrefs()->get_alt_http_port()) {\n    snprintf(&ports[strlen(ports)], sizeof(ports) - strlen(ports) - 1, \",%s%s%d\",\n\t     http_binding_addr,\n\t     (http_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t     ntop->getPrefs()->get_alt_http_port());\n  }\n\n  if((!use_http) && (!use_ssl) & (!ssl_enabled)) {\n    if(stat_rc != 0)\n      ntop->getTrace()->traceEvent(TRACE_WARNING,\n\t\t\t\t   \"Unable to start HTTP server: HTTP is disabled and the SSL certificate is missing.\");\n    ntop->getTrace()->traceEvent(TRACE_WARNING,\n\t\t\t\t \"Starting the HTTP server on the default port\");\n    snprintf(ports, sizeof(ports), \"%d\", ntop->getPrefs()->get_http_port());\n    use_http = true;\n  }\n\n  ntop->getRedis()->get((char*)SPLASH_HTTP_PORT, tmpBuf, sizeof(tmpBuf), true);\n  if(tmpBuf[0] != '\\0') {\n    http_splash_port = atoi(tmpBuf);\n\n    if(http_splash_port > 0) {\n      snprintf(&ports[strlen(ports)], sizeof(ports) - strlen(ports) - 1, \",%s%s%d\",\n\t       http_binding_addr,\n\t       (http_binding_addr[0] == '\\0') ? \"\" : \":\",\n\t       http_splash_port);\n\n      /* Mongoose uses network byte order */\n      http_splash_port = ntohs(http_splash_port);\n    } else\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"Ignoring HTTP splash port (%s)\", tmpBuf);\n  } else\n    http_splash_port = 0;\n\n  if(ntop->getPrefs()->is_access_log_enabled()) {\n    int i;\n\n    snprintf(access_log_path, sizeof(access_log_path), \"%s/ntopng_access.log\",\n\t     ntop->get_working_dir());\n\n    for(i=0; http_options[i] != NULL; i++)\n      ;\n\n    http_options[i] = (char*)\"access_log_file\", http_options[i+1] = access_log_path;\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"HTTP logs will be stored on %s\", access_log_path);\n  }\n\n  memset(&callbacks, 0, sizeof(callbacks));\n  callbacks.begin_request = handle_lua_request;\n  callbacks.log_message = handle_http_message;\n\n  /* mongoose */\n  http_prefix = ntop->getPrefs()->get_http_prefix(),\n    http_prefix_len = strlen(ntop->getPrefs()->get_http_prefix());\n\n  httpd_v4 = mg_start(&callbacks, NULL, (const char**)http_options);\n\n  if(httpd_v4 == NULL) {\n    ntop->getTrace()->traceEvent(TRACE_ERROR, \"Unable to start HTTP server (IPv4) on ports %s\", ports);\n    if (errno)\n      ntop->getTrace()->traceEvent(TRACE_ERROR, \"%s\", strerror(errno));\n    exit(-1);\n  }\n\n  /* ***************************** */\n\n  ntop->getTrace()->traceEvent(TRACE_NORMAL, \"Web server dirs [%s][%s]\", docs_dir, scripts_dir);\n\n  if(use_http)\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"HTTP server listening on port(s) %s\",\n\t\t\t\t ports);\n\n  if(use_ssl & ssl_enabled)\n    ntop->getTrace()->traceEvent(TRACE_NORMAL, \"HTTPS server listening on port %d\",\n\t\t\t\t ntop->getPrefs()->get_https_port());\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,12 @@\n   bool use_http = true;\n   struct stat statsBuf;\n   int stat_rc;\n+  struct timeval tv;\n \n+  /* Randomize data */\n+  gettimeofday(&tv, NULL);\n+  srand(tv.tv_sec + tv.tv_usec);\n+  \n   static char *http_options[] = {\n     (char*)\"listening_ports\", ports,\n     (char*)\"enable_directory_listing\", (char*)\"no\",",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  struct timeval tv;",
                "  /* Randomize data */",
                "  gettimeofday(&tv, NULL);",
                "  srand(tv.tv_sec + tv.tv_usec);",
                "  "
            ]
        }
    }
]