digraph PYBIND11_MODULE {  
"1000123" [label = "(METHOD,PYBIND11_MODULE)" ]
"1000830" [label = "(METHOD_RETURN,int)" ]
"1000124" [label = "(PARAM,onnx_cpp2py_export)" ]
"1000125" [label = "(PARAM,onnx_cpp2py_export)" ]
"1000127" [label = "(<operator>.assignment,onnx_cpp2py_export.doc() = \"Python interface to ONNX\")" ]
"1000131" [label = "(<operator>.assignment,defs = onnx_cpp2py_export.def_submodule(\"defs\"))" ]
"1000133" [label = "(onnx_cpp2py_export.def_submodule,onnx_cpp2py_export.def_submodule(\"defs\"))" ]
"1000135" [label = "(<operator>.assignment,defs.doc() = \"Schema submodule\")" ]
"1000138" [label = "(<operator>.lessThan,py::register_exception<SchemaError>(defs, \"SchemaError\"))" ]
"1000140" [label = "(<operator>.greaterThan,SchemaError>(defs, \"SchemaError\"))" ]
"1000143" [label = "(IDENTIFIER,defs,)" ]
"1000144" [label = "(LITERAL,\"SchemaError\",)" ]
"1000146" [label = "(<operator>.lessThan,py::enum_<OpSchema::FormalParameterOption>(op_schema, \"FormalParameterOption\")\n      .value(\"Single\", OpSchema::Single)\n      .value(\"Optional\", OpSchema::Optional)\n      .value(\"Variadic\", OpSchema::Variadic))" ]
"1000148" [label = "(<operator>.greaterThan,OpSchema::FormalParameterOption>(op_schema, \"FormalParameterOption\")\n      .value(\"Single\", OpSchema::Single)\n      .value(\"Optional\", OpSchema::Optional)\n      .value(\"Variadic\", OpSchema::Variadic))" ]
"1000150" [label = "((op_schema, \"FormalParameterOption\")\n      .value(\"Single\", OpSchema::Single)\n      .value(\"Optional\", OpSchema::Optional)\n      .value,(op_schema, \"FormalParameterOption\")\n      .value(\"Single\", OpSchema::Single)\n      .value(\"Optional\", OpSchema::Optional)\n      .value(\"Variadic\", OpSchema::Variadic))" ]
"1000153" [label = "(<operator>.lessThan,py::enum_<OpSchema::DifferentiationCategory>(op_schema, \"DifferentiationCategory\")\n      .value(\"Unknown\", OpSchema::Unknown)\n      .value(\"Differentiable\", OpSchema::Differentiable)\n      .value(\"NonDifferentiable\", OpSchema::NonDifferentiable))" ]
"1000155" [label = "(<operator>.greaterThan,OpSchema::DifferentiationCategory>(op_schema, \"DifferentiationCategory\")\n      .value(\"Unknown\", OpSchema::Unknown)\n      .value(\"Differentiable\", OpSchema::Differentiable)\n      .value(\"NonDifferentiable\", OpSchema::NonDifferentiable))" ]
"1000157" [label = "((op_schema, \"DifferentiationCategory\")\n      .value(\"Unknown\", OpSchema::Unknown)\n      .value(\"Differentiable\", OpSchema::Differentiable)\n      .value,(op_schema, \"DifferentiationCategory\")\n      .value(\"Unknown\", OpSchema::Unknown)\n      .value(\"Differentiable\", OpSchema::Differentiable)\n      .value(\"NonDifferentiable\", OpSchema::NonDifferentiable))" ]
"1000160" [label = "(<operator>.lessThan,py::enum_<AttributeProto::AttributeType>(op_schema, \"AttrType\")\n      .value(\"FLOAT\", AttributeProto::FLOAT)\n      .value(\"INT\", AttributeProto::INT)\n      .value(\"STRING\", AttributeProto::STRING)\n      .value(\"TENSOR\", AttributeProto::TENSOR)\n      .value(\"GRAPH\", AttributeProto::GRAPH)\n      .value(\"FLOATS\", AttributeProto::FLOATS)\n      .value(\"INTS\", AttributeProto::INTS)\n      .value(\"STRINGS\", AttributeProto::STRINGS)\n      .value(\"TENSORS\", AttributeProto::TENSORS)\n      .value(\"GRAPHS\", AttributeProto::GRAPHS)\n      .value(\"SPARSE_TENSOR\", AttributeProto::SPARSE_TENSOR)\n      .value(\"SPARSE_TENSORS\", AttributeProto::SPARSE_TENSORS)\n      .value(\"TYPE_PROTO\", AttributeProto::TYPE_PROTO)\n      .value(\"TYPE_PROTOS\", AttributeProto::TYPE_PROTOS))" ]
"1000162" [label = "(<operator>.greaterThan,AttributeProto::AttributeType>(op_schema, \"AttrType\")\n      .value(\"FLOAT\", AttributeProto::FLOAT)\n      .value(\"INT\", AttributeProto::INT)\n      .value(\"STRING\", AttributeProto::STRING)\n      .value(\"TENSOR\", AttributeProto::TENSOR)\n      .value(\"GRAPH\", AttributeProto::GRAPH)\n      .value(\"FLOATS\", AttributeProto::FLOATS)\n      .value(\"INTS\", AttributeProto::INTS)\n      .value(\"STRINGS\", AttributeProto::STRINGS)\n      .value(\"TENSORS\", AttributeProto::TENSORS)\n      .value(\"GRAPHS\", AttributeProto::GRAPHS)\n      .value(\"SPARSE_TENSOR\", AttributeProto::SPARSE_TENSOR)\n      .value(\"SPARSE_TENSORS\", AttributeProto::SPARSE_TENSORS)\n      .value(\"TYPE_PROTO\", AttributeProto::TYPE_PROTO)\n      .value(\"TYPE_PROTOS\", AttributeProto::TYPE_PROTOS))" ]
"1000164" [label = "((op_schema, \"AttrType\")\n      .value(\"FLOAT\", AttributeProto::FLOAT)\n      .value(\"INT\", AttributeProto::INT)\n      .value(\"STRING\", AttributeProto::STRING)\n      .value(\"TENSOR\", AttributeProto::TENSOR)\n      .value(\"GRAPH\", AttributeProto::GRAPH)\n      .value(\"FLOATS\", AttributeProto::FLOATS)\n      .value(\"INTS\", AttributeProto::INTS)\n      .value(\"STRINGS\", AttributeProto::STRINGS)\n      .value(\"TENSORS\", AttributeProto::TENSORS)\n      .value(\"GRAPHS\", AttributeProto::GRAPHS)\n      .value(\"SPARSE_TENSOR\", AttributeProto::SPARSE_TENSOR)\n      .value(\"SPARSE_TENSORS\", AttributeProto::SPARSE_TENSORS)\n      .value(\"TYPE_PROTO\", AttributeProto::TYPE_PROTO)\n      .value,(op_schema, \"AttrType\")\n      .value(\"FLOAT\", AttributeProto::FLOAT)\n      .value(\"INT\", AttributeProto::INT)\n      .value(\"STRING\", AttributeProto::STRING)\n      .value(\"TENSOR\", AttributeProto::TENSOR)\n      .value(\"GRAPH\", AttributeProto::GRAPH)\n      .value(\"FLOATS\", AttributeProto::FLOATS)\n      .value(\"INTS\", AttributeProto::INTS)\n      .value(\"STRINGS\", AttributeProto::STRINGS)\n      .value(\"TENSORS\", AttributeProto::TENSORS)\n      .value(\"GRAPHS\", AttributeProto::GRAPHS)\n      .value(\"SPARSE_TENSOR\", AttributeProto::SPARSE_TENSOR)\n      .value(\"SPARSE_TENSORS\", AttributeProto::SPARSE_TENSORS)\n      .value(\"TYPE_PROTO\", AttributeProto::TYPE_PROTO)\n      .value(\"TYPE_PROTOS\", AttributeProto::TYPE_PROTOS))" ]
"1000167" [label = "(<operator>.lessThan,py::enum_<OpSchema::SupportType>(op_schema, \"SupportType\")\n      .value(\"COMMON\", OpSchema::SupportType::COMMON)\n      .value(\"EXPERIMENTAL\", OpSchema::SupportType::EXPERIMENTAL))" ]
"1000169" [label = "(<operator>.greaterThan,OpSchema::SupportType>(op_schema, \"SupportType\")\n      .value(\"COMMON\", OpSchema::SupportType::COMMON)\n      .value(\"EXPERIMENTAL\", OpSchema::SupportType::EXPERIMENTAL))" ]
"1000171" [label = "((op_schema, \"SupportType\")\n      .value(\"COMMON\", OpSchema::SupportType::COMMON)\n      .value,(op_schema, \"SupportType\")\n      .value(\"COMMON\", OpSchema::SupportType::COMMON)\n      .value(\"EXPERIMENTAL\", OpSchema::SupportType::EXPERIMENTAL))" ]
"1000175" [label = "(RETURN,return OpSchema::Attribute(std::move(name), std::move(description), type, required);,return OpSchema::Attribute(std::move(name), std::move(description), type, required);)" ]
"1000176" [label = "(OpSchema::Attribute,OpSchema::Attribute(std::move(name), std::move(description), type, required))" ]
"1000177" [label = "(std::move,std::move(name))" ]
"1000179" [label = "(std::move,std::move(description))" ]
"1000185" [label = "(ParseProtoFromPyBytes,ParseProtoFromPyBytes(&proto, bytes))" ]
"1000189" [label = "(RETURN,return OpSchema::Attribute(std::move(name), std::move(description), std::move(proto));,return OpSchema::Attribute(std::move(name), std::move(description), std::move(proto));)" ]
"1000190" [label = "(OpSchema::Attribute,OpSchema::Attribute(std::move(name), std::move(description), std::move(proto)))" ]
"1000191" [label = "(std::move,std::move(name))" ]
"1000193" [label = "(std::move,std::move(description))" ]
"1000195" [label = "(std::move,std::move(proto))" ]
"1000199" [label = "(attr->default_value.SerializeToString,attr->default_value.SerializeToString(&out))" ]
"1000202" [label = "(RETURN,return out;,return out;)" ]
"1000203" [label = "(IDENTIFIER,out,return out;)" ]
"1000204" [label = "(def_readonly,def_readonly(\"required\", &OpSchema::Attribute::required))" ]
"1000208" [label = "(def_readonly(\"type_param_str\", &OpSchema::TypeConstraintParam::type_param_str)\n      .def_readonly(\"allowed_type_strs\", &OpSchema::TypeConstraintParam::allowed_type_strs)\n      .def_readonly,def_readonly(\"type_param_str\", &OpSchema::TypeConstraintParam::type_param_str)\n      .def_readonly(\"allowed_type_strs\", &OpSchema::TypeConstraintParam::allowed_type_strs)\n      .def_readonly(\"description\", &OpSchema::TypeConstraintParam::description))" ]
"1000213" [label = "(RETURN,return OpSchema::FormalParameter(\n                std::move(name),\n                description,\n                std::move(type_str),\n                param_option,\n                is_homogeneous,\n                min_arity,\n                differentiation_category);,return OpSchema::FormalParameter(\n                std::move(name),\n                description,\n                std::move(type_str),\n                param_option,\n                is_homogeneous,\n                min_arity,\n                differentiation_category);)" ]
"1000214" [label = "(OpSchema::FormalParameter,OpSchema::FormalParameter(\n                std::move(name),\n                description,\n                std::move(type_str),\n                param_option,\n                is_homogeneous,\n                min_arity,\n                differentiation_category))" ]
"1000215" [label = "(std::move,std::move(name))" ]
"1000218" [label = "(std::move,std::move(type_str))" ]
"1000224" [label = "(def_property_readonly(\"name\", &OpSchema::FormalParameter::GetName)\n      .def_property_readonly(\"types\", &OpSchema::FormalParameter::GetTypes)\n      .def_property_readonly(\"type_str\", &OpSchema::FormalParameter::GetTypeStr)\n      .def_property_readonly(\"description\", &OpSchema::FormalParameter::GetDescription)\n      .def_property_readonly(\"option\", &OpSchema::FormalParameter::GetOption)\n      .def_property_readonly(\"is_homogeneous\", &OpSchema::FormalParameter::GetIsHomogeneous)\n      .def_property_readonly(\"min_arity\", &OpSchema::FormalParameter::GetMinArity)\n      .def_property_readonly,def_property_readonly(\"name\", &OpSchema::FormalParameter::GetName)\n      .def_property_readonly(\"types\", &OpSchema::FormalParameter::GetTypes)\n      .def_property_readonly(\"type_str\", &OpSchema::FormalParameter::GetTypeStr)\n      .def_property_readonly(\"description\", &OpSchema::FormalParameter::GetDescription)\n      .def_property_readonly(\"option\", &OpSchema::FormalParameter::GetOption)\n      .def_property_readonly(\"is_homogeneous\", &OpSchema::FormalParameter::GetIsHomogeneous)\n      .def_property_readonly(\"min_arity\", &OpSchema::FormalParameter::GetMinArity)\n      .def_property_readonly(\"differentiation_category\", &OpSchema::FormalParameter::GetDifferentiationCategory))" ]
"1000230" [label = "(<operator>.assignment,self = OpSchema())" ]
"1000233" [label = "(self.SetName(std::move(name)).SetDomain(std::move(domain)).SinceVersion(since_version).SetDoc,self.SetName(std::move(name)).SetDomain(std::move(domain)).SinceVersion(since_version).SetDoc(doc))" ]
"1000237" [label = "(<operator>.assignment,i = 0)" ]
"1000240" [label = "(<operator>.lessThan,i < inputs.size())" ]
"1000243" [label = "(<operator>.preIncrement,++i)" ]
"1000246" [label = "(self.Input,self.Input(i, std::move(inputs[i])))" ]
"1000248" [label = "(std::move,std::move(inputs[i]))" ]
"1000254" [label = "(<operator>.assignment,i = 0)" ]
"1000257" [label = "(<operator>.lessThan,i < outputs.size())" ]
"1000260" [label = "(<operator>.preIncrement,++i)" ]
"1000263" [label = "(self.Output,self.Output(i, std::move(outputs[i])))" ]
"1000265" [label = "(std::move,std::move(outputs[i]))" ]
"1000272" [label = "(<operator>.lessThan,std::vector<std::string> constraints)" ]
"1000274" [label = "(<operator>.greaterThan,std::string> constraints)" ]
"1000278" [label = "(<operator>.assignment,tie(type_str, constraints, description) = std::move(type_constraint))" ]
"1000279" [label = "(tie,tie(type_str, constraints, description))" ]
"1000283" [label = "(std::move,std::move(type_constraint))" ]
"1000285" [label = "(self.TypeConstraint,self.TypeConstraint(std::move(type_str), std::move(constraints), std::move(description)))" ]
"1000286" [label = "(std::move,std::move(type_str))" ]
"1000288" [label = "(std::move,std::move(constraints))" ]
"1000290" [label = "(std::move,std::move(description))" ]
"1000294" [label = "(self.Attr,self.Attr(std::move(attribute)))" ]
"1000295" [label = "(std::move,std::move(attribute))" ]
"1000297" [label = "(self.Finalize,self.Finalize())" ]
"1000298" [label = "(RETURN,return self;,return self;)" ]
"1000299" [label = "(IDENTIFIER,self,return self;)" ]
"1000305" [label = "(self.SetName,self.SetName(name))" ]
"1000308" [label = "(self.SetDomain,self.SetDomain(domain))" ]
"1000311" [label = "(self.SetDoc,self.SetDoc(doc))" ]
"1000315" [label = "(<operator>.assignment,all_function_opset_versions = op->function_opset_versions())" ]
"1000319" [label = "(<operator>.assignment,context_dependent_function_opset_versions =\n                op->context_dependent_function_opset_versions())" ]
"1000322" [label = "(all_function_opset_versions.insert,all_function_opset_versions.insert(\n                all_function_opset_versions.end(),\n                context_dependent_function_opset_versions.begin(),\n                context_dependent_function_opset_versions.end()))" ]
"1000326" [label = "(std::sort,std::sort(all_function_opset_versions.begin(), all_function_opset_versions.end()))" ]
"1000329" [label = "(all_function_opset_versions.erase,all_function_opset_versions.erase(\n                std::unique(all_function_opset_versions.begin(), all_function_opset_versions.end()),\n                all_function_opset_versions.end()))" ]
"1000330" [label = "(std::unique,std::unique(all_function_opset_versions.begin(), all_function_opset_versions.end()))" ]
"1000334" [label = "(RETURN,return all_function_opset_versions;,return all_function_opset_versions;)" ]
"1000335" [label = "(IDENTIFIER,all_function_opset_versions,return all_function_opset_versions;)" ]
"1000337" [label = "(max,max())" ]
"1000343" [label = "(<operator>.assignment,bytes = \"\")" ]
"1000347" [label = "(op->HasFunction,op->HasFunction())" ]
"1000348" [label = "(op->GetFunction()->SerializeToString,op->GetFunction()->SerializeToString(&bytes))" ]
"1000351" [label = "(RETURN,return py::bytes(bytes);,return py::bytes(bytes);)" ]
"1000352" [label = "(py::bytes,py::bytes(bytes))" ]
"1000356" [label = "(<operator>.assignment,bytes = \"\")" ]
"1000360" [label = "(<operator>.assignment,* function_proto = op->GetFunction(opset_version))" ]
"1000362" [label = "(op->GetFunction,op->GetFunction(opset_version))" ]
"1000365" [label = "(IDENTIFIER,function_proto,if (function_proto))" ]
"1000367" [label = "(function_proto->SerializeToString,function_proto->SerializeToString(&bytes))" ]
"1000370" [label = "(RETURN,return py::bytes(bytes);,return py::bytes(bytes);)" ]
"1000371" [label = "(py::bytes,py::bytes(bytes))" ]
"1000375" [label = "(ParseProtoFromPyBytes,ParseProtoFromPyBytes(&proto, bytes))" ]
"1000380" [label = "(<operator>.assignment,func_bytes = \"\")" ]
"1000384" [label = "(op->HasContextDependentFunction,op->HasContextDependentFunction())" ]
"1000387" [label = "(input_types.reserve,input_types.reserve(input_types_bytes.size()))" ]
"1000392" [label = "(ParseProtoFromPyBytes,ParseProtoFromPyBytes(&type_proto, type_bytes))" ]
"1000396" [label = "(input_types.push_back,input_types.push_back(type_proto))" ]
"1000400" [label = "(op->BuildContextDependentFunction,op->BuildContextDependentFunction(ctx, func_proto))" ]
"1000403" [label = "(func_proto.SerializeToString,func_proto.SerializeToString(&func_bytes))" ]
"1000406" [label = "(RETURN,return py::bytes(func_bytes);,return py::bytes(func_bytes);)" ]
"1000407" [label = "(py::bytes,py::bytes(func_bytes))" ]
"1000411" [label = "(ParseProtoFromPyBytes,ParseProtoFromPyBytes(&proto, bytes))" ]
"1000416" [label = "(<operator>.assignment,func_bytes = \"\")" ]
"1000420" [label = "(op->HasContextDependentFunctionWithOpsetVersion,op->HasContextDependentFunctionWithOpsetVersion(opset_version))" ]
"1000424" [label = "(input_types.reserve,input_types.reserve(input_types_bytes.size()))" ]
"1000429" [label = "(ParseProtoFromPyBytes,ParseProtoFromPyBytes(&type_proto, type_bytes))" ]
"1000433" [label = "(input_types.push_back,input_types.push_back(type_proto))" ]
"1000437" [label = "(op->BuildContextDependentFunction,op->BuildContextDependentFunction(ctx, func_proto, opset_version))" ]
"1000441" [label = "(func_proto.SerializeToString,func_proto.SerializeToString(&func_bytes))" ]
"1000444" [label = "(RETURN,return py::bytes(func_bytes);,return py::bytes(func_bytes);)" ]
"1000445" [label = "(py::bytes,py::bytes(func_bytes))" ]
"1000448" [label = "(RETURN,return OpSchemaRegistry::Schema(op_type, domain) != nullptr;,return OpSchemaRegistry::Schema(op_type, domain) != nullptr;)" ]
"1000449" [label = "(<operator>.notEquals,OpSchemaRegistry::Schema(op_type, domain) != nullptr)" ]
"1000450" [label = "(OpSchemaRegistry::Schema,OpSchemaRegistry::Schema(op_type, domain))" ]
"1000455" [label = "(RETURN,return OpSchemaRegistry::DomainToVersionRange::Instance().Map();,return OpSchemaRegistry::DomainToVersionRange::Instance().Map();)" ]
"1000456" [label = "(OpSchemaRegistry::DomainToVersionRange::Instance().Map,OpSchemaRegistry::DomainToVersionRange::Instance().Map())" ]
"1000459" [label = "(<operator>.assignment,* schema = OpSchemaRegistry::Schema(op_type, max_inclusive_version, domain))" ]
"1000461" [label = "(OpSchemaRegistry::Schema,OpSchemaRegistry::Schema(op_type, max_inclusive_version, domain))" ]
"1000466" [label = "(<operator>.logicalNot,!schema)" ]
"1000469" [label = "(fail_schema,fail_schema(\n                  \"No schema registered for '\" + op_type + \"' version '\" + std::to_string(max_inclusive_version) +\n                  \"' and domain '\" + domain + \"'!\"))" ]
"1000470" [label = "(<operator>.addition,\"No schema registered for '\" + op_type + \"' version '\" + std::to_string(max_inclusive_version) +\n                  \"' and domain '\" + domain + \"'!\")" ]
"1000472" [label = "(<operator>.addition,op_type + \"' version '\" + std::to_string(max_inclusive_version) +\n                  \"' and domain '\" + domain + \"'!\")" ]
"1000474" [label = "(<operator>.addition,\"' version '\" + std::to_string(max_inclusive_version) +\n                  \"' and domain '\" + domain + \"'!\")" ]
"1000476" [label = "(<operator>.addition,std::to_string(max_inclusive_version) +\n                  \"' and domain '\" + domain + \"'!\")" ]
"1000477" [label = "(std::to_string,std::to_string(max_inclusive_version))" ]
"1000479" [label = "(<operator>.addition,\"' and domain '\" + domain + \"'!\")" ]
"1000481" [label = "(<operator>.addition,domain + \"'!\")" ]
"1000484" [label = "(RETURN,return *schema;,return *schema;)" ]
"1000489" [label = "(<operator>.assignment,* schema = OpSchemaRegistry::Schema(op_type, domain))" ]
"1000491" [label = "(OpSchemaRegistry::Schema,OpSchemaRegistry::Schema(op_type, domain))" ]
"1000495" [label = "(<operator>.logicalNot,!schema)" ]
"1000498" [label = "(fail_schema,fail_schema(\"No schema registered for '\" + op_type + \"' and domain '\" + domain + \"'!\"))" ]
"1000499" [label = "(<operator>.addition,\"No schema registered for '\" + op_type + \"' and domain '\" + domain + \"'!\")" ]
"1000501" [label = "(<operator>.addition,op_type + \"' and domain '\" + domain + \"'!\")" ]
"1000503" [label = "(<operator>.addition,\"' and domain '\" + domain + \"'!\")" ]
"1000505" [label = "(<operator>.addition,domain + \"'!\")" ]
"1000508" [label = "(RETURN,return *schema;,return *schema;)" ]
"1000512" [label = "(RETURN,return OpSchemaRegistry::get_all_schemas();,return OpSchemaRegistry::get_all_schemas();)" ]
"1000513" [label = "(OpSchemaRegistry::get_all_schemas,OpSchemaRegistry::get_all_schemas())" ]
"1000515" [label = "(RETURN,return OpSchemaRegistry::get_all_schemas_with_history();,return OpSchemaRegistry::get_all_schemas_with_history();)" ]
"1000516" [label = "(OpSchemaRegistry::get_all_schemas_with_history,OpSchemaRegistry::get_all_schemas_with_history())" ]
"1000518" [label = "(<operator>.assignment,checker = onnx_cpp2py_export.def_submodule(\"checker\"))" ]
"1000520" [label = "(onnx_cpp2py_export.def_submodule,onnx_cpp2py_export.def_submodule(\"checker\"))" ]
"1000522" [label = "(<operator>.assignment,checker.doc() = \"Checker submodule\")" ]
"1000525" [label = "(<operator>.lessThan,py::class_<checker::CheckerContext> checker_context(checker, \"CheckerContext\"))" ]
"1000527" [label = "(<operator>.greaterThan,checker::CheckerContext> checker_context(checker, \"CheckerContext\"))" ]
"1000529" [label = "(checker_context,checker_context(checker, \"CheckerContext\"))" ]
"1000532" [label = "(def_property(\"ir_version\", &checker::CheckerContext::get_ir_version, &checker::CheckerContext::set_ir_version)\n      .def_property,def_property(\"ir_version\", &checker::CheckerContext::get_ir_version, &checker::CheckerContext::set_ir_version)\n      .def_property(\n          \"opset_imports\", &checker::CheckerContext::get_opset_imports, &checker::CheckerContext::set_opset_imports))" ]
"1000538" [label = "(<operator>.lessThan,py::class_<checker::LexicalScopeContext> lexical_scope_context(checker, \"LexicalScopeContext\"))" ]
"1000540" [label = "(<operator>.greaterThan,checker::LexicalScopeContext> lexical_scope_context(checker, \"LexicalScopeContext\"))" ]
"1000542" [label = "(lexical_scope_context,lexical_scope_context(checker, \"LexicalScopeContext\"))" ]
"1000545" [label = "(<operator>.lessThan,py::register_exception<checker::ValidationError>(checker, \"ValidationError\"))" ]
"1000547" [label = "(<operator>.greaterThan,checker::ValidationError>(checker, \"ValidationError\"))" ]
"1000550" [label = "(IDENTIFIER,checker,)" ]
"1000551" [label = "(LITERAL,\"ValidationError\",)" ]
"1000554" [label = "(ParseProtoFromPyBytes,ParseProtoFromPyBytes(&proto, bytes))" ]
"1000558" [label = "(checker::check_value_info,checker::check_value_info(proto, ctx))" ]
"1000563" [label = "(ParseProtoFromPyBytes,ParseProtoFromPyBytes(&proto, bytes))" ]
"1000567" [label = "(checker::check_tensor,checker::check_tensor(proto, ctx))" ]
"1000572" [label = "(ParseProtoFromPyBytes,ParseProtoFromPyBytes(&proto, bytes))" ]
"1000576" [label = "(checker::check_sparse_tensor,checker::check_sparse_tensor(proto, ctx))" ]
"1000581" [label = "(ParseProtoFromPyBytes,ParseProtoFromPyBytes(&proto, bytes))" ]
"1000585" [label = "(checker::check_attribute,checker::check_attribute(proto, ctx, lex_ctx))" ]
"1000591" [label = "(ParseProtoFromPyBytes,ParseProtoFromPyBytes(&proto, bytes))" ]
"1000595" [label = "(checker::check_node,checker::check_node(proto, ctx, lex_ctx))" ]
"1000601" [label = "(ParseProtoFromPyBytes,ParseProtoFromPyBytes(&proto, bytes))" ]
"1000605" [label = "(checker::check_function,checker::check_function(proto, ctx, lex_ctx))" ]
"1000611" [label = "(ParseProtoFromPyBytes,ParseProtoFromPyBytes(&proto, bytes))" ]
"1000615" [label = "(checker::check_graph,checker::check_graph(proto, ctx, lex_ctx))" ]
"1000621" [label = "(ParseProtoFromPyBytes,ParseProtoFromPyBytes(&proto, bytes))" ]
"1000625" [label = "(checker::check_model,checker::check_model(proto, full_check, skip_opset_compatibility_check))" ]
"1000629" [label = "(checker.def,checker.def(\"_resolve_external_data_location\", &checker::resolve_external_data_location))" ]
"1000634" [label = "(<operator>.assignment,version_converter = onnx_cpp2py_export.def_submodule(\"version_converter\"))" ]
"1000636" [label = "(onnx_cpp2py_export.def_submodule,onnx_cpp2py_export.def_submodule(\"version_converter\"))" ]
"1000638" [label = "(<operator>.assignment,version_converter.doc() = \"VersionConverter submodule\")" ]
"1000641" [label = "(<operator>.lessThan,py::register_exception<ConvertError>(version_converter, \"ConvertError\"))" ]
"1000643" [label = "(<operator>.greaterThan,ConvertError>(version_converter, \"ConvertError\"))" ]
"1000646" [label = "(IDENTIFIER,version_converter,)" ]
"1000647" [label = "(LITERAL,\"ConvertError\",)" ]
"1000650" [label = "(ParseProtoFromPyBytes,ParseProtoFromPyBytes(&proto, bytes))" ]
"1000654" [label = "(shape_inference::InferShapes,shape_inference::InferShapes(proto))" ]
"1000657" [label = "(<operator>.assignment,result = version_conversion::ConvertVersion(proto, target))" ]
"1000659" [label = "(version_conversion::ConvertVersion,version_conversion::ConvertVersion(proto, target))" ]
"1000663" [label = "(result.SerializeToString,result.SerializeToString(&out))" ]
"1000666" [label = "(RETURN,return py::bytes(out);,return py::bytes(out);)" ]
"1000667" [label = "(py::bytes,py::bytes(out))" ]
"1000670" [label = "(<operator>.assignment,inliner = onnx_cpp2py_export.def_submodule(\"inliner\"))" ]
"1000672" [label = "(onnx_cpp2py_export.def_submodule,onnx_cpp2py_export.def_submodule(\"inliner\"))" ]
"1000674" [label = "(<operator>.assignment,inliner.doc() = \"Inliner submodule\")" ]
"1000679" [label = "(ParseProtoFromPyBytes,ParseProtoFromPyBytes(&model, bytes))" ]
"1000683" [label = "(inliner::InlineLocalFunctions,inliner::InlineLocalFunctions(model, convert_version))" ]
"1000687" [label = "(model.SerializeToString,model.SerializeToString(&out))" ]
"1000690" [label = "(RETURN,return py::bytes(out);,return py::bytes(out);)" ]
"1000691" [label = "(py::bytes,py::bytes(out))" ]
"1000695" [label = "(ParseProtoFromPyBytes,ParseProtoFromPyBytes(&model, bytes))" ]
"1000700" [label = "(<operator>.assignment,function_id_set = inliner::FunctionIdSet::Create(std::move(function_ids), exclude))" ]
"1000702" [label = "(inliner::FunctionIdSet::Create,inliner::FunctionIdSet::Create(std::move(function_ids), exclude))" ]
"1000703" [label = "(std::move,std::move(function_ids))" ]
"1000706" [label = "(inliner::InlineSelectedFunctions,inliner::InlineSelectedFunctions(model, *function_id_set))" ]
"1000711" [label = "(model.SerializeToString,model.SerializeToString(&out))" ]
"1000714" [label = "(RETURN,return py::bytes(out);,return py::bytes(out);)" ]
"1000715" [label = "(py::bytes,py::bytes(out))" ]
"1000718" [label = "(<operator>.assignment,shape_inference = onnx_cpp2py_export.def_submodule(\"shape_inference\"))" ]
"1000720" [label = "(onnx_cpp2py_export.def_submodule,onnx_cpp2py_export.def_submodule(\"shape_inference\"))" ]
"1000722" [label = "(<operator>.assignment,shape_inference.doc() = \"Shape Inference submodule\")" ]
"1000725" [label = "(<operator>.lessThan,py::register_exception<InferenceError>(shape_inference, \"InferenceError\"))" ]
"1000727" [label = "(<operator>.greaterThan,InferenceError>(shape_inference, \"InferenceError\"))" ]
"1000730" [label = "(IDENTIFIER,shape_inference,)" ]
"1000731" [label = "(LITERAL,\"InferenceError\",)" ]
"1000734" [label = "(ParseProtoFromPyBytes,ParseProtoFromPyBytes(&proto, bytes))" ]
"1000740" [label = "(shape_inference::InferShapes,shape_inference::InferShapes(proto, OpSchemaRegistry::Instance(), options))" ]
"1000745" [label = "(proto.SerializeToString,proto.SerializeToString(&out))" ]
"1000748" [label = "(RETURN,return py::bytes(out);,return py::bytes(out);)" ]
"1000749" [label = "(py::bytes,py::bytes(out))" ]
"1000754" [label = "(shape_inference::InferShapes,shape_inference::InferShapes(model_path, output_path, OpSchemaRegistry::Instance(), options))" ]
"1000761" [label = "(ParseProtoFromPyBytes,ParseProtoFromPyBytes(&proto, function_proto_bytes))" ]
"1000766" [label = "(input_types.reserve,input_types.reserve(input_types_bytes.size()))" ]
"1000771" [label = "(ParseProtoFromPyBytes,ParseProtoFromPyBytes(&type, bytes))" ]
"1000775" [label = "(input_types.push_back,input_types.push_back(type))" ]
"1000778" [label = "(attributes.reserve,attributes.reserve(attributes_bytes.size()))" ]
"1000783" [label = "(ParseProtoFromPyBytes,ParseProtoFromPyBytes(&attr, bytes))" ]
"1000787" [label = "(attributes.push_back,attributes.push_back(attr))" ]
"1000790" [label = "(<operator>.assignment,output_types = shape_inference::InferFunctionOutputTypes(proto, input_types, attributes))" ]
"1000792" [label = "(shape_inference::InferFunctionOutputTypes,shape_inference::InferFunctionOutputTypes(proto, input_types, attributes))" ]
"1000796" [label = "(<operator>.lessThan,std::vector<py::bytes> result)" ]
"1000798" [label = "(<operator>.greaterThan,py::bytes> result)" ]
"1000801" [label = "(result.reserve,result.reserve(output_types.size()))" ]
"1000806" [label = "(type_proto.SerializeToString,type_proto.SerializeToString(&out))" ]
"1000809" [label = "(result.push_back,result.push_back(py::bytes(out)))" ]
"1000810" [label = "(py::bytes,py::bytes(out))" ]
"1000812" [label = "(RETURN,return result;,return result;)" ]
"1000813" [label = "(IDENTIFIER,result,return result;)" ]
"1000815" [label = "(<operator>.assignment,parser = onnx_cpp2py_export.def_submodule(\"parser\"))" ]
"1000817" [label = "(onnx_cpp2py_export.def_submodule,onnx_cpp2py_export.def_submodule(\"parser\"))" ]
"1000819" [label = "(<operator>.assignment,parser.doc() = \"Parser submodule\")" ]
"1000823" [label = "(<operator>.assignment,printer = onnx_cpp2py_export.def_submodule(\"printer\"))" ]
"1000825" [label = "(onnx_cpp2py_export.def_submodule,onnx_cpp2py_export.def_submodule(\"printer\"))" ]
"1000827" [label = "(<operator>.assignment,printer.doc() = \"Printer submodule\")" ]
"1000242" [label = "(inputs.size,inputs.size())" ]
"1000249" [label = "(<operator>.indirectIndexAccess,inputs[i])" ]
"1000259" [label = "(outputs.size,outputs.size())" ]
"1000266" [label = "(<operator>.indirectIndexAccess,outputs[i])" ]
"1000349" [label = "(<operator>.addressOf,&bytes)" ]
"1000388" [label = "(input_types_bytes.size,input_types_bytes.size())" ]
"1000393" [label = "(<operator>.addressOf,&type_proto)" ]
"1000404" [label = "(<operator>.addressOf,&func_bytes)" ]
"1000425" [label = "(input_types_bytes.size,input_types_bytes.size())" ]
"1000430" [label = "(<operator>.addressOf,&type_proto)" ]
"1000442" [label = "(<operator>.addressOf,&func_bytes)" ]
  "1000455" -> "1000830"  [ label = "DDG: <RET>"] 
  "1000515" -> "1000830"  [ label = "DDG: <RET>"] 
  "1000512" -> "1000830"  [ label = "DDG: <RET>"] 
  "1000444" -> "1000830"  [ label = "DDG: <RET>"] 
  "1000714" -> "1000830"  [ label = "DDG: <RET>"] 
  "1000334" -> "1000830"  [ label = "DDG: <RET>"] 
  "1000448" -> "1000830"  [ label = "DDG: <RET>"] 
  "1000812" -> "1000830"  [ label = "DDG: <RET>"] 
  "1000175" -> "1000830"  [ label = "DDG: <RET>"] 
  "1000484" -> "1000830"  [ label = "DDG: <RET>"] 
  "1000213" -> "1000830"  [ label = "DDG: <RET>"] 
  "1000298" -> "1000830"  [ label = "DDG: <RET>"] 
  "1000176" -> "1000830"  [ label = "DDG: required"] 
  "1000257" -> "1000830"  [ label = "DDG: outputs.size()"] 
  "1000326" -> "1000830"  [ label = "DDG: std::sort(all_function_opset_versions.begin(), all_function_opset_versions.end())"] 
  "1000246" -> "1000830"  [ label = "DDG: std::move(inputs[i])"] 
  "1000641" -> "1000830"  [ label = "DDG: ConvertError>(version_converter, \"ConvertError\")"] 
  "1000538" -> "1000830"  [ label = "DDG: checker::LexicalScopeContext> lexical_scope_context(checker, \"LexicalScopeContext\")"] 
  "1000396" -> "1000830"  [ label = "DDG: input_types.push_back(type_proto)"] 
  "1000185" -> "1000830"  [ label = "DDG: bytes"] 
  "1000177" -> "1000830"  [ label = "DDG: name"] 
  "1000157" -> "1000830"  [ label = "DDG: OpSchema::NonDifferentiable"] 
  "1000740" -> "1000830"  [ label = "DDG: OpSchemaRegistry::Instance()"] 
  "1000809" -> "1000830"  [ label = "DDG: py::bytes(out)"] 
  "1000285" -> "1000830"  [ label = "DDG: std::move(type_str)"] 
  "1000162" -> "1000830"  [ label = "DDG: (op_schema, \"AttrType\")\n      .value(\"FLOAT\", AttributeProto::FLOAT)\n      .value(\"INT\", AttributeProto::INT)\n      .value(\"STRING\", AttributeProto::STRING)\n      .value(\"TENSOR\", AttributeProto::TENSOR)\n      .value(\"GRAPH\", AttributeProto::GRAPH)\n      .value(\"FLOATS\", AttributeProto::FLOATS)\n      .value(\"INTS\", AttributeProto::INTS)\n      .value(\"STRINGS\", AttributeProto::STRINGS)\n      .value(\"TENSORS\", AttributeProto::TENSORS)\n      .value(\"GRAPHS\", AttributeProto::GRAPHS)\n      .value(\"SPARSE_TENSOR\", AttributeProto::SPARSE_TENSOR)\n      .value(\"SPARSE_TENSORS\", AttributeProto::SPARSE_TENSORS)\n      .value(\"TYPE_PROTO\", AttributeProto::TYPE_PROTO)\n      .value(\"TYPE_PROTOS\", AttributeProto::TYPE_PROTOS)"] 
  "1000790" -> "1000830"  [ label = "DDG: shape_inference::InferFunctionOutputTypes(proto, input_types, attributes)"] 
  "1000167" -> "1000830"  [ label = "DDG: py::enum_"] 
  "1000308" -> "1000830"  [ label = "DDG: domain"] 
  "1000185" -> "1000830"  [ label = "DDG: &proto"] 
  "1000441" -> "1000830"  [ label = "DDG: &func_bytes"] 
  "1000754" -> "1000830"  [ label = "DDG: shape_inference::InferShapes(model_path, output_path, OpSchemaRegistry::Instance(), options)"] 
  "1000547" -> "1000830"  [ label = "DDG: checker::ValidationError"] 
  "1000790" -> "1000830"  [ label = "DDG: output_types"] 
  "1000525" -> "1000830"  [ label = "DDG: py::class_<checker::CheckerContext> checker_context(checker, \"CheckerContext\")"] 
  "1000348" -> "1000830"  [ label = "DDG: &bytes"] 
  "1000290" -> "1000830"  [ label = "DDG: description"] 
  "1000650" -> "1000830"  [ label = "DDG: ParseProtoFromPyBytes(&proto, bytes)"] 
  "1000815" -> "1000830"  [ label = "DDG: parser"] 
  "1000375" -> "1000830"  [ label = "DDG: &proto"] 
  "1000679" -> "1000830"  [ label = "DDG: bytes"] 
  "1000641" -> "1000830"  [ label = "DDG: py::register_exception<ConvertError>(version_converter, \"ConvertError\")"] 
  "1000715" -> "1000830"  [ label = "DDG: out"] 
  "1000330" -> "1000830"  [ label = "DDG: all_function_opset_versions.begin()"] 
  "1000396" -> "1000830"  [ label = "DDG: type_proto"] 
  "1000311" -> "1000830"  [ label = "DDG: doc"] 
  "1000459" -> "1000830"  [ label = "DDG: OpSchemaRegistry::Schema(op_type, max_inclusive_version, domain)"] 
  "1000214" -> "1000830"  [ label = "DDG: is_homogeneous"] 
  "1000711" -> "1000830"  [ label = "DDG: model.SerializeToString(&out)"] 
  "1000754" -> "1000830"  [ label = "DDG: OpSchemaRegistry::Instance()"] 
  "1000683" -> "1000830"  [ label = "DDG: model"] 
  "1000125" -> "1000830"  [ label = "DDG: <anonymous>"] 
  "1000329" -> "1000830"  [ label = "DDG: all_function_opset_versions.end()"] 
  "1000193" -> "1000830"  [ label = "DDG: description"] 
  "1000375" -> "1000830"  [ label = "DDG: ParseProtoFromPyBytes(&proto, bytes)"] 
  "1000806" -> "1000830"  [ label = "DDG: &out"] 
  "1000695" -> "1000830"  [ label = "DDG: ParseProtoFromPyBytes(&model, bytes)"] 
  "1000663" -> "1000830"  [ label = "DDG: result.SerializeToString(&out)"] 
  "1000214" -> "1000830"  [ label = "DDG: differentiation_category"] 
  "1000787" -> "1000830"  [ label = "DDG: attr"] 
  "1000285" -> "1000830"  [ label = "DDG: self.TypeConstraint(std::move(type_str), std::move(constraints), std::move(description))"] 
  "1000360" -> "1000830"  [ label = "DDG: function_proto"] 
  "1000638" -> "1000830"  [ label = "DDG: version_converter.doc()"] 
  "1000695" -> "1000830"  [ label = "DDG: &model"] 
  "1000437" -> "1000830"  [ label = "DDG: op->BuildContextDependentFunction(ctx, func_proto, opset_version)"] 
  "1000518" -> "1000830"  [ label = "DDG: onnx_cpp2py_export.def_submodule(\"checker\")"] 
  "1000734" -> "1000830"  [ label = "DDG: &proto"] 
  "1000754" -> "1000830"  [ label = "DDG: options"] 
  "1000715" -> "1000830"  [ label = "DDG: py::bytes(out)"] 
  "1000629" -> "1000830"  [ label = "DDG: checker.def(\"_resolve_external_data_location\", &checker::resolve_external_data_location)"] 
  "1000185" -> "1000830"  [ label = "DDG: ParseProtoFromPyBytes(&proto, bytes)"] 
  "1000761" -> "1000830"  [ label = "DDG: &proto"] 
  "1000711" -> "1000830"  [ label = "DDG: &out"] 
  "1000650" -> "1000830"  [ label = "DDG: &proto"] 
  "1000505" -> "1000830"  [ label = "DDG: domain"] 
  "1000659" -> "1000830"  [ label = "DDG: proto"] 
  "1000208" -> "1000830"  [ label = "DDG: &OpSchema::TypeConstraintParam::description"] 
  "1000274" -> "1000830"  [ label = "DDG: std::string"] 
  "1000233" -> "1000830"  [ label = "DDG: self.SetName(std::move(name)).SetDomain(std::move(domain)).SinceVersion(since_version).SetDoc(doc)"] 
  "1000734" -> "1000830"  [ label = "DDG: ParseProtoFromPyBytes(&proto, bytes)"] 
  "1000283" -> "1000830"  [ label = "DDG: type_constraint"] 
  "1000411" -> "1000830"  [ label = "DDG: ParseProtoFromPyBytes(&proto, bytes)"] 
  "1000595" -> "1000830"  [ label = "DDG: checker::check_node(proto, ctx, lex_ctx)"] 
  "1000294" -> "1000830"  [ label = "DDG: self.Attr(std::move(attribute))"] 
  "1000285" -> "1000830"  [ label = "DDG: std::move(description)"] 
  "1000513" -> "1000830"  [ label = "DDG: OpSchemaRegistry::get_all_schemas()"] 
  "1000167" -> "1000830"  [ label = "DDG: OpSchema::SupportType>(op_schema, \"SupportType\")\n      .value(\"COMMON\", OpSchema::SupportType::COMMON)\n      .value(\"EXPERIMENTAL\", OpSchema::SupportType::EXPERIMENTAL)"] 
  "1000495" -> "1000830"  [ label = "DDG: schema"] 
  "1000498" -> "1000830"  [ label = "DDG: fail_schema(\"No schema registered for '\" + op_type + \"' and domain '\" + domain + \"'!\")"] 
  "1000190" -> "1000830"  [ label = "DDG: OpSchema::Attribute(std::move(name), std::move(description), std::move(proto))"] 
  "1000796" -> "1000830"  [ label = "DDG: std::vector<py::bytes> result"] 
  "1000470" -> "1000830"  [ label = "DDG: op_type + \"' version '\" + std::to_string(max_inclusive_version) +\n                  \"' and domain '\" + domain + \"'!\""] 
  "1000667" -> "1000830"  [ label = "DDG: out"] 
  "1000615" -> "1000830"  [ label = "DDG: lex_ctx"] 
  "1000384" -> "1000830"  [ label = "DDG: op->HasContextDependentFunction()"] 
  "1000215" -> "1000830"  [ label = "DDG: name"] 
  "1000663" -> "1000830"  [ label = "DDG: &out"] 
  "1000295" -> "1000830"  [ label = "DDG: attribute"] 
  "1000615" -> "1000830"  [ label = "DDG: ctx"] 
  "1000286" -> "1000830"  [ label = "DDG: type_str"] 
  "1000199" -> "1000830"  [ label = "DDG: &out"] 
  "1000792" -> "1000830"  [ label = "DDG: proto"] 
  "1000643" -> "1000830"  [ label = "DDG: ConvertError"] 
  "1000155" -> "1000830"  [ label = "DDG: (op_schema, \"DifferentiationCategory\")\n      .value(\"Unknown\", OpSchema::Unknown)\n      .value(\"Differentiable\", OpSchema::Differentiable)\n      .value(\"NonDifferentiable\", OpSchema::NonDifferentiable)"] 
  "1000775" -> "1000830"  [ label = "DDG: type"] 
  "1000176" -> "1000830"  [ label = "DDG: std::move(description)"] 
  "1000392" -> "1000830"  [ label = "DDG: ParseProtoFromPyBytes(&type_proto, type_bytes)"] 
  "1000411" -> "1000830"  [ label = "DDG: &proto"] 
  "1000683" -> "1000830"  [ label = "DDG: convert_version"] 
  "1000683" -> "1000830"  [ label = "DDG: inliner::InlineLocalFunctions(model, convert_version)"] 
  "1000679" -> "1000830"  [ label = "DDG: ParseProtoFromPyBytes(&model, bytes)"] 
  "1000679" -> "1000830"  [ label = "DDG: &model"] 
  "1000783" -> "1000830"  [ label = "DDG: ParseProtoFromPyBytes(&attr, bytes)"] 
  "1000437" -> "1000830"  [ label = "DDG: opset_version"] 
  "1000527" -> "1000830"  [ label = "DDG: checker::CheckerContext"] 
  "1000823" -> "1000830"  [ label = "DDG: printer"] 
  "1000315" -> "1000830"  [ label = "DDG: all_function_opset_versions"] 
  "1000815" -> "1000830"  [ label = "DDG: onnx_cpp2py_export.def_submodule(\"parser\")"] 
  "1000224" -> "1000830"  [ label = "DDG: &OpSchema::FormalParameter::GetDifferentiationCategory"] 
  "1000766" -> "1000830"  [ label = "DDG: input_types_bytes.size()"] 
  "1000706" -> "1000830"  [ label = "DDG: *function_id_set"] 
  "1000400" -> "1000830"  [ label = "DDG: ctx"] 
  "1000806" -> "1000830"  [ label = "DDG: type_proto.SerializeToString(&out)"] 
  "1000218" -> "1000830"  [ label = "DDG: type_str"] 
  "1000659" -> "1000830"  [ label = "DDG: target"] 
  "1000501" -> "1000830"  [ label = "DDG: \"' and domain '\" + domain + \"'!\""] 
  "1000403" -> "1000830"  [ label = "DDG: &func_bytes"] 
  "1000725" -> "1000830"  [ label = "DDG: InferenceError>(shape_inference, \"InferenceError\")"] 
  "1000240" -> "1000830"  [ label = "DDG: i < inputs.size()"] 
  "1000214" -> "1000830"  [ label = "DDG: description"] 
  "1000311" -> "1000830"  [ label = "DDG: self.SetDoc(doc)"] 
  "1000160" -> "1000830"  [ label = "DDG: py::enum_<AttributeProto::AttributeType>(op_schema, \"AttrType\")\n      .value(\"FLOAT\", AttributeProto::FLOAT)\n      .value(\"INT\", AttributeProto::INT)\n      .value(\"STRING\", AttributeProto::STRING)\n      .value(\"TENSOR\", AttributeProto::TENSOR)\n      .value(\"GRAPH\", AttributeProto::GRAPH)\n      .value(\"FLOATS\", AttributeProto::FLOATS)\n      .value(\"INTS\", AttributeProto::INTS)\n      .value(\"STRINGS\", AttributeProto::STRINGS)\n      .value(\"TENSORS\", AttributeProto::TENSORS)\n      .value(\"GRAPHS\", AttributeProto::GRAPHS)\n      .value(\"SPARSE_TENSOR\", AttributeProto::SPARSE_TENSOR)\n      .value(\"SPARSE_TENSORS\", AttributeProto::SPARSE_TENSORS)\n      .value(\"TYPE_PROTO\", AttributeProto::TYPE_PROTO)\n      .value(\"TYPE_PROTOS\", AttributeProto::TYPE_PROTOS)"] 
  "1000801" -> "1000830"  [ label = "DDG: output_types.size()"] 
  "1000214" -> "1000830"  [ label = "DDG: OpSchema::FormalParameter(\n                std::move(name),\n                description,\n                std::move(type_str),\n                param_option,\n                is_homogeneous,\n                min_arity,\n                differentiation_category)"] 
  "1000400" -> "1000830"  [ label = "DDG: func_proto"] 
  "1000407" -> "1000830"  [ label = "DDG: py::bytes(func_bytes)"] 
  "1000629" -> "1000830"  [ label = "DDG: &checker::resolve_external_data_location"] 
  "1000305" -> "1000830"  [ label = "DDG: self.SetName(name)"] 
  "1000204" -> "1000830"  [ label = "DDG: &OpSchema::Attribute::required"] 
  "1000700" -> "1000830"  [ label = "DDG: function_id_set"] 
  "1000131" -> "1000830"  [ label = "DDG: defs"] 
  "1000819" -> "1000830"  [ label = "DDG: parser.doc()"] 
  "1000138" -> "1000830"  [ label = "DDG: py::register_exception"] 
  "1000461" -> "1000830"  [ label = "DDG: max_inclusive_version"] 
  "1000466" -> "1000830"  [ label = "DDG: schema"] 
  "1000140" -> "1000830"  [ label = "DDG: SchemaError"] 
  "1000749" -> "1000830"  [ label = "DDG: out"] 
  "1000745" -> "1000830"  [ label = "DDG: proto.SerializeToString(&out)"] 
  "1000164" -> "1000830"  [ label = "DDG: AttributeProto::TYPE_PROTOS"] 
  "1000367" -> "1000830"  [ label = "DDG: &bytes"] 
  "1000263" -> "1000830"  [ label = "DDG: std::move(outputs[i])"] 
  "1000491" -> "1000830"  [ label = "DDG: domain"] 
  "1000437" -> "1000830"  [ label = "DDG: ctx"] 
  "1000792" -> "1000830"  [ label = "DDG: attributes"] 
  "1000625" -> "1000830"  [ label = "DDG: full_check"] 
  "1000138" -> "1000830"  [ label = "DDG: SchemaError>(defs, \"SchemaError\")"] 
  "1000190" -> "1000830"  [ label = "DDG: std::move(proto)"] 
  "1000433" -> "1000830"  [ label = "DDG: type_proto"] 
  "1000407" -> "1000830"  [ label = "DDG: func_bytes"] 
  "1000352" -> "1000830"  [ label = "DDG: bytes"] 
  "1000150" -> "1000830"  [ label = "DDG: OpSchema::Variadic"] 
  "1000420" -> "1000830"  [ label = "DDG: op->HasContextDependentFunctionWithOpsetVersion(opset_version)"] 
  "1000411" -> "1000830"  [ label = "DDG: bytes"] 
  "1000474" -> "1000830"  [ label = "DDG: std::to_string(max_inclusive_version) +\n                  \"' and domain '\" + domain + \"'!\""] 
  "1000153" -> "1000830"  [ label = "DDG: OpSchema::DifferentiationCategory>(op_schema, \"DifferentiationCategory\")\n      .value(\"Unknown\", OpSchema::Unknown)\n      .value(\"Differentiable\", OpSchema::Differentiable)\n      .value(\"NonDifferentiable\", OpSchema::NonDifferentiable)"] 
  "1000348" -> "1000830"  [ label = "DDG: op->GetFunction()->SerializeToString(&bytes)"] 
  "1000392" -> "1000830"  [ label = "DDG: &type_proto"] 
  "1000167" -> "1000830"  [ label = "DDG: py::enum_<OpSchema::SupportType>(op_schema, \"SupportType\")\n      .value(\"COMMON\", OpSchema::SupportType::COMMON)\n      .value(\"EXPERIMENTAL\", OpSchema::SupportType::EXPERIMENTAL)"] 
  "1000754" -> "1000830"  [ label = "DDG: model_path"] 
  "1000625" -> "1000830"  [ label = "DDG: skip_opset_compatibility_check"] 
  "1000288" -> "1000830"  [ label = "DDG: constraints"] 
  "1000532" -> "1000830"  [ label = "DDG: &checker::CheckerContext::set_opset_imports"] 
  "1000387" -> "1000830"  [ label = "DDG: input_types_bytes.size()"] 
  "1000176" -> "1000830"  [ label = "DDG: type"] 
  "1000670" -> "1000830"  [ label = "DDG: onnx_cpp2py_export.def_submodule(\"inliner\")"] 
  "1000403" -> "1000830"  [ label = "DDG: func_proto.SerializeToString(&func_bytes)"] 
  "1000798" -> "1000830"  [ label = "DDG: result"] 
  "1000449" -> "1000830"  [ label = "DDG: OpSchemaRegistry::Schema(op_type, domain)"] 
  "1000472" -> "1000830"  [ label = "DDG: \"' version '\" + std::to_string(max_inclusive_version) +\n                  \"' and domain '\" + domain + \"'!\""] 
  "1000783" -> "1000830"  [ label = "DDG: bytes"] 
  "1000190" -> "1000830"  [ label = "DDG: std::move(name)"] 
  "1000674" -> "1000830"  [ label = "DDG: inliner.doc()"] 
  "1000798" -> "1000830"  [ label = "DDG: py::bytes"] 
  "1000214" -> "1000830"  [ label = "DDG: std::move(type_str)"] 
  "1000272" -> "1000830"  [ label = "DDG: std::string> constraints"] 
  "1000347" -> "1000830"  [ label = "DDG: op->HasFunction()"] 
  "1000263" -> "1000830"  [ label = "DDG: self.Output(i, std::move(outputs[i]))"] 
  "1000740" -> "1000830"  [ label = "DDG: shape_inference::InferShapes(proto, OpSchemaRegistry::Instance(), options)"] 
  "1000516" -> "1000830"  [ label = "DDG: OpSchemaRegistry::get_all_schemas_with_history()"] 
  "1000179" -> "1000830"  [ label = "DDG: description"] 
  "1000445" -> "1000830"  [ label = "DDG: func_bytes"] 
  "1000476" -> "1000830"  [ label = "DDG: \"' and domain '\" + domain + \"'!\""] 
  "1000745" -> "1000830"  [ label = "DDG: &out"] 
  "1000495" -> "1000830"  [ label = "DDG: !schema"] 
  "1000809" -> "1000830"  [ label = "DDG: result.push_back(py::bytes(out))"] 
  "1000450" -> "1000830"  [ label = "DDG: domain"] 
  "1000783" -> "1000830"  [ label = "DDG: &attr"] 
  "1000214" -> "1000830"  [ label = "DDG: min_arity"] 
  "1000501" -> "1000830"  [ label = "DDG: op_type"] 
  "1000449" -> "1000830"  [ label = "DDG: OpSchemaRegistry::Schema(op_type, domain) != nullptr"] 
  "1000650" -> "1000830"  [ label = "DDG: bytes"] 
  "1000208" -> "1000830"  [ label = "DDG: def_readonly(\"type_param_str\", &OpSchema::TypeConstraintParam::type_param_str)\n      .def_readonly(\"allowed_type_strs\", &OpSchema::TypeConstraintParam::allowed_type_strs)\n      .def_readonly(\"description\", &OpSchema::TypeConstraintParam::description)"] 
  "1000498" -> "1000830"  [ label = "DDG: \"No schema registered for '\" + op_type + \"' and domain '\" + domain + \"'!\""] 
  "1000146" -> "1000830"  [ label = "DDG: OpSchema::FormalParameterOption>(op_schema, \"FormalParameterOption\")\n      .value(\"Single\", OpSchema::Single)\n      .value(\"Optional\", OpSchema::Optional)\n      .value(\"Variadic\", OpSchema::Variadic)"] 
  "1000558" -> "1000830"  [ label = "DDG: checker::check_value_info(proto, ctx)"] 
  "1000176" -> "1000830"  [ label = "DDG: OpSchema::Attribute(std::move(name), std::move(description), type, required)"] 
  "1000615" -> "1000830"  [ label = "DDG: checker::check_graph(proto, ctx, lex_ctx)"] 
  "1000424" -> "1000830"  [ label = "DDG: input_types_bytes.size()"] 
  "1000469" -> "1000830"  [ label = "DDG: fail_schema(\n                  \"No schema registered for '\" + op_type + \"' version '\" + std::to_string(max_inclusive_version) +\n                  \"' and domain '\" + domain + \"'!\")"] 
  "1000148" -> "1000830"  [ label = "DDG: OpSchema::FormalParameterOption"] 
  "1000476" -> "1000830"  [ label = "DDG: std::to_string(max_inclusive_version)"] 
  "1000257" -> "1000830"  [ label = "DDG: i"] 
  "1000489" -> "1000830"  [ label = "DDG: OpSchemaRegistry::Schema(op_type, domain)"] 
  "1000305" -> "1000830"  [ label = "DDG: name"] 
  "1000445" -> "1000830"  [ label = "DDG: py::bytes(func_bytes)"] 
  "1000424" -> "1000830"  [ label = "DDG: input_types.reserve(input_types_bytes.size())"] 
  "1000766" -> "1000830"  [ label = "DDG: input_types.reserve(input_types_bytes.size())"] 
  "1000827" -> "1000830"  [ label = "DDG: printer.doc()"] 
  "1000429" -> "1000830"  [ label = "DDG: type_bytes"] 
  "1000567" -> "1000830"  [ label = "DDG: checker::check_tensor(proto, ctx)"] 
  "1000706" -> "1000830"  [ label = "DDG: inliner::InlineSelectedFunctions(model, *function_id_set)"] 
  "1000687" -> "1000830"  [ label = "DDG: model.SerializeToString(&out)"] 
  "1000792" -> "1000830"  [ label = "DDG: input_types"] 
  "1000787" -> "1000830"  [ label = "DDG: attributes.push_back(attr)"] 
  "1000400" -> "1000830"  [ label = "DDG: op->BuildContextDependentFunction(ctx, func_proto)"] 
  "1000387" -> "1000830"  [ label = "DDG: input_types.reserve(input_types_bytes.size())"] 
  "1000634" -> "1000830"  [ label = "DDG: version_converter"] 
  "1000702" -> "1000830"  [ label = "DDG: exclude"] 
  "1000265" -> "1000830"  [ label = "DDG: outputs[i]"] 
  "1000670" -> "1000830"  [ label = "DDG: inliner"] 
  "1000153" -> "1000830"  [ label = "DDG: py::enum_<OpSchema::DifferentiationCategory>(op_schema, \"DifferentiationCategory\")\n      .value(\"Unknown\", OpSchema::Unknown)\n      .value(\"Differentiable\", OpSchema::Differentiable)\n      .value(\"NonDifferentiable\", OpSchema::NonDifferentiable)"] 
  "1000329" -> "1000830"  [ label = "DDG: all_function_opset_versions.erase(\n                std::unique(all_function_opset_versions.begin(), all_function_opset_versions.end()),\n                all_function_opset_versions.end())"] 
  "1000700" -> "1000830"  [ label = "DDG: inliner::FunctionIdSet::Create(std::move(function_ids), exclude)"] 
  "1000540" -> "1000830"  [ label = "DDG: lexical_scope_context(checker, \"LexicalScopeContext\")"] 
  "1000329" -> "1000830"  [ label = "DDG: std::unique(all_function_opset_versions.begin(), all_function_opset_versions.end())"] 
  "1000367" -> "1000830"  [ label = "DDG: function_proto->SerializeToString(&bytes)"] 
  "1000230" -> "1000830"  [ label = "DDG: self"] 
  "1000657" -> "1000830"  [ label = "DDG: result"] 
  "1000499" -> "1000830"  [ label = "DDG: op_type + \"' and domain '\" + domain + \"'!\""] 
  "1000542" -> "1000830"  [ label = "DDG: checker"] 
  "1000718" -> "1000830"  [ label = "DDG: onnx_cpp2py_export.def_submodule(\"shape_inference\")"] 
  "1000527" -> "1000830"  [ label = "DDG: checker_context(checker, \"CheckerContext\")"] 
  "1000749" -> "1000830"  [ label = "DDG: py::bytes(out)"] 
  "1000433" -> "1000830"  [ label = "DDG: input_types.push_back(type_proto)"] 
  "1000740" -> "1000830"  [ label = "DDG: options"] 
  "1000605" -> "1000830"  [ label = "DDG: checker::check_function(proto, ctx, lex_ctx)"] 
  "1000625" -> "1000830"  [ label = "DDG: checker::check_model(proto, full_check, skip_opset_compatibility_check)"] 
  "1000461" -> "1000830"  [ label = "DDG: domain"] 
  "1000131" -> "1000830"  [ label = "DDG: onnx_cpp2py_export.def_submodule(\"defs\")"] 
  "1000449" -> "1000830"  [ label = "DDG: nullptr"] 
  "1000718" -> "1000830"  [ label = "DDG: shape_inference"] 
  "1000297" -> "1000830"  [ label = "DDG: self.Finalize()"] 
  "1000810" -> "1000830"  [ label = "DDG: out"] 
  "1000740" -> "1000830"  [ label = "DDG: proto"] 
  "1000532" -> "1000830"  [ label = "DDG: &checker::CheckerContext::get_opset_imports"] 
  "1000294" -> "1000830"  [ label = "DDG: std::move(attribute)"] 
  "1000199" -> "1000830"  [ label = "DDG: attr->default_value.SerializeToString(&out)"] 
  "1000272" -> "1000830"  [ label = "DDG: std::vector"] 
  "1000525" -> "1000830"  [ label = "DDG: checker::CheckerContext> checker_context(checker, \"CheckerContext\")"] 
  "1000634" -> "1000830"  [ label = "DDG: onnx_cpp2py_export.def_submodule(\"version_converter\")"] 
  "1000472" -> "1000830"  [ label = "DDG: op_type"] 
  "1000375" -> "1000830"  [ label = "DDG: bytes"] 
  "1000322" -> "1000830"  [ label = "DDG: context_dependent_function_opset_versions.begin()"] 
  "1000725" -> "1000830"  [ label = "DDG: py::register_exception<InferenceError>(shape_inference, \"InferenceError\")"] 
  "1000230" -> "1000830"  [ label = "DDG: OpSchema()"] 
  "1000503" -> "1000830"  [ label = "DDG: domain + \"'!\""] 
  "1000545" -> "1000830"  [ label = "DDG: py::register_exception<checker::ValidationError>(checker, \"ValidationError\")"] 
  "1000796" -> "1000830"  [ label = "DDG: py::bytes> result"] 
  "1000322" -> "1000830"  [ label = "DDG: all_function_opset_versions.insert(\n                all_function_opset_versions.end(),\n                context_dependent_function_opset_versions.begin(),\n                context_dependent_function_opset_versions.end())"] 
  "1000725" -> "1000830"  [ label = "DDG: py::register_exception"] 
  "1000702" -> "1000830"  [ label = "DDG: std::move(function_ids)"] 
  "1000171" -> "1000830"  [ label = "DDG: OpSchema::SupportType::EXPERIMENTAL"] 
  "1000522" -> "1000830"  [ label = "DDG: checker.doc()"] 
  "1000687" -> "1000830"  [ label = "DDG: &out"] 
  "1000190" -> "1000830"  [ label = "DDG: std::move(description)"] 
  "1000657" -> "1000830"  [ label = "DDG: version_conversion::ConvertVersion(proto, target)"] 
  "1000545" -> "1000830"  [ label = "DDG: checker::ValidationError>(checker, \"ValidationError\")"] 
  "1000322" -> "1000830"  [ label = "DDG: context_dependent_function_opset_versions.end()"] 
  "1000233" -> "1000830"  [ label = "DDG: doc"] 
  "1000135" -> "1000830"  [ label = "DDG: defs.doc()"] 
  "1000420" -> "1000830"  [ label = "DDG: opset_version"] 
  "1000734" -> "1000830"  [ label = "DDG: bytes"] 
  "1000240" -> "1000830"  [ label = "DDG: inputs.size()"] 
  "1000576" -> "1000830"  [ label = "DDG: checker::check_sparse_tensor(proto, ctx)"] 
  "1000538" -> "1000830"  [ label = "DDG: py::class_"] 
  "1000214" -> "1000830"  [ label = "DDG: param_option"] 
  "1000169" -> "1000830"  [ label = "DDG: (op_schema, \"SupportType\")\n      .value(\"COMMON\", OpSchema::SupportType::COMMON)\n      .value(\"EXPERIMENTAL\", OpSchema::SupportType::EXPERIMENTAL)"] 
  "1000778" -> "1000830"  [ label = "DDG: attributes.reserve(attributes_bytes.size())"] 
  "1000285" -> "1000830"  [ label = "DDG: std::move(constraints)"] 
  "1000761" -> "1000830"  [ label = "DDG: function_proto_bytes"] 
  "1000360" -> "1000830"  [ label = "DDG: op->GetFunction(opset_version)"] 
  "1000461" -> "1000830"  [ label = "DDG: op_type"] 
  "1000214" -> "1000830"  [ label = "DDG: std::move(name)"] 
  "1000801" -> "1000830"  [ label = "DDG: result.reserve(output_types.size())"] 
  "1000176" -> "1000830"  [ label = "DDG: std::move(name)"] 
  "1000823" -> "1000830"  [ label = "DDG: onnx_cpp2py_export.def_submodule(\"printer\")"] 
  "1000441" -> "1000830"  [ label = "DDG: func_proto.SerializeToString(&func_bytes)"] 
  "1000706" -> "1000830"  [ label = "DDG: model"] 
  "1000169" -> "1000830"  [ label = "DDG: OpSchema::SupportType"] 
  "1000450" -> "1000830"  [ label = "DDG: op_type"] 
  "1000148" -> "1000830"  [ label = "DDG: (op_schema, \"FormalParameterOption\")\n      .value(\"Single\", OpSchema::Single)\n      .value(\"Optional\", OpSchema::Optional)\n      .value(\"Variadic\", OpSchema::Variadic)"] 
  "1000491" -> "1000830"  [ label = "DDG: op_type"] 
  "1000257" -> "1000830"  [ label = "DDG: i < outputs.size()"] 
  "1000352" -> "1000830"  [ label = "DDG: py::bytes(bytes)"] 
  "1000654" -> "1000830"  [ label = "DDG: shape_inference::InferShapes(proto)"] 
  "1000691" -> "1000830"  [ label = "DDG: out"] 
  "1000319" -> "1000830"  [ label = "DDG: op->context_dependent_function_opset_versions()"] 
  "1000479" -> "1000830"  [ label = "DDG: domain + \"'!\""] 
  "1000127" -> "1000830"  [ label = "DDG: onnx_cpp2py_export.doc()"] 
  "1000155" -> "1000830"  [ label = "DDG: OpSchema::DifferentiationCategory"] 
  "1000272" -> "1000830"  [ label = "DDG: std::vector<std::string> constraints"] 
  "1000761" -> "1000830"  [ label = "DDG: ParseProtoFromPyBytes(&proto, function_proto_bytes)"] 
  "1000138" -> "1000830"  [ label = "DDG: py::register_exception<SchemaError>(defs, \"SchemaError\")"] 
  "1000371" -> "1000830"  [ label = "DDG: bytes"] 
  "1000722" -> "1000830"  [ label = "DDG: shape_inference.doc()"] 
  "1000695" -> "1000830"  [ label = "DDG: bytes"] 
  "1000538" -> "1000830"  [ label = "DDG: py::class_<checker::LexicalScopeContext> lexical_scope_context(checker, \"LexicalScopeContext\")"] 
  "1000429" -> "1000830"  [ label = "DDG: &type_proto"] 
  "1000437" -> "1000830"  [ label = "DDG: func_proto"] 
  "1000319" -> "1000830"  [ label = "DDG: context_dependent_function_opset_versions"] 
  "1000727" -> "1000830"  [ label = "DDG: InferenceError"] 
  "1000162" -> "1000830"  [ label = "DDG: AttributeProto::AttributeType"] 
  "1000195" -> "1000830"  [ label = "DDG: proto"] 
  "1000160" -> "1000830"  [ label = "DDG: AttributeProto::AttributeType>(op_schema, \"AttrType\")\n      .value(\"FLOAT\", AttributeProto::FLOAT)\n      .value(\"INT\", AttributeProto::INT)\n      .value(\"STRING\", AttributeProto::STRING)\n      .value(\"TENSOR\", AttributeProto::TENSOR)\n      .value(\"GRAPH\", AttributeProto::GRAPH)\n      .value(\"FLOATS\", AttributeProto::FLOATS)\n      .value(\"INTS\", AttributeProto::INTS)\n      .value(\"STRINGS\", AttributeProto::STRINGS)\n      .value(\"TENSORS\", AttributeProto::TENSORS)\n      .value(\"GRAPHS\", AttributeProto::GRAPHS)\n      .value(\"SPARSE_TENSOR\", AttributeProto::SPARSE_TENSOR)\n      .value(\"SPARSE_TENSORS\", AttributeProto::SPARSE_TENSORS)\n      .value(\"TYPE_PROTO\", AttributeProto::TYPE_PROTO)\n      .value(\"TYPE_PROTOS\", AttributeProto::TYPE_PROTOS)"] 
  "1000246" -> "1000830"  [ label = "DDG: self.Input(i, std::move(inputs[i]))"] 
  "1000477" -> "1000830"  [ label = "DDG: max_inclusive_version"] 
  "1000278" -> "1000830"  [ label = "DDG: std::move(type_constraint)"] 
  "1000146" -> "1000830"  [ label = "DDG: py::enum_<OpSchema::FormalParameterOption>(op_schema, \"FormalParameterOption\")\n      .value(\"Single\", OpSchema::Single)\n      .value(\"Optional\", OpSchema::Optional)\n      .value(\"Variadic\", OpSchema::Variadic)"] 
  "1000771" -> "1000830"  [ label = "DDG: &type"] 
  "1000754" -> "1000830"  [ label = "DDG: output_path"] 
  "1000641" -> "1000830"  [ label = "DDG: py::register_exception"] 
  "1000308" -> "1000830"  [ label = "DDG: self.SetDomain(domain)"] 
  "1000532" -> "1000830"  [ label = "DDG: def_property(\"ir_version\", &checker::CheckerContext::get_ir_version, &checker::CheckerContext::set_ir_version)\n      .def_property(\n          \"opset_imports\", &checker::CheckerContext::get_opset_imports, &checker::CheckerContext::set_opset_imports)"] 
  "1000703" -> "1000830"  [ label = "DDG: function_ids"] 
  "1000469" -> "1000830"  [ label = "DDG: \"No schema registered for '\" + op_type + \"' version '\" + std::to_string(max_inclusive_version) +\n                  \"' and domain '\" + domain + \"'!\""] 
  "1000778" -> "1000830"  [ label = "DDG: attributes_bytes.size()"] 
  "1000540" -> "1000830"  [ label = "DDG: checker::LexicalScopeContext"] 
  "1000278" -> "1000830"  [ label = "DDG: tie(type_str, constraints, description)"] 
  "1000337" -> "1000830"  [ label = "DDG: max()"] 
  "1000429" -> "1000830"  [ label = "DDG: ParseProtoFromPyBytes(&type_proto, type_bytes)"] 
  "1000191" -> "1000830"  [ label = "DDG: name"] 
  "1000771" -> "1000830"  [ label = "DDG: ParseProtoFromPyBytes(&type, bytes)"] 
  "1000456" -> "1000830"  [ label = "DDG: OpSchemaRegistry::DomainToVersionRange::Instance().Map()"] 
  "1000775" -> "1000830"  [ label = "DDG: input_types.push_back(type)"] 
  "1000371" -> "1000830"  [ label = "DDG: py::bytes(bytes)"] 
  "1000585" -> "1000830"  [ label = "DDG: checker::check_attribute(proto, ctx, lex_ctx)"] 
  "1000248" -> "1000830"  [ label = "DDG: inputs[i]"] 
  "1000362" -> "1000830"  [ label = "DDG: opset_version"] 
  "1000224" -> "1000830"  [ label = "DDG: def_property_readonly(\"name\", &OpSchema::FormalParameter::GetName)\n      .def_property_readonly(\"types\", &OpSchema::FormalParameter::GetTypes)\n      .def_property_readonly(\"type_str\", &OpSchema::FormalParameter::GetTypeStr)\n      .def_property_readonly(\"description\", &OpSchema::FormalParameter::GetDescription)\n      .def_property_readonly(\"option\", &OpSchema::FormalParameter::GetOption)\n      .def_property_readonly(\"is_homogeneous\", &OpSchema::FormalParameter::GetIsHomogeneous)\n      .def_property_readonly(\"min_arity\", &OpSchema::FormalParameter::GetMinArity)\n      .def_property_readonly(\"differentiation_category\", &OpSchema::FormalParameter::GetDifferentiationCategory)"] 
  "1000796" -> "1000830"  [ label = "DDG: std::vector"] 
  "1000481" -> "1000830"  [ label = "DDG: domain"] 
  "1000124" -> "1000830"  [ label = "DDG: <anonymous>"] 
  "1000204" -> "1000830"  [ label = "DDG: def_readonly(\"required\", &OpSchema::Attribute::required)"] 
  "1000466" -> "1000830"  [ label = "DDG: !schema"] 
  "1000667" -> "1000830"  [ label = "DDG: py::bytes(out)"] 
  "1000392" -> "1000830"  [ label = "DDG: type_bytes"] 
  "1000315" -> "1000830"  [ label = "DDG: op->function_opset_versions()"] 
  "1000691" -> "1000830"  [ label = "DDG: py::bytes(out)"] 
  "1000202" -> "1000830"  [ label = "DDG: <RET>"] 
  "1000690" -> "1000830"  [ label = "DDG: <RET>"] 
  "1000370" -> "1000830"  [ label = "DDG: <RET>"] 
  "1000189" -> "1000830"  [ label = "DDG: <RET>"] 
  "1000351" -> "1000830"  [ label = "DDG: <RET>"] 
  "1000748" -> "1000830"  [ label = "DDG: <RET>"] 
  "1000508" -> "1000830"  [ label = "DDG: <RET>"] 
  "1000406" -> "1000830"  [ label = "DDG: <RET>"] 
  "1000666" -> "1000830"  [ label = "DDG: <RET>"] 
  "1000123" -> "1000124"  [ label = "DDG: "] 
  "1000123" -> "1000125"  [ label = "DDG: "] 
  "1000123" -> "1000127"  [ label = "DDG: "] 
  "1000133" -> "1000131"  [ label = "DDG: \"defs\""] 
  "1000123" -> "1000131"  [ label = "DDG: "] 
  "1000123" -> "1000133"  [ label = "DDG: "] 
  "1000123" -> "1000135"  [ label = "DDG: "] 
  "1000123" -> "1000138"  [ label = "DDG: "] 
  "1000140" -> "1000138"  [ label = "DDG: SchemaError"] 
  "1000123" -> "1000140"  [ label = "DDG: "] 
  "1000123" -> "1000143"  [ label = "DDG: "] 
  "1000123" -> "1000144"  [ label = "DDG: "] 
  "1000123" -> "1000146"  [ label = "DDG: "] 
  "1000148" -> "1000146"  [ label = "DDG: OpSchema::FormalParameterOption"] 
  "1000148" -> "1000146"  [ label = "DDG: (op_schema, \"FormalParameterOption\")\n      .value(\"Single\", OpSchema::Single)\n      .value(\"Optional\", OpSchema::Optional)\n      .value(\"Variadic\", OpSchema::Variadic)"] 
  "1000123" -> "1000148"  [ label = "DDG: "] 
  "1000150" -> "1000148"  [ label = "DDG: \"Variadic\""] 
  "1000150" -> "1000148"  [ label = "DDG: OpSchema::Variadic"] 
  "1000123" -> "1000150"  [ label = "DDG: "] 
  "1000146" -> "1000153"  [ label = "DDG: py::enum_"] 
  "1000123" -> "1000153"  [ label = "DDG: "] 
  "1000155" -> "1000153"  [ label = "DDG: OpSchema::DifferentiationCategory"] 
  "1000155" -> "1000153"  [ label = "DDG: (op_schema, \"DifferentiationCategory\")\n      .value(\"Unknown\", OpSchema::Unknown)\n      .value(\"Differentiable\", OpSchema::Differentiable)\n      .value(\"NonDifferentiable\", OpSchema::NonDifferentiable)"] 
  "1000123" -> "1000155"  [ label = "DDG: "] 
  "1000157" -> "1000155"  [ label = "DDG: \"NonDifferentiable\""] 
  "1000157" -> "1000155"  [ label = "DDG: OpSchema::NonDifferentiable"] 
  "1000123" -> "1000157"  [ label = "DDG: "] 
  "1000153" -> "1000160"  [ label = "DDG: py::enum_"] 
  "1000123" -> "1000160"  [ label = "DDG: "] 
  "1000162" -> "1000160"  [ label = "DDG: AttributeProto::AttributeType"] 
  "1000162" -> "1000160"  [ label = "DDG: (op_schema, \"AttrType\")\n      .value(\"FLOAT\", AttributeProto::FLOAT)\n      .value(\"INT\", AttributeProto::INT)\n      .value(\"STRING\", AttributeProto::STRING)\n      .value(\"TENSOR\", AttributeProto::TENSOR)\n      .value(\"GRAPH\", AttributeProto::GRAPH)\n      .value(\"FLOATS\", AttributeProto::FLOATS)\n      .value(\"INTS\", AttributeProto::INTS)\n      .value(\"STRINGS\", AttributeProto::STRINGS)\n      .value(\"TENSORS\", AttributeProto::TENSORS)\n      .value(\"GRAPHS\", AttributeProto::GRAPHS)\n      .value(\"SPARSE_TENSOR\", AttributeProto::SPARSE_TENSOR)\n      .value(\"SPARSE_TENSORS\", AttributeProto::SPARSE_TENSORS)\n      .value(\"TYPE_PROTO\", AttributeProto::TYPE_PROTO)\n      .value(\"TYPE_PROTOS\", AttributeProto::TYPE_PROTOS)"] 
  "1000123" -> "1000162"  [ label = "DDG: "] 
  "1000164" -> "1000162"  [ label = "DDG: \"TYPE_PROTOS\""] 
  "1000164" -> "1000162"  [ label = "DDG: AttributeProto::TYPE_PROTOS"] 
  "1000123" -> "1000164"  [ label = "DDG: "] 
  "1000160" -> "1000167"  [ label = "DDG: py::enum_"] 
  "1000123" -> "1000167"  [ label = "DDG: "] 
  "1000169" -> "1000167"  [ label = "DDG: OpSchema::SupportType"] 
  "1000169" -> "1000167"  [ label = "DDG: (op_schema, \"SupportType\")\n      .value(\"COMMON\", OpSchema::SupportType::COMMON)\n      .value(\"EXPERIMENTAL\", OpSchema::SupportType::EXPERIMENTAL)"] 
  "1000123" -> "1000169"  [ label = "DDG: "] 
  "1000171" -> "1000169"  [ label = "DDG: \"EXPERIMENTAL\""] 
  "1000171" -> "1000169"  [ label = "DDG: OpSchema::SupportType::EXPERIMENTAL"] 
  "1000123" -> "1000171"  [ label = "DDG: "] 
  "1000176" -> "1000175"  [ label = "DDG: OpSchema::Attribute(std::move(name), std::move(description), type, required)"] 
  "1000177" -> "1000176"  [ label = "DDG: name"] 
  "1000123" -> "1000177"  [ label = "DDG: "] 
  "1000179" -> "1000176"  [ label = "DDG: description"] 
  "1000123" -> "1000179"  [ label = "DDG: "] 
  "1000123" -> "1000176"  [ label = "DDG: "] 
  "1000123" -> "1000185"  [ label = "DDG: "] 
  "1000190" -> "1000189"  [ label = "DDG: OpSchema::Attribute(std::move(name), std::move(description), std::move(proto))"] 
  "1000191" -> "1000190"  [ label = "DDG: name"] 
  "1000123" -> "1000191"  [ label = "DDG: "] 
  "1000193" -> "1000190"  [ label = "DDG: description"] 
  "1000123" -> "1000193"  [ label = "DDG: "] 
  "1000195" -> "1000190"  [ label = "DDG: proto"] 
  "1000123" -> "1000195"  [ label = "DDG: "] 
  "1000203" -> "1000202"  [ label = "DDG: out"] 
  "1000123" -> "1000202"  [ label = "DDG: "] 
  "1000123" -> "1000203"  [ label = "DDG: "] 
  "1000123" -> "1000204"  [ label = "DDG: "] 
  "1000123" -> "1000208"  [ label = "DDG: "] 
  "1000214" -> "1000213"  [ label = "DDG: OpSchema::FormalParameter(\n                std::move(name),\n                description,\n                std::move(type_str),\n                param_option,\n                is_homogeneous,\n                min_arity,\n                differentiation_category)"] 
  "1000215" -> "1000214"  [ label = "DDG: name"] 
  "1000123" -> "1000215"  [ label = "DDG: "] 
  "1000123" -> "1000214"  [ label = "DDG: "] 
  "1000218" -> "1000214"  [ label = "DDG: type_str"] 
  "1000123" -> "1000218"  [ label = "DDG: "] 
  "1000123" -> "1000224"  [ label = "DDG: "] 
  "1000123" -> "1000230"  [ label = "DDG: "] 
  "1000123" -> "1000233"  [ label = "DDG: "] 
  "1000123" -> "1000237"  [ label = "DDG: "] 
  "1000237" -> "1000240"  [ label = "DDG: i"] 
  "1000243" -> "1000240"  [ label = "DDG: i"] 
  "1000123" -> "1000240"  [ label = "DDG: "] 
  "1000246" -> "1000243"  [ label = "DDG: i"] 
  "1000123" -> "1000243"  [ label = "DDG: "] 
  "1000240" -> "1000246"  [ label = "DDG: i"] 
  "1000123" -> "1000246"  [ label = "DDG: "] 
  "1000248" -> "1000246"  [ label = "DDG: inputs[i]"] 
  "1000123" -> "1000254"  [ label = "DDG: "] 
  "1000254" -> "1000257"  [ label = "DDG: i"] 
  "1000260" -> "1000257"  [ label = "DDG: i"] 
  "1000123" -> "1000257"  [ label = "DDG: "] 
  "1000263" -> "1000260"  [ label = "DDG: i"] 
  "1000123" -> "1000260"  [ label = "DDG: "] 
  "1000257" -> "1000263"  [ label = "DDG: i"] 
  "1000123" -> "1000263"  [ label = "DDG: "] 
  "1000265" -> "1000263"  [ label = "DDG: outputs[i]"] 
  "1000123" -> "1000272"  [ label = "DDG: "] 
  "1000274" -> "1000272"  [ label = "DDG: std::string"] 
  "1000274" -> "1000272"  [ label = "DDG: constraints"] 
  "1000123" -> "1000274"  [ label = "DDG: "] 
  "1000283" -> "1000278"  [ label = "DDG: type_constraint"] 
  "1000123" -> "1000279"  [ label = "DDG: "] 
  "1000274" -> "1000279"  [ label = "DDG: constraints"] 
  "1000123" -> "1000283"  [ label = "DDG: "] 
  "1000286" -> "1000285"  [ label = "DDG: type_str"] 
  "1000279" -> "1000286"  [ label = "DDG: type_str"] 
  "1000123" -> "1000286"  [ label = "DDG: "] 
  "1000288" -> "1000285"  [ label = "DDG: constraints"] 
  "1000279" -> "1000288"  [ label = "DDG: constraints"] 
  "1000123" -> "1000288"  [ label = "DDG: "] 
  "1000290" -> "1000285"  [ label = "DDG: description"] 
  "1000279" -> "1000290"  [ label = "DDG: description"] 
  "1000123" -> "1000290"  [ label = "DDG: "] 
  "1000295" -> "1000294"  [ label = "DDG: attribute"] 
  "1000123" -> "1000295"  [ label = "DDG: "] 
  "1000123" -> "1000297"  [ label = "DDG: "] 
  "1000299" -> "1000298"  [ label = "DDG: self"] 
  "1000230" -> "1000298"  [ label = "DDG: self"] 
  "1000123" -> "1000299"  [ label = "DDG: "] 
  "1000123" -> "1000305"  [ label = "DDG: "] 
  "1000123" -> "1000308"  [ label = "DDG: "] 
  "1000123" -> "1000311"  [ label = "DDG: "] 
  "1000123" -> "1000315"  [ label = "DDG: "] 
  "1000123" -> "1000319"  [ label = "DDG: "] 
  "1000123" -> "1000322"  [ label = "DDG: "] 
  "1000123" -> "1000326"  [ label = "DDG: "] 
  "1000330" -> "1000329"  [ label = "DDG: all_function_opset_versions.begin()"] 
  "1000330" -> "1000329"  [ label = "DDG: all_function_opset_versions.end()"] 
  "1000123" -> "1000330"  [ label = "DDG: "] 
  "1000123" -> "1000329"  [ label = "DDG: "] 
  "1000335" -> "1000334"  [ label = "DDG: all_function_opset_versions"] 
  "1000315" -> "1000334"  [ label = "DDG: all_function_opset_versions"] 
  "1000123" -> "1000335"  [ label = "DDG: "] 
  "1000123" -> "1000337"  [ label = "DDG: "] 
  "1000123" -> "1000343"  [ label = "DDG: "] 
  "1000123" -> "1000347"  [ label = "DDG: "] 
  "1000352" -> "1000351"  [ label = "DDG: py::bytes(bytes)"] 
  "1000343" -> "1000352"  [ label = "DDG: bytes"] 
  "1000123" -> "1000352"  [ label = "DDG: "] 
  "1000123" -> "1000356"  [ label = "DDG: "] 
  "1000362" -> "1000360"  [ label = "DDG: opset_version"] 
  "1000123" -> "1000360"  [ label = "DDG: "] 
  "1000123" -> "1000362"  [ label = "DDG: "] 
  "1000123" -> "1000365"  [ label = "DDG: "] 
  "1000371" -> "1000370"  [ label = "DDG: py::bytes(bytes)"] 
  "1000356" -> "1000371"  [ label = "DDG: bytes"] 
  "1000123" -> "1000371"  [ label = "DDG: "] 
  "1000123" -> "1000375"  [ label = "DDG: "] 
  "1000123" -> "1000380"  [ label = "DDG: "] 
  "1000123" -> "1000384"  [ label = "DDG: "] 
  "1000123" -> "1000387"  [ label = "DDG: "] 
  "1000123" -> "1000392"  [ label = "DDG: "] 
  "1000123" -> "1000396"  [ label = "DDG: "] 
  "1000123" -> "1000400"  [ label = "DDG: "] 
  "1000407" -> "1000406"  [ label = "DDG: py::bytes(func_bytes)"] 
  "1000380" -> "1000407"  [ label = "DDG: func_bytes"] 
  "1000123" -> "1000407"  [ label = "DDG: "] 
  "1000123" -> "1000411"  [ label = "DDG: "] 
  "1000123" -> "1000416"  [ label = "DDG: "] 
  "1000123" -> "1000420"  [ label = "DDG: "] 
  "1000123" -> "1000424"  [ label = "DDG: "] 
  "1000123" -> "1000429"  [ label = "DDG: "] 
  "1000123" -> "1000433"  [ label = "DDG: "] 
  "1000123" -> "1000437"  [ label = "DDG: "] 
  "1000420" -> "1000437"  [ label = "DDG: opset_version"] 
  "1000445" -> "1000444"  [ label = "DDG: py::bytes(func_bytes)"] 
  "1000416" -> "1000445"  [ label = "DDG: func_bytes"] 
  "1000123" -> "1000445"  [ label = "DDG: "] 
  "1000449" -> "1000448"  [ label = "DDG: OpSchemaRegistry::Schema(op_type, domain) != nullptr"] 
  "1000450" -> "1000449"  [ label = "DDG: op_type"] 
  "1000450" -> "1000449"  [ label = "DDG: domain"] 
  "1000123" -> "1000450"  [ label = "DDG: "] 
  "1000123" -> "1000449"  [ label = "DDG: "] 
  "1000456" -> "1000455"  [ label = "DDG: OpSchemaRegistry::DomainToVersionRange::Instance().Map()"] 
  "1000123" -> "1000456"  [ label = "DDG: "] 
  "1000461" -> "1000459"  [ label = "DDG: op_type"] 
  "1000461" -> "1000459"  [ label = "DDG: max_inclusive_version"] 
  "1000461" -> "1000459"  [ label = "DDG: domain"] 
  "1000123" -> "1000459"  [ label = "DDG: "] 
  "1000123" -> "1000461"  [ label = "DDG: "] 
  "1000459" -> "1000466"  [ label = "DDG: schema"] 
  "1000123" -> "1000466"  [ label = "DDG: "] 
  "1000123" -> "1000469"  [ label = "DDG: "] 
  "1000461" -> "1000469"  [ label = "DDG: op_type"] 
  "1000477" -> "1000469"  [ label = "DDG: max_inclusive_version"] 
  "1000461" -> "1000469"  [ label = "DDG: domain"] 
  "1000123" -> "1000470"  [ label = "DDG: "] 
  "1000461" -> "1000470"  [ label = "DDG: op_type"] 
  "1000477" -> "1000470"  [ label = "DDG: max_inclusive_version"] 
  "1000461" -> "1000470"  [ label = "DDG: domain"] 
  "1000461" -> "1000472"  [ label = "DDG: op_type"] 
  "1000123" -> "1000472"  [ label = "DDG: "] 
  "1000477" -> "1000472"  [ label = "DDG: max_inclusive_version"] 
  "1000461" -> "1000472"  [ label = "DDG: domain"] 
  "1000123" -> "1000474"  [ label = "DDG: "] 
  "1000477" -> "1000474"  [ label = "DDG: max_inclusive_version"] 
  "1000461" -> "1000474"  [ label = "DDG: domain"] 
  "1000477" -> "1000476"  [ label = "DDG: max_inclusive_version"] 
  "1000461" -> "1000477"  [ label = "DDG: max_inclusive_version"] 
  "1000123" -> "1000477"  [ label = "DDG: "] 
  "1000123" -> "1000476"  [ label = "DDG: "] 
  "1000461" -> "1000476"  [ label = "DDG: domain"] 
  "1000123" -> "1000479"  [ label = "DDG: "] 
  "1000461" -> "1000479"  [ label = "DDG: domain"] 
  "1000461" -> "1000481"  [ label = "DDG: domain"] 
  "1000123" -> "1000481"  [ label = "DDG: "] 
  "1000123" -> "1000484"  [ label = "DDG: "] 
  "1000491" -> "1000489"  [ label = "DDG: op_type"] 
  "1000491" -> "1000489"  [ label = "DDG: domain"] 
  "1000123" -> "1000489"  [ label = "DDG: "] 
  "1000123" -> "1000491"  [ label = "DDG: "] 
  "1000489" -> "1000495"  [ label = "DDG: schema"] 
  "1000123" -> "1000495"  [ label = "DDG: "] 
  "1000123" -> "1000498"  [ label = "DDG: "] 
  "1000491" -> "1000498"  [ label = "DDG: op_type"] 
  "1000491" -> "1000498"  [ label = "DDG: domain"] 
  "1000123" -> "1000499"  [ label = "DDG: "] 
  "1000491" -> "1000499"  [ label = "DDG: op_type"] 
  "1000491" -> "1000499"  [ label = "DDG: domain"] 
  "1000491" -> "1000501"  [ label = "DDG: op_type"] 
  "1000123" -> "1000501"  [ label = "DDG: "] 
  "1000491" -> "1000501"  [ label = "DDG: domain"] 
  "1000123" -> "1000503"  [ label = "DDG: "] 
  "1000491" -> "1000503"  [ label = "DDG: domain"] 
  "1000491" -> "1000505"  [ label = "DDG: domain"] 
  "1000123" -> "1000505"  [ label = "DDG: "] 
  "1000123" -> "1000508"  [ label = "DDG: "] 
  "1000513" -> "1000512"  [ label = "DDG: OpSchemaRegistry::get_all_schemas()"] 
  "1000123" -> "1000513"  [ label = "DDG: "] 
  "1000516" -> "1000515"  [ label = "DDG: OpSchemaRegistry::get_all_schemas_with_history()"] 
  "1000123" -> "1000516"  [ label = "DDG: "] 
  "1000520" -> "1000518"  [ label = "DDG: \"checker\""] 
  "1000123" -> "1000518"  [ label = "DDG: "] 
  "1000123" -> "1000520"  [ label = "DDG: "] 
  "1000123" -> "1000522"  [ label = "DDG: "] 
  "1000123" -> "1000525"  [ label = "DDG: "] 
  "1000527" -> "1000525"  [ label = "DDG: checker::CheckerContext"] 
  "1000527" -> "1000525"  [ label = "DDG: checker_context(checker, \"CheckerContext\")"] 
  "1000123" -> "1000527"  [ label = "DDG: "] 
  "1000529" -> "1000527"  [ label = "DDG: checker"] 
  "1000529" -> "1000527"  [ label = "DDG: \"CheckerContext\""] 
  "1000518" -> "1000529"  [ label = "DDG: checker"] 
  "1000123" -> "1000529"  [ label = "DDG: "] 
  "1000123" -> "1000532"  [ label = "DDG: "] 
  "1000525" -> "1000538"  [ label = "DDG: py::class_"] 
  "1000123" -> "1000538"  [ label = "DDG: "] 
  "1000540" -> "1000538"  [ label = "DDG: checker::LexicalScopeContext"] 
  "1000540" -> "1000538"  [ label = "DDG: lexical_scope_context(checker, \"LexicalScopeContext\")"] 
  "1000123" -> "1000540"  [ label = "DDG: "] 
  "1000542" -> "1000540"  [ label = "DDG: checker"] 
  "1000542" -> "1000540"  [ label = "DDG: \"LexicalScopeContext\""] 
  "1000529" -> "1000542"  [ label = "DDG: checker"] 
  "1000123" -> "1000542"  [ label = "DDG: "] 
  "1000123" -> "1000545"  [ label = "DDG: "] 
  "1000547" -> "1000545"  [ label = "DDG: checker::ValidationError"] 
  "1000123" -> "1000547"  [ label = "DDG: "] 
  "1000123" -> "1000550"  [ label = "DDG: "] 
  "1000123" -> "1000551"  [ label = "DDG: "] 
  "1000123" -> "1000554"  [ label = "DDG: "] 
  "1000123" -> "1000558"  [ label = "DDG: "] 
  "1000554" -> "1000563"  [ label = "DDG: &proto"] 
  "1000554" -> "1000563"  [ label = "DDG: bytes"] 
  "1000123" -> "1000563"  [ label = "DDG: "] 
  "1000558" -> "1000567"  [ label = "DDG: proto"] 
  "1000123" -> "1000567"  [ label = "DDG: "] 
  "1000558" -> "1000567"  [ label = "DDG: ctx"] 
  "1000563" -> "1000572"  [ label = "DDG: &proto"] 
  "1000563" -> "1000572"  [ label = "DDG: bytes"] 
  "1000123" -> "1000572"  [ label = "DDG: "] 
  "1000567" -> "1000576"  [ label = "DDG: proto"] 
  "1000123" -> "1000576"  [ label = "DDG: "] 
  "1000567" -> "1000576"  [ label = "DDG: ctx"] 
  "1000572" -> "1000581"  [ label = "DDG: &proto"] 
  "1000572" -> "1000581"  [ label = "DDG: bytes"] 
  "1000123" -> "1000581"  [ label = "DDG: "] 
  "1000576" -> "1000585"  [ label = "DDG: proto"] 
  "1000123" -> "1000585"  [ label = "DDG: "] 
  "1000576" -> "1000585"  [ label = "DDG: ctx"] 
  "1000581" -> "1000591"  [ label = "DDG: &proto"] 
  "1000581" -> "1000591"  [ label = "DDG: bytes"] 
  "1000123" -> "1000591"  [ label = "DDG: "] 
  "1000585" -> "1000595"  [ label = "DDG: proto"] 
  "1000123" -> "1000595"  [ label = "DDG: "] 
  "1000585" -> "1000595"  [ label = "DDG: ctx"] 
  "1000585" -> "1000595"  [ label = "DDG: lex_ctx"] 
  "1000591" -> "1000601"  [ label = "DDG: &proto"] 
  "1000591" -> "1000601"  [ label = "DDG: bytes"] 
  "1000123" -> "1000601"  [ label = "DDG: "] 
  "1000595" -> "1000605"  [ label = "DDG: proto"] 
  "1000123" -> "1000605"  [ label = "DDG: "] 
  "1000595" -> "1000605"  [ label = "DDG: ctx"] 
  "1000595" -> "1000605"  [ label = "DDG: lex_ctx"] 
  "1000601" -> "1000611"  [ label = "DDG: &proto"] 
  "1000601" -> "1000611"  [ label = "DDG: bytes"] 
  "1000123" -> "1000611"  [ label = "DDG: "] 
  "1000605" -> "1000615"  [ label = "DDG: proto"] 
  "1000123" -> "1000615"  [ label = "DDG: "] 
  "1000605" -> "1000615"  [ label = "DDG: ctx"] 
  "1000605" -> "1000615"  [ label = "DDG: lex_ctx"] 
  "1000611" -> "1000621"  [ label = "DDG: &proto"] 
  "1000611" -> "1000621"  [ label = "DDG: bytes"] 
  "1000123" -> "1000621"  [ label = "DDG: "] 
  "1000615" -> "1000625"  [ label = "DDG: proto"] 
  "1000123" -> "1000625"  [ label = "DDG: "] 
  "1000123" -> "1000629"  [ label = "DDG: "] 
  "1000636" -> "1000634"  [ label = "DDG: \"version_converter\""] 
  "1000123" -> "1000634"  [ label = "DDG: "] 
  "1000123" -> "1000636"  [ label = "DDG: "] 
  "1000123" -> "1000638"  [ label = "DDG: "] 
  "1000545" -> "1000641"  [ label = "DDG: py::register_exception"] 
  "1000123" -> "1000641"  [ label = "DDG: "] 
  "1000643" -> "1000641"  [ label = "DDG: ConvertError"] 
  "1000123" -> "1000643"  [ label = "DDG: "] 
  "1000123" -> "1000646"  [ label = "DDG: "] 
  "1000123" -> "1000647"  [ label = "DDG: "] 
  "1000621" -> "1000650"  [ label = "DDG: &proto"] 
  "1000621" -> "1000650"  [ label = "DDG: bytes"] 
  "1000123" -> "1000650"  [ label = "DDG: "] 
  "1000625" -> "1000654"  [ label = "DDG: proto"] 
  "1000123" -> "1000654"  [ label = "DDG: "] 
  "1000659" -> "1000657"  [ label = "DDG: proto"] 
  "1000659" -> "1000657"  [ label = "DDG: target"] 
  "1000123" -> "1000657"  [ label = "DDG: "] 
  "1000654" -> "1000659"  [ label = "DDG: proto"] 
  "1000123" -> "1000659"  [ label = "DDG: "] 
  "1000667" -> "1000666"  [ label = "DDG: py::bytes(out)"] 
  "1000123" -> "1000667"  [ label = "DDG: "] 
  "1000672" -> "1000670"  [ label = "DDG: \"inliner\""] 
  "1000123" -> "1000670"  [ label = "DDG: "] 
  "1000123" -> "1000672"  [ label = "DDG: "] 
  "1000123" -> "1000674"  [ label = "DDG: "] 
  "1000123" -> "1000679"  [ label = "DDG: "] 
  "1000123" -> "1000683"  [ label = "DDG: "] 
  "1000691" -> "1000690"  [ label = "DDG: py::bytes(out)"] 
  "1000123" -> "1000691"  [ label = "DDG: "] 
  "1000123" -> "1000695"  [ label = "DDG: "] 
  "1000702" -> "1000700"  [ label = "DDG: std::move(function_ids)"] 
  "1000702" -> "1000700"  [ label = "DDG: exclude"] 
  "1000123" -> "1000700"  [ label = "DDG: "] 
  "1000703" -> "1000702"  [ label = "DDG: function_ids"] 
  "1000123" -> "1000703"  [ label = "DDG: "] 
  "1000123" -> "1000702"  [ label = "DDG: "] 
  "1000123" -> "1000706"  [ label = "DDG: "] 
  "1000715" -> "1000714"  [ label = "DDG: py::bytes(out)"] 
  "1000123" -> "1000715"  [ label = "DDG: "] 
  "1000720" -> "1000718"  [ label = "DDG: \"shape_inference\""] 
  "1000123" -> "1000718"  [ label = "DDG: "] 
  "1000123" -> "1000720"  [ label = "DDG: "] 
  "1000123" -> "1000722"  [ label = "DDG: "] 
  "1000123" -> "1000725"  [ label = "DDG: "] 
  "1000727" -> "1000725"  [ label = "DDG: InferenceError"] 
  "1000123" -> "1000727"  [ label = "DDG: "] 
  "1000123" -> "1000730"  [ label = "DDG: "] 
  "1000123" -> "1000731"  [ label = "DDG: "] 
  "1000123" -> "1000734"  [ label = "DDG: "] 
  "1000123" -> "1000740"  [ label = "DDG: "] 
  "1000749" -> "1000748"  [ label = "DDG: py::bytes(out)"] 
  "1000123" -> "1000749"  [ label = "DDG: "] 
  "1000123" -> "1000754"  [ label = "DDG: "] 
  "1000123" -> "1000761"  [ label = "DDG: "] 
  "1000123" -> "1000766"  [ label = "DDG: "] 
  "1000123" -> "1000771"  [ label = "DDG: "] 
  "1000123" -> "1000775"  [ label = "DDG: "] 
  "1000123" -> "1000778"  [ label = "DDG: "] 
  "1000771" -> "1000783"  [ label = "DDG: bytes"] 
  "1000123" -> "1000783"  [ label = "DDG: "] 
  "1000123" -> "1000787"  [ label = "DDG: "] 
  "1000792" -> "1000790"  [ label = "DDG: proto"] 
  "1000792" -> "1000790"  [ label = "DDG: input_types"] 
  "1000792" -> "1000790"  [ label = "DDG: attributes"] 
  "1000123" -> "1000790"  [ label = "DDG: "] 
  "1000123" -> "1000792"  [ label = "DDG: "] 
  "1000123" -> "1000796"  [ label = "DDG: "] 
  "1000798" -> "1000796"  [ label = "DDG: py::bytes"] 
  "1000798" -> "1000796"  [ label = "DDG: result"] 
  "1000123" -> "1000798"  [ label = "DDG: "] 
  "1000123" -> "1000801"  [ label = "DDG: "] 
  "1000810" -> "1000809"  [ label = "DDG: out"] 
  "1000123" -> "1000810"  [ label = "DDG: "] 
  "1000813" -> "1000812"  [ label = "DDG: result"] 
  "1000798" -> "1000812"  [ label = "DDG: result"] 
  "1000123" -> "1000813"  [ label = "DDG: "] 
  "1000817" -> "1000815"  [ label = "DDG: \"parser\""] 
  "1000123" -> "1000815"  [ label = "DDG: "] 
  "1000123" -> "1000817"  [ label = "DDG: "] 
  "1000123" -> "1000819"  [ label = "DDG: "] 
  "1000825" -> "1000823"  [ label = "DDG: \"printer\""] 
  "1000123" -> "1000823"  [ label = "DDG: "] 
  "1000123" -> "1000825"  [ label = "DDG: "] 
  "1000123" -> "1000827"  [ label = "DDG: "] 
  "1000240" -> "1000246"  [ label = "CDG: "] 
  "1000240" -> "1000243"  [ label = "CDG: "] 
  "1000240" -> "1000242"  [ label = "CDG: "] 
  "1000240" -> "1000249"  [ label = "CDG: "] 
  "1000240" -> "1000248"  [ label = "CDG: "] 
  "1000240" -> "1000240"  [ label = "CDG: "] 
  "1000257" -> "1000265"  [ label = "CDG: "] 
  "1000257" -> "1000260"  [ label = "CDG: "] 
  "1000257" -> "1000263"  [ label = "CDG: "] 
  "1000257" -> "1000259"  [ label = "CDG: "] 
  "1000257" -> "1000266"  [ label = "CDG: "] 
  "1000257" -> "1000257"  [ label = "CDG: "] 
  "1000347" -> "1000349"  [ label = "CDG: "] 
  "1000347" -> "1000348"  [ label = "CDG: "] 
  "1000384" -> "1000387"  [ label = "CDG: "] 
  "1000384" -> "1000396"  [ label = "CDG: "] 
  "1000384" -> "1000392"  [ label = "CDG: "] 
  "1000384" -> "1000400"  [ label = "CDG: "] 
  "1000384" -> "1000388"  [ label = "CDG: "] 
  "1000384" -> "1000404"  [ label = "CDG: "] 
  "1000384" -> "1000403"  [ label = "CDG: "] 
  "1000384" -> "1000393"  [ label = "CDG: "] 
  "1000420" -> "1000430"  [ label = "CDG: "] 
  "1000420" -> "1000424"  [ label = "CDG: "] 
  "1000420" -> "1000429"  [ label = "CDG: "] 
  "1000420" -> "1000441"  [ label = "CDG: "] 
  "1000420" -> "1000437"  [ label = "CDG: "] 
  "1000420" -> "1000425"  [ label = "CDG: "] 
  "1000420" -> "1000442"  [ label = "CDG: "] 
  "1000420" -> "1000433"  [ label = "CDG: "] 
  "1000466" -> "1000474"  [ label = "CDG: "] 
  "1000466" -> "1000479"  [ label = "CDG: "] 
  "1000466" -> "1000477"  [ label = "CDG: "] 
  "1000466" -> "1000469"  [ label = "CDG: "] 
  "1000466" -> "1000476"  [ label = "CDG: "] 
  "1000466" -> "1000470"  [ label = "CDG: "] 
  "1000466" -> "1000472"  [ label = "CDG: "] 
  "1000466" -> "1000481"  [ label = "CDG: "] 
  "1000495" -> "1000503"  [ label = "CDG: "] 
  "1000495" -> "1000498"  [ label = "CDG: "] 
  "1000495" -> "1000499"  [ label = "CDG: "] 
  "1000495" -> "1000501"  [ label = "CDG: "] 
  "1000495" -> "1000505"  [ label = "CDG: "] 
}
