{
  "total_2024_records": 773,
  "data_2024": [
    {
      "project": "linux",
      "filepath": "kernel/bpf/verifier.c",
      "func_name": "adjust_ptr_min_max_vals",
      "func_body": "static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_insn *insn,\n\t\t\t\t   const struct bpf_reg_state *ptr_reg,\n\t\t\t\t   const struct bpf_reg_state *off_reg)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tstruct bpf_reg_state *regs = state->regs, *dst_reg;\n\tbool known = tnum_is_const(off_reg->var_off);\n\ts64 smin_val = off_reg->smin_value, smax_val = off_reg->smax_value,\n\t    smin_ptr = ptr_reg->smin_value, smax_ptr = ptr_reg->smax_value;\n\tu64 umin_val = off_reg->umin_value, umax_val = off_reg->umax_value,\n\t    umin_ptr = ptr_reg->umin_value, umax_ptr = ptr_reg->umax_value;\n\tstruct bpf_sanitize_info info = {};\n\tu8 opcode = BPF_OP(insn->code);\n\tu32 dst = insn->dst_reg;\n\tint ret;\n\n\tdst_reg = &regs[dst];\n\n\tif ((known && (smin_val != smax_val || umin_val != umax_val)) ||\n\t    smin_val > smax_val || umin_val > umax_val) {\n\t\t/* Taint dst register if offset had invalid bounds derived from\n\t\t * e.g. dead branches.\n\t\t */\n\t\t__mark_reg_unknown(env, dst_reg);\n\t\treturn 0;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops on pointers produce (meaningless) scalars */\n\t\tif (opcode == BPF_SUB && env->allow_ptr_leaks) {\n\t\t\t__mark_reg_unknown(env, dst_reg);\n\t\t\treturn 0;\n\t\t}\n\n\t\tverbose(env,\n\t\t\t\"R%d 32-bit pointer arithmetic prohibited\\n\",\n\t\t\tdst);\n\t\treturn -EACCES;\n\t}\n\n\tif (ptr_reg->type & PTR_MAYBE_NULL) {\n\t\tverbose(env, \"R%d pointer arithmetic on %s prohibited, null-check it first\\n\",\n\t\t\tdst, reg_type_str(env, ptr_reg->type));\n\t\treturn -EACCES;\n\t}\n\n\tswitch (base_type(ptr_reg->type)) {\n\tcase PTR_TO_FLOW_KEYS:\n\t\tif (known)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase CONST_PTR_TO_MAP:\n\t\t/* smin_val represents the known value */\n\t\tif (known && smin_val == 0 && opcode == BPF_ADD)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase PTR_TO_PACKET_END:\n\tcase PTR_TO_SOCKET:\n\tcase PTR_TO_SOCK_COMMON:\n\tcase PTR_TO_TCP_SOCK:\n\tcase PTR_TO_XDP_SOCK:\n\t\tverbose(env, \"R%d pointer arithmetic on %s prohibited\\n\",\n\t\t\tdst, reg_type_str(env, ptr_reg->type));\n\t\treturn -EACCES;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* In case of 'scalar += pointer', dst_reg inherits pointer type and id.\n\t * The id may be overwritten later if we create a new variable offset.\n\t */\n\tdst_reg->type = ptr_reg->type;\n\tdst_reg->id = ptr_reg->id;\n\n\tif (!check_reg_sane_offset(env, off_reg, ptr_reg->type) ||\n\t    !check_reg_sane_offset(env, ptr_reg, ptr_reg->type))\n\t\treturn -EINVAL;\n\n\t/* pointer types do not carry 32-bit bounds at the moment. */\n\t__mark_reg32_unbounded(dst_reg);\n\n\tif (sanitize_needed(opcode)) {\n\t\tret = sanitize_ptr_alu(env, insn, ptr_reg, off_reg, dst_reg,\n\t\t\t\t       &info, false);\n\t\tif (ret < 0)\n\t\t\treturn sanitize_err(env, insn, ret, off_reg, dst_reg);\n\t}\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\t/* We can take a fixed offset as long as it doesn't overflow\n\t\t * the s32 'off' field\n\t\t */\n\t\tif (known && (ptr_reg->off + smin_val ==\n\t\t\t      (s64)(s32)(ptr_reg->off + smin_val))) {\n\t\t\t/* pointer += K.  Accumulate it into fixed offset */\n\t\t\tdst_reg->smin_value = smin_ptr;\n\t\t\tdst_reg->smax_value = smax_ptr;\n\t\t\tdst_reg->umin_value = umin_ptr;\n\t\t\tdst_reg->umax_value = umax_ptr;\n\t\t\tdst_reg->var_off = ptr_reg->var_off;\n\t\t\tdst_reg->off = ptr_reg->off + smin_val;\n\t\t\tdst_reg->raw = ptr_reg->raw;\n\t\t\tbreak;\n\t\t}\n\t\t/* A new variable offset is created.  Note that off_reg->off\n\t\t * == 0, since it's a scalar.\n\t\t * dst_reg gets the pointer type and since some positive\n\t\t * integer value was added to the pointer, give it a new 'id'\n\t\t * if it's a PTR_TO_PACKET.\n\t\t * this creates a new 'base' pointer, off_reg (variable) gets\n\t\t * added into the variable offset, and we copy the fixed offset\n\t\t * from ptr_reg.\n\t\t */\n\t\tif (signed_add_overflows(smin_ptr, smin_val) ||\n\t\t    signed_add_overflows(smax_ptr, smax_val)) {\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = smin_ptr + smin_val;\n\t\t\tdst_reg->smax_value = smax_ptr + smax_val;\n\t\t}\n\t\tif (umin_ptr + umin_val < umin_ptr ||\n\t\t    umax_ptr + umax_val < umax_ptr) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value = umin_ptr + umin_val;\n\t\t\tdst_reg->umax_value = umax_ptr + umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_add(ptr_reg->var_off, off_reg->var_off);\n\t\tdst_reg->off = ptr_reg->off;\n\t\tdst_reg->raw = ptr_reg->raw;\n\t\tif (reg_is_pkt_pointer(ptr_reg)) {\n\t\t\tdst_reg->id = ++env->id_gen;\n\t\t\t/* something was added to pkt_ptr, set range to zero */\n\t\t\tmemset(&dst_reg->raw, 0, sizeof(dst_reg->raw));\n\t\t}\n\t\tbreak;\n\tcase BPF_SUB:\n\t\tif (dst_reg == off_reg) {\n\t\t\t/* scalar -= pointer.  Creates an unknown scalar */\n\t\t\tverbose(env, \"R%d tried to subtract pointer from scalar\\n\",\n\t\t\t\tdst);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* We don't allow subtraction from FP, because (according to\n\t\t * test_verifier.c test \"invalid fp arithmetic\", JITs might not\n\t\t * be able to deal with it.\n\t\t */\n\t\tif (ptr_reg->type == PTR_TO_STACK) {\n\t\t\tverbose(env, \"R%d subtraction from stack pointer prohibited\\n\",\n\t\t\t\tdst);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (known && (ptr_reg->off - smin_val ==\n\t\t\t      (s64)(s32)(ptr_reg->off - smin_val))) {\n\t\t\t/* pointer -= K.  Subtract it from fixed offset */\n\t\t\tdst_reg->smin_value = smin_ptr;\n\t\t\tdst_reg->smax_value = smax_ptr;\n\t\t\tdst_reg->umin_value = umin_ptr;\n\t\t\tdst_reg->umax_value = umax_ptr;\n\t\t\tdst_reg->var_off = ptr_reg->var_off;\n\t\t\tdst_reg->id = ptr_reg->id;\n\t\t\tdst_reg->off = ptr_reg->off - smin_val;\n\t\t\tdst_reg->raw = ptr_reg->raw;\n\t\t\tbreak;\n\t\t}\n\t\t/* A new variable offset is created.  If the subtrahend is known\n\t\t * nonnegative, then any reg->range we had before is still good.\n\t\t */\n\t\tif (signed_sub_overflows(smin_ptr, smax_val) ||\n\t\t    signed_sub_overflows(smax_ptr, smin_val)) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = smin_ptr - smax_val;\n\t\t\tdst_reg->smax_value = smax_ptr - smin_val;\n\t\t}\n\t\tif (umin_ptr < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value = umin_ptr - umax_val;\n\t\t\tdst_reg->umax_value = umax_ptr - umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(ptr_reg->var_off, off_reg->var_off);\n\t\tdst_reg->off = ptr_reg->off;\n\t\tdst_reg->raw = ptr_reg->raw;\n\t\tif (reg_is_pkt_pointer(ptr_reg)) {\n\t\t\tdst_reg->id = ++env->id_gen;\n\t\t\t/* something was added to pkt_ptr, set range to zero */\n\t\t\tif (smin_val < 0)\n\t\t\t\tmemset(&dst_reg->raw, 0, sizeof(dst_reg->raw));\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\tcase BPF_OR:\n\tcase BPF_XOR:\n\t\t/* bitwise ops on pointers are troublesome, prohibit. */\n\t\tverbose(env, \"R%d bitwise operator %s on pointer prohibited\\n\",\n\t\t\tdst, bpf_alu_string[opcode >> 4]);\n\t\treturn -EACCES;\n\tdefault:\n\t\t/* other operators (e.g. MUL,LSH) produce non-pointer results */\n\t\tverbose(env, \"R%d pointer arithmetic with %s operator prohibited\\n\",\n\t\t\tdst, bpf_alu_string[opcode >> 4]);\n\t\treturn -EACCES;\n\t}\n\n\tif (!check_reg_sane_offset(env, dst_reg, ptr_reg->type))\n\t\treturn -EINVAL;\n\treg_bounds_sync(dst_reg);\n\tif (sanitize_check_bounds(env, insn, dst_reg) < 0)\n\t\treturn -EACCES;\n\tif (sanitize_needed(opcode)) {\n\t\tret = sanitize_ptr_alu(env, insn, dst_reg, off_reg, dst_reg,\n\t\t\t\t       &info, true);\n\t\tif (ret < 0)\n\t\t\treturn sanitize_err(env, insn, ret, off_reg, dst_reg);\n\t}\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-26589"
      ],
      "cwe_list": [
        "CWE-119"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/bpf/devmap.c",
      "func_name": "dev_map_init_map",
      "func_body": "static int dev_map_init_map(struct bpf_dtab *dtab, union bpf_attr *attr)\n{\n\tu32 valsize = attr->value_size;\n\n\t/* check sanity of attributes. 2 value sizes supported:\n\t * 4 bytes: ifindex\n\t * 8 bytes: ifindex + prog fd\n\t */\n\tif (attr->max_entries == 0 || attr->key_size != 4 ||\n\t    (valsize != offsetofend(struct bpf_devmap_val, ifindex) &&\n\t     valsize != offsetofend(struct bpf_devmap_val, bpf_prog.fd)) ||\n\t    attr->map_flags & ~DEV_CREATE_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\t/* Lookup returns a pointer straight to dev->ifindex, so make sure the\n\t * verifier prevents writes from the BPF side\n\t */\n\tattr->map_flags |= BPF_F_RDONLY_PROG;\n\n\n\tbpf_map_init_from_attr(&dtab->map, attr);\n\n\tif (attr->map_type == BPF_MAP_TYPE_DEVMAP_HASH) {\n\t\t/* hash table size must be power of 2; roundup_pow_of_two() can\n\t\t * overflow into UB on 32-bit arches, so check that first\n\t\t */\n\t\tif (dtab->map.max_entries > 1UL << 31)\n\t\t\treturn -EINVAL;\n\n\t\tdtab->n_buckets = roundup_pow_of_two(dtab->map.max_entries);\n\n\t\tdtab->dev_index_head = dev_map_create_hash(dtab->n_buckets,\n\t\t\t\t\t\t\t   dtab->map.numa_node);\n\t\tif (!dtab->dev_index_head)\n\t\t\treturn -ENOMEM;\n\n\t\tspin_lock_init(&dtab->index_lock);\n\t} else {\n\t\tdtab->netdev_map = bpf_map_area_alloc((u64) dtab->map.max_entries *\n\t\t\t\t\t\t      sizeof(struct bpf_dtab_netdev *),\n\t\t\t\t\t\t      dtab->map.numa_node);\n\t\tif (!dtab->netdev_map)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-26885"
      ],
      "cwe_list": [
        "CWE-119"
      ]
    },
    {
      "project": "linux",
      "filepath": "arch/loongarch/net/bpf_jit.c",
      "func_name": "build_insn",
      "func_body": "static int build_insn(const struct bpf_insn *insn, struct jit_ctx *ctx, bool extra_pass)\n{\n\tu8 tm = -1;\n\tu64 func_addr;\n\tbool func_addr_fixed, sign_extend;\n\tint i = insn - ctx->prog->insnsi;\n\tint ret, jmp_offset;\n\tconst u8 code = insn->code;\n\tconst u8 cond = BPF_OP(code);\n\tconst u8 t1 = LOONGARCH_GPR_T1;\n\tconst u8 t2 = LOONGARCH_GPR_T2;\n\tconst u8 src = regmap[insn->src_reg];\n\tconst u8 dst = regmap[insn->dst_reg];\n\tconst s16 off = insn->off;\n\tconst s32 imm = insn->imm;\n\tconst bool is32 = BPF_CLASS(insn->code) == BPF_ALU || BPF_CLASS(insn->code) == BPF_JMP32;\n\n\tswitch (code) {\n\t/* dst = src */\n\tcase BPF_ALU | BPF_MOV | BPF_X:\n\tcase BPF_ALU64 | BPF_MOV | BPF_X:\n\t\tswitch (off) {\n\t\tcase 0:\n\t\t\tmove_reg(ctx, dst, src);\n\t\t\temit_zext_32(ctx, dst, is32);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tmove_reg(ctx, t1, src);\n\t\t\temit_insn(ctx, extwb, dst, t1);\n\t\t\temit_zext_32(ctx, dst, is32);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tmove_reg(ctx, t1, src);\n\t\t\temit_insn(ctx, extwh, dst, t1);\n\t\t\temit_zext_32(ctx, dst, is32);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\temit_insn(ctx, addw, dst, src, LOONGARCH_GPR_ZERO);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t/* dst = imm */\n\tcase BPF_ALU | BPF_MOV | BPF_K:\n\tcase BPF_ALU64 | BPF_MOV | BPF_K:\n\t\tmove_imm(ctx, dst, imm, is32);\n\t\tbreak;\n\n\t/* dst = dst + src */\n\tcase BPF_ALU | BPF_ADD | BPF_X:\n\tcase BPF_ALU64 | BPF_ADD | BPF_X:\n\t\temit_insn(ctx, addd, dst, dst, src);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst + imm */\n\tcase BPF_ALU | BPF_ADD | BPF_K:\n\tcase BPF_ALU64 | BPF_ADD | BPF_K:\n\t\tif (is_signed_imm12(imm)) {\n\t\t\temit_insn(ctx, addid, dst, dst, imm);\n\t\t} else {\n\t\t\tmove_imm(ctx, t1, imm, is32);\n\t\t\temit_insn(ctx, addd, dst, dst, t1);\n\t\t}\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst - src */\n\tcase BPF_ALU | BPF_SUB | BPF_X:\n\tcase BPF_ALU64 | BPF_SUB | BPF_X:\n\t\temit_insn(ctx, subd, dst, dst, src);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst - imm */\n\tcase BPF_ALU | BPF_SUB | BPF_K:\n\tcase BPF_ALU64 | BPF_SUB | BPF_K:\n\t\tif (is_signed_imm12(-imm)) {\n\t\t\temit_insn(ctx, addid, dst, dst, -imm);\n\t\t} else {\n\t\t\tmove_imm(ctx, t1, imm, is32);\n\t\t\temit_insn(ctx, subd, dst, dst, t1);\n\t\t}\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst * src */\n\tcase BPF_ALU | BPF_MUL | BPF_X:\n\tcase BPF_ALU64 | BPF_MUL | BPF_X:\n\t\temit_insn(ctx, muld, dst, dst, src);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst * imm */\n\tcase BPF_ALU | BPF_MUL | BPF_K:\n\tcase BPF_ALU64 | BPF_MUL | BPF_K:\n\t\tmove_imm(ctx, t1, imm, is32);\n\t\temit_insn(ctx, muld, dst, dst, t1);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst / src */\n\tcase BPF_ALU | BPF_DIV | BPF_X:\n\tcase BPF_ALU64 | BPF_DIV | BPF_X:\n\t\tif (!off) {\n\t\t\temit_zext_32(ctx, dst, is32);\n\t\t\tmove_reg(ctx, t1, src);\n\t\t\temit_zext_32(ctx, t1, is32);\n\t\t\temit_insn(ctx, divdu, dst, dst, t1);\n\t\t\temit_zext_32(ctx, dst, is32);\n\t\t} else {\n\t\t\temit_sext_32(ctx, dst, is32);\n\t\t\tmove_reg(ctx, t1, src);\n\t\t\temit_sext_32(ctx, t1, is32);\n\t\t\temit_insn(ctx, divd, dst, dst, t1);\n\t\t\temit_sext_32(ctx, dst, is32);\n\t\t}\n\t\tbreak;\n\n\t/* dst = dst / imm */\n\tcase BPF_ALU | BPF_DIV | BPF_K:\n\tcase BPF_ALU64 | BPF_DIV | BPF_K:\n\t\tif (!off) {\n\t\t\tmove_imm(ctx, t1, imm, is32);\n\t\t\temit_zext_32(ctx, dst, is32);\n\t\t\temit_insn(ctx, divdu, dst, dst, t1);\n\t\t\temit_zext_32(ctx, dst, is32);\n\t\t} else {\n\t\t\tmove_imm(ctx, t1, imm, false);\n\t\t\temit_sext_32(ctx, t1, is32);\n\t\t\temit_sext_32(ctx, dst, is32);\n\t\t\temit_insn(ctx, divd, dst, dst, t1);\n\t\t\temit_sext_32(ctx, dst, is32);\n\t\t}\n\t\tbreak;\n\n\t/* dst = dst % src */\n\tcase BPF_ALU | BPF_MOD | BPF_X:\n\tcase BPF_ALU64 | BPF_MOD | BPF_X:\n\t\tif (!off) {\n\t\t\temit_zext_32(ctx, dst, is32);\n\t\t\tmove_reg(ctx, t1, src);\n\t\t\temit_zext_32(ctx, t1, is32);\n\t\t\temit_insn(ctx, moddu, dst, dst, t1);\n\t\t\temit_zext_32(ctx, dst, is32);\n\t\t} else {\n\t\t\temit_sext_32(ctx, dst, is32);\n\t\t\tmove_reg(ctx, t1, src);\n\t\t\temit_sext_32(ctx, t1, is32);\n\t\t\temit_insn(ctx, modd, dst, dst, t1);\n\t\t\temit_sext_32(ctx, dst, is32);\n\t\t}\n\t\tbreak;\n\n\t/* dst = dst % imm */\n\tcase BPF_ALU | BPF_MOD | BPF_K:\n\tcase BPF_ALU64 | BPF_MOD | BPF_K:\n\t\tif (!off) {\n\t\t\tmove_imm(ctx, t1, imm, is32);\n\t\t\temit_zext_32(ctx, dst, is32);\n\t\t\temit_insn(ctx, moddu, dst, dst, t1);\n\t\t\temit_zext_32(ctx, dst, is32);\n\t\t} else {\n\t\t\tmove_imm(ctx, t1, imm, false);\n\t\t\temit_sext_32(ctx, t1, is32);\n\t\t\temit_sext_32(ctx, dst, is32);\n\t\t\temit_insn(ctx, modd, dst, dst, t1);\n\t\t\temit_sext_32(ctx, dst, is32);\n\t\t}\n\t\tbreak;\n\n\t/* dst = -dst */\n\tcase BPF_ALU | BPF_NEG:\n\tcase BPF_ALU64 | BPF_NEG:\n\t\tmove_imm(ctx, t1, imm, is32);\n\t\temit_insn(ctx, subd, dst, LOONGARCH_GPR_ZERO, dst);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst & src */\n\tcase BPF_ALU | BPF_AND | BPF_X:\n\tcase BPF_ALU64 | BPF_AND | BPF_X:\n\t\temit_insn(ctx, and, dst, dst, src);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst & imm */\n\tcase BPF_ALU | BPF_AND | BPF_K:\n\tcase BPF_ALU64 | BPF_AND | BPF_K:\n\t\tif (is_unsigned_imm12(imm)) {\n\t\t\temit_insn(ctx, andi, dst, dst, imm);\n\t\t} else {\n\t\t\tmove_imm(ctx, t1, imm, is32);\n\t\t\temit_insn(ctx, and, dst, dst, t1);\n\t\t}\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst | src */\n\tcase BPF_ALU | BPF_OR | BPF_X:\n\tcase BPF_ALU64 | BPF_OR | BPF_X:\n\t\temit_insn(ctx, or, dst, dst, src);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst | imm */\n\tcase BPF_ALU | BPF_OR | BPF_K:\n\tcase BPF_ALU64 | BPF_OR | BPF_K:\n\t\tif (is_unsigned_imm12(imm)) {\n\t\t\temit_insn(ctx, ori, dst, dst, imm);\n\t\t} else {\n\t\t\tmove_imm(ctx, t1, imm, is32);\n\t\t\temit_insn(ctx, or, dst, dst, t1);\n\t\t}\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst ^ src */\n\tcase BPF_ALU | BPF_XOR | BPF_X:\n\tcase BPF_ALU64 | BPF_XOR | BPF_X:\n\t\temit_insn(ctx, xor, dst, dst, src);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst ^ imm */\n\tcase BPF_ALU | BPF_XOR | BPF_K:\n\tcase BPF_ALU64 | BPF_XOR | BPF_K:\n\t\tif (is_unsigned_imm12(imm)) {\n\t\t\temit_insn(ctx, xori, dst, dst, imm);\n\t\t} else {\n\t\t\tmove_imm(ctx, t1, imm, is32);\n\t\t\temit_insn(ctx, xor, dst, dst, t1);\n\t\t}\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\t/* dst = dst << src (logical) */\n\tcase BPF_ALU | BPF_LSH | BPF_X:\n\t\temit_insn(ctx, sllw, dst, dst, src);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\tcase BPF_ALU64 | BPF_LSH | BPF_X:\n\t\temit_insn(ctx, slld, dst, dst, src);\n\t\tbreak;\n\n\t/* dst = dst << imm (logical) */\n\tcase BPF_ALU | BPF_LSH | BPF_K:\n\t\temit_insn(ctx, slliw, dst, dst, imm);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\tcase BPF_ALU64 | BPF_LSH | BPF_K:\n\t\temit_insn(ctx, sllid, dst, dst, imm);\n\t\tbreak;\n\n\t/* dst = dst >> src (logical) */\n\tcase BPF_ALU | BPF_RSH | BPF_X:\n\t\temit_insn(ctx, srlw, dst, dst, src);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\tcase BPF_ALU64 | BPF_RSH | BPF_X:\n\t\temit_insn(ctx, srld, dst, dst, src);\n\t\tbreak;\n\n\t/* dst = dst >> imm (logical) */\n\tcase BPF_ALU | BPF_RSH | BPF_K:\n\t\temit_insn(ctx, srliw, dst, dst, imm);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\tcase BPF_ALU64 | BPF_RSH | BPF_K:\n\t\temit_insn(ctx, srlid, dst, dst, imm);\n\t\tbreak;\n\n\t/* dst = dst >> src (arithmetic) */\n\tcase BPF_ALU | BPF_ARSH | BPF_X:\n\t\temit_insn(ctx, sraw, dst, dst, src);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\tcase BPF_ALU64 | BPF_ARSH | BPF_X:\n\t\temit_insn(ctx, srad, dst, dst, src);\n\t\tbreak;\n\n\t/* dst = dst >> imm (arithmetic) */\n\tcase BPF_ALU | BPF_ARSH | BPF_K:\n\t\temit_insn(ctx, sraiw, dst, dst, imm);\n\t\temit_zext_32(ctx, dst, is32);\n\t\tbreak;\n\n\tcase BPF_ALU64 | BPF_ARSH | BPF_K:\n\t\temit_insn(ctx, sraid, dst, dst, imm);\n\t\tbreak;\n\n\t/* dst = BSWAP##imm(dst) */\n\tcase BPF_ALU | BPF_END | BPF_FROM_LE:\n\t\tswitch (imm) {\n\t\tcase 16:\n\t\t\t/* zero-extend 16 bits into 64 bits */\n\t\t\temit_insn(ctx, bstrpickd, dst, dst, 15, 0);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\t/* zero-extend 32 bits into 64 bits */\n\t\t\temit_zext_32(ctx, dst, is32);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\t/* do nothing */\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase BPF_ALU | BPF_END | BPF_FROM_BE:\n\tcase BPF_ALU64 | BPF_END | BPF_FROM_LE:\n\t\tswitch (imm) {\n\t\tcase 16:\n\t\t\temit_insn(ctx, revb2h, dst, dst);\n\t\t\t/* zero-extend 16 bits into 64 bits */\n\t\t\temit_insn(ctx, bstrpickd, dst, dst, 15, 0);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\temit_insn(ctx, revb2w, dst, dst);\n\t\t\t/* clear the upper 32 bits */\n\t\t\temit_zext_32(ctx, dst, true);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\temit_insn(ctx, revbd, dst, dst);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t/* PC += off if dst cond src */\n\tcase BPF_JMP | BPF_JEQ | BPF_X:\n\tcase BPF_JMP | BPF_JNE | BPF_X:\n\tcase BPF_JMP | BPF_JGT | BPF_X:\n\tcase BPF_JMP | BPF_JGE | BPF_X:\n\tcase BPF_JMP | BPF_JLT | BPF_X:\n\tcase BPF_JMP | BPF_JLE | BPF_X:\n\tcase BPF_JMP | BPF_JSGT | BPF_X:\n\tcase BPF_JMP | BPF_JSGE | BPF_X:\n\tcase BPF_JMP | BPF_JSLT | BPF_X:\n\tcase BPF_JMP | BPF_JSLE | BPF_X:\n\tcase BPF_JMP32 | BPF_JEQ | BPF_X:\n\tcase BPF_JMP32 | BPF_JNE | BPF_X:\n\tcase BPF_JMP32 | BPF_JGT | BPF_X:\n\tcase BPF_JMP32 | BPF_JGE | BPF_X:\n\tcase BPF_JMP32 | BPF_JLT | BPF_X:\n\tcase BPF_JMP32 | BPF_JLE | BPF_X:\n\tcase BPF_JMP32 | BPF_JSGT | BPF_X:\n\tcase BPF_JMP32 | BPF_JSGE | BPF_X:\n\tcase BPF_JMP32 | BPF_JSLT | BPF_X:\n\tcase BPF_JMP32 | BPF_JSLE | BPF_X:\n\t\tjmp_offset = bpf2la_offset(i, off, ctx);\n\t\tmove_reg(ctx, t1, dst);\n\t\tmove_reg(ctx, t2, src);\n\t\tif (is_signed_bpf_cond(BPF_OP(code))) {\n\t\t\temit_sext_32(ctx, t1, is32);\n\t\t\temit_sext_32(ctx, t2, is32);\n\t\t} else {\n\t\t\temit_zext_32(ctx, t1, is32);\n\t\t\temit_zext_32(ctx, t2, is32);\n\t\t}\n\t\tif (emit_cond_jmp(ctx, cond, t1, t2, jmp_offset) < 0)\n\t\t\tgoto toofar;\n\t\tbreak;\n\n\t/* PC += off if dst cond imm */\n\tcase BPF_JMP | BPF_JEQ | BPF_K:\n\tcase BPF_JMP | BPF_JNE | BPF_K:\n\tcase BPF_JMP | BPF_JGT | BPF_K:\n\tcase BPF_JMP | BPF_JGE | BPF_K:\n\tcase BPF_JMP | BPF_JLT | BPF_K:\n\tcase BPF_JMP | BPF_JLE | BPF_K:\n\tcase BPF_JMP | BPF_JSGT | BPF_K:\n\tcase BPF_JMP | BPF_JSGE | BPF_K:\n\tcase BPF_JMP | BPF_JSLT | BPF_K:\n\tcase BPF_JMP | BPF_JSLE | BPF_K:\n\tcase BPF_JMP32 | BPF_JEQ | BPF_K:\n\tcase BPF_JMP32 | BPF_JNE | BPF_K:\n\tcase BPF_JMP32 | BPF_JGT | BPF_K:\n\tcase BPF_JMP32 | BPF_JGE | BPF_K:\n\tcase BPF_JMP32 | BPF_JLT | BPF_K:\n\tcase BPF_JMP32 | BPF_JLE | BPF_K:\n\tcase BPF_JMP32 | BPF_JSGT | BPF_K:\n\tcase BPF_JMP32 | BPF_JSGE | BPF_K:\n\tcase BPF_JMP32 | BPF_JSLT | BPF_K:\n\tcase BPF_JMP32 | BPF_JSLE | BPF_K:\n\t\tjmp_offset = bpf2la_offset(i, off, ctx);\n\t\tif (imm) {\n\t\t\tmove_imm(ctx, t1, imm, false);\n\t\t\ttm = t1;\n\t\t} else {\n\t\t\t/* If imm is 0, simply use zero register. */\n\t\t\ttm = LOONGARCH_GPR_ZERO;\n\t\t}\n\t\tmove_reg(ctx, t2, dst);\n\t\tif (is_signed_bpf_cond(BPF_OP(code))) {\n\t\t\temit_sext_32(ctx, tm, is32);\n\t\t\temit_sext_32(ctx, t2, is32);\n\t\t} else {\n\t\t\temit_zext_32(ctx, tm, is32);\n\t\t\temit_zext_32(ctx, t2, is32);\n\t\t}\n\t\tif (emit_cond_jmp(ctx, cond, t2, tm, jmp_offset) < 0)\n\t\t\tgoto toofar;\n\t\tbreak;\n\n\t/* PC += off if dst & src */\n\tcase BPF_JMP | BPF_JSET | BPF_X:\n\tcase BPF_JMP32 | BPF_JSET | BPF_X:\n\t\tjmp_offset = bpf2la_offset(i, off, ctx);\n\t\temit_insn(ctx, and, t1, dst, src);\n\t\temit_zext_32(ctx, t1, is32);\n\t\tif (emit_cond_jmp(ctx, cond, t1, LOONGARCH_GPR_ZERO, jmp_offset) < 0)\n\t\t\tgoto toofar;\n\t\tbreak;\n\n\t/* PC += off if dst & imm */\n\tcase BPF_JMP | BPF_JSET | BPF_K:\n\tcase BPF_JMP32 | BPF_JSET | BPF_K:\n\t\tjmp_offset = bpf2la_offset(i, off, ctx);\n\t\tmove_imm(ctx, t1, imm, is32);\n\t\temit_insn(ctx, and, t1, dst, t1);\n\t\temit_zext_32(ctx, t1, is32);\n\t\tif (emit_cond_jmp(ctx, cond, t1, LOONGARCH_GPR_ZERO, jmp_offset) < 0)\n\t\t\tgoto toofar;\n\t\tbreak;\n\n\t/* PC += off */\n\tcase BPF_JMP | BPF_JA:\n\tcase BPF_JMP32 | BPF_JA:\n\t\tif (BPF_CLASS(code) == BPF_JMP)\n\t\t\tjmp_offset = bpf2la_offset(i, off, ctx);\n\t\telse\n\t\t\tjmp_offset = bpf2la_offset(i, imm, ctx);\n\t\tif (emit_uncond_jmp(ctx, jmp_offset) < 0)\n\t\t\tgoto toofar;\n\t\tbreak;\n\n\t/* function call */\n\tcase BPF_JMP | BPF_CALL:\n\t\tmark_call(ctx);\n\t\tret = bpf_jit_get_func_addr(ctx->prog, insn, extra_pass,\n\t\t\t\t\t    &func_addr, &func_addr_fixed);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmove_addr(ctx, t1, func_addr);\n\t\temit_insn(ctx, jirl, t1, LOONGARCH_GPR_RA, 0);\n\t\tmove_reg(ctx, regmap[BPF_REG_0], LOONGARCH_GPR_A0);\n\t\tbreak;\n\n\t/* tail call */\n\tcase BPF_JMP | BPF_TAIL_CALL:\n\t\tmark_tail_call(ctx);\n\t\tif (emit_bpf_tail_call(ctx) < 0)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\t/* function return */\n\tcase BPF_JMP | BPF_EXIT:\n\t\tif (i == ctx->prog->len - 1)\n\t\t\tbreak;\n\n\t\tjmp_offset = epilogue_offset(ctx);\n\t\tif (emit_uncond_jmp(ctx, jmp_offset) < 0)\n\t\t\tgoto toofar;\n\t\tbreak;\n\n\t/* dst = imm64 */\n\tcase BPF_LD | BPF_IMM | BPF_DW:\n\t{\n\t\tconst u64 imm64 = (u64)(insn + 1)->imm << 32 | (u32)insn->imm;\n\n\t\tmove_imm(ctx, dst, imm64, is32);\n\t\treturn 1;\n\t}\n\n\t/* dst = *(size *)(src + off) */\n\tcase BPF_LDX | BPF_MEM | BPF_B:\n\tcase BPF_LDX | BPF_MEM | BPF_H:\n\tcase BPF_LDX | BPF_MEM | BPF_W:\n\tcase BPF_LDX | BPF_MEM | BPF_DW:\n\tcase BPF_LDX | BPF_PROBE_MEM | BPF_DW:\n\tcase BPF_LDX | BPF_PROBE_MEM | BPF_W:\n\tcase BPF_LDX | BPF_PROBE_MEM | BPF_H:\n\tcase BPF_LDX | BPF_PROBE_MEM | BPF_B:\n\t/* dst_reg = (s64)*(signed size *)(src_reg + off) */\n\tcase BPF_LDX | BPF_MEMSX | BPF_B:\n\tcase BPF_LDX | BPF_MEMSX | BPF_H:\n\tcase BPF_LDX | BPF_MEMSX | BPF_W:\n\tcase BPF_LDX | BPF_PROBE_MEMSX | BPF_B:\n\tcase BPF_LDX | BPF_PROBE_MEMSX | BPF_H:\n\tcase BPF_LDX | BPF_PROBE_MEMSX | BPF_W:\n\t\tsign_extend = BPF_MODE(insn->code) == BPF_MEMSX ||\n\t\t\t      BPF_MODE(insn->code) == BPF_PROBE_MEMSX;\n\t\tswitch (BPF_SIZE(code)) {\n\t\tcase BPF_B:\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\tif (sign_extend)\n\t\t\t\t\temit_insn(ctx, ldb, dst, src, off);\n\t\t\t\telse\n\t\t\t\t\temit_insn(ctx, ldbu, dst, src, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t1, off, is32);\n\t\t\t\tif (sign_extend)\n\t\t\t\t\temit_insn(ctx, ldxb, dst, src, t1);\n\t\t\t\telse\n\t\t\t\t\temit_insn(ctx, ldxbu, dst, src, t1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_H:\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\tif (sign_extend)\n\t\t\t\t\temit_insn(ctx, ldh, dst, src, off);\n\t\t\t\telse\n\t\t\t\t\temit_insn(ctx, ldhu, dst, src, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t1, off, is32);\n\t\t\t\tif (sign_extend)\n\t\t\t\t\temit_insn(ctx, ldxh, dst, src, t1);\n\t\t\t\telse\n\t\t\t\t\temit_insn(ctx, ldxhu, dst, src, t1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_W:\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\tif (sign_extend)\n\t\t\t\t\temit_insn(ctx, ldw, dst, src, off);\n\t\t\t\telse\n\t\t\t\t\temit_insn(ctx, ldwu, dst, src, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t1, off, is32);\n\t\t\t\tif (sign_extend)\n\t\t\t\t\temit_insn(ctx, ldxw, dst, src, t1);\n\t\t\t\telse\n\t\t\t\t\temit_insn(ctx, ldxwu, dst, src, t1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_DW:\n\t\t\tmove_imm(ctx, t1, off, is32);\n\t\t\temit_insn(ctx, ldxd, dst, src, t1);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = add_exception_handler(insn, ctx, dst);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\t/* *(size *)(dst + off) = imm */\n\tcase BPF_ST | BPF_MEM | BPF_B:\n\tcase BPF_ST | BPF_MEM | BPF_H:\n\tcase BPF_ST | BPF_MEM | BPF_W:\n\tcase BPF_ST | BPF_MEM | BPF_DW:\n\t\tswitch (BPF_SIZE(code)) {\n\t\tcase BPF_B:\n\t\t\tmove_imm(ctx, t1, imm, is32);\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\temit_insn(ctx, stb, t1, dst, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t2, off, is32);\n\t\t\t\temit_insn(ctx, stxb, t1, dst, t2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_H:\n\t\t\tmove_imm(ctx, t1, imm, is32);\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\temit_insn(ctx, sth, t1, dst, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t2, off, is32);\n\t\t\t\temit_insn(ctx, stxh, t1, dst, t2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_W:\n\t\t\tmove_imm(ctx, t1, imm, is32);\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\temit_insn(ctx, stw, t1, dst, off);\n\t\t\t} else if (is_signed_imm14(off)) {\n\t\t\t\temit_insn(ctx, stptrw, t1, dst, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t2, off, is32);\n\t\t\t\temit_insn(ctx, stxw, t1, dst, t2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_DW:\n\t\t\tmove_imm(ctx, t1, imm, is32);\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\temit_insn(ctx, std, t1, dst, off);\n\t\t\t} else if (is_signed_imm14(off)) {\n\t\t\t\temit_insn(ctx, stptrd, t1, dst, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t2, off, is32);\n\t\t\t\temit_insn(ctx, stxd, t1, dst, t2);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t/* *(size *)(dst + off) = src */\n\tcase BPF_STX | BPF_MEM | BPF_B:\n\tcase BPF_STX | BPF_MEM | BPF_H:\n\tcase BPF_STX | BPF_MEM | BPF_W:\n\tcase BPF_STX | BPF_MEM | BPF_DW:\n\t\tswitch (BPF_SIZE(code)) {\n\t\tcase BPF_B:\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\temit_insn(ctx, stb, src, dst, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t1, off, is32);\n\t\t\t\temit_insn(ctx, stxb, src, dst, t1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_H:\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\temit_insn(ctx, sth, src, dst, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t1, off, is32);\n\t\t\t\temit_insn(ctx, stxh, src, dst, t1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_W:\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\temit_insn(ctx, stw, src, dst, off);\n\t\t\t} else if (is_signed_imm14(off)) {\n\t\t\t\temit_insn(ctx, stptrw, src, dst, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t1, off, is32);\n\t\t\t\temit_insn(ctx, stxw, src, dst, t1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_DW:\n\t\t\tif (is_signed_imm12(off)) {\n\t\t\t\temit_insn(ctx, std, src, dst, off);\n\t\t\t} else if (is_signed_imm14(off)) {\n\t\t\t\temit_insn(ctx, stptrd, src, dst, off);\n\t\t\t} else {\n\t\t\t\tmove_imm(ctx, t1, off, is32);\n\t\t\t\temit_insn(ctx, stxd, src, dst, t1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase BPF_STX | BPF_ATOMIC | BPF_W:\n\tcase BPF_STX | BPF_ATOMIC | BPF_DW:\n\t\temit_atomic(insn, ctx);\n\t\tbreak;\n\n\t/* Speculation barrier */\n\tcase BPF_ST | BPF_NOSPEC:\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"bpf_jit: unknown opcode %02x\\n\", code);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n\ntoofar:\n\tpr_info_once(\"bpf_jit: opcode %02x, jump too far\\n\", code);\n\treturn -E2BIG;\n}\n",
      "cve_list": [
        "CVE-2024-26588"
      ],
      "cwe_list": [
        "CWE-125",
        "CWE-119"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/bpf/hashtab.c",
      "func_name": "htab_map_alloc",
      "func_body": "static struct bpf_map *htab_map_alloc(union bpf_attr *attr)\n{\n\tbool percpu = (attr->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t\t       attr->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH);\n\tbool lru = (attr->map_type == BPF_MAP_TYPE_LRU_HASH ||\n\t\t    attr->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH);\n\t/* percpu_lru means each cpu has its own LRU list.\n\t * it is different from BPF_MAP_TYPE_PERCPU_HASH where\n\t * the map's value itself is percpu.  percpu_lru has\n\t * nothing to do with the map's value.\n\t */\n\tbool percpu_lru = (attr->map_flags & BPF_F_NO_COMMON_LRU);\n\tbool prealloc = !(attr->map_flags & BPF_F_NO_PREALLOC);\n\tstruct bpf_htab *htab;\n\tint err, i;\n\n\thtab = bpf_map_area_alloc(sizeof(*htab), NUMA_NO_NODE);\n\tif (!htab)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlockdep_register_key(&htab->lockdep_key);\n\n\tbpf_map_init_from_attr(&htab->map, attr);\n\n\tif (percpu_lru) {\n\t\t/* ensure each CPU's lru list has >=1 elements.\n\t\t * since we are at it, make each lru list has the same\n\t\t * number of elements.\n\t\t */\n\t\thtab->map.max_entries = roundup(attr->max_entries,\n\t\t\t\t\t\tnum_possible_cpus());\n\t\tif (htab->map.max_entries < attr->max_entries)\n\t\t\thtab->map.max_entries = rounddown(attr->max_entries,\n\t\t\t\t\t\t\t  num_possible_cpus());\n\t}\n\n\t/* hash table size must be power of 2; roundup_pow_of_two() can overflow\n\t * into UB on 32-bit arches, so check that first\n\t */\n\terr = -E2BIG;\n\tif (htab->map.max_entries > 1UL << 31)\n\t\tgoto free_htab;\n\n\thtab->n_buckets = roundup_pow_of_two(htab->map.max_entries);\n\n\thtab->elem_size = sizeof(struct htab_elem) +\n\t\t\t  round_up(htab->map.key_size, 8);\n\tif (percpu)\n\t\thtab->elem_size += sizeof(void *);\n\telse\n\t\thtab->elem_size += round_up(htab->map.value_size, 8);\n\n\t/* check for u32 overflow */\n\tif (htab->n_buckets > U32_MAX / sizeof(struct bucket))\n\t\tgoto free_htab;\n\n\terr = bpf_map_init_elem_count(&htab->map);\n\tif (err)\n\t\tgoto free_htab;\n\n\terr = -ENOMEM;\n\thtab->buckets = bpf_map_area_alloc(htab->n_buckets *\n\t\t\t\t\t   sizeof(struct bucket),\n\t\t\t\t\t   htab->map.numa_node);\n\tif (!htab->buckets)\n\t\tgoto free_elem_count;\n\n\tfor (i = 0; i < HASHTAB_MAP_LOCK_COUNT; i++) {\n\t\thtab->map_locked[i] = bpf_map_alloc_percpu(&htab->map,\n\t\t\t\t\t\t\t   sizeof(int),\n\t\t\t\t\t\t\t   sizeof(int),\n\t\t\t\t\t\t\t   GFP_USER);\n\t\tif (!htab->map_locked[i])\n\t\t\tgoto free_map_locked;\n\t}\n\n\tif (htab->map.map_flags & BPF_F_ZERO_SEED)\n\t\thtab->hashrnd = 0;\n\telse\n\t\thtab->hashrnd = get_random_u32();\n\n\thtab_init_buckets(htab);\n\n/* compute_batch_value() computes batch value as num_online_cpus() * 2\n * and __percpu_counter_compare() needs\n * htab->max_entries - cur_number_of_elems to be more than batch * num_online_cpus()\n * for percpu_counter to be faster than atomic_t. In practice the average bpf\n * hash map size is 10k, which means that a system with 64 cpus will fill\n * hashmap to 20% of 10k before percpu_counter becomes ineffective. Therefore\n * define our own batch count as 32 then 10k hash map can be filled up to 80%:\n * 10k - 8k > 32 _batch_ * 64 _cpus_\n * and __percpu_counter_compare() will still be fast. At that point hash map\n * collisions will dominate its performance anyway. Assume that hash map filled\n * to 50+% isn't going to be O(1) and use the following formula to choose\n * between percpu_counter and atomic_t.\n */\n#define PERCPU_COUNTER_BATCH 32\n\tif (attr->max_entries / 2 > num_online_cpus() * PERCPU_COUNTER_BATCH)\n\t\thtab->use_percpu_counter = true;\n\n\tif (htab->use_percpu_counter) {\n\t\terr = percpu_counter_init(&htab->pcount, 0, GFP_KERNEL);\n\t\tif (err)\n\t\t\tgoto free_map_locked;\n\t}\n\n\tif (prealloc) {\n\t\terr = prealloc_init(htab);\n\t\tif (err)\n\t\t\tgoto free_map_locked;\n\n\t\tif (!percpu && !lru) {\n\t\t\t/* lru itself can remove the least used element, so\n\t\t\t * there is no need for an extra elem during map_update.\n\t\t\t */\n\t\t\terr = alloc_extra_elems(htab);\n\t\t\tif (err)\n\t\t\t\tgoto free_prealloc;\n\t\t}\n\t} else {\n\t\terr = bpf_mem_alloc_init(&htab->ma, htab->elem_size, false);\n\t\tif (err)\n\t\t\tgoto free_map_locked;\n\t\tif (percpu) {\n\t\t\terr = bpf_mem_alloc_init(&htab->pcpu_ma,\n\t\t\t\t\t\t round_up(htab->map.value_size, 8), true);\n\t\t\tif (err)\n\t\t\t\tgoto free_map_locked;\n\t\t}\n\t}\n\n\treturn &htab->map;\n\nfree_prealloc:\n\tprealloc_destroy(htab);\nfree_map_locked:\n\tif (htab->use_percpu_counter)\n\t\tpercpu_counter_destroy(&htab->pcount);\n\tfor (i = 0; i < HASHTAB_MAP_LOCK_COUNT; i++)\n\t\tfree_percpu(htab->map_locked[i]);\n\tbpf_map_area_free(htab->buckets);\n\tbpf_mem_alloc_destroy(&htab->pcpu_ma);\n\tbpf_mem_alloc_destroy(&htab->ma);\nfree_elem_count:\n\tbpf_map_free_elem_count(&htab->map);\nfree_htab:\n\tlockdep_unregister_key(&htab->lockdep_key);\n\tbpf_map_area_free(htab);\n\treturn ERR_PTR(err);\n}\n",
      "cve_list": [
        "CVE-2024-26884"
      ],
      "cwe_list": [
        "CWE-190",
        "CWE-119"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/bpf/stackmap.c",
      "func_name": "stack_map_alloc",
      "func_body": "static struct bpf_map *stack_map_alloc(union bpf_attr *attr)\n{\n\tu32 value_size = attr->value_size;\n\tstruct bpf_stack_map *smap;\n\tu64 cost, n_buckets;\n\tint err;\n\n\tif (attr->map_flags & ~STACK_CREATE_FLAG_MASK)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 || attr->key_size != 4 ||\n\t    value_size < 8 || value_size % 8)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tBUILD_BUG_ON(sizeof(struct bpf_stack_build_id) % sizeof(u64));\n\tif (attr->map_flags & BPF_F_STACK_BUILD_ID) {\n\t\tif (value_size % sizeof(struct bpf_stack_build_id) ||\n\t\t    value_size / sizeof(struct bpf_stack_build_id)\n\t\t    > sysctl_perf_event_max_stack)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t} else if (value_size / 8 > sysctl_perf_event_max_stack)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* hash table size must be power of 2; roundup_pow_of_two() can overflow\n\t * into UB on 32-bit arches, so check that first\n\t */\n\tif (attr->max_entries > 1UL << 31)\n\t\treturn ERR_PTR(-E2BIG);\n\n\tn_buckets = roundup_pow_of_two(attr->max_entries);\n\n\tcost = n_buckets * sizeof(struct stack_map_bucket *) + sizeof(*smap);\n\tsmap = bpf_map_area_alloc(cost, bpf_map_attr_numa_node(attr));\n\tif (!smap)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbpf_map_init_from_attr(&smap->map, attr);\n\tsmap->n_buckets = n_buckets;\n\n\terr = get_callchain_buffers(sysctl_perf_event_max_stack);\n\tif (err)\n\t\tgoto free_smap;\n\n\terr = prealloc_elems_and_freelist(smap);\n\tif (err)\n\t\tgoto put_buffers;\n\n\treturn &smap->map;\n\nput_buffers:\n\tput_callchain_buffers();\nfree_smap:\n\tbpf_map_area_free(smap);\n\treturn ERR_PTR(err);\n}\n",
      "cve_list": [
        "CVE-2024-26883"
      ],
      "cwe_list": [
        "CWE-119"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/pwm/core.c",
      "func_name": "of_pwm_single_xlate",
      "func_body": "struct pwm_device *\nof_pwm_single_xlate(struct pwm_chip *chip, const struct of_phandle_args *args)\n{\n\tstruct pwm_device *pwm;\n\n\tif (chip->of_pwm_n_cells < 1)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* validate that one cell is specified, optionally with flags */\n\tif (args->args_count != 1 && args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpwm = pwm_request_from_chip(chip, 0, NULL);\n\tif (IS_ERR(pwm))\n\t\treturn pwm;\n\n\tpwm->args.period = args->args[0];\n\tpwm->args.polarity = PWM_POLARITY_NORMAL;\n\n\tif (args->args_count == 2 && args->args[1] & PWM_POLARITY_INVERTED)\n\t\tpwm->args.polarity = PWM_POLARITY_INVERSED;\n\n\treturn pwm;\n}\n",
      "cve_list": [
        "CVE-2024-26599"
      ],
      "cwe_list": [
        "CWE-119"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/ppatomctrl.c",
      "func_name": "atomctrl_retrieve_ac_timing",
      "func_body": "static int atomctrl_retrieve_ac_timing(\n\t\tuint8_t index,\n\t\tATOM_INIT_REG_BLOCK *reg_block,\n\t\tpp_atomctrl_mc_reg_table *table)\n{\n\tuint32_t i, j;\n\tuint8_t tmem_id;\n\tATOM_MEMORY_SETTING_DATA_BLOCK *reg_data = (ATOM_MEMORY_SETTING_DATA_BLOCK *)\n\t\t((uint8_t *)reg_block + (2 * sizeof(uint16_t)) + le16_to_cpu(reg_block->usRegIndexTblSize));\n\n\tuint8_t num_ranges = 0;\n\n\twhile (*(uint32_t *)reg_data != END_OF_REG_DATA_BLOCK &&\n\t\t\tnum_ranges < VBIOS_MAX_AC_TIMING_ENTRIES) {\n\t\ttmem_id = (uint8_t)((*(uint32_t *)reg_data & MEM_ID_MASK) >> MEM_ID_SHIFT);\n\n\t\tif (index == tmem_id) {\n\t\t\ttable->mc_reg_table_entry[num_ranges].mclk_max =\n\t\t\t\t(uint32_t)((*(uint32_t *)reg_data & CLOCK_RANGE_MASK) >>\n\t\t\t\t\t\tCLOCK_RANGE_SHIFT);\n\n\t\t\tfor (i = 0, j = 1; i < table->last; i++) {\n\t\t\t\tif ((table->mc_reg_address[i].uc_pre_reg_data &\n\t\t\t\t\t\t\tLOW_NIBBLE_MASK) == DATA_FROM_TABLE) {\n\t\t\t\t\ttable->mc_reg_table_entry[num_ranges].mc_data[i] =\n\t\t\t\t\t\t(uint32_t)*((uint32_t *)reg_data + j);\n\t\t\t\t\tj++;\n\t\t\t\t} else if ((table->mc_reg_address[i].uc_pre_reg_data &\n\t\t\t\t\t\t\tLOW_NIBBLE_MASK) == DATA_EQU_PREV) {\n\t\t\t\t\tif (i)\n\t\t\t\t\t\ttable->mc_reg_table_entry[num_ranges].mc_data[i] =\n\t\t\t\t\t\t\ttable->mc_reg_table_entry[num_ranges].mc_data[i-1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum_ranges++;\n\t\t}\n\n\t\treg_data = (ATOM_MEMORY_SETTING_DATA_BLOCK *)\n\t\t\t((uint8_t *)reg_data + le16_to_cpu(reg_block->usRegDataBlkSize)) ;\n\t}\n\n\tPP_ASSERT_WITH_CODE((*(uint32_t *)reg_data == END_OF_REG_DATA_BLOCK),\n\t\t\t\"Invalid VramInfo table.\", return -1);\n\ttable->num_entries = num_ranges;\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-46731"
      ],
      "cwe_list": [
        "CWE-125"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/char/tpm/tpm_tis_spi_main.c",
      "func_name": "tpm_tis_spi_init",
      "func_body": "int tpm_tis_spi_init(struct spi_device *spi, struct tpm_tis_spi_phy *phy,\n\t\t     int irq, const struct tpm_tis_phy_ops *phy_ops)\n{\n\tphy->iobuf = devm_kmalloc(&spi->dev, SPI_HDRSIZE + MAX_SPI_FRAMESIZE, GFP_KERNEL);\n\tif (!phy->iobuf)\n\t\treturn -ENOMEM;\n\n\tphy->spi_device = spi;\n\n\treturn tpm_tis_core_init(&spi->dev, &phy->priv, irq, phy_ops, NULL);\n}\n",
      "cve_list": [
        "CVE-2024-36477"
      ],
      "cwe_list": [
        "CWE-125"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/v3d/v3d_sched.c",
      "func_name": "v3d_csd_job_run",
      "func_body": "static struct dma_fence *\nv3d_csd_job_run(struct drm_sched_job *sched_job)\n{\n\tstruct v3d_csd_job *job = to_csd_job(sched_job);\n\tstruct v3d_dev *v3d = job->base.v3d;\n\tstruct drm_device *dev = &v3d->drm;\n\tstruct dma_fence *fence;\n\tint i, csd_cfg0_reg;\n\n\tv3d->csd_job = job;\n\n\tv3d_invalidate_caches(v3d);\n\n\tfence = v3d_fence_create(v3d, V3D_CSD);\n\tif (IS_ERR(fence))\n\t\treturn NULL;\n\n\tif (job->base.irq_fence)\n\t\tdma_fence_put(job->base.irq_fence);\n\tjob->base.irq_fence = dma_fence_get(fence);\n\n\ttrace_v3d_submit_csd(dev, to_v3d_fence(fence)->seqno);\n\n\tv3d_job_start_stats(&job->base, V3D_CSD);\n\tv3d_switch_perfmon(v3d, &job->base);\n\n\tcsd_cfg0_reg = V3D_CSD_QUEUED_CFG0(v3d->ver);\n\tfor (i = 1; i <= 6; i++)\n\t\tV3D_CORE_WRITE(0, csd_cfg0_reg + 4 * i, job->args.cfg[i]);\n\n\t/* Although V3D 7.1 has an eighth configuration register, we are not\n\t * using it. Therefore, make sure it remains unused.\n\t *\n\t * XXX: Set the CFG7 register\n\t */\n\tif (v3d->ver >= 71)\n\t\tV3D_CORE_WRITE(0, V3D_V7_CSD_QUEUED_CFG7, 0);\n\n\t/* CFG0 write kicks off the job. */\n\tV3D_CORE_WRITE(0, csd_cfg0_reg, job->args.cfg[0]);\n\n\treturn fence;\n}\n",
      "cve_list": [
        "CVE-2024-44993"
      ],
      "cwe_list": [
        "CWE-125"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c",
      "func_name": "amdgpu_atombios_init_mc_reg_table",
      "func_body": "int amdgpu_atombios_init_mc_reg_table(struct amdgpu_device *adev,\n\t\t\t\t      u8 module_index,\n\t\t\t\t      struct atom_mc_reg_table *reg_table)\n{\n\tint index = GetIndexIntoMasterTable(DATA, VRAM_Info);\n\tu8 frev, crev, num_entries, t_mem_id, num_ranges = 0;\n\tu32 i = 0, j;\n\tu16 data_offset, size;\n\tunion vram_info *vram_info;\n\n\tmemset(reg_table, 0, sizeof(struct atom_mc_reg_table));\n\n\tif (amdgpu_atom_parse_data_header(adev->mode_info.atom_context, index, &size,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tvram_info = (union vram_info *)\n\t\t\t(adev->mode_info.atom_context->bios + data_offset);\n\t\tswitch (frev) {\n\t\tcase 1:\n\t\t\tDRM_ERROR(\"old table version %d, %d\\n\", frev, crev);\n\t\t\treturn -EINVAL;\n\t\tcase 2:\n\t\t\tswitch (crev) {\n\t\t\tcase 1:\n\t\t\t\tif (module_index < vram_info->v2_1.ucNumOfVRAMModule) {\n\t\t\t\t\tATOM_INIT_REG_BLOCK *reg_block =\n\t\t\t\t\t\t(ATOM_INIT_REG_BLOCK *)\n\t\t\t\t\t\t((u8 *)vram_info + le16_to_cpu(vram_info->v2_1.usMemClkPatchTblOffset));\n\t\t\t\t\tATOM_MEMORY_SETTING_DATA_BLOCK *reg_data =\n\t\t\t\t\t\t(ATOM_MEMORY_SETTING_DATA_BLOCK *)\n\t\t\t\t\t\t((u8 *)reg_block + (2 * sizeof(u16)) +\n\t\t\t\t\t\t le16_to_cpu(reg_block->usRegIndexTblSize));\n\t\t\t\t\tATOM_INIT_REG_INDEX_FORMAT *format = &reg_block->asRegIndexBuf[0];\n\t\t\t\t\tnum_entries = (u8)((le16_to_cpu(reg_block->usRegIndexTblSize)) /\n\t\t\t\t\t\t\t   sizeof(ATOM_INIT_REG_INDEX_FORMAT)) - 1;\n\t\t\t\t\tif (num_entries > VBIOS_MC_REGISTER_ARRAY_SIZE)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\twhile (i < num_entries) {\n\t\t\t\t\t\tif (format->ucPreRegDataLength & ACCESS_PLACEHOLDER)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\treg_table->mc_reg_address[i].s1 =\n\t\t\t\t\t\t\t(u16)(le16_to_cpu(format->usRegIndex));\n\t\t\t\t\t\treg_table->mc_reg_address[i].pre_reg_data =\n\t\t\t\t\t\t\t(u8)(format->ucPreRegDataLength);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tformat = (ATOM_INIT_REG_INDEX_FORMAT *)\n\t\t\t\t\t\t\t((u8 *)format + sizeof(ATOM_INIT_REG_INDEX_FORMAT));\n\t\t\t\t\t}\n\t\t\t\t\treg_table->last = i;\n\t\t\t\t\twhile ((le32_to_cpu(*(u32 *)reg_data) != END_OF_REG_DATA_BLOCK) &&\n\t\t\t\t\t       (num_ranges < VBIOS_MAX_AC_TIMING_ENTRIES)) {\n\t\t\t\t\t\tt_mem_id = (u8)((le32_to_cpu(*(u32 *)reg_data) & MEM_ID_MASK)\n\t\t\t\t\t\t\t\t>> MEM_ID_SHIFT);\n\t\t\t\t\t\tif (module_index == t_mem_id) {\n\t\t\t\t\t\t\treg_table->mc_reg_table_entry[num_ranges].mclk_max =\n\t\t\t\t\t\t\t\t(u32)((le32_to_cpu(*(u32 *)reg_data) & CLOCK_RANGE_MASK)\n\t\t\t\t\t\t\t\t      >> CLOCK_RANGE_SHIFT);\n\t\t\t\t\t\t\tfor (i = 0, j = 1; i < reg_table->last; i++) {\n\t\t\t\t\t\t\t\tif ((reg_table->mc_reg_address[i].pre_reg_data & LOW_NIBBLE_MASK) == DATA_FROM_TABLE) {\n\t\t\t\t\t\t\t\t\treg_table->mc_reg_table_entry[num_ranges].mc_data[i] =\n\t\t\t\t\t\t\t\t\t\t(u32)le32_to_cpu(*((u32 *)reg_data + j));\n\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t} else if ((reg_table->mc_reg_address[i].pre_reg_data & LOW_NIBBLE_MASK) == DATA_EQU_PREV) {\n\t\t\t\t\t\t\t\t\tif (i == 0)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\treg_table->mc_reg_table_entry[num_ranges].mc_data[i] =\n\t\t\t\t\t\t\t\t\t\treg_table->mc_reg_table_entry[num_ranges].mc_data[i - 1];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum_ranges++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treg_data = (ATOM_MEMORY_SETTING_DATA_BLOCK *)\n\t\t\t\t\t\t\t((u8 *)reg_data + le16_to_cpu(reg_block->usRegDataBlkSize));\n\t\t\t\t\t}\n\t\t\t\t\tif (le32_to_cpu(*(u32 *)reg_data) != END_OF_REG_DATA_BLOCK)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\treg_table->num_entries = num_ranges;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n",
      "cve_list": [
        "CVE-2024-46722"
      ],
      "cwe_list": [
        "CWE-125"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/amdgpu/amdgpu_cgs.c",
      "func_name": "amdgpu_cgs_get_firmware_info",
      "func_body": "static int amdgpu_cgs_get_firmware_info(struct cgs_device *cgs_device,\n\t\t\t\t\tenum cgs_ucode_id type,\n\t\t\t\t\tstruct cgs_firmware_info *info)\n{\n\tCGS_FUNC_ADEV;\n\n\tif (type != CGS_UCODE_ID_SMU && type != CGS_UCODE_ID_SMU_SK) {\n\t\tuint64_t gpu_addr;\n\t\tuint32_t data_size;\n\t\tconst struct gfx_firmware_header_v1_0 *header;\n\t\tenum AMDGPU_UCODE_ID id;\n\t\tstruct amdgpu_firmware_info *ucode;\n\n\t\tid = fw_type_convert(cgs_device, type);\n\t\tif (id >= AMDGPU_UCODE_ID_MAXIMUM)\n\t\t\treturn -EINVAL;\n\n\t\tucode = &adev->firmware.ucode[id];\n\t\tif (ucode->fw == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tgpu_addr  = ucode->mc_addr;\n\t\theader = (const struct gfx_firmware_header_v1_0 *)ucode->fw->data;\n\t\tdata_size = le32_to_cpu(header->header.ucode_size_bytes);\n\n\t\tif ((type == CGS_UCODE_ID_CP_MEC_JT1) ||\n\t\t    (type == CGS_UCODE_ID_CP_MEC_JT2)) {\n\t\t\tgpu_addr += ALIGN(le32_to_cpu(header->header.ucode_size_bytes), PAGE_SIZE);\n\t\t\tdata_size = le32_to_cpu(header->jt_size) << 2;\n\t\t}\n\n\t\tinfo->kptr = ucode->kaddr;\n\t\tinfo->image_size = data_size;\n\t\tinfo->mc_addr = gpu_addr;\n\t\tinfo->version = (uint16_t)le32_to_cpu(header->header.ucode_version);\n\n\t\tif (type == CGS_UCODE_ID_CP_MEC)\n\t\t\tinfo->image_size = le32_to_cpu(header->jt_offset) << 2;\n\n\t\tinfo->fw_version = amdgpu_get_firmware_version(cgs_device, type);\n\t\tinfo->feature_version = (uint16_t)le32_to_cpu(header->ucode_feature_version);\n\t} else {\n\t\tchar fw_name[30] = {0};\n\t\tint err = 0;\n\t\tuint32_t ucode_size;\n\t\tuint32_t ucode_start_address;\n\t\tconst uint8_t *src;\n\t\tconst struct smc_firmware_header_v1_0 *hdr;\n\t\tconst struct common_firmware_header *header;\n\t\tstruct amdgpu_firmware_info *ucode = NULL;\n\n\t\tif (!adev->pm.fw) {\n\t\t\tswitch (adev->asic_type) {\n\t\t\tcase CHIP_TAHITI:\n\t\t\t\tstrcpy(fw_name, \"radeon/tahiti_smc.bin\");\n\t\t\t\tbreak;\n\t\t\tcase CHIP_PITCAIRN:\n\t\t\t\tif ((adev->pdev->revision == 0x81) &&\n\t\t\t\t    ((adev->pdev->device == 0x6810) ||\n\t\t\t\t    (adev->pdev->device == 0x6811))) {\n\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\tstrcpy(fw_name, \"radeon/pitcairn_k_smc.bin\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(fw_name, \"radeon/pitcairn_smc.bin\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CHIP_VERDE:\n\t\t\t\tif (((adev->pdev->device == 0x6820) &&\n\t\t\t\t\t((adev->pdev->revision == 0x81) ||\n\t\t\t\t\t(adev->pdev->revision == 0x83))) ||\n\t\t\t\t    ((adev->pdev->device == 0x6821) &&\n\t\t\t\t\t((adev->pdev->revision == 0x83) ||\n\t\t\t\t\t(adev->pdev->revision == 0x87))) ||\n\t\t\t\t    ((adev->pdev->revision == 0x87) &&\n\t\t\t\t\t((adev->pdev->device == 0x6823) ||\n\t\t\t\t\t(adev->pdev->device == 0x682b)))) {\n\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\tstrcpy(fw_name, \"radeon/verde_k_smc.bin\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(fw_name, \"radeon/verde_smc.bin\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CHIP_OLAND:\n\t\t\t\tif (((adev->pdev->revision == 0x81) &&\n\t\t\t\t\t((adev->pdev->device == 0x6600) ||\n\t\t\t\t\t(adev->pdev->device == 0x6604) ||\n\t\t\t\t\t(adev->pdev->device == 0x6605) ||\n\t\t\t\t\t(adev->pdev->device == 0x6610))) ||\n\t\t\t\t    ((adev->pdev->revision == 0x83) &&\n\t\t\t\t\t(adev->pdev->device == 0x6610))) {\n\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\tstrcpy(fw_name, \"radeon/oland_k_smc.bin\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(fw_name, \"radeon/oland_smc.bin\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CHIP_HAINAN:\n\t\t\t\tif (((adev->pdev->revision == 0x81) &&\n\t\t\t\t\t(adev->pdev->device == 0x6660)) ||\n\t\t\t\t    ((adev->pdev->revision == 0x83) &&\n\t\t\t\t\t((adev->pdev->device == 0x6660) ||\n\t\t\t\t\t(adev->pdev->device == 0x6663) ||\n\t\t\t\t\t(adev->pdev->device == 0x6665) ||\n\t\t\t\t\t (adev->pdev->device == 0x6667)))) {\n\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\tstrcpy(fw_name, \"radeon/hainan_k_smc.bin\");\n\t\t\t\t} else if ((adev->pdev->revision == 0xc3) &&\n\t\t\t\t\t (adev->pdev->device == 0x6665)) {\n\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\tstrcpy(fw_name, \"radeon/banks_k_2_smc.bin\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(fw_name, \"radeon/hainan_smc.bin\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CHIP_BONAIRE:\n\t\t\t\tif ((adev->pdev->revision == 0x80) ||\n\t\t\t\t\t(adev->pdev->revision == 0x81) ||\n\t\t\t\t\t(adev->pdev->device == 0x665f)) {\n\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/bonaire_k_smc.bin\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/bonaire_smc.bin\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CHIP_HAWAII:\n\t\t\t\tif (adev->pdev->revision == 0x80) {\n\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/hawaii_k_smc.bin\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/hawaii_smc.bin\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CHIP_TOPAZ:\n\t\t\t\tif (((adev->pdev->device == 0x6900) && (adev->pdev->revision == 0x81)) ||\n\t\t\t\t    ((adev->pdev->device == 0x6900) && (adev->pdev->revision == 0x83)) ||\n\t\t\t\t    ((adev->pdev->device == 0x6907) && (adev->pdev->revision == 0x87)) ||\n\t\t\t\t    ((adev->pdev->device == 0x6900) && (adev->pdev->revision == 0xD1)) ||\n\t\t\t\t    ((adev->pdev->device == 0x6900) && (adev->pdev->revision == 0xD3))) {\n\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/topaz_k_smc.bin\");\n\t\t\t\t} else\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/topaz_smc.bin\");\n\t\t\t\tbreak;\n\t\t\tcase CHIP_TONGA:\n\t\t\t\tif (((adev->pdev->device == 0x6939) && (adev->pdev->revision == 0xf1)) ||\n\t\t\t\t    ((adev->pdev->device == 0x6938) && (adev->pdev->revision == 0xf1))) {\n\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/tonga_k_smc.bin\");\n\t\t\t\t} else\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/tonga_smc.bin\");\n\t\t\t\tbreak;\n\t\t\tcase CHIP_FIJI:\n\t\t\t\tstrcpy(fw_name, \"amdgpu/fiji_smc.bin\");\n\t\t\t\tbreak;\n\t\t\tcase CHIP_POLARIS11:\n\t\t\t\tif (type == CGS_UCODE_ID_SMU) {\n\t\t\t\t\tif (ASICID_IS_P21(adev->pdev->device, adev->pdev->revision)) {\n\t\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\t\tstrcpy(fw_name, \"amdgpu/polaris11_k_smc.bin\");\n\t\t\t\t\t} else if (ASICID_IS_P31(adev->pdev->device, adev->pdev->revision)) {\n\t\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\t\tstrcpy(fw_name, \"amdgpu/polaris11_k2_smc.bin\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrcpy(fw_name, \"amdgpu/polaris11_smc.bin\");\n\t\t\t\t\t}\n\t\t\t\t} else if (type == CGS_UCODE_ID_SMU_SK) {\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/polaris11_smc_sk.bin\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CHIP_POLARIS10:\n\t\t\t\tif (type == CGS_UCODE_ID_SMU) {\n\t\t\t\t\tif (ASICID_IS_P20(adev->pdev->device, adev->pdev->revision)) {\n\t\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\t\tstrcpy(fw_name, \"amdgpu/polaris10_k_smc.bin\");\n\t\t\t\t\t} else if (ASICID_IS_P30(adev->pdev->device, adev->pdev->revision)) {\n\t\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\t\tstrcpy(fw_name, \"amdgpu/polaris10_k2_smc.bin\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrcpy(fw_name, \"amdgpu/polaris10_smc.bin\");\n\t\t\t\t\t}\n\t\t\t\t} else if (type == CGS_UCODE_ID_SMU_SK) {\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/polaris10_smc_sk.bin\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CHIP_POLARIS12:\n\t\t\t\tif (ASICID_IS_P23(adev->pdev->device, adev->pdev->revision)) {\n\t\t\t\t\tinfo->is_kicker = true;\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/polaris12_k_smc.bin\");\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/polaris12_smc.bin\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CHIP_VEGAM:\n\t\t\t\tstrcpy(fw_name, \"amdgpu/vegam_smc.bin\");\n\t\t\t\tbreak;\n\t\t\tcase CHIP_VEGA10:\n\t\t\t\tif ((adev->pdev->device == 0x687f) &&\n\t\t\t\t\t((adev->pdev->revision == 0xc0) ||\n\t\t\t\t\t(adev->pdev->revision == 0xc1) ||\n\t\t\t\t\t(adev->pdev->revision == 0xc3)))\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/vega10_acg_smc.bin\");\n\t\t\t\telse\n\t\t\t\t\tstrcpy(fw_name, \"amdgpu/vega10_smc.bin\");\n\t\t\t\tbreak;\n\t\t\tcase CHIP_VEGA12:\n\t\t\t\tstrcpy(fw_name, \"amdgpu/vega12_smc.bin\");\n\t\t\t\tbreak;\n\t\t\tcase CHIP_VEGA20:\n\t\t\t\tstrcpy(fw_name, \"amdgpu/vega20_smc.bin\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"SMC firmware not supported\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\terr = amdgpu_ucode_request(adev, &adev->pm.fw, fw_name);\n\t\t\tif (err) {\n\t\t\t\tDRM_ERROR(\"Failed to load firmware \\\"%s\\\"\", fw_name);\n\t\t\t\tamdgpu_ucode_release(&adev->pm.fw);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP) {\n\t\t\t\tucode = &adev->firmware.ucode[AMDGPU_UCODE_ID_SMC];\n\t\t\t\tucode->ucode_id = AMDGPU_UCODE_ID_SMC;\n\t\t\t\tucode->fw = adev->pm.fw;\n\t\t\t\theader = (const struct common_firmware_header *)ucode->fw->data;\n\t\t\t\tadev->firmware.fw_size +=\n\t\t\t\t\tALIGN(le32_to_cpu(header->ucode_size_bytes), PAGE_SIZE);\n\t\t\t}\n\t\t}\n\n\t\thdr = (const struct smc_firmware_header_v1_0 *)\tadev->pm.fw->data;\n\t\tamdgpu_ucode_print_smc_hdr(&hdr->header);\n\t\tadev->pm.fw_version = le32_to_cpu(hdr->header.ucode_version);\n\t\tucode_size = le32_to_cpu(hdr->header.ucode_size_bytes);\n\t\tucode_start_address = le32_to_cpu(hdr->ucode_start_addr);\n\t\tsrc = (const uint8_t *)(adev->pm.fw->data +\n\t\t       le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\n\t\tinfo->version = adev->pm.fw_version;\n\t\tinfo->image_size = ucode_size;\n\t\tinfo->ucode_start_address = ucode_start_address;\n\t\tinfo->kptr = (void *)src;\n\t}\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-46723"
      ],
      "cwe_list": [
        "CWE-125"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/amdgpu/sdma_v4_0.c",
      "func_name": "sdma_v4_0_process_trap_irq",
      "func_body": "static int sdma_v4_0_process_trap_irq(struct amdgpu_device *adev,\n\t\t\t\t      struct amdgpu_irq_src *source,\n\t\t\t\t      struct amdgpu_iv_entry *entry)\n{\n\tuint32_t instance;\n\n\tDRM_DEBUG(\"IH: SDMA trap\\n\");\n\tinstance = sdma_v4_0_irq_id_to_seq(entry->client_id);\n\tif (instance < 0)\n\t\treturn instance;\n\n\tswitch (entry->ring_id) {\n\tcase 0:\n\t\tamdgpu_fence_process(&adev->sdma.instance[instance].ring);\n\t\tbreak;\n\tcase 1:\n\t\tif (amdgpu_ip_version(adev, SDMA0_HWIP, 0) ==\n\t\t    IP_VERSION(4, 2, 0))\n\t\t\tamdgpu_fence_process(&adev->sdma.instance[instance].page);\n\t\tbreak;\n\tcase 2:\n\t\t/* XXX compute */\n\t\tbreak;\n\tcase 3:\n\t\tif (amdgpu_ip_version(adev, SDMA0_HWIP, 0) !=\n\t\t    IP_VERSION(4, 2, 0))\n\t\t\tamdgpu_fence_process(&adev->sdma.instance[instance].page);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-39471"
      ],
      "cwe_list": [
        "CWE-125"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/smb/server/asn1.c",
      "func_name": "ksmbd_neg_token_alloc",
      "func_body": "static int ksmbd_neg_token_alloc(void *context, size_t hdrlen,\n\t\t\t\t unsigned char tag, const void *value,\n\t\t\t\t size_t vlen)\n{\n\tstruct ksmbd_conn *conn = context;\n\n\tif (!vlen)\n\t\treturn -EINVAL;\n\n\tconn->mechToken = kmemdup_nul(value, vlen, GFP_KERNEL);\n\tif (!conn->mechToken)\n\t\treturn -ENOMEM;\n\n\tconn->mechTokenLen = (unsigned int)vlen;\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-26594"
      ],
      "cwe_list": [
        "CWE-125"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/hid/hid-cougar.c",
      "func_name": "cougar_report_fixup",
      "func_body": "static __u8 *cougar_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\t\t\t unsigned int *rsize)\n{\n\tif (*rsize >= 117 && rdesc[2] == 0x09 && rdesc[3] == 0x02 &&\n\t    (rdesc[115] | rdesc[116] << 8) >= HID_MAX_USAGES) {\n\t\thid_info(hdev,\n\t\t\t\"usage count exceeds max: fixing up report descriptor\\n\");\n\t\trdesc[115] = ((HID_MAX_USAGES-1) & 0xff);\n\t\trdesc[116] = ((HID_MAX_USAGES-1) >> 8);\n\t}\n\treturn rdesc;\n}\n",
      "cve_list": [
        "CVE-2024-46747"
      ],
      "cwe_list": [
        "CWE-125"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/of/irq.c",
      "func_name": "of_irq_parse_one",
      "func_body": "int of_irq_parse_one(struct device_node *device, int index, struct of_phandle_args *out_irq)\n{\n\tstruct device_node *p;\n\tconst __be32 *addr;\n\tu32 intsize;\n\tint i, res, addr_len;\n\t__be32 addr_buf[3] = { 0 };\n\n\tpr_debug(\"of_irq_parse_one: dev=%pOF, index=%d\\n\", device, index);\n\n\t/* OldWorld mac stuff is \"special\", handle out of line */\n\tif (of_irq_workarounds & OF_IMAP_OLDWORLD_MAC)\n\t\treturn of_irq_parse_oldworld(device, index, out_irq);\n\n\t/* Get the reg property (if any) */\n\taddr = of_get_property(device, \"reg\", &addr_len);\n\n\t/* Prevent out-of-bounds read in case of longer interrupt parent address size */\n\tif (addr_len > (3 * sizeof(__be32)))\n\t\taddr_len = 3 * sizeof(__be32);\n\tif (addr)\n\t\tmemcpy(addr_buf, addr, addr_len);\n\n\t/* Try the new-style interrupts-extended first */\n\tres = of_parse_phandle_with_args(device, \"interrupts-extended\",\n\t\t\t\t\t\"#interrupt-cells\", index, out_irq);\n\tif (!res)\n\t\treturn of_irq_parse_raw(addr_buf, out_irq);\n\n\t/* Look for the interrupt parent. */\n\tp = of_irq_find_parent(device);\n\tif (p == NULL)\n\t\treturn -EINVAL;\n\n\t/* Get size of interrupt specifier */\n\tif (of_property_read_u32(p, \"#interrupt-cells\", &intsize)) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\" parent=%pOF, intsize=%d\\n\", p, intsize);\n\n\t/* Copy intspec into irq structure */\n\tout_irq->np = p;\n\tout_irq->args_count = intsize;\n\tfor (i = 0; i < intsize; i++) {\n\t\tres = of_property_read_u32_index(device, \"interrupts\",\n\t\t\t\t\t\t (index * intsize) + i,\n\t\t\t\t\t\t out_irq->args + i);\n\t\tif (res)\n\t\t\tgoto out;\n\t}\n\n\tpr_debug(\" intspec=%d\\n\", *out_irq->args);\n\n\n\t/* Check if there are any interrupt-map translations to process */\n\tres = of_irq_parse_raw(addr_buf, out_irq);\n out:\n\tof_node_put(p);\n\treturn res;\n}\n",
      "cve_list": [
        "CVE-2024-46743"
      ],
      "cwe_list": [
        "CWE-125"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/i2c/busses/i2c-i801.c",
      "func_name": "i801_block_transaction_by_block",
      "func_body": "static int i801_block_transaction_by_block(struct i801_priv *priv,\n\t\t\t\t\t   union i2c_smbus_data *data,\n\t\t\t\t\t   char read_write, int command)\n{\n\tint i, len, status, xact;\n\n\tswitch (command) {\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\txact = I801_BLOCK_PROC_CALL;\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\txact = I801_BLOCK_DATA;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* Set block buffer mode */\n\toutb_p(inb_p(SMBAUXCTL(priv)) | SMBAUXCTL_E32B, SMBAUXCTL(priv));\n\n\tif (read_write == I2C_SMBUS_WRITE) {\n\t\tlen = data->block[0];\n\t\toutb_p(len, SMBHSTDAT0(priv));\n\t\tinb_p(SMBHSTCNT(priv));\t/* reset the data buffer index */\n\t\tfor (i = 0; i < len; i++)\n\t\t\toutb_p(data->block[i+1], SMBBLKDAT(priv));\n\t}\n\n\tstatus = i801_transaction(priv, xact);\n\tif (status)\n\t\tgoto out;\n\n\tif (read_write == I2C_SMBUS_READ ||\n\t    command == I2C_SMBUS_BLOCK_PROC_CALL) {\n\t\tlen = inb_p(SMBHSTDAT0(priv));\n\t\tif (len < 1 || len > I2C_SMBUS_BLOCK_MAX) {\n\t\t\tstatus = -EPROTO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->block[0] = len;\n\t\tinb_p(SMBHSTCNT(priv));\t/* reset the data buffer index */\n\t\tfor (i = 0; i < len; i++)\n\t\t\tdata->block[i + 1] = inb_p(SMBBLKDAT(priv));\n\t}\nout:\n\toutb_p(inb_p(SMBAUXCTL(priv)) & ~SMBAUXCTL_E32B, SMBAUXCTL(priv));\n\treturn status;\n}\n",
      "cve_list": [
        "CVE-2024-26593"
      ],
      "cwe_list": [
        "CWE-125"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/smb/server/smb2misc.c",
      "func_name": "smb2_get_data_area_len",
      "func_body": "static int smb2_get_data_area_len(unsigned int *off, unsigned int *len,\n\t\t\t\t  struct smb2_hdr *hdr)\n{\n\tint ret = 0;\n\n\t*off = 0;\n\t*len = 0;\n\n\t/*\n\t * Following commands have data areas so we have to get the location\n\t * of the data buffer offset and data buffer length for the particular\n\t * command.\n\t */\n\tswitch (hdr->Command) {\n\tcase SMB2_SESSION_SETUP:\n\t\t*off = le16_to_cpu(((struct smb2_sess_setup_req *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(((struct smb2_sess_setup_req *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_TREE_CONNECT:\n\t\t*off = le16_to_cpu(((struct smb2_tree_connect_req *)hdr)->PathOffset);\n\t\t*len = le16_to_cpu(((struct smb2_tree_connect_req *)hdr)->PathLength);\n\t\tbreak;\n\tcase SMB2_CREATE:\n\t{\n\t\tunsigned short int name_off =\n\t\t\tle16_to_cpu(((struct smb2_create_req *)hdr)->NameOffset);\n\t\tunsigned short int name_len =\n\t\t\tle16_to_cpu(((struct smb2_create_req *)hdr)->NameLength);\n\n\t\tif (((struct smb2_create_req *)hdr)->CreateContextsLength) {\n\t\t\t*off = le32_to_cpu(((struct smb2_create_req *)\n\t\t\t\thdr)->CreateContextsOffset);\n\t\t\t*len = le32_to_cpu(((struct smb2_create_req *)\n\t\t\t\thdr)->CreateContextsLength);\n\t\t\tif (!name_len)\n\t\t\t\tbreak;\n\n\t\t\tif (name_off + name_len < (u64)*off + *len)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t*off = name_off;\n\t\t*len = name_len;\n\t\tbreak;\n\t}\n\tcase SMB2_QUERY_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_query_info_req *)hdr)->InputBufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_query_info_req *)hdr)->InputBufferLength);\n\t\tbreak;\n\tcase SMB2_SET_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_set_info_req *)hdr)->BufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_set_info_req *)hdr)->BufferLength);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\t*off = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_WRITE:\n\t\tif (((struct smb2_write_req *)hdr)->DataOffset ||\n\t\t    ((struct smb2_write_req *)hdr)->Length) {\n\t\t\t*off = max_t(unsigned int,\n\t\t\t\t     le16_to_cpu(((struct smb2_write_req *)hdr)->DataOffset),\n\t\t\t\t     offsetof(struct smb2_write_req, Buffer));\n\t\t\t*len = le32_to_cpu(((struct smb2_write_req *)hdr)->Length);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\t*off = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameOffset);\n\t\t*len = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameLength);\n\t\tbreak;\n\tcase SMB2_LOCK:\n\t{\n\t\tunsigned short lock_count;\n\n\t\tlock_count = le16_to_cpu(((struct smb2_lock_req *)hdr)->LockCount);\n\t\tif (lock_count > 0) {\n\t\t\t*off = offsetof(struct smb2_lock_req, locks);\n\t\t\t*len = sizeof(struct smb2_lock_element) * lock_count;\n\t\t}\n\t\tbreak;\n\t}\n\tcase SMB2_IOCTL:\n\t\t*off = le32_to_cpu(((struct smb2_ioctl_req *)hdr)->InputOffset);\n\t\t*len = le32_to_cpu(((struct smb2_ioctl_req *)hdr)->InputCount);\n\t\tbreak;\n\tdefault:\n\t\tksmbd_debug(SMB, \"no length check for command\\n\");\n\t\tbreak;\n\t}\n\n\tif (*off > 4096) {\n\t\tksmbd_debug(SMB, \"offset %d too large\\n\", *off);\n\t\tret = -EINVAL;\n\t} else if ((u64)*off + *len > MAX_STREAM_PROT_LEN) {\n\t\tksmbd_debug(SMB, \"Request is larger than maximum stream protocol length(%u): %llu\\n\",\n\t\t\t    MAX_STREAM_PROT_LEN, (u64)*off + *len);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-22705"
      ],
      "cwe_list": [
        "CWE-125"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/amdgpu/df_v1_7.c",
      "func_name": "df_v1_7_get_hbm_channel_number",
      "func_body": "static u32 df_v1_7_get_hbm_channel_number(struct amdgpu_device *adev)\n{\n\tint fb_channel_number;\n\n\tfb_channel_number = adev->df.funcs->get_fb_channel_number(adev);\n\tif (fb_channel_number >= ARRAY_SIZE(df_v1_7_channel_number))\n\t\tfb_channel_number = 0;\n\n\treturn df_v1_7_channel_number[fb_channel_number];\n}\n",
      "cve_list": [
        "CVE-2024-46724"
      ],
      "cwe_list": [
        "CWE-125"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/bonding/bond_options.c",
      "func_name": "bond_option_arp_ip_targets_set",
      "func_body": "static int bond_option_arp_ip_targets_set(struct bonding *bond,\n\t\t\t\t\t  const struct bond_opt_value *newval)\n{\n\tint ret = -EPERM;\n\t__be32 target;\n\n\tif (newval->string) {\n\t\tif (strlen(newval->string) < 1 ||\n\t\t    !in4_pton(newval->string + 1, -1, (u8 *)&target, -1, NULL)) {\n\t\t\tnetdev_err(bond->dev, \"invalid ARP target specified\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tif (newval->string[0] == '+')\n\t\t\tret = bond_option_arp_ip_target_add(bond, target);\n\t\telse if (newval->string[0] == '-')\n\t\t\tret = bond_option_arp_ip_target_rem(bond, target);\n\t\telse\n\t\t\tnetdev_err(bond->dev, \"no command found in arp_ip_targets file - use +<addr> or -<addr>\\n\");\n\t} else {\n\t\ttarget = newval->value;\n\t\tret = bond_option_arp_ip_target_add(bond, target);\n\t}\n\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-39487"
      ],
      "cwe_list": [
        "CWE-125"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/phy/marvell/phy-mvebu-a3700-comphy.c",
      "func_name": "comphy_gbe_phy_init",
      "func_body": "static void comphy_gbe_phy_init(struct mvebu_a3700_comphy_lane *lane,\n\t\t\t\tbool is_1gbps)\n{\n\tint addr, fix_idx;\n\tu16 val;\n\n\tfix_idx = 0;\n\tfor (addr = 0; addr < 512; addr++) {\n\t\t/*\n\t\t * All PHY register values are defined in full for 3.125Gbps\n\t\t * SERDES speed. The values required for 1.25 Gbps are almost\n\t\t * the same and only few registers should be \"fixed\" in\n\t\t * comparison to 3.125 Gbps values. These register values are\n\t\t * stored in \"gbe_phy_init_fix\" array.\n\t\t */\n\t\tif (!is_1gbps &&\n\t\t    fix_idx < ARRAY_SIZE(gbe_phy_init_fix) &&\n\t\t    gbe_phy_init_fix[fix_idx].addr == addr) {\n\t\t\t/* Use new value */\n\t\t\tval = gbe_phy_init_fix[fix_idx].value;\n\t\t\tfix_idx++;\n\t\t} else {\n\t\t\tval = gbe_phy_init[addr];\n\t\t}\n\n\t\tcomphy_lane_reg_set(lane, addr, val, 0xFFFF);\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-35992"
      ],
      "cwe_list": [
        "CWE-125"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/dma/map_benchmark.c",
      "func_name": "do_map_benchmark",
      "func_body": "static int do_map_benchmark(struct map_benchmark_data *map)\n{\n\tstruct task_struct **tsk;\n\tint threads = map->bparam.threads;\n\tint node = map->bparam.node;\n\tu64 loops;\n\tint ret = 0;\n\tint i;\n\n\ttsk = kmalloc_array(threads, sizeof(*tsk), GFP_KERNEL);\n\tif (!tsk)\n\t\treturn -ENOMEM;\n\n\tget_device(map->dev);\n\n\tfor (i = 0; i < threads; i++) {\n\t\ttsk[i] = kthread_create_on_node(map_benchmark_thread, map,\n\t\t\t\tmap->bparam.node, \"dma-map-benchmark/%d\", i);\n\t\tif (IS_ERR(tsk[i])) {\n\t\t\tpr_err(\"create dma_map thread failed\\n\");\n\t\t\tret = PTR_ERR(tsk[i]);\n\t\t\twhile (--i >= 0)\n\t\t\t\tkthread_stop(tsk[i]);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (node != NUMA_NO_NODE)\n\t\t\tkthread_bind_mask(tsk[i], cpumask_of_node(node));\n\t}\n\n\t/* clear the old value in the previous benchmark */\n\tatomic64_set(&map->sum_map_100ns, 0);\n\tatomic64_set(&map->sum_unmap_100ns, 0);\n\tatomic64_set(&map->sum_sq_map, 0);\n\tatomic64_set(&map->sum_sq_unmap, 0);\n\tatomic64_set(&map->loops, 0);\n\n\tfor (i = 0; i < threads; i++) {\n\t\tget_task_struct(tsk[i]);\n\t\twake_up_process(tsk[i]);\n\t}\n\n\tmsleep_interruptible(map->bparam.seconds * 1000);\n\n\t/* wait for the completion of all started benchmark threads */\n\tfor (i = 0; i < threads; i++) {\n\t\tint kthread_ret = kthread_stop_put(tsk[i]);\n\n\t\tif (kthread_ret)\n\t\t\tret = kthread_ret;\n\t}\n\n\tif (ret)\n\t\tgoto out;\n\n\tloops = atomic64_read(&map->loops);\n\tif (likely(loops > 0)) {\n\t\tu64 map_variance, unmap_variance;\n\t\tu64 sum_map = atomic64_read(&map->sum_map_100ns);\n\t\tu64 sum_unmap = atomic64_read(&map->sum_unmap_100ns);\n\t\tu64 sum_sq_map = atomic64_read(&map->sum_sq_map);\n\t\tu64 sum_sq_unmap = atomic64_read(&map->sum_sq_unmap);\n\n\t\t/* average latency */\n\t\tmap->bparam.avg_map_100ns = div64_u64(sum_map, loops);\n\t\tmap->bparam.avg_unmap_100ns = div64_u64(sum_unmap, loops);\n\n\t\t/* standard deviation of latency */\n\t\tmap_variance = div64_u64(sum_sq_map, loops) -\n\t\t\t\tmap->bparam.avg_map_100ns *\n\t\t\t\tmap->bparam.avg_map_100ns;\n\t\tunmap_variance = div64_u64(sum_sq_unmap, loops) -\n\t\t\t\tmap->bparam.avg_unmap_100ns *\n\t\t\t\tmap->bparam.avg_unmap_100ns;\n\t\tmap->bparam.map_stddev = int_sqrt64(map_variance);\n\t\tmap->bparam.unmap_stddev = int_sqrt64(unmap_variance);\n\t}\n\nout:\n\tput_device(map->dev);\n\tkfree(tsk);\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-39277"
      ],
      "cwe_list": [
        "CWE-125"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/nilfs2/btree.c",
      "func_name": "nilfs_btree_check_delete",
      "func_body": "static int nilfs_btree_check_delete(struct nilfs_bmap *btree, __u64 key)\n{\n\tstruct buffer_head *bh;\n\tstruct nilfs_btree_node *root, *node;\n\t__u64 maxkey, nextmaxkey;\n\t__u64 ptr;\n\tint nchildren, ret;\n\n\troot = nilfs_btree_get_root(btree);\n\tnchildren = nilfs_btree_node_get_nchildren(root);\n\tif (unlikely(nchildren == 0))\n\t\treturn 0;\n\n\tswitch (nilfs_btree_height(btree)) {\n\tcase 2:\n\t\tbh = NULL;\n\t\tnode = root;\n\t\tbreak;\n\tcase 3:\n\t\tif (nchildren > 1)\n\t\t\treturn 0;\n\t\tptr = nilfs_btree_node_get_ptr(root, nchildren - 1,\n\t\t\t\t\t       NILFS_BTREE_ROOT_NCHILDREN_MAX);\n\t\tret = nilfs_btree_get_block(btree, ptr, &bh);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnode = (struct nilfs_btree_node *)bh->b_data;\n\t\tnchildren = nilfs_btree_node_get_nchildren(node);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tmaxkey = nilfs_btree_node_get_key(node, nchildren - 1);\n\tnextmaxkey = (nchildren > 1) ?\n\t\tnilfs_btree_node_get_key(node, nchildren - 2) : 0;\n\tbrelse(bh);\n\n\treturn (maxkey == key) && (nextmaxkey < NILFS_BMAP_LARGE_LOW);\n}\n",
      "cve_list": [
        "CVE-2024-47757"
      ],
      "cwe_list": [
        "CWE-125"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/media/dvb-frontends/tda10048.c",
      "func_name": "tda10048_set_if",
      "func_body": "static int tda10048_set_if(struct dvb_frontend *fe, u32 bw)\n{\n\tstruct tda10048_state *state = fe->demodulator_priv;\n\tstruct tda10048_config *config = &state->config;\n\tint i;\n\tu32 if_freq_khz;\n\tu64 sample_freq;\n\n\tdprintk(1, \"%s(bw = %d)\\n\", __func__, bw);\n\n\t/* based on target bandwidth and clk we calculate pll factors */\n\tswitch (bw) {\n\tcase 6000000:\n\t\tif_freq_khz = config->dtv6_if_freq_khz;\n\t\tbreak;\n\tcase 7000000:\n\t\tif_freq_khz = config->dtv7_if_freq_khz;\n\t\tbreak;\n\tcase 8000000:\n\t\tif_freq_khz = config->dtv8_if_freq_khz;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"%s() no default\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(pll_tab); i++) {\n\t\tif ((pll_tab[i].clk_freq_khz == config->clk_freq_khz) &&\n\t\t\t(pll_tab[i].if_freq_khz == if_freq_khz)) {\n\n\t\t\tstate->freq_if_hz = pll_tab[i].if_freq_khz * 1000;\n\t\t\tstate->xtal_hz = pll_tab[i].clk_freq_khz * 1000;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == ARRAY_SIZE(pll_tab)) {\n\t\tprintk(KERN_ERR \"%s() Incorrect attach settings\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdprintk(1, \"- freq_if_hz = %d\\n\", state->freq_if_hz);\n\tdprintk(1, \"- xtal_hz = %d\\n\", state->xtal_hz);\n\tdprintk(1, \"- pll_mfactor = %d\\n\", state->pll_mfactor);\n\tdprintk(1, \"- pll_nfactor = %d\\n\", state->pll_nfactor);\n\tdprintk(1, \"- pll_pfactor = %d\\n\", state->pll_pfactor);\n\n\t/* Calculate the sample frequency */\n\tsample_freq = state->xtal_hz;\n\tsample_freq *= state->pll_mfactor + 45;\n\tdo_div(sample_freq, state->pll_nfactor + 1);\n\tdo_div(sample_freq, state->pll_pfactor + 4);\n\tstate->sample_freq = sample_freq;\n\tdprintk(1, \"- sample_freq = %d\\n\", state->sample_freq);\n\n\t/* Update the I/F */\n\ttda10048_set_phy2(fe, state->sample_freq, state->freq_if_hz);\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-42223"
      ],
      "cwe_list": [
        "CWE-190"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/workqueue.c",
      "func_name": "shift_and_mask",
      "func_body": "static unsigned long shift_and_mask(unsigned long v, u32 shift, u32 bits)\n{\n\treturn (v >> shift) & ((1U << bits) - 1);\n}\n",
      "cve_list": [
        "CVE-2024-44981"
      ],
      "cwe_list": [
        "CWE-190"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/xe/xe_ttm_vram_mgr.c",
      "func_name": "xe_ttm_vram_mgr_new",
      "func_body": "static int xe_ttm_vram_mgr_new(struct ttm_resource_manager *man,\n\t\t\t       struct ttm_buffer_object *tbo,\n\t\t\t       const struct ttm_place *place,\n\t\t\t       struct ttm_resource **res)\n{\n\tstruct xe_ttm_vram_mgr *mgr = to_xe_ttm_vram_mgr(man);\n\tstruct xe_ttm_vram_mgr_resource *vres;\n\tstruct drm_buddy *mm = &mgr->mm;\n\tu64 size, remaining_size, min_page_size;\n\tunsigned long lpfn;\n\tint err;\n\n\tlpfn = place->lpfn;\n\tif (!lpfn || lpfn > man->size >> PAGE_SHIFT)\n\t\tlpfn = man->size >> PAGE_SHIFT;\n\n\tif (tbo->base.size >> PAGE_SHIFT > (lpfn - place->fpfn))\n\t\treturn -E2BIG; /* don't trigger eviction for the impossible */\n\n\tvres = kzalloc(sizeof(*vres), GFP_KERNEL);\n\tif (!vres)\n\t\treturn -ENOMEM;\n\n\tttm_resource_init(tbo, place, &vres->base);\n\n\t/* bail out quickly if there's likely not enough VRAM for this BO */\n\tif (ttm_resource_manager_usage(man) > man->size) {\n\t\terr = -ENOSPC;\n\t\tgoto error_fini;\n\t}\n\n\tINIT_LIST_HEAD(&vres->blocks);\n\n\tif (place->flags & TTM_PL_FLAG_TOPDOWN)\n\t\tvres->flags |= DRM_BUDDY_TOPDOWN_ALLOCATION;\n\n\tif (place->fpfn || lpfn != man->size >> PAGE_SHIFT)\n\t\tvres->flags |= DRM_BUDDY_RANGE_ALLOCATION;\n\n\tif (WARN_ON(!vres->base.size)) {\n\t\terr = -EINVAL;\n\t\tgoto error_fini;\n\t}\n\tsize = vres->base.size;\n\n\tmin_page_size = mgr->default_page_size;\n\tif (tbo->page_alignment)\n\t\tmin_page_size = (u64)tbo->page_alignment << PAGE_SHIFT;\n\n\tif (WARN_ON(min_page_size < mm->chunk_size)) {\n\t\terr = -EINVAL;\n\t\tgoto error_fini;\n\t}\n\n\tif (WARN_ON(min_page_size > SZ_2G)) { /* FIXME: sg limit */\n\t\terr = -EINVAL;\n\t\tgoto error_fini;\n\t}\n\n\tif (WARN_ON((size > SZ_2G &&\n\t\t     (vres->base.placement & TTM_PL_FLAG_CONTIGUOUS)))) {\n\t\terr = -EINVAL;\n\t\tgoto error_fini;\n\t}\n\n\tif (WARN_ON(!IS_ALIGNED(size, min_page_size))) {\n\t\terr = -EINVAL;\n\t\tgoto error_fini;\n\t}\n\n\tmutex_lock(&mgr->lock);\n\tif (lpfn <= mgr->visible_size >> PAGE_SHIFT && size > mgr->visible_avail) {\n\t\tmutex_unlock(&mgr->lock);\n\t\terr = -ENOSPC;\n\t\tgoto error_fini;\n\t}\n\n\tif (place->fpfn + (size >> PAGE_SHIFT) != place->lpfn &&\n\t    place->flags & TTM_PL_FLAG_CONTIGUOUS) {\n\t\tsize = roundup_pow_of_two(size);\n\t\tmin_page_size = size;\n\n\t\tlpfn = max_t(unsigned long, place->fpfn + (size >> PAGE_SHIFT), lpfn);\n\t}\n\n\tremaining_size = size;\n\tdo {\n\t\t/*\n\t\t * Limit maximum size to 2GiB due to SG table limitations.\n\t\t * FIXME: Should maybe be handled as part of sg construction.\n\t\t */\n\t\tu64 alloc_size = min_t(u64, remaining_size, SZ_2G);\n\n\t\terr = drm_buddy_alloc_blocks(mm, (u64)place->fpfn << PAGE_SHIFT,\n\t\t\t\t\t     (u64)lpfn << PAGE_SHIFT,\n\t\t\t\t\t     alloc_size,\n\t\t\t\t\t     min_page_size,\n\t\t\t\t\t     &vres->blocks,\n\t\t\t\t\t     vres->flags);\n\t\tif (err)\n\t\t\tgoto error_free_blocks;\n\n\t\tremaining_size -= alloc_size;\n\t} while (remaining_size);\n\n\tif (place->flags & TTM_PL_FLAG_CONTIGUOUS) {\n\t\tif (!drm_buddy_block_trim(mm, vres->base.size, &vres->blocks))\n\t\t\tsize = vres->base.size;\n\t}\n\n\tif (lpfn <= mgr->visible_size >> PAGE_SHIFT) {\n\t\tvres->used_visible_size = size;\n\t} else {\n\t\tstruct drm_buddy_block *block;\n\n\t\tlist_for_each_entry(block, &vres->blocks, link) {\n\t\t\tu64 start = drm_buddy_block_offset(block);\n\n\t\t\tif (start < mgr->visible_size) {\n\t\t\t\tu64 end = start + drm_buddy_block_size(mm, block);\n\n\t\t\t\tvres->used_visible_size +=\n\t\t\t\t\tmin(end, mgr->visible_size) - start;\n\t\t\t}\n\t\t}\n\t}\n\n\tmgr->visible_avail -= vres->used_visible_size;\n\tmutex_unlock(&mgr->lock);\n\n\tif (!(vres->base.placement & TTM_PL_FLAG_CONTIGUOUS) &&\n\t    xe_is_vram_mgr_blocks_contiguous(mm, &vres->blocks))\n\t\tvres->base.placement |= TTM_PL_FLAG_CONTIGUOUS;\n\n\t/*\n\t * For some kernel objects we still rely on the start when io mapping\n\t * the object.\n\t */\n\tif (vres->base.placement & TTM_PL_FLAG_CONTIGUOUS) {\n\t\tstruct drm_buddy_block *block = list_first_entry(&vres->blocks,\n\t\t\t\t\t\t\t\t typeof(*block),\n\t\t\t\t\t\t\t\t link);\n\n\t\tvres->base.start = drm_buddy_block_offset(block) >> PAGE_SHIFT;\n\t} else {\n\t\tvres->base.start = XE_BO_INVALID_OFFSET;\n\t}\n\n\t*res = &vres->base;\n\treturn 0;\n\nerror_free_blocks:\n\tdrm_buddy_free_list(mm, &vres->blocks);\n\tmutex_unlock(&mgr->lock);\nerror_fini:\n\tttm_resource_fini(man, &vres->base);\n\tkfree(vres);\n\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-42066"
      ],
      "cwe_list": [
        "CWE-190"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/ptp/ptp_sysfs.c",
      "func_name": "max_vclocks_store",
      "func_body": "static ssize_t max_vclocks_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct ptp_clock *ptp = dev_get_drvdata(dev);\n\tunsigned int *vclock_index;\n\tint err = -EINVAL;\n\tsize_t size;\n\tu32 max;\n\n\tif (kstrtou32(buf, 0, &max) || max == 0)\n\t\treturn -EINVAL;\n\n\tif (max == ptp->max_vclocks)\n\t\treturn count;\n\n\tif (mutex_lock_interruptible(&ptp->n_vclocks_mux))\n\t\treturn -ERESTARTSYS;\n\n\tif (max < ptp->n_vclocks)\n\t\tgoto out;\n\n\tvclock_index = kcalloc(max, sizeof(int), GFP_KERNEL);\n\tif (!vclock_index) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsize = sizeof(int) * ptp->n_vclocks;\n\tmemcpy(vclock_index, ptp->vclock_index, size);\n\n\tkfree(ptp->vclock_index);\n\tptp->vclock_index = vclock_index;\n\tptp->max_vclocks = max;\n\n\tmutex_unlock(&ptp->n_vclocks_mux);\n\n\treturn count;\nout:\n\tmutex_unlock(&ptp->n_vclocks_mux);\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-40994"
      ],
      "cwe_list": [
        "CWE-190"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/dc/dml/calcs/dcn_calcs.c",
      "func_name": "dcn_bw_update_from_pplib_fclks",
      "func_body": "void dcn_bw_update_from_pplib_fclks(\n\tstruct dc *dc,\n\tstruct dm_pp_clock_levels_with_voltage *fclks)\n{\n\tunsigned vmin0p65_idx, vmid0p72_idx, vnom0p8_idx, vmax0p9_idx;\n\n\tASSERT(fclks->num_levels);\n\n\tvmin0p65_idx = 0;\n\tvmid0p72_idx = fclks->num_levels > 2 ? fclks->num_levels - 3 : 0;\n\tvnom0p8_idx = fclks->num_levels > 1 ? fclks->num_levels - 2 : 0;\n\tvmax0p9_idx = fclks->num_levels > 0 ? fclks->num_levels - 1 : 0;\n\n\tdc->dcn_soc->fabric_and_dram_bandwidth_vmin0p65 =\n\t\t32 * (fclks->data[vmin0p65_idx].clocks_in_khz / 1000.0) / 1000.0;\n\tdc->dcn_soc->fabric_and_dram_bandwidth_vmid0p72 =\n\t\tdc->dcn_soc->number_of_channels *\n\t\t(fclks->data[vmid0p72_idx].clocks_in_khz / 1000.0)\n\t\t* ddr4_dram_factor_single_Channel / 1000.0;\n\tdc->dcn_soc->fabric_and_dram_bandwidth_vnom0p8 =\n\t\tdc->dcn_soc->number_of_channels *\n\t\t(fclks->data[vnom0p8_idx].clocks_in_khz / 1000.0)\n\t\t* ddr4_dram_factor_single_Channel / 1000.0;\n\tdc->dcn_soc->fabric_and_dram_bandwidth_vmax0p9 =\n\t\tdc->dcn_soc->number_of_channels *\n\t\t(fclks->data[vmax0p9_idx].clocks_in_khz / 1000.0)\n\t\t* ddr4_dram_factor_single_Channel / 1000.0;\n}\n",
      "cve_list": [
        "CVE-2024-46726"
      ],
      "cwe_list": [
        "CWE-190"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/padata.c",
      "func_name": "padata_do_serial",
      "func_body": "void padata_do_serial(struct padata_priv *padata)\n{\n\tstruct parallel_data *pd = padata->pd;\n\tint hashed_cpu = padata_cpu_hash(pd, padata->seq_nr);\n\tstruct padata_list *reorder = per_cpu_ptr(pd->reorder_list, hashed_cpu);\n\tstruct padata_priv *cur;\n\tstruct list_head *pos;\n\n\tspin_lock(&reorder->lock);\n\t/* Sort in ascending order of sequence number. */\n\tlist_for_each_prev(pos, &reorder->list) {\n\t\tcur = list_entry(pos, struct padata_priv, list);\n\t\t/* Compare by difference to consider integer wrap around */\n\t\tif ((signed int)(cur->seq_nr - padata->seq_nr) < 0)\n\t\t\tbreak;\n\t}\n\tlist_add(&padata->list, pos);\n\tspin_unlock(&reorder->lock);\n\n\t/*\n\t * Ensure the addition to the reorder list is ordered correctly\n\t * with the trylock of pd->lock in padata_reorder.  Pairs with smp_mb\n\t * in padata_reorder.\n\t */\n\tsmp_mb();\n\n\tpadata_reorder(pd);\n}\n",
      "cve_list": [
        "CVE-2024-47739"
      ],
      "cwe_list": [
        "CWE-190"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/bluetooth/hci_conn.c",
      "func_name": "hci_conn_add",
      "func_body": "struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst,\n\t\t\t      u8 role, u16 handle)\n{\n\tstruct hci_conn *conn;\n\n\tswitch (type) {\n\tcase ACL_LINK:\n\t\tif (!hdev->acl_mtu)\n\t\t\treturn ERR_PTR(-ECONNREFUSED);\n\t\tbreak;\n\tcase ISO_LINK:\n\t\tif (hdev->iso_mtu)\n\t\t\t/* Dedicated ISO Buffer exists */\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase LE_LINK:\n\t\tif (hdev->le_mtu && hdev->le_mtu < HCI_MIN_LE_MTU)\n\t\t\treturn ERR_PTR(-ECONNREFUSED);\n\t\tif (!hdev->le_mtu && hdev->acl_mtu < HCI_MIN_LE_MTU)\n\t\t\treturn ERR_PTR(-ECONNREFUSED);\n\t\tbreak;\n\tcase SCO_LINK:\n\tcase ESCO_LINK:\n\t\tif (!hdev->sco_pkts)\n\t\t\t/* Controller does not support SCO or eSCO over HCI */\n\t\t\treturn ERR_PTR(-ECONNREFUSED);\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-ECONNREFUSED);\n\t}\n\n\tbt_dev_dbg(hdev, \"dst %pMR handle 0x%4.4x\", dst, handle);\n\n\tconn = kzalloc(sizeof(*conn), GFP_KERNEL);\n\tif (!conn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tbacpy(&conn->dst, dst);\n\tbacpy(&conn->src, &hdev->bdaddr);\n\tconn->handle = handle;\n\tconn->hdev  = hdev;\n\tconn->type  = type;\n\tconn->role  = role;\n\tconn->mode  = HCI_CM_ACTIVE;\n\tconn->state = BT_OPEN;\n\tconn->auth_type = HCI_AT_GENERAL_BONDING;\n\tconn->io_capability = hdev->io_capability;\n\tconn->remote_auth = 0xff;\n\tconn->key_type = 0xff;\n\tconn->rssi = HCI_RSSI_INVALID;\n\tconn->tx_power = HCI_TX_POWER_INVALID;\n\tconn->max_tx_power = HCI_TX_POWER_INVALID;\n\tconn->sync_handle = HCI_SYNC_HANDLE_INVALID;\n\n\tset_bit(HCI_CONN_POWER_SAVE, &conn->flags);\n\tconn->disc_timeout = HCI_DISCONN_TIMEOUT;\n\n\t/* Set Default Authenticated payload timeout to 30s */\n\tconn->auth_payload_timeout = DEFAULT_AUTH_PAYLOAD_TIMEOUT;\n\n\tif (conn->role == HCI_ROLE_MASTER)\n\t\tconn->out = true;\n\n\tswitch (type) {\n\tcase ACL_LINK:\n\t\tconn->pkt_type = hdev->pkt_type & ACL_PTYPE_MASK;\n\t\tconn->mtu = hdev->acl_mtu;\n\t\tbreak;\n\tcase LE_LINK:\n\t\t/* conn->src should reflect the local identity address */\n\t\thci_copy_identity_address(hdev, &conn->src, &conn->src_type);\n\t\tconn->mtu = hdev->le_mtu ? hdev->le_mtu : hdev->acl_mtu;\n\t\tbreak;\n\tcase ISO_LINK:\n\t\t/* conn->src should reflect the local identity address */\n\t\thci_copy_identity_address(hdev, &conn->src, &conn->src_type);\n\n\t\t/* set proper cleanup function */\n\t\tif (!bacmp(dst, BDADDR_ANY))\n\t\t\tconn->cleanup = bis_cleanup;\n\t\telse if (conn->role == HCI_ROLE_MASTER)\n\t\t\tconn->cleanup = cis_cleanup;\n\n\t\tconn->mtu = hdev->iso_mtu ? hdev->iso_mtu :\n\t\t\t    hdev->le_mtu ? hdev->le_mtu : hdev->acl_mtu;\n\t\tbreak;\n\tcase SCO_LINK:\n\t\tif (lmp_esco_capable(hdev))\n\t\t\tconn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |\n\t\t\t\t\t(hdev->esco_type & EDR_ESCO_MASK);\n\t\telse\n\t\t\tconn->pkt_type = hdev->pkt_type & SCO_PTYPE_MASK;\n\n\t\tconn->mtu = hdev->sco_mtu;\n\t\tbreak;\n\tcase ESCO_LINK:\n\t\tconn->pkt_type = hdev->esco_type & ~EDR_ESCO_MASK;\n\t\tconn->mtu = hdev->sco_mtu;\n\t\tbreak;\n\t}\n\n\tskb_queue_head_init(&conn->data_q);\n\n\tINIT_LIST_HEAD(&conn->chan_list);\n\tINIT_LIST_HEAD(&conn->link_list);\n\n\tINIT_DELAYED_WORK(&conn->disc_work, hci_conn_timeout);\n\tINIT_DELAYED_WORK(&conn->auto_accept_work, hci_conn_auto_accept);\n\tINIT_DELAYED_WORK(&conn->idle_work, hci_conn_idle);\n\tINIT_DELAYED_WORK(&conn->le_conn_timeout, le_conn_timeout);\n\n\tatomic_set(&conn->refcnt, 0);\n\n\thci_dev_hold(hdev);\n\n\thci_conn_hash_add(hdev, conn);\n\n\t/* The SCO and eSCO connections will only be notified when their\n\t * setup has been completed. This is different to ACL links which\n\t * can be notified right away.\n\t */\n\tif (conn->type != SCO_LINK && conn->type != ESCO_LINK) {\n\t\tif (hdev->notify)\n\t\t\thdev->notify(hdev, HCI_NOTIFY_CONN_ADD);\n\t}\n\n\thci_conn_init_sysfs(conn);\n\n\treturn conn;\n}\n",
      "cve_list": [
        "CVE-2024-36968"
      ],
      "cwe_list": [
        "CWE-190"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/bluetooth/iso.c",
      "func_name": "iso_sock_sendmsg",
      "func_body": "static int iso_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb, **frag;\n\tsize_t mtu;\n\tint err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_CONNECTED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\n\tmtu = iso_pi(sk)->conn->hcon->mtu;\n\n\trelease_sock(sk);\n\n\tskb = bt_skb_sendmsg(sk, msg, len, mtu, HCI_ISO_DATA_HDR_SIZE, 0);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tlen -= skb->len;\n\n\tBT_DBG(\"skb %p len %d\", sk, skb->len);\n\n\t/* Continuation fragments */\n\tfrag = &skb_shinfo(skb)->frag_list;\n\twhile (len) {\n\t\tstruct sk_buff *tmp;\n\n\t\ttmp = bt_skb_sendmsg(sk, msg, len, mtu, 0, 0);\n\t\tif (IS_ERR(tmp)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn PTR_ERR(tmp);\n\t\t}\n\n\t\t*frag = tmp;\n\n\t\tlen  -= tmp->len;\n\n\t\tskb->len += tmp->len;\n\t\tskb->data_len += tmp->len;\n\n\t\tBT_DBG(\"frag %p len %d\", *frag, tmp->len);\n\n\t\tfrag = &(*frag)->next;\n\t}\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = iso_send_frame(sk, skb);\n\telse\n\t\terr = -ENOTCONN;\n\n\trelease_sock(sk);\n\n\tif (err < 0)\n\t\tkfree_skb(skb);\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-36968"
      ],
      "cwe_list": [
        "CWE-190"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/bluetooth/sco.c",
      "func_name": "sco_conn_add",
      "func_body": "static struct sco_conn *sco_conn_add(struct hci_conn *hcon)\n{\n\tstruct sco_conn *conn = hcon->sco_data;\n\n\tif (conn) {\n\t\tif (!conn->hcon)\n\t\t\tconn->hcon = hcon;\n\t\treturn conn;\n\t}\n\n\tconn = kzalloc(sizeof(struct sco_conn), GFP_KERNEL);\n\tif (!conn)\n\t\treturn NULL;\n\n\tspin_lock_init(&conn->lock);\n\tINIT_DELAYED_WORK(&conn->timeout_work, sco_sock_timeout);\n\n\thcon->sco_data = conn;\n\tconn->hcon = hcon;\n\tconn->mtu = hcon->mtu;\n\n\tif (hcon->mtu > 0)\n\t\tconn->mtu = hcon->mtu;\n\telse\n\t\tconn->mtu = 60;\n\n\tBT_DBG(\"hcon %p conn %p\", hcon, conn);\n\n\treturn conn;\n}\n",
      "cve_list": [
        "CVE-2024-36968"
      ],
      "cwe_list": [
        "CWE-190"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/trace/tracing_map.c",
      "func_name": "get_free_elt",
      "func_body": "static struct tracing_map_elt *get_free_elt(struct tracing_map *map)\n{\n\tstruct tracing_map_elt *elt = NULL;\n\tint idx;\n\n\tidx = atomic_fetch_add_unless(&map->next_elt, 1, map->max_elts);\n\tif (idx < map->max_elts) {\n\t\telt = *(TRACING_MAP_ELT(map->elts, idx));\n\t\tif (map->ops && map->ops->elt_init)\n\t\t\tmap->ops->elt_init(elt);\n\t}\n\n\treturn elt;\n}\n",
      "cve_list": [
        "CVE-2024-43890"
      ],
      "cwe_list": [
        "CWE-190"
      ]
    },
    {
      "project": "linux",
      "filepath": "block/ioctl.c",
      "func_name": "blkpg_do_ioctl",
      "func_body": "static int blkpg_do_ioctl(struct block_device *bdev,\n\t\t\t  struct blkpg_partition __user *upart, int op)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct blkpg_partition p;\n\tsector_t start, length, capacity, end;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\tif (copy_from_user(&p, upart, sizeof(struct blkpg_partition)))\n\t\treturn -EFAULT;\n\tif (bdev_is_partition(bdev))\n\t\treturn -EINVAL;\n\n\tif (p.pno <= 0)\n\t\treturn -EINVAL;\n\n\tif (op == BLKPG_DEL_PARTITION)\n\t\treturn bdev_del_partition(disk, p.pno);\n\n\tif (p.start < 0 || p.length <= 0 || LLONG_MAX - p.length < p.start)\n\t\treturn -EINVAL;\n\t/* Check that the partition is aligned to the block size */\n\tif (!IS_ALIGNED(p.start | p.length, bdev_logical_block_size(bdev)))\n\t\treturn -EINVAL;\n\n\tstart = p.start >> SECTOR_SHIFT;\n\tlength = p.length >> SECTOR_SHIFT;\n\tcapacity = get_capacity(disk);\n\n\tif (check_add_overflow(start, length, &end))\n\t\treturn -EINVAL;\n\n\tif (start >= capacity || end > capacity)\n\t\treturn -EINVAL;\n\n\tswitch (op) {\n\tcase BLKPG_ADD_PARTITION:\n\t\treturn bdev_add_partition(disk, p.pno, start, length);\n\tcase BLKPG_RESIZE_PARTITION:\n\t\treturn bdev_resize_partition(disk, p.pno, start, length);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-41000"
      ],
      "cwe_list": [
        "CWE-190"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/s390/crypto/ap_bus.c",
      "func_name": "modify_bitmap",
      "func_body": "static int modify_bitmap(const char *str, unsigned long *bitmap, int bits)\n{\n\tunsigned long a, i, z;\n\tchar *np, sign;\n\n\t/* bits needs to be a multiple of 8 */\n\tif (bits & 0x07)\n\t\treturn -EINVAL;\n\n\twhile (*str) {\n\t\tsign = *str++;\n\t\tif (sign != '+' && sign != '-')\n\t\t\treturn -EINVAL;\n\t\ta = z = simple_strtoul(str, &np, 0);\n\t\tif (str == np || a >= bits)\n\t\t\treturn -EINVAL;\n\t\tstr = np;\n\t\tif (*str == '-') {\n\t\t\tz = simple_strtoul(++str, &np, 0);\n\t\t\tif (str == np || a > z || z >= bits)\n\t\t\t\treturn -EINVAL;\n\t\t\tstr = np;\n\t\t}\n\t\tfor (i = a; i <= z; i++)\n\t\t\tif (sign == '+')\n\t\t\t\tset_bit_inv(i, bitmap);\n\t\t\telse\n\t\t\t\tclear_bit_inv(i, bitmap);\n\t\twhile (*str == ',' || *str == '\\n')\n\t\t\tstr++;\n\t}\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-38661"
      ],
      "cwe_list": [
        "CWE-190"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/dc/dce/dmub_abm_lcd.c",
      "func_name": "dmub_abm_set_pipe",
      "func_body": "bool dmub_abm_set_pipe(struct abm *abm,\n\t\tuint32_t otg_inst,\n\t\tuint32_t option,\n\t\tuint32_t panel_inst,\n\t\tuint32_t pwrseq_inst)\n{\n\tunion dmub_rb_cmd cmd;\n\tstruct dc_context *dc = abm->ctx;\n\tuint8_t ramping_boundary = 0xFF;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.abm_set_pipe.header.type = DMUB_CMD__ABM;\n\tcmd.abm_set_pipe.header.sub_type = DMUB_CMD__ABM_SET_PIPE;\n\tcmd.abm_set_pipe.abm_set_pipe_data.otg_inst = otg_inst;\n\tcmd.abm_set_pipe.abm_set_pipe_data.pwrseq_inst = pwrseq_inst;\n\tcmd.abm_set_pipe.abm_set_pipe_data.set_pipe_option = option;\n\tcmd.abm_set_pipe.abm_set_pipe_data.panel_inst = panel_inst;\n\tcmd.abm_set_pipe.abm_set_pipe_data.ramping_boundary = ramping_boundary;\n\tcmd.abm_set_pipe.header.payload_bytes = sizeof(struct dmub_cmd_abm_set_pipe_data);\n\n\tdc_wake_and_execute_dmub_cmd(dc, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\treturn true;\n}\n",
      "cve_list": [
        "CVE-2024-47661"
      ],
      "cwe_list": [
        "CWE-190"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/dc/hwss/dcn21/dcn21_hwseq.c",
      "func_name": "dmub_abm_set_pipe",
      "func_body": "static bool dmub_abm_set_pipe(struct abm *abm, uint32_t otg_inst,\n\t\tuint32_t option, uint32_t panel_inst, uint32_t pwrseq_inst)\n{\n\tunion dmub_rb_cmd cmd;\n\tstruct dc_context *dc = abm->ctx;\n\tuint8_t ramping_boundary = 0xFF;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.abm_set_pipe.header.type = DMUB_CMD__ABM;\n\tcmd.abm_set_pipe.header.sub_type = DMUB_CMD__ABM_SET_PIPE;\n\tcmd.abm_set_pipe.abm_set_pipe_data.otg_inst = otg_inst;\n\tcmd.abm_set_pipe.abm_set_pipe_data.pwrseq_inst = pwrseq_inst;\n\tcmd.abm_set_pipe.abm_set_pipe_data.set_pipe_option = option;\n\tcmd.abm_set_pipe.abm_set_pipe_data.panel_inst = panel_inst;\n\tcmd.abm_set_pipe.abm_set_pipe_data.ramping_boundary = ramping_boundary;\n\tcmd.abm_set_pipe.header.payload_bytes = sizeof(struct dmub_cmd_abm_set_pipe_data);\n\n\tdc_wake_and_execute_dmub_cmd(dc, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\treturn true;\n}\n",
      "cve_list": [
        "CVE-2024-47661"
      ],
      "cwe_list": [
        "CWE-190"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/cdrom/cdrom.c",
      "func_name": "cdrom_ioctl_timed_media_change",
      "func_body": "static int cdrom_ioctl_timed_media_change(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tint ret;\n\tstruct cdrom_timed_media_change_info __user *info;\n\tstruct cdrom_timed_media_change_info tmp_info;\n\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn -ENOSYS;\n\n\tinfo = (struct cdrom_timed_media_change_info __user *)arg;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_TIMED_MEDIA_CHANGE\\n\");\n\n\tret = cdrom_ioctl_media_changed(cdi, CDSL_CURRENT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (copy_from_user(&tmp_info, info, sizeof(tmp_info)) != 0)\n\t\treturn -EFAULT;\n\n\ttmp_info.media_flags = 0;\n\tif (cdi->last_media_change_ms > tmp_info.last_media_change)\n\t\ttmp_info.media_flags |= MEDIA_CHANGED_FLAG;\n\n\ttmp_info.last_media_change = cdi->last_media_change_ms;\n\n\tif (copy_to_user(info, &tmp_info, sizeof(*info)) != 0)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-42136"
      ],
      "cwe_list": [
        "CWE-190"
      ]
    },
    {
      "project": "linux",
      "filepath": "sound/usb/line6/driver.c",
      "func_name": "line6_data_received",
      "func_body": "static void line6_data_received(struct urb *urb)\n{\n\tstruct usb_line6 *line6 = (struct usb_line6 *)urb->context;\n\tstruct midi_buffer *mb = &line6->line6midi->midibuf_in;\n\tunsigned long flags;\n\tint done;\n\n\tif (urb->status == -ESHUTDOWN)\n\t\treturn;\n\n\tif (line6->properties->capabilities & LINE6_CAP_CONTROL_MIDI) {\n\t\tspin_lock_irqsave(&line6->line6midi->lock, flags);\n\t\tdone =\n\t\t\tline6_midibuf_write(mb, urb->transfer_buffer, urb->actual_length);\n\n\t\tif (done < urb->actual_length) {\n\t\t\tline6_midibuf_ignore(mb, done);\n\t\t\tdev_dbg(line6->ifcdev, \"%d %d buffer overflow - message skipped\\n\",\n\t\t\t\tdone, urb->actual_length);\n\t\t}\n\t\tspin_unlock_irqrestore(&line6->line6midi->lock, flags);\n\n\t\tfor (;;) {\n\t\t\tspin_lock_irqsave(&line6->line6midi->lock, flags);\n\t\t\tdone =\n\t\t\t\tline6_midibuf_read(mb, line6->buffer_message,\n\t\t\t\t\t\t   LINE6_MIDI_MESSAGE_MAXLEN,\n\t\t\t\t\t\t   LINE6_MIDIBUF_READ_RX);\n\t\t\tspin_unlock_irqrestore(&line6->line6midi->lock, flags);\n\n\t\t\tif (done <= 0)\n\t\t\t\tbreak;\n\n\t\t\tline6->message_length = done;\n\t\t\tline6_midi_receive(line6, line6->buffer_message, done);\n\n\t\t\tif (line6->process_message)\n\t\t\t\tline6->process_message(line6);\n\t\t}\n\t} else {\n\t\tline6->buffer_message = urb->transfer_buffer;\n\t\tline6->message_length = urb->actual_length;\n\t\tif (line6->process_message)\n\t\t\tline6->process_message(line6);\n\t\tline6->buffer_message = NULL;\n\t}\n\n\tline6_start_listen(line6);\n}\n",
      "cve_list": [
        "CVE-2024-44954"
      ],
      "cwe_list": [
        "CWE-362"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/notify/fsnotify.c",
      "func_name": "__fsnotify_parent",
      "func_body": "int __fsnotify_parent(struct dentry *dentry, __u32 mask, const void *data,\n\t\t      int data_type)\n{\n\tconst struct path *path = fsnotify_data_path(data, data_type);\n\t__u32 mnt_mask = path ? real_mount(path->mnt)->mnt_fsnotify_mask : 0;\n\tstruct inode *inode = d_inode(dentry);\n\tstruct dentry *parent;\n\tbool parent_watched = dentry->d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED;\n\tbool parent_needed, parent_interested;\n\t__u32 p_mask;\n\tstruct inode *p_inode = NULL;\n\tstruct name_snapshot name;\n\tstruct qstr *file_name = NULL;\n\tint ret = 0;\n\n\t/* Optimize the likely case of nobody watching this path */\n\tif (likely(!parent_watched &&\n\t\t   !fsnotify_object_watched(inode, mnt_mask, mask)))\n\t\treturn 0;\n\n\tparent = NULL;\n\tparent_needed = fsnotify_event_needs_parent(inode, mnt_mask, mask);\n\tif (!parent_watched && !parent_needed)\n\t\tgoto notify;\n\n\t/* Does parent inode care about events on children? */\n\tparent = dget_parent(dentry);\n\tp_inode = parent->d_inode;\n\tp_mask = fsnotify_inode_watches_children(p_inode);\n\tif (unlikely(parent_watched && !p_mask))\n\t\tfsnotify_clear_child_dentry_flag(p_inode, dentry);\n\n\t/*\n\t * Include parent/name in notification either if some notification\n\t * groups require parent info or the parent is interested in this event.\n\t */\n\tparent_interested = mask & p_mask & ALL_FSNOTIFY_EVENTS;\n\tif (parent_needed || parent_interested) {\n\t\t/* When notifying parent, child should be passed as data */\n\t\tWARN_ON_ONCE(inode != fsnotify_data_inode(data, data_type));\n\n\t\t/* Notify both parent and child with child name info */\n\t\ttake_dentry_name_snapshot(&name, dentry);\n\t\tfile_name = &name.name;\n\t\tif (parent_interested)\n\t\t\tmask |= FS_EVENT_ON_CHILD;\n\t}\n\nnotify:\n\tret = fsnotify(mask, data, data_type, p_inode, file_name, inode, 0);\n\n\tif (file_name)\n\t\trelease_dentry_name_snapshot(&name);\n\tdput(parent);\n\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-47660"
      ],
      "cwe_list": [
        "CWE-362"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/notify/mark.c",
      "func_name": "fsnotify_recalc_mask",
      "func_body": "void fsnotify_recalc_mask(struct fsnotify_mark_connector *conn)\n{\n\tbool update_children;\n\n\tif (!conn)\n\t\treturn;\n\n\tspin_lock(&conn->lock);\n\tupdate_children = !fsnotify_conn_watches_children(conn);\n\t__fsnotify_recalc_mask(conn);\n\tupdate_children &= fsnotify_conn_watches_children(conn);\n\tspin_unlock(&conn->lock);\n\t/*\n\t * Set children's PARENT_WATCHED flags only if parent started watching.\n\t * When parent stops watching, we clear false positive PARENT_WATCHED\n\t * flags lazily in __fsnotify_parent().\n\t */\n\tif (update_children)\n\t\tfsnotify_conn_set_children_dentry_flags(conn);\n}\n",
      "cve_list": [
        "CVE-2024-47660"
      ],
      "cwe_list": [
        "CWE-362"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/phy/qcom/at803x.c",
      "func_name": "at8031_probe",
      "func_body": "static int at8031_probe(struct phy_device *phydev)\n{\n\tstruct at803x_priv *priv;\n\tint mode_cfg;\n\tint ccr;\n\tint ret;\n\n\tret = at803x_probe(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv = phydev->priv;\n\n\t/* Only supported on AR8031/AR8033, the AR8030/AR8035 use strapping\n\t * options.\n\t */\n\tret = at8031_parse_dt(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tccr = phy_read(phydev, AT803X_REG_CHIP_CONFIG);\n\tif (ccr < 0)\n\t\treturn ccr;\n\tmode_cfg = ccr & AT803X_MODE_CFG_MASK;\n\n\tswitch (mode_cfg) {\n\tcase AT803X_MODE_CFG_BX1000_RGMII_50OHM:\n\tcase AT803X_MODE_CFG_BX1000_RGMII_75OHM:\n\t\tpriv->is_1000basex = true;\n\t\tfallthrough;\n\tcase AT803X_MODE_CFG_FX100_RGMII_50OHM:\n\tcase AT803X_MODE_CFG_FX100_RGMII_75OHM:\n\t\tpriv->is_fiber = true;\n\t\tbreak;\n\t}\n\n\t/* Disable WoL in 1588 register which is enabled\n\t * by default\n\t */\n\treturn phy_modify_mmd(phydev, MDIO_MMD_PCS,\n\t\t\t      AT803X_PHY_MMD3_WOL_CTRL,\n\t\t\t      AT803X_WOL_EN, 0);\n}\n",
      "cve_list": [
        "CVE-2024-26942"
      ],
      "cwe_list": [
        "CWE-476",
        "CWE-362"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/inode.c",
      "func_name": "evict_inodes",
      "func_body": "void evict_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\nagain:\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tif (atomic_read(&inode->i_count))\n\t\t\tcontinue;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (atomic_read(&inode->i_count)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\n\t\t/*\n\t\t * We can have a ton of inodes to evict at unmount time given\n\t\t * enough memory, check to see if we need to go to sleep for a\n\t\t * bit so we don't livelock.\n\t\t */\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&sb->s_inode_list_lock);\n\t\t\tcond_resched();\n\t\t\tdispose_list(&dispose);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n\n\tdispose_list(&dispose);\n}\n",
      "cve_list": [
        "CVE-2024-47679"
      ],
      "cwe_list": [
        "CWE-362"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/f2fs/super.c",
      "func_name": "f2fs_handle_critical_error",
      "func_body": "void f2fs_handle_critical_error(struct f2fs_sb_info *sbi, unsigned char reason,\n\t\t\t\t\t\t\tbool irq_context)\n{\n\tstruct super_block *sb = sbi->sb;\n\tbool shutdown = reason == STOP_CP_REASON_SHUTDOWN;\n\tbool continue_fs = !shutdown &&\n\t\t\tF2FS_OPTION(sbi).errors == MOUNT_ERRORS_CONTINUE;\n\n\tset_ckpt_flags(sbi, CP_ERROR_FLAG);\n\n\tif (!f2fs_hw_is_readonly(sbi)) {\n\t\tsave_stop_reason(sbi, reason);\n\n\t\tif (irq_context && !shutdown)\n\t\t\tschedule_work(&sbi->s_error_work);\n\t\telse\n\t\t\tf2fs_record_stop_reason(sbi);\n\t}\n\n\t/*\n\t * We force ERRORS_RO behavior when system is rebooting. Otherwise we\n\t * could panic during 'reboot -f' as the underlying device got already\n\t * disabled.\n\t */\n\tif (F2FS_OPTION(sbi).errors == MOUNT_ERRORS_PANIC &&\n\t\t\t\t!shutdown && !system_going_down() &&\n\t\t\t\t!is_sbi_flag_set(sbi, SBI_IS_SHUTDOWN))\n\t\tpanic(\"F2FS-fs (device %s): panic forced after error\\n\",\n\t\t\t\t\t\t\tsb->s_id);\n\n\tif (shutdown)\n\t\tset_sbi_flag(sbi, SBI_IS_SHUTDOWN);\n\n\t/*\n\t * Continue filesystem operators if errors=continue. Should not set\n\t * RO by shutdown, since RO bypasses thaw_super which can hang the\n\t * system.\n\t */\n\tif (continue_fs || f2fs_readonly(sb) || shutdown) {\n\t\tf2fs_warn(sbi, \"Stopped filesystem due to reason: %d\", reason);\n\t\treturn;\n\t}\n\n\tf2fs_warn(sbi, \"Remounting filesystem read-only\");\n\n\t/*\n\t * We have already set CP_ERROR_FLAG flag to stop all updates\n\t * to filesystem, so it doesn't need to set SB_RDONLY flag here\n\t * because the flag should be set covered w/ sb->s_umount semaphore\n\t * via remount procedure, otherwise, it will confuse code like\n\t * freeze_super() which will lead to deadlocks and other problems.\n\t */\n}\n",
      "cve_list": [
        "CVE-2024-47689"
      ],
      "cwe_list": [
        "CWE-362"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/netfilter/ipset/ip_set_list_set.c",
      "func_name": "list_set_cancel_gc",
      "func_body": "static void\nlist_set_cancel_gc(struct ip_set *set)\n{\n\tstruct list_set *map = set->data;\n\n\tif (SET_WITH_TIMEOUT(set))\n\t\ttimer_shutdown_sync(&map->gc);\n}\n",
      "cve_list": [
        "CVE-2024-26910"
      ],
      "cwe_list": [
        "CWE-362"
      ]
    },
    {
      "project": "linux",
      "filepath": "lib/generic-radix-tree.c",
      "func_name": "__genradix_ptr_alloc",
      "func_body": "void *__genradix_ptr_alloc(struct __genradix *radix, size_t offset,\n\t\t\t   gfp_t gfp_mask)\n{\n\tstruct genradix_root *v = READ_ONCE(radix->root);\n\tstruct genradix_node *n, *new_node = NULL;\n\tunsigned level;\n\n\t/* Increase tree depth if necessary: */\n\twhile (1) {\n\t\tstruct genradix_root *r = v, *new_root;\n\n\t\tn\t= genradix_root_to_node(r);\n\t\tlevel\t= genradix_root_to_depth(r);\n\n\t\tif (n && ilog2(offset) < genradix_depth_shift(level))\n\t\t\tbreak;\n\n\t\tif (!new_node) {\n\t\t\tnew_node = genradix_alloc_node(gfp_mask);\n\t\t\tif (!new_node)\n\t\t\t\treturn NULL;\n\t\t}\n\n\t\tnew_node->children[0] = n;\n\t\tnew_root = ((struct genradix_root *)\n\t\t\t    ((unsigned long) new_node | (n ? level + 1 : 0)));\n\n\t\tif ((v = cmpxchg_release(&radix->root, r, new_root)) == r) {\n\t\t\tv = new_root;\n\t\t\tnew_node = NULL;\n\t\t} else {\n\t\t\tnew_node->children[0] = NULL;\n\t\t}\n\t}\n\n\twhile (level--) {\n\t\tstruct genradix_node **p =\n\t\t\t&n->children[offset >> genradix_depth_shift(level)];\n\t\toffset &= genradix_depth_size(level) - 1;\n\n\t\tn = READ_ONCE(*p);\n\t\tif (!n) {\n\t\t\tif (!new_node) {\n\t\t\t\tnew_node = genradix_alloc_node(gfp_mask);\n\t\t\t\tif (!new_node)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tif (!(n = cmpxchg_release(p, NULL, new_node)))\n\t\t\t\tswap(n, new_node);\n\t\t}\n\t}\n\n\tif (new_node)\n\t\tgenradix_free_node(new_node);\n\n\treturn &n->data[offset];\n}\n",
      "cve_list": [
        "CVE-2024-47668"
      ],
      "cwe_list": [
        "CWE-362"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/f2fs/file.c",
      "func_name": "f2fs_defragment_range",
      "func_body": "static int f2fs_defragment_range(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct file *filp,\n\t\t\t\t\tstruct f2fs_defragment *range)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_map_blocks map = { .m_next_extent = NULL,\n\t\t\t\t\t.m_seg_type = NO_CHECK_TYPE,\n\t\t\t\t\t.m_may_create = false };\n\tstruct extent_info ei = {};\n\tpgoff_t pg_start, pg_end, next_pgofs;\n\tunsigned int total = 0, sec_num;\n\tblock_t blk_end = 0;\n\tbool fragmented = false;\n\tint err;\n\n\tf2fs_balance_fs(sbi, true);\n\n\tinode_lock(inode);\n\tpg_start = range->start >> PAGE_SHIFT;\n\tpg_end = min_t(pgoff_t,\n\t\t\t\t(range->start + range->len) >> PAGE_SHIFT,\n\t\t\t\tDIV_ROUND_UP(i_size_read(inode), PAGE_SIZE));\n\n\tif (is_inode_flag_set(inode, FI_COMPRESS_RELEASED) ||\n\t\tf2fs_is_atomic_file(inode)) {\n\t\terr = -EINVAL;\n\t\tgoto unlock_out;\n\t}\n\n\t/* if in-place-update policy is enabled, don't waste time here */\n\tset_inode_flag(inode, FI_OPU_WRITE);\n\tif (f2fs_should_update_inplace(inode, NULL)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* writeback all dirty pages in the range */\n\terr = filemap_write_and_wait_range(inode->i_mapping,\n\t\t\t\t\t\tpg_start << PAGE_SHIFT,\n\t\t\t\t\t\t(pg_end << PAGE_SHIFT) - 1);\n\tif (err)\n\t\tgoto out;\n\n\t/*\n\t * lookup mapping info in extent cache, skip defragmenting if physical\n\t * block addresses are continuous.\n\t */\n\tif (f2fs_lookup_read_extent_cache(inode, pg_start, &ei)) {\n\t\tif ((pgoff_t)ei.fofs + ei.len >= pg_end)\n\t\t\tgoto out;\n\t}\n\n\tmap.m_lblk = pg_start;\n\tmap.m_next_pgofs = &next_pgofs;\n\n\t/*\n\t * lookup mapping info in dnode page cache, skip defragmenting if all\n\t * physical block addresses are continuous even if there are hole(s)\n\t * in logical blocks.\n\t */\n\twhile (map.m_lblk < pg_end) {\n\t\tmap.m_len = pg_end - map.m_lblk;\n\t\terr = f2fs_map_blocks(inode, &map, F2FS_GET_BLOCK_DEFAULT);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (!(map.m_flags & F2FS_MAP_FLAGS)) {\n\t\t\tmap.m_lblk = next_pgofs;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (blk_end && blk_end != map.m_pblk)\n\t\t\tfragmented = true;\n\n\t\t/* record total count of block that we're going to move */\n\t\ttotal += map.m_len;\n\n\t\tblk_end = map.m_pblk + map.m_len;\n\n\t\tmap.m_lblk += map.m_len;\n\t}\n\n\tif (!fragmented) {\n\t\ttotal = 0;\n\t\tgoto out;\n\t}\n\n\tsec_num = DIV_ROUND_UP(total, CAP_BLKS_PER_SEC(sbi));\n\n\t/*\n\t * make sure there are enough free section for LFS allocation, this can\n\t * avoid defragment running in SSR mode when free section are allocated\n\t * intensively\n\t */\n\tif (has_not_enough_free_secs(sbi, 0, sec_num)) {\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tmap.m_lblk = pg_start;\n\tmap.m_len = pg_end - pg_start;\n\ttotal = 0;\n\n\twhile (map.m_lblk < pg_end) {\n\t\tpgoff_t idx;\n\t\tint cnt = 0;\n\ndo_map:\n\t\tmap.m_len = pg_end - map.m_lblk;\n\t\terr = f2fs_map_blocks(inode, &map, F2FS_GET_BLOCK_DEFAULT);\n\t\tif (err)\n\t\t\tgoto clear_out;\n\n\t\tif (!(map.m_flags & F2FS_MAP_FLAGS)) {\n\t\t\tmap.m_lblk = next_pgofs;\n\t\t\tgoto check;\n\t\t}\n\n\t\tset_inode_flag(inode, FI_SKIP_WRITES);\n\n\t\tidx = map.m_lblk;\n\t\twhile (idx < map.m_lblk + map.m_len &&\n\t\t\t\t\t\tcnt < BLKS_PER_SEG(sbi)) {\n\t\t\tstruct page *page;\n\n\t\t\tpage = f2fs_get_lock_data_page(inode, idx, true);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\terr = PTR_ERR(page);\n\t\t\t\tgoto clear_out;\n\t\t\t}\n\n\t\t\tf2fs_wait_on_page_writeback(page, DATA, true, true);\n\n\t\t\tset_page_dirty(page);\n\t\t\tset_page_private_gcing(page);\n\t\t\tf2fs_put_page(page, 1);\n\n\t\t\tidx++;\n\t\t\tcnt++;\n\t\t\ttotal++;\n\t\t}\n\n\t\tmap.m_lblk = idx;\ncheck:\n\t\tif (map.m_lblk < pg_end && cnt < BLKS_PER_SEG(sbi))\n\t\t\tgoto do_map;\n\n\t\tclear_inode_flag(inode, FI_SKIP_WRITES);\n\n\t\terr = filemap_fdatawrite(inode->i_mapping);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\nclear_out:\n\tclear_inode_flag(inode, FI_SKIP_WRITES);\nout:\n\tclear_inode_flag(inode, FI_OPU_WRITE);\nunlock_out:\n\tinode_unlock(inode);\n\tif (!err)\n\t\trange->len = (u64)total << PAGE_SHIFT;\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-49859"
      ],
      "cwe_list": [
        "CWE-362"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/f2fs/file.c",
      "func_name": "f2fs_move_file_range",
      "func_body": "static int f2fs_move_file_range(struct file *file_in, loff_t pos_in,\n\t\t\tstruct file *file_out, loff_t pos_out, size_t len)\n{\n\tstruct inode *src = file_inode(file_in);\n\tstruct inode *dst = file_inode(file_out);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(src);\n\tsize_t olen = len, dst_max_i_size = 0;\n\tsize_t dst_osize;\n\tint ret;\n\n\tif (file_in->f_path.mnt != file_out->f_path.mnt ||\n\t\t\t\tsrc->i_sb != dst->i_sb)\n\t\treturn -EXDEV;\n\n\tif (unlikely(f2fs_readonly(src->i_sb)))\n\t\treturn -EROFS;\n\n\tif (!S_ISREG(src->i_mode) || !S_ISREG(dst->i_mode))\n\t\treturn -EINVAL;\n\n\tif (IS_ENCRYPTED(src) || IS_ENCRYPTED(dst))\n\t\treturn -EOPNOTSUPP;\n\n\tif (pos_out < 0 || pos_in < 0)\n\t\treturn -EINVAL;\n\n\tif (src == dst) {\n\t\tif (pos_in == pos_out)\n\t\t\treturn 0;\n\t\tif (pos_out > pos_in && pos_out < pos_in + len)\n\t\t\treturn -EINVAL;\n\t}\n\n\tinode_lock(src);\n\tif (src != dst) {\n\t\tret = -EBUSY;\n\t\tif (!inode_trylock(dst))\n\t\t\tgoto out;\n\t}\n\n\tif (f2fs_compressed_file(src) || f2fs_compressed_file(dst) ||\n\t\tf2fs_is_pinned_file(src) || f2fs_is_pinned_file(dst)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_unlock;\n\t}\n\n\tif (f2fs_is_atomic_file(src) || f2fs_is_atomic_file(dst)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = -EINVAL;\n\tif (pos_in + len > src->i_size || pos_in + len < pos_in)\n\t\tgoto out_unlock;\n\tif (len == 0)\n\t\tolen = len = src->i_size - pos_in;\n\tif (pos_in + len == src->i_size)\n\t\tlen = ALIGN(src->i_size, F2FS_BLKSIZE) - pos_in;\n\tif (len == 0) {\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tdst_osize = dst->i_size;\n\tif (pos_out + olen > dst->i_size)\n\t\tdst_max_i_size = pos_out + olen;\n\n\t/* verify the end result is block aligned */\n\tif (!IS_ALIGNED(pos_in, F2FS_BLKSIZE) ||\n\t\t\t!IS_ALIGNED(pos_in + len, F2FS_BLKSIZE) ||\n\t\t\t!IS_ALIGNED(pos_out, F2FS_BLKSIZE))\n\t\tgoto out_unlock;\n\n\tret = f2fs_convert_inline_inode(src);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = f2fs_convert_inline_inode(dst);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* write out all dirty pages from offset */\n\tret = filemap_write_and_wait_range(src->i_mapping,\n\t\t\t\t\tpos_in, pos_in + len);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = filemap_write_and_wait_range(dst->i_mapping,\n\t\t\t\t\tpos_out, pos_out + len);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tf2fs_balance_fs(sbi, true);\n\n\tf2fs_down_write(&F2FS_I(src)->i_gc_rwsem[WRITE]);\n\tif (src != dst) {\n\t\tret = -EBUSY;\n\t\tif (!f2fs_down_write_trylock(&F2FS_I(dst)->i_gc_rwsem[WRITE]))\n\t\t\tgoto out_src;\n\t}\n\n\tf2fs_lock_op(sbi);\n\tret = __exchange_data_block(src, dst, F2FS_BYTES_TO_BLK(pos_in),\n\t\t\t\tF2FS_BYTES_TO_BLK(pos_out),\n\t\t\t\tF2FS_BYTES_TO_BLK(len), false);\n\n\tif (!ret) {\n\t\tif (dst_max_i_size)\n\t\t\tf2fs_i_size_write(dst, dst_max_i_size);\n\t\telse if (dst_osize != dst->i_size)\n\t\t\tf2fs_i_size_write(dst, dst_osize);\n\t}\n\tf2fs_unlock_op(sbi);\n\n\tif (src != dst)\n\t\tf2fs_up_write(&F2FS_I(dst)->i_gc_rwsem[WRITE]);\nout_src:\n\tf2fs_up_write(&F2FS_I(src)->i_gc_rwsem[WRITE]);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tinode_set_mtime_to_ts(src, inode_set_ctime_current(src));\n\tf2fs_mark_inode_dirty_sync(src, false);\n\tif (src != dst) {\n\t\tinode_set_mtime_to_ts(dst, inode_set_ctime_current(dst));\n\t\tf2fs_mark_inode_dirty_sync(dst, false);\n\t}\n\tf2fs_update_time(sbi, REQ_TIME);\n\nout_unlock:\n\tif (src != dst)\n\t\tinode_unlock(dst);\nout:\n\tinode_unlock(src);\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-49859"
      ],
      "cwe_list": [
        "CWE-362"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/f2fs/file.c",
      "func_name": "f2fs_ioc_set_pin_file",
      "func_body": "static int f2fs_ioc_set_pin_file(struct file *filp, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\t__u32 pin;\n\tint ret = 0;\n\n\tif (get_user(pin, (__u32 __user *)arg))\n\t\treturn -EFAULT;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (f2fs_readonly(sbi->sb))\n\t\treturn -EROFS;\n\n\tret = mnt_want_write_file(filp);\n\tif (ret)\n\t\treturn ret;\n\n\tinode_lock(inode);\n\n\tif (f2fs_is_atomic_file(inode)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!pin) {\n\t\tclear_inode_flag(inode, FI_PIN_FILE);\n\t\tf2fs_i_gc_failures_write(inode, 0);\n\t\tgoto done;\n\t} else if (f2fs_is_pinned_file(inode)) {\n\t\tgoto done;\n\t}\n\n\tif (F2FS_HAS_BLOCKS(inode)) {\n\t\tret = -EFBIG;\n\t\tgoto out;\n\t}\n\n\t/* Let's allow file pinning on zoned device. */\n\tif (!f2fs_sb_has_blkzoned(sbi) &&\n\t    f2fs_should_update_outplace(inode, NULL)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (f2fs_pin_file_control(inode, false)) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tret = f2fs_convert_inline_inode(inode);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!f2fs_disable_compressed_file(inode)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tset_inode_flag(inode, FI_PIN_FILE);\n\tret = F2FS_I(inode)->i_gc_failures;\ndone:\n\tf2fs_update_time(sbi, REQ_TIME);\nout:\n\tinode_unlock(inode);\n\tmnt_drop_write_file(filp);\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-49859"
      ],
      "cwe_list": [
        "CWE-362"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/netfilter/nf_tables_api.c",
      "func_name": "__nft_obj_type_get",
      "func_body": "static const struct nft_object_type *__nft_obj_type_get(u32 objtype, u8 family)\n{\n\tconst struct nft_object_type *type;\n\n\tlist_for_each_entry_rcu(type, &nf_tables_objects, list) {\n\t\tif (type->family != NFPROTO_UNSPEC &&\n\t\t    type->family != family)\n\t\t\tcontinue;\n\n\t\tif (objtype == type->type)\n\t\t\treturn type;\n\t}\n\treturn NULL;\n}\n",
      "cve_list": [
        "CVE-2024-27019"
      ],
      "cwe_list": [
        "CWE-362"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/netfilter/nf_tables_api.c",
      "func_name": "nft_obj_type_get",
      "func_body": "static const struct nft_object_type *\nnft_obj_type_get(struct net *net, u32 objtype, u8 family)\n{\n\tconst struct nft_object_type *type;\n\n\trcu_read_lock();\n\ttype = __nft_obj_type_get(objtype, family);\n\tif (type != NULL && try_module_get(type->owner)) {\n\t\trcu_read_unlock();\n\t\treturn type;\n\t}\n\trcu_read_unlock();\n\n\tlockdep_nfnl_nft_mutex_not_held();\n// #ifdef CONFIG_MODULES\n\tif (type == NULL) {\n\t\tif (nft_request_module(net, \"nft-obj-%u\", objtype) == -EAGAIN)\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t}\n#endif\n\treturn ERR_PTR(-ENOENT);\n}\n",
      "cve_list": [
        "CVE-2024-27019"
      ],
      "cwe_list": [
        "CWE-362"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/tls/tls_sw.c",
      "func_name": "tls_encrypt_done",
      "func_body": "static void tls_encrypt_done(void *data, int err)\n{\n\tstruct tls_sw_context_tx *ctx;\n\tstruct tls_context *tls_ctx;\n\tstruct tls_prot_info *prot;\n\tstruct tls_rec *rec = data;\n\tstruct scatterlist *sge;\n\tstruct sk_msg *msg_en;\n\tstruct sock *sk;\n\n\tmsg_en = &rec->msg_encrypted;\n\n\tsk = rec->sk;\n\ttls_ctx = tls_get_ctx(sk);\n\tprot = &tls_ctx->prot_info;\n\tctx = tls_sw_ctx_tx(tls_ctx);\n\n\tsge = sk_msg_elem(msg_en, msg_en->sg.curr);\n\tsge->offset -= prot->prepend_size;\n\tsge->length += prot->prepend_size;\n\n\t/* Check if error is previously set on socket */\n\tif (err || sk->sk_err) {\n\t\trec = NULL;\n\n\t\t/* If err is already set on socket, return the same code */\n\t\tif (sk->sk_err) {\n\t\t\tctx->async_wait.err = -sk->sk_err;\n\t\t} else {\n\t\t\tctx->async_wait.err = err;\n\t\t\ttls_err_abort(sk, err);\n\t\t}\n\t}\n\n\tif (rec) {\n\t\tstruct tls_rec *first_rec;\n\n\t\t/* Mark the record as ready for transmission */\n\t\tsmp_store_mb(rec->tx_ready, true);\n\n\t\t/* If received record is at head of tx_list, schedule tx */\n\t\tfirst_rec = list_first_entry(&ctx->tx_list,\n\t\t\t\t\t     struct tls_rec, list);\n\t\tif (rec == first_rec) {\n\t\t\t/* Schedule the transmission */\n\t\t\tif (!test_and_set_bit(BIT_TX_SCHEDULED,\n\t\t\t\t\t      &ctx->tx_bitmask))\n\t\t\t\tschedule_delayed_work(&ctx->tx_work.work, 1);\n\t\t}\n\t}\n\n\tif (atomic_dec_and_test(&ctx->encrypt_pending))\n\t\tcomplete(&ctx->async_wait.completion);\n}\n",
      "cve_list": [
        "CVE-2024-26585"
      ],
      "cwe_list": [
        "CWE-362"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/netfilter/nf_tables_api.c",
      "func_name": "__nft_expr_type_get",
      "func_body": "static const struct nft_expr_type *__nft_expr_type_get(u8 family,\n\t\t\t\t\t\t       struct nlattr *nla)\n{\n\tconst struct nft_expr_type *type, *candidate = NULL;\n\n\tlist_for_each_entry_rcu(type, &nf_tables_expressions, list) {\n\t\tif (!nla_strcmp(nla, type->name)) {\n\t\t\tif (!type->family && !candidate)\n\t\t\t\tcandidate = type;\n\t\t\telse if (type->family == family)\n\t\t\t\tcandidate = type;\n\t\t}\n\t}\n\treturn candidate;\n}\n",
      "cve_list": [
        "CVE-2024-27020"
      ],
      "cwe_list": [
        "CWE-362"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/netfilter/nf_tables_api.c",
      "func_name": "nft_expr_type_get",
      "func_body": "static const struct nft_expr_type *nft_expr_type_get(struct net *net,\n\t\t\t\t\t\t     u8 family,\n\t\t\t\t\t\t     struct nlattr *nla)\n{\n\tconst struct nft_expr_type *type;\n\n\tif (nla == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\trcu_read_lock();\n\ttype = __nft_expr_type_get(family, nla);\n\tif (type != NULL && try_module_get(type->owner)) {\n\t\trcu_read_unlock();\n\t\treturn type;\n\t}\n\trcu_read_unlock();\n\n\tlockdep_nfnl_nft_mutex_not_held();\n// #ifdef CONFIG_MODULES\n\tif (type == NULL) {\n\t\tif (nft_expr_type_request_module(net, family, nla) == -EAGAIN)\n\t\t\treturn ERR_PTR(-EAGAIN);\n\n\t\tif (nft_request_module(net, \"nft-expr-%.*s\",\n\t\t\t\t       nla_len(nla),\n\t\t\t\t       (char *)nla_data(nla)) == -EAGAIN)\n\t\t\treturn ERR_PTR(-EAGAIN);\n\t}\n#endif\n\treturn ERR_PTR(-ENOENT);\n}\n",
      "cve_list": [
        "CVE-2024-27020"
      ],
      "cwe_list": [
        "CWE-362"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/btrfs/bio.c",
      "func_name": "btrfs_submit_chunk",
      "func_body": "static bool btrfs_submit_chunk(struct btrfs_bio *bbio, int mirror_num)\n{\n\tstruct btrfs_inode *inode = bbio->inode;\n\tstruct btrfs_fs_info *fs_info = bbio->fs_info;\n\tstruct bio *bio = &bbio->bio;\n\tu64 logical = bio->bi_iter.bi_sector << SECTOR_SHIFT;\n\tu64 length = bio->bi_iter.bi_size;\n\tu64 map_length = length;\n\tbool use_append = btrfs_use_zone_append(bbio);\n\tstruct btrfs_io_context *bioc = NULL;\n\tstruct btrfs_io_stripe smap;\n\tblk_status_t ret;\n\tint error;\n\n\tsmap.is_scrub = !bbio->inode;\n\n\tbtrfs_bio_counter_inc_blocked(fs_info);\n\terror = btrfs_map_block(fs_info, btrfs_op(bio), logical, &map_length,\n\t\t\t\t&bioc, &smap, &mirror_num);\n\tif (error) {\n\t\tret = errno_to_blk_status(error);\n\t\tgoto fail;\n\t}\n\n\tmap_length = min(map_length, length);\n\tif (use_append)\n\t\tmap_length = min(map_length, fs_info->max_zone_append_size);\n\n\tif (map_length < length) {\n\t\tbbio = btrfs_split_bio(fs_info, bbio, map_length, use_append);\n\t\tbio = &bbio->bio;\n\t}\n\n\t/*\n\t * Save the iter for the end_io handler and preload the checksums for\n\t * data reads.\n\t */\n\tif (bio_op(bio) == REQ_OP_READ && is_data_bbio(bbio)) {\n\t\tbbio->saved_iter = bio->bi_iter;\n\t\tret = btrfs_lookup_bio_sums(bbio);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\tif (btrfs_op(bio) == BTRFS_MAP_WRITE) {\n\t\tif (use_append) {\n\t\t\tbio->bi_opf &= ~REQ_OP_WRITE;\n\t\t\tbio->bi_opf |= REQ_OP_ZONE_APPEND;\n\t\t}\n\n\t\tif (is_data_bbio(bbio) && bioc &&\n\t\t    btrfs_need_stripe_tree_update(bioc->fs_info, bioc->map_type)) {\n\t\t\t/*\n\t\t\t * No locking for the list update, as we only add to\n\t\t\t * the list in the I/O submission path, and list\n\t\t\t * iteration only happens in the completion path, which\n\t\t\t * can't happen until after the last submission.\n\t\t\t */\n\t\t\tbtrfs_get_bioc(bioc);\n\t\t\tlist_add_tail(&bioc->rst_ordered_entry, &bbio->ordered->bioc_list);\n\t\t}\n\n\t\t/*\n\t\t * Csum items for reloc roots have already been cloned at this\n\t\t * point, so they are handled as part of the no-checksum case.\n\t\t */\n\t\tif (inode && !(inode->flags & BTRFS_INODE_NODATASUM) &&\n\t\t    !test_bit(BTRFS_FS_STATE_NO_DATA_CSUMS, &fs_info->fs_state) &&\n\t\t    !btrfs_is_data_reloc_root(inode->root)) {\n\t\t\tif (should_async_write(bbio) &&\n\t\t\t    btrfs_wq_submit_bio(bbio, bioc, &smap, mirror_num))\n\t\t\t\tgoto done;\n\n\t\t\tret = btrfs_bio_csum(bbio);\n\t\t\tif (ret)\n\t\t\t\tgoto fail;\n\t\t} else if (use_append ||\n\t\t\t   (btrfs_is_zoned(fs_info) && inode &&\n\t\t\t    inode->flags & BTRFS_INODE_NODATASUM)) {\n\t\t\tret = btrfs_alloc_dummy_sum(bbio);\n\t\t\tif (ret)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t__btrfs_submit_bio(bio, bioc, &smap, mirror_num);\ndone:\n\treturn map_length == length;\n\nfail:\n\tbtrfs_bio_counter_dec(fs_info);\n\t/*\n\t * We have split the original bbio, now we have to end both the current\n\t * @bbio and remaining one, as the remaining one will never be submitted.\n\t */\n\tif (map_length < length) {\n\t\tstruct btrfs_bio *remaining = bbio->private;\n\n\t\tASSERT(bbio->bio.bi_pool == &btrfs_clone_bioset);\n\t\tASSERT(remaining);\n\n\t\tremaining->bio.bi_status = ret;\n\t\tbtrfs_orig_bbio_end_io(remaining);\n\t}\n\tbbio->bio.bi_status = ret;\n\tbtrfs_orig_bbio_end_io(bbio);\n\t/* Do not submit another chunk */\n\treturn true;\n}\n",
      "cve_list": [
        "CVE-2024-46687"
      ],
      "cwe_list": [
        "CWE-415",
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/hwtracing/stm/core.c",
      "func_name": "stm_register_device",
      "func_body": "int stm_register_device(struct device *parent, struct stm_data *stm_data,\n\t\t\tstruct module *owner)\n{\n\tstruct stm_device *stm;\n\tunsigned int nmasters;\n\tint err = -ENOMEM;\n\n\tif (!stm_core_up)\n\t\treturn -EPROBE_DEFER;\n\n\tif (!stm_data->packet || !stm_data->sw_nchannels)\n\t\treturn -EINVAL;\n\n\tnmasters = stm_data->sw_end - stm_data->sw_start + 1;\n\tstm = vzalloc(sizeof(*stm) + nmasters * sizeof(void *));\n\tif (!stm)\n\t\treturn -ENOMEM;\n\n\tstm->major = register_chrdev(0, stm_data->name, &stm_fops);\n\tif (stm->major < 0) {\n\t\terr = stm->major;\n\t\tvfree(stm);\n\t\treturn err;\n\t}\n\n\tdevice_initialize(&stm->dev);\n\tstm->dev.devt = MKDEV(stm->major, 0);\n\tstm->dev.class = &stm_class;\n\tstm->dev.parent = parent;\n\tstm->dev.release = stm_device_release;\n\n\tmutex_init(&stm->link_mutex);\n\tspin_lock_init(&stm->link_lock);\n\tINIT_LIST_HEAD(&stm->link_list);\n\n\t/* initialize the object before it is accessible via sysfs */\n\tspin_lock_init(&stm->mc_lock);\n\tmutex_init(&stm->policy_mutex);\n\tstm->sw_nmasters = nmasters;\n\tstm->owner = owner;\n\tstm->data = stm_data;\n\tstm_data->stm = stm;\n\n\terr = kobject_set_name(&stm->dev.kobj, \"%s\", stm_data->name);\n\tif (err)\n\t\tgoto err_device;\n\n\terr = device_add(&stm->dev);\n\tif (err)\n\t\tgoto err_device;\n\n\t/*\n\t * Use delayed autosuspend to avoid bouncing back and forth\n\t * on recurring character device writes, with the initial\n\t * delay time of 2 seconds.\n\t */\n\tpm_runtime_no_callbacks(&stm->dev);\n\tpm_runtime_use_autosuspend(&stm->dev);\n\tpm_runtime_set_autosuspend_delay(&stm->dev, 2000);\n\tpm_runtime_set_suspended(&stm->dev);\n\tpm_runtime_enable(&stm->dev);\n\n\treturn 0;\n\nerr_device:\n\tunregister_chrdev(stm->major, stm_data->name);\n\n\t/* calls stm_device_release() */\n\tput_device(&stm->dev);\n\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-38627"
      ],
      "cwe_list": [
        "CWE-415"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/amdgpu/amdgpu_umc.c",
      "func_name": "amdgpu_umc_handle_bad_pages",
      "func_body": "void amdgpu_umc_handle_bad_pages(struct amdgpu_device *adev,\n\t\t\tvoid *ras_error_status)\n{\n\tstruct ras_err_data *err_data = (struct ras_err_data *)ras_error_status;\n\tstruct amdgpu_ras *con = amdgpu_ras_get_context(adev);\n\tunsigned int error_query_mode;\n\tint ret = 0;\n\tunsigned long err_count;\n\n\tamdgpu_ras_get_error_query_mode(adev, &error_query_mode);\n\n\tmutex_lock(&con->page_retirement_lock);\n\tret = amdgpu_dpm_get_ecc_info(adev, (void *)&(con->umc_ecc));\n\tif (ret == -EOPNOTSUPP &&\n\t    error_query_mode == AMDGPU_RAS_DIRECT_ERROR_QUERY) {\n\t\tif (adev->umc.ras && adev->umc.ras->ras_block.hw_ops &&\n\t\t    adev->umc.ras->ras_block.hw_ops->query_ras_error_count)\n\t\t    adev->umc.ras->ras_block.hw_ops->query_ras_error_count(adev, ras_error_status);\n\n\t\tif (adev->umc.ras && adev->umc.ras->ras_block.hw_ops &&\n\t\t    adev->umc.ras->ras_block.hw_ops->query_ras_error_address &&\n\t\t    adev->umc.max_ras_err_cnt_per_query) {\n\t\t\terr_data->err_addr =\n\t\t\t\tkcalloc(adev->umc.max_ras_err_cnt_per_query,\n\t\t\t\t\tsizeof(struct eeprom_table_record), GFP_KERNEL);\n\n\t\t\t/* still call query_ras_error_address to clear error status\n\t\t\t * even NOMEM error is encountered\n\t\t\t */\n\t\t\tif(!err_data->err_addr)\n\t\t\t\tdev_warn(adev->dev, \"Failed to alloc memory for \"\n\t\t\t\t\t\t\"umc error address record!\\n\");\n\t\t\telse\n\t\t\t\terr_data->err_addr_len = adev->umc.max_ras_err_cnt_per_query;\n\n\t\t\t/* umc query_ras_error_address is also responsible for clearing\n\t\t\t * error status\n\t\t\t */\n\t\t\tadev->umc.ras->ras_block.hw_ops->query_ras_error_address(adev, ras_error_status);\n\t\t}\n\t} else if (error_query_mode == AMDGPU_RAS_FIRMWARE_ERROR_QUERY ||\n\t    (!ret && error_query_mode == AMDGPU_RAS_DIRECT_ERROR_QUERY)) {\n\t\tif (adev->umc.ras &&\n\t\t    adev->umc.ras->ecc_info_query_ras_error_count)\n\t\t    adev->umc.ras->ecc_info_query_ras_error_count(adev, ras_error_status);\n\n\t\tif (adev->umc.ras &&\n\t\t    adev->umc.ras->ecc_info_query_ras_error_address &&\n\t\t    adev->umc.max_ras_err_cnt_per_query) {\n\t\t\terr_data->err_addr =\n\t\t\t\tkcalloc(adev->umc.max_ras_err_cnt_per_query,\n\t\t\t\t\tsizeof(struct eeprom_table_record), GFP_KERNEL);\n\n\t\t\t/* still call query_ras_error_address to clear error status\n\t\t\t * even NOMEM error is encountered\n\t\t\t */\n\t\t\tif(!err_data->err_addr)\n\t\t\t\tdev_warn(adev->dev, \"Failed to alloc memory for \"\n\t\t\t\t\t\t\"umc error address record!\\n\");\n\t\t\telse\n\t\t\t\terr_data->err_addr_len = adev->umc.max_ras_err_cnt_per_query;\n\n\t\t\t/* umc query_ras_error_address is also responsible for clearing\n\t\t\t * error status\n\t\t\t */\n\t\t\tadev->umc.ras->ecc_info_query_ras_error_address(adev, ras_error_status);\n\t\t}\n\t}\n\n\t/* only uncorrectable error needs gpu reset */\n\tif (err_data->ue_count || err_data->de_count) {\n\t\terr_count = err_data->ue_count + err_data->de_count;\n\t\tif ((amdgpu_bad_page_threshold != 0) &&\n\t\t\terr_data->err_addr_cnt) {\n\t\t\tamdgpu_ras_add_bad_pages(adev, err_data->err_addr,\n\t\t\t\t\t\terr_data->err_addr_cnt);\n\t\t\tamdgpu_ras_save_bad_pages(adev, &err_count);\n\n\t\t\tamdgpu_dpm_send_hbm_bad_pages_num(adev, con->eeprom_control.ras_num_recs);\n\n\t\t\tif (con->update_channel_flag == true) {\n\t\t\t\tamdgpu_dpm_send_hbm_bad_channel_flag(adev, con->eeprom_control.bad_channel_bitmap);\n\t\t\t\tcon->update_channel_flag = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tkfree(err_data->err_addr);\n\terr_data->err_addr = NULL;\n\n\tmutex_unlock(&con->page_retirement_lock);\n}\n",
      "cve_list": [
        "CVE-2024-42123"
      ],
      "cwe_list": [
        "CWE-415"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/scsi/aacraid/comminit.c",
      "func_name": "aac_init_adapter",
      "func_body": "struct aac_dev *aac_init_adapter(struct aac_dev *dev)\n{\n\tu32 status[5];\n\tstruct Scsi_Host * host = dev->scsi_host_ptr;\n\textern int aac_sync_mode;\n\n\t/*\n\t *\tCheck the preferred comm settings, defaults from template.\n\t */\n\tdev->management_fib_count = 0;\n\tspin_lock_init(&dev->manage_lock);\n\tspin_lock_init(&dev->sync_lock);\n\tspin_lock_init(&dev->iq_lock);\n\tdev->max_fib_size = sizeof(struct hw_fib);\n\tdev->sg_tablesize = host->sg_tablesize = (dev->max_fib_size\n\t\t- sizeof(struct aac_fibhdr)\n\t\t- sizeof(struct aac_write) + sizeof(struct sgentry))\n\t\t\t/ sizeof(struct sgentry);\n\tdev->comm_interface = AAC_COMM_PRODUCER;\n\tdev->raw_io_interface = dev->raw_io_64 = 0;\n\n\n\t/*\n\t * Enable INTX mode, if not done already Enabled\n\t */\n\tif (aac_is_msix_mode(dev)) {\n\t\taac_change_to_intx(dev);\n\t\tdev_info(&dev->pdev->dev, \"Changed firmware to INTX mode\");\n\t}\n\n\tif ((!aac_adapter_sync_cmd(dev, GET_ADAPTER_PROPERTIES,\n\t\t0, 0, 0, 0, 0, 0,\n\t\tstatus+0, status+1, status+2, status+3, status+4)) &&\n\t\t(status[0] == 0x00000001)) {\n\t\tdev->doorbell_mask = status[3];\n\t\tif (status[1] & AAC_OPT_NEW_COMM_64)\n\t\t\tdev->raw_io_64 = 1;\n\t\tdev->sync_mode = aac_sync_mode;\n\t\tif (dev->a_ops.adapter_comm &&\n\t\t    (status[1] & AAC_OPT_NEW_COMM)) {\n\t\t\tdev->comm_interface = AAC_COMM_MESSAGE;\n\t\t\tdev->raw_io_interface = 1;\n\t\t\tif ((status[1] & AAC_OPT_NEW_COMM_TYPE1)) {\n\t\t\t\t/* driver supports TYPE1 (Tupelo) */\n\t\t\t\tdev->comm_interface = AAC_COMM_MESSAGE_TYPE1;\n\t\t\t} else if (status[1] & AAC_OPT_NEW_COMM_TYPE2) {\n\t\t\t\t/* driver supports TYPE2 (Denali, Yosemite) */\n\t\t\t\tdev->comm_interface = AAC_COMM_MESSAGE_TYPE2;\n\t\t\t} else if (status[1] & AAC_OPT_NEW_COMM_TYPE3) {\n\t\t\t\t/* driver supports TYPE3 (Yosemite, Thor) */\n\t\t\t\tdev->comm_interface = AAC_COMM_MESSAGE_TYPE3;\n\t\t\t} else if (status[1] & AAC_OPT_NEW_COMM_TYPE4) {\n\t\t\t\t/* not supported TYPE - switch to sync. mode */\n\t\t\t\tdev->comm_interface = AAC_COMM_MESSAGE_TYPE2;\n\t\t\t\tdev->sync_mode = 1;\n\t\t\t}\n\t\t}\n\t\tif ((status[1] & le32_to_cpu(AAC_OPT_EXTENDED)) &&\n\t\t\t(status[4] & le32_to_cpu(AAC_EXTOPT_SA_FIRMWARE)))\n\t\t\tdev->sa_firmware = 1;\n\t\telse\n\t\t\tdev->sa_firmware = 0;\n\n\t\tif (status[4] & le32_to_cpu(AAC_EXTOPT_SOFT_RESET))\n\t\t\tdev->soft_reset_support = 1;\n\t\telse\n\t\t\tdev->soft_reset_support = 0;\n\n\t\tif ((dev->comm_interface == AAC_COMM_MESSAGE) &&\n\t\t    (status[2] > dev->base_size)) {\n\t\t\taac_adapter_ioremap(dev, 0);\n\t\t\tdev->base_size = status[2];\n\t\t\tif (aac_adapter_ioremap(dev, status[2])) {\n\t\t\t\t/* remap failed, go back ... */\n\t\t\t\tdev->comm_interface = AAC_COMM_PRODUCER;\n\t\t\t\tif (aac_adapter_ioremap(dev, AAC_MIN_FOOTPRINT_SIZE)) {\n\t\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t  \"aacraid: unable to map adapter.\\n\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdev->max_msix = 0;\n\tdev->msi_enabled = 0;\n\tdev->adapter_shutdown = 0;\n\tif ((!aac_adapter_sync_cmd(dev, GET_COMM_PREFERRED_SETTINGS,\n\t  0, 0, 0, 0, 0, 0,\n\t  status+0, status+1, status+2, status+3, status+4))\n\t && (status[0] == 0x00000001)) {\n\t\t/*\n\t\t *\tstatus[1] >> 16\t\tmaximum command size in KB\n\t\t *\tstatus[1] & 0xFFFF\tmaximum FIB size\n\t\t *\tstatus[2] >> 16\t\tmaximum SG elements to driver\n\t\t *\tstatus[2] & 0xFFFF\tmaximum SG elements from driver\n\t\t *\tstatus[3] & 0xFFFF\tmaximum number FIBs outstanding\n\t\t */\n\t\thost->max_sectors = (status[1] >> 16) << 1;\n\t\t/* Multiple of 32 for PMC */\n\t\tdev->max_fib_size = status[1] & 0xFFE0;\n\t\thost->sg_tablesize = status[2] >> 16;\n\t\tdev->sg_tablesize = status[2] & 0xFFFF;\n\t\tif (aac_is_src(dev)) {\n\t\t\tif (host->can_queue > (status[3] >> 16) -\n\t\t\t\t\tAAC_NUM_MGT_FIB)\n\t\t\t\thost->can_queue = (status[3] >> 16) -\n\t\t\t\t\tAAC_NUM_MGT_FIB;\n\t\t} else if (host->can_queue > (status[3] & 0xFFFF) -\n\t\t\t\tAAC_NUM_MGT_FIB)\n\t\t\thost->can_queue = (status[3] & 0xFFFF) -\n\t\t\t\tAAC_NUM_MGT_FIB;\n\n\t\tdev->max_num_aif = status[4] & 0xFFFF;\n\t}\n\tif (numacb > 0) {\n\t\tif (numacb < host->can_queue)\n\t\t\thost->can_queue = numacb;\n\t\telse\n\t\t\tpr_warn(\"numacb=%d ignored\\n\", numacb);\n\t}\n\n\tif (aac_is_src(dev))\n\t\taac_define_int_mode(dev);\n\t/*\n\t *\tOk now init the communication subsystem\n\t */\n\n\tdev->queues = kzalloc(sizeof(struct aac_queue_block), GFP_KERNEL);\n\tif (dev->queues == NULL) {\n\t\tprintk(KERN_ERR \"Error could not allocate comm region.\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (aac_comm_init(dev)<0){\n\t\tkfree(dev->queues);\n\t\tdev->queues = NULL;\n\t\treturn NULL;\n\t}\n\t/*\n\t *\tInitialize the list of fibs\n\t */\n\tif (aac_fib_setup(dev) < 0) {\n\t\tkfree(dev->queues);\n\t\tdev->queues = NULL;\n\t\treturn NULL;\n\t}\n\t\t\n\tINIT_LIST_HEAD(&dev->fib_list);\n\tINIT_LIST_HEAD(&dev->sync_fib_list);\n\n\treturn dev;\n}\n",
      "cve_list": [
        "CVE-2024-46673"
      ],
      "cwe_list": [
        "CWE-415"
      ]
    },
    {
      "project": "linux",
      "filepath": "arch/um/drivers/line.c",
      "func_name": "register_winch_irq",
      "func_body": "void register_winch_irq(int fd, int tty_fd, int pid, struct tty_port *port,\n\t\t\tunsigned long stack)\n{\n\tstruct winch *winch;\n\n\twinch = kmalloc(sizeof(*winch), GFP_KERNEL);\n\tif (winch == NULL) {\n\t\tprintk(KERN_ERR \"register_winch_irq - kmalloc failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\t*winch = ((struct winch) { .fd  \t= fd,\n\t\t\t\t   .tty_fd \t= tty_fd,\n\t\t\t\t   .pid  \t= pid,\n\t\t\t\t   .port \t= port,\n\t\t\t\t   .stack\t= stack });\n\n\tspin_lock(&winch_handler_lock);\n\tlist_add(&winch->list, &winch_handlers);\n\tspin_unlock(&winch_handler_lock);\n\n\tif (um_request_irq(WINCH_IRQ, fd, IRQ_READ, winch_interrupt,\n\t\t\t   IRQF_SHARED, \"winch\", winch) < 0) {\n\t\tprintk(KERN_ERR \"register_winch_irq - failed to register \"\n\t\t       \"IRQ\\n\");\n\t\tspin_lock(&winch_handler_lock);\n\t\tlist_del(&winch->list);\n\t\tspin_unlock(&winch_handler_lock);\n\t\tgoto out_free;\n\t}\n\n\treturn;\n\n out_free:\n\tkfree(winch);\n cleanup:\n\tos_kill_process(pid, 1);\n\tos_close_file(fd);\n\tif (stack != 0)\n\t\tfree_stack(stack, 0);\n}\n",
      "cve_list": [
        "CVE-2024-39292"
      ],
      "cwe_list": [
        "CWE-415"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/ata/libata-core.c",
      "func_name": "ata_host_alloc",
      "func_body": "struct ata_host *ata_host_alloc(struct device *dev, int max_ports)\n{\n\tstruct ata_host *host;\n\tsize_t sz;\n\tint i;\n\tvoid *dr;\n\n\t/* alloc a container for our list of ATA ports (buses) */\n\tsz = sizeof(struct ata_host) + (max_ports + 1) * sizeof(void *);\n\thost = kzalloc(sz, GFP_KERNEL);\n\tif (!host)\n\t\treturn NULL;\n\n\tif (!devres_open_group(dev, NULL, GFP_KERNEL)) {\n\t\tkfree(host);\n\t\treturn NULL;\n\t}\n\n\tdr = devres_alloc(ata_devres_release, 0, GFP_KERNEL);\n\tif (!dr)\n\t\tgoto err_out;\n\n\tdevres_add(dev, dr);\n\tdev_set_drvdata(dev, host);\n\n\tspin_lock_init(&host->lock);\n\tmutex_init(&host->eh_mutex);\n\thost->dev = dev;\n\thost->n_ports = max_ports;\n\tkref_init(&host->kref);\n\n\t/* allocate ports bound to this host */\n\tfor (i = 0; i < max_ports; i++) {\n\t\tstruct ata_port *ap;\n\n\t\tap = ata_port_alloc(host);\n\t\tif (!ap)\n\t\t\tgoto err_out;\n\n\t\tap->port_no = i;\n\t\thost->ports[i] = ap;\n\t}\n\n\tdevres_remove_group(dev, NULL);\n\treturn host;\n\n err_out:\n\tdevres_release_group(dev, NULL);\n\treturn NULL;\n}\n",
      "cve_list": [
        "CVE-2024-41087"
      ],
      "cwe_list": [
        "CWE-415"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/usb/typec/tcpm/tcpm.c",
      "func_name": "tcpm_port_unregister_pd",
      "func_body": "static void tcpm_port_unregister_pd(struct tcpm_port *port)\n{\n\tint i;\n\n\tport->port_sink_caps = NULL;\n\tport->port_source_caps = NULL;\n\tfor (i = 0; i < port->pd_count; i++) {\n\t\tusb_power_delivery_unregister_capabilities(port->pd_list[i]->sink_cap);\n\t\tusb_power_delivery_unregister_capabilities(port->pd_list[i]->source_cap);\n\t\tdevm_kfree(port->dev, port->pd_list[i]);\n\t\tport->pd_list[i] = NULL;\n\t\tusb_power_delivery_unregister(port->pds[i]);\n\t\tport->pds[i] = NULL;\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-26932"
      ],
      "cwe_list": [
        "CWE-415"
      ]
    },
    {
      "project": "linux",
      "filepath": "mm/memcontrol.c",
      "func_name": "mem_cgroup_migrate",
      "func_body": "void mem_cgroup_migrate(struct folio *old, struct folio *new)\n{\n\tstruct mem_cgroup *memcg;\n\n\tVM_BUG_ON_FOLIO(!folio_test_locked(old), old);\n\tVM_BUG_ON_FOLIO(!folio_test_locked(new), new);\n\tVM_BUG_ON_FOLIO(folio_test_anon(old) != folio_test_anon(new), new);\n\tVM_BUG_ON_FOLIO(folio_nr_pages(old) != folio_nr_pages(new), new);\n\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\n\tmemcg = folio_memcg(old);\n\t/*\n\t * Note that it is normal to see !memcg for a hugetlb folio.\n\t * For e.g, itt could have been allocated when memory_hugetlb_accounting\n\t * was not selected.\n\t */\n\tVM_WARN_ON_ONCE_FOLIO(!folio_test_hugetlb(old) && !memcg, old);\n\tif (!memcg)\n\t\treturn;\n\n\t/* Transfer the charge and the css ref */\n\tcommit_charge(new, memcg);\n\told->memcg_data = 0;\n}\n",
      "cve_list": [
        "CVE-2024-42234"
      ],
      "cwe_list": [
        "CWE-415"
      ]
    },
    {
      "project": "linux",
      "filepath": "mm/migrate.c",
      "func_name": "folio_migrate_mapping",
      "func_body": "int folio_migrate_mapping(struct address_space *mapping,\n\t\tstruct folio *newfolio, struct folio *folio, int extra_count)\n{\n\tXA_STATE(xas, &mapping->i_pages, folio_index(folio));\n\tstruct zone *oldzone, *newzone;\n\tint dirty;\n\tint expected_count = folio_expected_refs(mapping, folio) + extra_count;\n\tlong nr = folio_nr_pages(folio);\n\tlong entries, i;\n\n\tif (!mapping) {\n\t\t/* Anonymous page without mapping */\n\t\tif (folio_ref_count(folio) != expected_count)\n\t\t\treturn -EAGAIN;\n\n\t\t/* Take off deferred split queue while frozen and memcg set */\n\t\tif (folio_test_large(folio) &&\n\t\t    folio_test_large_rmappable(folio)) {\n\t\t\tif (!folio_ref_freeze(folio, expected_count))\n\t\t\t\treturn -EAGAIN;\n\t\t\tfolio_undo_large_rmappable(folio);\n\t\t\tfolio_ref_unfreeze(folio, expected_count);\n\t\t}\n\n\t\t/* No turning back from here */\n\t\tnewfolio->index = folio->index;\n\t\tnewfolio->mapping = folio->mapping;\n\t\tif (folio_test_swapbacked(folio))\n\t\t\t__folio_set_swapbacked(newfolio);\n\n\t\treturn MIGRATEPAGE_SUCCESS;\n\t}\n\n\toldzone = folio_zone(folio);\n\tnewzone = folio_zone(newfolio);\n\n\txas_lock_irq(&xas);\n\tif (!folio_ref_freeze(folio, expected_count)) {\n\t\txas_unlock_irq(&xas);\n\t\treturn -EAGAIN;\n\t}\n\n\t/* Take off deferred split queue while frozen and memcg set */\n\tif (folio_test_large(folio) && folio_test_large_rmappable(folio))\n\t\tfolio_undo_large_rmappable(folio);\n\n\t/*\n\t * Now we know that no one else is looking at the folio:\n\t * no turning back from here.\n\t */\n\tnewfolio->index = folio->index;\n\tnewfolio->mapping = folio->mapping;\n\tfolio_ref_add(newfolio, nr); /* add cache reference */\n\tif (folio_test_swapbacked(folio)) {\n\t\t__folio_set_swapbacked(newfolio);\n\t\tif (folio_test_swapcache(folio)) {\n\t\t\tfolio_set_swapcache(newfolio);\n\t\t\tnewfolio->private = folio_get_private(folio);\n\t\t}\n\t\tentries = nr;\n\t} else {\n\t\tVM_BUG_ON_FOLIO(folio_test_swapcache(folio), folio);\n\t\tentries = 1;\n\t}\n\n\t/* Move dirty while page refs frozen and newpage not yet exposed */\n\tdirty = folio_test_dirty(folio);\n\tif (dirty) {\n\t\tfolio_clear_dirty(folio);\n\t\tfolio_set_dirty(newfolio);\n\t}\n\n\t/* Swap cache still stores N entries instead of a high-order entry */\n\tfor (i = 0; i < entries; i++) {\n\t\txas_store(&xas, newfolio);\n\t\txas_next(&xas);\n\t}\n\n\t/*\n\t * Drop cache reference from old page by unfreezing\n\t * to one less reference.\n\t * We know this isn't the last reference.\n\t */\n\tfolio_ref_unfreeze(folio, expected_count - nr);\n\n\txas_unlock(&xas);\n\t/* Leave irq disabled to prevent preemption while updating stats */\n\n\t/*\n\t * If moved to a different zone then also account\n\t * the page for that zone. Other VM counters will be\n\t * taken care of when we establish references to the\n\t * new page and drop references to the old page.\n\t *\n\t * Note that anonymous pages are accounted for\n\t * via NR_FILE_PAGES and NR_ANON_MAPPED if they\n\t * are mapped to swap space.\n\t */\n\tif (newzone != oldzone) {\n\t\tstruct lruvec *old_lruvec, *new_lruvec;\n\t\tstruct mem_cgroup *memcg;\n\n\t\tmemcg = folio_memcg(folio);\n\t\told_lruvec = mem_cgroup_lruvec(memcg, oldzone->zone_pgdat);\n\t\tnew_lruvec = mem_cgroup_lruvec(memcg, newzone->zone_pgdat);\n\n\t\t__mod_lruvec_state(old_lruvec, NR_FILE_PAGES, -nr);\n\t\t__mod_lruvec_state(new_lruvec, NR_FILE_PAGES, nr);\n\t\tif (folio_test_swapbacked(folio) && !folio_test_swapcache(folio)) {\n\t\t\t__mod_lruvec_state(old_lruvec, NR_SHMEM, -nr);\n\t\t\t__mod_lruvec_state(new_lruvec, NR_SHMEM, nr);\n\n\t\t\tif (folio_test_pmd_mappable(folio)) {\n\t\t\t\t__mod_lruvec_state(old_lruvec, NR_SHMEM_THPS, -nr);\n\t\t\t\t__mod_lruvec_state(new_lruvec, NR_SHMEM_THPS, nr);\n\t\t\t}\n\t\t}\n// #ifdef CONFIG_SWAP\n\t\tif (folio_test_swapcache(folio)) {\n\t\t\t__mod_lruvec_state(old_lruvec, NR_SWAPCACHE, -nr);\n\t\t\t__mod_lruvec_state(new_lruvec, NR_SWAPCACHE, nr);\n\t\t}\n#endif\n\t\tif (dirty && mapping_can_writeback(mapping)) {\n\t\t\t__mod_lruvec_state(old_lruvec, NR_FILE_DIRTY, -nr);\n\t\t\t__mod_zone_page_state(oldzone, NR_ZONE_WRITE_PENDING, -nr);\n\t\t\t__mod_lruvec_state(new_lruvec, NR_FILE_DIRTY, nr);\n\t\t\t__mod_zone_page_state(newzone, NR_ZONE_WRITE_PENDING, nr);\n\t\t}\n\t}\n\tlocal_irq_enable();\n\n\treturn MIGRATEPAGE_SUCCESS;\n}\n",
      "cve_list": [
        "CVE-2024-42234"
      ],
      "cwe_list": [
        "CWE-415"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/lantiq_etop.c",
      "func_name": "ltq_etop_free_channel",
      "func_body": "static void\nltq_etop_free_channel(struct net_device *dev, struct ltq_etop_chan *ch)\n{\n\tstruct ltq_etop_priv *priv = netdev_priv(dev);\n\n\tltq_dma_free(&ch->dma);\n\tif (ch->dma.irq)\n\t\tfree_irq(ch->dma.irq, priv);\n\tif (IS_RX(ch->idx)) {\n\t\tstruct ltq_dma_channel *dma = &ch->dma;\n\n\t\tfor (dma->desc = 0; dma->desc < LTQ_DESC_NUM; dma->desc++)\n\t\t\tdev_kfree_skb_any(ch->skb[ch->dma.desc]);\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-41046"
      ],
      "cwe_list": [
        "CWE-415"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/scsi/qla2xxx/qla_os.c",
      "func_name": "qla2x00_mem_alloc",
      "func_body": "static int\nqla2x00_mem_alloc(struct qla_hw_data *ha, uint16_t req_len, uint16_t rsp_len,\n\tstruct req_que **req, struct rsp_que **rsp)\n{\n\tchar\tname[16];\n\tint rc;\n\n\tif (QLA_TGT_MODE_ENABLED() || EDIF_CAP(ha)) {\n\t\tha->vp_map = kcalloc(MAX_MULTI_ID_FABRIC, sizeof(struct qla_vp_map), GFP_KERNEL);\n\t\tif (!ha->vp_map)\n\t\t\tgoto fail;\n\t}\n\n\tha->init_cb = dma_alloc_coherent(&ha->pdev->dev, ha->init_cb_size,\n\t\t&ha->init_cb_dma, GFP_KERNEL);\n\tif (!ha->init_cb)\n\t\tgoto fail_free_vp_map;\n\n\trc = btree_init32(&ha->host_map);\n\tif (rc)\n\t\tgoto fail_free_init_cb;\n\n\tif (qlt_mem_alloc(ha) < 0)\n\t\tgoto fail_free_btree;\n\n\tha->gid_list = dma_alloc_coherent(&ha->pdev->dev,\n\t\tqla2x00_gid_list_size(ha), &ha->gid_list_dma, GFP_KERNEL);\n\tif (!ha->gid_list)\n\t\tgoto fail_free_tgt_mem;\n\n\tha->srb_mempool = mempool_create_slab_pool(SRB_MIN_REQ, srb_cachep);\n\tif (!ha->srb_mempool)\n\t\tgoto fail_free_gid_list;\n\n\tif (IS_P3P_TYPE(ha) || IS_QLA27XX(ha) || (ql2xsecenable && IS_QLA28XX(ha))) {\n\t\t/* Allocate cache for CT6 Ctx. */\n\t\tif (!ctx_cachep) {\n\t\t\tctx_cachep = kmem_cache_create(\"qla2xxx_ctx\",\n\t\t\t\tsizeof(struct ct6_dsd), 0,\n\t\t\t\tSLAB_HWCACHE_ALIGN, NULL);\n\t\t\tif (!ctx_cachep)\n\t\t\t\tgoto fail_free_srb_mempool;\n\t\t}\n\t\tha->ctx_mempool = mempool_create_slab_pool(SRB_MIN_REQ,\n\t\t\tctx_cachep);\n\t\tif (!ha->ctx_mempool)\n\t\t\tgoto fail_free_srb_mempool;\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0021,\n\t\t    \"ctx_cachep=%p ctx_mempool=%p.\\n\",\n\t\t    ctx_cachep, ha->ctx_mempool);\n\t}\n\n\t/* Get memory for cached NVRAM */\n\tha->nvram = kzalloc(MAX_NVRAM_SIZE, GFP_KERNEL);\n\tif (!ha->nvram)\n\t\tgoto fail_free_ctx_mempool;\n\n\tsnprintf(name, sizeof(name), \"%s_%d\", QLA2XXX_DRIVER_NAME,\n\t\tha->pdev->device);\n\tha->s_dma_pool = dma_pool_create(name, &ha->pdev->dev,\n\t\tDMA_POOL_SIZE, 8, 0);\n\tif (!ha->s_dma_pool)\n\t\tgoto fail_free_nvram;\n\n\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0022,\n\t    \"init_cb=%p gid_list=%p, srb_mempool=%p s_dma_pool=%p.\\n\",\n\t    ha->init_cb, ha->gid_list, ha->srb_mempool, ha->s_dma_pool);\n\n\tif (IS_P3P_TYPE(ha) || ql2xenabledif || (IS_QLA28XX(ha) && ql2xsecenable)) {\n\t\tha->dl_dma_pool = dma_pool_create(name, &ha->pdev->dev,\n\t\t\tDSD_LIST_DMA_POOL_SIZE, 8, 0);\n\t\tif (!ha->dl_dma_pool) {\n\t\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x0023,\n\t\t\t    \"Failed to allocate memory for dl_dma_pool.\\n\");\n\t\t\tgoto fail_s_dma_pool;\n\t\t}\n\n\t\tha->fcp_cmnd_dma_pool = dma_pool_create(name, &ha->pdev->dev,\n\t\t\tFCP_CMND_DMA_POOL_SIZE, 8, 0);\n\t\tif (!ha->fcp_cmnd_dma_pool) {\n\t\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x0024,\n\t\t\t    \"Failed to allocate memory for fcp_cmnd_dma_pool.\\n\");\n\t\t\tgoto fail_dl_dma_pool;\n\t\t}\n\n\t\tif (ql2xenabledif) {\n\t\t\tu64 bufsize = DIF_BUNDLING_DMA_POOL_SIZE;\n\t\t\tstruct dsd_dma *dsd, *nxt;\n\t\t\tuint i;\n\t\t\t/* Creata a DMA pool of buffers for DIF bundling */\n\t\t\tha->dif_bundl_pool = dma_pool_create(name,\n\t\t\t    &ha->pdev->dev, DIF_BUNDLING_DMA_POOL_SIZE, 8, 0);\n\t\t\tif (!ha->dif_bundl_pool) {\n\t\t\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0024,\n\t\t\t\t    \"%s: failed create dif_bundl_pool\\n\",\n\t\t\t\t    __func__);\n\t\t\t\tgoto fail_dif_bundl_dma_pool;\n\t\t\t}\n\n\t\t\tINIT_LIST_HEAD(&ha->pool.good.head);\n\t\t\tINIT_LIST_HEAD(&ha->pool.unusable.head);\n\t\t\tha->pool.good.count = 0;\n\t\t\tha->pool.unusable.count = 0;\n\t\t\tfor (i = 0; i < 128; i++) {\n\t\t\t\tdsd = kzalloc(sizeof(*dsd), GFP_ATOMIC);\n\t\t\t\tif (!dsd) {\n\t\t\t\t\tql_dbg_pci(ql_dbg_init, ha->pdev,\n\t\t\t\t\t    0xe0ee, \"%s: failed alloc dsd\\n\",\n\t\t\t\t\t    __func__);\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t}\n\t\t\t\tha->dif_bundle_kallocs++;\n\n\t\t\t\tdsd->dsd_addr = dma_pool_alloc(\n\t\t\t\t    ha->dif_bundl_pool, GFP_ATOMIC,\n\t\t\t\t    &dsd->dsd_list_dma);\n\t\t\t\tif (!dsd->dsd_addr) {\n\t\t\t\t\tql_dbg_pci(ql_dbg_init, ha->pdev,\n\t\t\t\t\t    0xe0ee,\n\t\t\t\t\t    \"%s: failed alloc ->dsd_addr\\n\",\n\t\t\t\t\t    __func__);\n\t\t\t\t\tkfree(dsd);\n\t\t\t\t\tha->dif_bundle_kallocs--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tha->dif_bundle_dma_allocs++;\n\n\t\t\t\t/*\n\t\t\t\t * if DMA buffer crosses 4G boundary,\n\t\t\t\t * put it on bad list\n\t\t\t\t */\n\t\t\t\tif (MSD(dsd->dsd_list_dma) ^\n\t\t\t\t    MSD(dsd->dsd_list_dma + bufsize)) {\n\t\t\t\t\tlist_add_tail(&dsd->list,\n\t\t\t\t\t    &ha->pool.unusable.head);\n\t\t\t\t\tha->pool.unusable.count++;\n\t\t\t\t} else {\n\t\t\t\t\tlist_add_tail(&dsd->list,\n\t\t\t\t\t    &ha->pool.good.head);\n\t\t\t\t\tha->pool.good.count++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* return the good ones back to the pool */\n\t\t\tlist_for_each_entry_safe(dsd, nxt,\n\t\t\t    &ha->pool.good.head, list) {\n\t\t\t\tlist_del(&dsd->list);\n\t\t\t\tdma_pool_free(ha->dif_bundl_pool,\n\t\t\t\t    dsd->dsd_addr, dsd->dsd_list_dma);\n\t\t\t\tha->dif_bundle_dma_allocs--;\n\t\t\t\tkfree(dsd);\n\t\t\t\tha->dif_bundle_kallocs--;\n\t\t\t}\n\n\t\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0024,\n\t\t\t    \"%s: dif dma pool (good=%u unusable=%u)\\n\",\n\t\t\t    __func__, ha->pool.good.count,\n\t\t\t    ha->pool.unusable.count);\n\t\t}\n\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0025,\n\t\t    \"dl_dma_pool=%p fcp_cmnd_dma_pool=%p dif_bundl_pool=%p.\\n\",\n\t\t    ha->dl_dma_pool, ha->fcp_cmnd_dma_pool,\n\t\t    ha->dif_bundl_pool);\n\t}\n\n\t/* Allocate memory for SNS commands */\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha)) {\n\t/* Get consistent memory allocated for SNS commands */\n\t\tha->sns_cmd = dma_alloc_coherent(&ha->pdev->dev,\n\t\tsizeof(struct sns_cmd_pkt), &ha->sns_cmd_dma, GFP_KERNEL);\n\t\tif (!ha->sns_cmd)\n\t\t\tgoto fail_dma_pool;\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0026,\n\t\t    \"sns_cmd: %p.\\n\", ha->sns_cmd);\n\t} else {\n\t/* Get consistent memory allocated for MS IOCB */\n\t\tha->ms_iocb = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL,\n\t\t\t&ha->ms_iocb_dma);\n\t\tif (!ha->ms_iocb)\n\t\t\tgoto fail_dma_pool;\n\t/* Get consistent memory allocated for CT SNS commands */\n\t\tha->ct_sns = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\tsizeof(struct ct_sns_pkt), &ha->ct_sns_dma, GFP_KERNEL);\n\t\tif (!ha->ct_sns)\n\t\t\tgoto fail_free_ms_iocb;\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0027,\n\t\t    \"ms_iocb=%p ct_sns=%p.\\n\",\n\t\t    ha->ms_iocb, ha->ct_sns);\n\t}\n\n\t/* Allocate memory for request ring */\n\t*req = kzalloc(sizeof(struct req_que), GFP_KERNEL);\n\tif (!*req) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x0028,\n\t\t    \"Failed to allocate memory for req.\\n\");\n\t\tgoto fail_req;\n\t}\n\t(*req)->length = req_len;\n\t(*req)->ring = dma_alloc_coherent(&ha->pdev->dev,\n\t\t((*req)->length + 1) * sizeof(request_t),\n\t\t&(*req)->dma, GFP_KERNEL);\n\tif (!(*req)->ring) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x0029,\n\t\t    \"Failed to allocate memory for req_ring.\\n\");\n\t\tgoto fail_req_ring;\n\t}\n\t/* Allocate memory for response ring */\n\t*rsp = kzalloc(sizeof(struct rsp_que), GFP_KERNEL);\n\tif (!*rsp) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x002a,\n\t\t    \"Failed to allocate memory for rsp.\\n\");\n\t\tgoto fail_rsp;\n\t}\n\t(*rsp)->hw = ha;\n\t(*rsp)->length = rsp_len;\n\t(*rsp)->ring = dma_alloc_coherent(&ha->pdev->dev,\n\t\t((*rsp)->length + 1) * sizeof(response_t),\n\t\t&(*rsp)->dma, GFP_KERNEL);\n\tif (!(*rsp)->ring) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x002b,\n\t\t    \"Failed to allocate memory for rsp_ring.\\n\");\n\t\tgoto fail_rsp_ring;\n\t}\n\t(*req)->rsp = *rsp;\n\t(*rsp)->req = *req;\n\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x002c,\n\t    \"req=%p req->length=%d req->ring=%p rsp=%p \"\n\t    \"rsp->length=%d rsp->ring=%p.\\n\",\n\t    *req, (*req)->length, (*req)->ring, *rsp, (*rsp)->length,\n\t    (*rsp)->ring);\n\t/* Allocate memory for NVRAM data for vports */\n\tif (ha->nvram_npiv_size) {\n\t\tha->npiv_info = kcalloc(ha->nvram_npiv_size,\n\t\t\t\t\tsizeof(struct qla_npiv_entry),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!ha->npiv_info) {\n\t\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x002d,\n\t\t\t    \"Failed to allocate memory for npiv_info.\\n\");\n\t\t\tgoto fail_npiv_info;\n\t\t}\n\t} else\n\t\tha->npiv_info = NULL;\n\n\t/* Get consistent memory allocated for EX-INIT-CB. */\n\tif (IS_CNA_CAPABLE(ha) || IS_QLA2031(ha) || IS_QLA27XX(ha) ||\n\t    IS_QLA28XX(ha)) {\n\t\tha->ex_init_cb = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL,\n\t\t    &ha->ex_init_cb_dma);\n\t\tif (!ha->ex_init_cb)\n\t\t\tgoto fail_ex_init_cb;\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x002e,\n\t\t    \"ex_init_cb=%p.\\n\", ha->ex_init_cb);\n\t}\n\n\t/* Get consistent memory allocated for Special Features-CB. */\n\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\tha->sf_init_cb = dma_pool_zalloc(ha->s_dma_pool, GFP_KERNEL,\n\t\t\t\t\t\t&ha->sf_init_cb_dma);\n\t\tif (!ha->sf_init_cb)\n\t\t\tgoto fail_sf_init_cb;\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0199,\n\t\t\t   \"sf_init_cb=%p.\\n\", ha->sf_init_cb);\n\t}\n\n\n\t/* Get consistent memory allocated for Async Port-Database. */\n\tif (!IS_FWI2_CAPABLE(ha)) {\n\t\tha->async_pd = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL,\n\t\t\t&ha->async_pd_dma);\n\t\tif (!ha->async_pd)\n\t\t\tgoto fail_async_pd;\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x002f,\n\t\t    \"async_pd=%p.\\n\", ha->async_pd);\n\t}\n\n\tINIT_LIST_HEAD(&ha->vp_list);\n\n\t/* Allocate memory for our loop_id bitmap */\n\tha->loop_id_map = kcalloc(BITS_TO_LONGS(LOOPID_MAP_SIZE),\n\t\t\t\t  sizeof(long),\n\t\t\t\t  GFP_KERNEL);\n\tif (!ha->loop_id_map)\n\t\tgoto fail_loop_id_map;\n\telse {\n\t\tqla2x00_set_reserved_loop_ids(ha);\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0123,\n\t\t    \"loop_id_map=%p.\\n\", ha->loop_id_map);\n\t}\n\n\tha->sfp_data = dma_alloc_coherent(&ha->pdev->dev,\n\t    SFP_DEV_SIZE, &ha->sfp_data_dma, GFP_KERNEL);\n\tif (!ha->sfp_data) {\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x011b,\n\t\t    \"Unable to allocate memory for SFP read-data.\\n\");\n\t\tgoto fail_sfp_data;\n\t}\n\n\tha->flt = dma_alloc_coherent(&ha->pdev->dev,\n\t    sizeof(struct qla_flt_header) + FLT_REGIONS_SIZE, &ha->flt_dma,\n\t    GFP_KERNEL);\n\tif (!ha->flt) {\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x011b,\n\t\t    \"Unable to allocate memory for FLT.\\n\");\n\t\tgoto fail_flt_buffer;\n\t}\n\n\t/* allocate the purex dma pool */\n\tha->purex_dma_pool = dma_pool_create(name, &ha->pdev->dev,\n\t    ELS_MAX_PAYLOAD, 8, 0);\n\n\tif (!ha->purex_dma_pool) {\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x011b,\n\t\t    \"Unable to allocate purex_dma_pool.\\n\");\n\t\tgoto fail_flt;\n\t}\n\n\tha->elsrej.size = sizeof(struct fc_els_ls_rjt) + 16;\n\tha->elsrej.c = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\t\t\t  ha->elsrej.size,\n\t\t\t\t\t  &ha->elsrej.cdma,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!ha->elsrej.c) {\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0xffff,\n\t\t    \"Alloc failed for els reject cmd.\\n\");\n\t\tgoto fail_elsrej;\n\t}\n\tha->elsrej.c->er_cmd = ELS_LS_RJT;\n\tha->elsrej.c->er_reason = ELS_RJT_LOGIC;\n\tha->elsrej.c->er_explan = ELS_EXPL_UNAB_DATA;\n\n\tha->lsrjt.size = sizeof(struct fcnvme_ls_rjt);\n\tha->lsrjt.c = dma_alloc_coherent(&ha->pdev->dev, ha->lsrjt.size,\n\t\t\t&ha->lsrjt.cdma, GFP_KERNEL);\n\tif (!ha->lsrjt.c) {\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0xffff,\n\t\t\t   \"Alloc failed for nvme fc reject cmd.\\n\");\n\t\tgoto fail_lsrjt;\n\t}\n\n\treturn 0;\n\nfail_lsrjt:\n\tdma_free_coherent(&ha->pdev->dev, ha->elsrej.size,\n\t\t\t  ha->elsrej.c, ha->elsrej.cdma);\nfail_elsrej:\n\tdma_pool_destroy(ha->purex_dma_pool);\nfail_flt:\n\tdma_free_coherent(&ha->pdev->dev, SFP_DEV_SIZE,\n\t    ha->flt, ha->flt_dma);\n\nfail_flt_buffer:\n\tdma_free_coherent(&ha->pdev->dev, SFP_DEV_SIZE,\n\t    ha->sfp_data, ha->sfp_data_dma);\nfail_sfp_data:\n\tkfree(ha->loop_id_map);\nfail_loop_id_map:\n\tdma_pool_free(ha->s_dma_pool, ha->async_pd, ha->async_pd_dma);\nfail_async_pd:\n\tdma_pool_free(ha->s_dma_pool, ha->sf_init_cb, ha->sf_init_cb_dma);\nfail_sf_init_cb:\n\tdma_pool_free(ha->s_dma_pool, ha->ex_init_cb, ha->ex_init_cb_dma);\nfail_ex_init_cb:\n\tkfree(ha->npiv_info);\nfail_npiv_info:\n\tdma_free_coherent(&ha->pdev->dev, ((*rsp)->length + 1) *\n\t\tsizeof(response_t), (*rsp)->ring, (*rsp)->dma);\n\t(*rsp)->ring = NULL;\n\t(*rsp)->dma = 0;\nfail_rsp_ring:\n\tkfree(*rsp);\n\t*rsp = NULL;\nfail_rsp:\n\tdma_free_coherent(&ha->pdev->dev, ((*req)->length + 1) *\n\t\tsizeof(request_t), (*req)->ring, (*req)->dma);\n\t(*req)->ring = NULL;\n\t(*req)->dma = 0;\nfail_req_ring:\n\tkfree(*req);\n\t*req = NULL;\nfail_req:\n\tdma_free_coherent(&ha->pdev->dev, sizeof(struct ct_sns_pkt),\n\t\tha->ct_sns, ha->ct_sns_dma);\n\tha->ct_sns = NULL;\n\tha->ct_sns_dma = 0;\nfail_free_ms_iocb:\n\tdma_pool_free(ha->s_dma_pool, ha->ms_iocb, ha->ms_iocb_dma);\n\tha->ms_iocb = NULL;\n\tha->ms_iocb_dma = 0;\n\n\tif (ha->sns_cmd)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(struct sns_cmd_pkt),\n\t\t    ha->sns_cmd, ha->sns_cmd_dma);\nfail_dma_pool:\n\tif (ql2xenabledif) {\n\t\tstruct dsd_dma *dsd, *nxt;\n\n\t\tlist_for_each_entry_safe(dsd, nxt, &ha->pool.unusable.head,\n\t\t    list) {\n\t\t\tlist_del(&dsd->list);\n\t\t\tdma_pool_free(ha->dif_bundl_pool, dsd->dsd_addr,\n\t\t\t    dsd->dsd_list_dma);\n\t\t\tha->dif_bundle_dma_allocs--;\n\t\t\tkfree(dsd);\n\t\t\tha->dif_bundle_kallocs--;\n\t\t\tha->pool.unusable.count--;\n\t\t}\n\t\tdma_pool_destroy(ha->dif_bundl_pool);\n\t\tha->dif_bundl_pool = NULL;\n\t}\n\nfail_dif_bundl_dma_pool:\n\tif (IS_QLA82XX(ha) || ql2xenabledif) {\n\t\tdma_pool_destroy(ha->fcp_cmnd_dma_pool);\n\t\tha->fcp_cmnd_dma_pool = NULL;\n\t}\nfail_dl_dma_pool:\n\tif (IS_QLA82XX(ha) || ql2xenabledif) {\n\t\tdma_pool_destroy(ha->dl_dma_pool);\n\t\tha->dl_dma_pool = NULL;\n\t}\nfail_s_dma_pool:\n\tdma_pool_destroy(ha->s_dma_pool);\n\tha->s_dma_pool = NULL;\nfail_free_nvram:\n\tkfree(ha->nvram);\n\tha->nvram = NULL;\nfail_free_ctx_mempool:\n\tmempool_destroy(ha->ctx_mempool);\n\tha->ctx_mempool = NULL;\nfail_free_srb_mempool:\n\tmempool_destroy(ha->srb_mempool);\n\tha->srb_mempool = NULL;\nfail_free_gid_list:\n\tdma_free_coherent(&ha->pdev->dev, qla2x00_gid_list_size(ha),\n\tha->gid_list,\n\tha->gid_list_dma);\n\tha->gid_list = NULL;\n\tha->gid_list_dma = 0;\nfail_free_tgt_mem:\n\tqlt_mem_free(ha);\nfail_free_btree:\n\tbtree_destroy32(&ha->host_map);\nfail_free_init_cb:\n\tdma_free_coherent(&ha->pdev->dev, ha->init_cb_size, ha->init_cb,\n\tha->init_cb_dma);\n\tha->init_cb = NULL;\n\tha->init_cb_dma = 0;\nfail_free_vp_map:\n\tkfree(ha->vp_map);\n\tha->vp_map = NULL;\nfail:\n\tql_log(ql_log_fatal, NULL, 0x0030,\n\t    \"Memory allocation failure.\\n\");\n\treturn -ENOMEM;\n}\n",
      "cve_list": [
        "CVE-2024-26930"
      ],
      "cwe_list": [
        "CWE-415"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/nvme/host/core.c",
      "func_name": "nvme_cleanup_cmd",
      "func_body": "void nvme_cleanup_cmd(struct request *req)\n{\n\tif (req->rq_flags & RQF_SPECIAL_PAYLOAD) {\n\t\tstruct nvme_ctrl *ctrl = nvme_req(req)->ctrl;\n\n\t\tif (req->special_vec.bv_page == ctrl->discard_page)\n\t\t\tclear_bit_unlock(0, &ctrl->discard_page_busy);\n\t\telse\n\t\t\tkfree(bvec_virt(&req->special_vec));\n\t\treq->rq_flags &= ~RQF_SPECIAL_PAYLOAD;\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-41073"
      ],
      "cwe_list": [
        "CWE-415"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/misc/fastrpc.c",
      "func_name": "fastrpc_req_mmap",
      "func_body": "static int fastrpc_req_mmap(struct fastrpc_user *fl, char __user *argp)\n{\n\tstruct fastrpc_invoke_args args[3] = { [0 ... 2] = { 0 } };\n\tstruct fastrpc_buf *buf = NULL;\n\tstruct fastrpc_mmap_req_msg req_msg;\n\tstruct fastrpc_mmap_rsp_msg rsp_msg;\n\tstruct fastrpc_phy_page pages;\n\tstruct fastrpc_req_mmap req;\n\tstruct device *dev = fl->sctx->dev;\n\tint err;\n\tu32 sc;\n\n\tif (copy_from_user(&req, argp, sizeof(req)))\n\t\treturn -EFAULT;\n\n\tif (req.flags != ADSP_MMAP_ADD_PAGES && req.flags != ADSP_MMAP_REMOTE_HEAP_ADDR) {\n\t\tdev_err(dev, \"flag not supported 0x%x\\n\", req.flags);\n\n\t\treturn -EINVAL;\n\t}\n\n\tif (req.vaddrin) {\n\t\tdev_err(dev, \"adding user allocated pages is not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (req.flags == ADSP_MMAP_REMOTE_HEAP_ADDR)\n\t\terr = fastrpc_remote_heap_alloc(fl, dev, req.size, &buf);\n\telse\n\t\terr = fastrpc_buf_alloc(fl, dev, req.size, &buf);\n\n\tif (err) {\n\t\tdev_err(dev, \"failed to allocate buffer\\n\");\n\t\treturn err;\n\t}\n\n\treq_msg.pgid = fl->tgid;\n\treq_msg.flags = req.flags;\n\treq_msg.vaddr = req.vaddrin;\n\treq_msg.num = sizeof(pages);\n\n\targs[0].ptr = (u64) (uintptr_t) &req_msg;\n\targs[0].length = sizeof(req_msg);\n\n\tpages.addr = buf->phys;\n\tpages.size = buf->size;\n\n\targs[1].ptr = (u64) (uintptr_t) &pages;\n\targs[1].length = sizeof(pages);\n\n\targs[2].ptr = (u64) (uintptr_t) &rsp_msg;\n\targs[2].length = sizeof(rsp_msg);\n\n\tsc = FASTRPC_SCALARS(FASTRPC_RMID_INIT_MMAP, 2, 1);\n\terr = fastrpc_internal_invoke(fl, true, FASTRPC_INIT_HANDLE, sc,\n\t\t\t\t      &args[0]);\n\tif (err) {\n\t\tdev_err(dev, \"mmap error (len 0x%08llx)\\n\", buf->size);\n\t\tfastrpc_buf_free(buf);\n\t\treturn err;\n\t}\n\n\t/* update the buffer to be able to deallocate the memory on the DSP */\n\tbuf->raddr = (uintptr_t) rsp_msg.vaddr;\n\n\t/* let the client know the address to use */\n\treq.vaddrout = rsp_msg.vaddr;\n\n\t/* Add memory to static PD pool, protection thru hypervisor */\n\tif (req.flags == ADSP_MMAP_REMOTE_HEAP_ADDR && fl->cctx->vmcount) {\n\t\tu64 src_perms = BIT(QCOM_SCM_VMID_HLOS);\n\n\t\terr = qcom_scm_assign_mem(buf->phys, (u64)buf->size,\n\t\t\t&src_perms, fl->cctx->vmperms, fl->cctx->vmcount);\n\t\tif (err) {\n\t\t\tdev_err(fl->sctx->dev, \"Failed to assign memory phys 0x%llx size 0x%llx err %d\",\n\t\t\t\t\tbuf->phys, buf->size, err);\n\t\t\tgoto err_assign;\n\t\t}\n\t}\n\n\tspin_lock(&fl->lock);\n\tlist_add_tail(&buf->node, &fl->mmaps);\n\tspin_unlock(&fl->lock);\n\n\tif (copy_to_user((void __user *)argp, &req, sizeof(req))) {\n\t\terr = -EFAULT;\n\t\tgoto err_assign;\n\t}\n\n\tdev_dbg(dev, \"mmap\\t\\tpt 0x%09lx OK [len 0x%08llx]\\n\",\n\t\tbuf->raddr, buf->size);\n\n\treturn 0;\n\nerr_assign:\n\tfastrpc_req_munmap_impl(fl, buf);\n\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-46741"
      ],
      "cwe_list": [
        "CWE-415"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/firmware/arm_scmi/optee.c",
      "func_name": "scmi_optee_chan_free",
      "func_body": "static int scmi_optee_chan_free(int id, void *p, void *data)\n{\n\tstruct scmi_chan_info *cinfo = p;\n\tstruct scmi_optee_channel *channel = cinfo->transport_info;\n\n\t/*\n\t * Different protocols might share the same chan info, so a previous\n\t * call might have already freed the structure.\n\t */\n\tif (!channel)\n\t\treturn 0;\n\n\tmutex_lock(&scmi_optee_private->mu);\n\tlist_del(&channel->link);\n\tmutex_unlock(&scmi_optee_private->mu);\n\n\tclose_session(scmi_optee_private, channel->tee_session);\n\n\tif (channel->tee_shm) {\n\t\ttee_shm_free(channel->tee_shm);\n\t\tchannel->tee_shm = NULL;\n\t}\n\n\tcinfo->transport_info = NULL;\n\tchannel->cinfo = NULL;\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-49853"
      ],
      "cwe_list": [
        "CWE-415"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/btrfs/zoned.c",
      "func_name": "btrfs_load_zone_info",
      "func_body": "static int btrfs_load_zone_info(struct btrfs_fs_info *fs_info, int zone_idx,\n\t\t\t\tstruct zone_info *info, unsigned long *active,\n\t\t\t\tstruct btrfs_chunk_map *map)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\tstruct btrfs_device *device;\n\tint dev_replace_is_ongoing = 0;\n\tunsigned int nofs_flag;\n\tstruct blk_zone zone;\n\tint ret;\n\n\tinfo->physical = map->stripes[zone_idx].physical;\n\n\tdown_read(&dev_replace->rwsem);\n\tdevice = map->stripes[zone_idx].dev;\n\n\tif (!device->bdev) {\n\t\tup_read(&dev_replace->rwsem);\n\t\tinfo->alloc_offset = WP_MISSING_DEV;\n\t\treturn 0;\n\t}\n\n\t/* Consider a zone as active if we can allow any number of active zones. */\n\tif (!device->zone_info->max_active_zones)\n\t\t__set_bit(zone_idx, active);\n\n\tif (!btrfs_dev_is_sequential(device, info->physical)) {\n\t\tup_read(&dev_replace->rwsem);\n\t\tinfo->alloc_offset = WP_CONVENTIONAL;\n\t\treturn 0;\n\t}\n\n\t/* This zone will be used for allocation, so mark this zone non-empty. */\n\tbtrfs_dev_clear_zone_empty(device, info->physical);\n\n\tdev_replace_is_ongoing = btrfs_dev_replace_is_ongoing(dev_replace);\n\tif (dev_replace_is_ongoing && dev_replace->tgtdev != NULL)\n\t\tbtrfs_dev_clear_zone_empty(dev_replace->tgtdev, info->physical);\n\n\t/*\n\t * The group is mapped to a sequential zone. Get the zone write pointer\n\t * to determine the allocation offset within the zone.\n\t */\n\tWARN_ON(!IS_ALIGNED(info->physical, fs_info->zone_size));\n\tnofs_flag = memalloc_nofs_save();\n\tret = btrfs_get_dev_zone(device, info->physical, &zone);\n\tmemalloc_nofs_restore(nofs_flag);\n\tif (ret) {\n\t\tup_read(&dev_replace->rwsem);\n\t\tif (ret != -EIO && ret != -EOPNOTSUPP)\n\t\t\treturn ret;\n\t\tinfo->alloc_offset = WP_MISSING_DEV;\n\t\treturn 0;\n\t}\n\n\tif (zone.type == BLK_ZONE_TYPE_CONVENTIONAL) {\n\t\tbtrfs_err_in_rcu(fs_info,\n\t\t\"zoned: unexpected conventional zone %llu on device %s (devid %llu)\",\n\t\t\tzone.start << SECTOR_SHIFT, rcu_str_deref(device->name),\n\t\t\tdevice->devid);\n\t\tup_read(&dev_replace->rwsem);\n\t\treturn -EIO;\n\t}\n\n\tinfo->capacity = (zone.capacity << SECTOR_SHIFT);\n\n\tswitch (zone.cond) {\n\tcase BLK_ZONE_COND_OFFLINE:\n\tcase BLK_ZONE_COND_READONLY:\n\t\tbtrfs_err(fs_info,\n\t\t\"zoned: offline/readonly zone %llu on device %s (devid %llu)\",\n\t\t\t  (info->physical >> device->zone_info->zone_size_shift),\n\t\t\t  rcu_str_deref(device->name), device->devid);\n\t\tinfo->alloc_offset = WP_MISSING_DEV;\n\t\tbreak;\n\tcase BLK_ZONE_COND_EMPTY:\n\t\tinfo->alloc_offset = 0;\n\t\tbreak;\n\tcase BLK_ZONE_COND_FULL:\n\t\tinfo->alloc_offset = info->capacity;\n\t\tbreak;\n\tdefault:\n\t\t/* Partially used zone. */\n\t\tinfo->alloc_offset = ((zone.wp - zone.start) << SECTOR_SHIFT);\n\t\t__set_bit(zone_idx, active);\n\t\tbreak;\n\t}\n\n\tup_read(&dev_replace->rwsem);\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-39496"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ipv6/ila/ila_xlat.c",
      "func_name": "ila_xlat_pre_exit_net",
      "func_body": "void ila_xlat_pre_exit_net(struct net *net)\n{\n\tstruct ila_net *ilan = net_generic(net, ila_net_id);\n\n\tif (ilan->xlat.hooks_registered)\n\t\tnf_unregister_net_hooks(net, ila_nf_hook_ops,\n\t\t\t\t\tARRAY_SIZE(ila_nf_hook_ops));\n}\n",
      "cve_list": [
        "CVE-2024-46782"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/nfsd/nfs4state.c",
      "func_name": "nfsd4_cb_getattr_release",
      "func_body": "static void\nnfsd4_cb_getattr_release(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_cb_fattr *ncf =\n\t\t\tcontainer_of(cb, struct nfs4_cb_fattr, ncf_getattr);\n\tstruct nfs4_delegation *dp =\n\t\t\tcontainer_of(ncf, struct nfs4_delegation, dl_cb_fattr);\n\n\tclear_bit(CB_GETATTR_BUSY, &ncf->ncf_cb_flags);\n\twake_up_bit(&ncf->ncf_cb_flags, CB_GETATTR_BUSY);\n\tnfs4_put_stid(&dp->dl_stid);\n}\n",
      "cve_list": [
        "CVE-2024-46696"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/pci/pci.c",
      "func_name": "pci_bridge_wait_for_secondary_bus",
      "func_body": "int pci_bridge_wait_for_secondary_bus(struct pci_dev *dev, char *reset_type)\n{\n\tstruct pci_dev *child __free(pci_dev_put) = NULL;\n\tint delay;\n\n\tif (pci_dev_is_disconnected(dev))\n\t\treturn 0;\n\n\tif (!pci_is_bridge(dev))\n\t\treturn 0;\n\n\tdown_read(&pci_bus_sem);\n\n\t/*\n\t * We only deal with devices that are present currently on the bus.\n\t * For any hot-added devices the access delay is handled in pciehp\n\t * board_added(). In case of ACPI hotplug the firmware is expected\n\t * to configure the devices before OS is notified.\n\t */\n\tif (!dev->subordinate || list_empty(&dev->subordinate->devices)) {\n\t\tup_read(&pci_bus_sem);\n\t\treturn 0;\n\t}\n\n\t/* Take d3cold_delay requirements into account */\n\tdelay = pci_bus_max_d3cold_delay(dev->subordinate);\n\tif (!delay) {\n\t\tup_read(&pci_bus_sem);\n\t\treturn 0;\n\t}\n\n\tchild = pci_dev_get(list_first_entry(&dev->subordinate->devices,\n\t\t\t\t\t     struct pci_dev, bus_list));\n\tup_read(&pci_bus_sem);\n\n\t/*\n\t * Conventional PCI and PCI-X we need to wait Tpvrh + Trhfa before\n\t * accessing the device after reset (that is 1000 ms + 100 ms).\n\t */\n\tif (!pci_is_pcie(dev)) {\n\t\tpci_dbg(dev, \"waiting %d ms for secondary bus\\n\", 1000 + delay);\n\t\tmsleep(1000 + delay);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * For PCIe downstream and root ports that do not support speeds\n\t * greater than 5 GT/s need to wait minimum 100 ms. For higher\n\t * speeds (gen3) we need to wait first for the data link layer to\n\t * become active.\n\t *\n\t * However, 100 ms is the minimum and the PCIe spec says the\n\t * software must allow at least 1s before it can determine that the\n\t * device that did not respond is a broken device. Also device can\n\t * take longer than that to respond if it indicates so through Request\n\t * Retry Status completions.\n\t *\n\t * Therefore we wait for 100 ms and check for the device presence\n\t * until the timeout expires.\n\t */\n\tif (!pcie_downstream_port(dev))\n\t\treturn 0;\n\n\tif (pcie_get_speed_cap(dev) <= PCIE_SPEED_5_0GT) {\n\t\tu16 status;\n\n\t\tpci_dbg(dev, \"waiting %d ms for downstream link\\n\", delay);\n\t\tmsleep(delay);\n\n\t\tif (!pci_dev_wait(child, reset_type, PCI_RESET_WAIT - delay))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * If the port supports active link reporting we now check\n\t\t * whether the link is active and if not bail out early with\n\t\t * the assumption that the device is not present anymore.\n\t\t */\n\t\tif (!dev->link_active_reporting)\n\t\t\treturn -ENOTTY;\n\n\t\tpcie_capability_read_word(dev, PCI_EXP_LNKSTA, &status);\n\t\tif (!(status & PCI_EXP_LNKSTA_DLLLA))\n\t\t\treturn -ENOTTY;\n\n\t\treturn pci_dev_wait(child, reset_type,\n\t\t\t\t    PCIE_RESET_READY_POLL_MS - PCI_RESET_WAIT);\n\t}\n\n\tpci_dbg(dev, \"waiting %d ms for downstream link, after activation\\n\",\n\t\tdelay);\n\tif (!pcie_wait_for_link_delay(dev, true, delay)) {\n\t\t/* Did not train, no need to wait any further */\n\t\tpci_info(dev, \"Data Link Layer Link Active not set in 1000 msec\\n\");\n\t\treturn -ENOTTY;\n\t}\n\n\treturn pci_dev_wait(child, reset_type,\n\t\t\t    PCIE_RESET_READY_POLL_MS - delay);\n}\n",
      "cve_list": [
        "CVE-2024-42302"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/locks.c",
      "func_name": "posix_lock_inode",
      "func_body": "static int posix_lock_inode(struct inode *inode, struct file_lock *request,\n\t\t\t    struct file_lock *conflock)\n{\n\tstruct file_lock *fl, *tmp;\n\tstruct file_lock *new_fl = NULL;\n\tstruct file_lock *new_fl2 = NULL;\n\tstruct file_lock *left = NULL;\n\tstruct file_lock *right = NULL;\n\tstruct file_lock_context *ctx;\n\tint error;\n\tbool added = false;\n\tLIST_HEAD(dispose);\n\tvoid *owner;\n\tvoid (*func)(void);\n\n\tctx = locks_get_lock_context(inode, request->c.flc_type);\n\tif (!ctx)\n\t\treturn lock_is_unlock(request) ? 0 : -ENOMEM;\n\n\t/*\n\t * We may need two file_lock structures for this operation,\n\t * so we get them in advance to avoid races.\n\t *\n\t * In some cases we can be sure, that no new locks will be needed\n\t */\n\tif (!(request->c.flc_flags & FL_ACCESS) &&\n\t    (request->c.flc_type != F_UNLCK ||\n\t     request->fl_start != 0 || request->fl_end != OFFSET_MAX)) {\n\t\tnew_fl = locks_alloc_lock();\n\t\tnew_fl2 = locks_alloc_lock();\n\t}\n\nretry:\n\tpercpu_down_read(&file_rwsem);\n\tspin_lock(&ctx->flc_lock);\n\t/*\n\t * New lock request. Walk all POSIX locks and look for conflicts. If\n\t * there are any, either return error or put the request on the\n\t * blocker's list of waiters and the global blocked_hash.\n\t */\n\tif (request->c.flc_type != F_UNLCK) {\n\t\tlist_for_each_entry(fl, &ctx->flc_posix, c.flc_list) {\n\t\t\tif (!posix_locks_conflict(&request->c, &fl->c))\n\t\t\t\tcontinue;\n\t\t\tif (fl->fl_lmops && fl->fl_lmops->lm_lock_expirable\n\t\t\t\t&& (*fl->fl_lmops->lm_lock_expirable)(fl)) {\n\t\t\t\towner = fl->fl_lmops->lm_mod_owner;\n\t\t\t\tfunc = fl->fl_lmops->lm_expire_lock;\n\t\t\t\t__module_get(owner);\n\t\t\t\tspin_unlock(&ctx->flc_lock);\n\t\t\t\tpercpu_up_read(&file_rwsem);\n\t\t\t\t(*func)();\n\t\t\t\tmodule_put(owner);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tif (conflock)\n\t\t\t\tlocks_copy_conflock(conflock, fl);\n\t\t\terror = -EAGAIN;\n\t\t\tif (!(request->c.flc_flags & FL_SLEEP))\n\t\t\t\tgoto out;\n\t\t\t/*\n\t\t\t * Deadlock detection and insertion into the blocked\n\t\t\t * locks list must be done while holding the same lock!\n\t\t\t */\n\t\t\terror = -EDEADLK;\n\t\t\tspin_lock(&blocked_lock_lock);\n\t\t\t/*\n\t\t\t * Ensure that we don't find any locks blocked on this\n\t\t\t * request during deadlock detection.\n\t\t\t */\n\t\t\t__locks_wake_up_blocks(&request->c);\n\t\t\tif (likely(!posix_locks_deadlock(request, fl))) {\n\t\t\t\terror = FILE_LOCK_DEFERRED;\n\t\t\t\t__locks_insert_block(&fl->c, &request->c,\n\t\t\t\t\t\t     posix_locks_conflict);\n\t\t\t}\n\t\t\tspin_unlock(&blocked_lock_lock);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* If we're just looking for a conflict, we're done. */\n\terror = 0;\n\tif (request->c.flc_flags & FL_ACCESS)\n\t\tgoto out;\n\n\t/* Find the first old lock with the same owner as the new lock */\n\tlist_for_each_entry(fl, &ctx->flc_posix, c.flc_list) {\n\t\tif (posix_same_owner(&request->c, &fl->c))\n\t\t\tbreak;\n\t}\n\n\t/* Process locks with this owner. */\n\tlist_for_each_entry_safe_from(fl, tmp, &ctx->flc_posix, c.flc_list) {\n\t\tif (!posix_same_owner(&request->c, &fl->c))\n\t\t\tbreak;\n\n\t\t/* Detect adjacent or overlapping regions (if same lock type) */\n\t\tif (request->c.flc_type == fl->c.flc_type) {\n\t\t\t/* In all comparisons of start vs end, use\n\t\t\t * \"start - 1\" rather than \"end + 1\". If end\n\t\t\t * is OFFSET_MAX, end + 1 will become negative.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start - 1)\n\t\t\t\tcontinue;\n\t\t\t/* If the next lock in the list has entirely bigger\n\t\t\t * addresses than the new one, insert the lock here.\n\t\t\t */\n\t\t\tif (fl->fl_start - 1 > request->fl_end)\n\t\t\t\tbreak;\n\n\t\t\t/* If we come here, the new and old lock are of the\n\t\t\t * same type and adjacent or overlapping. Make one\n\t\t\t * lock yielding from the lower start address of both\n\t\t\t * locks to the higher end address.\n\t\t\t */\n\t\t\tif (fl->fl_start > request->fl_start)\n\t\t\t\tfl->fl_start = request->fl_start;\n\t\t\telse\n\t\t\t\trequest->fl_start = fl->fl_start;\n\t\t\tif (fl->fl_end < request->fl_end)\n\t\t\t\tfl->fl_end = request->fl_end;\n\t\t\telse\n\t\t\t\trequest->fl_end = fl->fl_end;\n\t\t\tif (added) {\n\t\t\t\tlocks_delete_lock_ctx(&fl->c, &dispose);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trequest = fl;\n\t\t\tadded = true;\n\t\t} else {\n\t\t\t/* Processing for different lock types is a bit\n\t\t\t * more complex.\n\t\t\t */\n\t\t\tif (fl->fl_end < request->fl_start)\n\t\t\t\tcontinue;\n\t\t\tif (fl->fl_start > request->fl_end)\n\t\t\t\tbreak;\n\t\t\tif (lock_is_unlock(request))\n\t\t\t\tadded = true;\n\t\t\tif (fl->fl_start < request->fl_start)\n\t\t\t\tleft = fl;\n\t\t\t/* If the next lock in the list has a higher end\n\t\t\t * address than the new one, insert the new one here.\n\t\t\t */\n\t\t\tif (fl->fl_end > request->fl_end) {\n\t\t\t\tright = fl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fl->fl_start >= request->fl_start) {\n\t\t\t\t/* The new lock completely replaces an old\n\t\t\t\t * one (This may happen several times).\n\t\t\t\t */\n\t\t\t\tif (added) {\n\t\t\t\t\tlocks_delete_lock_ctx(&fl->c, &dispose);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Replace the old lock with new_fl, and\n\t\t\t\t * remove the old one. It's safe to do the\n\t\t\t\t * insert here since we know that we won't be\n\t\t\t\t * using new_fl later, and that the lock is\n\t\t\t\t * just replacing an existing lock.\n\t\t\t\t */\n\t\t\t\terror = -ENOLCK;\n\t\t\t\tif (!new_fl)\n\t\t\t\t\tgoto out;\n\t\t\t\tlocks_copy_lock(new_fl, request);\n\t\t\t\tlocks_move_blocks(new_fl, request);\n\t\t\t\trequest = new_fl;\n\t\t\t\tnew_fl = NULL;\n\t\t\t\tlocks_insert_lock_ctx(&request->c,\n\t\t\t\t\t\t      &fl->c.flc_list);\n\t\t\t\tlocks_delete_lock_ctx(&fl->c, &dispose);\n\t\t\t\tadded = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * The above code only modifies existing locks in case of merging or\n\t * replacing. If new lock(s) need to be inserted all modifications are\n\t * done below this, so it's safe yet to bail out.\n\t */\n\terror = -ENOLCK; /* \"no luck\" */\n\tif (right && left == right && !new_fl2)\n\t\tgoto out;\n\n\terror = 0;\n\tif (!added) {\n\t\tif (lock_is_unlock(request)) {\n\t\t\tif (request->c.flc_flags & FL_EXISTS)\n\t\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!new_fl) {\n\t\t\terror = -ENOLCK;\n\t\t\tgoto out;\n\t\t}\n\t\tlocks_copy_lock(new_fl, request);\n\t\tlocks_move_blocks(new_fl, request);\n\t\tlocks_insert_lock_ctx(&new_fl->c, &fl->c.flc_list);\n\t\tfl = new_fl;\n\t\tnew_fl = NULL;\n\t}\n\tif (right) {\n\t\tif (left == right) {\n\t\t\t/* The new lock breaks the old one in two pieces,\n\t\t\t * so we have to use the second new lock.\n\t\t\t */\n\t\t\tleft = new_fl2;\n\t\t\tnew_fl2 = NULL;\n\t\t\tlocks_copy_lock(left, right);\n\t\t\tlocks_insert_lock_ctx(&left->c, &fl->c.flc_list);\n\t\t}\n\t\tright->fl_start = request->fl_end + 1;\n\t\tlocks_wake_up_blocks(&right->c);\n\t}\n\tif (left) {\n\t\tleft->fl_end = request->fl_start - 1;\n\t\tlocks_wake_up_blocks(&left->c);\n\t}\n out:\n\ttrace_posix_lock_inode(inode, request, error);\n\tspin_unlock(&ctx->flc_lock);\n\tpercpu_up_read(&file_rwsem);\n\t/*\n\t * Free any unused locks.\n\t */\n\tif (new_fl)\n\t\tlocks_free_lock(new_fl);\n\tif (new_fl2)\n\t\tlocks_free_lock(new_fl2);\n\tlocks_dispose_list(&dispose);\n\n\treturn error;\n}\n",
      "cve_list": [
        "CVE-2024-41049"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "block/bfq-iosched.c",
      "func_name": "bfq_waker_bfqq",
      "func_body": "static struct bfq_queue *bfq_waker_bfqq(struct bfq_queue *bfqq)\n{\n\tstruct bfq_queue *new_bfqq = bfqq->new_bfqq;\n\tstruct bfq_queue *waker_bfqq = bfqq->waker_bfqq;\n\n\tif (!waker_bfqq)\n\t\treturn NULL;\n\n\twhile (new_bfqq) {\n\t\tif (new_bfqq == waker_bfqq) {\n\t\t\t/*\n\t\t\t * If waker_bfqq is in the merge chain, and current\n\t\t\t * is the only procress.\n\t\t\t */\n\t\t\tif (bfqq_process_refs(waker_bfqq) == 1)\n\t\t\t\treturn NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tnew_bfqq = new_bfqq->new_bfqq;\n\t}\n\n\treturn waker_bfqq;\n}\n",
      "cve_list": [
        "CVE-2024-49854"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/cgroup/cpuset.c",
      "func_name": "proc_cpuset_show",
      "func_body": "int proc_cpuset_show(struct seq_file *m, struct pid_namespace *ns,\n\t\t     struct pid *pid, struct task_struct *tsk)\n{\n\tchar *buf;\n\tstruct cgroup_subsys_state *css;\n\tint retval;\n\n\tretval = -ENOMEM;\n\tbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto out;\n\n\trcu_read_lock();\n\tspin_lock_irq(&css_set_lock);\n\tcss = task_css(tsk, cpuset_cgrp_id);\n\tretval = cgroup_path_ns_locked(css->cgroup, buf, PATH_MAX,\n\t\t\t\t       current->nsproxy->cgroup_ns);\n\tspin_unlock_irq(&css_set_lock);\n\trcu_read_unlock();\n\n\tif (retval == -E2BIG)\n\t\tretval = -ENAMETOOLONG;\n\tif (retval < 0)\n\t\tgoto out_free;\n\tseq_puts(m, buf);\n\tseq_putc(m, '\\n');\n\tretval = 0;\nout_free:\n\tkfree(buf);\nout:\n\treturn retval;\n}\n",
      "cve_list": [
        "CVE-2024-43853"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/sched/sch_ingress.c",
      "func_name": "ingress_destroy",
      "func_body": "static void ingress_destroy(struct Qdisc *sch)\n{\n\tstruct ingress_sched_data *q = qdisc_priv(sch);\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct bpf_mprog_entry *entry = rtnl_dereference(dev->tcx_ingress);\n\n\tif (sch->parent != TC_H_INGRESS)\n\t\treturn;\n\n\ttcf_block_put_ext(q->block, sch, &q->block_info);\n\n\tif (entry) {\n\t\ttcx_miniq_dec(entry);\n\t\tif (!tcx_entry_is_active(entry)) {\n\t\t\ttcx_entry_update(dev, NULL, true);\n\t\t\ttcx_entry_free(entry);\n\t\t}\n\t}\n\n\tnet_dec_ingress_queue();\n}\n",
      "cve_list": [
        "CVE-2024-41010"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/sched/sch_ingress.c",
      "func_name": "clsact_init",
      "func_body": "static int clsact_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct clsact_sched_data *q = qdisc_priv(sch);\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct bpf_mprog_entry *entry;\n\tbool created;\n\tint err;\n\n\tif (sch->parent != TC_H_CLSACT)\n\t\treturn -EOPNOTSUPP;\n\n\tnet_inc_ingress_queue();\n\tnet_inc_egress_queue();\n\n\tentry = tcx_entry_fetch_or_create(dev, true, &created);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\ttcx_miniq_inc(entry);\n\tmini_qdisc_pair_init(&q->miniqp_ingress, sch, &tcx_entry(entry)->miniq);\n\tif (created)\n\t\ttcx_entry_update(dev, entry, true);\n\n\tq->ingress_block_info.binder_type = FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS;\n\tq->ingress_block_info.chain_head_change = clsact_chain_head_change;\n\tq->ingress_block_info.chain_head_change_priv = &q->miniqp_ingress;\n\n\terr = tcf_block_get_ext(&q->ingress_block, sch, &q->ingress_block_info,\n\t\t\t\textack);\n\tif (err)\n\t\treturn err;\n\n\tmini_qdisc_pair_block_init(&q->miniqp_ingress, q->ingress_block);\n\n\tentry = tcx_entry_fetch_or_create(dev, false, &created);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\ttcx_miniq_inc(entry);\n\tmini_qdisc_pair_init(&q->miniqp_egress, sch, &tcx_entry(entry)->miniq);\n\tif (created)\n\t\ttcx_entry_update(dev, entry, false);\n\n\tq->egress_block_info.binder_type = FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS;\n\tq->egress_block_info.chain_head_change = clsact_chain_head_change;\n\tq->egress_block_info.chain_head_change_priv = &q->miniqp_egress;\n\n\treturn tcf_block_get_ext(&q->egress_block, sch, &q->egress_block_info, extack);\n}\n",
      "cve_list": [
        "CVE-2024-41010"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/sched/sch_ingress.c",
      "func_name": "clsact_destroy",
      "func_body": "static void clsact_destroy(struct Qdisc *sch)\n{\n\tstruct clsact_sched_data *q = qdisc_priv(sch);\n\tstruct net_device *dev = qdisc_dev(sch);\n\tstruct bpf_mprog_entry *ingress_entry = rtnl_dereference(dev->tcx_ingress);\n\tstruct bpf_mprog_entry *egress_entry = rtnl_dereference(dev->tcx_egress);\n\n\tif (sch->parent != TC_H_CLSACT)\n\t\treturn;\n\n\ttcf_block_put_ext(q->ingress_block, sch, &q->ingress_block_info);\n\ttcf_block_put_ext(q->egress_block, sch, &q->egress_block_info);\n\n\tif (ingress_entry) {\n\t\ttcx_miniq_dec(ingress_entry);\n\t\tif (!tcx_entry_is_active(ingress_entry)) {\n\t\t\ttcx_entry_update(dev, NULL, true);\n\t\t\ttcx_entry_free(ingress_entry);\n\t\t}\n\t}\n\n\tif (egress_entry) {\n\t\ttcx_miniq_dec(egress_entry);\n\t\tif (!tcx_entry_is_active(egress_entry)) {\n\t\t\ttcx_entry_update(dev, NULL, false);\n\t\t\ttcx_entry_free(egress_entry);\n\t\t}\n\t}\n\n\tnet_dec_ingress_queue();\n\tnet_dec_egress_queue();\n}\n",
      "cve_list": [
        "CVE-2024-41010"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/sched/act_ct.c",
      "func_name": "tcf_ct_act",
      "func_body": "TC_INDIRECT_SCOPE int tcf_ct_act(struct sk_buff *skb, const struct tc_action *a,\n\t\t\t\t struct tcf_result *res)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tenum ip_conntrack_info ctinfo;\n\tstruct tcf_ct *c = to_ct(a);\n\tstruct nf_conn *tmpl = NULL;\n\tstruct nf_hook_state state;\n\tbool cached, commit, clear;\n\tint nh_ofs, err, retval;\n\tstruct tcf_ct_params *p;\n\tbool add_helper = false;\n\tbool skip_add = false;\n\tbool defrag = false;\n\tstruct nf_conn *ct;\n\tu8 family;\n\n\tp = rcu_dereference_bh(c->params);\n\n\tretval = READ_ONCE(c->tcf_action);\n\tcommit = p->ct_action & TCA_CT_ACT_COMMIT;\n\tclear = p->ct_action & TCA_CT_ACT_CLEAR;\n\ttmpl = p->tmpl;\n\n\ttcf_lastuse_update(&c->tcf_tm);\n\ttcf_action_update_bstats(&c->common, skb);\n\n\tif (clear) {\n\t\ttc_skb_cb(skb)->post_ct = false;\n\t\tct = nf_ct_get(skb, &ctinfo);\n\t\tif (ct) {\n\t\t\tnf_ct_put(ct);\n\t\t\tnf_ct_set(skb, NULL, IP_CT_UNTRACKED);\n\t\t}\n\n\t\tgoto out_clear;\n\t}\n\n\tfamily = tcf_ct_skb_nf_family(skb);\n\tif (family == NFPROTO_UNSPEC)\n\t\tgoto drop;\n\n\t/* The conntrack module expects to be working at L3.\n\t * We also try to pull the IPv4/6 header to linear area\n\t */\n\tnh_ofs = skb_network_offset(skb);\n\tskb_pull_rcsum(skb, nh_ofs);\n\terr = tcf_ct_handle_fragments(net, skb, family, p->zone, &defrag);\n\tif (err)\n\t\tgoto out_frag;\n\n\terr = nf_ct_skb_network_trim(skb, family);\n\tif (err)\n\t\tgoto drop;\n\n\t/* If we are recirculating packets to match on ct fields and\n\t * committing with a separate ct action, then we don't need to\n\t * actually run the packet through conntrack twice unless it's for a\n\t * different zone.\n\t */\n\tcached = tcf_ct_skb_nfct_cached(net, skb, p);\n\tif (!cached) {\n\t\tif (tcf_ct_flow_table_lookup(p, skb, family)) {\n\t\t\tskip_add = true;\n\t\t\tgoto do_nat;\n\t\t}\n\n\t\t/* Associate skb with specified zone. */\n\t\tif (tmpl) {\n\t\t\tnf_conntrack_put(skb_nfct(skb));\n\t\t\tnf_conntrack_get(&tmpl->ct_general);\n\t\t\tnf_ct_set(skb, tmpl, IP_CT_NEW);\n\t\t}\n\n\t\tstate.hook = NF_INET_PRE_ROUTING;\n\t\tstate.net = net;\n\t\tstate.pf = family;\n\t\terr = nf_conntrack_in(skb, &state);\n\t\tif (err != NF_ACCEPT)\n\t\t\tgoto out_push;\n\t}\n\ndo_nat:\n\tct = nf_ct_get(skb, &ctinfo);\n\tif (!ct)\n\t\tgoto out_push;\n\tnf_ct_deliver_cached_events(ct);\n\tnf_conn_act_ct_ext_fill(skb, ct, ctinfo);\n\n\terr = tcf_ct_act_nat(skb, ct, ctinfo, p->ct_action, &p->range, commit);\n\tif (err != NF_ACCEPT)\n\t\tgoto drop;\n\n\tif (!nf_ct_is_confirmed(ct) && commit && p->helper && !nfct_help(ct)) {\n\t\terr = __nf_ct_try_assign_helper(ct, p->tmpl, GFP_ATOMIC);\n\t\tif (err)\n\t\t\tgoto drop;\n\t\tadd_helper = true;\n\t\tif (p->ct_action & TCA_CT_ACT_NAT && !nfct_seqadj(ct)) {\n\t\t\tif (!nfct_seqadj_ext_add(ct))\n\t\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (nf_ct_is_confirmed(ct) ? ((!cached && !skip_add) || add_helper) : commit) {\n\t\tif (nf_ct_helper(skb, ct, ctinfo, family) != NF_ACCEPT)\n\t\t\tgoto drop;\n\t}\n\n\tif (commit) {\n\t\ttcf_ct_act_set_mark(ct, p->mark, p->mark_mask);\n\t\ttcf_ct_act_set_labels(ct, p->labels, p->labels_mask);\n\n\t\tif (!nf_ct_is_confirmed(ct))\n\t\t\tnf_conn_act_ct_ext_add(skb, ct, ctinfo);\n\n\t\t/* This will take care of sending queued events\n\t\t * even if the connection is already confirmed.\n\t\t */\n\t\tif (nf_conntrack_confirm(skb) != NF_ACCEPT)\n\t\t\tgoto drop;\n\n\t\t/* The ct may be dropped if a clash has been resolved,\n\t\t * so it's necessary to retrieve it from skb again to\n\t\t * prevent UAF.\n\t\t */\n\t\tct = nf_ct_get(skb, &ctinfo);\n\t\tif (!ct)\n\t\t\tskip_add = true;\n\t}\n\n\tif (!skip_add)\n\t\ttcf_ct_flow_table_process_conn(p->ct_ft, ct, ctinfo);\n\nout_push:\n\tskb_push_rcsum(skb, nh_ofs);\n\n\ttc_skb_cb(skb)->post_ct = true;\n\ttc_skb_cb(skb)->zone = p->zone;\nout_clear:\n\tif (defrag)\n\t\tqdisc_skb_cb(skb)->pkt_len = skb->len;\n\treturn retval;\n\nout_frag:\n\tif (err != -EINPROGRESS)\n\t\ttcf_action_inc_drop_qstats(&c->common);\n\treturn TC_ACT_CONSUMED;\n\ndrop:\n\ttcf_action_inc_drop_qstats(&c->common);\n\treturn TC_ACT_SHOT;\n}\n",
      "cve_list": [
        "CVE-2024-41040"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/bpf/syscall.c",
      "func_name": "bpf_link_free",
      "func_body": "static void bpf_link_free(struct bpf_link *link)\n{\n\tconst struct bpf_link_ops *ops = link->ops;\n\tbool sleepable = false;\n\n\tbpf_link_free_id(link->id);\n\tif (link->prog) {\n\t\tsleepable = link->prog->sleepable;\n\t\t/* detach BPF program, clean up used resources */\n\t\tops->release(link);\n\t\tbpf_prog_put(link->prog);\n\t}\n\tif (ops->dealloc_deferred) {\n\t\t/* schedule BPF link deallocation; if underlying BPF program\n\t\t * is sleepable, we need to first wait for RCU tasks trace\n\t\t * sync, then go through \"classic\" RCU grace period\n\t\t */\n\t\tif (sleepable)\n\t\t\tcall_rcu_tasks_trace(&link->rcu, bpf_link_defer_dealloc_mult_rcu_gp);\n\t\telse\n\t\t\tcall_rcu(&link->rcu, bpf_link_defer_dealloc_rcu_gp);\n\t} else if (ops->dealloc)\n\t\tops->dealloc(link);\n}\n",
      "cve_list": [
        "CVE-2024-40909"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/intel/idpf/idpf_txrx.c",
      "func_name": "idpf_vport_intr_rel",
      "func_body": "void idpf_vport_intr_rel(struct idpf_vport *vport)\n{\n\tfor (u32 v_idx = 0; v_idx < vport->num_q_vectors; v_idx++) {\n\t\tstruct idpf_q_vector *q_vector = &vport->q_vectors[v_idx];\n\n\t\tkfree(q_vector->complq);\n\t\tq_vector->complq = NULL;\n\t\tkfree(q_vector->bufq);\n\t\tq_vector->bufq = NULL;\n\t\tkfree(q_vector->tx);\n\t\tq_vector->tx = NULL;\n\t\tkfree(q_vector->rx);\n\t\tq_vector->rx = NULL;\n\n\t\tfree_cpumask_var(q_vector->affinity_mask);\n\t}\n\n\tkfree(vport->q_vectors);\n\tvport->q_vectors = NULL;\n}\n",
      "cve_list": [
        "CVE-2024-44932"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ipv6/ip6_output.c",
      "func_name": "ip6_xmit",
      "func_body": "int ip6_xmit(const struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6,\n\t     __u32 mark, struct ipv6_txoptions *opt, int tclass, u32 priority)\n{\n\tstruct net *net = sock_net(sk);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *first_hop = &fl6->daddr;\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct net_device *dev = dst->dev;\n\tstruct inet6_dev *idev = ip6_dst_idev(dst);\n\tstruct hop_jumbo_hdr *hop_jumbo;\n\tint hoplen = sizeof(*hop_jumbo);\n\tunsigned int head_room;\n\tstruct ipv6hdr *hdr;\n\tu8  proto = fl6->flowi6_proto;\n\tint seg_len = skb->len;\n\tint hlimit = -1;\n\tu32 mtu;\n\n\thead_room = sizeof(struct ipv6hdr) + hoplen + LL_RESERVED_SPACE(dev);\n\tif (opt)\n\t\thead_room += opt->opt_nflen + opt->opt_flen;\n\n\tif (unlikely(head_room > skb_headroom(skb))) {\n\t\t/* Make sure idev stays alive */\n\t\trcu_read_lock();\n\t\tskb = skb_expand_head(skb, head_room);\n\t\tif (!skb) {\n\t\t\tIP6_INC_STATS(net, idev, IPSTATS_MIB_OUTDISCARDS);\n\t\t\trcu_read_unlock();\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (opt) {\n\t\tseg_len += opt->opt_nflen + opt->opt_flen;\n\n\t\tif (opt->opt_flen)\n\t\t\tipv6_push_frag_opts(skb, opt, &proto);\n\n\t\tif (opt->opt_nflen)\n\t\t\tipv6_push_nfrag_opts(skb, opt, &proto, &first_hop,\n\t\t\t\t\t     &fl6->saddr);\n\t}\n\n\tif (unlikely(seg_len > IPV6_MAXPLEN)) {\n\t\thop_jumbo = skb_push(skb, hoplen);\n\n\t\thop_jumbo->nexthdr = proto;\n\t\thop_jumbo->hdrlen = 0;\n\t\thop_jumbo->tlv_type = IPV6_TLV_JUMBO;\n\t\thop_jumbo->tlv_len = 4;\n\t\thop_jumbo->jumbo_payload_len = htonl(seg_len + hoplen);\n\n\t\tproto = IPPROTO_HOPOPTS;\n\t\tseg_len = 0;\n\t\tIP6CB(skb)->flags |= IP6SKB_FAKEJUMBO;\n\t}\n\n\tskb_push(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\thdr = ipv6_hdr(skb);\n\n\t/*\n\t *\tFill in the IPv6 header\n\t */\n\tif (np)\n\t\thlimit = READ_ONCE(np->hop_limit);\n\tif (hlimit < 0)\n\t\thlimit = ip6_dst_hoplimit(dst);\n\n\tip6_flow_hdr(hdr, tclass, ip6_make_flowlabel(net, skb, fl6->flowlabel,\n\t\t\t\tip6_autoflowlabel(net, sk), fl6));\n\n\thdr->payload_len = htons(seg_len);\n\thdr->nexthdr = proto;\n\thdr->hop_limit = hlimit;\n\n\thdr->saddr = fl6->saddr;\n\thdr->daddr = *first_hop;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb->priority = priority;\n\tskb->mark = mark;\n\n\tmtu = dst_mtu(dst);\n\tif ((skb->len <= mtu) || skb->ignore_df || skb_is_gso(skb)) {\n\t\tIP6_INC_STATS(net, idev, IPSTATS_MIB_OUTREQUESTS);\n\n\t\t/* if egress device is enslaved to an L3 master device pass the\n\t\t * skb to its handler for processing\n\t\t */\n\t\tskb = l3mdev_ip6_out((struct sock *)sk, skb);\n\t\tif (unlikely(!skb))\n\t\t\treturn 0;\n\n\t\t/* hooks should never assume socket lock is held.\n\t\t * we promote our socket to non const\n\t\t */\n\t\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT,\n\t\t\t       net, (struct sock *)sk, skb, NULL, dev,\n\t\t\t       dst_output);\n\t}\n\n\tskb->dev = dev;\n\t/* ipv6_local_error() does not require socket lock,\n\t * we promote our socket to non const\n\t */\n\tipv6_local_error((struct sock *)sk, EMSGSIZE, fl6, mtu);\n\n\tIP6_INC_STATS(net, idev, IPSTATS_MIB_FRAGFAILS);\n\tkfree_skb(skb);\n\treturn -EMSGSIZE;\n}\n",
      "cve_list": [
        "CVE-2024-44985"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/scsi/elx/libefc/efc_nport.c",
      "func_name": "efc_nport_vport_del",
      "func_body": "int\nefc_nport_vport_del(struct efc *efc, struct efc_domain *domain,\n\t\t    u64 wwpn, uint64_t wwnn)\n{\n\tstruct efc_nport *nport;\n\tstruct efc_vport *vport;\n\tstruct efc_vport *next;\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&efc->vport_lock, flags);\n\t/* walk the efc_vport_list and remove from there */\n\tlist_for_each_entry_safe(vport, next, &efc->vport_list, list_entry) {\n\t\tif (vport->wwpn == wwpn && vport->wwnn == wwnn) {\n\t\t\tlist_del(&vport->list_entry);\n\t\t\tkfree(vport);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&efc->vport_lock, flags);\n\n\tif (!domain) {\n\t\t/* No domain means no nport to look for */\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&efc->lock, flags);\n\tlist_for_each_entry(nport, &domain->nport_list, list_entry) {\n\t\tif (nport->wwpn == wwpn && nport->wwnn == wwnn) {\n\t\t\t/* Shutdown this NPORT */\n\t\t\tefc_sm_post_event(&nport->sm, EFC_EVT_SHUTDOWN, NULL);\n\t\t\tkref_put(&nport->ref, nport->release);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&efc->lock, flags);\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-49852"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/tls/tls_sw.c",
      "func_name": "tls_decrypt_done",
      "func_body": "static void tls_decrypt_done(void *data, int err)\n{\n\tstruct aead_request *aead_req = data;\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(aead_req);\n\tstruct scatterlist *sgout = aead_req->dst;\n\tstruct tls_sw_context_rx *ctx;\n\tstruct tls_decrypt_ctx *dctx;\n\tstruct tls_context *tls_ctx;\n\tstruct scatterlist *sg;\n\tunsigned int pages;\n\tstruct sock *sk;\n\tint aead_size;\n\n\t/* If requests get too backlogged crypto API returns -EBUSY and calls\n\t * ->complete(-EINPROGRESS) immediately followed by ->complete(0)\n\t * to make waiting for backlog to flush with crypto_wait_req() easier.\n\t * First wait converts -EBUSY -> -EINPROGRESS, and the second one\n\t * -EINPROGRESS -> 0.\n\t * We have a single struct crypto_async_request per direction, this\n\t * scheme doesn't help us, so just ignore the first ->complete().\n\t */\n\tif (err == -EINPROGRESS)\n\t\treturn;\n\n\taead_size = sizeof(*aead_req) + crypto_aead_reqsize(aead);\n\taead_size = ALIGN(aead_size, __alignof__(*dctx));\n\tdctx = (void *)((u8 *)aead_req + aead_size);\n\n\tsk = dctx->sk;\n\ttls_ctx = tls_get_ctx(sk);\n\tctx = tls_sw_ctx_rx(tls_ctx);\n\n\t/* Propagate if there was an err */\n\tif (err) {\n\t\tif (err == -EBADMSG)\n\t\t\tTLS_INC_STATS(sock_net(sk), LINUX_MIB_TLSDECRYPTERROR);\n\t\tctx->async_wait.err = err;\n\t\ttls_err_abort(sk, err);\n\t}\n\n\t/* Free the destination pages if skb was not decrypted inplace */\n\tif (dctx->free_sgout) {\n\t\t/* Skip the first S/G entry as it points to AAD */\n\t\tfor_each_sg(sg_next(sgout), sg, UINT_MAX, pages) {\n\t\t\tif (!sg)\n\t\t\t\tbreak;\n\t\t\tput_page(sg_page(sg));\n\t\t}\n\t}\n\n\tkfree(aead_req);\n\n\tif (atomic_dec_and_test(&ctx->decrypt_pending))\n\t\tcomplete(&ctx->async_wait.completion);\n}\n",
      "cve_list": [
        "CVE-2024-26582"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/tls/tls_sw.c",
      "func_name": "tls_decrypt_sg",
      "func_body": "static int tls_decrypt_sg(struct sock *sk, struct iov_iter *out_iov,\n\t\t\t  struct scatterlist *out_sg,\n\t\t\t  struct tls_decrypt_arg *darg)\n{\n\tstruct tls_context *tls_ctx = tls_get_ctx(sk);\n\tstruct tls_sw_context_rx *ctx = tls_sw_ctx_rx(tls_ctx);\n\tstruct tls_prot_info *prot = &tls_ctx->prot_info;\n\tint n_sgin, n_sgout, aead_size, err, pages = 0;\n\tstruct sk_buff *skb = tls_strp_msg(ctx);\n\tconst struct strp_msg *rxm = strp_msg(skb);\n\tconst struct tls_msg *tlm = tls_msg(skb);\n\tstruct aead_request *aead_req;\n\tstruct scatterlist *sgin = NULL;\n\tstruct scatterlist *sgout = NULL;\n\tconst int data_len = rxm->full_len - prot->overhead_size;\n\tint tail_pages = !!prot->tail_size;\n\tstruct tls_decrypt_ctx *dctx;\n\tstruct sk_buff *clear_skb;\n\tint iv_offset = 0;\n\tu8 *mem;\n\n\tn_sgin = skb_nsg(skb, rxm->offset + prot->prepend_size,\n\t\t\t rxm->full_len - prot->prepend_size);\n\tif (n_sgin < 1)\n\t\treturn n_sgin ?: -EBADMSG;\n\n\tif (darg->zc && (out_iov || out_sg)) {\n\t\tclear_skb = NULL;\n\n\t\tif (out_iov)\n\t\t\tn_sgout = 1 + tail_pages +\n\t\t\t\tiov_iter_npages_cap(out_iov, INT_MAX, data_len);\n\t\telse\n\t\t\tn_sgout = sg_nents(out_sg);\n\t} else {\n\t\tdarg->zc = false;\n\n\t\tclear_skb = tls_alloc_clrtxt_skb(sk, skb, rxm->full_len);\n\t\tif (!clear_skb)\n\t\t\treturn -ENOMEM;\n\n\t\tn_sgout = 1 + skb_shinfo(clear_skb)->nr_frags;\n\t}\n\n\t/* Increment to accommodate AAD */\n\tn_sgin = n_sgin + 1;\n\n\t/* Allocate a single block of memory which contains\n\t *   aead_req || tls_decrypt_ctx.\n\t * Both structs are variable length.\n\t */\n\taead_size = sizeof(*aead_req) + crypto_aead_reqsize(ctx->aead_recv);\n\taead_size = ALIGN(aead_size, __alignof__(*dctx));\n\tmem = kmalloc(aead_size + struct_size(dctx, sg, size_add(n_sgin, n_sgout)),\n\t\t      sk->sk_allocation);\n\tif (!mem) {\n\t\terr = -ENOMEM;\n\t\tgoto exit_free_skb;\n\t}\n\n\t/* Segment the allocated memory */\n\taead_req = (struct aead_request *)mem;\n\tdctx = (struct tls_decrypt_ctx *)(mem + aead_size);\n\tdctx->sk = sk;\n\tsgin = &dctx->sg[0];\n\tsgout = &dctx->sg[n_sgin];\n\n\t/* For CCM based ciphers, first byte of nonce+iv is a constant */\n\tswitch (prot->cipher_type) {\n\tcase TLS_CIPHER_AES_CCM_128:\n\t\tdctx->iv[0] = TLS_AES_CCM_IV_B0_BYTE;\n\t\tiv_offset = 1;\n\t\tbreak;\n\tcase TLS_CIPHER_SM4_CCM:\n\t\tdctx->iv[0] = TLS_SM4_CCM_IV_B0_BYTE;\n\t\tiv_offset = 1;\n\t\tbreak;\n\t}\n\n\t/* Prepare IV */\n\tif (prot->version == TLS_1_3_VERSION ||\n\t    prot->cipher_type == TLS_CIPHER_CHACHA20_POLY1305) {\n\t\tmemcpy(&dctx->iv[iv_offset], tls_ctx->rx.iv,\n\t\t       prot->iv_size + prot->salt_size);\n\t} else {\n\t\terr = skb_copy_bits(skb, rxm->offset + TLS_HEADER_SIZE,\n\t\t\t\t    &dctx->iv[iv_offset] + prot->salt_size,\n\t\t\t\t    prot->iv_size);\n\t\tif (err < 0)\n\t\t\tgoto exit_free;\n\t\tmemcpy(&dctx->iv[iv_offset], tls_ctx->rx.iv, prot->salt_size);\n\t}\n\ttls_xor_iv_with_seq(prot, &dctx->iv[iv_offset], tls_ctx->rx.rec_seq);\n\n\t/* Prepare AAD */\n\ttls_make_aad(dctx->aad, rxm->full_len - prot->overhead_size +\n\t\t     prot->tail_size,\n\t\t     tls_ctx->rx.rec_seq, tlm->control, prot);\n\n\t/* Prepare sgin */\n\tsg_init_table(sgin, n_sgin);\n\tsg_set_buf(&sgin[0], dctx->aad, prot->aad_size);\n\terr = skb_to_sgvec(skb, &sgin[1],\n\t\t\t   rxm->offset + prot->prepend_size,\n\t\t\t   rxm->full_len - prot->prepend_size);\n\tif (err < 0)\n\t\tgoto exit_free;\n\n\tif (clear_skb) {\n\t\tsg_init_table(sgout, n_sgout);\n\t\tsg_set_buf(&sgout[0], dctx->aad, prot->aad_size);\n\n\t\terr = skb_to_sgvec(clear_skb, &sgout[1], prot->prepend_size,\n\t\t\t\t   data_len + prot->tail_size);\n\t\tif (err < 0)\n\t\t\tgoto exit_free;\n\t} else if (out_iov) {\n\t\tsg_init_table(sgout, n_sgout);\n\t\tsg_set_buf(&sgout[0], dctx->aad, prot->aad_size);\n\n\t\terr = tls_setup_from_iter(out_iov, data_len, &pages, &sgout[1],\n\t\t\t\t\t  (n_sgout - 1 - tail_pages));\n\t\tif (err < 0)\n\t\t\tgoto exit_free_pages;\n\n\t\tif (prot->tail_size) {\n\t\t\tsg_unmark_end(&sgout[pages]);\n\t\t\tsg_set_buf(&sgout[pages + 1], &dctx->tail,\n\t\t\t\t   prot->tail_size);\n\t\t\tsg_mark_end(&sgout[pages + 1]);\n\t\t}\n\t} else if (out_sg) {\n\t\tmemcpy(sgout, out_sg, n_sgout * sizeof(*sgout));\n\t}\n\tdctx->free_sgout = !!pages;\n\n\t/* Prepare and submit AEAD request */\n\terr = tls_do_decryption(sk, sgin, sgout, dctx->iv,\n\t\t\t\tdata_len + prot->tail_size, aead_req, darg);\n\tif (err)\n\t\tgoto exit_free_pages;\n\n\tdarg->skb = clear_skb ?: tls_strp_msg(ctx);\n\tclear_skb = NULL;\n\n\tif (unlikely(darg->async)) {\n\t\terr = tls_strp_msg_hold(&ctx->strp, &ctx->async_hold);\n\t\tif (err)\n\t\t\t__skb_queue_tail(&ctx->async_hold, darg->skb);\n\t\treturn err;\n\t}\n\n\tif (prot->tail_size)\n\t\tdarg->tail = dctx->tail;\n\nexit_free_pages:\n\t/* Release the pages in case iov was mapped to pages */\n\tfor (; pages > 0; pages--)\n\t\tput_page(sg_page(&sgout[pages]));\nexit_free:\n\tkfree(mem);\nexit_free_skb:\n\tconsume_skb(clear_skb);\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-26582"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/smb/server/connection.c",
      "func_name": "stop_sessions",
      "func_body": "static void stop_sessions(void)\n{\n\tstruct ksmbd_conn *conn;\n\tstruct ksmbd_transport *t;\n\nagain:\n\tdown_read(&conn_list_lock);\n\tlist_for_each_entry(conn, &conn_list, conns_list) {\n\t\tt = conn->transport;\n\t\tksmbd_conn_set_exiting(conn);\n\t\tif (t->ops->shutdown) {\n\t\t\tup_read(&conn_list_lock);\n\t\t\tt->ops->shutdown(t);\n\t\t\tdown_read(&conn_list_lock);\n\t\t}\n\t}\n\tup_read(&conn_list_lock);\n\n\tif (!list_empty(&conn_list)) {\n\t\tschedule_timeout_interruptible(HZ / 10); /* 100ms */\n\t\tgoto again;\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-26592"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/smb/server/transport_rdma.c",
      "func_name": "smb_direct_handle_connect_request",
      "func_body": "static int smb_direct_handle_connect_request(struct rdma_cm_id *new_cm_id)\n{\n\tstruct smb_direct_transport *t;\n\tstruct task_struct *handler;\n\tint ret;\n\n\tif (!rdma_frwr_is_supported(&new_cm_id->device->attrs)) {\n\t\tksmbd_debug(RDMA,\n\t\t\t    \"Fast Registration Work Requests is not supported. device capabilities=%llx\\n\",\n\t\t\t    new_cm_id->device->attrs.device_cap_flags);\n\t\treturn -EPROTONOSUPPORT;\n\t}\n\n\tt = alloc_transport(new_cm_id);\n\tif (!t)\n\t\treturn -ENOMEM;\n\n\tret = smb_direct_connect(t);\n\tif (ret)\n\t\tgoto out_err;\n\n\thandler = kthread_run(ksmbd_conn_handler_loop,\n\t\t\t      KSMBD_TRANS(t)->conn, \"ksmbd:r%u\",\n\t\t\t      smb_direct_port);\n\tif (IS_ERR(handler)) {\n\t\tret = PTR_ERR(handler);\n\t\tpr_err(\"Can't start thread\\n\");\n\t\tgoto out_err;\n\t}\n\n\treturn 0;\nout_err:\n\tfree_transport(t);\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-26592"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/smb/server/transport_tcp.c",
      "func_name": "ksmbd_tcp_new_connection",
      "func_body": "static int ksmbd_tcp_new_connection(struct socket *client_sk)\n{\n\tstruct sockaddr *csin;\n\tint rc = 0;\n\tstruct tcp_transport *t;\n\tstruct task_struct *handler;\n\n\tt = alloc_transport(client_sk);\n\tif (!t) {\n\t\tsock_release(client_sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tcsin = KSMBD_TCP_PEER_SOCKADDR(KSMBD_TRANS(t)->conn);\n\tif (kernel_getpeername(client_sk, csin) < 0) {\n\t\tpr_err(\"client ip resolution failed\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_error;\n\t}\n\n\thandler = kthread_run(ksmbd_conn_handler_loop,\n\t\t\t      KSMBD_TRANS(t)->conn,\n\t\t\t      \"ksmbd:%u\",\n\t\t\t      ksmbd_tcp_get_port(csin));\n\tif (IS_ERR(handler)) {\n\t\tpr_err(\"cannot start conn thread\\n\");\n\t\trc = PTR_ERR(handler);\n\t\tfree_transport(t);\n\t}\n\treturn rc;\n\nout_error:\n\tfree_transport(t);\n\treturn rc;\n}\n",
      "cve_list": [
        "CVE-2024-26592"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/bridge/br_mst.c",
      "func_name": "br_mst_vlan_set_state",
      "func_body": "static void br_mst_vlan_set_state(struct net_bridge_port *p, struct net_bridge_vlan *v,\n\t\t\t\t  u8 state)\n{\n\tstruct net_bridge_vlan_group *vg = nbp_vlan_group(p);\n\n\tif (br_vlan_get_state(v) == state)\n\t\treturn;\n\n\tbr_vlan_set_state(v, state);\n\n\tif (v->vid == vg->pvid)\n\t\tbr_vlan_set_pvid_state(vg, state);\n}\n",
      "cve_list": [
        "CVE-2024-36979"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/bridge/br_mst.c",
      "func_name": "br_mst_set_state",
      "func_body": "int br_mst_set_state(struct net_bridge_port *p, u16 msti, u8 state,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct switchdev_attr attr = {\n\t\t.id = SWITCHDEV_ATTR_ID_PORT_MST_STATE,\n\t\t.orig_dev = p->dev,\n\t\t.u.mst_state = {\n\t\t\t.msti = msti,\n\t\t\t.state = state,\n\t\t},\n\t};\n\tstruct net_bridge_vlan_group *vg;\n\tstruct net_bridge_vlan *v;\n\tint err = 0;\n\n\trcu_read_lock();\n\tvg = nbp_vlan_group(p);\n\tif (!vg)\n\t\tgoto out;\n\n\t/* MSTI 0 (CST) state changes are notified via the regular\n\t * SWITCHDEV_ATTR_ID_PORT_STP_STATE.\n\t */\n\tif (msti) {\n\t\terr = switchdev_port_attr_set(p->dev, &attr, extack);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\tgoto out;\n\t}\n\n\terr = 0;\n\tlist_for_each_entry_rcu(v, &vg->vlan_list, vlist) {\n\t\tif (v->brvlan->msti != msti)\n\t\t\tcontinue;\n\n\t\tbr_mst_vlan_set_state(p, v, state);\n\t}\n\nout:\n\trcu_read_unlock();\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-36979"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/sched/sch_netem.c",
      "func_name": "netem_dequeue",
      "func_body": "static struct sk_buff *netem_dequeue(struct Qdisc *sch)\n{\n\tstruct netem_sched_data *q = qdisc_priv(sch);\n\tstruct sk_buff *skb;\n\ntfifo_dequeue:\n\tskb = __qdisc_dequeue_head(&sch->q);\n\tif (skb) {\n\t\tqdisc_qstats_backlog_dec(sch, skb);\ndeliver:\n\t\tqdisc_bstats_update(sch, skb);\n\t\treturn skb;\n\t}\n\tskb = netem_peek(q);\n\tif (skb) {\n\t\tu64 time_to_send;\n\t\tu64 now = ktime_get_ns();\n\n\t\t/* if more time remaining? */\n\t\ttime_to_send = netem_skb_cb(skb)->time_to_send;\n\t\tif (q->slot.slot_next && q->slot.slot_next < time_to_send)\n\t\t\tget_slot_next(q, now);\n\n\t\tif (time_to_send <= now && q->slot.slot_next <= now) {\n\t\t\tnetem_erase_head(q, skb);\n\t\t\tsch->q.qlen--;\n\t\t\tqdisc_qstats_backlog_dec(sch, skb);\n\t\t\tskb->next = NULL;\n\t\t\tskb->prev = NULL;\n\t\t\t/* skb->dev shares skb->rbnode area,\n\t\t\t * we need to restore its value.\n\t\t\t */\n\t\t\tskb->dev = qdisc_dev(sch);\n\n\t\t\tif (q->slot.slot_next) {\n\t\t\t\tq->slot.packets_left--;\n\t\t\t\tq->slot.bytes_left -= qdisc_pkt_len(skb);\n\t\t\t\tif (q->slot.packets_left <= 0 ||\n\t\t\t\t    q->slot.bytes_left <= 0)\n\t\t\t\t\tget_slot_next(q, now);\n\t\t\t}\n\n\t\t\tif (q->qdisc) {\n\t\t\t\tunsigned int pkt_len = qdisc_pkt_len(skb);\n\t\t\t\tstruct sk_buff *to_free = NULL;\n\t\t\t\tint err;\n\n\t\t\t\terr = qdisc_enqueue(skb, q->qdisc, &to_free);\n\t\t\t\tkfree_skb_list(to_free);\n\t\t\t\tif (err != NET_XMIT_SUCCESS) {\n\t\t\t\t\tif (net_xmit_drop_count(err))\n\t\t\t\t\t\tqdisc_qstats_drop(sch);\n\t\t\t\t\tqdisc_tree_reduce_backlog(sch, 1, pkt_len);\n\t\t\t\t}\n\t\t\t\tgoto tfifo_dequeue;\n\t\t\t}\n\t\t\tgoto deliver;\n\t\t}\n\n\t\tif (q->qdisc) {\n\t\t\tskb = q->qdisc->ops->dequeue(q->qdisc);\n\t\t\tif (skb)\n\t\t\t\tgoto deliver;\n\t\t}\n\n\t\tqdisc_watchdog_schedule_ns(&q->watchdog,\n\t\t\t\t\t   max(time_to_send,\n\t\t\t\t\t       q->slot.slot_next));\n\t}\n\n\tif (q->qdisc) {\n\t\tskb = q->qdisc->ops->dequeue(q->qdisc);\n\t\tif (skb)\n\t\t\tgoto deliver;\n\t}\n\treturn NULL;\n}\n",
      "cve_list": [
        "CVE-2024-46800"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/locks.c",
      "func_name": "fcntl_setlk",
      "func_body": "int fcntl_setlk(unsigned int fd, struct file *filp, unsigned int cmd,\n\t\tstruct flock *flock)\n{\n\tstruct file_lock *file_lock = locks_alloc_lock();\n\tstruct inode *inode = file_inode(filp);\n\tstruct file *f;\n\tint error;\n\n\tif (file_lock == NULL)\n\t\treturn -ENOLCK;\n\n\terror = flock_to_posix_lock(filp, file_lock, flock);\n\tif (error)\n\t\tgoto out;\n\n\terror = check_fmode_for_setlk(file_lock);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If the cmd is requesting file-private locks, then set the\n\t * FL_OFDLCK flag and override the owner.\n\t */\n\tswitch (cmd) {\n\tcase F_OFD_SETLK:\n\t\terror = -EINVAL;\n\t\tif (flock->l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLK;\n\t\tfile_lock->c.flc_flags |= FL_OFDLCK;\n\t\tfile_lock->c.flc_owner = filp;\n\t\tbreak;\n\tcase F_OFD_SETLKW:\n\t\terror = -EINVAL;\n\t\tif (flock->l_pid != 0)\n\t\t\tgoto out;\n\n\t\tcmd = F_SETLKW;\n\t\tfile_lock->c.flc_flags |= FL_OFDLCK;\n\t\tfile_lock->c.flc_owner = filp;\n\t\tfallthrough;\n\tcase F_SETLKW:\n\t\tfile_lock->c.flc_flags |= FL_SLEEP;\n\t}\n\n\terror = do_lock_file_wait(filp, cmd, file_lock);\n\n\t/*\n\t * Detect close/fcntl races and recover by zapping all POSIX locks\n\t * associated with this file and our files_struct, just like on\n\t * filp_flush(). There is no need to do that when we're\n\t * unlocking though, or for OFD locks.\n\t */\n\tif (!error && file_lock->c.flc_type != F_UNLCK &&\n\t    !(file_lock->c.flc_flags & FL_OFDLCK)) {\n\t\tstruct files_struct *files = current->files;\n\t\t/*\n\t\t * We need that spin_lock here - it prevents reordering between\n\t\t * update of i_flctx->flc_posix and check for it done in\n\t\t * close(). rcu_read_lock() wouldn't do.\n\t\t */\n\t\tspin_lock(&files->file_lock);\n\t\tf = files_lookup_fd_locked(files, fd);\n\t\tspin_unlock(&files->file_lock);\n\t\tif (f != filp) {\n\t\t\tlocks_remove_posix(filp, files);\n\t\t\terror = -EBADF;\n\t\t}\n\t}\nout:\n\ttrace_fcntl_setlk(inode, file_lock, error);\n\tlocks_free_lock(file_lock);\n\treturn error;\n}\n",
      "cve_list": [
        "CVE-2024-41012"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/misc/vmw_vmci/vmci_resource.c",
      "func_name": "vmci_resource_remove",
      "func_body": "void vmci_resource_remove(struct vmci_resource *resource)\n{\n\tstruct vmci_handle handle = resource->handle;\n\tunsigned int idx = vmci_resource_hash(handle);\n\tstruct vmci_resource *r;\n\n\t/* Remove resource from hash table. */\n\tspin_lock(&vmci_resource_table.lock);\n\n\thlist_for_each_entry(r, &vmci_resource_table.entries[idx], node) {\n\t\tif (vmci_handle_is_equal(r->handle, resource->handle) &&\n\t\t    resource->type == r->type) {\n\t\t\thlist_del_init_rcu(&r->node);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&vmci_resource_table.lock);\n\tsynchronize_rcu();\n\n\tvmci_resource_put(resource);\n\twait_for_completion(&resource->done);\n}\n",
      "cve_list": [
        "CVE-2024-46738"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/mptcp/pm_netlink.c",
      "func_name": "select_local_address",
      "func_body": "static bool\nselect_local_address(const struct pm_nl_pernet *pernet,\n\t\t     const struct mptcp_sock *msk,\n\t\t     struct mptcp_pm_addr_entry *new_entry)\n{\n\tstruct mptcp_pm_addr_entry *entry;\n\tbool found = false;\n\n\tmsk_owned_by_me(msk);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(entry, &pernet->local_addr_list, list) {\n\t\tif (!(entry->flags & MPTCP_PM_ADDR_FLAG_SUBFLOW))\n\t\t\tcontinue;\n\n\t\tif (!test_bit(entry->addr.id, msk->pm.id_avail_bitmap))\n\t\t\tcontinue;\n\n\t\t*new_entry = *entry;\n\t\tfound = true;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn found;\n}\n",
      "cve_list": [
        "CVE-2024-44974"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/mptcp/pm_netlink.c",
      "func_name": "select_signal_address",
      "func_body": "static bool\nselect_signal_address(struct pm_nl_pernet *pernet, const struct mptcp_sock *msk,\n\t\t      struct mptcp_pm_addr_entry *new_entry)\n{\n\tstruct mptcp_pm_addr_entry *entry;\n\tbool found = false;\n\n\trcu_read_lock();\n\t/* do not keep any additional per socket state, just signal\n\t * the address list in order.\n\t * Note: removal from the local address list during the msk life-cycle\n\t * can lead to additional addresses not being announced.\n\t */\n\tlist_for_each_entry_rcu(entry, &pernet->local_addr_list, list) {\n\t\tif (!test_bit(entry->addr.id, msk->pm.id_avail_bitmap))\n\t\t\tcontinue;\n\n\t\tif (!(entry->flags & MPTCP_PM_ADDR_FLAG_SIGNAL))\n\t\t\tcontinue;\n\n\t\t*new_entry = *entry;\n\t\tfound = true;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn found;\n}\n",
      "cve_list": [
        "CVE-2024-44974"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/pensando/ionic/ionic_txrx.c",
      "func_name": "ionic_run_xdp",
      "func_body": "static bool ionic_run_xdp(struct ionic_rx_stats *stats,\n\t\t\t  struct net_device *netdev,\n\t\t\t  struct bpf_prog *xdp_prog,\n\t\t\t  struct ionic_queue *rxq,\n\t\t\t  struct ionic_buf_info *buf_info,\n\t\t\t  int len)\n{\n\tu32 xdp_action = XDP_ABORTED;\n\tstruct xdp_buff xdp_buf;\n\tstruct ionic_queue *txq;\n\tstruct netdev_queue *nq;\n\tstruct xdp_frame *xdpf;\n\tint remain_len;\n\tint frag_len;\n\tint err = 0;\n\n\txdp_init_buff(&xdp_buf, IONIC_PAGE_SIZE, rxq->xdp_rxq_info);\n\tfrag_len = min_t(u16, len, IONIC_XDP_MAX_LINEAR_MTU + VLAN_ETH_HLEN);\n\txdp_prepare_buff(&xdp_buf, ionic_rx_buf_va(buf_info),\n\t\t\t XDP_PACKET_HEADROOM, frag_len, false);\n\n\tdma_sync_single_range_for_cpu(rxq->dev, ionic_rx_buf_pa(buf_info),\n\t\t\t\t      XDP_PACKET_HEADROOM, len,\n\t\t\t\t      DMA_FROM_DEVICE);\n\n\tprefetchw(&xdp_buf.data_hard_start);\n\n\t/*  We limit MTU size to one buffer if !xdp_has_frags, so\n\t *  if the recv len is bigger than one buffer\n\t *     then we know we have frag info to gather\n\t */\n\tremain_len = len - frag_len;\n\tif (remain_len) {\n\t\tstruct skb_shared_info *sinfo;\n\t\tstruct ionic_buf_info *bi;\n\t\tskb_frag_t *frag;\n\n\t\tbi = buf_info;\n\t\tsinfo = xdp_get_shared_info_from_buff(&xdp_buf);\n\t\tsinfo->nr_frags = 0;\n\t\tsinfo->xdp_frags_size = 0;\n\t\txdp_buff_set_frags_flag(&xdp_buf);\n\n\t\tdo {\n\t\t\tif (unlikely(sinfo->nr_frags >= MAX_SKB_FRAGS)) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto out_xdp_abort;\n\t\t\t}\n\n\t\t\tfrag = &sinfo->frags[sinfo->nr_frags];\n\t\t\tsinfo->nr_frags++;\n\t\t\tbi++;\n\t\t\tfrag_len = min_t(u16, remain_len, ionic_rx_buf_size(bi));\n\t\t\tdma_sync_single_range_for_cpu(rxq->dev, ionic_rx_buf_pa(bi),\n\t\t\t\t\t\t      0, frag_len, DMA_FROM_DEVICE);\n\t\t\tskb_frag_fill_page_desc(frag, bi->page, 0, frag_len);\n\t\t\tsinfo->xdp_frags_size += frag_len;\n\t\t\tremain_len -= frag_len;\n\n\t\t\tif (page_is_pfmemalloc(bi->page))\n\t\t\t\txdp_buff_set_frag_pfmemalloc(&xdp_buf);\n\t\t} while (remain_len > 0);\n\t}\n\n\txdp_action = bpf_prog_run_xdp(xdp_prog, &xdp_buf);\n\n\tswitch (xdp_action) {\n\tcase XDP_PASS:\n\t\tstats->xdp_pass++;\n\t\treturn false;  /* false = we didn't consume the packet */\n\n\tcase XDP_DROP:\n\t\tionic_rx_page_free(rxq, buf_info);\n\t\tstats->xdp_drop++;\n\t\tbreak;\n\n\tcase XDP_TX:\n\t\txdpf = xdp_convert_buff_to_frame(&xdp_buf);\n\t\tif (!xdpf)\n\t\t\tgoto out_xdp_abort;\n\n\t\ttxq = rxq->partner;\n\t\tnq = netdev_get_tx_queue(netdev, txq->index);\n\t\t__netif_tx_lock(nq, smp_processor_id());\n\t\ttxq_trans_cond_update(nq);\n\n\t\tif (netif_tx_queue_stopped(nq) ||\n\t\t    !netif_txq_maybe_stop(q_to_ndq(netdev, txq),\n\t\t\t\t\t  ionic_q_space_avail(txq),\n\t\t\t\t\t  1, 1)) {\n\t\t\t__netif_tx_unlock(nq);\n\t\t\tgoto out_xdp_abort;\n\t\t}\n\n\t\tdma_unmap_page(rxq->dev, buf_info->dma_addr,\n\t\t\t       IONIC_PAGE_SIZE, DMA_FROM_DEVICE);\n\n\t\terr = ionic_xdp_post_frame(txq, xdpf, XDP_TX,\n\t\t\t\t\t   buf_info->page,\n\t\t\t\t\t   buf_info->page_offset,\n\t\t\t\t\t   true);\n\t\t__netif_tx_unlock(nq);\n\t\tif (err) {\n\t\t\tnetdev_dbg(netdev, \"tx ionic_xdp_post_frame err %d\\n\", err);\n\t\t\tgoto out_xdp_abort;\n\t\t}\n\t\tbuf_info->page = NULL;\n\t\tstats->xdp_tx++;\n\n\t\t/* the Tx completion will free the buffers */\n\t\tbreak;\n\n\tcase XDP_REDIRECT:\n\t\t/* unmap the pages before handing them to a different device */\n\t\tdma_unmap_page(rxq->dev, buf_info->dma_addr,\n\t\t\t       IONIC_PAGE_SIZE, DMA_FROM_DEVICE);\n\n\t\terr = xdp_do_redirect(netdev, &xdp_buf, xdp_prog);\n\t\tif (err) {\n\t\t\tnetdev_dbg(netdev, \"xdp_do_redirect err %d\\n\", err);\n\t\t\tgoto out_xdp_abort;\n\t\t}\n\t\tbuf_info->page = NULL;\n\t\trxq->xdp_flush = true;\n\t\tstats->xdp_redirect++;\n\t\tbreak;\n\n\tcase XDP_ABORTED:\n\tdefault:\n\t\tgoto out_xdp_abort;\n\t}\n\n\treturn true;\n\nout_xdp_abort:\n\ttrace_xdp_exception(netdev, xdp_prog, xdp_action);\n\tionic_rx_page_free(rxq, buf_info);\n\tstats->xdp_aborted++;\n\n\treturn true;\n}\n",
      "cve_list": [
        "CVE-2024-40907"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/ext4/super.c",
      "func_name": "__ext4_remount",
      "func_body": "static int __ext4_remount(struct fs_context *fc, struct super_block *sb)\n{\n\tstruct ext4_fs_context *ctx = fc->fs_private;\n\tstruct ext4_super_block *es;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned long old_sb_flags;\n\tstruct ext4_mount_options old_opts;\n\text4_group_t g;\n\tint err = 0;\n\tint enable_rw = 0;\n// #ifdef CONFIG_QUOTA\n\tint enable_quota = 0;\n\tint i, j;\n\tchar *to_free[EXT4_MAXQUOTAS];\n#endif\n\n\n\t/* Store the original options */\n\told_sb_flags = sb->s_flags;\n\told_opts.s_mount_opt = sbi->s_mount_opt;\n\told_opts.s_mount_opt2 = sbi->s_mount_opt2;\n\told_opts.s_resuid = sbi->s_resuid;\n\told_opts.s_resgid = sbi->s_resgid;\n\told_opts.s_commit_interval = sbi->s_commit_interval;\n\told_opts.s_min_batch_time = sbi->s_min_batch_time;\n\told_opts.s_max_batch_time = sbi->s_max_batch_time;\n// #ifdef CONFIG_QUOTA\n\told_opts.s_jquota_fmt = sbi->s_jquota_fmt;\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tif (sbi->s_qf_names[i]) {\n\t\t\tchar *qf_name = get_qf_name(sb, sbi, i);\n\n\t\t\told_opts.s_qf_names[i] = kstrdup(qf_name, GFP_KERNEL);\n\t\t\tif (!old_opts.s_qf_names[i]) {\n\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\tkfree(old_opts.s_qf_names[j]);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t} else\n\t\t\told_opts.s_qf_names[i] = NULL;\n#endif\n\tif (!(ctx->spec & EXT4_SPEC_JOURNAL_IOPRIO)) {\n\t\tif (sbi->s_journal && sbi->s_journal->j_task->io_context)\n\t\t\tctx->journal_ioprio =\n\t\t\t\tsbi->s_journal->j_task->io_context->ioprio;\n\t\telse\n\t\t\tctx->journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\n\t}\n\n\text4_apply_options(fc, sb);\n\n\tif ((old_opts.s_mount_opt & EXT4_MOUNT_JOURNAL_CHECKSUM) ^\n\t    test_opt(sb, JOURNAL_CHECKSUM)) {\n\t\text4_msg(sb, KERN_ERR, \"changing journal_checksum \"\n\t\t\t \"during remount not supported; ignoring\");\n\t\tsbi->s_mount_opt ^= EXT4_MOUNT_JOURNAL_CHECKSUM;\n\t}\n\n\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\tif (test_opt2(sb, EXPLICIT_DELALLOC)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and delalloc\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto restore_opts;\n\t\t}\n\t\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t \"both data=journal and dioread_nolock\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto restore_opts;\n\t\t}\n\t} else if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA) {\n\t\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't mount with \"\n\t\t\t\t\"journal_async_commit in data=ordered mode\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto restore_opts;\n\t\t}\n\t}\n\n\tif ((sbi->s_mount_opt ^ old_opts.s_mount_opt) & EXT4_MOUNT_NO_MBCACHE) {\n\t\text4_msg(sb, KERN_ERR, \"can't enable nombcache during remount\");\n\t\terr = -EINVAL;\n\t\tgoto restore_opts;\n\t}\n\n\tif (ext4_test_mount_flag(sb, EXT4_MF_FS_ABORTED))\n\t\text4_abort(sb, ESHUTDOWN, \"Abort forced by user\");\n\n\tsb->s_flags = (sb->s_flags & ~SB_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? SB_POSIXACL : 0);\n\n\tes = sbi->s_es;\n\n\tif (sbi->s_journal) {\n\t\text4_init_journal_params(sb, sbi->s_journal);\n\t\tset_task_ioprio(sbi->s_journal->j_task, ctx->journal_ioprio);\n\t}\n\n\t/* Flush outstanding errors before changing fs state */\n\tflush_work(&sbi->s_error_work);\n\n\tif ((bool)(fc->sb_flags & SB_RDONLY) != sb_rdonly(sb)) {\n\t\tif (ext4_test_mount_flag(sb, EXT4_MF_FS_ABORTED)) {\n\t\t\terr = -EROFS;\n\t\t\tgoto restore_opts;\n\t\t}\n\n\t\tif (fc->sb_flags & SB_RDONLY) {\n\t\t\terr = sync_filesystem(sb);\n\t\t\tif (err < 0)\n\t\t\t\tgoto restore_opts;\n\t\t\terr = dquot_suspend(sb, -1);\n\t\t\tif (err < 0)\n\t\t\t\tgoto restore_opts;\n\n\t\t\t/*\n\t\t\t * First of all, the unconditional stuff we have to do\n\t\t\t * to disable replay of the journal when we next remount\n\t\t\t */\n\t\t\tsb->s_flags |= SB_RDONLY;\n\n\t\t\t/*\n\t\t\t * OK, test if we are remounting a valid rw partition\n\t\t\t * readonly, and if so set the rdonly flag and then\n\t\t\t * mark the partition as valid again.\n\t\t\t */\n\t\t\tif (!(es->s_state & cpu_to_le16(EXT4_VALID_FS)) &&\n\t\t\t    (sbi->s_mount_state & EXT4_VALID_FS))\n\t\t\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\n\t\t\tif (sbi->s_journal) {\n\t\t\t\t/*\n\t\t\t\t * We let remount-ro finish even if marking fs\n\t\t\t\t * as clean failed...\n\t\t\t\t */\n\t\t\t\text4_mark_recovery_complete(sb, es);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Make sure we can mount this feature set readwrite */\n\t\t\tif (ext4_has_feature_readonly(sb) ||\n\t\t\t    !ext4_feature_set_ok(sb, 0)) {\n\t\t\t\terr = -EROFS;\n\t\t\t\tgoto restore_opts;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Make sure the group descriptor checksums\n\t\t\t * are sane.  If they aren't, refuse to remount r/w.\n\t\t\t */\n\t\t\tfor (g = 0; g < sbi->s_groups_count; g++) {\n\t\t\t\tstruct ext4_group_desc *gdp =\n\t\t\t\t\text4_get_group_desc(sb, g, NULL);\n\n\t\t\t\tif (!ext4_group_desc_csum_verify(sb, g, gdp)) {\n\t\t\t\t\text4_msg(sb, KERN_ERR,\n\t       \"ext4_remount: Checksum for group %u failed (%u!=%u)\",\n\t\tg, le16_to_cpu(ext4_group_desc_csum(sb, g, gdp)),\n\t\t\t\t\t       le16_to_cpu(gdp->bg_checksum));\n\t\t\t\t\terr = -EFSBADCRC;\n\t\t\t\t\tgoto restore_opts;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If we have an unprocessed orphan list hanging\n\t\t\t * around from a previously readonly bdev mount,\n\t\t\t * require a full umount/remount for now.\n\t\t\t */\n\t\t\tif (es->s_last_orphan || !ext4_orphan_file_empty(sb)) {\n\t\t\t\text4_msg(sb, KERN_WARNING, \"Couldn't \"\n\t\t\t\t       \"remount RDWR because of unprocessed \"\n\t\t\t\t       \"orphan inode list.  Please \"\n\t\t\t\t       \"umount/remount instead\");\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto restore_opts;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Mounting a RDONLY partition read-write, so reread\n\t\t\t * and store the current valid flag.  (It may have\n\t\t\t * been changed by e2fsck since we originally mounted\n\t\t\t * the partition.)\n\t\t\t */\n\t\t\tif (sbi->s_journal) {\n\t\t\t\terr = ext4_clear_journal_err(sb, es);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto restore_opts;\n\t\t\t}\n\t\t\tsbi->s_mount_state = (le16_to_cpu(es->s_state) &\n\t\t\t\t\t      ~EXT4_FC_REPLAY);\n\n\t\t\terr = ext4_setup_super(sb, es, 0);\n\t\t\tif (err)\n\t\t\t\tgoto restore_opts;\n\n\t\t\tenable_rw = 1;\n\t\t\tif (ext4_has_feature_mmp(sb)) {\n\t\t\t\terr = ext4_multi_mount_protect(sb,\n\t\t\t\t\t\tle64_to_cpu(es->s_mmp_block));\n\t\t\t\tif (err)\n\t\t\t\t\tgoto restore_opts;\n\t\t\t}\n// #ifdef CONFIG_QUOTA\n\t\t\tenable_quota = 1;\n#endif\n\t\t}\n\t}\n\n\t/*\n\t * Reinitialize lazy itable initialization thread based on\n\t * current settings\n\t */\n\tif (sb_rdonly(sb) || !test_opt(sb, INIT_INODE_TABLE))\n\t\text4_unregister_li_request(sb);\n\telse {\n\t\text4_group_t first_not_zeroed;\n\t\tfirst_not_zeroed = ext4_has_uninit_itable(sb);\n\t\text4_register_li_request(sb, first_not_zeroed);\n\t}\n\n\t/*\n\t * Handle creation of system zone data early because it can fail.\n\t * Releasing of existing data is done when we are sure remount will\n\t * succeed.\n\t */\n\tif (test_opt(sb, BLOCK_VALIDITY) && !sbi->s_system_blks) {\n\t\terr = ext4_setup_system_zone(sb);\n\t\tif (err)\n\t\t\tgoto restore_opts;\n\t}\n\n\tif (sbi->s_journal == NULL && !(old_sb_flags & SB_RDONLY)) {\n\t\terr = ext4_commit_super(sb);\n\t\tif (err)\n\t\t\tgoto restore_opts;\n\t}\n\n// #ifdef CONFIG_QUOTA\n\tif (enable_quota) {\n\t\tif (sb_any_quota_suspended(sb))\n\t\t\tdquot_resume(sb, -1);\n\t\telse if (ext4_has_feature_quota(sb)) {\n\t\t\terr = ext4_enable_quotas(sb);\n\t\t\tif (err)\n\t\t\t\tgoto restore_opts;\n\t\t}\n\t}\n\t/* Release old quota file names */\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(old_opts.s_qf_names[i]);\n#endif\n\tif (!test_opt(sb, BLOCK_VALIDITY) && sbi->s_system_blks)\n\t\text4_release_system_zone(sb);\n\n\tif (enable_rw)\n\t\tsb->s_flags &= ~SB_RDONLY;\n\n\tif (!ext4_has_feature_mmp(sb) || sb_rdonly(sb))\n\t\text4_stop_mmpd(sbi);\n\n\treturn 0;\n\nrestore_opts:\n\t/*\n\t * If there was a failing r/w to ro transition, we may need to\n\t * re-enable quota\n\t */\n\tif ((sb->s_flags & SB_RDONLY) && !(old_sb_flags & SB_RDONLY) &&\n\t    sb_any_quota_suspended(sb))\n\t\tdquot_resume(sb, -1);\n\tsb->s_flags = old_sb_flags;\n\tsbi->s_mount_opt = old_opts.s_mount_opt;\n\tsbi->s_mount_opt2 = old_opts.s_mount_opt2;\n\tsbi->s_resuid = old_opts.s_resuid;\n\tsbi->s_resgid = old_opts.s_resgid;\n\tsbi->s_commit_interval = old_opts.s_commit_interval;\n\tsbi->s_min_batch_time = old_opts.s_min_batch_time;\n\tsbi->s_max_batch_time = old_opts.s_max_batch_time;\n\tif (!test_opt(sb, BLOCK_VALIDITY) && sbi->s_system_blks)\n\t\text4_release_system_zone(sb);\n// #ifdef CONFIG_QUOTA\n\tsbi->s_jquota_fmt = old_opts.s_jquota_fmt;\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++) {\n\t\tto_free[i] = get_qf_name(sb, sbi, i);\n\t\trcu_assign_pointer(sbi->s_qf_names[i], old_opts.s_qf_names[i]);\n\t}\n\tsynchronize_rcu();\n\tfor (i = 0; i < EXT4_MAXQUOTAS; i++)\n\t\tkfree(to_free[i]);\n#endif\n\tif (!ext4_has_feature_mmp(sb) || sb_rdonly(sb))\n\t\text4_stop_mmpd(sbi);\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-0775"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/android/binder.c",
      "func_name": "binder_transaction",
      "func_body": "static void binder_transaction(struct binder_proc *proc,\n\t\t\t       struct binder_thread *thread,\n\t\t\t       struct binder_transaction_data *tr, int reply,\n\t\t\t       binder_size_t extra_buffers_size)\n{\n\tint ret;\n\tstruct binder_transaction *t;\n\tstruct binder_work *w;\n\tstruct binder_work *tcomplete;\n\tbinder_size_t buffer_offset = 0;\n\tbinder_size_t off_start_offset, off_end_offset;\n\tbinder_size_t off_min;\n\tbinder_size_t sg_buf_offset, sg_buf_end_offset;\n\tbinder_size_t user_offset = 0;\n\tstruct binder_proc *target_proc = NULL;\n\tstruct binder_thread *target_thread = NULL;\n\tstruct binder_node *target_node = NULL;\n\tstruct binder_transaction *in_reply_to = NULL;\n\tstruct binder_transaction_log_entry *e;\n\tuint32_t return_error = 0;\n\tuint32_t return_error_param = 0;\n\tuint32_t return_error_line = 0;\n\tbinder_size_t last_fixup_obj_off = 0;\n\tbinder_size_t last_fixup_min_off = 0;\n\tstruct binder_context *context = proc->context;\n\tint t_debug_id = atomic_inc_return(&binder_last_id);\n\tktime_t t_start_time = ktime_get();\n\tchar *secctx = NULL;\n\tu32 secctx_sz = 0;\n\tstruct list_head sgc_head;\n\tstruct list_head pf_head;\n\tconst void __user *user_buffer = (const void __user *)\n\t\t\t\t(uintptr_t)tr->data.ptr.buffer;\n\tINIT_LIST_HEAD(&sgc_head);\n\tINIT_LIST_HEAD(&pf_head);\n\n\te = binder_transaction_log_add(&binder_transaction_log);\n\te->debug_id = t_debug_id;\n\te->call_type = reply ? 2 : !!(tr->flags & TF_ONE_WAY);\n\te->from_proc = proc->pid;\n\te->from_thread = thread->pid;\n\te->target_handle = tr->target.handle;\n\te->data_size = tr->data_size;\n\te->offsets_size = tr->offsets_size;\n\tstrscpy(e->context_name, proc->context->name, BINDERFS_MAX_NAME);\n\n\tbinder_inner_proc_lock(proc);\n\tbinder_set_extended_error(&thread->ee, t_debug_id, BR_OK, 0);\n\tbinder_inner_proc_unlock(proc);\n\n\tif (reply) {\n\t\tbinder_inner_proc_lock(proc);\n\t\tin_reply_to = thread->transaction_stack;\n\t\tif (in_reply_to == NULL) {\n\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\tbinder_user_error(\"%d:%d got reply transaction with no transaction stack\\n\",\n\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPROTO;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_empty_call_stack;\n\t\t}\n\t\tif (in_reply_to->to_thread != thread) {\n\t\t\tspin_lock(&in_reply_to->lock);\n\t\t\tbinder_user_error(\"%d:%d got reply transaction with bad transaction stack, transaction %d has target %d:%d\\n\",\n\t\t\t\tproc->pid, thread->pid, in_reply_to->debug_id,\n\t\t\t\tin_reply_to->to_proc ?\n\t\t\t\tin_reply_to->to_proc->pid : 0,\n\t\t\t\tin_reply_to->to_thread ?\n\t\t\t\tin_reply_to->to_thread->pid : 0);\n\t\t\tspin_unlock(&in_reply_to->lock);\n\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPROTO;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tin_reply_to = NULL;\n\t\t\tgoto err_bad_call_stack;\n\t\t}\n\t\tthread->transaction_stack = in_reply_to->to_parent;\n\t\tbinder_inner_proc_unlock(proc);\n\t\tbinder_set_nice(in_reply_to->saved_priority);\n\t\ttarget_thread = binder_get_txn_from_and_acq_inner(in_reply_to);\n\t\tif (target_thread == NULL) {\n\t\t\t/* annotation for sparse */\n\t\t\t__release(&target_thread->proc->inner_lock);\n\t\t\tbinder_txn_error(\"%d:%d reply target not found\\n\",\n\t\t\t\tthread->pid, proc->pid);\n\t\t\treturn_error = BR_DEAD_REPLY;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_dead_binder;\n\t\t}\n\t\tif (target_thread->transaction_stack != in_reply_to) {\n\t\t\tbinder_user_error(\"%d:%d got reply transaction with bad target transaction stack %d, expected %d\\n\",\n\t\t\t\tproc->pid, thread->pid,\n\t\t\t\ttarget_thread->transaction_stack ?\n\t\t\t\ttarget_thread->transaction_stack->debug_id : 0,\n\t\t\t\tin_reply_to->debug_id);\n\t\t\tbinder_inner_proc_unlock(target_thread->proc);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPROTO;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tin_reply_to = NULL;\n\t\t\ttarget_thread = NULL;\n\t\t\tgoto err_dead_binder;\n\t\t}\n\t\ttarget_proc = target_thread->proc;\n\t\ttarget_proc->tmp_ref++;\n\t\tbinder_inner_proc_unlock(target_thread->proc);\n\t} else {\n\t\tif (tr->target.handle) {\n\t\t\tstruct binder_ref *ref;\n\n\t\t\t/*\n\t\t\t * There must already be a strong ref\n\t\t\t * on this node. If so, do a strong\n\t\t\t * increment on the node to ensure it\n\t\t\t * stays alive until the transaction is\n\t\t\t * done.\n\t\t\t */\n\t\t\tbinder_proc_lock(proc);\n\t\t\tref = binder_get_ref_olocked(proc, tr->target.handle,\n\t\t\t\t\t\t     true);\n\t\t\tif (ref) {\n\t\t\t\ttarget_node = binder_get_node_refs_for_txn(\n\t\t\t\t\t\tref->node, &target_proc,\n\t\t\t\t\t\t&return_error);\n\t\t\t} else {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction to invalid handle, %u\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid, tr->target.handle);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t}\n\t\t\tbinder_proc_unlock(proc);\n\t\t} else {\n\t\t\tmutex_lock(&context->context_mgr_node_lock);\n\t\t\ttarget_node = context->binder_context_mgr_node;\n\t\t\tif (target_node)\n\t\t\t\ttarget_node = binder_get_node_refs_for_txn(\n\t\t\t\t\t\ttarget_node, &target_proc,\n\t\t\t\t\t\t&return_error);\n\t\t\telse\n\t\t\t\treturn_error = BR_DEAD_REPLY;\n\t\t\tmutex_unlock(&context->context_mgr_node_lock);\n\t\t\tif (target_node && target_proc->pid == proc->pid) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction to context manager from process owning it\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EINVAL;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_invalid_target_handle;\n\t\t\t}\n\t\t}\n\t\tif (!target_node) {\n\t\t\tbinder_txn_error(\"%d:%d cannot find target node\\n\",\n\t\t\t\tthread->pid, proc->pid);\n\t\t\t/*\n\t\t\t * return_error is set above\n\t\t\t */\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_dead_binder;\n\t\t}\n\t\te->to_node = target_node->debug_id;\n\t\tif (WARN_ON(proc == target_proc)) {\n\t\t\tbinder_txn_error(\"%d:%d self transactions not allowed\\n\",\n\t\t\t\tthread->pid, proc->pid);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_invalid_target_handle;\n\t\t}\n\t\tif (security_binder_transaction(proc->cred,\n\t\t\t\t\t\ttarget_proc->cred) < 0) {\n\t\t\tbinder_txn_error(\"%d:%d transaction credentials failed\\n\",\n\t\t\t\tthread->pid, proc->pid);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPERM;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_invalid_target_handle;\n\t\t}\n\t\tbinder_inner_proc_lock(proc);\n\n\t\tw = list_first_entry_or_null(&thread->todo,\n\t\t\t\t\t     struct binder_work, entry);\n\t\tif (!(tr->flags & TF_ONE_WAY) && w &&\n\t\t    w->type == BINDER_WORK_TRANSACTION) {\n\t\t\t/*\n\t\t\t * Do not allow new outgoing transaction from a\n\t\t\t * thread that has a transaction at the head of\n\t\t\t * its todo list. Only need to check the head\n\t\t\t * because binder_select_thread_ilocked picks a\n\t\t\t * thread from proc->waiting_threads to enqueue\n\t\t\t * the transaction, and nothing is queued to the\n\t\t\t * todo list while the thread is on waiting_threads.\n\t\t\t */\n\t\t\tbinder_user_error(\"%d:%d new transaction not allowed when there is a transaction on thread todo\\n\",\n\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPROTO;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_todo_list;\n\t\t}\n\n\t\tif (!(tr->flags & TF_ONE_WAY) && thread->transaction_stack) {\n\t\t\tstruct binder_transaction *tmp;\n\n\t\t\ttmp = thread->transaction_stack;\n\t\t\tif (tmp->to_thread != thread) {\n\t\t\t\tspin_lock(&tmp->lock);\n\t\t\t\tbinder_user_error(\"%d:%d got new transaction with bad transaction stack, transaction %d has target %d:%d\\n\",\n\t\t\t\t\tproc->pid, thread->pid, tmp->debug_id,\n\t\t\t\t\ttmp->to_proc ? tmp->to_proc->pid : 0,\n\t\t\t\t\ttmp->to_thread ?\n\t\t\t\t\ttmp->to_thread->pid : 0);\n\t\t\t\tspin_unlock(&tmp->lock);\n\t\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EPROTO;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_bad_call_stack;\n\t\t\t}\n\t\t\twhile (tmp) {\n\t\t\t\tstruct binder_thread *from;\n\n\t\t\t\tspin_lock(&tmp->lock);\n\t\t\t\tfrom = tmp->from;\n\t\t\t\tif (from && from->proc == target_proc) {\n\t\t\t\t\tatomic_inc(&from->tmp_ref);\n\t\t\t\t\ttarget_thread = from;\n\t\t\t\t\tspin_unlock(&tmp->lock);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tspin_unlock(&tmp->lock);\n\t\t\t\ttmp = tmp->from_parent;\n\t\t\t}\n\t\t}\n\t\tbinder_inner_proc_unlock(proc);\n\t}\n\tif (target_thread)\n\t\te->to_thread = target_thread->pid;\n\te->to_proc = target_proc->pid;\n\n\t/* TODO: reuse incoming transaction for reply */\n\tt = kzalloc(sizeof(*t), GFP_KERNEL);\n\tif (t == NULL) {\n\t\tbinder_txn_error(\"%d:%d cannot allocate transaction\\n\",\n\t\t\tthread->pid, proc->pid);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -ENOMEM;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_alloc_t_failed;\n\t}\n\tINIT_LIST_HEAD(&t->fd_fixups);\n\tbinder_stats_created(BINDER_STAT_TRANSACTION);\n\tspin_lock_init(&t->lock);\n\n\ttcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);\n\tif (tcomplete == NULL) {\n\t\tbinder_txn_error(\"%d:%d cannot allocate work for transaction\\n\",\n\t\t\tthread->pid, proc->pid);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -ENOMEM;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_alloc_tcomplete_failed;\n\t}\n\tbinder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);\n\n\tt->debug_id = t_debug_id;\n\tt->start_time = t_start_time;\n\n\tif (reply)\n\t\tbinder_debug(BINDER_DEBUG_TRANSACTION,\n\t\t\t     \"%d:%d BC_REPLY %d -> %d:%d, data %016llx-%016llx size %lld-%lld-%lld\\n\",\n\t\t\t     proc->pid, thread->pid, t->debug_id,\n\t\t\t     target_proc->pid, target_thread->pid,\n\t\t\t     (u64)tr->data.ptr.buffer,\n\t\t\t     (u64)tr->data.ptr.offsets,\n\t\t\t     (u64)tr->data_size, (u64)tr->offsets_size,\n\t\t\t     (u64)extra_buffers_size);\n\telse\n\t\tbinder_debug(BINDER_DEBUG_TRANSACTION,\n\t\t\t     \"%d:%d BC_TRANSACTION %d -> %d - node %d, data %016llx-%016llx size %lld-%lld-%lld\\n\",\n\t\t\t     proc->pid, thread->pid, t->debug_id,\n\t\t\t     target_proc->pid, target_node->debug_id,\n\t\t\t     (u64)tr->data.ptr.buffer,\n\t\t\t     (u64)tr->data.ptr.offsets,\n\t\t\t     (u64)tr->data_size, (u64)tr->offsets_size,\n\t\t\t     (u64)extra_buffers_size);\n\n\tif (!reply && !(tr->flags & TF_ONE_WAY))\n\t\tt->from = thread;\n\telse\n\t\tt->from = NULL;\n\tt->from_pid = proc->pid;\n\tt->from_tid = thread->pid;\n\tt->sender_euid = task_euid(proc->tsk);\n\tt->to_proc = target_proc;\n\tt->to_thread = target_thread;\n\tt->code = tr->code;\n\tt->flags = tr->flags;\n\tt->priority = task_nice(current);\n\n\tif (target_node && target_node->txn_security_ctx) {\n\t\tu32 secid;\n\t\tsize_t added_size;\n\n\t\tsecurity_cred_getsecid(proc->cred, &secid);\n\t\tret = security_secid_to_secctx(secid, &secctx, &secctx_sz);\n\t\tif (ret) {\n\t\t\tbinder_txn_error(\"%d:%d failed to get security context\\n\",\n\t\t\t\tthread->pid, proc->pid);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = ret;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_get_secctx_failed;\n\t\t}\n\t\tadded_size = ALIGN(secctx_sz, sizeof(u64));\n\t\textra_buffers_size += added_size;\n\t\tif (extra_buffers_size < added_size) {\n\t\t\tbinder_txn_error(\"%d:%d integer overflow of extra_buffers_size\\n\",\n\t\t\t\tthread->pid, proc->pid);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_extra_size;\n\t\t}\n\t}\n\n\ttrace_binder_transaction(reply, t, target_node);\n\n\tt->buffer = binder_alloc_new_buf(&target_proc->alloc, tr->data_size,\n\t\ttr->offsets_size, extra_buffers_size,\n\t\t!reply && (t->flags & TF_ONE_WAY));\n\tif (IS_ERR(t->buffer)) {\n\t\tchar *s;\n\n\t\tret = PTR_ERR(t->buffer);\n\t\ts = (ret == -ESRCH) ? \": vma cleared, target dead or dying\"\n\t\t\t: (ret == -ENOSPC) ? \": no space left\"\n\t\t\t: (ret == -ENOMEM) ? \": memory allocation failed\"\n\t\t\t: \"\";\n\t\tbinder_txn_error(\"cannot allocate buffer%s\", s);\n\n\t\treturn_error_param = PTR_ERR(t->buffer);\n\t\treturn_error = return_error_param == -ESRCH ?\n\t\t\tBR_DEAD_REPLY : BR_FAILED_REPLY;\n\t\treturn_error_line = __LINE__;\n\t\tt->buffer = NULL;\n\t\tgoto err_binder_alloc_buf_failed;\n\t}\n\tif (secctx) {\n\t\tint err;\n\t\tsize_t buf_offset = ALIGN(tr->data_size, sizeof(void *)) +\n\t\t\t\t    ALIGN(tr->offsets_size, sizeof(void *)) +\n\t\t\t\t    ALIGN(extra_buffers_size, sizeof(void *)) -\n\t\t\t\t    ALIGN(secctx_sz, sizeof(u64));\n\n\t\tt->security_ctx = t->buffer->user_data + buf_offset;\n\t\terr = binder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t  t->buffer, buf_offset,\n\t\t\t\t\t\t  secctx, secctx_sz);\n\t\tif (err) {\n\t\t\tt->security_ctx = 0;\n\t\t\tWARN_ON(1);\n\t\t}\n\t\tsecurity_release_secctx(secctx, secctx_sz);\n\t\tsecctx = NULL;\n\t}\n\tt->buffer->debug_id = t->debug_id;\n\tt->buffer->transaction = t;\n\tt->buffer->target_node = target_node;\n\tt->buffer->clear_on_free = !!(t->flags & TF_CLEAR_BUF);\n\ttrace_binder_transaction_alloc_buf(t->buffer);\n\n\tif (binder_alloc_copy_user_to_buffer(\n\t\t\t\t&target_proc->alloc,\n\t\t\t\tt->buffer,\n\t\t\t\tALIGN(tr->data_size, sizeof(void *)),\n\t\t\t\t(const void __user *)\n\t\t\t\t\t(uintptr_t)tr->data.ptr.offsets,\n\t\t\t\ttr->offsets_size)) {\n\t\tbinder_user_error(\"%d:%d got transaction with invalid offsets ptr\\n\",\n\t\t\t\tproc->pid, thread->pid);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -EFAULT;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_copy_data_failed;\n\t}\n\tif (!IS_ALIGNED(tr->offsets_size, sizeof(binder_size_t))) {\n\t\tbinder_user_error(\"%d:%d got transaction with invalid offsets size, %lld\\n\",\n\t\t\t\tproc->pid, thread->pid, (u64)tr->offsets_size);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -EINVAL;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_bad_offset;\n\t}\n\tif (!IS_ALIGNED(extra_buffers_size, sizeof(u64))) {\n\t\tbinder_user_error(\"%d:%d got transaction with unaligned buffers size, %lld\\n\",\n\t\t\t\t  proc->pid, thread->pid,\n\t\t\t\t  (u64)extra_buffers_size);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -EINVAL;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_bad_offset;\n\t}\n\toff_start_offset = ALIGN(tr->data_size, sizeof(void *));\n\tbuffer_offset = off_start_offset;\n\toff_end_offset = off_start_offset + tr->offsets_size;\n\tsg_buf_offset = ALIGN(off_end_offset, sizeof(void *));\n\tsg_buf_end_offset = sg_buf_offset + extra_buffers_size -\n\t\tALIGN(secctx_sz, sizeof(u64));\n\toff_min = 0;\n\tfor (buffer_offset = off_start_offset; buffer_offset < off_end_offset;\n\t     buffer_offset += sizeof(binder_size_t)) {\n\t\tstruct binder_object_header *hdr;\n\t\tsize_t object_size;\n\t\tstruct binder_object object;\n\t\tbinder_size_t object_offset;\n\t\tbinder_size_t copy_size;\n\n\t\tif (binder_alloc_copy_from_buffer(&target_proc->alloc,\n\t\t\t\t\t\t  &object_offset,\n\t\t\t\t\t\t  t->buffer,\n\t\t\t\t\t\t  buffer_offset,\n\t\t\t\t\t\t  sizeof(object_offset))) {\n\t\t\tbinder_txn_error(\"%d:%d copy offset from buffer failed\\n\",\n\t\t\t\tthread->pid, proc->pid);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_offset;\n\t\t}\n\n\t\t/*\n\t\t * Copy the source user buffer up to the next object\n\t\t * that will be processed.\n\t\t */\n\t\tcopy_size = object_offset - user_offset;\n\t\tif (copy_size && (user_offset > object_offset ||\n\t\t\t\tobject_offset > tr->data_size ||\n\t\t\t\tbinder_alloc_copy_user_to_buffer(\n\t\t\t\t\t&target_proc->alloc,\n\t\t\t\t\tt->buffer, user_offset,\n\t\t\t\t\tuser_buffer + user_offset,\n\t\t\t\t\tcopy_size))) {\n\t\t\tbinder_user_error(\"%d:%d got transaction with invalid data ptr\\n\",\n\t\t\t\t\tproc->pid, thread->pid);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EFAULT;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_copy_data_failed;\n\t\t}\n\t\tobject_size = binder_get_object(target_proc, user_buffer,\n\t\t\t\tt->buffer, object_offset, &object);\n\t\tif (object_size == 0 || object_offset < off_min) {\n\t\t\tbinder_user_error(\"%d:%d got transaction with invalid offset (%lld, min %lld max %lld) or object.\\n\",\n\t\t\t\t\t  proc->pid, thread->pid,\n\t\t\t\t\t  (u64)object_offset,\n\t\t\t\t\t  (u64)off_min,\n\t\t\t\t\t  (u64)t->buffer->data_size);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_offset;\n\t\t}\n\t\t/*\n\t\t * Set offset to the next buffer fragment to be\n\t\t * copied\n\t\t */\n\t\tuser_offset = object_offset + object_size;\n\n\t\thdr = &object.hdr;\n\t\toff_min = object_offset + object_size;\n\t\tswitch (hdr->type) {\n\t\tcase BINDER_TYPE_BINDER:\n\t\tcase BINDER_TYPE_WEAK_BINDER: {\n\t\t\tstruct flat_binder_object *fp;\n\n\t\t\tfp = to_flat_binder_object(hdr);\n\t\t\tret = binder_translate_binder(fp, t, thread);\n\n\t\t\tif (ret < 0 ||\n\t\t\t    binder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t\tt->buffer,\n\t\t\t\t\t\t\tobject_offset,\n\t\t\t\t\t\t\tfp, sizeof(*fp))) {\n\t\t\t\tbinder_txn_error(\"%d:%d translate binder failed\\n\",\n\t\t\t\t\tthread->pid, proc->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t} break;\n\t\tcase BINDER_TYPE_HANDLE:\n\t\tcase BINDER_TYPE_WEAK_HANDLE: {\n\t\t\tstruct flat_binder_object *fp;\n\n\t\t\tfp = to_flat_binder_object(hdr);\n\t\t\tret = binder_translate_handle(fp, t, thread);\n\t\t\tif (ret < 0 ||\n\t\t\t    binder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t\tt->buffer,\n\t\t\t\t\t\t\tobject_offset,\n\t\t\t\t\t\t\tfp, sizeof(*fp))) {\n\t\t\t\tbinder_txn_error(\"%d:%d translate handle failed\\n\",\n\t\t\t\t\tthread->pid, proc->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t} break;\n\n\t\tcase BINDER_TYPE_FD: {\n\t\t\tstruct binder_fd_object *fp = to_binder_fd_object(hdr);\n\t\t\tbinder_size_t fd_offset = object_offset +\n\t\t\t\t(uintptr_t)&fp->fd - (uintptr_t)fp;\n\t\t\tint ret = binder_translate_fd(fp->fd, fd_offset, t,\n\t\t\t\t\t\t      thread, in_reply_to);\n\n\t\t\tfp->pad_binder = 0;\n\t\t\tif (ret < 0 ||\n\t\t\t    binder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t\tt->buffer,\n\t\t\t\t\t\t\tobject_offset,\n\t\t\t\t\t\t\tfp, sizeof(*fp))) {\n\t\t\t\tbinder_txn_error(\"%d:%d translate fd failed\\n\",\n\t\t\t\t\tthread->pid, proc->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t} break;\n\t\tcase BINDER_TYPE_FDA: {\n\t\t\tstruct binder_object ptr_object;\n\t\t\tbinder_size_t parent_offset;\n\t\t\tstruct binder_object user_object;\n\t\t\tsize_t user_parent_size;\n\t\t\tstruct binder_fd_array_object *fda =\n\t\t\t\tto_binder_fd_array_object(hdr);\n\t\t\tsize_t num_valid = (buffer_offset - off_start_offset) /\n\t\t\t\t\t\tsizeof(binder_size_t);\n\t\t\tstruct binder_buffer_object *parent =\n\t\t\t\tbinder_validate_ptr(target_proc, t->buffer,\n\t\t\t\t\t\t    &ptr_object, fda->parent,\n\t\t\t\t\t\t    off_start_offset,\n\t\t\t\t\t\t    &parent_offset,\n\t\t\t\t\t\t    num_valid);\n\t\t\tif (!parent) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction with invalid parent offset or type\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EINVAL;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_bad_parent;\n\t\t\t}\n\t\t\tif (!binder_validate_fixup(target_proc, t->buffer,\n\t\t\t\t\t\t   off_start_offset,\n\t\t\t\t\t\t   parent_offset,\n\t\t\t\t\t\t   fda->parent_offset,\n\t\t\t\t\t\t   last_fixup_obj_off,\n\t\t\t\t\t\t   last_fixup_min_off)) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction with out-of-order buffer fixup\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EINVAL;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_bad_parent;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We need to read the user version of the parent\n\t\t\t * object to get the original user offset\n\t\t\t */\n\t\t\tuser_parent_size =\n\t\t\t\tbinder_get_object(proc, user_buffer, t->buffer,\n\t\t\t\t\t\t  parent_offset, &user_object);\n\t\t\tif (user_parent_size != sizeof(user_object.bbo)) {\n\t\t\t\tbinder_user_error(\"%d:%d invalid ptr object size: %zd vs %zd\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid,\n\t\t\t\t\t\t  user_parent_size,\n\t\t\t\t\t\t  sizeof(user_object.bbo));\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EINVAL;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_bad_parent;\n\t\t\t}\n\t\t\tret = binder_translate_fd_array(&pf_head, fda,\n\t\t\t\t\t\t\tuser_buffer, parent,\n\t\t\t\t\t\t\t&user_object.bbo, t,\n\t\t\t\t\t\t\tthread, in_reply_to);\n\t\t\tif (!ret)\n\t\t\t\tret = binder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t\t\t  t->buffer,\n\t\t\t\t\t\t\t\t  object_offset,\n\t\t\t\t\t\t\t\t  fda, sizeof(*fda));\n\t\t\tif (ret) {\n\t\t\t\tbinder_txn_error(\"%d:%d translate fd array failed\\n\",\n\t\t\t\t\tthread->pid, proc->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret > 0 ? -EINVAL : ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t\tlast_fixup_obj_off = parent_offset;\n\t\t\tlast_fixup_min_off =\n\t\t\t\tfda->parent_offset + sizeof(u32) * fda->num_fds;\n\t\t} break;\n\t\tcase BINDER_TYPE_PTR: {\n\t\t\tstruct binder_buffer_object *bp =\n\t\t\t\tto_binder_buffer_object(hdr);\n\t\t\tsize_t buf_left = sg_buf_end_offset - sg_buf_offset;\n\t\t\tsize_t num_valid;\n\n\t\t\tif (bp->length > buf_left) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction with too large buffer\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EINVAL;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_bad_offset;\n\t\t\t}\n\t\t\tret = binder_defer_copy(&sgc_head, sg_buf_offset,\n\t\t\t\t(const void __user *)(uintptr_t)bp->buffer,\n\t\t\t\tbp->length);\n\t\t\tif (ret) {\n\t\t\t\tbinder_txn_error(\"%d:%d deferred copy failed\\n\",\n\t\t\t\t\tthread->pid, proc->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t\t/* Fixup buffer pointer to target proc address space */\n\t\t\tbp->buffer = t->buffer->user_data + sg_buf_offset;\n\t\t\tsg_buf_offset += ALIGN(bp->length, sizeof(u64));\n\n\t\t\tnum_valid = (buffer_offset - off_start_offset) /\n\t\t\t\t\tsizeof(binder_size_t);\n\t\t\tret = binder_fixup_parent(&pf_head, t,\n\t\t\t\t\t\t  thread, bp,\n\t\t\t\t\t\t  off_start_offset,\n\t\t\t\t\t\t  num_valid,\n\t\t\t\t\t\t  last_fixup_obj_off,\n\t\t\t\t\t\t  last_fixup_min_off);\n\t\t\tif (ret < 0 ||\n\t\t\t    binder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t\tt->buffer,\n\t\t\t\t\t\t\tobject_offset,\n\t\t\t\t\t\t\tbp, sizeof(*bp))) {\n\t\t\t\tbinder_txn_error(\"%d:%d failed to fixup parent\\n\",\n\t\t\t\t\tthread->pid, proc->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t\tlast_fixup_obj_off = object_offset;\n\t\t\tlast_fixup_min_off = 0;\n\t\t} break;\n\t\tdefault:\n\t\t\tbinder_user_error(\"%d:%d got transaction with invalid object type, %x\\n\",\n\t\t\t\tproc->pid, thread->pid, hdr->type);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_object_type;\n\t\t}\n\t}\n\t/* Done processing objects, copy the rest of the buffer */\n\tif (binder_alloc_copy_user_to_buffer(\n\t\t\t\t&target_proc->alloc,\n\t\t\t\tt->buffer, user_offset,\n\t\t\t\tuser_buffer + user_offset,\n\t\t\t\ttr->data_size - user_offset)) {\n\t\tbinder_user_error(\"%d:%d got transaction with invalid data ptr\\n\",\n\t\t\t\tproc->pid, thread->pid);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -EFAULT;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_copy_data_failed;\n\t}\n\n\tret = binder_do_deferred_txn_copies(&target_proc->alloc, t->buffer,\n\t\t\t\t\t    &sgc_head, &pf_head);\n\tif (ret) {\n\t\tbinder_user_error(\"%d:%d got transaction with invalid offsets ptr\\n\",\n\t\t\t\t  proc->pid, thread->pid);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = ret;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_copy_data_failed;\n\t}\n\tif (t->buffer->oneway_spam_suspect)\n\t\ttcomplete->type = BINDER_WORK_TRANSACTION_ONEWAY_SPAM_SUSPECT;\n\telse\n\t\ttcomplete->type = BINDER_WORK_TRANSACTION_COMPLETE;\n\tt->work.type = BINDER_WORK_TRANSACTION;\n\n\tif (reply) {\n\t\tbinder_enqueue_thread_work(thread, tcomplete);\n\t\tbinder_inner_proc_lock(target_proc);\n\t\tif (target_thread->is_dead) {\n\t\t\treturn_error = BR_DEAD_REPLY;\n\t\t\tbinder_inner_proc_unlock(target_proc);\n\t\t\tgoto err_dead_proc_or_thread;\n\t\t}\n\t\tBUG_ON(t->buffer->async_transaction != 0);\n\t\tbinder_pop_transaction_ilocked(target_thread, in_reply_to);\n\t\tbinder_enqueue_thread_work_ilocked(target_thread, &t->work);\n\t\ttarget_proc->outstanding_txns++;\n\t\tbinder_inner_proc_unlock(target_proc);\n\t\twake_up_interruptible_sync(&target_thread->wait);\n\t\tbinder_free_transaction(in_reply_to);\n\t} else if (!(t->flags & TF_ONE_WAY)) {\n\t\tBUG_ON(t->buffer->async_transaction != 0);\n\t\tbinder_inner_proc_lock(proc);\n\t\t/*\n\t\t * Defer the TRANSACTION_COMPLETE, so we don't return to\n\t\t * userspace immediately; this allows the target process to\n\t\t * immediately start processing this transaction, reducing\n\t\t * latency. We will then return the TRANSACTION_COMPLETE when\n\t\t * the target replies (or there is an error).\n\t\t */\n\t\tbinder_enqueue_deferred_thread_work_ilocked(thread, tcomplete);\n\t\tt->need_reply = 1;\n\t\tt->from_parent = thread->transaction_stack;\n\t\tthread->transaction_stack = t;\n\t\tbinder_inner_proc_unlock(proc);\n\t\treturn_error = binder_proc_transaction(t,\n\t\t\t\ttarget_proc, target_thread);\n\t\tif (return_error) {\n\t\t\tbinder_inner_proc_lock(proc);\n\t\t\tbinder_pop_transaction_ilocked(thread, t);\n\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\tgoto err_dead_proc_or_thread;\n\t\t}\n\t} else {\n\t\tBUG_ON(target_node == NULL);\n\t\tBUG_ON(t->buffer->async_transaction != 1);\n\t\treturn_error = binder_proc_transaction(t, target_proc, NULL);\n\t\t/*\n\t\t * Let the caller know when async transaction reaches a frozen\n\t\t * process and is put in a pending queue, waiting for the target\n\t\t * process to be unfrozen.\n\t\t */\n\t\tif (return_error == BR_TRANSACTION_PENDING_FROZEN)\n\t\t\ttcomplete->type = BINDER_WORK_TRANSACTION_PENDING;\n\t\tbinder_enqueue_thread_work(thread, tcomplete);\n\t\tif (return_error &&\n\t\t    return_error != BR_TRANSACTION_PENDING_FROZEN)\n\t\t\tgoto err_dead_proc_or_thread;\n\t}\n\tif (target_thread)\n\t\tbinder_thread_dec_tmpref(target_thread);\n\tbinder_proc_dec_tmpref(target_proc);\n\tif (target_node)\n\t\tbinder_dec_node_tmpref(target_node);\n\t/*\n\t * write barrier to synchronize with initialization\n\t * of log entry\n\t */\n\tsmp_wmb();\n\tWRITE_ONCE(e->debug_id_done, t_debug_id);\n\treturn;\n\nerr_dead_proc_or_thread:\n\tbinder_txn_error(\"%d:%d dead process or thread\\n\",\n\t\tthread->pid, proc->pid);\n\treturn_error_line = __LINE__;\n\tbinder_dequeue_work(proc, tcomplete);\nerr_translate_failed:\nerr_bad_object_type:\nerr_bad_offset:\nerr_bad_parent:\nerr_copy_data_failed:\n\tbinder_cleanup_deferred_txn_lists(&sgc_head, &pf_head);\n\tbinder_free_txn_fixups(t);\n\ttrace_binder_transaction_failed_buffer_release(t->buffer);\n\tbinder_transaction_buffer_release(target_proc, NULL, t->buffer,\n\t\t\t\t\t  buffer_offset, true);\n\tif (target_node)\n\t\tbinder_dec_node_tmpref(target_node);\n\ttarget_node = NULL;\n\tt->buffer->transaction = NULL;\n\tbinder_alloc_free_buf(&target_proc->alloc, t->buffer);\nerr_binder_alloc_buf_failed:\nerr_bad_extra_size:\n\tif (secctx)\n\t\tsecurity_release_secctx(secctx, secctx_sz);\nerr_get_secctx_failed:\n\tkfree(tcomplete);\n\tbinder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);\nerr_alloc_tcomplete_failed:\n\tif (trace_binder_txn_latency_free_enabled())\n\t\tbinder_txn_latency_free(t);\n\tkfree(t);\n\tbinder_stats_deleted(BINDER_STAT_TRANSACTION);\nerr_alloc_t_failed:\nerr_bad_todo_list:\nerr_bad_call_stack:\nerr_empty_call_stack:\nerr_dead_binder:\nerr_invalid_target_handle:\n\tif (target_node) {\n\t\tbinder_dec_node(target_node, 1, 0);\n\t\tbinder_dec_node_tmpref(target_node);\n\t}\n\n\tbinder_debug(BINDER_DEBUG_FAILED_TRANSACTION,\n\t\t     \"%d:%d transaction %s to %d:%d failed %d/%d/%d, size %lld-%lld line %d\\n\",\n\t\t     proc->pid, thread->pid, reply ? \"reply\" :\n\t\t     (tr->flags & TF_ONE_WAY ? \"async\" : \"call\"),\n\t\t     target_proc ? target_proc->pid : 0,\n\t\t     target_thread ? target_thread->pid : 0,\n\t\t     t_debug_id, return_error, return_error_param,\n\t\t     (u64)tr->data_size, (u64)tr->offsets_size,\n\t\t     return_error_line);\n\n\tif (target_thread)\n\t\tbinder_thread_dec_tmpref(target_thread);\n\tif (target_proc)\n\t\tbinder_proc_dec_tmpref(target_proc);\n\n\t{\n\t\tstruct binder_transaction_log_entry *fe;\n\n\t\te->return_error = return_error;\n\t\te->return_error_param = return_error_param;\n\t\te->return_error_line = return_error_line;\n\t\tfe = binder_transaction_log_add(&binder_transaction_log_failed);\n\t\t*fe = *e;\n\t\t/*\n\t\t * write barrier to synchronize with initialization\n\t\t * of log entry\n\t\t */\n\t\tsmp_wmb();\n\t\tWRITE_ONCE(e->debug_id_done, t_debug_id);\n\t\tWRITE_ONCE(fe->debug_id_done, t_debug_id);\n\t}\n\n\tBUG_ON(thread->return_error.cmd != BR_OK);\n\tif (in_reply_to) {\n\t\tbinder_set_txn_from_error(in_reply_to, t_debug_id,\n\t\t\t\treturn_error, return_error_param);\n\t\tthread->return_error.cmd = BR_TRANSACTION_COMPLETE;\n\t\tbinder_enqueue_thread_work(thread, &thread->return_error.work);\n\t\tbinder_send_failed_reply(in_reply_to, return_error);\n\t} else {\n\t\tbinder_inner_proc_lock(proc);\n\t\tbinder_set_extended_error(&thread->ee, t_debug_id,\n\t\t\t\treturn_error, return_error_param);\n\t\tbinder_inner_proc_unlock(proc);\n\t\tthread->return_error.cmd = return_error;\n\t\tbinder_enqueue_thread_work(thread, &thread->return_error.work);\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-46740"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/drm_file.c",
      "func_name": "drm_file_update_pid",
      "func_body": "void drm_file_update_pid(struct drm_file *filp)\n{\n\tstruct drm_device *dev;\n\tstruct pid *pid, *old;\n\n\t/*\n\t * Master nodes need to keep the original ownership in order for\n\t * drm_master_check_perm to keep working correctly. (See comment in\n\t * drm_auth.c.)\n\t */\n\tif (filp->was_master)\n\t\treturn;\n\n\tpid = task_tgid(current);\n\n\t/*\n\t * Quick unlocked check since the model is a single handover followed by\n\t * exclusive repeated use.\n\t */\n\tif (pid == rcu_access_pointer(filp->pid))\n\t\treturn;\n\n\tdev = filp->minor->dev;\n\tmutex_lock(&dev->filelist_mutex);\n\tget_pid(pid);\n\told = rcu_replace_pointer(filp->pid, pid, 1);\n\tmutex_unlock(&dev->filelist_mutex);\n\n\tsynchronize_rcu();\n\tput_pid(old);\n}\n",
      "cve_list": [
        "CVE-2024-39486"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "sound/soc/meson/axg-card.c",
      "func_name": "axg_card_add_tdm_loopback",
      "func_body": "static int axg_card_add_tdm_loopback(struct snd_soc_card *card,\n\t\t\t\t     int *index)\n{\n\tstruct meson_card *priv = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_dai_link *pad;\n\tstruct snd_soc_dai_link *lb;\n\tstruct snd_soc_dai_link_component *dlc;\n\tint ret;\n\n\t/* extend links */\n\tret = meson_card_reallocate_links(card, card->num_links + 1);\n\tif (ret)\n\t\treturn ret;\n\n\tpad = &card->dai_link[*index];\n\tlb = &card->dai_link[*index + 1];\n\n\tlb->name = devm_kasprintf(card->dev, GFP_KERNEL, \"%s-lb\", pad->name);\n\tif (!lb->name)\n\t\treturn -ENOMEM;\n\n\tdlc = devm_kzalloc(card->dev, sizeof(*dlc), GFP_KERNEL);\n\tif (!dlc)\n\t\treturn -ENOMEM;\n\n\tlb->cpus = dlc;\n\tlb->codecs = &snd_soc_dummy_dlc;\n\tlb->num_cpus = 1;\n\tlb->num_codecs = 1;\n\n\tlb->stream_name = lb->name;\n\tlb->cpus->of_node = pad->cpus->of_node;\n\tlb->cpus->dai_name = \"TDM Loopback\";\n\tlb->dpcm_capture = 1;\n\tlb->no_pcm = 1;\n\tlb->ops = &axg_card_tdm_be_ops;\n\tlb->init = axg_card_tdm_dai_lb_init;\n\n\t/* Provide the same link data to the loopback */\n\tpriv->link_data[*index + 1] = priv->link_data[*index];\n\n\t/*\n\t * axg_card_clean_references() will iterate over this link,\n\t * make sure the node count is balanced\n\t */\n\tof_node_get(lb->cpus->of_node);\n\n\t/* Let add_links continue where it should */\n\t*index += 1;\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-46849"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/cachefiles/cache.c",
      "func_name": "cachefiles_withdraw_volumes",
      "func_body": "static void cachefiles_withdraw_volumes(struct cachefiles_cache *cache)\n{\n\t_enter(\"\");\n\n\tfor (;;) {\n\t\tstruct fscache_volume *vcookie = NULL;\n\t\tstruct cachefiles_volume *volume = NULL;\n\n\t\tspin_lock(&cache->object_list_lock);\n\t\tif (!list_empty(&cache->volumes)) {\n\t\t\tvolume = list_first_entry(&cache->volumes,\n\t\t\t\t\t\t  struct cachefiles_volume, cache_link);\n\t\t\tvcookie = fscache_try_get_volume(volume->vcookie,\n\t\t\t\t\t\t\t fscache_volume_get_withdraw);\n\t\t\tif (!vcookie) {\n\t\t\t\tspin_unlock(&cache->object_list_lock);\n\t\t\t\tcpu_relax();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlist_del_init(&volume->cache_link);\n\t\t}\n\t\tspin_unlock(&cache->object_list_lock);\n\t\tif (!volume)\n\t\t\tbreak;\n\n\t\tcachefiles_withdraw_volume(volume);\n\t\tfscache_put_volume(vcookie, fscache_volume_put_withdraw);\n\t}\n\n\t_leave(\"\");\n}\n",
      "cve_list": [
        "CVE-2024-41058"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/watchdog/cpu5wdt.c",
      "func_name": "cpu5wdt_exit",
      "func_body": "static void cpu5wdt_exit(void)\n{\n\tif (cpu5wdt_device.queue) {\n\t\tcpu5wdt_device.queue = 0;\n\t\twait_for_completion(&cpu5wdt_device.stop);\n\t\ttimer_shutdown_sync(&cpu5wdt_device.timer);\n\t}\n\n\tmisc_deregister(&cpu5wdt_misc);\n\n\trelease_region(port, CPU5WDT_EXTENT);\n\n}\n",
      "cve_list": [
        "CVE-2024-38630"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/greybus/interface.c",
      "func_name": "gb_interface_release",
      "func_body": "static void gb_interface_release(struct device *dev)\n{\n\tstruct gb_interface *intf = to_gb_interface(dev);\n\n\ttrace_gb_interface_release(intf);\n\n\tcancel_work_sync(&intf->mode_switch_work);\n\tkfree(intf);\n}\n",
      "cve_list": [
        "CVE-2024-39495"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/cachefiles/cache.c",
      "func_name": "cachefiles_withdraw_cache",
      "func_body": "void cachefiles_withdraw_cache(struct cachefiles_cache *cache)\n{\n\tstruct fscache_cache *fscache = cache->cache;\n\n\tpr_info(\"File cache on %s unregistering\\n\", fscache->name);\n\n\tfscache_withdraw_cache(fscache);\n\tcachefiles_withdraw_fscache_volumes(cache);\n\n\t/* we now have to destroy all the active objects pertaining to this\n\t * cache - which we do by passing them off to thread pool to be\n\t * disposed of */\n\tcachefiles_withdraw_objects(cache);\n\tfscache_wait_for_objects(fscache);\n\n\tcachefiles_withdraw_volumes(cache);\n\tcachefiles_sync_cache(cache);\n\tcache->cache = NULL;\n\tfscache_relinquish_cache(fscache);\n}\n",
      "cve_list": [
        "CVE-2024-41057"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/cachefiles/volume.c",
      "func_name": "cachefiles_withdraw_volume",
      "func_body": "void cachefiles_withdraw_volume(struct cachefiles_volume *volume)\n{\n\tcachefiles_set_volume_xattr(volume);\n\t__cachefiles_free_volume(volume);\n}\n",
      "cve_list": [
        "CVE-2024-41057"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/trace/bpf_trace.c",
      "func_name": "bpf_uprobe_multi_link_attach",
      "func_body": "int bpf_uprobe_multi_link_attach(const union bpf_attr *attr, struct bpf_prog *prog)\n{\n\tstruct bpf_uprobe_multi_link *link = NULL;\n\tunsigned long __user *uref_ctr_offsets;\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_uprobe *uprobes = NULL;\n\tstruct task_struct *task = NULL;\n\tunsigned long __user *uoffsets;\n\tu64 __user *ucookies;\n\tvoid __user *upath;\n\tu32 flags, cnt, i;\n\tstruct path path;\n\tchar *name;\n\tpid_t pid;\n\tint err;\n\n\t/* no support for 32bit archs yet */\n\tif (sizeof(u64) != sizeof(void *))\n\t\treturn -EOPNOTSUPP;\n\n\tif (prog->expected_attach_type != BPF_TRACE_UPROBE_MULTI)\n\t\treturn -EINVAL;\n\n\tflags = attr->link_create.uprobe_multi.flags;\n\tif (flags & ~BPF_F_UPROBE_MULTI_RETURN)\n\t\treturn -EINVAL;\n\n\t/*\n\t * path, offsets and cnt are mandatory,\n\t * ref_ctr_offsets and cookies are optional\n\t */\n\tupath = u64_to_user_ptr(attr->link_create.uprobe_multi.path);\n\tuoffsets = u64_to_user_ptr(attr->link_create.uprobe_multi.offsets);\n\tcnt = attr->link_create.uprobe_multi.cnt;\n\tpid = attr->link_create.uprobe_multi.pid;\n\n\tif (!upath || !uoffsets || !cnt || pid < 0)\n\t\treturn -EINVAL;\n\tif (cnt > MAX_UPROBE_MULTI_CNT)\n\t\treturn -E2BIG;\n\n\turef_ctr_offsets = u64_to_user_ptr(attr->link_create.uprobe_multi.ref_ctr_offsets);\n\tucookies = u64_to_user_ptr(attr->link_create.uprobe_multi.cookies);\n\n\tname = strndup_user(upath, PATH_MAX);\n\tif (IS_ERR(name)) {\n\t\terr = PTR_ERR(name);\n\t\treturn err;\n\t}\n\n\terr = kern_path(name, LOOKUP_FOLLOW, &path);\n\tkfree(name);\n\tif (err)\n\t\treturn err;\n\n\tif (!d_is_reg(path.dentry)) {\n\t\terr = -EBADF;\n\t\tgoto error_path_put;\n\t}\n\n\tif (pid) {\n\t\ttask = get_pid_task(find_vpid(pid), PIDTYPE_TGID);\n\t\tif (!task) {\n\t\t\terr = -ESRCH;\n\t\t\tgoto error_path_put;\n\t\t}\n\t}\n\n\terr = -ENOMEM;\n\n\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\tuprobes = kvcalloc(cnt, sizeof(*uprobes), GFP_KERNEL);\n\n\tif (!uprobes || !link)\n\t\tgoto error_free;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (__get_user(uprobes[i].offset, uoffsets + i)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto error_free;\n\t\t}\n\t\tif (uprobes[i].offset < 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto error_free;\n\t\t}\n\t\tif (uref_ctr_offsets && __get_user(uprobes[i].ref_ctr_offset, uref_ctr_offsets + i)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto error_free;\n\t\t}\n\t\tif (ucookies && __get_user(uprobes[i].cookie, ucookies + i)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto error_free;\n\t\t}\n\n\t\tuprobes[i].link = link;\n\n\t\tif (flags & BPF_F_UPROBE_MULTI_RETURN)\n\t\t\tuprobes[i].consumer.ret_handler = uprobe_multi_link_ret_handler;\n\t\telse\n\t\t\tuprobes[i].consumer.handler = uprobe_multi_link_handler;\n\n\t\tif (pid)\n\t\t\tuprobes[i].consumer.filter = uprobe_multi_link_filter;\n\t}\n\n\tlink->cnt = cnt;\n\tlink->uprobes = uprobes;\n\tlink->path = path;\n\tlink->task = task;\n\tlink->flags = flags;\n\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_UPROBE_MULTI,\n\t\t      &bpf_uprobe_multi_link_lops, prog);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tuprobes[i].uprobe = uprobe_register(d_real_inode(link->path.dentry),\n\t\t\t\t\t\t    uprobes[i].offset,\n\t\t\t\t\t\t    uprobes[i].ref_ctr_offset,\n\t\t\t\t\t\t    &uprobes[i].consumer);\n\t\tif (IS_ERR(uprobes[i].uprobe)) {\n\t\t\terr = PTR_ERR(uprobes[i].uprobe);\n\t\t\tlink->cnt = i;\n\t\t\tgoto error_unregister;\n\t\t}\n\t}\n\n\terr = bpf_link_prime(&link->link, &link_primer);\n\tif (err)\n\t\tgoto error_unregister;\n\n\treturn bpf_link_settle(&link_primer);\n\nerror_unregister:\n\tbpf_uprobe_unregister(uprobes, link->cnt);\n\nerror_free:\n\tkvfree(uprobes);\n\tkfree(link);\n\tif (task)\n\t\tput_task_struct(task);\nerror_path_put:\n\tpath_put(&path);\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-47675"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/xen/privcmd.c",
      "func_name": "privcmd_irqfd_assign",
      "func_body": "static int privcmd_irqfd_assign(struct privcmd_irqfd *irqfd)\n{\n\tstruct privcmd_kernel_irqfd *kirqfd, *tmp;\n\tunsigned long flags;\n\t__poll_t events;\n\tstruct fd f;\n\tvoid *dm_op;\n\tint ret, idx;\n\n\tkirqfd = kzalloc(sizeof(*kirqfd) + irqfd->size, GFP_KERNEL);\n\tif (!kirqfd)\n\t\treturn -ENOMEM;\n\tdm_op = kirqfd + 1;\n\n\tif (copy_from_user(dm_op, u64_to_user_ptr(irqfd->dm_op), irqfd->size)) {\n\t\tret = -EFAULT;\n\t\tgoto error_kfree;\n\t}\n\n\tkirqfd->xbufs.size = irqfd->size;\n\tset_xen_guest_handle(kirqfd->xbufs.h, dm_op);\n\tkirqfd->dom = irqfd->dom;\n\tINIT_WORK(&kirqfd->shutdown, irqfd_shutdown);\n\n\tf = fdget(irqfd->fd);\n\tif (!f.file) {\n\t\tret = -EBADF;\n\t\tgoto error_kfree;\n\t}\n\n\tkirqfd->eventfd = eventfd_ctx_fileget(f.file);\n\tif (IS_ERR(kirqfd->eventfd)) {\n\t\tret = PTR_ERR(kirqfd->eventfd);\n\t\tgoto error_fd_put;\n\t}\n\n\t/*\n\t * Install our own custom wake-up handling so we are notified via a\n\t * callback whenever someone signals the underlying eventfd.\n\t */\n\tinit_waitqueue_func_entry(&kirqfd->wait, irqfd_wakeup);\n\tinit_poll_funcptr(&kirqfd->pt, irqfd_poll_func);\n\n\tspin_lock_irqsave(&irqfds_lock, flags);\n\n\tlist_for_each_entry(tmp, &irqfds_list, list) {\n\t\tif (kirqfd->eventfd == tmp->eventfd) {\n\t\t\tret = -EBUSY;\n\t\t\tspin_unlock_irqrestore(&irqfds_lock, flags);\n\t\t\tgoto error_eventfd;\n\t\t}\n\t}\n\n\tidx = srcu_read_lock(&irqfds_srcu);\n\tlist_add_tail(&kirqfd->list, &irqfds_list);\n\tspin_unlock_irqrestore(&irqfds_lock, flags);\n\n\t/*\n\t * Check if there was an event already pending on the eventfd before we\n\t * registered, and trigger it as if we didn't miss it.\n\t */\n\tevents = vfs_poll(f.file, &kirqfd->pt);\n\tif (events & EPOLLIN)\n\t\tirqfd_inject(kirqfd);\n\n\tsrcu_read_unlock(&irqfds_srcu, idx);\n\n\t/*\n\t * Do not drop the file until the kirqfd is fully initialized, otherwise\n\t * we might race against the EPOLLHUP.\n\t */\n\tfdput(f);\n\treturn 0;\n\nerror_eventfd:\n\teventfd_ctx_put(kirqfd->eventfd);\n\nerror_fd_put:\n\tfdput(f);\n\nerror_kfree:\n\tkfree(kirqfd);\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-46762"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "mm/memory.c",
      "func_name": "lock_vma_under_rcu",
      "func_body": "struct vm_area_struct *lock_vma_under_rcu(struct mm_struct *mm,\n\t\t\t\t\t  unsigned long address)\n{\n\tMA_STATE(mas, &mm->mm_mt, address, address);\n\tstruct vm_area_struct *vma;\n\n\trcu_read_lock();\nretry:\n\tvma = mas_walk(&mas);\n\tif (!vma)\n\t\tgoto inval;\n\n\t/* Only anonymous and tcp vmas are supported for now */\n\tif (!vma_is_anonymous(vma) && !vma_is_tcp(vma))\n\t\tgoto inval;\n\n\tif (!vma_start_read(vma))\n\t\tgoto inval;\n\n\t/*\n\t * find_mergeable_anon_vma uses adjacent vmas which are not locked.\n\t * This check must happen after vma_start_read(); otherwise, a\n\t * concurrent mremap() with MREMAP_DONTUNMAP could dissociate the VMA\n\t * from its anon_vma.\n\t */\n\tif (unlikely(!vma->anon_vma && !vma_is_tcp(vma)))\n\t\tgoto inval_end_read;\n\n\t/*\n\t * Due to the possibility of userfault handler dropping mmap_lock, avoid\n\t * it for now and fall back to page fault handling under mmap_lock.\n\t */\n\tif (userfaultfd_armed(vma))\n\t\tgoto inval_end_read;\n\n\t/* Check since vm_start/vm_end might change before we lock the VMA */\n\tif (unlikely(address < vma->vm_start || address >= vma->vm_end))\n\t\tgoto inval_end_read;\n\n\t/* Check if the VMA got isolated after we found it */\n\tif (vma->detached) {\n\t\tvma_end_read(vma);\n\t\tcount_vm_vma_lock_event(VMA_LOCK_MISS);\n\t\t/* The area was replaced with another one */\n\t\tgoto retry;\n\t}\n\n\trcu_read_unlock();\n\treturn vma;\n\ninval_end_read:\n\tvma_end_read(vma);\ninval:\n\trcu_read_unlock();\n\tcount_vm_vma_lock_event(VMA_LOCK_ABORT);\n\treturn NULL;\n}\n",
      "cve_list": [
        "CVE-2024-1312"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/media/tuners/xc2028.c",
      "func_name": "load_firmware_cb",
      "func_body": "static void load_firmware_cb(const struct firmware *fw,\n\t\t\t     void *context)\n{\n\tstruct dvb_frontend *fe = context;\n\tstruct xc2028_data *priv;\n\tint rc;\n\n\tif (!fe) {\n\t\tpr_warn(\"xc2028: No frontend in %s\\n\", __func__);\n\t\treturn;\n\t}\n\n\tpriv = fe->tuner_priv;\n\n\ttuner_dbg(\"request_firmware_nowait(): %s\\n\", fw ? \"OK\" : \"error\");\n\tif (!fw) {\n\t\ttuner_err(\"Could not load firmware %s.\\n\", priv->fname);\n\t\tpriv->state = XC2028_NODEV;\n\t\treturn;\n\t}\n\n\trc = load_all_firmwares(fe, fw);\n\n\trelease_firmware(fw);\n\n\tif (rc < 0)\n\t\treturn;\n\tpriv->state = XC2028_ACTIVE;\n}\n",
      "cve_list": [
        "CVE-2024-43900"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ceph/mon_client.c",
      "func_name": "delayed_work",
      "func_body": "static void delayed_work(struct work_struct *work)\n{\n\tstruct ceph_mon_client *monc =\n\t\tcontainer_of(work, struct ceph_mon_client, delayed_work.work);\n\n\tmutex_lock(&monc->mutex);\n\tdout(\"%s mon%d\\n\", __func__, monc->cur_mon);\n\tif (monc->cur_mon < 0) {\n\t\tgoto out;\n\t}\n\n\tif (monc->hunting) {\n\t\tdout(\"%s continuing hunt\\n\", __func__);\n\t\treopen_session(monc);\n\t} else {\n\t\tint is_auth = ceph_auth_is_authenticated(monc->auth);\n\n\t\tdout(\"%s is_authed %d\\n\", __func__, is_auth);\n\t\tif (ceph_con_keepalive_expired(&monc->con,\n\t\t\t\t\t       CEPH_MONC_PING_TIMEOUT)) {\n\t\t\tdout(\"monc keepalive timeout\\n\");\n\t\t\tis_auth = 0;\n\t\t\treopen_session(monc);\n\t\t}\n\n\t\tif (!monc->hunting) {\n\t\t\tceph_con_keepalive(&monc->con);\n\t\t\t__validate_auth(monc);\n\t\t\tun_backoff(monc);\n\t\t}\n\n\t\tif (is_auth &&\n\t\t    !(monc->con.peer_features & CEPH_FEATURE_MON_STATEFUL_SUB)) {\n\t\t\tunsigned long now = jiffies;\n\n\t\t\tdout(\"%s renew subs? now %lu renew after %lu\\n\",\n\t\t\t     __func__, now, monc->sub_renew_after);\n\t\t\tif (time_after_eq(now, monc->sub_renew_after))\n\t\t\t\t__send_subscribe(monc);\n\t\t}\n\t}\n\t__schedule_delayed(monc);\n\nout:\n\tmutex_unlock(&monc->mutex);\n}\n",
      "cve_list": [
        "CVE-2024-42232"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ceph/mon_client.c",
      "func_name": "ceph_monc_stop",
      "func_body": "void ceph_monc_stop(struct ceph_mon_client *monc)\n{\n\tdout(\"stop\\n\");\n\n\tmutex_lock(&monc->mutex);\n\t__close_session(monc);\n\tmonc->hunting = false;\n\tmonc->cur_mon = -1;\n\tmutex_unlock(&monc->mutex);\n\n\tcancel_delayed_work_sync(&monc->delayed_work);\n\n\t/*\n\t * flush msgr queue before we destroy ourselves to ensure that:\n\t *  - any work that references our embedded con is finished.\n\t *  - any osd_client or other work that may reference an authorizer\n\t *    finishes before we shut down the auth subsystem.\n\t */\n\tceph_msgr_flush();\n\n\tceph_auth_destroy(monc->auth);\n\n\tWARN_ON(!RB_EMPTY_ROOT(&monc->generic_request_tree));\n\n\tceph_msg_put(monc->m_auth);\n\tceph_msg_put(monc->m_auth_reply);\n\tceph_msg_put(monc->m_subscribe);\n\tceph_msg_put(monc->m_subscribe_ack);\n\n\tkfree(monc->monmap);\n}\n",
      "cve_list": [
        "CVE-2024-42232"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/core/sock.c",
      "func_name": "sk_common_release",
      "func_body": "void sk_common_release(struct sock *sk)\n{\n\tif (sk->sk_prot->destroy)\n\t\tsk->sk_prot->destroy(sk);\n\n\t/*\n\t * Observation: when sk_common_release is called, processes have\n\t * no access to socket. But net still has.\n\t * Step one, detach it from networking:\n\t *\n\t * A. Remove from hash tables.\n\t */\n\n\tsk->sk_prot->unhash(sk);\n\n\tif (sk->sk_socket)\n\t\tsk->sk_socket->sk = NULL;\n\n\t/*\n\t * In this point socket cannot receive new packets, but it is possible\n\t * that some packets are in flight because some CPU runs receiver and\n\t * did hash table lookup before we unhashed socket. They will achieve\n\t * receive queue and will be purged by socket destructor.\n\t *\n\t * Also we still have packets pending on receive queue and probably,\n\t * our own packets waiting in device queues. sock_destroy will drain\n\t * receive queue, but transmitted packets will delay socket destruction\n\t * until the last reference will be released.\n\t */\n\n\tsock_orphan(sk);\n\n\txfrm_sk_free_policy(sk);\n\n\tsock_put(sk);\n}\n",
      "cve_list": [
        "CVE-2024-40954"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/xe/xe_exec_queue.c",
      "func_name": "xe_exec_queue_create_ioctl",
      "func_body": "int xe_exec_queue_create_ioctl(struct drm_device *dev, void *data,\n\t\t\t       struct drm_file *file)\n{\n\tstruct xe_device *xe = to_xe_device(dev);\n\tstruct xe_file *xef = to_xe_file(file);\n\tstruct drm_xe_exec_queue_create *args = data;\n\tstruct drm_xe_engine_class_instance eci[XE_HW_ENGINE_MAX_INSTANCE];\n\tstruct drm_xe_engine_class_instance __user *user_eci =\n\t\tu64_to_user_ptr(args->instances);\n\tstruct xe_hw_engine *hwe;\n\tstruct xe_vm *vm, *migrate_vm;\n\tstruct xe_gt *gt;\n\tstruct xe_exec_queue *q = NULL;\n\tu32 logical_mask;\n\tu32 id;\n\tu32 len;\n\tint err;\n\n\tif (XE_IOCTL_DBG(xe, args->flags) ||\n\t    XE_IOCTL_DBG(xe, args->reserved[0] || args->reserved[1]))\n\t\treturn -EINVAL;\n\n\tlen = args->width * args->num_placements;\n\tif (XE_IOCTL_DBG(xe, !len || len > XE_HW_ENGINE_MAX_INSTANCE))\n\t\treturn -EINVAL;\n\n\terr = __copy_from_user(eci, user_eci,\n\t\t\t       sizeof(struct drm_xe_engine_class_instance) *\n\t\t\t       len);\n\tif (XE_IOCTL_DBG(xe, err))\n\t\treturn -EFAULT;\n\n\tif (XE_IOCTL_DBG(xe, eci[0].gt_id >= xe->info.gt_count))\n\t\treturn -EINVAL;\n\n\tif (eci[0].engine_class == DRM_XE_ENGINE_CLASS_VM_BIND) {\n\t\tfor_each_gt(gt, xe, id) {\n\t\t\tstruct xe_exec_queue *new;\n\t\t\tu32 flags;\n\n\t\t\tif (xe_gt_is_media_type(gt))\n\t\t\t\tcontinue;\n\n\t\t\teci[0].gt_id = gt->info.id;\n\t\t\tlogical_mask = bind_exec_queue_logical_mask(xe, gt, eci,\n\t\t\t\t\t\t\t\t    args->width,\n\t\t\t\t\t\t\t\t    args->num_placements);\n\t\t\tif (XE_IOCTL_DBG(xe, !logical_mask))\n\t\t\t\treturn -EINVAL;\n\n\t\t\thwe = find_hw_engine(xe, eci[0]);\n\t\t\tif (XE_IOCTL_DBG(xe, !hwe))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* The migration vm doesn't hold rpm ref */\n\t\t\txe_pm_runtime_get_noresume(xe);\n\n\t\t\tflags = EXEC_QUEUE_FLAG_VM | (id ? EXEC_QUEUE_FLAG_BIND_ENGINE_CHILD : 0);\n\n\t\t\tmigrate_vm = xe_migrate_get_vm(gt_to_tile(gt)->migrate);\n\t\t\tnew = xe_exec_queue_create(xe, migrate_vm, logical_mask,\n\t\t\t\t\t\t   args->width, hwe, flags,\n\t\t\t\t\t\t   args->extensions);\n\n\t\t\txe_pm_runtime_put(xe); /* now held by engine */\n\n\t\t\txe_vm_put(migrate_vm);\n\t\t\tif (IS_ERR(new)) {\n\t\t\t\terr = PTR_ERR(new);\n\t\t\t\tif (q)\n\t\t\t\t\tgoto put_exec_queue;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (id == 0)\n\t\t\t\tq = new;\n\t\t\telse\n\t\t\t\tlist_add_tail(&new->multi_gt_list,\n\t\t\t\t\t      &q->multi_gt_link);\n\t\t}\n\t} else {\n\t\tgt = xe_device_get_gt(xe, eci[0].gt_id);\n\t\tlogical_mask = calc_validate_logical_mask(xe, gt, eci,\n\t\t\t\t\t\t\t  args->width,\n\t\t\t\t\t\t\t  args->num_placements);\n\t\tif (XE_IOCTL_DBG(xe, !logical_mask))\n\t\t\treturn -EINVAL;\n\n\t\thwe = find_hw_engine(xe, eci[0]);\n\t\tif (XE_IOCTL_DBG(xe, !hwe))\n\t\t\treturn -EINVAL;\n\n\t\tvm = xe_vm_lookup(xef, args->vm_id);\n\t\tif (XE_IOCTL_DBG(xe, !vm))\n\t\t\treturn -ENOENT;\n\n\t\terr = down_read_interruptible(&vm->lock);\n\t\tif (err) {\n\t\t\txe_vm_put(vm);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (XE_IOCTL_DBG(xe, xe_vm_is_closed_or_banned(vm))) {\n\t\t\tup_read(&vm->lock);\n\t\t\txe_vm_put(vm);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tq = xe_exec_queue_create(xe, vm, logical_mask,\n\t\t\t\t\t args->width, hwe, 0,\n\t\t\t\t\t args->extensions);\n\t\tup_read(&vm->lock);\n\t\txe_vm_put(vm);\n\t\tif (IS_ERR(q))\n\t\t\treturn PTR_ERR(q);\n\n\t\tif (xe_vm_in_preempt_fence_mode(vm)) {\n\t\t\tq->lr.context = dma_fence_context_alloc(1);\n\n\t\t\terr = xe_vm_add_compute_exec_queue(vm, q);\n\t\t\tif (XE_IOCTL_DBG(xe, err))\n\t\t\t\tgoto put_exec_queue;\n\t\t}\n\t}\n\n\tmutex_lock(&xef->exec_queue.lock);\n\terr = xa_alloc(&xef->exec_queue.xa, &id, q, xa_limit_32b, GFP_KERNEL);\n\tmutex_unlock(&xef->exec_queue.lock);\n\tif (err)\n\t\tgoto kill_exec_queue;\n\n\targs->exec_queue_id = id;\n\tq->xef = xe_file_get(xef);\n\n\treturn 0;\n\nkill_exec_queue:\n\txe_exec_queue_kill(q);\nput_exec_queue:\n\txe_exec_queue_put(q);\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-46683"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/xe/xe_preempt_fence.c",
      "func_name": "xe_preempt_fence_arm",
      "func_body": "struct dma_fence *\nxe_preempt_fence_arm(struct xe_preempt_fence *pfence, struct xe_exec_queue *q,\n\t\t     u64 context, u32 seqno)\n{\n\tlist_del_init(&pfence->link);\n\tpfence->q = xe_exec_queue_get(q);\n\tspin_lock_init(&pfence->lock);\n\tdma_fence_init(&pfence->base, &preempt_fence_ops,\n\t\t      &pfence->lock, context, seqno);\n\n\treturn &pfence->base;\n}\n",
      "cve_list": [
        "CVE-2024-46683"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/kcm/kcmsock.c",
      "func_name": "kcm_sendmsg",
      "func_body": "static int kcm_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct kcm_sock *kcm = kcm_sk(sk);\n\tstruct sk_buff *skb = NULL, *head = NULL;\n\tsize_t copy, copied = 0;\n\tlong timeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\tint eor = (sock->type == SOCK_DGRAM) ?\n\t\t  !(msg->msg_flags & MSG_MORE) : !!(msg->msg_flags & MSG_EOR);\n\tint err = -EPIPE;\n\n\tmutex_lock(&kcm->tx_mutex);\n\tlock_sock(sk);\n\n\t/* Per tcp_sendmsg this should be in poll */\n\tsk_clear_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\n\tif (sk->sk_err)\n\t\tgoto out_error;\n\n\tif (kcm->seq_skb) {\n\t\t/* Previously opened message */\n\t\thead = kcm->seq_skb;\n\t\tskb = kcm_tx_msg(head)->last_skb;\n\t\tgoto start;\n\t}\n\n\t/* Call the sk_stream functions to manage the sndbuf mem. */\n\tif (!sk_stream_memory_free(sk)) {\n\t\tkcm_push(kcm);\n\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\t\terr = sk_stream_wait_memory(sk, &timeo);\n\t\tif (err)\n\t\t\tgoto out_error;\n\t}\n\n\tif (msg_data_left(msg)) {\n\t\t/* New message, alloc head skb */\n\t\thead = alloc_skb(0, sk->sk_allocation);\n\t\twhile (!head) {\n\t\t\tkcm_push(kcm);\n\t\t\terr = sk_stream_wait_memory(sk, &timeo);\n\t\t\tif (err)\n\t\t\t\tgoto out_error;\n\n\t\t\thead = alloc_skb(0, sk->sk_allocation);\n\t\t}\n\n\t\tskb = head;\n\n\t\t/* Set ip_summed to CHECKSUM_UNNECESSARY to avoid calling\n\t\t * csum_and_copy_from_iter from skb_do_copy_data_nocache.\n\t\t */\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t}\n\nstart:\n\twhile (msg_data_left(msg)) {\n\t\tbool merge = true;\n\t\tint i = skb_shinfo(skb)->nr_frags;\n\t\tstruct page_frag *pfrag = sk_page_frag(sk);\n\n\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\tgoto wait_for_memory;\n\n\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t      pfrag->offset)) {\n\t\t\tif (i == MAX_SKB_FRAGS) {\n\t\t\t\tstruct sk_buff *tskb;\n\n\t\t\t\ttskb = alloc_skb(0, sk->sk_allocation);\n\t\t\t\tif (!tskb)\n\t\t\t\t\tgoto wait_for_memory;\n\n\t\t\t\tif (head == skb)\n\t\t\t\t\tskb_shinfo(head)->frag_list = tskb;\n\t\t\t\telse\n\t\t\t\t\tskb->next = tskb;\n\n\t\t\t\tskb = tskb;\n\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmerge = false;\n\t\t}\n\n\t\tif (msg->msg_flags & MSG_SPLICE_PAGES) {\n\t\t\tcopy = msg_data_left(msg);\n\t\t\tif (!sk_wmem_schedule(sk, copy))\n\t\t\t\tgoto wait_for_memory;\n\n\t\t\terr = skb_splice_from_iter(skb, &msg->msg_iter, copy,\n\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\tif (err < 0) {\n\t\t\t\tif (err == -EMSGSIZE)\n\t\t\t\t\tgoto wait_for_memory;\n\t\t\t\tgoto out_error;\n\t\t\t}\n\n\t\t\tcopy = err;\n\t\t\tskb_shinfo(skb)->flags |= SKBFL_SHARED_FRAG;\n\t\t\tsk_wmem_queued_add(sk, copy);\n\t\t\tsk_mem_charge(sk, copy);\n\n\t\t\tif (head != skb)\n\t\t\t\thead->truesize += copy;\n\t\t} else {\n\t\t\tcopy = min_t(int, msg_data_left(msg),\n\t\t\t\t     pfrag->size - pfrag->offset);\n\t\t\tif (!sk_wmem_schedule(sk, copy))\n\t\t\t\tgoto wait_for_memory;\n\n\t\t\terr = skb_copy_to_page_nocache(sk, &msg->msg_iter, skb,\n\t\t\t\t\t\t       pfrag->page,\n\t\t\t\t\t\t       pfrag->offset,\n\t\t\t\t\t\t       copy);\n\t\t\tif (err)\n\t\t\t\tgoto out_error;\n\n\t\t\t/* Update the skb. */\n\t\t\tif (merge) {\n\t\t\t\tskb_frag_size_add(\n\t\t\t\t\t&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\t} else {\n\t\t\t\tskb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t   pfrag->offset, copy);\n\t\t\t\tget_page(pfrag->page);\n\t\t\t}\n\n\t\t\tpfrag->offset += copy;\n\t\t}\n\n\t\tcopied += copy;\n\t\tif (head != skb) {\n\t\t\thead->len += copy;\n\t\t\thead->data_len += copy;\n\t\t}\n\n\t\tcontinue;\n\nwait_for_memory:\n\t\tkcm_push(kcm);\n\t\terr = sk_stream_wait_memory(sk, &timeo);\n\t\tif (err)\n\t\t\tgoto out_error;\n\t}\n\n\tif (eor) {\n\t\tbool not_busy = skb_queue_empty(&sk->sk_write_queue);\n\n\t\tif (head) {\n\t\t\t/* Message complete, queue it on send buffer */\n\t\t\t__skb_queue_tail(&sk->sk_write_queue, head);\n\t\t\tkcm->seq_skb = NULL;\n\t\t\tKCM_STATS_INCR(kcm->stats.tx_msgs);\n\t\t}\n\n\t\tif (msg->msg_flags & MSG_BATCH) {\n\t\t\tkcm->tx_wait_more = true;\n\t\t} else if (kcm->tx_wait_more || not_busy) {\n\t\t\terr = kcm_write_msgs(kcm);\n\t\t\tif (err < 0) {\n\t\t\t\t/* We got a hard error in write_msgs but have\n\t\t\t\t * already queued this message. Report an error\n\t\t\t\t * in the socket, but don't affect return value\n\t\t\t\t * from sendmsg\n\t\t\t\t */\n\t\t\t\tpr_warn(\"KCM: Hard failure on kcm_write_msgs\\n\");\n\t\t\t\treport_csk_error(&kcm->sk, -err);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Message not complete, save state */\npartial_message:\n\t\tif (head) {\n\t\t\tkcm->seq_skb = head;\n\t\t\tkcm_tx_msg(head)->last_skb = skb;\n\t\t}\n\t}\n\n\tKCM_STATS_ADD(kcm->stats.tx_bytes, copied);\n\n\trelease_sock(sk);\n\tmutex_unlock(&kcm->tx_mutex);\n\treturn copied;\n\nout_error:\n\tkcm_push(kcm);\n\n\tif (sock->type == SOCK_SEQPACKET) {\n\t\t/* Wrote some bytes before encountering an\n\t\t * error, return partial success.\n\t\t */\n\t\tif (copied)\n\t\t\tgoto partial_message;\n\t\tif (head != kcm->seq_skb)\n\t\t\tkfree_skb(head);\n\t} else {\n\t\tkfree_skb(head);\n\t\tkcm->seq_skb = NULL;\n\t}\n\n\terr = sk_stream_error(sk, msg->msg_flags, err);\n\n\t/* make sure we wake any epoll edge trigger waiter */\n\tif (unlikely(skb_queue_len(&sk->sk_write_queue) == 0 && err == -EAGAIN))\n\t\tsk->sk_write_space(sk);\n\n\trelease_sock(sk);\n\tmutex_unlock(&kcm->tx_mutex);\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-44946"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/btrfs/compression.c",
      "func_name": "add_ra_bio_pages",
      "func_body": "static noinline int add_ra_bio_pages(struct inode *inode,\n\t\t\t\t     u64 compressed_end,\n\t\t\t\t     struct compressed_bio *cb,\n\t\t\t\t     int *memstall, unsigned long *pflags)\n{\n\tstruct btrfs_fs_info *fs_info = inode_to_fs_info(inode);\n\tunsigned long end_index;\n\tstruct bio *orig_bio = &cb->orig_bbio->bio;\n\tu64 cur = cb->orig_bbio->file_offset + orig_bio->bi_iter.bi_size;\n\tu64 isize = i_size_read(inode);\n\tint ret;\n\tstruct page *page;\n\tstruct extent_map *em;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_io_tree *tree;\n\tint sectors_missed = 0;\n\n\tem_tree = &BTRFS_I(inode)->extent_tree;\n\ttree = &BTRFS_I(inode)->io_tree;\n\n\tif (isize == 0)\n\t\treturn 0;\n\n\t/*\n\t * For current subpage support, we only support 64K page size,\n\t * which means maximum compressed extent size (128K) is just 2x page\n\t * size.\n\t * This makes readahead less effective, so here disable readahead for\n\t * subpage for now, until full compressed write is supported.\n\t */\n\tif (fs_info->sectorsize < PAGE_SIZE)\n\t\treturn 0;\n\n\tend_index = (i_size_read(inode) - 1) >> PAGE_SHIFT;\n\n\twhile (cur < compressed_end) {\n\t\tu64 page_end;\n\t\tu64 pg_index = cur >> PAGE_SHIFT;\n\t\tu32 add_size;\n\n\t\tif (pg_index > end_index)\n\t\t\tbreak;\n\n\t\tpage = xa_load(&mapping->i_pages, pg_index);\n\t\tif (page && !xa_is_value(page)) {\n\t\t\tsectors_missed += (PAGE_SIZE - offset_in_page(cur)) >>\n\t\t\t\t\t  fs_info->sectorsize_bits;\n\n\t\t\t/* Beyond threshold, no need to continue */\n\t\t\tif (sectors_missed > 4)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Jump to next page start as we already have page for\n\t\t\t * current offset.\n\t\t\t */\n\t\t\tcur = (pg_index << PAGE_SHIFT) + PAGE_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = __page_cache_alloc(mapping_gfp_constraint(mapping,\n\t\t\t\t\t\t\t\t ~__GFP_FS));\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tif (add_to_page_cache_lru(page, mapping, pg_index, GFP_NOFS)) {\n\t\t\tput_page(page);\n\t\t\t/* There is already a page, skip to page end */\n\t\t\tcur = (pg_index << PAGE_SHIFT) + PAGE_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!*memstall && PageWorkingset(page)) {\n\t\t\tpsi_memstall_enter(pflags);\n\t\t\t*memstall = 1;\n\t\t}\n\n\t\tret = set_page_extent_mapped(page);\n\t\tif (ret < 0) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tpage_end = (pg_index << PAGE_SHIFT) + PAGE_SIZE - 1;\n\t\tlock_extent(tree, cur, page_end, NULL);\n\t\tread_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, cur, page_end + 1 - cur);\n\t\tread_unlock(&em_tree->lock);\n\n\t\t/*\n\t\t * At this point, we have a locked page in the page cache for\n\t\t * these bytes in the file.  But, we have to make sure they map\n\t\t * to this compressed extent on disk.\n\t\t */\n\t\tif (!em || cur < em->start ||\n\t\t    (cur + fs_info->sectorsize > extent_map_end(em)) ||\n\t\t    (extent_map_block_start(em) >> SECTOR_SHIFT) !=\n\t\t    orig_bio->bi_iter.bi_sector) {\n\t\t\tfree_extent_map(em);\n\t\t\tunlock_extent(tree, cur, page_end, NULL);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tbreak;\n\t\t}\n\t\tadd_size = min(em->start + em->len, page_end + 1) - cur;\n\t\tfree_extent_map(em);\n\n\t\tif (page->index == end_index) {\n\t\t\tsize_t zero_offset = offset_in_page(isize);\n\n\t\t\tif (zero_offset) {\n\t\t\t\tint zeros;\n\t\t\t\tzeros = PAGE_SIZE - zero_offset;\n\t\t\t\tmemzero_page(page, zero_offset, zeros);\n\t\t\t}\n\t\t}\n\n\t\tret = bio_add_page(orig_bio, page, add_size, offset_in_page(cur));\n\t\tif (ret != add_size) {\n\t\t\tunlock_extent(tree, cur, page_end, NULL);\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * If it's subpage, we also need to increase its\n\t\t * subpage::readers number, as at endio we will decrease\n\t\t * subpage::readers and to unlock the page.\n\t\t */\n\t\tif (fs_info->sectorsize < PAGE_SIZE)\n\t\t\tbtrfs_subpage_start_reader(fs_info, page_folio(page),\n\t\t\t\t\t\t   cur, add_size);\n\t\tput_page(page);\n\t\tcur += add_size;\n\t}\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-42314"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/bridge/br_multicast.c",
      "func_name": "br_multicast_del_port",
      "func_body": "void br_multicast_del_port(struct net_bridge_port *port)\n{\n\tstruct net_bridge *br = port->br;\n\tstruct net_bridge_port_group *pg;\n\tstruct hlist_node *n;\n\n\t/* Take care of the remaining groups, only perm ones should be left */\n\tspin_lock_bh(&br->multicast_lock);\n\thlist_for_each_entry_safe(pg, n, &port->mglist, mglist)\n\t\tbr_multicast_find_del_pg(br, pg);\n\tspin_unlock_bh(&br->multicast_lock);\n\tflush_work(&br->mcast_gc_work);\n\tbr_multicast_port_ctx_deinit(&port->multicast_ctx);\n\tfree_percpu(port->mcast_stats);\n}\n",
      "cve_list": [
        "CVE-2024-44934"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ipv4/route.c",
      "func_name": "ipv4_negative_advice",
      "func_body": "static void ipv4_negative_advice(struct sock *sk,\n\t\t\t\t struct dst_entry *dst)\n{\n\tstruct rtable *rt = dst_rtable(dst);\n\n\tif ((dst->obsolete > 0) ||\n\t    (rt->rt_flags & RTCF_REDIRECTED) ||\n\t    rt->dst.expires)\n\t\tsk_dst_reset(sk);\n}\n",
      "cve_list": [
        "CVE-2024-36971"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ipv6/route.c",
      "func_name": "ip6_negative_advice",
      "func_body": "static void ip6_negative_advice(struct sock *sk,\n\t\t\t\tstruct dst_entry *dst)\n{\n\tstruct rt6_info *rt = dst_rt6_info(dst);\n\n\tif (rt->rt6i_flags & RTF_CACHE) {\n\t\trcu_read_lock();\n\t\tif (rt6_check_expired(rt)) {\n\t\t\t/* counteract the dst_release() in sk_dst_reset() */\n\t\t\tdst_hold(dst);\n\t\t\tsk_dst_reset(sk);\n\n\t\t\trt6_remove_exception_rt(rt);\n\t\t}\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tsk_dst_reset(sk);\n}\n",
      "cve_list": [
        "CVE-2024-36971"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/xfrm/xfrm_policy.c",
      "func_name": "xfrm_negative_advice",
      "func_body": "static void xfrm_negative_advice(struct sock *sk, struct dst_entry *dst)\n{\n\tif (dst->obsolete)\n\t\tsk_dst_reset(sk);\n}\n",
      "cve_list": [
        "CVE-2024-36971"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/amdgpu/amdgpu_mes.c",
      "func_name": "amdgpu_mes_remove_ring",
      "func_body": "void amdgpu_mes_remove_ring(struct amdgpu_device *adev,\n\t\t\t    struct amdgpu_ring *ring)\n{\n\tif (!ring)\n\t\treturn;\n\n\tamdgpu_mes_remove_hw_queue(adev, ring->hw_queue_id);\n\tdel_timer_sync(&ring->fence_drv.fallback_timer);\n\tamdgpu_ring_fini(ring);\n\tkfree(ring);\n}\n",
      "cve_list": [
        "CVE-2024-38581"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/hid/amd-sfh-hid/amd_sfh_hid.c",
      "func_name": "amdtp_hid_remove",
      "func_body": "void amdtp_hid_remove(struct amdtp_cl_data *cli_data)\n{\n\tint i;\n\tstruct amdtp_hid_data *hid_data;\n\n\tfor (i = 0; i < cli_data->num_hid_devices; ++i) {\n\t\tif (cli_data->hid_sensor_hubs[i]) {\n\t\t\thid_data = cli_data->hid_sensor_hubs[i]->driver_data;\n\t\t\thid_destroy_device(cli_data->hid_sensor_hubs[i]);\n\t\t\tkfree(hid_data);\n\t\t\tcli_data->hid_sensor_hubs[i] = NULL;\n\t\t}\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-46746"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c",
      "func_name": "i915_vma_revoke_fence",
      "func_body": "void i915_vma_revoke_fence(struct i915_vma *vma)\n{\n\tstruct i915_fence_reg *fence = vma->fence;\n\tintel_wakeref_t wakeref;\n\n\tlockdep_assert_held(&vma->vm->mutex);\n\tif (!fence)\n\t\treturn;\n\n\tGEM_BUG_ON(fence->vma != vma);\n\ti915_active_wait(&fence->active);\n\tGEM_BUG_ON(!i915_active_is_idle(&fence->active));\n\tGEM_BUG_ON(atomic_read(&fence->pin_count));\n\n\tfence->tiling = 0;\n\tWRITE_ONCE(fence->vma, NULL);\n\tvma->fence = NULL;\n\n\t/*\n\t * Skip the write to HW if and only if the device is currently\n\t * suspended.\n\t *\n\t * If the driver does not currently hold a wakeref (if_in_use == 0),\n\t * the device may currently be runtime suspended, or it may be woken\n\t * up before the suspend takes place. If the device is not suspended\n\t * (powered down) and we skip clearing the fence register, the HW is\n\t * left in an undefined state where we may end up with multiple\n\t * registers overlapping.\n\t */\n\twith_intel_runtime_pm_if_active(fence_to_uncore(fence)->rpm, wakeref)\n\t\tfence_write(fence);\n}\n",
      "cve_list": [
        "CVE-2024-41092"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/renesas/rswitch.c",
      "func_name": "rswitch_tx_free",
      "func_body": "static void rswitch_tx_free(struct net_device *ndev)\n{\n\tstruct rswitch_device *rdev = netdev_priv(ndev);\n\tstruct rswitch_gwca_queue *gq = rdev->tx_queue;\n\tstruct rswitch_ext_desc *desc;\n\tstruct sk_buff *skb;\n\n\tfor (; rswitch_get_num_cur_queues(gq) > 0;\n\t     gq->dirty = rswitch_next_queue_index(gq, false, 1)) {\n\t\tdesc = &gq->tx_ring[gq->dirty];\n\t\tif ((desc->desc.die_dt & DT_MASK) != DT_FEMPTY)\n\t\t\tbreak;\n\n\t\tdma_rmb();\n\t\tskb = gq->skbs[gq->dirty];\n\t\tif (skb) {\n\t\t\trdev->ndev->stats.tx_packets++;\n\t\t\trdev->ndev->stats.tx_bytes += skb->len;\n\t\t\tdma_unmap_single(ndev->dev.parent,\n\t\t\t\t\t gq->unmap_addrs[gq->dirty],\n\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb_any(gq->skbs[gq->dirty]);\n\t\t\tgq->skbs[gq->dirty] = NULL;\n\t\t}\n\t\tdesc->desc.die_dt = DT_EEMPTY;\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-42108"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/xe/xe_sched_job.c",
      "func_name": "xe_sched_job_destroy",
      "func_body": "void xe_sched_job_destroy(struct kref *ref)\n{\n\tstruct xe_sched_job *job =\n\t\tcontainer_of(ref, struct xe_sched_job, refcount);\n\tstruct xe_device *xe = job_to_xe(job);\n\tstruct xe_exec_queue *q = job->q;\n\n\txe_sched_job_free_fences(job);\n\tdma_fence_put(job->fence);\n\tdrm_sched_job_cleanup(&job->drm);\n\tjob_free(job);\n\txe_exec_queue_put(q);\n\txe_pm_runtime_put(xe);\n}\n",
      "cve_list": [
        "CVE-2024-44978"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/pci/msi/msi.c",
      "func_name": "msi_capability_init",
      "func_body": "static int msi_capability_init(struct pci_dev *dev, int nvec,\n\t\t\t       struct irq_affinity *affd)\n{\n\tstruct irq_affinity_desc *masks = NULL;\n\tstruct msi_desc *entry, desc;\n\tint ret;\n\n\t/* Reject multi-MSI early on irq domain enabled architectures */\n\tif (nvec > 1 && !pci_msi_domain_supports(dev, MSI_FLAG_MULTI_PCI_MSI, ALLOW_LEGACY))\n\t\treturn 1;\n\n\t/*\n\t * Disable MSI during setup in the hardware, but mark it enabled\n\t * so that setup code can evaluate it.\n\t */\n\tpci_msi_set_enable(dev, 0);\n\tdev->msi_enabled = 1;\n\n\tif (affd)\n\t\tmasks = irq_create_affinity_masks(nvec, affd);\n\n\tmsi_lock_descs(&dev->dev);\n\tret = msi_setup_msi_desc(dev, nvec, masks);\n\tif (ret)\n\t\tgoto fail;\n\n\t/* All MSIs are unmasked by default; mask them all */\n\tentry = msi_first_desc(&dev->dev, MSI_DESC_ALL);\n\tpci_msi_mask(entry, msi_multi_mask(entry));\n\t/*\n\t * Copy the MSI descriptor for the error path because\n\t * pci_msi_setup_msi_irqs() will free it for the hierarchical\n\t * interrupt domain case.\n\t */\n\tmemcpy(&desc, entry, sizeof(desc));\n\n\t/* Configure MSI capability structure */\n\tret = pci_msi_setup_msi_irqs(dev, nvec, PCI_CAP_ID_MSI);\n\tif (ret)\n\t\tgoto err;\n\n\tret = msi_verify_entries(dev);\n\tif (ret)\n\t\tgoto err;\n\n\t/* Set MSI enabled bits\t*/\n\tpci_intx_for_msi(dev, 0);\n\tpci_msi_set_enable(dev, 1);\n\n\tpcibios_free_irq(dev);\n\tdev->irq = entry->irq;\n\tgoto unlock;\n\nerr:\n\tpci_msi_unmask(&desc, msi_multi_mask(&desc));\n\tpci_free_msi_irqs(dev);\nfail:\n\tdev->msi_enabled = 0;\nunlock:\n\tmsi_unlock_descs(&dev->dev);\n\tkfree(masks);\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-41096"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/media/platform/qcom/venus/vdec.c",
      "func_name": "vdec_close",
      "func_body": "static int vdec_close(struct file *file)\n{\n\tstruct venus_inst *inst = to_inst(file);\n\n\tvdec_pm_get(inst);\n\n\tcancel_work_sync(&inst->delayed_process_work);\n\tv4l2_m2m_ctx_release(inst->m2m_ctx);\n\tv4l2_m2m_release(inst->m2m_dev);\n\tvdec_ctrl_deinit(inst);\n\tida_destroy(&inst->dpb_ids);\n\thfi_session_destroy(inst);\n\tmutex_destroy(&inst->lock);\n\tmutex_destroy(&inst->ctx_q_lock);\n\tv4l2_fh_del(&inst->fh);\n\tv4l2_fh_exit(&inst->fh);\n\n\tvdec_pm_put(inst, false);\n\n\tkfree(inst);\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-42313"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/microchip/vcap/vcap_api_kunit.c",
      "func_name": "vcap_api_encode_rule_test",
      "func_body": "static void vcap_api_encode_rule_test(struct kunit *test)\n{\n\t/* Data used by VCAP Library callback */\n\tstatic u32 keydata[32] = {};\n\tstatic u32 mskdata[32] = {};\n\tstatic u32 actdata[32] = {};\n\n\tstruct vcap_admin is2_admin = {\n\t\t.vtype = VCAP_TYPE_IS2,\n\t\t.first_cid = 8000000,\n\t\t.last_cid = 8099999,\n\t\t.lookups = 4,\n\t\t.last_valid_addr = 3071,\n\t\t.first_valid_addr = 0,\n\t\t.last_used_addr = 800,\n\t\t.cache = {\n\t\t\t.keystream = keydata,\n\t\t\t.maskstream = mskdata,\n\t\t\t.actionstream = actdata,\n\t\t},\n\t};\n\tstruct vcap_rule *rule;\n\tstruct vcap_rule_internal *ri;\n\tint vcap_chain_id = 8000000;\n\tenum vcap_user user = VCAP_USER_VCAP_UTIL;\n\tu16 priority = 10;\n\tint id = 100;\n\tint ret;\n\tstruct vcap_u48_key smac = {\n\t\t.value = { 0x88, 0x75, 0x32, 0x34, 0x9e, 0xb1 },\n\t\t.mask = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }\n\t};\n\tstruct vcap_u48_key dmac = {\n\t\t.value = { 0x06, 0x05, 0x04, 0x03, 0x02, 0x01 },\n\t\t.mask = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }\n\t};\n\tu32 port_mask_rng_value = 0x05;\n\tu32 port_mask_rng_mask = 0x0f;\n\tu32 igr_port_mask_value = 0xffabcd01;\n\tu32 igr_port_mask_mask = ~0;\n\t/* counter is written as the first operation */\n\tu32 expwriteaddr[] = {792, 792, 793, 794, 795, 796, 797};\n\tint idx;\n\n\tvcap_test_api_init(&is2_admin);\n\n\t/* Allocate the rule */\n\trule = vcap_alloc_rule(&test_vctrl, &test_netdev, vcap_chain_id, user,\n\t\t\t       priority, id);\n\tKUNIT_EXPECT_PTR_NE(test, NULL, rule);\n\tri = (struct vcap_rule_internal *)rule;\n\n\t/* Add rule keys */\n\tret = vcap_rule_add_key_u48(rule, VCAP_KF_L2_DMAC, &dmac);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = vcap_rule_add_key_u48(rule, VCAP_KF_L2_SMAC, &smac);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = vcap_rule_add_key_bit(rule, VCAP_KF_ETYPE_LEN_IS, VCAP_BIT_1);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\t/* Cannot add the same field twice */\n\tret = vcap_rule_add_key_bit(rule, VCAP_KF_ETYPE_LEN_IS, VCAP_BIT_1);\n\tKUNIT_EXPECT_EQ(test, -EINVAL, ret);\n\tret = vcap_rule_add_key_bit(rule, VCAP_KF_IF_IGR_PORT_MASK_L3,\n\t\t\t\t    VCAP_BIT_ANY);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = vcap_rule_add_key_u32(rule, VCAP_KF_IF_IGR_PORT_MASK_RNG,\n\t\t\t\t    port_mask_rng_value, port_mask_rng_mask);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = vcap_rule_add_key_u32(rule, VCAP_KF_IF_IGR_PORT_MASK,\n\t\t\t\t    igr_port_mask_value, igr_port_mask_mask);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\n\t/* Add rule actions */\n\tret = vcap_rule_add_action_bit(rule, VCAP_AF_POLICE_ENA, VCAP_BIT_1);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = vcap_rule_add_action_u32(rule, VCAP_AF_CNT_ID, id);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = vcap_rule_add_action_u32(rule, VCAP_AF_MATCH_ID, 1);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tret = vcap_rule_add_action_u32(rule, VCAP_AF_MATCH_ID_MASK, 1);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\n\t/* For now the actionset is hardcoded */\n\tret = vcap_set_rule_set_actionset(rule, VCAP_AFS_BASE_TYPE);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\n\t/* Validation with validate keyset callback */\n\tret = vcap_val_rule(rule, ETH_P_ALL);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tKUNIT_EXPECT_EQ(test, VCAP_KFS_MAC_ETYPE, rule->keyset);\n\tKUNIT_EXPECT_EQ(test, VCAP_AFS_BASE_TYPE, rule->actionset);\n\tKUNIT_EXPECT_EQ(test, 6, ri->size);\n\tKUNIT_EXPECT_EQ(test, 2, ri->keyset_sw_regs);\n\tKUNIT_EXPECT_EQ(test, 4, ri->actionset_sw_regs);\n\n\t/* Enable lookup, so the rule will be written */\n\tret = vcap_enable_lookups(&test_vctrl, &test_netdev, 0,\n\t\t\t\t  rule->vcap_chain_id, rule->cookie, true);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\n\t/* Add rule with write callback */\n\tret = vcap_add_rule(rule);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\tKUNIT_EXPECT_EQ(test, 792, is2_admin.last_used_addr);\n\tfor (idx = 0; idx < ARRAY_SIZE(expwriteaddr); ++idx)\n\t\tKUNIT_EXPECT_EQ(test, expwriteaddr[idx], test_updateaddr[idx]);\n\n\t/* Check that the rule has been added */\n\tret = list_empty(&is2_admin.rules);\n\tKUNIT_EXPECT_EQ(test, false, ret);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n\n\tvcap_enable_lookups(&test_vctrl, &test_netdev, 0, 0,\n\t\t\t    rule->cookie, false);\n\n\tret = vcap_del_rule(&test_vctrl, &test_netdev, id);\n\tKUNIT_EXPECT_EQ(test, 0, ret);\n}\n",
      "cve_list": [
        "CVE-2024-46831"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/nvme/host/core.c",
      "func_name": "nvme_uninit_ctrl",
      "func_body": "void nvme_uninit_ctrl(struct nvme_ctrl *ctrl)\n{\n\tnvme_stop_keep_alive(ctrl);\n\tnvme_hwmon_exit(ctrl);\n\tnvme_fault_inject_fini(&ctrl->fault_inject);\n\tdev_pm_qos_hide_latency_tolerance(ctrl->device);\n\tcdev_device_del(&ctrl->cdev, ctrl->device);\n\tnvme_put_ctrl(ctrl);\n}\n",
      "cve_list": [
        "CVE-2024-45013"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "arch/powerpc/kvm/book3s_64_vio.c",
      "func_name": "kvm_spapr_tce_attach_iommu_group",
      "func_body": "long kvm_spapr_tce_attach_iommu_group(struct kvm *kvm, int tablefd,\n\t\t\t\t      struct iommu_group *grp)\n{\n\tstruct kvmppc_spapr_tce_table *stt = NULL;\n\tbool found = false;\n\tstruct iommu_table *tbl = NULL;\n\tstruct iommu_table_group *table_group;\n\tlong i;\n\tstruct kvmppc_spapr_tce_iommu_table *stit;\n\tstruct fd f;\n\n\tf = fdget(tablefd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(stt, &kvm->arch.spapr_tce_tables, list) {\n\t\tif (stt == f.file->private_data) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!found) {\n\t\tfdput(f);\n\t\treturn -EINVAL;\n\t}\n\n\ttable_group = iommu_group_get_iommudata(grp);\n\tif (WARN_ON(!table_group)) {\n\t\tfdput(f);\n\t\treturn -EFAULT;\n\t}\n\n\tfor (i = 0; i < IOMMU_TABLE_GROUP_MAX_TABLES; ++i) {\n\t\tstruct iommu_table *tbltmp = table_group->tables[i];\n\n\t\tif (!tbltmp)\n\t\t\tcontinue;\n\t\t/* Make sure hardware table parameters are compatible */\n\t\tif ((tbltmp->it_page_shift <= stt->page_shift) &&\n\t\t\t\t(tbltmp->it_offset << tbltmp->it_page_shift ==\n\t\t\t\t stt->offset << stt->page_shift) &&\n\t\t\t\t(tbltmp->it_size << tbltmp->it_page_shift >=\n\t\t\t\t stt->size << stt->page_shift)) {\n\t\t\t/*\n\t\t\t * Reference the table to avoid races with\n\t\t\t * add/remove DMA windows.\n\t\t\t */\n\t\t\ttbl = iommu_tce_table_get(tbltmp);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!tbl) {\n\t\tfdput(f);\n\t\treturn -EINVAL;\n\t}\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(stit, &stt->iommu_tables, next) {\n\t\tif (tbl != stit->tbl)\n\t\t\tcontinue;\n\n\t\tif (!kref_get_unless_zero(&stit->kref)) {\n\t\t\t/* stit is being destroyed */\n\t\t\tiommu_tce_table_put(tbl);\n\t\t\trcu_read_unlock();\n\t\t\tfdput(f);\n\t\t\treturn -ENOTTY;\n\t\t}\n\t\t/*\n\t\t * The table is already known to this KVM, we just increased\n\t\t * its KVM reference counter and can return.\n\t\t */\n\t\trcu_read_unlock();\n\t\tfdput(f);\n\t\treturn 0;\n\t}\n\trcu_read_unlock();\n\n\tstit = kzalloc(sizeof(*stit), GFP_KERNEL);\n\tif (!stit) {\n\t\tiommu_tce_table_put(tbl);\n\t\tfdput(f);\n\t\treturn -ENOMEM;\n\t}\n\n\tstit->tbl = tbl;\n\tkref_init(&stit->kref);\n\n\tlist_add_rcu(&stit->next, &stt->iommu_tables);\n\n\tfdput(f);\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-41070"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/atm/idt77252.c",
      "func_name": "dequeue_rx",
      "func_body": "static void\ndequeue_rx(struct idt77252_dev *card, struct rsq_entry *rsqe)\n{\n\tstruct atm_vcc *vcc;\n\tstruct sk_buff *skb;\n\tstruct rx_pool *rpp;\n\tstruct vc_map *vc;\n\tu32 header, vpi, vci;\n\tu32 stat;\n\tint i;\n\n\tstat = le32_to_cpu(rsqe->word_4);\n\n\tif (stat & SAR_RSQE_IDLE) {\n\t\tRXPRINTK(\"%s: message about inactive connection.\\n\",\n\t\t\t card->name);\n\t\treturn;\n\t}\n\n\tskb = sb_pool_skb(card, le32_to_cpu(rsqe->word_2));\n\tif (skb == NULL) {\n\t\tprintk(\"%s: NULL skb in %s, rsqe: %08x %08x %08x %08x\\n\",\n\t\t       card->name, __func__,\n\t\t       le32_to_cpu(rsqe->word_1), le32_to_cpu(rsqe->word_2),\n\t\t       le32_to_cpu(rsqe->word_3), le32_to_cpu(rsqe->word_4));\n\t\treturn;\n\t}\n\n\theader = le32_to_cpu(rsqe->word_1);\n\tvpi = (header >> 16) & 0x00ff;\n\tvci = (header >>  0) & 0xffff;\n\n\tRXPRINTK(\"%s: SDU for %d.%d received in buffer 0x%p (data 0x%p).\\n\",\n\t\t card->name, vpi, vci, skb, skb->data);\n\n\tif ((vpi >= (1 << card->vpibits)) || (vci != (vci & card->vcimask))) {\n\t\tprintk(\"%s: SDU received for out-of-range vc %u.%u\\n\",\n\t\t       card->name, vpi, vci);\n\t\trecycle_rx_skb(card, skb);\n\t\treturn;\n\t}\n\n\tvc = card->vcs[VPCI2VC(card, vpi, vci)];\n\tif (!vc || !test_bit(VCF_RX, &vc->flags)) {\n\t\tprintk(\"%s: SDU received on non RX vc %u.%u\\n\",\n\t\t       card->name, vpi, vci);\n\t\trecycle_rx_skb(card, skb);\n\t\treturn;\n\t}\n\n\tvcc = vc->rx_vcc;\n\n\tdma_sync_single_for_cpu(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),\n\t\t\t\tskb_end_pointer(skb) - skb->data,\n\t\t\t\tDMA_FROM_DEVICE);\n\n\tif ((vcc->qos.aal == ATM_AAL0) ||\n\t    (vcc->qos.aal == ATM_AAL34)) {\n\t\tstruct sk_buff *sb;\n\t\tunsigned char *cell;\n\t\tu32 aal0;\n\n\t\tcell = skb->data;\n\t\tfor (i = (stat & SAR_RSQE_CELLCNT); i; i--) {\n\t\t\tif ((sb = dev_alloc_skb(64)) == NULL) {\n\t\t\t\tprintk(\"%s: Can't allocate buffers for aal0.\\n\",\n\t\t\t\t       card->name);\n\t\t\t\tatomic_add(i, &vcc->stats->rx_drop);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!atm_charge(vcc, sb->truesize)) {\n\t\t\t\tRXPRINTK(\"%s: atm_charge() dropped aal0 packets.\\n\",\n\t\t\t\t\t card->name);\n\t\t\t\tatomic_add(i - 1, &vcc->stats->rx_drop);\n\t\t\t\tdev_kfree_skb(sb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taal0 = (vpi << ATM_HDR_VPI_SHIFT) |\n\t\t\t       (vci << ATM_HDR_VCI_SHIFT);\n\t\t\taal0 |= (stat & SAR_RSQE_EPDU) ? 0x00000002 : 0;\n\t\t\taal0 |= (stat & SAR_RSQE_CLP)  ? 0x00000001 : 0;\n\n\t\t\t*((u32 *) sb->data) = aal0;\n\t\t\tskb_put(sb, sizeof(u32));\n\t\t\tskb_put_data(sb, cell, ATM_CELL_PAYLOAD);\n\n\t\t\tATM_SKB(sb)->vcc = vcc;\n\t\t\t__net_timestamp(sb);\n\t\t\tvcc->push(vcc, sb);\n\t\t\tatomic_inc(&vcc->stats->rx);\n\n\t\t\tcell += ATM_CELL_PAYLOAD;\n\t\t}\n\n\t\trecycle_rx_skb(card, skb);\n\t\treturn;\n\t}\n\tif (vcc->qos.aal != ATM_AAL5) {\n\t\tprintk(\"%s: Unexpected AAL type in dequeue_rx(): %d.\\n\",\n\t\t       card->name, vcc->qos.aal);\n\t\trecycle_rx_skb(card, skb);\n\t\treturn;\n\t}\n\tskb->len = (stat & SAR_RSQE_CELLCNT) * ATM_CELL_PAYLOAD;\n\n\trpp = &vc->rcv.rx_pool;\n\n\t__skb_queue_tail(&rpp->queue, skb);\n\trpp->len += skb->len;\n\n\tif (stat & SAR_RSQE_EPDU) {\n\t\tunsigned int len, truesize;\n\t\tunsigned char *l1l2;\n\n\t\tl1l2 = (unsigned char *) ((unsigned long) skb->data + skb->len - 6);\n\n\t\tlen = (l1l2[0] << 8) | l1l2[1];\n\t\tlen = len ? len : 0x10000;\n\n\t\tRXPRINTK(\"%s: PDU has %d bytes.\\n\", card->name, len);\n\n\t\tif ((len + 8 > rpp->len) || (len + (47 + 8) < rpp->len)) {\n\t\t\tRXPRINTK(\"%s: AAL5 PDU size mismatch: %d != %d. \"\n\t\t\t         \"(CDC: %08x)\\n\",\n\t\t\t         card->name, len, rpp->len, readl(SAR_REG_CDC));\n\t\t\trecycle_rx_pool_skb(card, rpp);\n\t\t\tatomic_inc(&vcc->stats->rx_err);\n\t\t\treturn;\n\t\t}\n\t\tif (stat & SAR_RSQE_CRC) {\n\t\t\tRXPRINTK(\"%s: AAL5 CRC error.\\n\", card->name);\n\t\t\trecycle_rx_pool_skb(card, rpp);\n\t\t\tatomic_inc(&vcc->stats->rx_err);\n\t\t\treturn;\n\t\t}\n\t\tif (skb_queue_len(&rpp->queue) > 1) {\n\t\t\tstruct sk_buff *sb;\n\n\t\t\tskb = dev_alloc_skb(rpp->len);\n\t\t\tif (!skb) {\n\t\t\t\tRXPRINTK(\"%s: Can't alloc RX skb.\\n\",\n\t\t\t\t\t card->name);\n\t\t\t\trecycle_rx_pool_skb(card, rpp);\n\t\t\t\tatomic_inc(&vcc->stats->rx_err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!atm_charge(vcc, skb->truesize)) {\n\t\t\t\trecycle_rx_pool_skb(card, rpp);\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tskb_queue_walk(&rpp->queue, sb)\n\t\t\t\tskb_put_data(skb, sb->data, sb->len);\n\n\t\t\trecycle_rx_pool_skb(card, rpp);\n\n\t\t\tskb_trim(skb, len);\n\t\t\tATM_SKB(skb)->vcc = vcc;\n\t\t\t__net_timestamp(skb);\n\n\t\t\tvcc->push(vcc, skb);\n\t\t\tatomic_inc(&vcc->stats->rx);\n\n\t\t\treturn;\n\t\t}\n\n\t\tflush_rx_pool(card, rpp);\n\n\t\tif (!atm_charge(vcc, skb->truesize)) {\n\t\t\trecycle_rx_skb(card, skb);\n\t\t\treturn;\n\t\t}\n\n\t\tdma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),\n\t\t\t\t skb_end_pointer(skb) - skb->data,\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tsb_pool_remove(card, skb);\n\n\t\tskb_trim(skb, len);\n\t\tATM_SKB(skb)->vcc = vcc;\n\t\t__net_timestamp(skb);\n\n\t\ttruesize = skb->truesize;\n\t\tvcc->push(vcc, skb);\n\t\tatomic_inc(&vcc->stats->rx);\n\n\t\tif (truesize > SAR_FB_SIZE_3)\n\t\t\tadd_rx_skb(card, 3, SAR_FB_SIZE_3, 1);\n\t\telse if (truesize > SAR_FB_SIZE_2)\n\t\t\tadd_rx_skb(card, 2, SAR_FB_SIZE_2, 1);\n\t\telse if (truesize > SAR_FB_SIZE_1)\n\t\t\tadd_rx_skb(card, 1, SAR_FB_SIZE_1, 1);\n\t\telse\n\t\t\tadd_rx_skb(card, 0, SAR_FB_SIZE_0, 1);\n\t\treturn;\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-44998"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "arch/arm64/kvm/vgic/vgic-its.c",
      "func_name": "vgic_its_check_cache",
      "func_body": "static struct vgic_irq *vgic_its_check_cache(struct kvm *kvm, phys_addr_t db,\n\t\t\t\t\t     u32 devid, u32 eventid)\n{\n\tstruct vgic_dist *dist = &kvm->arch.vgic;\n\tstruct vgic_irq *irq;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&dist->lpi_list_lock, flags);\n\n\tirq = __vgic_its_check_cache(dist, db, devid, eventid);\n\tif (irq)\n\t\tvgic_get_irq_kref(irq);\n\n\traw_spin_unlock_irqrestore(&dist->lpi_list_lock, flags);\n\n\treturn irq;\n}\n",
      "cve_list": [
        "CVE-2024-26598"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/infiniband/core/iwcm.c",
      "func_name": "cm_work_handler",
      "func_body": "static void cm_work_handler(struct work_struct *_work)\n{\n\tstruct iwcm_work *work = container_of(_work, struct iwcm_work, work);\n\tstruct iw_cm_event levent;\n\tstruct iwcm_id_private *cm_id_priv = work->cm_id;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\twhile (!list_empty(&cm_id_priv->work_list)) {\n\t\twork = list_first_entry(&cm_id_priv->work_list,\n\t\t\t\t\tstruct iwcm_work, list);\n\t\tlist_del_init(&work->list);\n\t\tlevent = work->event;\n\t\tput_work(work);\n\t\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\n\t\tif (!test_bit(IWCM_F_DROP_EVENTS, &cm_id_priv->flags)) {\n\t\t\tret = process_event(cm_id_priv, &levent);\n\t\t\tif (ret)\n\t\t\t\tWARN_ON_ONCE(destroy_cm_id(&cm_id_priv->id));\n\t\t} else\n\t\t\tpr_debug(\"dropping event %d\\n\", levent.event);\n\t\tif (iwcm_deref_id(cm_id_priv))\n\t\t\treturn;\n\t\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\t}\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n}\n",
      "cve_list": [
        "CVE-2024-42285"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/trace/trace_events_inject.c",
      "func_name": "event_inject_write",
      "func_body": "static ssize_t\nevent_inject_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t   loff_t *ppos)\n{\n\tstruct trace_event_call *call;\n\tstruct trace_event_file *file;\n\tint err = -ENODEV, size;\n\tvoid *entry = NULL;\n\tchar *buf;\n\n\tif (cnt >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user_nul(ubuf, cnt);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\tstrim(buf);\n\n\tmutex_lock(&event_mutex);\n\tfile = event_file_file(filp);\n\tif (file) {\n\t\tcall = file->event_call;\n\t\tsize = parse_entry(buf, call, &entry);\n\t\tif (size < 0)\n\t\t\terr = size;\n\t\telse\n\t\t\terr = trace_inject_entry(file, entry, size);\n\t}\n\tmutex_unlock(&event_mutex);\n\n\tkfree(entry);\n\tkfree(buf);\n\n\tif (err < 0)\n\t\treturn err;\n\n\t*ppos += err;\n\treturn cnt;\n}\n",
      "cve_list": [
        "CVE-2024-43891"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/netfilter/nf_tables_api.c",
      "func_name": "nft_setelem_catchall_deactivate",
      "func_body": "static int nft_setelem_catchall_deactivate(const struct net *net,\n\t\t\t\t\t   struct nft_set *set,\n\t\t\t\t\t   struct nft_set_elem *elem)\n{\n\tstruct nft_set_elem_catchall *catchall;\n\tstruct nft_set_ext *ext;\n\n\tlist_for_each_entry(catchall, &set->catchall_list, list) {\n\t\text = nft_set_elem_ext(set, catchall->elem);\n\t\tif (!nft_is_active_next(net, ext))\n\t\t\tcontinue;\n\n\t\tkfree(elem->priv);\n\t\telem->priv = catchall->elem;\n\t\tnft_set_elem_change_active(net, set, ext);\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n",
      "cve_list": [
        "CVE-2024-1085"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "sound/soc/soc-dapm.c",
      "func_name": "snd_soc_dai_link_event",
      "func_body": "static int snd_soc_dai_link_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t  struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_dapm_path *path;\n\tstruct snd_soc_dai *source, *sink;\n\tstruct snd_pcm_substream *substream = w->priv;\n\tint ret = 0, saved_stream = substream->stream;\n\n\tif (WARN_ON(list_empty(&w->edges[SND_SOC_DAPM_DIR_OUT]) ||\n\t\t    list_empty(&w->edges[SND_SOC_DAPM_DIR_IN])))\n\t\treturn -EINVAL;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tret = snd_soc_dai_link_event_pre_pmu(w, substream);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tsnd_soc_dapm_widget_for_each_sink_path(w, path) {\n\t\t\tsink = path->sink->priv;\n\n\t\t\tsnd_soc_dai_digital_mute(sink, 0, SNDRV_PCM_STREAM_PLAYBACK);\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tsnd_soc_dapm_widget_for_each_sink_path(w, path) {\n\t\t\tsink = path->sink->priv;\n\n\t\t\tsnd_soc_dai_digital_mute(sink, 1, SNDRV_PCM_STREAM_PLAYBACK);\n\t\t\tret = 0;\n\t\t}\n\n\t\tsubstream->stream = SNDRV_PCM_STREAM_CAPTURE;\n\t\tsnd_soc_dapm_widget_for_each_source_path(w, path) {\n\t\t\tsource = path->source->priv;\n\t\t\tsnd_soc_dai_hw_free(source, substream, 0);\n\t\t}\n\n\t\tsubstream->stream = SNDRV_PCM_STREAM_PLAYBACK;\n\t\tsnd_soc_dapm_widget_for_each_sink_path(w, path) {\n\t\t\tsink = path->sink->priv;\n\t\t\tsnd_soc_dai_hw_free(sink, substream, 0);\n\t\t}\n\n\t\tsubstream->stream = SNDRV_PCM_STREAM_CAPTURE;\n\t\tsnd_soc_dapm_widget_for_each_source_path(w, path) {\n\t\t\tsource = path->source->priv;\n\t\t\tsnd_soc_dai_deactivate(source, substream->stream);\n\t\t\tsnd_soc_dai_shutdown(source, substream, 0);\n\t\t}\n\n\t\tsubstream->stream = SNDRV_PCM_STREAM_PLAYBACK;\n\t\tsnd_soc_dapm_widget_for_each_sink_path(w, path) {\n\t\t\tsink = path->sink->priv;\n\t\t\tsnd_soc_dai_deactivate(sink, substream->stream);\n\t\t\tsnd_soc_dai_shutdown(sink, substream, 0);\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tkfree(substream->runtime);\n\t\tsubstream->runtime = NULL;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"Unknown event %d\\n\", event);\n\t\tret = -EINVAL;\n\t}\n\nout:\n\t/* Restore the substream direction */\n\tsubstream->stream = saved_stream;\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-46798"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/mptcp/pm_netlink.c",
      "func_name": "mptcp_pm_del_add_timer",
      "func_body": "struct mptcp_pm_add_entry *\nmptcp_pm_del_add_timer(struct mptcp_sock *msk,\n\t\t       const struct mptcp_addr_info *addr, bool check_id)\n{\n\tstruct mptcp_pm_add_entry *entry;\n\tstruct sock *sk = (struct sock *)msk;\n\tstruct timer_list *add_timer = NULL;\n\n\tspin_lock_bh(&msk->pm.lock);\n\tentry = mptcp_lookup_anno_list_by_saddr(msk, addr);\n\tif (entry && (!check_id || entry->addr.id == addr->id)) {\n\t\tentry->retrans_times = ADD_ADDR_RETRANS_MAX;\n\t\tadd_timer = &entry->add_timer;\n\t}\n\tif (!check_id && entry)\n\t\tlist_del(&entry->list);\n\tspin_unlock_bh(&msk->pm.lock);\n\n\t/* no lock, because sk_stop_timer_sync() is calling del_timer_sync() */\n\tif (add_timer)\n\t\tsk_stop_timer_sync(sk, add_timer);\n\n\treturn entry;\n}\n",
      "cve_list": [
        "CVE-2024-46858"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/seeq/ether3.c",
      "func_name": "ether3_remove",
      "func_body": "static void ether3_remove(struct expansion_card *ec)\n{\n\tstruct net_device *dev = ecard_get_drvdata(ec);\n\n\tether3_outw(priv(dev)->regs.config2 |= CFG2_CTRLO, REG_CONFIG2);\n\tecard_set_drvdata(ec, NULL);\n\n\tunregister_netdev(dev);\n\tdel_timer_sync(&priv(dev)->timer);\n\tfree_netdev(dev);\n\tecard_release_resources(ec);\n}\n",
      "cve_list": [
        "CVE-2024-47747"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/irq/irqdesc.c",
      "func_name": "irq_find_at_or_after",
      "func_body": "static unsigned int irq_find_at_or_after(unsigned int offset)\n{\n\tunsigned long index = offset;\n\tstruct irq_desc *desc;\n\n\tguard(rcu)();\n\tdesc = mt_find(&sparse_irqs, &index, nr_irqs);\n\n\treturn desc ? irq_desc_get_irq(desc) : nr_irqs;\n}\n",
      "cve_list": [
        "CVE-2024-38385"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/bpf/arena.c",
      "func_name": "arena_vm_close",
      "func_body": "static void arena_vm_close(struct vm_area_struct *vma)\n{\n\tstruct bpf_map *map = vma->vm_file->private_data;\n\tstruct bpf_arena *arena = container_of(map, struct bpf_arena, map);\n\tstruct vma_list *vml = vma->vm_private_data;\n\n\tif (!atomic_dec_and_test(&vml->mmap_count))\n\t\treturn;\n\tguard(mutex)(&arena->lock);\n\t/* update link list under lock */\n\tlist_del(&vml->head);\n\tvma->vm_private_data = NULL;\n\tkfree(vml);\n}\n",
      "cve_list": [
        "CVE-2024-42075"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/nilfs2/dir.c",
      "func_name": "nilfs_check_folio",
      "func_body": "static bool nilfs_check_folio(struct folio *folio, char *kaddr)\n{\n\tstruct inode *dir = folio->mapping->host;\n\tstruct super_block *sb = dir->i_sb;\n\tunsigned int chunk_size = nilfs_chunk_size(dir);\n\tsize_t offs, rec_len;\n\tsize_t limit = folio_size(folio);\n\tstruct nilfs_dir_entry *p;\n\tchar *error;\n\n\tif (dir->i_size < folio_pos(folio) + limit) {\n\t\tlimit = dir->i_size - folio_pos(folio);\n\t\tif (limit & (chunk_size - 1))\n\t\t\tgoto Ebadsize;\n\t\tif (!limit)\n\t\t\tgoto out;\n\t}\n\tfor (offs = 0; offs <= limit - NILFS_DIR_REC_LEN(1); offs += rec_len) {\n\t\tp = (struct nilfs_dir_entry *)(kaddr + offs);\n\t\trec_len = nilfs_rec_len_from_disk(p->rec_len);\n\n\t\tif (rec_len < NILFS_DIR_REC_LEN(1))\n\t\t\tgoto Eshort;\n\t\tif (rec_len & 3)\n\t\t\tgoto Ealign;\n\t\tif (rec_len < NILFS_DIR_REC_LEN(p->name_len))\n\t\t\tgoto Enamelen;\n\t\tif (((offs + rec_len - 1) ^ offs) & ~(chunk_size-1))\n\t\t\tgoto Espan;\n\t\tif (unlikely(p->inode &&\n\t\t\t     NILFS_PRIVATE_INODE(le64_to_cpu(p->inode))))\n\t\t\tgoto Einumber;\n\t}\n\tif (offs != limit)\n\t\tgoto Eend;\nout:\n\tfolio_set_checked(folio);\n\treturn true;\n\n\t/* Too bad, we had an error */\n\nEbadsize:\n\tnilfs_error(sb,\n\t\t    \"size of directory #%lu is not a multiple of chunk size\",\n\t\t    dir->i_ino);\n\tgoto fail;\nEshort:\n\terror = \"rec_len is smaller than minimal\";\n\tgoto bad_entry;\nEalign:\n\terror = \"unaligned directory entry\";\n\tgoto bad_entry;\nEnamelen:\n\terror = \"rec_len is too small for name_len\";\n\tgoto bad_entry;\nEspan:\n\terror = \"directory entry across blocks\";\n\tgoto bad_entry;\nEinumber:\n\terror = \"disallowed inode number\";\nbad_entry:\n\tnilfs_error(sb,\n\t\t    \"bad entry in directory #%lu: %s - offset=%lu, inode=%lu, rec_len=%zd, name_len=%d\",\n\t\t    dir->i_ino, error, (folio->index << PAGE_SHIFT) + offs,\n\t\t    (unsigned long)le64_to_cpu(p->inode),\n\t\t    rec_len, p->name_len);\n\tgoto fail;\nEend:\n\tp = (struct nilfs_dir_entry *)(kaddr + offs);\n\tnilfs_error(sb,\n\t\t    \"entry in directory #%lu spans the page boundary offset=%lu, inode=%lu\",\n\t\t    dir->i_ino, (folio->index << PAGE_SHIFT) + offs,\n\t\t    (unsigned long)le64_to_cpu(p->inode));\nfail:\n\treturn false;\n}\n",
      "cve_list": [
        "CVE-2024-42104"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "security/integrity/ima/ima_template_lib.c",
      "func_name": "ima_eventname_init_common",
      "func_body": "static int ima_eventname_init_common(struct ima_event_data *event_data,\n\t\t\t\t     struct ima_field_data *field_data,\n\t\t\t\t     bool size_limit)\n{\n\tconst char *cur_filename = NULL;\n\tstruct name_snapshot filename;\n\tu32 cur_filename_len = 0;\n\tbool snapshot = false;\n\tint ret;\n\n\tBUG_ON(event_data->filename == NULL && event_data->file == NULL);\n\n\tif (event_data->filename) {\n\t\tcur_filename = event_data->filename;\n\t\tcur_filename_len = strlen(event_data->filename);\n\n\t\tif (!size_limit || cur_filename_len <= IMA_EVENT_NAME_LEN_MAX)\n\t\t\tgoto out;\n\t}\n\n\tif (event_data->file) {\n\t\ttake_dentry_name_snapshot(&filename,\n\t\t\t\t\t  event_data->file->f_path.dentry);\n\t\tsnapshot = true;\n\t\tcur_filename = filename.name.name;\n\t\tcur_filename_len = strlen(cur_filename);\n\t} else\n\t\t/*\n\t\t * Truncate filename if the latter is too long and\n\t\t * the file descriptor is not available.\n\t\t */\n\t\tcur_filename_len = IMA_EVENT_NAME_LEN_MAX;\nout:\n\tret = ima_write_template_field_data(cur_filename, cur_filename_len,\n\t\t\t\t\t    DATA_FMT_STRING, field_data);\n\n\tif (snapshot)\n\t\trelease_dentry_name_snapshot(&filename);\n\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-39494"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/sched/sch_netem.c",
      "func_name": "netem_enqueue",
      "func_body": "static int netem_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t\t struct sk_buff **to_free)\n{\n\tstruct netem_sched_data *q = qdisc_priv(sch);\n\t/* We don't fill cb now as skb_unshare() may invalidate it */\n\tstruct netem_skb_cb *cb;\n\tstruct sk_buff *skb2 = NULL;\n\tstruct sk_buff *segs = NULL;\n\tunsigned int prev_len = qdisc_pkt_len(skb);\n\tint count = 1;\n\n\t/* Do not fool qdisc_drop_all() */\n\tskb->prev = NULL;\n\n\t/* Random duplication */\n\tif (q->duplicate && q->duplicate >= get_crandom(&q->dup_cor, &q->prng))\n\t\t++count;\n\n\t/* Drop packet? */\n\tif (loss_event(q)) {\n\t\tif (q->ecn && INET_ECN_set_ce(skb))\n\t\t\tqdisc_qstats_drop(sch); /* mark packet */\n\t\telse\n\t\t\t--count;\n\t}\n\tif (count == 0) {\n\t\tqdisc_qstats_drop(sch);\n\t\t__qdisc_drop(skb, to_free);\n\t\treturn NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n\t}\n\n\t/* If a delay is expected, orphan the skb. (orphaning usually takes\n\t * place at TX completion time, so _before_ the link transit delay)\n\t */\n\tif (q->latency || q->jitter || q->rate)\n\t\tskb_orphan_partial(skb);\n\n\t/*\n\t * If we need to duplicate packet, then clone it before\n\t * original is modified.\n\t */\n\tif (count > 1)\n\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\n\t/*\n\t * Randomized packet corruption.\n\t * Make copy if needed since we are modifying\n\t * If packet is going to be hardware checksummed, then\n\t * do it now in software before we mangle it.\n\t */\n\tif (q->corrupt && q->corrupt >= get_crandom(&q->corrupt_cor, &q->prng)) {\n\t\tif (skb_is_gso(skb)) {\n\t\t\tskb = netem_segment(skb, sch, to_free);\n\t\t\tif (!skb)\n\t\t\t\tgoto finish_segs;\n\n\t\t\tsegs = skb->next;\n\t\t\tskb_mark_not_on_list(skb);\n\t\t\tqdisc_skb_cb(skb)->pkt_len = skb->len;\n\t\t}\n\n\t\tskb = skb_unshare(skb, GFP_ATOMIC);\n\t\tif (unlikely(!skb)) {\n\t\t\tqdisc_qstats_drop(sch);\n\t\t\tgoto finish_segs;\n\t\t}\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL &&\n\t\t    skb_checksum_help(skb)) {\n\t\t\tqdisc_drop(skb, sch, to_free);\n\t\t\tskb = NULL;\n\t\t\tgoto finish_segs;\n\t\t}\n\n\t\tskb->data[get_random_u32_below(skb_headlen(skb))] ^=\n\t\t\t1<<get_random_u32_below(8);\n\t}\n\n\tif (unlikely(sch->q.qlen >= sch->limit)) {\n\t\t/* re-link segs, so that qdisc_drop_all() frees them all */\n\t\tskb->next = segs;\n\t\tqdisc_drop_all(skb, sch, to_free);\n\t\tif (skb2)\n\t\t\t__qdisc_drop(skb2, to_free);\n\t\treturn NET_XMIT_DROP;\n\t}\n\n\t/*\n\t * If doing duplication then re-insert at top of the\n\t * qdisc tree, since parent queuer expects that only one\n\t * skb will be queued.\n\t */\n\tif (skb2) {\n\t\tstruct Qdisc *rootq = qdisc_root_bh(sch);\n\t\tu32 dupsave = q->duplicate; /* prevent duplicating a dup... */\n\n\t\tq->duplicate = 0;\n\t\trootq->enqueue(skb2, rootq, to_free);\n\t\tq->duplicate = dupsave;\n\t\tskb2 = NULL;\n\t}\n\n\tqdisc_qstats_backlog_inc(sch, skb);\n\n\tcb = netem_skb_cb(skb);\n\tif (q->gap == 0 ||\t\t/* not doing reordering */\n\t    q->counter < q->gap - 1 ||\t/* inside last reordering gap */\n\t    q->reorder < get_crandom(&q->reorder_cor, &q->prng)) {\n\t\tu64 now;\n\t\ts64 delay;\n\n\t\tdelay = tabledist(q->latency, q->jitter,\n\t\t\t\t  &q->delay_cor, &q->prng, q->delay_dist);\n\n\t\tnow = ktime_get_ns();\n\n\t\tif (q->rate) {\n\t\t\tstruct netem_skb_cb *last = NULL;\n\n\t\t\tif (sch->q.tail)\n\t\t\t\tlast = netem_skb_cb(sch->q.tail);\n\t\t\tif (q->t_root.rb_node) {\n\t\t\t\tstruct sk_buff *t_skb;\n\t\t\t\tstruct netem_skb_cb *t_last;\n\n\t\t\t\tt_skb = skb_rb_last(&q->t_root);\n\t\t\t\tt_last = netem_skb_cb(t_skb);\n\t\t\t\tif (!last ||\n\t\t\t\t    t_last->time_to_send > last->time_to_send)\n\t\t\t\t\tlast = t_last;\n\t\t\t}\n\t\t\tif (q->t_tail) {\n\t\t\t\tstruct netem_skb_cb *t_last =\n\t\t\t\t\tnetem_skb_cb(q->t_tail);\n\n\t\t\t\tif (!last ||\n\t\t\t\t    t_last->time_to_send > last->time_to_send)\n\t\t\t\t\tlast = t_last;\n\t\t\t}\n\n\t\t\tif (last) {\n\t\t\t\t/*\n\t\t\t\t * Last packet in queue is reference point (now),\n\t\t\t\t * calculate this time bonus and subtract\n\t\t\t\t * from delay.\n\t\t\t\t */\n\t\t\t\tdelay -= last->time_to_send - now;\n\t\t\t\tdelay = max_t(s64, 0, delay);\n\t\t\t\tnow = last->time_to_send;\n\t\t\t}\n\n\t\t\tdelay += packet_time_ns(qdisc_pkt_len(skb), q);\n\t\t}\n\n\t\tcb->time_to_send = now + delay;\n\t\t++q->counter;\n\t\ttfifo_enqueue(skb, sch);\n\t} else {\n\t\t/*\n\t\t * Do re-ordering by putting one out of N packets at the front\n\t\t * of the queue.\n\t\t */\n\t\tcb->time_to_send = ktime_get_ns();\n\t\tq->counter = 0;\n\n\t\t__qdisc_enqueue_head(skb, &sch->q);\n\t\tsch->qstats.requeues++;\n\t}\n\nfinish_segs:\n\tif (skb2)\n\t\t__qdisc_drop(skb2, to_free);\n\n\tif (segs) {\n\t\tunsigned int len, last_len;\n\t\tint rc, nb;\n\n\t\tlen = skb ? skb->len : 0;\n\t\tnb = skb ? 1 : 0;\n\n\t\twhile (segs) {\n\t\t\tskb2 = segs->next;\n\t\t\tskb_mark_not_on_list(segs);\n\t\t\tqdisc_skb_cb(segs)->pkt_len = segs->len;\n\t\t\tlast_len = segs->len;\n\t\t\trc = qdisc_enqueue(segs, sch, to_free);\n\t\t\tif (rc != NET_XMIT_SUCCESS) {\n\t\t\t\tif (net_xmit_drop_count(rc))\n\t\t\t\t\tqdisc_qstats_drop(sch);\n\t\t\t} else {\n\t\t\t\tnb++;\n\t\t\t\tlen += last_len;\n\t\t\t}\n\t\t\tsegs = skb2;\n\t\t}\n\t\t/* Parent qdiscs accounted for 1 skb of size @prev_len */\n\t\tqdisc_tree_reduce_backlog(sch, -(nb - 1), -(len - prev_len));\n\t} else if (!skb) {\n\t\treturn NET_XMIT_DROP;\n\t}\n\treturn NET_XMIT_SUCCESS;\n}\n",
      "cve_list": [
        "CVE-2024-45016"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/mellanox/mlxsw/spectrum_buffers.c",
      "func_name": "mlxsw_sp_sb_occ_snapshot",
      "func_body": "int mlxsw_sp_sb_occ_snapshot(struct mlxsw_core *mlxsw_core,\n\t\t\t     unsigned int sb_index)\n{\n\tu16 local_port, local_port_1, first_local_port, last_local_port;\n\tstruct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);\n\tstruct mlxsw_sp_sb_sr_occ_query_cb_ctx cb_ctx;\n\tu8 masked_count, current_page = 0;\n\tunsigned long cb_priv = 0;\n\tLIST_HEAD(bulk_list);\n\tchar *sbsr_pl;\n\tint i;\n\tint err;\n\tint err2;\n\n\tsbsr_pl = kmalloc(MLXSW_REG_SBSR_LEN, GFP_KERNEL);\n\tif (!sbsr_pl)\n\t\treturn -ENOMEM;\n\n\tlocal_port = MLXSW_PORT_CPU_PORT;\nnext_batch:\n\tlocal_port_1 = local_port;\n\tmasked_count = 0;\n\tmlxsw_reg_sbsr_pack(sbsr_pl, false);\n\tmlxsw_reg_sbsr_port_page_set(sbsr_pl, current_page);\n\tfirst_local_port = current_page * MLXSW_REG_SBSR_NUM_PORTS_IN_PAGE;\n\tlast_local_port = current_page * MLXSW_REG_SBSR_NUM_PORTS_IN_PAGE +\n\t\t\t  MLXSW_REG_SBSR_NUM_PORTS_IN_PAGE - 1;\n\n\tfor (i = 0; i < MLXSW_SP_SB_ING_TC_COUNT; i++)\n\t\tmlxsw_reg_sbsr_pg_buff_mask_set(sbsr_pl, i, 1);\n\tfor (i = 0; i < MLXSW_SP_SB_EG_TC_COUNT; i++)\n\t\tmlxsw_reg_sbsr_tclass_mask_set(sbsr_pl, i, 1);\n\tfor (; local_port < mlxsw_core_max_ports(mlxsw_core); local_port++) {\n\t\tif (!mlxsw_sp->ports[local_port])\n\t\t\tcontinue;\n\t\tif (local_port > last_local_port) {\n\t\t\tcurrent_page++;\n\t\t\tgoto do_query;\n\t\t}\n\t\tif (local_port != MLXSW_PORT_CPU_PORT) {\n\t\t\t/* Ingress quotas are not supported for the CPU port */\n\t\t\tmlxsw_reg_sbsr_ingress_port_mask_set(sbsr_pl,\n\t\t\t\t\t\t\t     local_port - first_local_port,\n\t\t\t\t\t\t\t     1);\n\t\t}\n\t\tmlxsw_reg_sbsr_egress_port_mask_set(sbsr_pl,\n\t\t\t\t\t\t    local_port - first_local_port,\n\t\t\t\t\t\t    1);\n\t\tfor (i = 0; i < mlxsw_sp->sb_vals->pool_count; i++) {\n\t\t\terr = mlxsw_sp_sb_pm_occ_query(mlxsw_sp, local_port, i,\n\t\t\t\t\t\t       &bulk_list);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (++masked_count == MASKED_COUNT_MAX)\n\t\t\tgoto do_query;\n\t}\n\ndo_query:\n\tcb_ctx.masked_count = masked_count;\n\tcb_ctx.local_port_1 = local_port_1;\n\tmemcpy(&cb_priv, &cb_ctx, sizeof(cb_ctx));\n\terr = mlxsw_reg_trans_query(mlxsw_core, MLXSW_REG(sbsr), sbsr_pl,\n\t\t\t\t    &bulk_list, mlxsw_sp_sb_sr_occ_query_cb,\n\t\t\t\t    cb_priv);\n\tif (err)\n\t\tgoto out;\n\tif (local_port < mlxsw_core_max_ports(mlxsw_core)) {\n\t\tlocal_port++;\n\t\tgoto next_batch;\n\t}\n\nout:\n\terr2 = mlxsw_reg_trans_bulk_wait(&bulk_list);\n\tif (!err)\n\t\terr = err2;\n\tkfree(sbsr_pl);\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-42073"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/9p/vfs_dentry.c",
      "func_name": "v9fs_dentry_release",
      "func_body": "static void v9fs_dentry_release(struct dentry *dentry)\n{\n\tstruct hlist_node *p, *n;\n\tstruct hlist_head head;\n\n\tp9_debug(P9_DEBUG_VFS, \" dentry: %pd (%p)\\n\",\n\t\t dentry, dentry);\n\n\tspin_lock(&dentry->d_lock);\n\thlist_move_list((struct hlist_head *)&dentry->d_fsdata, &head);\n\tspin_unlock(&dentry->d_lock);\n\n\thlist_for_each_safe(p, n, &head)\n\t\tp9_fid_put(hlist_entry(p, struct p9_fid, dlist));\n}\n",
      "cve_list": [
        "CVE-2024-39463"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/mellanox/mlx5/core/main.c",
      "func_name": "mlx5_function_teardown",
      "func_body": "static int mlx5_function_teardown(struct mlx5_core_dev *dev, bool boot)\n{\n\tint err = mlx5_function_close(dev);\n\n\tif (!err)\n\t\tmlx5_function_disable(dev, boot);\n\telse\n\t\tmlx5_stop_health_poll(dev, boot);\n\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-40906"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/block/nbd.c",
      "func_name": "nbd_requeue_cmd",
      "func_body": "static void nbd_requeue_cmd(struct nbd_cmd *cmd)\n{\n\tstruct request *req = blk_mq_rq_from_pdu(cmd);\n\n\tlockdep_assert_held(&cmd->lock);\n\n\t/*\n\t * Clear INFLIGHT flag so that this cmd won't be completed in\n\t * normal completion path\n\t *\n\t * INFLIGHT flag will be set when the cmd is queued to nbd next\n\t * time.\n\t */\n\t__clear_bit(NBD_CMD_INFLIGHT, &cmd->flags);\n\n\tif (!test_and_set_bit(NBD_CMD_REQUEUED, &cmd->flags))\n\t\tblk_mq_requeue_request(req, true);\n}\n",
      "cve_list": [
        "CVE-2024-49855"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/thermal/thermal_debugfs.c",
      "func_name": "thermal_debug_cdev_remove",
      "func_body": "void thermal_debug_cdev_remove(struct thermal_cooling_device *cdev)\n{\n\tstruct thermal_debugfs *thermal_dbg;\n\n\tmutex_lock(&cdev->lock);\n\n\tthermal_dbg = cdev->debugfs;\n\tif (!thermal_dbg) {\n\t\tmutex_unlock(&cdev->lock);\n\t\treturn;\n\t}\n\n\tcdev->debugfs = NULL;\n\n\tmutex_unlock(&cdev->lock);\n\n\tmutex_lock(&thermal_dbg->lock);\n\n\tthermal_debugfs_cdev_clear(&thermal_dbg->cdev_dbg);\n\n\tmutex_unlock(&thermal_dbg->lock);\n\n\tthermal_debugfs_remove_id(thermal_dbg);\n}\n",
      "cve_list": [
        "CVE-2024-36932"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/f2fs/extent_cache.c",
      "func_name": "sanity_check_extent_cache",
      "func_body": "bool sanity_check_extent_cache(struct inode *inode, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_extent *i_ext = &F2FS_INODE(ipage)->i_ext;\n\tstruct extent_info ei;\n\n\tget_read_extent_info(&ei, i_ext);\n\n\tif (!ei.len)\n\t\treturn true;\n\n\tif (!f2fs_is_valid_blkaddr(sbi, ei.blk, DATA_GENERIC_ENHANCE) ||\n\t    !f2fs_is_valid_blkaddr(sbi, ei.blk + ei.len - 1,\n\t\t\t\t\tDATA_GENERIC_ENHANCE)) {\n\t\tf2fs_warn(sbi, \"%s: inode (ino=%lx) extent info [%u, %u, %u] is incorrect, run fsck to fix\",\n\t\t\t  __func__, inode->i_ino,\n\t\t\t  ei.blk, ei.fofs, ei.len);\n\t\treturn false;\n\t}\n\treturn true;\n}\n",
      "cve_list": [
        "CVE-2024-44941"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/f2fs/extent_cache.c",
      "func_name": "f2fs_init_read_extent_tree",
      "func_body": "void f2fs_init_read_extent_tree(struct inode *inode, struct page *ipage)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree_info *eti = &sbi->extent_tree[EX_READ];\n\tstruct f2fs_extent *i_ext = &F2FS_INODE(ipage)->i_ext;\n\tstruct extent_tree *et;\n\tstruct extent_node *en;\n\tstruct extent_info ei;\n\n\tif (!__may_extent_tree(inode, EX_READ)) {\n\t\t/* drop largest read extent */\n\t\tif (i_ext->len) {\n\t\t\tf2fs_wait_on_page_writeback(ipage, NODE, true, true);\n\t\t\ti_ext->len = 0;\n\t\t\tset_page_dirty(ipage);\n\t\t}\n\t\tset_inode_flag(inode, FI_NO_EXTENT);\n\t\treturn;\n\t}\n\n\tet = __grab_extent_tree(inode, EX_READ);\n\n\tget_read_extent_info(&ei, i_ext);\n\n\twrite_lock(&et->lock);\n\tif (atomic_read(&et->node_cnt) || !ei.len)\n\t\tgoto skip;\n\n\ten = __attach_extent_node(sbi, et, &ei, NULL,\n\t\t\t\t&et->root.rb_root.rb_node, true);\n\tif (en) {\n\t\tet->largest = en->ei;\n\t\tet->cached_en = en;\n\n\t\tspin_lock(&eti->extent_lock);\n\t\tlist_add_tail(&en->list, &eti->extent_list);\n\t\tspin_unlock(&eti->extent_lock);\n\t}\nskip:\n\t/* Let's drop, if checkpoint got corrupted. */\n\tif (f2fs_cp_error(sbi)) {\n\t\tet->largest.len = 0;\n\t\tet->largest_updated = true;\n\t}\n\twrite_unlock(&et->lock);\n}\n",
      "cve_list": [
        "CVE-2024-44941"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/f2fs/inode.c",
      "func_name": "do_read_inode",
      "func_body": "static int do_read_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct page *node_page;\n\tstruct f2fs_inode *ri;\n\tprojid_t i_projid;\n\n\t/* Check if ino is within scope */\n\tif (f2fs_check_nid_range(sbi, inode->i_ino))\n\t\treturn -EINVAL;\n\n\tnode_page = f2fs_get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page))\n\t\treturn PTR_ERR(node_page);\n\n\tri = F2FS_INODE(node_page);\n\n\tinode->i_mode = le16_to_cpu(ri->i_mode);\n\ti_uid_write(inode, le32_to_cpu(ri->i_uid));\n\ti_gid_write(inode, le32_to_cpu(ri->i_gid));\n\tset_nlink(inode, le32_to_cpu(ri->i_links));\n\tinode->i_size = le64_to_cpu(ri->i_size);\n\tinode->i_blocks = SECTOR_FROM_BLOCK(le64_to_cpu(ri->i_blocks) - 1);\n\n\tinode_set_atime(inode, le64_to_cpu(ri->i_atime),\n\t\t\tle32_to_cpu(ri->i_atime_nsec));\n\tinode_set_ctime(inode, le64_to_cpu(ri->i_ctime),\n\t\t\tle32_to_cpu(ri->i_ctime_nsec));\n\tinode_set_mtime(inode, le64_to_cpu(ri->i_mtime),\n\t\t\tle32_to_cpu(ri->i_mtime_nsec));\n\tinode->i_generation = le32_to_cpu(ri->i_generation);\n\tif (S_ISDIR(inode->i_mode))\n\t\tfi->i_current_depth = le32_to_cpu(ri->i_current_depth);\n\telse if (S_ISREG(inode->i_mode))\n\t\tfi->i_gc_failures = le16_to_cpu(ri->i_gc_failures);\n\tfi->i_xattr_nid = le32_to_cpu(ri->i_xattr_nid);\n\tfi->i_flags = le32_to_cpu(ri->i_flags);\n\tif (S_ISREG(inode->i_mode))\n\t\tfi->i_flags &= ~F2FS_PROJINHERIT_FL;\n\tbitmap_zero(fi->flags, FI_MAX);\n\tfi->i_advise = ri->i_advise;\n\tfi->i_pino = le32_to_cpu(ri->i_pino);\n\tfi->i_dir_level = ri->i_dir_level;\n\n\tget_inline_info(inode, ri);\n\n\tfi->i_extra_isize = f2fs_has_extra_attr(inode) ?\n\t\t\t\t\tle16_to_cpu(ri->i_extra_isize) : 0;\n\n\tif (f2fs_sb_has_flexible_inline_xattr(sbi)) {\n\t\tfi->i_inline_xattr_size = le16_to_cpu(ri->i_inline_xattr_size);\n\t} else if (f2fs_has_inline_xattr(inode) ||\n\t\t\t\tf2fs_has_inline_dentry(inode)) {\n\t\tfi->i_inline_xattr_size = DEFAULT_INLINE_XATTR_ADDRS;\n\t} else {\n\n\t\t/*\n\t\t * Previous inline data or directory always reserved 200 bytes\n\t\t * in inode layout, even if inline_xattr is disabled. In order\n\t\t * to keep inline_dentry's structure for backward compatibility,\n\t\t * we get the space back only from inline_data.\n\t\t */\n\t\tfi->i_inline_xattr_size = 0;\n\t}\n\n\tif (!sanity_check_inode(inode, node_page)) {\n\t\tf2fs_put_page(node_page, 1);\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_handle_error(sbi, ERROR_CORRUPTED_INODE);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check data exist */\n\tif (f2fs_has_inline_data(inode) && !f2fs_exist_data(inode))\n\t\t__recover_inline_status(inode, node_page);\n\n\t/* try to recover cold bit for non-dir inode */\n\tif (!S_ISDIR(inode->i_mode) && !is_cold_node(node_page)) {\n\t\tf2fs_wait_on_page_writeback(node_page, NODE, true, true);\n\t\tset_cold_node(node_page, false);\n\t\tset_page_dirty(node_page);\n\t}\n\n\t/* get rdev by using inline_info */\n\t__get_inode_rdev(inode, node_page);\n\n\tif (!f2fs_need_inode_block_update(sbi, inode->i_ino))\n\t\tfi->last_disk_size = inode->i_size;\n\n\tif (fi->i_flags & F2FS_PROJINHERIT_FL)\n\t\tset_inode_flag(inode, FI_PROJ_INHERIT);\n\n\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_project_quota(sbi) &&\n\t\t\tF2FS_FITS_IN_INODE(ri, fi->i_extra_isize, i_projid))\n\t\ti_projid = (projid_t)le32_to_cpu(ri->i_projid);\n\telse\n\t\ti_projid = F2FS_DEF_PROJID;\n\tfi->i_projid = make_kprojid(&init_user_ns, i_projid);\n\n\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_inode_crtime(sbi) &&\n\t\t\tF2FS_FITS_IN_INODE(ri, fi->i_extra_isize, i_crtime)) {\n\t\tfi->i_crtime.tv_sec = le64_to_cpu(ri->i_crtime);\n\t\tfi->i_crtime.tv_nsec = le32_to_cpu(ri->i_crtime_nsec);\n\t}\n\n\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_compression(sbi) &&\n\t\t\t\t\t(fi->i_flags & F2FS_COMPR_FL)) {\n\t\tif (F2FS_FITS_IN_INODE(ri, fi->i_extra_isize,\n\t\t\t\t\ti_compress_flag)) {\n\t\t\tunsigned short compress_flag;\n\n\t\t\tatomic_set(&fi->i_compr_blocks,\n\t\t\t\t\tle64_to_cpu(ri->i_compr_blocks));\n\t\t\tfi->i_compress_algorithm = ri->i_compress_algorithm;\n\t\t\tfi->i_log_cluster_size = ri->i_log_cluster_size;\n\t\t\tcompress_flag = le16_to_cpu(ri->i_compress_flag);\n\t\t\tfi->i_compress_level = compress_flag >>\n\t\t\t\t\t\tCOMPRESS_LEVEL_OFFSET;\n\t\t\tfi->i_compress_flag = compress_flag &\n\t\t\t\t\tGENMASK(COMPRESS_LEVEL_OFFSET - 1, 0);\n\t\t\tfi->i_cluster_size = BIT(fi->i_log_cluster_size);\n\t\t\tset_inode_flag(inode, FI_COMPRESSED_FILE);\n\t\t}\n\t}\n\n\tinit_idisk_time(inode);\n\n\tif (!sanity_check_extent_cache(inode, node_page)) {\n\t\tf2fs_put_page(node_page, 1);\n\t\tf2fs_handle_error(sbi, ERROR_CORRUPTED_INODE);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* Need all the flag bits */\n\tf2fs_init_read_extent_tree(inode, node_page);\n\tf2fs_init_age_extent_tree(inode);\n\n\tf2fs_put_page(node_page, 1);\n\n\tstat_inc_inline_xattr(inode);\n\tstat_inc_inline_inode(inode);\n\tstat_inc_inline_dir(inode);\n\tstat_inc_compr_inode(inode);\n\tstat_add_compr_blocks(inode, atomic_read(&fi->i_compr_blocks));\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-44941"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/gfs2/ops_fstype.c",
      "func_name": "init_sbd",
      "func_body": "static struct gfs2_sbd *init_sbd(struct super_block *sb)\n{\n\tstruct gfs2_sbd *sdp;\n\tstruct address_space *mapping;\n\n\tsdp = kzalloc(sizeof(struct gfs2_sbd), GFP_KERNEL);\n\tif (!sdp)\n\t\treturn NULL;\n\n\tsdp->sd_vfs = sb;\n\tsdp->sd_lkstats = alloc_percpu(struct gfs2_pcpu_lkstats);\n\tif (!sdp->sd_lkstats)\n\t\tgoto fail;\n\tsb->s_fs_info = sdp;\n\n\tset_bit(SDF_NOJOURNALID, &sdp->sd_flags);\n\tgfs2_tune_init(&sdp->sd_tune);\n\n\tinit_waitqueue_head(&sdp->sd_kill_wait);\n\tinit_waitqueue_head(&sdp->sd_async_glock_wait);\n\tatomic_set(&sdp->sd_glock_disposal, 0);\n\tinit_completion(&sdp->sd_locking_init);\n\tinit_completion(&sdp->sd_wdack);\n\tspin_lock_init(&sdp->sd_statfs_spin);\n\n\tspin_lock_init(&sdp->sd_rindex_spin);\n\tsdp->sd_rindex_tree.rb_node = NULL;\n\n\tINIT_LIST_HEAD(&sdp->sd_jindex_list);\n\tspin_lock_init(&sdp->sd_jindex_spin);\n\tmutex_init(&sdp->sd_jindex_mutex);\n\tinit_completion(&sdp->sd_journal_ready);\n\n\tINIT_LIST_HEAD(&sdp->sd_quota_list);\n\tmutex_init(&sdp->sd_quota_mutex);\n\tmutex_init(&sdp->sd_quota_sync_mutex);\n\tinit_waitqueue_head(&sdp->sd_quota_wait);\n\tspin_lock_init(&sdp->sd_bitmap_lock);\n\n\tINIT_LIST_HEAD(&sdp->sd_sc_inodes_list);\n\n\tmapping = &sdp->sd_aspace;\n\n\taddress_space_init_once(mapping);\n\tmapping->a_ops = &gfs2_rgrp_aops;\n\tmapping->host = sb->s_bdev->bd_inode;\n\tmapping->flags = 0;\n\tmapping_set_gfp_mask(mapping, GFP_NOFS);\n\tmapping->i_private_data = NULL;\n\tmapping->writeback_index = 0;\n\n\tspin_lock_init(&sdp->sd_log_lock);\n\tatomic_set(&sdp->sd_log_pinned, 0);\n\tINIT_LIST_HEAD(&sdp->sd_log_revokes);\n\tINIT_LIST_HEAD(&sdp->sd_log_ordered);\n\tspin_lock_init(&sdp->sd_ordered_lock);\n\n\tinit_waitqueue_head(&sdp->sd_log_waitq);\n\tinit_waitqueue_head(&sdp->sd_logd_waitq);\n\tspin_lock_init(&sdp->sd_ail_lock);\n\tINIT_LIST_HEAD(&sdp->sd_ail1_list);\n\tINIT_LIST_HEAD(&sdp->sd_ail2_list);\n\n\tinit_rwsem(&sdp->sd_log_flush_lock);\n\tatomic_set(&sdp->sd_log_in_flight, 0);\n\tinit_waitqueue_head(&sdp->sd_log_flush_wait);\n\tmutex_init(&sdp->sd_freeze_mutex);\n\tINIT_LIST_HEAD(&sdp->sd_dead_glocks);\n\n\treturn sdp;\n\nfail:\n\tfree_sbd(sdp);\n\treturn NULL;\n}\n",
      "cve_list": [
        "CVE-2024-38570"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/gfs2/super.c",
      "func_name": "gfs2_put_super",
      "func_body": "static void gfs2_put_super(struct super_block *sb)\n{\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct gfs2_jdesc *jd;\n\n\t/* No more recovery requests */\n\tset_bit(SDF_NORECOVERY, &sdp->sd_flags);\n\tsmp_mb();\n\n\t/* Wait on outstanding recovery */\nrestart:\n\tspin_lock(&sdp->sd_jindex_spin);\n\tlist_for_each_entry(jd, &sdp->sd_jindex_list, jd_list) {\n\t\tif (!test_bit(JDF_RECOVERY, &jd->jd_flags))\n\t\t\tcontinue;\n\t\tspin_unlock(&sdp->sd_jindex_spin);\n\t\twait_on_bit(&jd->jd_flags, JDF_RECOVERY,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&sdp->sd_jindex_spin);\n\n\tif (!sb_rdonly(sb))\n\t\tgfs2_make_fs_ro(sdp);\n\telse {\n\t\tif (gfs2_withdrawing_or_withdrawn(sdp))\n\t\t\tgfs2_destroy_threads(sdp);\n\n\t\tgfs2_quota_cleanup(sdp);\n\t}\n\n\tWARN_ON(gfs2_withdrawing(sdp));\n\n\t/*  At this point, we're through modifying the disk  */\n\n\t/*  Release stuff  */\n\n\tgfs2_freeze_unlock(&sdp->sd_freeze_gh);\n\n\tiput(sdp->sd_jindex);\n\tiput(sdp->sd_statfs_inode);\n\tiput(sdp->sd_rindex);\n\tiput(sdp->sd_quota_inode);\n\n\tgfs2_glock_put(sdp->sd_rename_gl);\n\tgfs2_glock_put(sdp->sd_freeze_gl);\n\n\tif (!sdp->sd_args.ar_spectator) {\n\t\tif (gfs2_holder_initialized(&sdp->sd_journal_gh))\n\t\t\tgfs2_glock_dq_uninit(&sdp->sd_journal_gh);\n\t\tif (gfs2_holder_initialized(&sdp->sd_jinode_gh))\n\t\t\tgfs2_glock_dq_uninit(&sdp->sd_jinode_gh);\n\t\tbrelse(sdp->sd_sc_bh);\n\t\tgfs2_glock_dq_uninit(&sdp->sd_sc_gh);\n\t\tgfs2_glock_dq_uninit(&sdp->sd_qc_gh);\n\t\tfree_local_statfs_inodes(sdp);\n\t\tiput(sdp->sd_qc_inode);\n\t}\n\n\tgfs2_glock_dq_uninit(&sdp->sd_live_gh);\n\tgfs2_clear_rgrpd(sdp);\n\tgfs2_jindex_free(sdp);\n\t/*  Take apart glock structures and buffer lists  */\n\tgfs2_gl_hash_clear(sdp);\n\ttruncate_inode_pages_final(&sdp->sd_aspace);\n\tgfs2_delete_debugfs_file(sdp);\n\n\tgfs2_sys_fs_del(sdp);\n\tfree_sbd(sdp);\n}\n",
      "cve_list": [
        "CVE-2024-38570"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ipv6/ip6_output.c",
      "func_name": "ip6_finish_output2",
      "func_body": "static int ip6_finish_output2(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct net_device *dev = dst->dev;\n\tstruct inet6_dev *idev = ip6_dst_idev(dst);\n\tunsigned int hh_len = LL_RESERVED_SPACE(dev);\n\tconst struct in6_addr *daddr, *nexthop;\n\tstruct ipv6hdr *hdr;\n\tstruct neighbour *neigh;\n\tint ret;\n\n\t/* Be paranoid, rather than too clever. */\n\tif (unlikely(hh_len > skb_headroom(skb)) && dev->header_ops) {\n\t\t/* Make sure idev stays alive */\n\t\trcu_read_lock();\n\t\tskb = skb_expand_head(skb, hh_len);\n\t\tif (!skb) {\n\t\t\tIP6_INC_STATS(net, idev, IPSTATS_MIB_OUTDISCARDS);\n\t\t\trcu_read_unlock();\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\thdr = ipv6_hdr(skb);\n\tdaddr = &hdr->daddr;\n\tif (ipv6_addr_is_multicast(daddr)) {\n\t\tif (!(dev->flags & IFF_LOOPBACK) && sk_mc_loop(sk) &&\n\t\t    ((mroute6_is_socket(net, skb) &&\n\t\t     !(IP6CB(skb)->flags & IP6SKB_FORWARDED)) ||\n\t\t     ipv6_chk_mcast_addr(dev, daddr, &hdr->saddr))) {\n\t\t\tstruct sk_buff *newskb = skb_clone(skb, GFP_ATOMIC);\n\n\t\t\t/* Do not check for IFF_ALLMULTI; multicast routing\n\t\t\t   is not supported in any case.\n\t\t\t */\n\t\t\tif (newskb)\n\t\t\t\tNF_HOOK(NFPROTO_IPV6, NF_INET_POST_ROUTING,\n\t\t\t\t\tnet, sk, newskb, NULL, newskb->dev,\n\t\t\t\t\tdev_loopback_xmit);\n\n\t\t\tif (hdr->hop_limit == 0) {\n\t\t\t\tIP6_INC_STATS(net, idev,\n\t\t\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tIP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUTMCAST, skb->len);\n\t\tif (IPV6_ADDR_MC_SCOPE(daddr) <= IPV6_ADDR_SCOPE_NODELOCAL &&\n\t\t    !(dev->flags & IFF_LOOPBACK)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (lwtunnel_xmit_redirect(dst->lwtstate)) {\n\t\tint res = lwtunnel_xmit(skb);\n\n\t\tif (res != LWTUNNEL_XMIT_CONTINUE)\n\t\t\treturn res;\n\t}\n\n\tIP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUT, skb->len);\n\n\trcu_read_lock();\n\tnexthop = rt6_nexthop(dst_rt6_info(dst), daddr);\n\tneigh = __ipv6_neigh_lookup_noref(dev, nexthop);\n\n\tif (unlikely(IS_ERR_OR_NULL(neigh))) {\n\t\tif (unlikely(!neigh))\n\t\t\tneigh = __neigh_create(&nd_tbl, nexthop, dev, false);\n\t\tif (IS_ERR(neigh)) {\n\t\t\trcu_read_unlock();\n\t\t\tIP6_INC_STATS(net, idev, IPSTATS_MIB_OUTNOROUTES);\n\t\t\tkfree_skb_reason(skb, SKB_DROP_REASON_NEIGH_CREATEFAIL);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tsock_confirm_neigh(skb, neigh);\n\tret = neigh_output(neigh, skb, false);\n\trcu_read_unlock();\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-44986"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/cachefiles/ondemand.c",
      "func_name": "cachefiles_ondemand_daemon_read",
      "func_body": "ssize_t cachefiles_ondemand_daemon_read(struct cachefiles_cache *cache,\n\t\t\t\t\tchar __user *_buffer, size_t buflen)\n{\n\tstruct cachefiles_req *req;\n\tstruct cachefiles_msg *msg;\n\tunsigned long id = 0;\n\tsize_t n;\n\tint ret = 0;\n\tXA_STATE(xas, &cache->reqs, cache->req_id_next);\n\n\txa_lock(&cache->reqs);\n\t/*\n\t * Cyclically search for a request that has not ever been processed,\n\t * to prevent requests from being processed repeatedly, and make\n\t * request distribution fair.\n\t */\n\treq = cachefiles_ondemand_select_req(&xas, ULONG_MAX);\n\tif (!req && cache->req_id_next > 0) {\n\t\txas_set(&xas, 0);\n\t\treq = cachefiles_ondemand_select_req(&xas, cache->req_id_next - 1);\n\t}\n\tif (!req) {\n\t\txa_unlock(&cache->reqs);\n\t\treturn 0;\n\t}\n\n\tmsg = &req->msg;\n\tn = msg->len;\n\n\tif (n > buflen) {\n\t\txa_unlock(&cache->reqs);\n\t\treturn -EMSGSIZE;\n\t}\n\n\txas_clear_mark(&xas, CACHEFILES_REQ_NEW);\n\tcache->req_id_next = xas.xa_index + 1;\n\trefcount_inc(&req->ref);\n\tcachefiles_grab_object(req->object, cachefiles_obj_get_read_req);\n\txa_unlock(&cache->reqs);\n\n\tid = xas.xa_index;\n\n\tif (msg->opcode == CACHEFILES_OP_OPEN) {\n\t\tret = cachefiles_ondemand_get_fd(req);\n\t\tif (ret) {\n\t\t\tcachefiles_ondemand_set_object_close(req->object);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tmsg->msg_id = id;\n\tmsg->object_id = req->object->ondemand->ondemand_id;\n\n\tif (copy_to_user(_buffer, msg, n) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto err_put_fd;\n\t}\n\n\tcachefiles_put_object(req->object, cachefiles_obj_put_read_req);\n\t/* CLOSE request has no reply */\n\tif (msg->opcode == CACHEFILES_OP_CLOSE) {\n\t\txa_erase(&cache->reqs, id);\n\t\tcomplete(&req->done);\n\t}\n\n\tcachefiles_req_put(req);\n\treturn n;\n\nerr_put_fd:\n\tif (msg->opcode == CACHEFILES_OP_OPEN)\n\t\tclose_fd(((struct cachefiles_open *)msg->data)->fd);\nerror:\n\tcachefiles_put_object(req->object, cachefiles_obj_put_read_req);\n\txas_reset(&xas);\n\txas_lock(&xas);\n\tif (xas_load(&xas) == req) {\n\t\treq->error = ret;\n\t\tcomplete(&req->done);\n\t\txas_store(&xas, NULL);\n\t}\n\txas_unlock(&xas);\n\tcachefiles_req_put(req);\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-39510"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/mellanox/mlx5/core/cmd.c",
      "func_name": "cmd_comp_notifier",
      "func_body": "static int cmd_comp_notifier(struct notifier_block *nb,\n\t\t\t     unsigned long type, void *data)\n{\n\tstruct mlx5_core_dev *dev;\n\tstruct mlx5_cmd *cmd;\n\tstruct mlx5_eqe *eqe;\n\n\tcmd = mlx5_nb_cof(nb, struct mlx5_cmd, nb);\n\tdev = container_of(cmd, struct mlx5_core_dev, cmd);\n\teqe = data;\n\n\tif (dev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR)\n\t\treturn NOTIFY_DONE;\n\n\tmlx5_cmd_comp_handler(dev, be32_to_cpu(eqe->data.cmd.vector), false);\n\n\treturn NOTIFY_OK;\n}\n",
      "cve_list": [
        "CVE-2024-38555"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/usb/dwc3/dwc3-st.c",
      "func_name": "st_dwc3_probe",
      "func_body": "static int st_dwc3_probe(struct platform_device *pdev)\n{\n\tstruct st_dwc3 *dwc3_data;\n\tstruct resource *res;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node, *child;\n\tstruct platform_device *child_pdev;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tdwc3_data = devm_kzalloc(dev, sizeof(*dwc3_data), GFP_KERNEL);\n\tif (!dwc3_data)\n\t\treturn -ENOMEM;\n\n\tdwc3_data->glue_base =\n\t\tdevm_platform_ioremap_resource_byname(pdev, \"reg-glue\");\n\tif (IS_ERR(dwc3_data->glue_base))\n\t\treturn PTR_ERR(dwc3_data->glue_base);\n\n\tregmap = syscon_regmap_lookup_by_phandle(node, \"st,syscfg\");\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tdwc3_data->dev = dev;\n\tdwc3_data->regmap = regmap;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"syscfg-reg\");\n\tif (!res)\n\t\treturn -ENXIO;\n\n\tdwc3_data->syscfg_reg_off = res->start;\n\n\tdev_vdbg(&pdev->dev, \"glue-logic addr 0x%pK, syscfg-reg offset 0x%x\\n\",\n\t\t dwc3_data->glue_base, dwc3_data->syscfg_reg_off);\n\n\tdwc3_data->rstc_pwrdn =\n\t\tdevm_reset_control_get_exclusive(dev, \"powerdown\");\n\tif (IS_ERR(dwc3_data->rstc_pwrdn)) {\n\t\tdev_err(&pdev->dev, \"could not get power controller\\n\");\n\t\treturn PTR_ERR(dwc3_data->rstc_pwrdn);\n\t}\n\n\t/* Manage PowerDown */\n\treset_control_deassert(dwc3_data->rstc_pwrdn);\n\n\tdwc3_data->rstc_rst =\n\t\tdevm_reset_control_get_shared(dev, \"softreset\");\n\tif (IS_ERR(dwc3_data->rstc_rst)) {\n\t\tdev_err(&pdev->dev, \"could not get reset controller\\n\");\n\t\tret = PTR_ERR(dwc3_data->rstc_rst);\n\t\tgoto undo_powerdown;\n\t}\n\n\t/* Manage SoftReset */\n\treset_control_deassert(dwc3_data->rstc_rst);\n\n\tchild = of_get_compatible_child(node, \"snps,dwc3\");\n\tif (!child) {\n\t\tdev_err(&pdev->dev, \"failed to find dwc3 core node\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_node_put;\n\t}\n\n\t/* Allocate and initialize the core */\n\tret = of_platform_populate(node, NULL, NULL, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add dwc3 core\\n\");\n\t\tgoto err_node_put;\n\t}\n\n\tchild_pdev = of_find_device_by_node(child);\n\tif (!child_pdev) {\n\t\tdev_err(dev, \"failed to find dwc3 core device\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_node_put;\n\t}\n\n\tdwc3_data->dr_mode = usb_get_dr_mode(&child_pdev->dev);\n\tof_node_put(child);\n\tplatform_device_put(child_pdev);\n\n\t/*\n\t * Configure the USB port as device or host according to the static\n\t * configuration passed from DT.\n\t * DRD is the only mode currently supported so this will be enhanced\n\t * as soon as OTG is available.\n\t */\n\tret = st_dwc3_drd_init(dwc3_data);\n\tif (ret) {\n\t\tdev_err(dev, \"drd initialisation failed\\n\");\n\t\tgoto undo_softreset;\n\t}\n\n\t/* ST glue logic init */\n\tst_dwc3_init(dwc3_data);\n\n\tplatform_set_drvdata(pdev, dwc3_data);\n\treturn 0;\n\nerr_node_put:\n\tof_node_put(child);\nundo_softreset:\n\treset_control_assert(dwc3_data->rstc_rst);\nundo_powerdown:\n\treset_control_assert(dwc3_data->rstc_pwrdn);\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-46674"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/cachefiles/ondemand.c",
      "func_name": "cachefiles_ondemand_send_req",
      "func_body": "static int cachefiles_ondemand_send_req(struct cachefiles_object *object,\n\t\t\t\t\tenum cachefiles_opcode opcode,\n\t\t\t\t\tsize_t data_len,\n\t\t\t\t\tinit_req_fn init_req,\n\t\t\t\t\tvoid *private)\n{\n\tstruct cachefiles_cache *cache = object->volume->cache;\n\tstruct cachefiles_req *req = NULL;\n\tXA_STATE(xas, &cache->reqs, 0);\n\tint ret;\n\n\tif (!test_bit(CACHEFILES_ONDEMAND_MODE, &cache->flags))\n\t\treturn 0;\n\n\tif (test_bit(CACHEFILES_DEAD, &cache->flags)) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\treq = kzalloc(sizeof(*req) + data_len, GFP_KERNEL);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trefcount_set(&req->ref, 1);\n\treq->object = object;\n\tinit_completion(&req->done);\n\treq->msg.opcode = opcode;\n\treq->msg.len = sizeof(struct cachefiles_msg) + data_len;\n\n\tret = init_req(req, private);\n\tif (ret)\n\t\tgoto out;\n\n\tdo {\n\t\t/*\n\t\t * Stop enqueuing the request when daemon is dying. The\n\t\t * following two operations need to be atomic as a whole.\n\t\t *   1) check cache state, and\n\t\t *   2) enqueue request if cache is alive.\n\t\t * Otherwise the request may be enqueued after xarray has been\n\t\t * flushed, leaving the orphan request never being completed.\n\t\t *\n\t\t * CPU 1\t\t\tCPU 2\n\t\t * =====\t\t\t=====\n\t\t *\t\t\t\ttest CACHEFILES_DEAD bit\n\t\t * set CACHEFILES_DEAD bit\n\t\t * flush requests in the xarray\n\t\t *\t\t\t\tenqueue the request\n\t\t */\n\t\txas_lock(&xas);\n\n\t\tif (test_bit(CACHEFILES_DEAD, &cache->flags)) {\n\t\t\txas_unlock(&xas);\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* coupled with the barrier in cachefiles_flush_reqs() */\n\t\tsmp_mb();\n\n\t\tif (opcode == CACHEFILES_OP_CLOSE &&\n\t\t\t!cachefiles_ondemand_object_is_open(object)) {\n\t\t\tWARN_ON_ONCE(object->ondemand->ondemand_id == 0);\n\t\t\txas_unlock(&xas);\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\txas.xa_index = 0;\n\t\txas_find_marked(&xas, UINT_MAX, XA_FREE_MARK);\n\t\tif (xas.xa_node == XAS_RESTART)\n\t\t\txas_set_err(&xas, -EBUSY);\n\t\txas_store(&xas, req);\n\t\txas_clear_mark(&xas, XA_FREE_MARK);\n\t\txas_set_mark(&xas, CACHEFILES_REQ_NEW);\n\t\txas_unlock(&xas);\n\t} while (xas_nomem(&xas, GFP_KERNEL));\n\n\tret = xas_error(&xas);\n\tif (ret)\n\t\tgoto out;\n\n\twake_up_all(&cache->daemon_pollwq);\n\twait_for_completion(&req->done);\n\tret = req->error;\n\tcachefiles_req_put(req);\n\treturn ret;\nout:\n\t/* Reset the object to close state in error handling path.\n\t * If error occurs after creating the anonymous fd,\n\t * cachefiles_ondemand_fd_release() will set object to close.\n\t */\n\tif (opcode == CACHEFILES_OP_OPEN)\n\t\tcachefiles_ondemand_set_object_close(object);\n\tkfree(req);\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-40899"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/crypto/intel/iaa/iaa_crypto_main.c",
      "func_name": "remove_device_compression_modes",
      "func_body": "static void remove_device_compression_modes(struct iaa_device *iaa_device)\n{\n\tstruct iaa_device_compression_mode *device_mode;\n\tint i;\n\n\tfor (i = 0; i < IAA_COMP_MODES_MAX; i++) {\n\t\tdevice_mode = iaa_device->compression_modes[i];\n\t\tif (!device_mode)\n\t\t\tcontinue;\n\n\t\tif (iaa_compression_modes[i]->free)\n\t\t\tiaa_compression_modes[i]->free(device_mode);\n\t\tfree_device_compression_mode(iaa_device, device_mode);\n\t\tiaa_device->compression_modes[i] = NULL;\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-47732"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/dma/idxd/irq.c",
      "func_name": "irq_process_work_list",
      "func_body": "static void irq_process_work_list(struct idxd_irq_entry *irq_entry)\n{\n\tLIST_HEAD(flist);\n\tstruct idxd_desc *desc, *n;\n\n\t/*\n\t * This lock protects list corruption from access of list outside of the irq handler\n\t * thread.\n\t */\n\tspin_lock(&irq_entry->list_lock);\n\tif (list_empty(&irq_entry->work_list)) {\n\t\tspin_unlock(&irq_entry->list_lock);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_safe(desc, n, &irq_entry->work_list, list) {\n\t\tif (desc->completion->status) {\n\t\t\tlist_move_tail(&desc->list, &flist);\n\t\t}\n\t}\n\n\tspin_unlock(&irq_entry->list_lock);\n\n\tlist_for_each_entry_safe(desc, n, &flist, list) {\n\t\t/*\n\t\t * Check against the original status as ABORT is software defined\n\t\t * and 0xff, which DSA_COMP_STATUS_MASK can mask out.\n\t\t */\n\t\tlist_del(&desc->list);\n\n\t\tif (unlikely(desc->completion->status == IDXD_COMP_DESC_ABORT)) {\n\t\t\tidxd_desc_complete(desc, IDXD_COMPLETE_ABORT, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tidxd_desc_complete(desc, IDXD_COMPLETE_NORMAL, true);\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-40956"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/scsi/pm8001/pm8001_sas.c",
      "func_name": "pm8001_phy_control",
      "func_body": "int pm8001_phy_control(struct asd_sas_phy *sas_phy, enum phy_func func,\n\tvoid *funcdata)\n{\n\tint rc = 0, phy_id = sas_phy->id;\n\tstruct pm8001_hba_info *pm8001_ha = NULL;\n\tstruct sas_phy_linkrates *rates;\n\tstruct pm8001_phy *phy;\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tunsigned long flags;\n\tpm8001_ha = sas_phy->ha->lldd_ha;\n\tphy = &pm8001_ha->phy[phy_id];\n\n\tif (PM8001_CHIP_DISP->fatal_errors(pm8001_ha)) {\n\t\t/*\n\t\t * If the controller is in fatal error state,\n\t\t * we will not get a response from the controller\n\t\t */\n\t\tpm8001_dbg(pm8001_ha, FAIL,\n\t\t\t   \"Phy control failed due to fatal errors\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tswitch (func) {\n\tcase PHY_FUNC_SET_LINK_RATE:\n\t\trates = funcdata;\n\t\tif (rates->minimum_linkrate) {\n\t\t\tpm8001_ha->phy[phy_id].minimum_linkrate =\n\t\t\t\trates->minimum_linkrate;\n\t\t}\n\t\tif (rates->maximum_linkrate) {\n\t\t\tpm8001_ha->phy[phy_id].maximum_linkrate =\n\t\t\t\trates->maximum_linkrate;\n\t\t}\n\t\tif (pm8001_ha->phy[phy_id].phy_state ==  PHY_LINK_DISABLE) {\n\t\t\tpm8001_ha->phy[phy_id].enable_completion = &completion;\n\t\t\tPM8001_CHIP_DISP->phy_start_req(pm8001_ha, phy_id);\n\t\t\twait_for_completion(&completion);\n\t\t}\n\t\tPM8001_CHIP_DISP->phy_ctl_req(pm8001_ha, phy_id,\n\t\t\t\t\t      PHY_LINK_RESET);\n\t\tbreak;\n\tcase PHY_FUNC_HARD_RESET:\n\t\tif (pm8001_ha->phy[phy_id].phy_state == PHY_LINK_DISABLE) {\n\t\t\tpm8001_ha->phy[phy_id].enable_completion = &completion;\n\t\t\tPM8001_CHIP_DISP->phy_start_req(pm8001_ha, phy_id);\n\t\t\twait_for_completion(&completion);\n\t\t}\n\t\tPM8001_CHIP_DISP->phy_ctl_req(pm8001_ha, phy_id,\n\t\t\t\t\t      PHY_HARD_RESET);\n\t\tbreak;\n\tcase PHY_FUNC_LINK_RESET:\n\t\tif (pm8001_ha->phy[phy_id].phy_state == PHY_LINK_DISABLE) {\n\t\t\tpm8001_ha->phy[phy_id].enable_completion = &completion;\n\t\t\tPM8001_CHIP_DISP->phy_start_req(pm8001_ha, phy_id);\n\t\t\twait_for_completion(&completion);\n\t\t}\n\t\tPM8001_CHIP_DISP->phy_ctl_req(pm8001_ha, phy_id,\n\t\t\t\t\t      PHY_LINK_RESET);\n\t\tbreak;\n\tcase PHY_FUNC_RELEASE_SPINUP_HOLD:\n\t\tPM8001_CHIP_DISP->phy_ctl_req(pm8001_ha, phy_id,\n\t\t\t\t\t      PHY_LINK_RESET);\n\t\tbreak;\n\tcase PHY_FUNC_DISABLE:\n\t\tif (pm8001_ha->chip_id != chip_8001) {\n\t\t\tif (pm8001_ha->phy[phy_id].phy_state ==\n\t\t\t\tPHY_STATE_LINK_UP_SPCV) {\n\t\t\t\tsas_phy_disconnected(&phy->sas_phy);\n\t\t\t\tsas_notify_phy_event(&phy->sas_phy,\n\t\t\t\t\tPHYE_LOSS_OF_SIGNAL, GFP_KERNEL);\n\t\t\t\tphy->phy_attached = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (pm8001_ha->phy[phy_id].phy_state ==\n\t\t\t\tPHY_STATE_LINK_UP_SPC) {\n\t\t\t\tsas_phy_disconnected(&phy->sas_phy);\n\t\t\t\tsas_notify_phy_event(&phy->sas_phy,\n\t\t\t\t\tPHYE_LOSS_OF_SIGNAL, GFP_KERNEL);\n\t\t\t\tphy->phy_attached = 0;\n\t\t\t}\n\t\t}\n\t\tPM8001_CHIP_DISP->phy_stop_req(pm8001_ha, phy_id);\n\t\tbreak;\n\tcase PHY_FUNC_GET_EVENTS:\n\t\tspin_lock_irqsave(&pm8001_ha->lock, flags);\n\t\tif (pm8001_ha->chip_id == chip_8001) {\n\t\t\tif (-1 == pm8001_bar4_shift(pm8001_ha,\n\t\t\t\t\t(phy_id < 4) ? 0x30000 : 0x40000)) {\n\t\t\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tstruct sas_phy *phy = sas_phy->phy;\n\t\t\tu32 __iomem *qp = pm8001_ha->io_mem[2].memvirtaddr\n\t\t\t\t+ 0x1034 + (0x4000 * (phy_id & 3));\n\n\t\t\tphy->invalid_dword_count = readl(qp);\n\t\t\tphy->running_disparity_error_count = readl(&qp[1]);\n\t\t\tphy->loss_of_dword_sync_count = readl(&qp[3]);\n\t\t\tphy->phy_reset_problem_count = readl(&qp[4]);\n\t\t}\n\t\tif (pm8001_ha->chip_id == chip_8001)\n\t\t\tpm8001_bar4_shift(pm8001_ha, 0);\n\t\tspin_unlock_irqrestore(&pm8001_ha->lock, flags);\n\t\treturn 0;\n\tdefault:\n\t\tpm8001_dbg(pm8001_ha, DEVIO, \"func 0x%x\\n\", func);\n\t\trc = -EOPNOTSUPP;\n\t}\n\tmsleep(300);\n\treturn rc;\n}\n",
      "cve_list": [
        "CVE-2024-47666"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/trace/ftrace.c",
      "func_name": "ftrace_location_range",
      "func_body": "unsigned long ftrace_location_range(unsigned long start, unsigned long end)\n{\n\tstruct dyn_ftrace *rec;\n\tunsigned long ip = 0;\n\n\trcu_read_lock();\n\trec = lookup_rec(start, end);\n\tif (rec)\n\t\tip = rec->ip;\n\trcu_read_unlock();\n\n\treturn ip;\n}\n",
      "cve_list": [
        "CVE-2024-38588"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/trace/ftrace.c",
      "func_name": "ftrace_location",
      "func_body": "unsigned long ftrace_location(unsigned long ip)\n{\n\tunsigned long loc;\n\tunsigned long offset;\n\tunsigned long size;\n\n\tloc = ftrace_location_range(ip, ip);\n\tif (!loc) {\n\t\tif (!kallsyms_lookup_size_offset(ip, &size, &offset))\n\t\t\tgoto out;\n\n\t\t/* map sym+0 to __fentry__ */\n\t\tif (!offset)\n\t\t\tloc = ftrace_location_range(ip, ip + size - 1);\n\t}\n\nout:\n\treturn loc;\n}\n",
      "cve_list": [
        "CVE-2024-38588"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/trace/ftrace.c",
      "func_name": "ftrace_process_locs",
      "func_body": "static int ftrace_process_locs(struct module *mod,\n\t\t\t       unsigned long *start,\n\t\t\t       unsigned long *end)\n{\n\tstruct ftrace_page *pg_unuse = NULL;\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tunsigned long skipped = 0;\n\tunsigned long count;\n\tunsigned long *p;\n\tunsigned long addr;\n\tunsigned long flags = 0; /* Shut up gcc */\n\tint ret = -ENOMEM;\n\n\tcount = end - start;\n\n\tif (!count)\n\t\treturn 0;\n\n\t/*\n\t * Sorting mcount in vmlinux at build time depend on\n\t * CONFIG_BUILDTIME_MCOUNT_SORT, while mcount loc in\n\t * modules can not be sorted at build time.\n\t */\n\tif (!IS_ENABLED(CONFIG_BUILDTIME_MCOUNT_SORT) || mod) {\n\t\tsort(start, count, sizeof(*start),\n\t\t     ftrace_cmp_ips, NULL);\n\t} else {\n\t\ttest_is_sorted(start, count);\n\t}\n\n\tstart_pg = ftrace_allocate_pages(count);\n\tif (!start_pg)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * Core and each module needs their own pages, as\n\t * modules will free them when they are removed.\n\t * Force a new page to be allocated for modules.\n\t */\n\tif (!mod) {\n\t\tWARN_ON(ftrace_pages || ftrace_pages_start);\n\t\t/* First initialization */\n\t\tftrace_pages = ftrace_pages_start = start_pg;\n\t} else {\n\t\tif (!ftrace_pages)\n\t\t\tgoto out;\n\n\t\tif (WARN_ON(ftrace_pages->next)) {\n\t\t\t/* Hmm, we have free pages? */\n\t\t\twhile (ftrace_pages->next)\n\t\t\t\tftrace_pages = ftrace_pages->next;\n\t\t}\n\n\t\tftrace_pages->next = start_pg;\n\t}\n\n\tp = start;\n\tpg = start_pg;\n\twhile (p < end) {\n\t\tunsigned long end_offset;\n\t\taddr = ftrace_call_adjust(*p++);\n\t\t/*\n\t\t * Some architecture linkers will pad between\n\t\t * the different mcount_loc sections of different\n\t\t * object files to satisfy alignments.\n\t\t * Skip any NULL pointers.\n\t\t */\n\t\tif (!addr) {\n\t\t\tskipped++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tend_offset = (pg->index+1) * sizeof(pg->records[0]);\n\t\tif (end_offset > PAGE_SIZE << pg->order) {\n\t\t\t/* We should have allocated enough */\n\t\t\tif (WARN_ON(!pg->next))\n\t\t\t\tbreak;\n\t\t\tpg = pg->next;\n\t\t}\n\n\t\trec = &pg->records[pg->index++];\n\t\trec->ip = addr;\n\t}\n\n\tif (pg->next) {\n\t\tpg_unuse = pg->next;\n\t\tpg->next = NULL;\n\t}\n\n\t/* Assign the last page to ftrace_pages */\n\tftrace_pages = pg;\n\n\t/*\n\t * We only need to disable interrupts on start up\n\t * because we are modifying code that an interrupt\n\t * may execute, and the modification is not atomic.\n\t * But for modules, nothing runs the code we modify\n\t * until we are finished with it, and there's no\n\t * reason to cause large interrupt latencies while we do it.\n\t */\n\tif (!mod)\n\t\tlocal_irq_save(flags);\n\tftrace_update_code(mod, start_pg);\n\tif (!mod)\n\t\tlocal_irq_restore(flags);\n\tret = 0;\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\t/* We should have used all pages unless we skipped some */\n\tif (pg_unuse) {\n\t\tWARN_ON(!skipped);\n\t\t/* Need to synchronize with ftrace_location_range() */\n\t\tsynchronize_rcu();\n\t\tftrace_free_pages(pg_unuse);\n\t}\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-38588"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/trace/ftrace.c",
      "func_name": "ftrace_release_mod",
      "func_body": "void ftrace_release_mod(struct module *mod)\n{\n\tstruct ftrace_mod_map *mod_map;\n\tstruct ftrace_mod_map *n;\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page **last_pg;\n\tstruct ftrace_page *tmp_page = NULL;\n\tstruct ftrace_page *pg;\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (ftrace_disabled)\n\t\tgoto out_unlock;\n\n\tlist_for_each_entry_safe(mod_map, n, &ftrace_mod_maps, list) {\n\t\tif (mod_map->mod == mod) {\n\t\t\tlist_del_rcu(&mod_map->list);\n\t\t\tcall_rcu(&mod_map->rcu, ftrace_free_mod_map);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Each module has its own ftrace_pages, remove\n\t * them from the list.\n\t */\n\tlast_pg = &ftrace_pages_start;\n\tfor (pg = ftrace_pages_start; pg; pg = *last_pg) {\n\t\trec = &pg->records[0];\n\t\tif (within_module(rec->ip, mod)) {\n\t\t\t/*\n\t\t\t * As core pages are first, the first\n\t\t\t * page should never be a module page.\n\t\t\t */\n\t\t\tif (WARN_ON(pg == ftrace_pages_start))\n\t\t\t\tgoto out_unlock;\n\n\t\t\t/* Check if we are deleting the last page */\n\t\t\tif (pg == ftrace_pages)\n\t\t\t\tftrace_pages = next_to_ftrace_page(last_pg);\n\n\t\t\tftrace_update_tot_cnt -= pg->index;\n\t\t\t*last_pg = pg->next;\n\n\t\t\tpg->next = tmp_page;\n\t\t\ttmp_page = pg;\n\t\t} else\n\t\t\tlast_pg = &pg->next;\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\t/* Need to synchronize with ftrace_location_range() */\n\tif (tmp_page)\n\t\tsynchronize_rcu();\n\tfor (pg = tmp_page; pg; pg = tmp_page) {\n\n\t\t/* Needs to be called outside of ftrace_lock */\n\t\tclear_mod_from_hashes(pg);\n\n\t\tif (pg->records) {\n\t\t\tfree_pages((unsigned long)pg->records, pg->order);\n\t\t\tftrace_number_of_pages -= 1 << pg->order;\n\t\t}\n\t\ttmp_page = pg->next;\n\t\tkfree(pg);\n\t\tftrace_number_of_groups--;\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-38588"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/trace/ftrace.c",
      "func_name": "ftrace_free_mem",
      "func_body": "void ftrace_free_mem(struct module *mod, void *start_ptr, void *end_ptr)\n{\n\tunsigned long start = (unsigned long)(start_ptr);\n\tunsigned long end = (unsigned long)(end_ptr);\n\tstruct ftrace_page **last_pg = &ftrace_pages_start;\n\tstruct ftrace_page *tmp_page = NULL;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tstruct dyn_ftrace key;\n\tstruct ftrace_mod_map *mod_map = NULL;\n\tstruct ftrace_init_func *func, *func_next;\n\tLIST_HEAD(clear_hash);\n\n\tkey.ip = start;\n\tkey.flags = end;\t/* overload flags, as it is unsigned long */\n\n\tmutex_lock(&ftrace_lock);\n\n\t/*\n\t * If we are freeing module init memory, then check if\n\t * any tracer is active. If so, we need to save a mapping of\n\t * the module functions being freed with the address.\n\t */\n\tif (mod && ftrace_ops_list != &ftrace_list_end)\n\t\tmod_map = allocate_ftrace_mod_map(mod, start, end);\n\n\tfor (pg = ftrace_pages_start; pg; last_pg = &pg->next, pg = *last_pg) {\n\t\tif (end < pg->records[0].ip ||\n\t\t    start >= (pg->records[pg->index - 1].ip + MCOUNT_INSN_SIZE))\n\t\t\tcontinue;\n again:\n\t\trec = bsearch(&key, pg->records, pg->index,\n\t\t\t      sizeof(struct dyn_ftrace),\n\t\t\t      ftrace_cmp_recs);\n\t\tif (!rec)\n\t\t\tcontinue;\n\n\t\t/* rec will be cleared from hashes after ftrace_lock unlock */\n\t\tadd_to_clear_hash_list(&clear_hash, rec);\n\n\t\tif (mod_map)\n\t\t\tsave_ftrace_mod_rec(mod_map, rec);\n\n\t\tpg->index--;\n\t\tftrace_update_tot_cnt--;\n\t\tif (!pg->index) {\n\t\t\t*last_pg = pg->next;\n\t\t\tpg->next = tmp_page;\n\t\t\ttmp_page = pg;\n\t\t\tpg = container_of(last_pg, struct ftrace_page, next);\n\t\t\tif (!(*last_pg))\n\t\t\t\tftrace_pages = pg;\n\t\t\tcontinue;\n\t\t}\n\t\tmemmove(rec, rec + 1,\n\t\t\t(pg->index - (rec - pg->records)) * sizeof(*rec));\n\t\t/* More than one function may be in this block */\n\t\tgoto again;\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n\tlist_for_each_entry_safe(func, func_next, &clear_hash, list) {\n\t\tclear_func_from_hashes(func);\n\t\tkfree(func);\n\t}\n\t/* Need to synchronize with ftrace_location_range() */\n\tif (tmp_page) {\n\t\tsynchronize_rcu();\n\t\tftrace_free_pages(tmp_page);\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-38588"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/usb/typec/tcpm/tcpm.c",
      "func_name": "tcpm_register_source_caps",
      "func_body": "static int tcpm_register_source_caps(struct tcpm_port *port)\n{\n\tstruct usb_power_delivery_desc desc = { port->negotiated_rev };\n\tstruct usb_power_delivery_capabilities_desc caps = { };\n\tstruct usb_power_delivery_capabilities *cap = port->partner_source_caps;\n\n\tif (!port->partner_pd)\n\t\tport->partner_pd = usb_power_delivery_register(NULL, &desc);\n\tif (IS_ERR(port->partner_pd))\n\t\treturn PTR_ERR(port->partner_pd);\n\n\tmemcpy(caps.pdo, port->source_caps, sizeof(u32) * port->nr_source_caps);\n\tcaps.role = TYPEC_SOURCE;\n\n\tif (cap) {\n\t\tusb_power_delivery_unregister_capabilities(cap);\n\t\tport->partner_source_caps = NULL;\n\t}\n\n\tcap = usb_power_delivery_register_capabilities(port->partner_pd, &caps);\n\tif (IS_ERR(cap))\n\t\treturn PTR_ERR(cap);\n\n\tport->partner_source_caps = cap;\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-40903"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/scsi/lpfc/lpfc_els.c",
      "func_name": "lpfc_get_sfp_info_wait",
      "func_body": "int lpfc_get_sfp_info_wait(struct lpfc_hba *phba,\n\t\t\t   struct lpfc_rdp_context *rdp_context)\n{\n\tLPFC_MBOXQ_t *mbox = NULL;\n\tint rc;\n\tstruct lpfc_dmabuf *mp;\n\tstruct lpfc_dmabuf *mpsave;\n\tvoid *virt;\n\tMAILBOX_t *mb;\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mbox) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_MBOX | LOG_ELS,\n\t\t\t\t\"7205 failed to allocate mailbox memory\");\n\t\treturn 1;\n\t}\n\n\tif (lpfc_sli4_dump_page_a0(phba, mbox))\n\t\tgoto sfp_fail;\n\tmp = mbox->ctx_buf;\n\tmpsave = mp;\n\tvirt = mp->virt;\n\tif (phba->sli_rev < LPFC_SLI_REV4) {\n\t\tmb = &mbox->u.mb;\n\t\tmb->un.varDmp.cv = 1;\n\t\tmb->un.varDmp.co = 1;\n\t\tmb->un.varWords[2] = 0;\n\t\tmb->un.varWords[3] = DMP_SFF_PAGE_A0_SIZE / 4;\n\t\tmb->un.varWords[4] = 0;\n\t\tmb->un.varWords[5] = 0;\n\t\tmb->un.varWords[6] = 0;\n\t\tmb->un.varWords[7] = 0;\n\t\tmb->un.varWords[8] = 0;\n\t\tmb->un.varWords[9] = 0;\n\t\tmb->un.varWords[10] = 0;\n\t\tmbox->in_ext_byte_len = DMP_SFF_PAGE_A0_SIZE;\n\t\tmbox->out_ext_byte_len = DMP_SFF_PAGE_A0_SIZE;\n\t\tmbox->mbox_offset_word = 5;\n\t\tmbox->ext_buf = virt;\n\t} else {\n\t\tbf_set(lpfc_mbx_memory_dump_type3_length,\n\t\t       &mbox->u.mqe.un.mem_dump_type3, DMP_SFF_PAGE_A0_SIZE);\n\t\tmbox->u.mqe.un.mem_dump_type3.addr_lo = putPaddrLow(mp->phys);\n\t\tmbox->u.mqe.un.mem_dump_type3.addr_hi = putPaddrHigh(mp->phys);\n\t}\n\tmbox->vport = phba->pport;\n\trc = lpfc_sli_issue_mbox_wait(phba, mbox, LPFC_MBOX_SLI4_CONFIG_TMO);\n\tif (rc == MBX_NOT_FINISHED) {\n\t\trc = 1;\n\t\tgoto error;\n\t}\n\tif (rc == MBX_TIMEOUT)\n\t\tgoto error;\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tmp = mbox->ctx_buf;\n\telse\n\t\tmp = mpsave;\n\n\tif (bf_get(lpfc_mqe_status, &mbox->u.mqe)) {\n\t\trc = 1;\n\t\tgoto error;\n\t}\n\n\tlpfc_sli_bemem_bcopy(mp->virt, &rdp_context->page_a0,\n\t\t\t     DMP_SFF_PAGE_A0_SIZE);\n\n\tmemset(mbox, 0, sizeof(*mbox));\n\tmemset(mp->virt, 0, DMP_SFF_PAGE_A2_SIZE);\n\tINIT_LIST_HEAD(&mp->list);\n\n\t/* save address for completion */\n\tmbox->ctx_buf = mp;\n\tmbox->vport = phba->pport;\n\n\tbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_DUMP_MEMORY);\n\tbf_set(lpfc_mbx_memory_dump_type3_type,\n\t       &mbox->u.mqe.un.mem_dump_type3, DMP_LMSD);\n\tbf_set(lpfc_mbx_memory_dump_type3_link,\n\t       &mbox->u.mqe.un.mem_dump_type3, phba->sli4_hba.physical_port);\n\tbf_set(lpfc_mbx_memory_dump_type3_page_no,\n\t       &mbox->u.mqe.un.mem_dump_type3, DMP_PAGE_A2);\n\tif (phba->sli_rev < LPFC_SLI_REV4) {\n\t\tmb = &mbox->u.mb;\n\t\tmb->un.varDmp.cv = 1;\n\t\tmb->un.varDmp.co = 1;\n\t\tmb->un.varWords[2] = 0;\n\t\tmb->un.varWords[3] = DMP_SFF_PAGE_A2_SIZE / 4;\n\t\tmb->un.varWords[4] = 0;\n\t\tmb->un.varWords[5] = 0;\n\t\tmb->un.varWords[6] = 0;\n\t\tmb->un.varWords[7] = 0;\n\t\tmb->un.varWords[8] = 0;\n\t\tmb->un.varWords[9] = 0;\n\t\tmb->un.varWords[10] = 0;\n\t\tmbox->in_ext_byte_len = DMP_SFF_PAGE_A2_SIZE;\n\t\tmbox->out_ext_byte_len = DMP_SFF_PAGE_A2_SIZE;\n\t\tmbox->mbox_offset_word = 5;\n\t\tmbox->ext_buf = virt;\n\t} else {\n\t\tbf_set(lpfc_mbx_memory_dump_type3_length,\n\t\t       &mbox->u.mqe.un.mem_dump_type3, DMP_SFF_PAGE_A2_SIZE);\n\t\tmbox->u.mqe.un.mem_dump_type3.addr_lo = putPaddrLow(mp->phys);\n\t\tmbox->u.mqe.un.mem_dump_type3.addr_hi = putPaddrHigh(mp->phys);\n\t}\n\n\trc = lpfc_sli_issue_mbox_wait(phba, mbox, LPFC_MBOX_SLI4_CONFIG_TMO);\n\n\tif (rc == MBX_TIMEOUT)\n\t\tgoto error;\n\tif (bf_get(lpfc_mqe_status, &mbox->u.mqe)) {\n\t\trc = 1;\n\t\tgoto error;\n\t}\n\trc = 0;\n\n\tlpfc_sli_bemem_bcopy(mp->virt, &rdp_context->page_a2,\n\t\t\t     DMP_SFF_PAGE_A2_SIZE);\n\nerror:\n\tif (mbox->mbox_flag & LPFC_MBX_WAKE) {\n\t\tmbox->ctx_buf = mpsave;\n\t\tlpfc_mbox_rsrc_cleanup(phba, mbox, MBOX_THD_UNLOCKED);\n\t}\n\n\treturn rc;\n\nsfp_fail:\n\tmempool_free(mbox, phba->mbox_mem_pool);\n\treturn 1;\n}\n",
      "cve_list": [
        "CVE-2024-46842"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/netfilter/nf_tables_api.c",
      "func_name": "nft_verdict_init",
      "func_body": "static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,\n\t\t\t    struct nft_data_desc *desc, const struct nlattr *nla)\n{\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nlattr *tb[NFTA_VERDICT_MAX + 1];\n\tstruct nft_chain *chain;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_VERDICT_MAX, nla,\n\t\t\t\t\t  nft_verdict_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_VERDICT_CODE])\n\t\treturn -EINVAL;\n\n\t/* zero padding hole for memcmp */\n\tmemset(data, 0, sizeof(*data));\n\tdata->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));\n\n\tswitch (data->verdict.code) {\n\tcase NF_ACCEPT:\n\tcase NF_DROP:\n\tcase NF_QUEUE:\n\t\tbreak;\n\tcase NFT_CONTINUE:\n\tcase NFT_BREAK:\n\tcase NFT_RETURN:\n\t\tbreak;\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tif (tb[NFTA_VERDICT_CHAIN]) {\n\t\t\tchain = nft_chain_lookup(ctx->net, ctx->table,\n\t\t\t\t\t\t tb[NFTA_VERDICT_CHAIN],\n\t\t\t\t\t\t genmask);\n\t\t} else if (tb[NFTA_VERDICT_CHAIN_ID]) {\n\t\t\tchain = nft_chain_lookup_byid(ctx->net, ctx->table,\n\t\t\t\t\t\t      tb[NFTA_VERDICT_CHAIN_ID],\n\t\t\t\t\t\t      genmask);\n\t\t\tif (IS_ERR(chain))\n\t\t\t\treturn PTR_ERR(chain);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (IS_ERR(chain))\n\t\t\treturn PTR_ERR(chain);\n\t\tif (nft_is_base_chain(chain))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (nft_chain_is_bound(chain))\n\t\t\treturn -EINVAL;\n\t\tif (desc->flags & NFT_DATA_DESC_SETELEM &&\n\t\t    chain->flags & NFT_CHAIN_BINDING)\n\t\t\treturn -EINVAL;\n\t\tif (!nft_use_inc(&chain->use))\n\t\t\treturn -EMFILE;\n\n\t\tdata->verdict.chain = chain;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdesc->len = sizeof(data->verdict);\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-1086"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/iucv/af_iucv.c",
      "func_name": "iucv_sever_path",
      "func_body": "static void iucv_sever_path(struct sock *sk, int with_user_data)\n{\n\tunsigned char user_data[16];\n\tstruct iucv_sock *iucv = iucv_sk(sk);\n\tstruct iucv_path *path = iucv->path;\n\n\t/* Whoever resets the path pointer, must sever and free it. */\n\tif (xchg(&iucv->path, NULL)) {\n\t\tif (with_user_data) {\n\t\t\tlow_nmcpy(user_data, iucv->src_name);\n\t\t\thigh_nmcpy(user_data, iucv->dst_name);\n\t\t\tASCEBC(user_data, sizeof(user_data));\n\t\t\tpr_iucv->path_sever(path, user_data);\n\t\t} else\n\t\t\tpr_iucv->path_sever(path, NULL);\n\t\tiucv_path_free(path);\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-42271"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "lib/kunit/try-catch.c",
      "func_name": "kunit_try_catch_run",
      "func_body": "void kunit_try_catch_run(struct kunit_try_catch *try_catch, void *context)\n{\n\tDECLARE_COMPLETION_ONSTACK(try_completion);\n\tstruct kunit *test = try_catch->test;\n\tstruct task_struct *task_struct;\n\tint exit_code, time_remaining;\n\n\ttry_catch->context = context;\n\ttry_catch->try_completion = &try_completion;\n\ttry_catch->try_result = 0;\n\ttask_struct = kthread_create(kunit_generic_run_threadfn_adapter,\n\t\t\t\t     try_catch, \"kunit_try_catch_thread\");\n\tif (IS_ERR(task_struct)) {\n\t\ttry_catch->try_result = PTR_ERR(task_struct);\n\t\ttry_catch->catch(try_catch->context);\n\t\treturn;\n\t}\n\tget_task_struct(task_struct);\n\twake_up_process(task_struct);\n\n\ttime_remaining = wait_for_completion_timeout(&try_completion,\n\t\t\t\t\t\t     kunit_test_timeout());\n\tif (time_remaining == 0) {\n\t\tkunit_err(test, \"try timed out\\n\");\n\t\ttry_catch->try_result = -ETIMEDOUT;\n\t\tkthread_stop(task_struct);\n\t}\n\n\tput_task_struct(task_struct);\n\texit_code = try_catch->try_result;\n\n\tif (!exit_code)\n\t\treturn;\n\n\tif (exit_code == -EFAULT)\n\t\ttry_catch->try_result = 0;\n\telse if (exit_code == -EINTR)\n\t\tkunit_err(test, \"wake_up_process() was never called\\n\");\n\telse if (exit_code)\n\t\tkunit_err(test, \"Unknown error: %d\\n\", exit_code);\n\n\ttry_catch->catch(try_catch->context);\n}\n",
      "cve_list": [
        "CVE-2024-38561"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/block/aoe/aoecmd.c",
      "func_name": "aoecmd_cfg_pkts",
      "func_body": "static void\naoecmd_cfg_pkts(ushort aoemajor, unsigned char aoeminor, struct sk_buff_head *queue)\n{\n\tstruct aoe_hdr *h;\n\tstruct aoe_cfghdr *ch;\n\tstruct sk_buff *skb;\n\tstruct net_device *ifp;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(&init_net, ifp) {\n\t\tdev_hold(ifp);\n\t\tif (!is_aoe_netif(ifp)) {\n\t\t\tdev_put(ifp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tskb = new_skb(sizeof *h + sizeof *ch);\n\t\tif (skb == NULL) {\n\t\t\tprintk(KERN_INFO \"aoe: skb alloc failure\\n\");\n\t\t\tdev_put(ifp);\n\t\t\tcontinue;\n\t\t}\n\t\tskb_put(skb, sizeof *h + sizeof *ch);\n\t\tskb->dev = ifp;\n\t\t__skb_queue_tail(queue, skb);\n\t\th = (struct aoe_hdr *) skb_mac_header(skb);\n\t\tmemset(h, 0, sizeof *h + sizeof *ch);\n\n\t\tmemset(h->dst, 0xff, sizeof h->dst);\n\t\tmemcpy(h->src, ifp->dev_addr, sizeof h->src);\n\t\th->type = __constant_cpu_to_be16(ETH_P_AOE);\n\t\th->verfl = AOE_HVER;\n\t\th->major = cpu_to_be16(aoemajor);\n\t\th->minor = aoeminor;\n\t\th->cmd = AOECMD_CFG;\n\t}\n\trcu_read_unlock();\n}\n",
      "cve_list": [
        "CVE-2024-26898"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/smb/client/smb2inode.c",
      "func_name": "smb2_set_path_size",
      "func_body": "int\nsmb2_set_path_size(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *full_path, __u64 size,\n\t\t   struct cifs_sb_info *cifs_sb, bool set_alloc,\n\t\t   struct dentry *dentry)\n{\n\tstruct cifs_open_parms oparms;\n\tstruct cifsFileInfo *cfile;\n\tstruct kvec in_iov;\n\t__le64 eof = cpu_to_le64(size);\n\tint rc;\n\n\tin_iov.iov_base = &eof;\n\tin_iov.iov_len = sizeof(eof);\n\tcifs_get_writable_path(tcon, full_path, FIND_WR_ANY, &cfile);\n\n\toparms = CIFS_OPARMS(cifs_sb, tcon, full_path, FILE_WRITE_DATA,\n\t\t\t     FILE_OPEN, 0, ACL_NO_MODE);\n\trc = smb2_compound_op(xid, tcon, cifs_sb,\n\t\t\t      full_path, &oparms, &in_iov,\n\t\t\t      &(int){SMB2_OP_SET_EOF}, 1,\n\t\t\t      cfile, NULL, NULL, dentry);\n\tif (rc == -EINVAL) {\n\t\tcifs_dbg(FYI, \"invalid lease key, resending request without lease\");\n\t\tcifs_get_writable_path(tcon, full_path, FIND_WR_ANY, &cfile);\n\t\trc = smb2_compound_op(xid, tcon, cifs_sb,\n\t\t\t\t      full_path, &oparms, &in_iov,\n\t\t\t\t      &(int){SMB2_OP_SET_EOF}, 1,\n\t\t\t\t      cfile, NULL, NULL, NULL);\n\t}\n\treturn rc;\n}\n",
      "cve_list": [
        "CVE-2024-46796"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ipv6/ip6_output.c",
      "func_name": "ip6_send_skb",
      "func_body": "int ip6_send_skb(struct sk_buff *skb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct rt6_info *rt = dst_rt6_info(skb_dst(skb));\n\tint err;\n\n\trcu_read_lock();\n\terr = ip6_local_out(net, skb->sk, skb);\n\tif (err) {\n\t\tif (err > 0)\n\t\t\terr = net_xmit_errno(err);\n\t\tif (err)\n\t\t\tIP6_INC_STATS(net, rt->rt6i_idev,\n\t\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t}\n\n\trcu_read_unlock();\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-44987"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/core/net_namespace.c",
      "func_name": "get_net_ns",
      "func_body": "struct ns_common *get_net_ns(struct ns_common *ns)\n{\n\tstruct net *net;\n\n\tnet = maybe_get_net(container_of(ns, struct net, ns));\n\tif (net)\n\t\treturn &net->ns;\n\treturn ERR_PTR(-EINVAL);\n}\n",
      "cve_list": [
        "CVE-2024-40958"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/mac80211/agg-tx.c",
      "func_name": "ieee80211_start_tx_ba_session",
      "func_body": "int ieee80211_start_tx_ba_session(struct ieee80211_sta *pubsta, u16 tid,\n\t\t\t\t  u16 timeout)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct tid_ampdu_tx *tid_tx;\n\tint ret = 0;\n\n\ttrace_api_start_tx_ba_session(pubsta, tid);\n\n\tif (WARN(sta->reserved_tid == tid,\n\t\t \"Requested to start BA session on reserved tid=%d\", tid))\n\t\treturn -EINVAL;\n\n\tif (!pubsta->deflink.ht_cap.ht_supported &&\n\t    !pubsta->deflink.vht_cap.vht_supported &&\n\t    !pubsta->deflink.he_cap.has_he &&\n\t    !pubsta->deflink.eht_cap.has_eht)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON_ONCE(!local->ops->ampdu_action))\n\t\treturn -EINVAL;\n\n\tif ((tid >= IEEE80211_NUM_TIDS) ||\n\t    !ieee80211_hw_check(&local->hw, AMPDU_AGGREGATION) ||\n\t    ieee80211_hw_check(&local->hw, TX_AMPDU_SETUP_IN_HW))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(tid >= IEEE80211_FIRST_TSPEC_TSID))\n\t\treturn -EINVAL;\n\n\tht_dbg(sdata, \"Open BA session requested for %pM tid %u\\n\",\n\t       pubsta->addr, tid);\n\n\tif (sdata->vif.type != NL80211_IFTYPE_STATION &&\n\t    sdata->vif.type != NL80211_IFTYPE_MESH_POINT &&\n\t    sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&\n\t    sdata->vif.type != NL80211_IFTYPE_AP &&\n\t    sdata->vif.type != NL80211_IFTYPE_ADHOC)\n\t\treturn -EINVAL;\n\n\tif (test_sta_flag(sta, WLAN_STA_BLOCK_BA)) {\n\t\tht_dbg(sdata,\n\t\t       \"BA sessions blocked - Denying BA session request %pM tid %d\\n\",\n\t\t       sta->sta.addr, tid);\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_sta_flag(sta, WLAN_STA_MFP) &&\n\t    !test_sta_flag(sta, WLAN_STA_AUTHORIZED)) {\n\t\tht_dbg(sdata,\n\t\t       \"MFP STA not authorized - deny BA session request %pM tid %d\\n\",\n\t\t       sta->sta.addr, tid);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * 802.11n-2009 11.5.1.1: If the initiating STA is an HT STA, is a\n\t * member of an IBSS, and has no other existing Block Ack agreement\n\t * with the recipient STA, then the initiating STA shall transmit a\n\t * Probe Request frame to the recipient STA and shall not transmit an\n\t * ADDBA Request frame unless it receives a Probe Response frame\n\t * from the recipient within dot11ADDBAFailureTimeout.\n\t *\n\t * The probe request mechanism for ADDBA is currently not implemented,\n\t * but we only build up Block Ack session with HT STAs. This information\n\t * is set when we receive a bss info from a probe response or a beacon.\n\t */\n\tif (sta->sdata->vif.type == NL80211_IFTYPE_ADHOC &&\n\t    !sta->sta.deflink.ht_cap.ht_supported) {\n\t\tht_dbg(sdata,\n\t\t       \"BA request denied - IBSS STA %pM does not advertise HT support\\n\",\n\t\t       pubsta->addr);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_bh(&sta->lock);\n\n\t/* we have tried too many times, receiver does not want A-MPDU */\n\tif (sta->ampdu_mlme.addba_req_num[tid] > HT_AGG_MAX_RETRIES) {\n\t\tret = -EBUSY;\n\t\tgoto err_unlock_sta;\n\t}\n\n\t/*\n\t * if we have tried more than HT_AGG_BURST_RETRIES times we\n\t * will spread our requests in time to avoid stalling connection\n\t * for too long\n\t */\n\tif (sta->ampdu_mlme.addba_req_num[tid] > HT_AGG_BURST_RETRIES &&\n\t    time_before(jiffies, sta->ampdu_mlme.last_addba_req_time[tid] +\n\t\t\tHT_AGG_RETRIES_PERIOD)) {\n\t\tht_dbg(sdata,\n\t\t       \"BA request denied - %d failed requests on %pM tid %u\\n\",\n\t\t       sta->ampdu_mlme.addba_req_num[tid], sta->sta.addr, tid);\n\t\tret = -EBUSY;\n\t\tgoto err_unlock_sta;\n\t}\n\n\ttid_tx = rcu_dereference_protected_tid_tx(sta, tid);\n\t/* check if the TID is not in aggregation flow already */\n\tif (tid_tx || sta->ampdu_mlme.tid_start_tx[tid]) {\n\t\tht_dbg(sdata,\n\t\t       \"BA request denied - session is not idle on %pM tid %u\\n\",\n\t\t       sta->sta.addr, tid);\n\t\tret = -EAGAIN;\n\t\tgoto err_unlock_sta;\n\t}\n\n\t/* prepare A-MPDU MLME for Tx aggregation */\n\ttid_tx = kzalloc(sizeof(struct tid_ampdu_tx), GFP_ATOMIC);\n\tif (!tid_tx) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unlock_sta;\n\t}\n\n\tskb_queue_head_init(&tid_tx->pending);\n\t__set_bit(HT_AGG_STATE_WANT_START, &tid_tx->state);\n\n\ttid_tx->timeout = timeout;\n\ttid_tx->sta = sta;\n\ttid_tx->tid = tid;\n\n\t/* response timer */\n\ttimer_setup(&tid_tx->addba_resp_timer, sta_addba_resp_timer_expired, 0);\n\n\t/* tx timer */\n\ttimer_setup(&tid_tx->session_timer,\n\t\t    sta_tx_agg_session_timer_expired, TIMER_DEFERRABLE);\n\n\t/* assign a dialog token */\n\tsta->ampdu_mlme.dialog_token_allocator++;\n\ttid_tx->dialog_token = sta->ampdu_mlme.dialog_token_allocator;\n\n\t/*\n\t * Finally, assign it to the start array; the work item will\n\t * collect it and move it to the normal array.\n\t */\n\tsta->ampdu_mlme.tid_start_tx[tid] = tid_tx;\n\n\twiphy_work_queue(local->hw.wiphy, &sta->ampdu_mlme.work);\n\n\t/* this flow continues off the work */\n err_unlock_sta:\n\tspin_unlock_bh(&sta->lock);\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-43911"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp_ta.c",
      "func_name": "ta_if_invoke_debugfs_write",
      "func_body": "static ssize_t ta_if_invoke_debugfs_write(struct file *fp, const char *buf, size_t len, loff_t *off)\n{\n\tuint32_t ta_type        = 0;\n\tuint32_t ta_id          = 0;\n\tuint32_t cmd_id         = 0;\n\tuint32_t shared_buf_len = 0;\n\tuint8_t *shared_buf     = NULL;\n\tuint32_t copy_pos       = 0;\n\tint      ret            = 0;\n\n\tstruct amdgpu_device *adev    = (struct amdgpu_device *)file_inode(fp)->i_private;\n\tstruct psp_context   *psp     = &adev->psp;\n\tstruct ta_context    *context = NULL;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tret = copy_from_user((void *)&ta_type, &buf[copy_pos], sizeof(uint32_t));\n\tif (ret)\n\t\treturn -EFAULT;\n\tcopy_pos += sizeof(uint32_t);\n\n\tret = copy_from_user((void *)&ta_id, &buf[copy_pos], sizeof(uint32_t));\n\tif (ret)\n\t\treturn -EFAULT;\n\tcopy_pos += sizeof(uint32_t);\n\n\tret = copy_from_user((void *)&cmd_id, &buf[copy_pos], sizeof(uint32_t));\n\tif (ret)\n\t\treturn -EFAULT;\n\tcopy_pos += sizeof(uint32_t);\n\n\tret = copy_from_user((void *)&shared_buf_len, &buf[copy_pos], sizeof(uint32_t));\n\tif (ret)\n\t\treturn -EFAULT;\n\tcopy_pos += sizeof(uint32_t);\n\n\tshared_buf = kzalloc(shared_buf_len, GFP_KERNEL);\n\tif (!shared_buf)\n\t\treturn -ENOMEM;\n\tif (copy_from_user((void *)shared_buf, &buf[copy_pos], shared_buf_len)) {\n\t\tret = -EFAULT;\n\t\tgoto err_free_shared_buf;\n\t}\n\n\tset_ta_context_funcs(psp, ta_type, &context);\n\n\tif (!context || !context->initialized) {\n\t\tdev_err(adev->dev, \"TA is not initialized\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_free_shared_buf;\n\t}\n\n\tif (!psp->ta_funcs || !psp->ta_funcs->fn_ta_invoke) {\n\t\tdev_err(adev->dev, \"Unsupported function to invoke TA\\n\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto err_free_shared_buf;\n\t}\n\n\tcontext->session_id = ta_id;\n\n\tret = prep_ta_mem_context(&context->mem_context, shared_buf, shared_buf_len);\n\tif (ret)\n\t\tgoto err_free_shared_buf;\n\n\tret = psp_fn_ta_invoke(psp, cmd_id);\n\tif (ret || context->resp_status) {\n\t\tdev_err(adev->dev, \"Failed to invoke TA via debugfs (%d) and status (0x%X)\\n\",\n\t\t\tret, context->resp_status);\n\t\tif (!ret) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_shared_buf;\n\t\t}\n\t}\n\n\tif (copy_to_user((char *)&buf[copy_pos], context->mem_context.shared_buf, shared_buf_len))\n\t\tret = -EFAULT;\n\nerr_free_shared_buf:\n\tkfree(shared_buf);\n\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-43906"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "mm/memcontrol-v1.c",
      "func_name": "memcg_write_event_control",
      "func_body": "static ssize_t memcg_write_event_control(struct kernfs_open_file *of,\n\t\t\t\t\t char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup_subsys_state *css = of_css(of);\n\tstruct mem_cgroup *memcg = mem_cgroup_from_css(css);\n\tstruct mem_cgroup_event *event;\n\tstruct cgroup_subsys_state *cfile_css;\n\tunsigned int efd, cfd;\n\tstruct fd efile;\n\tstruct fd cfile;\n\tstruct dentry *cdentry;\n\tconst char *name;\n\tchar *endp;\n\tint ret;\n\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\treturn -EOPNOTSUPP;\n\n\tbuf = strstrip(buf);\n\n\tefd = simple_strtoul(buf, &endp, 10);\n\tif (*endp != ' ')\n\t\treturn -EINVAL;\n\tbuf = endp + 1;\n\n\tcfd = simple_strtoul(buf, &endp, 10);\n\tif (*endp == '\\0')\n\t\tbuf = endp;\n\telse if (*endp == ' ')\n\t\tbuf = endp + 1;\n\telse\n\t\treturn -EINVAL;\n\n\tevent = kzalloc(sizeof(*event), GFP_KERNEL);\n\tif (!event)\n\t\treturn -ENOMEM;\n\n\tevent->memcg = memcg;\n\tINIT_LIST_HEAD(&event->list);\n\tinit_poll_funcptr(&event->pt, memcg_event_ptable_queue_proc);\n\tinit_waitqueue_func_entry(&event->wait, memcg_event_wake);\n\tINIT_WORK(&event->remove, memcg_event_remove);\n\n\tefile = fdget(efd);\n\tif (!efile.file) {\n\t\tret = -EBADF;\n\t\tgoto out_kfree;\n\t}\n\n\tevent->eventfd = eventfd_ctx_fileget(efile.file);\n\tif (IS_ERR(event->eventfd)) {\n\t\tret = PTR_ERR(event->eventfd);\n\t\tgoto out_put_efile;\n\t}\n\n\tcfile = fdget(cfd);\n\tif (!cfile.file) {\n\t\tret = -EBADF;\n\t\tgoto out_put_eventfd;\n\t}\n\n\t/* the process need read permission on control file */\n\t/* AV: shouldn't we check that it's been opened for read instead? */\n\tret = file_permission(cfile.file, MAY_READ);\n\tif (ret < 0)\n\t\tgoto out_put_cfile;\n\n\t/*\n\t * The control file must be a regular cgroup1 file. As a regular cgroup\n\t * file can't be renamed, it's safe to access its name afterwards.\n\t */\n\tcdentry = cfile.file->f_path.dentry;\n\tif (cdentry->d_sb->s_type != &cgroup_fs_type || !d_is_reg(cdentry)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_cfile;\n\t}\n\n\t/*\n\t * Determine the event callbacks and set them in @event.  This used\n\t * to be done via struct cftype but cgroup core no longer knows\n\t * about these events.  The following is crude but the whole thing\n\t * is for compatibility anyway.\n\t *\n\t * DO NOT ADD NEW FILES.\n\t */\n\tname = cdentry->d_name.name;\n\n\tif (!strcmp(name, \"memory.usage_in_bytes\")) {\n\t\tevent->register_event = mem_cgroup_usage_register_event;\n\t\tevent->unregister_event = mem_cgroup_usage_unregister_event;\n\t} else if (!strcmp(name, \"memory.oom_control\")) {\n\t\tevent->register_event = mem_cgroup_oom_register_event;\n\t\tevent->unregister_event = mem_cgroup_oom_unregister_event;\n\t} else if (!strcmp(name, \"memory.pressure_level\")) {\n\t\tevent->register_event = vmpressure_register_event;\n\t\tevent->unregister_event = vmpressure_unregister_event;\n\t} else if (!strcmp(name, \"memory.memsw.usage_in_bytes\")) {\n\t\tevent->register_event = memsw_cgroup_usage_register_event;\n\t\tevent->unregister_event = memsw_cgroup_usage_unregister_event;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto out_put_cfile;\n\t}\n\n\t/*\n\t * Verify @cfile should belong to @css.  Also, remaining events are\n\t * automatically removed on cgroup destruction but the removal is\n\t * asynchronous, so take an extra ref on @css.\n\t */\n\tcfile_css = css_tryget_online_from_dir(cdentry->d_parent,\n\t\t\t\t\t       &memory_cgrp_subsys);\n\tret = -EINVAL;\n\tif (IS_ERR(cfile_css))\n\t\tgoto out_put_cfile;\n\tif (cfile_css != css) {\n\t\tcss_put(cfile_css);\n\t\tgoto out_put_cfile;\n\t}\n\n\tret = event->register_event(memcg, event->eventfd, buf);\n\tif (ret)\n\t\tgoto out_put_css;\n\n\tvfs_poll(efile.file, &event->pt);\n\n\tspin_lock_irq(&memcg->event_list_lock);\n\tlist_add(&event->list, &memcg->event_list);\n\tspin_unlock_irq(&memcg->event_list_lock);\n\n\tfdput(cfile);\n\tfdput(efile);\n\n\treturn nbytes;\n\nout_put_css:\n\tcss_put(css);\nout_put_cfile:\n\tfdput(cfile);\nout_put_eventfd:\n\teventfd_ctx_put(event->eventfd);\nout_put_efile:\n\tfdput(efile);\nout_kfree:\n\tkfree(event);\n\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-45021"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/pm/swsmu/smu11/arcturus_ppt.c",
      "func_name": "arcturus_get_power_limit",
      "func_body": "static int arcturus_get_power_limit(struct smu_context *smu,\n\t\t\t\t\tuint32_t *current_power_limit,\n\t\t\t\t\tuint32_t *default_power_limit,\n\t\t\t\t\tuint32_t *max_power_limit,\n\t\t\t\t\tuint32_t *min_power_limit)\n{\n\tstruct smu_11_0_powerplay_table *powerplay_table =\n\t\t(struct smu_11_0_powerplay_table *)smu->smu_table.power_play_table;\n\tPPTable_t *pptable = smu->smu_table.driver_pptable;\n\tuint32_t power_limit, od_percent_upper = 0, od_percent_lower = 0;\n\n\tif (smu_v11_0_get_current_power_limit(smu, &power_limit)) {\n\t\t/* the last hope to figure out the ppt limit */\n\t\tif (!pptable) {\n\t\t\tdev_err(smu->adev->dev, \"Cannot get PPT limit due to pptable missing!\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpower_limit =\n\t\t\tpptable->SocketPowerLimitAc[PPT_THROTTLER_PPT0];\n\t}\n\n\tif (current_power_limit)\n\t\t*current_power_limit = power_limit;\n\tif (default_power_limit)\n\t\t*default_power_limit = power_limit;\n\n\tif (powerplay_table) {\n\t\tif (smu->od_enabled)\n\t\t\tod_percent_upper = le32_to_cpu(powerplay_table->overdrive_table.max[SMU_11_0_ODSETTING_POWERPERCENTAGE]);\n\t\telse\n\t\t\tod_percent_upper = 0;\n\n\t\tod_percent_lower = le32_to_cpu(powerplay_table->overdrive_table.min[SMU_11_0_ODSETTING_POWERPERCENTAGE]);\n\t}\n\n\tdev_dbg(smu->adev->dev, \"od percent upper:%d, od percent lower:%d (default power: %d)\\n\",\n\t\t\t\t\t\t\tod_percent_upper, od_percent_lower, power_limit);\n\n\tif (max_power_limit) {\n\t\t*max_power_limit = power_limit * (100 + od_percent_upper);\n\t\t*max_power_limit /= 100;\n\t}\n\n\tif (min_power_limit) {\n\t\t*min_power_limit = power_limit * (100 - od_percent_lower);\n\t\t*min_power_limit /= 100;\n\t}\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-26949"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c",
      "func_name": "navi10_get_power_limit",
      "func_body": "static int navi10_get_power_limit(struct smu_context *smu,\n\t\t\t\t\tuint32_t *current_power_limit,\n\t\t\t\t\tuint32_t *default_power_limit,\n\t\t\t\t\tuint32_t *max_power_limit,\n\t\t\t\t\tuint32_t *min_power_limit)\n{\n\tstruct smu_11_0_powerplay_table *powerplay_table =\n\t\t(struct smu_11_0_powerplay_table *)smu->smu_table.power_play_table;\n\tstruct smu_11_0_overdrive_table *od_settings = smu->od_settings;\n\tPPTable_t *pptable = smu->smu_table.driver_pptable;\n\tuint32_t power_limit, od_percent_upper = 0, od_percent_lower = 0;\n\n\tif (smu_v11_0_get_current_power_limit(smu, &power_limit)) {\n\t\t/* the last hope to figure out the ppt limit */\n\t\tif (!pptable) {\n\t\t\tdev_err(smu->adev->dev, \"Cannot get PPT limit due to pptable missing!\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpower_limit =\n\t\t\tpptable->SocketPowerLimitAc[PPT_THROTTLER_PPT0];\n\t}\n\n\tif (current_power_limit)\n\t\t*current_power_limit = power_limit;\n\tif (default_power_limit)\n\t\t*default_power_limit = power_limit;\n\n\tif (powerplay_table) {\n\t\tif (smu->od_enabled &&\n\t\t\t    navi10_od_feature_is_supported(od_settings, SMU_11_0_ODCAP_POWER_LIMIT))\n\t\t\tod_percent_upper = le32_to_cpu(powerplay_table->overdrive_table.max[SMU_11_0_ODSETTING_POWERPERCENTAGE]);\n\t\telse\n\t\t\tod_percent_upper = 0;\n\n\t\tod_percent_lower = le32_to_cpu(powerplay_table->overdrive_table.min[SMU_11_0_ODSETTING_POWERPERCENTAGE]);\n\t}\n\n\tdev_dbg(smu->adev->dev, \"od percent upper:%d, od percent lower:%d (default power: %d)\\n\",\n\t\t\t\t\tod_percent_upper, od_percent_lower, power_limit);\n\n\tif (max_power_limit) {\n\t\t*max_power_limit = power_limit * (100 + od_percent_upper);\n\t\t*max_power_limit /= 100;\n\t}\n\n\tif (min_power_limit) {\n\t\t*min_power_limit = power_limit * (100 - od_percent_lower);\n\t\t*min_power_limit /= 100;\n\t}\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-26949"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c",
      "func_name": "sienna_cichlid_get_power_limit",
      "func_body": "static int sienna_cichlid_get_power_limit(struct smu_context *smu,\n\t\t\t\t\t  uint32_t *current_power_limit,\n\t\t\t\t\t  uint32_t *default_power_limit,\n\t\t\t\t\t  uint32_t *max_power_limit,\n\t\t\t\t\t  uint32_t *min_power_limit)\n{\n\tstruct smu_11_0_7_powerplay_table *powerplay_table =\n\t\t(struct smu_11_0_7_powerplay_table *)smu->smu_table.power_play_table;\n\tuint32_t power_limit, od_percent_upper = 0, od_percent_lower = 0;\n\tuint16_t *table_member;\n\n\tGET_PPTABLE_MEMBER(SocketPowerLimitAc, &table_member);\n\n\tif (smu_v11_0_get_current_power_limit(smu, &power_limit)) {\n\t\tpower_limit =\n\t\t\ttable_member[PPT_THROTTLER_PPT0];\n\t}\n\n\tif (current_power_limit)\n\t\t*current_power_limit = power_limit;\n\tif (default_power_limit)\n\t\t*default_power_limit = power_limit;\n\n\tif (powerplay_table) {\n\t\tif (smu->od_enabled)\n\t\t\tod_percent_upper = le32_to_cpu(powerplay_table->overdrive_table.max[SMU_11_0_7_ODSETTING_POWERPERCENTAGE]);\n\t\telse\n\t\t\tod_percent_upper = 0;\n\n\t\tod_percent_lower = le32_to_cpu(powerplay_table->overdrive_table.min[SMU_11_0_7_ODSETTING_POWERPERCENTAGE]);\n\t}\n\n\tdev_dbg(smu->adev->dev, \"od percent upper:%d, od percent lower:%d (default power: %d)\\n\",\n\t\t\t\t\tod_percent_upper, od_percent_lower, power_limit);\n\n\tif (max_power_limit) {\n\t\t*max_power_limit = power_limit * (100 + od_percent_upper);\n\t\t*max_power_limit /= 100;\n\t}\n\n\tif (min_power_limit) {\n\t\t*min_power_limit = power_limit * (100 - od_percent_lower);\n\t\t*min_power_limit /= 100;\n\t}\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-26949"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c",
      "func_name": "smu_v13_0_0_get_power_limit",
      "func_body": "static int smu_v13_0_0_get_power_limit(struct smu_context *smu,\n\t\t\t\t\t\tuint32_t *current_power_limit,\n\t\t\t\t\t\tuint32_t *default_power_limit,\n\t\t\t\t\t\tuint32_t *max_power_limit,\n\t\t\t\t\t\tuint32_t *min_power_limit)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tstruct smu_13_0_0_powerplay_table *powerplay_table =\n\t\t(struct smu_13_0_0_powerplay_table *)table_context->power_play_table;\n\tPPTable_t *pptable = table_context->driver_pptable;\n\tSkuTable_t *skutable = &pptable->SkuTable;\n\tuint32_t power_limit, od_percent_upper = 0, od_percent_lower = 0;\n\tuint32_t msg_limit = skutable->MsgLimits.Power[PPT_THROTTLER_PPT0][POWER_SOURCE_AC];\n\n\tif (smu_v13_0_get_current_power_limit(smu, &power_limit))\n\t\tpower_limit = smu->adev->pm.ac_power ?\n\t\t\t      skutable->SocketPowerLimitAc[PPT_THROTTLER_PPT0] :\n\t\t\t      skutable->SocketPowerLimitDc[PPT_THROTTLER_PPT0];\n\n\tif (current_power_limit)\n\t\t*current_power_limit = power_limit;\n\tif (default_power_limit)\n\t\t*default_power_limit = power_limit;\n\n\tif (powerplay_table) {\n\t\tif (smu->od_enabled)\n\t\t\tod_percent_upper = le32_to_cpu(powerplay_table->overdrive_table.max[SMU_13_0_0_ODSETTING_POWERPERCENTAGE]);\n\t\telse\n\t\t\tod_percent_upper = 0;\n\n\t\tod_percent_lower = le32_to_cpu(powerplay_table->overdrive_table.min[SMU_13_0_0_ODSETTING_POWERPERCENTAGE]);\n\t}\n\n\tdev_dbg(smu->adev->dev, \"od percent upper:%d, od percent lower:%d (default power: %d)\\n\",\n\t\t\t\t\tod_percent_upper, od_percent_lower, power_limit);\n\n\tif (max_power_limit) {\n\t\t*max_power_limit = msg_limit * (100 + od_percent_upper);\n\t\t*max_power_limit /= 100;\n\t}\n\n\tif (min_power_limit) {\n\t\t*min_power_limit = power_limit * (100 - od_percent_lower);\n\t\t*min_power_limit /= 100;\n\t}\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-26949"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c",
      "func_name": "smu_v13_0_7_get_power_limit",
      "func_body": "static int smu_v13_0_7_get_power_limit(struct smu_context *smu,\n\t\t\t\t\t\tuint32_t *current_power_limit,\n\t\t\t\t\t\tuint32_t *default_power_limit,\n\t\t\t\t\t\tuint32_t *max_power_limit,\n\t\t\t\t\t\tuint32_t *min_power_limit)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tstruct smu_13_0_7_powerplay_table *powerplay_table =\n\t\t(struct smu_13_0_7_powerplay_table *)table_context->power_play_table;\n\tPPTable_t *pptable = table_context->driver_pptable;\n\tSkuTable_t *skutable = &pptable->SkuTable;\n\tuint32_t power_limit, od_percent_upper = 0, od_percent_lower = 0;\n\tuint32_t msg_limit = skutable->MsgLimits.Power[PPT_THROTTLER_PPT0][POWER_SOURCE_AC];\n\n\tif (smu_v13_0_get_current_power_limit(smu, &power_limit))\n\t\tpower_limit = smu->adev->pm.ac_power ?\n\t\t\t      skutable->SocketPowerLimitAc[PPT_THROTTLER_PPT0] :\n\t\t\t      skutable->SocketPowerLimitDc[PPT_THROTTLER_PPT0];\n\n\tif (current_power_limit)\n\t\t*current_power_limit = power_limit;\n\tif (default_power_limit)\n\t\t*default_power_limit = power_limit;\n\n\tif (powerplay_table) {\n\t\tif (smu->od_enabled)\n\t\t\tod_percent_upper = le32_to_cpu(powerplay_table->overdrive_table.max[SMU_13_0_7_ODSETTING_POWERPERCENTAGE]);\n\t\telse\n\t\t\tod_percent_upper = 0;\n\n\t\tod_percent_lower = le32_to_cpu(powerplay_table->overdrive_table.min[SMU_13_0_7_ODSETTING_POWERPERCENTAGE]);\n\t}\n\n\tdev_dbg(smu->adev->dev, \"od percent upper:%d, od percent lower:%d (default power: %d)\\n\",\n\t\t\t\t\tod_percent_upper, od_percent_lower, power_limit);\n\n\tif (max_power_limit) {\n\t\t*max_power_limit = msg_limit * (100 + od_percent_upper);\n\t\t*max_power_limit /= 100;\n\t}\n\n\tif (min_power_limit) {\n\t\t*min_power_limit = power_limit * (100 - od_percent_lower);\n\t\t*min_power_limit /= 100;\n\t}\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-26949"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/ti/am65-cpsw-nuss.c",
      "func_name": "am65_cpsw_ndo_xdp_xmit",
      "func_body": "static int am65_cpsw_ndo_xdp_xmit(struct net_device *ndev, int n,\n\t\t\t\t  struct xdp_frame **frames, u32 flags)\n{\n\tstruct am65_cpsw_common *common = am65_ndev_to_common(ndev);\n\tstruct am65_cpsw_tx_chn *tx_chn;\n\tstruct netdev_queue *netif_txq;\n\tint cpu = smp_processor_id();\n\tint i, nxmit = 0;\n\n\ttx_chn = &common->tx_chns[cpu % common->tx_ch_num];\n\tnetif_txq = netdev_get_tx_queue(ndev, tx_chn->id);\n\n\t__netif_tx_lock(netif_txq, cpu);\n\tfor (i = 0; i < n; i++) {\n\t\tif (am65_cpsw_xdp_tx_frame(ndev, tx_chn, frames[i],\n\t\t\t\t\t   AM65_CPSW_TX_BUF_TYPE_XDP_NDO))\n\t\t\tbreak;\n\t\tnxmit++;\n\t}\n\t__netif_tx_unlock(netif_txq);\n\n\treturn nxmit;\n}\n",
      "cve_list": [
        "CVE-2024-46799"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "sound/soc/intel/boards/bxt_rt298.c",
      "func_name": "broxton_audio_probe",
      "func_body": "static int broxton_audio_probe(struct platform_device *pdev)\n{\n\tstruct bxt_rt286_private *ctx;\n\tstruct snd_soc_card *card =\n\t\t\t(struct snd_soc_card *)pdev->id_entry->driver_data;\n\tstruct snd_soc_acpi_mach *mach;\n\tconst char *platform_name;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(broxton_rt298_dais); i++) {\n\t\tif (card->dai_link[i].num_codecs &&\n\t\t    !strncmp(card->dai_link[i].codecs->name, \"i2c-INT343A:00\",\n\t\t\t     I2C_NAME_SIZE)) {\n\t\t\tif (!strncmp(card->name, \"broxton-rt298\",\n\t\t\t\t     PLATFORM_NAME_SIZE)) {\n\t\t\t\tcard->dai_link[i].name = \"SSP5-Codec\";\n\t\t\t\tcard->dai_link[i].cpus->dai_name = \"SSP5 Pin\";\n\t\t\t} else if (!strncmp(card->name, \"geminilake-rt298\",\n\t\t\t\t\t    PLATFORM_NAME_SIZE)) {\n\t\t\t\tcard->dai_link[i].name = \"SSP2-Codec\";\n\t\t\t\tcard->dai_link[i].cpus->dai_name = \"SSP2 Pin\";\n\t\t\t}\n\t\t}\n\t}\n\n\tctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&ctx->hdmi_pcm_list);\n\n\tcard->dev = &pdev->dev;\n\tsnd_soc_card_set_drvdata(card, ctx);\n\n\t/* override platform name, if required */\n\tmach = pdev->dev.platform_data;\n\tplatform_name = mach->mach_params.platform;\n\n\tret = snd_soc_fixup_dai_links_platform_name(card,\n\t\t\t\t\t\t    platform_name);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->common_hdmi_codec_drv = mach->mach_params.common_hdmi_codec_drv;\n\n\treturn devm_snd_soc_register_card(&pdev->dev, card);\n}\n",
      "cve_list": [
        "CVE-2024-46793"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "sound/soc/intel/boards/bytcht_cx2072x.c",
      "func_name": "snd_byt_cht_cx2072x_probe",
      "func_body": "static int snd_byt_cht_cx2072x_probe(struct platform_device *pdev)\n{\n\tstruct snd_soc_acpi_mach *mach;\n\tstruct acpi_device *adev;\n\tint dai_index = 0;\n\tbool sof_parent;\n\tint i, ret;\n\n\tbyt_cht_cx2072x_card.dev = &pdev->dev;\n\tmach = dev_get_platdata(&pdev->dev);\n\n\t/* fix index of codec dai */\n\tfor (i = 0; i < ARRAY_SIZE(byt_cht_cx2072x_dais); i++) {\n\t\tif (byt_cht_cx2072x_dais[i].num_codecs &&\n\t\t    !strcmp(byt_cht_cx2072x_dais[i].codecs->name,\n\t\t\t    \"i2c-14F10720:00\")) {\n\t\t\tdai_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* fixup codec name based on HID */\n\tadev = acpi_dev_get_first_match_dev(mach->id, NULL, -1);\n\tif (adev) {\n\t\tsnprintf(codec_name, sizeof(codec_name), \"i2c-%s\",\n\t\t\t acpi_dev_name(adev));\n\t\tbyt_cht_cx2072x_dais[dai_index].codecs->name = codec_name;\n\t}\n\tacpi_dev_put(adev);\n\n\t/* override platform name, if required */\n\tret = snd_soc_fixup_dai_links_platform_name(&byt_cht_cx2072x_card,\n\t\t\t\t\t\t    mach->mach_params.platform);\n\tif (ret)\n\t\treturn ret;\n\n\tsof_parent = snd_soc_acpi_sof_parent(&pdev->dev);\n\n\t/* set card and driver name */\n\tif (sof_parent) {\n\t\tbyt_cht_cx2072x_card.name = SOF_CARD_NAME;\n\t\tbyt_cht_cx2072x_card.driver_name = SOF_DRIVER_NAME;\n\t} else {\n\t\tbyt_cht_cx2072x_card.name = CARD_NAME;\n\t\tbyt_cht_cx2072x_card.driver_name = DRIVER_NAME;\n\t}\n\n\t/* set pm ops */\n\tif (sof_parent)\n\t\tpdev->dev.driver->pm = &snd_soc_pm_ops;\n\n\treturn devm_snd_soc_register_card(&pdev->dev, &byt_cht_cx2072x_card);\n}\n",
      "cve_list": [
        "CVE-2024-46793"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "sound/soc/intel/boards/bytcht_da7213.c",
      "func_name": "bytcht_da7213_probe",
      "func_body": "static int bytcht_da7213_probe(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card;\n\tstruct snd_soc_acpi_mach *mach;\n\tconst char *platform_name;\n\tstruct acpi_device *adev;\n\tbool sof_parent;\n\tint dai_index = 0;\n\tint ret_val = 0;\n\tint i;\n\n\tmach = pdev->dev.platform_data;\n\tcard = &bytcht_da7213_card;\n\tcard->dev = &pdev->dev;\n\n\t/* fix index of codec dai */\n\tfor (i = 0; i < ARRAY_SIZE(dailink); i++) {\n\t\tif (dailink[i].num_codecs &&\n\t\t    !strcmp(dailink[i].codecs->name, \"i2c-DLGS7213:00\")) {\n\t\t\tdai_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* fixup codec name based on HID */\n\tadev = acpi_dev_get_first_match_dev(mach->id, NULL, -1);\n\tif (adev) {\n\t\tsnprintf(codec_name, sizeof(codec_name),\n\t\t\t \"i2c-%s\", acpi_dev_name(adev));\n\t\tdailink[dai_index].codecs->name = codec_name;\n\t}\n\tacpi_dev_put(adev);\n\n\t/* override platform name, if required */\n\tplatform_name = mach->mach_params.platform;\n\n\tret_val = snd_soc_fixup_dai_links_platform_name(card, platform_name);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tsof_parent = snd_soc_acpi_sof_parent(&pdev->dev);\n\n\t/* set card and driver name */\n\tif (sof_parent) {\n\t\tbytcht_da7213_card.name = SOF_CARD_NAME;\n\t\tbytcht_da7213_card.driver_name = SOF_DRIVER_NAME;\n\t} else {\n\t\tbytcht_da7213_card.name = CARD_NAME;\n\t\tbytcht_da7213_card.driver_name = DRIVER_NAME;\n\t}\n\n\t/* set pm ops */\n\tif (sof_parent)\n\t\tpdev->dev.driver->pm = &snd_soc_pm_ops;\n\n\tret_val = devm_snd_soc_register_card(&pdev->dev, card);\n\tif (ret_val) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"snd_soc_register_card failed %d\\n\", ret_val);\n\t\treturn ret_val;\n\t}\n\tplatform_set_drvdata(pdev, card);\n\treturn ret_val;\n}\n",
      "cve_list": [
        "CVE-2024-46793"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "sound/soc/intel/boards/bytcht_es8316.c",
      "func_name": "snd_byt_cht_es8316_mc_probe",
      "func_body": "static int snd_byt_cht_es8316_mc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstatic const char * const mic_name[] = { \"in1\", \"in2\" };\n\tstruct snd_soc_acpi_mach *mach = dev_get_platdata(dev);\n\tstruct property_entry props[MAX_NO_PROPS] = {};\n\tstruct byt_cht_es8316_private *priv;\n\tconst struct dmi_system_id *dmi_id;\n\tstruct fwnode_handle *fwnode;\n\tbool sof_parent, is_bytcr;\n\tconst char *platform_name;\n\tstruct acpi_device *adev;\n\tstruct device *codec_dev;\n\tunsigned int cnt = 0;\n\tint dai_index = 0;\n\tint i;\n\tint ret = 0;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t/* fix index of codec dai */\n\tfor (i = 0; i < ARRAY_SIZE(byt_cht_es8316_dais); i++) {\n\t\tif (byt_cht_es8316_dais[i].num_codecs &&\n\t\t    !strcmp(byt_cht_es8316_dais[i].codecs->name,\n\t\t\t    \"i2c-ESSX8316:00\")) {\n\t\t\tdai_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* fixup codec name based on HID */\n\tadev = acpi_dev_get_first_match_dev(mach->id, NULL, -1);\n\tif (adev) {\n\t\tsnprintf(codec_name, sizeof(codec_name),\n\t\t\t \"i2c-%s\", acpi_dev_name(adev));\n\t\tbyt_cht_es8316_dais[dai_index].codecs->name = codec_name;\n\t} else {\n\t\tdev_err(dev, \"Error cannot find '%s' dev\\n\", mach->id);\n\t\treturn -ENXIO;\n\t}\n\n\tcodec_dev = acpi_get_first_physical_node(adev);\n\tacpi_dev_put(adev);\n\tif (!codec_dev)\n\t\treturn -EPROBE_DEFER;\n\tpriv->codec_dev = get_device(codec_dev);\n\n\t/* override platform name, if required */\n\tbyt_cht_es8316_card.dev = dev;\n\tplatform_name = mach->mach_params.platform;\n\n\tret = snd_soc_fixup_dai_links_platform_name(&byt_cht_es8316_card,\n\t\t\t\t\t\t    platform_name);\n\tif (ret) {\n\t\tput_device(codec_dev);\n\t\treturn ret;\n\t}\n\n\tes83xx_dsm_dump(priv->codec_dev);\n\n\t/* Check for BYTCR or other platform and setup quirks */\n\tis_bytcr = soc_intel_is_byt() && mach->mach_params.acpi_ipc_irq_index == 0;\n\tdmi_id = dmi_first_match(byt_cht_es8316_quirk_table);\n\tif (dmi_id) {\n\t\tquirk = (unsigned long)dmi_id->driver_data;\n\t} else if (!byt_cht_es8316_get_quirks_from_dsm(priv, is_bytcr)) {\n\t\tdev_info(dev, \"Using ACPI DSM info for quirks\\n\");\n\t} else if (is_bytcr) {\n\t\t/* On BYTCR default to SSP0, internal-mic-in2-map, mono-spk */\n\t\tquirk = BYT_CHT_ES8316_SSP0 | BYT_CHT_ES8316_INTMIC_IN2_MAP |\n\t\t\tBYT_CHT_ES8316_MONO_SPEAKER;\n\t} else {\n\t\t/* Others default to internal-mic-in1-map, mono-speaker */\n\t\tquirk = BYT_CHT_ES8316_INTMIC_IN1_MAP |\n\t\t\tBYT_CHT_ES8316_MONO_SPEAKER;\n\t}\n\tif (quirk_override != -1) {\n\t\tdev_info(dev, \"Overriding quirk 0x%lx => 0x%x\\n\",\n\t\t\t quirk, quirk_override);\n\t\tquirk = quirk_override;\n\t}\n\tlog_quirks(dev);\n\n\tif (quirk & BYT_CHT_ES8316_SSP0)\n\t\tbyt_cht_es8316_dais[dai_index].cpus->dai_name = \"ssp0-port\";\n\n\t/* get the clock */\n\tpriv->mclk = devm_clk_get(dev, \"pmc_plt_clk_3\");\n\tif (IS_ERR(priv->mclk)) {\n\t\tput_device(codec_dev);\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->mclk), \"clk_get pmc_plt_clk_3 failed\\n\");\n\t}\n\n\tif (quirk & BYT_CHT_ES8316_JD_INVERTED)\n\t\tprops[cnt++] = PROPERTY_ENTRY_BOOL(\"everest,jack-detect-inverted\");\n\n\tif (cnt) {\n\t\tfwnode = fwnode_create_software_node(props, NULL);\n\t\tif (IS_ERR(fwnode)) {\n\t\t\tput_device(codec_dev);\n\t\t\treturn PTR_ERR(fwnode);\n\t\t}\n\n\t\tret = device_add_software_node(codec_dev, to_software_node(fwnode));\n\n\t\tfwnode_handle_put(fwnode);\n\n\t\tif (ret) {\n\t\t\tput_device(codec_dev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* get speaker enable GPIO */\n\tdevm_acpi_dev_add_driver_gpios(codec_dev, byt_cht_es8316_gpios);\n\tpriv->speaker_en_gpio =\n\t\tgpiod_get_optional(codec_dev, \"speaker-enable\",\n\t\t\t\t   /* see comment in byt_cht_es8316_resume() */\n\t\t\t\t   GPIOD_OUT_LOW | GPIOD_FLAGS_BIT_NONEXCLUSIVE);\n\tif (IS_ERR(priv->speaker_en_gpio)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(priv->speaker_en_gpio),\n\t\t\t\t    \"get speaker GPIO failed\\n\");\n\t\tgoto err_put_codec;\n\t}\n\n\tsnprintf(components_string, sizeof(components_string),\n\t\t \"cfg-spk:%s cfg-mic:%s\",\n\t\t (quirk & BYT_CHT_ES8316_MONO_SPEAKER) ? \"1\" : \"2\",\n\t\t mic_name[BYT_CHT_ES8316_MAP(quirk)]);\n\tbyt_cht_es8316_card.components = components_string;\n// #if !IS_ENABLED(CONFIG_SND_SOC_INTEL_USER_FRIENDLY_LONG_NAMES)\n\tsnprintf(long_name, sizeof(long_name), \"bytcht-es8316-%s-spk-%s-mic\",\n\t\t (quirk & BYT_CHT_ES8316_MONO_SPEAKER) ? \"mono\" : \"stereo\",\n\t\t mic_name[BYT_CHT_ES8316_MAP(quirk)]);\n\tbyt_cht_es8316_card.long_name = long_name;\n#endif\n\n\tsof_parent = snd_soc_acpi_sof_parent(dev);\n\n\t/* set card and driver name */\n\tif (sof_parent) {\n\t\tbyt_cht_es8316_card.name = SOF_CARD_NAME;\n\t\tbyt_cht_es8316_card.driver_name = SOF_DRIVER_NAME;\n\t} else {\n\t\tbyt_cht_es8316_card.name = CARD_NAME;\n\t\tbyt_cht_es8316_card.driver_name = DRIVER_NAME;\n\t}\n\n\t/* set pm ops */\n\tif (sof_parent)\n\t\tdev->driver->pm = &snd_soc_pm_ops;\n\n\t/* register the soc card */\n\tsnd_soc_card_set_drvdata(&byt_cht_es8316_card, priv);\n\n\tret = devm_snd_soc_register_card(dev, &byt_cht_es8316_card);\n\tif (ret) {\n\t\tgpiod_put(priv->speaker_en_gpio);\n\t\tdev_err(dev, \"snd_soc_register_card failed: %d\\n\", ret);\n\t\tgoto err_put_codec;\n\t}\n\tplatform_set_drvdata(pdev, &byt_cht_es8316_card);\n\treturn 0;\n\nerr_put_codec:\n\tdevice_remove_software_node(priv->codec_dev);\n\tput_device(priv->codec_dev);\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-46793"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "sound/soc/intel/boards/bytcr_rt5640.c",
      "func_name": "snd_byt_rt5640_mc_probe",
      "func_body": "static int snd_byt_rt5640_mc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstatic const char * const map_name[] = { \"dmic1\", \"dmic2\", \"in1\", \"in3\", \"none\" };\n\tstruct snd_soc_acpi_mach *mach = dev_get_platdata(dev);\n\t__maybe_unused const char *spk_type;\n\tconst struct dmi_system_id *dmi_id;\n\tconst char *headset2_string = \"\";\n\tconst char *lineout_string = \"\";\n\tstruct byt_rt5640_private *priv;\n\tconst char *platform_name;\n\tstruct acpi_device *adev;\n\tstruct device *codec_dev;\n\tconst char *cfg_spk;\n\tbool sof_parent;\n\tint ret_val = 0;\n\tint dai_index = 0;\n\tint i, aif;\n\n\tis_bytcr = false;\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t/* register the soc card */\n\tbyt_rt5640_card.dev = dev;\n\tsnd_soc_card_set_drvdata(&byt_rt5640_card, priv);\n\n\t/* fix index of codec dai */\n\tfor (i = 0; i < ARRAY_SIZE(byt_rt5640_dais); i++) {\n\t\tif (byt_rt5640_dais[i].num_codecs &&\n\t\t    !strcmp(byt_rt5640_dais[i].codecs->name,\n\t\t\t    \"i2c-10EC5640:00\")) {\n\t\t\tdai_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* fixup codec name based on HID */\n\tadev = acpi_dev_get_first_match_dev(mach->id, NULL, -1);\n\tif (adev) {\n\t\tsnprintf(byt_rt5640_codec_name, sizeof(byt_rt5640_codec_name),\n\t\t\t \"i2c-%s\", acpi_dev_name(adev));\n\t\tbyt_rt5640_dais[dai_index].codecs->name = byt_rt5640_codec_name;\n\t} else {\n\t\tdev_err(dev, \"Error cannot find '%s' dev\\n\", mach->id);\n\t\treturn -ENXIO;\n\t}\n\n\tcodec_dev = acpi_get_first_physical_node(adev);\n\tacpi_dev_put(adev);\n\tif (!codec_dev)\n\t\treturn -EPROBE_DEFER;\n\tpriv->codec_dev = get_device(codec_dev);\n\n\t/*\n\t * swap SSP0 if bytcr is detected\n\t * (will be overridden if DMI quirk is detected)\n\t */\n\tif (soc_intel_is_byt()) {\n\t\tif (mach->mach_params.acpi_ipc_irq_index == 0)\n\t\t\tis_bytcr = true;\n\t}\n\n\tif (is_bytcr) {\n\t\t/*\n\t\t * Baytrail CR platforms may have CHAN package in BIOS, try\n\t\t * to find relevant routing quirk based as done on Windows\n\t\t * platforms. We have to read the information directly from the\n\t\t * BIOS, at this stage the card is not created and the links\n\t\t * with the codec driver/pdata are non-existent\n\t\t */\n\n\t\tstruct acpi_chan_package chan_package = { 0 };\n\n\t\t/* format specified: 2 64-bit integers */\n\t\tstruct acpi_buffer format = {sizeof(\"NN\"), \"NN\"};\n\t\tstruct acpi_buffer state = {0, NULL};\n\t\tstruct snd_soc_acpi_package_context pkg_ctx;\n\t\tbool pkg_found = false;\n\n\t\tstate.length = sizeof(chan_package);\n\t\tstate.pointer = &chan_package;\n\n\t\tpkg_ctx.name = \"CHAN\";\n\t\tpkg_ctx.length = 2;\n\t\tpkg_ctx.format = &format;\n\t\tpkg_ctx.state = &state;\n\t\tpkg_ctx.data_valid = false;\n\n\t\tpkg_found = snd_soc_acpi_find_package_from_hid(mach->id,\n\t\t\t\t\t\t\t       &pkg_ctx);\n\t\tif (pkg_found) {\n\t\t\tif (chan_package.aif_value == 1) {\n\t\t\t\tdev_info(dev, \"BIOS Routing: AIF1 connected\\n\");\n\t\t\t\tbyt_rt5640_quirk |= BYT_RT5640_SSP0_AIF1;\n\t\t\t} else  if (chan_package.aif_value == 2) {\n\t\t\t\tdev_info(dev, \"BIOS Routing: AIF2 connected\\n\");\n\t\t\t\tbyt_rt5640_quirk |= BYT_RT5640_SSP0_AIF2;\n\t\t\t} else {\n\t\t\t\tdev_info(dev, \"BIOS Routing isn't valid, ignored\\n\");\n\t\t\t\tpkg_found = false;\n\t\t\t}\n\t\t}\n\n\t\tif (!pkg_found) {\n\t\t\t/* no BIOS indications, assume SSP0-AIF2 connection */\n\t\t\tbyt_rt5640_quirk |= BYT_RT5640_SSP0_AIF2;\n\t\t}\n\n\t\t/* change defaults for Baytrail-CR capture */\n\t\tbyt_rt5640_quirk |= BYTCR_INPUT_DEFAULTS;\n\t} else {\n\t\tbyt_rt5640_quirk |= BYT_RT5640_DMIC1_MAP |\n\t\t\t\t    BYT_RT5640_JD_SRC_JD2_IN4N |\n\t\t\t\t    BYT_RT5640_OVCD_TH_2000UA |\n\t\t\t\t    BYT_RT5640_OVCD_SF_0P75;\n\t}\n\n\t/* check quirks before creating card */\n\tdmi_id = dmi_first_match(byt_rt5640_quirk_table);\n\tif (dmi_id)\n\t\tbyt_rt5640_quirk = (unsigned long)dmi_id->driver_data;\n\tif (quirk_override != -1) {\n\t\tdev_info(dev, \"Overriding quirk 0x%lx => 0x%x\\n\",\n\t\t\t byt_rt5640_quirk, quirk_override);\n\t\tbyt_rt5640_quirk = quirk_override;\n\t}\n\n\tif (byt_rt5640_quirk & BYT_RT5640_JD_HP_ELITEP_1000G2) {\n\t\tacpi_dev_add_driver_gpios(ACPI_COMPANION(priv->codec_dev),\n\t\t\t\t\t  byt_rt5640_hp_elitepad_1000g2_gpios);\n\n\t\tpriv->hsmic_detect = devm_fwnode_gpiod_get(dev, codec_dev->fwnode,\n\t\t\t\t\t\t\t   \"headset-mic-detect\", GPIOD_IN,\n\t\t\t\t\t\t\t   \"headset-mic-detect\");\n\t\tif (IS_ERR(priv->hsmic_detect)) {\n\t\t\tret_val = dev_err_probe(dev, PTR_ERR(priv->hsmic_detect),\n\t\t\t\t\t\t\"getting hsmic-detect GPIO\\n\");\n\t\t\tgoto err_device;\n\t\t}\n\t}\n\n\t/* Must be called before register_card, also see declaration comment. */\n\tret_val = byt_rt5640_add_codec_device_props(codec_dev, priv);\n\tif (ret_val)\n\t\tgoto err_remove_gpios;\n\n\tlog_quirks(dev);\n\n\tif ((byt_rt5640_quirk & BYT_RT5640_SSP2_AIF2) ||\n\t    (byt_rt5640_quirk & BYT_RT5640_SSP0_AIF2)) {\n\t\tbyt_rt5640_dais[dai_index].codecs->dai_name = \"rt5640-aif2\";\n\t\taif = 2;\n\t} else {\n\t\taif = 1;\n\t}\n\n\tif ((byt_rt5640_quirk & BYT_RT5640_SSP0_AIF1) ||\n\t    (byt_rt5640_quirk & BYT_RT5640_SSP0_AIF2))\n\t\tbyt_rt5640_dais[dai_index].cpus->dai_name = \"ssp0-port\";\n\n\tif (byt_rt5640_quirk & BYT_RT5640_MCLK_EN) {\n\t\tpriv->mclk = devm_clk_get_optional(dev, \"pmc_plt_clk_3\");\n\t\tif (IS_ERR(priv->mclk)) {\n\t\t\tret_val = dev_err_probe(dev, PTR_ERR(priv->mclk),\n\t\t\t\t\t\t\"Failed to get MCLK from pmc_plt_clk_3\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\t/*\n\t\t * Fall back to bit clock usage when clock is not\n\t\t * available likely due to missing dependencies.\n\t\t */\n\t\tif (!priv->mclk)\n\t\t\tbyt_rt5640_quirk &= ~BYT_RT5640_MCLK_EN;\n\t}\n\n\tif (byt_rt5640_quirk & BYT_RT5640_NO_SPEAKERS) {\n\t\tcfg_spk = \"0\";\n\t\tspk_type = \"none\";\n\t} else if (byt_rt5640_quirk & BYT_RT5640_MONO_SPEAKER) {\n\t\tcfg_spk = \"1\";\n\t\tspk_type = \"mono\";\n\t} else if (byt_rt5640_quirk & BYT_RT5640_SWAPPED_SPEAKERS) {\n\t\tcfg_spk = \"swapped\";\n\t\tspk_type = \"swapped\";\n\t} else {\n\t\tcfg_spk = \"2\";\n\t\tspk_type = \"stereo\";\n\t}\n\n\tif (byt_rt5640_quirk & BYT_RT5640_LINEOUT) {\n\t\tif (byt_rt5640_quirk & BYT_RT5640_LINEOUT_AS_HP2)\n\t\t\tlineout_string = \" cfg-hp2:lineout\";\n\t\telse\n\t\t\tlineout_string = \" cfg-lineout:2\";\n\t}\n\n\tif (byt_rt5640_quirk & BYT_RT5640_HSMIC2_ON_IN1)\n\t\theadset2_string = \" cfg-hs2:in1\";\n\n\tsnprintf(byt_rt5640_components, sizeof(byt_rt5640_components),\n\t\t \"cfg-spk:%s cfg-mic:%s aif:%d%s%s\", cfg_spk,\n\t\t map_name[BYT_RT5640_MAP(byt_rt5640_quirk)], aif,\n\t\t lineout_string, headset2_string);\n\tbyt_rt5640_card.components = byt_rt5640_components;\n// #if !IS_ENABLED(CONFIG_SND_SOC_INTEL_USER_FRIENDLY_LONG_NAMES)\n\tsnprintf(byt_rt5640_long_name, sizeof(byt_rt5640_long_name),\n\t\t \"bytcr-rt5640-%s-spk-%s-mic\", spk_type,\n\t\t map_name[BYT_RT5640_MAP(byt_rt5640_quirk)]);\n\tbyt_rt5640_card.long_name = byt_rt5640_long_name;\n#endif\n\n\t/* override platform name, if required */\n\tplatform_name = mach->mach_params.platform;\n\n\tret_val = snd_soc_fixup_dai_links_platform_name(&byt_rt5640_card,\n\t\t\t\t\t\t\tplatform_name);\n\tif (ret_val)\n\t\tgoto err;\n\n\tsof_parent = snd_soc_acpi_sof_parent(dev);\n\n\t/* set card and driver name */\n\tif (sof_parent) {\n\t\tbyt_rt5640_card.name = SOF_CARD_NAME;\n\t\tbyt_rt5640_card.driver_name = SOF_DRIVER_NAME;\n\t} else {\n\t\tbyt_rt5640_card.name = CARD_NAME;\n\t\tbyt_rt5640_card.driver_name = DRIVER_NAME;\n\t}\n\n\t/* set pm ops */\n\tif (sof_parent)\n\t\tdev->driver->pm = &snd_soc_pm_ops;\n\n\tret_val = devm_snd_soc_register_card(dev, &byt_rt5640_card);\n\tif (ret_val) {\n\t\tdev_err(dev, \"devm_snd_soc_register_card failed %d\\n\", ret_val);\n\t\tgoto err;\n\t}\n\tplatform_set_drvdata(pdev, &byt_rt5640_card);\n\treturn ret_val;\n\nerr:\n\tdevice_remove_software_node(priv->codec_dev);\nerr_remove_gpios:\n\tif (byt_rt5640_quirk & BYT_RT5640_JD_HP_ELITEP_1000G2)\n\t\tacpi_dev_remove_driver_gpios(ACPI_COMPANION(priv->codec_dev));\nerr_device:\n\tput_device(priv->codec_dev);\n\treturn ret_val;\n}\n",
      "cve_list": [
        "CVE-2024-46793"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "sound/soc/intel/boards/bytcr_rt5651.c",
      "func_name": "snd_byt_rt5651_mc_probe",
      "func_body": "static int snd_byt_rt5651_mc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstatic const char * const mic_name[] = { \"dmic\", \"in1\", \"in2\", \"in12\" };\n\tstruct snd_soc_acpi_mach *mach = dev_get_platdata(dev);\n\tstruct byt_rt5651_private *priv;\n\tconst char *platform_name;\n\tstruct acpi_device *adev;\n\tstruct device *codec_dev;\n\tbool sof_parent;\n\tbool is_bytcr = false;\n\tint ret_val = 0;\n\tint dai_index = 0;\n\tint i;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t/* register the soc card */\n\tbyt_rt5651_card.dev = dev;\n\tsnd_soc_card_set_drvdata(&byt_rt5651_card, priv);\n\n\t/* fix index of codec dai */\n\tfor (i = 0; i < ARRAY_SIZE(byt_rt5651_dais); i++) {\n\t\tif (byt_rt5651_dais[i].num_codecs &&\n\t\t    !strcmp(byt_rt5651_dais[i].codecs->name,\n\t\t\t    \"i2c-10EC5651:00\")) {\n\t\t\tdai_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* fixup codec name based on HID */\n\tadev = acpi_dev_get_first_match_dev(mach->id, NULL, -1);\n\tif (adev) {\n\t\tsnprintf(byt_rt5651_codec_name, sizeof(byt_rt5651_codec_name),\n\t\t\t \"i2c-%s\", acpi_dev_name(adev));\n\t\tbyt_rt5651_dais[dai_index].codecs->name = byt_rt5651_codec_name;\n\t} else {\n\t\tdev_err(dev, \"Error cannot find '%s' dev\\n\", mach->id);\n\t\treturn -ENXIO;\n\t}\n\n\tcodec_dev = acpi_get_first_physical_node(adev);\n\tacpi_dev_put(adev);\n\tif (!codec_dev)\n\t\treturn -EPROBE_DEFER;\n\tpriv->codec_dev = get_device(codec_dev);\n\n\t/*\n\t * swap SSP0 if bytcr is detected\n\t * (will be overridden if DMI quirk is detected)\n\t */\n\tif (soc_intel_is_byt()) {\n\t\tif (mach->mach_params.acpi_ipc_irq_index == 0)\n\t\t\tis_bytcr = true;\n\t}\n\n\tif (is_bytcr) {\n\t\t/*\n\t\t * Baytrail CR platforms may have CHAN package in BIOS, try\n\t\t * to find relevant routing quirk based as done on Windows\n\t\t * platforms. We have to read the information directly from the\n\t\t * BIOS, at this stage the card is not created and the links\n\t\t * with the codec driver/pdata are non-existent\n\t\t */\n\n\t\tstruct acpi_chan_package chan_package = { 0 };\n\n\t\t/* format specified: 2 64-bit integers */\n\t\tstruct acpi_buffer format = {sizeof(\"NN\"), \"NN\"};\n\t\tstruct acpi_buffer state = {0, NULL};\n\t\tstruct snd_soc_acpi_package_context pkg_ctx;\n\t\tbool pkg_found = false;\n\n\t\tstate.length = sizeof(chan_package);\n\t\tstate.pointer = &chan_package;\n\n\t\tpkg_ctx.name = \"CHAN\";\n\t\tpkg_ctx.length = 2;\n\t\tpkg_ctx.format = &format;\n\t\tpkg_ctx.state = &state;\n\t\tpkg_ctx.data_valid = false;\n\n\t\tpkg_found = snd_soc_acpi_find_package_from_hid(mach->id,\n\t\t\t\t\t\t\t       &pkg_ctx);\n\t\tif (pkg_found) {\n\t\t\tif (chan_package.aif_value == 1) {\n\t\t\t\tdev_info(dev, \"BIOS Routing: AIF1 connected\\n\");\n\t\t\t\tbyt_rt5651_quirk |= BYT_RT5651_SSP0_AIF1;\n\t\t\t} else  if (chan_package.aif_value == 2) {\n\t\t\t\tdev_info(dev, \"BIOS Routing: AIF2 connected\\n\");\n\t\t\t\tbyt_rt5651_quirk |= BYT_RT5651_SSP0_AIF2;\n\t\t\t} else {\n\t\t\t\tdev_info(dev, \"BIOS Routing isn't valid, ignored\\n\");\n\t\t\t\tpkg_found = false;\n\t\t\t}\n\t\t}\n\n\t\tif (!pkg_found) {\n\t\t\t/* no BIOS indications, assume SSP0-AIF2 connection */\n\t\t\tbyt_rt5651_quirk |= BYT_RT5651_SSP0_AIF2;\n\t\t}\n\t}\n\n\t/* check quirks before creating card */\n\tdmi_check_system(byt_rt5651_quirk_table);\n\n\tif (quirk_override != -1) {\n\t\tdev_info(dev, \"Overriding quirk 0x%lx => 0x%x\\n\",\n\t\t\t byt_rt5651_quirk, quirk_override);\n\t\tbyt_rt5651_quirk = quirk_override;\n\t}\n\n\t/* Must be called before register_card, also see declaration comment. */\n\tret_val = byt_rt5651_add_codec_device_props(codec_dev, priv);\n\tif (ret_val)\n\t\tgoto err_device;\n\n\t/* Cherry Trail devices use an external amplifier enable gpio */\n\tif (soc_intel_is_cht() && !byt_rt5651_gpios)\n\t\tbyt_rt5651_gpios = cht_rt5651_gpios;\n\n\tif (byt_rt5651_gpios) {\n\t\tdevm_acpi_dev_add_driver_gpios(codec_dev, byt_rt5651_gpios);\n\t\tpriv->ext_amp_gpio = devm_fwnode_gpiod_get(dev, codec_dev->fwnode,\n\t\t\t\t\t\t\t   \"ext-amp-enable\",\n\t\t\t\t\t\t\t   GPIOD_OUT_LOW,\n\t\t\t\t\t\t\t   \"speaker-amp\");\n\t\tif (IS_ERR(priv->ext_amp_gpio)) {\n\t\t\tret_val = PTR_ERR(priv->ext_amp_gpio);\n\t\t\tswitch (ret_val) {\n\t\t\tcase -ENOENT:\n\t\t\t\tpriv->ext_amp_gpio = NULL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(dev, \"Failed to get ext-amp-enable GPIO: %d\\n\", ret_val);\n\t\t\t\tfallthrough;\n\t\t\tcase -EPROBE_DEFER:\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t\tpriv->hp_detect = devm_fwnode_gpiod_get(dev, codec_dev->fwnode,\n\t\t\t\t\t\t\t\"hp-detect\",\n\t\t\t\t\t\t\tGPIOD_IN,\n\t\t\t\t\t\t\t\"hp-detect\");\n\t\tif (IS_ERR(priv->hp_detect)) {\n\t\t\tret_val = PTR_ERR(priv->hp_detect);\n\t\t\tswitch (ret_val) {\n\t\t\tcase -ENOENT:\n\t\t\t\tpriv->hp_detect = NULL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(dev, \"Failed to get hp-detect GPIO: %d\\n\", ret_val);\n\t\t\t\tfallthrough;\n\t\t\tcase -EPROBE_DEFER:\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tlog_quirks(dev);\n\n\tif ((byt_rt5651_quirk & BYT_RT5651_SSP2_AIF2) ||\n\t    (byt_rt5651_quirk & BYT_RT5651_SSP0_AIF2))\n\t\tbyt_rt5651_dais[dai_index].codecs->dai_name = \"rt5651-aif2\";\n\n\tif ((byt_rt5651_quirk & BYT_RT5651_SSP0_AIF1) ||\n\t    (byt_rt5651_quirk & BYT_RT5651_SSP0_AIF2))\n\t\tbyt_rt5651_dais[dai_index].cpus->dai_name = \"ssp0-port\";\n\n\tif (byt_rt5651_quirk & BYT_RT5651_MCLK_EN) {\n\t\tpriv->mclk = devm_clk_get_optional(dev, \"pmc_plt_clk_3\");\n\t\tif (IS_ERR(priv->mclk)) {\n\t\t\tret_val = dev_err_probe(dev, PTR_ERR(priv->mclk),\n\t\t\t\t\t\t\"Failed to get MCLK from pmc_plt_clk_3\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\t/*\n\t\t * Fall back to bit clock usage when clock is not\n\t\t * available likely due to missing dependencies.\n\t\t */\n\t\tif (!priv->mclk)\n\t\t\tbyt_rt5651_quirk &= ~BYT_RT5651_MCLK_EN;\n\t}\n\n\tsnprintf(byt_rt5651_components, sizeof(byt_rt5651_components),\n\t\t \"cfg-spk:%s cfg-mic:%s%s\",\n\t\t (byt_rt5651_quirk & BYT_RT5651_MONO_SPEAKER) ? \"1\" : \"2\",\n\t\t mic_name[BYT_RT5651_MAP(byt_rt5651_quirk)],\n\t\t (byt_rt5651_quirk & BYT_RT5651_HP_LR_SWAPPED) ?\n\t\t\t\" cfg-hp:lrswap\" : \"\");\n\tbyt_rt5651_card.components = byt_rt5651_components;\n// #if !IS_ENABLED(CONFIG_SND_SOC_INTEL_USER_FRIENDLY_LONG_NAMES)\n\tsnprintf(byt_rt5651_long_name, sizeof(byt_rt5651_long_name),\n\t\t \"bytcr-rt5651-%s-spk-%s-mic%s\",\n\t\t (byt_rt5651_quirk & BYT_RT5651_MONO_SPEAKER) ?\n\t\t\t\"mono\" : \"stereo\",\n\t\t mic_name[BYT_RT5651_MAP(byt_rt5651_quirk)],\n\t\t (byt_rt5651_quirk & BYT_RT5651_HP_LR_SWAPPED) ?\n\t\t\t\"-hp-swapped\" : \"\");\n\tbyt_rt5651_card.long_name = byt_rt5651_long_name;\n#endif\n\n\t/* override platform name, if required */\n\tplatform_name = mach->mach_params.platform;\n\n\tret_val = snd_soc_fixup_dai_links_platform_name(&byt_rt5651_card,\n\t\t\t\t\t\t\tplatform_name);\n\tif (ret_val)\n\t\tgoto err;\n\n\tsof_parent = snd_soc_acpi_sof_parent(dev);\n\n\t/* set card and driver name */\n\tif (sof_parent) {\n\t\tbyt_rt5651_card.name = SOF_CARD_NAME;\n\t\tbyt_rt5651_card.driver_name = SOF_DRIVER_NAME;\n\t} else {\n\t\tbyt_rt5651_card.name = CARD_NAME;\n\t\tbyt_rt5651_card.driver_name = DRIVER_NAME;\n\t}\n\n\t/* set pm ops */\n\tif (sof_parent)\n\t\tdev->driver->pm = &snd_soc_pm_ops;\n\n\tret_val = devm_snd_soc_register_card(dev, &byt_rt5651_card);\n\tif (ret_val) {\n\t\tdev_err(dev, \"devm_snd_soc_register_card failed %d\\n\", ret_val);\n\t\tgoto err;\n\t}\n\tplatform_set_drvdata(pdev, &byt_rt5651_card);\n\treturn ret_val;\n\nerr:\n\tdevice_remove_software_node(priv->codec_dev);\nerr_device:\n\tput_device(priv->codec_dev);\n\treturn ret_val;\n}\n",
      "cve_list": [
        "CVE-2024-46793"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "sound/soc/intel/boards/bytcr_wm5102.c",
      "func_name": "snd_byt_wm5102_mc_probe",
      "func_body": "static int snd_byt_wm5102_mc_probe(struct platform_device *pdev)\n{\n\tstatic const char * const out_map_name[] = { \"spk\", \"hpout2\" };\n\tstatic const char * const intmic_map_name[] = { \"in3l\", \"in1l\" };\n\tstatic const char * const hsmic_map_name[] = { \"in1l\", \"in2l\" };\n\tchar codec_name[SND_ACPI_I2C_ID_LEN];\n\tstruct device *dev = &pdev->dev;\n\tstruct byt_wm5102_private *priv;\n\tstruct snd_soc_acpi_mach *mach;\n\tconst char *platform_name;\n\tstruct acpi_device *adev;\n\tstruct device *codec_dev;\n\tint dai_index = 0;\n\tbool sof_parent;\n\tint i, ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t/* Get MCLK */\n\tpriv->mclk = devm_clk_get(dev, \"pmc_plt_clk_3\");\n\tif (IS_ERR(priv->mclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->mclk), \"getting pmc_plt_clk_3\\n\");\n\n\t/*\n\t * Get speaker VDD enable GPIO:\n\t * 1. Get codec-device-name\n\t * 2. Get codec-device\n\t * 3. Get GPIO from codec-device\n\t */\n\tmach = dev->platform_data;\n\tadev = acpi_dev_get_first_match_dev(mach->id, NULL, -1);\n\tif (adev) {\n\t\tsnprintf(codec_name, sizeof(codec_name), \"spi-%s\", acpi_dev_name(adev));\n\t\tacpi_dev_put(adev);\n\t} else {\n\t\t/* Special case for when the codec is missing from the DSTD */\n\t\tstrscpy(codec_name, \"spi1.0\", sizeof(codec_name));\n\t}\n\n\tcodec_dev = bus_find_device_by_name(&spi_bus_type, NULL, codec_name);\n\tif (!codec_dev)\n\t\treturn -EPROBE_DEFER;\n\n\t/* Note no devm_ here since we call gpiod_get on codec_dev rather then dev */\n\tpriv->spkvdd_en_gpio = gpiod_get(codec_dev, \"wlf,spkvdd-ena\", GPIOD_OUT_LOW);\n\tput_device(codec_dev);\n\n\tif (IS_ERR(priv->spkvdd_en_gpio)) {\n\t\tret = PTR_ERR(priv->spkvdd_en_gpio);\n\t\t/*\n\t\t * The spkvdd gpio-lookup is registered by: drivers/mfd/arizona-spi.c,\n\t\t * so -ENOENT means that arizona-spi hasn't probed yet.\n\t\t */\n\t\tif (ret == -ENOENT)\n\t\t\tret = -EPROBE_DEFER;\n\n\t\treturn dev_err_probe(dev, ret, \"getting spkvdd-GPIO\\n\");\n\t}\n\n\tif (soc_intel_is_cht()) {\n\t\t/*\n\t\t * CHT always uses SSP2 and 19.2 MHz; and\n\t\t * the one currently supported CHT design uses HPOUT2 as\n\t\t * speaker output and has the intmic on IN1L + hsmic on IN2L.\n\t\t */\n\t\tquirk = BYT_WM5102_SSP2 | BYT_WM5102_MCLK_19_2MHZ |\n\t\t\tBYT_WM5102_INTMIC_IN1L_HSMIC_IN2L |\n\t\t\tBYT_WM5102_SPK_HPOUT2_MAP;\n\t}\n\tif (quirk_override != -1) {\n\t\tdev_info_once(dev, \"Overriding quirk 0x%lx => 0x%x\\n\",\n\t\t\t      quirk, quirk_override);\n\t\tquirk = quirk_override;\n\t}\n\tlog_quirks(dev);\n\n\tsnprintf(byt_wm5102_components, sizeof(byt_wm5102_components),\n\t\t \"cfg-spk:%s cfg-intmic:%s cfg-hsmic:%s\",\n\t\t out_map_name[FIELD_GET(BYT_WM5102_OUT_MAP, quirk)],\n\t\t intmic_map_name[FIELD_GET(BYT_WM5102_IN_MAP, quirk)],\n\t\t hsmic_map_name[FIELD_GET(BYT_WM5102_IN_MAP, quirk)]);\n\tbyt_wm5102_card.components = byt_wm5102_components;\n\n\t/* find index of codec dai */\n\tfor (i = 0; i < ARRAY_SIZE(byt_wm5102_dais); i++) {\n\t\tif (byt_wm5102_dais[i].num_codecs &&\n\t\t    !strcmp(byt_wm5102_dais[i].codecs->name,\n\t\t\t    \"wm5102-codec\")) {\n\t\t\tdai_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* override platform name, if required */\n\tbyt_wm5102_card.dev = dev;\n\tplatform_name = mach->mach_params.platform;\n\tret = snd_soc_fixup_dai_links_platform_name(&byt_wm5102_card, platform_name);\n\tif (ret)\n\t\tgoto out_put_gpio;\n\n\t/* override SSP port, if required */\n\tif (quirk & BYT_WM5102_SSP2)\n\t\tbyt_wm5102_dais[dai_index].cpus->dai_name = \"ssp2-port\";\n\n\t/* set card and driver name and pm-ops */\n\tsof_parent = snd_soc_acpi_sof_parent(dev);\n\tif (sof_parent) {\n\t\tbyt_wm5102_card.name = SOF_CARD_NAME;\n\t\tbyt_wm5102_card.driver_name = SOF_DRIVER_NAME;\n\t\tdev->driver->pm = &snd_soc_pm_ops;\n\t} else {\n\t\tbyt_wm5102_card.name = CARD_NAME;\n\t\tbyt_wm5102_card.driver_name = DRIVER_NAME;\n\t}\n\n\tsnd_soc_card_set_drvdata(&byt_wm5102_card, priv);\n\tret = devm_snd_soc_register_card(dev, &byt_wm5102_card);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"registering card\\n\");\n\t\tgoto out_put_gpio;\n\t}\n\n\tplatform_set_drvdata(pdev, &byt_wm5102_card);\n\treturn 0;\n\nout_put_gpio:\n\tgpiod_put(priv->spkvdd_en_gpio);\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-46793"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "sound/soc/intel/boards/cht_bsw_rt5645.c",
      "func_name": "snd_cht_mc_probe",
      "func_body": "static int snd_cht_mc_probe(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card = snd_soc_cards[0].soc_card;\n\tstruct snd_soc_acpi_mach *mach;\n\tconst char *platform_name;\n\tstruct cht_mc_private *drv;\n\tstruct acpi_device *adev;\n\tstruct device *codec_dev;\n\tbool sof_parent;\n\tbool found = false;\n\tbool is_bytcr = false;\n\tint dai_index = 0;\n\tint ret_val = 0;\n\tint i;\n\tconst char *mclk_name;\n\n\tdrv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_KERNEL);\n\tif (!drv)\n\t\treturn -ENOMEM;\n\n\tmach = pdev->dev.platform_data;\n\n\tfor (i = 0; i < ARRAY_SIZE(snd_soc_cards); i++) {\n\t\tif (acpi_dev_found(snd_soc_cards[i].codec_id) &&\n\t\t\t(!strncmp(snd_soc_cards[i].codec_id, mach->id, 8))) {\n\t\t\tdev_dbg(&pdev->dev,\n\t\t\t\t\"found codec %s\\n\", snd_soc_cards[i].codec_id);\n\t\t\tcard = snd_soc_cards[i].soc_card;\n\t\t\tdrv->acpi_card = &snd_soc_cards[i];\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tdev_err(&pdev->dev, \"No matching HID found in supported list\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tcard->dev = &pdev->dev;\n\n\t/* set correct codec name */\n\tfor (i = 0; i < ARRAY_SIZE(cht_dailink); i++)\n\t\tif (cht_dailink[i].num_codecs &&\n\t\t    !strcmp(cht_dailink[i].codecs->name,\n\t\t\t    \"i2c-10EC5645:00\")) {\n\t\t\tdai_index = i;\n\t\t\tbreak;\n\t\t}\n\n\t/* fixup codec name based on HID */\n\tadev = acpi_dev_get_first_match_dev(mach->id, NULL, -1);\n\tif (adev) {\n\t\tsnprintf(cht_rt5645_codec_name, sizeof(cht_rt5645_codec_name),\n\t\t\t \"i2c-%s\", acpi_dev_name(adev));\n\t\tcht_dailink[dai_index].codecs->name = cht_rt5645_codec_name;\n\t}\n\t/* acpi_get_first_physical_node() returns a borrowed ref, no need to deref */\n\tcodec_dev = acpi_get_first_physical_node(adev);\n\tacpi_dev_put(adev);\n\tif (!codec_dev)\n\t\treturn -EPROBE_DEFER;\n\n\tsnd_soc_card_chtrt5645.components = rt5645_components(codec_dev);\n\tsnd_soc_card_chtrt5650.components = rt5645_components(codec_dev);\n\n\t/*\n\t * swap SSP0 if bytcr is detected\n\t * (will be overridden if DMI quirk is detected)\n\t */\n\tif (soc_intel_is_byt()) {\n\t\tif (mach->mach_params.acpi_ipc_irq_index == 0)\n\t\t\tis_bytcr = true;\n\t}\n\n\tif (is_bytcr) {\n\t\t/*\n\t\t * Baytrail CR platforms may have CHAN package in BIOS, try\n\t\t * to find relevant routing quirk based as done on Windows\n\t\t * platforms. We have to read the information directly from the\n\t\t * BIOS, at this stage the card is not created and the links\n\t\t * with the codec driver/pdata are non-existent\n\t\t */\n\n\t\tstruct acpi_chan_package chan_package = { 0 };\n\n\t\t/* format specified: 2 64-bit integers */\n\t\tstruct acpi_buffer format = {sizeof(\"NN\"), \"NN\"};\n\t\tstruct acpi_buffer state = {0, NULL};\n\t\tstruct snd_soc_acpi_package_context pkg_ctx;\n\t\tbool pkg_found = false;\n\n\t\tstate.length = sizeof(chan_package);\n\t\tstate.pointer = &chan_package;\n\n\t\tpkg_ctx.name = \"CHAN\";\n\t\tpkg_ctx.length = 2;\n\t\tpkg_ctx.format = &format;\n\t\tpkg_ctx.state = &state;\n\t\tpkg_ctx.data_valid = false;\n\n\t\tpkg_found = snd_soc_acpi_find_package_from_hid(mach->id,\n\t\t\t\t\t\t\t       &pkg_ctx);\n\t\tif (pkg_found) {\n\t\t\tif (chan_package.aif_value == 1) {\n\t\t\t\tdev_info(&pdev->dev, \"BIOS Routing: AIF1 connected\\n\");\n\t\t\t\tcht_rt5645_quirk |= CHT_RT5645_SSP0_AIF1;\n\t\t\t} else  if (chan_package.aif_value == 2) {\n\t\t\t\tdev_info(&pdev->dev, \"BIOS Routing: AIF2 connected\\n\");\n\t\t\t\tcht_rt5645_quirk |= CHT_RT5645_SSP0_AIF2;\n\t\t\t} else {\n\t\t\t\tdev_info(&pdev->dev, \"BIOS Routing isn't valid, ignored\\n\");\n\t\t\t\tpkg_found = false;\n\t\t\t}\n\t\t}\n\n\t\tif (!pkg_found) {\n\t\t\t/* no BIOS indications, assume SSP0-AIF2 connection */\n\t\t\tcht_rt5645_quirk |= CHT_RT5645_SSP0_AIF2;\n\t\t}\n\t}\n\n\t/* check quirks before creating card */\n\tdmi_check_system(cht_rt5645_quirk_table);\n\tlog_quirks(&pdev->dev);\n\n\tif ((cht_rt5645_quirk & CHT_RT5645_SSP2_AIF2) ||\n\t    (cht_rt5645_quirk & CHT_RT5645_SSP0_AIF2))\n\t\tcht_dailink[dai_index].codecs->dai_name = \"rt5645-aif2\";\n\n\tif ((cht_rt5645_quirk & CHT_RT5645_SSP0_AIF1) ||\n\t    (cht_rt5645_quirk & CHT_RT5645_SSP0_AIF2))\n\t\tcht_dailink[dai_index].cpus->dai_name = \"ssp0-port\";\n\n\t/* override platform name, if required */\n\tplatform_name = mach->mach_params.platform;\n\n\tret_val = snd_soc_fixup_dai_links_platform_name(card,\n\t\t\t\t\t\t\tplatform_name);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (cht_rt5645_quirk & CHT_RT5645_PMC_PLT_CLK_0)\n\t\tmclk_name = \"pmc_plt_clk_0\";\n\telse\n\t\tmclk_name = \"pmc_plt_clk_3\";\n\n\tdrv->mclk = devm_clk_get(&pdev->dev, mclk_name);\n\tif (IS_ERR(drv->mclk)) {\n\t\tdev_err(&pdev->dev, \"Failed to get MCLK from %s: %ld\\n\",\n\t\t\tmclk_name, PTR_ERR(drv->mclk));\n\t\treturn PTR_ERR(drv->mclk);\n\t}\n\n\tsnd_soc_card_set_drvdata(card, drv);\n\n\tsof_parent = snd_soc_acpi_sof_parent(&pdev->dev);\n\n\t/* set card and driver name */\n\tif (sof_parent) {\n\t\tsnd_soc_card_chtrt5645.name = SOF_CARD_RT5645_NAME;\n\t\tsnd_soc_card_chtrt5645.driver_name = SOF_DRIVER_NAME;\n\t\tsnd_soc_card_chtrt5650.name = SOF_CARD_RT5650_NAME;\n\t\tsnd_soc_card_chtrt5650.driver_name = SOF_DRIVER_NAME;\n\t} else {\n\t\tsnd_soc_card_chtrt5645.name = CARD_RT5645_NAME;\n\t\tsnd_soc_card_chtrt5645.driver_name = DRIVER_NAME;\n\t\tsnd_soc_card_chtrt5650.name = CARD_RT5650_NAME;\n\t\tsnd_soc_card_chtrt5650.driver_name = DRIVER_NAME;\n\t}\n\n\t/* set pm ops */\n\tif (sof_parent)\n\t\tpdev->dev.driver->pm = &snd_soc_pm_ops;\n\n\tret_val = devm_snd_soc_register_card(&pdev->dev, card);\n\tif (ret_val) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"snd_soc_register_card failed %d\\n\", ret_val);\n\t\treturn ret_val;\n\t}\n\tplatform_set_drvdata(pdev, card);\n\treturn ret_val;\n}\n",
      "cve_list": [
        "CVE-2024-46793"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "sound/soc/intel/boards/cht_bsw_rt5672.c",
      "func_name": "snd_cht_mc_probe",
      "func_body": "static int snd_cht_mc_probe(struct platform_device *pdev)\n{\n\tint ret_val = 0;\n\tstruct cht_mc_private *drv;\n\tstruct snd_soc_acpi_mach *mach = pdev->dev.platform_data;\n\tconst char *platform_name;\n\tstruct acpi_device *adev;\n\tbool sof_parent;\n\tint dai_index = 0;\n\tint i;\n\n\tdrv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_KERNEL);\n\tif (!drv)\n\t\treturn -ENOMEM;\n\n\tstrcpy(drv->codec_name, RT5672_I2C_DEFAULT);\n\n\t/* find index of codec dai */\n\tfor (i = 0; i < ARRAY_SIZE(cht_dailink); i++) {\n\t\tif (cht_dailink[i].num_codecs &&\n\t\t    !strcmp(cht_dailink[i].codecs->name, RT5672_I2C_DEFAULT)) {\n\t\t\tdai_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* fixup codec name based on HID */\n\tadev = acpi_dev_get_first_match_dev(mach->id, NULL, -1);\n\tif (adev) {\n\t\tsnprintf(drv->codec_name, sizeof(drv->codec_name),\n\t\t\t \"i2c-%s\", acpi_dev_name(adev));\n\t\tcht_dailink[dai_index].codecs->name = drv->codec_name;\n\t}\n\tacpi_dev_put(adev);\n\n\t/* Use SSP0 on Bay Trail CR devices */\n\tif (soc_intel_is_byt() && mach->mach_params.acpi_ipc_irq_index == 0) {\n\t\tcht_dailink[dai_index].cpus->dai_name = \"ssp0-port\";\n\t\tdrv->use_ssp0 = true;\n\t}\n\n\t/* override platform name, if required */\n\tsnd_soc_card_cht.dev = &pdev->dev;\n\tplatform_name = mach->mach_params.platform;\n\n\tret_val = snd_soc_fixup_dai_links_platform_name(&snd_soc_card_cht,\n\t\t\t\t\t\t\tplatform_name);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tsnd_soc_card_cht.components = rt5670_components();\n\n\tdrv->mclk = devm_clk_get(&pdev->dev, \"pmc_plt_clk_3\");\n\tif (IS_ERR(drv->mclk)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to get MCLK from pmc_plt_clk_3: %ld\\n\",\n\t\t\tPTR_ERR(drv->mclk));\n\t\treturn PTR_ERR(drv->mclk);\n\t}\n\tsnd_soc_card_set_drvdata(&snd_soc_card_cht, drv);\n\n\tsof_parent = snd_soc_acpi_sof_parent(&pdev->dev);\n\n\t/* set card and driver name */\n\tif (sof_parent) {\n\t\tsnd_soc_card_cht.name = SOF_CARD_NAME;\n\t\tsnd_soc_card_cht.driver_name = SOF_DRIVER_NAME;\n\t} else {\n\t\tsnd_soc_card_cht.name = CARD_NAME;\n\t\tsnd_soc_card_cht.driver_name = DRIVER_NAME;\n\t}\n\n\t/* set pm ops */\n\tif (sof_parent)\n\t\tpdev->dev.driver->pm = &snd_soc_pm_ops;\n\n\t/* register the soc card */\n\tret_val = devm_snd_soc_register_card(&pdev->dev, &snd_soc_card_cht);\n\tif (ret_val) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"snd_soc_register_card failed %d\\n\", ret_val);\n\t\treturn ret_val;\n\t}\n\tplatform_set_drvdata(pdev, &snd_soc_card_cht);\n\treturn ret_val;\n}\n",
      "cve_list": [
        "CVE-2024-46793"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/tty/serial/max310x.c",
      "func_name": "max310x_i2c_probe",
      "func_body": "static int max310x_i2c_probe(struct i2c_client *client)\n{\n\tconst struct max310x_devtype *devtype;\n\tstruct i2c_client *port_client;\n\tstruct regmap *regmaps[4];\n\tunsigned int i;\n\tu8 port_addr;\n\n\tdevtype = device_get_match_data(&client->dev);\n\tif (!devtype)\n\t\treturn dev_err_probe(&client->dev, -ENODEV, \"Failed to match device\\n\");\n\n\tif (client->addr < devtype->slave_addr.min ||\n\t\tclient->addr > devtype->slave_addr.max)\n\t\treturn dev_err_probe(&client->dev, -EINVAL,\n\t\t\t\t     \"Slave addr 0x%x outside of range [0x%x, 0x%x]\\n\",\n\t\t\t\t     client->addr, devtype->slave_addr.min,\n\t\t\t\t     devtype->slave_addr.max);\n\n\tregmaps[0] = devm_regmap_init_i2c(client, &regcfg_i2c);\n\n\tfor (i = 1; i < devtype->nr; i++) {\n\t\tport_addr = max310x_i2c_slave_addr(client->addr, i);\n\t\tport_client = devm_i2c_new_dummy_device(&client->dev,\n\t\t\t\t\t\t\tclient->adapter,\n\t\t\t\t\t\t\tport_addr);\n\n\t\tregmaps[i] = devm_regmap_init_i2c(port_client, &regcfg_i2c);\n\t}\n\n\treturn max310x_probe(&client->dev, devtype, &max310x_i2c_if_cfg,\n\t\t\t     regmaps, client->irq);\n}\n",
      "cve_list": [
        "CVE-2024-26978"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_ptp.c",
      "func_name": "hclge_ptp_get_rx_hwts",
      "func_body": "void hclge_ptp_get_rx_hwts(struct hnae3_handle *handle, struct sk_buff *skb,\n\t\t\t   u32 nsec, u32 sec)\n{\n\tstruct hclge_vport *vport = hclge_get_vport(handle);\n\tstruct hclge_dev *hdev = vport->back;\n\tunsigned long flags;\n\tu64 ns = nsec;\n\tu32 sec_h;\n\n\tif (!hdev->ptp || !test_bit(HCLGE_PTP_FLAG_RX_EN, &hdev->ptp->flags))\n\t\treturn;\n\n\t/* Since the BD does not have enough space for the higher 16 bits of\n\t * second, and this part will not change frequently, so read it\n\t * from register.\n\t */\n\tspin_lock_irqsave(&hdev->ptp->lock, flags);\n\tsec_h = readl(hdev->ptp->io_base + HCLGE_PTP_CUR_TIME_SEC_H_REG);\n\tspin_unlock_irqrestore(&hdev->ptp->lock, flags);\n\n\tns += (((u64)sec_h) << HCLGE_PTP_SEC_H_OFFSET | sec) * NSEC_PER_SEC;\n\tskb_hwtstamps(skb)->hwtstamp = ns_to_ktime(ns);\n\thdev->ptp->last_rx = jiffies;\n\thdev->ptp->rx_cnt++;\n}\n",
      "cve_list": [
        "CVE-2024-26881"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/drm_client_modeset.c",
      "func_name": "drm_client_modeset_probe",
      "func_body": "int drm_client_modeset_probe(struct drm_client_dev *client, unsigned int width, unsigned int height)\n{\n\tstruct drm_connector *connector, **connectors = NULL;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_device *dev = client->dev;\n\tunsigned int total_modes_count = 0;\n\tstruct drm_client_offset *offsets;\n\tunsigned int connector_count = 0;\n\t/* points to modes protected by mode_config.mutex */\n\tstruct drm_display_mode **modes;\n\tstruct drm_crtc **crtcs;\n\tint i, ret = 0;\n\tbool *enabled;\n\n\tdrm_dbg_kms(dev, \"\\n\");\n\n\tif (!width)\n\t\twidth = dev->mode_config.max_width;\n\tif (!height)\n\t\theight = dev->mode_config.max_height;\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_client_for_each_connector_iter(connector, &conn_iter) {\n\t\tstruct drm_connector **tmp;\n\n\t\ttmp = krealloc(connectors, (connector_count + 1) * sizeof(*connectors), GFP_KERNEL);\n\t\tif (!tmp) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_connectors;\n\t\t}\n\n\t\tconnectors = tmp;\n\t\tdrm_connector_get(connector);\n\t\tconnectors[connector_count++] = connector;\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tif (!connector_count)\n\t\treturn 0;\n\n\tcrtcs = kcalloc(connector_count, sizeof(*crtcs), GFP_KERNEL);\n\tmodes = kcalloc(connector_count, sizeof(*modes), GFP_KERNEL);\n\toffsets = kcalloc(connector_count, sizeof(*offsets), GFP_KERNEL);\n\tenabled = kcalloc(connector_count, sizeof(bool), GFP_KERNEL);\n\tif (!crtcs || !modes || !enabled || !offsets) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&client->modeset_mutex);\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tfor (i = 0; i < connector_count; i++)\n\t\ttotal_modes_count += connectors[i]->funcs->fill_modes(connectors[i], width, height);\n\tif (!total_modes_count)\n\t\tdrm_dbg_kms(dev, \"No connectors reported connected with modes\\n\");\n\tdrm_client_connectors_enabled(connectors, connector_count, enabled);\n\n\tif (!drm_client_firmware_config(client, connectors, connector_count, crtcs,\n\t\t\t\t\tmodes, offsets, enabled, width, height)) {\n\t\tmemset(modes, 0, connector_count * sizeof(*modes));\n\t\tmemset(crtcs, 0, connector_count * sizeof(*crtcs));\n\t\tmemset(offsets, 0, connector_count * sizeof(*offsets));\n\n\t\tif (!drm_client_target_cloned(dev, connectors, connector_count, modes,\n\t\t\t\t\t      offsets, enabled, width, height) &&\n\t\t    !drm_client_target_preferred(dev, connectors, connector_count, modes,\n\t\t\t\t\t\t offsets, enabled, width, height))\n\t\t\tdrm_err(dev, \"Unable to find initial modes\\n\");\n\n\t\tdrm_dbg_kms(dev, \"picking CRTCs for %dx%d config\\n\",\n\t\t\t    width, height);\n\n\t\tdrm_client_pick_crtcs(client, connectors, connector_count,\n\t\t\t\t      crtcs, modes, 0, width, height);\n\t}\n\n\tdrm_client_modeset_release(client);\n\n\tfor (i = 0; i < connector_count; i++) {\n\t\tstruct drm_display_mode *mode = modes[i];\n\t\tstruct drm_crtc *crtc = crtcs[i];\n\t\tstruct drm_client_offset *offset = &offsets[i];\n\n\t\tif (mode && crtc) {\n\t\t\tstruct drm_mode_set *modeset = drm_client_find_modeset(client, crtc);\n\t\t\tstruct drm_connector *connector = connectors[i];\n\n\t\t\tdrm_dbg_kms(dev, \"[CRTC:%d:%s] desired mode %s set (%d,%d)\\n\",\n\t\t\t\t    crtc->base.id, crtc->name,\n\t\t\t\t    mode->name, offset->x, offset->y);\n\n\t\t\tif (drm_WARN_ON_ONCE(dev, modeset->num_connectors == DRM_CLIENT_MAX_CLONED_CONNECTORS ||\n\t\t\t\t\t     (dev->mode_config.num_crtc > 1 && modeset->num_connectors == 1))) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tkfree(modeset->mode);\n\t\t\tmodeset->mode = drm_mode_duplicate(dev, mode);\n\t\t\tif (!modeset->mode) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdrm_connector_get(connector);\n\t\t\tmodeset->connectors[modeset->num_connectors++] = connector;\n\t\t\tmodeset->x = offset->x;\n\t\t\tmodeset->y = offset->y;\n\t\t}\n\t}\n\tmutex_unlock(&dev->mode_config.mutex);\n\n\tmutex_unlock(&client->modeset_mutex);\nout:\n\tkfree(crtcs);\n\tkfree(modes);\n\tkfree(offsets);\n\tkfree(enabled);\nfree_connectors:\n\tfor (i = 0; i < connector_count; i++)\n\t\tdrm_connector_put(connectors[i]);\n\tkfree(connectors);\n\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-43894"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/erofs/decompressor.c",
      "func_name": "z_erofs_parse_cfgs",
      "func_body": "int z_erofs_parse_cfgs(struct super_block *sb, struct erofs_super_block *dsb)\n{\n\tstruct erofs_sb_info *sbi = EROFS_SB(sb);\n\tstruct erofs_buf buf = __EROFS_BUF_INITIALIZER;\n\tunsigned int algs, alg;\n\terofs_off_t offset;\n\tint size, ret = 0;\n\n\tif (!erofs_sb_has_compr_cfgs(sbi)) {\n\t\tsbi->available_compr_algs = 1 << Z_EROFS_COMPRESSION_LZ4;\n\t\treturn z_erofs_load_lz4_config(sb, dsb, NULL, 0);\n\t}\n\n\tsbi->available_compr_algs = le16_to_cpu(dsb->u1.available_compr_algs);\n\tif (sbi->available_compr_algs & ~Z_EROFS_ALL_COMPR_ALGS) {\n\t\terofs_err(sb, \"unidentified algorithms %x, please upgrade kernel\",\n\t\t\t  sbi->available_compr_algs & ~Z_EROFS_ALL_COMPR_ALGS);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terofs_init_metabuf(&buf, sb);\n\toffset = EROFS_SUPER_OFFSET + sbi->sb_size;\n\talg = 0;\n\tfor (algs = sbi->available_compr_algs; algs; algs >>= 1, ++alg) {\n\t\tvoid *data;\n\n\t\tif (!(algs & 1))\n\t\t\tcontinue;\n\n\t\tdata = erofs_read_metadata(sb, &buf, &offset, &size);\n\t\tif (IS_ERR(data)) {\n\t\t\tret = PTR_ERR(data);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (alg >= ARRAY_SIZE(erofs_decompressors) ||\n\t\t    !erofs_decompressors[alg].config) {\n\t\t\terofs_err(sb, \"algorithm %d isn't enabled on this kernel\",\n\t\t\t\t  alg);\n\t\t\tret = -EOPNOTSUPP;\n\t\t} else {\n\t\t\tret = erofs_decompressors[alg].config(sb,\n\t\t\t\t\tdsb, data, size);\n\t\t}\n\n\t\tkfree(data);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\terofs_put_metabuf(&buf);\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-26590"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/erofs/zmap.c",
      "func_name": "z_erofs_do_map_blocks",
      "func_body": "static int z_erofs_do_map_blocks(struct inode *inode,\n\t\t\t\t struct erofs_map_blocks *map, int flags)\n{\n\tstruct erofs_inode *const vi = EROFS_I(inode);\n\tbool ztailpacking = vi->z_advise & Z_EROFS_ADVISE_INLINE_PCLUSTER;\n\tbool fragment = vi->z_advise & Z_EROFS_ADVISE_FRAGMENT_PCLUSTER;\n\tstruct z_erofs_maprecorder m = {\n\t\t.inode = inode,\n\t\t.map = map,\n\t};\n\tint err = 0;\n\tunsigned int lclusterbits, endoff, afmt;\n\tunsigned long initial_lcn;\n\tunsigned long long ofs, end;\n\n\tlclusterbits = vi->z_logical_clusterbits;\n\tofs = flags & EROFS_GET_BLOCKS_FINDTAIL ? inode->i_size - 1 : map->m_la;\n\tinitial_lcn = ofs >> lclusterbits;\n\tendoff = ofs & ((1 << lclusterbits) - 1);\n\n\terr = z_erofs_load_lcluster_from_disk(&m, initial_lcn, false);\n\tif (err)\n\t\tgoto unmap_out;\n\n\tif (ztailpacking && (flags & EROFS_GET_BLOCKS_FINDTAIL))\n\t\tvi->z_idataoff = m.nextpackoff;\n\n\tmap->m_flags = EROFS_MAP_MAPPED | EROFS_MAP_ENCODED;\n\tend = (m.lcn + 1ULL) << lclusterbits;\n\n\tswitch (m.type) {\n\tcase Z_EROFS_LCLUSTER_TYPE_PLAIN:\n\tcase Z_EROFS_LCLUSTER_TYPE_HEAD1:\n\tcase Z_EROFS_LCLUSTER_TYPE_HEAD2:\n\t\tif (endoff >= m.clusterofs) {\n\t\t\tm.headtype = m.type;\n\t\t\tmap->m_la = (m.lcn << lclusterbits) | m.clusterofs;\n\t\t\t/*\n\t\t\t * For ztailpacking files, in order to inline data more\n\t\t\t * effectively, special EOF lclusters are now supported\n\t\t\t * which can have three parts at most.\n\t\t\t */\n\t\t\tif (ztailpacking && end > inode->i_size)\n\t\t\t\tend = inode->i_size;\n\t\t\tbreak;\n\t\t}\n\t\t/* m.lcn should be >= 1 if endoff < m.clusterofs */\n\t\tif (!m.lcn) {\n\t\t\terofs_err(inode->i_sb,\n\t\t\t\t  \"invalid logical cluster 0 at nid %llu\",\n\t\t\t\t  vi->nid);\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto unmap_out;\n\t\t}\n\t\tend = (m.lcn << lclusterbits) | m.clusterofs;\n\t\tmap->m_flags |= EROFS_MAP_FULL_MAPPED;\n\t\tm.delta[0] = 1;\n\t\tfallthrough;\n\tcase Z_EROFS_LCLUSTER_TYPE_NONHEAD:\n\t\t/* get the corresponding first chunk */\n\t\terr = z_erofs_extent_lookback(&m, m.delta[0]);\n\t\tif (err)\n\t\t\tgoto unmap_out;\n\t\tbreak;\n\tdefault:\n\t\terofs_err(inode->i_sb,\n\t\t\t  \"unknown type %u @ offset %llu of nid %llu\",\n\t\t\t  m.type, ofs, vi->nid);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unmap_out;\n\t}\n\tif (m.partialref)\n\t\tmap->m_flags |= EROFS_MAP_PARTIAL_REF;\n\tmap->m_llen = end - map->m_la;\n\n\tif (flags & EROFS_GET_BLOCKS_FINDTAIL) {\n\t\tvi->z_tailextent_headlcn = m.lcn;\n\t\t/* for non-compact indexes, fragmentoff is 64 bits */\n\t\tif (fragment && vi->datalayout == EROFS_INODE_COMPRESSED_FULL)\n\t\t\tvi->z_fragmentoff |= (u64)m.pblk << 32;\n\t}\n\tif (ztailpacking && m.lcn == vi->z_tailextent_headlcn) {\n\t\tmap->m_flags |= EROFS_MAP_META;\n\t\tmap->m_pa = vi->z_idataoff;\n\t\tmap->m_plen = vi->z_idata_size;\n\t} else if (fragment && m.lcn == vi->z_tailextent_headlcn) {\n\t\tmap->m_flags |= EROFS_MAP_FRAGMENT;\n\t} else {\n\t\tmap->m_pa = erofs_pos(inode->i_sb, m.pblk);\n\t\terr = z_erofs_get_extent_compressedlen(&m, initial_lcn);\n\t\tif (err)\n\t\t\tgoto unmap_out;\n\t}\n\n\tif (m.headtype == Z_EROFS_LCLUSTER_TYPE_PLAIN) {\n\t\tif (map->m_llen > map->m_plen) {\n\t\t\tDBG_BUGON(1);\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto unmap_out;\n\t\t}\n\t\tafmt = vi->z_advise & Z_EROFS_ADVISE_INTERLACED_PCLUSTER ?\n\t\t\tZ_EROFS_COMPRESSION_INTERLACED :\n\t\t\tZ_EROFS_COMPRESSION_SHIFTED;\n\t} else {\n\t\tafmt = m.headtype == Z_EROFS_LCLUSTER_TYPE_HEAD2 ?\n\t\t\tvi->z_algorithmtype[1] : vi->z_algorithmtype[0];\n\t\tif (!(EROFS_I_SB(inode)->available_compr_algs & (1 << afmt))) {\n\t\t\terofs_err(inode->i_sb, \"inconsistent algorithmtype %u for nid %llu\",\n\t\t\t\t  afmt, vi->nid);\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto unmap_out;\n\t\t}\n\t}\n\tmap->m_algorithmformat = afmt;\n\n\tif ((flags & EROFS_GET_BLOCKS_FIEMAP) ||\n\t    ((flags & EROFS_GET_BLOCKS_READMORE) &&\n\t     (map->m_algorithmformat == Z_EROFS_COMPRESSION_LZMA ||\n\t      map->m_algorithmformat == Z_EROFS_COMPRESSION_DEFLATE) &&\n\t      map->m_llen >= i_blocksize(inode))) {\n\t\terr = z_erofs_get_extent_decompressedlen(&m);\n\t\tif (!err)\n\t\t\tmap->m_flags |= EROFS_MAP_FULL_MAPPED;\n\t}\n\nunmap_out:\n\terofs_unmap_metabuf(&m.map->buf);\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-26590"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/soc/qcom/pmic_glink.c",
      "func_name": "pmic_glink_send",
      "func_body": "int pmic_glink_send(struct pmic_glink_client *client, void *data, size_t len)\n{\n\tstruct pmic_glink *pg = client->pg;\n\tint ret;\n\n\tmutex_lock(&pg->state_lock);\n\tif (!pg->ept)\n\t\tret = -ECONNRESET;\n\telse\n\t\tret = rpmsg_send(pg->ept, data, len);\n\tmutex_unlock(&pg->state_lock);\n\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-46691"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/dc/hwss/dcn30/dcn30_hwseq.c",
      "func_name": "dcn30_apply_idle_power_optimizations",
      "func_body": "bool dcn30_apply_idle_power_optimizations(struct dc *dc, bool enable)\n{\n\tunion dmub_rb_cmd cmd;\n\tuint32_t tmr_delay = 0, tmr_scale = 0;\n\tstruct dc_cursor_attributes cursor_attr = {0};\n\tbool cursor_cache_enable = false;\n\tstruct dc_stream_state *stream = NULL;\n\tstruct dc_plane_state *plane = NULL;\n\n\tif (!dc->ctx->dmub_srv)\n\t\treturn false;\n\n\tif (enable) {\n\t\tif (dc->current_state) {\n\t\t\tint i;\n\n\t\t\t/* First, check no-memory-requests case */\n\t\t\tfor (i = 0; i < dc->current_state->stream_count; i++) {\n\t\t\t\tif (dc->current_state->stream_status[i].plane_count)\n\t\t\t\t\t/* Fail eligibility on a visible stream */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i == dc->current_state->stream_count) {\n\t\t\t\t/* Enable no-memory-requests case */\n\t\t\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\t\t\tcmd.mall.header.type = DMUB_CMD__MALL;\n\t\t\t\tcmd.mall.header.sub_type = DMUB_CMD__MALL_ACTION_NO_DF_REQ;\n\t\t\t\tcmd.mall.header.payload_bytes = sizeof(cmd.mall) - sizeof(cmd.mall.header);\n\n\t\t\t\tdc_wake_and_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_NO_WAIT);\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tstream = dc->current_state->streams[0];\n\t\t\tplane = (stream ? dc->current_state->stream_status[0].plane_states[0] : NULL);\n\n\t\t\tif (!stream || !plane)\n\t\t\t\treturn false;\n\n\t\t\tif (stream && plane) {\n\t\t\t\tcursor_cache_enable = stream->cursor_position.enable &&\n\t\t\t\t\t\tplane->address.grph.cursor_cache_addr.quad_part;\n\t\t\t\tcursor_attr = stream->cursor_attributes;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Second, check MALL eligibility\n\t\t\t *\n\t\t\t * single display only, single surface only, 8 and 16 bit formats only, no VM,\n\t\t\t * do not use MALL for displays that support PSR as they use D0i3.2 in DMCUB FW\n\t\t\t *\n\t\t\t * TODO: When we implement multi-display, PSR displays will be allowed if there is\n\t\t\t * a non-PSR display present, since in that case we can't do D0i3.2\n\t\t\t */\n\t\t\tif (dc->current_state->stream_count == 1 &&\n\t\t\t\t\tstream->link->psr_settings.psr_version == DC_PSR_VERSION_UNSUPPORTED &&\n\t\t\t\t\tdc->current_state->stream_status[0].plane_count == 1 &&\n\t\t\t\t\tplane->format <= SURFACE_PIXEL_FORMAT_GRPH_ABGR16161616F &&\n\t\t\t\t\tplane->format >= SURFACE_PIXEL_FORMAT_GRPH_ARGB8888 &&\n\t\t\t\t\tplane->address.page_table_base.quad_part == 0 &&\n\t\t\t\t\tdc->hwss.does_plane_fit_in_mall &&\n\t\t\t\t\tdc->hwss.does_plane_fit_in_mall(dc, plane->plane_size.surface_pitch,\n\t\t\t\t\t\t\tplane->plane_size.surface_size.height, plane->format,\n\t\t\t\t\t\t\tcursor_cache_enable ? &cursor_attr : NULL)) {\n\t\t\t\tunsigned int v_total = stream->adjust.v_total_max ?\n\t\t\t\t\t\tstream->adjust.v_total_max : stream->timing.v_total;\n\t\t\t\tunsigned int refresh_hz = div_u64((unsigned long long) stream->timing.pix_clk_100hz *\n\t\t\t\t\t\t100LL, (v_total * stream->timing.h_total));\n\n\t\t\t\t/*\n\t\t\t\t * one frame time in microsec:\n\t\t\t\t * Delay_Us = 1000000 / refresh\n\t\t\t\t * dynamic_delay_us = 1000000 / refresh + 2 * stutter_period\n\t\t\t\t *\n\t\t\t\t * one frame time modified by 'additional timer percent' (p):\n\t\t\t\t * Delay_Us_modified = dynamic_delay_us + dynamic_delay_us * p / 100\n\t\t\t\t *                   = dynamic_delay_us * (1 + p / 100)\n\t\t\t\t *                   = (1000000 / refresh + 2 * stutter_period) * (100 + p) / 100\n\t\t\t\t *                   = (1000000 + 2 * stutter_period * refresh) * (100 + p) / (100 * refresh)\n\t\t\t\t *\n\t\t\t\t * formula for timer duration based on parameters, from regspec:\n\t\t\t\t * dynamic_delay_us = 65.28 * (64 + MallFrameCacheTmrDly) * 2^MallFrameCacheTmrScale\n\t\t\t\t *\n\t\t\t\t * dynamic_delay_us / 65.28 = (64 + MallFrameCacheTmrDly) * 2^MallFrameCacheTmrScale\n\t\t\t\t * (dynamic_delay_us / 65.28) / 2^MallFrameCacheTmrScale = 64 + MallFrameCacheTmrDly\n\t\t\t\t * MallFrameCacheTmrDly = ((dynamic_delay_us / 65.28) / 2^MallFrameCacheTmrScale) - 64\n\t\t\t\t *                      = (1000000 + 2 * stutter_period * refresh) * (100 + p) / (100 * refresh) / 65.28 / 2^MallFrameCacheTmrScale - 64\n\t\t\t\t *                      = (1000000 + 2 * stutter_period * refresh) * (100 + p) / (refresh * 6528 * 2^MallFrameCacheTmrScale) - 64\n\t\t\t\t *\n\t\t\t\t * need to round up the result of the division before the subtraction\n\t\t\t\t */\n\t\t\t\tunsigned int denom = refresh_hz * 6528;\n\t\t\t\tunsigned int stutter_period = dc->current_state->perf_params.stutter_period_us;\n\n\t\t\t\ttmr_delay = div_u64(((1000000LL + 2 * stutter_period * refresh_hz) *\n\t\t\t\t\t\t(100LL + dc->debug.mall_additional_timer_percent) + denom - 1),\n\t\t\t\t\t\tdenom) - 64LL;\n\n\t\t\t\t/* In some cases the stutter period is really big (tiny modes) in these\n\t\t\t\t * cases MALL cant be enabled, So skip these cases to avoid a ASSERT()\n\t\t\t\t *\n\t\t\t\t * We can check if stutter_period is more than 1/10th the frame time to\n\t\t\t\t * consider if we can actually meet the range of hysteresis timer\n\t\t\t\t */\n\t\t\t\tif (stutter_period > 100000/refresh_hz)\n\t\t\t\t\treturn false;\n\n\t\t\t\t/* scale should be increased until it fits into 6 bits */\n\t\t\t\twhile (tmr_delay & ~0x3F) {\n\t\t\t\t\ttmr_scale++;\n\n\t\t\t\t\tif (tmr_scale > 3) {\n\t\t\t\t\t\t/* Delay exceeds range of hysteresis timer */\n\t\t\t\t\t\tASSERT(false);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tdenom *= 2;\n\t\t\t\t\ttmr_delay = div_u64(((1000000LL + 2 * stutter_period * refresh_hz) *\n\t\t\t\t\t\t\t(100LL + dc->debug.mall_additional_timer_percent) + denom - 1),\n\t\t\t\t\t\t\tdenom) - 64LL;\n\t\t\t\t}\n\n\t\t\t\t/* Copy HW cursor */\n\t\t\t\tif (cursor_cache_enable) {\n\t\t\t\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\t\t\t\tcmd.mall.header.type = DMUB_CMD__MALL;\n\t\t\t\t\tcmd.mall.header.sub_type = DMUB_CMD__MALL_ACTION_COPY_CURSOR;\n\t\t\t\t\tcmd.mall.header.payload_bytes =\n\t\t\t\t\t\t\tsizeof(cmd.mall) - sizeof(cmd.mall.header);\n\n\t\t\t\t\tswitch (cursor_attr.color_format) {\n\t\t\t\t\tcase CURSOR_MODE_MONO:\n\t\t\t\t\t\tcmd.mall.cursor_bpp = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CURSOR_MODE_COLOR_1BIT_AND:\n\t\t\t\t\tcase CURSOR_MODE_COLOR_PRE_MULTIPLIED_ALPHA:\n\t\t\t\t\tcase CURSOR_MODE_COLOR_UN_PRE_MULTIPLIED_ALPHA:\n\t\t\t\t\t\tcmd.mall.cursor_bpp = 32;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CURSOR_MODE_COLOR_64BIT_FP_PRE_MULTIPLIED:\n\t\t\t\t\tcase CURSOR_MODE_COLOR_64BIT_FP_UN_PRE_MULTIPLIED:\n\t\t\t\t\t\tcmd.mall.cursor_bpp = 64;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcmd.mall.cursor_copy_src.quad_part = cursor_attr.address.quad_part;\n\t\t\t\t\tcmd.mall.cursor_copy_dst.quad_part =\n\t\t\t\t\t\t\t(plane->address.grph.cursor_cache_addr.quad_part + 2047) & ~2047;\n\t\t\t\t\tcmd.mall.cursor_width = cursor_attr.width;\n\t\t\t\t\tcmd.mall.cursor_height = cursor_attr.height;\n\t\t\t\t\tcmd.mall.cursor_pitch = cursor_attr.pitch;\n\n\t\t\t\t\tdc_wake_and_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\t\t\t\t\t/* Use copied cursor, and it's okay to not switch back */\n\t\t\t\t\tcursor_attr.address.quad_part = cmd.mall.cursor_copy_dst.quad_part;\n\t\t\t\t\tdc_stream_program_cursor_attributes(stream, &cursor_attr);\n\t\t\t\t}\n\n\t\t\t\t/* Enable MALL */\n\t\t\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\t\t\tcmd.mall.header.type = DMUB_CMD__MALL;\n\t\t\t\tcmd.mall.header.sub_type = DMUB_CMD__MALL_ACTION_ALLOW;\n\t\t\t\tcmd.mall.header.payload_bytes = sizeof(cmd.mall) - sizeof(cmd.mall.header);\n\t\t\t\tcmd.mall.tmr_delay = tmr_delay;\n\t\t\t\tcmd.mall.tmr_scale = tmr_scale;\n\t\t\t\tcmd.mall.debug_bits = dc->debug.mall_error_as_fatal;\n\n\t\t\t\tdc_wake_and_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_NO_WAIT);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t/* No applicable optimizations */\n\t\treturn false;\n\t}\n\n\t/* Disable MALL */\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.mall.header.type = DMUB_CMD__MALL;\n\tcmd.mall.header.sub_type = DMUB_CMD__MALL_ACTION_DISALLOW;\n\tcmd.mall.header.payload_bytes =\n\t\tsizeof(cmd.mall) - sizeof(cmd.mall.header);\n\n\tdc_wake_and_execute_dmub_cmd(dc->ctx, &cmd, DM_DMUB_WAIT_TYPE_WAIT);\n\n\treturn true;\n}\n",
      "cve_list": [
        "CVE-2024-43904"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/bridge/tc358767.c",
      "func_name": "tc_irq_handler",
      "func_body": "static irqreturn_t tc_irq_handler(int irq, void *arg)\n{\n\tstruct tc_data *tc = arg;\n\tu32 val;\n\tint r;\n\n\tr = regmap_read(tc->regmap, INTSTS_G, &val);\n\tif (r)\n\t\treturn IRQ_NONE;\n\n\tif (!val)\n\t\treturn IRQ_NONE;\n\n\tif (val & INT_SYSERR) {\n\t\tu32 stat = 0;\n\n\t\tregmap_read(tc->regmap, SYSSTAT, &stat);\n\n\t\tdev_err(tc->dev, \"syserr %x\\n\", stat);\n\t}\n\n\tif (tc->hpd_pin >= 0 && tc->bridge.dev && tc->aux.drm_dev) {\n\t\t/*\n\t\t * H is triggered when the GPIO goes high.\n\t\t *\n\t\t * LC is triggered when the GPIO goes low and stays low for\n\t\t * the duration of LCNT\n\t\t */\n\t\tbool h = val & INT_GPIO_H(tc->hpd_pin);\n\t\tbool lc = val & INT_GPIO_LC(tc->hpd_pin);\n\n\t\tdev_dbg(tc->dev, \"GPIO%d: %s %s\\n\", tc->hpd_pin,\n\t\t\th ? \"H\" : \"\", lc ? \"LC\" : \"\");\n\n\t\tif (h || lc)\n\t\t\tdrm_kms_helper_hotplug_event(tc->bridge.dev);\n\t}\n\n\tregmap_write(tc->regmap, INTSTS_G, val);\n\n\treturn IRQ_HANDLED;\n}\n",
      "cve_list": [
        "CVE-2024-46810"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/mellanox/mlx5/core/en_accel/ipsec_fs.c",
      "func_name": "rx_create",
      "func_body": "static int rx_create(struct mlx5_core_dev *mdev, struct mlx5e_ipsec *ipsec,\n\t\t     struct mlx5e_ipsec_rx *rx, u32 family)\n{\n\tstruct mlx5e_ipsec_rx_create_attr attr;\n\tstruct mlx5_flow_destination dest[2];\n\tstruct mlx5_flow_table *ft;\n\tu32 flags = 0;\n\tint err;\n\n\tipsec_rx_create_attr_set(ipsec, rx, family, &attr);\n\n\terr = ipsec_rx_status_pass_dest_get(ipsec, rx, &attr, &dest[0]);\n\tif (err)\n\t\treturn err;\n\n\tft = ipsec_ft_create(attr.ns, attr.status_level, attr.prio, 3, 0);\n\tif (IS_ERR(ft)) {\n\t\terr = PTR_ERR(ft);\n\t\tgoto err_fs_ft_status;\n\t}\n\trx->ft.status = ft;\n\n\tdest[1].type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;\n\tdest[1].counter_id = mlx5_fc_id(rx->fc->cnt);\n\terr = mlx5_ipsec_rx_status_create(ipsec, rx, dest);\n\tif (err)\n\t\tgoto err_add;\n\n\t/* Create FT */\n\tif (mlx5_ipsec_device_caps(mdev) & MLX5_IPSEC_CAP_TUNNEL)\n\t\trx->allow_tunnel_mode = mlx5_eswitch_block_encap(mdev);\n\tif (rx->allow_tunnel_mode)\n\t\tflags = MLX5_FLOW_TABLE_TUNNEL_EN_REFORMAT;\n\tft = ipsec_ft_create(attr.ns, attr.sa_level, attr.prio, 2, flags);\n\tif (IS_ERR(ft)) {\n\t\terr = PTR_ERR(ft);\n\t\tgoto err_fs_ft;\n\t}\n\trx->ft.sa = ft;\n\n\terr = ipsec_miss_create(mdev, rx->ft.sa, &rx->sa, dest);\n\tif (err)\n\t\tgoto err_fs;\n\n\tif (mlx5_ipsec_device_caps(mdev) & MLX5_IPSEC_CAP_PRIO) {\n\t\trx->chains = ipsec_chains_create(mdev, rx->ft.sa,\n\t\t\t\t\t\t attr.chains_ns,\n\t\t\t\t\t\t attr.prio,\n\t\t\t\t\t\t attr.pol_level,\n\t\t\t\t\t\t &rx->ft.pol);\n\t\tif (IS_ERR(rx->chains)) {\n\t\t\terr = PTR_ERR(rx->chains);\n\t\t\tgoto err_pol_ft;\n\t\t}\n\n\t\tgoto connect;\n\t}\n\n\tft = ipsec_ft_create(attr.ns, attr.pol_level, attr.prio, 2, 0);\n\tif (IS_ERR(ft)) {\n\t\terr = PTR_ERR(ft);\n\t\tgoto err_pol_ft;\n\t}\n\trx->ft.pol = ft;\n\tmemset(dest, 0x00, 2 * sizeof(*dest));\n\tdest[0].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tdest[0].ft = rx->ft.sa;\n\terr = ipsec_miss_create(mdev, rx->ft.pol, &rx->pol, dest);\n\tif (err)\n\t\tgoto err_pol_miss;\n\nconnect:\n\t/* connect */\n\tif (rx != ipsec->rx_esw)\n\t\tipsec_rx_ft_connect(ipsec, rx, &attr);\n\treturn 0;\n\nerr_pol_miss:\n\tmlx5_destroy_flow_table(rx->ft.pol);\nerr_pol_ft:\n\tmlx5_del_flow_rules(rx->sa.rule);\n\tmlx5_destroy_flow_group(rx->sa.group);\nerr_fs:\n\tmlx5_destroy_flow_table(rx->ft.sa);\nerr_fs_ft:\n\tif (rx->allow_tunnel_mode)\n\t\tmlx5_eswitch_unblock_encap(mdev);\n\tmlx5_ipsec_rx_status_destroy(ipsec, rx);\nerr_add:\n\tmlx5_destroy_flow_table(rx->ft.status);\nerr_fs_ft_status:\n\tmlx5_ipsec_fs_roce_rx_destroy(ipsec->roce, family, mdev);\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-36281"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/mediatek/mtk_eth_soc.c",
      "func_name": "mtk_remove",
      "func_body": "static void mtk_remove(struct platform_device *pdev)\n{\n\tstruct mtk_eth *eth = platform_get_drvdata(pdev);\n\tstruct mtk_mac *mac;\n\tint i;\n\n\t/* stop all devices to make sure that dma is properly shut down */\n\tfor (i = 0; i < MTK_MAX_DEVS; i++) {\n\t\tif (!eth->netdev[i])\n\t\t\tcontinue;\n\t\tmtk_stop(eth->netdev[i]);\n\t\tmac = netdev_priv(eth->netdev[i]);\n\t\tphylink_disconnect_phy(mac->phylink);\n\t}\n\n\tmtk_wed_exit();\n\tmtk_hw_deinit(eth);\n\n\tnetif_napi_del(&eth->tx_napi);\n\tnetif_napi_del(&eth->rx_napi);\n\tmtk_cleanup(eth);\n\tfree_netdev(eth->dummy_dev);\n\tmtk_mdio_cleanup(eth);\n}\n",
      "cve_list": [
        "CVE-2024-42282"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/microsoft/mana/mana_en.c",
      "func_name": "add_adev",
      "func_body": "static int add_adev(struct gdma_dev *gd)\n{\n\tstruct auxiliary_device *adev;\n\tstruct mana_adev *madev;\n\tint ret;\n\n\tmadev = kzalloc(sizeof(*madev), GFP_KERNEL);\n\tif (!madev)\n\t\treturn -ENOMEM;\n\n\tadev = &madev->adev;\n\tret = mana_adev_idx_alloc();\n\tif (ret < 0)\n\t\tgoto idx_fail;\n\tadev->id = ret;\n\n\tadev->name = \"rdma\";\n\tadev->dev.parent = gd->gdma_context->dev;\n\tadev->dev.release = adev_release;\n\tmadev->mdev = gd;\n\n\tret = auxiliary_device_init(adev);\n\tif (ret)\n\t\tgoto init_fail;\n\n\t/* madev is owned by the auxiliary device */\n\tmadev = NULL;\n\tret = auxiliary_device_add(adev);\n\tif (ret)\n\t\tgoto add_fail;\n\n\tgd->adev = adev;\n\treturn 0;\n\nadd_fail:\n\tauxiliary_device_uninit(adev);\n\ninit_fail:\n\tmana_adev_idx_free(adev->id);\n\nidx_fail:\n\tkfree(madev);\n\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-42069"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/base/module.c",
      "func_name": "module_add_driver",
      "func_body": "int module_add_driver(struct module *mod, const struct device_driver *drv)\n{\n\tchar *driver_name;\n\tstruct module_kobject *mk = NULL;\n\tint ret;\n\n\tif (!drv)\n\t\treturn 0;\n\n\tif (mod)\n\t\tmk = &mod->mkobj;\n\telse if (drv->mod_name) {\n\t\tstruct kobject *mkobj;\n\n\t\t/* Lookup built-in module entry in /sys/modules */\n\t\tmkobj = kset_find_obj(module_kset, drv->mod_name);\n\t\tif (mkobj) {\n\t\t\tmk = container_of(mkobj, struct module_kobject, kobj);\n\t\t\t/* remember our module structure */\n\t\t\tdrv->p->mkobj = mk;\n\t\t\t/* kset_find_obj took a reference */\n\t\t\tkobject_put(mkobj);\n\t\t}\n\t}\n\n\tif (!mk)\n\t\treturn 0;\n\n\tret = sysfs_create_link(&drv->p->kobj, &mk->kobj, \"module\");\n\tif (ret)\n\t\treturn ret;\n\n\tdriver_name = make_driver_name(drv);\n\tif (!driver_name) {\n\t\tret = -ENOMEM;\n\t\tgoto out_remove_kobj;\n\t}\n\n\tmodule_create_drivers_dir(mk);\n\tif (!mk->drivers_dir) {\n\t\tret = -EINVAL;\n\t\tgoto out_free_driver_name;\n\t}\n\n\tret = sysfs_create_link(mk->drivers_dir, &drv->p->kobj, driver_name);\n\tif (ret)\n\t\tgoto out_remove_drivers_dir;\n\n\tkfree(driver_name);\n\n\treturn 0;\n\nout_remove_drivers_dir:\n\tsysfs_remove_link(mk->drivers_dir, driver_name);\n\nout_free_driver_name:\n\tkfree(driver_name);\n\nout_remove_kobj:\n\tsysfs_remove_link(&drv->p->kobj, \"module\");\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-47688"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp.c",
      "func_name": "psp_xgmi_reflect_topology_info",
      "func_body": "static void psp_xgmi_reflect_topology_info(struct psp_context *psp,\n\t\t\t\t\tstruct psp_xgmi_node_info node_info)\n{\n\tstruct amdgpu_device *mirror_adev;\n\tstruct amdgpu_hive_info *hive;\n\tuint64_t src_node_id = psp->adev->gmc.xgmi.node_id;\n\tuint64_t dst_node_id = node_info.node_id;\n\tuint8_t dst_num_hops = node_info.num_hops;\n\tuint8_t dst_num_links = node_info.num_links;\n\n\thive = amdgpu_get_xgmi_hive(psp->adev);\n\tif (WARN_ON(!hive))\n\t\treturn;\n\n\tlist_for_each_entry(mirror_adev, &hive->device_list, gmc.xgmi.head) {\n\t\tstruct psp_xgmi_topology_info *mirror_top_info;\n\t\tint j;\n\n\t\tif (mirror_adev->gmc.xgmi.node_id != dst_node_id)\n\t\t\tcontinue;\n\n\t\tmirror_top_info = &mirror_adev->psp.xgmi_context.top_info;\n\t\tfor (j = 0; j < mirror_top_info->num_nodes; j++) {\n\t\t\tif (mirror_top_info->nodes[j].node_id != src_node_id)\n\t\t\t\tcontinue;\n\n\t\t\tmirror_top_info->nodes[j].num_hops = dst_num_hops;\n\t\t\t/*\n\t\t\t * prevent 0 num_links value re-reflection since reflection\n\t\t\t * criteria is based on num_hops (direct or indirect).\n\t\t\t *\n\t\t\t */\n\t\t\tif (dst_num_links)\n\t\t\t\tmirror_top_info->nodes[j].num_links = dst_num_links;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tamdgpu_put_xgmi_hive(hive);\n}\n",
      "cve_list": [
        "CVE-2024-46805"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/pinctrl/pinctrl-single.c",
      "func_name": "pcs_get_function",
      "func_body": "static int pcs_get_function(struct pinctrl_dev *pctldev, unsigned pin,\n\t\t\t    struct pcs_function **func)\n{\n\tstruct pcs_device *pcs = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pin_desc *pdesc = pin_desc_get(pctldev, pin);\n\tconst struct pinctrl_setting_mux *setting;\n\tstruct function_desc *function;\n\tunsigned fselector;\n\n\t/* If pin is not described in DTS & enabled, mux_setting is NULL. */\n\tsetting = pdesc->mux_setting;\n\tif (!setting)\n\t\treturn -ENOTSUPP;\n\tfselector = setting->func;\n\tfunction = pinmux_generic_get_function(pctldev, fselector);\n\tif (!function)\n\t\treturn -EINVAL;\n\t*func = function->data;\n\tif (!(*func)) {\n\t\tdev_err(pcs->dev, \"%s could not find function%i\\n\",\n\t\t\t__func__, fselector);\n\t\treturn -ENOTSUPP;\n\t}\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-46685"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ipv4/netfilter/nf_tproxy_ipv4.c",
      "func_name": "nf_tproxy_laddr4",
      "func_body": "__be32 nf_tproxy_laddr4(struct sk_buff *skb, __be32 user_laddr, __be32 daddr)\n{\n\tconst struct in_ifaddr *ifa;\n\tstruct in_device *indev;\n\t__be32 laddr;\n\n\tif (user_laddr)\n\t\treturn user_laddr;\n\n\tladdr = 0;\n\tindev = __in_dev_get_rcu(skb->dev);\n\tif (!indev)\n\t\treturn daddr;\n\n\tin_dev_for_each_ifa_rcu(ifa, indev) {\n\t\tif (ifa->ifa_flags & IFA_F_SECONDARY)\n\t\t\tcontinue;\n\n\t\tladdr = ifa->ifa_local;\n\t\tbreak;\n\t}\n\n\treturn laddr ? laddr : daddr;\n}\n",
      "cve_list": [
        "CVE-2024-36270"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/intel/ice/ice_lib.c",
      "func_name": "ice_vsi_rebuild",
      "func_body": "int ice_vsi_rebuild(struct ice_vsi *vsi, u32 vsi_flags)\n{\n\tstruct ice_coalesce_stored *coalesce;\n\tint prev_num_q_vectors;\n\tstruct ice_pf *pf;\n\tint ret;\n\n\tif (!vsi)\n\t\treturn -EINVAL;\n\n\tvsi->flags = vsi_flags;\n\tpf = vsi->back;\n\tif (WARN_ON(vsi->type == ICE_VSI_VF && !vsi->vf))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&vsi->xdp_state_lock);\n\n\tret = ice_vsi_realloc_stat_arrays(vsi);\n\tif (ret)\n\t\tgoto unlock;\n\n\tice_vsi_decfg(vsi);\n\tret = ice_vsi_cfg_def(vsi);\n\tif (ret)\n\t\tgoto unlock;\n\n\tcoalesce = kcalloc(vsi->num_q_vectors,\n\t\t\t   sizeof(struct ice_coalesce_stored), GFP_KERNEL);\n\tif (!coalesce) {\n\t\tret = -ENOMEM;\n\t\tgoto decfg;\n\t}\n\n\tprev_num_q_vectors = ice_vsi_rebuild_get_coalesce(vsi, coalesce);\n\n\tret = ice_vsi_cfg_tc_lan(pf, vsi);\n\tif (ret) {\n\t\tif (vsi_flags & ICE_VSI_FLAG_INIT) {\n\t\t\tret = -EIO;\n\t\t\tgoto free_coalesce;\n\t\t}\n\n\t\tret = ice_schedule_reset(pf, ICE_RESET_PFR);\n\t\tgoto free_coalesce;\n\t}\n\n\tice_vsi_rebuild_set_coalesce(vsi, coalesce, prev_num_q_vectors);\n\tclear_bit(ICE_VSI_REBUILD_PENDING, vsi->state);\n\nfree_coalesce:\n\tkfree(coalesce);\ndecfg:\n\tif (ret)\n\t\tice_vsi_decfg(vsi);\nunlock:\n\tmutex_unlock(&vsi->xdp_state_lock);\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-46765"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/intel/ice/ice_main.c",
      "func_name": "ice_prepare_for_reset",
      "func_body": "static void\nice_prepare_for_reset(struct ice_pf *pf, enum ice_reset_req reset_type)\n{\n\tstruct ice_hw *hw = &pf->hw;\n\tstruct ice_vsi *vsi;\n\tstruct ice_vf *vf;\n\tunsigned int bkt;\n\n\tdev_dbg(ice_pf_to_dev(pf), \"reset_type=%d\\n\", reset_type);\n\n\t/* already prepared for reset */\n\tif (test_bit(ICE_PREPARED_FOR_RESET, pf->state))\n\t\treturn;\n\n\tsynchronize_irq(pf->oicr_irq.virq);\n\n\tice_unplug_aux_dev(pf);\n\n\t/* Notify VFs of impending reset */\n\tif (ice_check_sq_alive(hw, &hw->mailboxq))\n\t\tice_vc_notify_reset(pf);\n\n\t/* Disable VFs until reset is completed */\n\tmutex_lock(&pf->vfs.table_lock);\n\tice_for_each_vf(pf, bkt, vf)\n\t\tice_set_vf_state_dis(vf);\n\tmutex_unlock(&pf->vfs.table_lock);\n\n\tif (ice_is_eswitch_mode_switchdev(pf)) {\n\t\tif (reset_type != ICE_RESET_PFR)\n\t\t\tice_clear_sw_switch_recipes(pf);\n\t}\n\n\t/* release ADQ specific HW and SW resources */\n\tvsi = ice_get_main_vsi(pf);\n\tif (!vsi)\n\t\tgoto skip;\n\n\t/* to be on safe side, reset orig_rss_size so that normal flow\n\t * of deciding rss_size can take precedence\n\t */\n\tvsi->orig_rss_size = 0;\n\n\tif (test_bit(ICE_FLAG_TC_MQPRIO, pf->flags)) {\n\t\tif (reset_type == ICE_RESET_PFR) {\n\t\t\tvsi->old_ena_tc = vsi->all_enatc;\n\t\t\tvsi->old_numtc = vsi->all_numtc;\n\t\t} else {\n\t\t\tice_remove_q_channels(vsi, true);\n\n\t\t\t/* for other reset type, do not support channel rebuild\n\t\t\t * hence reset needed info\n\t\t\t */\n\t\t\tvsi->old_ena_tc = 0;\n\t\t\tvsi->all_enatc = 0;\n\t\t\tvsi->old_numtc = 0;\n\t\t\tvsi->all_numtc = 0;\n\t\t\tvsi->req_txq = 0;\n\t\t\tvsi->req_rxq = 0;\n\t\t\tclear_bit(ICE_FLAG_TC_MQPRIO, pf->flags);\n\t\t\tmemset(&vsi->mqprio_qopt, 0, sizeof(vsi->mqprio_qopt));\n\t\t}\n\t}\n\n\tif (vsi->netdev)\n\t\tnetif_device_detach(vsi->netdev);\nskip:\n\n\t/* clear SW filtering DB */\n\tice_clear_hw_tbls(hw);\n\t/* disable the VSIs and their queues that are not already DOWN */\n\tset_bit(ICE_VSI_REBUILD_PENDING, ice_get_main_vsi(pf)->state);\n\tice_pf_dis_all_vsi(pf, false);\n\n\tif (test_bit(ICE_FLAG_PTP_SUPPORTED, pf->flags))\n\t\tice_ptp_prepare_for_reset(pf, reset_type);\n\n\tif (ice_is_feature_supported(pf, ICE_F_GNSS))\n\t\tice_gnss_exit(pf);\n\n\tif (hw->port_info)\n\t\tice_sched_clear_port(hw->port_info);\n\n\tice_shutdown_all_ctrlq(hw, false);\n\n\tset_bit(ICE_PREPARED_FOR_RESET, pf->state);\n}\n",
      "cve_list": [
        "CVE-2024-46765"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/intel/ice/ice_main.c",
      "func_name": "ice_xdp",
      "func_body": "static int ice_xdp(struct net_device *dev, struct netdev_bpf *xdp)\n{\n\tstruct ice_netdev_priv *np = netdev_priv(dev);\n\tstruct ice_vsi *vsi = np->vsi;\n\tint ret;\n\n\tif (vsi->type != ICE_VSI_PF) {\n\t\tNL_SET_ERR_MSG_MOD(xdp->extack, \"XDP can be loaded only on PF VSI\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&vsi->xdp_state_lock);\n\n\tswitch (xdp->command) {\n\tcase XDP_SETUP_PROG:\n\t\tret = ice_xdp_setup_prog(vsi, xdp->prog, xdp->extack);\n\t\tbreak;\n\tcase XDP_SETUP_XSK_POOL:\n\t\tret = ice_xsk_pool_setup(vsi, xdp->xsk.pool, xdp->xsk.queue_id);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&vsi->xdp_state_lock);\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-46765"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/intel/ice/ice_xsk.c",
      "func_name": "ice_xsk_pool_setup",
      "func_body": "int ice_xsk_pool_setup(struct ice_vsi *vsi, struct xsk_buff_pool *pool, u16 qid)\n{\n\tbool if_running, pool_present = !!pool;\n\tint ret = 0, pool_failure = 0;\n\n\tif (qid >= vsi->num_rxq || qid >= vsi->num_txq) {\n\t\tnetdev_err(vsi->netdev, \"Please use queue id in scope of combined queues count\\n\");\n\t\tpool_failure = -EINVAL;\n\t\tgoto failure;\n\t}\n\n\tif_running = !test_bit(ICE_VSI_DOWN, vsi->state) &&\n\t\t     ice_is_xdp_ena_vsi(vsi);\n\n\tif (if_running) {\n\t\tstruct ice_rx_ring *rx_ring = vsi->rx_rings[qid];\n\n\t\tret = ice_qp_dis(vsi, qid);\n\t\tif (ret) {\n\t\t\tnetdev_err(vsi->netdev, \"ice_qp_dis error = %d\\n\", ret);\n\t\t\tgoto xsk_pool_if_up;\n\t\t}\n\n\t\tret = ice_realloc_rx_xdp_bufs(rx_ring, pool_present);\n\t\tif (ret)\n\t\t\tgoto xsk_pool_if_up;\n\t}\n\n\tpool_failure = pool_present ? ice_xsk_pool_enable(vsi, pool, qid) :\n\t\t\t\t      ice_xsk_pool_disable(vsi, qid);\n\nxsk_pool_if_up:\n\tif (if_running) {\n\t\tret = ice_qp_ena(vsi, qid);\n\t\tif (!ret && pool_present)\n\t\t\tnapi_schedule(&vsi->rx_rings[qid]->xdp_ring->q_vector->napi);\n\t\telse if (ret)\n\t\t\tnetdev_err(vsi->netdev, \"ice_qp_ena error = %d\\n\", ret);\n\t}\n\nfailure:\n\tif (pool_failure) {\n\t\tnetdev_err(vsi->netdev, \"Could not %sable buffer pool, error = %d\\n\",\n\t\t\t   pool_present ? \"en\" : \"dis\", pool_failure);\n\t\treturn pool_failure;\n\t}\n\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-46765"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/bluetooth/rfcomm/core.c",
      "func_name": "rfcomm_process_rx",
      "func_body": "static struct rfcomm_session *rfcomm_process_rx(struct rfcomm_session *s)\n{\n\tstruct socket *sock = s->sock;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"session %p state %ld qlen %d\", s, s->state, skb_queue_len(&sk->sk_receive_queue));\n\n\t/* Get data directly from socket receive queue without copying it. */\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue))) {\n\t\tskb_orphan(skb);\n\t\tif (!skb_linearize(skb) && sk->sk_state != BT_CLOSED) {\n\t\t\ts = rfcomm_recv_frame(s, skb);\n\t\t\tif (!s)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\n\tif (s && (sk->sk_state == BT_CLOSED))\n\t\ts = rfcomm_session_close(s, sk->sk_err);\n\n\treturn s;\n}\n",
      "cve_list": [
        "CVE-2024-26903"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/dc/core/dc_resource.c",
      "func_name": "dc_validate_stream",
      "func_body": "enum dc_status dc_validate_stream(struct dc *dc, struct dc_stream_state *stream)\n{\n\tif (dc == NULL || stream == NULL)\n\t\treturn DC_ERROR_UNEXPECTED;\n\n\tstruct dc_link *link = stream->link;\n\tstruct timing_generator *tg = dc->res_pool->timing_generators[0];\n\tenum dc_status res = DC_OK;\n\n\tcalculate_phy_pix_clks(stream);\n\n\tif (!tg->funcs->validate_timing(tg, &stream->timing))\n\t\tres = DC_FAIL_CONTROLLER_VALIDATE;\n\n\tif (res == DC_OK) {\n\t\tif (link->ep_type == DISPLAY_ENDPOINT_PHY &&\n\t\t\t\t!link->link_enc->funcs->validate_output_with_stream(\n\t\t\t\t\t\tlink->link_enc, stream))\n\t\t\tres = DC_FAIL_ENC_VALIDATE;\n\t}\n\n\t/* TODO: validate audio ASIC caps, encoder */\n\n\tif (res == DC_OK)\n\t\tres = dc->link_srv->validate_mode_timing(stream,\n\t\t      link,\n\t\t      &stream->timing);\n\n\treturn res;\n}\n",
      "cve_list": [
        "CVE-2024-46802"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/cxl/core/region.c",
      "func_name": "__cxl_dpa_to_region",
      "func_body": "static int __cxl_dpa_to_region(struct device *dev, void *arg)\n{\n\tstruct cxl_dpa_to_region_context *ctx = arg;\n\tstruct cxl_endpoint_decoder *cxled;\n\tstruct cxl_region *cxlr;\n\tu64 dpa = ctx->dpa;\n\n\tif (!is_endpoint_decoder(dev))\n\t\treturn 0;\n\n\tcxled = to_cxl_endpoint_decoder(dev);\n\tif (!cxled || !cxled->dpa_res || !resource_size(cxled->dpa_res))\n\t\treturn 0;\n\n\tif (dpa > cxled->dpa_res->end || dpa < cxled->dpa_res->start)\n\t\treturn 0;\n\n\t/*\n\t * Stop the region search (return 1) when an endpoint mapping is\n\t * found. The region may not be fully constructed so offering\n\t * the cxlr in the context structure is not guaranteed.\n\t */\n\tcxlr = cxled->cxld.region;\n\tif (cxlr)\n\t\tdev_dbg(dev, \"dpa:0x%llx mapped in region:%s\\n\", dpa,\n\t\t\tdev_name(&cxlr->dev));\n\telse\n\t\tdev_dbg(dev, \"dpa:0x%llx mapped in endpoint:%s\\n\", dpa,\n\t\t\tdev_name(dev));\n\n\tctx->cxlr = cxlr;\n\n\treturn 1;\n}\n",
      "cve_list": [
        "CVE-2024-41084"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/spi/spi-intel.c",
      "func_name": "intel_spi_populate_chip",
      "func_body": "static int intel_spi_populate_chip(struct intel_spi *ispi)\n{\n\tstruct flash_platform_data *pdata;\n\tstruct mtd_partition *parts;\n\tstruct spi_board_info chip;\n\tint ret;\n\n\tret = intel_spi_read_desc(ispi);\n\tif (ret)\n\t\treturn ret;\n\n\tpdata = devm_kzalloc(ispi->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tpdata->nr_parts = 1;\n\tpdata->parts = devm_kcalloc(ispi->dev, pdata->nr_parts,\n\t\t\t\t    sizeof(*pdata->parts), GFP_KERNEL);\n\tif (!pdata->parts)\n\t\treturn -ENOMEM;\n\n\tintel_spi_fill_partition(ispi, pdata->parts);\n\n\tmemset(&chip, 0, sizeof(chip));\n\tsnprintf(chip.modalias, 8, \"spi-nor\");\n\tchip.platform_data = pdata;\n\n\tif (!spi_new_device(ispi->host, &chip))\n\t\treturn -ENODEV;\n\n\t/* Add the second chip if present */\n\tif (ispi->host->num_chipselect < 2)\n\t\treturn 0;\n\n\tpdata = devm_kzalloc(ispi->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tpdata->name = devm_kasprintf(ispi->dev, GFP_KERNEL, \"%s-chip1\",\n\t\t\t\t     dev_name(ispi->dev));\n\tif (!pdata->name)\n\t\treturn -ENOMEM;\n\n\tpdata->nr_parts = 1;\n\tparts = devm_kcalloc(ispi->dev, pdata->nr_parts, sizeof(*parts),\n\t\t\t     GFP_KERNEL);\n\tif (!parts)\n\t\treturn -ENOMEM;\n\n\tparts[0].size = MTDPART_SIZ_FULL;\n\tparts[0].name = \"BIOS1\";\n\tpdata->parts = parts;\n\n\tchip.platform_data = pdata;\n\tchip.chip_select = 1;\n\n\tif (!spi_new_device(ispi->host, &chip))\n\t\treturn -ENODEV;\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-46769"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/f2fs/file.c",
      "func_name": "f2fs_file_open",
      "func_body": "static int f2fs_file_open(struct inode *inode, struct file *filp)\n{\n\tint err = fscrypt_file_open(inode, filp);\n\n\tif (err)\n\t\treturn err;\n\n\tif (!f2fs_is_compress_backend_ready(inode))\n\t\treturn -EOPNOTSUPP;\n\n\terr = fsverity_file_open(inode, filp);\n\tif (err)\n\t\treturn err;\n\n\tfilp->f_mode |= FMODE_NOWAIT;\n\tfilp->f_mode |= FMODE_CAN_ODIRECT;\n\n\terr = dquot_file_open(inode, filp);\n\tif (err)\n\t\treturn err;\n\n\treturn finish_preallocate_blocks(inode);\n}\n",
      "cve_list": [
        "CVE-2024-43859"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/f2fs/inode.c",
      "func_name": "f2fs_iget",
      "func_body": "struct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\tif (is_meta_ino(sbi, ino)) {\n\t\t\tf2fs_err(sbi, \"inaccessible inode: %lu, run fsck to repair\", ino);\n\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\t\tret = -EFSCORRUPTED;\n\t\t\ttrace_f2fs_iget_exit(inode, ret);\n\t\t\tiput(inode);\n\t\t\tf2fs_handle_error(sbi, ERROR_CORRUPTED_INODE);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\n\tif (is_meta_ino(sbi, ino))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\t} else if (ino == F2FS_COMPRESS_INO(sbi)) {\n// #ifdef CONFIG_F2FS_FS_COMPRESSION\n\t\tinode->i_mapping->a_ops = &f2fs_compress_aops;\n\t\t/*\n\t\t * generic_error_remove_folio only truncates pages of regular\n\t\t * inode\n\t\t */\n\t\tinode->i_mode |= S_IFREG;\n#endif\n\t\tmapping_set_gfp_mask(inode->i_mapping,\n\t\t\tGFP_NOFS | __GFP_HIGHMEM | __GFP_MOVABLE);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_NOFS);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (file_is_encrypt(inode))\n\t\t\tinode->i_op = &f2fs_encrypted_symlink_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode_nohighmem(inode);\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tf2fs_set_inode_flags(inode);\n\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tf2fs_inode_synced(inode);\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}\n",
      "cve_list": [
        "CVE-2024-43859"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c",
      "func_name": "brcmf_pmksa_v3_op",
      "func_body": "static s32\nbrcmf_pmksa_v3_op(struct brcmf_if *ifp, struct cfg80211_pmksa *pmksa,\n\t\t  bool alive)\n{\n\tstruct brcmf_pmk_op_v3_le *pmk_op;\n\tint length = offsetof(struct brcmf_pmk_op_v3_le, pmk);\n\tint ret;\n\n\tpmk_op = kzalloc(sizeof(*pmk_op), GFP_KERNEL);\n\tif (!pmk_op)\n\t\treturn -ENOMEM;\n\n\tpmk_op->version = cpu_to_le16(BRCMF_PMKSA_VER_3);\n\n\tif (!pmksa) {\n\t\t/* Flush operation, operate on entire list */\n\t\tpmk_op->count = cpu_to_le16(0);\n\t} else {\n\t\t/* Single PMK operation */\n\t\tpmk_op->count = cpu_to_le16(1);\n\t\tlength += sizeof(struct brcmf_pmksa_v3);\n\t\tif (pmksa->bssid)\n\t\t\tmemcpy(pmk_op->pmk[0].bssid, pmksa->bssid, ETH_ALEN);\n\t\tif (pmksa->pmkid) {\n\t\t\tmemcpy(pmk_op->pmk[0].pmkid, pmksa->pmkid, WLAN_PMKID_LEN);\n\t\t\tpmk_op->pmk[0].pmkid_len = WLAN_PMKID_LEN;\n\t\t}\n\t\tif (pmksa->ssid && pmksa->ssid_len) {\n\t\t\tmemcpy(pmk_op->pmk[0].ssid.SSID, pmksa->ssid, pmksa->ssid_len);\n\t\t\tpmk_op->pmk[0].ssid.SSID_len = pmksa->ssid_len;\n\t\t}\n\t\tpmk_op->pmk[0].time_left = cpu_to_le32(alive ? BRCMF_PMKSA_NO_EXPIRY : 0);\n\t}\n\n\tpmk_op->length = cpu_to_le16(length);\n\n\tret = brcmf_fil_iovar_data_set(ifp, \"pmkid_info\", pmk_op, sizeof(*pmk_op));\n\tkfree(pmk_op);\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-46672"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/gma500/psb_intel_lvds.c",
      "func_name": "psb_intel_lvds_get_modes",
      "func_body": "static int psb_intel_lvds_get_modes(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct psb_intel_mode_device *mode_dev = &dev_priv->mode_dev;\n\tint ret = 0;\n\n\tif (!IS_MRST(dev))\n\t\tret = psb_intel_ddc_get_modes(connector, connector->ddc);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (mode_dev->panel_fixed_mode != NULL) {\n\t\tstruct drm_display_mode *mode =\n\t\t    drm_mode_duplicate(dev, mode_dev->panel_fixed_mode);\n\t\tif (!mode)\n\t\t\treturn 0;\n\n\t\tdrm_mode_probed_add(connector, mode);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-42309"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ipv6/route.c",
      "func_name": "fib6_nh_init",
      "func_body": "int fib6_nh_init(struct net *net, struct fib6_nh *fib6_nh,\n\t\t struct fib6_config *cfg, gfp_t gfp_flags,\n\t\t struct netlink_ext_ack *extack)\n{\n\tnetdevice_tracker *dev_tracker = &fib6_nh->fib_nh_dev_tracker;\n\tstruct net_device *dev = NULL;\n\tstruct inet6_dev *idev = NULL;\n\tint addr_type;\n\tint err;\n\n\tfib6_nh->fib_nh_family = AF_INET6;\n// #ifdef CONFIG_IPV6_ROUTER_PREF\n\tfib6_nh->last_probe = jiffies;\n#endif\n\tif (cfg->fc_is_fdb) {\n\t\tfib6_nh->fib_nh_gw6 = cfg->fc_gateway;\n\t\tfib6_nh->fib_nh_gw_family = AF_INET6;\n\t\treturn 0;\n\t}\n\n\terr = -ENODEV;\n\tif (cfg->fc_ifindex) {\n\t\tdev = netdev_get_by_index(net, cfg->fc_ifindex,\n\t\t\t\t\t  dev_tracker, gfp_flags);\n\t\tif (!dev)\n\t\t\tgoto out;\n\t\tidev = in6_dev_get(dev);\n\t\tif (!idev)\n\t\t\tgoto out;\n\t}\n\n\tif (cfg->fc_flags & RTNH_F_ONLINK) {\n\t\tif (!dev) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Nexthop device required for onlink\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!(dev->flags & IFF_UP)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop device is not up\");\n\t\t\terr = -ENETDOWN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfib6_nh->fib_nh_flags |= RTNH_F_ONLINK;\n\t}\n\n\tfib6_nh->fib_nh_weight = 1;\n\n\t/* We cannot add true routes via loopback here,\n\t * they would result in kernel looping; promote them to reject routes\n\t */\n\taddr_type = ipv6_addr_type(&cfg->fc_dst);\n\tif (fib6_is_reject(cfg->fc_flags, dev, addr_type)) {\n\t\t/* hold loopback dev/idev if we haven't done so. */\n\t\tif (dev != net->loopback_dev) {\n\t\t\tif (dev) {\n\t\t\t\tnetdev_put(dev, dev_tracker);\n\t\t\t\tin6_dev_put(idev);\n\t\t\t}\n\t\t\tdev = net->loopback_dev;\n\t\t\tnetdev_hold(dev, dev_tracker, gfp_flags);\n\t\t\tidev = in6_dev_get(dev);\n\t\t\tif (!idev) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tgoto pcpu_alloc;\n\t}\n\n\tif (cfg->fc_flags & RTF_GATEWAY) {\n\t\terr = ip6_validate_gw(net, cfg, &dev, dev_tracker,\n\t\t\t\t      &idev, extack);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tfib6_nh->fib_nh_gw6 = cfg->fc_gateway;\n\t\tfib6_nh->fib_nh_gw_family = AF_INET6;\n\t}\n\n\terr = -ENODEV;\n\tif (!dev)\n\t\tgoto out;\n\n\tif (!idev || idev->cnf.disable_ipv6) {\n\t\tNL_SET_ERR_MSG(extack, \"IPv6 is disabled on nexthop device\");\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (!(dev->flags & IFF_UP) && !cfg->fc_ignore_dev_down) {\n\t\tNL_SET_ERR_MSG(extack, \"Nexthop device is not up\");\n\t\terr = -ENETDOWN;\n\t\tgoto out;\n\t}\n\n\tif (!(cfg->fc_flags & (RTF_LOCAL | RTF_ANYCAST)) &&\n\t    !netif_carrier_ok(dev))\n\t\tfib6_nh->fib_nh_flags |= RTNH_F_LINKDOWN;\n\n\terr = fib_nh_common_init(net, &fib6_nh->nh_common, cfg->fc_encap,\n\t\t\t\t cfg->fc_encap_type, cfg, gfp_flags, extack);\n\tif (err)\n\t\tgoto out;\n\npcpu_alloc:\n\tfib6_nh->rt6i_pcpu = alloc_percpu_gfp(struct rt6_info *, gfp_flags);\n\tif (!fib6_nh->rt6i_pcpu) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfib6_nh->fib_nh_dev = dev;\n\tfib6_nh->fib_nh_oif = dev->ifindex;\n\terr = 0;\nout:\n\tif (idev)\n\t\tin6_dev_put(idev);\n\n\tif (err) {\n\t\tlwtstate_put(fib6_nh->fib_nh_lws);\n\t\tfib6_nh->fib_nh_lws = NULL;\n\t\tnetdev_put(dev, dev_tracker);\n\t}\n\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-40961"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/remoteproc/imx_rproc.c",
      "func_name": "imx_rproc_addr_init",
      "func_body": "static int imx_rproc_addr_init(struct imx_rproc *priv,\n\t\t\t       struct platform_device *pdev)\n{\n\tconst struct imx_rproc_dcfg *dcfg = priv->dcfg;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tint a, b = 0, err, nph;\n\n\t/* remap required addresses */\n\tfor (a = 0; a < dcfg->att_size; a++) {\n\t\tconst struct imx_rproc_att *att = &dcfg->att[a];\n\n\t\tif (!(att->flags & ATT_OWN))\n\t\t\tcontinue;\n\n\t\tif (b >= IMX_RPROC_MEM_MAX)\n\t\t\tbreak;\n\n\t\tif (att->flags & ATT_IOMEM)\n\t\t\tpriv->mem[b].cpu_addr = devm_ioremap(&pdev->dev,\n\t\t\t\t\t\t\t     att->sa, att->size);\n\t\telse\n\t\t\tpriv->mem[b].cpu_addr = devm_ioremap_wc(&pdev->dev,\n\t\t\t\t\t\t\t\tatt->sa, att->size);\n\t\tif (!priv->mem[b].cpu_addr) {\n\t\t\tdev_err(dev, \"failed to remap %#x bytes from %#x\\n\", att->size, att->sa);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpriv->mem[b].sys_addr = att->sa;\n\t\tpriv->mem[b].size = att->size;\n\t\tb++;\n\t}\n\n\t/* memory-region is optional property */\n\tnph = of_count_phandle_with_args(np, \"memory-region\", NULL);\n\tif (nph <= 0)\n\t\treturn 0;\n\n\t/* remap optional addresses */\n\tfor (a = 0; a < nph; a++) {\n\t\tstruct device_node *node;\n\t\tstruct resource res;\n\n\t\tnode = of_parse_phandle(np, \"memory-region\", a);\n\t\tif (!node)\n\t\t\tcontinue;\n\t\t/* Not map vdevbuffer, vdevring region */\n\t\tif (!strncmp(node->name, \"vdev\", strlen(\"vdev\"))) {\n\t\t\tof_node_put(node);\n\t\t\tcontinue;\n\t\t}\n\t\terr = of_address_to_resource(node, 0, &res);\n\t\tof_node_put(node);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"unable to resolve memory region\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tif (b >= IMX_RPROC_MEM_MAX)\n\t\t\tbreak;\n\n\t\t/* Not use resource version, because we might share region */\n\t\tpriv->mem[b].cpu_addr = devm_ioremap_wc(&pdev->dev, res.start, resource_size(&res));\n\t\tif (!priv->mem[b].cpu_addr) {\n\t\t\tdev_err(dev, \"failed to remap %pr\\n\", &res);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpriv->mem[b].sys_addr = res.start;\n\t\tpriv->mem[b].size = resource_size(&res);\n\t\tif (!strcmp(node->name, \"rsc-table\"))\n\t\t\tpriv->rsc_table = priv->mem[b].cpu_addr;\n\t\tb++;\n\t}\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-43860"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/pci/hotplug/pnv_php.c",
      "func_name": "pnv_php_disable_irq",
      "func_body": "static void pnv_php_disable_irq(struct pnv_php_slot *php_slot,\n\t\t\t\tbool disable_device)\n{\n\tstruct pci_dev *pdev = php_slot->pdev;\n\tu16 ctrl;\n\n\tif (php_slot->irq > 0) {\n\t\tpcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &ctrl);\n\t\tctrl &= ~(PCI_EXP_SLTCTL_HPIE |\n\t\t\t  PCI_EXP_SLTCTL_PDCE |\n\t\t\t  PCI_EXP_SLTCTL_DLLSCE);\n\t\tpcie_capability_write_word(pdev, PCI_EXP_SLTCTL, ctrl);\n\n\t\tfree_irq(php_slot->irq, php_slot);\n\t\tphp_slot->irq = 0;\n\t}\n\n\tif (php_slot->wq) {\n\t\tdestroy_workqueue(php_slot->wq);\n\t\tphp_slot->wq = NULL;\n\t}\n\n\tif (disable_device) {\n\t\tif (pdev->msix_enabled)\n\t\t\tpci_disable_msix(pdev);\n\t\telse if (pdev->msi_enabled)\n\t\t\tpci_disable_msi(pdev);\n\n\t\tpci_disable_device(pdev);\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-46761"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/perf/riscv_pmu_sbi.c",
      "func_name": "pmu_sbi_ovf_handler",
      "func_body": "static irqreturn_t pmu_sbi_ovf_handler(int irq, void *dev)\n{\n\tstruct perf_sample_data data;\n\tstruct pt_regs *regs;\n\tstruct hw_perf_event *hw_evt;\n\tunion sbi_pmu_ctr_info *info;\n\tint lidx, hidx, fidx;\n\tstruct riscv_pmu *pmu;\n\tstruct perf_event *event;\n\tunsigned long overflow;\n\tunsigned long overflowed_ctrs = 0;\n\tstruct cpu_hw_events *cpu_hw_evt = dev;\n\tu64 start_clock = sched_clock();\n\n\tif (WARN_ON_ONCE(!cpu_hw_evt))\n\t\treturn IRQ_NONE;\n\n\t/* Firmware counter don't support overflow yet */\n\tfidx = find_first_bit(cpu_hw_evt->used_hw_ctrs, RISCV_MAX_COUNTERS);\n\tif (fidx == RISCV_MAX_COUNTERS) {\n\t\tcsr_clear(CSR_SIP, BIT(riscv_pmu_irq_num));\n\t\treturn IRQ_NONE;\n\t}\n\n\tevent = cpu_hw_evt->events[fidx];\n\tif (!event) {\n\t\tcsr_clear(CSR_SIP, BIT(riscv_pmu_irq_num));\n\t\treturn IRQ_NONE;\n\t}\n\n\tpmu = to_riscv_pmu(event->pmu);\n\tpmu_sbi_stop_hw_ctrs(pmu);\n\n\t/* Overflow status register should only be read after counter are stopped */\n\tALT_SBI_PMU_OVERFLOW(overflow);\n\n\t/*\n\t * Overflow interrupt pending bit should only be cleared after stopping\n\t * all the counters to avoid any race condition.\n\t */\n\tcsr_clear(CSR_SIP, BIT(riscv_pmu_irq_num));\n\n\t/* No overflow bit is set */\n\tif (!overflow)\n\t\treturn IRQ_NONE;\n\n\tregs = get_irq_regs();\n\n\tfor_each_set_bit(lidx, cpu_hw_evt->used_hw_ctrs, RISCV_MAX_COUNTERS) {\n\t\tstruct perf_event *event = cpu_hw_evt->events[lidx];\n\n\t\t/* Skip if invalid event or user did not request a sampling */\n\t\tif (!event || !is_sampling_event(event))\n\t\t\tcontinue;\n\n\t\tinfo = &pmu_ctr_list[lidx];\n\t\t/* Do a sanity check */\n\t\tif (!info || info->type != SBI_PMU_CTR_TYPE_HW)\n\t\t\tcontinue;\n\n\t\t/* compute hardware counter index */\n\t\thidx = info->csr - CSR_CYCLE;\n\t\t/* check if the corresponding bit is set in sscountovf */\n\t\tif (!(overflow & BIT(hidx)))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Keep a track of overflowed counters so that they can be started\n\t\t * with updated initial value.\n\t\t */\n\t\toverflowed_ctrs |= BIT(lidx);\n\t\thw_evt = &event->hw;\n\t\triscv_pmu_event_update(event);\n\t\tperf_sample_data_init(&data, 0, hw_evt->last_period);\n\t\tif (riscv_pmu_event_set_period(event)) {\n\t\t\t/*\n\t\t\t * Unlike other ISAs, RISC-V don't have to disable interrupts\n\t\t\t * to avoid throttling here. As per the specification, the\n\t\t\t * interrupt remains disabled until the OF bit is set.\n\t\t\t * Interrupts are enabled again only during the start.\n\t\t\t * TODO: We will need to stop the guest counters once\n\t\t\t * virtualization support is added.\n\t\t\t */\n\t\t\tperf_event_overflow(event, &data, regs);\n\t\t}\n\t}\n\n\tpmu_sbi_start_overflow_mask(pmu, overflowed_ctrs);\n\tperf_sample_event_took(sched_clock() - start_clock);\n\n\treturn IRQ_HANDLED;\n}\n",
      "cve_list": [
        "CVE-2024-26902"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/gfs2/super.c",
      "func_name": "gfs2_jindex_free",
      "func_body": "void gfs2_jindex_free(struct gfs2_sbd *sdp)\n{\n\tstruct list_head list;\n\tstruct gfs2_jdesc *jd;\n\n\tspin_lock(&sdp->sd_jindex_spin);\n\tlist_add(&list, &sdp->sd_jindex_list);\n\tlist_del_init(&sdp->sd_jindex_list);\n\tsdp->sd_journals = 0;\n\tspin_unlock(&sdp->sd_jindex_spin);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\tsdp->sd_jdesc = NULL;\n\tup_write(&sdp->sd_log_flush_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tjd = list_first_entry(&list, struct gfs2_jdesc, jd_list);\n\t\tBUG_ON(jd->jd_log_bio);\n\t\tgfs2_free_journal_extents(jd);\n\t\tlist_del(&jd->jd_list);\n\t\tiput(jd->jd_inode);\n\t\tjd->jd_inode = NULL;\n\t\tkfree(jd);\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-42079"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/power/supply/qcom_battmgr.c",
      "func_name": "qcom_battmgr_probe",
      "func_body": "static int qcom_battmgr_probe(struct auxiliary_device *adev,\n\t\t\t      const struct auxiliary_device_id *id)\n{\n\tstruct power_supply_config psy_cfg_supply = {};\n\tstruct power_supply_config psy_cfg = {};\n\tconst struct of_device_id *match;\n\tstruct qcom_battmgr *battmgr;\n\tstruct device *dev = &adev->dev;\n\n\tbattmgr = devm_kzalloc(dev, sizeof(*battmgr), GFP_KERNEL);\n\tif (!battmgr)\n\t\treturn -ENOMEM;\n\n\tbattmgr->dev = dev;\n\n\tpsy_cfg.drv_data = battmgr;\n\tpsy_cfg.of_node = adev->dev.of_node;\n\n\tpsy_cfg_supply.drv_data = battmgr;\n\tpsy_cfg_supply.of_node = adev->dev.of_node;\n\tpsy_cfg_supply.supplied_to = qcom_battmgr_battery;\n\tpsy_cfg_supply.num_supplicants = 1;\n\n\tINIT_WORK(&battmgr->enable_work, qcom_battmgr_enable_worker);\n\tmutex_init(&battmgr->lock);\n\tinit_completion(&battmgr->ack);\n\n\tmatch = of_match_device(qcom_battmgr_of_variants, dev->parent);\n\tif (match)\n\t\tbattmgr->variant = (unsigned long)match->data;\n\telse\n\t\tbattmgr->variant = QCOM_BATTMGR_SM8350;\n\n\tif (battmgr->variant == QCOM_BATTMGR_SC8280XP) {\n\t\tbattmgr->bat_psy = devm_power_supply_register(dev, &sc8280xp_bat_psy_desc, &psy_cfg);\n\t\tif (IS_ERR(battmgr->bat_psy))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(battmgr->bat_psy),\n\t\t\t\t\t     \"failed to register battery power supply\\n\");\n\n\t\tbattmgr->ac_psy = devm_power_supply_register(dev, &sc8280xp_ac_psy_desc, &psy_cfg_supply);\n\t\tif (IS_ERR(battmgr->ac_psy))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(battmgr->ac_psy),\n\t\t\t\t\t     \"failed to register AC power supply\\n\");\n\n\t\tbattmgr->usb_psy = devm_power_supply_register(dev, &sc8280xp_usb_psy_desc, &psy_cfg_supply);\n\t\tif (IS_ERR(battmgr->usb_psy))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(battmgr->usb_psy),\n\t\t\t\t\t     \"failed to register USB power supply\\n\");\n\n\t\tbattmgr->wls_psy = devm_power_supply_register(dev, &sc8280xp_wls_psy_desc, &psy_cfg_supply);\n\t\tif (IS_ERR(battmgr->wls_psy))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(battmgr->wls_psy),\n\t\t\t\t\t     \"failed to register wireless charing power supply\\n\");\n\t} else {\n\t\tbattmgr->bat_psy = devm_power_supply_register(dev, &sm8350_bat_psy_desc, &psy_cfg);\n\t\tif (IS_ERR(battmgr->bat_psy))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(battmgr->bat_psy),\n\t\t\t\t\t     \"failed to register battery power supply\\n\");\n\n\t\tbattmgr->usb_psy = devm_power_supply_register(dev, &sm8350_usb_psy_desc, &psy_cfg_supply);\n\t\tif (IS_ERR(battmgr->usb_psy))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(battmgr->usb_psy),\n\t\t\t\t\t     \"failed to register USB power supply\\n\");\n\n\t\tbattmgr->wls_psy = devm_power_supply_register(dev, &sm8350_wls_psy_desc, &psy_cfg_supply);\n\t\tif (IS_ERR(battmgr->wls_psy))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(battmgr->wls_psy),\n\t\t\t\t\t     \"failed to register wireless charing power supply\\n\");\n\t}\n\n\tbattmgr->client = devm_pmic_glink_client_alloc(dev, PMIC_GLINK_OWNER_BATTMGR,\n\t\t\t\t\t\t       qcom_battmgr_callback,\n\t\t\t\t\t\t       qcom_battmgr_pdr_notify,\n\t\t\t\t\t\t       battmgr);\n\tif (IS_ERR(battmgr->client))\n\t\treturn PTR_ERR(battmgr->client);\n\n\tpmic_glink_client_register(battmgr->client);\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-46693"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/soc/qcom/pmic_glink_altmode.c",
      "func_name": "pmic_glink_altmode_probe",
      "func_body": "static int pmic_glink_altmode_probe(struct auxiliary_device *adev,\n\t\t\t\t    const struct auxiliary_device_id *id)\n{\n\tstruct pmic_glink_altmode_port *alt_port;\n\tstruct pmic_glink_altmode *altmode;\n\tconst struct of_device_id *match;\n\tstruct fwnode_handle *fwnode;\n\tstruct device *dev = &adev->dev;\n\tu32 port;\n\tint ret;\n\n\taltmode = devm_kzalloc(dev, sizeof(*altmode), GFP_KERNEL);\n\tif (!altmode)\n\t\treturn -ENOMEM;\n\n\taltmode->dev = dev;\n\n\tmatch = of_match_device(pmic_glink_altmode_of_quirks, dev->parent);\n\tif (match)\n\t\taltmode->owner_id = (unsigned long)match->data;\n\telse\n\t\taltmode->owner_id = PMIC_GLINK_OWNER_USBC_PAN;\n\n\tINIT_WORK(&altmode->enable_work, pmic_glink_altmode_enable_worker);\n\tinit_completion(&altmode->pan_ack);\n\tmutex_init(&altmode->lock);\n\n\tdevice_for_each_child_node(dev, fwnode) {\n\t\tret = fwnode_property_read_u32(fwnode, \"reg\", &port);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"missing reg property of %pOFn\\n\", fwnode);\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (port >= ARRAY_SIZE(altmode->ports)) {\n\t\t\tdev_warn(dev, \"invalid connector number, ignoring\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (altmode->ports[port].altmode) {\n\t\t\tdev_err(dev, \"multiple connector definition for port %u\\n\", port);\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\talt_port = &altmode->ports[port];\n\t\talt_port->altmode = altmode;\n\t\talt_port->index = port;\n\t\tINIT_WORK(&alt_port->work, pmic_glink_altmode_worker);\n\n\t\talt_port->bridge = devm_drm_dp_hpd_bridge_alloc(dev, to_of_node(fwnode));\n\t\tif (IS_ERR(alt_port->bridge)) {\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn PTR_ERR(alt_port->bridge);\n\t\t}\n\n\t\talt_port->dp_alt.svid = USB_TYPEC_DP_SID;\n\t\talt_port->dp_alt.mode = USB_TYPEC_DP_MODE;\n\t\talt_port->dp_alt.active = 1;\n\n\t\talt_port->typec_mux = fwnode_typec_mux_get(fwnode);\n\t\tif (IS_ERR(alt_port->typec_mux)) {\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn dev_err_probe(dev, PTR_ERR(alt_port->typec_mux),\n\t\t\t\t\t     \"failed to acquire mode-switch for port: %d\\n\",\n\t\t\t\t\t     port);\n\t\t}\n\n\t\tret = devm_add_action_or_reset(dev, pmic_glink_altmode_put_mux,\n\t\t\t\t\t       alt_port->typec_mux);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn ret;\n\t\t}\n\n\t\talt_port->typec_retimer = fwnode_typec_retimer_get(fwnode);\n\t\tif (IS_ERR(alt_port->typec_retimer)) {\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn dev_err_probe(dev, PTR_ERR(alt_port->typec_retimer),\n\t\t\t\t\t     \"failed to acquire retimer-switch for port: %d\\n\",\n\t\t\t\t\t     port);\n\t\t}\n\n\t\tret = devm_add_action_or_reset(dev, pmic_glink_altmode_put_retimer,\n\t\t\t\t\t       alt_port->typec_retimer);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn ret;\n\t\t}\n\n\t\talt_port->typec_switch = fwnode_typec_switch_get(fwnode);\n\t\tif (IS_ERR(alt_port->typec_switch)) {\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn dev_err_probe(dev, PTR_ERR(alt_port->typec_switch),\n\t\t\t\t\t     \"failed to acquire orientation-switch for port: %d\\n\",\n\t\t\t\t\t     port);\n\t\t}\n\n\t\tret = devm_add_action_or_reset(dev, pmic_glink_altmode_put_switch,\n\t\t\t\t\t       alt_port->typec_switch);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (port = 0; port < ARRAY_SIZE(altmode->ports); port++) {\n\t\talt_port = &altmode->ports[port];\n\t\tif (!alt_port->bridge)\n\t\t\tcontinue;\n\n\t\tret = devm_drm_dp_hpd_bridge_add(dev, alt_port->bridge);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\taltmode->client = devm_pmic_glink_client_alloc(dev,\n\t\t\t\t\t\t       altmode->owner_id,\n\t\t\t\t\t\t       pmic_glink_altmode_callback,\n\t\t\t\t\t\t       pmic_glink_altmode_pdr_notify,\n\t\t\t\t\t\t       altmode);\n\tif (IS_ERR(altmode->client))\n\t\treturn PTR_ERR(altmode->client);\n\n\tpmic_glink_client_register(altmode->client);\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-46693"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/usb/typec/ucsi/ucsi_glink.c",
      "func_name": "pmic_glink_ucsi_probe",
      "func_body": "static int pmic_glink_ucsi_probe(struct auxiliary_device *adev,\n\t\t\t\t const struct auxiliary_device_id *id)\n{\n\tstruct pmic_glink_ucsi *ucsi;\n\tstruct device *dev = &adev->dev;\n\tconst struct of_device_id *match;\n\tstruct fwnode_handle *fwnode;\n\tint ret;\n\n\tucsi = devm_kzalloc(dev, sizeof(*ucsi), GFP_KERNEL);\n\tif (!ucsi)\n\t\treturn -ENOMEM;\n\n\tucsi->dev = dev;\n\tdev_set_drvdata(dev, ucsi);\n\n\tINIT_WORK(&ucsi->notify_work, pmic_glink_ucsi_notify);\n\tINIT_WORK(&ucsi->register_work, pmic_glink_ucsi_register);\n\tinit_completion(&ucsi->read_ack);\n\tinit_completion(&ucsi->write_ack);\n\tmutex_init(&ucsi->lock);\n\n\tucsi->ucsi = ucsi_create(dev, &pmic_glink_ucsi_ops);\n\tif (IS_ERR(ucsi->ucsi))\n\t\treturn PTR_ERR(ucsi->ucsi);\n\n\t/* Make sure we destroy *after* pmic_glink unregister */\n\tret = devm_add_action_or_reset(dev, pmic_glink_ucsi_destroy, ucsi);\n\tif (ret)\n\t\treturn ret;\n\n\tmatch = of_match_device(pmic_glink_ucsi_of_quirks, dev->parent);\n\tif (match)\n\t\tucsi->ucsi->quirks = *(unsigned long *)match->data;\n\n\tucsi_set_drvdata(ucsi->ucsi, ucsi);\n\n\tdevice_for_each_child_node(dev, fwnode) {\n\t\tstruct gpio_desc *desc;\n\t\tu32 port;\n\n\t\tret = fwnode_property_read_u32(fwnode, \"reg\", &port);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"missing reg property of %pOFn\\n\", fwnode);\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (port >= PMIC_GLINK_MAX_PORTS) {\n\t\t\tdev_warn(dev, \"invalid connector number, ignoring\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tdesc = devm_gpiod_get_index_optional(&adev->dev, \"orientation\", port, GPIOD_IN);\n\n\t\t/* If GPIO isn't found, continue */\n\t\tif (!desc)\n\t\t\tcontinue;\n\n\t\tif (IS_ERR(desc)) {\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn dev_err_probe(dev, PTR_ERR(desc),\n\t\t\t\t\t     \"unable to acquire orientation gpio\\n\");\n\t\t}\n\t\tucsi->port_orientation[port] = desc;\n\t}\n\n\tucsi->client = devm_pmic_glink_client_alloc(dev, PMIC_GLINK_OWNER_USBC,\n\t\t\t\t\t\t    pmic_glink_ucsi_callback,\n\t\t\t\t\t\t    pmic_glink_ucsi_pdr_notify,\n\t\t\t\t\t\t    ucsi);\n\tif (IS_ERR(ucsi->client))\n\t\treturn PTR_ERR(ucsi->client);\n\n\tpmic_glink_client_register(ucsi->client);\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-46693"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "sound/soc/codecs/pcm6240.c",
      "func_name": "pcmdevice_i2c_probe",
      "func_body": "static int pcmdevice_i2c_probe(struct i2c_client *i2c)\n{\n\tconst struct i2c_device_id *id = i2c_match_id(pcmdevice_i2c_id, i2c);\n\tstruct pcmdevice_priv *pcm_dev;\n\tstruct device_node *np;\n\tunsigned int dev_addrs[PCMDEVICE_MAX_I2C_DEVICES];\n\tint ret = 0, i = 0, ndev = 0;\n// #ifdef CONFIG_OF\n\tconst __be32 *reg, *reg_end;\n\tint len, sw, aw;\n#endif\n\n\tpcm_dev = devm_kzalloc(&i2c->dev, sizeof(*pcm_dev), GFP_KERNEL);\n\tif (!pcm_dev)\n\t\treturn -ENOMEM;\n\n\tpcm_dev->chip_id = (id != NULL) ? id->driver_data : 0;\n\n\tpcm_dev->dev = &i2c->dev;\n\tpcm_dev->client = i2c;\n\n\tif (pcm_dev->chip_id >= MAX_DEVICE)\n\t\tpcm_dev->chip_id = 0;\n\n\tstrscpy(pcm_dev->dev_name, pcmdevice_i2c_id[pcm_dev->chip_id].name,\n\t\tsizeof(pcm_dev->dev_name));\n\n\tstrscpy(pcm_dev->upper_dev_name,\n\t\tpcmdevice_i2c_id[pcm_dev->chip_id].name,\n\t\tsizeof(pcm_dev->upper_dev_name));\n\n\tstr_to_upper(pcm_dev->upper_dev_name);\n\n\tpcm_dev->regmap = devm_regmap_init_i2c(i2c, &pcmdevice_i2c_regmap);\n\tif (IS_ERR(pcm_dev->regmap)) {\n\t\tret = PTR_ERR(pcm_dev->regmap);\n\t\tdev_err(&i2c->dev, \"%s: failed to allocate register map: %d\\n\",\n\t\t\t__func__, ret);\n\t\tgoto out;\n\t}\n\n\ti2c_set_clientdata(i2c, pcm_dev);\n\tmutex_init(&pcm_dev->codec_lock);\n\tnp = pcm_dev->dev->of_node;\n// #ifdef CONFIG_OF\n\taw = of_n_addr_cells(np);\n\tsw = of_n_size_cells(np);\n\tif (sw == 0) {\n\t\treg = (const __be32 *)of_get_property(np,\n\t\t\t\"reg\", &len);\n\t\treg_end = reg + len/sizeof(*reg);\n\t\tndev = 0;\n\t\tdo {\n\t\t\tdev_addrs[ndev] = of_read_number(reg, aw);\n\t\t\treg += aw;\n\t\t\tndev++;\n\t\t} while (reg < reg_end);\n\t} else {\n\t\tndev = 1;\n\t\tdev_addrs[0] = i2c->addr;\n\t}\n#else\n\tndev = 1;\n\tdev_addrs[0] = i2c->addr;\n#endif\n\tpcm_dev->irq_info.gpio = of_irq_get(np, 0);\n\n\tfor (i = 0; i < ndev; i++)\n\t\tpcm_dev->addr[i] = dev_addrs[i];\n\n\tpcm_dev->ndev = ndev;\n\n\tpcm_dev->hw_rst = devm_gpiod_get_optional(&i2c->dev,\n\t\t\t\"reset-gpios\", GPIOD_OUT_HIGH);\n\t/* No reset GPIO, no side-effect */\n\tif (IS_ERR(pcm_dev->hw_rst)) {\n\t\tif (pcm_dev->chip_id == PCM9211 || pcm_dev->chip_id == PCM1690)\n\t\t\tpcm9211_sw_rst(pcm_dev);\n\t\telse\n\t\t\tpcmdevice_sw_rst(pcm_dev);\n\t} else {\n\t\tgpiod_set_value_cansleep(pcm_dev->hw_rst, 0);\n\t\tusleep_range(500, 1000);\n\t\tgpiod_set_value_cansleep(pcm_dev->hw_rst, 1);\n\t}\n\n\tif (pcm_dev->chip_id == PCM1690)\n\t\tgoto skip_interrupt;\n\tif (gpio_is_valid(pcm_dev->irq_info.gpio)) {\n\t\tdev_dbg(pcm_dev->dev, \"irq-gpio = %d\", pcm_dev->irq_info.gpio);\n\n\t\tret = gpio_request(pcm_dev->irq_info.gpio, \"PCMDEV-IRQ\");\n\t\tif (!ret) {\n\t\t\tint gpio = pcm_dev->irq_info.gpio;\n\n\t\t\tgpio_direction_input(gpio);\n\t\t\tpcm_dev->irq_info.nmb = gpio_to_irq(gpio);\n\n\t\t} else\n\t\t\tdev_err(pcm_dev->dev, \"%s: GPIO %d request error\\n\",\n\t\t\t\t__func__, pcm_dev->irq_info.gpio);\n\t} else\n\t\tdev_err(pcm_dev->dev, \"Looking up irq-gpio failed %d\\n\",\n\t\t\tpcm_dev->irq_info.gpio);\n\nskip_interrupt:\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t&soc_codec_driver_pcmdevice, pcmdevice_dai_driver,\n\t\tARRAY_SIZE(pcmdevice_dai_driver));\n\tif (ret < 0)\n\t\tdev_err(&i2c->dev, \"probe register comp failed %d\\n\", ret);\n\nout:\n\tif (ret < 0)\n\t\tpcmdevice_remove(pcm_dev);\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-43822"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/staging/media/atomisp/pci/sh_css.c",
      "func_name": "load_video_binaries",
      "func_body": "static int load_video_binaries(struct ia_css_pipe *pipe)\n{\n\tstruct ia_css_frame_info video_in_info, tnr_info,\n\t\t       *video_vf_info, video_bds_out_info, *pipe_out_info, *pipe_vf_out_info;\n\tbool online;\n\tint err = 0;\n\tbool continuous = pipe->stream->config.continuous;\n\tunsigned int i;\n\tunsigned int num_output_pins;\n\tstruct ia_css_frame_info video_bin_out_info;\n\tbool need_scaler = false;\n\tbool vf_res_different_than_output = false;\n\tbool need_vf_pp = false;\n\tint vf_ds_log2;\n\tstruct ia_css_video_settings *mycs  = &pipe->pipe_settings.video;\n\n\tIA_CSS_ENTER_PRIVATE(\"\");\n\tassert(pipe);\n\tassert(pipe->mode == IA_CSS_PIPE_ID_VIDEO);\n\t/*\n\t * we only test the video_binary because offline video doesn't need a\n\t * vf_pp binary and online does not (always use) the copy_binary.\n\t * All are always reset at the same time anyway.\n\t */\n\tif (mycs->video_binary.info)\n\t\treturn 0;\n\n\tonline = pipe->stream->config.online;\n\tpipe_out_info = &pipe->output_info[0];\n\tpipe_vf_out_info = &pipe->vf_output_info[0];\n\n\tassert(pipe_out_info);\n\n\t/*\n\t * There is no explicit input format requirement for raw or yuv\n\t * What matters is that there is a binary that supports the stream format.\n\t * This is checked in the binary_find(), so no need to check it here\n\t */\n\terr = ia_css_util_check_input(&pipe->stream->config, false, false);\n\tif (err)\n\t\treturn err;\n\t/* cannot have online video and input_mode memory */\n\tif (online && pipe->stream->config.mode == IA_CSS_INPUT_MODE_MEMORY)\n\t\treturn -EINVAL;\n\tif (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0]) {\n\t\terr = ia_css_util_check_vf_out_info(pipe_out_info,\n\t\t\t\t\t\t    pipe_vf_out_info);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\terr = ia_css_frame_check_info(pipe_out_info);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (pipe->out_yuv_ds_input_info.res.width)\n\t\tvideo_bin_out_info = pipe->out_yuv_ds_input_info;\n\telse\n\t\tvideo_bin_out_info = *pipe_out_info;\n\n\t/* Video */\n\tif (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0]) {\n\t\tvideo_vf_info = pipe_vf_out_info;\n\t\tvf_res_different_than_output = (video_vf_info->res.width !=\n\t\t\t\t\t\tvideo_bin_out_info.res.width) ||\n\t\t\t\t\t       (video_vf_info->res.height != video_bin_out_info.res.height);\n\t} else {\n\t\tvideo_vf_info = NULL;\n\t}\n\n\tneed_scaler = need_downscaling(video_bin_out_info.res, pipe_out_info->res);\n\n\t/* we build up the pipeline starting at the end */\n\t/* YUV post-processing if needed */\n\tif (need_scaler) {\n\t\tstruct ia_css_cas_binary_descr cas_scaler_descr = { };\n\n\t\t/* NV12 is the common format that is supported by both */\n\t\t/* yuv_scaler and the video_xx_isp2_min binaries. */\n\t\tvideo_bin_out_info.format = IA_CSS_FRAME_FORMAT_NV12;\n\n\t\terr = ia_css_pipe_create_cas_scaler_desc_single_output(\n\t\t\t  &video_bin_out_info,\n\t\t\t  pipe_out_info,\n\t\t\t  NULL,\n\t\t\t  &cas_scaler_descr);\n\t\tif (err)\n\t\t\treturn err;\n\t\tmycs->num_yuv_scaler = cas_scaler_descr.num_stage;\n\t\tmycs->yuv_scaler_binary = kcalloc(cas_scaler_descr.num_stage,\n\t\t\t\t\t\t  sizeof(struct ia_css_binary),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!mycs->yuv_scaler_binary) {\n\t\t\tmycs->num_yuv_scaler = 0;\n\t\t\terr = -ENOMEM;\n\t\t\treturn err;\n\t\t}\n\t\tmycs->is_output_stage = kcalloc(cas_scaler_descr.num_stage,\n\t\t\t\t\t\tsizeof(bool), GFP_KERNEL);\n\t\tif (!mycs->is_output_stage) {\n\t\t\terr = -ENOMEM;\n\t\t\treturn err;\n\t\t}\n\t\tfor (i = 0; i < cas_scaler_descr.num_stage; i++) {\n\t\t\tstruct ia_css_binary_descr yuv_scaler_descr;\n\n\t\t\tmycs->is_output_stage[i] = cas_scaler_descr.is_output_stage[i];\n\t\t\tia_css_pipe_get_yuvscaler_binarydesc(pipe,\n\t\t\t\t\t\t\t     &yuv_scaler_descr, &cas_scaler_descr.in_info[i],\n\t\t\t\t\t\t\t     &cas_scaler_descr.out_info[i],\n\t\t\t\t\t\t\t     &cas_scaler_descr.internal_out_info[i],\n\t\t\t\t\t\t\t     &cas_scaler_descr.vf_info[i]);\n\t\t\terr = ia_css_binary_find(&yuv_scaler_descr,\n\t\t\t\t\t\t &mycs->yuv_scaler_binary[i]);\n\t\t\tif (err) {\n\t\t\t\tkfree(mycs->is_output_stage);\n\t\t\t\tmycs->is_output_stage = NULL;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tia_css_pipe_destroy_cas_scaler_desc(&cas_scaler_descr);\n\t}\n\n\t{\n\t\tstruct ia_css_binary_descr video_descr;\n\t\tenum ia_css_frame_format vf_info_format;\n\n\t\terr = ia_css_pipe_get_video_binarydesc(pipe,\n\t\t\t\t\t\t       &video_descr, &video_in_info, &video_bds_out_info, &video_bin_out_info,\n\t\t\t\t\t\t       video_vf_info,\n\t\t\t\t\t\t       pipe->stream->config.left_padding);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t/*\n\t\t * In the case where video_vf_info is not NULL, this allows\n\t\t * us to find a potential video library with desired vf format.\n\t\t * If success, no vf_pp binary is needed.\n\t\t * If failed, we will look up video binary with YUV_LINE vf format\n\t\t */\n\t\terr = ia_css_binary_find(&video_descr,\n\t\t\t\t\t &mycs->video_binary);\n\n\t\tif (err) {\n\t\t\t/* This will do another video binary lookup later for YUV_LINE format*/\n\t\t\tif (video_vf_info)\n\t\t\t\tneed_vf_pp = true;\n\t\t\telse\n\t\t\t\treturn err;\n\t\t} else if (video_vf_info) {\n\t\t\t/*\n\t\t\t * The first video binary lookup is successful, but we\n\t\t\t * may still need vf_pp binary based on additional check\n\t\t\t */\n\t\t\tnum_output_pins = mycs->video_binary.info->num_output_pins;\n\t\t\tvf_ds_log2 = mycs->video_binary.vf_downscale_log2;\n\n\t\t\t/*\n\t\t\t * If the binary has dual output pins, we need vf_pp\n\t\t\t * if the resolution is different.\n\t\t\t */\n\t\t\tneed_vf_pp |= ((num_output_pins == 2) && vf_res_different_than_output);\n\n\t\t\t/*\n\t\t\t * If the binary has single output pin, we need vf_pp\n\t\t\t * if additional scaling is needed for vf\n\t\t\t */\n\t\t\tneed_vf_pp |= ((num_output_pins == 1) &&\n\t\t\t\t       ((video_vf_info->res.width << vf_ds_log2 != pipe_out_info->res.width) ||\n\t\t\t\t\t(video_vf_info->res.height << vf_ds_log2 != pipe_out_info->res.height)));\n\t\t}\n\n\t\tif (need_vf_pp) {\n\t\t\t/* save the current vf_info format for restoration later */\n\t\t\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t\t\t    \"load_video_binaries() need_vf_pp; find video binary with YUV_LINE again\\n\");\n\n\t\t\tvf_info_format = video_vf_info->format;\n\n\t\t\tif (!pipe->config.enable_vfpp_bci)\n\t\t\t\tia_css_frame_info_set_format(video_vf_info,\n\t\t\t\t\t\t\t     IA_CSS_FRAME_FORMAT_YUV_LINE);\n\n\t\t\tia_css_binary_destroy_isp_parameters(&mycs->video_binary);\n\n\t\t\terr = ia_css_binary_find(&video_descr,\n\t\t\t\t\t\t &mycs->video_binary);\n\n\t\t\t/* restore original vf_info format */\n\t\t\tia_css_frame_info_set_format(video_vf_info,\n\t\t\t\t\t\t     vf_info_format);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t/*\n\t * If a video binary does not use a ref_frame, we set the frame delay\n\t * to 0. This is the case for the 1-stage low-power video binary.\n\t */\n\tif (!mycs->video_binary.info->sp.enable.ref_frame)\n\t\tpipe->dvs_frame_delay = 0;\n\n\t/*\n\t * The delay latency determines the number of invalid frames after\n\t * a stream is started.\n\t */\n\tpipe->num_invalid_frames = pipe->dvs_frame_delay;\n\tpipe->info.num_invalid_frames = pipe->num_invalid_frames;\n\n\t/*\n\t * Viewfinder frames also decrement num_invalid_frames. If the pipe\n\t * outputs a viewfinder output, then we need double the number of\n\t * invalid frames\n\t */\n\tif (video_vf_info)\n\t\tpipe->num_invalid_frames *= 2;\n\n\tia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,\n\t\t\t    \"load_video_binaries() num_invalid_frames=%d dvs_frame_delay=%d\\n\",\n\t\t\t    pipe->num_invalid_frames, pipe->dvs_frame_delay);\n\n\t/* pqiao TODO: temp hack for PO, should be removed after offline YUVPP is enabled */\n\tif (!IS_ISP2401) {\n\t\t/* Copy */\n\t\tif (!online && !continuous) {\n\t\t\t/*\n\t\t\t * TODO: what exactly needs doing, prepend the copy binary to\n\t\t\t *\t video base this only on !online?\n\t\t\t */\n\t\t\terr = load_copy_binary(pipe,\n\t\t\t\t\t       &mycs->copy_binary,\n\t\t\t\t\t       &mycs->video_binary);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0] && need_vf_pp) {\n\t\tstruct ia_css_binary_descr vf_pp_descr;\n\n\t\tif (mycs->video_binary.vf_frame_info.format\n\t\t    == IA_CSS_FRAME_FORMAT_YUV_LINE) {\n\t\t\tia_css_pipe_get_vfpp_binarydesc(pipe, &vf_pp_descr,\n\t\t\t\t\t\t\t&mycs->video_binary.vf_frame_info,\n\t\t\t\t\t\t\tpipe_vf_out_info);\n\t\t} else {\n\t\t\t/*\n\t\t\t * output from main binary is not yuv line. currently\n\t\t\t * this is possible only when bci is enabled on vfpp\n\t\t\t * output\n\t\t\t */\n\t\t\tassert(pipe->config.enable_vfpp_bci);\n\t\t\tia_css_pipe_get_yuvscaler_binarydesc(pipe, &vf_pp_descr,\n\t\t\t\t\t\t\t     &mycs->video_binary.vf_frame_info,\n\t\t\t\t\t\t\t     pipe_vf_out_info, NULL, NULL);\n\t\t}\n\n\t\terr = ia_css_binary_find(&vf_pp_descr,\n\t\t\t\t\t &mycs->vf_pp_binary);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = allocate_delay_frames(pipe);\n\n\tif (err)\n\t\treturn err;\n\n\tif (mycs->video_binary.info->sp.enable.block_output) {\n\t\ttnr_info = mycs->video_binary.out_frame_info[0];\n\n\t\t/* Make tnr reference buffers output block height align */\n\t\ttnr_info.res.height = CEIL_MUL(tnr_info.res.height,\n\t\t\t\t\t       mycs->video_binary.info->sp.block.output_block_height);\n\t} else {\n\t\ttnr_info = mycs->video_binary.internal_frame_info;\n\t}\n\ttnr_info.format = IA_CSS_FRAME_FORMAT_YUV_LINE;\n\ttnr_info.raw_bit_depth = SH_CSS_TNR_BIT_DEPTH;\n\n\tfor (i = 0; i < NUM_VIDEO_TNR_FRAMES; i++) {\n\t\tif (mycs->tnr_frames[i]) {\n\t\t\tia_css_frame_free(mycs->tnr_frames[i]);\n\t\t\tmycs->tnr_frames[i] = NULL;\n\t\t}\n\t\terr = ia_css_frame_allocate_from_info(\n\t\t\t  &mycs->tnr_frames[i],\n\t\t\t  &tnr_info);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tIA_CSS_LEAVE_PRIVATE(\"\");\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-38547"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c",
      "func_name": "amdgpu_dm_plane_helper_prepare_fb",
      "func_body": "static int amdgpu_dm_plane_helper_prepare_fb(struct drm_plane *plane,\n\t\t\t\t\t     struct drm_plane_state *new_state)\n{\n\tstruct amdgpu_framebuffer *afb;\n\tstruct drm_gem_object *obj;\n\tstruct amdgpu_device *adev;\n\tstruct amdgpu_bo *rbo;\n\tstruct dm_plane_state *dm_plane_state_new, *dm_plane_state_old;\n\tuint32_t domain;\n\tint r;\n\n\tif (!new_state->fb) {\n\t\tDRM_DEBUG_KMS(\"No FB bound\\n\");\n\t\treturn 0;\n\t}\n\n\tafb = to_amdgpu_framebuffer(new_state->fb);\n\tobj = drm_gem_fb_get_obj(new_state->fb, 0);\n\tif (!obj) {\n\t\tDRM_ERROR(\"Failed to get obj from framebuffer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trbo = gem_to_amdgpu_bo(obj);\n\tadev = amdgpu_ttm_adev(rbo->tbo.bdev);\n\tr = amdgpu_bo_reserve(rbo, true);\n\tif (r) {\n\t\tdev_err(adev->dev, \"fail to reserve bo (%d)\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = dma_resv_reserve_fences(rbo->tbo.base.resv, 1);\n\tif (r) {\n\t\tdev_err(adev->dev, \"reserving fence slot failed (%d)\\n\", r);\n\t\tgoto error_unlock;\n\t}\n\n\tif (plane->type != DRM_PLANE_TYPE_CURSOR)\n\t\tdomain = amdgpu_display_supported_domains(adev, rbo->flags);\n\telse\n\t\tdomain = AMDGPU_GEM_DOMAIN_VRAM;\n\n\tr = amdgpu_bo_pin(rbo, domain);\n\tif (unlikely(r != 0)) {\n\t\tif (r != -ERESTARTSYS)\n\t\t\tDRM_ERROR(\"Failed to pin framebuffer with error %d\\n\", r);\n\t\tgoto error_unlock;\n\t}\n\n\tr = amdgpu_ttm_alloc_gart(&rbo->tbo);\n\tif (unlikely(r != 0)) {\n\t\tDRM_ERROR(\"%p bind failed\\n\", rbo);\n\t\tgoto error_unpin;\n\t}\n\n\tr = drm_gem_plane_helper_prepare_fb(plane, new_state);\n\tif (unlikely(r != 0))\n\t\tgoto error_unpin;\n\n\tamdgpu_bo_unreserve(rbo);\n\n\tafb->address = amdgpu_bo_gpu_offset(rbo);\n\n\tamdgpu_bo_ref(rbo);\n\n\t/**\n\t * We don't do surface updates on planes that have been newly created,\n\t * but we also don't have the afb->address during atomic check.\n\t *\n\t * Fill in buffer attributes depending on the address here, but only on\n\t * newly created planes since they're not being used by DC yet and this\n\t * won't modify global state.\n\t */\n\tdm_plane_state_old = to_dm_plane_state(plane->state);\n\tdm_plane_state_new = to_dm_plane_state(new_state);\n\n\tif (dm_plane_state_new->dc_state &&\n\t    dm_plane_state_old->dc_state != dm_plane_state_new->dc_state) {\n\t\tstruct dc_plane_state *plane_state =\n\t\t\tdm_plane_state_new->dc_state;\n\t\tbool force_disable_dcc = !plane_state->dcc.enable;\n\n\t\tamdgpu_dm_plane_fill_plane_buffer_attributes(\n\t\t\tadev, afb, plane_state->format, plane_state->rotation,\n\t\t\tafb->tiling_flags,\n\t\t\t&plane_state->tiling_info, &plane_state->plane_size,\n\t\t\t&plane_state->dcc, &plane_state->address,\n\t\t\tafb->tmz_surface, force_disable_dcc);\n\t}\n\n\treturn 0;\n\nerror_unpin:\n\tamdgpu_bo_unpin(rbo);\n\nerror_unlock:\n\tamdgpu_bo_unreserve(rbo);\n\treturn r;\n}\n",
      "cve_list": [
        "CVE-2024-46694"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/bpf/btf.c",
      "func_name": "bpf_core_apply",
      "func_body": "int bpf_core_apply(struct bpf_core_ctx *ctx, const struct bpf_core_relo *relo,\n\t\t   int relo_idx, void *insn)\n{\n\tbool need_cands = relo->kind != BPF_CORE_TYPE_ID_LOCAL;\n\tstruct bpf_core_cand_list cands = {};\n\tstruct bpf_core_relo_res targ_res;\n\tstruct bpf_core_spec *specs;\n\tconst struct btf_type *type;\n\tint err;\n\n\t/* ~4k of temp memory necessary to convert LLVM spec like \"0:1:0:5\"\n\t * into arrays of btf_ids of struct fields and array indices.\n\t */\n\tspecs = kcalloc(3, sizeof(*specs), GFP_KERNEL);\n\tif (!specs)\n\t\treturn -ENOMEM;\n\n\ttype = btf_type_by_id(ctx->btf, relo->type_id);\n\tif (!type) {\n\t\tbpf_log(ctx->log, \"relo #%u: bad type id %u\\n\",\n\t\t\trelo_idx, relo->type_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (need_cands) {\n\t\tstruct bpf_cand_cache *cc;\n\t\tint i;\n\n\t\tmutex_lock(&cand_cache_mutex);\n\t\tcc = bpf_core_find_cands(ctx, relo->type_id);\n\t\tif (IS_ERR(cc)) {\n\t\t\tbpf_log(ctx->log, \"target candidate search failed for %d\\n\",\n\t\t\t\trelo->type_id);\n\t\t\terr = PTR_ERR(cc);\n\t\t\tgoto out;\n\t\t}\n\t\tif (cc->cnt) {\n\t\t\tcands.cands = kcalloc(cc->cnt, sizeof(*cands.cands), GFP_KERNEL);\n\t\t\tif (!cands.cands) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < cc->cnt; i++) {\n\t\t\tbpf_log(ctx->log,\n\t\t\t\t\"CO-RE relocating %s %s: found target candidate [%d]\\n\",\n\t\t\t\tbtf_kind_str[cc->kind], cc->name, cc->cands[i].id);\n\t\t\tcands.cands[i].btf = cc->cands[i].btf;\n\t\t\tcands.cands[i].id = cc->cands[i].id;\n\t\t}\n\t\tcands.len = cc->cnt;\n\t\t/* cand_cache_mutex needs to span the cache lookup and\n\t\t * copy of btf pointer into bpf_core_cand_list,\n\t\t * since module can be unloaded while bpf_core_calc_relo_insn\n\t\t * is working with module's btf.\n\t\t */\n\t}\n\n\terr = bpf_core_calc_relo_insn((void *)ctx->log, relo, relo_idx, ctx->btf, &cands, specs,\n\t\t\t\t      &targ_res);\n\tif (err)\n\t\tgoto out;\n\n\terr = bpf_core_patch_insn((void *)ctx->log, insn, relo->insn_off / 8, relo, relo_idx,\n\t\t\t\t  &targ_res);\n\nout:\n\tkfree(specs);\n\tif (need_cands) {\n\t\tkfree(cands.cands);\n\t\tmutex_unlock(&cand_cache_mutex);\n\t\tif (ctx->log->level & BPF_LOG_LEVEL2)\n\t\t\tprint_cand_cache(ctx->log);\n\t}\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-49850"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/mellanox/mlx5/core/en_main.c",
      "func_name": "_mlx5e_suspend",
      "func_body": "static int _mlx5e_suspend(struct auxiliary_device *adev, bool pre_netdev_reg)\n{\n\tstruct mlx5e_dev *mlx5e_dev = auxiliary_get_drvdata(adev);\n\tstruct mlx5e_priv *priv = mlx5e_dev->priv;\n\tstruct net_device *netdev = priv->netdev;\n\tstruct mlx5_core_dev *mdev = priv->mdev;\n\tstruct mlx5_core_dev *pos;\n\tint i;\n\n\tif (!pre_netdev_reg && !netif_device_present(netdev)) {\n\t\tif (test_bit(MLX5E_STATE_DESTROYING, &priv->state))\n\t\t\tmlx5_sd_for_each_dev(i, mdev, pos)\n\t\t\t\tmlx5e_destroy_mdev_resources(pos);\n\t\treturn -ENODEV;\n\t}\n\n\tmlx5e_detach_netdev(priv);\n\tmlx5_sd_for_each_dev(i, mdev, pos)\n\t\tmlx5e_destroy_mdev_resources(pos);\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-38608"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/mellanox/mlx5/core/en_main.c",
      "func_name": "mlx5e_suspend",
      "func_body": "static int mlx5e_suspend(struct auxiliary_device *adev, pm_message_t state)\n{\n\tstruct mlx5_adev *edev = container_of(adev, struct mlx5_adev, adev);\n\tstruct mlx5_core_dev *mdev = edev->mdev;\n\tstruct auxiliary_device *actual_adev;\n\tint err = 0;\n\n\tactual_adev = mlx5_sd_get_adev(mdev, adev, edev->idx);\n\tif (actual_adev)\n\t\terr = _mlx5e_suspend(actual_adev, false);\n\n\tmlx5_sd_cleanup(mdev);\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-38608"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "security/apparmor/apparmorfs.c",
      "func_name": "__aafs_profile_mkdir",
      "func_body": "int __aafs_profile_mkdir(struct aa_profile *profile, struct dentry *parent)\n{\n\tstruct aa_profile *child;\n\tstruct dentry *dent = NULL, *dir;\n\tint error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!mutex_is_locked(&profiles_ns(profile)->lock));\n\n\tif (!parent) {\n\t\tstruct aa_profile *p;\n\t\tp = aa_deref_parent(profile);\n\t\tdent = prof_dir(p);\n\t\tif (!dent) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto fail2;\n\t\t}\n\t\t/* adding to parent that previously didn't have children */\n\t\tdent = aafs_create_dir(\"profiles\", dent);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprof_child_dir(p) = parent = dent;\n\t}\n\n\tif (!profile->dirname) {\n\t\tint len, id_len;\n\t\tlen = mangle_name(profile->base.name, NULL);\n\t\tid_len = snprintf(NULL, 0, \".%ld\", profile->ns->uniq_id);\n\n\t\tprofile->dirname = kmalloc(len + id_len + 1, GFP_KERNEL);\n\t\tif (!profile->dirname) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto fail2;\n\t\t}\n\n\t\tmangle_name(profile->base.name, profile->dirname);\n\t\tsprintf(profile->dirname + len, \".%ld\", profile->ns->uniq_id++);\n\t}\n\n\tdent = aafs_create_dir(profile->dirname, parent);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprof_dir(profile) = dir = dent;\n\n\tdent = create_profile_file(dir, \"name\", profile,\n\t\t\t\t   &seq_profile_name_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_NAME] = dent;\n\n\tdent = create_profile_file(dir, \"mode\", profile,\n\t\t\t\t   &seq_profile_mode_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_MODE] = dent;\n\n\tdent = create_profile_file(dir, \"attach\", profile,\n\t\t\t\t   &seq_profile_attach_fops);\n\tif (IS_ERR(dent))\n\t\tgoto fail;\n\tprofile->dents[AAFS_PROF_ATTACH] = dent;\n\n\tif (profile->hash) {\n\t\tdent = create_profile_file(dir, \"sha256\", profile,\n\t\t\t\t\t   &seq_profile_hash_fops);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\tprofile->dents[AAFS_PROF_HASH] = dent;\n\t}\n\n// #ifdef CONFIG_SECURITY_APPARMOR_EXPORT_BINARY\n\tif (profile->rawdata) {\n\t\tif (aa_g_hash_policy) {\n\t\t\tdent = aafs_create(\"raw_sha256\", S_IFLNK | 0444, dir,\n\t\t\t\t\t   profile->label.proxy, NULL, NULL,\n\t\t\t\t\t   &rawdata_link_sha256_iops);\n\t\t\tif (IS_ERR(dent))\n\t\t\t\tgoto fail;\n\t\t\taa_get_proxy(profile->label.proxy);\n\t\t\tprofile->dents[AAFS_PROF_RAW_HASH] = dent;\n\t\t}\n\t\tdent = aafs_create(\"raw_abi\", S_IFLNK | 0444, dir,\n\t\t\t\t   profile->label.proxy, NULL, NULL,\n\t\t\t\t   &rawdata_link_abi_iops);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\taa_get_proxy(profile->label.proxy);\n\t\tprofile->dents[AAFS_PROF_RAW_ABI] = dent;\n\n\t\tdent = aafs_create(\"raw_data\", S_IFLNK | 0444, dir,\n\t\t\t\t   profile->label.proxy, NULL, NULL,\n\t\t\t\t   &rawdata_link_data_iops);\n\t\tif (IS_ERR(dent))\n\t\t\tgoto fail;\n\t\taa_get_proxy(profile->label.proxy);\n\t\tprofile->dents[AAFS_PROF_RAW_DATA] = dent;\n\t}\n#endif /*CONFIG_SECURITY_APPARMOR_EXPORT_BINARY */\n\n\tlist_for_each_entry(child, &profile->base.profiles, base.list) {\n\t\terror = __aafs_profile_mkdir(child, prof_child_dir(profile));\n\t\tif (error)\n\t\t\tgoto fail2;\n\t}\n\n\treturn 0;\n\nfail:\n\terror = PTR_ERR(dent);\n\nfail2:\n\t__aafs_profile_rmdir(profile);\n\n\treturn error;\n}\n",
      "cve_list": [
        "CVE-2024-46721"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "arch/arm64/kvm/sys_regs.c",
      "func_name": "access_gic_sgi",
      "func_body": "static bool access_gic_sgi(struct kvm_vcpu *vcpu,\n\t\t\t   struct sys_reg_params *p,\n\t\t\t   const struct sys_reg_desc *r)\n{\n\tbool g1;\n\n\tif (!kvm_has_gicv3(vcpu->kvm)) {\n\t\tkvm_inject_undefined(vcpu);\n\t\treturn false;\n\t}\n\n\tif (!p->is_write)\n\t\treturn read_from_write_only(vcpu, p, r);\n\n\t/*\n\t * In a system where GICD_CTLR.DS=1, a ICC_SGI0R_EL1 access generates\n\t * Group0 SGIs only, while ICC_SGI1R_EL1 can generate either group,\n\t * depending on the SGI configuration. ICC_ASGI1R_EL1 is effectively\n\t * equivalent to ICC_SGI0R_EL1, as there is no \"alternative\" secure\n\t * group.\n\t */\n\tif (p->Op0 == 0) {\t\t/* AArch32 */\n\t\tswitch (p->Op1) {\n\t\tdefault:\t\t/* Keep GCC quiet */\n\t\tcase 0:\t\t\t/* ICC_SGI1R */\n\t\t\tg1 = true;\n\t\t\tbreak;\n\t\tcase 1:\t\t\t/* ICC_ASGI1R */\n\t\tcase 2:\t\t\t/* ICC_SGI0R */\n\t\t\tg1 = false;\n\t\t\tbreak;\n\t\t}\n\t} else {\t\t\t/* AArch64 */\n\t\tswitch (p->Op2) {\n\t\tdefault:\t\t/* Keep GCC quiet */\n\t\tcase 5:\t\t\t/* ICC_SGI1R_EL1 */\n\t\t\tg1 = true;\n\t\t\tbreak;\n\t\tcase 6:\t\t\t/* ICC_ASGI1R_EL1 */\n\t\tcase 7:\t\t\t/* ICC_SGI0R_EL1 */\n\t\t\tg1 = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvgic_v3_dispatch_sgi(vcpu, p->regval, g1);\n\n\treturn true;\n}\n",
      "cve_list": [
        "CVE-2024-46707"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/crypto/ccp/sev-dev.c",
      "func_name": "__sev_snp_shutdown_locked",
      "func_body": "static int __sev_snp_shutdown_locked(int *error, bool panic)\n{\n\tstruct psp_device *psp = psp_master;\n\tstruct sev_device *sev;\n\tstruct sev_data_snp_shutdown_ex data;\n\tint ret;\n\n\tif (!psp || !psp->sev_data)\n\t\treturn 0;\n\n\tsev = psp->sev_data;\n\n\tif (!sev->snp_initialized)\n\t\treturn 0;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.len = sizeof(data);\n\tdata.iommu_snp_shutdown = 1;\n\n\t/*\n\t * If invoked during panic handling, local interrupts are disabled\n\t * and all CPUs are stopped, so wbinvd_on_all_cpus() can't be called.\n\t * In that case, a wbinvd() is done on remote CPUs via the NMI\n\t * callback, so only a local wbinvd() is needed here.\n\t */\n\tif (!panic)\n\t\twbinvd_on_all_cpus();\n\telse\n\t\twbinvd();\n\n\tret = __sev_do_cmd_locked(SEV_CMD_SNP_SHUTDOWN_EX, &data, error);\n\t/* SHUTDOWN may require DF_FLUSH */\n\tif (*error == SEV_RET_DFFLUSH_REQUIRED) {\n\t\tret = __sev_do_cmd_locked(SEV_CMD_SNP_DF_FLUSH, NULL, NULL);\n\t\tif (ret) {\n\t\t\tdev_err(sev->dev, \"SEV-SNP DF_FLUSH failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\t/* reissue the shutdown command */\n\t\tret = __sev_do_cmd_locked(SEV_CMD_SNP_SHUTDOWN_EX, &data,\n\t\t\t\t\t  error);\n\t}\n\tif (ret) {\n\t\tdev_err(sev->dev, \"SEV-SNP firmware shutdown failed\\n\");\n\t\treturn ret;\n\t}\n\n\t/*\n\t * SNP_SHUTDOWN_EX with IOMMU_SNP_SHUTDOWN set to 1 disables SNP\n\t * enforcement by the IOMMU and also transitions all pages\n\t * associated with the IOMMU to the Reclaim state.\n\t * Firmware was transitioning the IOMMU pages to Hypervisor state\n\t * before version 1.53. But, accounting for the number of assigned\n\t * 4kB pages in a 2M page was done incorrectly by not transitioning\n\t * to the Reclaim state. This resulted in RMP #PF when later accessing\n\t * the 2M page containing those pages during kexec boot. Hence, the\n\t * firmware now transitions these pages to Reclaim state and hypervisor\n\t * needs to transition these pages to shared state. SNP Firmware\n\t * version 1.53 and above are needed for kexec boot.\n\t */\n\tret = amd_iommu_snp_disable();\n\tif (ret) {\n\t\tdev_err(sev->dev, \"SNP IOMMU shutdown failed\\n\");\n\t\treturn ret;\n\t}\n\n\tsev->snp_initialized = false;\n\tdev_dbg(sev->dev, \"SEV-SNP firmware shutdown\\n\");\n\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-43874"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/msm/adreno/a6xx_gpu.c",
      "func_name": "a6xx_gpu_init",
      "func_body": "struct msm_gpu *a6xx_gpu_init(struct drm_device *dev)\n{\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct platform_device *pdev = priv->gpu_pdev;\n\tstruct adreno_platform_config *config = pdev->dev.platform_data;\n\tstruct device_node *node;\n\tstruct a6xx_gpu *a6xx_gpu;\n\tstruct adreno_gpu *adreno_gpu;\n\tstruct msm_gpu *gpu;\n\tbool is_a7xx;\n\tint ret;\n\n\ta6xx_gpu = kzalloc(sizeof(*a6xx_gpu), GFP_KERNEL);\n\tif (!a6xx_gpu)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tadreno_gpu = &a6xx_gpu->base;\n\tgpu = &adreno_gpu->base;\n\n\tmutex_init(&a6xx_gpu->gmu.lock);\n\n\tadreno_gpu->registers = NULL;\n\n\t/* Check if there is a GMU phandle and set it up */\n\tnode = of_parse_phandle(pdev->dev.of_node, \"qcom,gmu\", 0);\n\t/* FIXME: How do we gracefully handle this? */\n\tBUG_ON(!node);\n\n\tadreno_gpu->gmu_is_wrapper = of_device_is_compatible(node, \"qcom,adreno-gmu-wrapper\");\n\n\tadreno_gpu->base.hw_apriv =\n\t\t!!(config->info->quirks & ADRENO_QUIRK_HAS_HW_APRIV);\n\n\t/* gpu->info only gets assigned in adreno_gpu_init() */\n\tis_a7xx = config->info->family == ADRENO_7XX_GEN1 ||\n\t\t  config->info->family == ADRENO_7XX_GEN2 ||\n\t\t  config->info->family == ADRENO_7XX_GEN3;\n\n\ta6xx_llc_slices_init(pdev, a6xx_gpu, is_a7xx);\n\n\tret = a6xx_set_supported_hw(&pdev->dev, config->info);\n\tif (ret) {\n\t\ta6xx_llc_slices_destroy(a6xx_gpu);\n\t\tkfree(a6xx_gpu);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (is_a7xx)\n\t\tret = adreno_gpu_init(dev, pdev, adreno_gpu, &funcs_a7xx, 1);\n\telse if (adreno_has_gmu_wrapper(adreno_gpu))\n\t\tret = adreno_gpu_init(dev, pdev, adreno_gpu, &funcs_gmuwrapper, 1);\n\telse\n\t\tret = adreno_gpu_init(dev, pdev, adreno_gpu, &funcs, 1);\n\tif (ret) {\n\t\ta6xx_destroy(&(a6xx_gpu->base.base));\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/*\n\t * For now only clamp to idle freq for devices where this is known not\n\t * to cause power supply issues:\n\t */\n\tif (adreno_is_a618(adreno_gpu) || adreno_is_7c3(adreno_gpu))\n\t\tpriv->gpu_clamp_to_idle = true;\n\n\tif (adreno_has_gmu_wrapper(adreno_gpu))\n\t\tret = a6xx_gmu_wrapper_init(a6xx_gpu, node);\n\telse\n\t\tret = a6xx_gmu_init(a6xx_gpu, node);\n\tof_node_put(node);\n\tif (ret) {\n\t\ta6xx_destroy(&(a6xx_gpu->base.base));\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (gpu->aspace)\n\t\tmsm_mmu_set_fault_handler(gpu->aspace->mmu, gpu,\n\t\t\t\ta6xx_fault_handler);\n\n\ta6xx_calc_ubwc_config(adreno_gpu);\n\n\treturn gpu;\n}\n",
      "cve_list": [
        "CVE-2024-38390"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/spi/spi.c",
      "func_name": "__spi_sync",
      "func_body": "static int __spi_sync(struct spi_device *spi, struct spi_message *message)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tunsigned long flags;\n\tint status;\n\tstruct spi_controller *ctlr = spi->controller;\n\n\tif (__spi_check_suspended(ctlr)) {\n\t\tdev_warn_once(&spi->dev, \"Attempted to sync while suspend\\n\");\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tstatus = spi_maybe_optimize_message(spi, message);\n\tif (status)\n\t\treturn status;\n\n\tSPI_STATISTICS_INCREMENT_FIELD(ctlr->pcpu_statistics, spi_sync);\n\tSPI_STATISTICS_INCREMENT_FIELD(spi->pcpu_statistics, spi_sync);\n\n\t/*\n\t * Checking queue_empty here only guarantees async/sync message\n\t * ordering when coming from the same context. It does not need to\n\t * guard against reentrancy from a different context. The io_mutex\n\t * will catch those cases.\n\t */\n\tif (READ_ONCE(ctlr->queue_empty) && !ctlr->must_async) {\n\t\tmessage->actual_length = 0;\n\t\tmessage->status = -EINPROGRESS;\n\n\t\ttrace_spi_message_submit(message);\n\n\t\tSPI_STATISTICS_INCREMENT_FIELD(ctlr->pcpu_statistics, spi_sync_immediate);\n\t\tSPI_STATISTICS_INCREMENT_FIELD(spi->pcpu_statistics, spi_sync_immediate);\n\n\t\t__spi_transfer_message_noqueue(ctlr, message);\n\n\t\treturn message->status;\n\t}\n\n\t/*\n\t * There are messages in the async queue that could have originated\n\t * from the same context, so we need to preserve ordering.\n\t * Therefor we send the message to the async queue and wait until they\n\t * are completed.\n\t */\n\tmessage->complete = spi_complete;\n\tmessage->context = &done;\n\n\tspin_lock_irqsave(&ctlr->bus_lock_spinlock, flags);\n\tstatus = __spi_async(spi, message);\n\tspin_unlock_irqrestore(&ctlr->bus_lock_spinlock, flags);\n\n\tif (status == 0) {\n\t\twait_for_completion(&done);\n\t\tstatus = message->status;\n\t}\n\tmessage->complete = NULL;\n\tmessage->context = NULL;\n\n\treturn status;\n}\n",
      "cve_list": [
        "CVE-2024-36930"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/wireless/mediatek/mt76/mt7921/main.c",
      "func_name": "mt7921_ipv6_addr_change",
      "func_body": "static void mt7921_ipv6_addr_change(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct inet6_dev *idev)\n{\n\tstruct mt792x_vif *mvif = (struct mt792x_vif *)vif->drv_priv;\n\tstruct mt792x_dev *dev = mt792x_hw_dev(hw);\n\tstruct inet6_ifaddr *ifa;\n\tstruct in6_addr ns_addrs[IEEE80211_BSS_ARP_ADDR_LIST_LEN];\n\tstruct sk_buff *skb;\n\tu8 i, idx = 0;\n\n\tstruct {\n\t\tstruct {\n\t\t\tu8 bss_idx;\n\t\t\tu8 pad[3];\n\t\t} __packed hdr;\n\t\tstruct mt76_connac_arpns_tlv arpns;\n\t} req_hdr = {\n\t\t.hdr = {\n\t\t\t.bss_idx = mvif->bss_conf.mt76.idx,\n\t\t},\n\t\t.arpns = {\n\t\t\t.tag = cpu_to_le16(UNI_OFFLOAD_OFFLOAD_ND),\n\t\t\t.mode = 2,  /* update */\n\t\t\t.option = 1, /* update only */\n\t\t},\n\t};\n\n\tread_lock_bh(&idev->lock);\n\tlist_for_each_entry(ifa, &idev->addr_list, if_list) {\n\t\tif (ifa->flags & IFA_F_TENTATIVE)\n\t\t\tcontinue;\n\t\tns_addrs[idx] = ifa->addr;\n\t\tif (++idx >= IEEE80211_BSS_ARP_ADDR_LIST_LEN)\n\t\t\tbreak;\n\t}\n\tread_unlock_bh(&idev->lock);\n\n\tif (!idx)\n\t\treturn;\n\n\treq_hdr.arpns.ips_num = idx;\n\treq_hdr.arpns.len = cpu_to_le16(sizeof(struct mt76_connac_arpns_tlv)\n\t\t\t\t\t+ idx * sizeof(struct in6_addr));\n\tskb = __mt76_mcu_msg_alloc(&dev->mt76, &req_hdr,\n\t\t\tsizeof(req_hdr) + idx * sizeof(struct in6_addr),\n\t\t\tsizeof(req_hdr), GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tfor (i = 0; i < idx; i++)\n\t\tskb_put_data(skb, &ns_addrs[i].in6_u, sizeof(struct in6_addr));\n\n\tskb_queue_tail(&dev->ipv6_ns_list, skb);\n\n\tieee80211_queue_work(dev->mt76.hw, &dev->ipv6_ns_work);\n}\n",
      "cve_list": [
        "CVE-2024-46860"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "arch/powerpc/platforms/pseries/iommu.c",
      "func_name": "pci_dma_bus_setup_pSeriesLP",
      "func_body": "static void pci_dma_bus_setup_pSeriesLP(struct pci_bus *bus)\n{\n\tstruct iommu_table *tbl;\n\tstruct device_node *dn, *pdn;\n\tstruct pci_dn *ppci;\n\tstruct dynamic_dma_window_prop prop;\n\n\tdn = pci_bus_to_OF_node(bus);\n\n\tpr_debug(\"pci_dma_bus_setup_pSeriesLP: setting up bus %pOF\\n\",\n\t\t dn);\n\n\tpdn = pci_dma_find(dn, &prop);\n\n\t/* In PPC architecture, there will always be DMA window on bus or one of the\n\t * parent bus. During reboot, there will be ibm,dma-window property to\n\t * define DMA window. For kdump, there will at least be default window or DDW\n\t * or both.\n\t * There is an exception to the above. In case the PE goes into frozen\n\t * state, firmware may not provide ibm,dma-window property at the time\n\t * of LPAR boot up.\n\t */\n\n\tif (!pdn) {\n\t\tpr_debug(\"  no ibm,dma-window property !\\n\");\n\t\treturn;\n\t}\n\n\tppci = PCI_DN(pdn);\n\n\tpr_debug(\"  parent is %pOF, iommu_table: 0x%p\\n\",\n\t\t pdn, ppci->table_group);\n\n\tif (!ppci->table_group) {\n\t\tppci->table_group = iommu_pseries_alloc_group(ppci->phb->node);\n\t\ttbl = ppci->table_group->tables[0];\n\n\t\tiommu_table_setparms_common(tbl, ppci->phb->bus->number,\n\t\t\t\tbe32_to_cpu(prop.liobn),\n\t\t\t\tbe64_to_cpu(prop.dma_base),\n\t\t\t\t1ULL << be32_to_cpu(prop.window_shift),\n\t\t\t\tbe32_to_cpu(prop.tce_shift), NULL,\n\t\t\t\t&iommu_table_lpar_multi_ops);\n\n\t\t/* Only for normal boot with default window. Doesn't matter even\n\t\t * if we set these with DDW which is 64bit during kdump, since\n\t\t * these will not be used during kdump.\n\t\t */\n\t\tppci->table_group->tce32_start = be64_to_cpu(prop.dma_base);\n\t\tppci->table_group->tce32_size = 1 << be32_to_cpu(prop.window_shift);\n\n\t\tif (!iommu_init_table(tbl, ppci->phb->node, 0, 0))\n\t\t\tpanic(\"Failed to initialize iommu table\");\n\n\t\tiommu_register_group(ppci->table_group,\n\t\t\t\tpci_domain_nr(bus), 0);\n\t\tpr_debug(\"  created table: %p\\n\", ppci->table_group);\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-36926"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c",
      "func_name": "amdgpu_ras_interrupt_dispatch",
      "func_body": "int amdgpu_ras_interrupt_dispatch(struct amdgpu_device *adev,\n\t\tstruct ras_dispatch_if *info)\n{\n\tstruct ras_manager *obj;\n\tstruct ras_ih_data *data;\n\n\tobj = amdgpu_ras_find_obj(adev, &info->head);\n\tif (!obj)\n\t\treturn -EINVAL;\n\n\tdata = &obj->ih_data;\n\n\tif (data->inuse == 0)\n\t\treturn 0;\n\n\t/* Might be overflow... */\n\tmemcpy(&data->ring[data->wptr], info->entry,\n\t\t\tdata->element_size);\n\n\twmb();\n\tdata->wptr = (data->aligned_element_size +\n\t\t\tdata->wptr) % data->ring_size;\n\n\tschedule_work(&data->ih_work);\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-43908"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ethtool/pse-pd.c",
      "func_name": "ethnl_set_pse",
      "func_body": "static int\nethnl_set_pse(struct ethnl_req_info *req_info, struct genl_info *info)\n{\n\tstruct net_device *dev = req_info->dev;\n\tstruct pse_control_config config = {};\n\tstruct nlattr **tb = info->attrs;\n\tstruct phy_device *phydev;\n\n\tphydev = dev->phydev;\n\t/* These values are already validated by the ethnl_pse_set_policy */\n\tif (tb[ETHTOOL_A_PODL_PSE_ADMIN_CONTROL])\n\t\tconfig.podl_admin_control = nla_get_u32(tb[ETHTOOL_A_PODL_PSE_ADMIN_CONTROL]);\n\tif (tb[ETHTOOL_A_C33_PSE_ADMIN_CONTROL])\n\t\tconfig.c33_admin_control = nla_get_u32(tb[ETHTOOL_A_C33_PSE_ADMIN_CONTROL]);\n\n\t/* Return errno directly - PSE has no notification\n\t * pse_ethtool_set_config() will do nothing if the config is null\n\t */\n\treturn pse_ethtool_set_config(phydev->psec, info->extack, &config);\n}\n",
      "cve_list": [
        "CVE-2024-43836"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ipv6/ip6_output.c",
      "func_name": "ip6_output",
      "func_body": "int ip6_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb_dst(skb)->dev, *indev = skb->dev;\n\tstruct inet6_dev *idev = ip6_dst_idev(skb_dst(skb));\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb->dev = dev;\n\n\tif (unlikely(!idev || READ_ONCE(idev->cnf.disable_ipv6))) {\n\t\tIP6_INC_STATS(net, idev, IPSTATS_MIB_OUTDISCARDS);\n\t\tkfree_skb_reason(skb, SKB_DROP_REASON_IPV6DISABLED);\n\t\treturn 0;\n\t}\n\n\treturn NF_HOOK_COND(NFPROTO_IPV6, NF_INET_POST_ROUTING,\n\t\t\t    net, sk, skb, indev, dev,\n\t\t\t    ip6_finish_output,\n\t\t\t    !(IP6CB(skb)->flags & IP6SKB_REROUTED));\n}\n",
      "cve_list": [
        "CVE-2024-36901"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/smb/server/smb2pdu.c",
      "func_name": "parse_durable_handle_context",
      "func_body": "static int parse_durable_handle_context(struct ksmbd_work *work,\n\t\t\t\t\tstruct smb2_create_req *req,\n\t\t\t\t\tstruct lease_ctx_info *lc,\n\t\t\t\t\tstruct durable_info *dh_info)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct create_context *context;\n\tint dh_idx, err = 0;\n\tu64 persistent_id = 0;\n\tint req_op_level;\n\tstatic const char * const durable_arr[] = {\"DH2C\", \"DHnC\", \"DH2Q\", \"DHnQ\"};\n\n\treq_op_level = req->RequestedOplockLevel;\n\tfor (dh_idx = DURABLE_RECONN_V2; dh_idx <= ARRAY_SIZE(durable_arr);\n\t     dh_idx++) {\n\t\tcontext = smb2_find_context_vals(req, durable_arr[dh_idx - 1], 4);\n\t\tif (IS_ERR(context)) {\n\t\t\terr = PTR_ERR(context);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!context)\n\t\t\tcontinue;\n\n\t\tswitch (dh_idx) {\n\t\tcase DURABLE_RECONN_V2:\n\t\t{\n\t\t\tstruct create_durable_reconn_v2_req *recon_v2;\n\n\t\t\tif (dh_info->type == DURABLE_RECONN ||\n\t\t\t    dh_info->type == DURABLE_REQ_V2) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\trecon_v2 = (struct create_durable_reconn_v2_req *)context;\n\t\t\tpersistent_id = recon_v2->Fid.PersistentFileId;\n\t\t\tdh_info->fp = ksmbd_lookup_durable_fd(persistent_id);\n\t\t\tif (!dh_info->fp) {\n\t\t\t\tksmbd_debug(SMB, \"Failed to get durable handle state\\n\");\n\t\t\t\terr = -EBADF;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (memcmp(dh_info->fp->create_guid, recon_v2->CreateGuid,\n\t\t\t\t   SMB2_CREATE_GUID_SIZE)) {\n\t\t\t\terr = -EBADF;\n\t\t\t\tksmbd_put_durable_fd(dh_info->fp);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tdh_info->type = dh_idx;\n\t\t\tdh_info->reconnected = true;\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t\"reconnect v2 Persistent-id from reconnect = %llu\\n\",\n\t\t\t\t\tpersistent_id);\n\t\t\tbreak;\n\t\t}\n\t\tcase DURABLE_RECONN:\n\t\t{\n\t\t\tstruct create_durable_reconn_req *recon;\n\n\t\t\tif (dh_info->type == DURABLE_RECONN_V2 ||\n\t\t\t    dh_info->type == DURABLE_REQ_V2) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\trecon = (struct create_durable_reconn_req *)context;\n\t\t\tpersistent_id = recon->Data.Fid.PersistentFileId;\n\t\t\tdh_info->fp = ksmbd_lookup_durable_fd(persistent_id);\n\t\t\tif (!dh_info->fp) {\n\t\t\t\tksmbd_debug(SMB, \"Failed to get durable handle state\\n\");\n\t\t\t\terr = -EBADF;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tdh_info->type = dh_idx;\n\t\t\tdh_info->reconnected = true;\n\t\t\tksmbd_debug(SMB, \"reconnect Persistent-id from reconnect = %llu\\n\",\n\t\t\t\t    persistent_id);\n\t\t\tbreak;\n\t\t}\n\t\tcase DURABLE_REQ_V2:\n\t\t{\n\t\t\tstruct create_durable_req_v2 *durable_v2_blob;\n\n\t\t\tif (dh_info->type == DURABLE_RECONN ||\n\t\t\t    dh_info->type == DURABLE_RECONN_V2) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tdurable_v2_blob =\n\t\t\t\t(struct create_durable_req_v2 *)context;\n\t\t\tksmbd_debug(SMB, \"Request for durable v2 open\\n\");\n\t\t\tdh_info->fp = ksmbd_lookup_fd_cguid(durable_v2_blob->CreateGuid);\n\t\t\tif (dh_info->fp) {\n\t\t\t\tif (!memcmp(conn->ClientGUID, dh_info->fp->client_guid,\n\t\t\t\t\t    SMB2_CLIENT_GUID_SIZE)) {\n\t\t\t\t\tif (!(req->hdr.Flags & SMB2_FLAGS_REPLAY_OPERATION)) {\n\t\t\t\t\t\terr = -ENOEXEC;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\tdh_info->fp->conn = conn;\n\t\t\t\t\tdh_info->reconnected = true;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((lc && (lc->req_state & SMB2_LEASE_HANDLE_CACHING_LE)) ||\n\t\t\t    req_op_level == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t\t\tdh_info->CreateGuid =\n\t\t\t\t\tdurable_v2_blob->CreateGuid;\n\t\t\t\tdh_info->persistent =\n\t\t\t\t\tle32_to_cpu(durable_v2_blob->Flags);\n\t\t\t\tdh_info->timeout =\n\t\t\t\t\tle32_to_cpu(durable_v2_blob->Timeout);\n\t\t\t\tdh_info->type = dh_idx;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase DURABLE_REQ:\n\t\t\tif (dh_info->type == DURABLE_RECONN)\n\t\t\t\tgoto out;\n\t\t\tif (dh_info->type == DURABLE_RECONN_V2 ||\n\t\t\t    dh_info->type == DURABLE_REQ_V2) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif ((lc && (lc->req_state & SMB2_LEASE_HANDLE_CACHING_LE)) ||\n\t\t\t    req_op_level == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t\t\tksmbd_debug(SMB, \"Request for durable open\\n\");\n\t\t\t\tdh_info->type = dh_idx;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-46742"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/smb/server/smb2pdu.c",
      "func_name": "smb2_open",
      "func_body": "int smb2_open(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct ksmbd_tree_connect *tcon = work->tcon;\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct path path, parent_path;\n\tstruct ksmbd_share_config *share = tcon->share_conf;\n\tstruct ksmbd_file *fp = NULL;\n\tstruct file *filp = NULL;\n\tstruct mnt_idmap *idmap = NULL;\n\tstruct kstat stat;\n\tstruct create_context *context;\n\tstruct lease_ctx_info *lc = NULL;\n\tstruct create_ea_buf_req *ea_buf = NULL;\n\tstruct oplock_info *opinfo;\n\tstruct durable_info dh_info = {0};\n\t__le32 *next_ptr = NULL;\n\tint req_op_level = 0, open_flags = 0, may_flags = 0, file_info = 0;\n\tint rc = 0;\n\tint contxt_cnt = 0, query_disk_id = 0;\n\tint maximal_access_ctxt = 0, posix_ctxt = 0;\n\tint s_type = 0;\n\tint next_off = 0;\n\tchar *name = NULL;\n\tchar *stream_name = NULL;\n\tbool file_present = false, created = false, already_permitted = false;\n\tint share_ret, need_truncate = 0;\n\tu64 time;\n\tumode_t posix_mode = 0;\n\t__le32 daccess, maximal_access = 0;\n\tint iov_len = 0;\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\tif (req->hdr.NextCommand && !work->next_smb2_rcv_hdr_off &&\n\t    (req->hdr.Flags & SMB2_FLAGS_RELATED_OPERATIONS)) {\n\t\tksmbd_debug(SMB, \"invalid flag in chained command\\n\");\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_share_config_flag(share, KSMBD_SHARE_FLAG_PIPE)) {\n\t\tksmbd_debug(SMB, \"IPC pipe create request\\n\");\n\t\treturn create_smb2_pipe(work);\n\t}\n\n\tif (req->NameLength) {\n\t\tname = smb2_get_name((char *)req + le16_to_cpu(req->NameOffset),\n\t\t\t\t     le16_to_cpu(req->NameLength),\n\t\t\t\t     work->conn->local_nls);\n\t\tif (IS_ERR(name)) {\n\t\t\trc = PTR_ERR(name);\n\t\t\tname = NULL;\n\t\t\tgoto err_out2;\n\t\t}\n\n\t\tksmbd_debug(SMB, \"converted name = %s\\n\", name);\n\t\tif (strchr(name, ':')) {\n\t\t\tif (!test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t\t\t    KSMBD_SHARE_FLAG_STREAMS)) {\n\t\t\t\trc = -EBADF;\n\t\t\t\tgoto err_out2;\n\t\t\t}\n\t\t\trc = parse_stream_name(name, &stream_name, &s_type);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto err_out2;\n\t\t}\n\n\t\trc = ksmbd_validate_filename(name);\n\t\tif (rc < 0)\n\t\t\tgoto err_out2;\n\n\t\tif (ksmbd_share_veto_filename(share, name)) {\n\t\t\trc = -ENOENT;\n\t\t\tksmbd_debug(SMB, \"Reject open(), vetoed file: %s\\n\",\n\t\t\t\t    name);\n\t\t\tgoto err_out2;\n\t\t}\n\t} else {\n\t\tname = kstrdup(\"\", GFP_KERNEL);\n\t\tif (!name) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_out2;\n\t\t}\n\t}\n\n\treq_op_level = req->RequestedOplockLevel;\n\n\tif (server_conf.flags & KSMBD_GLOBAL_FLAG_DURABLE_HANDLE &&\n\t    req->CreateContextsOffset) {\n\t\tlc = parse_lease_state(req);\n\t\trc = parse_durable_handle_context(work, req, lc, &dh_info);\n\t\tif (rc) {\n\t\t\tksmbd_debug(SMB, \"error parsing durable handle context\\n\");\n\t\t\tgoto err_out2;\n\t\t}\n\n\t\tif (dh_info.reconnected == true) {\n\t\t\trc = smb2_check_durable_oplock(conn, share, dh_info.fp, lc, name);\n\t\t\tif (rc) {\n\t\t\t\tksmbd_put_durable_fd(dh_info.fp);\n\t\t\t\tgoto err_out2;\n\t\t\t}\n\n\t\t\trc = ksmbd_reopen_durable_fd(work, dh_info.fp);\n\t\t\tif (rc) {\n\t\t\t\tksmbd_put_durable_fd(dh_info.fp);\n\t\t\t\tgoto err_out2;\n\t\t\t}\n\n\t\t\tif (ksmbd_override_fsids(work)) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tksmbd_put_durable_fd(dh_info.fp);\n\t\t\t\tgoto err_out2;\n\t\t\t}\n\n\t\t\tfp = dh_info.fp;\n\t\t\tfile_info = FILE_OPENED;\n\n\t\t\trc = ksmbd_vfs_getattr(&fp->filp->f_path, &stat);\n\t\t\tif (rc)\n\t\t\t\tgoto err_out2;\n\n\t\t\tksmbd_put_durable_fd(fp);\n\t\t\tgoto reconnected_fp;\n\t\t}\n\t} else if (req_op_level == SMB2_OPLOCK_LEVEL_LEASE)\n\t\tlc = parse_lease_state(req);\n\n\tif (le32_to_cpu(req->ImpersonationLevel) > le32_to_cpu(IL_DELEGATE)) {\n\t\tpr_err(\"Invalid impersonationlevel : 0x%x\\n\",\n\t\t       le32_to_cpu(req->ImpersonationLevel));\n\t\trc = -EIO;\n\t\trsp->hdr.Status = STATUS_BAD_IMPERSONATION_LEVEL;\n\t\tgoto err_out2;\n\t}\n\n\tif (req->CreateOptions && !(req->CreateOptions & CREATE_OPTIONS_MASK_LE)) {\n\t\tpr_err(\"Invalid create options : 0x%x\\n\",\n\t\t       le32_to_cpu(req->CreateOptions));\n\t\trc = -EINVAL;\n\t\tgoto err_out2;\n\t} else {\n\t\tif (req->CreateOptions & FILE_SEQUENTIAL_ONLY_LE &&\n\t\t    req->CreateOptions & FILE_RANDOM_ACCESS_LE)\n\t\t\treq->CreateOptions = ~(FILE_SEQUENTIAL_ONLY_LE);\n\n\t\tif (req->CreateOptions &\n\t\t    (FILE_OPEN_BY_FILE_ID_LE | CREATE_TREE_CONNECTION |\n\t\t     FILE_RESERVE_OPFILTER_LE)) {\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto err_out2;\n\t\t}\n\n\t\tif (req->CreateOptions & FILE_DIRECTORY_FILE_LE) {\n\t\t\tif (req->CreateOptions & FILE_NON_DIRECTORY_FILE_LE) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out2;\n\t\t\t} else if (req->CreateOptions & FILE_NO_COMPRESSION_LE) {\n\t\t\t\treq->CreateOptions = ~(FILE_NO_COMPRESSION_LE);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (le32_to_cpu(req->CreateDisposition) >\n\t    le32_to_cpu(FILE_OVERWRITE_IF_LE)) {\n\t\tpr_err(\"Invalid create disposition : 0x%x\\n\",\n\t\t       le32_to_cpu(req->CreateDisposition));\n\t\trc = -EINVAL;\n\t\tgoto err_out2;\n\t}\n\n\tif (!(req->DesiredAccess & DESIRED_ACCESS_MASK)) {\n\t\tpr_err(\"Invalid desired access : 0x%x\\n\",\n\t\t       le32_to_cpu(req->DesiredAccess));\n\t\trc = -EACCES;\n\t\tgoto err_out2;\n\t}\n\n\tif (req->FileAttributes && !(req->FileAttributes & FILE_ATTRIBUTE_MASK_LE)) {\n\t\tpr_err(\"Invalid file attribute : 0x%x\\n\",\n\t\t       le32_to_cpu(req->FileAttributes));\n\t\trc = -EINVAL;\n\t\tgoto err_out2;\n\t}\n\n\tif (req->CreateContextsOffset) {\n\t\t/* Parse non-durable handle create contexts */\n\t\tcontext = smb2_find_context_vals(req, SMB2_CREATE_EA_BUFFER, 4);\n\t\tif (IS_ERR(context)) {\n\t\t\trc = PTR_ERR(context);\n\t\t\tgoto err_out2;\n\t\t} else if (context) {\n\t\t\tea_buf = (struct create_ea_buf_req *)context;\n\t\t\tif (le16_to_cpu(context->DataOffset) +\n\t\t\t    le32_to_cpu(context->DataLength) <\n\t\t\t    sizeof(struct create_ea_buf_req)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out2;\n\t\t\t}\n\t\t\tif (req->CreateOptions & FILE_NO_EA_KNOWLEDGE_LE) {\n\t\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\t\t\trc = -EACCES;\n\t\t\t\tgoto err_out2;\n\t\t\t}\n\t\t}\n\n\t\tcontext = smb2_find_context_vals(req,\n\t\t\t\t\t\t SMB2_CREATE_QUERY_MAXIMAL_ACCESS_REQUEST, 4);\n\t\tif (IS_ERR(context)) {\n\t\t\trc = PTR_ERR(context);\n\t\t\tgoto err_out2;\n\t\t} else if (context) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"get query maximal access context\\n\");\n\t\t\tmaximal_access_ctxt = 1;\n\t\t}\n\n\t\tcontext = smb2_find_context_vals(req,\n\t\t\t\t\t\t SMB2_CREATE_TIMEWARP_REQUEST, 4);\n\t\tif (IS_ERR(context)) {\n\t\t\trc = PTR_ERR(context);\n\t\t\tgoto err_out2;\n\t\t} else if (context) {\n\t\t\tksmbd_debug(SMB, \"get timewarp context\\n\");\n\t\t\trc = -EBADF;\n\t\t\tgoto err_out2;\n\t\t}\n\n\t\tif (tcon->posix_extensions) {\n\t\t\tcontext = smb2_find_context_vals(req,\n\t\t\t\t\t\t\t SMB2_CREATE_TAG_POSIX, 16);\n\t\t\tif (IS_ERR(context)) {\n\t\t\t\trc = PTR_ERR(context);\n\t\t\t\tgoto err_out2;\n\t\t\t} else if (context) {\n\t\t\t\tstruct create_posix *posix =\n\t\t\t\t\t(struct create_posix *)context;\n\t\t\t\tif (le16_to_cpu(context->DataOffset) +\n\t\t\t\t    le32_to_cpu(context->DataLength) <\n\t\t\t\t    sizeof(struct create_posix) - 4) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto err_out2;\n\t\t\t\t}\n\t\t\t\tksmbd_debug(SMB, \"get posix context\\n\");\n\n\t\t\t\tposix_mode = le32_to_cpu(posix->Mode);\n\t\t\t\tposix_ctxt = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ksmbd_override_fsids(work)) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out2;\n\t}\n\n\trc = ksmbd_vfs_kern_path_locked(work, name, LOOKUP_NO_SYMLINKS,\n\t\t\t\t\t&parent_path, &path, 1);\n\tif (!rc) {\n\t\tfile_present = true;\n\n\t\tif (req->CreateOptions & FILE_DELETE_ON_CLOSE_LE) {\n\t\t\t/*\n\t\t\t * If file exists with under flags, return access\n\t\t\t * denied error.\n\t\t\t */\n\t\t\tif (req->CreateDisposition == FILE_OVERWRITE_IF_LE ||\n\t\t\t    req->CreateDisposition == FILE_OPEN_IF_LE) {\n\t\t\t\trc = -EACCES;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\tif (!test_tree_conn_flag(tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\t\trc = -EACCES;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t} else if (d_is_symlink(path.dentry)) {\n\t\t\trc = -EACCES;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tfile_present = true;\n\t\tidmap = mnt_idmap(path.mnt);\n\t} else {\n\t\tif (rc != -ENOENT)\n\t\t\tgoto err_out;\n\t\tksmbd_debug(SMB, \"can not get linux path for %s, rc = %d\\n\",\n\t\t\t    name, rc);\n\t\trc = 0;\n\t}\n\n\tif (stream_name) {\n\t\tif (req->CreateOptions & FILE_DIRECTORY_FILE_LE) {\n\t\t\tif (s_type == DATA_STREAM) {\n\t\t\t\trc = -EIO;\n\t\t\t\trsp->hdr.Status = STATUS_NOT_A_DIRECTORY;\n\t\t\t}\n\t\t} else {\n\t\t\tif (file_present && S_ISDIR(d_inode(path.dentry)->i_mode) &&\n\t\t\t    s_type == DATA_STREAM) {\n\t\t\t\trc = -EIO;\n\t\t\t\trsp->hdr.Status = STATUS_FILE_IS_A_DIRECTORY;\n\t\t\t}\n\t\t}\n\n\t\tif (req->CreateOptions & FILE_DIRECTORY_FILE_LE &&\n\t\t    req->FileAttributes & FILE_ATTRIBUTE_NORMAL_LE) {\n\t\t\trsp->hdr.Status = STATUS_NOT_A_DIRECTORY;\n\t\t\trc = -EIO;\n\t\t}\n\n\t\tif (rc < 0)\n\t\t\tgoto err_out;\n\t}\n\n\tif (file_present && req->CreateOptions & FILE_NON_DIRECTORY_FILE_LE &&\n\t    S_ISDIR(d_inode(path.dentry)->i_mode) &&\n\t    !(req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)) {\n\t\tksmbd_debug(SMB, \"open() argument is a directory: %s, %x\\n\",\n\t\t\t    name, req->CreateOptions);\n\t\trsp->hdr.Status = STATUS_FILE_IS_A_DIRECTORY;\n\t\trc = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tif (file_present && (req->CreateOptions & FILE_DIRECTORY_FILE_LE) &&\n\t    !(req->CreateDisposition == FILE_CREATE_LE) &&\n\t    !S_ISDIR(d_inode(path.dentry)->i_mode)) {\n\t\trsp->hdr.Status = STATUS_NOT_A_DIRECTORY;\n\t\trc = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tif (!stream_name && file_present &&\n\t    req->CreateDisposition == FILE_CREATE_LE) {\n\t\trc = -EEXIST;\n\t\tgoto err_out;\n\t}\n\n\tdaccess = smb_map_generic_desired_access(req->DesiredAccess);\n\n\tif (file_present && !(req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)) {\n\t\trc = smb_check_perm_dacl(conn, &path, &daccess,\n\t\t\t\t\t sess->user->uid);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\t}\n\n\tif (daccess & FILE_MAXIMAL_ACCESS_LE) {\n\t\tif (!file_present) {\n\t\t\tdaccess = cpu_to_le32(GENERIC_ALL_FLAGS);\n\t\t} else {\n\t\t\tksmbd_vfs_query_maximal_access(idmap,\n\t\t\t\t\t\t\t    path.dentry,\n\t\t\t\t\t\t\t    &daccess);\n\t\t\talready_permitted = true;\n\t\t}\n\t\tmaximal_access = daccess;\n\t}\n\n\topen_flags = smb2_create_open_flags(file_present, daccess,\n\t\t\t\t\t    req->CreateDisposition,\n\t\t\t\t\t    &may_flags,\n\t\treq->CreateOptions & FILE_DIRECTORY_FILE_LE ||\n\t\t(file_present && S_ISDIR(d_inode(path.dentry)->i_mode)));\n\n\tif (!test_tree_conn_flag(tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {\n\t\tif (open_flags & (O_CREAT | O_TRUNC)) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"User does not have write permission\\n\");\n\t\t\trc = -EACCES;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\t/*create file if not present */\n\tif (!file_present) {\n\t\trc = smb2_creat(work, &parent_path, &path, name, open_flags,\n\t\t\t\tposix_mode,\n\t\t\t\treq->CreateOptions & FILE_DIRECTORY_FILE_LE);\n\t\tif (rc) {\n\t\t\tif (rc == -ENOENT) {\n\t\t\t\trc = -EIO;\n\t\t\t\trsp->hdr.Status = STATUS_OBJECT_PATH_NOT_FOUND;\n\t\t\t}\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tcreated = true;\n\t\tidmap = mnt_idmap(path.mnt);\n\t\tif (ea_buf) {\n\t\t\tif (le32_to_cpu(ea_buf->ccontext.DataLength) <\n\t\t\t    sizeof(struct smb2_ea_info)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\trc = smb2_set_ea(&ea_buf->ea,\n\t\t\t\t\t le32_to_cpu(ea_buf->ccontext.DataLength),\n\t\t\t\t\t &path, false);\n\t\t\tif (rc == -EOPNOTSUPP)\n\t\t\t\trc = 0;\n\t\t\telse if (rc)\n\t\t\t\tgoto err_out;\n\t\t}\n\t} else if (!already_permitted) {\n\t\t/* FILE_READ_ATTRIBUTE is allowed without inode_permission,\n\t\t * because execute(search) permission on a parent directory,\n\t\t * is already granted.\n\t\t */\n\t\tif (daccess & ~(FILE_READ_ATTRIBUTES_LE | FILE_READ_CONTROL_LE)) {\n\t\t\trc = inode_permission(idmap,\n\t\t\t\t\t      d_inode(path.dentry),\n\t\t\t\t\t      may_flags);\n\t\t\tif (rc)\n\t\t\t\tgoto err_out;\n\n\t\t\tif ((daccess & FILE_DELETE_LE) ||\n\t\t\t    (req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)) {\n\t\t\t\trc = inode_permission(idmap,\n\t\t\t\t\t\t      d_inode(path.dentry->d_parent),\n\t\t\t\t\t\t      MAY_EXEC | MAY_WRITE);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t}\n\n\trc = ksmbd_query_inode_status(path.dentry->d_parent);\n\tif (rc == KSMBD_INODE_STATUS_PENDING_DELETE) {\n\t\trc = -EBUSY;\n\t\tgoto err_out;\n\t}\n\n\trc = 0;\n\tfilp = dentry_open(&path, open_flags, current_cred());\n\tif (IS_ERR(filp)) {\n\t\trc = PTR_ERR(filp);\n\t\tpr_err(\"dentry open for dir failed, rc %d\\n\", rc);\n\t\tgoto err_out;\n\t}\n\n\tif (file_present) {\n\t\tif (!(open_flags & O_TRUNC))\n\t\t\tfile_info = FILE_OPENED;\n\t\telse\n\t\t\tfile_info = FILE_OVERWRITTEN;\n\n\t\tif ((req->CreateDisposition & FILE_CREATE_MASK_LE) ==\n\t\t    FILE_SUPERSEDE_LE)\n\t\t\tfile_info = FILE_SUPERSEDED;\n\t} else if (open_flags & O_CREAT) {\n\t\tfile_info = FILE_CREATED;\n\t}\n\n\tksmbd_vfs_set_fadvise(filp, req->CreateOptions);\n\n\t/* Obtain Volatile-ID */\n\tfp = ksmbd_open_fd(work, filp);\n\tif (IS_ERR(fp)) {\n\t\tfput(filp);\n\t\trc = PTR_ERR(fp);\n\t\tfp = NULL;\n\t\tgoto err_out;\n\t}\n\n\t/* Get Persistent-ID */\n\tksmbd_open_durable_fd(fp);\n\tif (!has_file_id(fp->persistent_id)) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tfp->cdoption = req->CreateDisposition;\n\tfp->daccess = daccess;\n\tfp->saccess = req->ShareAccess;\n\tfp->coption = req->CreateOptions;\n\n\t/* Set default windows and posix acls if creating new file */\n\tif (created) {\n\t\tint posix_acl_rc;\n\t\tstruct inode *inode = d_inode(path.dentry);\n\n\t\tposix_acl_rc = ksmbd_vfs_inherit_posix_acl(idmap,\n\t\t\t\t\t\t\t   &path,\n\t\t\t\t\t\t\t   d_inode(path.dentry->d_parent));\n\t\tif (posix_acl_rc)\n\t\t\tksmbd_debug(SMB, \"inherit posix acl failed : %d\\n\", posix_acl_rc);\n\n\t\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t\t   KSMBD_SHARE_FLAG_ACL_XATTR)) {\n\t\t\trc = smb_inherit_dacl(conn, &path, sess->user->uid,\n\t\t\t\t\t      sess->user->gid);\n\t\t}\n\n\t\tif (rc) {\n\t\t\trc = smb2_create_sd_buffer(work, req, &path);\n\t\t\tif (rc) {\n\t\t\t\tif (posix_acl_rc)\n\t\t\t\t\tksmbd_vfs_set_init_posix_acl(idmap,\n\t\t\t\t\t\t\t\t     &path);\n\n\t\t\t\tif (test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t\t\t\t   KSMBD_SHARE_FLAG_ACL_XATTR)) {\n\t\t\t\t\tstruct smb_fattr fattr;\n\t\t\t\t\tstruct smb_ntsd *pntsd;\n\t\t\t\t\tint pntsd_size, ace_num = 0;\n\n\t\t\t\t\tksmbd_acls_fattr(&fattr, idmap, inode);\n\t\t\t\t\tif (fattr.cf_acls)\n\t\t\t\t\t\tace_num = fattr.cf_acls->a_count;\n\t\t\t\t\tif (fattr.cf_dacls)\n\t\t\t\t\t\tace_num += fattr.cf_dacls->a_count;\n\n\t\t\t\t\tpntsd = kmalloc(sizeof(struct smb_ntsd) +\n\t\t\t\t\t\t\tsizeof(struct smb_sid) * 3 +\n\t\t\t\t\t\t\tsizeof(struct smb_acl) +\n\t\t\t\t\t\t\tsizeof(struct smb_ace) * ace_num * 2,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\t\tif (!pntsd) {\n\t\t\t\t\t\tposix_acl_release(fattr.cf_acls);\n\t\t\t\t\t\tposix_acl_release(fattr.cf_dacls);\n\t\t\t\t\t\tgoto err_out;\n\t\t\t\t\t}\n\n\t\t\t\t\trc = build_sec_desc(idmap,\n\t\t\t\t\t\t\t    pntsd, NULL, 0,\n\t\t\t\t\t\t\t    OWNER_SECINFO |\n\t\t\t\t\t\t\t    GROUP_SECINFO |\n\t\t\t\t\t\t\t    DACL_SECINFO,\n\t\t\t\t\t\t\t    &pntsd_size, &fattr);\n\t\t\t\t\tposix_acl_release(fattr.cf_acls);\n\t\t\t\t\tposix_acl_release(fattr.cf_dacls);\n\t\t\t\t\tif (rc) {\n\t\t\t\t\t\tkfree(pntsd);\n\t\t\t\t\t\tgoto err_out;\n\t\t\t\t\t}\n\n\t\t\t\t\trc = ksmbd_vfs_set_sd_xattr(conn,\n\t\t\t\t\t\t\t\t    idmap,\n\t\t\t\t\t\t\t\t    &path,\n\t\t\t\t\t\t\t\t    pntsd,\n\t\t\t\t\t\t\t\t    pntsd_size,\n\t\t\t\t\t\t\t\t    false);\n\t\t\t\t\tkfree(pntsd);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\tpr_err(\"failed to store ntacl in xattr : %d\\n\",\n\t\t\t\t\t\t       rc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trc = 0;\n\t}\n\n\tif (stream_name) {\n\t\trc = smb2_set_stream_name_xattr(&path,\n\t\t\t\t\t\tfp,\n\t\t\t\t\t\tstream_name,\n\t\t\t\t\t\ts_type);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\t\tfile_info = FILE_CREATED;\n\t}\n\n\tfp->attrib_only = !(req->DesiredAccess & ~(FILE_READ_ATTRIBUTES_LE |\n\t\t\tFILE_WRITE_ATTRIBUTES_LE | FILE_SYNCHRONIZE_LE));\n\n\t/* fp should be searchable through ksmbd_inode.m_fp_list\n\t * after daccess, saccess, attrib_only, and stream are\n\t * initialized.\n\t */\n\tdown_write(&fp->f_ci->m_lock);\n\tlist_add(&fp->node, &fp->f_ci->m_fp_list);\n\tup_write(&fp->f_ci->m_lock);\n\n\t/* Check delete pending among previous fp before oplock break */\n\tif (ksmbd_inode_pending_delete(fp)) {\n\t\trc = -EBUSY;\n\t\tgoto err_out;\n\t}\n\n\tif (file_present || created)\n\t\tksmbd_vfs_kern_path_unlock(&parent_path, &path);\n\n\tif (!S_ISDIR(file_inode(filp)->i_mode) && open_flags & O_TRUNC &&\n\t    !fp->attrib_only && !stream_name) {\n\t\tsmb_break_all_oplock(work, fp);\n\t\tneed_truncate = 1;\n\t}\n\n\tshare_ret = ksmbd_smb_check_shared_mode(fp->filp, fp);\n\tif (!test_share_config_flag(work->tcon->share_conf, KSMBD_SHARE_FLAG_OPLOCKS) ||\n\t    (req_op_level == SMB2_OPLOCK_LEVEL_LEASE &&\n\t     !(conn->vals->capabilities & SMB2_GLOBAL_CAP_LEASING))) {\n\t\tif (share_ret < 0 && !S_ISDIR(file_inode(fp->filp)->i_mode)) {\n\t\t\trc = share_ret;\n\t\t\tgoto err_out1;\n\t\t}\n\t} else {\n\t\tif (req_op_level == SMB2_OPLOCK_LEVEL_LEASE && lc) {\n\t\t\tif (S_ISDIR(file_inode(filp)->i_mode)) {\n\t\t\t\tlc->req_state &= ~SMB2_LEASE_WRITE_CACHING_LE;\n\t\t\t\tlc->is_dir = true;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Compare parent lease using parent key. If there is no\n\t\t\t * a lease that has same parent key, Send lease break\n\t\t\t * notification.\n\t\t\t */\n\t\t\tsmb_send_parent_lease_break_noti(fp, lc);\n\n\t\t\treq_op_level = smb2_map_lease_to_oplock(lc->req_state);\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"lease req for(%s) req oplock state 0x%x, lease state 0x%x\\n\",\n\t\t\t\t    name, req_op_level, lc->req_state);\n\t\t\trc = find_same_lease_key(sess, fp->f_ci, lc);\n\t\t\tif (rc)\n\t\t\t\tgoto err_out1;\n\t\t} else if (open_flags == O_RDONLY &&\n\t\t\t   (req_op_level == SMB2_OPLOCK_LEVEL_BATCH ||\n\t\t\t    req_op_level == SMB2_OPLOCK_LEVEL_EXCLUSIVE))\n\t\t\treq_op_level = SMB2_OPLOCK_LEVEL_II;\n\n\t\trc = smb_grant_oplock(work, req_op_level,\n\t\t\t\t      fp->persistent_id, fp,\n\t\t\t\t      le32_to_cpu(req->hdr.Id.SyncId.TreeId),\n\t\t\t\t      lc, share_ret);\n\t\tif (rc < 0)\n\t\t\tgoto err_out1;\n\t}\n\n\tif (req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)\n\t\tksmbd_fd_set_delete_on_close(fp, file_info);\n\n\tif (need_truncate) {\n\t\trc = smb2_create_truncate(&fp->filp->f_path);\n\t\tif (rc)\n\t\t\tgoto err_out1;\n\t}\n\n\tif (req->CreateContextsOffset) {\n\t\tstruct create_alloc_size_req *az_req;\n\n\t\taz_req = (struct create_alloc_size_req *)smb2_find_context_vals(req,\n\t\t\t\t\tSMB2_CREATE_ALLOCATION_SIZE, 4);\n\t\tif (IS_ERR(az_req)) {\n\t\t\trc = PTR_ERR(az_req);\n\t\t\tgoto err_out1;\n\t\t} else if (az_req) {\n\t\t\tloff_t alloc_size;\n\t\t\tint err;\n\n\t\t\tif (le16_to_cpu(az_req->ccontext.DataOffset) +\n\t\t\t    le32_to_cpu(az_req->ccontext.DataLength) <\n\t\t\t    sizeof(struct create_alloc_size_req)) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto err_out1;\n\t\t\t}\n\t\t\talloc_size = le64_to_cpu(az_req->AllocationSize);\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"request smb2 create allocate size : %llu\\n\",\n\t\t\t\t    alloc_size);\n\t\t\tsmb_break_all_levII_oplock(work, fp, 1);\n\t\t\terr = vfs_fallocate(fp->filp, FALLOC_FL_KEEP_SIZE, 0,\n\t\t\t\t\t    alloc_size);\n\t\t\tif (err < 0)\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"vfs_fallocate is failed : %d\\n\",\n\t\t\t\t\t    err);\n\t\t}\n\n\t\tcontext = smb2_find_context_vals(req, SMB2_CREATE_QUERY_ON_DISK_ID, 4);\n\t\tif (IS_ERR(context)) {\n\t\t\trc = PTR_ERR(context);\n\t\t\tgoto err_out1;\n\t\t} else if (context) {\n\t\t\tksmbd_debug(SMB, \"get query on disk id context\\n\");\n\t\t\tquery_disk_id = 1;\n\t\t}\n\t}\n\n\trc = ksmbd_vfs_getattr(&path, &stat);\n\tif (rc)\n\t\tgoto err_out1;\n\n\tif (stat.result_mask & STATX_BTIME)\n\t\tfp->create_time = ksmbd_UnixTimeToNT(stat.btime);\n\telse\n\t\tfp->create_time = ksmbd_UnixTimeToNT(stat.ctime);\n\tif (req->FileAttributes || fp->f_ci->m_fattr == 0)\n\t\tfp->f_ci->m_fattr =\n\t\t\tcpu_to_le32(smb2_get_dos_mode(&stat, le32_to_cpu(req->FileAttributes)));\n\n\tif (!created)\n\t\tsmb2_update_xattrs(tcon, &path, fp);\n\telse\n\t\tsmb2_new_xattrs(tcon, &path, fp);\n\n\tmemcpy(fp->client_guid, conn->ClientGUID, SMB2_CLIENT_GUID_SIZE);\n\n\tif (dh_info.type == DURABLE_REQ_V2 || dh_info.type == DURABLE_REQ) {\n\t\tif (dh_info.type == DURABLE_REQ_V2 && dh_info.persistent &&\n\t\t    test_share_config_flag(work->tcon->share_conf,\n\t\t\t\t\t   KSMBD_SHARE_FLAG_CONTINUOUS_AVAILABILITY))\n\t\t\tfp->is_persistent = true;\n\t\telse\n\t\t\tfp->is_durable = true;\n\n\t\tif (dh_info.type == DURABLE_REQ_V2) {\n\t\t\tmemcpy(fp->create_guid, dh_info.CreateGuid,\n\t\t\t\t\tSMB2_CREATE_GUID_SIZE);\n\t\t\tif (dh_info.timeout)\n\t\t\t\tfp->durable_timeout = min(dh_info.timeout,\n\t\t\t\t\t\tDURABLE_HANDLE_MAX_TIMEOUT);\n\t\t\telse\n\t\t\t\tfp->durable_timeout = 60;\n\t\t}\n\t}\n\nreconnected_fp:\n\trsp->StructureSize = cpu_to_le16(89);\n\trcu_read_lock();\n\topinfo = rcu_dereference(fp->f_opinfo);\n\trsp->OplockLevel = opinfo != NULL ? opinfo->level : 0;\n\trcu_read_unlock();\n\trsp->Flags = 0;\n\trsp->CreateAction = cpu_to_le32(file_info);\n\trsp->CreationTime = cpu_to_le64(fp->create_time);\n\ttime = ksmbd_UnixTimeToNT(stat.atime);\n\trsp->LastAccessTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.mtime);\n\trsp->LastWriteTime = cpu_to_le64(time);\n\ttime = ksmbd_UnixTimeToNT(stat.ctime);\n\trsp->ChangeTime = cpu_to_le64(time);\n\trsp->AllocationSize = S_ISDIR(stat.mode) ? 0 :\n\t\tcpu_to_le64(stat.blocks << 9);\n\trsp->EndofFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);\n\trsp->FileAttributes = fp->f_ci->m_fattr;\n\n\trsp->Reserved2 = 0;\n\n\trsp->PersistentFileId = fp->persistent_id;\n\trsp->VolatileFileId = fp->volatile_id;\n\n\trsp->CreateContextsOffset = 0;\n\trsp->CreateContextsLength = 0;\n\tiov_len = offsetof(struct smb2_create_rsp, Buffer);\n\n\t/* If lease is request send lease context response */\n\tif (opinfo && opinfo->is_lease) {\n\t\tstruct create_context *lease_ccontext;\n\n\t\tksmbd_debug(SMB, \"lease granted on(%s) lease state 0x%x\\n\",\n\t\t\t    name, opinfo->o_lease->state);\n\t\trsp->OplockLevel = SMB2_OPLOCK_LEVEL_LEASE;\n\n\t\tlease_ccontext = (struct create_context *)rsp->Buffer;\n\t\tcontxt_cnt++;\n\t\tcreate_lease_buf(rsp->Buffer, opinfo->o_lease);\n\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t     conn->vals->create_lease_size);\n\t\tiov_len += conn->vals->create_lease_size;\n\t\tnext_ptr = &lease_ccontext->Next;\n\t\tnext_off = conn->vals->create_lease_size;\n\t}\n\n\tif (maximal_access_ctxt) {\n\t\tstruct create_context *mxac_ccontext;\n\n\t\tif (maximal_access == 0)\n\t\t\tksmbd_vfs_query_maximal_access(idmap,\n\t\t\t\t\t\t       path.dentry,\n\t\t\t\t\t\t       &maximal_access);\n\t\tmxac_ccontext = (struct create_context *)(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength));\n\t\tcontxt_cnt++;\n\t\tcreate_mxac_rsp_buf(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength),\n\t\t\t\tle32_to_cpu(maximal_access));\n\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t     conn->vals->create_mxac_size);\n\t\tiov_len += conn->vals->create_mxac_size;\n\t\tif (next_ptr)\n\t\t\t*next_ptr = cpu_to_le32(next_off);\n\t\tnext_ptr = &mxac_ccontext->Next;\n\t\tnext_off = conn->vals->create_mxac_size;\n\t}\n\n\tif (query_disk_id) {\n\t\tstruct create_context *disk_id_ccontext;\n\n\t\tdisk_id_ccontext = (struct create_context *)(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength));\n\t\tcontxt_cnt++;\n\t\tcreate_disk_id_rsp_buf(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength),\n\t\t\t\tstat.ino, tcon->id);\n\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t     conn->vals->create_disk_id_size);\n\t\tiov_len += conn->vals->create_disk_id_size;\n\t\tif (next_ptr)\n\t\t\t*next_ptr = cpu_to_le32(next_off);\n\t\tnext_ptr = &disk_id_ccontext->Next;\n\t\tnext_off = conn->vals->create_disk_id_size;\n\t}\n\n\tif (dh_info.type == DURABLE_REQ || dh_info.type == DURABLE_REQ_V2) {\n\t\tstruct create_context *durable_ccontext;\n\n\t\tdurable_ccontext = (struct create_context *)(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength));\n\t\tcontxt_cnt++;\n\t\tif (dh_info.type == DURABLE_REQ) {\n\t\t\tcreate_durable_rsp_buf(rsp->Buffer +\n\t\t\t\t\tle32_to_cpu(rsp->CreateContextsLength));\n\t\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t\t\tconn->vals->create_durable_size);\n\t\t\tiov_len += conn->vals->create_durable_size;\n\t\t} else {\n\t\t\tcreate_durable_v2_rsp_buf(rsp->Buffer +\n\t\t\t\t\tle32_to_cpu(rsp->CreateContextsLength),\n\t\t\t\t\tfp);\n\t\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t\t\tconn->vals->create_durable_v2_size);\n\t\t\tiov_len += conn->vals->create_durable_v2_size;\n\t\t}\n\n\t\tif (next_ptr)\n\t\t\t*next_ptr = cpu_to_le32(next_off);\n\t\tnext_ptr = &durable_ccontext->Next;\n\t\tnext_off = conn->vals->create_durable_size;\n\t}\n\n\tif (posix_ctxt) {\n\t\tcontxt_cnt++;\n\t\tcreate_posix_rsp_buf(rsp->Buffer +\n\t\t\t\tle32_to_cpu(rsp->CreateContextsLength),\n\t\t\t\tfp);\n\t\tle32_add_cpu(&rsp->CreateContextsLength,\n\t\t\t     conn->vals->create_posix_size);\n\t\tiov_len += conn->vals->create_posix_size;\n\t\tif (next_ptr)\n\t\t\t*next_ptr = cpu_to_le32(next_off);\n\t}\n\n\tif (contxt_cnt > 0) {\n\t\trsp->CreateContextsOffset =\n\t\t\tcpu_to_le32(offsetof(struct smb2_create_rsp, Buffer));\n\t}\n\nerr_out:\n\tif (rc && (file_present || created))\n\t\tksmbd_vfs_kern_path_unlock(&parent_path, &path);\n\nerr_out1:\n\tksmbd_revert_fsids(work);\n\nerr_out2:\n\tif (!rc) {\n\t\tksmbd_update_fstate(&work->sess->file_table, fp, FP_INITED);\n\t\trc = ksmbd_iov_pin_rsp(work, (void *)rsp, iov_len);\n\t}\n\tif (rc) {\n\t\tif (rc == -EINVAL)\n\t\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\t\telse if (rc == -EOPNOTSUPP)\n\t\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\t\telse if (rc == -EACCES || rc == -ESTALE || rc == -EXDEV)\n\t\t\trsp->hdr.Status = STATUS_ACCESS_DENIED;\n\t\telse if (rc == -ENOENT)\n\t\t\trsp->hdr.Status = STATUS_OBJECT_NAME_INVALID;\n\t\telse if (rc == -EPERM)\n\t\t\trsp->hdr.Status = STATUS_SHARING_VIOLATION;\n\t\telse if (rc == -EBUSY)\n\t\t\trsp->hdr.Status = STATUS_DELETE_PENDING;\n\t\telse if (rc == -EBADF)\n\t\t\trsp->hdr.Status = STATUS_OBJECT_NAME_NOT_FOUND;\n\t\telse if (rc == -ENOEXEC)\n\t\t\trsp->hdr.Status = STATUS_DUPLICATE_OBJECTID;\n\t\telse if (rc == -ENXIO)\n\t\t\trsp->hdr.Status = STATUS_NO_SUCH_DEVICE;\n\t\telse if (rc == -EEXIST)\n\t\t\trsp->hdr.Status = STATUS_OBJECT_NAME_COLLISION;\n\t\telse if (rc == -EMFILE)\n\t\t\trsp->hdr.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t\tif (!rsp->hdr.Status)\n\t\t\trsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;\n\n\t\tif (fp)\n\t\t\tksmbd_fd_put(work, fp);\n\t\tsmb2_set_err_rsp(work);\n\t\tksmbd_debug(SMB, \"Error response: %x\\n\", rsp->hdr.Status);\n\t}\n\n\tkfree(name);\n\tkfree(lc);\n\n\treturn rc;\n}\n",
      "cve_list": [
        "CVE-2024-46742"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "sound/soc/amd/acp-es8336.c",
      "func_name": "st_es8336_late_probe",
      "func_body": "static int st_es8336_late_probe(struct snd_soc_card *card)\n{\n\tstruct acpi_device *adev;\n\tint ret;\n\n\tadev = acpi_dev_get_first_match_dev(\"ESSX8336\", NULL, -1);\n\tif (!adev)\n\t\treturn -ENODEV;\n\n\tcodec_dev = acpi_get_first_physical_node(adev);\n\tacpi_dev_put(adev);\n\tif (!codec_dev) {\n\t\tdev_err(card->dev, \"can not find codec dev\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = devm_acpi_dev_add_driver_gpios(codec_dev, acpi_es8336_gpios);\n\tif (ret)\n\t\tdev_warn(card->dev, \"Failed to add driver gpios\\n\");\n\n\tgpio_pa = gpiod_get_optional(codec_dev, \"pa-enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpio_pa)) {\n\t\tret = dev_err_probe(card->dev, PTR_ERR(gpio_pa),\n\t\t\t\t    \"could not get pa-enable GPIO\\n\");\n\t\tput_device(codec_dev);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-43818"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_mst_types.c",
      "func_name": "is_dsc_need_re_compute",
      "func_body": "static bool is_dsc_need_re_compute(\n\tstruct drm_atomic_state *state,\n\tstruct dc_state *dc_state,\n\tstruct dc_link *dc_link)\n{\n\tint i, j;\n\tbool is_dsc_need_re_compute = false;\n\tstruct amdgpu_dm_connector *stream_on_link[MAX_PIPES];\n\tint new_stream_on_link_num = 0;\n\tstruct amdgpu_dm_connector *aconnector;\n\tstruct dc_stream_state *stream;\n\tconst struct dc *dc = dc_link->dc;\n\n\t/* only check phy used by dsc mst branch */\n\tif (dc_link->type != dc_connection_mst_branch)\n\t\treturn false;\n\n\t/* add a check for older MST DSC with no virtual DPCDs */\n\tif (needs_dsc_aux_workaround(dc_link)  &&\n\t\t(!(dc_link->dpcd_caps.dsc_caps.dsc_basic_caps.fields.dsc_support.DSC_SUPPORT ||\n\t\tdc_link->dpcd_caps.dsc_caps.dsc_basic_caps.fields.dsc_support.DSC_PASSTHROUGH_SUPPORT)))\n\t\treturn false;\n\n\tfor (i = 0; i < MAX_PIPES; i++)\n\t\tstream_on_link[i] = NULL;\n\n\t/* check if there is mode change in new request */\n\tfor (i = 0; i < dc_state->stream_count; i++) {\n\t\tstruct drm_crtc_state *new_crtc_state;\n\t\tstruct drm_connector_state *new_conn_state;\n\n\t\tstream = dc_state->streams[i];\n\t\tif (!stream)\n\t\t\tcontinue;\n\n\t\t/* check if stream using the same link for mst */\n\t\tif (stream->link != dc_link)\n\t\t\tcontinue;\n\n\t\taconnector = (struct amdgpu_dm_connector *) stream->dm_stream_context;\n\t\tif (!aconnector || !aconnector->dsc_aux)\n\t\t\tcontinue;\n\n\t\tstream_on_link[new_stream_on_link_num] = aconnector;\n\t\tnew_stream_on_link_num++;\n\n\t\tnew_conn_state = drm_atomic_get_new_connector_state(state, &aconnector->base);\n\t\tif (!new_conn_state)\n\t\t\tcontinue;\n\n\t\tif (IS_ERR(new_conn_state))\n\t\t\tcontinue;\n\n\t\tif (!new_conn_state->crtc)\n\t\t\tcontinue;\n\n\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, new_conn_state->crtc);\n\t\tif (!new_crtc_state)\n\t\t\tcontinue;\n\n\t\tif (IS_ERR(new_crtc_state))\n\t\t\tcontinue;\n\n\t\tif (new_crtc_state->enable && new_crtc_state->active) {\n\t\t\tif (new_crtc_state->mode_changed || new_crtc_state->active_changed ||\n\t\t\t\tnew_crtc_state->connectors_changed)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (new_stream_on_link_num == 0)\n\t\treturn false;\n\n\t/* check current_state if there stream on link but it is not in\n\t * new request state\n\t */\n\tfor (i = 0; i < dc->current_state->stream_count; i++) {\n\t\tstream = dc->current_state->streams[i];\n\t\t/* only check stream on the mst hub */\n\t\tif (stream->link != dc_link)\n\t\t\tcontinue;\n\n\t\taconnector = (struct amdgpu_dm_connector *)stream->dm_stream_context;\n\t\tif (!aconnector)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < new_stream_on_link_num; j++) {\n\t\t\tif (stream_on_link[j]) {\n\t\t\t\tif (aconnector == stream_on_link[j])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (j == new_stream_on_link_num) {\n\t\t\t/* not in new state */\n\t\t\tis_dsc_need_re_compute = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn is_dsc_need_re_compute;\n}\n",
      "cve_list": [
        "CVE-2024-43895"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/bluetooth/mgmt.c",
      "func_name": "pair_device",
      "func_body": "static int pair_device(struct sock *sk, struct hci_dev *hdev, void *data,\n\t\t       u16 len)\n{\n\tstruct mgmt_cp_pair_device *cp = data;\n\tstruct mgmt_rp_pair_device rp;\n\tstruct mgmt_pending_cmd *cmd;\n\tu8 sec_level, auth_type;\n\tstruct hci_conn *conn;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"sock %p\", sk);\n\n\tmemset(&rp, 0, sizeof(rp));\n\tbacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);\n\trp.addr.type = cp->addr.type;\n\n\tif (!bdaddr_type_is_valid(cp->addr.type))\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &rp, sizeof(rp));\n\n\tif (cp->io_cap > SMP_IO_KEYBOARD_DISPLAY)\n\t\treturn mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\n\t\t\t\t\t MGMT_STATUS_INVALID_PARAMS,\n\t\t\t\t\t &rp, sizeof(rp));\n\n\thci_dev_lock(hdev);\n\n\tif (!hdev_is_powered(hdev)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\n\t\t\t\t\tMGMT_STATUS_NOT_POWERED, &rp,\n\t\t\t\t\tsizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tif (hci_bdaddr_is_paired(hdev, &cp->addr.bdaddr, cp->addr.type)) {\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\n\t\t\t\t\tMGMT_STATUS_ALREADY_PAIRED, &rp,\n\t\t\t\t\tsizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tsec_level = BT_SECURITY_MEDIUM;\n\tauth_type = HCI_AT_DEDICATED_BONDING;\n\n\tif (cp->addr.type == BDADDR_BREDR) {\n\t\tconn = hci_connect_acl(hdev, &cp->addr.bdaddr, sec_level,\n\t\t\t\t       auth_type, CONN_REASON_PAIR_DEVICE,\n\t\t\t\t       HCI_ACL_CONN_TIMEOUT);\n\t} else {\n\t\tu8 addr_type = le_addr_type(cp->addr.type);\n\t\tstruct hci_conn_params *p;\n\n\t\t/* When pairing a new device, it is expected to remember\n\t\t * this device for future connections. Adding the connection\n\t\t * parameter information ahead of time allows tracking\n\t\t * of the peripheral preferred values and will speed up any\n\t\t * further connection establishment.\n\t\t *\n\t\t * If connection parameters already exist, then they\n\t\t * will be kept and this function does nothing.\n\t\t */\n\t\tp = hci_conn_params_add(hdev, &cp->addr.bdaddr, addr_type);\n\t\tif (!p) {\n\t\t\terr = -EIO;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (p->auto_connect == HCI_AUTO_CONN_EXPLICIT)\n\t\t\tp->auto_connect = HCI_AUTO_CONN_DISABLED;\n\n\t\tconn = hci_connect_le_scan(hdev, &cp->addr.bdaddr, addr_type,\n\t\t\t\t\t   sec_level, HCI_LE_CONN_TIMEOUT,\n\t\t\t\t\t   CONN_REASON_PAIR_DEVICE);\n\t}\n\n\tif (IS_ERR(conn)) {\n\t\tint status;\n\n\t\tif (PTR_ERR(conn) == -EBUSY)\n\t\t\tstatus = MGMT_STATUS_BUSY;\n\t\telse if (PTR_ERR(conn) == -EOPNOTSUPP)\n\t\t\tstatus = MGMT_STATUS_NOT_SUPPORTED;\n\t\telse if (PTR_ERR(conn) == -ECONNREFUSED)\n\t\t\tstatus = MGMT_STATUS_REJECTED;\n\t\telse\n\t\t\tstatus = MGMT_STATUS_CONNECT_FAILED;\n\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\n\t\t\t\t\tstatus, &rp, sizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tif (conn->connect_cfm_cb) {\n\t\thci_conn_drop(conn);\n\t\terr = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_PAIR_DEVICE,\n\t\t\t\t\tMGMT_STATUS_BUSY, &rp, sizeof(rp));\n\t\tgoto unlock;\n\t}\n\n\tcmd = mgmt_pending_add(sk, MGMT_OP_PAIR_DEVICE, hdev, data, len);\n\tif (!cmd) {\n\t\terr = -ENOMEM;\n\t\thci_conn_drop(conn);\n\t\tgoto unlock;\n\t}\n\n\tcmd->cmd_complete = pairing_complete;\n\n\t/* For LE, just connecting isn't a proof that the pairing finished */\n\tif (cp->addr.type == BDADDR_BREDR) {\n\t\tconn->connect_cfm_cb = pairing_complete_cb;\n\t\tconn->security_cfm_cb = pairing_complete_cb;\n\t\tconn->disconn_cfm_cb = pairing_complete_cb;\n\t} else {\n\t\tconn->connect_cfm_cb = le_pairing_complete_cb;\n\t\tconn->security_cfm_cb = le_pairing_complete_cb;\n\t\tconn->disconn_cfm_cb = le_pairing_complete_cb;\n\t}\n\n\tconn->io_capability = cp->io_cap;\n\tcmd->user_data = hci_conn_get(conn);\n\n\tif ((conn->state == BT_CONNECTED || conn->state == BT_CONFIG) &&\n\t    hci_conn_security(conn, sec_level, auth_type, true)) {\n\t\tcmd->cmd_complete(cmd, 0);\n\t\tmgmt_pending_remove(cmd);\n\t}\n\n\terr = 0;\n\nunlock:\n\thci_dev_unlock(hdev);\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-43884"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/media/platform/mediatek/vcodec/common/mtk_vcodec_fw_scp.c",
      "func_name": "mtk_vcodec_fw_scp_init",
      "func_body": "struct mtk_vcodec_fw *mtk_vcodec_fw_scp_init(void *priv, enum mtk_vcodec_fw_use fw_use)\n{\n\tstruct mtk_vcodec_fw *fw;\n\tstruct platform_device *plat_dev;\n\tstruct mtk_scp *scp;\n\n\tif (fw_use == ENCODER) {\n\t\tstruct mtk_vcodec_enc_dev *enc_dev = priv;\n\n\t\tplat_dev = enc_dev->plat_dev;\n\t} else if (fw_use == DECODER) {\n\t\tstruct mtk_vcodec_dec_dev *dec_dev = priv;\n\n\t\tplat_dev = dec_dev->plat_dev;\n\t} else {\n\t\tpr_err(\"Invalid fw_use %d (use a reasonable fw id here)\\n\", fw_use);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tscp = scp_get(plat_dev);\n\tif (!scp) {\n\t\tdev_err(&plat_dev->dev, \"could not get vdec scp handle\");\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\tfw = devm_kzalloc(&plat_dev->dev, sizeof(*fw), GFP_KERNEL);\n\tif (!fw)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfw->type = SCP;\n\tfw->ops = &mtk_vcodec_rproc_msg;\n\tfw->scp = scp;\n\n\treturn fw;\n}\n",
      "cve_list": [
        "CVE-2024-40973"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/dc/link/protocols/link_dpcd.c",
      "func_name": "dpcd_extend_address_range",
      "func_body": "static void dpcd_extend_address_range(\n\t\tconst uint32_t in_address,\n\t\tuint8_t * const in_data,\n\t\tconst uint32_t in_size,\n\t\tuint32_t *out_address,\n\t\tuint8_t **out_data,\n\t\tuint32_t *out_size)\n{\n\tconst uint32_t end_address = END_ADDRESS(in_address, in_size);\n\tconst struct dpcd_address_range *addr_range;\n\tstruct dpcd_address_range new_addr_range;\n\tuint32_t i;\n\n\tnew_addr_range.start = in_address;\n\tnew_addr_range.end = end_address;\n\tfor (i = 0; i < ARRAY_SIZE(mandatory_dpcd_blocks); i++) {\n\t\taddr_range = &mandatory_dpcd_blocks[i];\n\t\tif (addr_range->start <= in_address && addr_range->end >= in_address)\n\t\t\tnew_addr_range.start = addr_range->start;\n\n\t\tif (addr_range->start <= end_address && addr_range->end >= end_address)\n\t\t\tnew_addr_range.end = addr_range->end;\n\t}\n\t*out_address = in_address;\n\t*out_size = in_size;\n\t*out_data = in_data;\n\tif (new_addr_range.start != in_address || new_addr_range.end != end_address) {\n\t\t*out_address = new_addr_range.start;\n\t\t*out_size = ADDRESS_RANGE_SIZE(new_addr_range.start, new_addr_range.end);\n\t\t*out_data = kcalloc(*out_size, sizeof(**out_data), GFP_KERNEL);\n\t\tASSERT(*out_data);\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-46808"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/nvme/target/tcp.c",
      "func_name": "nvmet_tcp_install_queue",
      "func_body": "static u16 nvmet_tcp_install_queue(struct nvmet_sq *sq)\n{\n\tstruct nvmet_tcp_queue *queue =\n\t\tcontainer_of(sq, struct nvmet_tcp_queue, nvme_sq);\n\n\tif (sq->qid == 0) {\n\t\tstruct nvmet_tcp_queue *q;\n\t\tint pending = 0;\n\n\t\t/* Check for pending controller teardown */\n\t\tmutex_lock(&nvmet_tcp_queue_mutex);\n\t\tlist_for_each_entry(q, &nvmet_tcp_queue_list, queue_list) {\n\t\t\tif (q->nvme_sq.ctrl == sq->ctrl &&\n\t\t\t    q->state == NVMET_TCP_Q_DISCONNECTING)\n\t\t\t\tpending++;\n\t\t}\n\t\tmutex_unlock(&nvmet_tcp_queue_mutex);\n\t\tif (pending > NVMET_TCP_BACKLOG)\n\t\t\treturn NVME_SC_CONNECT_CTRL_BUSY;\n\t}\n\n\tqueue->nr_cmds = sq->size * 2;\n\tif (nvmet_tcp_alloc_cmds(queue)) {\n\t\tqueue->nr_cmds = 0;\n\t\treturn NVME_SC_INTERNAL;\n\t}\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-46737"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ipv4/route.c",
      "func_name": "ip_route_use_hint",
      "func_body": "int ip_route_use_hint(struct sk_buff *skb, __be32 daddr, __be32 saddr,\n\t\t      u8 tos, struct net_device *dev,\n\t\t      const struct sk_buff *hint)\n{\n\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\tstruct rtable *rt = skb_rtable(hint);\n\tstruct net *net = dev_net(dev);\n\tint err = -EINVAL;\n\tu32 tag = 0;\n\n\tif (!in_dev)\n\t\treturn -EINVAL;\n\n\tif (ipv4_is_multicast(saddr) || ipv4_is_lbcast(saddr))\n\t\tgoto martian_source;\n\n\tif (ipv4_is_zeronet(saddr))\n\t\tgoto martian_source;\n\n\tif (ipv4_is_loopback(saddr) && !IN_DEV_NET_ROUTE_LOCALNET(in_dev, net))\n\t\tgoto martian_source;\n\n\tif (rt->rt_type != RTN_LOCAL)\n\t\tgoto skip_validate_source;\n\n\ttos &= IPTOS_RT_MASK;\n\terr = fib_validate_source(skb, saddr, daddr, tos, 0, dev, in_dev, &tag);\n\tif (err < 0)\n\t\tgoto martian_source;\n\nskip_validate_source:\n\tskb_dst_copy(skb, hint);\n\treturn 0;\n\nmartian_source:\n\tip_handle_martian_source(dev, in_dev, skb, daddr, saddr);\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-36008"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/ocfs2/journal.c",
      "func_name": "ocfs2_journal_dirty",
      "func_body": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tif (!is_handle_aborted(handle)) {\n\t\t\tjournal_t *journal = handle->h_transaction->t_journal;\n\n\t\t\tmlog(ML_ERROR, \"jbd2_journal_dirty_metadata failed: \"\n\t\t\t     \"handle type %u started at line %u, credits %u/%u \"\n\t\t\t     \"errcode %d. Aborting transaction and journal.\\n\",\n\t\t\t     handle->h_type, handle->h_line_no,\n\t\t\t     handle->h_requested_credits,\n\t\t\t     jbd2_handle_buffer_credits(handle), status);\n\t\t\thandle->h_err = status;\n\t\t\tjbd2_journal_abort_handle(handle);\n\t\t\tjbd2_journal_abort(journal, status);\n\t\t}\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-40952"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c",
      "func_name": "dm_helpers_dp_mst_send_payload_allocation",
      "func_body": "void dm_helpers_dp_mst_send_payload_allocation(\n\t\tstruct dc_context *ctx,\n\t\tconst struct dc_stream_state *stream)\n{\n\tstruct amdgpu_dm_connector *aconnector;\n\tstruct drm_dp_mst_topology_state *mst_state;\n\tstruct drm_dp_mst_topology_mgr *mst_mgr;\n\tstruct drm_dp_mst_atomic_payload *new_payload;\n\tenum mst_progress_status set_flag = MST_ALLOCATE_NEW_PAYLOAD;\n\tenum mst_progress_status clr_flag = MST_CLEAR_ALLOCATED_PAYLOAD;\n\tint ret = 0;\n\n\taconnector = (struct amdgpu_dm_connector *)stream->dm_stream_context;\n\n\tif (!aconnector || !aconnector->mst_root)\n\t\treturn;\n\n\tmst_mgr = &aconnector->mst_root->mst_mgr;\n\tmst_state = to_drm_dp_mst_topology_state(mst_mgr->base.state);\n\tnew_payload = drm_atomic_get_mst_payload_state(mst_state, aconnector->mst_output_port);\n\n\tret = drm_dp_add_payload_part2(mst_mgr, new_payload);\n\n\tif (ret) {\n\t\tamdgpu_dm_set_mst_status(&aconnector->mst_status,\n\t\t\tset_flag, false);\n\t} else {\n\t\tamdgpu_dm_set_mst_status(&aconnector->mst_status,\n\t\t\tset_flag, true);\n\t\tamdgpu_dm_set_mst_status(&aconnector->mst_status,\n\t\t\tclr_flag, false);\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-39498"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/display/drm_dp_mst_topology.c",
      "func_name": "drm_dp_add_payload_part2",
      "func_body": "int drm_dp_add_payload_part2(struct drm_dp_mst_topology_mgr *mgr,\n\t\t\t     struct drm_dp_mst_atomic_payload *payload)\n{\n\tint ret = 0;\n\n\t/* Skip failed payloads */\n\tif (payload->payload_allocation_status != DRM_DP_MST_PAYLOAD_ALLOCATION_DFP) {\n\t\tdrm_dbg_kms(mgr->dev, \"Part 1 of payload creation for %s failed, skipping part 2\\n\",\n\t\t\t    payload->port->connector->name);\n\t\treturn -EIO;\n\t}\n\n\t/* Allocate payload to remote end */\n\tret = drm_dp_create_payload_to_remote(mgr, payload);\n\tif (ret < 0)\n\t\tdrm_err(mgr->dev, \"Step 2 of creating MST payload for %p failed: %d\\n\",\n\t\t\tpayload->port, ret);\n\telse\n\t\tpayload->payload_allocation_status = DRM_DP_MST_PAYLOAD_ALLOCATION_REMOTE;\n\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-39498"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/i915/display/intel_dp_mst.c",
      "func_name": "intel_mst_enable_dp",
      "func_body": "static void intel_mst_enable_dp(struct intel_atomic_state *state,\n\t\t\t\tstruct intel_encoder *encoder,\n\t\t\t\tconst struct intel_crtc_state *pipe_config,\n\t\t\t\tconst struct drm_connector_state *conn_state)\n{\n\tstruct intel_dp_mst_encoder *intel_mst = enc_to_mst(encoder);\n\tstruct intel_digital_port *dig_port = intel_mst->primary;\n\tstruct intel_dp *intel_dp = &dig_port->dp;\n\tstruct intel_connector *connector = to_intel_connector(conn_state->connector);\n\tstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\n\tstruct drm_dp_mst_topology_state *mst_state =\n\t\tdrm_atomic_get_new_mst_topology_state(&state->base, &intel_dp->mst_mgr);\n\tenum transcoder trans = pipe_config->cpu_transcoder;\n\tbool first_mst_stream = intel_dp->active_mst_links == 1;\n\tstruct intel_crtc *pipe_crtc;\n\n\tdrm_WARN_ON(&dev_priv->drm, pipe_config->has_pch_encoder);\n\n\tif (intel_dp_is_uhbr(pipe_config)) {\n\t\tconst struct drm_display_mode *adjusted_mode =\n\t\t\t&pipe_config->hw.adjusted_mode;\n\t\tu64 crtc_clock_hz = KHz(adjusted_mode->crtc_clock);\n\n\t\tintel_de_write(dev_priv, TRANS_DP2_VFREQHIGH(pipe_config->cpu_transcoder),\n\t\t\t       TRANS_DP2_VFREQ_PIXEL_CLOCK(crtc_clock_hz >> 24));\n\t\tintel_de_write(dev_priv, TRANS_DP2_VFREQLOW(pipe_config->cpu_transcoder),\n\t\t\t       TRANS_DP2_VFREQ_PIXEL_CLOCK(crtc_clock_hz & 0xffffff));\n\t}\n\n\tenable_bs_jitter_was(pipe_config);\n\n\tintel_ddi_enable_transcoder_func(encoder, pipe_config);\n\n\tclear_act_sent(encoder, pipe_config);\n\n\tintel_de_rmw(dev_priv, TRANS_DDI_FUNC_CTL(trans), 0,\n\t\t     TRANS_DDI_DP_VC_PAYLOAD_ALLOC);\n\n\tdrm_dbg_kms(&dev_priv->drm, \"active links %d\\n\",\n\t\t    intel_dp->active_mst_links);\n\n\twait_for_act_sent(encoder, pipe_config);\n\n\tif (first_mst_stream)\n\t\tintel_ddi_wait_for_fec_status(encoder, pipe_config, true);\n\n\tdrm_dp_add_payload_part2(&intel_dp->mst_mgr,\n\t\t\t\t drm_atomic_get_mst_payload_state(mst_state, connector->port));\n\n\tif (DISPLAY_VER(dev_priv) >= 12)\n\t\tintel_de_rmw(dev_priv, hsw_chicken_trans_reg(dev_priv, trans),\n\t\t\t     FECSTALL_DIS_DPTSTREAM_DPTTG,\n\t\t\t     pipe_config->fec_enable ? FECSTALL_DIS_DPTSTREAM_DPTTG : 0);\n\n\tintel_audio_sdp_split_update(pipe_config);\n\n\tintel_enable_transcoder(pipe_config);\n\n\tfor_each_intel_crtc_in_pipe_mask_reverse(&dev_priv->drm, pipe_crtc,\n\t\t\t\t\t\t intel_crtc_joined_pipe_mask(pipe_config)) {\n\t\tconst struct intel_crtc_state *pipe_crtc_state =\n\t\t\tintel_atomic_get_new_crtc_state(state, pipe_crtc);\n\n\t\tintel_crtc_vblank_on(pipe_crtc_state);\n\t}\n\n\tintel_hdcp_enable(state, encoder, pipe_config, conn_state);\n}\n",
      "cve_list": [
        "CVE-2024-39498"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/nouveau/dispnv50/disp.c",
      "func_name": "nv50_msto_cleanup",
      "func_body": "static void\nnv50_msto_cleanup(struct drm_atomic_state *state,\n\t\t  struct drm_dp_mst_topology_state *new_mst_state,\n\t\t  struct drm_dp_mst_topology_mgr *mgr,\n\t\t  struct nv50_msto *msto)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(msto->encoder.dev);\n\tstruct drm_dp_mst_atomic_payload *new_payload =\n\t\tdrm_atomic_get_mst_payload_state(new_mst_state, msto->mstc->port);\n\tstruct drm_dp_mst_topology_state *old_mst_state =\n\t\tdrm_atomic_get_old_mst_topology_state(state, mgr);\n\tconst struct drm_dp_mst_atomic_payload *old_payload =\n\t\tdrm_atomic_get_mst_payload_state(old_mst_state, msto->mstc->port);\n\tstruct nv50_mstc *mstc = msto->mstc;\n\tstruct nv50_mstm *mstm = mstc->mstm;\n\n\tNV_ATOMIC(drm, \"%s: msto cleanup\\n\", msto->encoder.name);\n\n\tif (msto->disabled) {\n\t\tif (msto->head->func->display_id) {\n\t\t\tnvif_outp_dp_mst_id_put(&mstm->outp->outp, msto->display_id);\n\t\t\tmsto->display_id = 0;\n\t\t}\n\n\t\tmsto->mstc = NULL;\n\t\tmsto->disabled = false;\n\t\tdrm_dp_remove_payload_part2(mgr, new_mst_state, old_payload, new_payload);\n\t} else if (msto->enabled) {\n\t\tdrm_dp_add_payload_part2(mgr, new_payload);\n\t\tmsto->enabled = false;\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-39498"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/pci/endpoint/functions/pci-epf-test.c",
      "func_name": "pci_epf_test_core_init",
      "func_body": "static int pci_epf_test_core_init(struct pci_epf *epf)\n{\n\tstruct pci_epf_test *epf_test = epf_get_drvdata(epf);\n\tstruct pci_epf_header *header = epf->header;\n\tconst struct pci_epc_features *epc_features = epf_test->epc_features;\n\tstruct pci_epc *epc = epf->epc;\n\tstruct device *dev = &epf->dev;\n\tbool linkup_notifier = false;\n\tint ret;\n\n\tif (epf->vfunc_no <= 1) {\n\t\tret = pci_epc_write_header(epc, epf->func_no, epf->vfunc_no, header);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Configuration header write failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = pci_epf_test_set_bar(epf);\n\tif (ret)\n\t\treturn ret;\n\n\tif (epc_features->msi_capable) {\n\t\tret = pci_epc_set_msi(epc, epf->func_no, epf->vfunc_no,\n\t\t\t\t      epf->msi_interrupts);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"MSI configuration failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (epc_features->msix_capable) {\n\t\tret = pci_epc_set_msix(epc, epf->func_no, epf->vfunc_no,\n\t\t\t\t       epf->msix_interrupts,\n\t\t\t\t       epf_test->test_reg_bar,\n\t\t\t\t       epf_test->msix_table_offset);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"MSI-X configuration failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tlinkup_notifier = epc_features->linkup_notifier;\n\tif (!linkup_notifier)\n\t\tqueue_work(kpcitest_workqueue, &epf_test->cmd_handler.work);\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-43824"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/dc/hwss/dcn10/dcn10_hwseq.c",
      "func_name": "dcn10_log_color_state",
      "func_body": "static void dcn10_log_color_state(struct dc *dc,\n\t\t\t\t  struct dc_log_buffer_ctx *log_ctx)\n{\n\tstruct dc_context *dc_ctx = dc->ctx;\n\tstruct resource_pool *pool = dc->res_pool;\n\tbool is_gamut_remap_available = false;\n\tint i;\n\n\tDTN_INFO(\"DPP:    IGAM format    IGAM mode    DGAM mode    RGAM mode\"\n\t\t \"  GAMUT adjust  \"\n\t\t \"C11        C12        C13        C14        \"\n\t\t \"C21        C22        C23        C24        \"\n\t\t \"C31        C32        C33        C34        \\n\");\n\tfor (i = 0; i < pool->pipe_count; i++) {\n\t\tstruct dpp *dpp = pool->dpps[i];\n\t\tstruct dcn_dpp_state s = {0};\n\n\t\tdpp->funcs->dpp_read_state(dpp, &s);\n\t\tif (dpp->funcs->dpp_get_gamut_remap) {\n\t\t\tdpp->funcs->dpp_get_gamut_remap(dpp, &s.gamut_remap);\n\t\t\tis_gamut_remap_available = true;\n\t\t}\n\n\t\tif (!s.is_enabled)\n\t\t\tcontinue;\n\n\t\tDTN_INFO(\"[%2d]:  %11xh  %11s    %9s    %9s\",\n\t\t\t\tdpp->inst,\n\t\t\t\ts.igam_input_format,\n\t\t\t\t(s.igam_lut_mode == 0) ? \"BypassFixed\" :\n\t\t\t\t\t((s.igam_lut_mode == 1) ? \"BypassFloat\" :\n\t\t\t\t\t((s.igam_lut_mode == 2) ? \"RAM\" :\n\t\t\t\t\t((s.igam_lut_mode == 3) ? \"RAM\" :\n\t\t\t\t\t\t\t\t \"Unknown\"))),\n\t\t\t\t(s.dgam_lut_mode == 0) ? \"Bypass\" :\n\t\t\t\t\t((s.dgam_lut_mode == 1) ? \"sRGB\" :\n\t\t\t\t\t((s.dgam_lut_mode == 2) ? \"Ycc\" :\n\t\t\t\t\t((s.dgam_lut_mode == 3) ? \"RAM\" :\n\t\t\t\t\t((s.dgam_lut_mode == 4) ? \"RAM\" :\n\t\t\t\t\t\t\t\t \"Unknown\")))),\n\t\t\t\t(s.rgam_lut_mode == 0) ? \"Bypass\" :\n\t\t\t\t\t((s.rgam_lut_mode == 1) ? \"sRGB\" :\n\t\t\t\t\t((s.rgam_lut_mode == 2) ? \"Ycc\" :\n\t\t\t\t\t((s.rgam_lut_mode == 3) ? \"RAM\" :\n\t\t\t\t\t((s.rgam_lut_mode == 4) ? \"RAM\" :\n\t\t\t\t\t\t\t\t \"Unknown\")))));\n\t\tif (is_gamut_remap_available)\n\t\t\tDTN_INFO(\"  %12s  \"\n\t\t\t\t \"%010lld %010lld %010lld %010lld \"\n\t\t\t\t \"%010lld %010lld %010lld %010lld \"\n\t\t\t\t \"%010lld %010lld %010lld %010lld\",\n\t\t\t\t (s.gamut_remap.gamut_adjust_type == 0) ? \"Bypass\" :\n\t\t\t\t\t((s.gamut_remap.gamut_adjust_type == 1) ? \"HW\" : \"SW\"),\n\t\t\t\t s.gamut_remap.temperature_matrix[0].value,\n\t\t\t\t s.gamut_remap.temperature_matrix[1].value,\n\t\t\t\t s.gamut_remap.temperature_matrix[2].value,\n\t\t\t\t s.gamut_remap.temperature_matrix[3].value,\n\t\t\t\t s.gamut_remap.temperature_matrix[4].value,\n\t\t\t\t s.gamut_remap.temperature_matrix[5].value,\n\t\t\t\t s.gamut_remap.temperature_matrix[6].value,\n\t\t\t\t s.gamut_remap.temperature_matrix[7].value,\n\t\t\t\t s.gamut_remap.temperature_matrix[8].value,\n\t\t\t\t s.gamut_remap.temperature_matrix[9].value,\n\t\t\t\t s.gamut_remap.temperature_matrix[10].value,\n\t\t\t\t s.gamut_remap.temperature_matrix[11].value);\n\n\t\tDTN_INFO(\"\\n\");\n\t}\n\tDTN_INFO(\"\\n\");\n\tDTN_INFO(\"DPP Color Caps: input_lut_shared:%d  icsc:%d\"\n\t\t \"  dgam_ram:%d  dgam_rom: srgb:%d,bt2020:%d,gamma2_2:%d,pq:%d,hlg:%d\"\n\t\t \"  post_csc:%d  gamcor:%d  dgam_rom_for_yuv:%d  3d_lut:%d\"\n\t\t \"  blnd_lut:%d  oscs:%d\\n\\n\",\n\t\t dc->caps.color.dpp.input_lut_shared,\n\t\t dc->caps.color.dpp.icsc,\n\t\t dc->caps.color.dpp.dgam_ram,\n\t\t dc->caps.color.dpp.dgam_rom_caps.srgb,\n\t\t dc->caps.color.dpp.dgam_rom_caps.bt2020,\n\t\t dc->caps.color.dpp.dgam_rom_caps.gamma2_2,\n\t\t dc->caps.color.dpp.dgam_rom_caps.pq,\n\t\t dc->caps.color.dpp.dgam_rom_caps.hlg,\n\t\t dc->caps.color.dpp.post_csc,\n\t\t dc->caps.color.dpp.gamma_corr,\n\t\t dc->caps.color.dpp.dgam_rom_for_yuv,\n\t\t dc->caps.color.dpp.hw_3d_lut,\n\t\t dc->caps.color.dpp.ogam_ram,\n\t\t dc->caps.color.dpp.ocsc);\n\n\tDTN_INFO(\"MPCC:  OPP  DPP  MPCCBOT  MODE  ALPHA_MODE  PREMULT  OVERLAP_ONLY  IDLE\\n\");\n\tfor (i = 0; i < pool->mpcc_count; i++) {\n\t\tstruct mpcc_state s = {0};\n\n\t\tpool->mpc->funcs->read_mpcc_state(pool->mpc, i, &s);\n\t\tif (s.opp_id != 0xf)\n\t\t\tDTN_INFO(\"[%2d]:  %2xh  %2xh  %6xh  %4d  %10d  %7d  %12d  %4d\\n\",\n\t\t\t\ti, s.opp_id, s.dpp_id, s.bot_mpcc_id,\n\t\t\t\ts.mode, s.alpha_mode, s.pre_multiplied_alpha, s.overlap_only,\n\t\t\t\ts.idle);\n\t}\n\tDTN_INFO(\"\\n\");\n\tDTN_INFO(\"MPC Color Caps: gamut_remap:%d, 3dlut:%d, ogam_ram:%d, ocsc:%d\\n\\n\",\n\t\t dc->caps.color.mpc.gamut_remap,\n\t\t dc->caps.color.mpc.num_3dluts,\n\t\t dc->caps.color.mpc.ogam_ram,\n\t\t dc->caps.color.mpc.ocsc);\n}\n",
      "cve_list": [
        "CVE-2024-43901"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/ata/libata-core.c",
      "func_name": "ata_host_release",
      "func_body": "static void ata_host_release(struct kref *kref)\n{\n\tstruct ata_host *host = container_of(kref, struct ata_host, kref);\n\tint i;\n\n\tfor (i = 0; i < host->n_ports; i++) {\n\t\tstruct ata_port *ap = host->ports[i];\n\n\t\tif (!ap)\n\t\t\tcontinue;\n\n\t\tkfree(ap->pmp_link);\n\t\tkfree(ap->slave_link);\n\t\tkfree(ap->ncq_sense_buf);\n\t\tkfree(ap);\n\t\thost->ports[i] = NULL;\n\t}\n\tkfree(host);\n}\n",
      "cve_list": [
        "CVE-2024-41098"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/scsi/lpfc/lpfc_attr.c",
      "func_name": "lpfc_xcvr_data_show",
      "func_body": "static ssize_t\nlpfc_xcvr_data_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tint rc;\n\tint len = 0;\n\tstruct lpfc_rdp_context\t*rdp_context;\n\tu16 temperature;\n\tu16 rx_power;\n\tu16 tx_bias;\n\tu16 tx_power;\n\tu16 vcc;\n\tchar chbuf[128];\n\tu16 wavelength = 0;\n\tstruct sff_trasnceiver_codes_byte7 *trasn_code_byte7;\n\n\t/* Get transceiver information */\n\trdp_context = kmalloc(sizeof(*rdp_context), GFP_KERNEL);\n\tif (!rdp_context) {\n\t\tlen = scnprintf(buf, PAGE_SIZE - len,\n\t\t\t\t\"SPF info NA: alloc failure\\n\");\n\t\treturn len;\n\t}\n\n\trc = lpfc_get_sfp_info_wait(phba, rdp_context);\n\tif (rc) {\n\t\tlen = scnprintf(buf, PAGE_SIZE - len, \"SFP info NA:\\n\");\n\t\tgoto out_free_rdp;\n\t}\n\n\tstrscpy(chbuf, &rdp_context->page_a0[SSF_VENDOR_NAME], 16);\n\n\tlen = scnprintf(buf, PAGE_SIZE - len, \"VendorName:\\t%s\\n\", chbuf);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t \"VendorOUI:\\t%02x-%02x-%02x\\n\",\n\t\t\t (uint8_t)rdp_context->page_a0[SSF_VENDOR_OUI],\n\t\t\t (uint8_t)rdp_context->page_a0[SSF_VENDOR_OUI + 1],\n\t\t\t (uint8_t)rdp_context->page_a0[SSF_VENDOR_OUI + 2]);\n\tstrscpy(chbuf, &rdp_context->page_a0[SSF_VENDOR_PN], 16);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"VendorPN:\\t%s\\n\", chbuf);\n\tstrscpy(chbuf, &rdp_context->page_a0[SSF_VENDOR_SN], 16);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"VendorSN:\\t%s\\n\", chbuf);\n\tstrscpy(chbuf, &rdp_context->page_a0[SSF_VENDOR_REV], 4);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"VendorRev:\\t%s\\n\", chbuf);\n\tstrscpy(chbuf, &rdp_context->page_a0[SSF_DATE_CODE], 8);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"DateCode:\\t%s\\n\", chbuf);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"Identifier:\\t%xh\\n\",\n\t\t\t (uint8_t)rdp_context->page_a0[SSF_IDENTIFIER]);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"ExtIdentifier:\\t%xh\\n\",\n\t\t\t (uint8_t)rdp_context->page_a0[SSF_EXT_IDENTIFIER]);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"Connector:\\t%xh\\n\",\n\t\t\t (uint8_t)rdp_context->page_a0[SSF_CONNECTOR]);\n\twavelength = (rdp_context->page_a0[SSF_WAVELENGTH_B1] << 8) |\n\t\t      rdp_context->page_a0[SSF_WAVELENGTH_B0];\n\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"Wavelength:\\t%d nm\\n\",\n\t\t\t wavelength);\n\ttrasn_code_byte7 = (struct sff_trasnceiver_codes_byte7 *)\n\t\t\t&rdp_context->page_a0[SSF_TRANSCEIVER_CODE_B7];\n\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"Speeds: \\t\");\n\tif (*(uint8_t *)trasn_code_byte7 == 0) {\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"Unknown\\n\");\n\t} else {\n\t\tif (trasn_code_byte7->fc_sp_100MB)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"1 \");\n\t\tif (trasn_code_byte7->fc_sp_200mb)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"2 \");\n\t\tif (trasn_code_byte7->fc_sp_400MB)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"4 \");\n\t\tif (trasn_code_byte7->fc_sp_800MB)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"8 \");\n\t\tif (trasn_code_byte7->fc_sp_1600MB)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"16 \");\n\t\tif (trasn_code_byte7->fc_sp_3200MB)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"32 \");\n\t\tif (trasn_code_byte7->speed_chk_ecc)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"64 \");\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"GB\\n\");\n\t}\n\ttemperature = (rdp_context->page_a2[SFF_TEMPERATURE_B1] << 8 |\n\t\t       rdp_context->page_a2[SFF_TEMPERATURE_B0]);\n\tvcc = (rdp_context->page_a2[SFF_VCC_B1] << 8 |\n\t       rdp_context->page_a2[SFF_VCC_B0]);\n\ttx_power = (rdp_context->page_a2[SFF_TXPOWER_B1] << 8 |\n\t\t    rdp_context->page_a2[SFF_TXPOWER_B0]);\n\ttx_bias = (rdp_context->page_a2[SFF_TX_BIAS_CURRENT_B1] << 8 |\n\t\t   rdp_context->page_a2[SFF_TX_BIAS_CURRENT_B0]);\n\trx_power = (rdp_context->page_a2[SFF_RXPOWER_B1] << 8 |\n\t\t    rdp_context->page_a2[SFF_RXPOWER_B0]);\n\n\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t \"Temperature:\\tx%04x C\\n\", temperature);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"Vcc:\\t\\tx%04x V\\n\", vcc);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t \"TxBiasCurrent:\\tx%04x mA\\n\", tx_bias);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"TxPower:\\tx%04x mW\\n\",\n\t\t\t tx_power);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"RxPower:\\tx%04x mW\\n\",\n\t\t\t rx_power);\nout_free_rdp:\n\tkfree(rdp_context);\n\treturn len;\n}\n",
      "cve_list": [
        "CVE-2024-43821"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "sound/soc/mediatek/common/mtk-soundcard-driver.c",
      "func_name": "set_card_codec_info",
      "func_body": "static int set_card_codec_info(struct snd_soc_card *card,\n\t\t\t       struct device_node *sub_node,\n\t\t\t       struct snd_soc_dai_link *dai_link)\n{\n\tstruct device *dev = card->dev;\n\tstruct device_node *codec_node;\n\tint ret;\n\n\tcodec_node = of_get_child_by_name(sub_node, \"codec\");\n\tif (!codec_node) {\n\t\tdev_dbg(dev, \"%s no specified codec: setting dummy.\\n\", dai_link->name);\n\n\t\tdai_link->codecs = &snd_soc_dummy_dlc;\n\t\tdai_link->num_codecs = 1;\n\t\tdai_link->dynamic = 1;\n\t\treturn 0;\n\t}\n\n\t/* set card codec info */\n\tret = snd_soc_of_get_dai_link_codecs(dev, codec_node, dai_link);\n\n\tof_node_put(codec_node);\n\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"%s: codec dai not found\\n\",\n\t\t\t\t     dai_link->name);\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-38551"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/md/md.c",
      "func_name": "submit_flushes",
      "func_body": "static void submit_flushes(struct work_struct *ws)\n{\n\tstruct mddev *mddev = container_of(ws, struct mddev, flush_work);\n\tstruct md_rdev *rdev;\n\n\tmddev->start_flush = ktime_get_boottime();\n\tINIT_WORK(&mddev->flush_work, md_submit_flush_data);\n\tatomic_set(&mddev->flush_pending, 1);\n\trcu_read_lock();\n\trdev_for_each_rcu(rdev, mddev)\n\t\tif (rdev->raid_disk >= 0 &&\n\t\t    !test_bit(Faulty, &rdev->flags)) {\n\t\t\tstruct bio *bi;\n\n\t\t\tatomic_inc(&rdev->nr_pending);\n\t\t\trcu_read_unlock();\n\t\t\tbi = bio_alloc_bioset(rdev->bdev, 0,\n\t\t\t\t\t      REQ_OP_WRITE | REQ_PREFLUSH,\n\t\t\t\t\t      GFP_NOIO, &mddev->bio_set);\n\t\t\tbi->bi_end_io = md_end_flush;\n\t\t\tbi->bi_private = rdev;\n\t\t\tatomic_inc(&mddev->flush_pending);\n\t\t\tsubmit_bio(bi);\n\t\t\trcu_read_lock();\n\t\t}\n\trcu_read_unlock();\n\tif (atomic_dec_and_test(&mddev->flush_pending))\n\t\tqueue_work(md_wq, &mddev->flush_work);\n}\n",
      "cve_list": [
        "CVE-2024-43855"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/md/md.c",
      "func_name": "md_submit_flush_data",
      "func_body": "static void md_submit_flush_data(struct work_struct *ws)\n{\n\tstruct mddev *mddev = container_of(ws, struct mddev, flush_work);\n\tstruct bio *bio = mddev->flush_bio;\n\n\t/*\n\t * must reset flush_bio before calling into md_handle_request to avoid a\n\t * deadlock, because other bios passed md_handle_request suspend check\n\t * could wait for this and below md_handle_request could wait for those\n\t * bios because of suspend check\n\t */\n\tspin_lock_irq(&mddev->lock);\n\tmddev->prev_flush_start = mddev->start_flush;\n\tmddev->flush_bio = NULL;\n\tspin_unlock_irq(&mddev->lock);\n\twake_up(&mddev->sb_wait);\n\n\tif (bio->bi_iter.bi_size == 0) {\n\t\t/* an empty barrier - all done */\n\t\tbio_endio(bio);\n\t} else {\n\t\tbio->bi_opf &= ~REQ_PREFLUSH;\n\n\t\t/*\n\t\t * make_requst() will never return error here, it only\n\t\t * returns error in raid5_make_request() by dm-raid.\n\t\t * Since dm always splits data and flush operation into\n\t\t * two separate io, io size of flush submitted by dm\n\t\t * always is 0, make_request() will not be called here.\n\t\t */\n\t\tif (WARN_ON_ONCE(!mddev->pers->make_request(mddev, bio)))\n\t\t\tbio_io_error(bio);;\n\t}\n\n\t/* The pair is percpu_ref_get() from md_flush_request() */\n\tpercpu_ref_put(&mddev->active_io);\n}\n",
      "cve_list": [
        "CVE-2024-43855"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/pci/controller/dwc/pci-keystone.c",
      "func_name": "ks_pcie_quirk",
      "func_body": "static void ks_pcie_quirk(struct pci_dev *dev)\n{\n\tstruct pci_bus *bus = dev->bus;\n\tstruct keystone_pcie *ks_pcie;\n\tstruct device *bridge_dev;\n\tstruct pci_dev *bridge;\n\tu32 val;\n\n\tstatic const struct pci_device_id rc_pci_devids[] = {\n\t\t{ PCI_DEVICE(PCI_VENDOR_ID_TI, PCIE_RC_K2HK),\n\t\t .class = PCI_CLASS_BRIDGE_PCI_NORMAL, .class_mask = ~0, },\n\t\t{ PCI_DEVICE(PCI_VENDOR_ID_TI, PCIE_RC_K2E),\n\t\t .class = PCI_CLASS_BRIDGE_PCI_NORMAL, .class_mask = ~0, },\n\t\t{ PCI_DEVICE(PCI_VENDOR_ID_TI, PCIE_RC_K2L),\n\t\t .class = PCI_CLASS_BRIDGE_PCI_NORMAL, .class_mask = ~0, },\n\t\t{ PCI_DEVICE(PCI_VENDOR_ID_TI, PCIE_RC_K2G),\n\t\t .class = PCI_CLASS_BRIDGE_PCI_NORMAL, .class_mask = ~0, },\n\t\t{ 0, },\n\t};\n\tstatic const struct pci_device_id am6_pci_devids[] = {\n\t\t{ PCI_DEVICE(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_AM654X),\n\t\t .class = PCI_CLASS_BRIDGE_PCI << 8, .class_mask = ~0, },\n\t\t{ 0, },\n\t};\n\n\tif (pci_is_root_bus(bus))\n\t\tbridge = dev;\n\n\t/* look for the host bridge */\n\twhile (!pci_is_root_bus(bus)) {\n\t\tbridge = bus->self;\n\t\tbus = bus->parent;\n\t}\n\n\tif (!bridge)\n\t\treturn;\n\n\t/*\n\t * Keystone PCI controller has a h/w limitation of\n\t * 256 bytes maximum read request size.  It can't handle\n\t * anything higher than this.  So force this limit on\n\t * all downstream devices.\n\t */\n\tif (pci_match_id(rc_pci_devids, bridge)) {\n\t\tif (pcie_get_readrq(dev) > 256) {\n\t\t\tdev_info(&dev->dev, \"limiting MRRS to 256 bytes\\n\");\n\t\t\tpcie_set_readrq(dev, 256);\n\t\t}\n\t}\n\n\t/*\n\t * Memory transactions fail with PCI controller in AM654 PG1.0\n\t * when MRRS is set to more than 128 bytes. Force the MRRS to\n\t * 128 bytes in all downstream devices.\n\t */\n\tif (pci_match_id(am6_pci_devids, bridge)) {\n\t\tbridge_dev = pci_get_host_bridge_device(dev);\n\t\tif (!bridge_dev || !bridge_dev->parent)\n\t\t\treturn;\n\n\t\tks_pcie = dev_get_drvdata(bridge_dev->parent);\n\t\tif (!ks_pcie)\n\t\t\treturn;\n\n\t\tval = ks_pcie_app_readl(ks_pcie, PID);\n\t\tval &= RTL;\n\t\tval >>= RTL_SHIFT;\n\t\tif (val != AM6_PCI_PG1_RTL_VER)\n\t\t\treturn;\n\n\t\tif (pcie_get_readrq(dev) > 128) {\n\t\t\tdev_info(&dev->dev, \"limiting MRRS to 128 bytes\\n\");\n\t\t\tpcie_set_readrq(dev, 128);\n\t\t}\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-47756"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/iommu/sprd-iommu.c",
      "func_name": "sprd_iommu_cleanup",
      "func_body": "static void sprd_iommu_cleanup(struct sprd_iommu_domain *dom)\n{\n\tsize_t pgt_size;\n\n\t/* Nothing need to do if the domain hasn't been attached */\n\tif (!dom->sdev)\n\t\treturn;\n\n\tpgt_size = sprd_iommu_pgt_size(&dom->domain);\n\tdma_free_coherent(dom->sdev->dev, pgt_size, dom->pgt_va, dom->pgt_pa);\n\tsprd_iommu_hw_en(dom->sdev, false);\n\tdom->sdev = NULL;\n}\n",
      "cve_list": [
        "CVE-2024-42277"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "sound/pci/hda/cs35l41_hda.c",
      "func_name": "cs35l41_hda_unbind",
      "func_body": "static void cs35l41_hda_unbind(struct device *dev, struct device *master, void *master_data)\n{\n\tstruct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);\n\tstruct hda_component *comps = master_data;\n\tunsigned int sleep_flags;\n\n\tif (comps[cs35l41->index].dev == dev) {\n\t\tmemset(&comps[cs35l41->index], 0, sizeof(*comps));\n\t\tsleep_flags = lock_system_sleep();\n\t\tdevice_link_remove(&cs35l41->codec->core.dev, cs35l41->dev);\n\t\tunlock_system_sleep(sleep_flags);\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-40964"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/wireless/util.c",
      "func_name": "cfg80211_get_station",
      "func_body": "int cfg80211_get_station(struct net_device *dev, const u8 *mac_addr,\n\t\t\t struct station_info *sinfo)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tint ret;\n\n\twdev = dev->ieee80211_ptr;\n\tif (!wdev)\n\t\treturn -EOPNOTSUPP;\n\n\trdev = wiphy_to_rdev(wdev->wiphy);\n\tif (!rdev->ops->get_station)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(sinfo, 0, sizeof(*sinfo));\n\n\twiphy_lock(&rdev->wiphy);\n\tret = rdev_get_station(rdev, dev, mac_addr, sinfo);\n\twiphy_unlock(&rdev->wiphy);\n\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-40911"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/iommu/arm/arm-smmu/arm-smmu-nvidia.c",
      "func_name": "nvidia_smmu_context_fault",
      "func_body": "static irqreturn_t nvidia_smmu_context_fault(int irq, void *dev)\n{\n\tint idx;\n\tunsigned int inst;\n\tirqreturn_t ret = IRQ_NONE;\n\tstruct arm_smmu_device *smmu;\n\tstruct arm_smmu_domain *smmu_domain = dev;\n\tstruct nvidia_smmu *nvidia;\n\n\tsmmu = smmu_domain->smmu;\n\tnvidia = to_nvidia_smmu(smmu);\n\n\tfor (inst = 0; inst < nvidia->num_instances; inst++) {\n\t\tirqreturn_t irq_ret;\n\n\t\t/*\n\t\t * Interrupt line is shared between all contexts.\n\t\t * Check for faults across all contexts.\n\t\t */\n\t\tfor (idx = 0; idx < smmu->num_context_banks; idx++) {\n\t\t\tirq_ret = nvidia_smmu_context_fault_bank(irq, smmu,\n\t\t\t\t\t\t\t\t idx, inst);\n\t\t\tif (irq_ret == IRQ_HANDLED)\n\t\t\t\tret = IRQ_HANDLED;\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-36884"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/core/skmsg.c",
      "func_name": "sk_psock_verdict_data_ready",
      "func_body": "static void sk_psock_verdict_data_ready(struct sock *sk)\n{\n\tstruct socket *sock = sk->sk_socket;\n\tconst struct proto_ops *ops;\n\tint copied;\n\n\ttrace_sk_data_ready(sk);\n\n\tif (unlikely(!sock))\n\t\treturn;\n\tops = READ_ONCE(sock->ops);\n\tif (!ops || !ops->read_skb)\n\t\treturn;\n\tcopied = ops->read_skb(sk, sk_psock_verdict_recv);\n\tif (copied >= 0) {\n\t\tstruct sk_psock *psock;\n\n\t\trcu_read_lock();\n\t\tpsock = sk_psock(sk);\n\t\tif (psock)\n\t\t\tsk_psock_data_ready(sk, psock);\n\t\trcu_read_unlock();\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-36938"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/nouveau/dispnv04/tvnv17.c",
      "func_name": "nv17_tv_get_ld_modes",
      "func_body": "static int nv17_tv_get_ld_modes(struct drm_encoder *encoder,\n\t\t\t\tstruct drm_connector *connector)\n{\n\tstruct nv17_tv_norm_params *tv_norm = get_tv_norm(encoder);\n\tconst struct drm_display_mode *tv_mode;\n\tint n = 0;\n\n\tfor (tv_mode = nv17_tv_modes; tv_mode->hdisplay; tv_mode++) {\n\t\tstruct drm_display_mode *mode;\n\n\t\tmode = drm_mode_duplicate(encoder->dev, tv_mode);\n\t\tif (!mode)\n\t\t\tcontinue;\n\n\t\tmode->clock = tv_norm->tv_enc_mode.vrefresh *\n\t\t\tmode->htotal / 1000 *\n\t\t\tmode->vtotal / 1000;\n\n\t\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\t\tmode->clock *= 2;\n\n\t\tif (mode->hdisplay == tv_norm->tv_enc_mode.hdisplay &&\n\t\t    mode->vdisplay == tv_norm->tv_enc_mode.vdisplay)\n\t\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\n\t\tdrm_mode_probed_add(connector, mode);\n\t\tn++;\n\t}\n\n\treturn n;\n}\n",
      "cve_list": [
        "CVE-2024-41095"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/ocfs2/journal.c",
      "func_name": "ocfs2_abort_trigger",
      "func_body": "static void ocfs2_abort_trigger(struct jbd2_buffer_trigger_type *triggers,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tstruct ocfs2_triggers *ot = to_ocfs2_trigger(triggers);\n\n\tmlog(ML_ERROR,\n\t     \"ocfs2_abort_trigger called by JBD2.  bh = 0x%lx, \"\n\t     \"bh->b_blocknr = %llu\\n\",\n\t     (unsigned long)bh,\n\t     (unsigned long long)bh->b_blocknr);\n\n\tocfs2_error(ot->sb,\n\t\t    \"JBD2 has aborted our journal, ocfs2 cannot continue\\n\");\n}\n",
      "cve_list": [
        "CVE-2024-40951"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/ocfs2/super.c",
      "func_name": "ocfs2_fill_super",
      "func_body": "static int ocfs2_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct dentry *root;\n\tint status, sector_size;\n\tstruct mount_options parsed_options;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_super *osb = NULL;\n\tstruct buffer_head *bh = NULL;\n\tchar nodestr[12];\n\tstruct ocfs2_blockcheck_stats stats;\n\n\ttrace_ocfs2_fill_super(sb, data, silent);\n\n\tif (!ocfs2_parse_options(sb, data, &parsed_options, 0)) {\n\t\tstatus = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* probe for superblock */\n\tstatus = ocfs2_sb_probe(sb, &bh, &sector_size, &stats);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"superblock probe failed!\\n\");\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_initialize_super(sb, bh, sector_size, &stats);\n\tbrelse(bh);\n\tbh = NULL;\n\tif (status < 0)\n\t\tgoto out;\n\n\tosb = OCFS2_SB(sb);\n\n\tif (!ocfs2_check_set_options(sb, &parsed_options)) {\n\t\tstatus = -EINVAL;\n\t\tgoto out_super;\n\t}\n\tosb->s_mount_opt = parsed_options.mount_opt;\n\tosb->s_atime_quantum = parsed_options.atime_quantum;\n\tosb->preferred_slot = parsed_options.slot;\n\tosb->osb_commit_interval = parsed_options.commit_interval;\n\n\tocfs2_la_set_sizes(osb, parsed_options.localalloc_opt);\n\tosb->osb_resv_level = parsed_options.resv_level;\n\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\tif (parsed_options.dir_resv_level == -1)\n\t\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\telse\n\t\tosb->osb_dir_resv_level = parsed_options.dir_resv_level;\n\n\tstatus = ocfs2_verify_userspace_stack(osb, &parsed_options);\n\tif (status)\n\t\tgoto out_super;\n\n\tsb->s_magic = OCFS2_SUPER_MAGIC;\n\n\tsb->s_flags = (sb->s_flags & ~(SB_POSIXACL | SB_NOSEC)) |\n\t\t((osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) ? SB_POSIXACL : 0);\n\n\t/* Hard readonly mode only if: bdev_read_only, SB_RDONLY,\n\t * heartbeat=none */\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\tif (!sb_rdonly(sb)) {\n\t\t\tstatus = -EACCES;\n\t\t\tmlog(ML_ERROR, \"Readonly device detected but readonly \"\n\t\t\t     \"mount was not specified.\\n\");\n\t\t\tgoto out_super;\n\t\t}\n\n\t\t/* You should not be able to start a local heartbeat\n\t\t * on a readonly device. */\n\t\tif (osb->s_mount_opt & OCFS2_MOUNT_HB_LOCAL) {\n\t\t\tstatus = -EROFS;\n\t\t\tmlog(ML_ERROR, \"Local heartbeat specified on readonly \"\n\t\t\t     \"device.\\n\");\n\t\t\tgoto out_super;\n\t\t}\n\n\t\tstatus = ocfs2_check_journals_nolocks(osb);\n\t\tif (status < 0) {\n\t\t\tif (status == -EROFS)\n\t\t\t\tmlog(ML_ERROR, \"Recovery required on readonly \"\n\t\t\t\t     \"file system, but write access is \"\n\t\t\t\t     \"unavailable.\\n\");\n\t\t\tgoto out_super;\n\t\t}\n\n\t\tocfs2_set_ro_flag(osb, 1);\n\n\t\tprintk(KERN_NOTICE \"ocfs2: Readonly device (%s) detected. \"\n\t\t       \"Cluster services will not be used for this mount. \"\n\t\t       \"Recovery will be skipped.\\n\", osb->dev_str);\n\t}\n\n\tif (!ocfs2_is_hard_readonly(osb)) {\n\t\tif (sb_rdonly(sb))\n\t\t\tocfs2_set_ro_flag(osb, 0);\n\t}\n\n\tstatus = ocfs2_verify_heartbeat(osb);\n\tif (status < 0)\n\t\tgoto out_super;\n\n\tosb->osb_debug_root = debugfs_create_dir(osb->uuid_str,\n\t\t\t\t\t\t ocfs2_debugfs_root);\n\n\tdebugfs_create_file(\"fs_state\", S_IFREG|S_IRUSR, osb->osb_debug_root,\n\t\t\t    osb, &ocfs2_osb_debug_fops);\n\n\tif (ocfs2_meta_ecc(osb)) {\n\t\tocfs2_initialize_journal_triggers(sb, osb->s_journal_triggers);\n\t\tocfs2_blockcheck_stats_debugfs_install( &osb->osb_ecc_stats,\n\t\t\t\t\t\t\tosb->osb_debug_root);\n\t}\n\n\tstatus = ocfs2_mount_volume(sb);\n\tif (status < 0)\n\t\tgoto out_debugfs;\n\n\tif (osb->root_inode)\n\t\tinode = igrab(osb->root_inode);\n\n\tif (!inode) {\n\t\tstatus = -EIO;\n\t\tgoto out_dismount;\n\t}\n\n\tosb->osb_dev_kset = kset_create_and_add(sb->s_id, NULL,\n\t\t\t\t\t\t&ocfs2_kset->kobj);\n\tif (!osb->osb_dev_kset) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create device kset %s.\\n\", sb->s_id);\n\t\tgoto out_dismount;\n\t}\n\n\t/* Create filecheck sysfs related directories/files at\n\t * /sys/fs/ocfs2/<devname>/filecheck */\n\tif (ocfs2_filecheck_create_sysfs(osb)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create filecheck sysfs directory at \"\n\t\t\t\"/sys/fs/ocfs2/%s/filecheck.\\n\", sb->s_id);\n\t\tgoto out_dismount;\n\t}\n\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out_dismount;\n\t}\n\n\tsb->s_root = root;\n\n\tocfs2_complete_mount_recovery(osb);\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Mounting device (%s) on (node %s, slot %d) \"\n\t       \"with %s data mode.\\n\",\n\t       osb->dev_str, nodestr, osb->slot_num,\n\t       osb->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK ? \"writeback\" :\n\t       \"ordered\");\n\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Now we can initialize quotas because we can afford to wait\n\t * for cluster locks recovery now. That also means that truncation\n\t * log recovery can happen but that waits for proper quota setup */\n\tif (!sb_rdonly(sb)) {\n\t\tstatus = ocfs2_enable_quotas(osb);\n\t\tif (status < 0) {\n\t\t\t/* We have to err-out specially here because\n\t\t\t * s_root is already set */\n\t\t\tmlog_errno(status);\n\t\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\t\twake_up(&osb->osb_mount_event);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tocfs2_complete_quota_recovery(osb);\n\n\t/* Now we wake up again for processes waiting for quotas */\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED_QUOTAS);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Start this when the mount is almost sure of being successful */\n\tocfs2_orphan_scan_start(osb);\n\n\treturn status;\n\nout_dismount:\n\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\twake_up(&osb->osb_mount_event);\n\tocfs2_free_replay_slots(osb);\n\tocfs2_dismount_volume(sb, 1);\n\tgoto out;\n\nout_debugfs:\n\tdebugfs_remove_recursive(osb->osb_debug_root);\nout_super:\n\tocfs2_release_system_inodes(osb);\n\tkfree(osb->recovery_map);\n\tocfs2_delete_osb(osb);\n\tkfree(osb);\nout:\n\tmlog_errno(status);\n\n\treturn status;\n}\n",
      "cve_list": [
        "CVE-2024-40951"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/amdgpu/amdgpu_device.c",
      "func_name": "amdgpu_device_recover_vram",
      "func_body": "static int amdgpu_device_recover_vram(struct amdgpu_device *adev)\n{\n\tstruct dma_fence *fence = NULL, *next = NULL;\n\tstruct amdgpu_bo *shadow;\n\tstruct amdgpu_bo_vm *vmbo;\n\tlong r = 1, tmo;\n\n\tif (amdgpu_sriov_runtime(adev))\n\t\ttmo = msecs_to_jiffies(8000);\n\telse\n\t\ttmo = msecs_to_jiffies(100);\n\n\tdev_info(adev->dev, \"recover vram bo from shadow start\\n\");\n\tmutex_lock(&adev->shadow_list_lock);\n\tlist_for_each_entry(vmbo, &adev->shadow_list, shadow_list) {\n\t\t/* If vm is compute context or adev is APU, shadow will be NULL */\n\t\tif (!vmbo->shadow)\n\t\t\tcontinue;\n\t\tshadow = vmbo->shadow;\n\n\t\t/* No need to recover an evicted BO */\n\t\tif (!shadow->tbo.resource ||\n\t\t    shadow->tbo.resource->mem_type != TTM_PL_TT ||\n\t\t    shadow->tbo.resource->start == AMDGPU_BO_INVALID_OFFSET ||\n\t\t    shadow->parent->tbo.resource->mem_type != TTM_PL_VRAM)\n\t\t\tcontinue;\n\n\t\tr = amdgpu_bo_restore_shadow(shadow, &next);\n\t\tif (r)\n\t\t\tbreak;\n\n\t\tif (fence) {\n\t\t\ttmo = dma_fence_wait_timeout(fence, false, tmo);\n\t\t\tdma_fence_put(fence);\n\t\t\tfence = next;\n\t\t\tif (tmo == 0) {\n\t\t\t\tr = -ETIMEDOUT;\n\t\t\t\tbreak;\n\t\t\t} else if (tmo < 0) {\n\t\t\t\tr = tmo;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tfence = next;\n\t\t}\n\t}\n\tmutex_unlock(&adev->shadow_list_lock);\n\n\tif (fence)\n\t\ttmo = dma_fence_wait_timeout(fence, false, tmo);\n\tdma_fence_put(fence);\n\n\tif (r < 0 || tmo <= 0) {\n\t\tdev_err(adev->dev, \"recover vram bo from shadow failed, r is %ld, tmo is %ld\\n\", r, tmo);\n\t\treturn -EIO;\n\t}\n\n\tdev_info(adev->dev, \"recover vram bo from shadow done\\n\");\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-46807"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/nouveau/dispnv04/tvnv17.c",
      "func_name": "nv17_tv_get_hd_modes",
      "func_body": "static int nv17_tv_get_hd_modes(struct drm_encoder *encoder,\n\t\t\t\tstruct drm_connector *connector)\n{\n\tstruct nv17_tv_norm_params *tv_norm = get_tv_norm(encoder);\n\tstruct drm_display_mode *output_mode = &tv_norm->ctv_enc_mode.mode;\n\tstruct drm_display_mode *mode;\n\tconst struct {\n\t\tint hdisplay;\n\t\tint vdisplay;\n\t} modes[] = {\n\t\t{ 640, 400 },\n\t\t{ 640, 480 },\n\t\t{ 720, 480 },\n\t\t{ 720, 576 },\n\t\t{ 800, 600 },\n\t\t{ 1024, 768 },\n\t\t{ 1280, 720 },\n\t\t{ 1280, 1024 },\n\t\t{ 1920, 1080 }\n\t};\n\tint i, n = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(modes); i++) {\n\t\tif (modes[i].hdisplay > output_mode->hdisplay ||\n\t\t    modes[i].vdisplay > output_mode->vdisplay)\n\t\t\tcontinue;\n\n\t\tif (modes[i].hdisplay == output_mode->hdisplay &&\n\t\t    modes[i].vdisplay == output_mode->vdisplay) {\n\t\t\tmode = drm_mode_duplicate(encoder->dev, output_mode);\n\t\t\tif (!mode)\n\t\t\t\tcontinue;\n\t\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\n\t\t} else {\n\t\t\tmode = drm_cvt_mode(encoder->dev, modes[i].hdisplay,\n\t\t\t\t\t    modes[i].vdisplay, 60, false,\n\t\t\t\t\t    (output_mode->flags &\n\t\t\t\t\t     DRM_MODE_FLAG_INTERLACE), false);\n\t\t\tif (!mode)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* CVT modes are sometimes unsuitable... */\n\t\tif (output_mode->hdisplay <= 720\n\t\t    || output_mode->hdisplay >= 1920) {\n\t\t\tmode->htotal = output_mode->htotal;\n\t\t\tmode->hsync_start = (mode->hdisplay + (mode->htotal\n\t\t\t\t\t     - mode->hdisplay) * 9 / 10) & ~7;\n\t\t\tmode->hsync_end = mode->hsync_start + 8;\n\t\t}\n\n\t\tif (output_mode->vdisplay >= 1024) {\n\t\t\tmode->vtotal = output_mode->vtotal;\n\t\t\tmode->vsync_start = output_mode->vsync_start;\n\t\t\tmode->vsync_end = output_mode->vsync_end;\n\t\t}\n\n\t\tmode->type |= DRM_MODE_TYPE_DRIVER;\n\t\tdrm_mode_probed_add(connector, mode);\n\t\tn++;\n\t}\n\n\treturn n;\n}\n",
      "cve_list": [
        "CVE-2024-41089"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/radeon/radeon_gem.c",
      "func_name": "radeon_gem_va_update_vm",
      "func_body": "static void radeon_gem_va_update_vm(struct radeon_device *rdev,\n\t\t\t\t    struct radeon_bo_va *bo_va)\n{\n\tstruct ttm_validate_buffer tv, *entry;\n\tstruct radeon_bo_list *vm_bos;\n\tstruct ww_acquire_ctx ticket;\n\tstruct list_head list;\n\tunsigned domain;\n\tint r;\n\n\tINIT_LIST_HEAD(&list);\n\n\ttv.bo = &bo_va->bo->tbo;\n\ttv.num_shared = 1;\n\tlist_add(&tv.head, &list);\n\n\tvm_bos = radeon_vm_get_bos(rdev, bo_va->vm, &list);\n\tif (!vm_bos)\n\t\treturn;\n\n\tr = ttm_eu_reserve_buffers(&ticket, &list, true, NULL);\n\tif (r)\n\t\tgoto error_free;\n\n\tlist_for_each_entry(entry, &list, head) {\n\t\tdomain = radeon_mem_type_to_domain(entry->bo->resource->mem_type);\n\t\t/* if anything is swapped out don't swap it in here,\n\t\t   just abort and wait for the next CS */\n\t\tif (domain == RADEON_GEM_DOMAIN_CPU)\n\t\t\tgoto error_unreserve;\n\t}\n\n\tmutex_lock(&bo_va->vm->mutex);\n\tr = radeon_vm_clear_freed(rdev, bo_va->vm);\n\tif (r)\n\t\tgoto error_unlock;\n\n\tif (bo_va->it.start && bo_va->bo)\n\t\tr = radeon_vm_bo_update(rdev, bo_va, bo_va->bo->tbo.resource);\n\nerror_unlock:\n\tmutex_unlock(&bo_va->vm->mutex);\n\nerror_unreserve:\n\tttm_eu_backoff_reservation(&ticket, &list);\n\nerror_free:\n\tkvfree(vm_bos);\n\n\tif (r && r != -ERESTARTSYS)\n\t\tDRM_ERROR(\"Couldn't update BO_VA (%d)\\n\", r);\n}\n",
      "cve_list": [
        "CVE-2024-41060"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "crypto/asymmetric_keys/asymmetric_type.c",
      "func_name": "find_asymmetric_key",
      "func_body": "struct key *find_asymmetric_key(struct key *keyring,\n\t\t\t\tconst struct asymmetric_key_id *id_0,\n\t\t\t\tconst struct asymmetric_key_id *id_1,\n\t\t\t\tconst struct asymmetric_key_id *id_2,\n\t\t\t\tbool partial)\n{\n\tstruct key *key;\n\tkey_ref_t ref;\n\tconst char *lookup;\n\tchar *req, *p;\n\tint len;\n\n\tif (id_0) {\n\t\tlookup = id_0->data;\n\t\tlen = id_0->len;\n\t} else if (id_1) {\n\t\tlookup = id_1->data;\n\t\tlen = id_1->len;\n\t} else if (id_2) {\n\t\tlookup = id_2->data;\n\t\tlen = id_2->len;\n\t} else {\n\t\tWARN_ON(1);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/* Construct an identifier \"id:<keyid>\". */\n\tp = req = kmalloc(2 + 1 + len * 2 + 1, GFP_KERNEL);\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!id_0 && !id_1) {\n\t\t*p++ = 'd';\n\t\t*p++ = 'n';\n\t} else if (partial) {\n\t\t*p++ = 'i';\n\t\t*p++ = 'd';\n\t} else {\n\t\t*p++ = 'e';\n\t\t*p++ = 'x';\n\t}\n\t*p++ = ':';\n\tp = bin2hex(p, lookup, len);\n\t*p = 0;\n\n\tpr_debug(\"Look up: \\\"%s\\\"\\n\", req);\n\n\tref = keyring_search(make_key_ref(keyring, 1),\n\t\t\t     &key_type_asymmetric, req, true);\n\tif (IS_ERR(ref))\n\t\tpr_debug(\"Request for key '%s' err %ld\\n\", req, PTR_ERR(ref));\n\tkfree(req);\n\n\tif (IS_ERR(ref)) {\n\t\tswitch (PTR_ERR(ref)) {\n\t\t\t/* Hide some search errors */\n\t\tcase -EACCES:\n\t\tcase -ENOTDIR:\n\t\tcase -EAGAIN:\n\t\t\treturn ERR_PTR(-ENOKEY);\n\t\tdefault:\n\t\t\treturn ERR_CAST(ref);\n\t\t}\n\t}\n\n\tkey = key_ref_to_ptr(ref);\n\tif (id_0 && id_1) {\n\t\tconst struct asymmetric_key_ids *kids = asymmetric_key_ids(key);\n\n\t\tif (!kids->id[1]) {\n\t\t\tpr_debug(\"First ID matches, but second is missing\\n\");\n\t\t\tgoto reject;\n\t\t}\n\t\tif (!asymmetric_key_id_same(id_1, kids->id[1])) {\n\t\t\tpr_debug(\"First ID matches, but second does not\\n\");\n\t\t\tgoto reject;\n\t\t}\n\t}\n\n\tpr_devel(\"<==%s() = 0 [%x]\\n\", __func__, key_serial(key));\n\treturn key;\n\nreject:\n\tkey_put(key);\n\treturn ERR_PTR(-EKEYREJECTED);\n}\n",
      "cve_list": [
        "CVE-2024-47743"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/tty/serial/max3100.c",
      "func_name": "max3100_probe",
      "func_body": "static int max3100_probe(struct spi_device *spi)\n{\n\tint i, retval;\n\tstruct plat_max3100 *pdata;\n\tu16 tx, rx;\n\n\tmutex_lock(&max3100s_lock);\n\n\tif (!uart_driver_registered) {\n\t\tretval = uart_register_driver(&max3100_uart_driver);\n\t\tif (retval) {\n\t\t\tprintk(KERN_ERR \"Couldn't register max3100 uart driver\\n\");\n\t\t\tmutex_unlock(&max3100s_lock);\n\t\t\treturn retval;\n\t\t}\n\n\t\tuart_driver_registered = 1;\n\t}\n\n\tfor (i = 0; i < MAX_MAX3100; i++)\n\t\tif (!max3100s[i])\n\t\t\tbreak;\n\tif (i == MAX_MAX3100) {\n\t\tdev_warn(&spi->dev, \"too many MAX3100 chips\\n\");\n\t\tmutex_unlock(&max3100s_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tmax3100s[i] = kzalloc(sizeof(struct max3100_port), GFP_KERNEL);\n\tif (!max3100s[i]) {\n\t\tdev_warn(&spi->dev,\n\t\t\t \"kmalloc for max3100 structure %d failed!\\n\", i);\n\t\tmutex_unlock(&max3100s_lock);\n\t\treturn -ENOMEM;\n\t}\n\tmax3100s[i]->spi = spi;\n\tmax3100s[i]->irq = spi->irq;\n\tspin_lock_init(&max3100s[i]->conf_lock);\n\tspi_set_drvdata(spi, max3100s[i]);\n\tpdata = dev_get_platdata(&spi->dev);\n\tmax3100s[i]->crystal = pdata->crystal;\n\tmax3100s[i]->loopback = pdata->loopback;\n\tmax3100s[i]->poll_time = msecs_to_jiffies(pdata->poll_time);\n\tif (pdata->poll_time > 0 && max3100s[i]->poll_time == 0)\n\t\tmax3100s[i]->poll_time = 1;\n\tmax3100s[i]->max3100_hw_suspend = pdata->max3100_hw_suspend;\n\tmax3100s[i]->minor = i;\n\ttimer_setup(&max3100s[i]->timer, max3100_timeout, 0);\n\n\tdev_dbg(&spi->dev, \"%s: adding port %d\\n\", __func__, i);\n\tmax3100s[i]->port.irq = max3100s[i]->irq;\n\tmax3100s[i]->port.uartclk = max3100s[i]->crystal ? 3686400 : 1843200;\n\tmax3100s[i]->port.fifosize = 16;\n\tmax3100s[i]->port.ops = &max3100_ops;\n\tmax3100s[i]->port.flags = UPF_SKIP_TEST | UPF_BOOT_AUTOCONF;\n\tmax3100s[i]->port.line = i;\n\tmax3100s[i]->port.type = PORT_MAX3100;\n\tmax3100s[i]->port.dev = &spi->dev;\n\tretval = uart_add_one_port(&max3100_uart_driver, &max3100s[i]->port);\n\tif (retval < 0)\n\t\tdev_warn(&spi->dev,\n\t\t\t \"uart_add_one_port failed for line %d with error %d\\n\",\n\t\t\t i, retval);\n\n\t/* set shutdown mode to save power. Will be woken-up on open */\n\tif (max3100s[i]->max3100_hw_suspend)\n\t\tmax3100s[i]->max3100_hw_suspend(1);\n\telse {\n\t\ttx = MAX3100_WC | MAX3100_SHDN;\n\t\tmax3100_sr(max3100s[i], tx, &rx);\n\t}\n\tmutex_unlock(&max3100s_lock);\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-38633"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/bpf/syscall.c",
      "func_name": "bpf_tracing_prog_attach",
      "func_body": "static int bpf_tracing_prog_attach(struct bpf_prog *prog,\n\t\t\t\t   int tgt_prog_fd,\n\t\t\t\t   u32 btf_id,\n\t\t\t\t   u64 bpf_cookie)\n{\n\tstruct bpf_link_primer link_primer;\n\tstruct bpf_prog *tgt_prog = NULL;\n\tstruct bpf_trampoline *tr = NULL;\n\tstruct bpf_tracing_link *link;\n\tu64 key = 0;\n\tint err;\n\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_TRACING:\n\t\tif (prog->expected_attach_type != BPF_TRACE_FENTRY &&\n\t\t    prog->expected_attach_type != BPF_TRACE_FEXIT &&\n\t\t    prog->expected_attach_type != BPF_MODIFY_RETURN) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbreak;\n\tcase BPF_PROG_TYPE_EXT:\n\t\tif (prog->expected_attach_type != 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbreak;\n\tcase BPF_PROG_TYPE_LSM:\n\t\tif (prog->expected_attach_type != BPF_LSM_MAC) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out_put_prog;\n\t}\n\n\tif (!!tgt_prog_fd != !!btf_id) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_prog;\n\t}\n\n\tif (tgt_prog_fd) {\n\t\t/*\n\t\t * For now we only allow new targets for BPF_PROG_TYPE_EXT. If this\n\t\t * part would be changed to implement the same for\n\t\t * BPF_PROG_TYPE_TRACING, do not forget to update the way how\n\t\t * attach_tracing_prog flag is set.\n\t\t */\n\t\tif (prog->type != BPF_PROG_TYPE_EXT) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\n\t\ttgt_prog = bpf_prog_get(tgt_prog_fd);\n\t\tif (IS_ERR(tgt_prog)) {\n\t\t\terr = PTR_ERR(tgt_prog);\n\t\t\ttgt_prog = NULL;\n\t\t\tgoto out_put_prog;\n\t\t}\n\n\t\tkey = bpf_trampoline_compute_key(tgt_prog, NULL, btf_id);\n\t}\n\n\tlink = kzalloc(sizeof(*link), GFP_USER);\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_prog;\n\t}\n\tbpf_link_init(&link->link.link, BPF_LINK_TYPE_TRACING,\n\t\t      &bpf_tracing_link_lops, prog);\n\tlink->attach_type = prog->expected_attach_type;\n\tlink->link.cookie = bpf_cookie;\n\n\tmutex_lock(&prog->aux->dst_mutex);\n\n\t/* There are a few possible cases here:\n\t *\n\t * - if prog->aux->dst_trampoline is set, the program was just loaded\n\t *   and not yet attached to anything, so we can use the values stored\n\t *   in prog->aux\n\t *\n\t * - if prog->aux->dst_trampoline is NULL, the program has already been\n         *   attached to a target and its initial target was cleared (below)\n\t *\n\t * - if tgt_prog != NULL, the caller specified tgt_prog_fd +\n\t *   target_btf_id using the link_create API.\n\t *\n\t * - if tgt_prog == NULL when this function was called using the old\n\t *   raw_tracepoint_open API, and we need a target from prog->aux\n\t *\n\t * - if prog->aux->dst_trampoline and tgt_prog is NULL, the program\n\t *   was detached and is going for re-attachment.\n\t *\n\t * - if prog->aux->dst_trampoline is NULL and tgt_prog and prog->aux->attach_btf\n\t *   are NULL, then program was already attached and user did not provide\n\t *   tgt_prog_fd so we have no way to find out or create trampoline\n\t */\n\tif (!prog->aux->dst_trampoline && !tgt_prog) {\n\t\t/*\n\t\t * Allow re-attach for TRACING and LSM programs. If it's\n\t\t * currently linked, bpf_trampoline_link_prog will fail.\n\t\t * EXT programs need to specify tgt_prog_fd, so they\n\t\t * re-attach in separate code path.\n\t\t */\n\t\tif (prog->type != BPF_PROG_TYPE_TRACING &&\n\t\t    prog->type != BPF_PROG_TYPE_LSM) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/* We can allow re-attach only if we have valid attach_btf. */\n\t\tif (!prog->aux->attach_btf) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tbtf_id = prog->aux->attach_btf_id;\n\t\tkey = bpf_trampoline_compute_key(NULL, prog->aux->attach_btf, btf_id);\n\t}\n\n\tif (!prog->aux->dst_trampoline ||\n\t    (key && key != prog->aux->dst_trampoline->key)) {\n\t\t/* If there is no saved target, or the specified target is\n\t\t * different from the destination specified at load time, we\n\t\t * need a new trampoline and a check for compatibility\n\t\t */\n\t\tstruct bpf_attach_target_info tgt_info = {};\n\n\t\terr = bpf_check_attach_target(NULL, prog, tgt_prog, btf_id,\n\t\t\t\t\t      &tgt_info);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\n\t\tif (tgt_info.tgt_mod) {\n\t\t\tmodule_put(prog->aux->mod);\n\t\t\tprog->aux->mod = tgt_info.tgt_mod;\n\t\t}\n\n\t\ttr = bpf_trampoline_get(key, &tgt_info);\n\t\tif (!tr) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\t/* The caller didn't specify a target, or the target was the\n\t\t * same as the destination supplied during program load. This\n\t\t * means we can reuse the trampoline and reference from program\n\t\t * load time, and there is no need to allocate a new one. This\n\t\t * can only happen once for any program, as the saved values in\n\t\t * prog->aux are cleared below.\n\t\t */\n\t\ttr = prog->aux->dst_trampoline;\n\t\ttgt_prog = prog->aux->dst_prog;\n\t}\n\n\terr = bpf_link_prime(&link->link.link, &link_primer);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = bpf_trampoline_link_prog(&link->link, tr);\n\tif (err) {\n\t\tbpf_link_cleanup(&link_primer);\n\t\tlink = NULL;\n\t\tgoto out_unlock;\n\t}\n\n\tlink->tgt_prog = tgt_prog;\n\tlink->trampoline = tr;\n\n\t/* Always clear the trampoline and target prog from prog->aux to make\n\t * sure the original attach destination is not kept alive after a\n\t * program is (re-)attached to another target.\n\t */\n\tif (prog->aux->dst_prog &&\n\t    (tgt_prog_fd || tr != prog->aux->dst_trampoline))\n\t\t/* got extra prog ref from syscall, or attaching to different prog */\n\t\tbpf_prog_put(prog->aux->dst_prog);\n\tif (prog->aux->dst_trampoline && tr != prog->aux->dst_trampoline)\n\t\t/* we allocated a new trampoline, so free the old one */\n\t\tbpf_trampoline_put(prog->aux->dst_trampoline);\n\n\tprog->aux->dst_prog = NULL;\n\tprog->aux->dst_trampoline = NULL;\n\tmutex_unlock(&prog->aux->dst_mutex);\n\n\treturn bpf_link_settle(&link_primer);\nout_unlock:\n\tif (tr && tr != prog->aux->dst_trampoline)\n\t\tbpf_trampoline_put(tr);\n\tmutex_unlock(&prog->aux->dst_mutex);\n\tkfree(link);\nout_put_prog:\n\tif (tgt_prog_fd && tgt_prog)\n\t\tbpf_prog_put(tgt_prog);\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-26591"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/ufs/core/ufshcd.c",
      "func_name": "ufshcd_abort_one",
      "func_body": "static bool ufshcd_abort_one(struct request *rq, void *priv)\n{\n\tint *ret = priv;\n\tu32 tag = rq->tag;\n\tstruct scsi_cmnd *cmd = blk_mq_rq_to_pdu(rq);\n\tstruct scsi_device *sdev = cmd->device;\n\tstruct Scsi_Host *shost = sdev->host;\n\tstruct ufs_hba *hba = shost_priv(shost);\n\tstruct ufshcd_lrb *lrbp = &hba->lrb[tag];\n\tstruct ufs_hw_queue *hwq;\n\tunsigned long flags;\n\n\t*ret = ufshcd_try_to_abort_task(hba, tag);\n\tdev_err(hba->dev, \"Aborting tag %d / CDB %#02x %s\\n\", tag,\n\t\thba->lrb[tag].cmd ? hba->lrb[tag].cmd->cmnd[0] : -1,\n\t\t*ret ? \"failed\" : \"succeeded\");\n\n\t/* Release cmd in MCQ mode if abort succeeds */\n\tif (is_mcq_enabled(hba) && (*ret == 0)) {\n\t\thwq = ufshcd_mcq_req_to_hwq(hba, scsi_cmd_to_rq(lrbp->cmd));\n\t\tif (!hwq)\n\t\t\treturn 0;\n\t\tspin_lock_irqsave(&hwq->cq_lock, flags);\n\t\tif (ufshcd_cmd_inflight(lrbp->cmd))\n\t\t\tufshcd_release_scsi_cmd(hba, lrbp);\n\t\tspin_unlock_irqrestore(&hwq->cq_lock, flags);\n\t}\n\n\treturn *ret == 0;\n}\n",
      "cve_list": [
        "CVE-2024-41053"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/smb/client/file.c",
      "func_name": "cifs_free_subrequest",
      "func_body": "static void cifs_free_subrequest(struct netfs_io_subrequest *subreq)\n{\n\tstruct cifs_io_subrequest *rdata =\n\t\tcontainer_of(subreq, struct cifs_io_subrequest, subreq);\n\tint rc = subreq->error;\n\n\tif (rdata->subreq.source == NETFS_DOWNLOAD_FROM_SERVER) {\n// #ifdef CONFIG_CIFS_SMB_DIRECT\n\t\tif (rdata->mr) {\n\t\t\tsmbd_deregister_mr(rdata->mr);\n\t\t\trdata->mr = NULL;\n\t\t}\n#endif\n\t}\n\n\tif (rdata->credits.value != 0) {\n\t\ttrace_smb3_rw_credits(rdata->rreq->debug_id,\n\t\t\t\t      rdata->subreq.debug_index,\n\t\t\t\t      rdata->credits.value,\n\t\t\t\t      rdata->server ? rdata->server->credits : 0,\n\t\t\t\t      rdata->server ? rdata->server->in_flight : 0,\n\t\t\t\t      -rdata->credits.value,\n\t\t\t\t      cifs_trace_rw_credits_free_subreq);\n\t\tif (rdata->server)\n\t\t\tadd_credits_and_wake_if(rdata->server, &rdata->credits, 0);\n\t\telse\n\t\t\trdata->credits.value = 0;\n\t}\n\n\tif (rdata->have_xid)\n\t\tfree_xid(rdata->xid);\n}\n",
      "cve_list": [
        "CVE-2024-44992"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/dma/swiotlb.c",
      "func_name": "rmem_swiotlb_device_init",
      "func_body": "static int rmem_swiotlb_device_init(struct reserved_mem *rmem,\n\t\t\t\t    struct device *dev)\n{\n\tstruct io_tlb_mem *mem = rmem->priv;\n\tunsigned long nslabs = rmem->size >> IO_TLB_SHIFT;\n\n\t/* Set Per-device io tlb area to one */\n\tunsigned int nareas = 1;\n\n\tif (PageHighMem(pfn_to_page(PHYS_PFN(rmem->base)))) {\n\t\tdev_err(dev, \"Restricted DMA pool must be accessible within the linear mapping.\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Since multiple devices can share the same pool, the private data,\n\t * io_tlb_mem struct, will be initialized by the first device attached\n\t * to it.\n\t */\n\tif (!mem) {\n\t\tstruct io_tlb_pool *pool;\n\n\t\tmem = kzalloc(sizeof(*mem), GFP_KERNEL);\n\t\tif (!mem)\n\t\t\treturn -ENOMEM;\n\t\tpool = &mem->defpool;\n\n\t\tpool->slots = kcalloc(nslabs, sizeof(*pool->slots), GFP_KERNEL);\n\t\tif (!pool->slots) {\n\t\t\tkfree(mem);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpool->areas = kcalloc(nareas, sizeof(*pool->areas),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!pool->areas) {\n\t\t\tkfree(pool->slots);\n\t\t\tkfree(mem);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tset_memory_decrypted((unsigned long)phys_to_virt(rmem->base),\n\t\t\t\t     rmem->size >> PAGE_SHIFT);\n\t\tswiotlb_init_io_tlb_pool(pool, rmem->base, nslabs,\n\t\t\t\t\t false, nareas);\n\t\tmem->force_bounce = true;\n\t\tmem->for_alloc = true;\n// #ifdef CONFIG_SWIOTLB_DYNAMIC\n\t\tspin_lock_init(&mem->lock);\n\t\tINIT_LIST_HEAD_RCU(&mem->pools);\n#endif\n\t\tadd_mem_pool(mem, pool);\n\n\t\trmem->priv = mem;\n\n\t\tswiotlb_create_debugfs_files(mem, rmem->name);\n\t}\n\n\tdev->dma_io_tlb_mem = mem;\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-36925"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/scsi/qla2xxx/qla_mid.c",
      "func_name": "qla24xx_disable_vp",
      "func_body": "int\nqla24xx_disable_vp(scsi_qla_host_t *vha)\n{\n\tunsigned long flags;\n\tint ret = QLA_SUCCESS;\n\tfc_port_t *fcport;\n\n\tif (vha->hw->flags.edif_enabled) {\n\t\tif (DBELL_ACTIVE(vha))\n\t\t\tqla2x00_post_aen_work(vha, FCH_EVT_VENDOR_UNIQUE,\n\t\t\t    FCH_EVT_VENDOR_UNIQUE_VPORT_DOWN);\n\t\t/* delete sessions and flush sa_indexes */\n\t\tqla2x00_wait_for_sess_deletion(vha);\n\t}\n\n\tif (vha->hw->flags.fw_started)\n\t\tret = qla24xx_control_vp(vha, VCE_COMMAND_DISABLE_VPS_LOGO_ALL);\n\n\tatomic_set(&vha->loop_state, LOOP_DOWN);\n\tatomic_set(&vha->loop_down_timer, LOOP_DOWN_TIME);\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list)\n\t\tfcport->logout_on_delete = 1;\n\n\tif (!vha->hw->flags.edif_enabled)\n\t\tqla2x00_wait_for_sess_deletion(vha);\n\n\t/* Remove port id from vp target map */\n\tspin_lock_irqsave(&vha->hw->hardware_lock, flags);\n\tqla_update_vp_map(vha, RESET_AL_PA);\n\tspin_unlock_irqrestore(&vha->hw->hardware_lock, flags);\n\n\tqla2x00_mark_vp_devices_dead(vha);\n\tatomic_set(&vha->vp_state, VP_FAILED);\n\tvha->flags.management_server_logged_in = 0;\n\tif (ret == QLA_SUCCESS) {\n\t\tfc_vport_set_state(vha->fc_vport, FC_VPORT_DISABLED);\n\t} else {\n\t\tfc_vport_set_state(vha->fc_vport, FC_VPORT_FAILED);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-42289"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "arch/s390/kvm/kvm-s390.c",
      "func_name": "kvm_arch_prepare_memory_region",
      "func_body": "int kvm_arch_prepare_memory_region(struct kvm *kvm,\n\t\t\t\t   const struct kvm_memory_slot *old,\n\t\t\t\t   struct kvm_memory_slot *new,\n\t\t\t\t   enum kvm_mr_change change)\n{\n\tgpa_t size;\n\n\tif (kvm_is_ucontrol(kvm))\n\t\treturn -EINVAL;\n\n\t/* When we are protected, we should not change the memory slots */\n\tif (kvm_s390_pv_get_handle(kvm))\n\t\treturn -EINVAL;\n\n\tif (change != KVM_MR_DELETE && change != KVM_MR_FLAGS_ONLY) {\n\t\t/*\n\t\t * A few sanity checks. We can have memory slots which have to be\n\t\t * located/ended at a segment boundary (1MB). The memory in userland is\n\t\t * ok to be fragmented into various different vmas. It is okay to mmap()\n\t\t * and munmap() stuff in this slot after doing this call at any time\n\t\t */\n\n\t\tif (new->userspace_addr & 0xffffful)\n\t\t\treturn -EINVAL;\n\n\t\tsize = new->npages * PAGE_SIZE;\n\t\tif (size & 0xffffful)\n\t\t\treturn -EINVAL;\n\n\t\tif ((new->base_gfn * PAGE_SIZE) + size > kvm->arch.mem_limit)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!kvm->arch.migration_mode)\n\t\treturn 0;\n\n\t/*\n\t * Turn off migration mode when:\n\t * - userspace creates a new memslot with dirty logging off,\n\t * - userspace modifies an existing memslot (MOVE or FLAGS_ONLY) and\n\t *   dirty logging is turned off.\n\t * Migration mode expects dirty page logging being enabled to store\n\t * its dirty bitmap.\n\t */\n\tif (change != KVM_MR_DELETE &&\n\t    !(new->flags & KVM_MEM_LOG_DIRTY_PAGES))\n\t\tWARN(kvm_s390_vm_stop_migration(kvm),\n\t\t     \"Failed to stop migration mode\");\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-43819"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/media/platform/mediatek/vcodec/decoder/vdec/vdec_h264_req_if.c",
      "func_name": "vdec_h264_slice_decode",
      "func_body": "static int vdec_h264_slice_decode(void *h_vdec, struct mtk_vcodec_mem *bs,\n\t\t\t\t  struct vdec_fb *unused, bool *res_chg)\n{\n\tstruct vdec_h264_slice_inst *inst = h_vdec;\n\tconst struct v4l2_ctrl_h264_decode_params *dec_params =\n\t\tmtk_vdec_h264_get_ctrl_ptr(inst->ctx, V4L2_CID_STATELESS_H264_DECODE_PARAMS);\n\tstruct vdec_vpu_inst *vpu = &inst->vpu;\n\tstruct mtk_video_dec_buf *src_buf_info;\n\tstruct mtk_video_dec_buf *dst_buf_info;\n\tstruct vdec_fb *fb;\n\tu32 data[2];\n\tu64 y_fb_dma;\n\tu64 c_fb_dma;\n\tint err;\n\n\tinst->num_nalu++;\n\t/* bs NULL means flush decoder */\n\tif (!bs)\n\t\treturn vpu_dec_reset(vpu);\n\n\tfb = inst->ctx->dev->vdec_pdata->get_cap_buffer(inst->ctx);\n\tif (!fb) {\n\t\tmtk_vdec_err(inst->ctx, \"fb buffer is NULL\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsrc_buf_info = container_of(bs, struct mtk_video_dec_buf, bs_buffer);\n\tdst_buf_info = container_of(fb, struct mtk_video_dec_buf, frame_buffer);\n\n\ty_fb_dma = fb->base_y.dma_addr;\n\tc_fb_dma = fb->base_c.dma_addr;\n\n\tmtk_vdec_debug(inst->ctx, \"+ [%d] FB y_dma=%llx c_dma=%llx va=%p\",\n\t\t       inst->num_nalu, y_fb_dma, c_fb_dma, fb);\n\n\tinst->vsi_ctx.dec.bs_dma = (uint64_t)bs->dma_addr;\n\tinst->vsi_ctx.dec.y_fb_dma = y_fb_dma;\n\tinst->vsi_ctx.dec.c_fb_dma = c_fb_dma;\n\tinst->vsi_ctx.dec.vdec_fb_va = (u64)(uintptr_t)fb;\n\n\tv4l2_m2m_buf_copy_metadata(&src_buf_info->m2m_buf.vb,\n\t\t\t\t   &dst_buf_info->m2m_buf.vb, true);\n\terr = get_vdec_decode_parameters(inst);\n\tif (err)\n\t\tgoto err_free_fb_out;\n\n\tdata[0] = bs->size;\n\t/*\n\t * Reconstruct the first byte of the NAL unit, as the firmware requests\n\t * that information to be passed even though it is present in the stream\n\t * itself...\n\t */\n\tdata[1] = (dec_params->nal_ref_idc << 5) |\n\t\t  ((dec_params->flags & V4L2_H264_DECODE_PARAM_FLAG_IDR_PIC)\n\t\t\t? 0x5 : 0x1);\n\n\t*res_chg = inst->vsi_ctx.dec.resolution_changed;\n\tif (*res_chg) {\n\t\tmtk_vdec_debug(inst->ctx, \"- resolution changed -\");\n\t\tif (inst->vsi_ctx.dec.realloc_mv_buf) {\n\t\t\terr = alloc_mv_buf(inst, &inst->ctx->picinfo);\n\t\t\tinst->vsi_ctx.dec.realloc_mv_buf = false;\n\t\t\tif (err)\n\t\t\t\tgoto err_free_fb_out;\n\t\t}\n\t\t*res_chg = false;\n\t}\n\n\tmemcpy(inst->vpu.vsi, &inst->vsi_ctx, sizeof(inst->vsi_ctx));\n\terr = vpu_dec_start(vpu, data, 2);\n\tif (err)\n\t\tgoto err_free_fb_out;\n\n\t/* wait decoder done interrupt */\n\terr = mtk_vcodec_wait_for_done_ctx(inst->ctx,\n\t\t\t\t\t   MTK_INST_IRQ_RECEIVED,\n\t\t\t\t\t   WAIT_INTR_TIMEOUT_MS, 0);\n\tif (err)\n\t\tgoto err_free_fb_out;\n\tvpu_dec_end(vpu);\n\n\tmemcpy(&inst->vsi_ctx, inst->vpu.vsi, sizeof(inst->vsi_ctx));\n\tmtk_vdec_debug(inst->ctx, \"\\n - NALU[%d]\", inst->num_nalu);\n\treturn 0;\n\nerr_free_fb_out:\n\tmtk_vdec_err(inst->ctx, \"\\n - NALU[%d] err=%d -\\n\", inst->num_nalu, err);\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-47752"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/ssb/main.c",
      "func_name": "ssb_device_uevent",
      "func_body": "static int ssb_device_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct ssb_device *ssb_dev;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tssb_dev = dev_to_ssb_dev(dev);\n\n\treturn add_uevent_var(env,\n\t\t\t     \"MODALIAS=ssb:v%04Xid%04Xrev%02X\",\n\t\t\t     ssb_dev->id.vendor, ssb_dev->id.coreid,\n\t\t\t     ssb_dev->id.revision);\n}\n",
      "cve_list": [
        "CVE-2024-40982"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/smb/server/smb2pdu.c",
      "func_name": "smb2_sess_setup",
      "func_body": "int smb2_sess_setup(struct ksmbd_work *work)\n{\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct smb2_sess_setup_req *req;\n\tstruct smb2_sess_setup_rsp *rsp;\n\tstruct ksmbd_session *sess;\n\tstruct negotiate_message *negblob;\n\tunsigned int negblob_len, negblob_off;\n\tint rc = 0;\n\n\tksmbd_debug(SMB, \"Received request for session setup\\n\");\n\n\tWORK_BUFFERS(work, req, rsp);\n\n\trsp->StructureSize = cpu_to_le16(9);\n\trsp->SessionFlags = 0;\n\trsp->SecurityBufferOffset = cpu_to_le16(72);\n\trsp->SecurityBufferLength = 0;\n\n\tksmbd_conn_lock(conn);\n\tif (!req->hdr.SessionId) {\n\t\tsess = ksmbd_smb2_session_create();\n\t\tif (!sess) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\t\trsp->hdr.SessionId = cpu_to_le64(sess->id);\n\t\trc = ksmbd_session_register(conn, sess);\n\t\tif (rc)\n\t\t\tgoto out_err;\n\n\t\tconn->binding = false;\n\t} else if (conn->dialect >= SMB30_PROT_ID &&\n\t\t   (server_conf.flags & KSMBD_GLOBAL_FLAG_SMB3_MULTICHANNEL) &&\n\t\t   req->Flags & SMB2_SESSION_REQ_FLAG_BINDING) {\n\t\tu64 sess_id = le64_to_cpu(req->hdr.SessionId);\n\n\t\tsess = ksmbd_session_lookup_slowpath(sess_id);\n\t\tif (!sess) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (conn->dialect != sess->dialect) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (!(req->hdr.Flags & SMB2_FLAGS_SIGNED)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (strncmp(conn->ClientGUID, sess->ClientGUID,\n\t\t\t    SMB2_CLIENT_GUID_SIZE)) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (sess->state == SMB2_SESSION_IN_PROGRESS) {\n\t\t\trc = -EACCES;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (sess->state == SMB2_SESSION_EXPIRED) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (ksmbd_conn_need_reconnect(conn)) {\n\t\t\trc = -EFAULT;\n\t\t\tsess = NULL;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (ksmbd_session_lookup(conn, sess_id)) {\n\t\t\trc = -EACCES;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (user_guest(sess->user)) {\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tconn->binding = true;\n\t} else if ((conn->dialect < SMB30_PROT_ID ||\n\t\t    server_conf.flags & KSMBD_GLOBAL_FLAG_SMB3_MULTICHANNEL) &&\n\t\t   (req->Flags & SMB2_SESSION_REQ_FLAG_BINDING)) {\n\t\tsess = NULL;\n\t\trc = -EACCES;\n\t\tgoto out_err;\n\t} else {\n\t\tsess = ksmbd_session_lookup(conn,\n\t\t\t\t\t    le64_to_cpu(req->hdr.SessionId));\n\t\tif (!sess) {\n\t\t\trc = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (sess->state == SMB2_SESSION_EXPIRED) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (ksmbd_conn_need_reconnect(conn)) {\n\t\t\trc = -EFAULT;\n\t\t\tsess = NULL;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tconn->binding = false;\n\t}\n\twork->sess = sess;\n\n\tnegblob_off = le16_to_cpu(req->SecurityBufferOffset);\n\tnegblob_len = le16_to_cpu(req->SecurityBufferLength);\n\tif (negblob_off < offsetof(struct smb2_sess_setup_req, Buffer)) {\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tnegblob = (struct negotiate_message *)((char *)&req->hdr.ProtocolId +\n\t\t\tnegblob_off);\n\n\tif (decode_negotiation_token(conn, negblob, negblob_len) == 0) {\n\t\tif (conn->mechToken) {\n\t\t\tnegblob = (struct negotiate_message *)conn->mechToken;\n\t\t\tnegblob_len = conn->mechTokenLen;\n\t\t}\n\t}\n\n\tif (negblob_len < offsetof(struct negotiate_message, NegotiateFlags)) {\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tif (server_conf.auth_mechs & conn->auth_mechs) {\n\t\trc = generate_preauth_hash(work);\n\t\tif (rc)\n\t\t\tgoto out_err;\n\n\t\tif (conn->preferred_auth_mech &\n\t\t\t\t(KSMBD_AUTH_KRB5 | KSMBD_AUTH_MSKRB5)) {\n\t\t\trc = krb5_authenticate(work, req, rsp);\n\t\t\tif (rc) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\tif (!ksmbd_conn_need_reconnect(conn)) {\n\t\t\t\tksmbd_conn_set_good(conn);\n\t\t\t\tsess->state = SMB2_SESSION_VALID;\n\t\t\t}\n\t\t\tkfree(sess->Preauth_HashValue);\n\t\t\tsess->Preauth_HashValue = NULL;\n\t\t} else if (conn->preferred_auth_mech == KSMBD_AUTH_NTLMSSP) {\n\t\t\tif (negblob->MessageType == NtLmNegotiate) {\n\t\t\t\trc = ntlm_negotiate(work, negblob, negblob_len, rsp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out_err;\n\t\t\t\trsp->hdr.Status =\n\t\t\t\t\tSTATUS_MORE_PROCESSING_REQUIRED;\n\t\t\t} else if (negblob->MessageType == NtLmAuthenticate) {\n\t\t\t\trc = ntlm_authenticate(work, req, rsp);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out_err;\n\n\t\t\t\tif (!ksmbd_conn_need_reconnect(conn)) {\n\t\t\t\t\tksmbd_conn_set_good(conn);\n\t\t\t\t\tsess->state = SMB2_SESSION_VALID;\n\t\t\t\t}\n\t\t\t\tif (conn->binding) {\n\t\t\t\t\tstruct preauth_session *preauth_sess;\n\n\t\t\t\t\tpreauth_sess =\n\t\t\t\t\t\tksmbd_preauth_session_lookup(conn, sess->id);\n\t\t\t\t\tif (preauth_sess) {\n\t\t\t\t\t\tlist_del(&preauth_sess->preauth_entry);\n\t\t\t\t\t\tkfree(preauth_sess);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tkfree(sess->Preauth_HashValue);\n\t\t\t\tsess->Preauth_HashValue = NULL;\n\t\t\t} else {\n\t\t\t\tpr_info_ratelimited(\"Unknown NTLMSSP message type : 0x%x\\n\",\n\t\t\t\t\t\tle32_to_cpu(negblob->MessageType));\n\t\t\t\trc = -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\t/* TODO: need one more negotiation */\n\t\t\tpr_err(\"Not support the preferred authentication\\n\");\n\t\t\trc = -EINVAL;\n\t\t}\n\t} else {\n\t\tpr_err(\"Not support authentication\\n\");\n\t\trc = -EINVAL;\n\t}\n\nout_err:\n\tif (rc == -EINVAL)\n\t\trsp->hdr.Status = STATUS_INVALID_PARAMETER;\n\telse if (rc == -ENOENT)\n\t\trsp->hdr.Status = STATUS_USER_SESSION_DELETED;\n\telse if (rc == -EACCES)\n\t\trsp->hdr.Status = STATUS_REQUEST_NOT_ACCEPTED;\n\telse if (rc == -EFAULT)\n\t\trsp->hdr.Status = STATUS_NETWORK_SESSION_EXPIRED;\n\telse if (rc == -ENOMEM)\n\t\trsp->hdr.Status = STATUS_INSUFFICIENT_RESOURCES;\n\telse if (rc == -EOPNOTSUPP)\n\t\trsp->hdr.Status = STATUS_NOT_SUPPORTED;\n\telse if (rc)\n\t\trsp->hdr.Status = STATUS_LOGON_FAILURE;\n\n\tif (conn->use_spnego && conn->mechToken) {\n\t\tkfree(conn->mechToken);\n\t\tconn->mechToken = NULL;\n\t}\n\n\tif (rc < 0) {\n\t\t/*\n\t\t * SecurityBufferOffset should be set to zero\n\t\t * in session setup error response.\n\t\t */\n\t\trsp->SecurityBufferOffset = 0;\n\n\t\tif (sess) {\n\t\t\tbool try_delay = false;\n\n\t\t\t/*\n\t\t\t * To avoid dictionary attacks (repeated session setups rapidly sent) to\n\t\t\t * connect to server, ksmbd make a delay of a 5 seconds on session setup\n\t\t\t * failure to make it harder to send enough random connection requests\n\t\t\t * to break into a server.\n\t\t\t */\n\t\t\tif (sess->user && sess->user->flags & KSMBD_USER_FLAG_DELAY_SESSION)\n\t\t\t\ttry_delay = true;\n\n\t\t\tsess->last_active = jiffies;\n\t\t\tsess->state = SMB2_SESSION_EXPIRED;\n\t\t\tif (try_delay) {\n\t\t\t\tksmbd_conn_set_need_reconnect(conn);\n\t\t\t\tssleep(5);\n\t\t\t\tksmbd_conn_set_need_negotiate(conn);\n\t\t\t}\n\t\t}\n\t\tsmb2_set_err_rsp(work);\n\t} else {\n\t\tunsigned int iov_len;\n\n\t\tif (rsp->SecurityBufferLength)\n\t\t\tiov_len = offsetof(struct smb2_sess_setup_rsp, Buffer) +\n\t\t\t\tle16_to_cpu(rsp->SecurityBufferLength);\n\t\telse\n\t\t\tiov_len = sizeof(struct smb2_sess_setup_rsp);\n\t\trc = ksmbd_iov_pin_rsp(work, rsp, iov_len);\n\t\tif (rc)\n\t\t\trsp->hdr.Status = STATUS_INSUFFICIENT_RESOURCES;\n\t}\n\n\tksmbd_conn_unlock(conn);\n\treturn rc;\n}\n",
      "cve_list": [
        "CVE-2024-46795"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/qxl/qxl_display.c",
      "func_name": "qxl_add_mode",
      "func_body": "static int qxl_add_mode(struct drm_connector *connector,\n\t\t\tunsigned int width,\n\t\t\tunsigned int height,\n\t\t\tbool preferred)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct qxl_device *qdev = to_qxl(dev);\n\tstruct drm_display_mode *mode = NULL;\n\tint rc;\n\n\trc = qxl_check_mode(qdev, width, height);\n\tif (rc != 0)\n\t\treturn 0;\n\n\tmode = drm_cvt_mode(dev, width, height, 60, false, false, false);\n\tif (!mode)\n\t\treturn 0;\n\n\tif (preferred)\n\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\tmode->hdisplay = width;\n\tmode->vdisplay = height;\n\tdrm_mode_set_name(mode);\n\tdrm_mode_probed_add(connector, mode);\n\treturn 1;\n}\n",
      "cve_list": [
        "CVE-2024-43829"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/char/tpm/tpm2-sessions.c",
      "func_name": "tpm_buf_check_hmac_response",
      "func_body": "int tpm_buf_check_hmac_response(struct tpm_chip *chip, struct tpm_buf *buf,\n\t\t\t\tint rc)\n{\n\tstruct tpm_header *head = (struct tpm_header *)buf->data;\n\tstruct tpm2_auth *auth = chip->auth;\n\toff_t offset_s, offset_p;\n\tu8 rphash[SHA256_DIGEST_SIZE];\n\tu32 attrs, cc;\n\tstruct sha256_state sctx;\n\tu16 tag = be16_to_cpu(head->tag);\n\tint parm_len, len, i, handles;\n\n\tif (!auth)\n\t\treturn rc;\n\n\tcc = be32_to_cpu(auth->ordinal);\n\n\tif (auth->session >= TPM_HEADER_SIZE) {\n\t\tWARN(1, \"tpm session not filled correctly\\n\");\n\t\tgoto out;\n\t}\n\n\tif (rc != 0)\n\t\t/* pass non success rc through and close the session */\n\t\tgoto out;\n\n\trc = -EINVAL;\n\tif (tag != TPM2_ST_SESSIONS) {\n\t\tdev_err(&chip->dev, \"TPM: HMAC response check has no sessions tag\\n\");\n\t\tgoto out;\n\t}\n\n\ti = tpm2_find_cc(chip, cc);\n\tif (i < 0)\n\t\tgoto out;\n\tattrs = chip->cc_attrs_tbl[i];\n\thandles = (attrs >> TPM2_CC_ATTR_RHANDLE) & 1;\n\n\t/* point to area beyond handles */\n\toffset_s = TPM_HEADER_SIZE + handles * 4;\n\tparm_len = tpm_buf_read_u32(buf, &offset_s);\n\toffset_p = offset_s;\n\toffset_s += parm_len;\n\t/* skip over any sessions before ours */\n\tfor (i = 0; i < auth->session - 1; i++) {\n\t\tlen = tpm_buf_read_u16(buf, &offset_s);\n\t\toffset_s += len + 1;\n\t\tlen = tpm_buf_read_u16(buf, &offset_s);\n\t\toffset_s += len;\n\t}\n\t/* TPM nonce */\n\tlen = tpm_buf_read_u16(buf, &offset_s);\n\tif (offset_s + len > tpm_buf_length(buf))\n\t\tgoto out;\n\tif (len != SHA256_DIGEST_SIZE)\n\t\tgoto out;\n\tmemcpy(auth->tpm_nonce, &buf->data[offset_s], len);\n\toffset_s += len;\n\tattrs = tpm_buf_read_u8(buf, &offset_s);\n\tlen = tpm_buf_read_u16(buf, &offset_s);\n\tif (offset_s + len != tpm_buf_length(buf))\n\t\tgoto out;\n\tif (len != SHA256_DIGEST_SIZE)\n\t\tgoto out;\n\t/*\n\t * offset_s points to the HMAC. now calculate comparison, beginning\n\t * with rphash\n\t */\n\tsha256_init(&sctx);\n\t/* yes, I know this is now zero, but it's what the standard says */\n\tsha256_update(&sctx, (u8 *)&head->return_code,\n\t\t      sizeof(head->return_code));\n\t/* ordinal is already BE */\n\tsha256_update(&sctx, (u8 *)&auth->ordinal, sizeof(auth->ordinal));\n\tsha256_update(&sctx, &buf->data[offset_p], parm_len);\n\tsha256_final(&sctx, rphash);\n\n\t/* now calculate the hmac */\n\ttpm2_hmac_init(&sctx, auth->session_key, sizeof(auth->session_key)\n\t\t       + auth->passphrase_len);\n\tsha256_update(&sctx, rphash, sizeof(rphash));\n\tsha256_update(&sctx, auth->tpm_nonce, sizeof(auth->tpm_nonce));\n\tsha256_update(&sctx, auth->our_nonce, sizeof(auth->our_nonce));\n\tsha256_update(&sctx, &auth->attrs, 1);\n\t/* we're done with the rphash, so put our idea of the hmac there */\n\ttpm2_hmac_final(&sctx, auth->session_key, sizeof(auth->session_key)\n\t\t\t+ auth->passphrase_len, rphash);\n\tif (memcmp(rphash, &buf->data[offset_s], SHA256_DIGEST_SIZE) == 0) {\n\t\trc = 0;\n\t} else {\n\t\tdev_err(&chip->dev, \"TPM: HMAC check failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* now do response decryption */\n\tif (auth->attrs & TPM2_SA_ENCRYPT) {\n\t\t/* need key and IV */\n\t\ttpm2_KDFa(auth->session_key, SHA256_DIGEST_SIZE\n\t\t\t  + auth->passphrase_len, \"CFB\", auth->tpm_nonce,\n\t\t\t  auth->our_nonce, AES_KEY_BYTES + AES_BLOCK_SIZE,\n\t\t\t  auth->scratch);\n\n\t\tlen = tpm_buf_read_u16(buf, &offset_p);\n\t\taes_expandkey(&auth->aes_ctx, auth->scratch, AES_KEY_BYTES);\n\t\taescfb_decrypt(&auth->aes_ctx, &buf->data[offset_p],\n\t\t\t       &buf->data[offset_p], len,\n\t\t\t       auth->scratch + AES_KEY_BYTES);\n\t}\n\n out:\n\tif ((auth->attrs & TPM2_SA_CONTINUE_SESSION) == 0) {\n\t\tif (rc)\n\t\t\t/* manually close the session if it wasn't consumed */\n\t\t\ttpm2_flush_context(chip, auth->handle);\n\t\tmemzero_explicit(auth, sizeof(*auth));\n\t} else {\n\t\t/* reset for next use  */\n\t\tauth->session = TPM_HEADER_SIZE;\n\t}\n\n\treturn rc;\n}\n",
      "cve_list": [
        "CVE-2024-42255"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ipv4/fou_core.c",
      "func_name": "fou_from_sock",
      "func_body": "static inline struct fou *fou_from_sock(struct sock *sk)\n{\n\treturn rcu_dereference_sk_user_data(sk);\n}\n",
      "cve_list": [
        "CVE-2024-46763"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ipv4/fou_core.c",
      "func_name": "fou_gro_receive",
      "func_body": "static struct sk_buff *fou_gro_receive(struct sock *sk,\n\t\t\t\t       struct list_head *head,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tconst struct net_offload __rcu **offloads;\n\tstruct fou *fou = fou_from_sock(sk);\n\tconst struct net_offload *ops;\n\tstruct sk_buff *pp = NULL;\n\tu8 proto;\n\n\tif (!fou)\n\t\tgoto out;\n\n\tproto = fou->protocol;\n\n\t/* We can clear the encap_mark for FOU as we are essentially doing\n\t * one of two possible things.  We are either adding an L4 tunnel\n\t * header to the outer L3 tunnel header, or we are simply\n\t * treating the GRE tunnel header as though it is a UDP protocol\n\t * specific header such as VXLAN or GENEVE.\n\t */\n\tNAPI_GRO_CB(skb)->encap_mark = 0;\n\n\t/* Flag this frame as already having an outer encap header */\n\tNAPI_GRO_CB(skb)->is_fou = 1;\n\n\toffloads = NAPI_GRO_CB(skb)->is_ipv6 ? inet6_offloads : inet_offloads;\n\tops = rcu_dereference(offloads[proto]);\n\tif (!ops || !ops->callbacks.gro_receive)\n\t\tgoto out;\n\n\tpp = call_gro_receive(ops->callbacks.gro_receive, head, skb);\n\nout:\n\treturn pp;\n}\n",
      "cve_list": [
        "CVE-2024-46763"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/nouveau/nouveau_connector.c",
      "func_name": "nouveau_connector_get_modes",
      "func_body": "static int\nnouveau_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_connector *nv_connector = nouveau_connector(connector);\n\tstruct nouveau_encoder *nv_encoder = nv_connector->detected_encoder;\n\tstruct drm_encoder *encoder = to_drm_encoder(nv_encoder);\n\tint ret = 0;\n\n\t/* destroy the native mode, the attached monitor could have changed.\n\t */\n\tif (nv_connector->native_mode) {\n\t\tdrm_mode_destroy(dev, nv_connector->native_mode);\n\t\tnv_connector->native_mode = NULL;\n\t}\n\n\tif (nv_connector->edid)\n\t\tret = drm_add_edid_modes(connector, nv_connector->edid);\n\telse\n\tif (nv_encoder->dcb->type == DCB_OUTPUT_LVDS &&\n\t    (nv_encoder->dcb->lvdsconf.use_straps_for_mode ||\n\t     drm->vbios.fp_no_ddc) && nouveau_bios_fp_mode(dev, NULL)) {\n\t\tstruct drm_display_mode mode;\n\n\t\tnouveau_bios_fp_mode(dev, &mode);\n\t\tnv_connector->native_mode = drm_mode_duplicate(dev, &mode);\n\t}\n\n\t/* Determine display colour depth for everything except LVDS now,\n\t * DP requires this before mode_valid() is called.\n\t */\n\tif (connector->connector_type != DRM_MODE_CONNECTOR_LVDS)\n\t\tnouveau_connector_detect_depth(connector);\n\n\t/* Find the native mode if this is a digital panel, if we didn't\n\t * find any modes through DDC previously add the native mode to\n\t * the list of modes.\n\t */\n\tif (!nv_connector->native_mode)\n\t\tnv_connector->native_mode = nouveau_conn_native_mode(connector);\n\tif (ret == 0 && nv_connector->native_mode) {\n\t\tstruct drm_display_mode *mode;\n\n\t\tmode = drm_mode_duplicate(dev, nv_connector->native_mode);\n\t\tif (!mode)\n\t\t\treturn 0;\n\n\t\tdrm_mode_probed_add(connector, mode);\n\t\tret = 1;\n\t}\n\n\t/* Determine LVDS colour depth, must happen after determining\n\t * \"native\" mode as some VBIOS tables require us to use the\n\t * pixel clock as part of the lookup...\n\t */\n\tif (connector->connector_type == DRM_MODE_CONNECTOR_LVDS && nv_connector->native_mode)\n\t\tnouveau_connector_detect_depth(connector);\n\n\tif (nv_encoder->dcb->type == DCB_OUTPUT_TV)\n\t\tret = get_slave_funcs(encoder)->get_modes(encoder, connector);\n\n\tif (nv_connector->type == DCB_CONNECTOR_LVDS ||\n\t    nv_connector->type == DCB_CONNECTOR_LVDS_SPWG ||\n\t    nv_connector->type == DCB_CONNECTOR_eDP)\n\t\tret += nouveau_connector_scaler_modes_add(connector);\n\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-42101"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/cxl/core/pmem.c",
      "func_name": "cxl_find_nvdimm_bridge",
      "func_body": "struct cxl_nvdimm_bridge *cxl_find_nvdimm_bridge(struct cxl_port *port)\n{\n\tstruct cxl_root *cxl_root __free(put_cxl_root) = find_cxl_root(port);\n\tstruct device *dev;\n\n\tif (!cxl_root)\n\t\treturn NULL;\n\n\tdev = device_find_child(&cxl_root->port.dev, NULL, match_nvdimm_bridge);\n\n\tif (!dev)\n\t\treturn NULL;\n\n\treturn to_cxl_nvdimm_bridge(dev);\n}\n",
      "cve_list": [
        "CVE-2024-41085"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/cxl/core/region.c",
      "func_name": "cxl_pmem_region_alloc",
      "func_body": "static int cxl_pmem_region_alloc(struct cxl_region *cxlr)\n{\n\tstruct cxl_region_params *p = &cxlr->params;\n\tstruct cxl_nvdimm_bridge *cxl_nvb;\n\tstruct device *dev;\n\tint i;\n\n\tguard(rwsem_read)(&cxl_region_rwsem);\n\tif (p->state != CXL_CONFIG_COMMIT)\n\t\treturn -ENXIO;\n\n\tstruct cxl_pmem_region *cxlr_pmem __free(kfree) =\n\t\tkzalloc(struct_size(cxlr_pmem, mapping, p->nr_targets), GFP_KERNEL);\n\tif (!cxlr_pmem)\n\t\treturn -ENOMEM;\n\n\tcxlr_pmem->hpa_range.start = p->res->start;\n\tcxlr_pmem->hpa_range.end = p->res->end;\n\n\t/* Snapshot the region configuration underneath the cxl_region_rwsem */\n\tcxlr_pmem->nr_mappings = p->nr_targets;\n\tfor (i = 0; i < p->nr_targets; i++) {\n\t\tstruct cxl_endpoint_decoder *cxled = p->targets[i];\n\t\tstruct cxl_memdev *cxlmd = cxled_to_memdev(cxled);\n\t\tstruct cxl_pmem_region_mapping *m = &cxlr_pmem->mapping[i];\n\n\t\t/*\n\t\t * Regions never span CXL root devices, so by definition the\n\t\t * bridge for one device is the same for all.\n\t\t */\n\t\tif (i == 0) {\n\t\t\tcxl_nvb = cxl_find_nvdimm_bridge(cxlmd->endpoint);\n\t\t\tif (!cxl_nvb)\n\t\t\t\treturn -ENODEV;\n\t\t\tcxlr->cxl_nvb = cxl_nvb;\n\t\t}\n\t\tm->cxlmd = cxlmd;\n\t\tget_device(&cxlmd->dev);\n\t\tm->start = cxled->dpa_res->start;\n\t\tm->size = resource_size(cxled->dpa_res);\n\t\tm->position = i;\n\t}\n\n\tdev = &cxlr_pmem->dev;\n\tdevice_initialize(dev);\n\tlockdep_set_class(&dev->mutex, &cxl_pmem_region_key);\n\tdevice_set_pm_not_required(dev);\n\tdev->parent = &cxlr->dev;\n\tdev->bus = &cxl_bus_type;\n\tdev->type = &cxl_pmem_region_type;\n\tcxlr_pmem->cxlr = cxlr;\n\tcxlr->cxlr_pmem = no_free_ptr(cxlr_pmem);\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-41085"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/cxl/mem.c",
      "func_name": "cxl_mem_probe",
      "func_body": "static int cxl_mem_probe(struct device *dev)\n{\n\tstruct cxl_memdev *cxlmd = to_cxl_memdev(dev);\n\tstruct cxl_memdev_state *mds = to_cxl_memdev_state(cxlmd->cxlds);\n\tstruct cxl_dev_state *cxlds = cxlmd->cxlds;\n\tstruct device *endpoint_parent;\n\tstruct cxl_port *parent_port;\n\tstruct cxl_dport *dport;\n\tstruct dentry *dentry;\n\tint rc;\n\n\tif (!cxlds->media_ready)\n\t\treturn -EBUSY;\n\n\t/*\n\t * Someone is trying to reattach this device after it lost its port\n\t * connection (an endpoint port previously registered by this memdev was\n\t * disabled). This racy check is ok because if the port is still gone,\n\t * no harm done, and if the port hierarchy comes back it will re-trigger\n\t * this probe. Port rescan and memdev detach work share the same\n\t * single-threaded workqueue.\n\t */\n\tif (work_pending(&cxlmd->detach_work))\n\t\treturn -EBUSY;\n\n\tdentry = cxl_debugfs_create_dir(dev_name(dev));\n\tdebugfs_create_devm_seqfile(dev, \"dpamem\", dentry, cxl_mem_dpa_show);\n\n\tif (test_bit(CXL_POISON_ENABLED_INJECT, mds->poison.enabled_cmds))\n\t\tdebugfs_create_file(\"inject_poison\", 0200, dentry, cxlmd,\n\t\t\t\t    &cxl_poison_inject_fops);\n\tif (test_bit(CXL_POISON_ENABLED_CLEAR, mds->poison.enabled_cmds))\n\t\tdebugfs_create_file(\"clear_poison\", 0200, dentry, cxlmd,\n\t\t\t\t    &cxl_poison_clear_fops);\n\n\trc = devm_add_action_or_reset(dev, remove_debugfs, dentry);\n\tif (rc)\n\t\treturn rc;\n\n\trc = devm_cxl_enumerate_ports(cxlmd);\n\tif (rc)\n\t\treturn rc;\n\n\tparent_port = cxl_mem_find_port(cxlmd, &dport);\n\tif (!parent_port) {\n\t\tdev_err(dev, \"CXL port topology not found\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (resource_size(&cxlds->pmem_res) && IS_ENABLED(CONFIG_CXL_PMEM)) {\n\t\trc = devm_cxl_add_nvdimm(parent_port, cxlmd);\n\t\tif (rc) {\n\t\t\tif (rc == -ENODEV)\n\t\t\t\tdev_info(dev, \"PMEM disabled by platform\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif (dport->rch)\n\t\tendpoint_parent = parent_port->uport_dev;\n\telse\n\t\tendpoint_parent = &parent_port->dev;\n\n\tcxl_setup_parent_dport(dev, dport);\n\n\tdevice_lock(endpoint_parent);\n\tif (!endpoint_parent->driver) {\n\t\tdev_err(dev, \"CXL port topology %s not enabled\\n\",\n\t\t\tdev_name(endpoint_parent));\n\t\trc = -ENXIO;\n\t\tgoto unlock;\n\t}\n\n\trc = devm_cxl_add_endpoint(endpoint_parent, cxlmd, dport);\nunlock:\n\tdevice_unlock(endpoint_parent);\n\tput_device(&parent_port->dev);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * The kernel may be operating out of CXL memory on this device,\n\t * there is no spec defined way to determine whether this device\n\t * preserves contents over suspend, and there is no simple way\n\t * to arrange for the suspend image to avoid CXL memory which\n\t * would setup a circular dependency between PCI resume and save\n\t * state restoration.\n\t *\n\t * TODO: support suspend when all the regions this device is\n\t * hosting are locked and covered by the system address map,\n\t * i.e. platform firmware owns restoring the HDM configuration\n\t * that it locked.\n\t */\n\tcxl_mem_active_inc();\n\treturn devm_add_action_or_reset(dev, enable_suspend, NULL);\n}\n",
      "cve_list": [
        "CVE-2024-41085"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/dc/core/dc_resource.c",
      "func_name": "resource_log_pipe_topology_update",
      "func_body": "void resource_log_pipe_topology_update(struct dc *dc, struct dc_state *state)\n{\n\tstruct pipe_ctx *otg_master;\n\tint stream_idx, phantom_stream_idx;\n\tDC_LOGGER_INIT(dc->ctx->logger);\n\n\tDC_LOG_DC(\"    pipe topology update\");\n\tDC_LOG_DC(\"  ________________________\");\n\tfor (stream_idx = 0; stream_idx < state->stream_count; stream_idx++) {\n\t\tif (state->streams[stream_idx]->is_phantom)\n\t\t\tcontinue;\n\n\t\totg_master = resource_get_otg_master_for_stream(\n\t\t\t\t&state->res_ctx, state->streams[stream_idx]);\n\n\t\tif (!otg_master)\n\t\t\tcontinue;\n\n\t\tresource_log_pipe_for_stream(dc, state, otg_master, stream_idx);\n\t}\n\tif (state->phantom_stream_count > 0) {\n\t\tDC_LOG_DC(\" |    (phantom pipes)     |\");\n\t\tfor (stream_idx = 0; stream_idx < state->stream_count; stream_idx++) {\n\t\t\tif (state->stream_status[stream_idx].mall_stream_config.type != SUBVP_MAIN)\n\t\t\t\tcontinue;\n\n\t\t\tphantom_stream_idx = resource_stream_to_stream_idx(state,\n\t\t\t\t\tstate->stream_status[stream_idx].mall_stream_config.paired_stream);\n\t\t\totg_master = resource_get_otg_master_for_stream(\n\t\t\t\t\t&state->res_ctx, state->streams[phantom_stream_idx]);\n\t\t\tif (!otg_master)\n\t\t\t\tcontinue;\n\n\t\t\tresource_log_pipe_for_stream(dc, state, otg_master, stream_idx);\n\t\t}\n\t}\n\tDC_LOG_DC(\" |________________________|\\n\");\n}\n",
      "cve_list": [
        "CVE-2024-46727"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/s390/block/dasd_devmap.c",
      "func_name": "dasd_copy_pair_store",
      "func_body": "static ssize_t dasd_copy_pair_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct dasd_devmap *prim_devmap, *sec_devmap;\n\tchar prim_busid[DASD_BUS_ID_SIZE];\n\tchar sec_busid[DASD_BUS_ID_SIZE];\n\tstruct dasd_copy_relation *copy;\n\tstruct dasd_device *device;\n\tbool pprc_enabled;\n\tint rc;\n\n\tif (strncmp(buf, \"clear\", strlen(\"clear\")) == 0) {\n\t\tif (dasd_devmap_clear_copy_relation(dev))\n\t\t\treturn -EINVAL;\n\t\treturn count;\n\t}\n\n\trc = dasd_devmap_parse_busid(buf, prim_busid, sec_busid);\n\tif (rc)\n\t\treturn rc;\n\n\tif (strncmp(dev_name(dev), prim_busid, DASD_BUS_ID_SIZE) != 0 &&\n\t    strncmp(dev_name(dev), sec_busid, DASD_BUS_ID_SIZE) != 0)\n\t\treturn -EINVAL;\n\n\t/* allocate primary devmap if needed */\n\tprim_devmap = dasd_find_busid(prim_busid);\n\tif (IS_ERR(prim_devmap)) {\n\t\tprim_devmap = dasd_add_busid(prim_busid, DASD_FEATURE_DEFAULT);\n\t\tif (IS_ERR(prim_devmap))\n\t\t\treturn PTR_ERR(prim_devmap);\n\t}\n\n\t/* allocate secondary devmap if needed */\n\tsec_devmap = dasd_find_busid(sec_busid);\n\tif (IS_ERR(sec_devmap)) {\n\t\tsec_devmap = dasd_add_busid(sec_busid, DASD_FEATURE_DEFAULT);\n\t\tif (IS_ERR(sec_devmap))\n\t\t\treturn PTR_ERR(sec_devmap);\n\t}\n\n\t/* setting copy relation is only allowed for offline secondary */\n\tif (sec_devmap->device)\n\t\treturn -EINVAL;\n\n\tif (prim_devmap->copy) {\n\t\tcopy = prim_devmap->copy;\n\t} else if (sec_devmap->copy) {\n\t\tcopy = sec_devmap->copy;\n\t} else {\n\t\tcopy = kzalloc(sizeof(*copy), GFP_KERNEL);\n\t\tif (!copy)\n\t\t\treturn -ENOMEM;\n\t}\n\tspin_lock(&dasd_devmap_lock);\n\trc = dasd_devmap_set_copy_relation(prim_devmap, copy, prim_busid, true);\n\tif (rc) {\n\t\tspin_unlock(&dasd_devmap_lock);\n\t\treturn rc;\n\t}\n\trc = dasd_devmap_set_copy_relation(sec_devmap, copy, sec_busid, false);\n\tif (rc) {\n\t\tspin_unlock(&dasd_devmap_lock);\n\t\treturn rc;\n\t}\n\tspin_unlock(&dasd_devmap_lock);\n\n\t/* if primary device is already online call device setup directly */\n\tif (prim_devmap->device && !prim_devmap->device->copy) {\n\t\tdevice = prim_devmap->device;\n\t\tif (device->discipline->pprc_enabled) {\n\t\t\tpprc_enabled = device->discipline->pprc_enabled(device);\n\t\t\trc = dasd_devmap_set_device_copy_relation(device->cdev,\n\t\t\t\t\t\t\t\t  pprc_enabled);\n\t\t} else {\n\t\t\trc = -EOPNOTSUPP;\n\t\t}\n\t}\n\tif (rc) {\n\t\tdasd_devmap_del_copy_relation(copy, prim_busid);\n\t\tdasd_devmap_del_copy_relation(copy, sec_busid);\n\t\tcount = rc;\n\t}\n\n\treturn count;\n}\n",
      "cve_list": [
        "CVE-2024-42320"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/dc/clk_mgr/dcn30/dcn30_clk_mgr.c",
      "func_name": "dcn3_clk_mgr_construct",
      "func_body": "void dcn3_clk_mgr_construct(\n\t\tstruct dc_context *ctx,\n\t\tstruct clk_mgr_internal *clk_mgr,\n\t\tstruct pp_smu_funcs *pp_smu,\n\t\tstruct dccg *dccg)\n{\n\tstruct clk_state_registers_and_bypass s = { 0 };\n\n\tclk_mgr->base.ctx = ctx;\n\tclk_mgr->base.funcs = &dcn3_funcs;\n\tclk_mgr->regs = &clk_mgr_regs;\n\tclk_mgr->clk_mgr_shift = &clk_mgr_shift;\n\tclk_mgr->clk_mgr_mask = &clk_mgr_mask;\n\n\tclk_mgr->dccg = dccg;\n\tclk_mgr->dfs_bypass_disp_clk = 0;\n\n\tclk_mgr->dprefclk_ss_percentage = 0;\n\tclk_mgr->dprefclk_ss_divider = 1000;\n\tclk_mgr->ss_on_dprefclk = false;\n\tclk_mgr->dfs_ref_freq_khz = 100000;\n\n\tclk_mgr->base.dprefclk_khz = 730000; // 700 MHz planned if VCO is 3.85 GHz, will be retrieved\n\n\t/* integer part is now VCO frequency in kHz */\n\tclk_mgr->base.dentist_vco_freq_khz = dcn30_get_vco_frequency_from_reg(clk_mgr);\n\n\t/* in case we don't get a value from the register, use default */\n\tif (clk_mgr->base.dentist_vco_freq_khz == 0)\n\t\tclk_mgr->base.dentist_vco_freq_khz = 3650000;\n\t/* Convert dprefclk units from MHz to KHz */\n\t/* Value already divided by 10, some resolution lost */\n\n\t/*TODO: uncomment assert once dcn3_dump_clk_registers is implemented */\n\t//ASSERT(s.dprefclk != 0);\n\tif (s.dprefclk != 0)\n\t\tclk_mgr->base.dprefclk_khz = s.dprefclk * 1000;\n\n\tclk_mgr->dfs_bypass_enabled = false;\n\n\tclk_mgr->smu_present = false;\n\n\tdce_clock_read_ss_info(clk_mgr);\n\n\tclk_mgr->base.bw_params = kzalloc(sizeof(*clk_mgr->base.bw_params), GFP_KERNEL);\n\tif (!clk_mgr->base.bw_params) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\t/* need physical address of table to give to PMFW */\n\tclk_mgr->wm_range_table = dm_helpers_allocate_gpu_mem(clk_mgr->base.ctx,\n\t\t\tDC_MEM_ALLOC_TYPE_GART, sizeof(WatermarksExternal_t),\n\t\t\t&clk_mgr->wm_range_table_addr);\n\tif (!clk_mgr->wm_range_table) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-42122"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/dc/clk_mgr/dcn32/dcn32_clk_mgr.c",
      "func_name": "dcn32_clk_mgr_construct",
      "func_body": "void dcn32_clk_mgr_construct(\n\t\tstruct dc_context *ctx,\n\t\tstruct clk_mgr_internal *clk_mgr,\n\t\tstruct pp_smu_funcs *pp_smu,\n\t\tstruct dccg *dccg)\n{\n\tstruct clk_log_info log_info = {0};\n\n\tclk_mgr->base.ctx = ctx;\n\tclk_mgr->base.funcs = &dcn32_funcs;\n\tif (ASICREV_IS_GC_11_0_2(clk_mgr->base.ctx->asic_id.hw_internal_rev)) {\n\t\tclk_mgr->regs = &clk_mgr_regs_dcn321;\n\t\tclk_mgr->clk_mgr_shift = &clk_mgr_shift_dcn321;\n\t\tclk_mgr->clk_mgr_mask = &clk_mgr_mask_dcn321;\n\t} else {\n\t\tclk_mgr->regs = &clk_mgr_regs_dcn32;\n\t\tclk_mgr->clk_mgr_shift = &clk_mgr_shift_dcn32;\n\t\tclk_mgr->clk_mgr_mask = &clk_mgr_mask_dcn32;\n\t}\n\n\tclk_mgr->dccg = dccg;\n\tclk_mgr->dfs_bypass_disp_clk = 0;\n\n\tclk_mgr->dprefclk_ss_percentage = 0;\n\tclk_mgr->dprefclk_ss_divider = 1000;\n\tclk_mgr->ss_on_dprefclk = false;\n\tclk_mgr->dfs_ref_freq_khz = 100000;\n\n\t/* Changed from DCN3.2_clock_frequency doc to match\n\t * dcn32_dump_clk_registers from 4 * dentist_vco_freq_khz /\n\t * dprefclk DID divider\n\t */\n\tclk_mgr->base.dprefclk_khz = 716666;\n\tif (ctx->dc->debug.disable_dtb_ref_clk_switch) {\n\t\t//initialize DTB ref clock value if DPM disabled\n\t\tif (ctx->dce_version == DCN_VERSION_3_21)\n\t\t\tclk_mgr->base.clks.ref_dtbclk_khz = 477800;\n\t\telse\n\t\t\tclk_mgr->base.clks.ref_dtbclk_khz = 268750;\n\t}\n\n\n\t/* integer part is now VCO frequency in kHz */\n\tclk_mgr->base.dentist_vco_freq_khz = dcn32_get_vco_frequency_from_reg(clk_mgr);\n\n\t/* in case we don't get a value from the register, use default */\n\tif (clk_mgr->base.dentist_vco_freq_khz == 0)\n\t\tclk_mgr->base.dentist_vco_freq_khz = 4300000; /* Updated as per HW docs */\n\n\tdcn32_dump_clk_registers(&clk_mgr->base.boot_snapshot, &clk_mgr->base, &log_info);\n\n\tif (ctx->dc->debug.disable_dtb_ref_clk_switch &&\n\t\t\tclk_mgr->base.clks.ref_dtbclk_khz != clk_mgr->base.boot_snapshot.dtbclk) {\n\t\tclk_mgr->base.clks.ref_dtbclk_khz = clk_mgr->base.boot_snapshot.dtbclk;\n\t}\n\n\tif (clk_mgr->base.boot_snapshot.dprefclk != 0) {\n\t\tclk_mgr->base.dprefclk_khz = clk_mgr->base.boot_snapshot.dprefclk;\n\t}\n\tdcn32_clock_read_ss_info(clk_mgr);\n\n\tclk_mgr->dfs_bypass_enabled = false;\n\n\tclk_mgr->smu_present = false;\n\n\tclk_mgr->base.bw_params = kzalloc(sizeof(*clk_mgr->base.bw_params), GFP_KERNEL);\n\tif (!clk_mgr->base.bw_params) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\t/* need physical address of table to give to PMFW */\n\tclk_mgr->wm_range_table = dm_helpers_allocate_gpu_mem(clk_mgr->base.ctx,\n\t\t\tDC_MEM_ALLOC_TYPE_GART, sizeof(WatermarksExternal_t),\n\t\t\t&clk_mgr->wm_range_table_addr);\n\tif (!clk_mgr->wm_range_table) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-42122"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/dc/resource/dcn30/dcn30_resource.c",
      "func_name": "dcn30_validate_bandwidth",
      "func_body": "bool dcn30_validate_bandwidth(struct dc *dc,\n\t\tstruct dc_state *context,\n\t\tbool fast_validate)\n{\n\tbool out = false;\n\n\tBW_VAL_TRACE_SETUP();\n\n\tint vlevel = 0;\n\tint pipe_cnt = 0;\n\tdisplay_e2e_pipe_params_st *pipes = kzalloc(dc->res_pool->pipe_count * sizeof(display_e2e_pipe_params_st), GFP_KERNEL);\n\tDC_LOGGER_INIT(dc->ctx->logger);\n\n\tBW_VAL_TRACE_COUNT();\n\n\tif (!pipes)\n\t\tgoto validate_fail;\n\n\tDC_FP_START();\n\tout = dcn30_internal_validate_bw(dc, context, pipes, &pipe_cnt, &vlevel, fast_validate, true);\n\tDC_FP_END();\n\n\tif (pipe_cnt == 0)\n\t\tgoto validate_out;\n\n\tif (!out)\n\t\tgoto validate_fail;\n\n\tBW_VAL_TRACE_END_VOLTAGE_LEVEL();\n\n\tif (fast_validate) {\n\t\tBW_VAL_TRACE_SKIP(fast);\n\t\tgoto validate_out;\n\t}\n\n\tDC_FP_START();\n\tif (dc->res_pool->funcs->calculate_wm_and_dlg)\n\t\tdc->res_pool->funcs->calculate_wm_and_dlg(dc, context, pipes, pipe_cnt, vlevel);\n\tDC_FP_END();\n\n\tBW_VAL_TRACE_END_WATERMARKS();\n\n\tgoto validate_out;\n\nvalidate_fail:\n\tDC_LOG_WARNING(\"Mode Validation Warning: %s failed validation.\\n\",\n\t\tdml_get_status_message(context->bw_ctx.dml.vba.ValidationStatus[context->bw_ctx.dml.vba.soc.num_states]));\n\n\tBW_VAL_TRACE_SKIP(fail);\n\tout = false;\n\nvalidate_out:\n\tkfree(pipes);\n\n\tBW_VAL_TRACE_FINISH();\n\n\treturn out;\n}\n",
      "cve_list": [
        "CVE-2024-42122"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/dc/resource/dcn315/dcn315_resource.c",
      "func_name": "dcn31_hpo_dp_link_encoder_create",
      "func_body": "static struct hpo_dp_link_encoder *dcn31_hpo_dp_link_encoder_create(\n\tuint8_t inst,\n\tstruct dc_context *ctx)\n{\n\tstruct dcn31_hpo_dp_link_encoder *hpo_dp_enc31;\n\n\t/* allocate HPO link encoder */\n\thpo_dp_enc31 = kzalloc(sizeof(struct dcn31_hpo_dp_link_encoder), GFP_KERNEL);\n\tif (!hpo_dp_enc31)\n\t\treturn NULL; /* out of memory */\n\n\thpo_dp_link_encoder31_construct(hpo_dp_enc31, ctx, inst,\n\t\t\t\t\t&hpo_dp_link_enc_regs[inst],\n\t\t\t\t\t&hpo_dp_le_shift, &hpo_dp_le_mask);\n\n\treturn &hpo_dp_enc31->base;\n}\n",
      "cve_list": [
        "CVE-2024-42122"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/dc/resource/dcn321/dcn321_resource.c",
      "func_name": "dcn321_hpo_dp_link_encoder_create",
      "func_body": "static struct hpo_dp_link_encoder *dcn321_hpo_dp_link_encoder_create(\n\tuint8_t inst,\n\tstruct dc_context *ctx)\n{\n\tstruct dcn31_hpo_dp_link_encoder *hpo_dp_enc31;\n\n\t/* allocate HPO link encoder */\n\thpo_dp_enc31 = kzalloc(sizeof(struct dcn31_hpo_dp_link_encoder), GFP_KERNEL);\n\tif (!hpo_dp_enc31)\n\t\treturn NULL; /* out of memory */\n\n#undef REG_STRUCT\n#define REG_STRUCT hpo_dp_link_enc_regs\n\thpo_dp_link_encoder_reg_init(0),\n\thpo_dp_link_encoder_reg_init(1);\n\n\thpo_dp_link_encoder32_construct(hpo_dp_enc31, ctx, inst,\n\t\t\t\t\t&hpo_dp_link_enc_regs[inst],\n\t\t\t\t\t&hpo_dp_le_shift, &hpo_dp_le_mask);\n\n\treturn &hpo_dp_enc31->base;\n}\n",
      "cve_list": [
        "CVE-2024-42122"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/dc/resource/dcn351/dcn351_resource.c",
      "func_name": "dcn31_hpo_dp_link_encoder_create",
      "func_body": "static struct hpo_dp_link_encoder *dcn31_hpo_dp_link_encoder_create(\n\tuint8_t inst,\n\tstruct dc_context *ctx)\n{\n\tstruct dcn31_hpo_dp_link_encoder *hpo_dp_enc31;\n\n\t/* allocate HPO link encoder */\n\thpo_dp_enc31 = kzalloc(sizeof(struct dcn31_hpo_dp_link_encoder), GFP_KERNEL);\n\tif (!hpo_dp_enc31)\n\t\treturn NULL; /* out of memory */\n\n#undef REG_STRUCT\n#define REG_STRUCT hpo_dp_link_enc_regs\n\thpo_dp_link_encoder_reg_init(0),\n\thpo_dp_link_encoder_reg_init(1);\n\n\thpo_dp_link_encoder31_construct(hpo_dp_enc31, ctx, inst,\n\t\t\t\t\t&hpo_dp_link_enc_regs[inst],\n\t\t\t\t\t&hpo_dp_le_shift, &hpo_dp_le_mask);\n\n\treturn &hpo_dp_enc31->base;\n}\n",
      "cve_list": [
        "CVE-2024-42122"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "tools/tracing/rtla/src/osnoise_top.c",
      "func_name": "osnoise_init_top",
      "func_body": "struct osnoise_tool *osnoise_init_top(struct osnoise_top_params *params)\n{\n\tstruct osnoise_tool *tool;\n\tint nr_cpus;\n\n\tnr_cpus = sysconf(_SC_NPROCESSORS_CONF);\n\n\ttool = osnoise_init_tool(\"osnoise_top\");\n\tif (!tool)\n\t\treturn NULL;\n\n\ttool->data = osnoise_alloc_top(nr_cpus);\n\tif (!tool->data) {\n\t\tosnoise_destroy_tool(tool);\n\t\treturn NULL;\n\t}\n\n\ttool->params = params;\n\n\ttep_register_event_handler(tool->trace.tep, -1, \"ftrace\", \"osnoise\",\n\t\t\t\t   osnoise_top_handler, NULL);\n\n\treturn tool;\n}\n",
      "cve_list": [
        "CVE-2024-45002"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "sound/soc/sof/intel/hda-dai.c",
      "func_name": "hda_dai_suspend",
      "func_body": "static int hda_dai_suspend(struct hdac_bus *bus)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\tstruct hdac_ext_stream *hext_stream;\n\tstruct hdac_stream *s;\n\tint ret;\n\n\t/* set internal flag for BE */\n\tlist_for_each_entry(s, &bus->stream_list, list) {\n\n\t\thext_stream = stream_to_hdac_ext_stream(s);\n\n\t\t/*\n\t\t * clear stream. This should already be taken care for running\n\t\t * streams when the SUSPEND trigger is called. But paused\n\t\t * streams do not get suspended, so this needs to be done\n\t\t * explicitly during suspend.\n\t\t */\n\t\tif (hext_stream->link_substream) {\n\t\t\tconst struct hda_dai_widget_dma_ops *ops;\n\t\t\tstruct snd_sof_widget *swidget;\n\t\t\tstruct snd_soc_dapm_widget *w;\n\t\t\tstruct snd_soc_dai *cpu_dai;\n\t\t\tstruct snd_sof_dev *sdev;\n\t\t\tstruct snd_sof_dai *sdai;\n\n\t\t\trtd = snd_soc_substream_to_rtd(hext_stream->link_substream);\n\t\t\tcpu_dai = snd_soc_rtd_to_cpu(rtd, 0);\n\t\t\tw = snd_soc_dai_get_widget(cpu_dai, hdac_stream(hext_stream)->direction);\n\t\t\tswidget = w->dobj.private;\n\t\t\tsdev = widget_to_sdev(w);\n\t\t\tsdai = swidget->private;\n\t\t\tops = sdai->platform_private;\n\n\t\t\t/* for consistency with TRIGGER_SUSPEND  */\n\t\t\tif (ops->post_trigger) {\n\t\t\t\tret = ops->post_trigger(sdev, cpu_dai,\n\t\t\t\t\t\t\thext_stream->link_substream,\n\t\t\t\t\t\t\tSNDRV_PCM_TRIGGER_SUSPEND);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = hda_link_dma_cleanup(hext_stream->link_substream,\n\t\t\t\t\t\t   hext_stream,\n\t\t\t\t\t\t   cpu_dai);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-41037"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/i2c/i2c-core-base.c",
      "func_name": "__i2c_transfer",
      "func_body": "int __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tunsigned long orig_jiffies;\n\tint ret, try;\n\n\tif (!adap->algo->master_xfer) {\n\t\tdev_dbg(&adap->dev, \"I2C level transfers not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (WARN_ON(!msgs || num < 1))\n\t\treturn -EINVAL;\n\n\tret = __i2c_check_suspended(adap);\n\tif (ret)\n\t\treturn ret;\n\n\tif (adap->quirks && i2c_check_for_quirks(adap, msgs, num))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * i2c_trace_msg_key gets enabled when tracepoint i2c_transfer gets\n\t * enabled.  This is an efficient way of keeping the for-loop from\n\t * being executed when not needed.\n\t */\n\tif (static_branch_unlikely(&i2c_trace_msg_key)) {\n\t\tint i;\n\t\tfor (i = 0; i < num; i++)\n\t\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\t\ttrace_i2c_read(adap, &msgs[i], i);\n\t\t\telse\n\t\t\t\ttrace_i2c_write(adap, &msgs[i], i);\n\t}\n\n\t/* Retry automatically on arbitration loss */\n\torig_jiffies = jiffies;\n\tfor (ret = 0, try = 0; try <= adap->retries; try++) {\n\t\tif (i2c_in_atomic_xfer_mode() && adap->algo->master_xfer_atomic)\n\t\t\tret = adap->algo->master_xfer_atomic(adap, msgs, num);\n\t\telse\n\t\t\tret = adap->algo->master_xfer(adap, msgs, num);\n\n\t\tif (ret != -EAGAIN)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, orig_jiffies + adap->timeout))\n\t\t\tbreak;\n\t}\n\n\tif (static_branch_unlikely(&i2c_trace_msg_key)) {\n\t\tint i;\n\t\tfor (i = 0; i < ret; i++)\n\t\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\t\ttrace_i2c_reply(adap, &msgs[i], i);\n\t\ttrace_i2c_result(adap, num, ret);\n\t}\n\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-35984"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/tls/tls_main.c",
      "func_name": "tls_ctx_create",
      "func_body": "struct tls_context *tls_ctx_create(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tls_context *ctx;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_ATOMIC);\n\tif (!ctx)\n\t\treturn NULL;\n\n\tmutex_init(&ctx->tx_lock);\n\tctx->sk_proto = READ_ONCE(sk->sk_prot);\n\tctx->sk = sk;\n\t/* Release semantic of rcu_assign_pointer() ensures that\n\t * ctx->sk_proto is visible before changing sk->sk_prot in\n\t * update_sk_prot(), and prevents reading uninitialized value in\n\t * tls_{getsockopt, setsockopt}. Note that we do not need a\n\t * read barrier in tls_{getsockopt,setsockopt} as there is an\n\t * address dependency between sk->sk_proto->{getsockopt,setsockopt}\n\t * and ctx->sk_proto.\n\t */\n\trcu_assign_pointer(icsk->icsk_ulp_data, ctx);\n\treturn ctx;\n}\n",
      "cve_list": [
        "CVE-2024-36489"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "sound/soc/codecs/tas2781-fmwlib.c",
      "func_name": "tasdev_load_calibrated_data",
      "func_body": "static void tasdev_load_calibrated_data(struct tasdevice_priv *priv, int i)\n{\n\tstruct tasdevice_calibration *cal;\n\tstruct tasdevice_fw *cal_fmw;\n\n\tcal_fmw = priv->tasdevice[i].cali_data_fmw;\n\n\t/* No calibrated data for current devices, playback will go ahead. */\n\tif (!cal_fmw)\n\t\treturn;\n\n\tcal = cal_fmw->calibrations;\n\tif (!cal)\n\t\treturn;\n\n\tload_calib_data(priv, &cal->dev_data);\n}\n",
      "cve_list": [
        "CVE-2024-42278"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/ufs/core/ufs-mcq.c",
      "func_name": "ufshcd_mcq_req_to_hwq",
      "func_body": "struct ufs_hw_queue *ufshcd_mcq_req_to_hwq(struct ufs_hba *hba,\n\t\t\t\t\t struct request *req)\n{\n\tstruct blk_mq_hw_ctx *hctx = READ_ONCE(req->mq_hctx);\n\n\treturn hctx ? &hba->uhq[hctx->queue_num] : NULL;\n}\n",
      "cve_list": [
        "CVE-2024-41054"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/ufs/core/ufs-mcq.c",
      "func_name": "ufshcd_mcq_sq_cleanup",
      "func_body": "int ufshcd_mcq_sq_cleanup(struct ufs_hba *hba, int task_tag)\n{\n\tstruct ufshcd_lrb *lrbp = &hba->lrb[task_tag];\n\tstruct scsi_cmnd *cmd = lrbp->cmd;\n\tstruct ufs_hw_queue *hwq;\n\tvoid __iomem *reg, *opr_sqd_base;\n\tu32 nexus, id, val;\n\tint err;\n\n\tif (hba->quirks & UFSHCD_QUIRK_MCQ_BROKEN_RTC)\n\t\treturn -ETIMEDOUT;\n\n\tif (task_tag != hba->nutrs - UFSHCD_NUM_RESERVED) {\n\t\tif (!cmd)\n\t\t\treturn -EINVAL;\n\t\thwq = ufshcd_mcq_req_to_hwq(hba, scsi_cmd_to_rq(cmd));\n\t\tif (!hwq)\n\t\t\treturn 0;\n\t} else {\n\t\thwq = hba->dev_cmd_queue;\n\t}\n\n\tid = hwq->id;\n\n\tmutex_lock(&hwq->sq_mutex);\n\n\t/* stop the SQ fetching before working on it */\n\terr = ufshcd_mcq_sq_stop(hba, hwq);\n\tif (err)\n\t\tgoto unlock;\n\n\t/* SQCTI = EXT_IID, IID, LUN, Task Tag */\n\tnexus = lrbp->lun << 8 | task_tag;\n\topr_sqd_base = mcq_opr_base(hba, OPR_SQD, id);\n\twritel(nexus, opr_sqd_base + REG_SQCTI);\n\n\t/* SQRTCy.ICU = 1 */\n\twritel(SQ_ICU, opr_sqd_base + REG_SQRTC);\n\n\t/* Poll SQRTSy.CUS = 1. Return result from SQRTSy.RTC */\n\treg = opr_sqd_base + REG_SQRTS;\n\terr = read_poll_timeout(readl, val, val & SQ_CUS, 20,\n\t\t\t\tMCQ_POLL_US, false, reg);\n\tif (err)\n\t\tdev_err(hba->dev, \"%s: failed. hwq=%d, tag=%d err=%ld\\n\",\n\t\t\t__func__, id, task_tag,\n\t\t\tFIELD_GET(SQ_ICU_ERR_CODE_MASK, readl(reg)));\n\n\tif (ufshcd_mcq_sq_start(hba, hwq))\n\t\terr = -ETIMEDOUT;\n\nunlock:\n\tmutex_unlock(&hwq->sq_mutex);\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-41054"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "lib/maple_tree.c",
      "func_name": "mas_empty_area_rev",
      "func_body": "int mas_empty_area_rev(struct ma_state *mas, unsigned long min,\n\t\tunsigned long max, unsigned long size)\n{\n\tstruct maple_enode *last = mas->node;\n\n\tif (min > max)\n\t\treturn -EINVAL;\n\n\tif (size == 0 || max - min < size - 1)\n\t\treturn -EINVAL;\n\n\tif (mas_is_start(mas))\n\t\tmas_start(mas);\n\telse if ((mas->offset < 2) && (!mas_rewind_node(mas)))\n\t\treturn -EBUSY;\n\n\tif (unlikely(mas_is_none(mas) || mas_is_ptr(mas)))\n\t\treturn mas_sparse_area(mas, min, max, size, false);\n\telse if (mas->offset >= 2)\n\t\tmas->offset -= 2;\n\telse\n\t\tmas->offset = mas_data_end(mas);\n\n\n\t/* The start of the window can only be within these values. */\n\tmas->index = min;\n\tmas->last = max;\n\n\twhile (!mas_rev_awalk(mas, size, &min, &max)) {\n\t\tif (last == mas->node) {\n\t\t\tif (!mas_rewind_node(mas))\n\t\t\t\treturn -EBUSY;\n\t\t} else {\n\t\t\tlast = mas->node;\n\t\t}\n\t}\n\n\tif (mas_is_err(mas))\n\t\treturn xa_err(mas->node);\n\n\tif (unlikely(mas->offset == MAPLE_NODE_SLOTS))\n\t\treturn -EBUSY;\n\n\t/* Trim the upper limit to the max. */\n\tif (max < mas->last)\n\t\tmas->last = max;\n\n\tmas->index = mas->last - size + 1;\n\tmas->end = mas_data_end(mas);\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-36891"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/bonding/bond_main.c",
      "func_name": "bond_ipsec_offload_ok",
      "func_body": "static bool bond_ipsec_offload_ok(struct sk_buff *skb, struct xfrm_state *xs)\n{\n\tstruct net_device *bond_dev = xs->xso.dev;\n\tstruct net_device *real_dev;\n\tstruct slave *curr_active;\n\tstruct bonding *bond;\n\tbool ok = false;\n\n\tbond = netdev_priv(bond_dev);\n\trcu_read_lock();\n\tcurr_active = rcu_dereference(bond->curr_active_slave);\n\tif (!curr_active)\n\t\tgoto out;\n\treal_dev = curr_active->dev;\n\n\tif (BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP)\n\t\tgoto out;\n\n\tif (!xs->xso.real_dev)\n\t\tgoto out;\n\n\tif (!real_dev->xfrmdev_ops ||\n\t    !real_dev->xfrmdev_ops->xdo_dev_offload_ok ||\n\t    netif_is_bond_master(real_dev))\n\t\tgoto out;\n\n\tok = real_dev->xfrmdev_ops->xdo_dev_offload_ok(skb, xs);\nout:\n\trcu_read_unlock();\n\treturn ok;\n}\n",
      "cve_list": [
        "CVE-2024-44990"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/usb/gadget/udc/core.c",
      "func_name": "usb_ep_enable",
      "func_body": "int usb_ep_enable(struct usb_ep *ep)\n{\n\tint ret = 0;\n\n\tif (ep->enabled)\n\t\tgoto out;\n\n\t/* UDC drivers can't handle endpoints with maxpacket size 0 */\n\tif (!ep->desc || usb_endpoint_maxp(ep->desc) == 0) {\n\t\tWARN_ONCE(1, \"%s: ep%d (%s) has %s\\n\", __func__, ep->address, ep->name,\n\t\t\t  (!ep->desc) ? \"NULL descriptor\" : \"maxpacket 0\");\n\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = ep->ops->enable(ep, ep->desc);\n\tif (ret)\n\t\tgoto out;\n\n\tep->enabled = true;\n\nout:\n\ttrace_usb_ep_enable(ep, ret);\n\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-44960"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/dc/bios/bios_parser2.c",
      "func_name": "construct_integrated_info",
      "func_body": "static enum bp_result construct_integrated_info(\n\tstruct bios_parser *bp,\n\tstruct integrated_info *info)\n{\n\tstatic enum bp_result result = BP_RESULT_BADBIOSTABLE;\n\n\tstruct atom_common_table_header *header;\n\tstruct atom_data_revision revision;\n\n\tuint32_t i;\n\tuint32_t j;\n\n\tif (info && DATA_TABLES(integratedsysteminfo)) {\n\t\theader = GET_IMAGE(struct atom_common_table_header,\n\t\t\t\t\tDATA_TABLES(integratedsysteminfo));\n\n\t\tget_atom_data_table_revision(header, &revision);\n\n\t\tswitch (revision.major) {\n\t\tcase 1:\n\t\t\tswitch (revision.minor) {\n\t\t\tcase 11:\n\t\t\tcase 12:\n\t\t\t\tresult = get_integrated_info_v11(bp, info);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tswitch (revision.minor) {\n\t\t\tcase 1:\n\t\t\t\tresult = get_integrated_info_v2_1(bp, info);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\tcase 3:\n\t\t\t\tresult = get_integrated_info_v2_2(bp, info);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn result;\n\t\t}\n\t\tif (result == BP_RESULT_OK) {\n\n\t\t\tDC_LOG_BIOS(\"edp1:\\n\"\n\t\t\t\t\t\t\"\\tedp_pwr_on_off_delay = %d\\n\"\n\t\t\t\t\t\t\"\\tedp_pwr_on_vary_bl_to_blon = %d\\n\"\n\t\t\t\t\t\t\"\\tedp_pwr_down_bloff_to_vary_bloff = %d\\n\"\n\t\t\t\t\t\t\"\\tedp_bootup_bl_level = %d\\n\",\n\t\t\t\t\t\tinfo->edp1_info.edp_pwr_on_off_delay,\n\t\t\t\t\t\tinfo->edp1_info.edp_pwr_on_vary_bl_to_blon,\n\t\t\t\t\t\tinfo->edp1_info.edp_pwr_down_bloff_to_vary_bloff,\n\t\t\t\t\t\tinfo->edp1_info.edp_bootup_bl_level);\n\t\t\tDC_LOG_BIOS(\"edp2:\\n\"\n\t\t\t\t\t\t\"\\tedp_pwr_on_off_delayv = %d\\n\"\n\t\t\t\t\t\t\"\\tedp_pwr_on_vary_bl_to_blon = %d\\n\"\n\t\t\t\t\t\t\"\\tedp_pwr_down_bloff_to_vary_bloff = %d\\n\"\n\t\t\t\t\t\t\"\\tedp_bootup_bl_level = %d\\n\",\n\t\t\t\t\t\tinfo->edp2_info.edp_pwr_on_off_delay,\n\t\t\t\t\t\tinfo->edp2_info.edp_pwr_on_vary_bl_to_blon,\n\t\t\t\t\t\tinfo->edp2_info.edp_pwr_down_bloff_to_vary_bloff,\n\t\t\t\t\t\tinfo->edp2_info.edp_bootup_bl_level);\n\t\t}\n\t}\n\n\tif (result != BP_RESULT_OK)\n\t\treturn result;\n\telse {\n\t\t// Log each external path\n\t\tfor (i = 0; i < MAX_NUMBER_OF_EXT_DISPLAY_PATH; i++) {\n\t\t\tif (info->ext_disp_conn_info.path[i].device_tag != 0)\n\t\t\t\tDC_LOG_BIOS(\"integrated_info:For EXTERNAL DISPLAY PATH %d --------------\\n\"\n\t\t\t\t\t\t\"DEVICE_TAG: 0x%x\\n\"\n\t\t\t\t\t\t\"DEVICE_ACPI_ENUM: 0x%x\\n\"\n\t\t\t\t\t\t\"DEVICE_CONNECTOR_ID: 0x%x\\n\"\n\t\t\t\t\t\t\"EXT_AUX_DDC_LUT_INDEX: %d\\n\"\n\t\t\t\t\t\t\"EXT_HPD_PIN_LUT_INDEX: %d\\n\"\n\t\t\t\t\t\t\"EXT_ENCODER_OBJ_ID: 0x%x\\n\"\n\t\t\t\t\t\t\"Encoder CAPS: 0x%x\\n\",\n\t\t\t\t\t\ti,\n\t\t\t\t\t\tinfo->ext_disp_conn_info.path[i].device_tag,\n\t\t\t\t\t\tinfo->ext_disp_conn_info.path[i].device_acpi_enum,\n\t\t\t\t\t\tinfo->ext_disp_conn_info.path[i].device_connector_id.id,\n\t\t\t\t\t\tinfo->ext_disp_conn_info.path[i].ext_aux_ddc_lut_index,\n\t\t\t\t\t\tinfo->ext_disp_conn_info.path[i].ext_hpd_pin_lut_index,\n\t\t\t\t\t\tinfo->ext_disp_conn_info.path[i].ext_encoder_obj_id.id,\n\t\t\t\t\t\tinfo->ext_disp_conn_info.path[i].caps\n\t\t\t\t\t\t);\n\t\t\tif (info->ext_disp_conn_info.path[i].caps & EXT_DISPLAY_PATH_CAPS__DP_FIXED_VS_EN)\n\t\t\t\tDC_LOG_BIOS(\"BIOS EXT_DISPLAY_PATH_CAPS__DP_FIXED_VS_EN on path %d\\n\", i);\n\t\t\telse if (bp->base.ctx->dc->config.force_bios_fixed_vs) {\n\t\t\t\tinfo->ext_disp_conn_info.path[i].caps |= EXT_DISPLAY_PATH_CAPS__DP_FIXED_VS_EN;\n\t\t\t\tDC_LOG_BIOS(\"driver forced EXT_DISPLAY_PATH_CAPS__DP_FIXED_VS_EN on path %d\\n\", i);\n\t\t\t}\n\t\t}\n\t\t// Log the Checksum and Voltage Swing\n\t\tDC_LOG_BIOS(\"Integrated info table CHECKSUM: %d\\n\"\n\t\t\t\t\t\"Integrated info table FIX_DP_VOLTAGE_SWING: %d\\n\",\n\t\t\t\t\tinfo->ext_disp_conn_info.checksum,\n\t\t\t\t\tinfo->ext_disp_conn_info.fixdpvoltageswing);\n\t\tif (bp->base.ctx->dc->config.force_bios_fixed_vs && info->ext_disp_conn_info.fixdpvoltageswing == 0) {\n\t\t\tinfo->ext_disp_conn_info.fixdpvoltageswing = bp->base.ctx->dc->config.force_bios_fixed_vs & 0xF;\n\t\t\tDC_LOG_BIOS(\"driver forced fixdpvoltageswing = %d\\n\", info->ext_disp_conn_info.fixdpvoltageswing);\n\t\t}\n\t}\n\t/* Sort voltage table from low to high*/\n\tfor (i = 1; i < NUMBER_OF_DISP_CLK_VOLTAGE; ++i) {\n\t\tfor (j = i; j > 0; --j) {\n\t\t\tif (info->disp_clk_voltage[j].max_supported_clk <\n\t\t\t    info->disp_clk_voltage[j-1].max_supported_clk)\n\t\t\t\tswap(info->disp_clk_voltage[j-1], info->disp_clk_voltage[j]);\n\t\t}\n\t}\n\n\treturn result;\n}\n",
      "cve_list": [
        "CVE-2024-36897"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ipv6/seg6_local.c",
      "func_name": "input_action_end_dx6",
      "func_body": "static int input_action_end_dx6(struct sk_buff *skb,\n\t\t\t\tstruct seg6_local_lwt *slwt)\n{\n\t/* this function accepts IPv6 encapsulated packets, with either\n\t * an SRH with SL=0, or no SRH.\n\t */\n\n\tif (!decap_and_validate(skb, IPPROTO_IPV6))\n\t\tgoto drop;\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\tgoto drop;\n\n\tskb_set_transport_header(skb, sizeof(struct ipv6hdr));\n\tnf_reset_ct(skb);\n\n\tif (static_branch_unlikely(&nf_hooks_lwtunnel_enabled))\n\t\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING,\n\t\t\t       dev_net(skb->dev), NULL, skb, skb->dev,\n\t\t\t       NULL, input_action_end_dx6_finish);\n\n\treturn input_action_end_dx6_finish(dev_net(skb->dev), NULL, skb);\ndrop:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n",
      "cve_list": [
        "CVE-2024-40957"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ipv6/seg6_local.c",
      "func_name": "input_action_end_dx4",
      "func_body": "static int input_action_end_dx4(struct sk_buff *skb,\n\t\t\t\tstruct seg6_local_lwt *slwt)\n{\n\tif (!decap_and_validate(skb, IPPROTO_IPIP))\n\t\tgoto drop;\n\n\tif (!pskb_may_pull(skb, sizeof(struct iphdr)))\n\t\tgoto drop;\n\n\tskb->protocol = htons(ETH_P_IP);\n\tskb_set_transport_header(skb, sizeof(struct iphdr));\n\tnf_reset_ct(skb);\n\n\tif (static_branch_unlikely(&nf_hooks_lwtunnel_enabled))\n\t\treturn NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,\n\t\t\t       dev_net(skb->dev), NULL, skb, skb->dev,\n\t\t\t       NULL, input_action_end_dx4_finish);\n\n\treturn input_action_end_dx4_finish(dev_net(skb->dev), NULL, skb);\ndrop:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n",
      "cve_list": [
        "CVE-2024-40957"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/media/v4l2-core/v4l2-async.c",
      "func_name": "v4l2_async_create_ancillary_links",
      "func_body": "static int v4l2_async_create_ancillary_links(struct v4l2_async_notifier *n,\n\t\t\t\t\t     struct v4l2_subdev *sd)\n{\n// #if IS_ENABLED(CONFIG_MEDIA_CONTROLLER)\n\tstruct media_link *link;\n\n\tif (sd->entity.function != MEDIA_ENT_F_LENS &&\n\t    sd->entity.function != MEDIA_ENT_F_FLASH)\n\t\treturn 0;\n\n\tif (!n->sd)\n\t\treturn 0;\n\n\tlink = media_create_ancillary_link(&n->sd->entity, &sd->entity);\n\n\treturn IS_ERR(link) ? PTR_ERR(link) : 0;\n#else\n\treturn 0;\n#endif\n}\n",
      "cve_list": [
        "CVE-2024-43833"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/media/platform/mediatek/vcodec/decoder/vdec/vdec_h264_req_multi_if.c",
      "func_name": "vdec_h264_slice_single_decode",
      "func_body": "static int vdec_h264_slice_single_decode(void *h_vdec, struct mtk_vcodec_mem *bs,\n\t\t\t\t\t struct vdec_fb *unused, bool *res_chg)\n{\n\tstruct vdec_h264_slice_inst *inst = h_vdec;\n\tstruct vdec_vpu_inst *vpu = &inst->vpu;\n\tstruct mtk_video_dec_buf *src_buf_info, *dst_buf_info;\n\tstruct vdec_fb *fb;\n\tunsigned char *buf;\n\tunsigned int data[2], i;\n\tu64 y_fb_dma, c_fb_dma;\n\tstruct mtk_vcodec_mem *mem;\n\tint err, nal_start_idx;\n\n\t/* bs NULL means flush decoder */\n\tif (!bs)\n\t\treturn vpu_dec_reset(vpu);\n\n\tfb = inst->ctx->dev->vdec_pdata->get_cap_buffer(inst->ctx);\n\tif (!fb) {\n\t\tmtk_vdec_err(inst->ctx, \"fb buffer is NULL\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsrc_buf_info = container_of(bs, struct mtk_video_dec_buf, bs_buffer);\n\tdst_buf_info = container_of(fb, struct mtk_video_dec_buf, frame_buffer);\n\n\ty_fb_dma = fb->base_y.dma_addr;\n\tc_fb_dma = fb->base_c.dma_addr;\n\tmtk_vdec_debug(inst->ctx, \"[h264-dec] [%d] y_dma=%llx c_dma=%llx\",\n\t\t       inst->ctx->decoded_frame_cnt, y_fb_dma, c_fb_dma);\n\n\tinst->vsi_ctx.dec.bs_buf_addr = (u64)bs->dma_addr;\n\tinst->vsi_ctx.dec.bs_buf_size = bs->size;\n\tinst->vsi_ctx.dec.y_fb_dma = y_fb_dma;\n\tinst->vsi_ctx.dec.c_fb_dma = c_fb_dma;\n\tinst->vsi_ctx.dec.vdec_fb_va = (u64)(uintptr_t)fb;\n\n\tv4l2_m2m_buf_copy_metadata(&src_buf_info->m2m_buf.vb,\n\t\t\t\t   &dst_buf_info->m2m_buf.vb, true);\n\terr = get_vdec_sig_decode_parameters(inst);\n\tif (err)\n\t\tgoto err_free_fb_out;\n\n\tbuf = (unsigned char *)bs->va;\n\tnal_start_idx = mtk_vdec_h264_find_start_code(buf, bs->size);\n\tif (nal_start_idx < 0) {\n\t\terr = -EINVAL;\n\t\tgoto err_free_fb_out;\n\t}\n\tinst->vsi_ctx.dec.nal_info = buf[nal_start_idx];\n\n\t*res_chg = inst->resolution_changed;\n\tif (inst->resolution_changed) {\n\t\tmtk_vdec_debug(inst->ctx, \"- resolution changed -\");\n\t\tif (inst->realloc_mv_buf) {\n\t\t\terr = vdec_h264_slice_alloc_mv_buf(inst, &inst->ctx->picinfo);\n\t\t\tinst->realloc_mv_buf = false;\n\t\t\tif (err)\n\t\t\t\tgoto err_free_fb_out;\n\t\t}\n\t\tinst->resolution_changed = false;\n\n\t\tfor (i = 0; i < H264_MAX_MV_NUM; i++) {\n\t\t\tmem = &inst->mv_buf[i];\n\t\t\tinst->vsi_ctx.mv_buf_dma[i] = mem->dma_addr;\n\t\t}\n\t}\n\n\tmemcpy(inst->vpu.vsi, &inst->vsi_ctx, sizeof(inst->vsi_ctx));\n\terr = vpu_dec_start(vpu, data, 2);\n\tif (err)\n\t\tgoto err_free_fb_out;\n\n\t/* wait decoder done interrupt */\n\terr = mtk_vcodec_wait_for_done_ctx(inst->ctx, MTK_INST_IRQ_RECEIVED,\n\t\t\t\t\t   WAIT_INTR_TIMEOUT_MS, MTK_VDEC_CORE);\n\tif (err)\n\t\tmtk_vdec_err(inst->ctx, \"decode timeout: pic_%d\", inst->ctx->decoded_frame_cnt);\n\n\tinst->vsi->dec.timeout = !!err;\n\terr = vpu_dec_end(vpu);\n\tif (err)\n\t\tgoto err_free_fb_out;\n\n\tmemcpy(&inst->vsi_ctx, inst->vpu.vsi, sizeof(inst->vsi_ctx));\n\tmtk_vdec_debug(inst->ctx, \"pic[%d] crc: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\",\n\t\t       inst->ctx->decoded_frame_cnt,\n\t\t       inst->vsi_ctx.dec.crc[0], inst->vsi_ctx.dec.crc[1],\n\t\t       inst->vsi_ctx.dec.crc[2], inst->vsi_ctx.dec.crc[3],\n\t\t       inst->vsi_ctx.dec.crc[4], inst->vsi_ctx.dec.crc[5],\n\t\t       inst->vsi_ctx.dec.crc[6], inst->vsi_ctx.dec.crc[7]);\n\n\tinst->ctx->decoded_frame_cnt++;\n\treturn 0;\n\nerr_free_fb_out:\n\tmtk_vdec_err(inst->ctx, \"dec frame number: %d err: %d\", inst->ctx->decoded_frame_cnt, err);\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-47754"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/orangefs/super.c",
      "func_name": "orangefs_mount",
      "func_body": "struct dentry *orangefs_mount(struct file_system_type *fst,\n\t\t\t   int flags,\n\t\t\t   const char *devname,\n\t\t\t   void *data)\n{\n\tint ret;\n\tstruct super_block *sb = ERR_PTR(-EINVAL);\n\tstruct orangefs_kernel_op_s *new_op;\n\tstruct dentry *d = ERR_PTR(-EINVAL);\n\n\tgossip_debug(GOSSIP_SUPER_DEBUG,\n\t\t     \"orangefs_mount: called with devname %s\\n\",\n\t\t     devname);\n\n\tif (!devname) {\n\t\tgossip_err(\"ERROR: device name not specified.\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tnew_op = op_alloc(ORANGEFS_VFS_OP_FS_MOUNT);\n\tif (!new_op)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(new_op->upcall.req.fs_mount.orangefs_config_server,\n\t\tdevname,\n\t\tORANGEFS_MAX_SERVER_ADDR_LEN - 1);\n\n\tgossip_debug(GOSSIP_SUPER_DEBUG,\n\t\t     \"Attempting ORANGEFS Mount via host %s\\n\",\n\t\t     new_op->upcall.req.fs_mount.orangefs_config_server);\n\n\tret = service_operation(new_op, \"orangefs_mount\", 0);\n\tgossip_debug(GOSSIP_SUPER_DEBUG,\n\t\t     \"orangefs_mount: mount got return value of %d\\n\", ret);\n\tif (ret)\n\t\tgoto free_op;\n\n\tif (new_op->downcall.resp.fs_mount.fs_id == ORANGEFS_FS_ID_NULL) {\n\t\tgossip_err(\"ERROR: Retrieved null fs_id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free_op;\n\t}\n\n\tsb = sget(fst, NULL, set_anon_super, flags, NULL);\n\n\tif (IS_ERR(sb)) {\n\t\td = ERR_CAST(sb);\n\t\torangefs_unmount(new_op->downcall.resp.fs_mount.id,\n\t\t    new_op->downcall.resp.fs_mount.fs_id, devname);\n\t\tgoto free_op;\n\t}\n\n\t/* alloc and init our private orangefs sb info */\n\tsb->s_fs_info = kzalloc(sizeof(struct orangefs_sb_info_s), GFP_KERNEL);\n\tif (!ORANGEFS_SB(sb)) {\n\t\td = ERR_PTR(-ENOMEM);\n\t\tgoto free_op;\n\t}\n\n\tret = orangefs_fill_sb(sb,\n\t      &new_op->downcall.resp.fs_mount, data,\n\t      flags & SB_SILENT ? 1 : 0);\n\n\tif (ret) {\n\t\td = ERR_PTR(ret);\n\t\tgoto free_sb_and_op;\n\t}\n\n\t/*\n\t * on successful mount, store the devname and data\n\t * used\n\t */\n\tstrncpy(ORANGEFS_SB(sb)->devname,\n\t\tdevname,\n\t\tORANGEFS_MAX_SERVER_ADDR_LEN - 1);\n\n\t/* mount_pending must be cleared */\n\tORANGEFS_SB(sb)->mount_pending = 0;\n\n\t/*\n\t * finally, add this sb to our list of known orangefs\n\t * sb's\n\t */\n\tgossip_debug(GOSSIP_SUPER_DEBUG,\n\t\t     \"Adding SB %p to orangefs superblocks\\n\",\n\t\t     ORANGEFS_SB(sb));\n\tspin_lock(&orangefs_superblocks_lock);\n\tlist_add_tail(&ORANGEFS_SB(sb)->list, &orangefs_superblocks);\n\tspin_unlock(&orangefs_superblocks_lock);\n\top_release(new_op);\n\n\t/* Must be removed from the list now. */\n\tORANGEFS_SB(sb)->no_list = 0;\n\n\tif (orangefs_userspace_version >= 20906) {\n\t\tnew_op = op_alloc(ORANGEFS_VFS_OP_FEATURES);\n\t\tif (!new_op)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnew_op->upcall.req.features.features = 0;\n\t\tret = service_operation(new_op, \"orangefs_features\", 0);\n\t\torangefs_features = new_op->downcall.resp.features.features;\n\t\top_release(new_op);\n\t} else {\n\t\torangefs_features = 0;\n\t}\n\n\treturn dget(sb->s_root);\n\nfree_sb_and_op:\n\t/* Will call orangefs_kill_sb with sb not in list. */\n\tORANGEFS_SB(sb)->no_list = 1;\n\t/* ORANGEFS_VFS_OP_FS_UMOUNT is done by orangefs_kill_sb. */\n\tdeactivate_locked_super(sb);\nfree_op:\n\tgossip_err(\"orangefs_mount: mount request failed with %d\\n\", ret);\n\tif (ret == -EINVAL) {\n\t\tgossip_err(\"Ensure that all orangefs-servers have the same FS configuration files\\n\");\n\t\tgossip_err(\"Look at pvfs2-client-core log file (typically /tmp/pvfs2-client.log) for more details\\n\");\n\t}\n\n\top_release(new_op);\n\n\treturn d;\n}\n",
      "cve_list": [
        "CVE-2024-36023"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/thermal/mediatek/lvts_thermal.c",
      "func_name": "lvts_probe",
      "func_body": "static int lvts_probe(struct platform_device *pdev)\n{\n\tconst struct lvts_data *lvts_data;\n\tstruct lvts_domain *lvts_td;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tint irq, ret;\n\n\tlvts_td = devm_kzalloc(dev, sizeof(*lvts_td), GFP_KERNEL);\n\tif (!lvts_td)\n\t\treturn -ENOMEM;\n\n\tlvts_data = of_device_get_match_data(dev);\n\tif (!lvts_data)\n\t\treturn -ENODEV;\n\n\tlvts_td->clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(lvts_td->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(lvts_td->clk), \"Failed to retrieve clock\\n\");\n\n\tres = platform_get_mem_or_io(pdev, 0);\n\tif (!res)\n\t\treturn dev_err_probe(dev, (-ENXIO), \"No IO resource\\n\");\n\n\tlvts_td->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(lvts_td->base))\n\t\treturn dev_err_probe(dev, PTR_ERR(lvts_td->base), \"Failed to map io resource\\n\");\n\n\tlvts_td->reset = devm_reset_control_get_by_index(dev, 0);\n\tif (IS_ERR(lvts_td->reset))\n\t\treturn dev_err_probe(dev, PTR_ERR(lvts_td->reset), \"Failed to get reset control\\n\");\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tgolden_temp_offset = lvts_data->temp_offset;\n\n\tret = lvts_domain_init(dev, lvts_td, lvts_data);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to initialize the lvts domain\\n\");\n\n\t/*\n\t * At this point the LVTS is initialized and enabled. We can\n\t * safely enable the interrupt.\n\t */\n\tret = devm_request_threaded_irq(dev, irq, NULL, lvts_irq_handler,\n\t\t\t\t\tIRQF_ONESHOT, dev_name(dev), lvts_td);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to request interrupt\\n\");\n\n\tplatform_set_drvdata(pdev, lvts_td);\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-42144"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/iommu/iommufd/hw_pagetable.c",
      "func_name": "iommufd_hwpt_nested_alloc",
      "func_body": "static struct iommufd_hwpt_nested *\niommufd_hwpt_nested_alloc(struct iommufd_ctx *ictx,\n\t\t\t  struct iommufd_hwpt_paging *parent,\n\t\t\t  struct iommufd_device *idev, u32 flags,\n\t\t\t  const struct iommu_user_data *user_data)\n{\n\tconst struct iommu_ops *ops = dev_iommu_ops(idev->dev);\n\tstruct iommufd_hwpt_nested *hwpt_nested;\n\tstruct iommufd_hw_pagetable *hwpt;\n\tint rc;\n\n\tif ((flags & ~IOMMU_HWPT_FAULT_ID_VALID) ||\n\t    !user_data->len || !ops->domain_alloc_user)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\tif (parent->auto_domain || !parent->nest_parent)\n\t\treturn ERR_PTR(-EINVAL);\n\n\thwpt_nested = __iommufd_object_alloc(\n\t\tictx, hwpt_nested, IOMMUFD_OBJ_HWPT_NESTED, common.obj);\n\tif (IS_ERR(hwpt_nested))\n\t\treturn ERR_CAST(hwpt_nested);\n\thwpt = &hwpt_nested->common;\n\n\trefcount_inc(&parent->common.obj.users);\n\thwpt_nested->parent = parent;\n\n\thwpt->domain = ops->domain_alloc_user(idev->dev,\n\t\t\t\t\t      flags & ~IOMMU_HWPT_FAULT_ID_VALID,\n\t\t\t\t\t      parent->common.domain, user_data);\n\tif (IS_ERR(hwpt->domain)) {\n\t\trc = PTR_ERR(hwpt->domain);\n\t\thwpt->domain = NULL;\n\t\tgoto out_abort;\n\t}\n\thwpt->domain->owner = ops;\n\n\tif (WARN_ON_ONCE(hwpt->domain->type != IOMMU_DOMAIN_NESTED ||\n\t\t\t !hwpt->domain->ops->cache_invalidate_user)) {\n\t\trc = -EINVAL;\n\t\tgoto out_abort;\n\t}\n\treturn hwpt_nested;\n\nout_abort:\n\tiommufd_object_abort_and_destroy(ictx, &hwpt->obj);\n\treturn ERR_PTR(rc);\n}\n",
      "cve_list": [
        "CVE-2024-46824"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/mmc/core/mmc_test.c",
      "func_name": "mtf_test_write",
      "func_body": "static ssize_t mtf_test_write(struct file *file, const char __user *buf,\n\tsize_t count, loff_t *pos)\n{\n\tstruct seq_file *sf = file->private_data;\n\tstruct mmc_card *card = sf->private;\n\tstruct mmc_test_card *test;\n\tlong testcase;\n\tint ret;\n\n\tret = kstrtol_from_user(buf, count, 10, &testcase);\n\tif (ret)\n\t\treturn ret;\n\n\ttest = kzalloc(sizeof(*test), GFP_KERNEL);\n\tif (!test)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Remove all test cases associated with given card. Thus we have only\n\t * actual data of the last run.\n\t */\n\tmmc_test_free_result(card);\n\n\ttest->card = card;\n\n\ttest->buffer = kzalloc(BUFFER_SIZE, GFP_KERNEL);\n// #ifdef CONFIG_HIGHMEM\n\ttest->highmem = alloc_pages(GFP_KERNEL | __GFP_HIGHMEM, BUFFER_ORDER);\n\tif (!test->highmem) {\n\t\tcount = -ENOMEM;\n\t\tgoto free_test_buffer;\n\t}\n#endif\n\n\tif (test->buffer) {\n\t\tmutex_lock(&mmc_test_lock);\n\t\tmmc_test_run(test, testcase);\n\t\tmutex_unlock(&mmc_test_lock);\n\t}\n\n// #ifdef CONFIG_HIGHMEM\n\t__free_pages(test->highmem, BUFFER_ORDER);\nfree_test_buffer:\n#endif\n\tkfree(test->buffer);\n\tkfree(test);\n\n\treturn count;\n}\n",
      "cve_list": [
        "CVE-2024-45028"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/pci/controller/dwc/pci-keystone.c",
      "func_name": "ks_pcie_setup_rc_app_regs",
      "func_body": "static int ks_pcie_setup_rc_app_regs(struct keystone_pcie *ks_pcie)\n{\n\tu32 val;\n\tu32 num_viewport = ks_pcie->num_viewport;\n\tstruct dw_pcie *pci = ks_pcie->pci;\n\tstruct dw_pcie_rp *pp = &pci->pp;\n\tstruct resource_entry *entry;\n\tstruct resource *mem;\n\tu64 start, end;\n\tint i;\n\n\tentry = resource_list_first_type(&pp->bridge->windows, IORESOURCE_MEM);\n\tif (!entry)\n\t\treturn -ENODEV;\n\n\tmem = entry->res;\n\tstart = mem->start;\n\tend = mem->end;\n\n\t/* Disable BARs for inbound access */\n\tks_pcie_set_dbi_mode(ks_pcie);\n\tdw_pcie_writel_dbi(pci, PCI_BASE_ADDRESS_0, 0);\n\tdw_pcie_writel_dbi(pci, PCI_BASE_ADDRESS_1, 0);\n\tks_pcie_clear_dbi_mode(ks_pcie);\n\n\tif (ks_pcie->is_am6)\n\t\treturn 0;\n\n\tval = ilog2(OB_WIN_SIZE);\n\tks_pcie_app_writel(ks_pcie, OB_SIZE, val);\n\n\t/* Using Direct 1:1 mapping of RC <-> PCI memory space */\n\tfor (i = 0; i < num_viewport && (start < end); i++) {\n\t\tks_pcie_app_writel(ks_pcie, OB_OFFSET_INDEX(i),\n\t\t\t\t   lower_32_bits(start) | OB_ENABLEN);\n\t\tks_pcie_app_writel(ks_pcie, OB_OFFSET_HI(i),\n\t\t\t\t   upper_32_bits(start));\n\t\tstart += OB_WIN_SIZE * SZ_1M;\n\t}\n\n\tval = ks_pcie_app_readl(ks_pcie, CMD_STATUS);\n\tval |= OB_XLAT_EN_VAL;\n\tks_pcie_app_writel(ks_pcie, CMD_STATUS, val);\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-43823"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/block/null_blk/main.c",
      "func_name": "nullb_apply_submit_queues",
      "func_body": "static int nullb_apply_submit_queues(struct nullb_device *dev,\n\t\t\t\t     unsigned int submit_queues)\n{\n\tint ret;\n\n\tmutex_lock(&lock);\n\tret = nullb_update_nr_hw_queues(dev, submit_queues, dev->poll_queues);\n\tmutex_unlock(&lock);\n\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-36478"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/block/null_blk/main.c",
      "func_name": "nullb_device_power_store",
      "func_body": "static ssize_t nullb_device_power_store(struct config_item *item,\n\t\t\t\t     const char *page, size_t count)\n{\n\tstruct nullb_device *dev = to_nullb_device(item);\n\tbool newp = false;\n\tssize_t ret;\n\n\tret = nullb_device_bool_attr_store(&newp, page, count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = count;\n\tmutex_lock(&lock);\n\tif (!dev->power && newp) {\n\t\tif (test_and_set_bit(NULLB_DEV_FL_UP, &dev->flags))\n\t\t\tgoto out;\n\n\t\tret = null_add_dev(dev);\n\t\tif (ret) {\n\t\t\tclear_bit(NULLB_DEV_FL_UP, &dev->flags);\n\t\t\tgoto out;\n\t\t}\n\n\t\tset_bit(NULLB_DEV_FL_CONFIGURED, &dev->flags);\n\t\tdev->power = newp;\n\t} else if (dev->power && !newp) {\n\t\tif (test_and_clear_bit(NULLB_DEV_FL_UP, &dev->flags)) {\n\t\t\tdev->power = newp;\n\t\t\tnull_del_dev(dev->nullb);\n\t\t}\n\t\tclear_bit(NULLB_DEV_FL_CONFIGURED, &dev->flags);\n\t}\n\nout:\n\tmutex_unlock(&lock);\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-36478"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/xe/xe_ttm_stolen_mgr.c",
      "func_name": "xe_ttm_stolen_mgr_init",
      "func_body": "void xe_ttm_stolen_mgr_init(struct xe_device *xe)\n{\n\tstruct xe_ttm_stolen_mgr *mgr = drmm_kzalloc(&xe->drm, sizeof(*mgr), GFP_KERNEL);\n\tstruct pci_dev *pdev = to_pci_dev(xe->drm.dev);\n\tu64 stolen_size, io_size, pgsize;\n\tint err;\n\n\tif (!mgr) {\n\t\tdrm_dbg_kms(&xe->drm, \"Stolen mgr init failed\\n\");\n\t\treturn;\n\t}\n\n\tif (IS_SRIOV_VF(xe))\n\t\tstolen_size = 0;\n\telse if (IS_DGFX(xe))\n\t\tstolen_size = detect_bar2_dgfx(xe, mgr);\n\telse if (GRAPHICS_VERx100(xe) >= 1270)\n\t\tstolen_size = detect_bar2_integrated(xe, mgr);\n\telse\n\t\tstolen_size = detect_stolen(xe, mgr);\n\n\tif (!stolen_size) {\n\t\tdrm_dbg_kms(&xe->drm, \"No stolen memory support\\n\");\n\t\treturn;\n\t}\n\n\tpgsize = xe->info.vram_flags & XE_VRAM_FLAGS_NEED64K ? SZ_64K : SZ_4K;\n\tif (pgsize < PAGE_SIZE)\n\t\tpgsize = PAGE_SIZE;\n\n\t/*\n\t * We don't try to attempt partial visible support for stolen vram,\n\t * since stolen is always at the end of vram, and the BAR size is pretty\n\t * much always 256M, with small-bar.\n\t */\n\tio_size = 0;\n\tif (mgr->io_base && !xe_ttm_stolen_cpu_access_needs_ggtt(xe))\n\t\tio_size = stolen_size;\n\n\terr = __xe_ttm_vram_mgr_init(xe, &mgr->base, XE_PL_STOLEN, stolen_size,\n\t\t\t\t     io_size, pgsize);\n\tif (err) {\n\t\tdrm_dbg_kms(&xe->drm, \"Stolen mgr init failed: %i\\n\", err);\n\t\treturn;\n\t}\n\n\tdrm_dbg_kms(&xe->drm, \"Initialized stolen memory support with %llu bytes\\n\",\n\t\t    stolen_size);\n\n\tif (io_size)\n\t\tmgr->mapping = devm_ioremap_wc(&pdev->dev, mgr->io_base, io_size);\n}\n",
      "cve_list": [
        "CVE-2024-42065"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/dc/hwss/dcn10/dcn10_hwseq.c",
      "func_name": "dcn10_set_drr",
      "func_body": "void dcn10_set_drr(struct pipe_ctx **pipe_ctx,\n\t\tint num_pipes, struct dc_crtc_timing_adjust adjust)\n{\n\tint i = 0;\n\tstruct drr_params params = {0};\n\t// DRR set trigger event mapped to OTG_TRIG_A (bit 11) for manual control flow\n\tunsigned int event_triggers = 0x800;\n\t// Note DRR trigger events are generated regardless of whether num frames met.\n\tunsigned int num_frames = 2;\n\n\tparams.vertical_total_max = adjust.v_total_max;\n\tparams.vertical_total_min = adjust.v_total_min;\n\tparams.vertical_total_mid = adjust.v_total_mid;\n\tparams.vertical_total_mid_frame_num = adjust.v_total_mid_frame_num;\n\t/* TODO: If multiple pipes are to be supported, you need\n\t * some GSL stuff. Static screen triggers may be programmed differently\n\t * as well.\n\t */\n\tfor (i = 0; i < num_pipes; i++) {\n\t\t/* dc_state_destruct() might null the stream resources, so fetch tg\n\t\t * here first to avoid a race condition. The lifetime of the pointee\n\t\t * itself (the timing_generator object) is not a problem here.\n\t\t */\n\t\tstruct timing_generator *tg = pipe_ctx[i]->stream_res.tg;\n\n\t\tif ((tg != NULL) && tg->funcs) {\n\t\t\tif (tg->funcs->set_drr)\n\t\t\t\ttg->funcs->set_drr(tg, &params);\n\t\t\tif (adjust.v_total_max != 0 && adjust.v_total_min != 0)\n\t\t\t\tif (tg->funcs->set_static_screen_control)\n\t\t\t\t\ttg->funcs->set_static_screen_control(\n\t\t\t\t\t\ttg, event_triggers, num_frames);\n\t\t}\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-46851"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/netfs/buffered_write.c",
      "func_name": "netfs_page_mkwrite",
      "func_body": "vm_fault_t netfs_page_mkwrite(struct vm_fault *vmf, struct netfs_group *netfs_group)\n{\n\tstruct netfs_group *group;\n\tstruct folio *folio = page_folio(vmf->page);\n\tstruct file *file = vmf->vma->vm_file;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = file_inode(file);\n\tstruct netfs_inode *ictx = netfs_inode(inode);\n\tvm_fault_t ret = VM_FAULT_RETRY;\n\tint err;\n\n\t_enter(\"%lx\", folio->index);\n\n\tsb_start_pagefault(inode->i_sb);\n\n\tif (folio_lock_killable(folio) < 0)\n\t\tgoto out;\n\tif (folio->mapping != mapping) {\n\t\tfolio_unlock(folio);\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out;\n\t}\n\n\tif (folio_wait_writeback_killable(folio)) {\n\t\tret = VM_FAULT_LOCKED;\n\t\tgoto out;\n\t}\n\n\t/* Can we see a streaming write here? */\n\tif (WARN_ON(!folio_test_uptodate(folio))) {\n\t\tret = VM_FAULT_SIGBUS | VM_FAULT_LOCKED;\n\t\tgoto out;\n\t}\n\n\tgroup = netfs_folio_group(folio);\n\tif (group != netfs_group && group != NETFS_FOLIO_COPY_TO_CACHE) {\n\t\tfolio_unlock(folio);\n\t\terr = filemap_fdatawait_range(mapping,\n\t\t\t\t\t      folio_pos(folio),\n\t\t\t\t\t      folio_pos(folio) + folio_size(folio));\n\t\tswitch (err) {\n\t\tcase 0:\n\t\t\tret = VM_FAULT_RETRY;\n\t\t\tgoto out;\n\t\tcase -ENOMEM:\n\t\t\tret = VM_FAULT_OOM;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (folio_test_dirty(folio))\n\t\ttrace_netfs_folio(folio, netfs_folio_trace_mkwrite_plus);\n\telse\n\t\ttrace_netfs_folio(folio, netfs_folio_trace_mkwrite);\n\tnetfs_set_group(folio, netfs_group);\n\tfile_update_time(file);\n\tif (ictx->ops->post_modify)\n\t\tictx->ops->post_modify(inode);\n\tret = VM_FAULT_LOCKED;\nout:\n\tsb_end_pagefault(inode->i_sb);\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-41083"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/wireless/intel/iwlwifi/mvm/ftm-initiator.c",
      "func_name": "iwl_mvm_ftm_set_secured_ranging",
      "func_body": "static void\niwl_mvm_ftm_set_secured_ranging(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t\tu8 *bssid, u8 *cipher, u8 *hltk, u8 *tk,\n\t\t\t\tu8 *rx_pn, u8 *tx_pn, __le32 *flags)\n{\n\tstruct iwl_mvm_ftm_pasn_entry *entry;\n// #ifdef CONFIG_IWLWIFI_DEBUGFS\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tif (mvmvif->ftm_unprotected)\n\t\treturn;\n#endif\n\n\tif (!(le32_to_cpu(*flags) & (IWL_INITIATOR_AP_FLAGS_NON_TB |\n\t\t       IWL_INITIATOR_AP_FLAGS_TB)))\n\t\treturn;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tlist_for_each_entry(entry, &mvm->ftm_initiator.pasn_list, list) {\n\t\tif (memcmp(entry->addr, bssid, sizeof(entry->addr)))\n\t\t\tcontinue;\n\n\t\t*cipher = entry->cipher;\n\n\t\tif (entry->flags & IWL_MVM_PASN_FLAG_HAS_HLTK)\n\t\t\tmemcpy(hltk, entry->hltk, sizeof(entry->hltk));\n\t\telse\n\t\t\tmemset(hltk, 0, sizeof(entry->hltk));\n\n\t\tif (vif->cfg.assoc &&\n\t\t    !memcmp(vif->bss_conf.bssid, bssid, ETH_ALEN)) {\n\t\t\tstruct iwl_mvm_ftm_iter_data target;\n\n\t\t\ttarget.bssid = bssid;\n\t\t\ttarget.cipher = cipher;\n\t\t\tieee80211_iter_keys(mvm->hw, vif, iter, &target);\n\t\t} else {\n\t\t\tmemcpy(tk, entry->tk, sizeof(entry->tk));\n\t\t}\n\n\t\tmemcpy(rx_pn, entry->rx_pn, sizeof(entry->rx_pn));\n\t\tmemcpy(tx_pn, entry->tx_pn, sizeof(entry->tx_pn));\n\n\t\tFTM_SET_FLAG(SECURED);\n\t\treturn;\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-49857"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/tty/serial/ma35d1_serial.c",
      "func_name": "ma35d1serial_probe",
      "func_body": "static int ma35d1serial_probe(struct platform_device *pdev)\n{\n\tstruct resource *res_mem;\n\tstruct uart_ma35d1_port *up;\n\tint ret = 0;\n\n\tif (!pdev->dev.of_node)\n\t\treturn -ENODEV;\n\n\tret = of_alias_get_id(pdev->dev.of_node, \"serial\");\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to get alias/pdev id, errno %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tup = &ma35d1serial_ports[ret];\n\tup->port.line = ret;\n\tres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res_mem)\n\t\treturn -ENODEV;\n\n\tup->port.iobase = res_mem->start;\n\tup->port.membase = ioremap(up->port.iobase, MA35_UART_REG_SIZE);\n\tif (!up->port.membase)\n\t\treturn -ENOMEM;\n\n\tup->port.ops = &ma35d1serial_ops;\n\n\tspin_lock_init(&up->port.lock);\n\n\tup->clk = of_clk_get(pdev->dev.of_node, 0);\n\tif (IS_ERR(up->clk)) {\n\t\tret = PTR_ERR(up->clk);\n\t\tdev_err(&pdev->dev, \"failed to get core clk: %d\\n\", ret);\n\t\tgoto err_iounmap;\n\t}\n\n\tret = clk_prepare_enable(up->clk);\n\tif (ret)\n\t\tgoto err_iounmap;\n\n\tif (up->port.line != 0)\n\t\tup->port.uartclk = clk_get_rate(up->clk);\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto err_clk_disable;\n\n\tup->port.irq = ret;\n\tup->port.dev = &pdev->dev;\n\tup->port.flags = UPF_BOOT_AUTOCONF;\n\n\tplatform_set_drvdata(pdev, up);\n\n\tret = uart_add_one_port(&ma35d1serial_reg, &up->port);\n\tif (ret < 0)\n\t\tgoto err_free_irq;\n\n\treturn 0;\n\nerr_free_irq:\n\tfree_irq(up->port.irq, &up->port);\n\nerr_clk_disable:\n\tclk_disable_unprepare(up->clk);\n\nerr_iounmap:\n\tiounmap(up->port.membase);\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-42248"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/wireless/realtek/rtw88/usb.c",
      "func_name": "rtw_usb_init_rx",
      "func_body": "static int rtw_usb_init_rx(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_usb *rtwusb = rtw_get_usb_priv(rtwdev);\n\n\trtwusb->rxwq = create_singlethread_workqueue(\"rtw88_usb: rx wq\");\n\tif (!rtwusb->rxwq) {\n\t\trtw_err(rtwdev, \"failed to create RX work queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_queue_head_init(&rtwusb->rx_queue);\n\n\tINIT_WORK(&rtwusb->rx_work, rtw_usb_rx_handler);\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-46760"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/wireless/realtek/rtw88/usb.c",
      "func_name": "rtw_usb_probe",
      "func_body": "int rtw_usb_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct rtw_dev *rtwdev;\n\tstruct ieee80211_hw *hw;\n\tstruct rtw_usb *rtwusb;\n\tint drv_data_size;\n\tint ret;\n\n\tdrv_data_size = sizeof(struct rtw_dev) + sizeof(struct rtw_usb);\n\thw = ieee80211_alloc_hw(drv_data_size, &rtw_ops);\n\tif (!hw)\n\t\treturn -ENOMEM;\n\n\trtwdev = hw->priv;\n\trtwdev->hw = hw;\n\trtwdev->dev = &intf->dev;\n\trtwdev->chip = (struct rtw_chip_info *)id->driver_info;\n\trtwdev->hci.ops = &rtw_usb_ops;\n\trtwdev->hci.type = RTW_HCI_TYPE_USB;\n\n\trtwusb = rtw_get_usb_priv(rtwdev);\n\trtwusb->rtwdev = rtwdev;\n\n\tret = rtw_usb_alloc_rx_bufs(rtwusb);\n\tif (ret)\n\t\tgoto err_release_hw;\n\n\tret = rtw_core_init(rtwdev);\n\tif (ret)\n\t\tgoto err_free_rx_bufs;\n\n\tret = rtw_usb_intf_init(rtwdev, intf);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to init USB interface\\n\");\n\t\tgoto err_deinit_core;\n\t}\n\n\tret = rtw_usb_init_tx(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to init USB TX\\n\");\n\t\tgoto err_destroy_usb;\n\t}\n\n\tret = rtw_usb_init_rx(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to init USB RX\\n\");\n\t\tgoto err_destroy_txwq;\n\t}\n\n\tret = rtw_chip_info_setup(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to setup chip information\\n\");\n\t\tgoto err_destroy_rxwq;\n\t}\n\n\tret = rtw_register_hw(rtwdev, rtwdev->hw);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to register hw\\n\");\n\t\tgoto err_destroy_rxwq;\n\t}\n\n\trtw_usb_setup_rx(rtwdev);\n\n\treturn 0;\n\nerr_destroy_rxwq:\n\trtw_usb_deinit_rx(rtwdev);\n\nerr_destroy_txwq:\n\trtw_usb_deinit_tx(rtwdev);\n\nerr_destroy_usb:\n\trtw_usb_intf_deinit(rtwdev, intf);\n\nerr_deinit_core:\n\trtw_core_deinit(rtwdev);\n\nerr_free_rx_bufs:\n\trtw_usb_free_rx_bufs(rtwusb);\n\nerr_release_hw:\n\tieee80211_free_hw(hw);\n\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-46760"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/msm/disp/dpu1/dpu_encoder.c",
      "func_name": "dpu_encoder_virt_atomic_enable",
      "func_body": "static void dpu_encoder_virt_atomic_enable(struct drm_encoder *drm_enc,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct dpu_encoder_virt *dpu_enc = NULL;\n\tint ret = 0;\n\tstruct drm_display_mode *cur_mode = NULL;\n\n\tdpu_enc = to_dpu_encoder_virt(drm_enc);\n\tdpu_enc->dsc = dpu_encoder_get_dsc_config(drm_enc);\n\n\tatomic_set(&dpu_enc->frame_done_timeout_cnt, 0);\n\n\tmutex_lock(&dpu_enc->enc_lock);\n\n\tdpu_enc->commit_done_timedout = false;\n\n\tdpu_enc->connector = drm_atomic_get_new_connector_for_encoder(state, drm_enc);\n\n\tcur_mode = &dpu_enc->base.crtc->state->adjusted_mode;\n\n\tdpu_enc->wide_bus_en = dpu_encoder_is_widebus_enabled(drm_enc);\n\n\ttrace_dpu_enc_enable(DRMID(drm_enc), cur_mode->hdisplay,\n\t\t\t     cur_mode->vdisplay);\n\n\t/* always enable slave encoder before master */\n\tif (dpu_enc->cur_slave && dpu_enc->cur_slave->ops.enable)\n\t\tdpu_enc->cur_slave->ops.enable(dpu_enc->cur_slave);\n\n\tif (dpu_enc->cur_master && dpu_enc->cur_master->ops.enable)\n\t\tdpu_enc->cur_master->ops.enable(dpu_enc->cur_master);\n\n\tret = dpu_encoder_resource_control(drm_enc, DPU_ENC_RC_EVENT_KICKOFF);\n\tif (ret) {\n\t\tDPU_ERROR_ENC(dpu_enc, \"dpu resource control failed: %d\\n\",\n\t\t\t\tret);\n\t\tgoto out;\n\t}\n\n\t_dpu_encoder_virt_enable_helper(drm_enc);\n\n\tdpu_enc->enabled = true;\n\nout:\n\tmutex_unlock(&dpu_enc->enc_lock);\n}\n",
      "cve_list": [
        "CVE-2024-45015"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/usb/host/xhci.c",
      "func_name": "xhci_configure_endpoint",
      "func_body": "static int xhci_configure_endpoint(struct xhci_hcd *xhci,\n\t\tstruct usb_device *udev,\n\t\tstruct xhci_command *command,\n\t\tbool ctx_change, bool must_succeed)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct xhci_input_control_ctx *ctrl_ctx;\n\tstruct xhci_virt_device *virt_dev;\n\tstruct xhci_slot_ctx *slot_ctx;\n\n\tif (!command)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&xhci->lock, flags);\n\n\tif (xhci->xhc_state & XHCI_STATE_DYING) {\n\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tvirt_dev = xhci->devs[udev->slot_id];\n\n\tctrl_ctx = xhci_get_input_control_ctx(command->in_ctx);\n\tif (!ctrl_ctx) {\n\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\txhci_warn(xhci, \"%s: Could not get input context, bad type.\\n\",\n\t\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tif ((xhci->quirks & XHCI_EP_LIMIT_QUIRK) &&\n\t\t\txhci_reserve_host_resources(xhci, ctrl_ctx)) {\n\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\txhci_warn(xhci, \"Not enough host resources, \"\n\t\t\t\t\"active endpoint contexts = %u\\n\",\n\t\t\t\txhci->num_active_eps);\n\t\treturn -ENOMEM;\n\t}\n\tif ((xhci->quirks & XHCI_SW_BW_CHECKING) && !ctx_change &&\n\t    xhci_reserve_bandwidth(xhci, virt_dev, command->in_ctx)) {\n\t\tif ((xhci->quirks & XHCI_EP_LIMIT_QUIRK))\n\t\t\txhci_free_host_resources(xhci, ctrl_ctx);\n\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\txhci_warn(xhci, \"Not enough bandwidth\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tslot_ctx = xhci_get_slot_ctx(xhci, command->in_ctx);\n\n\ttrace_xhci_configure_endpoint_ctrl_ctx(ctrl_ctx);\n\ttrace_xhci_configure_endpoint(slot_ctx);\n\n\tif (!ctx_change)\n\t\tret = xhci_queue_configure_endpoint(xhci, command,\n\t\t\t\tcommand->in_ctx->dma,\n\t\t\t\tudev->slot_id, must_succeed);\n\telse\n\t\tret = xhci_queue_evaluate_context(xhci, command,\n\t\t\t\tcommand->in_ctx->dma,\n\t\t\t\tudev->slot_id, must_succeed);\n\tif (ret < 0) {\n\t\tif ((xhci->quirks & XHCI_EP_LIMIT_QUIRK))\n\t\t\txhci_free_host_resources(xhci, ctrl_ctx);\n\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\txhci_dbg_trace(xhci,  trace_xhci_dbg_context_change,\n\t\t\t\t\"FIXME allocate a new ring segment\");\n\t\treturn -ENOMEM;\n\t}\n\txhci_ring_cmd_db(xhci);\n\tspin_unlock_irqrestore(&xhci->lock, flags);\n\n\t/* Wait for the configure endpoint command to complete */\n\twait_for_completion(command->completion);\n\n\tif (!ctx_change)\n\t\tret = xhci_configure_endpoint_result(xhci, udev,\n\t\t\t\t\t\t     &command->status);\n\telse\n\t\tret = xhci_evaluate_context_result(xhci, udev,\n\t\t\t\t\t\t   &command->status);\n\n\tif ((xhci->quirks & XHCI_EP_LIMIT_QUIRK)) {\n\t\tspin_lock_irqsave(&xhci->lock, flags);\n\t\t/* If the command failed, remove the reserved resources.\n\t\t * Otherwise, clean up the estimate to include dropped eps.\n\t\t */\n\t\tif (ret)\n\t\t\txhci_free_host_resources(xhci, ctrl_ctx);\n\t\telse\n\t\t\txhci_finish_resource_reservation(xhci, ctrl_ctx);\n\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t}\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-45006"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ipv6/ip6_fib.c",
      "func_name": "__fib6_drop_pcpu_from",
      "func_body": "static void __fib6_drop_pcpu_from(struct fib6_nh *fib6_nh,\n\t\t\t\t  const struct fib6_info *match,\n\t\t\t\t  const struct fib6_table *table)\n{\n\tint cpu;\n\n\tif (!fib6_nh->rt6i_pcpu)\n\t\treturn;\n\n\trcu_read_lock();\n\t/* release the reference to this fib entry from\n\t * all of its cached pcpu routes\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct rt6_info **ppcpu_rt;\n\t\tstruct rt6_info *pcpu_rt;\n\n\t\tppcpu_rt = per_cpu_ptr(fib6_nh->rt6i_pcpu, cpu);\n\n\t\t/* Paired with xchg() in rt6_get_pcpu_route() */\n\t\tpcpu_rt = READ_ONCE(*ppcpu_rt);\n\n\t\t/* only dropping the 'from' reference if the cached route\n\t\t * is using 'match'. The cached pcpu_rt->from only changes\n\t\t * from a fib6_info to NULL (ip6_dst_destroy); it can never\n\t\t * change from one fib6_info reference to another\n\t\t */\n\t\tif (pcpu_rt && rcu_access_pointer(pcpu_rt->from) == match) {\n\t\t\tstruct fib6_info *from;\n\n\t\t\tfrom = xchg((__force struct fib6_info **)&pcpu_rt->from, NULL);\n\t\t\tfib6_info_release(from);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n",
      "cve_list": [
        "CVE-2024-40905"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ipv6/route.c",
      "func_name": "rt6_get_pcpu_route",
      "func_body": "static struct rt6_info *rt6_get_pcpu_route(const struct fib6_result *res)\n{\n\tstruct rt6_info *pcpu_rt;\n\n\tpcpu_rt = this_cpu_read(*res->nh->rt6i_pcpu);\n\n\tif (pcpu_rt && pcpu_rt->sernum && !rt6_is_valid(pcpu_rt)) {\n\t\tstruct rt6_info *prev, **p;\n\n\t\tp = this_cpu_ptr(res->nh->rt6i_pcpu);\n\t\t/* Paired with READ_ONCE() in __fib6_drop_pcpu_from() */\n\t\tprev = xchg(p, NULL);\n\t\tif (prev) {\n\t\t\tdst_dev_put(&prev->dst);\n\t\t\tdst_release(&prev->dst);\n\t\t}\n\n\t\tpcpu_rt = NULL;\n\t}\n\n\treturn pcpu_rt;\n}\n",
      "cve_list": [
        "CVE-2024-40905"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/media/platform/mediatek/vcodec/decoder/vdec/vdec_vp8_req_if.c",
      "func_name": "vdec_vp8_slice_decode",
      "func_body": "static int vdec_vp8_slice_decode(void *h_vdec, struct mtk_vcodec_mem *bs,\n\t\t\t\t struct vdec_fb *fb, bool *res_chg)\n{\n\tstruct vdec_vp8_slice_inst *inst = h_vdec;\n\tstruct vdec_vpu_inst *vpu = &inst->vpu;\n\tstruct mtk_video_dec_buf *src_buf_info, *dst_buf_info;\n\tunsigned int data;\n\tu64 y_fb_dma, c_fb_dma;\n\tint err, timeout;\n\n\t/* Resolution changes are never initiated by us */\n\t*res_chg = false;\n\n\t/* bs NULL means flush decoder */\n\tif (!bs)\n\t\treturn vpu_dec_reset(vpu);\n\n\tsrc_buf_info = container_of(bs, struct mtk_video_dec_buf, bs_buffer);\n\n\tfb = inst->ctx->dev->vdec_pdata->get_cap_buffer(inst->ctx);\n\tif (!fb) {\n\t\tmtk_vdec_err(inst->ctx, \"fb buffer is NULL\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdst_buf_info = container_of(fb, struct mtk_video_dec_buf, frame_buffer);\n\ty_fb_dma = fb->base_y.dma_addr;\n\tif (inst->ctx->q_data[MTK_Q_DATA_DST].fmt->num_planes == 1)\n\t\tc_fb_dma = y_fb_dma +\n\t\t\tinst->ctx->picinfo.buf_w * inst->ctx->picinfo.buf_h;\n\telse\n\t\tc_fb_dma = fb->base_c.dma_addr;\n\n\tinst->vsi->dec.bs_dma = (u64)bs->dma_addr;\n\tinst->vsi->dec.bs_sz = bs->size;\n\tinst->vsi->dec.cur_y_fb_dma = y_fb_dma;\n\tinst->vsi->dec.cur_c_fb_dma = c_fb_dma;\n\n\tmtk_vdec_debug(inst->ctx, \"frame[%d] bs(%zu 0x%llx) y/c(0x%llx 0x%llx)\",\n\t\t       inst->ctx->decoded_frame_cnt,\n\t\t       bs->size, (u64)bs->dma_addr,\n\t\t       y_fb_dma, c_fb_dma);\n\n\tv4l2_m2m_buf_copy_metadata(&src_buf_info->m2m_buf.vb,\n\t\t\t\t   &dst_buf_info->m2m_buf.vb, true);\n\n\terr = vdec_vp8_slice_get_decode_parameters(inst);\n\tif (err)\n\t\tgoto error;\n\n\terr = vpu_dec_start(vpu, &data, 1);\n\tif (err) {\n\t\tmtk_vdec_debug(inst->ctx, \"vp8 dec start err!\");\n\t\tgoto error;\n\t}\n\n\tif (inst->vsi->dec.resolution_changed) {\n\t\tmtk_vdec_debug(inst->ctx, \"- resolution_changed -\");\n\t\t*res_chg = true;\n\t\treturn 0;\n\t}\n\n\t/* wait decode done interrupt */\n\ttimeout = mtk_vcodec_wait_for_done_ctx(inst->ctx, MTK_INST_IRQ_RECEIVED,\n\t\t\t\t\t       50, MTK_VDEC_CORE);\n\n\terr = vpu_dec_end(vpu);\n\tif (err || timeout)\n\t\tmtk_vdec_debug(inst->ctx, \"vp8 dec error timeout:%d err: %d pic_%d\",\n\t\t\t       timeout, err, inst->ctx->decoded_frame_cnt);\n\n\tmtk_vdec_debug(inst->ctx, \"pic[%d] crc: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\",\n\t\t       inst->ctx->decoded_frame_cnt,\n\t\t       inst->vsi->dec.crc[0], inst->vsi->dec.crc[1],\n\t\t       inst->vsi->dec.crc[2], inst->vsi->dec.crc[3],\n\t\t       inst->vsi->dec.crc[4], inst->vsi->dec.crc[5],\n\t\t       inst->vsi->dec.crc[6], inst->vsi->dec.crc[7]);\n\n\tinst->ctx->decoded_frame_cnt++;\nerror:\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-47753"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/xe/xe_devcoredump.c",
      "func_name": "xe_devcoredump_read",
      "func_body": "static ssize_t xe_devcoredump_read(char *buffer, loff_t offset,\n\t\t\t\t   size_t count, void *data, size_t datalen)\n{\n\tstruct xe_devcoredump *coredump = data;\n\tstruct xe_device *xe;\n\tstruct xe_devcoredump_snapshot *ss;\n\tstruct drm_printer p;\n\tstruct drm_print_iterator iter;\n\tstruct timespec64 ts;\n\tint i;\n\n\tif (!coredump)\n\t\treturn -ENODEV;\n\n\txe = coredump_to_xe(coredump);\n\tss = &coredump->snapshot;\n\n\t/* Ensure delayed work is captured before continuing */\n\tflush_work(&ss->work);\n\n\titer.data = buffer;\n\titer.offset = 0;\n\titer.start = offset;\n\titer.remain = count;\n\n\tp = drm_coredump_printer(&iter);\n\n\tdrm_printf(&p, \"**** Xe Device Coredump ****\\n\");\n\tdrm_printf(&p, \"kernel: \" UTS_RELEASE \"\\n\");\n\tdrm_printf(&p, \"module: \" KBUILD_MODNAME \"\\n\");\n\n\tts = ktime_to_timespec64(ss->snapshot_time);\n\tdrm_printf(&p, \"Snapshot time: %lld.%09ld\\n\", ts.tv_sec, ts.tv_nsec);\n\tts = ktime_to_timespec64(ss->boot_time);\n\tdrm_printf(&p, \"Uptime: %lld.%09ld\\n\", ts.tv_sec, ts.tv_nsec);\n\txe_device_snapshot_print(xe, &p);\n\n\tdrm_printf(&p, \"\\n**** GuC CT ****\\n\");\n\txe_guc_ct_snapshot_print(coredump->snapshot.ct, &p);\n\txe_guc_exec_queue_snapshot_print(coredump->snapshot.ge, &p);\n\n\tdrm_printf(&p, \"\\n**** Job ****\\n\");\n\txe_sched_job_snapshot_print(coredump->snapshot.job, &p);\n\n\tdrm_printf(&p, \"\\n**** HW Engines ****\\n\");\n\tfor (i = 0; i < XE_NUM_HW_ENGINES; i++)\n\t\tif (coredump->snapshot.hwe[i])\n\t\t\txe_hw_engine_snapshot_print(coredump->snapshot.hwe[i],\n\t\t\t\t\t\t    &p);\n\tdrm_printf(&p, \"\\n**** VM state ****\\n\");\n\txe_vm_snapshot_print(coredump->snapshot.vm, &p);\n\n\treturn count - iter.remain;\n}\n",
      "cve_list": [
        "CVE-2024-42081"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/mellanox/mlx5/core/esw/legacy.c",
      "func_name": "mlx5_eswitch_set_vepa",
      "func_body": "int mlx5_eswitch_set_vepa(struct mlx5_eswitch *esw, u8 setting)\n{\n\tint err = 0;\n\n\tif (!esw)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!mlx5_esw_allowed(esw))\n\t\treturn -EPERM;\n\n\tmutex_lock(&esw->state_lock);\n\tif (esw->mode != MLX5_ESWITCH_LEGACY || !mlx5_esw_is_fdb_created(esw)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = _mlx5_eswitch_set_vepa_locked(esw, setting);\n\nout:\n\tmutex_unlock(&esw->state_lock);\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-46857"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/amdgpu/amdgpu_device.c",
      "func_name": "amdgpu_device_gpu_recover",
      "func_body": "int amdgpu_device_gpu_recover(struct amdgpu_device *adev,\n\t\t\t      struct amdgpu_job *job,\n\t\t\t      struct amdgpu_reset_context *reset_context)\n{\n\tstruct list_head device_list, *device_list_handle =  NULL;\n\tbool job_signaled = false;\n\tstruct amdgpu_hive_info *hive = NULL;\n\tstruct amdgpu_device *tmp_adev = NULL;\n\tint i, r = 0;\n\tbool need_emergency_restart = false;\n\tbool audio_suspended = false;\n\tint retry_limit = AMDGPU_MAX_RETRY_LIMIT;\n\n\t/*\n\t * Special case: RAS triggered and full reset isn't supported\n\t */\n\tneed_emergency_restart = amdgpu_ras_need_emergency_restart(adev);\n\n\t/*\n\t * Flush RAM to disk so that after reboot\n\t * the user can read log and see why the system rebooted.\n\t */\n\tif (need_emergency_restart && amdgpu_ras_get_context(adev) &&\n\t\tamdgpu_ras_get_context(adev)->reboot) {\n\t\tDRM_WARN(\"Emergency reboot.\");\n\n\t\tksys_sync_helper();\n\t\temergency_restart();\n\t}\n\n\tdev_info(adev->dev, \"GPU %s begin!\\n\",\n\t\tneed_emergency_restart ? \"jobs stop\":\"reset\");\n\n\tif (!amdgpu_sriov_vf(adev))\n\t\thive = amdgpu_get_xgmi_hive(adev);\n\tif (hive)\n\t\tmutex_lock(&hive->hive_lock);\n\n\treset_context->job = job;\n\treset_context->hive = hive;\n\t/*\n\t * Build list of devices to reset.\n\t * In case we are in XGMI hive mode, resort the device list\n\t * to put adev in the 1st position.\n\t */\n\tINIT_LIST_HEAD(&device_list);\n\tif (!amdgpu_sriov_vf(adev) && (adev->gmc.xgmi.num_physical_nodes > 1) && hive) {\n\t\tlist_for_each_entry(tmp_adev, &hive->device_list, gmc.xgmi.head) {\n\t\t\tlist_add_tail(&tmp_adev->reset_list, &device_list);\n\t\t\tif (adev->shutdown)\n\t\t\t\ttmp_adev->shutdown = true;\n\t\t}\n\t\tif (!list_is_first(&adev->reset_list, &device_list))\n\t\t\tlist_rotate_to_front(&adev->reset_list, &device_list);\n\t\tdevice_list_handle = &device_list;\n\t} else {\n\t\tlist_add_tail(&adev->reset_list, &device_list);\n\t\tdevice_list_handle = &device_list;\n\t}\n\n\tif (!amdgpu_sriov_vf(adev)) {\n\t\tr = amdgpu_device_health_check(device_list_handle);\n\t\tif (r)\n\t\t\tgoto end_reset;\n\t}\n\n\t/* We need to lock reset domain only once both for XGMI and single device */\n\ttmp_adev = list_first_entry(device_list_handle, struct amdgpu_device,\n\t\t\t\t    reset_list);\n\tamdgpu_device_lock_reset_domain(tmp_adev->reset_domain);\n\n\t/* block all schedulers and reset given job's ring */\n\tlist_for_each_entry(tmp_adev, device_list_handle, reset_list) {\n\n\t\tamdgpu_device_set_mp1_state(tmp_adev);\n\n\t\t/*\n\t\t * Try to put the audio codec into suspend state\n\t\t * before gpu reset started.\n\t\t *\n\t\t * Due to the power domain of the graphics device\n\t\t * is shared with AZ power domain. Without this,\n\t\t * we may change the audio hardware from behind\n\t\t * the audio driver's back. That will trigger\n\t\t * some audio codec errors.\n\t\t */\n\t\tif (!amdgpu_device_suspend_display_audio(tmp_adev))\n\t\t\taudio_suspended = true;\n\n\t\tamdgpu_ras_set_error_query_ready(tmp_adev, false);\n\n\t\tcancel_delayed_work_sync(&tmp_adev->delayed_init_work);\n\n\t\tamdgpu_amdkfd_pre_reset(tmp_adev);\n\n\t\t/*\n\t\t * Mark these ASICs to be reseted as untracked first\n\t\t * And add them back after reset completed\n\t\t */\n\t\tamdgpu_unregister_gpu_instance(tmp_adev);\n\n\t\tdrm_fb_helper_set_suspend_unlocked(adev_to_drm(tmp_adev)->fb_helper, true);\n\n\t\t/* disable ras on ALL IPs */\n\t\tif (!need_emergency_restart &&\n\t\t      amdgpu_device_ip_need_full_reset(tmp_adev))\n\t\t\tamdgpu_ras_suspend(tmp_adev);\n\n\t\tfor (i = 0; i < AMDGPU_MAX_RINGS; ++i) {\n\t\t\tstruct amdgpu_ring *ring = tmp_adev->rings[i];\n\n\t\t\tif (!amdgpu_ring_sched_ready(ring))\n\t\t\t\tcontinue;\n\n\t\t\tdrm_sched_stop(&ring->sched, job ? &job->base : NULL);\n\n\t\t\tif (need_emergency_restart)\n\t\t\t\tamdgpu_job_stop_all_jobs_on_sched(&ring->sched);\n\t\t}\n\t\tatomic_inc(&tmp_adev->gpu_reset_counter);\n\t}\n\n\tif (need_emergency_restart)\n\t\tgoto skip_sched_resume;\n\n\t/*\n\t * Must check guilty signal here since after this point all old\n\t * HW fences are force signaled.\n\t *\n\t * job->base holds a reference to parent fence\n\t */\n\tif (job && dma_fence_is_signaled(&job->hw_fence)) {\n\t\tjob_signaled = true;\n\t\tdev_info(adev->dev, \"Guilty job already signaled, skipping HW reset\");\n\t\tgoto skip_hw_reset;\n\t}\n\nretry:\t/* Rest of adevs pre asic reset from XGMI hive. */\n\tlist_for_each_entry(tmp_adev, device_list_handle, reset_list) {\n\t\tr = amdgpu_device_pre_asic_reset(tmp_adev, reset_context);\n\t\t/*TODO Should we stop ?*/\n\t\tif (r) {\n\t\t\tdev_err(tmp_adev->dev, \"GPU pre asic reset failed with err, %d for drm dev, %s \",\n\t\t\t\t  r, adev_to_drm(tmp_adev)->unique);\n\t\t\ttmp_adev->asic_reset_res = r;\n\t\t}\n\t}\n\n\t/* Actual ASIC resets if needed.*/\n\t/* Host driver will handle XGMI hive reset for SRIOV */\n\tif (amdgpu_sriov_vf(adev)) {\n\t\tr = amdgpu_device_reset_sriov(adev, reset_context);\n\t\tif (AMDGPU_RETRY_SRIOV_RESET(r) && (retry_limit--) > 0) {\n\t\t\tamdgpu_virt_release_full_gpu(adev, true);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (r)\n\t\t\tadev->asic_reset_res = r;\n\t} else {\n\t\tr = amdgpu_do_asic_reset(device_list_handle, reset_context);\n\t\tif (r && r == -EAGAIN)\n\t\t\tgoto retry;\n\t}\n\n\tlist_for_each_entry(tmp_adev, device_list_handle, reset_list) {\n\t\t/*\n\t\t * Drop any pending non scheduler resets queued before reset is done.\n\t\t * Any reset scheduled after this point would be valid. Scheduler resets\n\t\t * were already dropped during drm_sched_stop and no new ones can come\n\t\t * in before drm_sched_start.\n\t\t */\n\t\tamdgpu_device_stop_pending_resets(tmp_adev);\n\t}\n\nskip_hw_reset:\n\n\t/* Post ASIC reset for all devs .*/\n\tlist_for_each_entry(tmp_adev, device_list_handle, reset_list) {\n\n\t\tfor (i = 0; i < AMDGPU_MAX_RINGS; ++i) {\n\t\t\tstruct amdgpu_ring *ring = tmp_adev->rings[i];\n\n\t\t\tif (!amdgpu_ring_sched_ready(ring))\n\t\t\t\tcontinue;\n\n\t\t\tdrm_sched_start(&ring->sched, true);\n\t\t}\n\n\t\tif (!drm_drv_uses_atomic_modeset(adev_to_drm(tmp_adev)) && !job_signaled)\n\t\t\tdrm_helper_resume_force_mode(adev_to_drm(tmp_adev));\n\n\t\tif (tmp_adev->asic_reset_res)\n\t\t\tr = tmp_adev->asic_reset_res;\n\n\t\ttmp_adev->asic_reset_res = 0;\n\n\t\tif (r) {\n\t\t\t/* bad news, how to tell it to userspace ? */\n\t\t\tdev_info(tmp_adev->dev, \"GPU reset(%d) failed\\n\", atomic_read(&tmp_adev->gpu_reset_counter));\n\t\t\tamdgpu_vf_error_put(tmp_adev, AMDGIM_ERROR_VF_GPU_RESET_FAIL, 0, r);\n\t\t} else {\n\t\t\tdev_info(tmp_adev->dev, \"GPU reset(%d) succeeded!\\n\", atomic_read(&tmp_adev->gpu_reset_counter));\n\t\t\tif (amdgpu_acpi_smart_shift_update(adev_to_drm(tmp_adev), AMDGPU_SS_DEV_D0))\n\t\t\t\tDRM_WARN(\"smart shift update failed\\n\");\n\t\t}\n\t}\n\nskip_sched_resume:\n\tlist_for_each_entry(tmp_adev, device_list_handle, reset_list) {\n\t\t/* unlock kfd: SRIOV would do it separately */\n\t\tif (!need_emergency_restart && !amdgpu_sriov_vf(tmp_adev))\n\t\t\tamdgpu_amdkfd_post_reset(tmp_adev);\n\n\t\t/* kfd_post_reset will do nothing if kfd device is not initialized,\n\t\t * need to bring up kfd here if it's not be initialized before\n\t\t */\n\t\tif (!adev->kfd.init_complete)\n\t\t\tamdgpu_amdkfd_device_init(adev);\n\n\t\tif (audio_suspended)\n\t\t\tamdgpu_device_resume_display_audio(tmp_adev);\n\n\t\tamdgpu_device_unset_mp1_state(tmp_adev);\n\n\t\tamdgpu_ras_set_error_query_ready(tmp_adev, true);\n\t}\n\n\ttmp_adev = list_first_entry(device_list_handle, struct amdgpu_device,\n\t\t\t\t\t    reset_list);\n\tamdgpu_device_unlock_reset_domain(tmp_adev->reset_domain);\n\nend_reset:\n\tif (hive) {\n\t\tmutex_unlock(&hive->hive_lock);\n\t\tamdgpu_put_xgmi_hive(hive);\n\t}\n\n\tif (r)\n\t\tdev_info(adev->dev, \"GPU reset end with ret = %d\\n\", r);\n\n\tatomic_set(&adev->reset_domain->reset_res, r);\n\treturn r;\n}\n",
      "cve_list": [
        "CVE-2024-46720"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/ti/icssg/icssg_prueth.c",
      "func_name": "prueth_probe",
      "func_body": "static int prueth_probe(struct platform_device *pdev)\n{\n\tstruct device_node *eth_node, *eth_ports_node;\n\tstruct device_node  *eth0_node = NULL;\n\tstruct device_node  *eth1_node = NULL;\n\tstruct genpool_data_align gp_data = {\n\t\t.align = SZ_64K,\n\t};\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np;\n\tstruct prueth *prueth;\n\tstruct pruss *pruss;\n\tu32 msmc_ram_size;\n\tint i, ret;\n\n\tnp = dev->of_node;\n\n\tprueth = devm_kzalloc(dev, sizeof(*prueth), GFP_KERNEL);\n\tif (!prueth)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, prueth);\n\tprueth->pdev = pdev;\n\tprueth->pdata = *(const struct prueth_pdata *)device_get_match_data(dev);\n\n\tprueth->dev = dev;\n\teth_ports_node = of_get_child_by_name(np, \"ethernet-ports\");\n\tif (!eth_ports_node)\n\t\treturn -ENOENT;\n\n\tfor_each_child_of_node(eth_ports_node, eth_node) {\n\t\tu32 reg;\n\n\t\tif (strcmp(eth_node->name, \"port\"))\n\t\t\tcontinue;\n\t\tret = of_property_read_u32(eth_node, \"reg\", &reg);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%pOF error reading port_id %d\\n\",\n\t\t\t\teth_node, ret);\n\t\t}\n\n\t\tof_node_get(eth_node);\n\n\t\tif (reg == 0) {\n\t\t\teth0_node = eth_node;\n\t\t\tif (!of_device_is_available(eth0_node)) {\n\t\t\t\tof_node_put(eth0_node);\n\t\t\t\teth0_node = NULL;\n\t\t\t}\n\t\t} else if (reg == 1) {\n\t\t\teth1_node = eth_node;\n\t\t\tif (!of_device_is_available(eth1_node)) {\n\t\t\t\tof_node_put(eth1_node);\n\t\t\t\teth1_node = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tdev_err(dev, \"port reg should be 0 or 1\\n\");\n\t\t}\n\t}\n\n\tof_node_put(eth_ports_node);\n\n\t/* At least one node must be present and available else we fail */\n\tif (!eth0_node && !eth1_node) {\n\t\tdev_err(dev, \"neither port0 nor port1 node available\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (eth0_node == eth1_node) {\n\t\tdev_err(dev, \"port0 and port1 can't have same reg\\n\");\n\t\tof_node_put(eth0_node);\n\t\treturn -ENODEV;\n\t}\n\n\tprueth->eth_node[PRUETH_MAC0] = eth0_node;\n\tprueth->eth_node[PRUETH_MAC1] = eth1_node;\n\n\tprueth->miig_rt = syscon_regmap_lookup_by_phandle(np, \"ti,mii-g-rt\");\n\tif (IS_ERR(prueth->miig_rt)) {\n\t\tdev_err(dev, \"couldn't get ti,mii-g-rt syscon regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tprueth->mii_rt = syscon_regmap_lookup_by_phandle(np, \"ti,mii-rt\");\n\tif (IS_ERR(prueth->mii_rt)) {\n\t\tdev_err(dev, \"couldn't get ti,mii-rt syscon regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (eth0_node) {\n\t\tret = prueth_get_cores(prueth, ICSS_SLICE0, false);\n\t\tif (ret)\n\t\t\tgoto put_cores;\n\t}\n\n\tif (eth1_node) {\n\t\tret = prueth_get_cores(prueth, ICSS_SLICE1, false);\n\t\tif (ret)\n\t\t\tgoto put_cores;\n\t}\n\n\tpruss = pruss_get(eth0_node ?\n\t\t\t  prueth->pru[ICSS_SLICE0] : prueth->pru[ICSS_SLICE1]);\n\tif (IS_ERR(pruss)) {\n\t\tret = PTR_ERR(pruss);\n\t\tdev_err(dev, \"unable to get pruss handle\\n\");\n\t\tgoto put_cores;\n\t}\n\n\tprueth->pruss = pruss;\n\n\tret = pruss_request_mem_region(pruss, PRUSS_MEM_SHRD_RAM2,\n\t\t\t\t       &prueth->shram);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to get PRUSS SHRD RAM2: %d\\n\", ret);\n\t\tgoto put_pruss;\n\t}\n\n\tprueth->sram_pool = of_gen_pool_get(np, \"sram\", 0);\n\tif (!prueth->sram_pool) {\n\t\tdev_err(dev, \"unable to get SRAM pool\\n\");\n\t\tret = -ENODEV;\n\n\t\tgoto put_mem;\n\t}\n\n\tmsmc_ram_size = MSMC_RAM_SIZE;\n\n\t/* NOTE: FW bug needs buffer base to be 64KB aligned */\n\tprueth->msmcram.va =\n\t\t(void __iomem *)gen_pool_alloc_algo(prueth->sram_pool,\n\t\t\t\t\t\t    msmc_ram_size,\n\t\t\t\t\t\t    gen_pool_first_fit_align,\n\t\t\t\t\t\t    &gp_data);\n\n\tif (!prueth->msmcram.va) {\n\t\tret = -ENOMEM;\n\t\tdev_err(dev, \"unable to allocate MSMC resource\\n\");\n\t\tgoto put_mem;\n\t}\n\tprueth->msmcram.pa = gen_pool_virt_to_phys(prueth->sram_pool,\n\t\t\t\t\t\t   (unsigned long)prueth->msmcram.va);\n\tprueth->msmcram.size = msmc_ram_size;\n\tmemset_io(prueth->msmcram.va, 0, msmc_ram_size);\n\tdev_dbg(dev, \"sram: pa %llx va %p size %zx\\n\", prueth->msmcram.pa,\n\t\tprueth->msmcram.va, prueth->msmcram.size);\n\n\tprueth->iep0 = icss_iep_get_idx(np, 0);\n\tif (IS_ERR(prueth->iep0)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(prueth->iep0), \"iep0 get failed\\n\");\n\t\tprueth->iep0 = NULL;\n\t\tgoto free_pool;\n\t}\n\n\tprueth->iep1 = icss_iep_get_idx(np, 1);\n\tif (IS_ERR(prueth->iep1)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(prueth->iep1), \"iep1 get failed\\n\");\n\t\tgoto put_iep0;\n\t}\n\n\tif (prueth->pdata.quirk_10m_link_issue) {\n\t\t/* Enable IEP1 for FW in 64bit mode as W/A for 10M FD link detect issue under TX\n\t\t * traffic.\n\t\t */\n\t\ticss_iep_init_fw(prueth->iep1);\n\t}\n\n\t/* setup netdev interfaces */\n\tif (eth0_node) {\n\t\tret = prueth_netdev_init(prueth, eth0_node);\n\t\tif (ret) {\n\t\t\tdev_err_probe(dev, ret, \"netdev init %s failed\\n\",\n\t\t\t\t      eth0_node->name);\n\t\t\tgoto exit_iep;\n\t\t}\n\n\t\tif (of_find_property(eth0_node, \"ti,half-duplex-capable\", NULL))\n\t\t\tprueth->emac[PRUETH_MAC0]->half_duplex = 1;\n\n\t\tprueth->emac[PRUETH_MAC0]->iep = prueth->iep0;\n\t}\n\n\tif (eth1_node) {\n\t\tret = prueth_netdev_init(prueth, eth1_node);\n\t\tif (ret) {\n\t\t\tdev_err_probe(dev, ret, \"netdev init %s failed\\n\",\n\t\t\t\t      eth1_node->name);\n\t\t\tgoto netdev_exit;\n\t\t}\n\n\t\tif (of_find_property(eth1_node, \"ti,half-duplex-capable\", NULL))\n\t\t\tprueth->emac[PRUETH_MAC1]->half_duplex = 1;\n\n\t\tprueth->emac[PRUETH_MAC1]->iep = prueth->iep0;\n\t}\n\n\t/* register the network devices */\n\tif (eth0_node) {\n\t\tret = register_netdev(prueth->emac[PRUETH_MAC0]->ndev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"can't register netdev for port MII0\");\n\t\t\tgoto netdev_exit;\n\t\t}\n\n\t\tprueth->registered_netdevs[PRUETH_MAC0] = prueth->emac[PRUETH_MAC0]->ndev;\n\n\t\tret = emac_phy_connect(prueth->emac[PRUETH_MAC0]);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"can't connect to MII0 PHY, error -%d\", ret);\n\t\t\tgoto netdev_unregister;\n\t\t}\n\t\tphy_attached_info(prueth->emac[PRUETH_MAC0]->ndev->phydev);\n\t}\n\n\tif (eth1_node) {\n\t\tret = register_netdev(prueth->emac[PRUETH_MAC1]->ndev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"can't register netdev for port MII1\");\n\t\t\tgoto netdev_unregister;\n\t\t}\n\n\t\tprueth->registered_netdevs[PRUETH_MAC1] = prueth->emac[PRUETH_MAC1]->ndev;\n\t\tret = emac_phy_connect(prueth->emac[PRUETH_MAC1]);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"can't connect to MII1 PHY, error %d\", ret);\n\t\t\tgoto netdev_unregister;\n\t\t}\n\t\tphy_attached_info(prueth->emac[PRUETH_MAC1]->ndev->phydev);\n\t}\n\n\tdev_info(dev, \"TI PRU ethernet driver initialized: %s EMAC mode\\n\",\n\t\t (!eth0_node || !eth1_node) ? \"single\" : \"dual\");\n\n\tif (eth1_node)\n\t\tof_node_put(eth1_node);\n\tif (eth0_node)\n\t\tof_node_put(eth0_node);\n\treturn 0;\n\nnetdev_unregister:\n\tfor (i = 0; i < PRUETH_NUM_MACS; i++) {\n\t\tif (!prueth->registered_netdevs[i])\n\t\t\tcontinue;\n\t\tif (prueth->emac[i]->ndev->phydev) {\n\t\t\tphy_disconnect(prueth->emac[i]->ndev->phydev);\n\t\t\tprueth->emac[i]->ndev->phydev = NULL;\n\t\t}\n\t\tunregister_netdev(prueth->registered_netdevs[i]);\n\t}\n\nnetdev_exit:\n\tfor (i = 0; i < PRUETH_NUM_MACS; i++) {\n\t\teth_node = prueth->eth_node[i];\n\t\tif (!eth_node)\n\t\t\tcontinue;\n\n\t\tprueth_netdev_exit(prueth, eth_node);\n\t}\n\nexit_iep:\n\tif (prueth->pdata.quirk_10m_link_issue)\n\t\ticss_iep_exit_fw(prueth->iep1);\n\ticss_iep_put(prueth->iep1);\n\nput_iep0:\n\ticss_iep_put(prueth->iep0);\n\tprueth->iep0 = NULL;\n\tprueth->iep1 = NULL;\n\nfree_pool:\n\tgen_pool_free(prueth->sram_pool,\n\t\t      (unsigned long)prueth->msmcram.va, msmc_ram_size);\n\nput_mem:\n\tpruss_release_mem_region(prueth->pruss, &prueth->shram);\n\nput_pruss:\n\tpruss_put(prueth->pruss);\n\nput_cores:\n\tif (eth1_node) {\n\t\tprueth_put_cores(prueth, ICSS_SLICE1);\n\t\tof_node_put(eth1_node);\n\t}\n\n\tif (eth0_node) {\n\t\tprueth_put_cores(prueth, ICSS_SLICE0);\n\t\tof_node_put(eth0_node);\n\t}\n\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-38584"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/firmware/sysfb.c",
      "func_name": "sysfb_disable",
      "func_body": "void sysfb_disable(struct device *dev)\n{\n\tstruct screen_info *si = &screen_info;\n\n\tmutex_lock(&disable_lock);\n\tif (!dev || dev == sysfb_parent_dev(si)) {\n\t\tsysfb_unregister();\n\t\tdisabled = true;\n\t}\n\tmutex_unlock(&disable_lock);\n}\n",
      "cve_list": [
        "CVE-2024-46698"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/firmware/sysfb.c",
      "func_name": "sysfb_pci_dev_is_enabled",
      "func_body": "static bool sysfb_pci_dev_is_enabled(struct pci_dev *pdev)\n{\n\treturn false;\n}\n",
      "cve_list": [
        "CVE-2024-46698"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/video/aperture.c",
      "func_name": "aperture_remove_conflicting_pci_devices",
      "func_body": "int aperture_remove_conflicting_pci_devices(struct pci_dev *pdev, const char *name)\n{\n\tresource_size_t base, size;\n\tint bar, ret = 0;\n\n\tsysfb_disable(&pdev->dev);\n\n\tfor (bar = 0; bar < PCI_STD_NUM_BARS; ++bar) {\n\t\tif (!(pci_resource_flags(pdev, bar) & IORESOURCE_MEM))\n\t\t\tcontinue;\n\n\t\tbase = pci_resource_start(pdev, bar);\n\t\tsize = pci_resource_len(pdev, bar);\n\t\taperture_detach_devices(base, size);\n\t}\n\n\t/*\n\t * If this is the primary adapter, there could be a VGA device\n\t * that consumes the VGA framebuffer I/O range. Remove this\n\t * device as well.\n\t */\n\tif (pdev == vga_default_device())\n\t\tret = __aperture_remove_legacy_vga_devices(pdev);\n\n\treturn ret;\n\n}\n",
      "cve_list": [
        "CVE-2024-46698"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "arch/s390/mm/pgalloc.c",
      "func_name": "crst_table_free",
      "func_body": "void crst_table_free(struct mm_struct *mm, unsigned long *table)\n{\n\tif (!table)\n\t\treturn;\n\tpagetable_free(virt_to_ptdesc(table));\n}\n",
      "cve_list": [
        "CVE-2024-42235"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "arch/s390/mm/pgalloc.c",
      "func_name": "base_crst_free",
      "func_body": "static void base_crst_free(unsigned long *table)\n{\n\tif (!table)\n\t\treturn;\n\tpagetable_free(virt_to_ptdesc(table));\n}\n",
      "cve_list": [
        "CVE-2024-42235"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ipv6/route.c",
      "func_name": "rt6_probe",
      "func_body": "static void rt6_probe(struct fib6_nh *fib6_nh)\n{\n\tstruct __rt6_probe_work *work = NULL;\n\tconst struct in6_addr *nh_gw;\n\tunsigned long last_probe;\n\tstruct neighbour *neigh;\n\tstruct net_device *dev;\n\tstruct inet6_dev *idev;\n\n\t/*\n\t * Okay, this does not seem to be appropriate\n\t * for now, however, we need to check if it\n\t * is really so; aka Router Reachability Probing.\n\t *\n\t * Router Reachability Probe MUST be rate-limited\n\t * to no more than one per minute.\n\t */\n\tif (!fib6_nh->fib_nh_gw_family)\n\t\treturn;\n\n\tnh_gw = &fib6_nh->fib_nh_gw6;\n\tdev = fib6_nh->fib_nh_dev;\n\trcu_read_lock();\n\tlast_probe = READ_ONCE(fib6_nh->last_probe);\n\tidev = __in6_dev_get(dev);\n\tif (!idev)\n\t\tgoto out;\n\tneigh = __ipv6_neigh_lookup_noref(dev, nh_gw);\n\tif (neigh) {\n\t\tif (READ_ONCE(neigh->nud_state) & NUD_VALID)\n\t\t\tgoto out;\n\n\t\twrite_lock_bh(&neigh->lock);\n\t\tif (!(neigh->nud_state & NUD_VALID) &&\n\t\t    time_after(jiffies,\n\t\t\t       neigh->updated +\n\t\t\t       READ_ONCE(idev->cnf.rtr_probe_interval))) {\n\t\t\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\t\t\tif (work)\n\t\t\t\t__neigh_set_probe_once(neigh);\n\t\t}\n\t\twrite_unlock_bh(&neigh->lock);\n\t} else if (time_after(jiffies, last_probe +\n\t\t\t\t       READ_ONCE(idev->cnf.rtr_probe_interval))) {\n\t\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\t}\n\n\tif (!work || cmpxchg(&fib6_nh->last_probe,\n\t\t\t     last_probe, jiffies) != last_probe) {\n\t\tkfree(work);\n\t} else {\n\t\tINIT_WORK(&work->work, rt6_probe_deferred);\n\t\twork->target = *nh_gw;\n\t\tnetdev_hold(dev, &work->dev_tracker, GFP_ATOMIC);\n\t\twork->dev = dev;\n\t\tschedule_work(&work->work);\n\t}\n\nout:\n\trcu_read_unlock();\n}\n",
      "cve_list": [
        "CVE-2024-40960"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "io_uring/kbuf.c",
      "func_name": "io_alloc_pbuf_ring",
      "func_body": "static int io_alloc_pbuf_ring(struct io_ring_ctx *ctx,\n\t\t\t      struct io_uring_buf_reg *reg,\n\t\t\t      struct io_buffer_list *bl)\n{\n\tsize_t ring_size;\n\n\tring_size = reg->ring_entries * sizeof(struct io_uring_buf_ring);\n\n\tbl->buf_ring = io_pages_map(&bl->buf_pages, &bl->buf_nr_pages, ring_size);\n\tif (IS_ERR(bl->buf_ring)) {\n\t\tbl->buf_ring = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tbl->is_buf_ring = 1;\n\tbl->is_mmap = 1;\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-42254"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/amdgpu/gfx_v11_0.c",
      "func_name": "gfx_v11_0_hw_init",
      "func_body": "static int gfx_v11_0_hw_init(void *handle)\n{\n\tint r;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_RLC_BACKDOOR_AUTO) {\n\t\tif (adev->gfx.imu.funcs) {\n\t\t\t/* RLC autoload sequence 1: Program rlc ram */\n\t\t\tif (adev->gfx.imu.funcs->program_rlc_ram)\n\t\t\t\tadev->gfx.imu.funcs->program_rlc_ram(adev);\n\t\t\t/* rlc autoload firmware */\n\t\t\tr = gfx_v11_0_rlc_backdoor_autoload_enable(adev);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t} else {\n\t\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_DIRECT) {\n\t\t\tif (adev->gfx.imu.funcs && (amdgpu_dpm > 0)) {\n\t\t\t\tif (adev->gfx.imu.funcs->load_microcode)\n\t\t\t\t\tadev->gfx.imu.funcs->load_microcode(adev);\n\t\t\t\tif (adev->gfx.imu.funcs->setup_imu)\n\t\t\t\t\tadev->gfx.imu.funcs->setup_imu(adev);\n\t\t\t\tif (adev->gfx.imu.funcs->start_imu)\n\t\t\t\t\tadev->gfx.imu.funcs->start_imu(adev);\n\t\t\t}\n\n\t\t\t/* disable gpa mode in backdoor loading */\n\t\t\tgfx_v11_0_disable_gpa_mode(adev);\n\t\t}\n\t}\n\n\tif ((adev->firmware.load_type == AMDGPU_FW_LOAD_RLC_BACKDOOR_AUTO) ||\n\t    (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP)) {\n\t\tr = gfx_v11_0_wait_for_rlc_autoload_complete(adev);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"(%d) failed to wait rlc autoload complete\\n\", r);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tadev->gfx.is_poweron = true;\n\n\tif(get_gb_addr_config(adev))\n\t\tDRM_WARN(\"Invalid gb_addr_config !\\n\");\n\n\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP &&\n\t    adev->gfx.rs64_enable)\n\t\tgfx_v11_0_config_gfx_rs64(adev);\n\n\tr = gfx_v11_0_gfxhub_enable(adev);\n\tif (r)\n\t\treturn r;\n\n\tif (!amdgpu_emu_mode)\n\t\tgfx_v11_0_init_golden_registers(adev);\n\n\tif ((adev->firmware.load_type == AMDGPU_FW_LOAD_DIRECT) ||\n\t    (adev->firmware.load_type == AMDGPU_FW_LOAD_RLC_BACKDOOR_AUTO && amdgpu_dpm == 1)) {\n\t\t/**\n\t\t * For gfx 11, rlc firmware loading relies on smu firmware is\n\t\t * loaded firstly, so in direct type, it has to load smc ucode\n\t\t * here before rlc.\n\t\t */\n\t\tif (!(adev->flags & AMD_IS_APU)) {\n\t\t\tr = amdgpu_pm_load_smu_firmware(adev, NULL);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n\tgfx_v11_0_constants_init(adev);\n\n\tif (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP)\n\t\tgfx_v11_0_select_cp_fw_arch(adev);\n\n\tif (adev->nbio.funcs->gc_doorbell_init)\n\t\tadev->nbio.funcs->gc_doorbell_init(adev);\n\n\tr = gfx_v11_0_rlc_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\t/*\n\t * init golden registers and rlc resume may override some registers,\n\t * reconfig them here\n\t */\n\tgfx_v11_0_tcp_harvest(adev);\n\n\tr = gfx_v11_0_cp_resume(adev);\n\tif (r)\n\t\treturn r;\n\n\t/* get IMU version from HW if it's not set */\n\tif (!adev->gfx.imu_fw_version)\n\t\tadev->gfx.imu_fw_version = RREG32_SOC15(GC, 0, regGFX_IMU_SCRATCH_0);\n\n\treturn r;\n}\n",
      "cve_list": [
        "CVE-2024-46835"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c",
      "func_name": "smu7_hwmgr_backend_init",
      "func_body": "static int smu7_hwmgr_backend_init(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tstruct smu7_hwmgr *data;\n\tint result = 0;\n\n\tdata = kzalloc(sizeof(struct smu7_hwmgr), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\thwmgr->backend = data;\n\tsmu7_patch_voltage_workaround(hwmgr);\n\tsmu7_init_dpm_defaults(hwmgr);\n\n\t/* Get leakage voltage based on leakage ID. */\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_EVV)) {\n\t\tresult = smu7_get_evv_voltages(hwmgr);\n\t\tif (result) {\n\t\t\tpr_info(\"Get EVV Voltage Failed.  Abort Driver loading!\\n\");\n\t\t\tkfree(hwmgr->backend);\n\t\t\thwmgr->backend = NULL;\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tsmu7_get_elb_voltages(hwmgr);\n\t}\n\n\tif (hwmgr->pp_table_version == PP_TABLE_V1) {\n\t\tsmu7_complete_dependency_tables(hwmgr);\n\t\tsmu7_set_private_data_based_on_pptable_v1(hwmgr);\n\t} else if (hwmgr->pp_table_version == PP_TABLE_V0) {\n\t\tsmu7_patch_dependency_tables_with_leakage(hwmgr);\n\t\tsmu7_set_private_data_based_on_pptable_v0(hwmgr);\n\t}\n\n\t/* Initalize Dynamic State Adjustment Rule Settings */\n\tresult = phm_initializa_dynamic_state_adjustment_rule_settings(hwmgr);\n\n\tif (result)\n\t\tgoto fail;\n\n\tdata->is_tlu_enabled = false;\n\n\thwmgr->platform_descriptor.hardwareActivityPerformanceLevels =\n\t\t\t\t\t\t\tSMU7_MAX_HARDWARE_POWERLEVELS;\n\thwmgr->platform_descriptor.hardwarePerformanceLevels = 2;\n\thwmgr->platform_descriptor.minimumClocksReductionPercentage = 50;\n\n\tdata->pcie_gen_cap = adev->pm.pcie_gen_mask;\n\tif (data->pcie_gen_cap & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN3)\n\t\tdata->pcie_spc_cap = 20;\n\telse\n\t\tdata->pcie_spc_cap = 16;\n\tdata->pcie_lane_cap = adev->pm.pcie_mlw_mask;\n\n\thwmgr->platform_descriptor.vbiosInterruptId = 0x20000400; /* IRQ_SOURCE1_SW_INT */\n\t/* The true clock step depends on the frequency, typically 4.5 or 9 MHz. Here we use 5. */\n\thwmgr->platform_descriptor.clockStep.engineClock = 500;\n\thwmgr->platform_descriptor.clockStep.memoryClock = 500;\n\tsmu7_thermal_parameter_init(hwmgr);\n\n\tresult = smu7_update_edc_leakage_table(hwmgr);\n\tif (result)\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tsmu7_hwmgr_backend_fini(hwmgr);\n\treturn result;\n}\n",
      "cve_list": [
        "CVE-2024-43909"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "lib/test_hmm.c",
      "func_name": "dmirror_device_evict_chunk",
      "func_body": "static void dmirror_device_evict_chunk(struct dmirror_chunk *chunk)\n{\n\tunsigned long start_pfn = chunk->pagemap.range.start >> PAGE_SHIFT;\n\tunsigned long end_pfn = chunk->pagemap.range.end >> PAGE_SHIFT;\n\tunsigned long npages = end_pfn - start_pfn + 1;\n\tunsigned long i;\n\tunsigned long *src_pfns;\n\tunsigned long *dst_pfns;\n\n\tsrc_pfns = kvcalloc(npages, sizeof(*src_pfns), GFP_KERNEL | __GFP_NOFAIL);\n\tdst_pfns = kvcalloc(npages, sizeof(*dst_pfns), GFP_KERNEL | __GFP_NOFAIL);\n\n\tmigrate_device_range(src_pfns, start_pfn, npages);\n\tfor (i = 0; i < npages; i++) {\n\t\tstruct page *dpage, *spage;\n\n\t\tspage = migrate_pfn_to_page(src_pfns[i]);\n\t\tif (!spage || !(src_pfns[i] & MIGRATE_PFN_MIGRATE))\n\t\t\tcontinue;\n\n\t\tif (WARN_ON(!is_device_private_page(spage) &&\n\t\t\t    !is_device_coherent_page(spage)))\n\t\t\tcontinue;\n\t\tspage = BACKING_PAGE(spage);\n\t\tdpage = alloc_page(GFP_HIGHUSER_MOVABLE | __GFP_NOFAIL);\n\t\tlock_page(dpage);\n\t\tcopy_highpage(dpage, spage);\n\t\tdst_pfns[i] = migrate_pfn(page_to_pfn(dpage));\n\t\tif (src_pfns[i] & MIGRATE_PFN_WRITE)\n\t\t\tdst_pfns[i] |= MIGRATE_PFN_WRITE;\n\t}\n\tmigrate_device_pages(src_pfns, dst_pfns, npages);\n\tmigrate_device_finalize(src_pfns, dst_pfns, npages);\n\tkvfree(src_pfns);\n\tkvfree(dst_pfns);\n}\n",
      "cve_list": [
        "CVE-2024-38543"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/cavium/liquidio/lio_vf_rep.c",
      "func_name": "lio_vf_rep_copy_packet",
      "func_body": "static void\nlio_vf_rep_copy_packet(struct octeon_device *oct,\n\t\t       struct sk_buff *skb,\n\t\t       int len)\n{\n\tif (likely(len > MIN_SKB_SIZE)) {\n\t\tstruct octeon_skb_page_info *pg_info;\n\t\tunsigned char *va;\n\n\t\tpg_info = ((struct octeon_skb_page_info *)(skb->cb));\n\t\tif (pg_info->page) {\n\t\t\tva = page_address(pg_info->page) +\n\t\t\t\tpg_info->page_offset;\n\t\t\tmemcpy(skb->data, va, MIN_SKB_SIZE);\n\t\t\tskb_put(skb, MIN_SKB_SIZE);\n\t\t\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags,\n\t\t\t\t\tpg_info->page,\n\t\t\t\t\tpg_info->page_offset + MIN_SKB_SIZE,\n\t\t\t\t\tlen - MIN_SKB_SIZE,\n\t\t\t\t\tLIO_RXBUFFER_SZ);\n\t\t}\n\t} else {\n\t\tstruct octeon_skb_page_info *pg_info =\n\t\t\t((struct octeon_skb_page_info *)(skb->cb));\n\n\t\tskb_copy_to_linear_data(skb, page_address(pg_info->page) +\n\t\t\t\t\tpg_info->page_offset, len);\n\t\tskb_put(skb, len);\n\t\tput_page(pg_info->page);\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-39506"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/netfilter/nft_meta.c",
      "func_name": "nft_meta_inner_init",
      "func_body": "static int nft_meta_inner_init(const struct nft_ctx *ctx,\n\t\t\t       const struct nft_expr *expr,\n\t\t\t       const struct nlattr * const tb[])\n{\n\tstruct nft_meta *priv = nft_expr_priv(expr);\n\tunsigned int len;\n\n\tif (!tb[NFTA_META_KEY] || !tb[NFTA_META_DREG])\n\t\treturn -EINVAL;\n\n\tpriv->key = ntohl(nla_get_be32(tb[NFTA_META_KEY]));\n\tswitch (priv->key) {\n\tcase NFT_META_PROTOCOL:\n\t\tlen = sizeof(u16);\n\t\tbreak;\n\tcase NFT_META_L4PROTO:\n\t\tlen = sizeof(u32);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\tpriv->len = len;\n\n\treturn nft_parse_register_store(ctx, tb[NFTA_META_DREG], &priv->dreg,\n\t\t\t\t\tNULL, NFT_DATA_VALUE, len);\n}\n",
      "cve_list": [
        "CVE-2024-39504"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/netfilter/nft_payload.c",
      "func_name": "nft_payload_inner_init",
      "func_body": "static int nft_payload_inner_init(const struct nft_ctx *ctx,\n\t\t\t\t  const struct nft_expr *expr,\n\t\t\t\t  const struct nlattr * const tb[])\n{\n\tstruct nft_payload *priv = nft_expr_priv(expr);\n\tu32 base;\n\n\tif (!tb[NFTA_PAYLOAD_BASE] || !tb[NFTA_PAYLOAD_OFFSET] ||\n\t    !tb[NFTA_PAYLOAD_LEN] || !tb[NFTA_PAYLOAD_DREG])\n\t\treturn -EINVAL;\n\n\tbase   = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_BASE]));\n\tswitch (base) {\n\tcase NFT_PAYLOAD_TUN_HEADER:\n\tcase NFT_PAYLOAD_LL_HEADER:\n\tcase NFT_PAYLOAD_NETWORK_HEADER:\n\tcase NFT_PAYLOAD_TRANSPORT_HEADER:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpriv->base   = base;\n\tpriv->offset = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_OFFSET]));\n\tpriv->len    = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_LEN]));\n\n\treturn nft_parse_register_store(ctx, tb[NFTA_PAYLOAD_DREG],\n\t\t\t\t\t&priv->dreg, NULL, NFT_DATA_VALUE,\n\t\t\t\t\tpriv->len);\n}\n",
      "cve_list": [
        "CVE-2024-39504"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/dc/dcn20/dcn20_dwb_scl.c",
      "func_name": "wbscl_set_scaler_filter",
      "func_body": "static void wbscl_set_scaler_filter(\n\tstruct dcn20_dwbc *dwbc20,\n\tuint32_t taps,\n\tenum wbscl_coef_filter_type_sel filter_type,\n\tconst uint16_t *filter)\n{\n\tconst int tap_pairs = (taps + 1) / 2;\n\tint phase;\n\tint pair;\n\tuint16_t odd_coef, even_coef;\n\n\tif (!filter)\n\t\treturn;\n\n\tfor (phase = 0; phase < (NUM_PHASES / 2 + 1); phase++) {\n\t\tfor (pair = 0; pair < tap_pairs; pair++) {\n\t\t\teven_coef = filter[phase * taps + 2 * pair];\n\t\t\tif ((pair * 2 + 1) < taps)\n\t\t\t\todd_coef = filter[phase * taps + 2 * pair + 1];\n\t\t\telse\n\t\t\t\todd_coef = 0;\n\n\t\t\tREG_SET_3(WBSCL_COEF_RAM_SELECT, 0,\n\t\t\t\tWBSCL_COEF_RAM_TAP_PAIR_IDX, pair,\n\t\t\t\tWBSCL_COEF_RAM_PHASE, phase,\n\t\t\t\tWBSCL_COEF_RAM_FILTER_TYPE, filter_type);\n\n\t\t\tREG_SET_4(WBSCL_COEF_RAM_TAP_DATA, 0,\n\t\t\t\t/* Even tap coefficient (bits 1:0 fixed to 0) */\n\t\t\t\tWBSCL_COEF_RAM_EVEN_TAP_COEF, even_coef,\n\t\t\t\t/* Write/read control for even coefficient */\n\t\t\t\tWBSCL_COEF_RAM_EVEN_TAP_COEF_EN, 1,\n\t\t\t\t/* Odd tap coefficient (bits 1:0 fixed to 0) */\n\t\t\t\tWBSCL_COEF_RAM_ODD_TAP_COEF, odd_coef,\n\t\t\t\t/* Write/read control for odd coefficient */\n\t\t\t\tWBSCL_COEF_RAM_ODD_TAP_COEF_EN, 1);\n\t\t}\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-46714"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/vc4/vc4_hdmi.c",
      "func_name": "vc4_hdmi_audio_init",
      "func_body": "static int vc4_hdmi_audio_init(struct vc4_hdmi *vc4_hdmi)\n{\n\tconst struct vc4_hdmi_register *mai_data =\n\t\t&vc4_hdmi->variant->registers[HDMI_MAI_DATA];\n\tstruct snd_soc_dai_link *dai_link = &vc4_hdmi->audio.link;\n\tstruct snd_soc_card *card = &vc4_hdmi->audio.card;\n\tstruct device *dev = &vc4_hdmi->pdev->dev;\n\tstruct platform_device *codec_pdev;\n\tconst __be32 *addr;\n\tint index, len;\n\tint ret;\n\n\t/*\n\t * ASoC makes it a bit hard to retrieve a pointer to the\n\t * vc4_hdmi structure. Registering the card will overwrite our\n\t * device drvdata with a pointer to the snd_soc_card structure,\n\t * which can then be used to retrieve whatever drvdata we want\n\t * to associate.\n\t *\n\t * However, that doesn't fly in the case where we wouldn't\n\t * register an ASoC card (because of an old DT that is missing\n\t * the dmas properties for example), then the card isn't\n\t * registered and the device drvdata wouldn't be set.\n\t *\n\t * We can deal with both cases by making sure a snd_soc_card\n\t * pointer and a vc4_hdmi structure are pointing to the same\n\t * memory address, so we can treat them indistinctly without any\n\t * issue.\n\t */\n\tBUILD_BUG_ON(offsetof(struct vc4_hdmi_audio, card) != 0);\n\tBUILD_BUG_ON(offsetof(struct vc4_hdmi, audio) != 0);\n\n\tif (!of_find_property(dev->of_node, \"dmas\", &len) || !len) {\n\t\tdev_warn(dev,\n\t\t\t \"'dmas' DT property is missing or empty, no HDMI audio\\n\");\n\t\treturn 0;\n\t}\n\n\tif (mai_data->reg != VC4_HD) {\n\t\tWARN_ONCE(true, \"MAI isn't in the HD block\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Get the physical address of VC4_HD_MAI_DATA. We need to retrieve\n\t * the bus address specified in the DT, because the physical address\n\t * (the one returned by platform_get_resource()) is not appropriate\n\t * for DMA transfers.\n\t * This VC/MMU should probably be exposed to avoid this kind of hacks.\n\t */\n\tindex = of_property_match_string(dev->of_node, \"reg-names\", \"hd\");\n\t/* Before BCM2711, we don't have a named register range */\n\tif (index < 0)\n\t\tindex = 1;\n\n\taddr = of_get_address(dev->of_node, index, NULL, NULL);\n\tif (!addr)\n\t\treturn -EINVAL;\n\n\tvc4_hdmi->audio.dma_data.addr = be32_to_cpup(addr) + mai_data->offset;\n\tvc4_hdmi->audio.dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tvc4_hdmi->audio.dma_data.maxburst = 2;\n\n\t/*\n\t * NOTE: Strictly speaking, we should probably use a DRM-managed\n\t * registration there to avoid removing all the audio components\n\t * by the time the driver doesn't have any user anymore.\n\t *\n\t * However, the ASoC core uses a number of devm_kzalloc calls\n\t * when registering, even when using non-device-managed\n\t * functions (such as in snd_soc_register_component()).\n\t *\n\t * If we call snd_soc_unregister_component() in a DRM-managed\n\t * action, the device-managed actions have already been executed\n\t * and thus we would access memory that has been freed.\n\t *\n\t * Using device-managed hooks here probably leaves us open to a\n\t * bunch of issues if userspace still has a handle on the ALSA\n\t * device when the device is removed. However, this is mitigated\n\t * by the use of drm_dev_enter()/drm_dev_exit() in the audio\n\t * path to prevent the access to the device resources if it\n\t * isn't there anymore.\n\t *\n\t * Then, the vc4_hdmi structure is DRM-managed and thus only\n\t * freed whenever the last user has closed the DRM device file.\n\t * It should thus outlive ALSA in most situations.\n\t */\n\tret = devm_snd_dmaengine_pcm_register(dev, &pcm_conf, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not register PCM component: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_soc_register_component(dev, &vc4_hdmi_audio_cpu_dai_comp,\n\t\t\t\t\t      &vc4_hdmi_audio_cpu_dai_drv, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not register CPU DAI: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcodec_pdev = platform_device_register_data(dev, HDMI_CODEC_DRV_NAME,\n\t\t\t\t\t\t   PLATFORM_DEVID_AUTO,\n\t\t\t\t\t\t   &vc4_hdmi_codec_pdata,\n\t\t\t\t\t\t   sizeof(vc4_hdmi_codec_pdata));\n\tif (IS_ERR(codec_pdev)) {\n\t\tdev_err(dev, \"Couldn't register the HDMI codec: %ld\\n\", PTR_ERR(codec_pdev));\n\t\treturn PTR_ERR(codec_pdev);\n\t}\n\tvc4_hdmi->audio.codec_pdev = codec_pdev;\n\n\tret = devm_add_action_or_reset(dev, vc4_hdmi_audio_codec_release, vc4_hdmi);\n\tif (ret)\n\t\treturn ret;\n\n\tdai_link->cpus\t\t= &vc4_hdmi->audio.cpu;\n\tdai_link->codecs\t= &vc4_hdmi->audio.codec;\n\tdai_link->platforms\t= &vc4_hdmi->audio.platform;\n\n\tdai_link->num_cpus\t= 1;\n\tdai_link->num_codecs\t= 1;\n\tdai_link->num_platforms\t= 1;\n\n\tdai_link->name = \"MAI\";\n\tdai_link->stream_name = \"MAI PCM\";\n\tdai_link->codecs->dai_name = \"i2s-hifi\";\n\tdai_link->cpus->dai_name = dev_name(dev);\n\tdai_link->codecs->name = dev_name(&codec_pdev->dev);\n\tdai_link->platforms->name = dev_name(dev);\n\n\tcard->dai_link = dai_link;\n\tcard->num_links = 1;\n\tcard->name = vc4_hdmi->variant->card_name;\n\tcard->driver_name = \"vc4-hdmi\";\n\tcard->dev = dev;\n\tcard->owner = THIS_MODULE;\n\n\t/*\n\t * Be careful, snd_soc_register_card() calls dev_set_drvdata() and\n\t * stores a pointer to the snd card object in dev->driver_data. This\n\t * means we cannot use it for something else. The hdmi back-pointer is\n\t * now stored in card->drvdata and should be retrieved with\n\t * snd_soc_card_get_drvdata() if needed.\n\t */\n\tsnd_soc_card_set_drvdata(card, vc4_hdmi);\n\tret = devm_snd_soc_register_card(dev, card);\n\tif (ret)\n\t\tdev_err_probe(dev, ret, \"Could not register sound card\\n\");\n\n\treturn ret;\n\n}\n",
      "cve_list": [
        "CVE-2024-38546"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/bluetooth/btnxpuart.c",
      "func_name": "btnxpuart_flush",
      "func_body": "static int btnxpuart_flush(struct hci_dev *hdev)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\n\t/* Flush any pending characters */\n\tserdev_device_write_flush(nxpdev->serdev);\n\tskb_queue_purge(&nxpdev->txq);\n\n\tcancel_work_sync(&nxpdev->tx_work);\n\n\tif (!IS_ERR_OR_NULL(nxpdev->rx_skb)) {\n\t\tkfree_skb(nxpdev->rx_skb);\n\t\tnxpdev->rx_skb = NULL;\n\t}\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-46749"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/xe/xe_device.c",
      "func_name": "xe_device_probe",
      "func_body": "int xe_device_probe(struct xe_device *xe)\n{\n\tstruct xe_tile *tile;\n\tstruct xe_gt *gt;\n\tint err;\n\tu8 id;\n\n\txe_pat_init_early(xe);\n\n\terr = xe_sriov_init(xe);\n\tif (err)\n\t\treturn err;\n\n\txe->info.mem_region_mask = 1;\n\terr = xe_display_init_nommio(xe);\n\tif (err)\n\t\treturn err;\n\n\terr = xe_set_dma_info(xe);\n\tif (err)\n\t\treturn err;\n\n\terr = xe_mmio_probe_tiles(xe);\n\tif (err)\n\t\treturn err;\n\n\txe_ttm_sys_mgr_init(xe);\n\n\tfor_each_gt(gt, xe, id) {\n\t\terr = xe_gt_init_early(gt);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor_each_tile(tile, xe, id) {\n\t\terr = xe_ggtt_init_early(tile->mem.ggtt);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (IS_SRIOV_VF(xe)) {\n\t\t\terr = xe_memirq_init(&tile->sriov.vf.memirq);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tfor_each_gt(gt, xe, id) {\n\t\terr = xe_gt_init_hwconfig(gt);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = xe_devcoredump_init(xe);\n\tif (err)\n\t\treturn err;\n\terr = devm_add_action_or_reset(xe->drm.dev, xe_driver_flr_fini, xe);\n\tif (err)\n\t\treturn err;\n\n\terr = xe_display_init_noirq(xe);\n\tif (err)\n\t\treturn err;\n\n\terr = xe_irq_install(xe);\n\tif (err)\n\t\tgoto err;\n\n\terr = xe_device_set_has_flat_ccs(xe);\n\tif (err)\n\t\tgoto err_irq_shutdown;\n\n\terr = xe_mmio_probe_vram(xe);\n\tif (err)\n\t\tgoto err_irq_shutdown;\n\n\tfor_each_tile(tile, xe, id) {\n\t\terr = xe_tile_init_noalloc(tile);\n\t\tif (err)\n\t\t\tgoto err_irq_shutdown;\n\t}\n\n\t/* Allocate and map stolen after potential VRAM resize */\n\txe_ttm_stolen_mgr_init(xe);\n\n\t/*\n\t * Now that GT is initialized (TTM in particular),\n\t * we can try to init display, and inherit the initial fb.\n\t * This is the reason the first allocation needs to be done\n\t * inside display.\n\t */\n\terr = xe_display_init_noaccel(xe);\n\tif (err)\n\t\tgoto err_irq_shutdown;\n\n\tfor_each_gt(gt, xe, id) {\n\t\terr = xe_gt_init(gt);\n\t\tif (err)\n\t\t\tgoto err_irq_shutdown;\n\t}\n\n\txe_heci_gsc_init(xe);\n\n\terr = xe_display_init(xe);\n\tif (err)\n\t\tgoto err_irq_shutdown;\n\n\terr = drm_dev_register(&xe->drm, 0);\n\tif (err)\n\t\tgoto err_fini_display;\n\n\txe_display_register(xe);\n\n\txe_debugfs_register(xe);\n\n\txe_hwmon_register(xe);\n\n\treturn devm_add_action_or_reset(xe->drm.dev, xe_device_sanitize, xe);\n\nerr_fini_display:\n\txe_display_driver_remove(xe);\nerr_irq_shutdown:\n\txe_irq_shutdown(xe);\nerr:\n\txe_display_fini(xe);\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-46705"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/smb/client/smb2pdu.c",
      "func_name": "smb2_new_read_req",
      "func_body": "static int\nsmb2_new_read_req(void **buf, unsigned int *total_len,\n\tstruct cifs_io_parms *io_parms, struct cifs_io_subrequest *rdata,\n\tunsigned int remaining_bytes, int request_type)\n{\n\tint rc = -EACCES;\n\tstruct smb2_read_req *req = NULL;\n\tstruct smb2_hdr *shdr;\n\tstruct TCP_Server_Info *server = io_parms->server;\n\n\trc = smb2_plain_req_init(SMB2_READ, io_parms->tcon, server,\n\t\t\t\t (void **) &req, total_len);\n\tif (rc)\n\t\treturn rc;\n\n\tif (server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tshdr = &req->hdr;\n\tshdr->Id.SyncId.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->ReadChannelInfoOffset = 0; /* reserved */\n\treq->ReadChannelInfoLength = 0; /* reserved */\n\treq->Channel = 0; /* reserved */\n\treq->MinimumCount = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\n\ttrace_smb3_read_enter(rdata ? rdata->rreq->debug_id : 0,\n\t\t\t      rdata ? rdata->subreq.debug_index : 0,\n\t\t\t      rdata ? rdata->xid : 0,\n\t\t\t      io_parms->persistent_fid,\n\t\t\t      io_parms->tcon->tid, io_parms->tcon->ses->Suid,\n\t\t\t      io_parms->offset, io_parms->length);\n// #ifdef CONFIG_CIFS_SMB_DIRECT\n\t/*\n\t * If we want to do a RDMA write, fill in and append\n\t * smbd_buffer_descriptor_v1 to the end of read request\n\t */\n\tif (rdata && smb3_use_rdma_offload(io_parms)) {\n\t\tstruct smbd_buffer_descriptor_v1 *v1;\n\t\tbool need_invalidate = server->dialect == SMB30_PROT_ID;\n\n\t\trdata->mr = smbd_register_mr(server->smbd_conn, &rdata->subreq.io_iter,\n\t\t\t\t\t     true, need_invalidate);\n\t\tif (!rdata->mr)\n\t\t\treturn -EAGAIN;\n\n\t\treq->Channel = SMB2_CHANNEL_RDMA_V1_INVALIDATE;\n\t\tif (need_invalidate)\n\t\t\treq->Channel = SMB2_CHANNEL_RDMA_V1;\n\t\treq->ReadChannelInfoOffset =\n\t\t\tcpu_to_le16(offsetof(struct smb2_read_req, Buffer));\n\t\treq->ReadChannelInfoLength =\n\t\t\tcpu_to_le16(sizeof(struct smbd_buffer_descriptor_v1));\n\t\tv1 = (struct smbd_buffer_descriptor_v1 *) &req->Buffer[0];\n\t\tv1->offset = cpu_to_le64(rdata->mr->mr->iova);\n\t\tv1->token = cpu_to_le32(rdata->mr->mr->rkey);\n\t\tv1->length = cpu_to_le32(rdata->mr->mr->length);\n\n\t\t*total_len += sizeof(*v1) - 1;\n\t}\n#endif\n\tif (request_type & CHAINED_REQUEST) {\n\t\tif (!(request_type & END_OF_CHAIN)) {\n\t\t\t/* next 8-byte aligned request */\n\t\t\t*total_len = ALIGN(*total_len, 8);\n\t\t\tshdr->NextCommand = cpu_to_le32(*total_len);\n\t\t} else /* END_OF_CHAIN */\n\t\t\tshdr->NextCommand = 0;\n\t\tif (request_type & RELATED_REQUEST) {\n\t\t\tshdr->Flags |= SMB2_FLAGS_RELATED_OPERATIONS;\n\t\t\t/*\n\t\t\t * Related requests use info from previous read request\n\t\t\t * in chain.\n\t\t\t */\n\t\t\tshdr->SessionId = cpu_to_le64(0xFFFFFFFFFFFFFFFF);\n\t\t\tshdr->Id.SyncId.TreeId = cpu_to_le32(0xFFFFFFFF);\n\t\t\treq->PersistentFileId = (u64)-1;\n\t\t\treq->VolatileFileId = (u64)-1;\n\t\t}\n\t}\n\tif (remaining_bytes > io_parms->length)\n\t\treq->RemainingBytes = cpu_to_le32(remaining_bytes);\n\telse\n\t\treq->RemainingBytes = 0;\n\n\t*buf = req;\n\treturn rc;\n}\n",
      "cve_list": [
        "CVE-2024-46686"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/f2fs/data.c",
      "func_name": "is_end_zone_blkaddr",
      "func_body": "static bool is_end_zone_blkaddr(struct f2fs_sb_info *sbi, block_t blkaddr)\n{\n\tstruct block_device *bdev = sbi->sb->s_bdev;\n\tint devi = 0;\n\n\tif (f2fs_is_multi_device(sbi)) {\n\t\tdevi = f2fs_target_device_index(sbi, blkaddr);\n\t\tif (blkaddr < FDEV(devi).start_blk ||\n\t\t    blkaddr > FDEV(devi).end_blk) {\n\t\t\tf2fs_err(sbi, \"Invalid block %x\", blkaddr);\n\t\t\treturn false;\n\t\t}\n\t\tblkaddr -= FDEV(devi).start_blk;\n\t\tbdev = FDEV(devi).bdev;\n\t}\n\treturn bdev_is_zoned(bdev) &&\n\t\tf2fs_blkz_is_seq(sbi, devi, blkaddr) &&\n\t\t(blkaddr % sbi->blocks_per_blkz == sbi->blocks_per_blkz - 1);\n}\n",
      "cve_list": [
        "CVE-2024-43857"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/dc/dml2/dml2_mall_phantom.c",
      "func_name": "enable_phantom_plane",
      "func_body": "static void enable_phantom_plane(struct dml2_context *ctx,\n\t\tstruct dc_state *state,\n\t\tstruct dc_stream_state *phantom_stream,\n\t\tunsigned int dc_pipe_idx)\n{\n\tstruct dc_plane_state *phantom_plane = NULL;\n\tstruct dc_plane_state *prev_phantom_plane = NULL;\n\tstruct pipe_ctx *curr_pipe = &state->res_ctx.pipe_ctx[dc_pipe_idx];\n\n\twhile (curr_pipe) {\n\t\tif (curr_pipe->top_pipe && curr_pipe->top_pipe->plane_state == curr_pipe->plane_state) {\n\t\t\tphantom_plane = prev_phantom_plane;\n\t\t} else {\n\t\t\tphantom_plane = ctx->config.svp_pstate.callbacks.create_phantom_plane(\n\t\t\t\t\tctx->config.svp_pstate.callbacks.dc,\n\t\t\t\t\tstate,\n\t\t\t\t\tcurr_pipe->plane_state);\n\t\t\tif (!phantom_plane)\n\t\t\t\treturn;\n\t\t}\n\n\t\tmemcpy(&phantom_plane->address, &curr_pipe->plane_state->address, sizeof(phantom_plane->address));\n\t\tmemcpy(&phantom_plane->scaling_quality, &curr_pipe->plane_state->scaling_quality,\n\t\t\t\tsizeof(phantom_plane->scaling_quality));\n\t\tmemcpy(&phantom_plane->src_rect, &curr_pipe->plane_state->src_rect, sizeof(phantom_plane->src_rect));\n\t\tmemcpy(&phantom_plane->dst_rect, &curr_pipe->plane_state->dst_rect, sizeof(phantom_plane->dst_rect));\n\t\tmemcpy(&phantom_plane->clip_rect, &curr_pipe->plane_state->clip_rect, sizeof(phantom_plane->clip_rect));\n\t\tmemcpy(&phantom_plane->plane_size, &curr_pipe->plane_state->plane_size,\n\t\t\t\tsizeof(phantom_plane->plane_size));\n\t\tmemcpy(&phantom_plane->tiling_info, &curr_pipe->plane_state->tiling_info,\n\t\t\t\tsizeof(phantom_plane->tiling_info));\n\t\tmemcpy(&phantom_plane->dcc, &curr_pipe->plane_state->dcc, sizeof(phantom_plane->dcc));\n\t\t//phantom_plane->tiling_info.gfx10compatible.compat_level = curr_pipe->plane_state->tiling_info.gfx10compatible.compat_level;\n\t\tphantom_plane->format = curr_pipe->plane_state->format;\n\t\tphantom_plane->rotation = curr_pipe->plane_state->rotation;\n\t\tphantom_plane->visible = curr_pipe->plane_state->visible;\n\n\t\t/* Shadow pipe has small viewport. */\n\t\tphantom_plane->clip_rect.y = 0;\n\t\tphantom_plane->clip_rect.height = phantom_stream->timing.v_addressable;\n\n\t\tctx->config.svp_pstate.callbacks.add_phantom_plane(ctx->config.svp_pstate.callbacks.dc, phantom_stream, phantom_plane, state);\n\n\t\tcurr_pipe = curr_pipe->bottom_pipe;\n\t\tprev_phantom_plane = phantom_plane;\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-43827"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/gma500/cdv_intel_lvds.c",
      "func_name": "cdv_intel_lvds_get_modes",
      "func_body": "static int cdv_intel_lvds_get_modes(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct psb_intel_mode_device *mode_dev = &dev_priv->mode_dev;\n\tint ret;\n\n\tret = psb_intel_ddc_get_modes(connector, connector->ddc);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (mode_dev->panel_fixed_mode != NULL) {\n\t\tstruct drm_display_mode *mode =\n\t\t    drm_mode_duplicate(dev, mode_dev->panel_fixed_mode);\n\t\tif (!mode)\n\t\t\treturn 0;\n\n\t\tdrm_mode_probed_add(connector, mode);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-42310"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/jfs/jfs_dtree.c",
      "func_name": "dtInsert",
      "func_body": "int dtInsert(tid_t tid, struct inode *ip,\n\t struct component_name * name, ino_t * fsn, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\tdtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index;\n\tstruct dtsplit split;\t/* split information */\n\tddata_t data;\n\tstruct dt_lock *dtlck;\n\tint n;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\n\t/*\n\t *\tretrieve search result\n\t *\n\t * dtSearch() returns (leaf page pinned, index at which to insert).\n\t * n.b. dtSearch() may return index of (maxindex + 1) of\n\t * the full page.\n\t */\n\tDT_GETSEARCH(ip, btstack->top, bn, mp, p, index);\n\tif (p->header.freelist == 0)\n\t\treturn -EINVAL;\n\n\t/*\n\t *\tinsert entry for new key\n\t */\n\tif (DO_INDEX(ip)) {\n\t\tif (JFS_IP(ip)->next_index == DIREND) {\n\t\t\tDT_PUTPAGE(mp);\n\t\t\treturn -EMLINK;\n\t\t}\n\t\tn = NDTLEAF(name->namlen);\n\t\tdata.leaf.tid = tid;\n\t\tdata.leaf.ip = ip;\n\t} else {\n\t\tn = NDTLEAF_LEGACY(name->namlen);\n\t\tdata.leaf.ip = NULL;\t/* signifies legacy directory format */\n\t}\n\tdata.leaf.ino = *fsn;\n\n\t/*\n\t *\tleaf page does not have enough room for new entry:\n\t *\n\t *\textend/split the leaf page;\n\t *\n\t * dtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tif (n > p->header.freecnt) {\n\t\tsplit.mp = mp;\n\t\tsplit.index = index;\n\t\tsplit.nslot = n;\n\t\tsplit.key = name;\n\t\tsplit.data = &data;\n\t\trc = dtSplitUp(tid, ip, &split, btstack);\n\t\treturn rc;\n\t}\n\n\t/*\n\t *\tleaf page does have enough room for new entry:\n\t *\n\t *\tinsert the new data entry into the leaf page;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire a transaction lock on the leaf page\n\t */\n\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\n\t/* linelock header */\n\tlv->offset = 0;\n\tlv->length = 1;\n\tdtlck->index++;\n\n\tdtInsertEntry(p, index, name, &data, &dtlck);\n\n\t/* linelock stbl of non-root leaf page */\n\tif (!(p->header.flag & BT_ROOT)) {\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tn = index >> L2DTSLOTSIZE;\n\t\tlv->offset = p->header.stblindex + n;\n\t\tlv->length =\n\t\t    ((p->header.nextindex - 1) >> L2DTSLOTSIZE) - n + 1;\n\t\tdtlck->index++;\n\t}\n\n\t/* unpin the leaf page */\n\tDT_PUTPAGE(mp);\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-44939"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/nfsd/nfs4idmap.c",
      "func_name": "idmap_id_to_name",
      "func_body": "static __be32 idmap_id_to_name(struct xdr_stream *xdr,\n\t\t\t       struct svc_rqst *rqstp, int type, u32 id)\n{\n\tstruct ent *item, key = {\n\t\t.id = id,\n\t\t.type = type,\n\t};\n\t__be32 status = nfs_ok;\n\t__be32 *p;\n\tint ret;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tstrscpy(key.authname, rqst_authname(rqstp), sizeof(key.authname));\n\tret = idmap_lookup(rqstp, idtoname_lookup, &key, nn->idtoname_cache, &item);\n\tif (ret == -ENOENT)\n\t\treturn encode_ascii_id(xdr, id);\n\tif (ret)\n\t\treturn nfserrno(ret);\n\tret = strlen(item->name);\n\tWARN_ON_ONCE(ret > IDMAP_NAMESZ);\n\n\tp = xdr_reserve_space(xdr, ret + 4);\n\tif (unlikely(!p)) {\n\t\tstatus = nfserr_resource;\n\t\tgoto out_put;\n\t}\n\txdr_encode_opaque(p, item->name, ret);\nout_put:\n\tcache_put(&item->h, nn->idtoname_cache);\n\treturn status;\n}\n",
      "cve_list": [
        "CVE-2024-47737"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ipv6/fib6_rules.c",
      "func_name": "__fib6_rule_action",
      "func_body": "static int __fib6_rule_action(struct fib_rule *rule, struct flowi *flp,\n\t\t\t      int flags, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct flowi6 *flp6 = &flp->u.ip6;\n\tstruct rt6_info *rt = NULL;\n\tstruct fib6_table *table;\n\tstruct net *net = rule->fr_net;\n\tpol_lookup_t lookup = arg->lookup_ptr;\n\tint err = 0;\n\tu32 tb_id;\n\n\tswitch (rule->action) {\n\tcase FR_ACT_TO_TBL:\n\t\tbreak;\n\tcase FR_ACT_UNREACHABLE:\n\t\terr = -ENETUNREACH;\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tgoto discard_pkt;\n\tdefault:\n\tcase FR_ACT_BLACKHOLE:\n\t\terr = -EINVAL;\n\t\trt = net->ipv6.ip6_blk_hole_entry;\n\t\tgoto discard_pkt;\n\tcase FR_ACT_PROHIBIT:\n\t\terr = -EACCES;\n\t\trt = net->ipv6.ip6_prohibit_entry;\n\t\tgoto discard_pkt;\n\t}\n\n\ttb_id = fib_rule_get_table(rule, arg);\n\ttable = fib6_get_table(net, tb_id);\n\tif (!table) {\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trt = pol_lookup_func(lookup,\n\t\t\t     net, table, flp6, arg->lookup_data, flags);\n\tif (rt != net->ipv6.ip6_null_entry) {\n\t\tstruct inet6_dev *idev = ip6_dst_idev(&rt->dst);\n\n\t\tif (!idev)\n\t\t\tgoto again;\n\t\terr = fib6_rule_saddr(net, rule, flags, flp6,\n\t\t\t\t      idev->dev);\n\n\t\tif (err == -EAGAIN)\n\t\t\tgoto again;\n\n\t\terr = rt->dst.error;\n\t\tif (err != -EAGAIN)\n\t\t\tgoto out;\n\t}\nagain:\n\tip6_rt_put_flags(rt, flags);\n\terr = -EAGAIN;\n\trt = NULL;\n\tgoto out;\n\ndiscard_pkt:\n\tif (!(flags & RT6_LOOKUP_F_DST_NOREF))\n\t\tdst_hold(&rt->dst);\nout:\n\tres->rt6 = rt;\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-36902"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/intel/ice/ice_main.c",
      "func_name": "ice_rebuild",
      "func_body": "static void ice_rebuild(struct ice_pf *pf, enum ice_reset_req reset_type)\n{\n\tstruct ice_vsi *vsi = ice_get_main_vsi(pf);\n\tstruct device *dev = ice_pf_to_dev(pf);\n\tstruct ice_hw *hw = &pf->hw;\n\tbool dvm;\n\tint err;\n\n\tif (test_bit(ICE_DOWN, pf->state))\n\t\tgoto clear_recovery;\n\n\tdev_dbg(dev, \"rebuilding PF after reset_type=%d\\n\", reset_type);\n\n#define ICE_EMP_RESET_SLEEP_MS 5000\n\tif (reset_type == ICE_RESET_EMPR) {\n\t\t/* If an EMP reset has occurred, any previously pending flash\n\t\t * update will have completed. We no longer know whether or\n\t\t * not the NVM update EMP reset is restricted.\n\t\t */\n\t\tpf->fw_emp_reset_disabled = false;\n\n\t\tmsleep(ICE_EMP_RESET_SLEEP_MS);\n\t}\n\n\terr = ice_init_all_ctrlq(hw);\n\tif (err) {\n\t\tdev_err(dev, \"control queues init failed %d\\n\", err);\n\t\tgoto err_init_ctrlq;\n\t}\n\n\t/* if DDP was previously loaded successfully */\n\tif (!ice_is_safe_mode(pf)) {\n\t\t/* reload the SW DB of filter tables */\n\t\tif (reset_type == ICE_RESET_PFR)\n\t\t\tice_fill_blk_tbls(hw);\n\t\telse\n\t\t\t/* Reload DDP Package after CORER/GLOBR reset */\n\t\t\tice_load_pkg(NULL, pf);\n\t}\n\n\terr = ice_clear_pf_cfg(hw);\n\tif (err) {\n\t\tdev_err(dev, \"clear PF configuration failed %d\\n\", err);\n\t\tgoto err_init_ctrlq;\n\t}\n\n\tice_clear_pxe_mode(hw);\n\n\terr = ice_init_nvm(hw);\n\tif (err) {\n\t\tdev_err(dev, \"ice_init_nvm failed %d\\n\", err);\n\t\tgoto err_init_ctrlq;\n\t}\n\n\terr = ice_get_caps(hw);\n\tif (err) {\n\t\tdev_err(dev, \"ice_get_caps failed %d\\n\", err);\n\t\tgoto err_init_ctrlq;\n\t}\n\n\terr = ice_aq_set_mac_cfg(hw, ICE_AQ_SET_MAC_FRAME_SIZE_MAX, NULL);\n\tif (err) {\n\t\tdev_err(dev, \"set_mac_cfg failed %d\\n\", err);\n\t\tgoto err_init_ctrlq;\n\t}\n\n\tdvm = ice_is_dvm_ena(hw);\n\n\terr = ice_aq_set_port_params(pf->hw.port_info, dvm, NULL);\n\tif (err)\n\t\tgoto err_init_ctrlq;\n\n\terr = ice_sched_init_port(hw->port_info);\n\tif (err)\n\t\tgoto err_sched_init_port;\n\n\t/* start misc vector */\n\terr = ice_req_irq_msix_misc(pf);\n\tif (err) {\n\t\tdev_err(dev, \"misc vector setup failed: %d\\n\", err);\n\t\tgoto err_sched_init_port;\n\t}\n\n\tif (test_bit(ICE_FLAG_FD_ENA, pf->flags)) {\n\t\twr32(hw, PFQF_FD_ENA, PFQF_FD_ENA_FD_ENA_M);\n\t\tif (!rd32(hw, PFQF_FD_SIZE)) {\n\t\t\tu16 unused, guar, b_effort;\n\n\t\t\tguar = hw->func_caps.fd_fltr_guar;\n\t\t\tb_effort = hw->func_caps.fd_fltr_best_effort;\n\n\t\t\t/* force guaranteed filter pool for PF */\n\t\t\tice_alloc_fd_guar_item(hw, &unused, guar);\n\t\t\t/* force shared filter pool for PF */\n\t\t\tice_alloc_fd_shrd_item(hw, &unused, b_effort);\n\t\t}\n\t}\n\n\tif (test_bit(ICE_FLAG_DCB_ENA, pf->flags))\n\t\tice_dcb_rebuild(pf);\n\n\t/* If the PF previously had enabled PTP, PTP init needs to happen before\n\t * the VSI rebuild. If not, this causes the PTP link status events to\n\t * fail.\n\t */\n\tif (test_bit(ICE_FLAG_PTP_SUPPORTED, pf->flags))\n\t\tice_ptp_rebuild(pf, reset_type);\n\n\tif (ice_is_feature_supported(pf, ICE_F_GNSS))\n\t\tice_gnss_init(pf);\n\n\t/* rebuild PF VSI */\n\terr = ice_vsi_rebuild_by_type(pf, ICE_VSI_PF);\n\tif (err) {\n\t\tdev_err(dev, \"PF VSI rebuild failed: %d\\n\", err);\n\t\tgoto err_vsi_rebuild;\n\t}\n\n\tif (reset_type == ICE_RESET_PFR) {\n\t\terr = ice_rebuild_channels(pf);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"failed to rebuild and replay ADQ VSIs, err %d\\n\",\n\t\t\t\terr);\n\t\t\tgoto err_vsi_rebuild;\n\t\t}\n\t}\n\n\t/* If Flow Director is active */\n\tif (test_bit(ICE_FLAG_FD_ENA, pf->flags)) {\n\t\terr = ice_vsi_rebuild_by_type(pf, ICE_VSI_CTRL);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"control VSI rebuild failed: %d\\n\", err);\n\t\t\tgoto err_vsi_rebuild;\n\t\t}\n\n\t\t/* replay HW Flow Director recipes */\n\t\tif (hw->fdir_prof)\n\t\t\tice_fdir_replay_flows(hw);\n\n\t\t/* replay Flow Director filters */\n\t\tice_fdir_replay_fltrs(pf);\n\n\t\tice_rebuild_arfs(pf);\n\t}\n\n\tif (vsi && vsi->netdev)\n\t\tnetif_device_attach(vsi->netdev);\n\n\tice_update_pf_netdev_link(pf);\n\n\t/* tell the firmware we are up */\n\terr = ice_send_version(pf);\n\tif (err) {\n\t\tdev_err(dev, \"Rebuild failed due to error sending driver version: %d\\n\",\n\t\t\terr);\n\t\tgoto err_vsi_rebuild;\n\t}\n\n\tice_replay_post(hw);\n\n\t/* if we get here, reset flow is successful */\n\tclear_bit(ICE_RESET_FAILED, pf->state);\n\n\tice_plug_aux_dev(pf);\n\tif (ice_is_feature_supported(pf, ICE_F_SRIOV_LAG))\n\t\tice_lag_rebuild(pf);\n\n\t/* Restore timestamp mode settings after VSI rebuild */\n\tice_ptp_restore_timestamp_mode(pf);\n\treturn;\n\nerr_vsi_rebuild:\nerr_sched_init_port:\n\tice_sched_cleanup_all(hw);\nerr_init_ctrlq:\n\tice_shutdown_all_ctrlq(hw, false);\n\tset_bit(ICE_RESET_FAILED, pf->state);\nclear_recovery:\n\t/* set this bit in PF state to control service task scheduling */\n\tset_bit(ICE_NEEDS_RESTART, pf->state);\n\tdev_err(dev, \"Rebuild failed, unload and reload driver\\n\");\n}\n",
      "cve_list": [
        "CVE-2024-46770"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/amdgpu/nbio_v7_4.c",
      "func_name": "nbio_v7_4_handle_ras_controller_intr_no_bifring",
      "func_body": "static void nbio_v7_4_handle_ras_controller_intr_no_bifring(struct amdgpu_device *adev)\n{\n\tuint32_t bif_doorbell_intr_cntl;\n\tstruct ras_manager *obj = amdgpu_ras_find_obj(adev, adev->nbio.ras_if);\n\tstruct ras_err_data err_data;\n\tstruct amdgpu_ras *ras = amdgpu_ras_get_context(adev);\n\n\tif (amdgpu_ras_error_data_init(&err_data))\n\t\treturn;\n\n\tif (adev->asic_type == CHIP_ALDEBARAN)\n\t\tbif_doorbell_intr_cntl = RREG32_SOC15(NBIO, 0, mmBIF_DOORBELL_INT_CNTL_ALDE);\n\telse\n\t\tbif_doorbell_intr_cntl = RREG32_SOC15(NBIO, 0, mmBIF_DOORBELL_INT_CNTL);\n\n\tif (REG_GET_FIELD(bif_doorbell_intr_cntl,\n\t\tBIF_DOORBELL_INT_CNTL, RAS_CNTLR_INTERRUPT_STATUS)) {\n\t\t/* driver has to clear the interrupt status when bif ring is disabled */\n\t\tbif_doorbell_intr_cntl = REG_SET_FIELD(bif_doorbell_intr_cntl,\n\t\t\t\t\t\tBIF_DOORBELL_INT_CNTL,\n\t\t\t\t\t\tRAS_CNTLR_INTERRUPT_CLEAR, 1);\n\t\tif (adev->asic_type == CHIP_ALDEBARAN)\n\t\t\tWREG32_SOC15(NBIO, 0, mmBIF_DOORBELL_INT_CNTL_ALDE, bif_doorbell_intr_cntl);\n\t\telse\n\t\t\tWREG32_SOC15(NBIO, 0, mmBIF_DOORBELL_INT_CNTL, bif_doorbell_intr_cntl);\n\n\t\tif (ras && !ras->disable_ras_err_cnt_harvest && obj) {\n\t\t\t/*\n\t\t\t * clear error status after ras_controller_intr\n\t\t\t * according to hw team and count ue number\n\t\t\t * for query\n\t\t\t */\n\t\t\tnbio_v7_4_query_ras_error_count(adev, &err_data);\n\n\t\t\t/* logging on error cnt and printing for awareness */\n\t\t\tobj->err_data.ue_count += err_data.ue_count;\n\t\t\tobj->err_data.ce_count += err_data.ce_count;\n\n\t\t\tif (err_data.ce_count)\n\t\t\t\tdev_info(adev->dev, \"%ld correctable hardware \"\n\t\t\t\t\t\t\"errors detected in %s block\\n\",\n\t\t\t\t\t\tobj->err_data.ce_count,\n\t\t\t\t\t\tget_ras_block_str(adev->nbio.ras_if));\n\n\t\t\tif (err_data.ue_count)\n\t\t\t\tdev_info(adev->dev, \"%ld uncorrectable hardware \"\n\t\t\t\t\t\t\"errors detected in %s block\\n\",\n\t\t\t\t\t\tobj->err_data.ue_count,\n\t\t\t\t\t\tget_ras_block_str(adev->nbio.ras_if));\n\t\t}\n\n\t\tdev_info(adev->dev, \"RAS controller interrupt triggered \"\n\t\t\t\t\t\"by NBIF error\\n\");\n\n\t\t/* ras_controller_int is dedicated for nbif ras error,\n\t\t * not the global interrupt for sync flood\n\t\t */\n\t\tamdgpu_ras_reset_gpu(adev);\n\t}\n\n\tamdgpu_ras_error_data_fini(&err_data);\n}\n",
      "cve_list": [
        "CVE-2024-46819"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c",
      "func_name": "smu7_apply_state_adjust_rules",
      "func_body": "static int smu7_apply_state_adjust_rules(struct pp_hwmgr *hwmgr,\n\t\t\t\tstruct pp_power_state *request_ps,\n\t\t\tconst struct pp_power_state *current_ps)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tstruct smu7_power_state *smu7_ps;\n\tuint32_t sclk;\n\tuint32_t mclk;\n\tstruct PP_Clocks minimum_clocks = {0};\n\tbool disable_mclk_switching;\n\tbool disable_mclk_switching_for_frame_lock;\n\tbool disable_mclk_switching_for_display;\n\tconst struct phm_clock_and_voltage_limits *max_limits;\n\tuint32_t i;\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\tint32_t count;\n\tint32_t stable_pstate_sclk = 0, stable_pstate_mclk = 0;\n\tuint32_t latency;\n\tbool latency_allowed = false;\n\n\tsmu7_ps = cast_phw_smu7_power_state(&request_ps->hardware);\n\tif (!smu7_ps)\n\t\treturn -EINVAL;\n\n\tdata->battery_state = (PP_StateUILabel_Battery ==\n\t\t\trequest_ps->classification.ui_label);\n\tdata->mclk_ignore_signal = false;\n\n\tmax_limits = adev->pm.ac_power ?\n\t\t\t&(hwmgr->dyn_state.max_clock_voltage_on_ac) :\n\t\t\t&(hwmgr->dyn_state.max_clock_voltage_on_dc);\n\n\t/* Cap clock DPM tables at DC MAX if it is in DC. */\n\tif (!adev->pm.ac_power) {\n\t\tfor (i = 0; i < smu7_ps->performance_level_count; i++) {\n\t\t\tif (smu7_ps->performance_levels[i].memory_clock > max_limits->mclk)\n\t\t\t\tsmu7_ps->performance_levels[i].memory_clock = max_limits->mclk;\n\t\t\tif (smu7_ps->performance_levels[i].engine_clock > max_limits->sclk)\n\t\t\t\tsmu7_ps->performance_levels[i].engine_clock = max_limits->sclk;\n\t\t}\n\t}\n\n\tminimum_clocks.engineClock = hwmgr->display_config->min_core_set_clock;\n\tminimum_clocks.memoryClock = hwmgr->display_config->min_mem_set_clock;\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_StablePState)) {\n\t\tmax_limits = &(hwmgr->dyn_state.max_clock_voltage_on_ac);\n\t\tstable_pstate_sclk = (max_limits->sclk * 75) / 100;\n\n\t\tfor (count = table_info->vdd_dep_on_sclk->count - 1;\n\t\t\t\tcount >= 0; count--) {\n\t\t\tif (stable_pstate_sclk >=\n\t\t\t\t\ttable_info->vdd_dep_on_sclk->entries[count].clk) {\n\t\t\t\tstable_pstate_sclk =\n\t\t\t\t\t\ttable_info->vdd_dep_on_sclk->entries[count].clk;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (count < 0)\n\t\t\tstable_pstate_sclk = table_info->vdd_dep_on_sclk->entries[0].clk;\n\n\t\tstable_pstate_mclk = max_limits->mclk;\n\n\t\tminimum_clocks.engineClock = stable_pstate_sclk;\n\t\tminimum_clocks.memoryClock = stable_pstate_mclk;\n\t}\n\n\tdisable_mclk_switching_for_frame_lock = phm_cap_enabled(\n\t\t\t\t    hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t    PHM_PlatformCaps_DisableMclkSwitchingForFrameLock);\n\n\tdisable_mclk_switching_for_display = ((1 < hwmgr->display_config->num_display) &&\n\t\t\t\t\t\t!hwmgr->display_config->multi_monitor_in_sync) ||\n\t\t\t\t\t\t(hwmgr->display_config->num_display &&\n\t\t\t\t\t\tsmu7_vblank_too_short(hwmgr, hwmgr->display_config->min_vblank_time));\n\n\tdisable_mclk_switching = disable_mclk_switching_for_frame_lock ||\n\t\t\t\t\t disable_mclk_switching_for_display;\n\n\tif (hwmgr->display_config->num_display == 0) {\n\t\tif (hwmgr->chip_id >= CHIP_POLARIS10 && hwmgr->chip_id <= CHIP_VEGAM)\n\t\t\tdata->mclk_ignore_signal = true;\n\t\telse\n\t\t\tdisable_mclk_switching = false;\n\t}\n\n\tsclk = smu7_ps->performance_levels[0].engine_clock;\n\tmclk = smu7_ps->performance_levels[0].memory_clock;\n\n\tif (disable_mclk_switching &&\n\t    (!(hwmgr->chip_id >= CHIP_POLARIS10 &&\n\t    hwmgr->chip_id <= CHIP_VEGAM)))\n\t\tmclk = smu7_ps->performance_levels\n\t\t[smu7_ps->performance_level_count - 1].memory_clock;\n\n\tif (sclk < minimum_clocks.engineClock)\n\t\tsclk = (minimum_clocks.engineClock > max_limits->sclk) ?\n\t\t\t\tmax_limits->sclk : minimum_clocks.engineClock;\n\n\tif (mclk < minimum_clocks.memoryClock)\n\t\tmclk = (minimum_clocks.memoryClock > max_limits->mclk) ?\n\t\t\t\tmax_limits->mclk : minimum_clocks.memoryClock;\n\n\tsmu7_ps->performance_levels[0].engine_clock = sclk;\n\tsmu7_ps->performance_levels[0].memory_clock = mclk;\n\n\tsmu7_ps->performance_levels[1].engine_clock =\n\t\t(smu7_ps->performance_levels[1].engine_clock >=\n\t\t\t\tsmu7_ps->performance_levels[0].engine_clock) ?\n\t\t\t\t\t\tsmu7_ps->performance_levels[1].engine_clock :\n\t\t\t\t\t\tsmu7_ps->performance_levels[0].engine_clock;\n\n\tif (disable_mclk_switching) {\n\t\tif (mclk < smu7_ps->performance_levels[1].memory_clock)\n\t\t\tmclk = smu7_ps->performance_levels[1].memory_clock;\n\n\t\tif (hwmgr->chip_id >= CHIP_POLARIS10 && hwmgr->chip_id <= CHIP_VEGAM) {\n\t\t\tif (disable_mclk_switching_for_display) {\n\t\t\t\t/* Find the lowest MCLK frequency that is within\n\t\t\t\t * the tolerable latency defined in DAL\n\t\t\t\t */\n\t\t\t\tlatency = hwmgr->display_config->dce_tolerable_mclk_in_active_latency;\n\t\t\t\tfor (i = 0; i < data->mclk_latency_table.count; i++) {\n\t\t\t\t\tif (data->mclk_latency_table.entries[i].latency <= latency) {\n\t\t\t\t\t\tlatency_allowed = true;\n\n\t\t\t\t\t\tif ((data->mclk_latency_table.entries[i].frequency >=\n\t\t\t\t\t\t\t\tsmu7_ps->performance_levels[0].memory_clock) &&\n\t\t\t\t\t\t    (data->mclk_latency_table.entries[i].frequency <=\n\t\t\t\t\t\t\t\tsmu7_ps->performance_levels[1].memory_clock)) {\n\t\t\t\t\t\t\tmclk = data->mclk_latency_table.entries[i].frequency;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((i >= data->mclk_latency_table.count - 1) && !latency_allowed) {\n\t\t\t\t\tdata->mclk_ignore_signal = true;\n\t\t\t\t} else {\n\t\t\t\t\tdata->mclk_ignore_signal = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (disable_mclk_switching_for_frame_lock)\n\t\t\t\tmclk = smu7_ps->performance_levels[1].memory_clock;\n\t\t}\n\n\t\tsmu7_ps->performance_levels[0].memory_clock = mclk;\n\n\t\tif (!(hwmgr->chip_id >= CHIP_POLARIS10 &&\n\t\t      hwmgr->chip_id <= CHIP_VEGAM))\n\t\t\tsmu7_ps->performance_levels[1].memory_clock = mclk;\n\t} else {\n\t\tif (smu7_ps->performance_levels[1].memory_clock <\n\t\t\t\tsmu7_ps->performance_levels[0].memory_clock)\n\t\t\tsmu7_ps->performance_levels[1].memory_clock =\n\t\t\t\t\tsmu7_ps->performance_levels[0].memory_clock;\n\t}\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_StablePState)) {\n\t\tfor (i = 0; i < smu7_ps->performance_level_count; i++) {\n\t\t\tsmu7_ps->performance_levels[i].engine_clock = stable_pstate_sclk;\n\t\t\tsmu7_ps->performance_levels[i].memory_clock = stable_pstate_mclk;\n\t\t\tsmu7_ps->performance_levels[i].pcie_gen = data->pcie_gen_performance.max;\n\t\t\tsmu7_ps->performance_levels[i].pcie_lane = data->pcie_gen_performance.max;\n\t\t}\n\t}\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-43907"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu8_hwmgr.c",
      "func_name": "smu8_apply_state_adjust_rules",
      "func_body": "static int smu8_apply_state_adjust_rules(struct pp_hwmgr *hwmgr,\n\t\t\t\tstruct pp_power_state  *prequest_ps,\n\t\t\tconst struct pp_power_state *pcurrent_ps)\n{\n\tstruct smu8_power_state *smu8_ps;\n\tconst struct smu8_power_state *smu8_current_ps;\n\tstruct smu8_hwmgr *data = hwmgr->backend;\n\tstruct PP_Clocks clocks = {0, 0, 0, 0};\n\tbool force_high;\n\n\tsmu8_ps = cast_smu8_power_state(&prequest_ps->hardware);\n\tsmu8_current_ps = cast_const_smu8_power_state(&pcurrent_ps->hardware);\n\n\tif (!smu8_ps || !smu8_current_ps)\n\t\treturn -EINVAL;\n\n\tsmu8_ps->need_dfs_bypass = true;\n\n\tdata->battery_state = (PP_StateUILabel_Battery == prequest_ps->classification.ui_label);\n\n\tclocks.memoryClock = hwmgr->display_config->min_mem_set_clock != 0 ?\n\t\t\t\thwmgr->display_config->min_mem_set_clock :\n\t\t\t\tdata->sys_info.nbp_memory_clock[1];\n\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_StablePState))\n\t\tclocks.memoryClock = hwmgr->dyn_state.max_clock_voltage_on_ac.mclk;\n\n\tforce_high = (clocks.memoryClock > data->sys_info.nbp_memory_clock[SMU8_NUM_NBPMEMORYCLOCK - 1])\n\t\t\t|| (hwmgr->display_config->num_display >= 3);\n\n\tsmu8_ps->action = smu8_current_ps->action;\n\n\tif (hwmgr->request_dpm_level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK)\n\t\tsmu8_nbdpm_pstate_enable_disable(hwmgr, false, false);\n\telse if (hwmgr->request_dpm_level == AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD)\n\t\tsmu8_nbdpm_pstate_enable_disable(hwmgr, false, true);\n\telse if (!force_high && (smu8_ps->action == FORCE_HIGH))\n\t\tsmu8_ps->action = CANCEL_FORCE_HIGH;\n\telse if (force_high && (smu8_ps->action != FORCE_HIGH))\n\t\tsmu8_ps->action = FORCE_HIGH;\n\telse\n\t\tsmu8_ps->action = DO_NOTHING;\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-43907"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c",
      "func_name": "vega10_apply_state_adjust_rules",
      "func_body": "static int vega10_apply_state_adjust_rules(struct pp_hwmgr *hwmgr,\n\t\t\t\tstruct pp_power_state  *request_ps,\n\t\t\tconst struct pp_power_state *current_ps)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tstruct vega10_power_state *vega10_ps;\n\tuint32_t sclk;\n\tuint32_t mclk;\n\tstruct PP_Clocks minimum_clocks = {0};\n\tbool disable_mclk_switching;\n\tbool disable_mclk_switching_for_frame_lock;\n\tbool disable_mclk_switching_for_vr;\n\tbool force_mclk_high;\n\tconst struct phm_clock_and_voltage_limits *max_limits;\n\tuint32_t i;\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\tint32_t count;\n\tuint32_t stable_pstate_sclk_dpm_percentage;\n\tuint32_t stable_pstate_sclk = 0, stable_pstate_mclk = 0;\n\tuint32_t latency;\n\n\tvega10_ps = cast_phw_vega10_power_state(&request_ps->hardware);\n\tif (!vega10_ps)\n\t\treturn -EINVAL;\n\n\tdata->battery_state = (PP_StateUILabel_Battery ==\n\t\t\trequest_ps->classification.ui_label);\n\n\tif (vega10_ps->performance_level_count != 2)\n\t\tpr_info(\"VI should always have 2 performance levels\");\n\n\tmax_limits = adev->pm.ac_power ?\n\t\t\t&(hwmgr->dyn_state.max_clock_voltage_on_ac) :\n\t\t\t&(hwmgr->dyn_state.max_clock_voltage_on_dc);\n\n\t/* Cap clock DPM tables at DC MAX if it is in DC. */\n\tif (!adev->pm.ac_power) {\n\t\tfor (i = 0; i < vega10_ps->performance_level_count; i++) {\n\t\t\tif (vega10_ps->performance_levels[i].mem_clock >\n\t\t\t\tmax_limits->mclk)\n\t\t\t\tvega10_ps->performance_levels[i].mem_clock =\n\t\t\t\t\t\tmax_limits->mclk;\n\t\t\tif (vega10_ps->performance_levels[i].gfx_clock >\n\t\t\t\tmax_limits->sclk)\n\t\t\t\tvega10_ps->performance_levels[i].gfx_clock =\n\t\t\t\t\t\tmax_limits->sclk;\n\t\t}\n\t}\n\n\t/* result = PHM_CheckVBlankTime(hwmgr, &vblankTooShort);*/\n\tminimum_clocks.engineClock = hwmgr->display_config->min_core_set_clock;\n\tminimum_clocks.memoryClock = hwmgr->display_config->min_mem_set_clock;\n\n\tif (PP_CAP(PHM_PlatformCaps_StablePState)) {\n\t\tstable_pstate_sclk_dpm_percentage =\n\t\t\tdata->registry_data.stable_pstate_sclk_dpm_percentage;\n\t\tPP_ASSERT_WITH_CODE(\n\t\t\tdata->registry_data.stable_pstate_sclk_dpm_percentage >= 1 &&\n\t\t\tdata->registry_data.stable_pstate_sclk_dpm_percentage <= 100,\n\t\t\t\"percent sclk value must range from 1% to 100%, setting default value\",\n\t\t\tstable_pstate_sclk_dpm_percentage = 75);\n\n\t\tmax_limits = &(hwmgr->dyn_state.max_clock_voltage_on_ac);\n\t\tstable_pstate_sclk = (max_limits->sclk *\n\t\t\t\tstable_pstate_sclk_dpm_percentage) / 100;\n\n\t\tfor (count = table_info->vdd_dep_on_sclk->count - 1;\n\t\t\t\tcount >= 0; count--) {\n\t\t\tif (stable_pstate_sclk >=\n\t\t\t\t\ttable_info->vdd_dep_on_sclk->entries[count].clk) {\n\t\t\t\tstable_pstate_sclk =\n\t\t\t\t\t\ttable_info->vdd_dep_on_sclk->entries[count].clk;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (count < 0)\n\t\t\tstable_pstate_sclk = table_info->vdd_dep_on_sclk->entries[0].clk;\n\n\t\tstable_pstate_mclk = max_limits->mclk;\n\n\t\tminimum_clocks.engineClock = stable_pstate_sclk;\n\t\tminimum_clocks.memoryClock = stable_pstate_mclk;\n\t}\n\n\tdisable_mclk_switching_for_frame_lock =\n\t\tPP_CAP(PHM_PlatformCaps_DisableMclkSwitchingForFrameLock);\n\tdisable_mclk_switching_for_vr =\n\t\tPP_CAP(PHM_PlatformCaps_DisableMclkSwitchForVR);\n\tforce_mclk_high = PP_CAP(PHM_PlatformCaps_ForceMclkHigh);\n\n\tif (hwmgr->display_config->num_display == 0)\n\t\tdisable_mclk_switching = false;\n\telse\n\t\tdisable_mclk_switching = ((1 < hwmgr->display_config->num_display) &&\n\t\t\t\t\t  !hwmgr->display_config->multi_monitor_in_sync) ||\n\t\t\tdisable_mclk_switching_for_frame_lock ||\n\t\t\tdisable_mclk_switching_for_vr ||\n\t\t\tforce_mclk_high;\n\n\tsclk = vega10_ps->performance_levels[0].gfx_clock;\n\tmclk = vega10_ps->performance_levels[0].mem_clock;\n\n\tif (sclk < minimum_clocks.engineClock)\n\t\tsclk = (minimum_clocks.engineClock > max_limits->sclk) ?\n\t\t\t\tmax_limits->sclk : minimum_clocks.engineClock;\n\n\tif (mclk < minimum_clocks.memoryClock)\n\t\tmclk = (minimum_clocks.memoryClock > max_limits->mclk) ?\n\t\t\t\tmax_limits->mclk : minimum_clocks.memoryClock;\n\n\tvega10_ps->performance_levels[0].gfx_clock = sclk;\n\tvega10_ps->performance_levels[0].mem_clock = mclk;\n\n\tif (vega10_ps->performance_levels[1].gfx_clock <\n\t\t\tvega10_ps->performance_levels[0].gfx_clock)\n\t\tvega10_ps->performance_levels[0].gfx_clock =\n\t\t\t\tvega10_ps->performance_levels[1].gfx_clock;\n\n\tif (disable_mclk_switching) {\n\t\t/* Set Mclk the max of level 0 and level 1 */\n\t\tif (mclk < vega10_ps->performance_levels[1].mem_clock)\n\t\t\tmclk = vega10_ps->performance_levels[1].mem_clock;\n\n\t\t/* Find the lowest MCLK frequency that is within\n\t\t * the tolerable latency defined in DAL\n\t\t */\n\t\tlatency = hwmgr->display_config->dce_tolerable_mclk_in_active_latency;\n\t\tfor (i = 0; i < data->mclk_latency_table.count; i++) {\n\t\t\tif ((data->mclk_latency_table.entries[i].latency <= latency) &&\n\t\t\t\t(data->mclk_latency_table.entries[i].frequency >=\n\t\t\t\t\t\tvega10_ps->performance_levels[0].mem_clock) &&\n\t\t\t\t(data->mclk_latency_table.entries[i].frequency <=\n\t\t\t\t\t\tvega10_ps->performance_levels[1].mem_clock))\n\t\t\t\tmclk = data->mclk_latency_table.entries[i].frequency;\n\t\t}\n\t\tvega10_ps->performance_levels[0].mem_clock = mclk;\n\t} else {\n\t\tif (vega10_ps->performance_levels[1].mem_clock <\n\t\t\t\tvega10_ps->performance_levels[0].mem_clock)\n\t\t\tvega10_ps->performance_levels[0].mem_clock =\n\t\t\t\t\tvega10_ps->performance_levels[1].mem_clock;\n\t}\n\n\tif (PP_CAP(PHM_PlatformCaps_StablePState)) {\n\t\tfor (i = 0; i < vega10_ps->performance_level_count; i++) {\n\t\t\tvega10_ps->performance_levels[i].gfx_clock = stable_pstate_sclk;\n\t\t\tvega10_ps->performance_levels[i].mem_clock = stable_pstate_mclk;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-43907"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/ipv6/xfrm6_policy.c",
      "func_name": "xfrm6_get_saddr",
      "func_body": "static int xfrm6_get_saddr(struct net *net, int oif,\n\t\t\t   xfrm_address_t *saddr, xfrm_address_t *daddr,\n\t\t\t   u32 mark)\n{\n\tstruct dst_entry *dst;\n\tstruct net_device *dev;\n\tstruct inet6_dev *idev;\n\n\tdst = xfrm6_dst_lookup(net, 0, oif, NULL, daddr, mark);\n\tif (IS_ERR(dst))\n\t\treturn -EHOSTUNREACH;\n\n\tidev = ip6_dst_idev(dst);\n\tif (!idev) {\n\t\tdst_release(dst);\n\t\treturn -EHOSTUNREACH;\n\t}\n\tdev = idev->dev;\n\tipv6_dev_get_saddr(dev_net(dev), dev, &daddr->in6, 0, &saddr->in6);\n\tdst_release(dst);\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-40959"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/tracefs/event_inode.c",
      "func_name": "eventfs_find_events",
      "func_body": "static struct eventfs_inode *eventfs_find_events(struct dentry *dentry)\n{\n\tstruct eventfs_inode *ei;\n\n\tdo {\n\t\t// The parent is stable because we do not do renames\n\t\tdentry = dentry->d_parent;\n\t\t// ... and directories always have d_fsdata\n\t\tei = dentry->d_fsdata;\n\n\t\t/*\n\t\t * If the ei is being freed, the ownership of the children\n\t\t * doesn't matter.\n\t\t */\n\t\tif (ei->is_freed)\n\t\t\treturn NULL;\n\n\t\t// Walk upwards until you find the events inode\n\t} while (!ei->is_events);\n\n\tupdate_events_attr(ei, dentry->d_sb);\n\n\treturn ei;\n}\n",
      "cve_list": [
        "CVE-2024-39470"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/thermal/qcom/tsens.c",
      "func_name": "compute_intercept_slope",
      "func_body": "void compute_intercept_slope(struct tsens_priv *priv, u32 *p1,\n\t\t\t     u32 *p2, u32 mode)\n{\n\tint i;\n\tint num, den;\n\n\tfor (i = 0; i < priv->num_sensors; i++) {\n\t\tdev_dbg(priv->dev,\n\t\t\t\"%s: sensor%d - data_point1:%#x data_point2:%#x\\n\",\n\t\t\t__func__, i, p1[i], p2 ? p2[i] : 0);\n\n\t\tif (!priv->sensor[i].slope)\n\t\t\tpriv->sensor[i].slope = SLOPE_DEFAULT;\n\t\tif (mode == TWO_PT_CALIB || mode == TWO_PT_CALIB_NO_OFFSET) {\n\t\t\t/*\n\t\t\t * slope (m) = adc_code2 - adc_code1 (y2 - y1)/\n\t\t\t *\ttemp_120_degc - temp_30_degc (x2 - x1)\n\t\t\t */\n\t\t\tnum = p2[i] - p1[i];\n\t\t\tnum *= SLOPE_FACTOR;\n\t\t\tden = CAL_DEGC_PT2 - CAL_DEGC_PT1;\n\t\t\tpriv->sensor[i].slope = num / den;\n\t\t}\n\n\t\tpriv->sensor[i].offset = (p1[i] * SLOPE_FACTOR) -\n\t\t\t\t(CAL_DEGC_PT1 *\n\t\t\t\tpriv->sensor[i].slope);\n\t\tdev_dbg(priv->dev, \"%s: offset:%d\\n\", __func__,\n\t\t\tpriv->sensor[i].offset);\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-38571"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/thermal/qcom/lmh.c",
      "func_name": "lmh_probe",
      "func_body": "static int lmh_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *cpu_node;\n\tstruct lmh_hw_data *lmh_data;\n\tint temp_low, temp_high, temp_arm, cpu_id, ret;\n\tunsigned int enable_alg;\n\tu32 node_id;\n\n\tif (!qcom_scm_is_available())\n\t\treturn -EPROBE_DEFER;\n\n\tlmh_data = devm_kzalloc(dev, sizeof(*lmh_data), GFP_KERNEL);\n\tif (!lmh_data)\n\t\treturn -ENOMEM;\n\n\tlmh_data->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(lmh_data->base))\n\t\treturn PTR_ERR(lmh_data->base);\n\n\tcpu_node = of_parse_phandle(np, \"cpus\", 0);\n\tif (!cpu_node)\n\t\treturn -EINVAL;\n\tcpu_id = of_cpu_node_to_id(cpu_node);\n\tof_node_put(cpu_node);\n\n\tret = of_property_read_u32(np, \"qcom,lmh-temp-high-millicelsius\", &temp_high);\n\tif (ret) {\n\t\tdev_err(dev, \"missing qcom,lmh-temp-high-millicelsius property\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(np, \"qcom,lmh-temp-low-millicelsius\", &temp_low);\n\tif (ret) {\n\t\tdev_err(dev, \"missing qcom,lmh-temp-low-millicelsius property\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(np, \"qcom,lmh-temp-arm-millicelsius\", &temp_arm);\n\tif (ret) {\n\t\tdev_err(dev, \"missing qcom,lmh-temp-arm-millicelsius property\\n\");\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Only sdm845 has lmh hardware currently enabled from hlos. If this is needed\n\t * for other platforms, revisit this to check if the <cpu-id, node-id> should be part\n\t * of a dt match table.\n\t */\n\tif (cpu_id == 0) {\n\t\tnode_id = LMH_CLUSTER0_NODE_ID;\n\t} else if (cpu_id == 4) {\n\t\tnode_id = LMH_CLUSTER1_NODE_ID;\n\t} else {\n\t\tdev_err(dev, \"Wrong CPU id associated with LMh node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!qcom_scm_lmh_dcvsh_available())\n\t\treturn -EINVAL;\n\n\tenable_alg = (uintptr_t)of_device_get_match_data(dev);\n\n\tif (enable_alg) {\n\t\tret = qcom_scm_lmh_dcvsh(LMH_SUB_FN_CRNT, LMH_ALGO_MODE_ENABLE, 1,\n\t\t\t\t\t LMH_NODE_DCVS, node_id, 0);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Error %d enabling current subfunction\\n\", ret);\n\n\t\tret = qcom_scm_lmh_dcvsh(LMH_SUB_FN_REL, LMH_ALGO_MODE_ENABLE, 1,\n\t\t\t\t\t LMH_NODE_DCVS, node_id, 0);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Error %d enabling reliability subfunction\\n\", ret);\n\n\t\tret = qcom_scm_lmh_dcvsh(LMH_SUB_FN_BCL, LMH_ALGO_MODE_ENABLE, 1,\n\t\t\t\t\t LMH_NODE_DCVS, node_id, 0);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Error %d enabling BCL subfunction\\n\", ret);\n\n\t\tret = qcom_scm_lmh_dcvsh(LMH_SUB_FN_THERMAL, LMH_ALGO_MODE_ENABLE, 1,\n\t\t\t\t\t LMH_NODE_DCVS, node_id, 0);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Error %d enabling thermal subfunction\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = qcom_scm_lmh_profile_change(0x1);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Error %d changing profile\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Set default thermal trips */\n\tret = qcom_scm_lmh_dcvsh(LMH_SUB_FN_THERMAL, LMH_TH_ARM_THRESHOLD, temp_arm,\n\t\t\t\t LMH_NODE_DCVS, node_id, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"Error setting thermal ARM threshold%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = qcom_scm_lmh_dcvsh(LMH_SUB_FN_THERMAL, LMH_TH_HI_THRESHOLD, temp_high,\n\t\t\t\t LMH_NODE_DCVS, node_id, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"Error setting thermal HI threshold%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = qcom_scm_lmh_dcvsh(LMH_SUB_FN_THERMAL, LMH_TH_LOW_THRESHOLD, temp_low,\n\t\t\t\t LMH_NODE_DCVS, node_id, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"Error setting thermal ARM threshold%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tlmh_data->irq = platform_get_irq(pdev, 0);\n\tlmh_data->domain = irq_domain_add_linear(np, 1, &lmh_irq_ops, lmh_data);\n\tif (!lmh_data->domain) {\n\t\tdev_err(dev, \"Error adding irq_domain\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Disable the irq and let cpufreq enable it when ready to handle the interrupt */\n\tirq_set_status_flags(lmh_data->irq, IRQ_NOAUTOEN);\n\tret = devm_request_irq(dev, lmh_data->irq, lmh_handle_irq,\n\t\t\t       IRQF_ONESHOT | IRQF_NO_SUSPEND,\n\t\t\t       \"lmh-irq\", lmh_data);\n\tif (ret) {\n\t\tdev_err(dev, \"Error %d registering irq %x\\n\", ret, lmh_data->irq);\n\t\tirq_domain_remove(lmh_data->domain);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-39466"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "sound/soc/codecs/cs-amp-lib.c",
      "func_name": "cs_amp_get_efi_variable",
      "func_body": "static efi_status_t cs_amp_get_efi_variable(efi_char16_t *name,\n\t\t\t\t\t    efi_guid_t *guid,\n\t\t\t\t\t    unsigned long *size,\n\t\t\t\t\t    void *buf)\n{\n\tu32 attr;\n\n\tKUNIT_STATIC_STUB_REDIRECT(cs_amp_get_efi_variable, name, guid, size, buf);\n\n\tif (efi_rt_services_supported(EFI_RT_SUPPORTED_GET_VARIABLE))\n\t\treturn efi.get_variable(name, guid, &attr, size, buf);\n\n\treturn EFI_NOT_FOUND;\n}\n",
      "cve_list": [
        "CVE-2024-43896"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/gtp.c",
      "func_name": "gtp_encap_enable_socket",
      "func_body": "static struct sock *gtp_encap_enable_socket(int fd, int type,\n\t\t\t\t\t    struct gtp_dev *gtp)\n{\n\tstruct udp_tunnel_sock_cfg tuncfg = {NULL};\n\tstruct socket *sock;\n\tstruct sock *sk;\n\tint err;\n\n\tpr_debug(\"enable gtp on %d, %d\\n\", fd, type);\n\n\tsock = sockfd_lookup(fd, &err);\n\tif (!sock) {\n\t\tpr_debug(\"gtp socket fd=%d not found\\n\", fd);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tsk = sock->sk;\n\tif (sk->sk_protocol != IPPROTO_UDP ||\n\t    sk->sk_type != SOCK_DGRAM ||\n\t    (sk->sk_family != AF_INET && sk->sk_family != AF_INET6)) {\n\t\tpr_debug(\"socket fd=%d not UDP\\n\", fd);\n\t\tsk = ERR_PTR(-EINVAL);\n\t\tgoto out_sock;\n\t}\n\n\tif (sk->sk_family == AF_INET6 &&\n\t    !sk->sk_ipv6only) {\n\t\tsk = ERR_PTR(-EADDRNOTAVAIL);\n\t\tgoto out_sock;\n\t}\n\n\tlock_sock(sk);\n\tif (sk->sk_user_data) {\n\t\tsk = ERR_PTR(-EBUSY);\n\t\tgoto out_rel_sock;\n\t}\n\n\tsock_hold(sk);\n\n\ttuncfg.sk_user_data = gtp;\n\ttuncfg.encap_type = type;\n\ttuncfg.encap_rcv = gtp_encap_recv;\n\ttuncfg.encap_destroy = gtp_encap_destroy;\n\n\tsetup_udp_tunnel_sock(sock_net(sock->sk), sock, &tuncfg);\n\nout_rel_sock:\n\trelease_sock(sock->sk);\nout_sock:\n\tsockfd_put(sock);\n\treturn sk;\n}\n",
      "cve_list": [
        "CVE-2024-46677"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/platform/x86/intel/vbtn.c",
      "func_name": "notify_handler",
      "func_body": "static void notify_handler(acpi_handle handle, u32 event, void *context)\n{\n\tstruct platform_device *device = context;\n\tstruct intel_vbtn_priv *priv = dev_get_drvdata(&device->dev);\n\tunsigned int val = !(event & 1); /* Even=press, Odd=release */\n\tconst struct key_entry *ke, *ke_rel;\n\tstruct input_dev *input_dev;\n\tbool autorelease;\n\tint ret;\n\n\tguard(mutex)(&priv->mutex);\n\n\tif ((ke = sparse_keymap_entry_from_scancode(priv->buttons_dev, event))) {\n\t\tif (!priv->has_buttons) {\n\t\t\tdev_warn(&device->dev, \"Warning: received 0x%02x button event on a device without buttons, please report this.\\n\",\n\t\t\t\t event);\n\t\t\treturn;\n\t\t}\n\t\tinput_dev = priv->buttons_dev;\n\t} else if ((ke = sparse_keymap_entry_from_scancode(priv->switches_dev, event))) {\n\t\tif (!priv->has_switches) {\n\t\t\t/* See dual_accel_detect.h for more info */\n\t\t\tif (priv->dual_accel)\n\t\t\t\treturn;\n\n\t\t\tdev_info(&device->dev, \"Registering Intel Virtual Switches input-dev after receiving a switch event\\n\");\n\t\t\tret = input_register_device(priv->switches_dev);\n\t\t\tif (ret)\n\t\t\t\treturn;\n\n\t\t\tpriv->has_switches = true;\n\t\t}\n\t\tinput_dev = priv->switches_dev;\n\t} else {\n\t\tdev_dbg(&device->dev, \"unknown event index 0x%x\\n\", event);\n\t\treturn;\n\t}\n\n\tif (priv->wakeup_mode) {\n\t\tpm_wakeup_hard_event(&device->dev);\n\n\t\t/*\n\t\t * Skip reporting an evdev event for button wake events,\n\t\t * mirroring how the drivers/acpi/button.c code skips this too.\n\t\t */\n\t\tif (ke->type == KE_KEY)\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Even press events are autorelease if there is no corresponding odd\n\t * release event, or if the odd event is KE_IGNORE.\n\t */\n\tke_rel = sparse_keymap_entry_from_scancode(input_dev, event | 1);\n\tautorelease = val && (!ke_rel || ke_rel->type == KE_IGNORE);\n\n\tsparse_keymap_report_event(input_dev, event, val, autorelease);\n}\n",
      "cve_list": [
        "CVE-2024-44937"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/pensando/ionic/ionic_txrx.c",
      "func_name": "ionic_run_xdp",
      "func_body": "static bool ionic_run_xdp(struct ionic_rx_stats *stats,\n\t\t\t  struct net_device *netdev,\n\t\t\t  struct bpf_prog *xdp_prog,\n\t\t\t  struct ionic_queue *rxq,\n\t\t\t  struct ionic_buf_info *buf_info,\n\t\t\t  int len)\n{\n\tu32 xdp_action = XDP_ABORTED;\n\tstruct xdp_buff xdp_buf;\n\tstruct ionic_queue *txq;\n\tstruct netdev_queue *nq;\n\tstruct xdp_frame *xdpf;\n\tint remain_len;\n\tint nbufs = 1;\n\tint frag_len;\n\tint err = 0;\n\n\txdp_init_buff(&xdp_buf, IONIC_PAGE_SIZE, rxq->xdp_rxq_info);\n\tfrag_len = min_t(u16, len, IONIC_XDP_MAX_LINEAR_MTU + VLAN_ETH_HLEN);\n\txdp_prepare_buff(&xdp_buf, ionic_rx_buf_va(buf_info),\n\t\t\t XDP_PACKET_HEADROOM, frag_len, false);\n\n\tdma_sync_single_range_for_cpu(rxq->dev, ionic_rx_buf_pa(buf_info),\n\t\t\t\t      XDP_PACKET_HEADROOM, len,\n\t\t\t\t      DMA_FROM_DEVICE);\n\n\tprefetchw(&xdp_buf.data_hard_start);\n\n\t/*  We limit MTU size to one buffer if !xdp_has_frags, so\n\t *  if the recv len is bigger than one buffer\n\t *     then we know we have frag info to gather\n\t */\n\tremain_len = len - frag_len;\n\tif (remain_len) {\n\t\tstruct skb_shared_info *sinfo;\n\t\tstruct ionic_buf_info *bi;\n\t\tskb_frag_t *frag;\n\n\t\tbi = buf_info;\n\t\tsinfo = xdp_get_shared_info_from_buff(&xdp_buf);\n\t\tsinfo->nr_frags = 0;\n\t\tsinfo->xdp_frags_size = 0;\n\t\txdp_buff_set_frags_flag(&xdp_buf);\n\n\t\tdo {\n\t\t\tif (unlikely(sinfo->nr_frags >= MAX_SKB_FRAGS)) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto out_xdp_abort;\n\t\t\t}\n\n\t\t\tfrag = &sinfo->frags[sinfo->nr_frags];\n\t\t\tsinfo->nr_frags++;\n\t\t\tbi++;\n\t\t\tfrag_len = min_t(u16, remain_len, ionic_rx_buf_size(bi));\n\t\t\tdma_sync_single_range_for_cpu(rxq->dev, ionic_rx_buf_pa(bi),\n\t\t\t\t\t\t      0, frag_len, DMA_FROM_DEVICE);\n\t\t\tskb_frag_fill_page_desc(frag, bi->page, 0, frag_len);\n\t\t\tsinfo->xdp_frags_size += frag_len;\n\t\t\tremain_len -= frag_len;\n\n\t\t\tif (page_is_pfmemalloc(bi->page))\n\t\t\t\txdp_buff_set_frag_pfmemalloc(&xdp_buf);\n\t\t} while (remain_len > 0);\n\t\tnbufs += sinfo->nr_frags;\n\t}\n\n\txdp_action = bpf_prog_run_xdp(xdp_prog, &xdp_buf);\n\n\tswitch (xdp_action) {\n\tcase XDP_PASS:\n\t\tstats->xdp_pass++;\n\t\treturn false;  /* false = we didn't consume the packet */\n\n\tcase XDP_DROP:\n\t\tionic_rx_page_free(rxq, buf_info);\n\t\tstats->xdp_drop++;\n\t\tbreak;\n\n\tcase XDP_TX:\n\t\txdpf = xdp_convert_buff_to_frame(&xdp_buf);\n\t\tif (!xdpf)\n\t\t\tgoto out_xdp_abort;\n\n\t\ttxq = rxq->partner;\n\t\tnq = netdev_get_tx_queue(netdev, txq->index);\n\t\t__netif_tx_lock(nq, smp_processor_id());\n\t\ttxq_trans_cond_update(nq);\n\n\t\tif (netif_tx_queue_stopped(nq) ||\n\t\t    !netif_txq_maybe_stop(q_to_ndq(netdev, txq),\n\t\t\t\t\t  ionic_q_space_avail(txq),\n\t\t\t\t\t  1, 1)) {\n\t\t\t__netif_tx_unlock(nq);\n\t\t\tgoto out_xdp_abort;\n\t\t}\n\n\t\terr = ionic_xdp_post_frame(txq, xdpf, XDP_TX,\n\t\t\t\t\t   buf_info->page,\n\t\t\t\t\t   buf_info->page_offset,\n\t\t\t\t\t   true);\n\t\t__netif_tx_unlock(nq);\n\t\tif (err) {\n\t\t\tnetdev_dbg(netdev, \"tx ionic_xdp_post_frame err %d\\n\", err);\n\t\t\tgoto out_xdp_abort;\n\t\t}\n\t\tionic_xdp_rx_put_bufs(rxq, buf_info, nbufs);\n\t\tstats->xdp_tx++;\n\n\t\t/* the Tx completion will free the buffers */\n\t\tbreak;\n\n\tcase XDP_REDIRECT:\n\t\terr = xdp_do_redirect(netdev, &xdp_buf, xdp_prog);\n\t\tif (err) {\n\t\t\tnetdev_dbg(netdev, \"xdp_do_redirect err %d\\n\", err);\n\t\t\tgoto out_xdp_abort;\n\t\t}\n\t\tionic_xdp_rx_put_bufs(rxq, buf_info, nbufs);\n\t\trxq->xdp_flush = true;\n\t\tstats->xdp_redirect++;\n\t\tbreak;\n\n\tcase XDP_ABORTED:\n\tdefault:\n\t\tgoto out_xdp_abort;\n\t}\n\n\treturn true;\n\nout_xdp_abort:\n\ttrace_xdp_exception(netdev, xdp_prog, xdp_action);\n\tionic_rx_page_free(rxq, buf_info);\n\tstats->xdp_aborted++;\n\n\treturn true;\n}\n",
      "cve_list": [
        "CVE-2024-42083"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/block/ublk_drv.c",
      "func_name": "ublk_ctrl_start_recovery",
      "func_body": "static int ublk_ctrl_start_recovery(struct ublk_device *ub,\n\t\tstruct io_uring_cmd *cmd)\n{\n\tconst struct ublksrv_ctrl_cmd *header = io_uring_sqe_cmd(cmd->sqe);\n\tint ret = -EINVAL;\n\tint i;\n\n\tmutex_lock(&ub->mutex);\n\tif (!ublk_can_use_recovery(ub))\n\t\tgoto out_unlock;\n\tif (!ub->nr_queues_ready)\n\t\tgoto out_unlock;\n\t/*\n\t * START_RECOVERY is only allowd after:\n\t *\n\t * (1) UB_STATE_OPEN is not set, which means the dying process is exited\n\t *     and related io_uring ctx is freed so file struct of /dev/ublkcX is\n\t *     released.\n\t *\n\t * (2) UBLK_S_DEV_QUIESCED is set, which means the quiesce_work:\n\t *     (a)has quiesced request queue\n\t *     (b)has requeued every inflight rqs whose io_flags is ACTIVE\n\t *     (c)has requeued/aborted every inflight rqs whose io_flags is NOT ACTIVE\n\t *     (d)has completed/camceled all ioucmds owned by ther dying process\n\t */\n\tif (test_bit(UB_STATE_OPEN, &ub->state) ||\n\t\t\tub->dev_info.state != UBLK_S_DEV_QUIESCED) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tpr_devel(\"%s: start recovery for dev id %d.\\n\", __func__, header->dev_id);\n\tfor (i = 0; i < ub->dev_info.nr_hw_queues; i++)\n\t\tublk_queue_reinit(ub, ublk_get_queue(ub, i));\n\t/* set to NULL, otherwise new ubq_daemon cannot mmap the io_cmd_buf */\n\tub->mm = NULL;\n\tub->nr_queues_ready = 0;\n\tub->nr_privileged_daemon = 0;\n\tinit_completion(&ub->completion);\n\tret = 0;\n out_unlock:\n\tmutex_unlock(&ub->mutex);\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-46735"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "sound/soc/fsl/fsl_qmc_audio.c",
      "func_name": "qmc_audio_dai_parse",
      "func_body": "static int qmc_audio_dai_parse(struct qmc_audio *qmc_audio, struct device_node *np,\n\tstruct qmc_dai *qmc_dai, struct snd_soc_dai_driver *qmc_soc_dai_driver)\n{\n\tstruct qmc_chan_info info;\n\tu32 val;\n\tint ret;\n\n\tqmc_dai->dev = qmc_audio->dev;\n\n\tret = of_property_read_u32(np, \"reg\", &val);\n\tif (ret) {\n\t\tdev_err(qmc_audio->dev, \"%pOF: failed to read reg\\n\", np);\n\t\treturn ret;\n\t}\n\tqmc_dai->id = val;\n\n\tqmc_dai->name = devm_kasprintf(qmc_audio->dev, GFP_KERNEL, \"%s.%d\",\n\t\t\t\t       np->parent->name, qmc_dai->id);\n\tif (!qmc_dai->name)\n\t\treturn -ENOMEM;\n\n\tqmc_dai->qmc_chan = devm_qmc_chan_get_byphandle(qmc_audio->dev, np,\n\t\t\t\t\t\t\t\"fsl,qmc-chan\");\n\tif (IS_ERR(qmc_dai->qmc_chan)) {\n\t\tret = PTR_ERR(qmc_dai->qmc_chan);\n\t\treturn dev_err_probe(qmc_audio->dev, ret,\n\t\t\t\t     \"dai %d get QMC channel failed\\n\", qmc_dai->id);\n\t}\n\n\tqmc_soc_dai_driver->id = qmc_dai->id;\n\tqmc_soc_dai_driver->name = qmc_dai->name;\n\n\tret = qmc_chan_get_info(qmc_dai->qmc_chan, &info);\n\tif (ret) {\n\t\tdev_err(qmc_audio->dev, \"dai %d get QMC channel info failed %d\\n\",\n\t\t\tqmc_dai->id, ret);\n\t\treturn ret;\n\t}\n\tdev_info(qmc_audio->dev, \"dai %d QMC channel mode %d, nb_tx_ts %u, nb_rx_ts %u\\n\",\n\t\t qmc_dai->id, info.mode, info.nb_tx_ts, info.nb_rx_ts);\n\n\tif (info.mode != QMC_TRANSPARENT) {\n\t\tdev_err(qmc_audio->dev, \"dai %d QMC chan mode %d is not QMC_TRANSPARENT\\n\",\n\t\t\tqmc_dai->id, info.mode);\n\t\treturn -EINVAL;\n\t}\n\tqmc_dai->nb_tx_ts = info.nb_tx_ts;\n\tqmc_dai->nb_rx_ts = info.nb_rx_ts;\n\n\tqmc_soc_dai_driver->playback.channels_min = 0;\n\tqmc_soc_dai_driver->playback.channels_max = 0;\n\tif (qmc_dai->nb_tx_ts) {\n\t\tqmc_soc_dai_driver->playback.channels_min = 1;\n\t\tqmc_soc_dai_driver->playback.channels_max = qmc_dai->nb_tx_ts;\n\t}\n\tqmc_soc_dai_driver->playback.formats = qmc_audio_formats(qmc_dai->nb_tx_ts);\n\n\tqmc_soc_dai_driver->capture.channels_min = 0;\n\tqmc_soc_dai_driver->capture.channels_max = 0;\n\tif (qmc_dai->nb_rx_ts) {\n\t\tqmc_soc_dai_driver->capture.channels_min = 1;\n\t\tqmc_soc_dai_driver->capture.channels_max = qmc_dai->nb_rx_ts;\n\t}\n\tqmc_soc_dai_driver->capture.formats = qmc_audio_formats(qmc_dai->nb_rx_ts);\n\n\tqmc_soc_dai_driver->playback.rates = snd_pcm_rate_to_rate_bit(info.tx_fs_rate);\n\tqmc_soc_dai_driver->playback.rate_min = info.tx_fs_rate;\n\tqmc_soc_dai_driver->playback.rate_max = info.tx_fs_rate;\n\tqmc_soc_dai_driver->capture.rates = snd_pcm_rate_to_rate_bit(info.rx_fs_rate);\n\tqmc_soc_dai_driver->capture.rate_min = info.rx_fs_rate;\n\tqmc_soc_dai_driver->capture.rate_max = info.rx_fs_rate;\n\n\tqmc_soc_dai_driver->ops = &qmc_dai_ops;\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-42298"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/infiniband/hw/cxgb4/cm.c",
      "func_name": "act_establish",
      "func_body": "static int act_establish(struct c4iw_dev *dev, struct sk_buff *skb)\n{\n\tstruct c4iw_ep *ep;\n\tstruct cpl_act_establish *req = cplhdr(skb);\n\tunsigned short tcp_opt = ntohs(req->tcp_opt);\n\tunsigned int tid = GET_TID(req);\n\tunsigned int atid = TID_TID_G(ntohl(req->tos_atid));\n\tstruct tid_info *t = dev->rdev.lldi.tids;\n\tint ret;\n\n\tep = lookup_atid(t, atid);\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"ep %p tid %u snd_isn %u rcv_isn %u\\n\", ep, tid,\n\t\t be32_to_cpu(req->snd_isn), be32_to_cpu(req->rcv_isn));\n\n\tmutex_lock(&ep->com.mutex);\n\tdst_confirm(ep->dst);\n\n\t/* setup the hwtid for this connection */\n\tep->hwtid = tid;\n\tcxgb4_insert_tid(t, ep, tid, ep->com.local_addr.ss_family);\n\tinsert_ep_tid(ep);\n\n\tep->snd_seq = be32_to_cpu(req->snd_isn);\n\tep->rcv_seq = be32_to_cpu(req->rcv_isn);\n\tep->snd_wscale = TCPOPT_SND_WSCALE_G(tcp_opt);\n\n\tset_emss(ep, tcp_opt);\n\n\t/* dealloc the atid */\n\txa_erase_irq(&ep->com.dev->atids, atid);\n\tcxgb4_free_atid(t, atid);\n\tset_bit(ACT_ESTAB, &ep->com.history);\n\n\t/* start MPA negotiation */\n\tret = send_flowc(ep);\n\tif (ret)\n\t\tgoto err;\n\tif (ep->retry_with_mpa_v1)\n\t\tret = send_mpa_req(ep, skb, 1);\n\telse\n\t\tret = send_mpa_req(ep, skb, mpa_rev);\n\tif (ret)\n\t\tgoto err;\n\tmutex_unlock(&ep->com.mutex);\n\treturn 0;\nerr:\n\tmutex_unlock(&ep->com.mutex);\n\tconnect_reply_upcall(ep, -ENOMEM);\n\tc4iw_ep_disconnect(ep, 0, GFP_KERNEL);\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-47749"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/infiniband/hw/cxgb4/cm.c",
      "func_name": "act_open_rpl",
      "func_body": "static int act_open_rpl(struct c4iw_dev *dev, struct sk_buff *skb)\n{\n\tstruct c4iw_ep *ep;\n\tstruct cpl_act_open_rpl *rpl = cplhdr(skb);\n\tunsigned int atid = TID_TID_G(AOPEN_ATID_G(\n\t\t\t\t      ntohl(rpl->atid_status)));\n\tstruct tid_info *t = dev->rdev.lldi.tids;\n\tint status = AOPEN_STATUS_G(ntohl(rpl->atid_status));\n\tstruct sockaddr_in *la;\n\tstruct sockaddr_in *ra;\n\tstruct sockaddr_in6 *la6;\n\tstruct sockaddr_in6 *ra6;\n\tint ret = 0;\n\n\tep = lookup_atid(t, atid);\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tla = (struct sockaddr_in *)&ep->com.local_addr;\n\tra = (struct sockaddr_in *)&ep->com.remote_addr;\n\tla6 = (struct sockaddr_in6 *)&ep->com.local_addr;\n\tra6 = (struct sockaddr_in6 *)&ep->com.remote_addr;\n\n\tpr_debug(\"ep %p atid %u status %u errno %d\\n\", ep, atid,\n\t\t status, status2errno(status));\n\n\tif (cxgb_is_neg_adv(status)) {\n\t\tpr_debug(\"Connection problems for atid %u status %u (%s)\\n\",\n\t\t\t atid, status, neg_adv_str(status));\n\t\tep->stats.connect_neg_adv++;\n\t\tmutex_lock(&dev->rdev.stats.lock);\n\t\tdev->rdev.stats.neg_adv++;\n\t\tmutex_unlock(&dev->rdev.stats.lock);\n\t\treturn 0;\n\t}\n\n\tset_bit(ACT_OPEN_RPL, &ep->com.history);\n\n\t/*\n\t * Log interesting failures.\n\t */\n\tswitch (status) {\n\tcase CPL_ERR_CONN_RESET:\n\tcase CPL_ERR_CONN_TIMEDOUT:\n\t\tbreak;\n\tcase CPL_ERR_TCAM_FULL:\n\t\tmutex_lock(&dev->rdev.stats.lock);\n\t\tdev->rdev.stats.tcam_full++;\n\t\tmutex_unlock(&dev->rdev.stats.lock);\n\t\tif (ep->com.local_addr.ss_family == AF_INET &&\n\t\t    dev->rdev.lldi.enable_fw_ofld_conn) {\n\t\t\tret = send_fw_act_open_req(ep, TID_TID_G(AOPEN_ATID_G(\n\t\t\t\t\t\t   ntohl(rpl->atid_status))));\n\t\t\tif (ret)\n\t\t\t\tgoto fail;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase CPL_ERR_CONN_EXIST:\n\t\tif (ep->retry_count++ < ACT_OPEN_RETRY_COUNT) {\n\t\t\tset_bit(ACT_RETRY_INUSE, &ep->com.history);\n\t\t\tif (ep->com.remote_addr.ss_family == AF_INET6) {\n\t\t\t\tstruct sockaddr_in6 *sin6 =\n\t\t\t\t\t\t(struct sockaddr_in6 *)\n\t\t\t\t\t\t&ep->com.local_addr;\n\t\t\t\tcxgb4_clip_release(\n\t\t\t\t\t\tep->com.dev->rdev.lldi.ports[0],\n\t\t\t\t\t\t(const u32 *)\n\t\t\t\t\t\t&sin6->sin6_addr.s6_addr, 1);\n\t\t\t}\n\t\t\txa_erase_irq(&ep->com.dev->atids, atid);\n\t\t\tcxgb4_free_atid(t, atid);\n\t\t\tdst_release(ep->dst);\n\t\t\tcxgb4_l2t_release(ep->l2t);\n\t\t\tc4iw_reconnect(ep);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (ep->com.local_addr.ss_family == AF_INET) {\n\t\t\tpr_info(\"Active open failure - atid %u status %u errno %d %pI4:%u->%pI4:%u\\n\",\n\t\t\t\tatid, status, status2errno(status),\n\t\t\t\t&la->sin_addr.s_addr, ntohs(la->sin_port),\n\t\t\t\t&ra->sin_addr.s_addr, ntohs(ra->sin_port));\n\t\t} else {\n\t\t\tpr_info(\"Active open failure - atid %u status %u errno %d %pI6:%u->%pI6:%u\\n\",\n\t\t\t\tatid, status, status2errno(status),\n\t\t\t\tla6->sin6_addr.s6_addr, ntohs(la6->sin6_port),\n\t\t\t\tra6->sin6_addr.s6_addr, ntohs(ra6->sin6_port));\n\t\t}\n\t\tbreak;\n\t}\n\nfail:\n\tconnect_reply_upcall(ep, status2errno(status));\n\tstate_set(&ep->com, DEAD);\n\n\tif (ep->com.remote_addr.ss_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *sin6 =\n\t\t\t(struct sockaddr_in6 *)&ep->com.local_addr;\n\t\tcxgb4_clip_release(ep->com.dev->rdev.lldi.ports[0],\n\t\t\t\t   (const u32 *)&sin6->sin6_addr.s6_addr, 1);\n\t}\n\tif (status && act_open_has_tid(status))\n\t\tcxgb4_remove_tid(ep->com.dev->rdev.lldi.tids, 0, GET_TID(rpl),\n\t\t\t\t ep->com.local_addr.ss_family);\n\n\txa_erase_irq(&ep->com.dev->atids, atid);\n\tcxgb4_free_atid(t, atid);\n\tdst_release(ep->dst);\n\tcxgb4_l2t_release(ep->l2t);\n\tc4iw_put_ep(&ep->com);\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-47749"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/dc/hwss/dcn35/dcn35_hwseq.c",
      "func_name": "dcn35_set_drr",
      "func_body": "void dcn35_set_drr(struct pipe_ctx **pipe_ctx,\n\t\tint num_pipes, struct dc_crtc_timing_adjust adjust)\n{\n\tint i = 0;\n\tstruct drr_params params = {0};\n\t// DRR set trigger event mapped to OTG_TRIG_A\n\tunsigned int event_triggers = 0x2;//Bit[1]: OTG_TRIG_A\n\t// Note DRR trigger events are generated regardless of whether num frames met.\n\tunsigned int num_frames = 2;\n\n\tparams.vertical_total_max = adjust.v_total_max;\n\tparams.vertical_total_min = adjust.v_total_min;\n\tparams.vertical_total_mid = adjust.v_total_mid;\n\tparams.vertical_total_mid_frame_num = adjust.v_total_mid_frame_num;\n\n\tfor (i = 0; i < num_pipes; i++) {\n\t\t/* dc_state_destruct() might null the stream resources, so fetch tg\n\t\t * here first to avoid a race condition. The lifetime of the pointee\n\t\t * itself (the timing_generator object) is not a problem here.\n\t\t */\n\t\tstruct timing_generator *tg = pipe_ctx[i]->stream_res.tg;\n\n\t\tif ((tg != NULL) && tg->funcs) {\n\t\t\tstruct dc_crtc_timing *timing = &pipe_ctx[i]->stream->timing;\n\t\t\tstruct dc *dc = pipe_ctx[i]->stream->ctx->dc;\n\n\t\t\tif (dc->debug.static_screen_wait_frames) {\n\t\t\t\tunsigned int frame_rate = timing->pix_clk_100hz / (timing->h_total * timing->v_total);\n\n\t\t\t\tif (frame_rate >= 120 && dc->caps.ips_support &&\n\t\t\t\t\tdc->config.disable_ips != DMUB_IPS_DISABLE_ALL) {\n\t\t\t\t\t/*ips enable case*/\n\t\t\t\t\tnum_frames = 2 * (frame_rate % 60);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tg->funcs->set_drr)\n\t\t\t\ttg->funcs->set_drr(tg, &params);\n\t\t\tif (adjust.v_total_max != 0 && adjust.v_total_min != 0)\n\t\t\t\tif (tg->funcs->set_static_screen_control)\n\t\t\t\t\ttg->funcs->set_static_screen_control(\n\t\t\t\t\t\ttg, event_triggers, num_frames);\n\t\t}\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-46850"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/netdevsim/netdev.c",
      "func_name": "nsim_destroy",
      "func_body": "void nsim_destroy(struct netdevsim *ns)\n{\n\tstruct net_device *dev = ns->netdev;\n\n\trtnl_lock();\n\tunregister_netdevice(dev);\n\tif (nsim_dev_port_is_pf(ns->nsim_dev_port)) {\n\t\tnsim_macsec_teardown(ns);\n\t\tnsim_ipsec_teardown(ns);\n\t\tnsim_bpf_uninit(ns);\n\t}\n\trtnl_unlock();\n\tif (nsim_dev_port_is_pf(ns->nsim_dev_port))\n\t\tnsim_exit_netdevsim(ns);\n\tfree_netdev(dev);\n}\n",
      "cve_list": [
        "CVE-2024-26587"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/scsi/qla2xxx/qla_nvme.c",
      "func_name": "qla_nvme_register_remote",
      "func_body": "int qla_nvme_register_remote(struct scsi_qla_host *vha, struct fc_port *fcport)\n{\n\tstruct qla_nvme_rport *rport;\n\tstruct nvme_fc_port_info req;\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_NVME_FC))\n\t\treturn 0;\n\n\tif (!vha->flags.nvme_enabled) {\n\t\tql_log(ql_log_info, vha, 0x2100,\n\t\t    \"%s: Not registering target since Host NVME is not enabled\\n\",\n\t\t    __func__);\n\t\treturn 0;\n\t}\n\n\tif (qla_nvme_register_hba(vha))\n\t\treturn 0;\n\n\tif (!vha->nvme_local_port)\n\t\treturn 0;\n\n\tif (!(fcport->nvme_prli_service_param &\n\t    (NVME_PRLI_SP_TARGET | NVME_PRLI_SP_DISCOVERY)) ||\n\t\t(fcport->nvme_flag & NVME_FLAG_REGISTERED))\n\t\treturn 0;\n\n\tfcport->nvme_flag &= ~NVME_FLAG_RESETTING;\n\n\tmemset(&req, 0, sizeof(struct nvme_fc_port_info));\n\treq.port_name = wwn_to_u64(fcport->port_name);\n\treq.node_name = wwn_to_u64(fcport->node_name);\n\treq.port_role = 0;\n\treq.dev_loss_tmo = fcport->dev_loss_tmo;\n\n\tif (fcport->nvme_prli_service_param & NVME_PRLI_SP_INITIATOR)\n\t\treq.port_role = FC_PORT_ROLE_NVME_INITIATOR;\n\n\tif (fcport->nvme_prli_service_param & NVME_PRLI_SP_TARGET)\n\t\treq.port_role |= FC_PORT_ROLE_NVME_TARGET;\n\n\tif (fcport->nvme_prli_service_param & NVME_PRLI_SP_DISCOVERY)\n\t\treq.port_role |= FC_PORT_ROLE_NVME_DISCOVERY;\n\n\treq.port_id = fcport->d_id.b24;\n\n\tql_log(ql_log_info, vha, 0x2102,\n\t    \"%s: traddr=nn-0x%016llx:pn-0x%016llx PortID:%06x\\n\",\n\t    __func__, req.node_name, req.port_name,\n\t    req.port_id);\n\n\tret = nvme_fc_register_remoteport(vha->nvme_local_port, &req,\n\t    &fcport->nvme_remote_port);\n\tif (ret) {\n\t\tql_log(ql_log_warn, vha, 0x212e,\n\t\t    \"Failed to register remote port. Transport returned %d\\n\",\n\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tnvme_fc_set_remoteport_devloss(fcport->nvme_remote_port,\n\t\t\t\t       fcport->dev_loss_tmo);\n\n\tif (fcport->nvme_prli_service_param & NVME_PRLI_SP_SLER)\n\t\tql_log(ql_log_info, vha, 0x212a,\n\t\t       \"PortID:%06x Supports SLER\\n\", req.port_id);\n\n\tif (fcport->nvme_prli_service_param & NVME_PRLI_SP_PI_CTRL)\n\t\tql_log(ql_log_info, vha, 0x212b,\n\t\t       \"PortID:%06x Supports PI control\\n\", req.port_id);\n\n\trport = fcport->nvme_remote_port->private;\n\trport->fcport = fcport;\n\n\tfcport->nvme_flag |= NVME_FLAG_REGISTERED;\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-42286"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/display/dc/resource/dcn20/dcn20_resource.c",
      "func_name": "dcn20_get_dcc_compression_cap",
      "func_body": "bool dcn20_get_dcc_compression_cap(const struct dc *dc,\n\t\tconst struct dc_dcc_surface_param *input,\n\t\tstruct dc_surface_dcc_cap *output)\n{\n\tif (dc->res_pool->hubbub->funcs->get_dcc_compression_cap)\n\t\treturn dc->res_pool->hubbub->funcs->get_dcc_compression_cap(\n\t\t\tdc->res_pool->hubbub, input, output);\n\n\treturn false;\n}\n",
      "cve_list": [
        "CVE-2024-43899"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c",
      "func_name": "mlxsw_sp_acl_tcam_region_destroy",
      "func_body": "static void\nmlxsw_sp_acl_tcam_region_destroy(struct mlxsw_sp *mlxsw_sp,\n\t\t\t\t struct mlxsw_sp_acl_tcam_region *region)\n{\n\tstruct mlxsw_sp_acl_tcam *tcam = mlxsw_sp_acl_to_tcam(mlxsw_sp->acl);\n\tconst struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;\n\n\tops->region_fini(mlxsw_sp, region->priv);\n\tmlxsw_sp_acl_tcam_region_disable(mlxsw_sp, region);\n\tmlxsw_sp_acl_tcam_region_free(mlxsw_sp, region);\n\tmlxsw_sp_acl_tcam_region_id_put(tcam, region->id);\n\tkfree(region);\n}\n",
      "cve_list": [
        "CVE-2024-26595"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/wireless/mediatek/mt76/mt7996/mcu.c",
      "func_name": "mt7996_mcu_sta_bfer_he",
      "func_body": "static void\nmt7996_mcu_sta_bfer_he(struct ieee80211_sta *sta, struct ieee80211_vif *vif,\n\t\t       struct mt7996_phy *phy, struct sta_rec_bf *bf)\n{\n\tstruct ieee80211_sta_he_cap *pc = &sta->deflink.he_cap;\n\tstruct ieee80211_he_cap_elem *pe = &pc->he_cap_elem;\n\tconst struct ieee80211_sta_he_cap *vc =\n\t\tmt76_connac_get_he_phy_cap(phy->mt76, vif);\n\tconst struct ieee80211_he_cap_elem *ve = &vc->he_cap_elem;\n\tu16 mcs_map = le16_to_cpu(pc->he_mcs_nss_supp.rx_mcs_80);\n\tu8 nss_mcs = mt7996_mcu_get_sta_nss(mcs_map);\n\tu8 snd_dim, sts;\n\n\tif (!vc)\n\t\treturn;\n\n\tbf->tx_mode = MT_PHY_TYPE_HE_SU;\n\n\tmt7996_mcu_sta_sounding_rate(bf);\n\n\tbf->trigger_su = HE_PHY(CAP6_TRIG_SU_BEAMFORMING_FB,\n\t\t\t\tpe->phy_cap_info[6]);\n\tbf->trigger_mu = HE_PHY(CAP6_TRIG_MU_BEAMFORMING_PARTIAL_BW_FB,\n\t\t\t\tpe->phy_cap_info[6]);\n\tsnd_dim = HE_PHY(CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_MASK,\n\t\t\t ve->phy_cap_info[5]);\n\tsts = HE_PHY(CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_MASK,\n\t\t     pe->phy_cap_info[4]);\n\tbf->nrow = min_t(u8, snd_dim, sts);\n\tbf->ncol = min_t(u8, nss_mcs, bf->nrow);\n\tbf->ibf_ncol = bf->ncol;\n\n\tif (sta->deflink.bandwidth != IEEE80211_STA_RX_BW_160)\n\t\treturn;\n\n\t/* go over for 160MHz and 80p80 */\n\tif (pe->phy_cap_info[0] &\n\t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G) {\n\t\tmcs_map = le16_to_cpu(pc->he_mcs_nss_supp.rx_mcs_160);\n\t\tnss_mcs = mt7996_mcu_get_sta_nss(mcs_map);\n\n\t\tbf->ncol_gt_bw80 = nss_mcs;\n\t}\n\n\tif (pe->phy_cap_info[0] &\n\t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G) {\n\t\tmcs_map = le16_to_cpu(pc->he_mcs_nss_supp.rx_mcs_80p80);\n\t\tnss_mcs = mt7996_mcu_get_sta_nss(mcs_map);\n\n\t\tif (bf->ncol_gt_bw80)\n\t\t\tbf->ncol_gt_bw80 = min_t(u8, bf->ncol_gt_bw80, nss_mcs);\n\t\telse\n\t\t\tbf->ncol_gt_bw80 = nss_mcs;\n\t}\n\n\tsnd_dim = HE_PHY(CAP5_BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ_MASK,\n\t\t\t ve->phy_cap_info[5]);\n\tsts = HE_PHY(CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_MASK,\n\t\t     pe->phy_cap_info[4]);\n\n\tbf->nrow_gt_bw80 = min_t(int, snd_dim, sts);\n}\n",
      "cve_list": [
        "CVE-2024-47681"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/netfs/fscache_cookie.c",
      "func_name": "fscache_cookie_state_machine",
      "func_body": "static void fscache_cookie_state_machine(struct fscache_cookie *cookie)\n{\n\tenum fscache_cookie_state state;\n\tbool wake = false;\n\n\t_enter(\"c=%x\", cookie->debug_id);\n\nagain:\n\tspin_lock(&cookie->lock);\nagain_locked:\n\tstate = cookie->state;\n\tswitch (state) {\n\tcase FSCACHE_COOKIE_STATE_QUIESCENT:\n\t\t/* The QUIESCENT state is jumped to the LOOKING_UP state by\n\t\t * fscache_use_cookie().\n\t\t */\n\n\t\tif (atomic_read(&cookie->n_accesses) == 0 &&\n\t\t    test_bit(FSCACHE_COOKIE_DO_RELINQUISH, &cookie->flags)) {\n\t\t\t__fscache_set_cookie_state(cookie,\n\t\t\t\t\t\t   FSCACHE_COOKIE_STATE_RELINQUISHING);\n\t\t\twake = true;\n\t\t\tgoto again_locked;\n\t\t}\n\t\tbreak;\n\n\tcase FSCACHE_COOKIE_STATE_LOOKING_UP:\n\t\tspin_unlock(&cookie->lock);\n\t\tfscache_init_access_gate(cookie);\n\t\tfscache_perform_lookup(cookie);\n\t\tgoto again;\n\n\tcase FSCACHE_COOKIE_STATE_INVALIDATING:\n\t\tspin_unlock(&cookie->lock);\n\t\tfscache_perform_invalidation(cookie);\n\t\tgoto again;\n\n\tcase FSCACHE_COOKIE_STATE_ACTIVE:\n\t\tif (test_and_clear_bit(FSCACHE_COOKIE_DO_PREP_TO_WRITE, &cookie->flags)) {\n\t\t\tspin_unlock(&cookie->lock);\n\t\t\tfscache_prepare_to_write(cookie);\n\t\t\tspin_lock(&cookie->lock);\n\t\t}\n\t\tif (test_bit(FSCACHE_COOKIE_DO_LRU_DISCARD, &cookie->flags)) {\n\t\t\tif (atomic_read(&cookie->n_accesses) != 0)\n\t\t\t\t/* still being accessed: postpone it */\n\t\t\t\tbreak;\n\n\t\t\t__fscache_set_cookie_state(cookie,\n\t\t\t\t\t\t   FSCACHE_COOKIE_STATE_LRU_DISCARDING);\n\t\t\twake = true;\n\t\t\tgoto again_locked;\n\t\t}\n\t\tfallthrough;\n\n\tcase FSCACHE_COOKIE_STATE_FAILED:\n\t\tif (test_and_clear_bit(FSCACHE_COOKIE_DO_INVALIDATE, &cookie->flags))\n\t\t\tfscache_end_cookie_access(cookie, fscache_access_invalidate_cookie_end);\n\n\t\tif (atomic_read(&cookie->n_accesses) != 0)\n\t\t\tbreak;\n\t\tif (test_bit(FSCACHE_COOKIE_DO_RELINQUISH, &cookie->flags)) {\n\t\t\t__fscache_set_cookie_state(cookie,\n\t\t\t\t\t\t   FSCACHE_COOKIE_STATE_RELINQUISHING);\n\t\t\twake = true;\n\t\t\tgoto again_locked;\n\t\t}\n\t\tif (test_bit(FSCACHE_COOKIE_DO_WITHDRAW, &cookie->flags)) {\n\t\t\t__fscache_set_cookie_state(cookie,\n\t\t\t\t\t\t   FSCACHE_COOKIE_STATE_WITHDRAWING);\n\t\t\twake = true;\n\t\t\tgoto again_locked;\n\t\t}\n\t\tbreak;\n\n\tcase FSCACHE_COOKIE_STATE_LRU_DISCARDING:\n\tcase FSCACHE_COOKIE_STATE_RELINQUISHING:\n\tcase FSCACHE_COOKIE_STATE_WITHDRAWING:\n\t\tif (cookie->cache_priv) {\n\t\t\tspin_unlock(&cookie->lock);\n\t\t\tcookie->volume->cache->ops->withdraw_cookie(cookie);\n\t\t\tspin_lock(&cookie->lock);\n\t\t}\n\n\t\tif (test_and_clear_bit(FSCACHE_COOKIE_DO_INVALIDATE, &cookie->flags))\n\t\t\tfscache_end_cookie_access(cookie, fscache_access_invalidate_cookie_end);\n\n\t\tswitch (state) {\n\t\tcase FSCACHE_COOKIE_STATE_RELINQUISHING:\n\t\t\tfscache_see_cookie(cookie, fscache_cookie_see_relinquish);\n\t\t\tfscache_unhash_cookie(cookie);\n\t\t\t__fscache_set_cookie_state(cookie,\n\t\t\t\t\t\t   FSCACHE_COOKIE_STATE_DROPPED);\n\t\t\twake = true;\n\t\t\tgoto out;\n\t\tcase FSCACHE_COOKIE_STATE_LRU_DISCARDING:\n\t\t\tfscache_see_cookie(cookie, fscache_cookie_see_lru_discard);\n\t\t\tbreak;\n\t\tcase FSCACHE_COOKIE_STATE_WITHDRAWING:\n\t\t\tfscache_see_cookie(cookie, fscache_cookie_see_withdraw);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_bit(FSCACHE_COOKIE_NEEDS_UPDATE, &cookie->flags);\n\t\tclear_bit(FSCACHE_COOKIE_DO_WITHDRAW, &cookie->flags);\n\t\tclear_bit(FSCACHE_COOKIE_DO_LRU_DISCARD, &cookie->flags);\n\t\tclear_bit(FSCACHE_COOKIE_DO_PREP_TO_WRITE, &cookie->flags);\n\t\tset_bit(FSCACHE_COOKIE_NO_DATA_TO_READ, &cookie->flags);\n\t\t__fscache_set_cookie_state(cookie, FSCACHE_COOKIE_STATE_QUIESCENT);\n\t\twake = true;\n\t\tgoto again_locked;\n\n\tcase FSCACHE_COOKIE_STATE_DROPPED:\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ONCE(1, \"Cookie %x in unexpected state %u\\n\",\n\t\t\t  cookie->debug_id, state);\n\t\tbreak;\n\t}\n\nout:\n\tspin_unlock(&cookie->lock);\n\tif (wake)\n\t\twake_up_cookie_state(cookie);\n\t_leave(\"\");\n}\n",
      "cve_list": [
        "CVE-2024-45000"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/bonding/bond_main.c",
      "func_name": "bond_ipsec_del_sa_all",
      "func_body": "static void bond_ipsec_del_sa_all(struct bonding *bond)\n{\n\tstruct net_device *bond_dev = bond->dev;\n\tstruct bond_ipsec *ipsec;\n\tstruct slave *slave;\n\n\trcu_read_lock();\n\tslave = rcu_dereference(bond->curr_active_slave);\n\tif (!slave) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&bond->ipsec_lock);\n\tlist_for_each_entry(ipsec, &bond->ipsec_list, list) {\n\t\tif (!ipsec->xs->xso.real_dev)\n\t\t\tcontinue;\n\n\t\tif (!slave->dev->xfrmdev_ops ||\n\t\t    !slave->dev->xfrmdev_ops->xdo_dev_state_delete ||\n\t\t    netif_is_bond_master(slave->dev)) {\n\t\t\tslave_warn(bond_dev, slave->dev,\n\t\t\t\t   \"%s: no slave xdo_dev_state_delete\\n\",\n\t\t\t\t   __func__);\n\t\t} else {\n\t\t\tslave->dev->xfrmdev_ops->xdo_dev_state_delete(ipsec->xs);\n\t\t}\n\t}\n\tspin_unlock_bh(&bond->ipsec_lock);\n\trcu_read_unlock();\n}\n",
      "cve_list": [
        "CVE-2024-44989"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/uio/uio_hv_generic.c",
      "func_name": "hv_uio_rescind",
      "func_body": "static void hv_uio_rescind(struct vmbus_channel *channel)\n{\n\tstruct hv_device *hv_dev = channel->device_obj;\n\tstruct hv_uio_private_data *pdata = hv_get_drvdata(hv_dev);\n\n\t/*\n\t * Turn off the interrupt file handle\n\t * Next read for event will return -EIO\n\t */\n\tpdata->info.irq = 0;\n\n\t/* Wake up reader */\n\tuio_event_notify(&pdata->info);\n}\n",
      "cve_list": [
        "CVE-2024-46739"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "sound/soc/sof/ipc4-topology.c",
      "func_name": "sof_ipc4_get_input_pin_audio_fmt",
      "func_body": "static const struct sof_ipc4_audio_format *\nsof_ipc4_get_input_pin_audio_fmt(struct snd_sof_widget *swidget, int pin_index)\n{\n\tstruct sof_ipc4_base_module_cfg_ext *base_cfg_ext;\n\tstruct sof_ipc4_process *process;\n\tint i;\n\n\tif (swidget->id != snd_soc_dapm_effect) {\n\t\tstruct sof_ipc4_base_module_cfg *base = swidget->private;\n\n\t\t/* For non-process modules, base module config format is used for all input pins */\n\t\treturn &base->audio_fmt;\n\t}\n\n\tprocess = swidget->private;\n\n\t/*\n\t * For process modules without base config extension, base module config\n\t * format is used for all input pins\n\t */\n\tif (process->init_config != SOF_IPC4_MODULE_INIT_CONFIG_TYPE_BASE_CFG_WITH_EXT)\n\t\treturn &process->base_config.audio_fmt;\n\n\tbase_cfg_ext = process->base_config_ext;\n\n\t/*\n\t * If there are multiple input formats available for a pin, the first available format\n\t * is chosen.\n\t */\n\tfor (i = 0; i < base_cfg_ext->num_input_pin_fmts; i++) {\n\t\tstruct sof_ipc4_pin_format *pin_format = &base_cfg_ext->pin_formats[i];\n\n\t\tif (pin_format->pin_index == pin_index)\n\t\t\treturn &pin_format->audio_fmt;\n\t}\n\n\treturn NULL;\n}\n",
      "cve_list": [
        "CVE-2024-39473"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/ext4/mballoc.c",
      "func_name": "mb_avg_fragment_size_order",
      "func_body": "static int mb_avg_fragment_size_order(struct super_block *sb, ext4_grpblk_t len)\n{\n\tint order;\n\n\t/*\n\t * We don't bother with a special lists groups with only 1 block free\n\t * extents and for completely empty groups.\n\t */\n\torder = fls(len) - 2;\n\tif (order < 0)\n\t\treturn 0;\n\tif (order == MB_NUM_ORDERS(sb))\n\t\torder--;\n\tif (WARN_ON_ONCE(order > MB_NUM_ORDERS(sb)))\n\t\torder = MB_NUM_ORDERS(sb) - 1;\n\treturn order;\n}\n",
      "cve_list": [
        "CVE-2024-40955"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/ext4/mballoc.c",
      "func_name": "ext4_mb_choose_next_group_best_avail",
      "func_body": "static void ext4_mb_choose_next_group_best_avail(struct ext4_allocation_context *ac,\n\t\tenum criteria *new_cr, ext4_group_t *group)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_group_info *grp = NULL;\n\tint i, order, min_order;\n\tunsigned long num_stripe_clusters = 0;\n\n\tif (unlikely(ac->ac_flags & EXT4_MB_CR_BEST_AVAIL_LEN_OPTIMIZED)) {\n\t\tif (sbi->s_mb_stats)\n\t\t\tatomic_inc(&sbi->s_bal_best_avail_bad_suggestions);\n\t}\n\n\t/*\n\t * mb_avg_fragment_size_order() returns order in a way that makes\n\t * retrieving back the length using (1 << order) inaccurate. Hence, use\n\t * fls() instead since we need to know the actual length while modifying\n\t * goal length.\n\t */\n\torder = fls(ac->ac_g_ex.fe_len) - 1;\n\tif (WARN_ON_ONCE(order - 1 > MB_NUM_ORDERS(ac->ac_sb)))\n\t\torder = MB_NUM_ORDERS(ac->ac_sb);\n\tmin_order = order - sbi->s_mb_best_avail_max_trim_order;\n\tif (min_order < 0)\n\t\tmin_order = 0;\n\n\tif (sbi->s_stripe > 0) {\n\t\t/*\n\t\t * We are assuming that stripe size is always a multiple of\n\t\t * cluster ratio otherwise __ext4_fill_super exists early.\n\t\t */\n\t\tnum_stripe_clusters = EXT4_NUM_B2C(sbi, sbi->s_stripe);\n\t\tif (1 << min_order < num_stripe_clusters)\n\t\t\t/*\n\t\t\t * We consider 1 order less because later we round\n\t\t\t * up the goal len to num_stripe_clusters\n\t\t\t */\n\t\t\tmin_order = fls(num_stripe_clusters) - 1;\n\t}\n\n\tif (1 << min_order < ac->ac_o_ex.fe_len)\n\t\tmin_order = fls(ac->ac_o_ex.fe_len);\n\n\tfor (i = order; i >= min_order; i--) {\n\t\tint frag_order;\n\t\t/*\n\t\t * Scale down goal len to make sure we find something\n\t\t * in the free fragments list. Basically, reduce\n\t\t * preallocations.\n\t\t */\n\t\tac->ac_g_ex.fe_len = 1 << i;\n\n\t\tif (num_stripe_clusters > 0) {\n\t\t\t/*\n\t\t\t * Try to round up the adjusted goal length to\n\t\t\t * stripe size (in cluster units) multiple for\n\t\t\t * efficiency.\n\t\t\t */\n\t\t\tac->ac_g_ex.fe_len = roundup(ac->ac_g_ex.fe_len,\n\t\t\t\t\t\t     num_stripe_clusters);\n\t\t}\n\n\t\tfrag_order = mb_avg_fragment_size_order(ac->ac_sb,\n\t\t\t\t\t\t\tac->ac_g_ex.fe_len);\n\n\t\tgrp = ext4_mb_find_good_group_avg_frag_lists(ac, frag_order);\n\t\tif (grp) {\n\t\t\t*group = grp->bb_group;\n\t\t\tac->ac_flags |= EXT4_MB_CR_BEST_AVAIL_LEN_OPTIMIZED;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Reset goal length to original goal length before falling into CR_GOAL_LEN_SLOW */\n\tac->ac_g_ex.fe_len = ac->ac_orig_goal_len;\n\t*new_cr = CR_GOAL_LEN_SLOW;\n}\n",
      "cve_list": [
        "CVE-2024-40955"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/intel/ice/ice_base.c",
      "func_name": "ice_free_q_vector",
      "func_body": "static void ice_free_q_vector(struct ice_vsi *vsi, int v_idx)\n{\n\tstruct ice_q_vector *q_vector;\n\tstruct ice_pf *pf = vsi->back;\n\tstruct ice_tx_ring *tx_ring;\n\tstruct ice_rx_ring *rx_ring;\n\tstruct device *dev;\n\n\tdev = ice_pf_to_dev(pf);\n\tif (!vsi->q_vectors[v_idx]) {\n\t\tdev_dbg(dev, \"Queue vector at index %d not found\\n\", v_idx);\n\t\treturn;\n\t}\n\tq_vector = vsi->q_vectors[v_idx];\n\n\tice_for_each_tx_ring(tx_ring, vsi->q_vectors[v_idx]->tx)\n\t\ttx_ring->q_vector = NULL;\n\n\tice_for_each_rx_ring(rx_ring, vsi->q_vectors[v_idx]->rx)\n\t\trx_ring->q_vector = NULL;\n\n\t/* only VSI with an associated netdev is set up with NAPI */\n\tif (vsi->netdev)\n\t\tnetif_napi_del(&q_vector->napi);\n\n\t/* release MSIX interrupt if q_vector had interrupt allocated */\n\tif (q_vector->irq.index < 0)\n\t\tgoto free_q_vector;\n\n\t/* only free last VF ctrl vsi interrupt */\n\tif (vsi->type == ICE_VSI_CTRL && vsi->vf &&\n\t    ice_get_vf_ctrl_vsi(pf, vsi))\n\t\tgoto free_q_vector;\n\n\tice_free_irq(pf, q_vector->irq);\n\nfree_q_vector:\n\tkfree(q_vector);\n\tvsi->q_vectors[v_idx] = NULL;\n}\n",
      "cve_list": [
        "CVE-2024-46766"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/spi/spi-nxp-fspi.c",
      "func_name": "nxp_fspi_fill_txfifo",
      "func_body": "static void nxp_fspi_fill_txfifo(struct nxp_fspi *f,\n\t\t\t\t const struct spi_mem_op *op)\n{\n\tvoid __iomem *base = f->iobase;\n\tint i, ret;\n\tu8 *buf = (u8 *) op->data.buf.out;\n\n\t/* clear the TX FIFO. */\n\tfspi_writel(f, FSPI_IPTXFCR_CLR, base + FSPI_IPTXFCR);\n\n\t/*\n\t * Default value of water mark level is 8 bytes, hence in single\n\t * write request controller can write max 8 bytes of data.\n\t */\n\n\tfor (i = 0; i < ALIGN_DOWN(op->data.nbytes, 8); i += 8) {\n\t\t/* Wait for TXFIFO empty */\n\t\tret = fspi_readl_poll_tout(f, f->iobase + FSPI_INTR,\n\t\t\t\t\t   FSPI_INTR_IPTXWE, 0,\n\t\t\t\t\t   POLL_TOUT, true);\n\t\tWARN_ON(ret);\n\n\t\tfspi_writel(f, *(u32 *) (buf + i), base + FSPI_TFDR);\n\t\tfspi_writel(f, *(u32 *) (buf + i + 4), base + FSPI_TFDR + 4);\n\t\tfspi_writel(f, FSPI_INTR_IPTXWE, base + FSPI_INTR);\n\t}\n\n\tif (i < op->data.nbytes) {\n\t\tu32 data = 0;\n\t\tint j;\n\t\tint remaining = op->data.nbytes - i;\n\t\t/* Wait for TXFIFO empty */\n\t\tret = fspi_readl_poll_tout(f, f->iobase + FSPI_INTR,\n\t\t\t\t\t   FSPI_INTR_IPTXWE, 0,\n\t\t\t\t\t   POLL_TOUT, true);\n\t\tWARN_ON(ret);\n\n\t\tfor (j = 0; j < ALIGN(remaining, 4); j += 4) {\n\t\t\tmemcpy(&data, buf + i + j, min_t(int, 4, remaining - j));\n\t\t\tfspi_writel(f, data, base + FSPI_TFDR + j);\n\t\t}\n\t\tfspi_writel(f, FSPI_INTR_IPTXWE, base + FSPI_INTR);\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-46853"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/mellanox/mlxsw/spectrum_acl_tcam.c",
      "func_name": "mlxsw_sp_acl_tcam_init",
      "func_body": "int mlxsw_sp_acl_tcam_init(struct mlxsw_sp *mlxsw_sp,\n\t\t\t   struct mlxsw_sp_acl_tcam *tcam)\n{\n\tconst struct mlxsw_sp_acl_tcam_ops *ops = mlxsw_sp->acl_tcam_ops;\n\tu64 max_tcam_regions;\n\tu64 max_regions;\n\tu64 max_groups;\n\tint err;\n\n\tmutex_init(&tcam->lock);\n\ttcam->vregion_rehash_intrvl =\n\t\t\tMLXSW_SP_ACL_TCAM_VREGION_REHASH_INTRVL_DFLT;\n\tINIT_LIST_HEAD(&tcam->vregion_list);\n\n\terr = mlxsw_sp_acl_tcam_rehash_params_register(mlxsw_sp);\n\tif (err)\n\t\tgoto err_rehash_params_register;\n\n\tmax_tcam_regions = MLXSW_CORE_RES_GET(mlxsw_sp->core,\n\t\t\t\t\t      ACL_MAX_TCAM_REGIONS);\n\tmax_regions = MLXSW_CORE_RES_GET(mlxsw_sp->core, ACL_MAX_REGIONS);\n\n\t/* Use 1:1 mapping between ACL region and TCAM region */\n\tif (max_tcam_regions < max_regions)\n\t\tmax_regions = max_tcam_regions;\n\n\ttcam->used_regions = bitmap_zalloc(max_regions, GFP_KERNEL);\n\tif (!tcam->used_regions) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_used_regions;\n\t}\n\ttcam->max_regions = max_regions;\n\n\tmax_groups = MLXSW_CORE_RES_GET(mlxsw_sp->core, ACL_MAX_GROUPS);\n\ttcam->used_groups = bitmap_zalloc(max_groups, GFP_KERNEL);\n\tif (!tcam->used_groups) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_used_groups;\n\t}\n\ttcam->max_groups = max_groups;\n\ttcam->max_group_size = MLXSW_CORE_RES_GET(mlxsw_sp->core,\n\t\t\t\t\t\t  ACL_MAX_GROUP_SIZE);\n\ttcam->max_group_size = min_t(unsigned int, tcam->max_group_size,\n\t\t\t\t     MLXSW_REG_PAGT_ACL_MAX_NUM);\n\n\terr = ops->init(mlxsw_sp, tcam->priv, tcam);\n\tif (err)\n\t\tgoto err_tcam_init;\n\n\treturn 0;\n\nerr_tcam_init:\n\tbitmap_free(tcam->used_groups);\nerr_alloc_used_groups:\n\tbitmap_free(tcam->used_regions);\nerr_alloc_used_regions:\n\tmlxsw_sp_acl_tcam_rehash_params_unregister(mlxsw_sp);\nerr_rehash_params_register:\n\tmutex_destroy(&tcam->lock);\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-26586"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/iio/industrialio-gts-helper.c",
      "func_name": "iio_gts_build_avail_time_table",
      "func_body": "static int iio_gts_build_avail_time_table(struct iio_gts *gts)\n{\n\tint *times, i, j, idx = 0, *int_micro_times;\n\n\tif (!gts->num_itime)\n\t\treturn 0;\n\n\ttimes = kcalloc(gts->num_itime, sizeof(int), GFP_KERNEL);\n\tif (!times)\n\t\treturn -ENOMEM;\n\n\t/* Sort times from all tables to one and remove duplicates */\n\tfor (i = gts->num_itime - 1; i >= 0; i--) {\n\t\tint new = gts->itime_table[i].time_us;\n\n\t\tif (idx == 0 || times[idx - 1] < new) {\n\t\t\ttimes[idx++] = new;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < idx; j++) {\n\t\t\tif (times[j] == new)\n\t\t\t\tbreak;\n\t\t\tif (times[j] > new) {\n\t\t\t\tmemmove(&times[j + 1], &times[j],\n\t\t\t\t\t(idx - j) * sizeof(int));\n\t\t\t\ttimes[j] = new;\n\t\t\t\tidx++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* create a list of times formatted as list of IIO_VAL_INT_PLUS_MICRO */\n\tint_micro_times = kcalloc(idx, sizeof(int) * 2, GFP_KERNEL);\n\tif (int_micro_times) {\n\t\t/*\n\t\t * This is just to survive a unlikely corner-case where times in\n\t\t * the given time table were not unique. Else we could just\n\t\t * trust the gts->num_itime.\n\t\t */\n\t\tgts->num_avail_time_tables = idx;\n\t\tiio_gts_us_to_int_micro(times, int_micro_times, idx);\n\t}\n\n\tgts->avail_time_tables = int_micro_times;\n\tkfree(times);\n\n\tif (!int_micro_times)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-43825"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "mm/vmalloc.c",
      "func_name": "vm_area_alloc_pages",
      "func_body": "static inline unsigned int\nvm_area_alloc_pages(gfp_t gfp, int nid,\n\t\tunsigned int order, unsigned int nr_pages, struct page **pages)\n{\n\tunsigned int nr_allocated = 0;\n\tgfp_t alloc_gfp = gfp;\n\tbool nofail = gfp & __GFP_NOFAIL;\n\tstruct page *page;\n\tint i;\n\n\t/*\n\t * For order-0 pages we make use of bulk allocator, if\n\t * the page array is partly or not at all populated due\n\t * to fails, fallback to a single page allocator that is\n\t * more permissive.\n\t */\n\tif (!order) {\n\t\t/* bulk allocator doesn't support nofail req. officially */\n\t\tgfp_t bulk_gfp = gfp & ~__GFP_NOFAIL;\n\n\t\twhile (nr_allocated < nr_pages) {\n\t\t\tunsigned int nr, nr_pages_request;\n\n\t\t\t/*\n\t\t\t * A maximum allowed request is hard-coded and is 100\n\t\t\t * pages per call. That is done in order to prevent a\n\t\t\t * long preemption off scenario in the bulk-allocator\n\t\t\t * so the range is [1:100].\n\t\t\t */\n\t\t\tnr_pages_request = min(100U, nr_pages - nr_allocated);\n\n\t\t\t/* memory allocation should consider mempolicy, we can't\n\t\t\t * wrongly use nearest node when nid == NUMA_NO_NODE,\n\t\t\t * otherwise memory may be allocated in only one node,\n\t\t\t * but mempolicy wants to alloc memory by interleaving.\n\t\t\t */\n\t\t\tif (IS_ENABLED(CONFIG_NUMA) && nid == NUMA_NO_NODE)\n\t\t\t\tnr = alloc_pages_bulk_array_mempolicy_noprof(bulk_gfp,\n\t\t\t\t\t\t\tnr_pages_request,\n\t\t\t\t\t\t\tpages + nr_allocated);\n\n\t\t\telse\n\t\t\t\tnr = alloc_pages_bulk_array_node_noprof(bulk_gfp, nid,\n\t\t\t\t\t\t\tnr_pages_request,\n\t\t\t\t\t\t\tpages + nr_allocated);\n\n\t\t\tnr_allocated += nr;\n\t\t\tcond_resched();\n\n\t\t\t/*\n\t\t\t * If zero or pages were obtained partly,\n\t\t\t * fallback to a single page allocator.\n\t\t\t */\n\t\t\tif (nr != nr_pages_request)\n\t\t\t\tbreak;\n\t\t}\n\t} else if (gfp & __GFP_NOFAIL) {\n\t\t/*\n\t\t * Higher order nofail allocations are really expensive and\n\t\t * potentially dangerous (pre-mature OOM, disruptive reclaim\n\t\t * and compaction etc.\n\t\t */\n\t\talloc_gfp &= ~__GFP_NOFAIL;\n\t}\n\n\t/* High-order pages or fallback path if \"bulk\" fails. */\n\twhile (nr_allocated < nr_pages) {\n\t\tif (!nofail && fatal_signal_pending(current))\n\t\t\tbreak;\n\n\t\tif (nid == NUMA_NO_NODE)\n\t\t\tpage = alloc_pages_noprof(alloc_gfp, order);\n\t\telse\n\t\t\tpage = alloc_pages_node_noprof(nid, alloc_gfp, order);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Higher order allocations must be able to be treated as\n\t\t * indepdenent small pages by callers (as they can with\n\t\t * small-page vmallocs). Some drivers do their own refcounting\n\t\t * on vmalloc_to_page() pages, some use page->mapping,\n\t\t * page->lru, etc.\n\t\t */\n\t\tif (order)\n\t\t\tsplit_page(page, order);\n\n\t\t/*\n\t\t * Careful, we allocate and map page-order pages, but\n\t\t * tracking is done per PAGE_SIZE page so as to keep the\n\t\t * vm_struct APIs independent of the physical/mapped size.\n\t\t */\n\t\tfor (i = 0; i < (1U << order); i++)\n\t\t\tpages[nr_allocated + i] = page + i;\n\n\t\tcond_resched();\n\t\tnr_allocated += 1U << order;\n\t}\n\n\treturn nr_allocated;\n}\n",
      "cve_list": [
        "CVE-2024-45022"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/usb/gadget/configfs.c",
      "func_name": "usb_string_copy",
      "func_body": "static int usb_string_copy(const char *s, char **s_copy)\n{\n\tint ret;\n\tchar *str;\n\tchar *copy = *s_copy;\n\n\tret = strlen(s);\n\tif (ret > USB_MAX_STRING_LEN)\n\t\treturn -EOVERFLOW;\n\tif (ret < 1)\n\t\treturn -EINVAL;\n\n\tif (copy) {\n\t\tstr = copy;\n\t} else {\n\t\tstr = kmalloc(USB_MAX_STRING_WITH_NULL_LEN, GFP_KERNEL);\n\t\tif (!str)\n\t\t\treturn -ENOMEM;\n\t}\n\tstrcpy(str, s);\n\tif (str[ret - 1] == '\\n')\n\t\tstr[ret - 1] = '\\0';\n\t*s_copy = str;\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-42236"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/jfs/jfs_dmap.c",
      "func_name": "dbDiscardAG",
      "func_body": "s64 dbDiscardAG(struct inode *ip, int agno, s64 minlen)\n{\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\ts64 nblocks, blkno;\n\tu64 trimmed = 0;\n\tint rc, l2nb;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tstruct range2trim {\n\t\tu64 blkno;\n\t\tu64 nblocks;\n\t} *totrim, *tt;\n\n\t/* max blkno / nblocks pairs to trim */\n\tint count = 0, range_cnt;\n\tu64 max_ranges;\n\n\t/* prevent others from writing new stuff here, while trimming */\n\tIWRITE_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\tnblocks = bmp->db_agfree[agno];\n\tmax_ranges = nblocks;\n\tdo_div(max_ranges, minlen);\n\trange_cnt = min_t(u64, max_ranges + 1, 32 * 1024);\n\ttotrim = kmalloc_array(range_cnt, sizeof(struct range2trim), GFP_NOFS);\n\tif (totrim == NULL) {\n\t\tjfs_error(bmp->db_ipbmap->i_sb, \"no memory for trim array\\n\");\n\t\tIWRITE_UNLOCK(ipbmap);\n\t\treturn 0;\n\t}\n\n\ttt = totrim;\n\twhile (nblocks >= minlen) {\n\t\tl2nb = BLKSTOL2(nblocks);\n\n\t\t/* 0 = okay, -EIO = fatal, -ENOSPC -> try smaller block */\n\t\trc = dbAllocAG(bmp, agno, nblocks, l2nb, &blkno);\n\t\tif (rc == 0) {\n\t\t\ttt->blkno = blkno;\n\t\t\ttt->nblocks = nblocks;\n\t\t\ttt++; count++;\n\n\t\t\t/* the whole ag is free, trim now */\n\t\t\tif (bmp->db_agfree[agno] == 0)\n\t\t\t\tbreak;\n\n\t\t\t/* give a hint for the next while */\n\t\t\tnblocks = bmp->db_agfree[agno];\n\t\t\tcontinue;\n\t\t} else if (rc == -ENOSPC) {\n\t\t\t/* search for next smaller log2 block */\n\t\t\tl2nb = BLKSTOL2(nblocks) - 1;\n\t\t\tif (unlikely(l2nb < 0))\n\t\t\t\tbreak;\n\t\t\tnblocks = 1LL << l2nb;\n\t\t} else {\n\t\t\t/* Trim any already allocated blocks */\n\t\t\tjfs_error(bmp->db_ipbmap->i_sb, \"-EIO\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* check, if our trim array is full */\n\t\tif (unlikely(count >= range_cnt - 1))\n\t\t\tbreak;\n\t}\n\tIWRITE_UNLOCK(ipbmap);\n\n\ttt->nblocks = 0; /* mark the current end */\n\tfor (tt = totrim; tt->nblocks != 0; tt++) {\n\t\t/* when mounted with online discard, dbFree() will\n\t\t * call jfs_issue_discard() itself */\n\t\tif (!(JFS_SBI(sb)->flag & JFS_DISCARD))\n\t\t\tjfs_issue_discard(ip, tt->blkno, tt->nblocks);\n\t\tdbFree(ip, tt->blkno, tt->nblocks);\n\t\ttrimmed += tt->nblocks;\n\t}\n\tkfree(totrim);\n\n\treturn trimmed;\n}\n",
      "cve_list": [
        "CVE-2024-44938"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/s390/block/dasd.c",
      "func_name": "dasd_ese_needs_format",
      "func_body": "static int dasd_ese_needs_format(struct dasd_block *block, struct irb *irb)\n{\n\tstruct dasd_device *device = NULL;\n\tu8 *sense = NULL;\n\n\tif (!block)\n\t\treturn 0;\n\tdevice = block->base;\n\tif (!device || !device->discipline->is_ese)\n\t\treturn 0;\n\tif (!device->discipline->is_ese(device))\n\t\treturn 0;\n\n\tsense = dasd_get_sense(irb);\n\tif (!sense)\n\t\treturn 0;\n\n\tif (sense[1] & SNS1_NO_REC_FOUND)\n\t\treturn 1;\n\n\tif ((sense[1] & SNS1_INV_TRACK_FORMAT) &&\n\t    scsw_is_tm(&irb->scsw) &&\n\t    !(sense[2] & SNS2_ENV_DATA_PRESENT))\n\t\treturn 1;\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-45026"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/s390/block/dasd_3990_erp.c",
      "func_name": "dasd_3990_erp_file_prot",
      "func_body": "static struct dasd_ccw_req *\ndasd_3990_erp_file_prot(struct dasd_ccw_req * erp)\n{\n\n\tstruct dasd_device *device = erp->startdev;\n\n\tdev_err(&device->cdev->dev,\n\t\t\"Accessing the DASD failed because of a hardware error\\n\");\n\n\treturn dasd_3990_erp_cleanup(erp, DASD_CQR_FAILED);\n\n}\t\t\t\t/* end dasd_3990_erp_file_prot */\n",
      "cve_list": [
        "CVE-2024-45026"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/intel/igb/igb_main.c",
      "func_name": "igb_set_rx_buffer_len",
      "func_body": "static void igb_set_rx_buffer_len(struct igb_adapter *adapter,\n\t\t\t\t  struct igb_ring *rx_ring)\n{\n// #if (PAGE_SIZE < 8192)\n\tstruct e1000_hw *hw = &adapter->hw;\n#endif\n\n\t/* set build_skb and buffer size flags */\n\tclear_ring_build_skb_enabled(rx_ring);\n\tclear_ring_uses_large_buffer(rx_ring);\n\n\tif (adapter->flags & IGB_FLAG_RX_LEGACY)\n\t\treturn;\n\n\tset_ring_build_skb_enabled(rx_ring);\n\n// #if (PAGE_SIZE < 8192)\n\tif (adapter->max_frame_size > IGB_MAX_FRAME_BUILD_SKB ||\n\t    IGB_2K_TOO_SMALL_WITH_PADDING ||\n\t    rd32(E1000_RCTL) & E1000_RCTL_SBP)\n\t\tset_ring_uses_large_buffer(rx_ring);\n#endif\n}\n",
      "cve_list": [
        "CVE-2024-45030"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "fs/file.c",
      "func_name": "copy_fd_bitmaps",
      "func_body": "static inline void copy_fd_bitmaps(struct fdtable *nfdt, struct fdtable *ofdt,\n\t\t\t    unsigned int copy_words)\n{\n\tunsigned int nwords = fdt_words(nfdt);\n\n\tbitmap_copy_and_extend(nfdt->open_fds, ofdt->open_fds,\n\t\t\tcopy_words * BITS_PER_LONG, nwords * BITS_PER_LONG);\n\tbitmap_copy_and_extend(nfdt->close_on_exec, ofdt->close_on_exec,\n\t\t\tcopy_words * BITS_PER_LONG, nwords * BITS_PER_LONG);\n\tbitmap_copy_and_extend(nfdt->full_fds_bits, ofdt->full_fds_bits,\n\t\t\tcopy_words, nwords);\n}\n",
      "cve_list": [
        "CVE-2024-45025"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "tools/testing/selftests/core/close_range_test.c",
      "func_name": "TEST",
      "func_body": "TEST(close_range_bitmap_corruption)\n{\n\tpid_t pid;\n\tint status;\n\tstruct __clone_args args = {\n\t\t.flags = CLONE_FILES,\n\t\t.exit_signal = SIGCHLD,\n\t};\n\n\t/* get the first 128 descriptors open */\n\tfor (int i = 2; i < 128; i++)\n\t\tEXPECT_GE(dup2(0, i), 0);\n\n\t/* get descriptor table shared */\n\tpid = sys_clone3(&args, sizeof(args));\n\tASSERT_GE(pid, 0);\n\n\tif (pid == 0) {\n\t\t/* unshare and truncate descriptor table down to 64 */\n\t\tif (sys_close_range(64, ~0U, CLOSE_RANGE_UNSHARE))\n\t\t\texit(EXIT_FAILURE);\n\n\t\tASSERT_EQ(fcntl(64, F_GETFD), -1);\n\t\t/* ... and verify that the range 64..127 is not\n\t\t   stuck \"fully used\" according to secondary bitmap */\n\t\tEXPECT_EQ(dup(0), 64)\n\t\t\texit(EXIT_FAILURE);\n\t\texit(EXIT_SUCCESS);\n\t}\n\n\tEXPECT_EQ(waitpid(pid, &status, 0), pid);\n\tEXPECT_EQ(true, WIFEXITED(status));\n\tEXPECT_EQ(0, WEXITSTATUS(status));\n}\n",
      "cve_list": [
        "CVE-2024-45025"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "arch/riscv/kernel/cpu_ops_sbi.c",
      "func_name": "sbi_cpu_start",
      "func_body": "static int sbi_cpu_start(unsigned int cpuid, struct task_struct *tidle)\n{\n\tunsigned long boot_addr = __pa_symbol(secondary_start_sbi);\n\tunsigned long hartid = cpuid_to_hartid_map(cpuid);\n\tunsigned long hsm_data;\n\tstruct sbi_hart_boot_data *bdata = &per_cpu(boot_data, cpuid);\n\n\t/* Make sure tidle is updated */\n\tsmp_mb();\n\tbdata->task_ptr = tidle;\n\tbdata->stack_ptr = task_pt_regs(tidle);\n\t/* Make sure boot data is updated */\n\tsmp_mb();\n\thsm_data = __pa(bdata);\n\treturn sbi_hsm_hart_start(hartid, boot_addr, hsm_data);\n}\n",
      "cve_list": [
        "CVE-2024-38667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "arch/riscv/kernel/cpu_ops_spinwait.c",
      "func_name": "cpu_update_secondary_bootdata",
      "func_body": "static void cpu_update_secondary_bootdata(unsigned int cpuid,\n\t\t\t\t   struct task_struct *tidle)\n{\n\tunsigned long hartid = cpuid_to_hartid_map(cpuid);\n\n\t/*\n\t * The hartid must be less than NR_CPUS to avoid out-of-bound access\n\t * errors for __cpu_spinwait_stack/task_pointer. That is not always possible\n\t * for platforms with discontiguous hartid numbering scheme. That's why\n\t * spinwait booting is not the recommended approach for any platforms\n\t * booting Linux in S-mode and can be disabled in the future.\n\t */\n\tif (hartid == INVALID_HARTID || hartid >= (unsigned long) NR_CPUS)\n\t\treturn;\n\n\t/* Make sure tidle is updated */\n\tsmp_mb();\n\tWRITE_ONCE(__cpu_spinwait_stack_pointer[hartid], task_pt_regs(tidle));\n\tWRITE_ONCE(__cpu_spinwait_task_pointer[hartid], tidle);\n}\n",
      "cve_list": [
        "CVE-2024-38667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/sched/sch_multiq.c",
      "func_name": "multiq_tune",
      "func_body": "static int multiq_tune(struct Qdisc *sch, struct nlattr *opt,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct multiq_sched_data *q = qdisc_priv(sch);\n\tstruct tc_multiq_qopt *qopt;\n\tstruct Qdisc **removed;\n\tint i, n_removed = 0;\n\n\tif (!netif_is_multiqueue(qdisc_dev(sch)))\n\t\treturn -EOPNOTSUPP;\n\tif (nla_len(opt) < sizeof(*qopt))\n\t\treturn -EINVAL;\n\n\tqopt = nla_data(opt);\n\n\tqopt->bands = qdisc_dev(sch)->real_num_tx_queues;\n\n\tremoved = kmalloc(sizeof(*removed) * (q->max_bands - qopt->bands),\n\t\t\t  GFP_KERNEL);\n\tif (!removed)\n\t\treturn -ENOMEM;\n\n\tsch_tree_lock(sch);\n\tq->bands = qopt->bands;\n\tfor (i = q->bands; i < q->max_bands; i++) {\n\t\tif (q->queues[i] != &noop_qdisc) {\n\t\t\tstruct Qdisc *child = q->queues[i];\n\n\t\t\tq->queues[i] = &noop_qdisc;\n\t\t\tqdisc_purge_queue(child);\n\t\t\tremoved[n_removed++] = child;\n\t\t}\n\t}\n\n\tsch_tree_unlock(sch);\n\n\tfor (i = 0; i < n_removed; i++)\n\t\tqdisc_put(removed[i]);\n\tkfree(removed);\n\n\tfor (i = 0; i < q->bands; i++) {\n\t\tif (q->queues[i] == &noop_qdisc) {\n\t\t\tstruct Qdisc *child, *old;\n\t\t\tchild = qdisc_create_dflt(sch->dev_queue,\n\t\t\t\t\t\t  &pfifo_qdisc_ops,\n\t\t\t\t\t\t  TC_H_MAKE(sch->handle,\n\t\t\t\t\t\t\t    i + 1), extack);\n\t\t\tif (child) {\n\t\t\t\tsch_tree_lock(sch);\n\t\t\t\told = q->queues[i];\n\t\t\t\tq->queues[i] = child;\n\t\t\t\tif (child != &noop_qdisc)\n\t\t\t\t\tqdisc_hash_add(child, true);\n\n\t\t\t\tif (old != &noop_qdisc)\n\t\t\t\t\tqdisc_purge_queue(old);\n\t\t\t\tsch_tree_unlock(sch);\n\t\t\t\tqdisc_put(old);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-36978"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/amdgpu/amdgpu_ring.c",
      "func_name": "amdgpu_ring_init",
      "func_body": "int amdgpu_ring_init(struct amdgpu_device *adev, struct amdgpu_ring *ring,\n\t\t     unsigned int max_dw, struct amdgpu_irq_src *irq_src,\n\t\t     unsigned int irq_type, unsigned int hw_prio,\n\t\t     atomic_t *sched_score)\n{\n\tint r;\n\tint sched_hw_submission = amdgpu_sched_hw_submission;\n\tu32 *num_sched;\n\tu32 hw_ip;\n\tunsigned int max_ibs_dw;\n\n\t/* Set the hw submission limit higher for KIQ because\n\t * it's used for a number of gfx/compute tasks by both\n\t * KFD and KGD which may have outstanding fences and\n\t * it doesn't really use the gpu scheduler anyway;\n\t * KIQ tasks get submitted directly to the ring.\n\t */\n\tif (ring->funcs->type == AMDGPU_RING_TYPE_KIQ)\n\t\tsched_hw_submission = max(sched_hw_submission, 256);\n\telse if (ring == &adev->sdma.instance[0].page)\n\t\tsched_hw_submission = 256;\n\n\tif (ring->adev == NULL) {\n\t\tif (adev->num_rings >= AMDGPU_MAX_RINGS)\n\t\t\treturn -EINVAL;\n\n\t\tring->adev = adev;\n\t\tring->num_hw_submission = sched_hw_submission;\n\t\tring->sched_score = sched_score;\n\t\tring->vmid_wait = dma_fence_get_stub();\n\n\t\tif (!ring->is_mes_queue) {\n\t\t\tring->idx = adev->num_rings++;\n\t\t\tadev->rings[ring->idx] = ring;\n\t\t}\n\n\t\tr = amdgpu_fence_driver_init_ring(ring);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tif (ring->is_mes_queue) {\n\t\tring->rptr_offs = amdgpu_mes_ctx_get_offs(ring,\n\t\t\t\tAMDGPU_MES_CTX_RPTR_OFFS);\n\t\tring->wptr_offs = amdgpu_mes_ctx_get_offs(ring,\n\t\t\t\tAMDGPU_MES_CTX_WPTR_OFFS);\n\t\tring->fence_offs = amdgpu_mes_ctx_get_offs(ring,\n\t\t\t\tAMDGPU_MES_CTX_FENCE_OFFS);\n\t\tring->trail_fence_offs = amdgpu_mes_ctx_get_offs(ring,\n\t\t\t\tAMDGPU_MES_CTX_TRAIL_FENCE_OFFS);\n\t\tring->cond_exe_offs = amdgpu_mes_ctx_get_offs(ring,\n\t\t\t\tAMDGPU_MES_CTX_COND_EXE_OFFS);\n\t} else {\n\t\tr = amdgpu_device_wb_get(adev, &ring->rptr_offs);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"(%d) ring rptr_offs wb alloc failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\n\t\tr = amdgpu_device_wb_get(adev, &ring->wptr_offs);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"(%d) ring wptr_offs wb alloc failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\n\t\tr = amdgpu_device_wb_get(adev, &ring->fence_offs);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"(%d) ring fence_offs wb alloc failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\n\t\tr = amdgpu_device_wb_get(adev, &ring->trail_fence_offs);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"(%d) ring trail_fence_offs wb alloc failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\n\t\tr = amdgpu_device_wb_get(adev, &ring->cond_exe_offs);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"(%d) ring cond_exec_polling wb alloc failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tring->fence_gpu_addr =\n\t\tamdgpu_ring_get_gpu_addr(ring, ring->fence_offs);\n\tring->fence_cpu_addr =\n\t\tamdgpu_ring_get_cpu_addr(ring, ring->fence_offs);\n\n\tring->rptr_gpu_addr =\n\t\tamdgpu_ring_get_gpu_addr(ring, ring->rptr_offs);\n\tring->rptr_cpu_addr =\n\t\tamdgpu_ring_get_cpu_addr(ring, ring->rptr_offs);\n\n\tring->wptr_gpu_addr =\n\t\tamdgpu_ring_get_gpu_addr(ring, ring->wptr_offs);\n\tring->wptr_cpu_addr =\n\t\tamdgpu_ring_get_cpu_addr(ring, ring->wptr_offs);\n\n\tring->trail_fence_gpu_addr =\n\t\tamdgpu_ring_get_gpu_addr(ring, ring->trail_fence_offs);\n\tring->trail_fence_cpu_addr =\n\t\tamdgpu_ring_get_cpu_addr(ring, ring->trail_fence_offs);\n\n\tring->cond_exe_gpu_addr =\n\t\tamdgpu_ring_get_gpu_addr(ring, ring->cond_exe_offs);\n\tring->cond_exe_cpu_addr =\n\t\tamdgpu_ring_get_cpu_addr(ring, ring->cond_exe_offs);\n\n\t/* always set cond_exec_polling to CONTINUE */\n\t*ring->cond_exe_cpu_addr = 1;\n\n\tr = amdgpu_fence_driver_start_ring(ring, irq_src, irq_type);\n\tif (r) {\n\t\tdev_err(adev->dev, \"failed initializing fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tmax_ibs_dw = ring->funcs->emit_frame_size +\n\t\t     amdgpu_ring_max_ibs(ring->funcs->type) * ring->funcs->emit_ib_size;\n\tmax_ibs_dw = (max_ibs_dw + ring->funcs->align_mask) & ~ring->funcs->align_mask;\n\n\tif (WARN_ON(max_ibs_dw > max_dw))\n\t\tmax_dw = max_ibs_dw;\n\n\tring->ring_size = roundup_pow_of_two(max_dw * 4 * sched_hw_submission);\n\n\tring->buf_mask = (ring->ring_size / 4) - 1;\n\tring->ptr_mask = ring->funcs->support_64bit_ptrs ?\n\t\t0xffffffffffffffff : ring->buf_mask;\n\n\t/* Allocate ring buffer */\n\tif (ring->is_mes_queue) {\n\t\tint offset = 0;\n\n\t\tBUG_ON(ring->ring_size > PAGE_SIZE*4);\n\n\t\toffset = amdgpu_mes_ctx_get_offs(ring,\n\t\t\t\t\t AMDGPU_MES_CTX_RING_OFFS);\n\t\tring->gpu_addr = amdgpu_mes_ctx_get_offs_gpu_addr(ring, offset);\n\t\tring->ring = amdgpu_mes_ctx_get_offs_cpu_addr(ring, offset);\n\t\tamdgpu_ring_clear_ring(ring);\n\n\t} else if (ring->ring_obj == NULL) {\n\t\tr = amdgpu_bo_create_kernel(adev, ring->ring_size + ring->funcs->extra_dw, PAGE_SIZE,\n\t\t\t\t\t    AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t\t    &ring->ring_obj,\n\t\t\t\t\t    &ring->gpu_addr,\n\t\t\t\t\t    (void **)&ring->ring);\n\t\tif (r) {\n\t\t\tdev_err(adev->dev, \"(%d) ring create failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\t\tamdgpu_ring_clear_ring(ring);\n\t}\n\n\tring->max_dw = max_dw;\n\tring->hw_prio = hw_prio;\n\n\tif (!ring->no_scheduler && ring->funcs->type < AMDGPU_HW_IP_NUM) {\n\t\thw_ip = ring->funcs->type;\n\t\tnum_sched = &adev->gpu_sched[hw_ip][hw_prio].num_scheds;\n\t\tadev->gpu_sched[hw_ip][hw_prio].sched[(*num_sched)++] =\n\t\t\t&ring->sched;\n\t}\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-46725"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/bpf/verifier.c",
      "func_name": "stacksafe",
      "func_body": "static bool stacksafe(struct bpf_verifier_env *env, struct bpf_func_state *old,\n\t\t      struct bpf_func_state *cur, struct bpf_idmap *idmap,\n\t\t      enum exact_level exact)\n{\n\tint i, spi;\n\n\t/* walk slots of the explored stack and ignore any additional\n\t * slots in the current stack, since explored(safe) state\n\t * didn't use them\n\t */\n\tfor (i = 0; i < old->allocated_stack; i++) {\n\t\tstruct bpf_reg_state *old_reg, *cur_reg;\n\n\t\tspi = i / BPF_REG_SIZE;\n\n\t\tif (exact != NOT_EXACT &&\n\t\t    (i >= cur->allocated_stack ||\n\t\t     old->stack[spi].slot_type[i % BPF_REG_SIZE] !=\n\t\t     cur->stack[spi].slot_type[i % BPF_REG_SIZE]))\n\t\t\treturn false;\n\n\t\tif (!(old->stack[spi].spilled_ptr.live & REG_LIVE_READ)\n\t\t    && exact == NOT_EXACT) {\n\t\t\ti += BPF_REG_SIZE - 1;\n\t\t\t/* explored state didn't use this */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (old->stack[spi].slot_type[i % BPF_REG_SIZE] == STACK_INVALID)\n\t\t\tcontinue;\n\n\t\tif (env->allow_uninit_stack &&\n\t\t    old->stack[spi].slot_type[i % BPF_REG_SIZE] == STACK_MISC)\n\t\t\tcontinue;\n\n\t\t/* explored stack has more populated slots than current stack\n\t\t * and these slots were used\n\t\t */\n\t\tif (i >= cur->allocated_stack)\n\t\t\treturn false;\n\n\t\t/* 64-bit scalar spill vs all slots MISC and vice versa.\n\t\t * Load from all slots MISC produces unbound scalar.\n\t\t * Construct a fake register for such stack and call\n\t\t * regsafe() to ensure scalar ids are compared.\n\t\t */\n\t\told_reg = scalar_reg_for_stack(env, &old->stack[spi]);\n\t\tcur_reg = scalar_reg_for_stack(env, &cur->stack[spi]);\n\t\tif (old_reg && cur_reg) {\n\t\t\tif (!regsafe(env, old_reg, cur_reg, idmap, exact))\n\t\t\t\treturn false;\n\t\t\ti += BPF_REG_SIZE - 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* if old state was safe with misc data in the stack\n\t\t * it will be safe with zero-initialized stack.\n\t\t * The opposite is not true\n\t\t */\n\t\tif (old->stack[spi].slot_type[i % BPF_REG_SIZE] == STACK_MISC &&\n\t\t    cur->stack[spi].slot_type[i % BPF_REG_SIZE] == STACK_ZERO)\n\t\t\tcontinue;\n\t\tif (old->stack[spi].slot_type[i % BPF_REG_SIZE] !=\n\t\t    cur->stack[spi].slot_type[i % BPF_REG_SIZE])\n\t\t\t/* Ex: old explored (safe) state has STACK_SPILL in\n\t\t\t * this stack slot, but current has STACK_MISC ->\n\t\t\t * this verifier states are not equivalent,\n\t\t\t * return false to continue verification of this path\n\t\t\t */\n\t\t\treturn false;\n\t\tif (i % BPF_REG_SIZE != BPF_REG_SIZE - 1)\n\t\t\tcontinue;\n\t\t/* Both old and cur are having same slot_type */\n\t\tswitch (old->stack[spi].slot_type[BPF_REG_SIZE - 1]) {\n\t\tcase STACK_SPILL:\n\t\t\t/* when explored and current stack slot are both storing\n\t\t\t * spilled registers, check that stored pointers types\n\t\t\t * are the same as well.\n\t\t\t * Ex: explored safe path could have stored\n\t\t\t * (bpf_reg_state) {.type = PTR_TO_STACK, .off = -8}\n\t\t\t * but current path has stored:\n\t\t\t * (bpf_reg_state) {.type = PTR_TO_STACK, .off = -16}\n\t\t\t * such verifier states are not equivalent.\n\t\t\t * return false to continue verification of this path\n\t\t\t */\n\t\t\tif (!regsafe(env, &old->stack[spi].spilled_ptr,\n\t\t\t\t     &cur->stack[spi].spilled_ptr, idmap, exact))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase STACK_DYNPTR:\n\t\t\told_reg = &old->stack[spi].spilled_ptr;\n\t\t\tcur_reg = &cur->stack[spi].spilled_ptr;\n\t\t\tif (old_reg->dynptr.type != cur_reg->dynptr.type ||\n\t\t\t    old_reg->dynptr.first_slot != cur_reg->dynptr.first_slot ||\n\t\t\t    !check_ids(old_reg->ref_obj_id, cur_reg->ref_obj_id, idmap))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase STACK_ITER:\n\t\t\told_reg = &old->stack[spi].spilled_ptr;\n\t\t\tcur_reg = &cur->stack[spi].spilled_ptr;\n\t\t\t/* iter.depth is not compared between states as it\n\t\t\t * doesn't matter for correctness and would otherwise\n\t\t\t * prevent convergence; we maintain it only to prevent\n\t\t\t * infinite loop check triggering, see\n\t\t\t * iter_active_depths_differ()\n\t\t\t */\n\t\t\tif (old_reg->iter.btf != cur_reg->iter.btf ||\n\t\t\t    old_reg->iter.btf_id != cur_reg->iter.btf_id ||\n\t\t\t    old_reg->iter.state != cur_reg->iter.state ||\n\t\t\t    /* ignore {old_reg,cur_reg}->iter.depth, see above */\n\t\t\t    !check_ids(old_reg->ref_obj_id, cur_reg->ref_obj_id, idmap))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase STACK_MISC:\n\t\tcase STACK_ZERO:\n\t\tcase STACK_INVALID:\n\t\t\tcontinue;\n\t\t/* Ensure that new unhandled slot types return false by default */\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n",
      "cve_list": [
        "CVE-2024-45020"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/scsi/qla2xxx/qla_os.c",
      "func_name": "qla2x00_number_of_exch",
      "func_body": "static void\nqla2x00_number_of_exch(scsi_qla_host_t *vha, u32 *ret_cnt, u16 max_cnt)\n{\n\tu32 temp;\n\tstruct init_cb_81xx *icb = (struct init_cb_81xx *)vha->hw->init_cb;\n\t*ret_cnt = FW_DEF_EXCHANGES_CNT;\n\n\tif (max_cnt > vha->hw->max_exchg)\n\t\tmax_cnt = vha->hw->max_exchg;\n\n\tif (qla_ini_mode_enabled(vha)) {\n\t\tif (vha->ql2xiniexchg > max_cnt)\n\t\t\tvha->ql2xiniexchg = max_cnt;\n\n\t\tif (vha->ql2xiniexchg > FW_DEF_EXCHANGES_CNT)\n\t\t\t*ret_cnt = vha->ql2xiniexchg;\n\n\t} else if (qla_tgt_mode_enabled(vha)) {\n\t\tif (vha->ql2xexchoffld > max_cnt) {\n\t\t\tvha->ql2xexchoffld = max_cnt;\n\t\t\ticb->exchange_count = cpu_to_le16(vha->ql2xexchoffld);\n\t\t}\n\n\t\tif (vha->ql2xexchoffld > FW_DEF_EXCHANGES_CNT)\n\t\t\t*ret_cnt = vha->ql2xexchoffld;\n\t} else if (qla_dual_mode_enabled(vha)) {\n\t\ttemp = vha->ql2xiniexchg + vha->ql2xexchoffld;\n\t\tif (temp > max_cnt) {\n\t\t\tvha->ql2xiniexchg -= (temp - max_cnt)/2;\n\t\t\tvha->ql2xexchoffld -= (((temp - max_cnt)/2) + 1);\n\t\t\ttemp = max_cnt;\n\t\t\ticb->exchange_count = cpu_to_le16(vha->ql2xexchoffld);\n\t\t}\n\n\t\tif (temp > FW_DEF_EXCHANGES_CNT)\n\t\t\t*ret_cnt = temp;\n\t}\n}\n",
      "cve_list": [
        "CVE-2024-42288"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/md/raid1.c",
      "func_name": "choose_bb_rdev",
      "func_body": "static int choose_bb_rdev(struct r1conf *conf, struct r1bio *r1_bio,\n\t\t\t  int *max_sectors)\n{\n\tsector_t this_sector = r1_bio->sector;\n\tint best_disk = -1;\n\tint best_len = 0;\n\tint disk;\n\n\tfor (disk = 0 ; disk < conf->raid_disks * 2 ; disk++) {\n\t\tstruct md_rdev *rdev;\n\t\tint len;\n\t\tint read_len;\n\n\t\tif (r1_bio->bios[disk] == IO_BLOCKED)\n\t\t\tcontinue;\n\n\t\trdev = conf->mirrors[disk].rdev;\n\t\tif (!rdev || test_bit(Faulty, &rdev->flags) ||\n\t\t    rdev_in_recovery(rdev, r1_bio) ||\n\t\t    test_bit(WriteMostly, &rdev->flags))\n\t\t\tcontinue;\n\n\t\t/* keep track of the disk with the most readable sectors. */\n\t\tlen = r1_bio->sectors;\n\t\tread_len = raid1_check_read_range(rdev, this_sector, &len);\n\t\tif (read_len > best_len) {\n\t\t\tbest_disk = disk;\n\t\t\tbest_len = read_len;\n\t\t}\n\t}\n\n\tif (best_disk != -1) {\n\t\t*max_sectors = best_len;\n\t\tupdate_read_sectors(conf, best_disk, this_sector, best_len);\n\t}\n\n\treturn best_disk;\n}\n",
      "cve_list": [
        "CVE-2024-45023"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/md/raid1.c",
      "func_name": "choose_slow_rdev",
      "func_body": "static int choose_slow_rdev(struct r1conf *conf, struct r1bio *r1_bio,\n\t\t\t    int *max_sectors)\n{\n\tsector_t this_sector = r1_bio->sector;\n\tint bb_disk = -1;\n\tint bb_read_len = 0;\n\tint disk;\n\n\tfor (disk = 0 ; disk < conf->raid_disks * 2 ; disk++) {\n\t\tstruct md_rdev *rdev;\n\t\tint len;\n\t\tint read_len;\n\n\t\tif (r1_bio->bios[disk] == IO_BLOCKED)\n\t\t\tcontinue;\n\n\t\trdev = conf->mirrors[disk].rdev;\n\t\tif (!rdev || test_bit(Faulty, &rdev->flags) ||\n\t\t    !test_bit(WriteMostly, &rdev->flags) ||\n\t\t    rdev_in_recovery(rdev, r1_bio))\n\t\t\tcontinue;\n\n\t\t/* there are no bad blocks, we can use this disk */\n\t\tlen = r1_bio->sectors;\n\t\tread_len = raid1_check_read_range(rdev, this_sector, &len);\n\t\tif (read_len == r1_bio->sectors) {\n\t\t\t*max_sectors = read_len;\n\t\t\tupdate_read_sectors(conf, disk, this_sector, read_len);\n\t\t\treturn disk;\n\t\t}\n\n\t\t/*\n\t\t * there are partial bad blocks, choose the rdev with largest\n\t\t * read length.\n\t\t */\n\t\tif (read_len > bb_read_len) {\n\t\t\tbb_disk = disk;\n\t\t\tbb_read_len = read_len;\n\t\t}\n\t}\n\n\tif (bb_disk != -1) {\n\t\t*max_sectors = bb_read_len;\n\t\tupdate_read_sectors(conf, bb_disk, this_sector, bb_read_len);\n\t}\n\n\treturn bb_disk;\n}\n",
      "cve_list": [
        "CVE-2024-45023"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/gpu/drm/amd/amdgpu/amdgpu_psp_ta.c",
      "func_name": "ta_if_load_debugfs_write",
      "func_body": "static ssize_t ta_if_load_debugfs_write(struct file *fp, const char *buf, size_t len, loff_t *off)\n{\n\tuint32_t ta_type    = 0;\n\tuint32_t ta_bin_len = 0;\n\tuint8_t  *ta_bin    = NULL;\n\tuint32_t copy_pos   = 0;\n\tint      ret        = 0;\n\n\tstruct amdgpu_device *adev    = (struct amdgpu_device *)file_inode(fp)->i_private;\n\tstruct psp_context   *psp     = &adev->psp;\n\tstruct ta_context    *context = NULL;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tret = copy_from_user((void *)&ta_type, &buf[copy_pos], sizeof(uint32_t));\n\tif (ret || (!is_ta_type_valid(ta_type)))\n\t\treturn -EFAULT;\n\n\tcopy_pos += sizeof(uint32_t);\n\n\tret = copy_from_user((void *)&ta_bin_len, &buf[copy_pos], sizeof(uint32_t));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tif (ta_bin_len > PSP_1_MEG)\n\t\treturn -EINVAL;\n\n\tcopy_pos += sizeof(uint32_t);\n\n\tta_bin = kzalloc(ta_bin_len, GFP_KERNEL);\n\tif (!ta_bin)\n\t\treturn -ENOMEM;\n\tif (copy_from_user((void *)ta_bin, &buf[copy_pos], ta_bin_len)) {\n\t\tret = -EFAULT;\n\t\tgoto err_free_bin;\n\t}\n\n\t/* Set TA context and functions */\n\tset_ta_context_funcs(psp, ta_type, &context);\n\n\tif (!psp->ta_funcs || !psp->ta_funcs->fn_ta_terminate) {\n\t\tdev_err(adev->dev, \"Unsupported function to terminate TA\\n\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto err_free_bin;\n\t}\n\n\t/*\n\t * Allocate TA shared buf in case shared buf was freed\n\t * due to loading TA failed before.\n\t */\n\tif (!context->mem_context.shared_buf) {\n\t\tret = psp_ta_init_shared_buf(psp, &context->mem_context);\n\t\tif (ret) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_bin;\n\t\t}\n\t}\n\n\tret = psp_fn_ta_terminate(psp);\n\tif (ret || context->resp_status) {\n\t\tdev_err(adev->dev,\n\t\t\t\"Failed to unload embedded TA (%d) and status (0x%X)\\n\",\n\t\t\tret, context->resp_status);\n\t\tif (!ret)\n\t\t\tret = -EINVAL;\n\t\tgoto err_free_ta_shared_buf;\n\t}\n\n\t/* Prepare TA context for TA initialization */\n\tcontext->ta_type                     = ta_type;\n\tcontext->bin_desc.fw_version         = get_bin_version(ta_bin);\n\tcontext->bin_desc.size_bytes         = ta_bin_len;\n\tcontext->bin_desc.start_addr         = ta_bin;\n\n\tif (!psp->ta_funcs->fn_ta_initialize) {\n\t\tdev_err(adev->dev, \"Unsupported function to initialize TA\\n\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto err_free_ta_shared_buf;\n\t}\n\n\tret = psp_fn_ta_initialize(psp);\n\tif (ret || context->resp_status) {\n\t\tdev_err(adev->dev, \"Failed to load TA via debugfs (%d) and status (0x%X)\\n\",\n\t\t\tret, context->resp_status);\n\t\tif (!ret)\n\t\t\tret = -EINVAL;\n\t\tgoto err_free_ta_shared_buf;\n\t}\n\n\tif (copy_to_user((char *)buf, (void *)&context->session_id, sizeof(uint32_t)))\n\t\tret = -EFAULT;\n\nerr_free_ta_shared_buf:\n\t/* Only free TA shared buf when returns error code */\n\tif (ret && context->mem_context.shared_buf)\n\t\tpsp_ta_free_shared_buf(&context->mem_context);\nerr_free_bin:\n\tkfree(ta_bin);\n\n\treturn ret;\n}\n",
      "cve_list": [
        "CVE-2024-44977"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/infiniband/core/restrack.c",
      "func_name": "rdma_restrack_clean",
      "func_body": "void rdma_restrack_clean(struct ib_device *dev)\n{\n\tstruct rdma_restrack_root *rt = dev->res;\n\tint i;\n\n\tfor (i = 0 ; i < RDMA_RESTRACK_MAX; i++) {\n\t\tstruct xarray *xa = &dev->res[i].xa;\n\n\t\tWARN_ON(!xa_empty(xa));\n\t\txa_destroy(xa);\n\t}\n\tkfree(rt);\n}\n",
      "cve_list": [
        "CVE-2024-42080"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/freescale/dpaa2/dpaa2-eth.c",
      "func_name": "update_xps",
      "func_body": "static int update_xps(struct dpaa2_eth_priv *priv)\n{\n\tstruct net_device *net_dev = priv->net_dev;\n\tint i, num_queues, netdev_queues;\n\tstruct dpaa2_eth_fq *fq;\n\tcpumask_var_t xps_mask;\n\tint err = 0;\n\n\tif (!alloc_cpumask_var(&xps_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tnum_queues = dpaa2_eth_queue_count(priv);\n\tnetdev_queues = (net_dev->num_tc ? : 1) * num_queues;\n\n\t/* The first <num_queues> entries in priv->fq array are Tx/Tx conf\n\t * queues, so only process those\n\t */\n\tfor (i = 0; i < netdev_queues; i++) {\n\t\tfq = &priv->fq[i % num_queues];\n\n\t\tcpumask_clear(xps_mask);\n\t\tcpumask_set_cpu(fq->target_cpu, xps_mask);\n\n\t\terr = netif_set_xps_queue(net_dev, xps_mask, i);\n\t\tif (err) {\n\t\t\tnetdev_warn_once(net_dev, \"Error setting XPS queue\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree_cpumask_var(xps_mask);\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-42093"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/net/ethernet/broadcom/bnxt/bnxt.c",
      "func_name": "bnxt_need_reserve_rings",
      "func_body": "static bool bnxt_need_reserve_rings(struct bnxt *bp)\n{\n\tstruct bnxt_hw_resc *hw_resc = &bp->hw_resc;\n\tint cp = bnxt_cp_rings_in_use(bp);\n\tint nq = bnxt_nq_rings_in_use(bp);\n\tint rx = bp->rx_nr_rings, stat;\n\tint vnic, grp = rx;\n\n\t/* Old firmware does not need RX ring reservations but we still\n\t * need to setup a default RSS map when needed.  With new firmware\n\t * we go through RX ring reservations first and then set up the\n\t * RSS map for the successfully reserved RX rings when needed.\n\t */\n\tif (!BNXT_NEW_RM(bp))\n\t\tbnxt_check_rss_tbl_no_rmgr(bp);\n\n\tif (hw_resc->resv_tx_rings != bp->tx_nr_rings &&\n\t    bp->hwrm_spec_code >= 0x10601)\n\t\treturn true;\n\n\tif (!BNXT_NEW_RM(bp))\n\t\treturn false;\n\n\tvnic = bnxt_get_total_vnics(bp, rx);\n\n\tif (bp->flags & BNXT_FLAG_AGG_RINGS)\n\t\trx <<= 1;\n\tstat = bnxt_get_func_stat_ctxs(bp);\n\tif (hw_resc->resv_rx_rings != rx || hw_resc->resv_cp_rings != cp ||\n\t    hw_resc->resv_vnics != vnic || hw_resc->resv_stat_ctxs != stat ||\n\t    (hw_resc->resv_hw_ring_grps != grp &&\n\t     !(bp->flags & BNXT_FLAG_CHIP_P5_PLUS)))\n\t\treturn true;\n\tif ((bp->flags & BNXT_FLAG_CHIP_P5_PLUS) && BNXT_PF(bp) &&\n\t    hw_resc->resv_irqs != nq)\n\t\treturn true;\n\treturn false;\n}\n",
      "cve_list": [
        "CVE-2024-44933"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "kernel/bpf/verifier.c",
      "func_name": "process_dynptr_func",
      "func_body": "static int process_dynptr_func(struct bpf_verifier_env *env, int regno, int insn_idx,\n\t\t\t       enum bpf_arg_type arg_type, int clone_ref_obj_id)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tint err;\n\n\tif (reg->type != PTR_TO_STACK && reg->type != CONST_PTR_TO_DYNPTR) {\n\t\tverbose(env,\n\t\t\t\"arg#%d expected pointer to stack or const struct bpf_dynptr\\n\",\n\t\t\tregno);\n\t\treturn -EINVAL;\n\t}\n\n\t/* MEM_UNINIT and MEM_RDONLY are exclusive, when applied to an\n\t * ARG_PTR_TO_DYNPTR (or ARG_PTR_TO_DYNPTR | DYNPTR_TYPE_*):\n\t */\n\tif ((arg_type & (MEM_UNINIT | MEM_RDONLY)) == (MEM_UNINIT | MEM_RDONLY)) {\n\t\tverbose(env, \"verifier internal error: misconfigured dynptr helper type flags\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t/*  MEM_UNINIT - Points to memory that is an appropriate candidate for\n\t *\t\t constructing a mutable bpf_dynptr object.\n\t *\n\t *\t\t Currently, this is only possible with PTR_TO_STACK\n\t *\t\t pointing to a region of at least 16 bytes which doesn't\n\t *\t\t contain an existing bpf_dynptr.\n\t *\n\t *  MEM_RDONLY - Points to a initialized bpf_dynptr that will not be\n\t *\t\t mutated or destroyed. However, the memory it points to\n\t *\t\t may be mutated.\n\t *\n\t *  None       - Points to a initialized dynptr that can be mutated and\n\t *\t\t destroyed, including mutation of the memory it points\n\t *\t\t to.\n\t */\n\tif (arg_type & MEM_UNINIT) {\n\t\tint i;\n\n\t\tif (!is_dynptr_reg_valid_uninit(env, reg)) {\n\t\t\tverbose(env, \"Dynptr has to be an uninitialized dynptr\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* we write BPF_DW bits (8 bytes) at a time */\n\t\tfor (i = 0; i < BPF_DYNPTR_SIZE; i += 8) {\n\t\t\terr = check_mem_access(env, insn_idx, regno,\n\t\t\t\t\t       i, BPF_DW, BPF_WRITE, -1, false, false);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\terr = mark_stack_slots_dynptr(env, reg, arg_type, insn_idx, clone_ref_obj_id);\n\t} else /* MEM_RDONLY and None case from above */ {\n\t\t/* For the reg->type == PTR_TO_STACK case, bpf_dynptr is never const */\n\t\tif (reg->type == CONST_PTR_TO_DYNPTR && !(arg_type & MEM_RDONLY)) {\n\t\t\tverbose(env, \"cannot pass pointer to const bpf_dynptr, the helper mutates it\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!is_dynptr_reg_valid_init(env, reg)) {\n\t\t\tverbose(env,\n\t\t\t\t\"Expected an initialized dynptr as arg #%d\\n\",\n\t\t\t\tregno);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Fold modifiers (in this case, MEM_RDONLY) when checking expected type */\n\t\tif (!is_dynptr_type_expected(env, reg, arg_type & ~MEM_RDONLY)) {\n\t\t\tverbose(env,\n\t\t\t\t\"Expected a dynptr of type %s as arg #%d\\n\",\n\t\t\t\tdynptr_type_str(arg_to_dynptr_type(arg_type)), regno);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = mark_dynptr_read(env, reg);\n\t}\n\treturn err;\n}\n",
      "cve_list": [
        "CVE-2024-43910"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "drivers/soc/qcom/cmd-db.c",
      "func_name": "cmd_db_dev_probe",
      "func_body": "static int cmd_db_dev_probe(struct platform_device *pdev)\n{\n\tstruct reserved_mem *rmem;\n\tint ret = 0;\n\n\trmem = of_reserved_mem_lookup(pdev->dev.of_node);\n\tif (!rmem) {\n\t\tdev_err(&pdev->dev, \"failed to acquire memory region\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcmd_db_header = memremap(rmem->base, rmem->size, MEMREMAP_WC);\n\tif (!cmd_db_header) {\n\t\tret = -ENOMEM;\n\t\tcmd_db_header = NULL;\n\t\treturn ret;\n\t}\n\n\tif (!cmd_db_magic_matches(cmd_db_header)) {\n\t\tdev_err(&pdev->dev, \"Invalid Command DB Magic\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdebugfs_create_file(\"cmd-db\", 0400, NULL, NULL, &cmd_db_debugfs_ops);\n\n\tdevice_set_pm_not_required(&pdev->dev);\n\n\treturn 0;\n}\n",
      "cve_list": [
        "CVE-2024-46689"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/sctp/socket.c",
      "func_name": "sctp_auto_asconf_init",
      "func_body": "static void sctp_auto_asconf_init(struct sctp_sock *sp)\n{\n\tstruct net *net = sock_net(&sp->inet.sk);\n\n\tif (net->sctp.default_auto_asconf) {\n\t\tspin_lock_bh(&net->sctp.addr_wq_lock);\n\t\tlist_add_tail(&sp->auto_asconf_list, &net->sctp.auto_asconf_splist);\n\t\tspin_unlock_bh(&net->sctp.addr_wq_lock);\n\t\tsp->do_auto_asconf = 1;\n\t}\n}",
      "cve_list": [
        "CVE-2024-0639"
      ],
      "cwe_list": [
        "CWE-667"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/tipc/crypto.c",
      "func_name": "tipc_crypto_key_revoke",
      "func_body": "static int tipc_crypto_key_revoke(struct net *net, u8 tx_key)\n{\n\tstruct tipc_crypto *tx = tipc_net(net)->crypto_tx;\n\tstruct tipc_key key;\n\n\tspin_lock_bh(&tx->lock);\n\tkey = tx->key;\n\tWARN_ON(!key.active || tx_key != key.active);\n\n\t/* Free the active key */\n\ttipc_crypto_key_set_state(tx, key.passive, 0, key.pending);\n\ttipc_crypto_key_detach(tx->aead[key.active], &tx->lock);\n\tspin_unlock_bh(&tx->lock);\n\n\tpr_warn(\"%s: key is revoked\\n\", tx->name);\n\treturn -EKEYREVOKED;\n}",
      "cve_list": [
        "CVE-2024-0641"
      ],
      "cwe_list": [
        "CWE-667"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/netfilter/nft_byteorder.c",
      "func_name": "nft_byteorder_eval",
      "func_body": "void nft_byteorder_eval(const struct nft_expr *expr,\n\t\t\tstruct nft_regs *regs,\n\t\t\tconst struct nft_pktinfo *pkt)\n{\n\tconst struct nft_byteorder *priv = nft_expr_priv(expr);\n\tu32 *src = &regs->data[priv->sreg];\n\tu32 *dst = &regs->data[priv->dreg];\n\tu16 *s16, *d16;\n\tunsigned int i;\n\n\ts16 = (void *)src;\n\td16 = (void *)dst;\n\n\tswitch (priv->size) {\n\tcase 8: {\n\t\tu64 *dst64 = (void *)dst;\n\t\tu64 src64;\n\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 8; i++) {\n\t\t\t\tsrc64 = nft_reg_load64(&src[i]);\n\t\t\t\tnft_reg_store64(&dst64[i],\n\t\t\t\t\t\tbe64_to_cpu((__force __be64)src64));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 8; i++) {\n\t\t\t\tsrc64 = (__force __u64)\n\t\t\t\t\tcpu_to_be64(nft_reg_load64(&src[i]));\n\t\t\t\tnft_reg_store64(&dst64[i], src64);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 4:\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 4; i++)\n\t\t\t\tdst[i] = ntohl((__force __be32)src[i]);\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 4; i++)\n\t\t\t\tdst[i] = (__force __u32)htonl(src[i]);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 2; i++)\n\t\t\t\td16[i] = ntohs((__force __be16)s16[i]);\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 2; i++)\n\t\t\t\td16[i] = (__force __u16)htons(s16[i]);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}",
      "cve_list": [
        "CVE-2024-0607"
      ],
      "cwe_list": [
        "NVD-CWE-Other"
      ]
    },
    {
      "project": "linux",
      "filepath": "net/netfilter/nft_meta.c",
      "func_name": "nft_meta_get_eval_time",
      "func_body": "nft_meta_get_eval_time(enum nft_meta_keys key,\n\t\t       u32 *dest)\n{\n\tswitch (key) {\n\tcase NFT_META_TIME_NS:\n\t\tnft_reg_store64((u64 *)dest, ktime_get_real_ns());\n\t\tbreak;\n\tcase NFT_META_TIME_DAY:\n\t\tnft_reg_store8(dest, nft_meta_weekday());\n\t\tbreak;\n\tcase NFT_META_TIME_HOUR:\n\t\t*dest = nft_meta_hour(ktime_get_real_seconds());\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
      "cve_list": [
        "CVE-2024-0607"
      ],
      "cwe_list": [
        "NVD-CWE-Other"
      ]
    },
    {
      "project": "linux",
      "filepath": "arch/x86/kernel/sev.c",
      "func_name": "do_boot_stage2_vc",
      "func_body": "void do_boot_stage2_vc(struct pt_regs *regs, unsigned long exit_code)\n{\n\tstruct es_em_ctxt ctxt;\n\tenum es_result result;\n\n\tif (!boot_ghcb && !early_setup_ghcb())\n\t\tsev_es_terminate(SEV_TERM_SET_GEN, GHCB_SEV_ES_GEN_REQ);\n\n\tvc_ghcb_invalidate(boot_ghcb);\n\tresult = vc_init_em_ctxt(&ctxt, regs, exit_code);\n\tif (result != ES_OK)\n\t\tgoto finish;\n\n\tresult = vc_check_opcode_bytes(&ctxt, exit_code);\n\tif (result != ES_OK)\n\t\tgoto finish;\n\n\tswitch (exit_code) {\n\tcase SVM_EXIT_RDTSC:\n\tcase SVM_EXIT_RDTSCP:\n\t\tresult = vc_handle_rdtsc(boot_ghcb, &ctxt, exit_code);\n\t\tbreak;\n\tcase SVM_EXIT_IOIO:\n\t\tresult = vc_handle_ioio(boot_ghcb, &ctxt);\n\t\tbreak;\n\tcase SVM_EXIT_CPUID:\n\t\tresult = vc_handle_cpuid(boot_ghcb, &ctxt);\n\t\tbreak;\n\tdefault:\n\t\tresult = ES_UNSUPPORTED;\n\t\tbreak;\n\t}\n\nfinish:\n\tif (result == ES_OK)\n\t\tvc_finish_insn(&ctxt);\n\telse if (result != ES_RETRY)\n\t\tsev_es_terminate(SEV_TERM_SET_GEN, GHCB_SEV_ES_GEN_REQ);\n}",
      "cve_list": [
        "CVE-2024-25742"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "linux",
      "filepath": "arch/x86/kernel/sev.c",
      "func_name": "vc_handle_exitcode",
      "func_body": "static enum es_result vc_handle_exitcode(struct es_em_ctxt *ctxt,\n\t\t\t\t\t struct ghcb *ghcb,\n\t\t\t\t\t unsigned long exit_code)\n{\n\tenum es_result result = vc_check_opcode_bytes(ctxt, exit_code);\n\n\tif (result != ES_OK)\n\t\treturn result;\n\n\tswitch (exit_code) {\n\tcase SVM_EXIT_READ_DR7:\n\t\tresult = vc_handle_dr7_read(ghcb, ctxt);\n\t\tbreak;\n\tcase SVM_EXIT_WRITE_DR7:\n\t\tresult = vc_handle_dr7_write(ghcb, ctxt);\n\t\tbreak;\n\tcase SVM_EXIT_EXCP_BASE + X86_TRAP_AC:\n\t\tresult = vc_handle_trap_ac(ghcb, ctxt);\n\t\tbreak;\n\tcase SVM_EXIT_RDTSC:\n\tcase SVM_EXIT_RDTSCP:\n\t\tresult = vc_handle_rdtsc(ghcb, ctxt, exit_code);\n\t\tbreak;\n\tcase SVM_EXIT_RDPMC:\n\t\tresult = vc_handle_rdpmc(ghcb, ctxt);\n\t\tbreak;\n\tcase SVM_EXIT_INVD:\n\t\tpr_err_ratelimited(\"#VC exception for INVD??? Seriously???\\n\");\n\t\tresult = ES_UNSUPPORTED;\n\t\tbreak;\n\tcase SVM_EXIT_CPUID:\n\t\tresult = vc_handle_cpuid(ghcb, ctxt);\n\t\tbreak;\n\tcase SVM_EXIT_IOIO:\n\t\tresult = vc_handle_ioio(ghcb, ctxt);\n\t\tbreak;\n\tcase SVM_EXIT_MSR:\n\t\tresult = vc_handle_msr(ghcb, ctxt);\n\t\tbreak;\n\tcase SVM_EXIT_VMMCALL:\n\t\tresult = vc_handle_vmmcall(ghcb, ctxt);\n\t\tbreak;\n\tcase SVM_EXIT_WBINVD:\n\t\tresult = vc_handle_wbinvd(ghcb, ctxt);\n\t\tbreak;\n\tcase SVM_EXIT_MONITOR:\n\t\tresult = vc_handle_monitor(ghcb, ctxt);\n\t\tbreak;\n\tcase SVM_EXIT_MWAIT:\n\t\tresult = vc_handle_mwait(ghcb, ctxt);\n\t\tbreak;\n\tcase SVM_EXIT_NPF:\n\t\tresult = vc_handle_mmio(ghcb, ctxt);\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * Unexpected #VC exception\n\t\t */\n\t\tresult = ES_UNSUPPORTED;\n\t}\n\n\treturn result;\n}",
      "cve_list": [
        "CVE-2024-25742"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "linux",
      "filepath": "arch/x86/kernel/sev-shared.c",
      "func_name": "do_vc_no_ghcb",
      "func_body": "void __init do_vc_no_ghcb(struct pt_regs *regs, unsigned long exit_code)\n{\n\tunsigned int subfn = lower_bits(regs->cx, 32);\n\tunsigned int fn = lower_bits(regs->ax, 32);\n\tu16 opcode = *(unsigned short *)regs->ip;\n\tstruct cpuid_leaf leaf;\n\tint ret;\n\n\t/* Only CPUID is supported via MSR protocol */\n\tif (exit_code != SVM_EXIT_CPUID)\n\t\tgoto fail;\n\n\t/* Is it really a CPUID insn? */\n\tif (opcode != 0xa20f)\n\t\tgoto fail;\n\n\tleaf.fn = fn;\n\tleaf.subfn = subfn;\n\n\tret = snp_cpuid(NULL, NULL, &leaf);\n\tif (!ret)\n\t\tgoto cpuid_done;\n\n\tif (ret != -EOPNOTSUPP)\n\t\tgoto fail;\n\n\tif (__sev_cpuid_hv_msr(&leaf))\n\t\tgoto fail;\n\ncpuid_done:\n\tregs->ax = leaf.eax;\n\tregs->bx = leaf.ebx;\n\tregs->cx = leaf.ecx;\n\tregs->dx = leaf.edx;\n\n\t/*\n\t * This is a VC handler and the #VC is only raised when SEV-ES is\n\t * active, which means SEV must be active too. Do sanity checks on the\n\t * CPUID results to make sure the hypervisor does not trick the kernel\n\t * into the no-sev path. This could map sensitive data unencrypted and\n\t * make it accessible to the hypervisor.\n\t *\n\t * In particular, check for:\n\t *\t- Availability of CPUID leaf 0x8000001f\n\t *\t- SEV CPUID bit.\n\t *\n\t * The hypervisor might still report the wrong C-bit position, but this\n\t * can't be checked here.\n\t */\n\n\tif (fn == 0x80000000 && (regs->ax < 0x8000001f))\n\t\t/* SEV leaf check */\n\t\tgoto fail;\n\telse if ((fn == 0x8000001f && !(regs->ax & BIT(1))))\n\t\t/* SEV bit */\n\t\tgoto fail;\n\n\t/* Skip over the CPUID two-byte opcode */\n\tregs->ip += 2;\n\n\treturn;\n\nfail:\n\t/* Terminate the guest */\n\tsev_es_terminate(SEV_TERM_SET_GEN, GHCB_SEV_ES_GEN_REQ);\n}",
      "cve_list": [
        "CVE-2024-25742"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "linux",
      "filepath": "arch/x86/kernel/sev-shared.c",
      "func_name": "vc_check_opcode_bytes",
      "func_body": "static enum es_result vc_check_opcode_bytes(struct es_em_ctxt *ctxt,\n\t\t\t\t\t    unsigned long exit_code)\n{\n\tunsigned int opcode = (unsigned int)ctxt->insn.opcode.value;\n\tu8 modrm = ctxt->insn.modrm.value;\n\n\tswitch (exit_code) {\n\n\tcase SVM_EXIT_IOIO:\n\tcase SVM_EXIT_NPF:\n\t\t/* handled separately */\n\t\treturn ES_OK;\n\n\tcase SVM_EXIT_CPUID:\n\t\tif (opcode == 0xa20f)\n\t\t\treturn ES_OK;\n\t\tbreak;\n\n\tcase SVM_EXIT_INVD:\n\t\tif (opcode == 0x080f)\n\t\t\treturn ES_OK;\n\t\tbreak;\n\n\tcase SVM_EXIT_MONITOR:\n\t\tif (opcode == 0x010f && modrm == 0xc8)\n\t\t\treturn ES_OK;\n\t\tbreak;\n\n\tcase SVM_EXIT_MWAIT:\n\t\tif (opcode == 0x010f && modrm == 0xc9)\n\t\t\treturn ES_OK;\n\t\tbreak;\n\n\tcase SVM_EXIT_MSR:\n\t\t/* RDMSR */\n\t\tif (opcode == 0x320f ||\n\t\t/* WRMSR */\n\t\t    opcode == 0x300f)\n\t\t\treturn ES_OK;\n\t\tbreak;\n\n\tcase SVM_EXIT_RDPMC:\n\t\tif (opcode == 0x330f)\n\t\t\treturn ES_OK;\n\t\tbreak;\n\n\tcase SVM_EXIT_RDTSC:\n\t\tif (opcode == 0x310f)\n\t\t\treturn ES_OK;\n\t\tbreak;\n\n\tcase SVM_EXIT_RDTSCP:\n\t\tif (opcode == 0x010f && modrm == 0xf9)\n\t\t\treturn ES_OK;\n\t\tbreak;\n\n\tcase SVM_EXIT_READ_DR7:\n\t\tif (opcode == 0x210f &&\n\t\t    X86_MODRM_REG(ctxt->insn.modrm.value) == 7)\n\t\t\treturn ES_OK;\n\t\tbreak;\n\n\tcase SVM_EXIT_VMMCALL:\n\t\tif (opcode == 0x010f && modrm == 0xd9)\n\t\t\treturn ES_OK;\n\n\t\tbreak;\n\n\tcase SVM_EXIT_WRITE_DR7:\n\t\tif (opcode == 0x230f &&\n\t\t    X86_MODRM_REG(ctxt->insn.modrm.value) == 7)\n\t\t\treturn ES_OK;\n\t\tbreak;\n\n\tcase SVM_EXIT_WBINVD:\n\t\tif (opcode == 0x90f)\n\t\t\treturn ES_OK;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsev_printk(KERN_ERR \"Wrong/unhandled opcode bytes: 0x%x, exit_code: 0x%lx, rIP: 0x%lx\\n\",\n\t\t   opcode, exit_code, ctxt->regs->ip);\n\n\treturn ES_UNSUPPORTED;\n}",
      "cve_list": [
        "CVE-2024-25742"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "FFmpeg",
      "filepath": "libavfilter/avf_showspectrum.c",
      "func_name": "activate",
      "func_body": "static int activate(AVFilterContext *ctx)\n{\n    AVFilterLink *inlink = ctx->inputs[0];\n    AVFilterLink *outlink = ctx->outputs[0];\n    ShowSpectrumContext *s = ctx->priv;\n    int ret, status;\n    int64_t pts;\n\n    FF_FILTER_FORWARD_STATUS_BACK(outlink, inlink);\n\n    if (s->outpicref) {\n        AVFrame *fin;\n\n        ret = ff_inlink_consume_samples(inlink, s->hop_size, s->hop_size, &fin);\n        if (ret < 0)\n            return ret;\n        if (ret > 0) {\n            s->consumed += fin->nb_samples;\n            ff_filter_execute(ctx, run_channel_fft, fin, NULL, s->nb_display_channels);\n\n            if (s->data == D_MAGNITUDE)\n                ff_filter_execute(ctx, calc_channel_magnitudes, NULL, NULL, s->nb_display_channels);\n\n            if (s->data == D_PHASE)\n                ff_filter_execute(ctx, calc_channel_phases, NULL, NULL, s->nb_display_channels);\n\n            if (s->data == D_UPHASE)\n                ff_filter_execute(ctx, calc_channel_uphases, NULL, NULL, s->nb_display_channels);\n\n            ret = plot_spectrum_column(inlink, fin);\n            av_frame_free(&fin);\n            if (ret <= 0)\n                return ret;\n        }\n    }\n\n    if (ff_outlink_get_status(inlink) == AVERROR_EOF &&\n        s->sliding == FULLFRAME &&\n        s->xpos > 0 && s->outpicref) {\n\n        if (s->orientation == VERTICAL) {\n            for (int i = 0; i < outlink->h; i++) {\n                memset(s->outpicref->data[0] + i * s->outpicref->linesize[0] + s->xpos,   0, outlink->w - s->xpos);\n                memset(s->outpicref->data[1] + i * s->outpicref->linesize[1] + s->xpos, 128, outlink->w - s->xpos);\n                memset(s->outpicref->data[2] + i * s->outpicref->linesize[2] + s->xpos, 128, outlink->w - s->xpos);\n            }\n        } else {\n            for (int i = s->xpos; i < outlink->h; i++) {\n                memset(s->outpicref->data[0] + i * s->outpicref->linesize[0],   0, outlink->w);\n                memset(s->outpicref->data[1] + i * s->outpicref->linesize[1], 128, outlink->w);\n                memset(s->outpicref->data[2] + i * s->outpicref->linesize[2], 128, outlink->w);\n            }\n        }\n        s->outpicref->pts += av_rescale_q(s->consumed, inlink->time_base, outlink->time_base);\n        pts = s->outpicref->pts;\n        ret = ff_filter_frame(outlink, s->outpicref);\n        s->outpicref = NULL;\n        ff_outlink_set_status(outlink, AVERROR_EOF, pts);\n        return 0;\n    }\n\n    if (ff_inlink_acknowledge_status(inlink, &status, &pts)) {\n        if (status == AVERROR_EOF) {\n            ff_outlink_set_status(outlink, status, s->pts);\n            return 0;\n        }\n    }\n\n    if (ff_inlink_queued_samples(inlink) >= s->hop_size) {\n        ff_filter_set_ready(ctx, 10);\n        return 0;\n    }\n\n    if (ff_outlink_frame_wanted(outlink)) {\n        ff_inlink_request_frame(inlink);\n        return 0;\n    }\n\n    return FFERROR_NOT_READY;\n}",
      "cve_list": [
        "CVE-2024-31585"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "FFmpeg",
      "filepath": "libavfilter/avf_showspectrum.c",
      "func_name": "config_output",
      "func_body": "static int config_output(AVFilterLink *outlink)\n{\n    AVFilterContext *ctx = outlink->src;\n    AVFilterLink *inlink = ctx->inputs[0];\n    ShowSpectrumContext *s = ctx->priv;\n    int i, fft_size, h, w, ret;\n    float overlap;\n\n    s->dmax = expf(s->limit * M_LN10 / 20.f);\n    s->dmin = expf((s->limit - s->drange) * M_LN10 / 20.f);\n\n    switch (s->fscale) {\n    case F_LINEAR: s->plot_channel = plot_channel_lin; break;\n    case F_LOG:    s->plot_channel = plot_channel_log; break;\n    default: return AVERROR_BUG;\n    }\n\n    s->stop = FFMIN(s->stop, inlink->sample_rate / 2);\n    if ((s->stop || s->start) && s->stop <= s->start) {\n        av_log(ctx, AV_LOG_ERROR, \"Stop frequency should be greater than start.\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    if (!strcmp(ctx->filter->name, \"showspectrumpic\"))\n        s->single_pic = 1;\n\n    outlink->w = s->w;\n    outlink->h = s->h;\n    outlink->sample_aspect_ratio = (AVRational){1,1};\n\n    if (s->legend) {\n        s->start_x = (log10(inlink->sample_rate) + 1) * 25;\n        s->start_y = 64;\n        outlink->w += s->start_x * 2;\n        outlink->h += s->start_y * 2;\n    }\n\n    h = (s->mode == COMBINED || s->orientation == HORIZONTAL) ? s->h : s->h / inlink->channels;\n    w = (s->mode == COMBINED || s->orientation == VERTICAL)   ? s->w : s->w / inlink->channels;\n    s->channel_height = h;\n    s->channel_width  = w;\n\n    if (s->orientation == VERTICAL) {\n        /* FFT window size (precision) according to the requested output frame height */\n        fft_size = h * 2;\n    } else {\n        /* FFT window size (precision) according to the requested output frame width */\n        fft_size = w * 2;\n    }\n\n    s->win_size = fft_size;\n    s->buf_size = FFALIGN(s->win_size << (!!s->stop), av_cpu_max_align());\n\n    if (!s->fft) {\n        s->fft = av_calloc(inlink->channels, sizeof(*s->fft));\n        if (!s->fft)\n            return AVERROR(ENOMEM);\n    }\n\n    if (s->stop) {\n        if (!s->ifft) {\n            s->ifft = av_calloc(inlink->channels, sizeof(*s->ifft));\n            if (!s->ifft)\n                return AVERROR(ENOMEM);\n        }\n    }\n\n    /* (re-)configuration if the video output changed (or first init) */\n    if (fft_size != s->fft_size) {\n        AVFrame *outpicref;\n\n        s->fft_size = fft_size;\n\n        /* FFT buffers: x2 for each (display) channel buffer.\n         * Note: we use free and malloc instead of a realloc-like function to\n         * make sure the buffer is aligned in memory for the FFT functions. */\n        for (i = 0; i < s->nb_display_channels; i++) {\n            if (s->stop) {\n                av_tx_uninit(&s->ifft[i]);\n                av_freep(&s->fft_scratch[i]);\n            }\n            av_tx_uninit(&s->fft[i]);\n            av_freep(&s->fft_in[i]);\n            av_freep(&s->fft_data[i]);\n        }\n        av_freep(&s->fft_data);\n\n        s->nb_display_channels = inlink->channels;\n        for (i = 0; i < s->nb_display_channels; i++) {\n            float scale;\n\n            ret = av_tx_init(&s->fft[i], &s->tx_fn, AV_TX_FLOAT_FFT, 0, fft_size << (!!s->stop), &scale, 0);\n            if (s->stop) {\n                ret = av_tx_init(&s->ifft[i], &s->itx_fn, AV_TX_FLOAT_FFT, 1, fft_size << (!!s->stop), &scale, 0);\n                if (ret < 0) {\n                    av_log(ctx, AV_LOG_ERROR, \"Unable to create Inverse FFT context. \"\n                           \"The window size might be too high.\\n\");\n                    return ret;\n                }\n            }\n            if (ret < 0) {\n                av_log(ctx, AV_LOG_ERROR, \"Unable to create FFT context. \"\n                       \"The window size might be too high.\\n\");\n                return ret;\n            }\n        }\n\n        s->magnitudes = av_calloc(s->nb_display_channels, sizeof(*s->magnitudes));\n        if (!s->magnitudes)\n            return AVERROR(ENOMEM);\n        for (i = 0; i < s->nb_display_channels; i++) {\n            s->magnitudes[i] = av_calloc(s->orientation == VERTICAL ? s->h : s->w, sizeof(**s->magnitudes));\n            if (!s->magnitudes[i])\n                return AVERROR(ENOMEM);\n        }\n\n        s->phases = av_calloc(s->nb_display_channels, sizeof(*s->phases));\n        if (!s->phases)\n            return AVERROR(ENOMEM);\n        for (i = 0; i < s->nb_display_channels; i++) {\n            s->phases[i] = av_calloc(s->orientation == VERTICAL ? s->h : s->w, sizeof(**s->phases));\n            if (!s->phases[i])\n                return AVERROR(ENOMEM);\n        }\n\n        av_freep(&s->color_buffer);\n        s->color_buffer = av_calloc(s->nb_display_channels, sizeof(*s->color_buffer));\n        if (!s->color_buffer)\n            return AVERROR(ENOMEM);\n        for (i = 0; i < s->nb_display_channels; i++) {\n            s->color_buffer[i] = av_calloc(s->orientation == VERTICAL ? s->h * 3 : s->w * 3, sizeof(**s->color_buffer));\n            if (!s->color_buffer[i])\n                return AVERROR(ENOMEM);\n        }\n\n        s->fft_in = av_calloc(s->nb_display_channels, sizeof(*s->fft_in));\n        if (!s->fft_in)\n            return AVERROR(ENOMEM);\n        s->fft_data = av_calloc(s->nb_display_channels, sizeof(*s->fft_data));\n        if (!s->fft_data)\n            return AVERROR(ENOMEM);\n        s->fft_scratch = av_calloc(s->nb_display_channels, sizeof(*s->fft_scratch));\n        if (!s->fft_scratch)\n            return AVERROR(ENOMEM);\n        for (i = 0; i < s->nb_display_channels; i++) {\n            s->fft_in[i] = av_calloc(s->buf_size, sizeof(**s->fft_in));\n            if (!s->fft_in[i])\n                return AVERROR(ENOMEM);\n\n            s->fft_data[i] = av_calloc(s->buf_size, sizeof(**s->fft_data));\n            if (!s->fft_data[i])\n                return AVERROR(ENOMEM);\n\n            s->fft_scratch[i] = av_calloc(s->buf_size, sizeof(**s->fft_scratch));\n            if (!s->fft_scratch[i])\n                return AVERROR(ENOMEM);\n        }\n\n        /* pre-calc windowing function */\n        s->window_func_lut =\n            av_realloc_f(s->window_func_lut, s->win_size,\n                         sizeof(*s->window_func_lut));\n        if (!s->window_func_lut)\n            return AVERROR(ENOMEM);\n        generate_window_func(s->window_func_lut, s->win_size, s->win_func, &overlap);\n        if (s->overlap == 1)\n            s->overlap = overlap;\n        s->hop_size = (1.f - s->overlap) * s->win_size;\n        if (s->hop_size < 1) {\n            av_log(ctx, AV_LOG_ERROR, \"overlap %f too big\\n\", s->overlap);\n            return AVERROR(EINVAL);\n        }\n\n        for (s->win_scale = 0, i = 0; i < s->win_size; i++) {\n            s->win_scale += s->window_func_lut[i] * s->window_func_lut[i];\n        }\n        s->win_scale = 1.f / sqrtf(s->win_scale);\n\n        /* prepare the initial picref buffer (black frame) */\n        av_frame_free(&s->outpicref);\n        s->outpicref = outpicref =\n            ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!outpicref)\n            return AVERROR(ENOMEM);\n        outpicref->sample_aspect_ratio = (AVRational){1,1};\n        for (i = 0; i < outlink->h; i++) {\n            memset(outpicref->data[0] + i * outpicref->linesize[0],   0, outlink->w);\n            memset(outpicref->data[1] + i * outpicref->linesize[1], 128, outlink->w);\n            memset(outpicref->data[2] + i * outpicref->linesize[2], 128, outlink->w);\n        }\n        outpicref->color_range = AVCOL_RANGE_JPEG;\n\n        if (!s->single_pic && s->legend)\n            draw_legend(ctx, 0);\n    }\n\n    if ((s->orientation == VERTICAL   && s->xpos >= s->w) ||\n        (s->orientation == HORIZONTAL && s->xpos >= s->h))\n        s->xpos = 0;\n\n    if (s->sliding == LREPLACE) {\n        if (s->orientation == VERTICAL)\n            s->xpos = s->w - 1;\n        if (s->orientation == HORIZONTAL)\n            s->xpos = s->h - 1;\n    }\n\n    s->auto_frame_rate = av_make_q(inlink->sample_rate, s->hop_size);\n    if (s->orientation == VERTICAL && s->sliding == FULLFRAME)\n        s->auto_frame_rate = av_mul_q(s->auto_frame_rate, av_make_q(1, s->w));\n    if (s->orientation == HORIZONTAL && s->sliding == FULLFRAME)\n        s->auto_frame_rate = av_mul_q(s->auto_frame_rate, av_make_q(1, s->h));\n    if (!s->single_pic && strcmp(s->rate_str, \"auto\")) {\n        int ret = av_parse_video_rate(&s->frame_rate, s->rate_str);\n        if (ret < 0)\n            return ret;\n    } else {\n        s->frame_rate = s->auto_frame_rate;\n    }\n    outlink->frame_rate = s->frame_rate;\n    outlink->time_base = av_inv_q(outlink->frame_rate);\n\n    if (s->orientation == VERTICAL) {\n        s->combine_buffer =\n            av_realloc_f(s->combine_buffer, s->h * 3,\n                         sizeof(*s->combine_buffer));\n    } else {\n        s->combine_buffer =\n            av_realloc_f(s->combine_buffer, s->w * 3,\n                         sizeof(*s->combine_buffer));\n    }\n\n    av_log(ctx, AV_LOG_VERBOSE, \"s:%dx%d FFT window size:%d\\n\",\n           s->w, s->h, s->win_size);\n\n    s->in_frame = ff_get_audio_buffer(inlink, s->win_size);\n    if (!s->in_frame)\n        return AVERROR(ENOMEM);\n\n    s->frames = av_fast_realloc(NULL, &s->frames_size,\n                                DEFAULT_LENGTH * sizeof(*(s->frames)));\n    if (!s->frames)\n        return AVERROR(ENOMEM);\n\n    return 0;\n}",
      "cve_list": [
        "CVE-2024-31585"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "FFmpeg",
      "filepath": "libavfilter/avf_showspectrum.c",
      "func_name": "draw_legend",
      "func_body": "static int draw_legend(AVFilterContext *ctx, uint64_t samples)\n{\n    ShowSpectrumContext *s = ctx->priv;\n    AVFilterLink *inlink = ctx->inputs[0];\n    AVFilterLink *outlink = ctx->outputs[0];\n    int ch, y, x = 0, sz = s->orientation == VERTICAL ? s->w : s->h;\n    int multi = (s->mode == SEPARATE && s->color_mode == CHANNEL);\n    float spp = samples / (float)sz;\n    char *text;\n    uint8_t *dst;\n    char chlayout_str[128];\n\n    av_get_channel_layout_string(chlayout_str, sizeof(chlayout_str), inlink->channels,\n                                 inlink->channel_layout);\n\n    text = av_asprintf(\"%d Hz | %s\", inlink->sample_rate, chlayout_str);\n    if (!text)\n        return AVERROR(ENOMEM);\n\n    drawtext(s->outpicref, 2, outlink->h - 10, \"CREATED BY LIBAVFILTER\", 0);\n    drawtext(s->outpicref, outlink->w - 2 - strlen(text) * 10, outlink->h - 10, text, 0);\n    av_freep(&text);\n    if (s->stop) {\n        text = av_asprintf(\"Zoom: %d Hz - %d Hz\", s->start, s->stop);\n        if (!text)\n            return AVERROR(ENOMEM);\n        drawtext(s->outpicref, outlink->w - 2 - strlen(text) * 10, 3, text, 0);\n        av_freep(&text);\n    }\n\n    dst = s->outpicref->data[0] + (s->start_y - 1) * s->outpicref->linesize[0] + s->start_x - 1;\n    for (x = 0; x < s->w + 1; x++)\n        dst[x] = 200;\n    dst = s->outpicref->data[0] + (s->start_y + s->h) * s->outpicref->linesize[0] + s->start_x - 1;\n    for (x = 0; x < s->w + 1; x++)\n        dst[x] = 200;\n    for (y = 0; y < s->h + 2; y++) {\n        dst = s->outpicref->data[0] + (y + s->start_y - 1) * s->outpicref->linesize[0];\n        dst[s->start_x - 1] = 200;\n        dst[s->start_x + s->w] = 200;\n    }\n    if (s->orientation == VERTICAL) {\n        int h = s->mode == SEPARATE ? s->h / s->nb_display_channels : s->h;\n        int hh = s->mode == SEPARATE ? -(s->h % s->nb_display_channels) + 1 : 1;\n        for (ch = 0; ch < (s->mode == SEPARATE ? s->nb_display_channels : 1); ch++) {\n            for (y = 0; y < h; y += 20) {\n                dst = s->outpicref->data[0] + (s->start_y + h * (ch + 1) - y - hh) * s->outpicref->linesize[0];\n                dst[s->start_x - 2] = 200;\n                dst[s->start_x + s->w + 1] = 200;\n            }\n            for (y = 0; y < h; y += 40) {\n                dst = s->outpicref->data[0] + (s->start_y + h * (ch + 1) - y - hh) * s->outpicref->linesize[0];\n                dst[s->start_x - 3] = 200;\n                dst[s->start_x + s->w + 2] = 200;\n            }\n            dst = s->outpicref->data[0] + (s->start_y - 2) * s->outpicref->linesize[0] + s->start_x;\n            for (x = 0; x < s->w; x+=40)\n                dst[x] = 200;\n            dst = s->outpicref->data[0] + (s->start_y - 3) * s->outpicref->linesize[0] + s->start_x;\n            for (x = 0; x < s->w; x+=80)\n                dst[x] = 200;\n            dst = s->outpicref->data[0] + (s->h + s->start_y + 1) * s->outpicref->linesize[0] + s->start_x;\n            for (x = 0; x < s->w; x+=40) {\n                dst[x] = 200;\n            }\n            dst = s->outpicref->data[0] + (s->h + s->start_y + 2) * s->outpicref->linesize[0] + s->start_x;\n            for (x = 0; x < s->w; x+=80) {\n                dst[x] = 200;\n            }\n            for (y = 0; y < h; y += 40) {\n                float range = s->stop ? s->stop - s->start : inlink->sample_rate / 2;\n                float hertz = get_hz(y, h, s->start, s->start + range, s->fscale);\n                char *units;\n\n                if (hertz == 0)\n                    units = av_asprintf(\"DC\");\n                else\n                    units = av_asprintf(\"%.2f\", hertz);\n                if (!units)\n                    return AVERROR(ENOMEM);\n\n                drawtext(s->outpicref, s->start_x - 8 * strlen(units) - 4, h * (ch + 1) + s->start_y - y - 4 - hh, units, 0);\n                av_free(units);\n            }\n        }\n\n        for (x = 0; x < s->w && s->single_pic; x+=80) {\n            float seconds = x * spp / inlink->sample_rate;\n            char *units = get_time(ctx, seconds, x);\n            if (!units)\n                return AVERROR(ENOMEM);\n\n            drawtext(s->outpicref, s->start_x + x - 4 * strlen(units), s->h + s->start_y + 6, units, 0);\n            drawtext(s->outpicref, s->start_x + x - 4 * strlen(units), s->start_y - 12, units, 0);\n            av_free(units);\n        }\n\n        drawtext(s->outpicref, outlink->w / 2 - 4 * 4, outlink->h - s->start_y / 2, \"TIME\", 0);\n        drawtext(s->outpicref, s->start_x / 7, outlink->h / 2 - 14 * 4, \"FREQUENCY (Hz)\", 1);\n    } else {\n        int w = s->mode == SEPARATE ? s->w / s->nb_display_channels : s->w;\n        for (y = 0; y < s->h; y += 20) {\n            dst = s->outpicref->data[0] + (s->start_y + y) * s->outpicref->linesize[0];\n            dst[s->start_x - 2] = 200;\n            dst[s->start_x + s->w + 1] = 200;\n        }\n        for (y = 0; y < s->h; y += 40) {\n            dst = s->outpicref->data[0] + (s->start_y + y) * s->outpicref->linesize[0];\n            dst[s->start_x - 3] = 200;\n            dst[s->start_x + s->w + 2] = 200;\n        }\n        for (ch = 0; ch < (s->mode == SEPARATE ? s->nb_display_channels : 1); ch++) {\n            dst = s->outpicref->data[0] + (s->start_y - 2) * s->outpicref->linesize[0] + s->start_x + w * ch;\n            for (x = 0; x < w; x+=40)\n                dst[x] = 200;\n            dst = s->outpicref->data[0] + (s->start_y - 3) * s->outpicref->linesize[0] + s->start_x + w * ch;\n            for (x = 0; x < w; x+=80)\n                dst[x] = 200;\n            dst = s->outpicref->data[0] + (s->h + s->start_y + 1) * s->outpicref->linesize[0] + s->start_x + w * ch;\n            for (x = 0; x < w; x+=40) {\n                dst[x] = 200;\n            }\n            dst = s->outpicref->data[0] + (s->h + s->start_y + 2) * s->outpicref->linesize[0] + s->start_x + w * ch;\n            for (x = 0; x < w; x+=80) {\n                dst[x] = 200;\n            }\n            for (x = 0; x < w - 79; x += 80) {\n                float range = s->stop ? s->stop - s->start : inlink->sample_rate / 2;\n                float hertz = get_hz(x, w, s->start, s->start + range, s->fscale);\n                char *units;\n\n                if (hertz == 0)\n                    units = av_asprintf(\"DC\");\n                else\n                    units = av_asprintf(\"%.2f\", hertz);\n                if (!units)\n                    return AVERROR(ENOMEM);\n\n                drawtext(s->outpicref, s->start_x - 4 * strlen(units) + x + w * ch, s->start_y - 12, units, 0);\n                drawtext(s->outpicref, s->start_x - 4 * strlen(units) + x + w * ch, s->h + s->start_y + 6, units, 0);\n                av_free(units);\n            }\n        }\n        for (y = 0; y < s->h && s->single_pic; y+=40) {\n            float seconds = y * spp / inlink->sample_rate;\n            char *units = get_time(ctx, seconds, x);\n            if (!units)\n                return AVERROR(ENOMEM);\n\n            drawtext(s->outpicref, s->start_x - 8 * strlen(units) - 4, s->start_y + y - 4, units, 0);\n            av_free(units);\n        }\n        drawtext(s->outpicref, s->start_x / 7, outlink->h / 2 - 4 * 4, \"TIME\", 1);\n        drawtext(s->outpicref, outlink->w / 2 - 14 * 4, outlink->h - s->start_y / 2, \"FREQUENCY (Hz)\", 0);\n    }\n\n    for (ch = 0; ch < (multi ? s->nb_display_channels : 1); ch++) {\n        int h = multi ? s->h / s->nb_display_channels : s->h;\n\n        for (y = 0; y < h; y++) {\n            float out[3] = { 0., 127.5, 127.5};\n            int chn;\n\n            for (chn = 0; chn < (s->mode == SEPARATE ? 1 : s->nb_display_channels); chn++) {\n                float yf, uf, vf;\n                int channel = (multi) ? s->nb_display_channels - ch - 1 : chn;\n                float lout[3];\n\n                color_range(s, channel, &yf, &uf, &vf);\n                pick_color(s, yf, uf, vf, y / (float)h, lout);\n                out[0] += lout[0];\n                out[1] += lout[1];\n                out[2] += lout[2];\n            }\n            memset(s->outpicref->data[0]+(s->start_y + h * (ch + 1) - y - 1) * s->outpicref->linesize[0] + s->w + s->start_x + 20, av_clip_uint8(out[0]), 10);\n            memset(s->outpicref->data[1]+(s->start_y + h * (ch + 1) - y - 1) * s->outpicref->linesize[1] + s->w + s->start_x + 20, av_clip_uint8(out[1]), 10);\n            memset(s->outpicref->data[2]+(s->start_y + h * (ch + 1) - y - 1) * s->outpicref->linesize[2] + s->w + s->start_x + 20, av_clip_uint8(out[2]), 10);\n        }\n\n        for (y = 0; ch == 0 && y < h + 5; y += 25) {\n            static const char *log_fmt = \"%.0f\";\n            static const char *lin_fmt = \"%.3f\";\n            const float a = av_clipf(1.f - y / (float)(h - 1), 0.f, 1.f);\n            const float value = s->scale == LOG ? log10f(get_iscale(ctx, s->scale, a)) * 20.f : get_iscale(ctx, s->scale, a);\n            char *text;\n\n            text = av_asprintf(s->scale == LOG ? log_fmt : lin_fmt, value);\n            if (!text)\n                continue;\n            drawtext(s->outpicref, s->w + s->start_x + 35, s->start_y + y - 3, text, 0);\n            av_free(text);\n        }\n    }\n\n    if (s->scale == LOG)\n        drawtext(s->outpicref, s->w + s->start_x + 22, s->start_y + s->h + 20, \"dBFS\", 0);\n\n    return 0;\n}",
      "cve_list": [
        "CVE-2024-31585"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "FFmpeg",
      "filepath": "libavfilter/avf_showspectrum.c",
      "func_name": "plot_spectrum_column",
      "func_body": "static int plot_spectrum_column(AVFilterLink *inlink, AVFrame *insamples)\n{\n    AVFilterContext *ctx = inlink->dst;\n    AVFilterLink *outlink = ctx->outputs[0];\n    ShowSpectrumContext *s = ctx->priv;\n    AVFrame *outpicref = s->outpicref;\n    int ret, plane, x, y, z = s->orientation == VERTICAL ? s->h : s->w;\n\n    /* fill a new spectrum column */\n    /* initialize buffer for combining to black */\n    clear_combine_buffer(s, z);\n\n    ff_filter_execute(ctx, s->plot_channel, NULL, NULL, s->nb_display_channels);\n\n    for (y = 0; y < z * 3; y++) {\n        for (x = 0; x < s->nb_display_channels; x++) {\n            s->combine_buffer[y] += s->color_buffer[x][y];\n        }\n    }\n\n    av_frame_make_writable(s->outpicref);\n    /* copy to output */\n    if (s->orientation == VERTICAL) {\n        if (s->sliding == SCROLL) {\n            for (plane = 0; plane < 3; plane++) {\n                for (y = 0; y < s->h; y++) {\n                    uint8_t *p = outpicref->data[plane] + s->start_x +\n                                 (y + s->start_y) * outpicref->linesize[plane];\n                    memmove(p, p + 1, s->w - 1);\n                }\n            }\n            s->xpos = s->w - 1;\n        } else if (s->sliding == RSCROLL) {\n            for (plane = 0; plane < 3; plane++) {\n                for (y = 0; y < s->h; y++) {\n                    uint8_t *p = outpicref->data[plane] + s->start_x +\n                                 (y + s->start_y) * outpicref->linesize[plane];\n                    memmove(p + 1, p, s->w - 1);\n                }\n            }\n            s->xpos = 0;\n        }\n        for (plane = 0; plane < 3; plane++) {\n            uint8_t *p = outpicref->data[plane] + s->start_x +\n                         (outlink->h - 1 - s->start_y) * outpicref->linesize[plane] +\n                         s->xpos;\n            for (y = 0; y < s->h; y++) {\n                *p = lrintf(av_clipf(s->combine_buffer[3 * y + plane], 0, 255));\n                p -= outpicref->linesize[plane];\n            }\n        }\n    } else {\n        if (s->sliding == SCROLL) {\n            for (plane = 0; plane < 3; plane++) {\n                for (y = 1; y < s->h; y++) {\n                    memmove(outpicref->data[plane] + (y-1 + s->start_y) * outpicref->linesize[plane] + s->start_x,\n                            outpicref->data[plane] + (y   + s->start_y) * outpicref->linesize[plane] + s->start_x,\n                            s->w);\n                }\n            }\n            s->xpos = s->h - 1;\n        } else if (s->sliding == RSCROLL) {\n            for (plane = 0; plane < 3; plane++) {\n                for (y = s->h - 1; y >= 1; y--) {\n                    memmove(outpicref->data[plane] + (y   + s->start_y) * outpicref->linesize[plane] + s->start_x,\n                            outpicref->data[plane] + (y-1 + s->start_y) * outpicref->linesize[plane] + s->start_x,\n                            s->w);\n                }\n            }\n            s->xpos = 0;\n        }\n        for (plane = 0; plane < 3; plane++) {\n            uint8_t *p = outpicref->data[plane] + s->start_x +\n                         (s->xpos + s->start_y) * outpicref->linesize[plane];\n            for (x = 0; x < s->w; x++) {\n                *p = lrintf(av_clipf(s->combine_buffer[3 * x + plane], 0, 255));\n                p++;\n            }\n        }\n    }\n\n    if (s->sliding != FULLFRAME || s->xpos == 0)\n        s->pts = outpicref->pts = av_rescale_q(insamples->pts, inlink->time_base, outlink->time_base);\n\n    if (s->sliding == LREPLACE) {\n        s->xpos--;\n        if (s->orientation == VERTICAL && s->xpos < 0)\n            s->xpos = s->w - 1;\n        if (s->orientation == HORIZONTAL && s->xpos < 0)\n            s->xpos = s->h - 1;\n    } else {\n        s->xpos++;\n        if (s->orientation == VERTICAL && s->xpos >= s->w)\n            s->xpos = 0;\n        if (s->orientation == HORIZONTAL && s->xpos >= s->h)\n            s->xpos = 0;\n    }\n\n    if (!s->single_pic && (s->sliding != FULLFRAME || s->xpos == 0)) {\n        if (s->old_pts < outpicref->pts) {\n            AVFrame *clone;\n\n            if (s->legend) {\n                char *units = get_time(ctx, insamples->pts /(float)inlink->sample_rate, x);\n                if (!units)\n                    return AVERROR(ENOMEM);\n\n                if (s->orientation == VERTICAL) {\n                    for (y = 0; y < 10; y++) {\n                        memset(s->outpicref->data[0] + outlink->w / 2 - 4 * s->old_len +\n                               (outlink->h - s->start_y / 2 - 20 + y) * s->outpicref->linesize[0], 0, 10 * s->old_len);\n                    }\n                    drawtext(s->outpicref,\n                             outlink->w / 2 - 4 * strlen(units),\n                             outlink->h - s->start_y / 2 - 20,\n                             units, 0);\n                } else  {\n                    for (y = 0; y < 10 * s->old_len; y++) {\n                        memset(s->outpicref->data[0] + s->start_x / 7 + 20 +\n                               (outlink->h / 2 - 4 * s->old_len + y) * s->outpicref->linesize[0], 0, 10);\n                    }\n                    drawtext(s->outpicref,\n                             s->start_x / 7 + 20,\n                             outlink->h / 2 - 4 * strlen(units),\n                             units, 1);\n                }\n                s->old_len = strlen(units);\n                av_free(units);\n            }\n            s->old_pts = outpicref->pts;\n            clone = av_frame_clone(s->outpicref);\n            if (!clone)\n                return AVERROR(ENOMEM);\n            ret = ff_filter_frame(outlink, clone);\n            if (ret < 0)\n                return ret;\n            return 0;\n        }\n    }\n\n    return 1;\n}",
      "cve_list": [
        "CVE-2024-31585"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "FFmpeg",
      "filepath": "libavfilter/avf_showspectrum.c",
      "func_name": "run_channel_fft",
      "func_body": "static int run_channel_fft(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs)\n{\n    ShowSpectrumContext *s = ctx->priv;\n    AVFilterLink *inlink = ctx->inputs[0];\n    const float *window_func_lut = s->window_func_lut;\n    AVFrame *fin = arg;\n    const int ch = jobnr;\n    int n;\n\n    /* fill FFT input with the number of samples available */\n    const float *p = (float *)fin->extended_data[ch];\n    float *in_frame = (float *)s->in_frame->extended_data[ch];\n\n    memmove(in_frame, in_frame + s->hop_size, (s->fft_size - s->hop_size) * sizeof(float));\n    memcpy(in_frame + s->fft_size - s->hop_size, p, fin->nb_samples * sizeof(float));\n\n    for (int i = fin->nb_samples; i < s->hop_size; i++)\n        in_frame[i + s->fft_size - s->hop_size] = 0.f;\n\n    if (s->stop) {\n        float theta, phi, psi, a, b, S, c;\n        AVComplexFloat *f = s->fft_in[ch];\n        AVComplexFloat *g = s->fft_data[ch];\n        AVComplexFloat *h = s->fft_scratch[ch];\n        int L = s->buf_size;\n        int N = s->win_size;\n        int M = s->win_size / 2;\n\n        for (n = 0; n < s->win_size; n++) {\n            s->fft_data[ch][n].re = in_frame[n] * window_func_lut[n];\n            s->fft_data[ch][n].im = 0;\n        }\n\n        phi = 2.f * M_PI * (s->stop - s->start) / (float)inlink->sample_rate / (M - 1);\n        theta = 2.f * M_PI * s->start / (float)inlink->sample_rate;\n\n        for (int n = 0; n < M; n++) {\n            h[n].re = cosf(n * n / 2.f * phi);\n            h[n].im = sinf(n * n / 2.f * phi);\n        }\n\n        for (int n = M; n < L; n++) {\n            h[n].re = 0.f;\n            h[n].im = 0.f;\n        }\n\n        for (int n = L - N; n < L; n++) {\n            h[n].re = cosf((L - n) * (L - n) / 2.f * phi);\n            h[n].im = sinf((L - n) * (L - n) / 2.f * phi);\n        }\n\n        for (int n = N; n < L; n++) {\n            g[n].re = 0.f;\n            g[n].im = 0.f;\n        }\n\n        for (int n = 0; n < N; n++) {\n            psi = n * theta + n * n / 2.f * phi;\n            c =  cosf(psi);\n            S = -sinf(psi);\n            a = c * g[n].re - S * g[n].im;\n            b = S * g[n].re + c * g[n].im;\n            g[n].re = a;\n            g[n].im = b;\n        }\n\n        memcpy(f, h, s->buf_size * sizeof(*f));\n        s->tx_fn(s->fft[ch], h, f, sizeof(float));\n\n        memcpy(f, g, s->buf_size * sizeof(*f));\n        s->tx_fn(s->fft[ch], g, f, sizeof(float));\n\n        for (int n = 0; n < L; n++) {\n            c = g[n].re;\n            S = g[n].im;\n            a = c * h[n].re - S * h[n].im;\n            b = S * h[n].re + c * h[n].im;\n\n            g[n].re = a / L;\n            g[n].im = b / L;\n        }\n\n        memcpy(f, g, s->buf_size * sizeof(*f));\n        s->itx_fn(s->ifft[ch], g, f, sizeof(float));\n\n        for (int k = 0; k < M; k++) {\n            psi = k * k / 2.f * phi;\n            c =  cosf(psi);\n            S = -sinf(psi);\n            a = c * g[k].re - S * g[k].im;\n            b = S * g[k].re + c * g[k].im;\n            s->fft_data[ch][k].re = a;\n            s->fft_data[ch][k].im = b;\n        }\n    } else {\n        for (n = 0; n < s->win_size; n++) {\n            s->fft_in[ch][n].re = in_frame[n] * window_func_lut[n];\n            s->fft_in[ch][n].im = 0;\n        }\n\n        /* run FFT on each samples set */\n        s->tx_fn(s->fft[ch], s->fft_data[ch], s->fft_in[ch], sizeof(float));\n    }\n\n    return 0;\n}",
      "cve_list": [
        "CVE-2024-31585"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "FFmpeg",
      "filepath": "libavfilter/avf_showspectrum.c",
      "func_name": "showspectrumpic_filter_frame",
      "func_body": "static int showspectrumpic_filter_frame(AVFilterLink *inlink, AVFrame *insamples)\n{\n    AVFilterContext *ctx = inlink->dst;\n    ShowSpectrumContext *s = ctx->priv;\n    void *ptr;\n\n    if (s->nb_frames + 1ULL > s->frames_size / sizeof(*(s->frames))) {\n        ptr = av_fast_realloc(s->frames, &s->frames_size, s->frames_size * 2);\n        if (!ptr)\n            return AVERROR(ENOMEM);\n        s->frames = ptr;\n    }\n\n    s->frames[s->nb_frames] = insamples;\n    s->samples += insamples->nb_samples;\n    s->nb_frames++;\n\n    return 0;\n}",
      "cve_list": [
        "CVE-2024-31585"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "FFmpeg",
      "filepath": "libavfilter/avf_showspectrum.c",
      "func_name": "showspectrumpic_request_frame",
      "func_body": "static int showspectrumpic_request_frame(AVFilterLink *outlink)\n{\n    AVFilterContext *ctx = outlink->src;\n    ShowSpectrumContext *s = ctx->priv;\n    AVFilterLink *inlink = ctx->inputs[0];\n    int ret;\n\n    ret = ff_request_frame(inlink);\n    if (ret == AVERROR_EOF && s->outpicref && s->samples > 0) {\n        int consumed = 0;\n        int x = 0, sz = s->orientation == VERTICAL ? s->w : s->h;\n        unsigned int nb_frame = 0;\n        int ch, spf, spb;\n        int src_offset = 0;\n        AVFrame *fin;\n\n        spf = s->win_size * (s->samples / ((s->win_size * sz) * ceil(s->samples / (float)(s->win_size * sz))));\n        spf = FFMAX(1, spf);\n\n        spb = (s->samples / (spf * sz)) * spf;\n\n        fin = ff_get_audio_buffer(inlink, spf);\n        if (!fin)\n            return AVERROR(ENOMEM);\n\n        while (x < sz) {\n            int acc_samples = 0;\n            int dst_offset = 0;\n\n            while (nb_frame <= s->nb_frames) {\n                AVFrame *cur_frame = s->frames[nb_frame];\n                int cur_frame_samples = cur_frame->nb_samples;\n                int nb_samples = 0;\n\n                if (acc_samples < spf) {\n                    nb_samples = FFMIN(spf - acc_samples, cur_frame_samples - src_offset);\n                    acc_samples += nb_samples;\n                    av_samples_copy(fin->extended_data, cur_frame->extended_data,\n                                    dst_offset, src_offset, nb_samples,\n                                    cur_frame->channels, AV_SAMPLE_FMT_FLTP);\n                }\n\n                src_offset += nb_samples;\n                dst_offset += nb_samples;\n                if (cur_frame_samples <= src_offset) {\n                    av_frame_free(&s->frames[nb_frame]);\n                    nb_frame++;\n                    src_offset = 0;\n                }\n\n                if (acc_samples == spf)\n                    break;\n            }\n\n            ff_filter_execute(ctx, run_channel_fft, fin, NULL, s->nb_display_channels);\n            acalc_magnitudes(s);\n\n            consumed += spf;\n            if (consumed >= spb) {\n                int h = s->orientation == VERTICAL ? s->h : s->w;\n\n                scale_magnitudes(s, 1.f / (consumed / spf));\n                plot_spectrum_column(inlink, fin);\n                consumed = 0;\n                x++;\n                for (ch = 0; ch < s->nb_display_channels; ch++)\n                    memset(s->magnitudes[ch], 0, h * sizeof(float));\n            }\n        }\n\n        av_frame_free(&fin);\n        s->outpicref->pts = 0;\n\n        if (s->legend)\n            draw_legend(ctx, s->samples);\n\n        ret = ff_filter_frame(outlink, s->outpicref);\n        s->outpicref = NULL;\n    }\n\n    return ret;\n}",
      "cve_list": [
        "CVE-2024-31585"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "FFmpeg",
      "filepath": "libavfilter/avf_showspectrum.c",
      "func_name": "uninit",
      "func_body": "static av_cold void uninit(AVFilterContext *ctx)\n{\n    ShowSpectrumContext *s = ctx->priv;\n    int i;\n\n    av_freep(&s->combine_buffer);\n    if (s->fft) {\n        for (i = 0; i < s->nb_display_channels; i++)\n            av_tx_uninit(&s->fft[i]);\n    }\n    av_freep(&s->fft);\n    if (s->ifft) {\n        for (i = 0; i < s->nb_display_channels; i++)\n            av_tx_uninit(&s->ifft[i]);\n    }\n    av_freep(&s->ifft);\n    if (s->fft_data) {\n        for (i = 0; i < s->nb_display_channels; i++)\n            av_freep(&s->fft_data[i]);\n    }\n    av_freep(&s->fft_data);\n    if (s->fft_in) {\n        for (i = 0; i < s->nb_display_channels; i++)\n            av_freep(&s->fft_in[i]);\n    }\n    av_freep(&s->fft_in);\n    if (s->fft_scratch) {\n        for (i = 0; i < s->nb_display_channels; i++)\n            av_freep(&s->fft_scratch[i]);\n    }\n    av_freep(&s->fft_scratch);\n    if (s->color_buffer) {\n        for (i = 0; i < s->nb_display_channels; i++)\n            av_freep(&s->color_buffer[i]);\n    }\n    av_freep(&s->color_buffer);\n    av_freep(&s->window_func_lut);\n    if (s->magnitudes) {\n        for (i = 0; i < s->nb_display_channels; i++)\n            av_freep(&s->magnitudes[i]);\n    }\n    av_freep(&s->magnitudes);\n    av_frame_free(&s->outpicref);\n    av_frame_free(&s->in_frame);\n    if (s->phases) {\n        for (i = 0; i < s->nb_display_channels; i++)\n            av_freep(&s->phases[i]);\n    }\n    av_freep(&s->phases);\n\n    while (s->nb_frames > 0) {\n        av_frame_free(&s->frames[s->nb_frames - 1]);\n        s->nb_frames--;\n    }\n\n    av_freep(&s->frames);\n}",
      "cve_list": [
        "CVE-2024-31585"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "FFmpeg",
      "filepath": "libavformat/jpegxl_anim_dec.c",
      "func_name": "jpegxl_anim_read_packet",
      "func_body": "static int jpegxl_anim_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    JXLAnimDemuxContext *ctx = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int ret;\n    int64_t size;\n    size_t offset = 0;\n\n    size = avio_size(pb);\n    if (size < 0)\n        return size;\n    if (size > INT_MAX)\n        return AVERROR(EDOM);\n    if (size == 0)\n        size = 4096;\n\n    if (ctx->initial && size < ctx->initial->size)\n        size = ctx->initial->size;\n\n    ret = av_new_packet(pkt, size);\n    if (ret < 0)\n        return ret;\n\n    if (ctx->initial) {\n        offset = ctx->initial->size;\n        memcpy(pkt->data, ctx->initial->data, offset);\n        av_buffer_unref(&ctx->initial);\n    }\n\n    ret = avio_read(pb, pkt->data + offset, size - offset);\n    if (ret < 0)\n        return ret;\n    if (ret < size - offset)\n        pkt->size = ret + offset;\n\n    return 0;\n}",
      "cve_list": [
        "CVE-2024-22860"
      ],
      "cwe_list": [
        "CWE-190"
      ]
    },
    {
      "project": "FFmpeg",
      "filepath": "libavcodec/jpegxl_parser.c",
      "func_name": "skip_boxes",
      "func_body": "static int skip_boxes(JXLParseContext *ctx, const uint8_t *buf, int buf_size)\n{\n    GetByteContext gb;\n\n    if (ctx->skip > buf_size)\n        return AVERROR_BUFFER_TOO_SMALL;\n\n    buf += ctx->skip;\n    buf_size -= ctx->skip;\n    bytestream2_init(&gb, buf, buf_size);\n\n    while (1) {\n        uint64_t size;\n        int head_size = 4;\n\n        if (bytestream2_peek_le16(&gb) == FF_JPEGXL_CODESTREAM_SIGNATURE_LE)\n            break;\n        if (bytestream2_peek_le64(&gb) == FF_JPEGXL_CONTAINER_SIGNATURE_LE)\n            break;\n\n        if (bytestream2_get_bytes_left(&gb) < 8)\n            return AVERROR_BUFFER_TOO_SMALL;\n\n        size = bytestream2_get_be32(&gb);\n        if (size == 1) {\n            if (bytestream2_get_bytes_left(&gb) < 12)\n                return AVERROR_BUFFER_TOO_SMALL;\n            size = bytestream2_get_be64(&gb);\n            head_size = 12;\n        }\n        if (!size)\n            return AVERROR_INVALIDDATA;\n        /* invalid ISOBMFF size */\n        if (size <= head_size + 4 || size > INT_MAX - ctx->skip)\n            return AVERROR_INVALIDDATA;\n\n        ctx->skip += size;\n        bytestream2_skip(&gb, size - head_size);\n        if (bytestream2_get_bytes_left(&gb) <= 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n    }\n\n    return 0;\n}",
      "cve_list": [
        "CVE-2024-22862"
      ],
      "cwe_list": [
        "CWE-190"
      ]
    },
    {
      "project": "libarchive",
      "filepath": "libarchive/archive_read_support_format_rar.c",
      "func_name": "execute_filter_e8",
      "func_body": "execute_filter_e8(struct rar_filter *filter, struct rar_virtual_machine *vm, size_t pos, int e9also)\n{\n  uint32_t length = filter->initialregisters[4];\n  uint32_t filesize = 0x1000000;\n  uint32_t i;\n\n  if (length > PROGRAM_WORK_SIZE || length <= 4)\n    return 0;\n\n  for (i = 0; i <= length - 5; i++)\n  {\n    if (vm->memory[i] == 0xE8 || (e9also && vm->memory[i] == 0xE9))\n    {\n      uint32_t currpos = (uint32_t)pos + i + 1;\n      int32_t address = (int32_t)vm_read_32(vm, i + 1);\n      if (address < 0 && currpos >= (uint32_t)-address)\n        vm_write_32(vm, i + 1, address + filesize);\n      else if (address >= 0 && (uint32_t)address < filesize)\n        vm_write_32(vm, i + 1, address - currpos);\n      i += 4;\n    }\n  }\n\n  filter->filteredblockaddress = 0;\n  filter->filteredblocklength = length;\n\n  return 1;\n}",
      "cve_list": [
        "CVE-2024-26256"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "libarchive",
      "filepath": "libarchive/archive_read_support_format_zip.c",
      "func_name": "slurp_central_directory",
      "func_body": "slurp_central_directory(struct archive_read *a, struct archive_entry* entry,\n    struct zip *zip)\n{\n\tssize_t i;\n\tunsigned found;\n\tint64_t correction;\n\tssize_t bytes_avail;\n\tconst char *p;\n\n\t/*\n\t * Find the start of the central directory.  The end-of-CD\n\t * record has our starting point, but there are lots of\n\t * Zip archives which have had other data prepended to the\n\t * file, which makes the recorded offsets all too small.\n\t * So we search forward from the specified offset until we\n\t * find the real start of the central directory.  Then we\n\t * know the correction we need to apply to account for leading\n\t * padding.\n\t */\n\tif (__archive_read_seek(a, zip->central_directory_offset_adjusted, SEEK_SET)\n\t\t< 0)\n\t\treturn ARCHIVE_FATAL;\n\n\tfound = 0;\n\twhile (!found) {\n\t\tif ((p = __archive_read_ahead(a, 20, &bytes_avail)) == NULL)\n\t\t\treturn ARCHIVE_FATAL;\n\t\tfor (found = 0, i = 0; !found && i < bytes_avail - 4;) {\n\t\t\tswitch (p[i + 3]) {\n\t\t\tcase 'P': i += 3; break;\n\t\t\tcase 'K': i += 2; break;\n\t\t\tcase 001: i += 1; break;\n\t\t\tcase 002:\n\t\t\t\tif (memcmp(p + i, \"PK\\001\\002\", 4) == 0) {\n\t\t\t\t\tp += i;\n\t\t\t\t\tfound = 1;\n\t\t\t\t} else\n\t\t\t\t\ti += 4;\n\t\t\t\tbreak;\n\t\t\tcase 005: i += 1; break;\n\t\t\tcase 006:\n\t\t\t\tif (memcmp(p + i, \"PK\\005\\006\", 4) == 0) {\n\t\t\t\t\tp += i;\n\t\t\t\t\tfound = 1;\n\t\t\t\t} else if (memcmp(p + i, \"PK\\006\\006\", 4) == 0) {\n\t\t\t\t\tp += i;\n\t\t\t\t\tfound = 1;\n\t\t\t\t} else\n\t\t\t\t\ti += 1;\n\t\t\t\tbreak;\n\t\t\tdefault: i += 4; break;\n\t\t\t}\n\t\t}\n\t\t__archive_read_consume(a, i);\n\t}\n\tcorrection = archive_filter_bytes(&a->archive, 0)\n\t\t\t- zip->central_directory_offset;\n\n\t__archive_rb_tree_init(&zip->tree, &rb_ops);\n\t__archive_rb_tree_init(&zip->tree_rsrc, &rb_rsrc_ops);\n\n\tzip->central_directory_entries_total = 0;\n\twhile (1) {\n\t\tstruct zip_entry *zip_entry;\n\t\tsize_t filename_length, extra_length, comment_length;\n\t\tuint32_t external_attributes;\n\t\tconst char *name, *r;\n\n\t\tif ((p = __archive_read_ahead(a, 4, NULL)) == NULL)\n\t\t\treturn ARCHIVE_FATAL;\n\t\tif (memcmp(p, \"PK\\006\\006\", 4) == 0\n\t\t    || memcmp(p, \"PK\\005\\006\", 4) == 0) {\n\t\t\tbreak;\n\t\t} else if (memcmp(p, \"PK\\001\\002\", 4) != 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    -1, \"Invalid central directory signature\");\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\t\tif ((p = __archive_read_ahead(a, 46, NULL)) == NULL)\n\t\t\treturn ARCHIVE_FATAL;\n\n\t\tzip_entry = calloc(1, sizeof(struct zip_entry));\n\t\tif (zip_entry == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t\"Can't allocate zip entry\");\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\t\tzip_entry->next = zip->zip_entries;\n\t\tzip_entry->flags |= LA_FROM_CENTRAL_DIRECTORY;\n\t\tzip->zip_entries = zip_entry;\n\t\tzip->central_directory_entries_total++;\n\n\t\t/* version = p[4]; */\n\t\tzip_entry->system = p[5];\n\t\t/* version_required = archive_le16dec(p + 6); */\n\t\tzip_entry->zip_flags = archive_le16dec(p + 8);\n\t\tif (zip_entry->zip_flags\n\t\t      & (ZIP_ENCRYPTED | ZIP_STRONG_ENCRYPTED)){\n\t\t\tzip->has_encrypted_entries = 1;\n\t\t}\n\t\tzip_entry->compression = (char)archive_le16dec(p + 10);\n\t\tzip_entry->mtime = zip_time(p + 12);\n\t\tzip_entry->crc32 = archive_le32dec(p + 16);\n\t\tif (zip_entry->zip_flags & ZIP_LENGTH_AT_END)\n\t\t\tzip_entry->decdat = p[13];\n\t\telse\n\t\t\tzip_entry->decdat = p[19];\n\t\tzip_entry->compressed_size = archive_le32dec(p + 20);\n\t\tzip_entry->uncompressed_size = archive_le32dec(p + 24);\n\t\tfilename_length = archive_le16dec(p + 28);\n\t\textra_length = archive_le16dec(p + 30);\n\t\tcomment_length = archive_le16dec(p + 32);\n\t\t/* disk_start = archive_le16dec(p + 34);\n\t\t *   Better be zero.\n\t\t * internal_attributes = archive_le16dec(p + 36);\n\t\t *   text bit */\n\t\texternal_attributes = archive_le32dec(p + 38);\n\t\tzip_entry->local_header_offset =\n\t\t    archive_le32dec(p + 42) + correction;\n\n\t\t/* If we can't guess the mode, leave it zero here;\n\t\t   when we read the local file header we might get\n\t\t   more information. */\n\t\tif (zip_entry->system == 3) {\n\t\t\tzip_entry->mode = external_attributes >> 16;\n\t\t} else if (zip_entry->system == 0) {\n\t\t\t// Interpret MSDOS directory bit\n\t\t\tif (0x10 == (external_attributes & 0x10)) {\n\t\t\t\tzip_entry->mode = AE_IFDIR | 0775;\n\t\t\t} else {\n\t\t\t\tzip_entry->mode = AE_IFREG | 0664;\n\t\t\t}\n\t\t\tif (0x01 == (external_attributes & 0x01)) {\n\t\t\t\t// Read-only bit; strip write permissions\n\t\t\t\tzip_entry->mode &= 0555;\n\t\t\t}\n\t\t} else {\n\t\t\tzip_entry->mode = 0;\n\t\t}\n\n\t\t/* We're done with the regular data; get the filename and\n\t\t * extra data. */\n\t\t__archive_read_consume(a, 46);\n\t\tp = __archive_read_ahead(a, filename_length + extra_length,\n\t\t\tNULL);\n\t\tif (p == NULL) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated ZIP file header\");\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\t\tif (ARCHIVE_OK != process_extra(a, entry, p + filename_length,\n\t\t    extra_length, zip_entry)) {\n\t\t\treturn ARCHIVE_FATAL;\n\t\t}\n\n\t\t/*\n\t\t * Mac resource fork files are stored under the\n\t\t * \"__MACOSX/\" directory, so we should check if\n\t\t * it is.\n\t\t */\n\t\tif (!zip->process_mac_extensions) {\n\t\t\t/* Treat every entry as a regular entry. */\n\t\t\t__archive_rb_tree_insert_node(&zip->tree,\n\t\t\t    &zip_entry->node);\n\t\t} else {\n\t\t\tname = p;\n\t\t\tr = rsrc_basename(name, filename_length);\n\t\t\tif (filename_length >= 9 &&\n\t\t\t    strncmp(\"__MACOSX/\", name, 9) == 0) {\n\t\t\t\t/* If this file is not a resource fork nor\n\t\t\t\t * a directory. We should treat it as a non\n\t\t\t\t * resource fork file to expose it. */\n\t\t\t\tif (name[filename_length-1] != '/' &&\n\t\t\t\t    (r - name < 3 || r[0] != '.' ||\n\t\t\t\t     r[1] != '_')) {\n\t\t\t\t\t__archive_rb_tree_insert_node(\n\t\t\t\t\t    &zip->tree, &zip_entry->node);\n\t\t\t\t\t/* Expose its parent directories. */\n\t\t\t\t\texpose_parent_dirs(zip, name,\n\t\t\t\t\t    filename_length);\n\t\t\t\t} else {\n\t\t\t\t\t/* This file is a resource fork file or\n\t\t\t\t\t * a directory. */\n\t\t\t\t\tarchive_strncpy(&(zip_entry->rsrcname),\n\t\t\t\t\t     name, filename_length);\n\t\t\t\t\t__archive_rb_tree_insert_node(\n\t\t\t\t\t    &zip->tree_rsrc, &zip_entry->node);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Generate resource fork name to find its\n\t\t\t\t * resource file at zip->tree_rsrc. */\n\n\t\t\t\t/* If this is an entry ending with slash,\n\t\t\t\t * make the resource for name slash-less\n\t\t\t\t * as the actual resource fork doesn't end with '/'.\n\t\t\t\t */\n\t\t\t\tsize_t tmp_length = filename_length;\n\t\t\t\tif (tmp_length > 0 && name[tmp_length - 1] == '/') {\n\t\t\t\t\ttmp_length--;\n\t\t\t\t\tr = rsrc_basename(name, tmp_length);\n\t\t\t\t}\n\n\t\t\t\tarchive_strcpy(&(zip_entry->rsrcname),\n\t\t\t\t    \"__MACOSX/\");\n\t\t\t\tarchive_strncat(&(zip_entry->rsrcname),\n\t\t\t\t    name, r - name);\n\t\t\t\tarchive_strcat(&(zip_entry->rsrcname), \"._\");\n\t\t\t\tarchive_strncat(&(zip_entry->rsrcname),\n\t\t\t\t    name + (r - name),\n\t\t\t\t    tmp_length - (r - name));\n\t\t\t\t/* Register an entry to RB tree to sort it by\n\t\t\t\t * file offset. */\n\t\t\t\t__archive_rb_tree_insert_node(&zip->tree,\n\t\t\t\t    &zip_entry->node);\n\t\t\t}\n\t\t}\n\n\t\t/* Skip the comment too ... */\n\t\t__archive_read_consume(a,\n\t\t    filename_length + extra_length + comment_length);\n\t}\n\n\treturn ARCHIVE_OK;\n}",
      "cve_list": [
        "CVE-2024-37407"
      ],
      "cwe_list": [
        "CWE-125"
      ]
    },
    {
      "project": "qemu",
      "filepath": "hw/scsi/esp.c",
      "func_name": "esp_do_nodma",
      "func_body": "static void esp_do_nodma(ESPState *s)\n{\n    int to_device = ((s->rregs[ESP_RSTAT] & 7) == STAT_DO);\n    uint32_t cmdlen;\n    int len;\n\n    if (s->do_cmd) {\n        cmdlen = fifo8_num_used(&s->cmdfifo);\n        trace_esp_handle_ti_cmd(cmdlen);\n        s->ti_size = 0;\n        if ((s->rregs[ESP_RSTAT] & 7) == STAT_CD) {\n            /* No command received */\n            if (s->cmdfifo_cdb_offset == fifo8_num_used(&s->cmdfifo)) {\n                return;\n            }\n\n            /* Command has been received */\n            s->do_cmd = 0;\n            do_cmd(s);\n        } else {\n            /*\n             * Extra message out bytes received: update cmdfifo_cdb_offset\n             * and then switch to command phase\n             */\n            s->cmdfifo_cdb_offset = fifo8_num_used(&s->cmdfifo);\n            s->rregs[ESP_RSTAT] = STAT_TC | STAT_CD;\n            s->rregs[ESP_RSEQ] = SEQ_CD;\n            s->rregs[ESP_RINTR] |= INTR_BS;\n            esp_raise_irq(s);\n        }\n        return;\n    }\n\n    if (!s->current_req) {\n        return;\n    }\n\n    if (s->async_len == 0) {\n        /* Defer until data is available.  */\n        return;\n    }\n\n    if (to_device) {\n        len = MIN(s->async_len, ESP_FIFO_SZ);\n        len = MIN(len, fifo8_num_used(&s->fifo));\n        esp_fifo_pop_buf(&s->fifo, s->async_buf, len);\n        s->async_buf += len;\n        s->async_len -= len;\n        s->ti_size += len;\n    } else {\n        if (fifo8_is_empty(&s->fifo)) {\n            fifo8_push(&s->fifo, s->async_buf[0]);\n            s->async_buf++;\n            s->async_len--;\n            s->ti_size--;\n        }\n    }\n\n    if (s->async_len == 0) {\n        scsi_req_continue(s->current_req);\n        return;\n    }\n\n    s->rregs[ESP_RINTR] |= INTR_BS;\n    esp_raise_irq(s);\n}",
      "cve_list": [
        "CVE-2024-24474"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "FreeRDP",
      "filepath": "libfreerdp/codec/planar.c",
      "func_name": "freerdp_bitmap_planar_context_reset",
      "func_body": "BOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT* context, UINT32 width,\n                                         UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\n\tcontext->bgr = FALSE;\n\tcontext->maxWidth = PLANAR_ALIGN(width, 4);\n\tcontext->maxHeight = PLANAR_ALIGN(height, 4);\n\tconst UINT64 tmp = (UINT64)context->maxWidth * context->maxHeight;\n\tif (tmp > UINT32_MAX)\n\t\treturn FALSE;\n\tcontext->maxPlaneSize = tmp;\n\n\tif (context->maxWidth > UINT32_MAX / 4)\n\t\treturn FALSE;\n\tcontext->nTempStep = context->maxWidth * 4;\n\n\tmemset(context->planes, 0, sizeof(context->planes));\n\tmemset(context->rlePlanes, 0, sizeof(context->rlePlanes));\n\tmemset(context->deltaPlanes, 0, sizeof(context->deltaPlanes));\n\n\tif (context->maxPlaneSize > 0)\n\t{\n\t\tvoid* tmp = winpr_aligned_recalloc(context->planesBuffer, context->maxPlaneSize, 4, 32);\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\t\tcontext->planesBuffer = tmp;\n\n\t\ttmp = winpr_aligned_recalloc(context->pTempData, context->maxPlaneSize, 6, 32);\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\t\tcontext->pTempData = tmp;\n\n\t\ttmp = winpr_aligned_recalloc(context->deltaPlanesBuffer, context->maxPlaneSize, 4, 32);\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\t\tcontext->deltaPlanesBuffer = tmp;\n\n\t\ttmp = winpr_aligned_recalloc(context->rlePlanesBuffer, context->maxPlaneSize, 4, 32);\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\t\tcontext->rlePlanesBuffer = tmp;\n\n\t\tcontext->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];\n\t\tcontext->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];\n\t\tcontext->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];\n\t\tcontext->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];\n\t\tcontext->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];\n\t\tcontext->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];\n\t\tcontext->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];\n\t\tcontext->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];\n\t}\n\treturn TRUE;\n}",
      "cve_list": [
        "CVE-2024-22211"
      ],
      "cwe_list": [
        "CWE-190"
      ]
    },
    {
      "project": "FreeRDP",
      "filepath": "libfreerdp/codec/interleaved.c",
      "func_name": "ExtractRunLengthMegaMega",
      "func_body": "static UINT ExtractRunLengthMegaMega(const BYTE* pbOrderHdr, const BYTE* pbEnd, UINT32* advance)\n{\n\tUINT runLength = 0;\n\n\tWINPR_ASSERT(pbOrderHdr);\n\tWINPR_ASSERT(pbEnd);\n\tWINPR_ASSERT(advance);\n\n\tif (!buffer_within_range(pbOrderHdr, 3, pbEnd))\n\t{\n\t\t*advance = 0;\n\t\treturn 0;\n\t}\n\n\trunLength = ((UINT16)pbOrderHdr[1]) | (((UINT16)pbOrderHdr[2]) << 8);\n\t(*advance) += 2;\n\n\treturn runLength;\n}",
      "cve_list": [
        "CVE-2024-32658"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "FreeRDP",
      "filepath": "libfreerdp/codec/interleaved.c",
      "func_name": "ExtractRunLengthRegularFgBg",
      "func_body": "static UINT ExtractRunLengthRegularFgBg(const BYTE* pbOrderHdr, const BYTE* pbEnd, UINT32* advance)\n{\n\tUINT runLength = 0;\n\n\tWINPR_ASSERT(pbOrderHdr);\n\tWINPR_ASSERT(pbEnd);\n\tWINPR_ASSERT(advance);\n\n\trunLength = (*pbOrderHdr) & g_MaskRegularRunLength;\n\tif (runLength == 0)\n\t{\n\t\tif (!buffer_within_range(pbOrderHdr, 2, pbEnd))\n\t\t{\n\t\t\t*advance = 0;\n\t\t\treturn 0;\n\t\t}\n\t\trunLength = *(pbOrderHdr + 1) + 1;\n\t\t(*advance)++;\n\t}\n\telse\n\t\trunLength = runLength * 8;\n\n\treturn runLength;\n}",
      "cve_list": [
        "CVE-2024-32658"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "FreeRDP",
      "filepath": "libfreerdp/codec/zgfx.c",
      "func_name": "zgfx_append",
      "func_body": "static BOOL zgfx_append(ZGFX_CONTEXT* zgfx, BYTE** ppConcatenated, size_t uncompressedSize,\n                        size_t* pUsed)\n{\n\tWINPR_ASSERT(zgfx);\n\tWINPR_ASSERT(ppConcatenated);\n\tWINPR_ASSERT(pUsed);\n\n\tconst size_t used = *pUsed;\n\tif (zgfx->OutputCount > UINT32_MAX - used)\n\t\treturn FALSE;\n\n\tif (used + zgfx->OutputCount > uncompressedSize)\n\t\treturn FALSE;\n\n\tBYTE* tmp = realloc(*ppConcatenated, used + zgfx->OutputCount + 64ull);\n\tif (!tmp)\n\t\treturn FALSE;\n\t*ppConcatenated = tmp;\n\tCopyMemory(&tmp[used], zgfx->OutputBuffer, zgfx->OutputCount);\n\t*pUsed = used + zgfx->OutputCount;\n\treturn TRUE;\n}",
      "cve_list": [
        "CVE-2024-32660"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "FreeRDP",
      "filepath": "libfreerdp/codec/zgfx.c",
      "func_name": "zgfx_decompress",
      "func_body": "int zgfx_decompress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,\n                    UINT32* pDstSize, UINT32 flags)\n{\n\tint status = -1;\n\tBYTE descriptor = 0;\n\twStream sbuffer = { 0 };\n\tsize_t used = 0;\n\tBYTE* pConcatenated = NULL;\n\twStream* stream = Stream_StaticConstInit(&sbuffer, pSrcData, SrcSize);\n\n\tWINPR_ASSERT(zgfx);\n\tWINPR_ASSERT(stream);\n\tWINPR_ASSERT(ppDstData);\n\tWINPR_ASSERT(pDstSize);\n\n\t*ppDstData = NULL;\n\t*pDstSize = 0;\n\n\tif (!Stream_CheckAndLogRequiredLength(TAG, stream, 1))\n\t\tgoto fail;\n\n\tStream_Read_UINT8(stream, descriptor); /* descriptor (1 byte) */\n\n\tif (descriptor == ZGFX_SEGMENTED_SINGLE)\n\t{\n\t\tif (!zgfx_decompress_segment(zgfx, stream, Stream_GetRemainingLength(stream)))\n\t\t\tgoto fail;\n\n\t\tif (zgfx->OutputCount > 0)\n\t\t{\n\t\t\tif (!zgfx_append(zgfx, &pConcatenated, zgfx->OutputCount, &used))\n\t\t\t\tgoto fail;\n\t\t\tif (used != zgfx->OutputCount)\n\t\t\t\tgoto fail;\n\t\t\t*ppDstData = pConcatenated;\n\t\t\t*pDstSize = zgfx->OutputCount;\n\t\t}\n\t}\n\telse if (descriptor == ZGFX_SEGMENTED_MULTIPART)\n\t{\n\t\tUINT32 segmentSize = 0;\n\t\tUINT16 segmentNumber = 0;\n\t\tUINT16 segmentCount = 0;\n\t\tUINT32 uncompressedSize = 0;\n\n\t\tif (!Stream_CheckAndLogRequiredLength(TAG, stream, 6))\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT16(stream, segmentCount);     /* segmentCount (2 bytes) */\n\t\tStream_Read_UINT32(stream, uncompressedSize); /* uncompressedSize (4 bytes) */\n\n\t\tfor (segmentNumber = 0; segmentNumber < segmentCount; segmentNumber++)\n\t\t{\n\t\t\tif (!Stream_CheckAndLogRequiredLength(TAG, stream, sizeof(UINT32)))\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read_UINT32(stream, segmentSize); /* segmentSize (4 bytes) */\n\n\t\t\tif (!zgfx_decompress_segment(zgfx, stream, segmentSize))\n\t\t\t\tgoto fail;\n\n\t\t\tif (!zgfx_append(zgfx, &pConcatenated, uncompressedSize, &used))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\tif (used != uncompressedSize)\n\t\t\tgoto fail;\n\n\t\t*ppDstData = pConcatenated;\n\t\t*pDstSize = uncompressedSize;\n\t}\n\telse\n\t{\n\t\tgoto fail;\n\t}\n\n\tstatus = 1;\nfail:\n\tif (status < 0)\n\t\tfree(pConcatenated);\n\treturn status;\n}",
      "cve_list": [
        "CVE-2024-32660"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "FreeRDP",
      "filepath": "libfreerdp/codec/color.c",
      "func_name": "freerdp_image_copy",
      "func_body": "BOOL freerdp_image_copy(BYTE* pDstData, DWORD DstFormat, UINT32 nDstStep, UINT32 nXDst,\n                        UINT32 nYDst, UINT32 nWidth, UINT32 nHeight, const BYTE* pSrcData,\n                        DWORD SrcFormat, UINT32 nSrcStep, UINT32 nXSrc, UINT32 nYSrc,\n                        const gdiPalette* palette, UINT32 flags)\n{\n\tconst UINT32 dstByte = FreeRDPGetBytesPerPixel(DstFormat);\n\tconst UINT32 srcByte = FreeRDPGetBytesPerPixel(SrcFormat);\n\n\tif ((nHeight > INT32_MAX) || (nWidth > INT32_MAX))\n\t\treturn FALSE;\n\n\tif (!pDstData || !pSrcData)\n\t\treturn FALSE;\n\n\tif ((nWidth == 0) || (nHeight == 0))\n\t\treturn TRUE;\n\n\tif (nDstStep == 0)\n\t\tnDstStep = nWidth * FreeRDPGetBytesPerPixel(DstFormat);\n\n\tif (nSrcStep == 0)\n\t\tnSrcStep = nWidth * FreeRDPGetBytesPerPixel(SrcFormat);\n\n\tconst BOOL ovl = overlapping(pDstData, nXDst, nYDst, nDstStep, dstByte, pSrcData, nXSrc, nYSrc,\n\t                             nSrcStep, srcByte, nWidth, nHeight);\n\tif (ovl)\n\t\treturn freerdp_image_copy_overlap(pDstData, DstFormat, nDstStep, nXDst, nYDst, nWidth,\n\t\t                                  nHeight, pSrcData, SrcFormat, nSrcStep, nXSrc, nYSrc,\n\t\t                                  palette, flags);\n\treturn freerdp_image_copy_no_overlap(pDstData, DstFormat, nDstStep, nXDst, nYDst, nWidth,\n\t                                     nHeight, pSrcData, SrcFormat, nSrcStep, nXSrc, nYSrc,\n\t                                     palette, flags);\n}",
      "cve_list": [
        "CVE-2024-32659"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "FreeRDP",
      "filepath": "libfreerdp/core/info.c",
      "func_name": "rdp_write_logon_info_v1",
      "func_body": "static BOOL rdp_write_logon_info_v1(wStream* s, logon_info* info)\n{\n\tconst size_t charLen = 52 / sizeof(WCHAR);\n\tconst size_t userCharLen = 512 / sizeof(WCHAR);\n\n\tsize_t sz = 4 + 52 + 4 + 512 + 4;\n\tsize_t len = 0;\n\n\tif (!Stream_EnsureRemainingCapacity(s, sz))\n\t\treturn FALSE;\n\n\t/* domain */\n\tWINPR_ASSERT(info);\n\tif (!info->domain || !info->username)\n\t\treturn FALSE;\n\n\tlen = strnlen(info->domain, charLen + 1);\n\tif (len > charLen)\n\t\treturn FALSE;\n\n\tStream_Write_UINT32(s, len * sizeof(WCHAR));\n\tif (Stream_Write_UTF16_String_From_UTF8(s, charLen, info->domain, len, TRUE) < 0)\n\t\treturn FALSE;\n\n\t/* username */\n\tlen = strnlen(info->username, userCharLen + 1);\n\tif (len > userCharLen)\n\t\treturn FALSE;\n\n\tStream_Write_UINT32(s, len * sizeof(WCHAR));\n\tif (Stream_Write_UTF16_String_From_UTF8(s, userCharLen, info->username, len, TRUE) < 0)\n\t\treturn FALSE;\n\n\t/* sessionId */\n\tStream_Write_UINT32(s, info->sessionId);\n\treturn TRUE;\n}",
      "cve_list": [
        "CVE-2024-32661"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "FreeRDP",
      "filepath": "libfreerdp/core/redirection.c",
      "func_name": "rdp_redirection_read_base64_wchar",
      "func_body": "static BOOL rdp_redirection_read_base64_wchar(UINT32 flag, wStream* s, UINT32* pLength,\n                                              BYTE** pData)\n{\n\tBOOL rc = FALSE;\n\tchar buffer[64] = { 0 };\n\tconst BYTE* ptr = NULL;\n\n\tif (!rdp_redirection_get_data(s, pLength, &ptr))\n\t\treturn FALSE;\n\tconst WCHAR* wchar = (const WCHAR*)ptr;\n\n\tsize_t utf8_len = 0;\n\tchar* utf8 = ConvertWCharNToUtf8Alloc(wchar, *pLength / sizeof(WCHAR), &utf8_len);\n\tif (!utf8)\n\t\tgoto fail;\n\n\tredirection_free_data(pData, NULL);\n\n\tutf8_len = strnlen(utf8, utf8_len);\n\t*pData = calloc(utf8_len, sizeof(BYTE));\n\tif (!*pData)\n\t\tgoto fail;\n\n\tsize_t rlen = utf8_len;\n\tsize_t wpos = 0;\n\tchar* tok = strtok(utf8, \"\\r\\n\");\n\twhile (tok)\n\t{\n\t\tconst size_t len = strnlen(tok, rlen);\n\t\trlen -= len;\n\n\t\tsize_t bplen = 0;\n\t\tBYTE* bptr = NULL;\n\t\tcrypto_base64_decode(tok, len, &bptr, &bplen);\n\t\tif (!bptr)\n\t\t\tgoto fail;\n\t\tmemcpy(&(*pData)[wpos], bptr, bplen);\n\t\twpos += bplen;\n\t\tfree(bptr);\n\n\t\ttok = strtok(NULL, \"\\r\\n\");\n\t}\n\t*pLength = wpos;\n\n\tWLog_DBG(TAG, \"%s:\", rdp_redirection_flags_to_string(flag, buffer, sizeof(buffer)));\n\n\trc = TRUE;\nfail:\n\tif (!rc)\n\t\tWLog_ERR(TAG, \"failed to read base64 data\");\n\tfree(utf8);\n\treturn rc;\n}",
      "cve_list": [
        "CVE-2024-32662"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "tcpdump",
      "filepath": "print-ppp.c",
      "func_name": "ppp_hdlc",
      "func_body": "ppp_hdlc(netdissect_options *ndo,\n         const u_char *p, u_int length)\n{\n\tu_int caplen = ND_BYTES_AVAILABLE_AFTER(p);\n\tu_char *b, *t, c;\n\tconst u_char *s;\n\tu_int i, proto;\n\n\tif (caplen == 0)\n\t\treturn;\n\n        if (length == 0)\n                return;\n\n\tb = (u_char *)malloc(caplen);\n\tif (b == NULL) {\n\t\t(*ndo->ndo_error)(ndo, S_ERR_ND_MEM_ALLOC,\n\t\t\t\"%s: malloc\", __func__);\n\t}\n\n\t/*\n\t * Unescape all the data into a temporary, private, buffer.\n\t * Do this so that we don't overwrite the original packet\n\t * contents.\n\t */\n\tfor (s = p, t = b, i = caplen; i != 0; i--) {\n\t\tc = GET_U_1(s);\n\t\ts++;\n\t\tif (c == 0x7d) {\n\t\t\tif (i <= 1)\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t\tc = GET_U_1(s) ^ 0x20;\n\t\t\ts++;\n\t\t}\n\t\t*t++ = c;\n\t}\n\n\t/*\n\t * Switch to the output buffer for dissection, and save it\n\t * on the buffer stack so it can be freed; our caller must\n\t * pop it when done.\n\t */\n\tif (!nd_push_buffer(ndo, b, b, (u_int)(t - b))) {\n\t\tfree(b);\n\t\t(*ndo->ndo_error)(ndo, S_ERR_ND_MEM_ALLOC,\n\t\t\t\"%s: can't push buffer on buffer stack\", __func__);\n\t}\n\tlength = ND_BYTES_AVAILABLE_AFTER(b);\n\n        /* now lets guess about the payload codepoint format */\n        if (length < 1)\n                goto trunc;\n        proto = GET_U_1(b); /* start with a one-octet codepoint guess */\n\n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        case PPP_IPV6:\n\t\tip6_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        default: /* no luck - try next guess */\n\t\tbreak;\n        }\n\n        if (length < 2)\n                goto trunc;\n        proto = GET_BE_U_2(b); /* next guess - load two octets */\n\n        switch (proto) {\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): /* looks like a PPP frame */\n            if (length < 4)\n                goto trunc;\n            proto = GET_BE_U_2(b + 2); /* load the PPP proto-id */\n            if ((proto & 0xff00) == 0x7e00)\n                ND_PRINT(\"(protocol 0x%04x invalid)\", proto);\n            else\n                handle_ppp(ndo, proto, b + 4, length - 4);\n            break;\n        default: /* last guess - proto must be a PPP proto-id */\n            if ((proto & 0xff00) == 0x7e00)\n                ND_PRINT(\"(protocol 0x%04x invalid)\", proto);\n            else\n                handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\n\ncleanup:\n\tnd_pop_packet_info(ndo);\n        return;\n\ntrunc:\n\tnd_pop_packet_info(ndo);\n\tnd_print_trunc(ndo);\n}",
      "cve_list": [
        "CVE-2024-2397"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "tcpdump",
      "filepath": "print.c",
      "func_name": "pretty_print_packet",
      "func_body": "pretty_print_packet(netdissect_options *ndo, const struct pcap_pkthdr *h,\n\t\t    const u_char *sp, u_int packets_captured)\n{\n\tu_int hdrlen = 0;\n\tint invalid_header = 0;\n\n\tif (ndo->ndo_print_sampling && packets_captured % ndo->ndo_print_sampling != 0)\n\t\treturn;\n\n#ifdef ENABLE_INSTRUMENT_FUNCTIONS\n\tif (pretty_print_packet_level == -1)\n\t\tpretty_print_packet_level = profile_func_level;\n#endif\n\n\tif (ndo->ndo_packet_number)\n\t\tND_PRINT(\"%5u  \", packets_captured);\n\n\tif (ndo->ndo_lengths)\n\t\tND_PRINT(\"caplen %u len %u \", h->caplen, h->len);\n\n\t/* Sanity checks on packet length / capture length */\n\tif (h->caplen == 0) {\n\t\tinvalid_header = 1;\n\t\tND_PRINT(\"[Invalid header: caplen==0\");\n\t}\n\tif (h->len == 0) {\n\t\tif (!invalid_header) {\n\t\t\tinvalid_header = 1;\n\t\t\tND_PRINT(\"[Invalid header:\");\n\t\t} else\n\t\t\tND_PRINT(\",\");\n\t\tND_PRINT(\" len==0\");\n\t} else if (h->len < h->caplen) {\n\t\tif (!invalid_header) {\n\t\t\tinvalid_header = 1;\n\t\t\tND_PRINT(\"[Invalid header:\");\n\t\t} else\n\t\t\tND_PRINT(\",\");\n\t\tND_PRINT(\" len(%u) < caplen(%u)\", h->len, h->caplen);\n\t}\n\tif (h->caplen > MAXIMUM_SNAPLEN) {\n\t\tif (!invalid_header) {\n\t\t\tinvalid_header = 1;\n\t\t\tND_PRINT(\"[Invalid header:\");\n\t\t} else\n\t\t\tND_PRINT(\",\");\n\t\tND_PRINT(\" caplen(%u) > %u\", h->caplen, MAXIMUM_SNAPLEN);\n\t}\n\tif (h->len > MAXIMUM_SNAPLEN) {\n\t\tif (!invalid_header) {\n\t\t\tinvalid_header = 1;\n\t\t\tND_PRINT(\"[Invalid header:\");\n\t\t} else\n\t\t\tND_PRINT(\",\");\n\t\tND_PRINT(\" len(%u) > %u\", h->len, MAXIMUM_SNAPLEN);\n\t}\n\tif (invalid_header) {\n\t\tND_PRINT(\"]\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * At this point:\n\t *   capture length != 0,\n\t *   packet length != 0,\n\t *   capture length <= MAXIMUM_SNAPLEN,\n\t *   packet length <= MAXIMUM_SNAPLEN,\n\t *   packet length >= capture length.\n\t *\n\t * Currently, there is no D-Bus printer, thus no need for\n\t * bigger lengths.\n\t */\n\n\t/*\n\t * The header /usr/include/pcap/pcap.h in OpenBSD declares h->ts as\n\t * struct bpf_timeval, not struct timeval. The former comes from\n\t * /usr/include/net/bpf.h and uses 32-bit unsigned types instead of\n\t * the types used in struct timeval.\n\t */\n\tstruct timeval tvbuf;\n\ttvbuf.tv_sec = h->ts.tv_sec;\n\ttvbuf.tv_usec = h->ts.tv_usec;\n\tts_print(ndo, &tvbuf);\n\n\t/*\n\t * Printers must check that they're not walking off the end of\n\t * the packet.\n\t * Rather than pass it all the way down, we set this member\n\t * of the netdissect_options structure.\n\t */\n\tndo->ndo_snapend = sp + h->caplen;\n\tndo->ndo_packetp = sp;\n\n\tndo->ndo_protocol = \"\";\n\tndo->ndo_ll_hdr_len = 0;\n\tswitch (setjmp(ndo->ndo_early_end)) {\n\tcase 0:\n\t\t/* Print the packet. */\n\t\t(ndo->ndo_if_printer)(ndo, h, sp);\n\t\tbreak;\n\tcase ND_TRUNCATED:\n\t\t/* A printer quit because the packet was truncated; report it */\n\t\tnd_print_trunc(ndo);\n\t\t/* Print the full packet */\n\t\tndo->ndo_ll_hdr_len = 0;\n#ifdef ENABLE_INSTRUMENT_FUNCTIONS\n\t\t/* truncation => reassignment */\n\t\tprofile_func_level = pretty_print_packet_level;\n#endif\n\t\tbreak;\n\t}\n\thdrlen = ndo->ndo_ll_hdr_len;\n\n\t/*\n\t * Empty the stack of packet information, freeing all pushed buffers;\n\t * if we got here by a printer quitting, we need to release anything\n\t * that didn't get released because we longjmped out of the code\n\t * before it popped the packet information.\n\t */\n\tnd_pop_all_packet_info(ndo);\n\n\t/*\n\t * Restore the originals snapend and packetp, as a printer\n\t * might have changed them.\n\t *\n\t * XXX - nd_pop_all_packet_info() should have restored the\n\t * original values, but, just in case....\n\t */\n\tndo->ndo_snapend = sp + h->caplen;\n\tndo->ndo_packetp = sp;\n\tif (ndo->ndo_Xflag) {\n\t\t/*\n\t\t * Print the raw packet data in hex and ASCII.\n\t\t */\n\t\tif (ndo->ndo_Xflag > 1) {\n\t\t\t/*\n\t\t\t * Include the link-layer header.\n\t\t\t */\n\t\t\thex_and_ascii_print(ndo, \"\\n\\t\", sp, h->caplen);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Don't include the link-layer header - and if\n\t\t\t * we have nothing past the link-layer header,\n\t\t\t * print nothing.\n\t\t\t */\n\t\t\tif (h->caplen > hdrlen)\n\t\t\t\thex_and_ascii_print(ndo, \"\\n\\t\", sp + hdrlen,\n\t\t\t\t\t\t    h->caplen - hdrlen);\n\t\t}\n\t} else if (ndo->ndo_xflag) {\n\t\t/*\n\t\t * Print the raw packet data in hex.\n\t\t */\n\t\tif (ndo->ndo_xflag > 1) {\n\t\t\t/*\n\t\t\t * Include the link-layer header.\n\t\t\t */\n\t\t\thex_print(ndo, \"\\n\\t\", sp, h->caplen);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Don't include the link-layer header - and if\n\t\t\t * we have nothing past the link-layer header,\n\t\t\t * print nothing.\n\t\t\t */\n\t\t\tif (h->caplen > hdrlen)\n\t\t\t\thex_print(ndo, \"\\n\\t\", sp + hdrlen,\n\t\t\t\t\t  h->caplen - hdrlen);\n\t\t}\n\t} else if (ndo->ndo_Aflag) {\n\t\t/*\n\t\t * Print the raw packet data in ASCII.\n\t\t */\n\t\tif (ndo->ndo_Aflag > 1) {\n\t\t\t/*\n\t\t\t * Include the link-layer header.\n\t\t\t */\n\t\t\tascii_print(ndo, sp, h->caplen);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Don't include the link-layer header - and if\n\t\t\t * we have nothing past the link-layer header,\n\t\t\t * print nothing.\n\t\t\t */\n\t\t\tif (h->caplen > hdrlen)\n\t\t\t\tascii_print(ndo, sp + hdrlen, h->caplen - hdrlen);\n\t\t}\n\t}\n\n\tND_PRINT(\"\\n\");\n\tnd_free_all(ndo);\n}",
      "cve_list": [
        "CVE-2024-2397"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "libgit2",
      "filepath": "tests/refs/revparse.c",
      "func_name": "revparse",
      "func_body": "static int revparse(\n\tgit_object **object_out,\n\tgit_reference **reference_out,\n\tsize_t *identifier_len_out,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tsize_t pos = 0, identifier_len = 0;\n\tint error = -1, n;\n\tgit_str buf = GIT_STR_INIT;\n\n\tgit_reference *reference = NULL;\n\tgit_object *base_rev = NULL;\n\n\tbool should_return_reference = true;\n\n\tGIT_ASSERT_ARG(object_out);\n\tGIT_ASSERT_ARG(reference_out);\n\tGIT_ASSERT_ARG(repo);\n\tGIT_ASSERT_ARG(spec);\n\n\t*object_out = NULL;\n\t*reference_out = NULL;\n\n\twhile (spec[pos]) {\n\t\tswitch (spec[pos]) {\n\t\tcase '^':\n\t\t\tshould_return_reference = false;\n\n\t\t\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (spec[pos+1] == '{') {\n\t\t\t\tgit_object *temp_object = NULL;\n\n\t\t\t\tif ((error = extract_curly_braces_content(&buf, spec, &pos)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_caret_curly_syntax(&temp_object, base_rev, git_str_cstr(&buf))) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tgit_object_free(base_rev);\n\t\t\t\tbase_rev = temp_object;\n\t\t\t} else {\n\t\t\t\tgit_object *temp_object = NULL;\n\n\t\t\t\tif ((error = extract_how_many(&n, spec, &pos)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_caret_parent_syntax(&temp_object, base_rev, n)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tgit_object_free(base_rev);\n\t\t\t\tbase_rev = temp_object;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '~':\n\t\t{\n\t\t\tgit_object *temp_object = NULL;\n\n\t\t\tshould_return_reference = false;\n\n\t\t\tif ((error = extract_how_many(&n, spec, &pos)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif ((error = handle_linear_syntax(&temp_object, base_rev, n)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tgit_object_free(base_rev);\n\t\t\tbase_rev = temp_object;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase ':':\n\t\t{\n\t\t\tgit_object *temp_object = NULL;\n\n\t\t\tshould_return_reference = false;\n\n\t\t\tif ((error = extract_path(&buf, spec, &pos)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (any_left_hand_identifier(base_rev, reference, identifier_len)) {\n\t\t\t\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, true)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_colon_syntax(&temp_object, base_rev, git_str_cstr(&buf))) < 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t} else {\n\t\t\t\tif (*git_str_cstr(&buf) == '/') {\n\t\t\t\t\tif ((error = handle_grep_syntax(&temp_object, repo, NULL, git_str_cstr(&buf) + 1)) < 0)\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t} else {\n\n\t\t\t\t\t/*\n\t\t\t\t\t * TODO: support merge-stage path lookup (\":2:Makefile\")\n\t\t\t\t\t * and plain index blob lookup (:i-am/a/blob)\n\t\t\t\t\t */\n\t\t\t\t\tgit_error_set(GIT_ERROR_INVALID, \"unimplemented\");\n\t\t\t\t\terror = GIT_ERROR;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgit_object_free(base_rev);\n\t\t\tbase_rev = temp_object;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase '@':\n\t\t\tif (spec[pos+1] == '{') {\n\t\t\t\tgit_object *temp_object = NULL;\n\n\t\t\t\tif ((error = extract_curly_braces_content(&buf, spec, &pos)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = ensure_base_rev_is_not_known_yet(base_rev)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_at_syntax(&temp_object, &reference, spec, identifier_len, repo, git_str_cstr(&buf))) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif (temp_object != NULL)\n\t\t\t\t\tbase_rev = temp_object;\n\t\t\t\tbreak;\n\t\t\t} else if (spec[pos+1] == '\\0') {\n\t\t\t\tspec = \"HEAD\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall through */\n\n\t\tdefault:\n\t\t\tif ((error = ensure_left_hand_identifier_is_not_known_yet(base_rev, reference)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tpos++;\n\t\t\tidentifier_len++;\n\t\t}\n\t}\n\n\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)\n\t\tgoto cleanup;\n\n\tif (!should_return_reference) {\n\t\tgit_reference_free(reference);\n\t\treference = NULL;\n\t}\n\n\t*object_out = base_rev;\n\t*reference_out = reference;\n\t*identifier_len_out = identifier_len;\n\terror = 0;\n\ncleanup:\n\tif (error) {\n\t\tif (error == GIT_EINVALIDSPEC)\n\t\t\tgit_error_set(GIT_ERROR_INVALID,\n\t\t\t\t\"failed to parse revision specifier - Invalid pattern '%s'\", spec);\n\n\t\tgit_object_free(base_rev);\n\t\tgit_reference_free(reference);\n\t}\n\n\tgit_str_dispose(&buf);\n\treturn error;\n}",
      "cve_list": [
        "CVE-2024-24575"
      ],
      "cwe_list": [
        "CWE-400"
      ]
    },
    {
      "project": "libgit2",
      "filepath": "tests/refs/revparse.c",
      "func_name": "test_refs_revparse__parses_at_head",
      "func_body": "void test_refs_revparse__parses_at_head(void)\n{\n\ttest_id(\"HEAD\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", NULL, GIT_REVSPEC_SINGLE);\n\ttest_id(\"@{0}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", NULL, GIT_REVSPEC_SINGLE);\n\ttest_id(\"@\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", NULL, GIT_REVSPEC_SINGLE);\n}",
      "cve_list": [
        "CVE-2024-24575"
      ],
      "cwe_list": [
        "CWE-400"
      ]
    },
    {
      "project": "git",
      "filepath": "builtin/clone.c",
      "func_name": "copy_or_link_directory",
      "func_body": "static void copy_or_link_directory(struct strbuf *src, struct strbuf *dest,\n\t\t\t\t   const char *src_repo)\n{\n\tint src_len, dest_len;\n\tstruct dir_iterator *iter;\n\tint iter_status;\n\n\t/*\n\t * Refuse copying directories by default which aren't owned by us. The\n\t * code that performs either the copying or hardlinking is not prepared\n\t * to handle various edge cases where an adversary may for example\n\t * racily swap out files for symlinks. This can cause us to\n\t * inadvertently use the wrong source file.\n\t *\n\t * Furthermore, even if we were prepared to handle such races safely,\n\t * creating hardlinks across user boundaries is an inherently unsafe\n\t * operation as the hardlinked files can be rewritten at will by the\n\t * potentially-untrusted user. We thus refuse to do so by default.\n\t */\n\tdie_upon_dubious_ownership(NULL, NULL, src_repo);\n\n\tmkdir_if_missing(dest->buf, 0777);\n\n\titer = dir_iterator_begin(src->buf, DIR_ITERATOR_PEDANTIC);\n\n\tif (!iter)\n\t\tdie_errno(_(\"failed to start iterator over '%s'\"), src->buf);\n\n\tstrbuf_addch(src, '/');\n\tsrc_len = src->len;\n\tstrbuf_addch(dest, '/');\n\tdest_len = dest->len;\n\n\twhile ((iter_status = dir_iterator_advance(iter)) == ITER_OK) {\n\t\tstrbuf_setlen(src, src_len);\n\t\tstrbuf_addstr(src, iter->relative_path);\n\t\tstrbuf_setlen(dest, dest_len);\n\t\tstrbuf_addstr(dest, iter->relative_path);\n\n\t\tif (S_ISLNK(iter->st.st_mode))\n\t\t\tdie(_(\"symlink '%s' exists, refusing to clone with --local\"),\n\t\t\t    iter->relative_path);\n\n\t\tif (S_ISDIR(iter->st.st_mode)) {\n\t\t\tmkdir_if_missing(dest->buf, 0777);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Files that cannot be copied bit-for-bit... */\n\t\tif (!fspathcmp(iter->relative_path, \"info/alternates\")) {\n\t\t\tcopy_alternates(src, src_repo);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (unlink(dest->buf) && errno != ENOENT)\n\t\t\tdie_errno(_(\"failed to unlink '%s'\"), dest->buf);\n\t\tif (!option_no_hardlinks) {\n\t\t\tif (!link(src->buf, dest->buf)) {\n\t\t\t\tstruct stat st;\n\n\t\t\t\t/*\n\t\t\t\t * Sanity-check whether the created hardlink\n\t\t\t\t * actually links to the expected file now. This\n\t\t\t\t * catches time-of-check-time-of-use bugs in\n\t\t\t\t * case the source file was meanwhile swapped.\n\t\t\t\t */\n\t\t\t\tif (lstat(dest->buf, &st))\n\t\t\t\t\tdie(_(\"hardlink cannot be checked at '%s'\"), dest->buf);\n\t\t\t\tif (st.st_mode != iter->st.st_mode ||\n\t\t\t\t    st.st_ino != iter->st.st_ino ||\n\t\t\t\t    st.st_dev != iter->st.st_dev ||\n\t\t\t\t    st.st_size != iter->st.st_size ||\n\t\t\t\t    st.st_uid != iter->st.st_uid ||\n\t\t\t\t    st.st_gid != iter->st.st_gid)\n\t\t\t\t\tdie(_(\"hardlink different from source at '%s'\"), dest->buf);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (option_local > 0)\n\t\t\t\tdie_errno(_(\"failed to create link '%s'\"), dest->buf);\n\t\t\toption_no_hardlinks = 1;\n\t\t}\n\t\tif (copy_file_with_time(dest->buf, src->buf, 0666))\n\t\t\tdie_errno(_(\"failed to copy file to '%s'\"), dest->buf);\n\t}\n\n\tif (iter_status != ITER_DONE) {\n\t\tstrbuf_setlen(src, src_len);\n\t\tdie(_(\"failed to iterate over '%s'\"), src->buf);\n\t}\n}",
      "cve_list": [
        "CVE-2024-32020"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "git",
      "filepath": "path.c",
      "func_name": "enter_repo",
      "func_body": "const char *enter_repo(const char *path, int strict)\n{\n\tstatic struct strbuf validated_path = STRBUF_INIT;\n\tstatic struct strbuf used_path = STRBUF_INIT;\n\n\tif (!path)\n\t\treturn NULL;\n\n\tif (!strict) {\n\t\tstatic const char *suffix[] = {\n\t\t\t\"/.git\", \"\", \".git/.git\", \".git\", NULL,\n\t\t};\n\t\tconst char *gitfile;\n\t\tint len = strlen(path);\n\t\tint i;\n\t\twhile ((1 < len) && (path[len-1] == '/'))\n\t\t\tlen--;\n\n\t\t/*\n\t\t * We can handle arbitrary-sized buffers, but this remains as a\n\t\t * sanity check on untrusted input.\n\t\t */\n\t\tif (PATH_MAX <= len)\n\t\t\treturn NULL;\n\n\t\tstrbuf_reset(&used_path);\n\t\tstrbuf_reset(&validated_path);\n\t\tstrbuf_add(&used_path, path, len);\n\t\tstrbuf_add(&validated_path, path, len);\n\n\t\tif (used_path.buf[0] == '~') {\n\t\t\tchar *newpath = interpolate_path(used_path.buf, 0);\n\t\t\tif (!newpath)\n\t\t\t\treturn NULL;\n\t\t\tstrbuf_attach(&used_path, newpath, strlen(newpath),\n\t\t\t\t      strlen(newpath));\n\t\t}\n\t\tfor (i = 0; suffix[i]; i++) {\n\t\t\tstruct stat st;\n\t\t\tsize_t baselen = used_path.len;\n\t\t\tstrbuf_addstr(&used_path, suffix[i]);\n\t\t\tif (!stat(used_path.buf, &st) &&\n\t\t\t    (S_ISREG(st.st_mode) ||\n\t\t\t    (S_ISDIR(st.st_mode) && is_git_directory(used_path.buf)))) {\n\t\t\t\tstrbuf_addstr(&validated_path, suffix[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrbuf_setlen(&used_path, baselen);\n\t\t}\n\t\tif (!suffix[i])\n\t\t\treturn NULL;\n\t\tgitfile = read_gitfile(used_path.buf);\n\t\tdie_upon_dubious_ownership(gitfile, NULL, used_path.buf);\n\t\tif (gitfile) {\n\t\t\tstrbuf_reset(&used_path);\n\t\t\tstrbuf_addstr(&used_path, gitfile);\n\t\t}\n\t\tif (chdir(used_path.buf))\n\t\t\treturn NULL;\n\t\tpath = validated_path.buf;\n\t}\n\telse {\n\t\tconst char *gitfile = read_gitfile(path);\n\t\tdie_upon_dubious_ownership(gitfile, NULL, path);\n\t\tif (gitfile)\n\t\t\tpath = gitfile;\n\t\tif (chdir(path))\n\t\t\treturn NULL;\n\t}\n\n\tif (is_git_directory(\".\")) {\n\t\tset_git_dir(\".\", 0);\n\t\tcheck_repository_format(NULL);\n\t\treturn path;\n\t}\n\n\treturn NULL;\n}",
      "cve_list": [
        "CVE-2024-32004"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "git",
      "filepath": "setup.c",
      "func_name": "die_upon_dubious_ownership",
      "func_body": "void die_upon_dubious_ownership(const char *gitfile, const char *worktree,\n\t\t\t\tconst char *gitdir)\n{\n\tstruct strbuf report = STRBUF_INIT, quoted = STRBUF_INIT;\n\tconst char *path;\n\n\tif (ensure_valid_ownership(gitfile, worktree, gitdir, &report))\n\t\treturn;\n\n\tstrbuf_complete(&report, '\\n');\n\tpath = gitfile ? gitfile : gitdir;\n\tsq_quote_buf_pretty(&quoted, path);\n\n\tdie(_(\"detected dubious ownership in repository at '%s'\\n\"\n\t      \"%s\"\n\t      \"To add an exception for this directory, call:\\n\"\n\t      \"\\n\"\n\t      \"\\tgit config --global --add safe.directory %s\"),\n\t    path, report.buf, quoted.buf);\n}",
      "cve_list": [
        "CVE-2024-32004"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "git",
      "filepath": "builtin/upload-pack.c",
      "func_name": "cmd_upload_pack",
      "func_body": "int cmd_upload_pack(int argc, const char **argv, const char *prefix)\n{\n\tconst char *dir;\n\tint strict = 0;\n\tint advertise_refs = 0;\n\tint stateless_rpc = 0;\n\tint timeout = 0;\n\tstruct option options[] = {\n\t\tOPT_BOOL(0, \"stateless-rpc\", &stateless_rpc,\n\t\t\t N_(\"quit after a single request/response exchange\")),\n\t\tOPT_HIDDEN_BOOL(0, \"http-backend-info-refs\", &advertise_refs,\n\t\t\t\tN_(\"serve up the info/refs for git-http-backend\")),\n\t\tOPT_ALIAS(0, \"advertise-refs\", \"http-backend-info-refs\"),\n\t\tOPT_BOOL(0, \"strict\", &strict,\n\t\t\t N_(\"do not try <directory>/.git/ if <directory> is no Git directory\")),\n\t\tOPT_INTEGER(0, \"timeout\", &timeout,\n\t\t\t    N_(\"interrupt transfer after <n> seconds of inactivity\")),\n\t\tOPT_END()\n\t};\n\n\tpacket_trace_identity(\"upload-pack\");\n\tread_replace_refs = 0;\n\t/* TODO: This should use NO_LAZY_FETCH_ENVIRONMENT */\n\txsetenv(\"GIT_NO_LAZY_FETCH\", \"1\", 0);\n\n\targc = parse_options(argc, argv, prefix, options, upload_pack_usage, 0);\n\n\tif (argc != 1)\n\t\tusage_with_options(upload_pack_usage, options);\n\n\tsetup_path();\n\n\tdir = argv[0];\n\n\tif (!enter_repo(dir, strict))\n\t\tdie(\"'%s' does not appear to be a git repository\", dir);\n\n\tswitch (determine_protocol_version_server()) {\n\tcase protocol_v2:\n\t\tif (advertise_refs)\n\t\t\tprotocol_v2_advertise_capabilities();\n\t\telse\n\t\t\tprotocol_v2_serve_loop(stateless_rpc);\n\t\tbreak;\n\tcase protocol_v1:\n\t\t/*\n\t\t * v1 is just the original protocol with a version string,\n\t\t * so just fall through after writing the version string.\n\t\t */\n\t\tif (advertise_refs || !stateless_rpc)\n\t\t\tpacket_write_fmt(1, \"version 1\\n\");\n\n\t\t/* fallthrough */\n\tcase protocol_v0:\n\t\tupload_pack(advertise_refs, stateless_rpc, timeout);\n\t\tbreak;\n\tcase protocol_unknown_version:\n\t\tBUG(\"unknown protocol version\");\n\t}\n\n\treturn 0;\n}",
      "cve_list": [
        "CVE-2024-32465"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "git",
      "filepath": "promisor-remote.c",
      "func_name": "fetch_objects",
      "func_body": "static int fetch_objects(struct repository *repo,\n\t\t\t const char *remote_name,\n\t\t\t const struct object_id *oids,\n\t\t\t int oid_nr)\n{\n\tstruct child_process child = CHILD_PROCESS_INIT;\n\tint i;\n\tFILE *child_in;\n\n\t/* TODO: This should use NO_LAZY_FETCH_ENVIRONMENT */\n\tif (git_env_bool(\"GIT_NO_LAZY_FETCH\", 0)) {\n\t\tstatic int warning_shown;\n\t\tif (!warning_shown) {\n\t\t\twarning_shown = 1;\n\t\t\twarning(_(\"lazy fetching disabled; some objects may not be available\"));\n\t\t}\n\t\treturn -1;\n\t}\n\n\tchild.git_cmd = 1;\n\tchild.in = -1;\n\tif (repo != the_repository)\n\t\tprepare_other_repo_env(&child.env, repo->gitdir);\n\tstrvec_pushl(&child.args, \"-c\", \"fetch.negotiationAlgorithm=noop\",\n\t\t     \"fetch\", remote_name, \"--no-tags\",\n\t\t     \"--no-write-fetch-head\", \"--recurse-submodules=no\",\n\t\t     \"--filter=blob:none\", \"--stdin\", NULL);\n\tif (start_command(&child))\n\t\tdie(_(\"promisor-remote: unable to fork off fetch subprocess\"));\n\tchild_in = xfdopen(child.in, \"w\");\n\n\ttrace2_data_intmax(\"promisor\", repo, \"fetch_count\", oid_nr);\n\n\tfor (i = 0; i < oid_nr; i++) {\n\t\tif (fputs(oid_to_hex(&oids[i]), child_in) < 0)\n\t\t\tdie_errno(_(\"promisor-remote: could not write to fetch subprocess\"));\n\t\tif (fputc('\\n', child_in) < 0)\n\t\t\tdie_errno(_(\"promisor-remote: could not write to fetch subprocess\"));\n\t}\n\n\tif (fclose(child_in) < 0)\n\t\tdie_errno(_(\"promisor-remote: could not close stdin to fetch subprocess\"));\n\treturn finish_command(&child) ? -1 : 0;\n}",
      "cve_list": [
        "CVE-2024-32465"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "git",
      "filepath": "builtin/submodule--helper.c",
      "func_name": "clone_submodule",
      "func_body": "static int clone_submodule(const struct module_clone_data *clone_data,\n\t\t\t   struct string_list *reference)\n{\n\tchar *p;\n\tchar *sm_gitdir = clone_submodule_sm_gitdir(clone_data->name);\n\tchar *sm_alternate = NULL, *error_strategy = NULL;\n\tstruct stat st;\n\tstruct child_process cp = CHILD_PROCESS_INIT;\n\tconst char *clone_data_path = clone_data->path;\n\tchar *to_free = NULL;\n\n\tif (!is_absolute_path(clone_data->path))\n\t\tclone_data_path = to_free = xstrfmt(\"%s/%s\", get_git_work_tree(),\n\t\t\t\t\t\t    clone_data->path);\n\n\tif (validate_submodule_git_dir(sm_gitdir, clone_data->name) < 0)\n\t\tdie(_(\"refusing to create/use '%s' in another submodule's \"\n\t\t      \"git dir\"), sm_gitdir);\n\n\tif (!file_exists(sm_gitdir)) {\n\t\tif (clone_data->require_init && !stat(clone_data_path, &st) &&\n\t\t    !is_empty_dir(clone_data_path))\n\t\t\tdie(_(\"directory not empty: '%s'\"), clone_data_path);\n\n\t\tif (safe_create_leading_directories_const(sm_gitdir) < 0)\n\t\t\tdie(_(\"could not create directory '%s'\"), sm_gitdir);\n\n\t\tprepare_possible_alternates(clone_data->name, reference);\n\n\t\tstrvec_push(&cp.args, \"clone\");\n\t\tstrvec_push(&cp.args, \"--no-checkout\");\n\t\tif (clone_data->quiet)\n\t\t\tstrvec_push(&cp.args, \"--quiet\");\n\t\tif (clone_data->progress)\n\t\t\tstrvec_push(&cp.args, \"--progress\");\n\t\tif (clone_data->depth && *(clone_data->depth))\n\t\t\tstrvec_pushl(&cp.args, \"--depth\", clone_data->depth, NULL);\n\t\tif (reference->nr) {\n\t\t\tstruct string_list_item *item;\n\n\t\t\tfor_each_string_list_item(item, reference)\n\t\t\t\tstrvec_pushl(&cp.args, \"--reference\",\n\t\t\t\t\t     item->string, NULL);\n\t\t}\n\t\tif (clone_data->dissociate)\n\t\t\tstrvec_push(&cp.args, \"--dissociate\");\n\t\tif (sm_gitdir && *sm_gitdir)\n\t\t\tstrvec_pushl(&cp.args, \"--separate-git-dir\", sm_gitdir, NULL);\n\t\tif (clone_data->filter_options && clone_data->filter_options->choice)\n\t\t\tstrvec_pushf(&cp.args, \"--filter=%s\",\n\t\t\t\t     expand_list_objects_filter_spec(\n\t\t\t\t\t     clone_data->filter_options));\n\t\tif (clone_data->single_branch >= 0)\n\t\t\tstrvec_push(&cp.args, clone_data->single_branch ?\n\t\t\t\t    \"--single-branch\" :\n\t\t\t\t    \"--no-single-branch\");\n\n\t\tstrvec_push(&cp.args, \"--\");\n\t\tstrvec_push(&cp.args, clone_data->url);\n\t\tstrvec_push(&cp.args, clone_data_path);\n\n\t\tcp.git_cmd = 1;\n\t\tprepare_submodule_repo_env(&cp.env);\n\t\tcp.no_stdin = 1;\n\n\t\tif(run_command(&cp))\n\t\t\tdie(_(\"clone of '%s' into submodule path '%s' failed\"),\n\t\t\t    clone_data->url, clone_data_path);\n\n\t\tif (clone_data->require_init && !stat(clone_data_path, &st) &&\n\t\t    !dir_contains_only_dotgit(clone_data_path)) {\n\t\t\tchar *dot_git = xstrfmt(\"%s/.git\", clone_data_path);\n\t\t\tunlink(dot_git);\n\t\t\tfree(dot_git);\n\t\t\tdie(_(\"directory not empty: '%s'\"), clone_data_path);\n\t\t}\n\t} else {\n\t\tchar *path;\n\n\t\tif (clone_data->require_init && !access(clone_data_path, X_OK) &&\n\t\t    !is_empty_dir(clone_data_path))\n\t\t\tdie(_(\"directory not empty: '%s'\"), clone_data_path);\n\t\tif (safe_create_leading_directories_const(clone_data_path) < 0)\n\t\t\tdie(_(\"could not create directory '%s'\"), clone_data_path);\n\t\tpath = xstrfmt(\"%s/index\", sm_gitdir);\n\t\tunlink_or_warn(path);\n\t\tfree(path);\n\t}\n\n\t/*\n\t * We already performed this check at the beginning of this function,\n\t * before cloning the objects. This tries to detect racy behavior e.g.\n\t * in parallel clones, where another process could easily have made the\n\t * gitdir nested _after_ it was created.\n\t *\n\t * To prevent further harm coming from this unintentionally-nested\n\t * gitdir, let's disable it by deleting the `HEAD` file.\n\t */\n\tif (validate_submodule_git_dir(sm_gitdir, clone_data->name) < 0) {\n\t\tchar *head = xstrfmt(\"%s/HEAD\", sm_gitdir);\n\t\tunlink(head);\n\t\tfree(head);\n\t\tdie(_(\"refusing to create/use '%s' in another submodule's \"\n\t\t      \"git dir\"), sm_gitdir);\n\t}\n\n\tconnect_work_tree_and_git_dir(clone_data_path, sm_gitdir, 0);\n\n\tp = git_pathdup_submodule(clone_data_path, \"config\");\n\tif (!p)\n\t\tdie(_(\"could not get submodule directory for '%s'\"), clone_data_path);\n\n\t/* setup alternateLocation and alternateErrorStrategy in the cloned submodule if needed */\n\tgit_config_get_string(\"submodule.alternateLocation\", &sm_alternate);\n\tif (sm_alternate)\n\t\tgit_config_set_in_file(p, \"submodule.alternateLocation\",\n\t\t\t\t       sm_alternate);\n\tgit_config_get_string(\"submodule.alternateErrorStrategy\", &error_strategy);\n\tif (error_strategy)\n\t\tgit_config_set_in_file(p, \"submodule.alternateErrorStrategy\",\n\t\t\t\t       error_strategy);\n\n\tfree(sm_alternate);\n\tfree(error_strategy);\n\n\tfree(sm_gitdir);\n\tfree(p);\n\tfree(to_free);\n\treturn 0;\n}",
      "cve_list": [
        "CVE-2024-32002"
      ],
      "cwe_list": [
        "CWE-59"
      ]
    },
    {
      "project": "git",
      "filepath": "builtin/submodule--helper.c",
      "func_name": "dir_contains_only_dotgit",
      "func_body": "static int dir_contains_only_dotgit(const char *path)\n{\n\tDIR *dir = opendir(path);\n\tstruct dirent *e;\n\tint ret = 1;\n\n\tif (!dir)\n\t\treturn 0;\n\n\te = readdir_skip_dot_and_dotdot(dir);\n\tif (!e)\n\t\tret = 0;\n\telse if (strcmp(DEFAULT_GIT_DIR_ENVIRONMENT, e->d_name) ||\n\t\t (e = readdir_skip_dot_and_dotdot(dir))) {\n\t\terror(\"unexpected item '%s' in '%s'\", e->d_name, path);\n\t\tret = 0;\n\t}\n\n\tclosedir(dir);\n\treturn ret;\n}",
      "cve_list": [
        "CVE-2024-32002"
      ],
      "cwe_list": [
        "CWE-59"
      ]
    },
    {
      "project": "libuv",
      "filepath": "src/idna.c",
      "func_name": "uv__idna_toascii",
      "func_body": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n  ds = d;\n\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c != '.')\n      if (c != 0x3002)  /*  */\n        if (c != 0xFF0E)  /*  */\n          if (c != 0xFF61)  /*  */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d >= de)\n    return UV_EINVAL;\n\n  *d++ = '\\0';\n  return d - ds;  /* Number of bytes written. */\n}",
      "cve_list": [
        "CVE-2024-24806"
      ],
      "cwe_list": [
        "CWE-918"
      ]
    },
    {
      "project": "libuv",
      "filepath": "test/test-idna.c",
      "func_name": "TEST_IMPL",
      "func_body": "TEST_IMPL(utf8_decode1_overrun) {\n  const char* p;\n  char b[1];\n  char c[1];\n\n  /* Single byte. */\n  p = b;\n  b[0] = 0x7F;\n  ASSERT_EQ(0x7F, uv__utf8_decode1(&p, b + 1));\n  ASSERT_PTR_EQ(p, b + 1);\n\n  /* Multi-byte. */\n  p = b;\n  b[0] = 0xC0;\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + 1));\n  ASSERT_PTR_EQ(p, b + 1);\n\n  b[0] = 0x7F;\n  ASSERT_EQ(UV_EINVAL, uv__idna_toascii(b, b + 1, c, c + 1));\n\n  return 0;\n}",
      "cve_list": [
        "CVE-2024-24806"
      ],
      "cwe_list": [
        "CWE-918"
      ]
    },
    {
      "project": "libuv",
      "filepath": "src/idna.c",
      "func_name": "uv__idna_toascii",
      "func_body": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n  if (s == se)\n    return UV_EINVAL;\n\n  ds = d;\n\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c != '.')\n      if (c != 0x3002)  /*  */\n        if (c != 0xFF0E)  /*  */\n          if (c != 0xFF61)  /*  */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d >= de)\n    return UV_EINVAL;\n\n  *d++ = '\\0';\n  return d - ds;  /* Number of bytes written. */\n}",
      "cve_list": [
        "CVE-2024-24806"
      ],
      "cwe_list": [
        "CWE-918"
      ]
    },
    {
      "project": "libuv",
      "filepath": "test/test-idna.c",
      "func_name": "TEST_IMPL",
      "func_body": "TEST_IMPL(utf8_decode1_overrun) {\n  const char* p;\n  char b[1];\n  char c[1];\n\n  /* Single byte. */\n  p = b;\n  b[0] = 0x7F;\n  ASSERT_EQ(0x7F, uv__utf8_decode1(&p, b + 1));\n  ASSERT_PTR_EQ(p, b + 1);\n\n  /* Multi-byte. */\n  p = b;\n  b[0] = 0xC0;\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + 1));\n  ASSERT_PTR_EQ(p, b + 1);\n\n  b[0] = 0x7F;\n  ASSERT_EQ(UV_EINVAL, uv__idna_toascii(b, b + 0, c, c + 1));\n  ASSERT_EQ(UV_EINVAL, uv__idna_toascii(b, b + 1, c, c + 1));\n\n  return 0;\n}",
      "cve_list": [
        "CVE-2024-24806"
      ],
      "cwe_list": [
        "CWE-918"
      ]
    },
    {
      "project": "libuv",
      "filepath": "test/test-idna.c",
      "func_name": "TEST_IMPL",
      "func_body": "TEST_IMPL(idna_toascii) {\n  /* Illegal inputs. */\n  F(\"\\xC0\\x80\\xC1\\x80\", UV_EINVAL);  /* Overlong UTF-8 sequence. */\n  F(\"\\xC0\\x80\\xC1\\x80.com\", UV_EINVAL);  /* Overlong UTF-8 sequence. */\n  F(\"\", UV_EINVAL);\n  /* No conversion. */\n  T(\".\", \".\");\n  T(\".com\", \".com\");\n  T(\"example\", \"example\");\n  T(\"example-\", \"example-\");\n  T(\"strae.de\", \"xn--strae-oqa.de\");\n  /* Test cases adapted from punycode.js. Most are from RFC 3492. */\n  T(\"foo.bar\", \"foo.bar\");\n  T(\"maana.com\", \"xn--maana-pta.com\");\n  T(\"example.com.\", \"example.com.\");\n  T(\"bcher.com\", \"xn--bcher-kva.com\");\n  T(\"caf.com\", \"xn--caf-dma.com\");\n  T(\"caf.caf.com\", \"xn--caf-dma.xn--caf-dma.com\");\n  T(\"-.com\", \"xn----dqo34k.com\");\n  T(\"-.com\", \"xn----dqo34kn65z.com\");\n  T(\".la\", \"xn--ls8h.la\");\n  T(\"maana.com\", \"xn--maana-pta.com\");\n  T(\"maanacom\", \"xn--maana-pta.com\");\n  T(\"maanacom\", \"xn--maana-pta.com\");\n  T(\"maanacom\", \"xn--maana-pta.com\");\n  T(\"\", \"xn--tda\");\n  T(\".\", \".xn--tda\");\n  T(\".\", \"xn--tda.xn--tda\");\n  T(\"..\", \"xn--tda.xn--tda.\");\n  T(\"\", \"xn--4can8av2009b\");\n  T(\"Willst du die Blthe des frhen, die Frchte des spteren Jahres\",\n    \"xn--Willst du die Blthe des frhen, \"\n    \"die Frchte des spteren Jahres-x9e96lkal\");\n  T(\"\", \"xn--egbpdaj6bu4bxfgehfvwxn\");\n  T(\"\", \"xn--ihqwcrb4cv8a8dqg056pqjye\");\n  T(\"\", \"xn--ihqwctvzc91f659drss3x8bo0yb\");\n  T(\"Proprostnemluvesky\", \"xn--Proprostnemluvesky-uyb24dma41a\");\n  T(\"\", \"xn--4dbcagdahymbxekheh6e0a7fei0b\");\n  T(\"\",\n    \"xn--i1baa7eci9glrd9b2ae1bj0hfcgg6iyaf8o0a1dig0cd\");\n  T(\"\",\n    \"xn--n8jok5ay5dzabd5bym9f0cm5685rrjetr6pdxa\");\n  T(\"\",\n    \"xn--989aomsvi5e83db1d2a355cv1e0vak1d\"\n    \"wrv93d5xbh15a0dt30a5jpsd879ccm6fea98c\");\n  T(\"\", \"xn--b1abfaaepdrnnbgefbadotcwatmq2g4l\");\n  T(\"PorqunopuedensimplementehablarenEspaol\",\n    \"xn--PorqunopuedensimplementehablarenEspaol-fmd56a\");\n  T(\"TisaohkhngthchnitingVit\",\n    \"xn--TisaohkhngthchnitingVit-kjcr8268qyxafd2f1b9g\");\n  T(\"3B\", \"xn--3B-ww4c5e180e575a65lsy2b\");\n  T(\"-with-SUPER-MONKEYS\",\n    \"xn---with-SUPER-MONKEYS-pc58ag80a8qai00g7n9n\");\n  T(\"Hello-Another-Way-\",\n    \"xn--Hello-Another-Way--fc4qua05auwb3674vfr0b\");\n  T(\"2\", \"xn--2-u9tlzr9756bt3uc0v\");\n  T(\"MajiKoi5\", \"xn--MajiKoi5-783gue6qz075azm5e\");\n  T(\"de\", \"xn--de-jg4avhby1noc0d\");\n  T(\"\", \"xn--d9juau41awczczp\");\n  T(\"-> $1.00 <-\", \"-> $1.00 <-\");\n  /* Test cases from https://unicode.org/reports/tr46/ */\n  T(\"fa.de\", \"xn--fa-hia.de\");\n  T(\".com\", \"xn--nxasmm1c.com\");\n  T(\".com\", \"xn--10cl1a0b660p.com\");\n  T(\".com\", \"xn--mgba3gch31f060k.com\");\n  return 0;\n}",
      "cve_list": [
        "CVE-2024-24806"
      ],
      "cwe_list": [
        "CWE-918"
      ]
    },
    {
      "project": "vim",
      "filepath": "src/map.c",
      "func_name": "did_set_langmap",
      "func_body": "did_set_langmap(optset_T *args UNUSED)\n{\n    char_u  *p;\n    char_u  *p2;\n    int\t    from, to;\n\n    ga_clear(&langmap_mapga);\t\t    // clear the previous map first\n    langmap_init();\t\t\t    // back to one-to-one map\n\n    for (p = p_langmap; p[0] != NUL; )\n    {\n\tfor (p2 = p; p2[0] != NUL && p2[0] != ',' && p2[0] != ';';\n\t\t\t\t\t\t\t       MB_PTR_ADV(p2))\n\t{\n\t    if (p2[0] == '\\\\' && p2[1] != NUL)\n\t\t++p2;\n\t}\n\tif (p2[0] == ';')\n\t    ++p2;\t    // abcd;ABCD form, p2 points to A\n\telse\n\t    p2 = NULL;\t    // aAbBcCdD form, p2 is NULL\n\twhile (p[0])\n\t{\n\t    if (p[0] == ',')\n\t    {\n\t\t++p;\n\t\tbreak;\n\t    }\n\t    if (p[0] == '\\\\' && p[1] != NUL)\n\t\t++p;\n\t    from = (*mb_ptr2char)(p);\n\t    to = NUL;\n\t    if (p2 == NULL)\n\t    {\n\t\tMB_PTR_ADV(p);\n\t\tif (p[0] != ',')\n\t\t{\n\t\t    if (p[0] == '\\\\')\n\t\t\t++p;\n\t\t    to = (*mb_ptr2char)(p);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (p2[0] != ',')\n\t\t{\n\t\t    if (p2[0] == '\\\\')\n\t\t\t++p2;\n\t\t    to = (*mb_ptr2char)(p2);\n\t\t}\n\t    }\n\t    if (to == NUL)\n\t    {\n\t\tsprintf(args->os_errbuf,\n\t\t\t_(e_langmap_matching_character_missing_for_str),\n\t\t\ttranschar(from));\n\t\treturn args->os_errbuf;\n\t    }\n\n\t    if (from >= 256)\n\t\tlangmap_set_entry(from, to);\n\t    else\n\t\tlangmap_mapchar[from & 255] = to;\n\n\t    // Advance to next pair\n\t    MB_PTR_ADV(p);\n\t    if (p2 != NULL)\n\t    {\n\t\tMB_PTR_ADV(p2);\n\t\tif (*p == ';')\n\t\t{\n\t\t    p = p2;\n\t\t    if (p[0] != NUL)\n\t\t    {\n\t\t\tif (p[0] != ',')\n\t\t\t{\n\t\t\t    snprintf(args->os_errbuf, args->os_errbuflen,\n\t\t\t\t    _(e_langmap_extra_characters_after_semicolon_str),\n\t\t\t\t    p);\n\t\t\t    return args->os_errbuf;\n\t\t\t}\n\t\t\t++p;\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n\n    return NULL;\n}",
      "cve_list": [
        "CVE-2024-22667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "vim",
      "filepath": "src/option.c",
      "func_name": "do_set",
      "func_body": "do_set(\n    char_u\t*arg_start,\t// option string (may be written to!)\n    int\t\topt_flags)\n{\n    char_u\t*arg = arg_start;\n    int\t\ti;\n    int\t\tdid_show = FALSE;   // already showed one value\n\n    if (*arg == NUL)\n    {\n\tshowoptions(0, opt_flags);\n\tdid_show = TRUE;\n\tgoto theend;\n    }\n\n    while (*arg != NUL)\t\t// loop to process all options\n    {\n\tif (STRNCMP(arg, \"all\", 3) == 0 && !ASCII_ISALPHA(arg[3])\n\t\t\t\t\t\t&& !(opt_flags & OPT_MODELINE))\n\t{\n\t    // \":set all\"  show all options.\n\t    // \":set all&\" set all options to their default value.\n\t    arg += 3;\n\t    if (*arg == '&')\n\t    {\n\t\t++arg;\n\t\t// Only for :set command set global value of local options.\n\t\tset_options_default(OPT_FREE | opt_flags);\n\t\tdidset_options();\n\t\tdidset_options2();\n\t\tredraw_all_later(UPD_CLEAR);\n\t    }\n\t    else\n\t    {\n\t\tshowoptions(1, opt_flags);\n\t\tdid_show = TRUE;\n\t    }\n\t}\n\telse if (STRNCMP(arg, \"termcap\", 7) == 0 && !(opt_flags & OPT_MODELINE))\n\t{\n\t    showoptions(2, opt_flags);\n\t    show_termcodes(opt_flags);\n\t    did_show = TRUE;\n\t    arg += 7;\n\t}\n\telse\n\t{\n\t    int\t\tstopopteval = FALSE;\n\t    char\t*errmsg = NULL;\n\t    char\terrbuf[ERR_BUFLEN];\n\t    char_u\t*startarg = arg;\n\n\t    errmsg = do_set_option(opt_flags, &arg, arg_start, &startarg,\n\t\t\t\t\t&did_show, &stopopteval, errbuf,\n\t\t\t\t\tERR_BUFLEN);\n\t    if (stopopteval)\n\t\tbreak;\n\n\t    // Advance to next argument.\n\t    // - skip until a blank found, taking care of backslashes\n\t    // - skip blanks\n\t    // - skip one \"=val\" argument (for hidden options \":set gfn =xx\")\n\t    for (i = 0; i < 2 ; ++i)\n\t    {\n\t\twhile (*arg != NUL && !VIM_ISWHITE(*arg))\n\t\t    if (*arg++ == '\\\\' && *arg != NUL)\n\t\t\t++arg;\n\t\targ = skipwhite(arg);\n\t\tif (*arg != '=')\n\t\t    break;\n\t    }\n\n\t    if (errmsg != NULL)\n\t    {\n\t\tvim_strncpy(IObuff, (char_u *)_(errmsg), IOSIZE - 1);\n\t\ti = (int)STRLEN(IObuff) + 2;\n\t\tif (i + (arg - startarg) < IOSIZE)\n\t\t{\n\t\t    // append the argument with the error\n\t\t    STRCAT(IObuff, \": \");\n\t\t    mch_memmove(IObuff + i, startarg, (arg - startarg));\n\t\t    IObuff[i + (arg - startarg)] = NUL;\n\t\t}\n\t\t// make sure all characters are printable\n\t\ttrans_characters(IObuff, IOSIZE);\n\n\t\t++no_wait_return;\t\t// wait_return() done later\n\t\temsg((char *)IObuff);\t// show error highlighted\n\t\t--no_wait_return;\n\n\t\treturn FAIL;\n\t    }\n\t}\n\n\targ = skipwhite(arg);\n    }\n\ntheend:\n    if (silent_mode && did_show)\n    {\n\t// After displaying option values in silent mode.\n\tsilent_mode = FALSE;\n\tinfo_message = TRUE;\t// use mch_msg(), not mch_errmsg()\n\tmsg_putchar('\\n');\n\tcursor_on();\t\t// msg_start() switches it off\n\tout_flush();\n\tsilent_mode = TRUE;\n\tinfo_message = FALSE;\t// use mch_msg(), not mch_errmsg()\n    }\n\n    return OK;\n}",
      "cve_list": [
        "CVE-2024-22667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "vim",
      "filepath": "src/option.c",
      "func_name": "do_set_option_string",
      "func_body": "do_set_option_string(\n\tint\t    opt_idx,\n\tint\t    opt_flags,\n\tchar_u\t    **argp,\n\tint\t    nextchar,\n\tset_op_T    op_arg,\n\tlong_u\t    flags,\n\tint\t    cp_val,\n\tchar_u\t    *varp_arg,\n\tchar\t    *errbuf,\n\tint\t    errbuflen,\n\tint\t    *value_checked,\n\tchar\t    **errmsg)\n{\n    char_u\t*arg = *argp;\n    set_op_T    op = op_arg;\n    char_u\t*varp = varp_arg;\n    char_u\t*oldval = NULL; // previous value if *varp\n    char_u\t*newval;\n    char_u\t*origval = NULL;\n    char_u\t*origval_l = NULL;\n    char_u\t*origval_g = NULL;\n#if defined(FEAT_EVAL)\n    char_u\t*saved_origval = NULL;\n    char_u\t*saved_origval_l = NULL;\n    char_u\t*saved_origval_g = NULL;\n    char_u\t*saved_newval = NULL;\n#endif\n\n    // When using \":set opt=val\" for a global option\n    // with a local value the local value will be\n    // reset, use the global value here.\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n\t    && ((int)options[opt_idx].indir & PV_BOTH))\n\tvarp = options[opt_idx].var;\n\n    // The old value is kept until we are sure that the new value is valid.\n    oldval = *(char_u **)varp;\n\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n    {\n\torigval_l = *(char_u **)get_varp_scope(\n\t\t\t   &(options[opt_idx]), OPT_LOCAL);\n\torigval_g = *(char_u **)get_varp_scope(\n\t\t\t  &(options[opt_idx]), OPT_GLOBAL);\n\n\t// A global-local string option might have an empty option as value to\n\t// indicate that the global value should be used.\n\tif (((int)options[opt_idx].indir & PV_BOTH)\n\t\t\t\t\t\t  && origval_l == empty_option)\n\t    origval_l = origval_g;\n    }\n\n    // When setting the local value of a global option, the old value may be\n    // the global value.\n    if (((int)options[opt_idx].indir & PV_BOTH) && (opt_flags & OPT_LOCAL))\n\torigval = *(char_u **)get_varp(&options[opt_idx]);\n    else\n\torigval = oldval;\n\n    // Get the new value for the option\n    newval = stropt_get_newval(nextchar, opt_idx, &arg, varp, &origval,\n\t\t\t\t&origval_l, &origval_g, &oldval, &op, flags,\n\t\t\t\tcp_val);\n\n    // Set the new value.\n    *(char_u **)(varp) = newval;\n    if (newval == NULL)\n\t*(char_u **)(varp) = empty_option;\n\n#if defined(FEAT_EVAL)\n    if (!starting\n# ifdef FEAT_CRYPT\n\t    && options[opt_idx].indir != PV_KEY\n# endif\n\t\t      && origval != NULL && newval != NULL)\n    {\n\t// origval may be freed by did_set_string_option(), make a copy.\n\tsaved_origval = vim_strsave(origval);\n\t// newval (and varp) may become invalid if the buffer is closed by\n\t// autocommands.\n\tsaved_newval = vim_strsave(newval);\n\tif (origval_l != NULL)\n\t    saved_origval_l = vim_strsave(origval_l);\n\tif (origval_g != NULL)\n\t    saved_origval_g = vim_strsave(origval_g);\n    }\n#endif\n\n    {\n\tlong_u\t*p = insecure_flag(opt_idx, opt_flags);\n\tint\tsecure_saved = secure;\n\n\t// When an option is set in the sandbox, from a modeline or in secure\n\t// mode, then deal with side effects in secure mode.  Also when the\n\t// value was set with the P_INSECURE flag and is not completely\n\t// replaced.\n\tif ((opt_flags & OPT_MODELINE)\n#ifdef HAVE_SANDBOX\n\t      || sandbox != 0\n#endif\n\t      || (op != OP_NONE && (*p & P_INSECURE)))\n\t    secure = 1;\n\n\t// Handle side effects, and set the global value for \":set\" on local\n\t// options. Note: when setting 'syntax' or 'filetype' autocommands may\n\t// be triggered that can cause havoc.\n\t*errmsg = did_set_string_option(\n\t\t\topt_idx, (char_u **)varp, oldval, newval, errbuf,\n\t\t\terrbuflen, opt_flags, op, value_checked);\n\n\tsecure = secure_saved;\n    }\n\n#if defined(FEAT_EVAL)\n    if (*errmsg == NULL)\n\ttrigger_optionset_string(opt_idx, opt_flags, saved_origval,\n\t\t\t       saved_origval_l, saved_origval_g, saved_newval);\n    vim_free(saved_origval);\n    vim_free(saved_origval_l);\n    vim_free(saved_origval_g);\n    vim_free(saved_newval);\n#endif\n\n    *argp = arg;\n    return *errmsg == NULL ? OK : FAIL;\n}",
      "cve_list": [
        "CVE-2024-22667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "vim",
      "filepath": "src/option.c",
      "func_name": "do_set_option_value",
      "func_body": "do_set_option_value(\n    int\t\topt_idx,\n    int\t\topt_flags,\n    char_u\t**argp,\n    set_prefix_T prefix,\n    set_op_T\top,\n    long_u\tflags,\n    char_u\t*varp,\n    char_u\t*key_name,\n    int\t\tnextchar,\n    int\t\tafterchar,\n    int\t\tcp_val,\n    int\t\t*stopopteval,\n    char\t*errbuf,\n    size_t\terrbuflen)\n{\n    int\t\tvalue_checked = FALSE;\n    char\t*errmsg = NULL;\n    char_u\t*arg = *argp;\n\n    if (flags & P_BOOL)\n    {\n\t// boolean option\n\terrmsg = do_set_option_bool(opt_idx, opt_flags, prefix, flags, varp,\n\t\t\t\t\t\tnextchar, afterchar, cp_val);\n\tif (errmsg != NULL)\n\t    goto skip;\n    }\n    else\n    {\n\t// numeric or string option\n\tif (vim_strchr((char_u *)\"=:&<\", nextchar) == NULL\n\t\t|| prefix != PREFIX_NONE)\n\t{\n\t    errmsg = e_invalid_argument;\n\t    goto skip;\n\t}\n\n\tif (flags & P_NUM)\n\t{\n\t    // numeric option\n\t    errmsg = do_set_option_numeric(opt_idx, opt_flags, &arg, nextchar,\n\t\t\t\t\t\top, flags, cp_val, varp,\n\t\t\t\t\t\terrbuf, errbuflen);\n\t    if (errmsg != NULL)\n\t\tgoto skip;\n\t}\n\telse if (opt_idx >= 0)\n\t{\n\t    // string option\n\t    if (do_set_option_string(opt_idx, opt_flags, &arg, nextchar, op,\n\t\t\t\t\tflags, cp_val, varp, errbuf, errbuflen,\n\t\t\t\t\t&value_checked, &errmsg) == FAIL)\n\t    {\n\t\tif (errmsg != NULL)\n\t\t    goto skip;\n\t\t*stopopteval = TRUE;\n\t\tgoto skip;\n\t    }\n\t}\n\telse\n\t{\n\t    // key code option\n\t    errmsg = do_set_option_keycode(&arg, key_name, nextchar);\n\t    if (errmsg != NULL)\n\t\tgoto skip;\n\t}\n    }\n\n    if (opt_idx >= 0)\n\tdid_set_option(opt_idx, opt_flags, op == OP_NONE, value_checked);\n\nskip:\n    *argp = arg;\n    return errmsg;\n}",
      "cve_list": [
        "CVE-2024-22667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "vim",
      "filepath": "src/option.c",
      "func_name": "set_option_value",
      "func_body": "set_option_value(\n    char_u\t*name,\n    long\tnumber,\n    char_u\t*string,\n    int\t\topt_flags)\t// OPT_LOCAL or 0 (both)\n{\n    int\t\topt_idx;\n    char_u\t*varp;\n    long_u\tflags;\n    static char\terrbuf[ERR_BUFLEN];\n    int\t\terrbuflen = ERR_BUFLEN;\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\n    {\n\tint key;\n\n\tif (STRLEN(name) == 4 && name[0] == 't' && name[1] == '_'\n\t\t&& (key = find_key_option(name, FALSE)) != 0)\n\t{\n\t    char_u key_name[2];\n\n\t    if (key < 0)\n\t    {\n\t\tkey_name[0] = KEY2TERMCAP0(key);\n\t\tkey_name[1] = KEY2TERMCAP1(key);\n\t    }\n\t    else\n\t    {\n\t\tkey_name[0] = KS_KEY;\n\t\tkey_name[1] = (key & 0xff);\n\t    }\n\t    add_termcode(key_name, string, FALSE);\n\t    if (full_screen)\n\t\tttest(FALSE);\n\t    redraw_all_later(UPD_CLEAR);\n\t    return NULL;\n\t}\n\n\tsemsg(_(e_unknown_option_str_2), name);\n    }\n    else\n    {\n\tflags = options[opt_idx].flags;\n#ifdef HAVE_SANDBOX\n\t// Disallow changing some options in the sandbox\n\tif (sandbox > 0 && (flags & P_SECURE))\n\t{\n\t    emsg(_(e_not_allowed_in_sandbox));\n\t    return NULL;\n\t}\n#endif\n\tif (flags & P_STRING)\n\t    return set_string_option(opt_idx, string, opt_flags, errbuf, errbuflen);\n\n\tvarp = get_varp_scope(&(options[opt_idx]), opt_flags);\n\tif (varp != NULL)\t// hidden option is not changed\n\t{\n\t    if (number == 0 && string != NULL)\n\t    {\n\t\tint idx;\n\n\t\t// Either we are given a string or we are setting option\n\t\t// to zero.\n\t\tfor (idx = 0; string[idx] == '0'; ++idx)\n\t\t    ;\n\t\tif (string[idx] != NUL || idx == 0)\n\t\t{\n\t\t    // There's another character after zeros or the string\n\t\t    // is empty.  In both cases, we are trying to set a\n\t\t    // num option using a string.\n\t\t    semsg(_(e_number_required_after_str_equal_str),\n\t\t\t\t\t\t\t\t name, string);\n\t\t    return NULL;     // do nothing as we hit an error\n\n\t\t}\n\t    }\n\t    if (flags & P_NUM)\n\t    {\n\t\treturn set_num_option(opt_idx, varp, number,\n\t\t\t\t\t   errbuf, sizeof(errbuf), opt_flags);\n\t    }\n\t    else\n\t\treturn set_bool_option(opt_idx, varp, (int)number, opt_flags);\n\t}\n\n    }\n    return NULL;\n}",
      "cve_list": [
        "CVE-2024-22667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "vim",
      "filepath": "src/optionstr.c",
      "func_name": "check_stl_option",
      "func_body": "check_stl_option(char_u *s)\n{\n    int\t\tgroupdepth = 0;\n    static char errbuf[ERR_BUFLEN];\n    int\t\terrbuflen = ERR_BUFLEN;\n\n    while (*s)\n    {\n\t// Check for valid keys after % sequences\n\twhile (*s && *s != '%')\n\t    s++;\n\tif (!*s)\n\t    break;\n\ts++;\n\tif (*s == '%' || *s == STL_TRUNCMARK || *s == STL_SEPARATE)\n\t{\n\t    s++;\n\t    continue;\n\t}\n\tif (*s == ')')\n\t{\n\t    s++;\n\t    if (--groupdepth < 0)\n\t\tbreak;\n\t    continue;\n\t}\n\tif (*s == '-')\n\t    s++;\n\twhile (VIM_ISDIGIT(*s))\n\t    s++;\n\tif (*s == STL_USER_HL)\n\t    continue;\n\tif (*s == '.')\n\t{\n\t    s++;\n\t    while (*s && VIM_ISDIGIT(*s))\n\t\ts++;\n\t}\n\tif (*s == '(')\n\t{\n\t    groupdepth++;\n\t    continue;\n\t}\n\tif (vim_strchr(STL_ALL, *s) == NULL)\n\t{\n\t    return illegal_char(errbuf, errbuflen, *s);\n\t}\n\tif (*s == '{')\n\t{\n\t    int reevaluate = (*++s == '%');\n\n\t    if (reevaluate && *++s == '}')\n\t\t// \"}\" is not allowed immediately after \"%{%\"\n\t\treturn illegal_char(errbuf, errbuflen, '}');\n\t    while ((*s != '}' || (reevaluate && s[-1] != '%')) && *s)\n\t\ts++;\n\t    if (*s != '}')\n\t\treturn e_unclosed_expression_sequence;\n\t}\n    }\n    if (groupdepth != 0)\n\treturn e_unbalanced_groups;\n    return NULL;\n}",
      "cve_list": [
        "CVE-2024-22667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "vim",
      "filepath": "src/optionstr.c",
      "func_name": "did_set_comments",
      "func_body": "did_set_comments(optset_T *args)\n{\n    char_u\t**varp = (char_u **)args->os_varp;\n    char_u\t*s;\n    char\t*errmsg = NULL;\n\n    for (s = *varp; *s; )\n    {\n\twhile (*s && *s != ':')\n\t{\n\t    if (vim_strchr((char_u *)COM_ALL, *s) == NULL\n\t\t    && !VIM_ISDIGIT(*s) && *s != '-')\n\t    {\n\t\terrmsg = illegal_char(args->os_errbuf, args->os_errbuflen, *s);\n\t\tbreak;\n\t    }\n\t    ++s;\n\t}\n\tif (*s++ == NUL)\n\t    errmsg = e_missing_colon;\n\telse if (*s == ',' || *s == NUL)\n\t    errmsg = e_zero_length_string;\n\tif (errmsg != NULL)\n\t    break;\n\twhile (*s && *s != ',')\n\t{\n\t    if (*s == '\\\\' && s[1] != NUL)\n\t\t++s;\n\t    ++s;\n\t}\n\ts = skip_to_option_part(s);\n    }\n\n    return errmsg;\n}",
      "cve_list": [
        "CVE-2024-22667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "vim",
      "filepath": "src/optionstr.c",
      "func_name": "did_set_complete",
      "func_body": "did_set_complete(optset_T *args)\n{\n    char_u\t**varp = (char_u **)args->os_varp;\n    char_u\t*s;\n\n    // check if it is a valid value for 'complete' -- Acevedo\n    for (s = *varp; *s;)\n    {\n\twhile (*s == ',' || *s == ' ')\n\t    s++;\n\tif (!*s)\n\t    break;\n\tif (vim_strchr((char_u *)\".wbuksid]tU\", *s) == NULL)\n\t    return illegal_char(args->os_errbuf, args->os_errbuflen, *s);\n\tif (*++s != NUL && *s != ',' && *s != ' ')\n\t{\n\t    if (s[-1] == 'k' || s[-1] == 's')\n\t    {\n\t\t// skip optional filename after 'k' and 's'\n\t\twhile (*s && *s != ',' && *s != ' ')\n\t\t{\n\t\t    if (*s == '\\\\' && s[1] != NUL)\n\t\t\t++s;\n\t\t    ++s;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (args->os_errbuf != NULL)\n\t\t{\n\t\t    snprintf((char *)args->os_errbuf, args->os_errbuflen,\n\t\t\t    _(e_illegal_character_after_chr), *--s);\n\t\t    return args->os_errbuf;\n\t\t}\n\t\treturn \"\";\n\t    }\n\t}\n    }\n\n    return NULL;\n}",
      "cve_list": [
        "CVE-2024-22667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "vim",
      "filepath": "src/optionstr.c",
      "func_name": "did_set_concealcursor",
      "func_body": "did_set_concealcursor(optset_T *args)\n{\n    char_u\t**varp = (char_u **)args->os_varp;\n\n    return did_set_option_listflag(*varp, (char_u *)COCU_ALL, args->os_errbuf,\n\t\t    args->os_errbuflen);\n}",
      "cve_list": [
        "CVE-2024-22667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "vim",
      "filepath": "src/optionstr.c",
      "func_name": "did_set_cpoptions",
      "func_body": "did_set_cpoptions(optset_T *args)\n{\n    char_u\t**varp = (char_u **)args->os_varp;\n\n    return did_set_option_listflag(*varp, (char_u *)CPO_ALL, args->os_errbuf,\n\t\t    args->os_errbuflen);\n}",
      "cve_list": [
        "CVE-2024-22667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "vim",
      "filepath": "src/optionstr.c",
      "func_name": "did_set_formatoptions",
      "func_body": "did_set_formatoptions(optset_T *args)\n{\n    char_u\t**varp = (char_u **)args->os_varp;\n\n    return did_set_option_listflag(*varp, (char_u *)FO_ALL, args->os_errbuf,\n\t\t    args->os_errbuflen);\n}",
      "cve_list": [
        "CVE-2024-22667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "vim",
      "filepath": "src/optionstr.c",
      "func_name": "did_set_guioptions",
      "func_body": "did_set_guioptions(optset_T *args)\n{\n    char_u\t**varp = (char_u **)args->os_varp;\n    char *errmsg;\n\n    errmsg = did_set_option_listflag(*varp, (char_u *)GO_ALL, args->os_errbuf,\n\t\t    args->os_errbuflen);\n    if (errmsg != NULL)\n\treturn errmsg;\n\n    gui_init_which_components(args->os_oldval.string);\n    return NULL;\n}",
      "cve_list": [
        "CVE-2024-22667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "vim",
      "filepath": "src/optionstr.c",
      "func_name": "did_set_mouse",
      "func_body": "did_set_mouse(optset_T *args)\n{\n    char_u\t**varp = (char_u **)args->os_varp;\n\n    return did_set_option_listflag(*varp, (char_u *)MOUSE_ALL, args->os_errbuf,\n\t\t    args->os_errbuflen);\n}",
      "cve_list": [
        "CVE-2024-22667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "vim",
      "filepath": "src/optionstr.c",
      "func_name": "did_set_option_listflag",
      "func_body": "did_set_option_listflag(\n\tchar_u *val,\n\tchar_u *flags,\n\tchar *errbuf,\n\tint errbuflen)\n{\n    char_u\t*s;\n\n    for (s = val; *s; ++s)\n\tif (vim_strchr(flags, *s) == NULL)\n\t    return illegal_char(errbuf, errbuflen, *s);\n\n    return NULL;\n}",
      "cve_list": [
        "CVE-2024-22667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "vim",
      "filepath": "src/optionstr.c",
      "func_name": "did_set_shortmess",
      "func_body": "did_set_shortmess(optset_T *args)\n{\n    char_u\t**varp = (char_u **)args->os_varp;\n\n    return did_set_option_listflag(*varp, (char_u *)SHM_ALL, args->os_errbuf,\n\t\t    args->os_errbuflen);\n}",
      "cve_list": [
        "CVE-2024-22667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "vim",
      "filepath": "src/optionstr.c",
      "func_name": "did_set_string_option",
      "func_body": "did_set_string_option(\n    int\t\topt_idx,\t\t// index in options[] table\n    char_u\t**varp,\t\t\t// pointer to the option variable\n    char_u\t*oldval,\t\t// previous value of the option\n    char_u\t*value,\t\t\t// new value of the option\n    char\t*errbuf,\t\t// buffer for errors, or NULL\n    int\t\terrbuflen,\t\t// length of error buffer\n    int\t\topt_flags,\t\t// OPT_LOCAL and/or OPT_GLOBAL\n    set_op_T    op,\t\t\t// OP_ADDING/OP_PREPENDING/OP_REMOVING\n    int\t\t*value_checked)\t\t// value was checked to be safe, no\n\t\t\t\t\t// need to set P_INSECURE\n{\n    char\t*errmsg = NULL;\n    long_u\tfree_oldval = (get_option_flags(opt_idx) & P_ALLOCED);\n    opt_did_set_cb_T did_set_cb = get_option_did_set_cb(opt_idx);\n    optset_T\targs;\n\n    // 'ttytype' is an alias for 'term'.  Both 'term' and 'ttytype' point to\n    // T_NAME.  If 'term' or 'ttytype' is modified, then use the index for the\n    // 'term' option.  Only set the P_ALLOCED flag on 'term'.\n    if (varp == &T_NAME)\n    {\n\topt_idx = findoption((char_u *)\"term\");\n\tif (opt_idx >= 0)\n\t{\n\t    free_oldval = (get_option_flags(opt_idx) & P_ALLOCED);\n\t    did_set_cb = get_option_did_set_cb(opt_idx);\n\t}\n    }\n\n    CLEAR_FIELD(args);\n\n    // Disallow changing some options from secure mode\n    if ((secure\n#ifdef HAVE_SANDBOX\n\t\t|| sandbox != 0\n#endif\n\t\t) && (get_option_flags(opt_idx) & P_SECURE))\n\terrmsg = e_not_allowed_here;\n    // Check for a \"normal\" directory or file name in some options.\n    else if (check_illegal_path_names(opt_idx, varp))\n\terrmsg = e_invalid_argument;\n    else if (did_set_cb != NULL)\n    {\n\targs.os_varp = (char_u *)varp;\n\targs.os_idx = opt_idx;\n\targs.os_flags = opt_flags;\n\targs.os_op = op;\n\targs.os_oldval.string = oldval;\n\targs.os_newval.string = value;\n\targs.os_errbuf = errbuf;\n\targs.os_errbuflen = errbuflen;\n\t// Invoke the option specific callback function to validate and apply\n\t// the new option value.\n\terrmsg = did_set_cb(&args);\n\n\t// The 'keymap', 'filetype' and 'syntax' option callback functions\n\t// may change the os_value_checked field.\n\t*value_checked = args.os_value_checked;\n    }\n\n    // If an error is detected, restore the previous value.\n    if (errmsg != NULL)\n    {\n\tfree_string_option(*varp);\n\t*varp = oldval;\n\t// When resetting some values, need to act on it.\n\tif (args.os_restore_chartab)\n\t    (void)init_chartab();\n\tif (varp == &p_hl)\n\t    (void)highlight_changed();\n    }\n    else\n    {\n#ifdef FEAT_EVAL\n\t// Remember where the option was set.\n\tset_option_sctx_idx(opt_idx, opt_flags, current_sctx);\n#endif\n\t// Free string options that are in allocated memory.\n\t// Use \"free_oldval\", because recursiveness may change the flags under\n\t// our fingers (esp. init_highlight()).\n\tif (free_oldval)\n\t    free_string_option(oldval);\n\tset_option_flag(opt_idx, P_ALLOCED);\n\n\tif ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n\t\t&& is_global_local_option(opt_idx))\n\t{\n\t    // global option with local value set to use global value; free\n\t    // the local value and make it empty\n\t    char_u *p = get_option_varp_scope(opt_idx, OPT_LOCAL);\n\t    free_string_option(*(char_u **)p);\n\t    *(char_u **)p = empty_option;\n\t}\n\n\t// May set global value for local option.\n\telse if (!(opt_flags & OPT_LOCAL) && opt_flags != OPT_GLOBAL)\n\t    set_string_option_global(opt_idx, varp);\n\n\t// Trigger the autocommand only after setting the flags.\n#ifdef FEAT_SYN_HL\n\tif (varp == &(curbuf->b_p_syn))\n\t    do_syntax_autocmd(args.os_value_changed);\n#endif\n\telse if (varp == &(curbuf->b_p_ft))\n\t    do_filetype_autocmd(varp, opt_flags, args.os_value_changed);\n#ifdef FEAT_SPELL\n\tif (varp == &(curwin->w_s->b_p_spl))\n\t    do_spelllang_source();\n#endif\n    }\n\n    if (varp == &p_mouse)\n    {\n\tif (*p_mouse == NUL)\n\t    mch_setmouse(FALSE);    // switch mouse off\n\telse\n\t    setmouse();\t\t    // in case 'mouse' changed\n    }\n\n#if defined(FEAT_LUA) || defined(PROTO)\n    if (varp == &p_rtp)\n\tupdate_package_paths_in_lua();\n#endif\n\n#if defined(FEAT_LINEBREAK)\n    // Changing Formatlistpattern when briopt includes the list setting:\n    // redraw\n    if ((varp == &p_flp || varp == &(curbuf->b_p_flp))\n\t    && curwin->w_briopt_list)\n\tredraw_all_later(UPD_NOT_VALID);\n#endif\n\n    if (curwin->w_curswant != MAXCOL\n\t\t   && (get_option_flags(opt_idx) & (P_CURSWANT | P_RALL)) != 0)\n\tcurwin->w_set_curswant = TRUE;\n\n    if ((opt_flags & OPT_NO_REDRAW) == 0)\n    {\n#ifdef FEAT_GUI\n\t// set when changing an option that only requires a redraw in the GUI\n\tint\tredraw_gui_only = FALSE;\n\n\tif (varp == &p_go\t\t\t// 'guioptions'\n\t\t|| varp == &p_guifont\t\t// 'guifont'\n# ifdef FEAT_GUI_TABLINE\n\t\t|| varp == &p_gtl\t\t// 'guitablabel'\n\t\t|| varp == &p_gtt\t\t// 'guitabtooltip'\n# endif\n# ifdef FEAT_XFONTSET\n\t\t|| varp == &p_guifontset\t// 'guifontset'\n# endif\n\t\t|| varp == &p_guifontwide\t// 'guifontwide'\n# ifdef FEAT_GUI_GTK\n\t\t|| varp == &p_guiligatures\t// 'guiligatures'\n# endif\n\t    )\n\t    redraw_gui_only = TRUE;\n\n\t// check redraw when it's not a GUI option or the GUI is active.\n\tif (!redraw_gui_only || gui.in_use)\n#endif\n\t    check_redraw(get_option_flags(opt_idx));\n    }\n\n#if defined(FEAT_VTP) && defined(FEAT_TERMGUICOLORS)\n    if (args.os_did_swaptcap)\n    {\n\tset_termname((char_u *)\"win32\");\n\tinit_highlight(TRUE, FALSE);\n    }\n#endif\n\n    return errmsg;\n}",
      "cve_list": [
        "CVE-2024-22667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "vim",
      "filepath": "src/optionstr.c",
      "func_name": "did_set_viminfo",
      "func_body": "did_set_viminfo(optset_T *args)\n{\n    char_u\t*s;\n    char\t*errmsg = NULL;\n\n    for (s = p_viminfo; *s;)\n    {\n\t// Check it's a valid character\n\tif (vim_strchr((char_u *)\"!\\\"%'/:<@cfhnrs\", *s) == NULL)\n\t{\n\t    errmsg = illegal_char(args->os_errbuf, args->os_errbuflen, *s);\n\t    break;\n\t}\n\tif (*s == 'n')\t// name is always last one\n\t    break;\n\telse if (*s == 'r') // skip until next ','\n\t{\n\t    while (*++s && *s != ',')\n\t\t;\n\t}\n\telse if (*s == '%')\n\t{\n\t    // optional number\n\t    while (vim_isdigit(*++s))\n\t\t;\n\t}\n\telse if (*s == '!' || *s == 'h' || *s == 'c')\n\t    ++s;\t\t// no extra chars\n\telse\t\t// must have a number\n\t{\n\t    while (vim_isdigit(*++s))\n\t\t;\n\n\t    if (!VIM_ISDIGIT(*(s - 1)))\n\t    {\n\t\tif (args->os_errbuf != NULL)\n\t\t{\n\t\t    snprintf(args->os_errbuf, args->os_errbuflen,\n\t\t\t    _(e_missing_number_after_angle_str_angle),\n\t\t\t    transchar_byte(*(s - 1)));\n\t\t    errmsg = args->os_errbuf;\n\t\t}\n\t\telse\n\t\t    errmsg = \"\";\n\t\tbreak;\n\t    }\n\t}\n\tif (*s == ',')\n\t    ++s;\n\telse if (*s)\n\t{\n\t    if (args->os_errbuf != NULL)\n\t\terrmsg = e_missing_comma;\n\t    else\n\t\terrmsg = \"\";\n\t    break;\n\t}\n    }\n    if (*p_viminfo && errmsg == NULL && get_viminfo_parameter('\\'') < 0)\n\terrmsg = e_must_specify_a_value;\n\n    return errmsg;\n}",
      "cve_list": [
        "CVE-2024-22667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "vim",
      "filepath": "src/optionstr.c",
      "func_name": "did_set_whichwrap",
      "func_body": "did_set_whichwrap(optset_T *args)\n{\n    char_u\t**varp = (char_u **)args->os_varp;\n\n    // Add ',' to the list flags because 'whichwrap' is a flag\n    // list that is comma-separated.\n    return did_set_option_listflag(*varp, (char_u *)(WW_ALL \",\"),\n\t\t    args->os_errbuf, args->os_errbuflen);\n}",
      "cve_list": [
        "CVE-2024-22667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "vim",
      "filepath": "src/optionstr.c",
      "func_name": "illegal_char",
      "func_body": "illegal_char(char *errbuf, int errbuflen, int c)\n{\n    if (errbuf == NULL)\n\treturn \"\";\n    snprintf((char *)errbuf, errbuflen, _(e_illegal_character_str),\n\t\t    (char *)transchar(c));\n    return errbuf;\n}",
      "cve_list": [
        "CVE-2024-22667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "vim",
      "filepath": "src/optionstr.c",
      "func_name": "set_string_option",
      "func_body": "set_string_option(\n    int\t\topt_idx,\n    char_u\t*value,\n    int\t\topt_flags,\t// OPT_LOCAL and/or OPT_GLOBAL\n    char\t*errbuf,\n    int\t\terrbuflen)\n{\n    char_u\t*s;\n    char_u\t**varp;\n    char_u\t*oldval;\n#if defined(FEAT_EVAL)\n    char_u\t*oldval_l = NULL;\n    char_u\t*oldval_g = NULL;\n    char_u\t*saved_oldval = NULL;\n    char_u\t*saved_oldval_l = NULL;\n    char_u\t*saved_oldval_g = NULL;\n    char_u\t*saved_newval = NULL;\n#endif\n    char\t*errmsg = NULL;\n    int\t\tvalue_checked = FALSE;\n\n    if (is_hidden_option(opt_idx))\t// don't set hidden option\n\treturn NULL;\n\n    s = vim_strsave(value == NULL ? (char_u *)\"\" : value);\n    if (s == NULL)\n\treturn NULL;\n\n    varp = (char_u **)get_option_varp_scope(opt_idx,\n\t    (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n\t    ? (is_global_local_option(opt_idx)\n\t\t? OPT_GLOBAL : OPT_LOCAL)\n\t    : opt_flags);\n    oldval = *varp;\n#if defined(FEAT_EVAL)\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n    {\n\toldval_l = *(char_u **)get_option_varp_scope(opt_idx, OPT_LOCAL);\n\toldval_g = *(char_u **)get_option_varp_scope(opt_idx, OPT_GLOBAL);\n    }\n#endif\n    *varp = s;\n\n#if defined(FEAT_EVAL)\n    if (!starting\n# ifdef FEAT_CRYPT\n\t    && !is_crypt_key_option(opt_idx)\n# endif\n       )\n    {\n\tif (oldval_l != NULL)\n\t    saved_oldval_l = vim_strsave(oldval_l);\n\tif (oldval_g != NULL)\n\t    saved_oldval_g = vim_strsave(oldval_g);\n\tsaved_oldval = vim_strsave(oldval);\n\tsaved_newval = vim_strsave(s);\n    }\n#endif\n    if ((errmsg = did_set_string_option(opt_idx, varp, oldval, value, errbuf,\n\t\t    errbuflen, opt_flags, OP_NONE, &value_checked)) == NULL)\n\tdid_set_option(opt_idx, opt_flags, TRUE, value_checked);\n\n#if defined(FEAT_EVAL)\n    // call autocommand after handling side effects\n    if (errmsg == NULL)\n\ttrigger_optionset_string(opt_idx, opt_flags,\n\t\tsaved_oldval, saved_oldval_l,\n\t\tsaved_oldval_g, saved_newval);\n    vim_free(saved_oldval);\n    vim_free(saved_oldval_l);\n    vim_free(saved_oldval_g);\n    vim_free(saved_newval);\n#endif\n    return errmsg;\n}",
      "cve_list": [
        "CVE-2024-22667"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "wireshark",
      "filepath": "wsutil/to_str.c",
      "func_name": "format_fractional_part_nsecs",
      "func_body": "format_fractional_part_nsecs(gchar *buf, size_t buflen, guint32 nsecs, const char *decimal_point, int precision)\n{\n\tgchar *ptr;\n\tsize_t remaining;\n\tint num_bytes;\n\tgsize decimal_point_len;\n\tguint32 frac_part;\n\tgint8 num_buf[CHARS_NANOSECONDS];\n\tgint8 *num_end = &num_buf[CHARS_NANOSECONDS];\n\tgint8 *num_ptr;\n\tsize_t num_len;\n\n\tws_assert(precision != 0);\n\n\tif (buflen == 0) {\n\t\t/*\n\t\t * No room in the buffer for anything, including\n\t\t * a terminating '\\0'.\n\t\t */\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the fractional part is >= 1, don't show it as a\n\t * fractional part.\n\t */\n\tif (nsecs >= 1000000000U) {\n\t\tnum_bytes = snprintf(buf, buflen, \"%s(%u nanoseconds)\",\n\t\t    decimal_point, nsecs);\n\t\tif ((unsigned int)num_bytes >= buflen) {\n\t\t\t/*\n\t\t\t * That filled up or would have overflowed\n\t\t\t * the buffer.  Nothing more to do; return\n\t\t\t * the remaining space in the buffer, minus\n\t\t\t * one byte for the terminating '\\0',* as\n\t\t\t * that's the number of bytes we copied.\n\t\t\t */\n\t\t\treturn (int)(buflen - 1);\n\t\t}\n\t\treturn num_bytes;\n\t}\n\n\tptr = buf;\n\tremaining = buflen;\n\tnum_bytes = 0;\n\n\t/*\n\t * Copy the decimal point.\n\t */\n\tdecimal_point_len = g_strlcpy(buf, decimal_point, buflen);\n\tif (decimal_point_len >= buflen) {\n\t\t/*\n\t\t * The decimal point didn't fit in the buffer\n\t\t * and was truncated.  Nothing more to do;\n\t\t * return the remaining space in the buffer,\n\t\t * minus one byte for the terminating '\\0',\n\t\t * as that's the number of bytes we copied.\n\t\t */\n\t\treturn (int)(buflen - 1);\n\t}\n\tptr += decimal_point_len;\n\tremaining -= decimal_point_len;\n\tnum_bytes += decimal_point_len;\n\n\t/*\n\t * Fill in num_buf with the nanoseconds value, padded with\n\t * leading zeroes, to the specified precision.\n\t *\n\t * We scale the fractional part in advance, as that just\n\t * takes one division by a constant (which may be\n\t * optimized to a faster multiplication by a constant)\n\t * and gets rid of some divisions and remainders by 100\n\t * done to generate the digits.\n\t *\n\t * We pass preciions as the last argument to\n\t * uint_to_str_back_len(), as that might mean that\n\t * all of the cases end up using common code to\n\t * do part of the call to uint_to_str_back_len().\n\t */\n\tswitch (precision) {\n\n\tcase 1:\n\t\t/*\n\t\t * Scale down to units of 1/10 second.\n\t\t */\n\t\tfrac_part = nsecs / 100000000U;\n\t\tbreak;\n\n\tcase 2:\n\t\t/*\n\t\t * Scale down to units of 1/100 second.\n\t\t */\n\t\tfrac_part = nsecs / 10000000U;\n\t\tbreak;\n\n\tcase 3:\n\t\t/*\n\t\t * Scale down to units of 1/1000 second.\n\t\t */\n\t\tfrac_part = nsecs / 1000000U;\n\t\tbreak;\n\n\tcase 4:\n\t\t/*\n\t\t * Scale down to units of 1/10000 second.\n\t\t */\n\t\tfrac_part = nsecs / 100000U;\n\t\tbreak;\n\n\tcase 5:\n\t\t/*\n\t\t * Scale down to units of 1/100000 second.\n\t\t */\n\t\tfrac_part = nsecs / 10000U;\n\t\tbreak;\n\n\tcase 6:\n\t\t/*\n\t\t * Scale down to units of 1/1000000 second.\n\t\t */\n\t\tfrac_part = nsecs / 1000U;\n\t\tbreak;\n\n\tcase 7:\n\t\t/*\n\t\t * Scale down to units of 1/10000000 second.\n\t\t */\n\t\tfrac_part = nsecs / 100U;\n\t\tbreak;\n\n\tcase 8:\n\t\t/*\n\t\t * Scale down to units of 1/100000000 second.\n\t\t */\n\t\tfrac_part = nsecs / 10U;\n\t\tbreak;\n\n\tcase 9:\n\t\t/*\n\t\t * We're already in units of 1/1000000000 second.\n\t\t */\n\t\tfrac_part = nsecs;\n\t\tbreak;\n\n\tdefault:\n\t\tws_assert_not_reached();\n\t\tbreak;\n\t}\n\n\tnum_ptr = uint_to_str_back_len(num_end, frac_part, precision);\n\n\t/*\n\t * The length of the string that we want to copy to the buffer\n\t * is the minimum of:\n\t *\n\t *    the length of the digit string;\n\t *    the remaining space in the buffer, minus 1 for the\n\t *      terminating '\\0'.\n\t */\n\tnum_len = MIN((size_t)(num_end - num_ptr), remaining - 1);\n\tif (num_len == 0) {\n\t\t/*\n\t\t * Not enough room to copy anything.\n\t\t * Return the number of bytes we've generated.\n\t\t */\n\t\treturn num_bytes;\n\t}\n\n\t/*\n\t * Copy over the fractional part.\n\t */\n\tmemcpy(ptr, num_ptr, num_len);\n\tptr += num_len;\n\tnum_bytes += num_len;\n\n\t/*\n\t * '\\0'-terminate it.\n\t */\n\t*ptr = '\\0';\n\treturn num_bytes;\n}",
      "cve_list": [
        "CVE-2024-24479"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wireshark",
      "filepath": "wsutil/to_str.c",
      "func_name": "format_nstime_as_iso8601",
      "func_body": "format_nstime_as_iso8601(gchar *buf, size_t buflen, const nstime_t *ns,\n    char *decimal_point, gboolean local, int precision)\n{\n\tstruct tm tm, *tmp;\n\tgchar *ptr;\n\tsize_t remaining;\n\tint num_bytes;\n\n\tif (local)\n\t\ttmp = ws_localtime_r(&ns->secs, &tm);\n\telse\n\t\ttmp = ws_gmtime_r(&ns->secs, &tm);\n\tif (tmp == NULL) {\n\t\tsnprintf(buf, buflen, \"Not representable\");\n\t\treturn;\n\t}\n\tptr = buf;\n\tremaining = buflen;\n\tnum_bytes = snprintf(ptr, remaining,\n\t    \"%04d-%02d-%02d %02d:%02d:%02d\",\n\t    tmp->tm_year + 1900,\n\t    tmp->tm_mon + 1,\n\t    tmp->tm_mday,\n\t    tmp->tm_hour,\n\t    tmp->tm_min,\n\t    tmp->tm_sec);\n\tif (num_bytes < 0) {\n\t\t/*\n\t\t * That got an error.\n\t\t * Not much else we can do.\n\t\t */\n\t\tsnprintf(buf, buflen, \"snprintf() failed\");\n\t\treturn;\n\t}\n\tif ((unsigned int)num_bytes >= remaining) {\n\t\t/*\n\t\t * That filled up or would have overflowed the buffer.\n\t\t * Nothing more we can do.\n\t\t */\n\t\treturn;\n\t}\n\tptr += num_bytes;\n\tremaining -= num_bytes;\n\n\tif (precision != 0) {\n\t\t/*\n\t\t * Append the fractional part.\n\t\t * Get the nsecs as a 32-bit unsigned value, as it should\n\t\t * never be negative, so we treat it as unsigned.\n\t\t */\n\t\tformat_fractional_part_nsecs(ptr, remaining, (guint32)ns->nsecs, decimal_point, precision);\n\t}\n}",
      "cve_list": [
        "CVE-2024-24479"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wireshark",
      "filepath": "epan/addr_resolv.c",
      "func_name": "eth_addr_resolve",
      "func_body": "eth_addr_resolve(hashether_t *tp) {\n    ether_t      *eth;\n    hashmanuf_t *manuf_value;\n    const guint8 *addr = tp->addr;\n    size_t addr_size = sizeof(tp->addr);\n\n    if ( (eth = get_ethbyaddr(addr)) != NULL) {\n        (void) g_strlcpy(tp->resolved_name, eth->name, MAXNAMELEN);\n        tp->status = HASHETHER_STATUS_RESOLVED_NAME;\n        return tp;\n    } else {\n        guint         mask;\n        gchar        *name;\n        address       ether_addr;\n\n        /* Unknown name.  Try looking for it in the well-known-address\n           tables for well-known address ranges smaller than 2^24. */\n        mask = 7;\n        do {\n            /* Only the topmost 5 bytes participate fully */\n            if ((name = wka_name_lookup(addr, mask+40)) != NULL) {\n                snprintf(tp->resolved_name, MAXNAMELEN, \"%s_%02x\",\n                        name, addr[5] & (0xFF >> mask));\n                tp->status = HASHETHER_STATUS_RESOLVED_DUMMY;\n                return tp;\n            }\n        } while (mask--);\n\n        mask = 7;\n        do {\n            /* Only the topmost 4 bytes participate fully */\n            if ((name = wka_name_lookup(addr, mask+32)) != NULL) {\n                snprintf(tp->resolved_name, MAXNAMELEN, \"%s_%02x:%02x\",\n                        name, addr[4] & (0xFF >> mask), addr[5]);\n                tp->status = HASHETHER_STATUS_RESOLVED_DUMMY;\n                return tp;\n            }\n        } while (mask--);\n\n        mask = 7;\n        do {\n            /* Only the topmost 3 bytes participate fully */\n            if ((name = wka_name_lookup(addr, mask+24)) != NULL) {\n                snprintf(tp->resolved_name, MAXNAMELEN, \"%s_%02x:%02x:%02x\",\n                        name, addr[3] & (0xFF >> mask), addr[4], addr[5]);\n                tp->status = HASHETHER_STATUS_RESOLVED_DUMMY;\n                return tp;\n            }\n        } while (mask--);\n\n        /* Now try looking in the manufacturer table. */\n        manuf_value = manuf_name_lookup(addr, addr_size);\n        if ((manuf_value != NULL) && (manuf_value->status != HASHETHER_STATUS_UNRESOLVED)) {\n            snprintf(tp->resolved_name, MAXNAMELEN, \"%s_%02x:%02x:%02x\",\n                    manuf_value->resolved_name, addr[3], addr[4], addr[5]);\n            tp->status = HASHETHER_STATUS_RESOLVED_DUMMY;\n            return tp;\n        }\n\n        /* Now try looking for it in the well-known-address\n           tables for well-known address ranges larger than 2^24. */\n        mask = 7;\n        do {\n            /* Only the topmost 2 bytes participate fully */\n            if ((name = wka_name_lookup(addr, mask+16)) != NULL) {\n                snprintf(tp->resolved_name, MAXNAMELEN, \"%s_%02x:%02x:%02x:%02x\",\n                        name, addr[2] & (0xFF >> mask), addr[3], addr[4],\n                        addr[5]);\n                tp->status = HASHETHER_STATUS_RESOLVED_DUMMY;\n                return tp;\n            }\n        } while (mask--);\n\n        mask = 7;\n        do {\n            /* Only the topmost byte participates fully */\n            if ((name = wka_name_lookup(addr, mask+8)) != NULL) {\n                snprintf(tp->resolved_name, MAXNAMELEN, \"%s_%02x:%02x:%02x:%02x:%02x\",\n                        name, addr[1] & (0xFF >> mask), addr[2], addr[3],\n                        addr[4], addr[5]);\n                tp->status = HASHETHER_STATUS_RESOLVED_DUMMY;\n                return tp;\n            }\n        } while (mask--);\n\n        mask = 7;\n        do {\n            /* Not even the topmost byte participates fully */\n            if ((name = wka_name_lookup(addr, mask)) != NULL) {\n                snprintf(tp->resolved_name, MAXNAMELEN, \"%s_%02x:%02x:%02x:%02x:%02x:%02x\",\n                        name, addr[0] & (0xFF >> mask), addr[1], addr[2],\n                        addr[3], addr[4], addr[5]);\n                tp->status = HASHETHER_STATUS_RESOLVED_DUMMY;\n                return tp;\n            }\n        } while (--mask); /* Work down to the last bit */\n\n        /* No match whatsoever. */\n        set_address(&ether_addr, AT_ETHER, 6, addr);\n        address_to_str_buf(&ether_addr, tp->resolved_name, MAXNAMELEN);\n        tp->status = HASHETHER_STATUS_RESOLVED_DUMMY;\n        return tp;\n    }\n    ws_assert_not_reached();\n} /* eth_addr_resolve */",
      "cve_list": [
        "CVE-2024-24476"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wireshark",
      "filepath": "epan/addr_resolv.c",
      "func_name": "eui64_to_display",
      "func_body": "eui64_to_display(wmem_allocator_t *allocator, const guint64 addr_eui64)\n{\n    guint8 *addr = (guint8 *)wmem_alloc(NULL, 8);\n    hashmanuf_t *manuf_value;\n    gchar *ret;\n\n    /* Copy and convert the address to network byte order. */\n    *(guint64 *)(void *)(addr) = pntoh64(&(addr_eui64));\n\n    manuf_value = manuf_name_lookup(addr, 8);\n    if (!gbl_resolv_flags.mac_name || (manuf_value->status == HASHETHER_STATUS_UNRESOLVED)) {\n        ret = wmem_strdup_printf(allocator, \"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7]);\n    } else {\n        ret = wmem_strdup_printf(allocator, \"%s_%02x:%02x:%02x:%02x:%02x\", manuf_value->resolved_name, addr[3], addr[4], addr[5], addr[6], addr[7]);\n    }\n\n    wmem_free(NULL, addr);\n    return ret;\n} /* eui64_to_display */",
      "cve_list": [
        "CVE-2024-24476"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wireshark",
      "filepath": "epan/addr_resolv.c",
      "func_name": "get_manuf_name",
      "func_body": "get_manuf_name(const guint8 *addr, size_t size)\n{\n    hashmanuf_t *manuf_value;\n\n    manuf_value = manuf_name_lookup(addr, size);\n    if (gbl_resolv_flags.mac_name && manuf_value->status != HASHETHER_STATUS_UNRESOLVED)\n        return manuf_value->resolved_name;\n\n    return manuf_value->hexaddr;\n\n} /* get_manuf_name */",
      "cve_list": [
        "CVE-2024-24476"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wireshark",
      "filepath": "epan/addr_resolv.c",
      "func_name": "get_manuf_name_if_known",
      "func_body": "get_manuf_name_if_known(const guint8 *addr, size_t size)\n{\n    hashmanuf_t *manuf_value;\n    guint manuf_key;\n    guint8 oct;\n\n    ws_return_val_if(size != 6, NULL);\n\n    /* manuf needs only the 3 most significant octets of the ethernet address */\n    manuf_key = addr[0];\n    manuf_key = manuf_key<<8;\n    oct = addr[1];\n    manuf_key = manuf_key | oct;\n    manuf_key = manuf_key<<8;\n    oct = addr[2];\n    manuf_key = manuf_key | oct;\n\n    manuf_value = (hashmanuf_t *)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n    if (manuf_value != NULL && manuf_value->status != HASHETHER_STATUS_UNRESOLVED) {\n        return manuf_value->resolved_longname;\n    }\n\n    /* Try the global manuf tables. */\n    const char *short_name, *long_name;\n    short_name = ws_manuf_lookup_str(addr, &long_name);\n    if (short_name != NULL) {\n        /* Found it */\n        return long_name;\n    }\n\n    return NULL;\n\n} /* get_manuf_name_if_known */",
      "cve_list": [
        "CVE-2024-24476"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wireshark",
      "filepath": "epan/addr_resolv.c",
      "func_name": "manuf_name_lookup",
      "func_body": "manuf_name_lookup(const guint8 *addr, size_t size)\n{\n    guint32       manuf_key;\n    guint8       oct;\n    hashmanuf_t  *manuf_value;\n\n    ws_return_val_if(size < 6, NULL);\n\n    /* manuf needs only the 3 most significant octets of the ethernet address */\n    manuf_key = addr[0];\n    manuf_key = manuf_key<<8;\n    oct = addr[1];\n    manuf_key = manuf_key | oct;\n    manuf_key = manuf_key<<8;\n    oct = addr[2];\n    manuf_key = manuf_key | oct;\n\n\n    /* first try to find a \"perfect match\" */\n    manuf_value = (hashmanuf_t*)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n    if (manuf_value != NULL) {\n        return manuf_value;\n    }\n\n    /* Mask out the broadcast/multicast flag but not the locally\n     * administered flag as locally administered means: not assigned\n     * by the IEEE but the local administrator instead.\n     * 0x01 multicast / broadcast bit\n     * 0x02 locally administered bit */\n    if ((manuf_key & 0x00010000) != 0) {\n        manuf_key &= 0x00FEFFFF;\n        manuf_value = (hashmanuf_t*)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n        if (manuf_value != NULL) {\n            return manuf_value;\n        }\n    }\n\n    /* Try the global manuf tables. */\n    const char *short_name, *long_name;\n    short_name = ws_manuf_lookup_str(addr, &long_name);\n    if (short_name != NULL) {\n        /* Found it */\n        return manuf_hash_new_entry(addr, short_name, long_name);\n    }\n\n    /* Add the address as a hex string */\n    return manuf_hash_new_entry(addr, NULL, NULL);\n\n} /* manuf_name_lookup */",
      "cve_list": [
        "CVE-2024-24476"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wireshark",
      "filepath": "epan/addr_resolv.c",
      "func_name": "tvb_get_manuf_name",
      "func_body": "tvb_get_manuf_name(tvbuff_t *tvb, gint offset)\n{\n    guint8 buf[6] = { 0 };\n    tvb_memcpy(tvb, buf, offset, 3);\n    return get_manuf_name(buf, sizeof(buf));\n}",
      "cve_list": [
        "CVE-2024-24476"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wireshark",
      "filepath": "epan/addr_resolv.c",
      "func_name": "tvb_get_manuf_name_if_known",
      "func_body": "tvb_get_manuf_name_if_known(tvbuff_t *tvb, gint offset)\n{\n    guint8 buf[6] = { 0 };\n    tvb_memcpy(tvb, buf, offset, 3);\n    return get_manuf_name_if_known(buf, sizeof(buf));\n}",
      "cve_list": [
        "CVE-2024-24476"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wireshark",
      "filepath": "epan/address_types.c",
      "func_name": "fcwwn_name_res_str",
      "func_body": "static const gchar* fcwwn_name_res_str(const address* addr)\n{\n    const guint8 *addrp = (const guint8*)addr->data;\n    int fmt;\n    guint8 oui[6];\n\n    fmt = (addrp[0] & 0xF0) >> 4;\n    switch (fmt) {\n\n    case FC_NH_NAA_IEEE:\n    case FC_NH_NAA_IEEE_E:\n\n        memcpy (oui, &addrp[2], 6);\n        return get_manuf_name(oui, sizeof(oui));\n\n    case FC_NH_NAA_IEEE_R:\n        oui[0] = ((addrp[0] & 0x0F) << 4) | ((addrp[1] & 0xF0) >> 4);\n        oui[1] = ((addrp[1] & 0x0F) << 4) | ((addrp[2] & 0xF0) >> 4);\n        oui[2] = ((addrp[2] & 0x0F) << 4) | ((addrp[3] & 0xF0) >> 4);\n        oui[3] = ((addrp[3] & 0x0F) << 4) | ((addrp[4] & 0xF0) >> 4);\n        oui[4] = ((addrp[4] & 0x0F) << 4) | ((addrp[5] & 0xF0) >> 4);\n        oui[5] = ((addrp[5] & 0x0F) << 4) | ((addrp[6] & 0xF0) >> 4);\n\n        return get_manuf_name(oui, sizeof(oui));\n    }\n\n    return \"\";\n}",
      "cve_list": [
        "CVE-2024-24476"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wireshark",
      "filepath": "epan/dissectors/packet-bgp.c",
      "func_name": "proto_register_bgp",
      "func_body": "proto_register_bgp(void)\n{\n\n    static hf_register_info hf[] = {\n      /* BGP Header */\n      { &hf_bgp_marker,\n        { \"Marker\", \"bgp.marker\", FT_BYTES, BASE_NONE,\n          NULL, 0x0, \"Must be set to all ones (16 Bytes)\", HFILL }},\n      { &hf_bgp_length,\n        { \"Length\", \"bgp.length\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, \"The total length of the message, including the header in octets\", HFILL }},\n      { &hf_bgp_prefix_length,\n        { \"Prefix Length\", \"bgp.prefix_length\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_rd,\n        { \"Route Distinguisher\", \"bgp.rd\", FT_STRING, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_continuation,\n        { \"Continuation\", \"bgp.continuation\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_originating_as,\n        { \"Originating AS\", \"bgp.originating_as\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_community_prefix,\n        { \"Community Prefix\", \"bgp.community_prefix\", FT_STRING, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_endpoint_address,\n        { \"Endpoint Address\", \"bgp.endpoint_address\", FT_IPv4, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_endpoint_address_ipv6,\n        { \"Endpoint Address\", \"bgp.endpoint_address_ipv6\", FT_IPv6, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_label_stack,\n        { \"Label Stack\", \"bgp.label_stack\", FT_STRING, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_vplsad_length,\n        { \"Length\", \"bgp.vplsad.length\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_vplsad_rd,\n        { \"RD\", \"bgp.vplsad.rd\", FT_STRING, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_bgpad_pe_addr,\n        { \"PE Addr\", \"bgp.ad.pe_addr\", FT_IPv4, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_vplsbgp_ce_id,\n        { \"CE-ID\", \"bgp.vplsbgp.ce_id\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_vplsbgp_labelblock_offset,\n        { \"Label Block Offset\", \"bgp.vplsbgp.labelblock.offset\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_vplsbgp_labelblock_size,\n        { \"Label Block Size\", \"bgp.vplsbgp.labelblock.size\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_vplsbgp_labelblock_base,\n        { \"Label Block Base\", \"bgp.vplsbgp.labelblock.base\", FT_STRING, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_wildcard_route_target,\n        { \"Wildcard route target\", \"bgp.wildcard_route_target\", FT_STRING, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_type,\n        { \"Type\", \"bgp.type\", FT_UINT8, BASE_DEC,\n          VALS(bgptypevals), 0x0, \"BGP message type\", HFILL }},\n      /* Open Message */\n      { &hf_bgp_open_version,\n        { \"Version\", \"bgp.open.version\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, \"The protocol version number\", HFILL }},\n      { &hf_bgp_open_myas,\n        { \"My AS\", \"bgp.open.myas\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, \"The Autonomous System number of the sender\", HFILL }},\n      { &hf_bgp_open_holdtime,\n        { \"Hold Time\", \"bgp.open.holdtime\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, \"The number of seconds the sender proposes for Hold Time\", HFILL }},\n      { &hf_bgp_open_identifier,\n        { \"BGP Identifier\", \"bgp.open.identifier\", FT_IPv4, BASE_NONE,\n          NULL, 0x0, \"The BGP Identifier of the sender\", HFILL }},\n      { &hf_bgp_open_opt_len,\n        { \"Optional Parameters Length\", \"bgp.open.opt.len\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, \"The total length of the Optional Parameters field in octets\", HFILL }},\n      { &hf_bgp_open_opt_extension,\n        { \"Optional Parameter Extension\", \"bgp.open.opt.extension\", FT_NONE, BASE_NONE,\n          NULL, 0x0, \"Optional Parameters Extension detected\", HFILL }},\n      { &hf_bgp_open_opt_extension_mark,\n        { \"Extension Mark\", \"bgp.open.opt.extension.mark\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, \"Optional Parameters Extension detected\", HFILL }},\n      { &hf_bgp_open_opt_extension_len,\n        { \"Extended Length\", \"bgp.open.opt.extension_len\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, \"The total extended length of the Optional Parameters field in octets\", HFILL }},\n      { &hf_bgp_open_opt_params,\n        { \"Optional Parameters\", \"bgp.open.opt\", FT_NONE, BASE_NONE,\n          NULL, 0x0, \"List of optional parameters\", HFILL }},\n      { &hf_bgp_open_opt_param,\n        { \"Optional Parameter\", \"bgp.open.opt.param\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_open_opt_param_type,\n        { \"Parameter Type\", \"bgp.open.opt.param.type\", FT_UINT8, BASE_DEC,\n          VALS(bgp_open_opt_vals), 0x0, \"Unambiguously identifies individual parameters\", HFILL }},\n      { &hf_bgp_open_opt_param_len,\n        { \"Parameter Length\", \"bgp.open.opt.param.len\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, \"Length of the Parameter Value\", HFILL }},\n      { &hf_bgp_open_opt_param_auth,\n        { \"Authentication Data\", \"bgp.open.opt.param.auth\", FT_BYTES, BASE_NONE,\n          NULL, 0x0, \"Deprecated\", HFILL }},\n      { &hf_bgp_open_opt_param_unknown,\n        { \"Unknown\", \"bgp.open.opt.param.unknown\", FT_BYTES, BASE_NONE,\n          NULL, 0x0, \"Unknown Parameter\", HFILL }},\n        /* Notification error */\n      { &hf_bgp_notify_major_error,\n        { \"Major error Code\", \"bgp.notify.major_error\", FT_UINT8, BASE_DEC,\n          VALS(bgpnotify_major), 0x0, NULL, HFILL }},\n      { &hf_bgp_notify_minor_msg_hdr,\n        { \"Minor error Code (Message Header)\", \"bgp.notify.minor_error\", FT_UINT8, BASE_DEC,\n          VALS(bgpnotify_minor_msg_hdr), 0x0, NULL, HFILL }},\n      { &hf_bgp_notify_minor_open_msg,\n        { \"Minor error Code (Open Message)\", \"bgp.notify.minor_error_open\", FT_UINT8, BASE_DEC,\n          VALS(bgpnotify_minor_open_msg), 0x0, NULL, HFILL }},\n      { &hf_bgp_notify_minor_update_msg,\n        { \"Minor error Code (Update Message)\", \"bgp.notify.minor_error_update\", FT_UINT8, BASE_DEC,\n          VALS(bgpnotify_minor_update_msg), 0x0, NULL, HFILL }},\n      { &hf_bgp_notify_minor_ht_expired,\n        { \"Minor error Code (Hold Timer Expired)\", \"bgp.notify.minor_error_expired\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_notify_minor_state_machine,\n        { \"Minor error Code (State Machine)\", \"bgp.notify.minor_error_state\", FT_UINT8, BASE_DEC,\n          VALS(bgpnotify_minor_state_machine), 0x0, NULL, HFILL }},\n      { &hf_bgp_notify_minor_cease,\n        { \"Minor error Code (Cease)\", \"bgp.notify.minor_error_cease\", FT_UINT8, BASE_DEC,\n          VALS(bgpnotify_minor_cease), 0x0, NULL, HFILL }},\n      { &hf_bgp_notify_minor_rr_msg,\n        { \"Minor error Code (Route-Refresh message)\", \"bgp.notify.minor_error_route_refresh\", FT_UINT8, BASE_DEC,\n          VALS(bgpnotify_minor_rr_msg), 0x0, NULL, HFILL }},\n      { &hf_bgp_notify_minor_unknown,\n        { \"Minor error Code (Unknown)\", \"bgp.notify.minor_error_unknown\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_notify_data,\n        { \"Data\", \"bgp.notify.minor_data\", FT_BYTES, BASE_NONE,\n           NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_notify_error_open_bad_peer_as,\n        { \"Bad Peer AS\", \"bgp.notify.error_open.bad_peer_as\", FT_UINT32, BASE_DEC,\n           NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_notify_communication_length,\n        { \"BGP Shutdown Communication Length\", \"bgp.notify.communication_length\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_notify_communication,\n        { \"Shutdown Communication\", \"bgp.notify.communication\", FT_STRING, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n\n        /* Route Refresh */\n      { &hf_bgp_route_refresh_afi,\n        { \"Address family identifier (AFI)\", \"bgp.route_refresh.afi\", FT_UINT16, BASE_DEC,\n          VALS(afn_vals), 0x0, NULL, HFILL }},\n      { &hf_bgp_route_refresh_subtype,\n        { \"Subtype\", \"bgp.route_refresh.subtype\", FT_UINT8, BASE_DEC,\n          VALS(route_refresh_subtype_vals), 0x0, NULL, HFILL }},\n      { &hf_bgp_route_refresh_safi,\n        { \"Subsequent address family identifier (SAFI)\", \"bgp.route_refresh.safi\", FT_UINT8, BASE_DEC,\n          VALS(bgpattr_nlri_safi), 0x0, NULL, HFILL }},\n      { &hf_bgp_route_refresh_orf,\n        { \"ORF information\", \"bgp.route_refresh.orf\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_route_refresh_orf_flag,\n        { \"ORF flag\", \"bgp.route_refresh.orf.flag\", FT_UINT8, BASE_DEC,\n          VALS(orf_when_vals), 0x0, NULL, HFILL }},\n      { &hf_bgp_route_refresh_orf_type,\n        { \"ORF type\", \"bgp.route_refresh.orf.type\", FT_UINT8, BASE_DEC,\n          VALS(orf_type_vals), 0x0, NULL, HFILL }},\n      { &hf_bgp_route_refresh_orf_length,\n        { \"ORF length\", \"bgp.route_refresh.orf.length\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_route_refresh_orf_entry_prefixlist,\n        { \"ORFEntry PrefixList\", \"bgp.route_refresh.orf.entry\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_route_refresh_orf_entry_action,\n        { \"ORFEntry Action\", \"bgp.route_refresh.orf.entry.action\", FT_UINT8, BASE_DEC,\n          VALS(orf_entry_action_vals), BGP_ORF_ACTION, NULL, HFILL }},\n      { &hf_bgp_route_refresh_orf_entry_match,\n        { \"ORFEntry Match\", \"bgp.route_refresh.orf.entry.match\", FT_UINT8, BASE_DEC,\n          VALS(orf_entry_match_vals), BGP_ORF_MATCH, NULL, HFILL }},\n      { &hf_bgp_route_refresh_orf_entry_sequence,\n        { \"ORFEntry Sequence\", \"bgp.route_refresh.orf.entry.sequence\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_route_refresh_orf_entry_prefixmask_lower,\n        { \"ORFEntry PrefixMask length lower bound\", \"bgp.route_refresh.orf.entry.prefixmask_lower\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_route_refresh_orf_entry_prefixmask_upper,\n        { \"ORFEntry PrefixMask length upper bound\", \"bgp.route_refresh.orf.entry.prefixmask_upper\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_route_refresh_orf_entry_ip,\n        { \"ORFEntry IP address\", \"bgp.route_refresh.orf.entry.ip\", FT_IPv4, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n\n        /* Capability */\n      { &hf_bgp_cap,\n        { \"Capability\", \"bgp.cap\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_type,\n        { \"Type\", \"bgp.cap.type\", FT_UINT8, BASE_DEC,\n          VALS(capability_vals), 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_length,\n        { \"Length\", \"bgp.cap.length\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_action,\n        { \"Action\", \"bgp.cap.action\", FT_UINT8, BASE_DEC,\n          VALS(bgpcap_action), 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_unknown,\n        { \"Unknown\", \"bgp.cap.unknown\", FT_BYTES, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_reserved,\n        { \"Reserved\", \"bgp.cap.reserved\", FT_BYTES, BASE_NONE,\n          NULL, 0x0, \"Must be Zero\", HFILL }},\n      { &hf_bgp_cap_mp_afi,\n        { \"AFI\", \"bgp.cap.mp.afi\", FT_UINT16, BASE_DEC,\n          VALS(afn_vals), 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_mp_safi,\n        { \"SAFI\", \"bgp.cap.mp.safi\", FT_UINT8, BASE_DEC,\n          VALS(bgpattr_nlri_safi), 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_enh_afi,\n        { \"AFI\", \"bgp.cap.enh.afi\", FT_UINT16, BASE_DEC,\n          VALS(afn_vals), 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_enh_safi,\n        { \"SAFI\", \"bgp.cap.enh.safi\", FT_UINT16, BASE_DEC,\n          VALS(bgpattr_nlri_safi), 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_enh_nhafi,\n        { \"Next hop AFI\", \"bgp.cap.enh.nhafi\", FT_UINT16, BASE_DEC,\n          VALS(afn_vals), 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_role,\n        { \"BGP Role\", \"bgp.cap.role\", FT_UINT8, BASE_DEC,\n          VALS(bgprole_vals), 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_gr_timers,\n        { \"Restart Timers\", \"bgp.cap.gr.timers\", FT_UINT16, BASE_HEX,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_gr_timers_restart_flag,\n        { \"Restart state\", \"bgp.cap.gr.timers.restart_flag\", FT_BOOLEAN, 16,\n          TFS(&tfs_yes_no), 0x8000, NULL, HFILL }},\n      { &hf_bgp_cap_gr_timers_notification_flag,\n        { \"Graceful notification\", \"bgp.cap.gr.timers.notification_flag\", FT_BOOLEAN, 16,\n          TFS(&tfs_yes_no), 0x4000, NULL, HFILL }},\n      { &hf_bgp_cap_gr_timers_restart_time,\n        { \"Time\", \"bgp.cap.gr.timers.restart_time\", FT_UINT16, BASE_DEC,\n          NULL, 0x0FFF, \"in us\", HFILL }},\n      { &hf_bgp_cap_gr_afi,\n        { \"AFI\", \"bgp.cap.gr.afi\", FT_UINT16, BASE_DEC,\n          VALS(afn_vals), 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_gr_safi,\n        { \"SAFI\", \"bgp.cap.gr.safi\", FT_UINT8, BASE_DEC,\n          VALS(bgpattr_nlri_safi), 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_gr_flag,\n        { \"Flag\", \"bgp.cap.gr.flag\", FT_UINT8, BASE_HEX,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_gr_flag_pfs,\n        { \"Preserve forwarding state\", \"bgp.cap.gr.flag.pfs\", FT_BOOLEAN, 8,\n          TFS(&tfs_yes_no), 0x80, NULL, HFILL }},\n      { &hf_bgp_cap_4as,\n        { \"AS Number\", \"bgp.cap.4as\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_dc,\n        { \"Capability Dynamic\", \"bgp.cap.dc\", FT_UINT8, BASE_DEC,\n          VALS(capability_vals), 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_ap_afi,\n        { \"AFI\", \"bgp.cap.ap.afi\", FT_UINT16, BASE_DEC,\n          VALS(afn_vals), 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_ap_safi,\n        { \"SAFI\", \"bgp.cap.ap.safi\", FT_UINT8, BASE_DEC,\n          VALS(bgpattr_nlri_safi), 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_ap_sendreceive,\n        { \"Send/Receive\", \"bgp.cap.ap.sendreceive\", FT_UINT8, BASE_DEC,\n          VALS(orf_send_recv_vals), 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_orf_afi,\n        { \"AFI\", \"bgp.cap.orf.afi\", FT_UINT16, BASE_DEC,\n          VALS(afn_vals), 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_orf_safi,\n        { \"SAFI\", \"bgp.cap.orf.safi\", FT_UINT8, BASE_DEC,\n          VALS(bgpattr_nlri_safi), 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_orf_number,\n        { \"Number\", \"bgp.cap.orf.number\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_orf_type,\n        { \"Type\", \"bgp.cap.orf.type\", FT_UINT8, BASE_DEC,\n          VALS(orf_type_vals), 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_orf_sendreceive,\n        { \"Send Receive\", \"bgp.cap.orf.sendreceive\", FT_UINT8, BASE_DEC,\n          VALS(orf_send_recv_vals), 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_fqdn_hostname_len,\n        { \"Hostname Length\", \"bgp.cap.orf.fqdn.hostname.len\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_fqdn_hostname,\n        { \"Hostname\", \"bgp.cap.orf.fqdn.hostname\", FT_STRING, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_fqdn_domain_name_len,\n        { \"Domain Name Length\", \"bgp.cap.orf.fqdn.domain_name.len\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_fqdn_domain_name,\n        { \"Domain Name\", \"bgp.cap.orf.fqdn.domain_name\", FT_STRING, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_multisession_flags,\n        { \"Flag\", \"bgp.cap.multisession.flags\", FT_UINT8, BASE_HEX,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_bgpsec_flags,\n        { \"Flag\", \"bgp.cap.bgpsec.flags\", FT_UINT8, BASE_HEX,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_bgpsec_version,\n        { \"Version\", \"bgp.cap.bgpsec.version\", FT_UINT8, BASE_DEC,\n          NULL, 0xF0, NULL, HFILL }},\n      { &hf_bgp_cap_bgpsec_sendreceive,\n        { \"Send/Receive\", \"bgp.cap.bgpsec.sendreceive\", FT_UINT8, BASE_DEC,\n          VALS(bgpsec_send_receive_vals), 0x8, NULL, HFILL }},\n      { &hf_bgp_cap_bgpsec_reserved,\n        { \"Reserved\", \"bgp.cap.bgpsec.reserved\", FT_UINT8, BASE_HEX,\n          NULL, 0x7, \"Must be Zero\", HFILL }},\n      { &hf_bgp_cap_bgpsec_afi,\n        { \"AFI\", \"bgp.cap.bgpsec.afi\", FT_UINT16, BASE_DEC,\n          VALS(afn_vals), 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_soft_version_len,\n        { \"Software Version Length\", \"bgp.cap.software_version.len\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_cap_soft_version,\n        { \"Software Version\", \"bgp.cap.software_version\", FT_STRING, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      /* BGP update */\n\n      { &hf_bgp_update_withdrawn_routes_length,\n        { \"Withdrawn Routes Length\", \"bgp.update.withdrawn_routes.length\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_withdrawn_routes,\n        { \"Withdrawn Routes\", \"bgp.update.withdrawn_routes\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n\n      { &hf_bgp_update_path_attribute_aggregator_as,\n        { \"Aggregator AS\", \"bgp.update.path_attribute.aggregator_as\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      /* BGP update path attributes */\n      { &hf_bgp_update_path_attributes,\n        { \"Path attributes\", \"bgp.update.path_attributes\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attributes_unknown,\n        { \"Unknown Path attributes\", \"bgp.update.path_attributes.unknown\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_total_path_attribute_length,\n        { \"Total Path Attribute Length\", \"bgp.update.path_attributes.length\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_aggregator_origin,\n        { \"Aggregator origin\", \"bgp.update.path_attribute.aggregator_origin\", FT_IPv4, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_as_path_segment,\n        { \"AS Path segment\", \"bgp.update.path_attribute.as_path_segment\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_as_path_segment_type,\n        { \"Segment type\", \"bgp.update.path_attribute.as_path_segment.type\", FT_UINT8, BASE_DEC,\n          VALS(as_segment_type), 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_as_path_segment_length,\n        { \"Segment length (number of ASN)\", \"bgp.update.path_attribute.as_path_segment.length\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_as_path_segment_as2,\n        { \"AS2\", \"bgp.update.path_attribute.as_path_segment.as2\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_as_path_segment_as4,\n        { \"AS4\", \"bgp.update.path_attribute.as_path_segment.as4\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_communities,\n        { \"Communities\", \"bgp.update.path_attribute.communities\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_community,\n        { \"Community\", \"bgp.update.path_attribute.community\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_community_well_known,\n        { \"Community Well-known\", \"bgp.update.path_attribute.community_wellknown\", FT_UINT32, BASE_HEX,\n          VALS(community_vals), 0x0, \"Reserved\", HFILL}},\n      { &hf_bgp_update_path_attribute_community_as,\n        { \"Community AS\", \"bgp.update.path_attribute.community_as\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_community_value,\n        { \"Community value\", \"bgp.update.path_attribute.community_value\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_local_pref,\n        { \"Local preference\", \"bgp.update.path_attribute.local_pref\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_attrset_origin_as,\n        { \"Origin AS\", \"bgp.update.path_attribute.attr_set.origin_as\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_multi_exit_disc,\n        { \"Multiple exit discriminator\", \"bgp.update.path_attribute.multi_exit_disc\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_next_hop,\n        { \"Next hop\", \"bgp.update.path_attribute.next_hop\", FT_IPv4, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_origin,\n        { \"Origin\", \"bgp.update.path_attribute.origin\", FT_UINT8, BASE_DEC,\n          VALS(bgpattr_origin), 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute,\n        { \"Path Attribute\", \"bgp.update.path_attribute\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_flags,\n        { \"Flags\", \"bgp.update.path_attribute.flags\", FT_UINT8, BASE_HEX,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_flags_optional,\n        { \"Optional\", \"bgp.update.path_attribute.flags.optional\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGP_ATTR_FLAG_OPTIONAL, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_flags_transitive,\n        { \"Transitive\", \"bgp.update.path_attribute.flags.transitive\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGP_ATTR_FLAG_TRANSITIVE, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_flags_partial,\n        { \"Partial\", \"bgp.update.path_attribute.flags.partial\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGP_ATTR_FLAG_PARTIAL, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_flags_extended_length,\n        { \"Extended-Length\", \"bgp.update.path_attribute.flags.extended_length\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGP_ATTR_FLAG_EXTENDED_LENGTH, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_flags_unused,\n        { \"Unused\", \"bgp.update.path_attribute.flags.unused\", FT_UINT8, BASE_HEX,\n          NULL, BGP_ATTR_FLAG_UNUSED, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_type_code,\n        { \"Type Code\", \"bgp.update.path_attribute.type_code\", FT_UINT8, BASE_DEC,\n          VALS(bgpattr_type), 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_length,\n        { \"Length\", \"bgp.update.path_attribute.length\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_link_state,\n        { \"Link State\", \"bgp.update.path_attribute.link_state\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n\n      /* BGPsec Path Attributes, RFC8205*/\n      { &hf_bgp_update_path_attribute_bgpsec_sp_len,\n        { \"Length\", \"bgp.update.path_attribute.bgpsec.sp.length\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_bgpsec_sps_pcount,\n        { \"pCount\", \"bgp.update.path_attribute.bgpsec.sps.pcount\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_bgpsec_sps_flags,\n        { \"Flags\", \"bgp.update.path_attribute.bgpsec.sps.flags\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_bgpsec_sps_as,\n        { \"AS Number\", \"bgp.update.path_attribute.bgpsec.sps.as\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_bgpsec_sb_len,\n        { \"Length\", \"bgp.update.path_attribute.bgpsec.sb.length\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_bgpsec_algo_id,\n        { \"Algo ID\", \"bgp.update.path_attribute.bgpsec.sb.algo_id\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_bgpsec_ski,\n        { \"SKI\", \"bgp.update.path_attribute.bgpsec.ss.ski\", FT_BYTES, SEP_SPACE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_bgpsec_sig_len,\n        { \"Length\", \"bgp.update.path_attribute.bgpsec.ss.length\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_bgpsec_sig,\n        { \"Signature\", \"bgp.update.path_attribute.bgpsec.ss.sig\", FT_BYTES, SEP_SPACE,\n          NULL, 0x0, NULL, HFILL}},\n\n      { &hf_bgp_update_path_attribute_mp_reach_nlri_address_family,\n        { \"Address family identifier (AFI)\", \"bgp.update.path_attribute.mp_reach_nlri.afi\", FT_UINT16, BASE_DEC,\n          VALS(afn_vals), 0x0, NULL, HFILL }},\n      { &hf_bgp_update_path_attribute_mp_reach_nlri_safi,\n        { \"Subsequent address family identifier (SAFI)\", \"bgp.update.path_attribute.mp_reach_nlri.safi\", FT_UINT8, BASE_DEC,\n          VALS(bgpattr_nlri_safi), 0x0, NULL, HFILL }},\n      { &hf_bgp_update_path_attribute_mp_reach_nlri_next_hop,\n        { \"Next hop\", \"bgp.update.path_attribute.mp_reach_nlri.next_hop\", FT_BYTES, BASE_NO_DISPLAY_VALUE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_update_path_attribute_mp_reach_nlri_next_hop_rd,\n        { \"Route Distinguisher\", \"bgp.update.path_attribute.mp_reach_nlri.next_hop.rd\", FT_STRING, BASE_NONE,\n          NULL, 0x0, \"RD is always zero in the Next Hop\", HFILL }},\n      { &hf_bgp_update_path_attribute_mp_reach_nlri_next_hop_ipv4,\n        { \"IPv4 Address\", \"bgp.update.path_attribute.mp_reach_nlri.next_hop.ipv4\", FT_IPv4, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_mp_reach_nlri_next_hop_ipv6,\n        { \"IPv6 Address\", \"bgp.update.path_attribute.mp_reach_nlri.next_hop.ipv6\", FT_IPv6, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_mp_reach_nlri_next_hop_ipv6_link_local,\n        { \"Link-local Address\", \"bgp.update.path_attribute.mp_reach_nlri.next_hop.ipv6.link_local\", FT_IPv6, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_mp_reach_nlri_nbr_snpa,\n        { \"Number of Subnetwork points of attachment (SNPA)\", \"bgp.update.path_attribute.mp_reach_nlri.nbr_snpa\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_update_path_attribute_mp_reach_nlri_snpa_length,\n        { \"SNPA Length\", \"bgp.update.path_attribute.mp_reach_nlri.snpa_length\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_update_path_attribute_mp_reach_nlri_snpa,\n        { \"SNPA\", \"bgp.update.path_attribute.mp_reach_nlri.snpa\", FT_BYTES, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_update_path_attribute_mp_reach_nlri,\n        { \"Network Layer Reachability Information (NLRI)\", \"bgp.update.path_attribute.mp_reach_nlri\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n\n      { &hf_bgp_update_path_attribute_mp_unreach_nlri_address_family,\n        { \"Address family identifier (AFI)\", \"bgp.update.path_attribute.mp_unreach_nlri.afi\", FT_UINT16, BASE_DEC,\n          VALS(afn_vals), 0x0, NULL, HFILL }},\n      { &hf_bgp_update_path_attribute_mp_unreach_nlri_safi,\n        { \"Subsequent address family identifier (SAFI)\", \"bgp.update.path_attribute.mp_unreach_nlri.safi\", FT_UINT8, BASE_DEC,\n          VALS(bgpattr_nlri_safi), 0x0, NULL, HFILL }},\n      { &hf_bgp_update_path_attribute_mp_unreach_nlri,\n        { \"Withdrawn Routes\", \"bgp.update.path_attribute.mp_unreach_nlri\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n\n      { &hf_bgp_pmsi_tunnel_flags,\n        { \"Flags\", \"bgp.update.path_attribute.pmsi.tunnel.flags\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_type,\n        { \"Tunnel Type\", \"bgp.update.path_attribute.pmsi.tunnel.type\", FT_UINT8, BASE_DEC,\n          VALS(pmsi_tunnel_type), 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_id,\n        { \"Tunnel ID\", \"bgp.update.path_attribute.pmsi.tunnel.id\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_not_present,\n        { \"Tunnel ID not present\", \"bgp.update.path_attribute.pmsi.tunnel_id.not_present\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_mpls_label,\n        { \"MPLS Label Stack\", \"bgp.update.path_attribute.mpls_label\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_mpls_label_value_20bits,\n        { \"MPLS Label\", \"bgp.update.path_attribute.mpls_label_value_20bits\", FT_UINT24,\n          BASE_DEC, NULL, BGP_MPLS_LABEL, NULL, HFILL}},\n      { &hf_bgp_update_mpls_label_value,\n        { \"MPLS Label\", \"bgp.update.path_attribute.mpls_label_value\", FT_UINT24,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_mpls_traffic_class,\n        { \"Traffic Class\", \"bgp.update.path_attribute.mpls_traffic_class\", FT_UINT24,\n          BASE_HEX, NULL, BGP_MPLS_TRAFFIC_CLASS, NULL, HFILL}},\n      { &hf_bgp_update_mpls_bottom_stack,\n        { \"Bottom-of-Stack\", \"bgp.update.path_attribute.mpls_bottom_stack\", FT_BOOLEAN,\n          24, NULL, BGP_MPLS_BOTTOM_L_STACK, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_rsvp_p2mp_id, /* RFC4875 section 19 */\n        { \"RSVP P2MP id\", \"bgp.update.path_attribute.pmsi.rsvp.id\", FT_IPv4, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_rsvp_p2mp_tunnel_id,\n        { \"RSVP P2MP tunnel id\", \"bgp.update.path_attribute.pmsi.rsvp.tunnel_id\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_rsvp_p2mp_ext_tunnel_idv4,\n        { \"RSVP P2MP extended tunnel id\", \"bgp.update.path_attribute.pmsi.rsvp.ext_tunnel_idv4\", FT_IPv4, BASE_NONE,\n         NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_mldp_fec_el_type,\n        { \"mLDP P2MP FEC element type\", \"bgp.update.path_attribute.pmsi.mldp.fec.type\", FT_UINT8, BASE_DEC,\n         VALS(fec_types_vals), 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_mldp_fec_el_afi,\n        {\"mLDP P2MP FEC element address family\", \"bgp.update.path_attribute.pmsi.mldp.fec.address_family\", FT_UINT16, BASE_DEC,\n         VALS(afn_vals), 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_mldp_fec_el_adr_len,\n        {\"mLDP P2MP FEC element address length\", \"bgp.update.path_attribute.pmsi.mldp.fec.address_length\", FT_UINT8, BASE_DEC,\n         NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_mldp_fec_el_root_nodev4,\n        {\"mLDP P2MP FEC element root node address\", \"bgp.update.path_attribute.pmsi.mldp.fec.root_nodev4\", FT_IPv4, BASE_NONE,\n         NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_mldp_fec_el_root_nodev6,\n        {\"mLDP P2MP FEC element root node address\", \"bgp.update.path_attribute.pmsi.mldp.fec.root_nodev6\", FT_IPv6, BASE_NONE,\n         NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_mldp_fec_el_opa_len,\n        {\"mLDP P2MP FEC element opaque length\", \"bgp.update.path_attribute.pmsi.mldp.fec.opaque_length\", FT_UINT16, BASE_DEC,\n         NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_mldp_fec_el_opa_val_type,\n        {\"mLDP P2MP FEC element opaque value type\", \"bgp.update.path_attribute.pmsi.mldp.fec.opaque_value_type\", FT_UINT8, BASE_DEC,\n         VALS(pmsi_mldp_fec_opaque_value_type), 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_mldp_fec_el_opa_val_len,\n        {\"mLDP P2MP FEC element opaque value length\", \"bgp.update.path_attribute.pmsi.mldp.fec.opaque_value_length\", FT_UINT16, BASE_DEC,\n         NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_mldp_fec_el_opa_value_rn,\n        {\"mLDP P2MP FEC element opaque value unique Id\", \"bgp.update.path_attribute.pmsi.mldp.fec.opaque_value_unique_id_rn\", FT_UINT32, BASE_DEC,\n         NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_mldp_fec_el_opa_value_str,\n        {\"mLDP P2MP FEC element opaque value unique Id\", \"bgp.update.path_attribute.pmsi.mldp.fec.opaque_value_unique_id_str\", FT_STRING, BASE_NONE,\n         NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_mldp_fec_el_opa_val_ext_type,\n        {\"mLDP P2MP FEC element opaque extended value type\", \"bgp.update.path_attribute.pmsi.mldp.fec.opaque_ext_value_type\", FT_UINT16, BASE_DEC,\n         VALS(pmsi_mldp_fec_opa_extented_type), 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_mldp_fec_el_opa_val_ext_len,\n        {\"mLDP P2MP FEC element opaque extended length\", \"bgp.update.path_attribute.pmsi.mldp.fec.opaque_ext_length\", FT_UINT16, BASE_DEC,\n         NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_pimsm_sender,\n        {\"PIM-SM Tree tunnel sender address\", \"bgp.update.path_attribute.pmsi.pimsm.sender_address\", FT_IPv4, BASE_NONE,\n         NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_pimsm_pmc_group,\n        {\"PIM-SM Tree tunnel P-multicast group\", \"bgp.update.path_attribute.pmsi.pimsm.pmulticast_group\", FT_IPv4, BASE_NONE,\n         NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_pimssm_root_node,\n        {\"PIM-SSM Tree tunnel Root Node\", \"bgp.update.path_attribute.pmsi.pimssm.root_node\", FT_IPv4, BASE_NONE,\n         NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_pimssm_pmc_group,\n        {\"PIM-SSM Tree tunnel P-multicast group\", \"bgp.update.path_attribute.pmsi.pimssm.pmulticast_group\", FT_IPv4, BASE_NONE,\n         NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_pimbidir_sender,\n        {\"BIDIR-PIM Tree Tunnel sender address\", \"bgp.update.path_attribute.pmsi.bidir_pim_tree.sender\", FT_IPv4, BASE_NONE,\n         NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_pimbidir_pmc_group,\n        {\"BIDIR-PIM Tree Tunnel P-multicast group\", \"bgp.update.path_attribute.pmsi.bidir_pim_tree.pmulticast_group\", FT_IPv4, BASE_NONE,\n         NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_ingress_rep_addr,\n        {\"Tunnel type ingress replication IP end point\", \"bgp.update.path_attribute.pmsi.ingress_rep_ip\", FT_IPv4, BASE_NONE,\n        NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_pmsi_tunnel_ingress_rep_addr6,\n        {\"Tunnel type ingress replication IP end point\", \"bgp.update.path_attribute.pmsi.ingress_rep_ip6\", FT_IPv6, BASE_NONE,\n        NULL, 0x0, NULL, HFILL}},\n\n        /* BGP Only to Customer (OTC) Attribute, RFC9234 */\n      { &hf_bgp_update_path_attribute_otc,\n        { \"Only to Customer\", \"bgp.update.path_attribute.otc\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n\n        /* https://tools.ietf.org/html/draft-rabadan-sajassi-bess-evpn-ipvpn-interworking-02 */\n      { &hf_bgp_update_path_attribute_d_path,\n        { \"Domain Path Attribute\", \"bgp.update.path_attribute.dpath\", FT_STRING, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_d_path_length,\n        {\"Domain Path Attribute length\", \"bgp.update.attribute.dpath.length\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_d_path_ga,\n        { \"Global Administrator\", \"bgp.update.attribute.dpath.ga\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, \"A four-octet namespace identifier. This SHOULD be an Autonomous System Number\", HFILL }},\n      { &hf_bgp_d_path_la,\n        { \"Local Administrator\", \"bgp.update.attribute.dpath.la\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, \"A two-octet operator-defined value\", HFILL }},\n      { &hf_bgp_d_path_isf_safi,\n        { \"Inter-Subnet Forwarding SAFI type\", \"bgp.update.attribute.dpath.isf.safi\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n\n        /* RFC7311 */\n      { &hf_bgp_update_path_attribute_aigp,\n        { \"AIGP Attribute\", \"bgp.update.path_attribute.aigp\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_aigp_type,\n        {\"AIGP attribute type\", \"bgp.update.attribute.aigp.type\", FT_UINT8, BASE_DEC,\n        VALS(aigp_tlv_type), 0x0, NULL, HFILL }},\n      { &hf_bgp_aigp_tlv_length,\n        {\"AIGP TLV length\", \"bgp.update.attribute.aigp.length\", FT_UINT16, BASE_DEC,\n        NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_aigp_accu_igp_metric,\n        {\"AIGP Accumulated IGP Metric\", \"bgp.update.attribute.aigp.accu_igp_metric\", FT_UINT64, BASE_DEC,\n        NULL, 0x0, NULL, HFILL}},\n\n        /* RFC8092 */\n      { &hf_bgp_large_communities,\n        { \"Large Communities\", \"bgp.large_communities\", FT_STRING, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_large_communities_ga,\n        { \"Global Administrator\", \"bgp.large_communities.ga\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, \"A four-octet namespace identifier. This SHOULD be an Autonomous System Number\", HFILL }},\n      { &hf_bgp_large_communities_ldp1,\n        { \"Local Data Part 1\", \"bgp.large_communities.ldp1\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, \"A four-octet operator-defined value\", HFILL }},\n      { &hf_bgp_large_communities_ldp2,\n        { \"Local Data Part 2\", \"bgp.large_communities.ldp2\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, \"A four-octet operator-defined value\", HFILL }},\n\n        /* RFC4456 */\n       { &hf_bgp_update_path_attribute_originator_id,\n        { \"Originator identifier\", \"bgp.update.path_attribute.originator_id\", FT_IPv4, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_cluster_list,\n        { \"Cluster List\", \"bgp.path_attribute.cluster_list\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_path_attribute_cluster_id,\n        { \"Cluster ID\", \"bgp.path_attribute.cluster_id\", FT_IPv4, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n\n        /* RFC8669 */\n      { &hf_bgp_prefix_sid_unknown,\n        { \"Unknown TLV\", \"bgp.prefix_sid.unknown\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_label_index,\n        { \"Label-Index\", \"bgp.prefix_sid.label_index\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_label_index_value,\n        { \"Label-Index Value\", \"bgp.prefix_sid.label_index.value\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, \"4-octet label index value\", HFILL }},\n      { &hf_bgp_prefix_sid_label_index_flags,\n        { \"Label-Index Flags\", \"bgp.prefix_sid.label_index.flags\", FT_UINT16, BASE_HEX,\n          NULL, 0x0, \"2-octet flags, None is defined\", HFILL }},\n      { &hf_bgp_prefix_sid_originator_srgb_flags,\n        { \"Originator SRGB Flags\", \"bgp.prefix_sid.originator_srgb.flags\", FT_UINT16, BASE_HEX,\n          NULL, 0x0, \"2-octet flags, None is defined\", HFILL }},\n      { &hf_bgp_prefix_sid_originator_srgb,\n        { \"Originator SRGB\", \"bgp.prefix_sid.originator_srgb\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_originator_srgb_blocks,\n        { \"SRGB Blocks\", \"bgp.prefix_sid.originator_srgb_blocks\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_originator_srgb_block,\n        { \"SRGB Block\", \"bgp.prefix_sid.originator_srgb_block\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_originator_srgb_base,\n        { \"SRGB Base\", \"bgp.prefix_sid.originator_srgb_base\", FT_UINT24, BASE_DEC,\n          NULL, 0x0, \"A three-octet value\", HFILL }},\n      { &hf_bgp_prefix_sid_originator_srgb_range,\n        { \"SRGB Range\", \"bgp.prefix_sid.originator_srgb_range\", FT_UINT24, BASE_DEC,\n          NULL, 0x0, \"A three-octet value\", HFILL }},\n      { &hf_bgp_prefix_sid_type,\n        { \"Type\", \"bgp.prefix_sid.type\", FT_UINT8, BASE_DEC,\n          VALS(bgp_prefix_sid_type), 0x0, \"BGP Prefix-SID message type\", HFILL }},\n      { &hf_bgp_prefix_sid_length,\n        { \"Length\", \"bgp.prefix_sid.length\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, \"BGP Prefix-SID message payload\", HFILL }},\n      { &hf_bgp_prefix_sid_value,\n        { \"Value\", \"bgp.prefix_sid.value\", FT_BYTES, BASE_NONE,\n          NULL, 0x0, \"BGP Prefix-SID message value\", HFILL }},\n      { &hf_bgp_prefix_sid_reserved,\n        { \"Reserved\", \"bgp.prefix_sid.reserved\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, \"Unused (must be clear)\", HFILL }},\n\n        /* draft-ietf-bess-srv6-services-05 */\n      { &hf_bgp_prefix_sid_srv6_l3vpn,\n        { \"SRv6 L3 Service\", \"bgp.prefix_sid.srv6_l3vpn\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l3vpn_sub_tlvs,\n        { \"SRv6 Service Sub-TLVs\", \"bgp.prefix_sid.srv6_l3vpn.sub_tlvs\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l3vpn_sub_tlv,\n        { \"SRv6 Service Sub-TLV\", \"bgp.prefix_sid.srv6_l3vpn.sub_tlv\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l3vpn_sub_tlv_type,\n        { \"Type\", \"bgp.prefix_sid.srv6_l3vpn.sub_tlv.type\", FT_UINT8, BASE_DEC,\n          VALS(srv6_service_sub_tlv_type), 0x0, \"SRv6 Service Sub-TLV type\", HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l3vpn_sub_tlv_length,\n        { \"Length\", \"bgp.prefix_sid.srv6_l3vpn.sub_tlv.length\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, \"SRv6 Service Sub-TLV length\", HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l3vpn_sub_tlv_value,\n        { \"Value\", \"bgp.prefix_sid.srv6_l3vpn.sub_tlv.value\", FT_BYTES, BASE_NONE,\n          NULL, 0x0, \"SRv6 Service Sub-TLV value\", HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l3vpn_sub_tlv_reserved,\n        { \"Reserved\", \"bgp.prefix_sid.srv6_l3vpn.sub_tlv.reserved\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, \"Unused (must be clear)\", HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l3vpn_sid_value,\n        { \"SRv6 SID Value\", \"bgp.prefix_sid.srv6_l3vpn.sid_value\", FT_IPv6, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l3vpn_sid_flags,\n        { \"SRv6 SID Flags\", \"bgp.prefix_sid.srv6_l3vpn.sid_flags\", FT_UINT8, BASE_HEX,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l3vpn_srv6_endpoint_behavior,\n        { \"SRv6 Endpoint Behavior\", \"bgp.prefix_sid.srv6_l3vpn.srv6_endpoint_behavior\", FT_UINT16, BASE_HEX,\n          VALS(srv6_endpoint_behavior), 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l3vpn_reserved,\n        { \"Reserved\", \"bgp.prefix_sid.srv6_l3vpn.reserved\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, \"Unused (must be clear)\", HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l3vpn_sub_sub_tlvs,\n        { \"SRv6 Service Data Sub-Sub-TLVs\", \"bgp.prefix_sid.srv6_l3vpn.sub_sub_tlvs\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l3vpn_sub_sub_tlv,\n        { \"SRv6 Service Data Sub-Sub-TLV\", \"bgp.prefix_sid.srv6_l3vpn.sub_sub_tlv\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l3vpn_sub_sub_tlv_type,\n        { \"Type\", \"bgp.prefix_sid.srv6_l3vpn.sub_sub_tlv.type\", FT_UINT8, BASE_DEC,\n          VALS(srv6_service_data_sub_sub_tlv_type), 0x0, \"SRv6 Service Data Sub-Sub-TLV type\", HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l3vpn_sub_sub_tlv_length,\n        { \"Length\", \"bgp.prefix_sid.srv6_l3vpn.sub_sub_tlv.length\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, \"SRv6 Service Data Sub-Sub-TLV length\", HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l3vpn_sub_sub_tlv_value,\n        { \"Value\", \"bgp.prefix_sid.srv6_l3vpn.sub_sub_tlv.value\", FT_BYTES, BASE_NONE,\n          NULL, 0x0, \"SRv6 Service Data Sub-Sub-TLV value\", HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l3vpn_sid_locator_block_len,\n        { \"Locator Block Length\", \"bgp.prefix_sid.srv6_l3vpn.sid.locator_block_len\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l3vpn_sid_locator_node_len,\n        { \"Locator Node Length\", \"bgp.prefix_sid.srv6_l3vpn.sid.locator_node_len\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l3vpn_sid_func_len,\n        { \"Function Length\", \"bgp.prefix_sid.srv6_l3vpn.sid.func_len\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l3vpn_sid_arg_len,\n        { \"Argument Length\", \"bgp.prefix_sid.srv6_l3vpn.sid.arg_len\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l3vpn_sid_trans_len,\n        { \"Transposition Length\", \"bgp.prefix_sid.srv6_l3vpn.sid.trans_len\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l3vpn_sid_trans_offset,\n        { \"Transposition Offset\", \"bgp.prefix_sid.srv6_l3vpn.sid.trans_offset\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn,\n        { \"SRv6 L2 Service\", \"bgp.prefix_sid.srv6_l2vpn\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn_sub_tlvs,\n        { \"SRv6 Service Sub-TLVs\", \"bgp.prefix_sid.srv6_l2vpn.sub_tlvs\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn_sub_tlv,\n        { \"SRv6 Service Sub-TLV\", \"bgp.prefix_sid.srv6_l2vpn.sub_tlv\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn_sub_tlv_type,\n        { \"Type\", \"bgp.prefix_sid.srv6_l2vpn.sub_tlv.type\", FT_UINT8, BASE_DEC,\n          VALS(srv6_service_sub_tlv_type), 0x0, \"SRv6 Service Sub-TLV type\", HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn_sub_tlv_length,\n        { \"Length\", \"bgp.prefix_sid.srv6_l2vpn.sub_tlv.length\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, \"SRv6 Service Sub-TLV length\", HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn_sub_tlv_value,\n        { \"Value\", \"bgp.prefix_sid.srv6_l2vpn.sub_tlv.value\", FT_BYTES, BASE_NONE,\n          NULL, 0x0, \"SRv6 Service Sub-TLV value\", HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn_sub_tlv_reserved,\n        { \"Reserved\", \"bgp.prefix_sid.srv6_l2vpn.sub_tlv.reserved\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, \"Unused (must be clear)\", HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn_sid_value,\n        { \"SRv6 SID Value\", \"bgp.prefix_sid.srv6_l2vpn.sid_value\", FT_IPv6, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn_sid_flags,\n        { \"SRv6 SID Flags\", \"bgp.prefix_sid.srv6_l2vpn.sid_flags\", FT_UINT8, BASE_HEX,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn_srv6_endpoint_behavior,\n        { \"SRv6 Endpoint Behavior\", \"bgp.prefix_sid.srv6_l2vpn.srv6_endpoint_behavior\", FT_UINT16, BASE_HEX,\n          VALS(srv6_endpoint_behavior), 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn_reserved,\n        { \"Reserved\", \"bgp.prefix_sid.srv6_l2vpn.reserved\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, \"Unused (must be clear)\", HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn_sub_sub_tlvs,\n        { \"SRv6 Service Data Sub-Sub-TLVs\", \"bgp.prefix_sid.srv6_l2vpn.sub_sub_tlvs\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn_sub_sub_tlv,\n        { \"SRv6 Service Data Sub-Sub-TLV\", \"bgp.prefix_sid.srv6_l2vpn.sub_sub_tlv\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn_sub_sub_tlv_type,\n        { \"Type\", \"bgp.prefix_sid.srv6_l2vpn.sub_sub_tlv.type\", FT_UINT8, BASE_DEC,\n          VALS(srv6_service_data_sub_sub_tlv_type), 0x0, \"SRv6 Service Data Sub-Sub-TLV type\", HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn_sub_sub_tlv_length,\n        { \"Length\", \"bgp.prefix_sid.srv6_l2vpn.sub_sub_tlv.length\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, \"SRv6 Service Data Sub-Sub-TLV length\", HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn_sub_sub_tlv_value,\n        { \"Value\", \"bgp.prefix_sid.srv6_l2vpn.sub_sub_tlv.value\", FT_BYTES, BASE_NONE,\n          NULL, 0x0, \"SRv6 Service Data Sub-Sub-TLV value\", HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn_sid_locator_block_len,\n        { \"Locator Block Length\", \"bgp.prefix_sid.srv6_l2vpn.sid.locator_block_len\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn_sid_locator_node_len,\n        { \"Locator Node Length\", \"bgp.prefix_sid.srv6_l2vpn.sid.locator_node_len\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn_sid_func_len,\n        { \"Function Length\", \"bgp.prefix_sid.srv6_l2vpn.sid.func_len\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn_sid_arg_len,\n        { \"Argument Length\", \"bgp.prefix_sid.srv6_l2vpn.sid.arg_len\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn_sid_trans_len,\n        { \"Transposition Length\", \"bgp.prefix_sid.srv6_l2vpn.sid.trans_len\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_prefix_sid_srv6_l2vpn_sid_trans_offset,\n        { \"Transposition Offset\", \"bgp.prefix_sid.srv6_l2vpn.sid.trans_offset\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n\n        /* RFC5512 : BGP Encapsulation SAFI and the BGP Tunnel Encapsulation Attribute  */\n      { &hf_bgp_update_encaps_tunnel_tlv_len,\n        { \"length\", \"bgp.update.encaps_tunnel_tlv_len\", FT_UINT16,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_tlv_type,\n        { \"Type code\", \"bgp.update.encaps_tunnel_tlv_type\", FT_UINT16, BASE_DEC,\n          VALS(bgp_attr_tunnel_type), 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_len,\n        { \"length\", \"bgp.update.encaps_tunnel_tlv_sublen\", FT_UINT16,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_type,\n        { \"Type code\", \"bgp.update.encaps_tunnel_subtlv_type\", FT_UINT8, BASE_DEC,\n          VALS(subtlv_type), 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_session_id,\n        { \"Session ID\", \"bgp.update.encaps_tunnel_tlv_subtlv_session_id\", FT_UINT32,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_cookie,\n        { \"Cookie\", \"bgp.update.encaps_tunnel_tlv_subtlv_cookie\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_gre_key,\n        { \"GRE Key\", \"bgp.update.encaps_tunnel_tlv_subtlv_gre_key\", FT_UINT32,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_color_value,\n        { \"Color Value\", \"bgp.update.encaps_tunnel_tlv_subtlv_color_value\", FT_UINT32,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_lb_block_length,\n        { \"Load-balancing block length\", \"bgp.update.encaps_tunnel_tlv_subtlv_lb_block_length\", FT_UINT32,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_vxlan_flags,\n        { \"Flags\", \"bgp.update.encaps_tunnel_tlv_subtlv.vxlan.flags\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_vxlan_flags_valid_vnid,\n        { \"Valid VN-ID\", \"bgp.update.encaps_tunnel_tlv_subtlv.vxlan.flags.valid_vnid\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), TUNNEL_SUBTLV_VXLAN_VALID_VNID, NULL, HFILL }},\n      { &hf_bgp_update_encaps_tunnel_subtlv_vxlan_flags_valid_mac,\n        { \"Valid MAC address\", \"bgp.update.encaps_tunnel_tlv_subtlv.vxlan.flags.valid_mac\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), TUNNEL_SUBTLV_VXLAN_VALID_MAC, NULL, HFILL }},\n      { &hf_bgp_update_encaps_tunnel_subtlv_vxlan_flags_reserved,\n        { \"Reserved\", \"bgp.update.encaps_tunnel_tlv_subtlv.vxlan.flags.reserved\", FT_UINT8,\n          BASE_HEX, NULL, TUNNEL_SUBTLV_VXLAN_RESERVED, NULL, HFILL }},\n      { &hf_bgp_update_encaps_tunnel_subtlv_vxlan_vnid,\n        { \"VN-ID\", \"bgp.update.encaps_tunnel_tlv_subtlv.vxlan.vnid\", FT_UINT24,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_vxlan_mac,\n        { \"MAC\", \"bgp.update.encaps_tunnel_tlv_subtlv.vxlan.mac\", FT_ETHER,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_vxlan_reserved,\n        { \"Reserved\", \"bgp.update.encaps_tunnel_tlv_subtlv.vxlan.reserved\", FT_UINT16,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_vxlan_gpe_flags,\n        { \"Flags\", \"bgp.update.encaps_tunnel_tlv_subtlv.vxlan_gpe.flags\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_vxlan_gpe_flags_version,\n        { \"Version\", \"bgp.update.encaps_tunnel_tlv_subtlv.vxlan_gpe.flags.version\", FT_UINT8,\n          BASE_DEC, NULL, TUNNEL_SUBTLV_VXLAN_GPE_VERSION, NULL, HFILL }},\n      { &hf_bgp_update_encaps_tunnel_subtlv_vxlan_gpe_flags_valid_vnid,\n        { \"Valid VN-ID\", \"bgp.update.encaps_tunnel_tlv_subtlv.vxlan_gpe.flags.valid_vnid\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), TUNNEL_SUBTLV_VXLAN_GPE_VALID_VNID, NULL, HFILL }},\n      { &hf_bgp_update_encaps_tunnel_subtlv_vxlan_gpe_flags_reserved,\n        { \"Reserved\", \"bgp.update.encaps_tunnel_tlv_subtlv.vxlan_gpe.flags.reserved\", FT_UINT8,\n          BASE_HEX, NULL, TUNNEL_SUBTLV_VXLAN_GPE_RESERVED, NULL, HFILL }},\n      { &hf_bgp_update_encaps_tunnel_subtlv_vxlan_gpe_vnid,\n        { \"VN-ID\", \"bgp.update.encaps_tunnel_tlv_subtlv.vxlan_gpe.vnid\", FT_UINT24,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_vxlan_gpe_reserved,\n        { \"Reserved\", \"bgp.update.encaps_tunnel_tlv_subtlv.vxlan_gpe.reserved\", FT_UINT16,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_nvgre_flags,\n        { \"Flags\", \"bgp.update.encaps_tunnel_tlv_subtlv.nvgre.flags\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_nvgre_flags_valid_vnid,\n        { \"Valid VN-ID\", \"bgp.update.encaps_tunnel_tlv_subtlv.nvgre.flags.valid_vnid\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), TUNNEL_SUBTLV_NVGRE_VALID_VNID, NULL, HFILL }},\n      { &hf_bgp_update_encaps_tunnel_subtlv_nvgre_flags_valid_mac,\n        { \"Valid MAC address\", \"bgp.update.encaps_tunnel_tlv_subtlv.nvgre.flags.valid_mac\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), TUNNEL_SUBTLV_NVGRE_VALID_MAC, NULL, HFILL }},\n      { &hf_bgp_update_encaps_tunnel_subtlv_nvgre_flags_reserved,\n        { \"Reserved\", \"bgp.update.encaps_tunnel_tlv_subtlv.nvgre.flags.reserved\", FT_UINT8,\n          BASE_HEX, NULL, TUNNEL_SUBTLV_NVGRE_RESERVED, NULL, HFILL }},\n      { &hf_bgp_update_encaps_tunnel_subtlv_nvgre_vnid,\n        { \"VN-ID\", \"bgp.update.encaps_tunnel_tlv_subtlv.nvgre.vnid\", FT_UINT24,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_nvgre_mac,\n        { \"MAC\", \"bgp.update.encaps_tunnel_tlv_subtlv.nvgre.mac\", FT_ETHER,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_nvgre_reserved,\n        { \"Reserved\", \"bgp.update.encaps_tunnel_tlv_subtlv.nvgre.reserved\", FT_UINT16,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_value,\n        { \"Value\", \"bgp.update.encaps_tunnel_tlv_subtlv.value\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_pref_flags,\n        { \"Flags\", \"bgp.update.encaps_tunnel_tlv_subtlv.pref.flags\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_pref_reserved,\n        { \"Reserved\", \"bgp.update.encaps_tunnel_tlv_subtlv.pref.reserved\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_pref_preference,\n        { \"Preference\", \"bgp.update.encaps_tunnel_tlv_subtlv.pref.preference\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_binding_sid_flags,\n        { \"Flags\", \"bgp.update.encaps_tunnel_tlv_subtlv.binding_sid.flags\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_binding_sid_flags_specified,\n        { \"Specified-BSID-only\", \"bgp.update.encaps_tunnel_tlv_subtlv.binding_sid.flags.specified\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), TUNNEL_SUBTLV_BINDING_SPECIFIED, NULL, HFILL }},\n      { &hf_bgp_update_encaps_tunnel_subtlv_binding_sid_flags_invalid,\n        { \"Drop Upon Invalid\", \"bgp.update.encaps_tunnel_tlv_subtlv.binding_sid.flags.invalid\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), TUNNEL_SUBTLV_BINDING_INVALID, NULL, HFILL }},\n      { &hf_bgp_update_encaps_tunnel_subtlv_binding_sid_flags_reserved,\n        { \"Reserved\", \"bgp.update.encaps_tunnel_tlv_subtlv.binding_sid.flags.reserved\", FT_UINT8,\n          BASE_HEX, NULL, TUNNEL_SUBTLV_BINDING_RESERVED, NULL, HFILL }},\n      { &hf_bgp_update_encaps_tunnel_subtlv_binding_sid_reserved,\n        { \"Reserved\", \"bgp.update.encaps_tunnel_tlv_subtlv.binding_sid.reserved\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_binding_sid_sid,\n        { \"Binding SID\", \"bgp.update.encaps_tunnel_tlv_subtlv.binding_sid.sid\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_enlp_flags,\n        { \"Flags\", \"bgp.update.encaps_tunnel_tlv_subtlv.enlp.flags\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_enlp_reserved,\n        { \"Reserved\", \"bgp.update.encaps_tunnel_tlv_subtlv.enlp.reserved\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_enlp_enlp,\n        { \"ENLP\", \"bgp.update.encaps_tunnel_tlv_subtlv.enlp.preference\", FT_UINT8,\n          BASE_DEC, VALS(bgp_enlp_type), 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_priority_priority,\n        { \"Priority\", \"bgp.update.encaps_tunnel_tlv_subtlv.priority.priority\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_priority_reserved,\n        { \"Reserved\", \"bgp.update.encaps_tunnel_tlv_subtlv.priority.reserved\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_segment_list_reserved,\n        { \"Reserved\", \"bgp.update.encaps_tunnel_tlv_subtlv.segment_list.reserved\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv,\n        { \"sub-TLVs\", \"bgp.update.encaps_tunnel_tlv_subtlv.segment_list.subtlv\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_type,\n        { \"Type\", \"bgp.update.encaps_tunnel_tlv_subtlv.segment_list.subtlv.type\", FT_UINT8,\n          BASE_DEC, VALS(bgp_sr_policy_list_type), 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_length,\n        { \"Length\", \"bgp.update.encaps_tunnel_tlv_subtlv.segment_list.subtlv.length\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_flags,\n        { \"Flags\", \"bgp.update.encaps_tunnel_tlv_subtlv.segment_list_subtlv.flags\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_flags_verification,\n        { \"SID verification\", \"bgp.update.encaps_tunnel_tlv_subtlv.segment_list_subtlv.flags.verification\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), TUNNEL_SUBTLV_SEGMENT_LIST_SUB_VERIFICATION, NULL, HFILL }},\n      { &hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_flags_algorithm,\n        { \"SR Algorithm id\", \"bgp.update.encaps_tunnel_tlv_subtlv.segment_list_subtlv.flags.algorithm\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), TUNNEL_SUBTLV_SEGMENT_LIST_SUB_ALGORITHM, NULL, HFILL }},\n      { &hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_flags_reserved,\n        { \"Reserved\", \"bgp.update.encaps_tunnel_tlv_subtlv.segment_list_subtlv.flags.reserved\", FT_UINT8,\n          BASE_HEX, NULL, TUNNEL_SUBTLV_SEGMENT_LIST_SUB_RESERVED, NULL, HFILL }},\n      { &hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_reserved,\n        { \"Reserved\", \"bgp.update.encaps_tunnel_tlv_subtlv.segment_list_subtlv.reserved\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_mpls_label,\n        { \"MPLS Label\", \"bgp.update.encaps_tunnel_tlv_subtlv.segment_list_subtlv.mpls_label\", FT_UINT24,\n          BASE_HEX, NULL, BGP_MPLS_LABEL, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_traffic_class,\n        { \"Traffic Class\", \"bgp.update.encaps_tunnel_tlv_subtlv.segment_list_subtlv.traffic_class\", FT_UINT24,\n          BASE_HEX, NULL, BGP_MPLS_TRAFFIC_CLASS, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_bottom_stack,\n        { \"Bottom-of-Stack\", \"bgp.update.encaps_tunnel_tlv_subtlv.segment_list_subtlv.bottom_stack\", FT_BOOLEAN,\n          24, NULL, BGP_MPLS_BOTTOM_L_STACK, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_ttl,\n        { \"TTL\", \"bgp.update.encaps_tunnel_tlv_subtlv.segment_list_subtlv.ttl\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_data,\n        { \"Data\", \"bgp.update.encaps_tunnel_tlv_subtlv.segment_list.subtlv.data\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_policy_name_reserved,\n        { \"Reserved\", \"bgp.update.encaps_tunnel_tlv_subtlv.policy_name.reserved\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_update_encaps_tunnel_subtlv_policy_name_name,\n        { \"Policy name\", \"bgp.update.encaps_tunnel_tlv_subtlv.policy_name.name\", FT_STRING,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n\n      /* BGP update path attribut SSA SAFI (deprecated IETF draft) */\n      { &hf_bgp_ssa_t,\n        { \"Transitive bit\", \"bgp.ssa_t\", FT_BOOLEAN, 8,\n          NULL, 0x80, \"SSA Transitive bit\", HFILL}},\n      { &hf_bgp_ssa_type,\n        { \"SSA Type\", \"bgp.ssa_type\", FT_UINT16, BASE_DEC,\n          VALS(bgp_ssa_type), 0x7FFF, NULL, HFILL}},\n      { &hf_bgp_ssa_len,\n        { \"Length\", \"bgp.ssa_len\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, \"SSA Length\", HFILL}},\n      { &hf_bgp_ssa_value,\n        { \"Value\", \"bgp.ssa_value\", FT_BYTES, BASE_NONE,\n          NULL, 0x0, \"SSA Value\", HFILL}},\n      { &hf_bgp_ssa_l2tpv3_pref,\n        { \"Preference\", \"bgp.ssa_l2tpv3_pref\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ssa_l2tpv3_s,\n        { \"Sequencing bit\", \"bgp.ssa_l2tpv3_s\", FT_BOOLEAN, 8,\n          NULL, 0x80, \"Sequencing S-bit\", HFILL}},\n      { &hf_bgp_ssa_l2tpv3_unused,\n        { \"Unused\", \"bgp.ssa_l2tpv3_Unused\", FT_BOOLEAN, 8,\n          NULL, 0x7F, \"Unused Flags\", HFILL}},\n      { &hf_bgp_ssa_l2tpv3_cookie_len,\n        { \"Cookie Length\", \"bgp.ssa_l2tpv3_cookie_len\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ssa_l2tpv3_session_id,\n        { \"Session ID\", \"bgp.ssa_l2tpv3_session_id\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ssa_l2tpv3_cookie,\n        { \"Cookie\", \"bgp.ssa_l2tpv3_cookie\", FT_BYTES, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_withdrawn_prefix,\n        { \"Withdrawn prefix\", \"bgp.withdrawn_prefix\", FT_IPv4, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n\n      /* NLRI header description */\n      { &hf_bgp_update_nlri,\n        { \"Network Layer Reachability Information (NLRI)\", \"bgp.update.nlri\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      /* Global NLRI description */\n      { &hf_bgp_mp_reach_nlri_ipv4_prefix,\n        { \"MP Reach NLRI IPv4 prefix\", \"bgp.mp_reach_nlri_ipv4_prefix\", FT_IPv4, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mp_unreach_nlri_ipv4_prefix,\n        { \"MP Unreach NLRI IPv4 prefix\", \"bgp.mp_unreach_nlri_ipv4_prefix\", FT_IPv4, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mp_reach_nlri_ipv6_prefix,\n        { \"MP Reach NLRI IPv6 prefix\", \"bgp.mp_reach_nlri_ipv6_prefix\", FT_IPv6, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mp_unreach_nlri_ipv6_prefix,\n        { \"MP Unreach NLRI IPv6 prefix\", \"bgp.mp_unreach_nlri_ipv6_prefix\", FT_IPv6, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mp_nlri_tnl_id,\n        { \"MP Reach NLRI Tunnel Identifier\", \"bgp.mp_nlri_tnl_id\", FT_UINT16, BASE_HEX,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_nlri_prefix,\n        { \"NLRI prefix\", \"bgp.nlri_prefix\", FT_IPv4, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_nlri_path_id,\n        { \"NLRI path id\", \"bgp.nlri_path_id\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n\n      /* mcast vpn nlri and capability */\n      { &hf_bgp_mcast_vpn_nlri_t,\n        { \"MCAST-VPN nlri\", \"bgp.mcast_vpn_nlri\", FT_BYTES, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mcast_vpn_nlri_route_type,\n        { \"Route Type\", \"bgp.mcast_vpn_nlri_route_type\", FT_UINT8,\n          BASE_DEC, VALS(mcast_vpn_route_type), 0x0, NULL, HFILL}},\n      { &hf_bgp_mcast_vpn_nlri_length,\n        { \"Length\", \"bgp.mcast_vpn_nlri_length\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mcast_vpn_nlri_rd,\n        { \"Route Distinguisher\", \"bgp.mcast_vpn_nlri_rd\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mcast_vpn_nlri_origin_router_ipv4,\n        { \"Originating Router\", \"bgp.mcast_vpn_nlri_origin_router_ipv4\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mcast_vpn_nlri_origin_router_ipv6,\n        { \"Originating Router\", \"bgp.mcast_vpn_nlri_origin_router_ipv6\", FT_IPv6,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mcast_vpn_nlri_source_as,\n        { \"Source AS\", \"bgp.mcast_vpn_nlri_source_as\", FT_UINT32,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n       { &hf_bgp_mcast_vpn_nlri_source_length,\n        { \"Multicast Source Length\", \"bgp.mcast_vpn_nlri_source_length\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n       { &hf_bgp_mcast_vpn_nlri_group_length,\n        { \"Multicast Group Length\", \"bgp.mcast_vpn_nlri_group_length\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mcast_vpn_nlri_source_addr_ipv4,\n        { \"Multicast Source Address\", \"bgp.mcast_vpn_nlri_source_addr_ipv4\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mcast_vpn_nlri_source_addr_ipv6,\n        { \"Multicast Source Address\", \"bgp.mcast_vpn_nlri_source_addr_ipv6\", FT_IPv6,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mcast_vpn_nlri_group_addr_ipv4,\n        { \"Multicast Group Address\", \"bgp.mcast_vpn_nlri_group_addr_ipv4\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mcast_vpn_nlri_group_addr_ipv6,\n        { \"Group Address\", \"bgp.mcast_vpn_nlri_group_addr_ipv6\", FT_IPv6,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mcast_vpn_nlri_route_key,\n        { \"Route Key\", \"bgp.mcast_vpn_nlri_route_key\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      /* sr policy nlri*/\n      { &hf_bgp_sr_policy_nlri_length,\n        { \"NLRI length\", \"bgp.sr_policy_nlri_length\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, \"NLRI length in bits\", HFILL}},\n      { &hf_bgp_sr_policy_nlri_distinguisher,\n        { \"Distinguisher\", \"bgp.sr_policy_nlri_distinguisher\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_sr_policy_nlri_policy_color,\n        { \"Policy color\", \"bgp.sr_policy_nlri_policy_color\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_sr_policy_nlri_endpoint_v4,\n        { \"Endpoint\", \"bgp.sr_policy_nlri_endpoint_ipv4\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_sr_policy_nlri_endpoint_v6,\n        { \"Endpoint\", \"bgp.sr_policy_nlri_endpoint_ipv6\", FT_IPv6,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n        /* Bgp flow spec nlri and capability */\n      { &hf_bgp_flowspec_nlri_t,\n        { \"FLOW-SPEC nlri\", \"bgp.flowspec_nlri\", FT_BYTES, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_flowspec_nlri_route_distinguisher,\n        { \"Route Distinguisher\", \"bgp.flowspec_route_distinguisher\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_flowspec_nlri_route_distinguisher_type,\n        { \"Route Distinguisher Type\", \"bgp.flowspec_route_distinguisher_type\", FT_UINT16,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_flowspec_nlri_route_dist_admin_asnum_2,\n        { \"Administrator Subfield\", \"bgp.flowspec_route_distinguisher_admin_as_num_2\", FT_UINT16,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_flowspec_nlri_route_dist_admin_ipv4,\n        { \"Administrator Subfield\", \"bgp.flowspec_route_distinguisher_admin_ipv4\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_flowspec_nlri_route_dist_admin_asnum_4,\n        { \"Administrator Subfield\", \"bgp.flowspec_route_distinguisher_admin_as_num_4\", FT_UINT32,\n          BASE_HEX_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_flowspec_nlri_route_dist_asnum_2,\n        { \"Assigned Number Subfield\", \"bgp.flowspec_route_distinguisher_asnum_2\", FT_UINT16,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_flowspec_nlri_route_dist_asnum_4,\n        { \"Assigned Number Subfield\", \"bgp.flowspec_route_distinguisher_asnum_4\", FT_UINT32,\n          BASE_HEX_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_flowspec_nlri_filter,\n        { \"Filter\", \"bgp.flowspec_nlri.filter\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_filter_type,\n        { \"Filter type\", \"bgp.flowspec_nlri.filter_type\", FT_UINT8, BASE_DEC,\n          VALS(flowspec_nlri_opvaluepair_type), 0x0, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_length,\n        { \"NRLI length\", \"bgp.flowspec_nlri.length\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_op_flags,\n        { \"Operator flags\", \"bgp.flowspec_nlri.opflags\", FT_UINT8, BASE_HEX,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_dst_pref_ipv4,\n        { \"Destination IP filter\", \"bgp.flowspec_nlri.dst_prefix_filter\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_flowspec_nlri_src_pref_ipv4,\n        { \"Source IP filter\", \"bgp.flowspec_nlri.src_prefix_filter\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_flowspec_nlri_op_eol,\n        { \"end-of-list\", \"bgp.flowspec_nlri.op.eol\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGPNLRI_FSPEC_END_OF_LST, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_op_and,\n        { \"and\", \"bgp.flowspec_nlri.op.and\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGPNLRI_FSPEC_AND_BIT, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_op_val_len,\n        { \"Value length\", \"bgp.flowspec_nlri.op.val_len\", FT_UINT8, BASE_DEC,\n          VALS(flow_spec_op_len_val), BGPNLRI_FSPEC_VAL_LEN, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_op_un_bit4,\n        { \"Reserved\", \"bgp.flowspec_nlri.op.un_bit4\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGPNLRI_FSPEC_UNUSED_BIT4, \"Unused (must be zero)\",HFILL}},\n      { &hf_bgp_flowspec_nlri_op_un_bit5,\n        { \"Reserved\", \"bgp.flowspec_nlri.op.un_bit5\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGPNLRI_FSPEC_UNUSED_BIT5, \"Unused (must be zero)\", HFILL}},\n      { &hf_bgp_flowspec_nlri_dec_val_8,\n        { \"Decimal value\", \"bgp.flowspec_nlri.dec_val_8\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_dec_val_16,\n        { \"Decimal value\", \"bgp.flowspec_nlri.dec_val_16\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_dec_val_32,\n        { \"Decimal value\", \"bgp.flowspec_nlri.dec_val_32\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_dec_val_64,\n        { \"Decimal value\", \"bgp.flowspec_nlri.dec_val_64\", FT_UINT64, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_op_lt,\n        { \"less than\", \"bgp.flowspec_nlri.op.lt\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGPNLRI_FSPEC_LESS_THAN, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_op_gt,\n        { \"greater than\", \"bgp.flowspec_nlri.op.gt\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGPNLRI_FSPEC_GREATER_THAN, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_op_eq,\n        { \"equal\", \"bgp.flowspec_nlri.op.equal\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGPNLRI_FSPEC_EQUAL, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_op_flg_not,\n        { \"logical negation\", \"bgp.flowspec_nlri.op.flg_not\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGPNLRI_FSPEC_TCPF_NOTBIT, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_op_flg_match,\n        { \"Match bit\", \"bgp.flowspec_nlri.op.flg_match\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGPNLRI_FSPEC_TCPF_MATCHBIT, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_tcp_flags,\n        { \"TCP flags\", \"bgp.flowspec_nlri.val_tcp.flags\", FT_UINT8, BASE_HEX,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_tcp_flags_cwr,\n        { \"Congestion Window Reduced (CWR)\", \"bgp.flowspec_nlri.val_tcp.flags.cwr\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGPNLRI_FSPEC_TH_CWR, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_tcp_flags_ecn,\n        { \"ECN-Echo\", \"bgp.flowspec_nlri.val_tcp.flags.ecn\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGPNLRI_FSPEC_TH_ECN, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_tcp_flags_urg,\n        { \"Urgent\",  \"bgp.flowspec_nlri.val_tcp.flags.urg\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGPNLRI_FSPEC_TH_URG, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_tcp_flags_ack,\n        { \"Acknowledgment\", \"bgp.flowspec_nlri.val_tcp.flags.ack\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGPNLRI_FSPEC_TH_ACK, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_tcp_flags_push,\n        { \"Push\", \"bgp.flowspec_nlri.val_tcp.flags.push\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGPNLRI_FSPEC_TH_PUSH, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_tcp_flags_reset,\n        { \"Reset\", \"bgp.flowspec_nlri.val_tcp.flags.reset\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGPNLRI_FSPEC_TH_RST, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_tcp_flags_syn,\n        { \"Syn\", \"bgp.flowspec_nlri.val_tcp.flags.syn\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGPNLRI_FSPEC_TH_SYN, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_tcp_flags_fin,\n        { \"Fin\", \"bgp.flowspec_nlri.val_tcp.flags.fin\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGPNLRI_FSPEC_TH_FIN, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_fflag,\n        { \"Fragment Flag\", \"bgp.flowspec_nlri.val_frag\", FT_UINT8, BASE_HEX,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_fflag_lf,\n        { \"Last fragment\", \"bgp.flowspec_nlri.val_frag_lf\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGPNLRI_FSPEC_FG_LF, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_fflag_ff,\n        { \"First fragment\", \"bgp.flowspec_nlri.val_frag_ff\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGPNLRI_FSPEC_FG_FF, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_fflag_isf,\n        { \"Is a fragment\", \"bgp.flowspec_nlri.val_frag_isf\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGPNLRI_FSPEC_FG_ISF, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_fflag_df,\n        { \"Don't fragment\", \"bgp.flowspec_nlri.val_frag_df\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGPNLRI_FSPEC_FG_DF, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_dscp,\n        { \"Differentiated Services Codepoint\", \"bgp.flowspec_nlri.val_dsfield\", FT_UINT8, BASE_HEX | BASE_EXT_STRING,\n          &dscp_vals_ext, BGPNLRI_FSPEC_DSCP_BITMASK, NULL, HFILL }},\n      { &hf_bgp_flowspec_nlri_src_ipv6_pref,\n        { \"Source IPv6 prefix\", \"bgp.flowspec_nlri.src_ipv6_pref\", FT_IPv6, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_flowspec_nlri_dst_ipv6_pref,\n        { \"Destination IPv6 prefix\", \"bgp.flowspec_nlri.dst_ipv6_pref\", FT_IPv6, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_flowspec_nlri_ipv6_pref_len,\n        { \"IPv6 prefix length\", \"bgp.flowspec_nlri.ipv6_pref_length\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_flowspec_nlri_ipv6_pref_offset,\n        { \"IPv6 prefix offset\", \"bgp.flowspec_nlri.ipv6_pref_offset\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n        /* end of bgp flow spec */\n        /* BGP update safi ndt nlri  draft-nalawade-idr-mdt-safi-03 */\n      { &hf_bgp_mdt_nlri_safi_rd,\n        { \"Route Distinguisher\", \"bgp.mdt_safi_rd\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mdt_nlri_safi_ipv4_addr,\n        { \"IPv4 Address\", \"bgp.mdt_safi_ipv4_addr\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mdt_nlri_safi_group_addr,\n        { \"Group Address\", \"bgp.mdt_safi_group_addr\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n        /* BGP update extended community header field */\n      { &hf_bgp_ext_communities,\n        { \"Carried extended communities\", \"bgp.ext_communities\", FT_NONE, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ext_community,\n        { \"Community\", \"bgp.ext_community\", FT_NONE, BASE_NONE,\n          NULL, 0x0, \"Extended Community attribute\", HFILL }},\n      { &hf_bgp_ext_com_type_high,\n        { \"Type\", \"bgp.ext_com.type\", FT_UINT8, BASE_HEX,\n          VALS(bgpext_com_type_high), 0x0, \"Extended Community type\", HFILL }},\n      { &hf_bgp_ext_com_type_auth,\n        { \"IANA Authority\", \"bgp.ext_com.type.auth\", FT_BOOLEAN, 8,\n          TFS(&tfs_bgpext_com_type_auth), BGP_EXT_COM_TYPE_AUTH, \"IANA Type Allocation Policy\", HFILL }},\n      {&hf_bgp_ext_com_type_tran,\n        { \"Transitive across ASes\", \"bgp.ext_com.type.tran\", FT_BOOLEAN, 8,\n          TFS(&tfs_non_transitive_transitive), BGP_EXT_COM_TYPE_TRAN, \"Transitivity of the attribute across autonomous systems\", HFILL }},\n      { &hf_bgp_ext_com_stype_low_unknown,\n        { \"Subtype\", \"bgp.ext_com.stype_unknown\", FT_UINT8, BASE_HEX,\n          NULL, 0x0, \"Extended Community subtype\", HFILL }},\n      { &hf_bgp_ext_com_stype_tr_evpn,\n        { \"Subtype (EVPN)\", \"bgp.ext_com.stype_tr_evpn\", FT_UINT8, BASE_HEX,\n          VALS(bgpext_com_stype_tr_evpn), 0x0, \"EVPN Extended Community subtype\", HFILL}},\n      { &hf_bgp_ext_com_stype_tr_as2,\n        { \"Subtype (AS2)\", \"bgp.ext_com.stype_tr_as2\", FT_UINT8, BASE_HEX,\n          VALS(bgpext_com_stype_tr_as2), 0x0, \"2-Octet AS-Specific Transitive Extended Community subtype\", HFILL}},\n      { &hf_bgp_ext_com_stype_ntr_as2,\n        { \"Subtype (Non-transitive AS2)\", \"bgp.ext_com.stype_ntr_as2\", FT_UINT8, BASE_HEX,\n          VALS(bgpext_com_stype_ntr_as2), 0x0, \"2-Octet AS-Specific Non-transitive Extended Community subtype\", HFILL}},\n      { &hf_bgp_ext_com_stype_tr_as4,\n        { \"Subtype (AS4)\", \"bgp.ext_com.stype_tr_as4\", FT_UINT8, BASE_HEX,\n          VALS(bgpext_com_stype_tr_as4), 0x0, \"4-Octet AS-Specific Transitive Extended Community subtype\", HFILL}},\n      { &hf_bgp_ext_com_stype_ntr_as4,\n        { \"Subtype (Non-transitive AS4)\", \"bgp.ext_com.stype_ntr_as4\", FT_UINT8, BASE_HEX,\n          VALS(bgpext_com_stype_ntr_as4), 0x0, \"4-Octet AS-Specific Non-transitive Extended Community subtype\", HFILL}},\n      { &hf_bgp_ext_com_stype_tr_IP4,\n        { \"Subtype (IPv4)\", \"bgp.ext_com.stype_tr_IP4\", FT_UINT8, BASE_HEX,\n          VALS(bgpext_com_stype_tr_IP4), 0x0, \"IPv4-Address-Specific Transitive Extended Community subtype\", HFILL}},\n      { &hf_bgp_ext_com_stype_ntr_IP4,\n        { \"Subtype (Non-transitive IPv4)\", \"bgp.ext_com.stype_ntr_IP4\", FT_UINT8, BASE_HEX,\n          VALS(bgpext_com_stype_ntr_IP4), 0x0, \"IPv4-Address-Specific Non-transitive Extended Community subtype\", HFILL}},\n      { &hf_bgp_ext_com_stype_tr_opaque,\n        { \"Subtype (Opaque)\", \"bgp.ext_com.stype_tr_opaque\", FT_UINT8, BASE_HEX,\n          VALS(bgpext_com_stype_tr_opaque), 0x0, \"Opaque Transitive Extended Community subtype\", HFILL}},\n      { &hf_bgp_ext_com_stype_ntr_opaque,\n        { \"Subtype (Non-transitive Opaque)\", \"bgp.ext_com.stype_ntr_opaque\", FT_UINT8, BASE_HEX,\n          VALS(bgpext_com_stype_ntr_opaque), 0x0, \"Opaque Non-transitive Extended Community subtype\", HFILL}},\n      { &hf_bgp_ext_com_tunnel_type,\n        { \"Tunnel type\", \"bgp.ext_com.tunnel_type\", FT_UINT16, BASE_DEC,\n          VALS(bgpext_com_tunnel_type), 0x0, \"Tunnel encapsulation type\", HFILL}},\n      { &hf_bgp_ext_com_stype_tr_mup,\n        { \"Subtype (MUP)\", \"bgp.ext_com.stype_tr_mup\", FT_UINT8, BASE_HEX,\n          VALS(bgpext_com_stype_tr_mup), 0x0, \"MUP Extended Community subtype\", HFILL}},\n      { &hf_bgp_ext_com_stype_tr_exp,\n        { \"Subtype (Experimental)\", \"bgp.ext_com.stype_tr_exp\", FT_UINT8, BASE_HEX,\n          VALS(bgpext_com_stype_tr_exp), 0x0, \"Experimental Transitive Extended Community subtype\", HFILL}},\n      { &hf_bgp_ext_com_stype_tr_exp_2,\n        { \"Subtype (Experimental Part 2)\", \"bgp.ext_com.stype_tr_exp_2\", FT_UINT8, BASE_HEX,\n          VALS(bgpext_com_stype_tr_exp_2), 0x0, \"Generic Transitive Experimental Use Extended Community Part 2 Sub-Types\", HFILL}},\n      { &hf_bgp_ext_com_stype_tr_exp_3,\n        { \"Subtype (Experimental Part 3)\", \"bgp.ext_com.stype_tr_exp_3\", FT_UINT8, BASE_HEX,\n          VALS(bgpext_com_stype_tr_exp_3), 0x0, \"Generic Transitive Experimental Use Extended Community Part 3 Sub-Types\", HFILL}},\n      { &hf_bgp_ext_com_value_as2,\n        { \"2-Octet AS\", \"bgp.ext_com.value_as2\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, \"Global Administrator Field value (2B Autonomous System Number)\", HFILL }},\n      { &hf_bgp_ext_com_value_as4,\n        { \"4-Octet AS\", \"bgp.ext_com.value_as4\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, \"Global Administrator Field value (4B Autonomous System Number)\", HFILL }},\n      { &hf_bgp_ext_com_value_IP4,\n        { \"IPv4 address\", \"bgp.ext_com.value_IP4\", FT_IPv4, BASE_NONE,\n          NULL, 0x0, \"Global Administrator Field value (IPv4 Address)\", HFILL }},\n      { &hf_bgp_ext_com_value_an2,\n        { \"2-Octet AN\", \"bgp.ext_com.value_an2\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, \"Local Administrator Field value (2B Assigned Number)\", HFILL }},\n      { &hf_bgp_ext_com_value_an4,\n        { \"4-Octet AN\", \"bgp.ext_com.value_an4\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, \"Local Administrator Field value (4B Assigned Number)\", HFILL }},\n      { &hf_bgp_ext_com_value_link_bw,\n        { \"Link bandwidth\", \"bgp.ext_com.value_link_bw\", FT_FLOAT, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ext_com_value_ospf_rt_area,\n        { \"Area ID\", \"bgp.ext_com.value_ospf_rtype.area\", FT_IPv4, BASE_NONE,\n          NULL, 0x0, \"Original OSPF Area ID this route comes from\", HFILL }},\n      { &hf_bgp_ext_com_value_ospf_rt_type,\n        { \"Route type\", \"bgp.ext_com.value_ospf_rtype.type\", FT_UINT8, BASE_DEC,\n          VALS(bgpext_com_ospf_rtype), 0x0, \"Original OSPF LSA Type that carried this route\", HFILL}},\n      { &hf_bgp_ext_com_value_ospf_rt_options,\n        { \"Options\", \"bgp.ext_com.value_ospf_rtype.options\", FT_UINT8, BASE_HEX,\n          NULL, 0x0, \"OSPF Route Type Options bitfield\", HFILL }},\n      { &hf_bgp_ext_com_value_ospf_rt_options_mt,\n        { \"Metric type\", \"bgp.ext_com.value_ospf_rtype.options.mt\", FT_BOOLEAN, 8,\n          TFS(&tfs_ospf_rt_mt), BGP_OSPF_RTYPE_METRIC_TYPE, \"OSPF metric type (Type-1 or Type-2) of the original route\", HFILL }},\n      { &hf_bgp_ext_com_value_ospf_rid,\n        { \"Router ID\", \"bgp.ext_com.value_ospf_rid\", FT_IPv4, BASE_NONE,\n          NULL, 0x0, \"OSPF Router ID of the redistributing PE router\", HFILL }},\n      { &hf_bgp_ext_com_value_fs_remark,\n        { \"Remarking value\", \"bgp.ext_com.value_fs_dscp\", FT_UINT8, BASE_HEX | BASE_EXT_STRING,\n          &dscp_vals_ext, BGPNLRI_FSPEC_DSCP_BITMASK, NULL, HFILL }},\n      { &hf_bgp_ext_com_local_admin_flags,\n        { \"Local Administrator\", \"bgp.ext_com.local_admin\", FT_UINT8, BASE_HEX,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ext_com_local_admin_auto_derived_flag,\n        { \"A-Bit\", \"bgp.ext_com.local_admin.auto_derived\", FT_BOOLEAN, 8,\n          TFS(&tfs_manually_auto_derived), 0x80, NULL, HFILL }},\n      { &hf_bgp_ext_com_local_admin_type,\n        { \"Type\", \"bgp.ext_com.local_admin.type\", FT_UINT8, BASE_DEC,\n          VALS(bgp_ext_com_local_admin_types), 0x70, NULL, HFILL }},\n      { &hf_bgp_ext_com_local_admin_domain_id,\n        { \"Domain Id\", \"bgp.ext_com.local_admin.domain_id\", FT_UINT8, BASE_DEC,\n          NULL, 0x0F, NULL, HFILL }},\n      { &hf_bgp_ext_com_local_admin_service_id,\n        { \"Service Id\", \"bgp.ext_com.local_admin.service_id\", FT_UINT24, BASE_DEC,\n          NULL, 0x00, NULL, HFILL }},\n      { &hf_bgp_ext_com_value_raw,\n        { \"Raw Value\", \"bgp.ext_com.value_raw\", FT_UINT48, BASE_HEX,\n          NULL, 0x0, \"Raw value of the lowmost 6 octets of the Extended Community attribute\", HFILL }},\n            /* BGP update extended community flow spec RFC 5575 */\n      { &hf_bgp_ext_com_flow_act_samp_act,\n        { \"Sample\", \"bgp.ext_com_flow.sample\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGP_EXT_COM_FSPEC_ACT_S, NULL, HFILL }},\n      { &hf_bgp_ext_com_flow_act_term_act,\n        { \"Terminal action\", \"bgp.ext_com_flow.traff_act\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset),BGP_EXT_COM_FSPEC_ACT_T,NULL, HFILL}},\n      { &hf_bgp_ext_com_flow_rate_float,\n        { \"Rate shaper\", \"bgp.ext_com_flow.rate_limit\", FT_FLOAT, BASE_NONE,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ext_com_flow_act_allset,\n        { \"5 Bytes\", \"bgp.flowspec_ext_com.emptybytes\", FT_BYTES, BASE_NONE,\n          NULL, 0x0, \"Must be set to all 0\", HFILL }},\n            /* BGP QoS propagation draft-knoll-idr-qos-attribute */\n      { &hf_bgp_ext_com_qos_flags,\n        { \"Flags\", \"bgp.ext_com_qos.flags\", FT_UINT8, BASE_HEX,\n          NULL, 0, NULL, HFILL}},\n      { &hf_bgp_ext_com_qos_flags_remarking,\n        { \"Remarking\", \"bgp.ext_com_qos.flags.remarking\", FT_BOOLEAN, 8,\n          TFS(&tfs_yes_no), 0x10, NULL, HFILL}},\n      { &hf_bgp_ext_com_qos_flags_ignore_remarking,\n        { \"Ignore remarking\", \"bgp.ext_com_qos.flags.ignore_remarking\", FT_BOOLEAN, 8,\n          TFS(&tfs_yes_no), 0x08, NULL, HFILL}},\n      { &hf_bgp_ext_com_qos_flags_agg_marking,\n        { \"Aggregation of markins\", \"bgp.ext_com_qos.flags.agg_marking\", FT_BOOLEAN, 8,\n          TFS(&tfs_yes_no), 0x04, NULL, HFILL}},\n      { &hf_bgp_ext_com_cos_flags,\n        { \"Flags byte\", \"bgp.ext_com_cos.flags\", FT_UINT8, BASE_HEX,\n          NULL, 0, NULL, HFILL}},\n      { &hf_bgp_ext_com_cos_flags_be,\n        { \"BE class\", \"bgp.ext_com_cos.flags.be\", FT_BOOLEAN, 8,\n          TFS(&tfs_supported_not_supported), 0x80, NULL, HFILL}},\n      { &hf_bgp_ext_com_cos_flags_ef,\n        { \"EF class\", \"bgp.ext_com_cos.flags.ef\", FT_BOOLEAN, 8,\n          TFS(&tfs_supported_not_supported), 0x40, NULL, HFILL}},\n      { &hf_bgp_ext_com_cos_flags_af,\n        { \"AF class\", \"bgp.ext_com_cos.flags.af\", FT_BOOLEAN, 8,\n          TFS(&tfs_supported_not_supported), 0x20, NULL, HFILL}},\n      { &hf_bgp_ext_com_cos_flags_le,\n        { \"LE class\", \"bgp.ext_com_cos.flags.le\", FT_BOOLEAN, 8,\n          TFS(&tfs_supported_not_supported), 0x10, NULL, HFILL}},\n      { &hf_bgp_ext_com_qos_set_number,\n        { \"QoS Set Number\", \"bgp.ext_com_qos.set_number\", FT_UINT8, BASE_HEX,\n          NULL, 0, NULL, HFILL}},\n      { &hf_bgp_ext_com_qos_tech_type,\n        { \"Technology Type\", \"bgp.ext_com_qos.tech_type\", FT_UINT8, BASE_HEX,\n          VALS(qos_tech_type), 0, NULL, HFILL}},\n      { &hf_bgp_ext_com_qos_marking_o,\n        { \"QoS Marking O\", \"bgp.ext_com_qos.marking_o\", FT_UINT16, BASE_HEX,\n          NULL, 0, NULL, HFILL}},\n      { &hf_bgp_ext_com_qos_marking_a,\n        { \"QoS Marking A\", \"bgp.ext_com_qos.marking_a\", FT_UINT8, BASE_HEX_DEC,\n          NULL, 0, NULL, HFILL}},\n      { &hf_bgp_ext_com_qos_default_to_zero,\n        { \"Defaults to zero\", \"bgp.ext_com_qos.default_to_zero\", FT_UINT8, BASE_HEX,\n          NULL, 0, NULL, HFILL}},\n      /* BGP L2 extended community RFC 4761, RFC 6624 */\n            /* draft-ietf-l2vpn-vpls-multihoming */\n      { &hf_bgp_ext_com_l2_encaps,\n        { \"Encaps Type\", \"bgp.ext_com_l2.encaps_type\", FT_UINT8, BASE_DEC,\n          VALS(bgp_l2vpn_encaps), 0, NULL, HFILL}},\n      { &hf_bgp_ext_com_l2_c_flags,\n        { \"Control Flags\", \"bgp.ext_com_l2.c_flags\", FT_UINT8, BASE_HEX,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ext_com_l2_flag_d,\n        { \"Down flag\", \"bgp.ext_com_l2.flag_d\",FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGP_EXT_COM_L2_FLAG_D, NULL, HFILL }},\n      { &hf_bgp_ext_com_l2_flag_z1,\n        { \"Unassigned\", \"bgp.ext_com_l2.flag_z1\",FT_UINT8, BASE_DEC,\n          NULL, BGP_EXT_COM_L2_FLAG_Z1, \"Must be Zero\", HFILL }},\n      { &hf_bgp_ext_com_l2_flag_f,\n        { \"Flush flag\", \"bgp.ext_com_l2.flag_f\",FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGP_EXT_COM_L2_FLAG_F, NULL, HFILL }},\n      { &hf_bgp_ext_com_l2_flag_z345,\n        { \"Unassigned\", \"bgp.ext_com_l2.flag_z345\",FT_UINT8, BASE_DEC,\n          NULL, BGP_EXT_COM_L2_FLAG_Z345, \"Must be Zero\", HFILL }},\n      { &hf_bgp_ext_com_l2_flag_c,\n        { \"C flag\", \"bgp.ext_com_l2.flag_c\",FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGP_EXT_COM_L2_FLAG_C, NULL, HFILL }},\n      { &hf_bgp_ext_com_l2_flag_s,\n        { \"S flag\", \"bgp.ext_com_l2.flag_s\",FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGP_EXT_COM_L2_FLAG_S, NULL, HFILL }},\n      { &hf_bgp_ext_com_l2_mtu,\n        { \"Layer-2 MTU\", \"bgp.ext_com_l2.l2_mtu\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ext_com_l2_esi_label_flag,\n        { \"Single active bit\", \"bgp.ext_com_l2.esi_label_flag\",FT_BOOLEAN, 8,\n          TFS(&tfs_esi_label_flag), BGP_EXT_COM_ESI_LABEL_FLAGS, NULL, HFILL }},\n      { &hf_bgp_ext_com_etree_root_vlan,\n        { \"Root VLAN\", \"bgp.ext_com_etree.root_vlan\", FT_UINT16, BASE_DEC,\n          NULL, 0x0FFF, NULL, HFILL }},\n      { &hf_bgp_ext_com_etree_leaf_vlan,\n        { \"Leaf VLAN\", \"bgp.ext_com_etree.leaf_vlan\", FT_UINT16, BASE_DEC,\n          NULL, 0x0FFF, NULL, HFILL }},\n      { &hf_bgp_ext_com_etree_flags,\n        { \"Flags\", \"bgp.ext_com_etree.flags\", FT_UINT16, BASE_HEX,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ext_com_etree_flag_reserved,\n        { \"Reserved\", \"bgp.ext_com_etree.flag_reserved\",FT_UINT16, BASE_HEX,\n          NULL, BGP_EXT_COM_ETREE_FLAG_RESERVED, NULL, HFILL }},\n      { &hf_bgp_ext_com_etree_flag_p,\n        { \"P\", \"bgp.ext_com_etree.flag_p\",FT_BOOLEAN, 16,\n          TFS(&tfs_set_notset), BGP_EXT_COM_ETREE_FLAG_P, \"PE is attached with leaf nodes only\", HFILL }},\n      { &hf_bgp_ext_com_etree_flag_v,\n        { \"V\", \"bgp.ext_com_etree.flag_v\",FT_BOOLEAN, 16,\n          TFS(&tfs_set_notset), BGP_EXT_COM_ETREE_FLAG_V, \"VLAN mapping\", HFILL }},\n      { &hf_bgp_ext_com_evpn_mmac_flag,\n        { \"Flags\", \"bgp.ext_com_evpn.mmac.flags\", FT_UINT8, BASE_HEX,\n          NULL, 0x0, \"MAC Mobility flags\", HFILL }},\n      { &hf_bgp_ext_com_evpn_mmac_flag_sticky,\n        { \"Sticky/Static MAC\", \"bgp.ext_com_evpn.mmac.flags.sticky\", FT_BOOLEAN, 8,\n          TFS(&tfs_yes_no), BGP_EXT_COM_EVPN_MMAC_STICKY, \"Indicates whether the MAC address is fixed or movable\", HFILL }},\n      { &hf_bgp_ext_com_evpn_mmac_seq,\n        { \"Sequence number\", \"bgp.ext_com_evpn.mmac.seq\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, \"MAC Mobility Update Sequence number\", HFILL }},\n      { &hf_bgp_ext_com_evpn_esirt,\n        { \"ES-Import Route Target\", \"bgp.ext_com_evpn.esi.rt\", FT_ETHER, BASE_NONE,\n          NULL, 0x0, \"Route Target as a MAC Address\", HFILL }},\n      { &hf_bgp_ext_com_evpn_routermac,\n        { \"Router's MAC\", \"bgp.ext_com_evpn.esi.router_mac\", FT_ETHER, BASE_NONE,\n          NULL, 0x0, \"Router's MAC Address\", HFILL }},\n      { &hf_bgp_ext_com_evpn_l2attr_flags,\n        { \"Flags\", \"bgp.ext_com_evpn.l2attr.flags\", FT_UINT16, BASE_HEX,\n          NULL, 0x0, \"EVPN L2 attribute flags\", HFILL }},\n      { &hf_bgp_ext_com_evpn_l2attr_flag_reserved,\n        { \"Reserved\", \"bgp.ext_com_evpn.l2attr.flag_reserved\", FT_UINT16, BASE_HEX,\n          NULL, BGP_EXT_COM_EVPN_L2ATTR_FLAG_RESERVED, NULL, HFILL }},\n      { &hf_bgp_ext_com_evpn_l2attr_flag_ci,\n        { \"CI flag\", \"bgp.ext_com_evpn.l2attr.flag_ci\", FT_BOOLEAN, 16,\n          TFS(&tfs_set_notset), BGP_EXT_COM_EVPN_L2ATTR_FLAG_CI, \"Control Word Indicator Extended Community can be advertised\", HFILL }},\n      { &hf_bgp_ext_com_evpn_l2attr_flag_f,\n        { \"F flag\", \"bgp.ext_com_evpn.l2attr.flag_f\", FT_BOOLEAN, 16,\n          TFS(&tfs_set_notset), BGP_EXT_COM_EVPN_L2ATTR_FLAG_F, \"PE is capable to send and receive flow label\", HFILL }},\n      { &hf_bgp_ext_com_evpn_l2attr_flag_c,\n        { \"C flag\", \"bgp.ext_com_evpn.l2attr.flag_c\", FT_BOOLEAN, 16,\n          TFS(&tfs_set_notset), BGP_EXT_COM_EVPN_L2ATTR_FLAG_C, \"Control word must be present when sending EVPN packets to this PE\", HFILL }},\n      { &hf_bgp_ext_com_evpn_l2attr_flag_p,\n        { \"P flag\", \"bgp.ext_com_evpn.l2attr.flag_p\", FT_BOOLEAN, 16,\n          TFS(&tfs_set_notset), BGP_EXT_COM_EVPN_L2ATTR_FLAG_P, \"Primary PE\", HFILL }},\n      { &hf_bgp_ext_com_evpn_l2attr_flag_b,\n        { \"B flag\", \"bgp.ext_com_evpn.l2attr.flag_b\", FT_BOOLEAN, 16,\n          TFS(&tfs_set_notset), BGP_EXT_COM_EVPN_L2ATTR_FLAG_B, \"Backup PE\", HFILL }},\n      { &hf_bgp_ext_com_evpn_l2attr_l2_mtu,\n        { \"L2 MTU\", \"bgp.ext_com_evpn.l2attr.l2_mtu\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ext_com_evpn_l2attr_reserved,\n        { \"Reserved\", \"bgp.ext_com_evpn.l2attr.reserved\", FT_BYTES, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ext_com_evpn_etree_flags,\n        { \"Flags\", \"bgp.ext_com_evpn.etree.flags\", FT_UINT8, BASE_HEX,\n          NULL, 0x0, \"EVPN E-Tree attribute flags\", HFILL }},\n      { &hf_bgp_ext_com_evpn_etree_flag_reserved,\n        { \"Reserved\", \"bgp.ext_com_evpn.etree.flag_reserved\", FT_UINT8, BASE_HEX,\n          NULL, BGP_EXT_COM_EVPN_ETREE_FLAG_RESERVED, NULL, HFILL }},\n      { &hf_bgp_ext_com_evpn_etree_flag_l,\n        { \"L flag\", \"bgp.ext_com_evpn.etree.flag_l\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), BGP_EXT_COM_EVPN_ETREE_FLAG_L, \"Leaf-Indication\", HFILL }},\n      { &hf_bgp_ext_com_evpn_etree_reserved,\n        { \"Reserved\", \"bgp.ext_com_evpn.etree.reserved\", FT_BYTES, BASE_NONE,\n          NULL, 0x0, NULL, HFILL }},\n      /* BGP Cost Community */\n      { &hf_bgp_ext_com_cost_poi,\n        { \"Point of insertion\", \"bgp.ext_com_cost.poi\", FT_UINT8, BASE_DEC,\n          VALS(bgpext_com_cost_poi_type), 0x0, \"Placement of the Cost value in the BGP Best Path algorithm\", HFILL }},\n      { &hf_bgp_ext_com_cost_cid,\n        { \"Community ID\", \"bgp.ext_com_cost.cid\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, \"Community instance ID to distinguish between multiple Cost communities\", HFILL }},\n      { &hf_bgp_ext_com_cost_cost,\n        { \"Cost\", \"bgp.ext_com_cost.cost\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, \"Cost value\", HFILL }},\n      { &hf_bgp_ext_com_cost_cid_rep,\n        { \"Cost use\", \"bgp.ext_com_cost.cid.use\", FT_BOOLEAN, 8,\n          TFS(&tfs_cost_replace), BGP_EXT_COM_COST_CID_REP, \"Indicates whether the Cost value will replace the original attribute value\", HFILL }},\n      /* EIGRP Route Metrics Extended Communities */\n      { &hf_bgp_ext_com_stype_tr_exp_eigrp,\n        { \"Route Attributes\", \"bgp.ext_com_eigrp\", FT_UINT8, BASE_DEC,\n          VALS(bgpext_com_stype_tr_eigrp), 0x0, \"Original EIGRP route attributes\", HFILL }},\n      { &hf_bgp_ext_com_eigrp_flags,\n        { \"Route flags\", \"bgp.ext_com_eigrp.flags\", FT_UINT16, BASE_HEX,\n          NULL, 0x0, \"EIGRP Route flags bitfield\", HFILL }},\n      { &hf_bgp_ext_com_eigrp_flags_rt,\n        { \"Route type\", \"bgp.ext_com_eigrp.flags.rt\", FT_BOOLEAN, 16,\n          TFS(&tfs_eigrp_rtype), BGP_EXT_COM_EXP_EIGRP_FLAG_RT, \"Original EIGRP route type (internal/external)\", HFILL }},\n      { &hf_bgp_ext_com_eigrp_rtag,\n        { \"Route tag\", \"bgp.ext_com_eigrp.rtag\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, \"Original EIGRP route tag\", HFILL }},\n      { &hf_bgp_ext_com_eigrp_asn,\n        { \"AS Number\", \"bgp.ext_com_eigrp.asn\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, \"Original EIGRP Autonomous System Number this route comes from\", HFILL }},\n      { &hf_bgp_ext_com_eigrp_delay,\n        { \"Delay\", \"bgp.ext_com_eigrp.dly\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, \"Original EIGRP route delay metric\", HFILL }},\n      { &hf_bgp_ext_com_eigrp_rly,\n        { \"Reliability\", \"bgp.ext_com_eigrp.rly\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, \"Original EIGRP route reliability metric\", HFILL }},\n      { &hf_bgp_ext_com_eigrp_hops,\n        { \"Hop count\", \"bgp.ext_com_eigrp.hops\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, \"Original EIGRP route hop count\", HFILL }},\n      { &hf_bgp_ext_com_eigrp_bw,\n        { \"Bandwidth\", \"bgp.ext_com_eigrp.bw\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, \"Original EIGRP route bandwidth metric\", HFILL }},\n      { &hf_bgp_ext_com_eigrp_load,\n        { \"Load\", \"bgp.ext_com_eigrp.load\", FT_UINT8, BASE_DEC,\n          NULL, 0x0, \"Original EIGRP route load metric\", HFILL }},\n      { &hf_bgp_ext_com_eigrp_mtu,\n        { \"MTU\", \"bgp.ext_com_eigrp.mtu\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, \"Original EIGRP route path MTU\", HFILL }},\n      { &hf_bgp_ext_com_eigrp_rid,\n        { \"Router ID\", \"bgp.ext_com_eigrp.rid\", FT_IPv4, BASE_NONE,\n          NULL, 0x0, \"EIGRP Router ID of the router that originated the route\", HFILL }},\n      { &hf_bgp_ext_com_eigrp_e_asn,\n        { \"External AS Number\", \"bgp.ext_com_eigrp.e_asn\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, \"Original AS Number of the route before its redistribution into EIGRP\", HFILL }},\n      { &hf_bgp_ext_com_eigrp_e_rid,\n        { \"External Router ID\", \"bgp.ext_com_eigrp.e_rid\", FT_IPv4, BASE_NONE,\n          NULL, 0x0, \"EIGRP Router ID of the router that redistributed this route into EIGRP\", HFILL }},\n      { &hf_bgp_ext_com_eigrp_e_pid,\n        { \"External protocol\", \"bgp.ext_com_eigrp.e_pid\", FT_UINT16, BASE_DEC,\n          VALS(eigrp_proto2string), 0x0, \"Original routing protocol from which this route was redistributed into EIGRP\", HFILL }},\n      { &hf_bgp_ext_com_eigrp_e_m,\n        { \"External metric\", \"bgp.ext_com_eigrp.e_metric\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, \"Original metric of the route before its redistribution into EIGRP\", HFILL }},\n      { &hf_bgp_ext_com_mup_segment_id2,\n        { \"Segment Identifier 2-byte\", \"bgp.ext_com_mup.segment_id2\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, \"Configurable segment identifier value 2-byte\", HFILL }},\n      { &hf_bgp_ext_com_mup_segment_id4,\n        { \"Segment Identifier 4-byte\", \"bgp.ext_com_mup.segment_id4\", FT_UINT32, BASE_DEC,\n          NULL, 0x0, \"Configurable segment identifier value 4-byte\", HFILL }},\n\n      /* idr-ls-03 */\n      { &hf_bgp_ls_type,\n        { \"Type\", \"bgp.ls.type\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, \"BGP-LS message type\", HFILL }},\n      { &hf_bgp_ls_length,\n        { \"Length\", \"bgp.ls.length\", FT_UINT16, BASE_DEC,\n          NULL, 0x0, \"The total length of the message payload in octets\", HFILL }},\n      { &hf_bgp_ls_nlri,\n        { \"BGP-LS NLRI\", \"bgp.ls.nlri\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_safi128_nlri,\n        { \"Link State SAFI 128 NLRI\", \"bgp.ls.nlri_safi128\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_safi128_nlri_route_distinguisher,\n        { \"Route Distinguisher\", \"bgp.ls.nlri_safi128_route_distinguisher\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_safi128_nlri_route_distinguisher_type,\n        { \"Route Distinguisher Type\", \"bgp.ls.nlri_safi128_route_distinguisher_type\", FT_UINT16,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_safi128_nlri_route_dist_admin_asnum_2,\n        { \"Administrator Subfield\", \"bgp.ls.nlri_safi128_route_distinguisher_admin_as_num_2\", FT_UINT16,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_safi128_nlri_route_dist_admin_ipv4,\n        { \"Administrator Subfield\", \"bgp.ls.nlri_safi128_route_distinguisher_admin_ipv4\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_safi128_nlri_route_dist_admin_asnum_4,\n        { \"Administrator Subfield\", \"bgp.ls.nlri_safi128_route_distinguisher_admin_as_num_4\", FT_UINT32,\n          BASE_HEX_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_safi128_nlri_route_dist_asnum_2,\n        { \"Assigned Number Subfield\", \"bgp.ls.nlri_safi128_route_distinguisher_asnum_2\", FT_UINT16,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_safi128_nlri_route_dist_asnum_4,\n        { \"Assigned Number Subfield\", \"bgp.ls.nlri_safi128_route_distinguisher_asnum_4\", FT_UINT32,\n          BASE_HEX_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_nlri_type,\n        { \"NLRI Type\", \"bgp.ls.nlri_type\", FT_UINT16,\n          BASE_DEC, VALS(bgp_ls_nlri_type_vals), 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_nlri_length,\n        { \"NLRI Length\", \"bgp.ls.nlri_length\", FT_UINT16,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_nlri_link_nlri_type,\n        { \"Link-State NLRI Link NLRI\", \"bgp.ls.nlri_link\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_nlri_link_descriptors_tlv,\n        { \"Link Descriptors TLV\", \"bgp.ls.nlri_link_descriptors_tlv\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_nlri_prefix_descriptors_tlv,\n        { \"Prefix Descriptors TLV\", \"bgp.ls.nlri_prefix_descriptors_tlv\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_nlri_srv6_sid_descriptors_tlv,\n        { \"SRv6 SID Descriptors TLV\", \"bgp.ls.nlri_srv6_sid_descriptors_tlv\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_nlri_link_local_identifier,\n        { \"Link Local Identifier\", \"bgp.ls.nlri_link_local_identifier\", FT_UINT32,\n          BASE_HEX_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_nlri_link_remote_identifier,\n        { \"Link Remote Identifier\", \"bgp.ls.nlri_link_remote_identifier\", FT_UINT32,\n          BASE_HEX_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_nlri_ipv4_interface_address,\n        { \"IPv4 Interface Address\", \"bgp.ls.nlri_ipv4_interface_address\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_nlri_ipv4_neighbor_address,\n        { \"IPv4 Neighbor Address\", \"bgp.ls.nlri_ipv4_neighbor_address\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_nlri_ipv6_interface_address,\n        { \"IPv6 Interface Address\", \"bgp.ls.nlri_ipv6_interface_address\", FT_IPv6,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_nlri_ipv6_neighbor_address,\n        { \"IPv6 Neighbor Address\", \"bgp.ls.nlri_ipv6_neighbor_address\", FT_IPv6,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_nlri_multi_topology_id,\n        { \"Multi Topology ID\", \"bgp.ls.nlri_multi_topology_id\", FT_UINT16,\n          BASE_DEC_HEX, NULL, 0x0fff, NULL, HFILL}},\n      { &hf_bgp_ls_nlri_ospf_route_type,\n        { \"OSPF Route Type\", \"bgp.ls.nlri_ospf_route_type\", FT_UINT8,\n          BASE_DEC, VALS(link_state_prefix_descriptors_ospf_route_type), 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_nlri_ip_reachability_prefix_ip,\n       { \"Reachability prefix\", \"bgp.ls.nlri_ip_reachability_prefix_ip\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_nlri_ip_reachability_prefix_ip6,\n       { \"Reachability prefix\", \"bgp.ls.nlri_ip_reachability_prefix_ip6\", FT_IPv6,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_nlri_node_nlri_type,\n        { \"Link-State NLRI Node NLRI\", \"bgp.ls.nlri_node\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_nlri_node_protocol_id,\n        { \"Protocol ID\", \"bgp.ls.nlri_node.protocol_id\", FT_UINT8,\n          BASE_DEC, VALS(link_state_nlri_protocol_id_values), 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_nlri_node_identifier,\n        { \"Identifier\", \"bgp.ls.nlri_node.identifier\", FT_UINT64,\n          BASE_DEC | BASE_VAL64_STRING, VALS64(link_state_nlri_routing_universe_values), 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_ipv4_topology_prefix_nlri_type,\n        { \"Link-State NLRI IPv4 Topology Prefix\", \"bgp.ls.ipv4_topology_prefix\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_ipv6_topology_prefix_nlri_type,\n        { \"Link-State NLRI IPv6 Topology Prefix\", \"bgp.ls.ipv6_topology_prefix\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_nlri_srv6_sid_nlri_type,\n        { \"Link-State NLRI SRv6 SID NLRI\", \"bgp.ls.nlri_srv6_sid\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n       /* NLRI TLVs */\n      { &hf_bgp_ls_tlv_local_node_descriptors,\n        { \"Local Node Descriptors TLV\", \"bgp.ls.tlv.local_node_descriptors\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_remote_node_descriptors,\n        { \"Remote Node Descriptors TLV\", \"bgp.ls.tlv.remote_node_descriptors\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_autonomous_system,\n        { \"Autonomous System TLV\", \"bgp.ls.tlv.autonomous_system\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_autonomous_system_id,\n        { \"AS ID\", \"bgp.ls.tlv.autonomous_system.id\", FT_UINT32,\n          BASE_DEC_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_bgp_ls_identifier,\n        { \"BGP-LS Identifier TLV\", \"bgp.ls.tlv.bgp_ls_identifier\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_bgp_ls_identifier_id,\n        { \"BGP-LS ID\", \"bgp.ls.tlv.bgp_ls_identifier_id\", FT_UINT32,\n          BASE_DEC_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_area_id,\n        { \"Area ID TLV\", \"bgp.ls.tlv.area_id\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_area_id_id,\n        { \"Area ID\", \"bgp.ls.tlv.area_id.id\", FT_UINT32,\n          BASE_DEC_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_ipv4_router_id_of_local_node,\n        { \"IPv4 Router-ID of Local Node TLV\", \"bgp.ls.tlv.ipv4_router_id_of_local_node\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_tlv_ipv4_router_id_value,\n        { \"IPv4 Router-ID\", \"bgp.ls.tlv.ipv4_router_id_value\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_ipv6_router_id_of_local_node,\n        { \"IPv6 Router-ID of Local Node TLV\", \"bgp.ls.tlv.ipv6_router_id_of_local_node\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_tlv_ipv6_router_id_value,\n        { \"IPv6 Router-ID\", \"bgp.ls.tlv.ipv6_router_id_value\", FT_IPv6,\n          BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_tlv_ipv4_router_id_of_remote_node,\n        { \"IPv4 Router-ID of Remote Node TLV\", \"bgp.ls.tlv.ipv4_router_id_of_remote_node\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_tlv_ipv6_router_id_of_remote_node,\n        { \"IPv6 Router-ID of Remote Node TLV\", \"bgp.ls.tlv.ipv6_router_id_of_remote_node\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_tlv_link_local_remote_identifiers,\n        { \"Link Local/Remote Identifiers TLV\", \"bgp.ls.tlv.link_local_remote_identifiers\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_tlv_ipv4_interface_address,\n        {  \"IPv4 interface address TLV\", \"bgp.ls.tlv.ipv4_interface_address\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_tlv_ipv4_neighbor_address,\n        { \"IPv4 neighbor address TLV\", \"bgp.ls.tlv.ipv4_neighbor_address\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_ipv6_interface_address,\n        { \"IPv6 interface address TLV\", \"bgp.ls.tlv.ipv6_interface_address\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_ipv6_neighbor_address,\n        { \"IPv6 neighbor address TLV\", \"bgp.ls.tlv.ipv6_neighbor_address\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_node_msd,\n        { \"Node MSD TLV\", \"bgp.ls.tlv.node_msd\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_link_msd,\n        { \"Link MSD TLV\", \"bgp.ls.tlv.link_msd\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_igp_msd_type,\n        { \"MSD Type\", \"bgp.ls.tlv.igp_msd_type\", FT_UINT8,\n          BASE_DEC, VALS(igp_msd_types), 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_tlv_igp_msd_value,\n        { \"MSD Value\", \"bgp.ls.tlv.igp_msd_value\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_tlv_multi_topology_id,\n        { \"Multi Topology ID TLV\", \"bgp.ls.tlv.multi_topology_id\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_ospf_route_type,\n        { \"OSPF Route Type TLV\", \"bgp.ls.tlv.ospf_route_type\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_ip_reachability_information,\n        { \"IP Reachability Information TLV\", \"bgp.ls.tlv.ip_reachability_information\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_administrative_group_color,\n        { \"Administrative group (color) TLV\", \"bgp.ls.tlv.administrative_group_color\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_administrative_group_color_value,\n        { \"Group Mask\", \"bgp.ls.tlv.administrative_group_color_value\", FT_UINT32,\n         BASE_DEC, NULL, 0xffff, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_administrative_group,\n        { \"Group\", \"bgp.ls.tlv.administrative_group\", FT_UINT32,\n         BASE_DEC, NULL, 0xffff, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_max_link_bandwidth,\n        { \"Maximum link bandwidth TLV\", \"bgp.ls.tlv.maximum_link_bandwidth\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_max_reservable_link_bandwidth,\n        { \"Maximum reservable link bandwidth TLV\", \"bgp.ls.tlv.maximum_reservable_link_bandwidth\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_unreserved_bandwidth,\n        { \"Unreserved bandwidth TLV\", \"bgp.ls.tlv.unreserved_bandwidth\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_bandwidth_value,\n        {\"Bandwidth\", \"bgp.ls.bandwidth_value\", FT_FLOAT,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_te_default_metric,\n        { \"TE Default Metric TLV\", \"bgp.ls.tlv.te_default_metric\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_te_default_metric_value_old,\n        { \"TE Default Metric (old format)\", \"bgp.ls.tlv.te_default_metric_value.old\", FT_UINT24,\n          BASE_HEX_DEC, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_tlv_te_default_metric_value,\n        { \"TE Default Metric\", \"bgp.ls.tlv.te_default_metric_value\", FT_UINT32,\n          BASE_HEX_DEC, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_tlv_link_protection_type,\n        { \"Link Protection Type TLV\", \"bgp.ls.tlv.link_protection_type\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_link_protection_type_value,\n        { \"Protection Capabilities\", \"bgp.ls.tlv.link_protection_type_value\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_mpls_protocol_mask,\n        { \"MPLS Protocol Mask TLV\", \"bgp.ls.tlv.mpls_protocol_mask\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_metric,\n        { \"Metric TLV\", \"bgp.ls.tlv.metric\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_metric_value1,\n        { \"IGP Metric\", \"bgp.ls.tlv.metric_value\", FT_UINT8,\n          BASE_HEX_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_metric_value2,\n        { \"IGP Metric\", \"bgp.ls.tlv.metric_value\", FT_UINT16,\n          BASE_HEX_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_metric_value3,\n        { \"IGP Metric\", \"bgp.ls.tlv.metric_value\", FT_UINT24,\n          BASE_HEX_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_shared_risk_link_group,\n        { \"Shared Risk Link Group TLV\", \"bgp.ls.tlv.shared_risk_link_group\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_shared_risk_link_group_value,\n        { \"Shared Risk Link Group Value\", \"bgp.ls.tlv.shared_risk_link_group_value\", FT_UINT32,\n          BASE_HEX_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_opaque_link_attribute,\n        { \"Opaque Link Attribute TLV\", \"bgp.ls.tlv.opaque_link_attribute\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_opaque_link_attribute_value,\n        { \"Opaque link attributes\", \"bgp.ls.tlv.opaque_link_attribute_value\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_link_name_attribute,\n        { \"Opaque Link Attribute TLV\", \"bgp.ls.tlv.link_name_attribute\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_link_name_attribute_value,\n        {\"Link Name\", \"bgp.ls.tlv.link_name_attribute_value\", FT_STRING,\n          BASE_NONE, NULL, 0, NULL, HFILL }},\n      { &hf_bgp_ls_tlv_igp_flags,\n        { \"IGP Flags TLV\", \"bgp.ls.tlv.igp_flags\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_route_tag,\n        { \"Route Tag TLV\", \"bgp.ls.tlv.route_tag\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_route_tag_value,\n        { \"Route Tag Value\", \"bgp.ls.tlv.route_tag_value\", FT_UINT32,\n          BASE_HEX_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_route_extended_tag,\n        { \"Extended Route Tag TLV\", \"bgp.ls.tlv.route_extended_tag\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_route_extended_tag_value,\n        {\"Extended Route Tag\", \"bgp.ls.tlv.extended_route_tag_value\", FT_UINT64,\n          BASE_HEX_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_prefix_metric,\n        { \"Prefix Metric TLV\", \"bgp.ls.tlv.prefix_metric\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_prefix_metric_value,\n        { \"Prefix Metric\", \"bgp.ls.tlv.prefix_metric_value\", FT_UINT32,\n          BASE_HEX_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_ospf_forwarding_address,\n        { \"OSPF Forwarding Address TLV\", \"bgp.ls.tlv.ospf_forwarding_address\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_ospf_forwarding_address_ipv4_address,\n        { \"OSPF forwarding IPv4 address\", \"bgp.ls.tlv.ospf_forwarding_address_ipv4\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_ospf_forwarding_address_ipv6_address,\n        { \"OSPF forwarding IPv6 address\", \"bgp.ls.tlv.ospf_forwarding_address_ipv6\", FT_IPv6,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_opaque_prefix_attribute,\n        { \"Opaque Prefix Attribute TLV\", \"bgp.ls.tlv.opaque_prefix_attribute\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_opaque_prefix_attribute_value,\n        { \"Opaque prefix attributes\", \"bgp.ls.tlv.opaque_prefix_attribute_value\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_extended_administrative_group,\n        { \"Extended Administrative Group TLV\", \"bgp.ls.tlv.extended_administrative_group\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_extended_administrative_group_value,\n        { \"Extended Administrative Group\", \"bgp.ls.tlv.extended_administrative_group_value\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_igp_router,\n        { \"IGP Router-ID\", \"bgp.ls.tlv.igp_router\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_igp_router_id,\n        { \"IGP ID\", \"bgp.ls.tlv.igp_router_id\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_bgp_router_id,\n        { \"BGP Router-ID TLV\", \"bgp.ls.tlv.bgp_router_id\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_bgp_router_id_id,\n        { \"BGP Router-ID\", \"bgp.ls.tlv.bgp_router_id.id\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_srv6_sid_info,\n        { \"SRv6 SID Information TLV\", \"bgp.ls.tlv.srv6_sid_info\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_srv6_sid_info_sid,\n        { \"SID\", \"bgp.ls.tlv.srv6_sid_info.sid\", FT_IPv6,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_node_flags_bits,\n        { \"Node Flags Bits TLV\", \"bgp.ls.tlv.node_flags_bits\", FT_NONE,\n         BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_opaque_node_properties,\n        { \"Opaque Node Properties TLV\", \"bgp.ls.tlv.opaque_node_properties\", FT_NONE,\n         BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_opaque_node_properties_value,\n        { \"Opaque Node Properties\", \"bgp.ls.tlv.opaque_node_properties_value\", FT_NONE,\n         BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_node_name,\n        { \"Node Name TLV\", \"bgp.ls.tlv.node_name\", FT_NONE,\n         BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_node_name_value,\n        {\"Node name\", \"bgp.ls.tlv.node_name_value\", FT_STRING,\n         BASE_NONE, NULL, 0, NULL, HFILL }},\n      { &hf_bgp_ls_tlv_is_is_area_identifier,\n        { \"IS-IS Area Identifier TLV\", \"bgp.ls.tlv.is_is_area_identifier\", FT_NONE,\n         BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_is_is_area_identifier_value,\n        { \"IS-IS Area Identifier\", \"bgp.ls.tlv.is_is_area_identifier_value\", FT_BYTES,\n         BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      /* Link Protection Types */\n      { &hf_bgp_ls_link_protection_type_enhanced,\n        { \"Enhanced\", \"bgp.ls.link_protection_type.enhanced\", FT_BOOLEAN, 8,\n          TFS(&tfs_capable_not_capable), 0x20, NULL, HFILL }},\n      { &hf_bgp_ls_link_protection_type_dedicated_1plus1,\n        { \"Dedicated 1+1\", \"bgp.ls.link_protection_type.dedicated_1plus1\", FT_BOOLEAN, 8,\n          TFS(&tfs_capable_not_capable), 0x10, NULL, HFILL }},\n      { &hf_bgp_ls_link_protection_type_dedicated_1to1,\n        { \"Dedicated 1:1\", \"bgp.ls.link_protection_type.dedicated_1colon1\", FT_BOOLEAN, 8,\n          TFS(&tfs_capable_not_capable), 0x08, NULL, HFILL }},\n      { &hf_bgp_ls_link_protection_type_shared,\n        { \"Shared\", \"bgp.ls.link_protection_type.shared\", FT_BOOLEAN, 8,\n          TFS(&tfs_capable_not_capable), 0x04, NULL, HFILL }},\n      { &hf_bgp_ls_link_protection_type_unprotected,\n        { \"Unprotected\", \"bgp.ls.link_protection_type.unprotected\", FT_BOOLEAN, 8,\n          TFS(&tfs_capable_not_capable), 0x02, NULL, HFILL }},\n      { &hf_bgp_ls_link_protection_type_extra_traffic,\n        { \"Extra Traffic\", \"bgp.ls.link_protection_type.extra_traffic\", FT_BOOLEAN, 8,\n          TFS(&tfs_capable_not_capable), 0x01, NULL, HFILL }},\n      /* MPLS Protocol Mask flags */\n      { &hf_bgp_ls_mpls_protocol_mask_flag_l,\n        { \"Label Distribution Protocol (LDP)\", \"bgp.ls.protocol_mask_tlv.mpls_protocol.l\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), 0x80, NULL, HFILL}},\n      { &hf_bgp_ls_mpls_protocol_mask_flag_r,\n        { \"Extension to RSVP for LSP Tunnels (RSVP-TE)\", \"bgp.ls.protocol_mask_tlv.mpls_protocol.r\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), 0x40, NULL, HFILL}},\n      /* IGP Flags TLV */\n      { &hf_bgp_ls_igp_flags_flag_d,\n        { \"IS-IS Up/Down Bit\", \"bgp.ls.protocol_mask_tlv.igp_flags_flag_d.d\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), 0x80, NULL, HFILL}},\n      /* Node Flag Bits TLV flags */\n      { &hf_bgp_ls_node_flag_bits_overload,\n        { \"Overload Bit\", \"bgp.ls.node_flag_bits.overload\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), 0x80, NULL, HFILL}},\n      { &hf_bgp_ls_node_flag_bits_attached,\n        { \"Attached Bit\", \"bgp.ls.node_flag_bits.attached\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), 0x40, NULL, HFILL}},\n      { &hf_bgp_ls_node_flag_bits_external,\n        { \"External Bit\", \"bgp.ls.node_flag_bits.external\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), 0x20, NULL, HFILL}},\n      { &hf_bgp_ls_node_flag_bits_abr,\n        { \"ABR Bit\", \"bgp.ls.node_flag_bits.abr\", FT_BOOLEAN, 8,\n          TFS(&tfs_set_notset), 0x10, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri,\n        { \"EVPN NLRI\", \"bgp.evpn.nlri\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri_rt,\n        { \"Route Type\", \"bgp.evpn.nlri.rt\", FT_UINT8, BASE_DEC,\n          VALS(evpnrtypevals), 0x0, NULL, HFILL }},\n      { &hf_bgp_evpn_nlri_len,\n        { \"Length\", \"bgp.evpn.nlri.len\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri_rd,\n        { \"Route Distinguisher\", \"bgp.evpn.nlri.rd\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri_esi,\n        { \"ESI\", \"bgp.evpn.nlri.esi\", FT_BYTES,\n          SEP_COLON, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_evpn_nlri_esi_type,\n        { \"ESI Type\", \"bgp.evpn.nlri.esi.type\", FT_UINT8,\n          BASE_DEC, VALS(evpn_nlri_esi_type), 0x0, \"EVPN ESI type\", HFILL }},\n      { &hf_bgp_evpn_nlri_esi_lacp_mac,\n        { \"CE LACP system MAC\", \"bgp.evpn.nlri.esi.lacp_mac\", FT_ETHER,\n          BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_evpn_nlri_esi_portk,\n        { \"LACP port key\", \"bgp.evpn.nlri.esi.lacp_portkey\", FT_UINT16,\n          BASE_DEC_HEX, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_evpn_nlri_esi_remain,\n        { \"Remaining bytes\", \"bgp.evpn.nlri.esi.remaining\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_evpn_nlri_esi_reserved,\n        { \"Reserved value all 0xff\", \"bgp.evpn.nlri.esi.reserved\", FT_BYTES,\n         BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_evpn_nlri_esi_value,\n        { \"ESI Value\", \"bgp.evpn.nlri.esi.value\", FT_BYTES,\n          SEP_SPACE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_evpn_nlri_esi_value_type0,\n        { \"ESI 9 bytes value\", \"bgp.evpn.nlri.esi.type0\", FT_BYTES,\n          SEP_SPACE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_evpn_nlri_esi_rb_mac,\n        { \"ESI root bridge MAC\", \"bgp.evpn.nlri.esi.root_bridge\", FT_ETHER,\n          BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_evpn_nlri_esi_rbprio,\n        { \"ESI root bridge priority\", \"bgp.evpn.nlri.esi.rb_prio\", FT_UINT16,\n          BASE_DEC_HEX, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_evpn_nlri_esi_sys_mac,\n        { \"ESI system MAC\", \"bgp.evpn.nlri.esi.system_mac\", FT_ETHER,\n          BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_evpn_nlri_esi_mac_discr,\n        { \"ESI system mac discriminator\", \"bgp.evpn.nlri.esi.system_mac_discr\", FT_BYTES,\n          SEP_SPACE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_evpn_nlri_esi_router_id,\n        { \"ESI router ID\", \"bgp.evpn.nlri.esi.router_id\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_evpn_nlri_esi_router_discr,\n        { \"ESI router discriminator\", \"bgp.evpn.nlri.esi.router_discr\", FT_BYTES,\n          SEP_SPACE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_evpn_nlri_esi_asn,\n        { \"ESI ASN\", \"bgp.evpn.nlri.esi.asn\", FT_UINT32,\n          BASE_DEC, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_evpn_nlri_esi_asn_discr,\n        { \"ESI ASN discriminator\", \"bgp.evpn.nlri.esi.asn_discr\", FT_BYTES,\n          SEP_SPACE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_evpn_nlri_etag,\n       { \"Ethernet Tag ID\", \"bgp.evpn.nlri.etag\", FT_UINT32,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri_mpls_ls1,\n        { \"MPLS Label 1\", \"bgp.evpn.nlri.mpls_ls1\", FT_UINT24,\n          BASE_DEC, NULL, BGP_MPLS_LABEL, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri_mpls_ls2,\n        { \"MPLS Label 2\", \"bgp.evpn.nlri.mpls_ls2\", FT_UINT24,\n          BASE_DEC, NULL, BGP_MPLS_LABEL, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri_vni,\n        { \"VNI\", \"bgp.evpn.nlri.vni\", FT_UINT24,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri_maclen,\n       { \"MAC Address Length\", \"bgp.evpn.nlri.maclen\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri_mac_addr,\n        { \"MAC Address\", \"bgp.evpn.nlri.mac_addr\", FT_ETHER,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri_iplen,\n        { \"IP Address Length\", \"bgp.evpn.nlri.iplen\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri_prefix_len,\n        { \"IP prefix length\", \"bgp.evpn.nlri.prefix_len\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri_ip_addr,\n        { \"IPv4 address\", \"bgp.evpn.nlri.ip.addr\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri_ipv6_addr,\n        { \"IPv6 address\", \"bgp.evpn.nlri.ipv6.addr\", FT_IPv6,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri_ipv4_gtw,\n        { \"IPv4 Gateway address\", \"bgp.evpn.nlri.ipv4.gtw_addr\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri_ipv6_gtw,\n        { \"IPv6 Gateway address\", \"bgp.evpn.nlri.ipv6.gtw_addr\", FT_IPv6,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n     /* segment routing extentions to link state */\n     /* Node Attributes TLVs */\n      { &hf_bgp_ls_sr_tlv_capabilities,\n        { \"SR Capabilities\", \"bgp.ls.sr.tlv.capabilities\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_capabilities_flags,\n        { \"Flags\", \"bgp.ls.sr.tlv.capabilities.flags\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_capabilities_flags_i,\n        { \"MPLS IPv4 flag (I)\", \"bgp.ls.sr.tlv.capabilities.flags.i\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_CAPABILITY_FLAG_I, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_capabilities_flags_v,\n        { \"MPLS IPv6 flag (V)\", \"bgp.ls.sr.tlv.capabilities.flags.v\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_CAPABILITY_FLAG_V, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_capabilities_flags_h,\n        { \"SR-IPv6 flag (H)\", \"bgp.ls.sr.tlv.capabilities.flags.h\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_CAPABILITY_FLAG_H, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_capabilities_flags_reserved,\n        { \"Reserved\", \"bgp.ls.sr.tlv.capabilities.flags.reserved\", FT_UINT8,\n          BASE_HEX, NULL, 0x1F, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_capabilities_range_size,\n        { \"Range Size\", \"bgp.ls.sr.tlv.capabilities.range_size\", FT_UINT24,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_capabilities_sid_label,\n        { \"From Label\", \"bgp.ls.sr.tlv.capabilities.sid.label\", FT_UINT24,\n          BASE_DEC, NULL, 0x0FFFFF, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_capabilities_sid_index,\n        { \"From Index\", \"bgp.ls.sr.tlv.capabilities.sid.index\", FT_UINT32,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_algorithm,\n        { \"SR Algorithm TLV\", \"bgp.ls.sr.tlv.algorithm\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_algorithm_value,\n        { \"SR Algorithm\", \"bgp.ls.sr.tlv.algorithm.value\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_local_block,\n        { \"SR Local Block\", \"bgp.ls.sr.tlv.local_block\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_srv6_cap,\n        { \"SRv6 Capabilities TLV\", \"bgp.ls.sr.tlv.srv6_capabilities\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_srv6_cap_flags,\n        { \"Flags\", \"bgp.ls.sr.tlv.srv6_capabilities.flags\", FT_UINT16,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_srv6_cap_flags_o,\n        { \"OAM flag (O)\", \"bgp.ls.sr.tlv.srv6_capabilities.flags.o\", FT_BOOLEAN,\n          16, TFS(&tfs_set_notset), BGP_LS_SRV6_CAP_FLAG_O, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_srv6_cap_flags_reserved,\n        { \"Reserved\", \"bgp.ls.sr.tlv.srv6_capabilities.flags.reserved\", FT_UINT16,\n          BASE_HEX, NULL, 0x3fff, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_srv6_cap_reserved,\n        { \"Reserved\", \"bgp.ls.sr.tlv.srv6_capabilities.reserved\", FT_UINT16,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_local_block_flags,\n        { \"Flags\", \"bgp.ls.sr.tlv.local_block.flags\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_local_block_range_size,\n        { \"Range Size\", \"bgp.ls.sr.tlv.local_block.range_size\", FT_UINT24,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_local_block_sid_label,\n        { \"From Label\", \"bgp.ls.sr.tlv.local_block.sid.label\", FT_UINT24,\n          BASE_DEC, NULL, 0x0FFFFF, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_local_block_sid_index,\n        { \"From Index\", \"bgp.ls.sr.tlv.local_block.sid.index\", FT_UINT32,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_flex_algo_def,\n        { \"Flexible Algorithm Definition TLV\", \"bgp.ls.sr.tlv.flex_algo\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_flex_algo_algorithm,\n        { \"Flex-Algorithm\", \"bgp.ls.sr.tlv.flex_algo.flex_algorithm\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_flex_algo_metric_type,\n        { \"Metric-Type\", \"bgp.ls.sr.tlv.flex_algo.metric_type\", FT_UINT8,\n          BASE_DEC, VALS(flex_algo_metric_types), 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_flex_algo_calc_type,\n        { \"Calculation-Type\", \"bgp.ls.sr.tlv.flex_algo.calculation_type\", FT_UINT8,\n          BASE_DEC, VALS(igp_algo_types), 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_flex_algo_priority,\n        { \"Priority\", \"bgp.ls.sr.tlv.flex_algo.priority\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_flex_algo_exc_any_affinity,\n        { \"Flex Algo Exclude Any Affinity TLV\", \"bgp.ls.sr.tlv.flex_algo.exclude_any_affinity\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_flex_algo_inc_any_affinity,\n        { \"Flex Algo Include Any Affinity TLV\", \"bgp.ls.sr.tlv.flex_algo.include_any_affinity\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_flex_algo_inc_all_affinity,\n        { \"Flex Algo Include All Affinity TLV\", \"bgp.ls.sr.tlv.flex_algo.include_all_affinity\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n     /* Prefix Attribute TLVs */\n      { &hf_bgp_ls_sr_tlv_prefix_sid,\n        { \"Prefix SID TLV\", \"bgp.ls.sr.tlv.prefix.sid\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_prefix_sid_flags,\n        { \"Flags\", \"bgp.ls.sr.tlv.prefix.sid.flags\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_prefix_sid_flags_r,\n        { \"Re-advertisement (R)\", \"bgp.ls.sr.tlv.prefix.sid.flags.r\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_PREFIX_SID_FLAG_R, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_prefix_sid_flags_n,\n        { \"Node-SID (N)\", \"bgp.ls.sr.tlv.prefix.sid.flags.n\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_PREFIX_SID_FLAG_N, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_prefix_sid_flags_np,\n        { \"No-PHP (NP)\", \"bgp.ls.sr.tlv.prefix.sid.flags.np\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_PREFIX_SID_FLAG_NP, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_prefix_sid_flags_p,\n        { \"No-PHP (P)\", \"bgp.ls.sr.tlv.prefix.sid.flags.p\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_PREFIX_SID_FLAG_P, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_prefix_sid_flags_m,\n        { \"Mapping Server Flag (M)\", \"bgp.ls.sr.tlv.prefix.sid.flags.m\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_PREFIX_SID_FLAG_M, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_prefix_sid_flags_e,\n        { \"Explicit-Null (E)\", \"bgp.ls.sr.tlv.prefix.sid.flags.e\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_PREFIX_SID_FLAG_E, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_prefix_sid_flags_v,\n        { \"Value (V)\", \"bgp.ls.sr.tlv.prefix.sid.flags.v\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_PREFIX_SID_FLAG_V, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_prefix_sid_flags_l,\n        { \"Local (L)\", \"bgp.ls.sr.tlv.prefix.sid.flags.l\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_PREFIX_SID_FLAG_L, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_prefix_sid_algo,\n        { \"Algorithm\", \"bgp.ls.sr.tlv.prefix.sid.algo\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_prefix_sid_label,\n        { \"SID/Label\", \"bgp.ls.sr.tlv.prefix.sid.label\", FT_UINT24,\n          BASE_DEC, NULL, 0x0FFFFF, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_prefix_sid_index,\n        { \"SID/Index\", \"bgp.ls.sr.tlv.prefix.sid.index\", FT_UINT32,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_srv6_locator,\n        { \"SRv6 Locator TLV\", \"bgp.ls.sr.tlv.srv6_locator\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_srv6_locator_flags,\n        { \"Flags\", \"bgp.ls.sr.tlv.srv6_locator.flags\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_srv6_locator_flags_d,\n        { \"Down flag (D)\", \"bgp.ls.sr.tlv.srv6_locator.flags.d\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SRV6_LOC_FLAG_D, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_srv6_locator_flags_reserved,\n        { \"Reserved\", \"bgp.ls.sr.tlv.srv6_locator.flags.reserved\", FT_UINT8,\n          BASE_HEX, NULL, BGP_LS_SRV6_LOC_FLAG_RESERVED, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_srv6_locator_algo,\n        { \"Algorithm\", \"bgp.ls.sr.tlv.srv6_locator.algorithm\",\n          FT_UINT8, BASE_DEC, VALS(igp_algo_types), 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_srv6_locator_reserved,\n        { \"Reserved\", \"bgp.ls.sr.tlv.srv6_locator.reserved\", FT_UINT16,\n          BASE_HEX, NULL, 0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_srv6_locator_metric,\n        { \"Metric\", \"bgp.ls.sr.tlv.srv6_locator.metric\", FT_UINT32,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_prefix_attr_flags,\n        { \"Prefix Attribute Flags TLV\", \"bgp.ls.sr.tlv.prefix.attribute_flags\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_prefix_attr_flags_flags,\n        { \"Flags\", \"bgp.ls.sr.tlv.prefix.attribute_flags.flags\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_prefix_attr_flags_flags_unknown,\n        { \"Flags\", \"bgp.ls.sr.tlv_prefix.attribute_flags.flags.unknown\", FT_BYTES,\n          SEP_SPACE, NULL, 0x0,NULL, HFILL }},\n      { &hf_bgp_ls_sr_tlv_prefix_attr_flags_flags_ao,\n        { \"Attach (A)\", \"bgp.ls.sr.tlv.prefix.attribute_flags.flags.a\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_PREFIX_ATTR_FLAGS_FLAG_AO, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_prefix_attr_flags_flags_no,\n        { \"Node (N)\", \"bgp.ls.sr.tlv.prefix.attribute_flags.flags.n\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_PREFIX_ATTR_FLAGS_FLAG_NO, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_prefix_attr_flags_flags_eo,\n        { \"ELC (E)\", \"bgp.ls.sr.tlv.prefix.attribute_flags.flags.e\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_PREFIX_ATTR_FLAGS_FLAG_EO, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_prefix_attr_flags_flags_xi,\n        { \"External Prefix (X)\", \"bgp.ls.sr.tlv.prefix.attribute_flags.flags.x\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_PREFIX_ATTR_FLAGS_FLAG_XI, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_prefix_attr_flags_flags_ri,\n        { \"Re-advertisement (X)\", \"bgp.ls.sr.tlv.prefix.attribute_flags.flags.r\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_PREFIX_ATTR_FLAGS_FLAG_RI, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_prefix_attr_flags_flags_ni,\n        { \"Node (N)\", \"bgp.ls.sr.tlv.prefix.attribute_flags.flags.n\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_PREFIX_ATTR_FLAGS_FLAG_NI, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_prefix_attr_flags_flags_ei,\n        { \"ELC (E)\", \"bgp.ls.sr.tlv.prefix.attribute_flags.flags.e\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_PREFIX_ATTR_FLAGS_FLAG_EI, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_source_router_id,\n        { \"Source Router-ID TLV\", \"bgp.ls.sr.tlv.source_router_id\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n     /* SID Attribute TLVs */\n      { &hf_bgp_ls_sr_tlv_srv6_endpoint_behavior,\n        { \"SRv6 Endpoint Behavior TLV\", \"bgp.ls.sr.tlv.srv6_endpoint_behavior\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_srv6_endpoint_behavior_endpoint_behavior,\n        { \"Endpoint Behavior\", \"bgp.ls.sr.tlv.srv6_endpoint_behavior.endpoint_behavior\", FT_UINT16,\n          BASE_HEX, VALS(srv6_endpoint_behavior), 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_srv6_endpoint_behavior_flags,\n        { \"Flags\", \"bgp.ls.sr.tlv.srv6_endpoint_behavior.flags\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_srv6_endpoint_behavior_algo,\n        { \"Algorithm\", \"bgp.ls.sr.tlv.srv6_endpoint_behavior.algorithm\",\n          FT_UINT8, BASE_DEC, VALS(igp_algo_types), 0x0, NULL, HFILL}},\n     /* Adjacency Attribute TLVs */\n      { &hf_bgp_ls_sr_tlv_adjacency_sid,\n        { \"Adjacency SID TLV\", \"bgp.ls.sr.tlv.adjacency.sid\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_adjacency_sid_flags,\n        { \"Flags\", \"bgp.ls.sr.tlv.adjacency.sid.flags\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_adjacency_sid_flags_fi,\n        { \"Address-Family flag (F)\", \"bgp.ls.sr.tlv.adjacency.sid.flags.f\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_ADJACENCY_SID_FLAG_FI, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_adjacency_sid_flags_bo,\n        { \"Backup Flag (B)\", \"bgp.ls.sr.tlv.adjacency.sid.flags.b\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_ADJACENCY_SID_FLAG_BO, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_adjacency_sid_flags_bi,\n        { \"Backup Flag (B)\", \"bgp.ls.sr.tlv.adjacency.sid.flags.b\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_ADJACENCY_SID_FLAG_BI, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_adjacency_sid_flags_vo,\n        { \"Value Flag (V)\", \"bgp.ls.sr.tlv.adjacency.sid.flags.v\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_ADJACENCY_SID_FLAG_VO, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_adjacency_sid_flags_vi,\n        { \"Value Flag (V)\", \"bgp.ls.sr.tlv.adjacency.sid.flags.v\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_ADJACENCY_SID_FLAG_VI, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_adjacency_sid_flags_lo,\n        { \"Local Flag (L)\", \"bgp.ls.sr.tlv.adjacency.sid.flags.l\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_ADJACENCY_SID_FLAG_LO, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_adjacency_sid_flags_li,\n        { \"Local Flag (L)\", \"bgp.ls.sr.tlv.adjacency.sid.flags.l\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_ADJACENCY_SID_FLAG_LI, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_adjacency_sid_flags_so,\n        { \"Set Flag (S)\", \"bgp.ls.sr.tlv.adjacency.sid.flags.s\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_ADJACENCY_SID_FLAG_SO, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_adjacency_sid_flags_si,\n        { \"Set Flag (S)\", \"bgp.ls.sr.tlv.adjacency.sid.flags.s\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_ADJACENCY_SID_FLAG_SI, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_adjacency_sid_weight,\n        { \"Weight\", \"bgp.ls.sr.tlv.adjacency.sid.weight\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_adjacency_sid_label,\n        { \"SID/Label\", \"bgp.ls.sr.tlv.adjacency.sid.label\", FT_UINT24,\n          BASE_DEC, NULL, 0x0FFFFF, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_adjacency_sid_index,\n        { \"SID/Index\", \"bgp.ls.sr.tlv.adjacency.sid.index\", FT_UINT32,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_peer_node_sid,\n        { \"PeerNode SID TLV\", \"bgp.ls.sr.tlv.peer_node.sid\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_peer_adj_sid,\n        { \"PeerAdj SID TLV\", \"bgp.ls.sr.tlv.peer_adj.sid\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_peer_set_sid,\n        { \"PeerSet SID TLV\", \"bgp.ls.sr.tlv.peer_set.sid\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_peer_sid_flags,\n        { \"Flags\", \"bgp.ls.sr.tlv.peer.sid.flags\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_peer_sid_flags_v,\n        { \"Value flag (V)\", \"bgp.ls.sr.tlv.peer.sid.flags.v\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_PEER_SID_FLAG_V, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_peer_sid_flags_l,\n        { \"Local flag (L)\", \"bgp.ls.sr.tlv.peer.sid.flags.l\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_PEER_SID_FLAG_L, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_peer_sid_flags_b,\n        { \"Backup flag (B)\", \"bgp.ls.sr.tlv.peer.sid.flags.b\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_PEER_SID_FLAG_B, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_peer_sid_flags_p,\n        { \"Persistent flag (P)\", \"bgp.ls.sr.tlv.peer.sid.flags.p\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_SR_PEER_SID_FLAG_P, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_peer_sid_weight,\n        { \"Weight\", \"bgp.ls.sr.tlv.peer.sid.weight\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_peer_sid_label,\n        { \"SID/Label\", \"bgp.ls.sr.tlv.peer.sid.label\", FT_UINT24,\n          BASE_DEC, NULL, 0x0FFFFF, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_peer_sid_index,\n        { \"SID/Index\", \"bgp.ls.sr.tlv.peer.sid.index\", FT_UINT32,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_sr_tlv_srv6_endx_sid,\n        { \"SRv6 End.X SID TLV\", \"bgp.ls.sr.tlv.srv6_endx_sid\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_sr_tlv_srv6_lan_endx_sid,\n        { \"SRv6 LAN End.X SID TLV\", \"bgp.ls.sr.tlv.srv6_lan_endx_sid\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_sr_tlv_srv6_endx_sid_endpoint_behavior,\n        { \"Endpoint Behavior\", \"bgp.ls.sr.tlv.srv6_endx_sid.endpoint_behavior\",\n          FT_UINT16, BASE_DEC, VALS(srv6_endpoint_behavior), 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_sr_tlv_srv6_endx_sid_flags,\n        { \"Flags\", \"bgp.ls.sr.tlv.srv6_endx_sid.flags\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_sr_tlv_srv6_endx_sid_flags_b,\n        { \"Backup flag\", \"bgp.ls.sr.tlv.srv6_endx_sid.flags.b\",\n          FT_BOOLEAN, 8, TFS(&tfs_set_notset), BGP_LS_SRV6_ENDX_SID_FLAG_B, NULL, HFILL }},\n      { &hf_bgp_ls_sr_tlv_srv6_endx_sid_flags_s,\n        { \"Set flag\", \"bgp.ls.sr.tlv.srv6_endx_sid.flags.s\",\n          FT_BOOLEAN, 8, TFS(&tfs_set_notset), BGP_LS_SRV6_ENDX_SID_FLAG_S, NULL, HFILL }},\n      { &hf_bgp_ls_sr_tlv_srv6_endx_sid_flags_p,\n        { \"Persistent flag\", \"bgp.ls.sr.tlv.srv6_endx_sid.flags.p\",\n          FT_BOOLEAN, 8, TFS(&tfs_set_notset), BGP_LS_SRV6_ENDX_SID_FLAG_P, NULL, HFILL }},\n      { &hf_bgp_ls_sr_tlv_srv6_endx_sid_flags_reserved,\n        { \"Reserved\", \"bgp.ls.sr.tlv.srv6_endx_sid.flags.reserved\",\n          FT_UINT8, BASE_HEX, NULL, BGP_LS_SRV6_ENDX_SID_FLAG_RESERVED, NULL, HFILL }},\n      { &hf_bgp_ls_sr_tlv_srv6_endx_sid_algo,\n        { \"Algorithm\", \"bgp.ls.sr.tlv.srv6_endx_sid.algorithm\",\n          FT_UINT8, BASE_DEC, VALS(igp_algo_types), 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_sr_tlv_srv6_endx_sid_weight,\n        { \"Weight\", \"bgp.ls.sr.tlv.srv6_endx_sid.weight\",\n          FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_sr_tlv_srv6_endx_sid_reserved,\n        { \"Reserved\", \"bgp.ls.sr.tlv.srv6_endx_sid.reserved\",\n          FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_sr_tlv_srv6_endx_sid_neighbor_ospf,\n        { \"Neighbor-ID\", \"bgp.ls.tlv.srv6_endx_sid.neighbor_id_ospf\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_sr_tlv_srv6_endx_sid_neighbor_isis,\n        { \"Neighbor-ID\", \"bgp.ls.tlv.srv6_endx_sid.neighbor_id_isis\", FT_SYSTEM_ID,\n          BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_sr_tlv_srv6_endx_sid_sid,\n        { \"SID\", \"bgp.ls.sr.tlv.srv6_endx_sid.sid\",\n          FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_sr_tlv_srv6_sid_struct,\n        { \"SRv6 SID Structure TLV\", \"bgp.ls.sr.tlv.srv6_sid_structure\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_sr_tlv_srv6_sid_struct_lb_len,\n        { \"Locator Block Length\", \"bgp.ls.sr.tlv.srv6_sid_structure.locator_block_len\",\n          FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_sr_tlv_srv6_sid_struct_ln_len,\n        { \"Locator Node Length\", \"bgp.ls.sr.tlv.srv6_sid_structure.locator_node_len\",\n          FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_sr_tlv_srv6_sid_struct_fun_len,\n        { \"Function Length\", \"bgp.ls.sr.tlv.srv6_sid_structure.fun_len\",\n          FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\n      { &hf_bgp_ls_sr_tlv_srv6_sid_struct_arg_len,\n        { \"Arguments Length\", \"bgp.ls.sr.tlv.srv6_sid_structure.arg_len\",\n          FT_UINT8, BASE_DEC, NULL, 0x0,NULL, HFILL }},\n      { &hf_bgp_ls_igp_te_metric_flags,\n        { \"TE Metric Flags\", \"bgp.ls.igp_te_metric.flags\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_igp_te_metric_flags_a,\n        { \"Anomalous (A) bit\", \"bgp.ls.igp_te_metric.flags.a\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), BGP_LS_IGP_TE_METRIC_FLAG_A, NULL, HFILL}},\n      { &hf_bgp_ls_igp_te_metric_flags_reserved,\n        { \"Reserved\", \"bgp.ls.igp_te_metric.flags.reserved\", FT_UINT8,\n          BASE_HEX, NULL, BGP_LS_IGP_TE_METRIC_FLAG_RESERVED, NULL, HFILL}},\n      { &hf_bgp_ls_igp_te_metric_delay,\n        { \"Unidirectional Link Delay TLV\", \"bgp.ls.igp_te_metric.delay\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_igp_te_metric_delay_value,\n        { \"Delay\", \"bgp.ls.igp_te_metric.delay_value\", FT_UINT24,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_igp_te_metric_delay_min_max,\n        { \"Min/Max Unidirectional Link Delay TLV\", \"bgp.ls.igp_te_metric.delay_min_max\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_igp_te_metric_delay_min,\n        { \"Min Delay\", \"bgp.ls.igp_te_metric.delay_min\", FT_UINT24,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_igp_te_metric_delay_max,\n        { \"Max Delay\", \"bgp.ls.igp_te_metric.delay_max\", FT_UINT24,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_igp_te_metric_delay_variation,\n        { \"Unidirectional Delay Variation TLV\", \"bgp.ls.igp_te_metric.delay_variation\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_igp_te_metric_delay_variation_value,\n        { \"Delay Variation\", \"bgp.ls.igp_te_metric.delay_variation_value\", FT_UINT24,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_igp_te_metric_link_loss,\n        { \"Unidirectional Link Loss TLV\", \"bgp.ls.igp_te_metric.link_loss\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_igp_te_metric_link_loss_value,\n        { \"Link Loss\", \"bgp.ls.igp_te_metric.link_loss_value\", FT_UINT24,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_igp_te_metric_bandwidth_residual,\n        { \"Unidirectional Residual Bandwidth TLV\", \"bgp.ls.igp_te_metric.residual_bandwidth\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_igp_te_metric_bandwidth_residual_value,\n        { \"Residual Bandwidth\", \"bgp.ls.igp_te_metric.residual_bandwidth_value\", FT_UINT32,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_igp_te_metric_bandwidth_available,\n        { \"Unidirectional Available Bandwidth TLV\", \"bgp.ls.igp_te_metric.available_bandwidth\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_igp_te_metric_bandwidth_available_value,\n        { \"Residual Bandwidth\", \"bgp.ls.igp_te_metric.available_bandwidth_value\", FT_UINT32,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_igp_te_metric_bandwidth_utilized,\n        { \"Unidirectional Utilized Bandwidth TLV\", \"bgp.ls.igp_te_metric.utilized_bandwidth\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_igp_te_metric_bandwidth_utilized_value,\n        { \"Utilized Bandwidth\", \"bgp.ls.igp_te_metric.utilized_bandwidth_value\", FT_UINT32,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_igp_te_metric_reserved,\n        { \"Reserved\", \"bgp.ls.igp_te_metric.reserved\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_app_spec_link_attrs,\n        { \"Application-Specific Link Attributes TLV\", \"bgp.ls.tlv.application_specific_link_attributes\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_app_spec_link_attrs_sabm_len,\n        { \"SABM Length\", \"bgp.ls.tlv.application_specific_link_attributes.sabm_length\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_app_spec_link_attrs_udabm_len,\n        { \"UDABM Length\", \"bgp.ls.tlv.application_specific_link_attributes.udabm_length\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_app_spec_link_attrs_reserved,\n        { \"Reserved\", \"bgp.ls.tlv.application_specific_link_attributes.reserved\", FT_UINT16,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_app_spec_link_attrs_sabm,\n        { \"Standard Application Identifier Bit Mask\", \"bgp.ls.tlv.application_specific_link_attributes.sabm\", FT_UINT32,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_app_spec_link_attrs_sabm_r,\n        { \"RSVP-TE (R)\", \"bgp.ls.tlv.application_specific_link_attributes.sabm.r\", FT_BOOLEAN,\n          32, TFS(&tfs_set_notset), BGP_LS_APP_SPEC_LINK_ATTRS_SABM_R, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_app_spec_link_attrs_sabm_s,\n        { \"Segment Routing Policy (S)\", \"bgp.ls.tlv.application_specific_link_attributes.sabm.s\", FT_BOOLEAN,\n          32, TFS(&tfs_set_notset), BGP_LS_APP_SPEC_LINK_ATTRS_SABM_S, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_app_spec_link_attrs_sabm_f,\n        { \"Loop Free Alternate (F)\", \"bgp.ls.tlv.application_specific_link_attributes.sabm.f\", FT_BOOLEAN,\n          32, TFS(&tfs_set_notset), BGP_LS_APP_SPEC_LINK_ATTRS_SABM_F, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_app_spec_link_attrs_sabm_x,\n        { \"Flexible Algorithm (X)\", \"bgp.ls.tlv.application_specific_link_attributes.sabm.x\", FT_BOOLEAN,\n          32, TFS(&tfs_set_notset), BGP_LS_APP_SPEC_LINK_ATTRS_SABM_X, NULL, HFILL}},\n      { &hf_bgp_ls_tlv_app_spec_link_attrs_udabm,\n        { \"User-Defined Application Identifier Bit Mask\", \"bgp.ls.tlv.application_specific_link_attributes.udabm\", FT_BYTES,\n          SEP_SPACE, NULL, 0x0,NULL, HFILL }},\n\n      { &hf_bgp_evpn_nlri_igmp_mc_or_length,\n       { \"Originator Router Length\", \"bgp.evpn.nlri.or_length\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri_igmp_mc_or_addr_ipv4,\n       { \"Originator Router Address IPv4\", \"bgp.evpn.nlri.or_addr_ipv4\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri_igmp_mc_or_addr_ipv6,\n       { \"Originator Router Address IPv6\", \"bgp.evpn.nlri.or_addr_ipv6\", FT_IPv6,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri_igmp_mc_flags,\n       { \"Flags\", \"bgp.evpn.nlri.igmp_mc_flags\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri_igmp_mc_flags_v1,\n        { \"IGMP Version 1\", \"bgp.evpn.nlri.igmp_mc_flags.v1\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), EVPN_IGMP_MC_FLAG_V1, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri_igmp_mc_flags_v2,\n        { \"IGMP Version 2\", \"bgp.evpn.nlri.igmp_mc_flags.v2\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), EVPN_IGMP_MC_FLAG_V2, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri_igmp_mc_flags_v3,\n        { \"IGMP Version 3\", \"bgp.evpn.nlri.igmp_mc_flags.v3\", FT_BOOLEAN,\n          8, TFS(&tfs_set_notset), EVPN_IGMP_MC_FLAG_V3, NULL, HFILL}},\n      { &hf_bgp_evpn_nlri_igmp_mc_flags_ie,\n        { \"Group Type (IE Flag)\", \"bgp.evpn.nlri.igmp_mc_flags.ie\", FT_BOOLEAN,\n          8, TFS(&tfs_exclude_include), EVPN_IGMP_MC_FLAG_IE, \"Group Type (Include/Exclude Flag)\", HFILL}},\n      { &hf_bgp_evpn_nlri_igmp_mc_flags_reserved,\n        { \"Reserved\", \"bgp.evpn.nlri.igmp_mc_flags.reserved\", FT_UINT8,\n          BASE_HEX, NULL, EVPN_IGMP_MC_FLAG_RESERVED, NULL, HFILL}},\n\n        /* draft-mpmz-bess-mup-safi-00 */\n      { &hf_bgp_mup_nlri,\n        { \"BGP-MUP NLRI\", \"bgp.mup.nlri\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mup_nlri_at,\n        { \"Architecture Type\", \"bgp.mup.nlri.at\", FT_UINT8, BASE_DEC,\n          VALS(bgp_mup_architecture_types), 0x0, NULL, HFILL }},\n      { &hf_bgp_mup_nlri_rt,\n        { \"Route Type\", \"bgp.mup.nlri.rt\", FT_UINT16, BASE_DEC,\n          VALS(bgp_mup_route_types), 0x0, NULL, HFILL }},\n      { &hf_bgp_mup_nlri_len,\n        { \"Length\", \"bgp.mup.nlri.len\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mup_nlri_rd,\n        { \"Route Distinguisher\", \"bgp.mup.nlri.rd\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mup_nlri_prefixlen,\n        { \"Prefix Length\", \"bgp.mup.nlri.prefixlen\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mup_nlri_ip_prefix,\n        { \"IPv4 Prefix\", \"bgp.mup.nlri.ip_prefix\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mup_nlri_ipv6_prefix,\n        { \"IPv6 Prefix\", \"bgp.mup.nlri.ipv6_prefix\", FT_IPv6,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mup_nlri_ip_addr,\n        { \"IPv4 Address\", \"bgp.mup.nlri.ip_addr\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mup_nlri_ipv6_addr,\n        { \"IPv6 Address\", \"bgp.mup.nlri.ipv6_addr\", FT_IPv6,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mup_nlri_3gpp_5g_teid,\n        { \"TEID\", \"bgp.mup.nlri.3gpp_5g.teid\", FT_UINT32,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mup_nlri_3gpp_5g_qfi,\n        { \"QFI\", \"bgp.mup.nlri.3gpp_5g.qfi\", FT_UINT8,\n          BASE_HEX, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mup_nlri_3gpp_5g_ep_addr_len,\n        { \"Endpoint Length\", \"bgp.mup.nlri.3gpp_5g.ep.len\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mup_nlri_3gpp_5g_ep_ip_addr,\n        { \"Endpoint Address\", \"bgp.mup.nlri.3gpp_5g.ep.ip_addr\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mup_nlri_3gpp_5g_ep_ipv6_addr,\n        { \"Endpoint Address\", \"bgp.mup.nlri.3gpp_5g.ep.ipv6_addr\", FT_IPv6,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mup_nlri_ep_len,\n        { \"Endpoint Length\", \"bgp.mup.nlri.ep.len\", FT_UINT8,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mup_nlri_ep_ip_addr,\n        { \"Endpoint Address\", \"bgp.mup.nlri.ep.ip_addr\", FT_IPv4,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mup_nlri_ep_ipv6_addr,\n        { \"Endpoint Address\", \"bgp.mup.nlri.ep.ipv6_addr\", FT_IPv6,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mup_nlri_3gpp_5g_ep_teid,\n        { \"Endpoint TEID\", \"bgp.mup.nlri.3gpp_5g.ep.teid\", FT_UINT32,\n          BASE_DEC, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mup_nlri_3gpp_5g_type1_st_route,\n        { \"3gpp-5g specific Type 1 ST route\", \"bgp.mup.nlri.3gpp_5g.type1_st_route\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mup_nlri_3gpp_5g_type2_st_route,\n        { \"3gpp-5g specific Type 2 ST route\", \"bgp.mup.nlri.3gpp_5g.type2_st_route\", FT_NONE,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n      { &hf_bgp_mup_nlri_unknown_data,\n        { \"Unknown Data\", \"bgp.mup.nlri.unknown_data\", FT_BYTES,\n          BASE_NONE, NULL, 0x0, NULL, HFILL}},\n};\n\n    static gint *ett[] = {\n      &ett_bgp,\n      &ett_bgp_prefix,\n      &ett_bgp_unfeas,\n      &ett_bgp_attrs,\n      &ett_bgp_attr,\n      &ett_bgp_attr_flags,\n      &ett_bgp_mp_nhna,\n      &ett_bgp_mp_reach_nlri,\n      &ett_bgp_mp_unreach_nlri,\n      &ett_bgp_mp_snpa,\n      &ett_bgp_nlri,\n      &ett_bgp_open,\n      &ett_bgp_update,\n      &ett_bgp_notification,\n      &ett_bgp_route_refresh,\n      &ett_bgp_capability,\n      &ett_bgp_as_path_segment,\n      &ett_bgp_as_path_segment_asn,\n      &ett_bgp_communities,\n      &ett_bgp_community,\n      &ett_bgp_cluster_list,\n      &ett_bgp_options,\n      &ett_bgp_option,\n      &ett_bgp_options_ext,\n      &ett_bgp_cap,\n      &ett_bgp_extended_communities,\n      &ett_bgp_extended_community,\n      &ett_bgp_ext_com_type,\n      &ett_bgp_extended_com_fspec_redir,\n      &ett_bgp_ext_com_flags,\n      &ett_bgp_ext_com_l2_flags,\n      &ett_bgp_ext_com_etree_flags,\n      &ett_bgp_ext_com_evpn_mmac_flags,\n      &ett_bgp_ext_com_evpn_l2attr_flags,\n      &ett_bgp_ext_com_evpn_etree_flags,\n      &ett_bgp_ext_com_cost_cid,\n      &ett_bgp_ext_com_ospf_rt_opt,\n      &ett_bgp_ext_com_eigrp_flags,\n      &ett_bgp_ssa,\n      &ett_bgp_ssa_subtree,\n      &ett_bgp_orf,\n      &ett_bgp_orf_entry,\n      &ett_bgp_mcast_vpn_nlri,\n      &ett_bgp_flow_spec_nlri,\n      &ett_bgp_flow_spec_nlri_filter,\n      &ett_bgp_flow_spec_nlri_op_flags,\n      &ett_bgp_flow_spec_nlri_tcp,\n      &ett_bgp_flow_spec_nlri_ff,\n      &ett_bgp_tunnel_tlv,\n      &ett_bgp_tunnel_tlv_subtree,\n      &ett_bgp_tunnel_subtlv,\n      &ett_bgp_tunnel_subtlv_subtree,\n      &ett_bgp_link_state,\n      &ett_bgp_evpn_nlri,\n      &ett_bgp_evpn_nlri_esi,\n      &ett_bgp_evpn_nlri_mc,\n      &ett_bgp_mpls_labels,\n      &ett_bgp_pmsi_tunnel_id,\n      &ett_bgp_aigp_attr,\n      &ett_bgp_large_communities,\n      &ett_bgp_dpath,\n      &ett_bgp_prefix_sid_label_index,\n      &ett_bgp_prefix_sid_ipv6,\n      &ett_bgp_prefix_sid_originator_srgb,\n      &ett_bgp_prefix_sid_originator_srgb_block,\n      &ett_bgp_prefix_sid_originator_srgb_blocks,\n      &ett_bgp_bgpsec_secure_path,\n      &ett_bgp_bgpsec_secure_path_segment,\n      &ett_bgp_bgpsec_signature_block,\n      &ett_bgp_bgpsec_signature_segment,\n      &ett_bgp_vxlan,\n      &ett_bgp_binding_sid,\n      &ett_bgp_segment_list,\n      &ett_bgp_prefix_sid_unknown,\n      &ett_bgp_prefix_sid_srv6_l3vpn,\n      &ett_bgp_prefix_sid_srv6_l3vpn_sub_tlvs,\n      &ett_bgp_prefix_sid_srv6_l3vpn_sid_information,\n      &ett_bgp_prefix_sid_srv6_l3vpn_sub_sub_tlvs,\n      &ett_bgp_prefix_sid_srv6_l3vpn_sid_structure,\n      &ett_bgp_prefix_sid_srv6_l3vpn_sid_unknown,\n      &ett_bgp_prefix_sid_srv6_l3vpn_unknown,\n      &ett_bgp_prefix_sid_srv6_l2vpn,\n      &ett_bgp_prefix_sid_srv6_l2vpn_sub_tlvs,\n      &ett_bgp_prefix_sid_srv6_l2vpn_sid_information,\n      &ett_bgp_prefix_sid_srv6_l2vpn_sub_sub_tlvs,\n      &ett_bgp_prefix_sid_srv6_l2vpn_sid_structure,\n      &ett_bgp_prefix_sid_srv6_l2vpn_sid_unknown,\n      &ett_bgp_prefix_sid_srv6_l2vpn_unknown,\n      &ett_bgp_mup_nlri,\n      &ett_bgp_mup_nlri_3gpp_5g_type1_st_route,\n      &ett_bgp_mup_nlri_3gpp_5g_type2_st_route,\n    };\n    static ei_register_info ei[] = {\n        { &ei_bgp_marker_invalid, { \"bgp.marker_invalid\", PI_MALFORMED, PI_ERROR, \"Marker is not all ones\", EXPFILL }},\n        { &ei_bgp_cap_len_bad, { \"bgp.cap.length.bad\", PI_MALFORMED, PI_ERROR, \"Capability length is wrong\", EXPFILL }},\n        { &ei_bgp_cap_gr_helper_mode_only, { \"bgp.cap.gr.helper_mode_only\", PI_REQUEST_CODE, PI_CHAT, \"Graceful Restart Capability supported in Helper mode only\", EXPFILL }},\n        { &ei_bgp_notify_minor_unknown, { \"bgp.notify.minor_error.unknown\", PI_UNDECODED, PI_NOTE, \"Unknown notification error\", EXPFILL }},\n        { &ei_bgp_route_refresh_orf_type_unknown, { \"bgp.route_refresh.orf.type.unknown\", PI_MALFORMED, PI_ERROR, \"ORFEntry-Unknown\", EXPFILL }},\n        { &ei_bgp_length_invalid, { \"bgp.length.invalid\", PI_MALFORMED, PI_ERROR, \"Length is invalid\", EXPFILL }},\n        { &ei_bgp_prefix_length_invalid, { \"bgp.prefix_length.invalid\", PI_MALFORMED, PI_ERROR, \"Prefix length is invalid\", EXPFILL }},\n        { &ei_bgp_afi_type_not_supported, { \"bgp.afi_type_not_supported\", PI_PROTOCOL, PI_ERROR, \"AFI Type not supported\", EXPFILL }},\n        { &ei_bgp_unknown_afi, { \"bgp.unknown_afi\", PI_PROTOCOL, PI_ERROR, \"Unknown Address Family\", EXPFILL }},\n        { &ei_bgp_unknown_safi, { \"bgp.unknown_safi\", PI_PROTOCOL, PI_ERROR, \"Unknown SAFI\", EXPFILL }},\n        { &ei_bgp_unknown_label_vpn, { \"bgp.unknown_label\", PI_PROTOCOL, PI_ERROR, \"Unknown Label VPN\", EXPFILL }},\n        { &ei_bgp_ls_error, { \"bgp.ls.error\", PI_PROTOCOL, PI_ERROR, \"Link State error\", EXPFILL }},\n        { &ei_bgp_ls_warn, { \"bgp.ls.warn\", PI_PROTOCOL, PI_WARN, \"Link State warning\", EXPFILL }},\n        { &ei_bgp_ext_com_len_bad, { \"bgp.ext_com.length.bad\", PI_PROTOCOL, PI_ERROR, \"Extended community length is wrong\", EXPFILL }},\n        { &ei_bgp_evpn_nlri_rt_type_err, { \"bgp.evpn.type\", PI_MALFORMED, PI_ERROR, \"EVPN Route Type is invalid\", EXPFILL }},\n        { &ei_bgp_evpn_nlri_rt_len_err, { \"bgp.evpn.len\", PI_MALFORMED, PI_ERROR, \"EVPN Length is invalid\", EXPFILL }},\n        { &ei_bgp_evpn_nlri_esi_type_err, { \"bgp.evpn.esi_type\", PI_MALFORMED, PI_ERROR, \"EVPN ESI Type is invalid\", EXPFILL }},\n        { &ei_bgp_evpn_nlri_rt4_no_ip, { \"bgp.evpn.no_ip\", PI_PROTOCOL, PI_NOTE, \"IP Address: NOT INCLUDED\", EXPFILL }},\n        { &ei_bgp_attr_pmsi_tunnel_type, { \"bgp.attr.pmsi.tunnel_type\", PI_PROTOCOL, PI_ERROR, \"Unknown Tunnel type\", EXPFILL }},\n        { &ei_bgp_attr_pmsi_opaque_type, { \"bgp.attr.pmsi.opaque_type\", PI_PROTOCOL, PI_ERROR, \"Invalid pmsi opaque type\", EXPFILL }},\n        { &ei_bgp_attr_aigp_type, { \"bgp.attr.aigp.type\", PI_MALFORMED, PI_NOTE, \"Unknown AIGP attribute type\", EXPFILL}},\n        { &ei_bgp_prefix_length_err, { \"bgp.prefix.length\", PI_MALFORMED, PI_ERROR, \"Invalid IPv6 prefix length\", EXPFILL}},\n        { &ei_bgp_attr_as_path_as_len_err, { \"bgp.attr.as_path.as_len\", PI_UNDECODED, PI_ERROR, \"unable to determine 4 or 2 bytes ASN\", EXPFILL}},\n        { &ei_bgp_next_hop_ipv6_scope, { \"bgp.next_hop.ipv6.scope\", PI_PROTOCOL, PI_WARN, \"Invalid IPv6 address scope\", EXPFILL}},\n        { &ei_bgp_next_hop_rd_nonzero, { \"bgp.next_hop.rd.nonzero\", PI_PROTOCOL, PI_WARN, \"Route Distinguisher in Next Hop Network Address nonzero\", EXPFILL}},\n        { &ei_bgp_mup_unknown_at, { \"bgp.mup.unknown_at\", PI_PROTOCOL, PI_ERROR, \"Unknown architecture type\", EXPFILL }},\n        { &ei_bgp_mup_unknown_rt, { \"bgp.mup.unknown_rt\", PI_PROTOCOL, PI_ERROR, \"Unknown route type\", EXPFILL }},\n        { &ei_bgp_mup_nlri_addr_len_err, { \"bgp.mup.nlri.addr_len_err\", PI_PROTOCOL, PI_ERROR, \"Address length invalid\", EXPFILL }},\n    };\n\n    module_t *bgp_module;\n    expert_module_t* expert_bgp;\n\n    static const enum_val_t asn_len[] = {\n        {\"auto-detect\", \"Auto-detect\", 0},\n        {\"2\", \"2 octet\", 2},\n        {\"4\", \"4 octet\", 4},\n        {NULL, NULL, -1}\n    };\n\n    proto_bgp = proto_register_protocol(\"Border Gateway Protocol\",\n                                        \"BGP\", \"bgp\");\n    proto_register_field_array(proto_bgp, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n    expert_bgp = expert_register_protocol(proto_bgp);\n    expert_register_field_array(expert_bgp, ei, array_length(ei));\n\n    bgp_module = prefs_register_protocol(proto_bgp, NULL);\n    prefs_register_bool_preference(bgp_module, \"desegment\",\n      \"Reassemble BGP messages spanning multiple TCP segments\",\n      \"Whether the BGP dissector should reassemble messages spanning multiple TCP segments.\"\n      \" To use this option, you must also enable \\\"Allow subdissectors to reassemble TCP streams\\\" in the TCP protocol settings.\",\n      &bgp_desegment);\n    prefs_register_enum_preference(bgp_module, \"asn_len\",\n      \"Length of the AS number\",\n      \"BGP dissector detect the length of the AS number in AS_PATH attributes automatically or manually (NOTE: Automatic detection is not 100% accurate)\",\n      &bgp_asn_len, asn_len, FALSE);\n\n    bgp_handle = register_dissector(\"bgp\", dissect_bgp, proto_bgp);\n    register_dissector(\"bgp.pdu\", dissect_bgp_pdu, proto_bgp);\n}",
      "cve_list": [
        "CVE-2024-24478"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "jerryscript",
      "filepath": "jerry-core/ecma/operations/ecma-function-object.c",
      "func_name": "ecma_op_function_call_constructor",
      "func_body": "ecma_op_function_call_constructor (vm_frame_ctx_shared_args_t *shared_args_p, /**< shared data */\n                                   ecma_object_t *scope_p, /**< lexical environment to use */\n                                   ecma_value_t this_binding) /**< value of 'ThisBinding' */\n{\n  ECMA_CHECK_STACK_USAGE ();\n\n  shared_args_p->header.status_flags |= VM_FRAME_CTX_SHARED_NON_ARROW_FUNC;\n\n  ecma_value_t ret_value;\n\n  if (JERRY_CONTEXT (current_new_target_p) == NULL)\n  {\n    ret_value = ecma_raise_type_error (ECMA_ERR_CLASS_CONSTRUCTOR_REQUIRES_NEW);\n    goto exit;\n  }\n\n  ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) shared_args_p->header.function_object_p;\n  if (ECMA_GET_THIRD_BIT_FROM_POINTER_TAG (ext_func_p->u.function.scope_cp))\n  {\n    this_binding = ECMA_VALUE_UNINITIALIZED;\n  }\n\n  ecma_op_create_environment_record (scope_p, this_binding, shared_args_p->header.function_object_p);\n\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);\n  JERRY_CONTEXT (global_object_p) = ecma_op_function_get_realm (shared_args_p->header.bytecode_header_p);\n#endif /* JERRY_BUILTIN_REALMS */\n\n  ret_value = vm_run (&shared_args_p->header, this_binding, scope_p);\n\n#if JERRY_BUILTIN_REALMS\n  JERRY_CONTEXT (global_object_p) = saved_global_object_p;\n#endif /* JERRY_BUILTIN_REALMS */\n\n  /* ECMAScript v6, 9.2.2.13 */\n  if (JERRY_UNLIKELY (this_binding == ECMA_VALUE_UNINITIALIZED))\n  {\n    if (!ECMA_IS_VALUE_ERROR (ret_value) && !ecma_is_value_object (ret_value))\n    {\n      if (!ecma_is_value_undefined (ret_value))\n      {\n        ecma_free_value (ret_value);\n        ret_value = ecma_raise_type_error (ECMA_ERR_DERIVED_CTOR_RETURN_NOR_OBJECT_OR_UNDEFINED);\n      }\n      else\n      {\n        ret_value = ecma_op_get_this_binding (scope_p);\n      }\n    }\n  }\n\nexit:\n  if (JERRY_UNLIKELY (shared_args_p->header.status_flags & VM_FRAME_CTX_SHARED_FREE_LOCAL_ENV))\n  {\n    ecma_deref_object (scope_p);\n  }\n\n  return ret_value;\n} /* ecma_op_function_call_constructor */",
      "cve_list": [
        "CVE-2024-29489"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "jerryscript",
      "filepath": "jerry-core/ecma/operations/ecma-function-object.c",
      "func_name": "ecma_op_function_call_native",
      "func_body": "ecma_op_function_call_native (ecma_object_t *func_obj_p, /**< Function object */\n                              ecma_value_t this_arg_value, /**< 'this' argument's value */\n                              const ecma_value_t *arguments_list_p, /**< arguments list */\n                              uint32_t arguments_list_len) /**< length of arguments list */\n{\n  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_NATIVE_FUNCTION);\n\n  ECMA_CHECK_STACK_USAGE ();\n\n  ecma_native_function_t *native_function_p = (ecma_native_function_t *) func_obj_p;\n\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);\n  JERRY_CONTEXT (global_object_p) =\n    ECMA_GET_INTERNAL_VALUE_POINTER (ecma_global_object_t, native_function_p->realm_value);\n#endif /* JERRY_BUILTIN_REALMS */\n\n  jerry_call_info_t call_info;\n  call_info.function = ecma_make_object_value (func_obj_p);\n  call_info.this_value = this_arg_value;\n\n  ecma_object_t *new_target_p = JERRY_CONTEXT (current_new_target_p);\n  call_info.new_target = (new_target_p == NULL) ? ECMA_VALUE_UNDEFINED : ecma_make_object_value (new_target_p);\n\n  JERRY_ASSERT (native_function_p->native_handler_cb != NULL);\n  ecma_value_t ret_value = native_function_p->native_handler_cb (&call_info, arguments_list_p, arguments_list_len);\n#if JERRY_BUILTIN_REALMS\n  JERRY_CONTEXT (global_object_p) = saved_global_object_p;\n#endif /* JERRY_BUILTIN_REALMS */\n\n  if (JERRY_UNLIKELY (ecma_is_value_exception (ret_value)))\n  {\n    ecma_throw_exception (ret_value);\n    return ECMA_VALUE_ERROR;\n  }\n\n#if JERRY_DEBUGGER\n  JERRY_DEBUGGER_CLEAR_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);\n#endif /* JERRY_DEBUGGER */\n  return ret_value;\n} /* ecma_op_function_call_native */",
      "cve_list": [
        "CVE-2024-29489"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "jerryscript",
      "filepath": "jerry-core/ecma/operations/ecma-function-object.c",
      "func_name": "ecma_op_function_call_native_built_in",
      "func_body": "ecma_op_function_call_native_built_in (ecma_object_t *func_obj_p, /**< Function object */\n                                       ecma_value_t this_arg_value, /**< 'this' argument's value */\n                                       const ecma_value_t *arguments_list_p, /**< arguments list */\n                                       uint32_t arguments_list_len) /**< length of arguments list */\n{\n  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);\n\n  ECMA_CHECK_STACK_USAGE ();\n\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);\n\n  ecma_extended_object_t *ext_func_obj_p = (ecma_extended_object_t *) func_obj_p;\n  JERRY_CONTEXT (global_object_p) =\n    ECMA_GET_INTERNAL_VALUE_POINTER (ecma_global_object_t, ext_func_obj_p->u.built_in.realm_value);\n#endif /* JERRY_BUILTIN_REALMS */\n\n  ecma_value_t ret_value =\n    ecma_builtin_dispatch_call (func_obj_p, this_arg_value, arguments_list_p, arguments_list_len);\n\n#if JERRY_BUILTIN_REALMS\n  JERRY_CONTEXT (global_object_p) = saved_global_object_p;\n#endif /* JERRY_BUILTIN_REALMS */\n  return ret_value;\n} /* ecma_op_function_call_native_built_in */",
      "cve_list": [
        "CVE-2024-29489"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "jerryscript",
      "filepath": "jerry-core/ecma/operations/ecma-function-object.c",
      "func_name": "ecma_op_function_call_simple",
      "func_body": "ecma_op_function_call_simple (ecma_object_t *func_obj_p, /**< Function object */\n                              ecma_value_t this_binding, /**< 'this' argument's value */\n                              const ecma_value_t *arguments_list_p, /**< arguments list */\n                              uint32_t arguments_list_len) /**< length of arguments list */\n{\n  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_FUNCTION);\n\n  ECMA_CHECK_STACK_USAGE ();\n\n  vm_frame_ctx_shared_args_t shared_args;\n  shared_args.header.status_flags = VM_FRAME_CTX_SHARED_HAS_ARG_LIST;\n  shared_args.header.function_object_p = func_obj_p;\n  shared_args.arg_list_p = arguments_list_p;\n  shared_args.arg_list_len = arguments_list_len;\n\n  /* Entering Function Code (ECMA-262 v5, 10.4.3) */\n  ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_obj_p;\n\n  ecma_object_t *scope_p = ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t, ext_func_p->u.function.scope_cp);\n\n  /* 8. */\n  const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);\n  uint16_t status_flags = bytecode_data_p->status_flags;\n\n  shared_args.header.bytecode_header_p = bytecode_data_p;\n\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *realm_p = ecma_op_function_get_realm (bytecode_data_p);\n#endif /* JERRY_BUILTIN_REALMS */\n\n  /* 5. */\n  if (!(status_flags & CBC_CODE_FLAGS_LEXICAL_ENV_NOT_NEEDED))\n  {\n    shared_args.header.status_flags |= VM_FRAME_CTX_SHARED_FREE_LOCAL_ENV;\n    scope_p = ecma_create_decl_lex_env (scope_p);\n  }\n\n  /* 1. */\n  switch (CBC_FUNCTION_GET_TYPE (status_flags))\n  {\n    case CBC_FUNCTION_CONSTRUCTOR:\n    {\n      return ecma_op_function_call_constructor (&shared_args, scope_p, this_binding);\n    }\n    case CBC_FUNCTION_ARROW:\n    {\n      ecma_arrow_function_t *arrow_func_p = (ecma_arrow_function_t *) func_obj_p;\n\n      if (ecma_is_value_undefined (arrow_func_p->new_target))\n      {\n        JERRY_CONTEXT (current_new_target_p) = NULL;\n      }\n      else\n      {\n        JERRY_CONTEXT (current_new_target_p) = ecma_get_object_from_value (arrow_func_p->new_target);\n      }\n\n      this_binding = arrow_func_p->this_binding;\n\n      if (JERRY_UNLIKELY (this_binding == ECMA_VALUE_UNINITIALIZED))\n      {\n        ecma_environment_record_t *env_record_p = ecma_op_get_environment_record (scope_p);\n        JERRY_ASSERT (env_record_p);\n        this_binding = env_record_p->this_binding;\n      }\n      break;\n    }\n    default:\n    {\n      shared_args.header.status_flags |= VM_FRAME_CTX_SHARED_NON_ARROW_FUNC;\n\n      if (status_flags & CBC_CODE_FLAGS_STRICT_MODE)\n      {\n        break;\n      }\n\n      if (ecma_is_value_undefined (this_binding) || ecma_is_value_null (this_binding))\n      {\n        /* 2. */\n#if JERRY_BUILTIN_REALMS\n        this_binding = realm_p->this_binding;\n#else /* !JERRY_BUILTIN_REALMS */\n        this_binding = ecma_make_object_value (ecma_builtin_get_global ());\n#endif /* JERRY_BUILTIN_REALMS */\n      }\n      else if (!ecma_is_value_object (this_binding))\n      {\n        /* 3., 4. */\n        this_binding = ecma_op_to_object (this_binding);\n        shared_args.header.status_flags |= VM_FRAME_CTX_SHARED_FREE_THIS;\n\n        JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (this_binding));\n      }\n      break;\n    }\n  }\n\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);\n  JERRY_CONTEXT (global_object_p) = realm_p;\n#endif /* JERRY_BUILTIN_REALMS */\n\n  ecma_value_t ret_value = vm_run (&shared_args.header, this_binding, scope_p);\n\n#if JERRY_BUILTIN_REALMS\n  JERRY_CONTEXT (global_object_p) = saved_global_object_p;\n#endif /* JERRY_BUILTIN_REALMS */\n\n  if (JERRY_UNLIKELY (shared_args.header.status_flags & VM_FRAME_CTX_SHARED_FREE_LOCAL_ENV))\n  {\n    ecma_deref_object (scope_p);\n  }\n\n  if (JERRY_UNLIKELY (shared_args.header.status_flags & VM_FRAME_CTX_SHARED_FREE_THIS))\n  {\n    ecma_free_value (this_binding);\n  }\n\n  return ret_value;\n} /* ecma_op_function_call_simple */",
      "cve_list": [
        "CVE-2024-29489"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "jerryscript",
      "filepath": "jerry-core/ecma/operations/ecma-proxy-object.c",
      "func_name": "ecma_proxy_object_get",
      "func_body": "ecma_proxy_object_get (ecma_object_t *obj_p, /**< proxy object */\n                       ecma_string_t *prop_name_p, /**< property name */\n                       ecma_value_t receiver) /**< receiver to invoke getter function */\n{\n  JERRY_ASSERT (ECMA_OBJECT_IS_PROXY (obj_p));\n  ECMA_CHECK_STACK_USAGE ();\n\n  ecma_proxy_object_t *proxy_obj_p = (ecma_proxy_object_t *) obj_p;\n\n  /* 2. */\n  ecma_value_t handler = proxy_obj_p->handler;\n\n  /* 3-6. */\n  ecma_value_t trap = ecma_validate_proxy_object (handler, LIT_MAGIC_STRING_GET);\n\n  /* 7. */\n  if (ECMA_IS_VALUE_ERROR (trap))\n  {\n    return trap;\n  }\n\n  /* 8. */\n  if (ecma_is_value_undefined (trap))\n  {\n    ecma_object_t *target_obj_p = ecma_get_object_from_value (proxy_obj_p->target);\n    ecma_value_t result = ecma_op_object_get_with_receiver (target_obj_p, prop_name_p, receiver);\n    JERRY_BLOCK_TAIL_CALL_OPTIMIZATION ();\n    return result;\n  }\n\n  ecma_object_t *func_obj_p = ecma_get_object_from_value (trap);\n  ecma_value_t prop_value = ecma_make_prop_name_value (prop_name_p);\n  ecma_value_t args[] = { proxy_obj_p->target, prop_value, receiver };\n\n  /* 9. */\n  ecma_ref_object (obj_p);\n  ecma_value_t trap_result = ecma_op_function_call (func_obj_p, handler, args, 3);\n  ecma_deref_object (obj_p);\n\n  ecma_deref_object (func_obj_p);\n\n  /* 10. */\n  if (ECMA_IS_VALUE_ERROR (trap_result) || (obj_p->u2.prototype_cp & JERRY_PROXY_SKIP_RESULT_VALIDATION))\n  {\n    return trap_result;\n  }\n\n  /* 11. */\n  ecma_property_descriptor_t target_desc;\n  ecma_value_t status = ecma_op_get_own_property_descriptor (proxy_obj_p->target, prop_name_p, &target_desc);\n\n  /* 12. */\n  if (ECMA_IS_VALUE_ERROR (status))\n  {\n    ecma_free_value (trap_result);\n    return status;\n  }\n\n  /* 13. */\n  if (ecma_is_value_true (status))\n  {\n    ecma_value_t ret_value = ECMA_VALUE_EMPTY;\n\n    if ((target_desc.flags & JERRY_PROP_IS_VALUE_DEFINED) && !(target_desc.flags & JERRY_PROP_IS_CONFIGURABLE)\n        && !(target_desc.flags & JERRY_PROP_IS_WRITABLE) && !ecma_op_same_value (trap_result, target_desc.value))\n    {\n      ret_value = ecma_raise_type_error (ECMA_ERR_INCORRECT_RETURN_PROXY_GET_TRAP);\n    }\n    else if (!(target_desc.flags & JERRY_PROP_IS_CONFIGURABLE)\n             && (target_desc.flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED))\n             && target_desc.get_p == NULL && !ecma_is_value_undefined (trap_result))\n    {\n      ret_value = ecma_raise_type_error (ECMA_ERR_PROXY_PROPERTY_NOT_CONFIGURABLE_NOT_HAVE_GETTER);\n    }\n\n    ecma_free_property_descriptor (&target_desc);\n\n    if (ECMA_IS_VALUE_ERROR (ret_value))\n    {\n      ecma_free_value (trap_result);\n\n      return ret_value;\n    }\n  }\n\n  /* 14. */\n  return trap_result;\n} /* ecma_proxy_object_get */",
      "cve_list": [
        "CVE-2024-29489"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "gpac",
      "filepath": "src/filters/reframe_ac3.c",
      "func_name": "ac3dmx_process",
      "func_body": "GF_Err ac3dmx_process(GF_Filter *filter)\n{\n\tGF_AC3DmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu8 *output;\n\tu8 *start;\n\tu32 pck_size, remain, prev_pck_size;\n\tu64 cts;\n\nrestart:\n\tcts = GF_FILTER_NO_TS;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tac3dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->ac3_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tprev_pck_size = ctx->ac3_buffer_size;\n\tif (pck && !ctx->resume_from) {\n\t\tconst u8 *data = gf_filter_pck_get_data(pck, &pck_size);\n\t\tif (!pck_size) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\t//max EAC3 frame is 4096 but we can have side streams, AC3 is 3840 - if we store more than 2 frames consider we have garbage\n\t\tif (ctx->ac3_buffer_size>100000) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[AC3Dmx] Trashing %d garbage bytes\\n\", ctx->ac3_buffer_size));\n\t\t\tctx->ac3_buffer_size = 0;\n\t\t}\n\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\tu64 byte_offset = gf_filter_pck_get_byte_offset(pck);\n\t\t\tif (!ctx->ac3_buffer_size) {\n\t\t\t\tctx->byte_offset = byte_offset;\n\t\t\t} else if (ctx->byte_offset + ctx->ac3_buffer_size != byte_offset) {\n\t\t\t\tctx->byte_offset = GF_FILTER_NO_BO;\n\t\t\t\tif ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->ac3_buffer_size) ) {\n\t\t\t\t\tctx->byte_offset = byte_offset - ctx->ac3_buffer_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->ac3_buffer_size + pck_size > ctx->ac3_buffer_alloc) {\n\t\t\tctx->ac3_buffer_alloc = ctx->ac3_buffer_size + pck_size;\n\t\t\tctx->ac3_buffer = gf_realloc(ctx->ac3_buffer, ctx->ac3_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->ac3_buffer + ctx->ac3_buffer_size, data, pck_size);\n\t\tctx->ac3_buffer_size += pck_size;\n\t}\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && pck) {\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t\t//init cts at first packet\n\t\tif (!ctx->cts && (cts != GF_FILTER_NO_TS))\n\t\t\tctx->cts = cts;\n\t}\n\n\tif (cts == GF_FILTER_NO_TS) {\n\t\t//avoids updating cts\n\t\tprev_pck_size = 0;\n\t}\n\n\tremain = ctx->ac3_buffer_size;\n\tstart = ctx->ac3_buffer;\n\n\tif (ctx->resume_from) {\n\t\tstart += ctx->resume_from - 1;\n\t\tremain -= ctx->resume_from - 1;\n\t\tctx->resume_from = 0;\n\t}\n\n\tif (!ctx->bs) {\n\t\tctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);\n\t} else {\n\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t}\n\twhile (remain) {\n\t\tu8 *sync;\n\t\tBool res;\n\t\tu32 sync_pos, bytes_to_drop=0;\n\n\t\tres = ctx->ac3_parser_bs(ctx->bs, &ctx->hdr, GF_TRUE);\n\n\t\tsync_pos = (u32) gf_bs_get_position(ctx->bs);\n\n\t\t//if not end of stream or no valid frame\n\t\tif (pck || !ctx->hdr.framesize) {\n\t\t\t//startcode not found or not enough bytes, gather more\n\t\t\tif (!res || (remain < sync_pos + ctx->hdr.framesize)) {\n\t\t\t\tif (sync_pos && ctx->hdr.framesize) {\n\t\t\t\t\tstart += sync_pos;\n\t\t\t\t\tremain -= sync_pos;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tac3dmx_check_pid(filter, ctx);\n\t\t}\n\t\t//may happen with very-short streams\n\t\tif (!ctx->sample_rate)\n\t\t\tac3dmx_check_pid(filter, ctx);\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = 1 + ctx->ac3_buffer_size - remain;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tif (sync_pos) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[AC3Dmx] %d bytes unrecovered before sync word\\n\", sync_pos));\n\t\t}\n\t\tsync = start + sync_pos;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * ctx->hdr.sample_rate);\n\t\t\tif (ctx->cts + AC3_FRAME_SIZE >= nb_samples_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tbytes_to_drop = sync_pos + ctx->hdr.framesize;\n\t\tif (ctx->timescale && !prev_pck_size &&  (cts != GF_FILTER_NO_TS) ) {\n\t\t\t//trust input CTS if diff is more than one sec\n\t\t\tif ((cts > ctx->cts + ctx->timescale) || (ctx->cts > cts + ctx->timescale))\n\t\t\t\tctx->cts = cts;\n\t\t\tcts = GF_FILTER_NO_TS;\n\t\t}\n\n\t\tif (!ctx->in_seek && remain >= sync_pos + ctx->hdr.framesize) {\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->hdr.framesize, &output);\n\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\tmemcpy(output, sync, ctx->hdr.framesize);\n\t\t\tgf_filter_pck_set_dts(dst_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tif (ctx->timescale && (ctx->timescale!=ctx->sample_rate))\n\t\t\t\tgf_filter_pck_set_duration(dst_pck, (u32) gf_timestamp_rescale(AC3_FRAME_SIZE, ctx->sample_rate, ctx->timescale));\n\t\t\telse\n\t\t\t\tgf_filter_pck_set_duration(dst_pck, AC3_FRAME_SIZE);\n\t\t\tgf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\n\t\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset + ctx->hdr.framesize);\n\t\t\t}\n\n\t\t\tgf_filter_pck_send(dst_pck);\n\t\t}\n\t\tac3dmx_update_cts(ctx);\n\n\t\t//truncated last frame\n\t\tif (bytes_to_drop>remain) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[ADTSDmx] truncated AC3 frame!\\n\"));\n\t\t\tbytes_to_drop=remain;\n\t\t}\n\n\t\tif (!bytes_to_drop) {\n\t\t\tbytes_to_drop = 1;\n\t\t}\n\t\tstart += bytes_to_drop;\n\t\tremain -= bytes_to_drop;\n\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\n\t\tif (prev_pck_size) {\n\t\t\tif (prev_pck_size > bytes_to_drop) prev_pck_size -= bytes_to_drop;\n\t\t\telse {\n\t\t\t\tprev_pck_size=0;\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = pck;\n\t\t\t\tif (pck)\n\t\t\t\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\t\t}\n\t\t}\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO)\n\t\t\tctx->byte_offset += bytes_to_drop;\n\t}\n\n\tif (!pck) {\n\t\tctx->ac3_buffer_size = 0;\n\t\t//avoid recursive call\n\t\tgoto restart;\n\t} else {\n\t\tif (remain && (remain < ctx->ac3_buffer_size)) {\n\t\t\tmemmove(ctx->ac3_buffer, start, remain);\n\t\t}\n\t\tctx->ac3_buffer_size = remain;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t}\n\treturn GF_OK;\n}",
      "cve_list": [
        "CVE-2024-0322"
      ],
      "cwe_list": [
        "CWE-125"
      ]
    },
    {
      "project": "gpac",
      "filepath": "src/filters/load_text.c",
      "func_name": "gf_text_get_utf8_line",
      "func_body": "\nchar *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[2048];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = gf_fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\tif (unicode_type<=1) {\n\t\tj=0;\n\t\tlen = (u32) strlen(szLine);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ((szLine[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tszLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[i] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xe0) == 0xc0) {\n\t\t\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tif (j+1 >= GF_ARRAY_LENGTH(szLineConv))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tif (j+2 >= GF_ARRAY_LENGTH(szLineConv))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\ti+=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv))\n\t\t\t\tbreak;\n\n\t\t\tszLineConv[j] = szLine[i];\n\t\t\tj++;\n\n\n\t\t}\n\t\tif ( j >= GF_ARRAY_LENGTH(szLineConv) ) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TXTIn] Line too long to convert to utf8 (len: %d)\\n\", len));\n\t\t\tj = GF_ARRAY_LENGTH(szLineConv) -1 ;\n\t\t}\n\t\tif ( j >= lineSize ) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TXTIn] UT8 converted line too long for buffer (len: %d, buffer: %d)\\n\", j, lineSize));\n\t\t\tj = lineSize-1 ;\n\t\t}\n\t\tszLineConv[j] = 0;\n\t\tstrcpy(szLine, szLineConv);\n\t\treturn sOK;\n\t}\n\n#ifdef GPAC_BIG_ENDIAN\n\tif (unicode_type==3)\n#else\n\tif (unicode_type==2)\n#endif\n\t{\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tif (!szLine[i] && !szLine[i+1]) break;\n\t\t\tc = szLine[i+1];\n\t\t\tszLine[i+1] = szLine[i];\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);\n\tif (i == GF_UTF8_FAIL) i = 0;\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \\0 after a \\n*/\n\tif (unicode_type==3) gf_fgetc(txt_in);\n\treturn sOK;",
      "cve_list": [
        "CVE-2024-0321"
      ],
      "cwe_list": [
        "CWE-787"
      ]
    },
    {
      "project": "gpac",
      "filepath": "src/filters/isoffin_read.c",
      "func_name": "isoffin_process",
      "func_body": "static GF_Err isoffin_process(GF_Filter *filter)\n{\n\tISOMReader *read = gf_filter_get_udta(filter);\n\tu32 i, count = gf_list_count(read->channels);\n\tBool is_active = GF_FALSE;\n\tBool in_is_eos = GF_FALSE;\n\tBool in_is_flush = GF_FALSE;\n\tBool check_forced_end = GF_FALSE;\n\tBool has_new_data = GF_FALSE;\n\tu64 min_offset_plus_one = 0;\n\tu32 nb_forced_end=0;\n\tif (read->in_error)\n\t\treturn read->in_error;\n\n\tif (read->pid) {\n\t\tBool fetch_input = GF_TRUE;\n\n\t\t//we failed at loading the init segment during a dash switch, retry\n\t\tif (!read->is_partial_download && !read->mem_load_mode && (read->moov_not_loaded==2) ) {\n\t\t\tisoffin_configure_pid(filter, read->pid, GF_FALSE);\n\t\t\tif (read->moov_not_loaded) return GF_OK;\n\t\t}\n\t\tif (read->mem_load_mode==2) {\n\t\t\tif (!read->force_fetch && (read->mem_blob.size > read->mstore_size)) {\n\t\t\t\tfetch_input = GF_FALSE;\n\t\t\t}\n\t\t\tread->force_fetch = GF_FALSE;\n\t\t}\n\t\twhile (fetch_input) {\n\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(read->pid);\n\t\t\tif (!pck) {\n\t\t\t\t//we issued a seek, wait for the first packet to be received before fetching channels\n\t\t\t\t//otherwise we could end up reading from the wrong cache\n\t\t\t\tif (read->wait_for_source) {\n\t\t\t\t\t//something went wrong during the seek request\n\t\t\t\t\tif (gf_filter_pid_is_eos(read->pid))\n\t\t\t\t\t\treturn GF_EOS;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tread->wait_for_source = GF_FALSE;\n\n\t\t\tif (read->mem_load_mode) {\n\t\t\t\tu32 data_size;\n\t\t\t\tconst u8 *pck_data = gf_filter_pck_get_data(pck, &data_size);\n\t\t\t\tisoffin_push_buffer(filter, read, pck_data, data_size);\n\t\t\t}\n\t\t\t//we just had a switch but init seg is not completely done: input packet is only a part of the init, drop it\n\t\t\telse if (read->moov_not_loaded==2) {\n\t\t\t\tgf_filter_pid_drop_packet(read->pid);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tgf_filter_pid_drop_packet(read->pid);\n\t\t\thas_new_data = GF_TRUE;\n\t\t\tif (read->in_error)\n\t\t\t\treturn read->in_error;\n\t\t}\n\t\tif (gf_filter_pid_is_eos(read->pid)) {\n\t\t\tif (!gf_filter_pid_is_flush_eos(read->pid)) {\n\t\t\t\tread->input_loaded = GF_TRUE;\n\t\t\t\tin_is_eos = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tin_is_flush = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tif (read->input_is_stop) {\n\t\t\tread->input_loaded = GF_TRUE;\n\t\t\tin_is_eos = GF_TRUE;\n\t\t\tread->input_is_stop = GF_FALSE;\n\t\t}\n\t\tif (!read->frag_type && read->input_loaded) {\n\t\t\tin_is_eos = GF_TRUE;\n\t\t}\n        //segment is invalid, wait for eos on input an send eos on all channels\n        if (read->invalid_segment) {\n            if (!in_is_eos) return GF_OK;\n            read->invalid_segment = GF_FALSE;\n\n            for (i=0; i<count; i++) {\n                ISOMChannel *ch = gf_list_get(read->channels, i);\n                if (!ch->playing) {\n                    continue;\n                }\n                if (!ch->eos_sent) {\n                    ch->eos_sent = 1;\n                    gf_filter_pid_set_eos(ch->pid);\n                }\n            }\n            read->eos_signaled = GF_TRUE;\n            return GF_EOS;\n        }\n\t} else if (read->extern_mov) {\n\t\tin_is_eos = GF_TRUE;\n\t\tread->input_loaded = GF_TRUE;\n\t}\n\tif (read->moov_not_loaded==1) {\n\t\tif (read->mem_load_mode)\n\t\t\treturn GF_OK;\n\t\tread->moov_not_loaded = GF_FALSE;\n\t\treturn isoffin_setup(filter, read, in_is_eos);\n\t}\n\n\tif (read->refresh_fragmented) {\n\t\tconst GF_PropertyValue *prop;\n\n\t\tif (in_is_eos) {\n\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t} else {\n\t\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILE_CACHED);\n\t\t\tif (prop && prop->value.boolean)\n\t\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t}\n\n\t\tif (has_new_data) {\n\t\t\tu64 bytesMissing=0;\n\t\t\tGF_Err e;\n\t\t\tconst char *new_url = NULL;\n\t\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILEPATH);\n\t\t\tif (prop) new_url = prop->value.string;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\te = gf_isom_refresh_fragmented(read->mov, &bytesMissing, new_url);\n\n\t\t\tif (e && (e != GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[IsoMedia] Failed to refresh current segment: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] Refreshing current segment at UTC \"LLU\" - \"LLU\" bytes still missing - input is EOS %d\\n\", gf_net_get_utc(), bytesMissing, in_is_eos));\n\t\t\t}\n#endif\n\n\t\t\tif (!read->refresh_fragmented && (e==GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[IsoMedia] Incomplete Segment received - \"LLU\" bytes missing but EOF found\\n\", bytesMissing ));\n\t\t\t}\n\n#ifndef GPAC_DISABLE_LOG\n\t\t\tif (gf_log_tool_level_on(GF_LOG_DASH, GF_LOG_DEBUG)) {\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tISOMChannel *ch = gf_list_get(read->channels, i);\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] refresh track %d fragment - cur sample %d - new sample count %d\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track) ));\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tisor_check_producer_ref_time(read);\n\t\t\tif (!read->frag_type)\n\t\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t}\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\tu8 *data;\n\t\tu32 nb_pck=50;\n\t\tISOMChannel *ch;\n\t\tch = gf_list_get(read->channels, i);\n\t\tif (!ch->playing) {\n\t\t\tnb_forced_end++;\n\t\t\tcontinue;\n\t\t}\n\t\t//eos not sent on this channel, we are active\n\t\tif (!ch->eos_sent)\n\t\t\tis_active = GF_TRUE;\n\n\t\twhile (nb_pck) {\n\t\t\tch->sample_data_offset = 0;\n\t\t\tif (!in_is_flush && !read->full_segment_flush && gf_filter_pid_would_block(ch->pid) )\n\t\t\t\tbreak;\n\n\t\t\tif (ch->item_id) {\n\t\t\t\tisor_reader_get_sample_from_item(ch);\n\t\t\t} else {\n\t\t\t\tisor_reader_get_sample(ch);\n\t\t\t}\n\t\t\tif (!ch->sample && ch->pck) {\n\t\t\t\tgf_filter_pck_discard(ch->pck);\n\t\t\t\tch->pck = NULL;\n\t\t\t\tif (ch->static_sample) {\n\t\t\t\t\tch->static_sample->data = NULL;\n\t\t\t\t\tch->static_sample->alloc_size=0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (read->stsd && (ch->last_sample_desc_index != read->stsd) && ch->sample) {\n\t\t\t\tisor_reader_release_sample(ch);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ch->sample) {\n\t\t\t\tu32 sample_dur;\n\t\t\t\tu8 dep_flags;\n\t\t\t\tu8 *subs_buf;\n\t\t\t\tu32 subs_buf_size;\n\t\t\t\tGF_FilterPacket *pck;\n\n\t\t\t\tif (!read->keepc && ch->sample->corrupted) {\n\t\t\t\t\tisor_reader_release_sample(ch);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (ch->needs_pid_reconfig) {\n\t\t\t\t\tisor_update_channel_config(ch);\n\t\t\t\t\tch->needs_pid_reconfig = 0;\n\t\t\t\t}\n\n\t\t\t\t//we have at least two samples, update GF_PROP_PID_HAS_SYNC if needed\n\t\t\t\tif (ch->check_has_rap && (gf_isom_get_sample_count(ch->owner->mov, ch->track)>1) && (gf_isom_has_sync_points(ch->owner->mov, ch->track)==1)) {\n\t\t\t\t\tch->check_has_rap = 0;\n\t\t\t\t\tch->has_rap = 1;\n\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_HAS_SYNC, &PROP_BOOL(ch->has_rap) );\n\t\t\t\t}\n\n\t\t\t\t//strip param sets from payload, trigger reconfig if needed\n\t\t\t\tisor_reader_check_config(ch);\n\n\t\t\t\tif (ch->pck) {\n\t\t\t\t\tpck = ch->pck;\n\t\t\t\t\tch->pck = NULL;\n\t\t\t\t\tgf_filter_pck_check_realloc(pck, ch->sample->data, ch->sample->dataLength);\n\t\t\t\t\tch->static_sample->data = NULL;\n\t\t\t\t\tch->static_sample->dataLength = 0;\n\t\t\t\t\tch->static_sample->alloc_size=0;\n\t\t\t\t}\n\t\t\t\telse if (read->nodata) {\n\t\t\t\t\tif (read->nodata==1)\n\t\t\t\t\t\tpck = gf_filter_pck_new_shared(ch->pid, NULL, ch->sample->dataLength, NULL);\n\t\t\t\t\telse\n\t\t\t\t\t\tpck = gf_filter_pck_new_alloc(ch->pid, ch->sample->dataLength, &data);\n\n\t\t\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\t\t\t\t} else {\n\t\t\t\t\tpck = gf_filter_pck_new_alloc(ch->pid, ch->sample->dataLength, &data);\n\t\t\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tif (ch->sample->data)\n\t\t\t\t\t\tmemcpy(data, ch->sample->data, ch->sample->dataLength);\n\t\t\t\t}\n\t\t\t\tgf_filter_pck_set_dts(pck, ch->dts);\n\t\t\t\tgf_filter_pck_set_cts(pck, ch->cts + ch->cts_offset);\n\t\t\t\tif (ch->sample->IsRAP==-1) {\n\t\t\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\t\t\t\t\tch->redundant = 1;\n\t\t\t\t} else {\n\t\t\t\t\tgf_filter_pck_set_sap(pck, (GF_FilterSAPType) ch->sample->IsRAP);\n\t\t\t\t}\n\n\t\t\t\tif (ch->sap_3)\n\t\t\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_3);\n\t\t\t\telse if (ch->sap_4_type) {\n\t\t\t\t\tgf_filter_pck_set_sap(pck, (ch->sap_4_type==GF_ISOM_SAMPLE_PREROLL) ? GF_FILTER_SAP_4_PROL : GF_FILTER_SAP_4);\n\t\t\t\t\tgf_filter_pck_set_roll_info(pck, ch->roll);\n\t\t\t\t}\n\n\t\t\t\tsample_dur = ch->sample->duration;\n\t\t\t\tif (ch->sample->nb_pack)\n\t\t\t\t\tsample_dur *= ch->sample->nb_pack;\n\t\t\t\tgf_filter_pck_set_duration(pck, sample_dur);\n\t\t\t\tgf_filter_pck_set_seek_flag(pck, ch->seek_flag);\n\n\t\t\t\t//for now we only signal xPS mask for non-sap\n\t\t\t\tif (ch->xps_mask && !gf_filter_pck_get_sap(pck) ) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_XPS_MASK, &PROP_UINT(ch->xps_mask) );\n\t\t\t\t}\n\n\t\t\t\tdep_flags = ch->isLeading;\n\t\t\t\tdep_flags <<= 2;\n\t\t\t\tdep_flags |= ch->dependsOn;\n\t\t\t\tdep_flags <<= 2;\n\t\t\t\tdep_flags |= ch->dependedOn;\n\t\t\t\tdep_flags <<= 2;\n\t\t\t\tdep_flags |= ch->redundant;\n\n\t\t\t\tif (dep_flags)\n\t\t\t\t\tgf_filter_pck_set_dependency_flags(pck, dep_flags);\n\t\t\t\tif (ch->sample->corrupted)\n\t\t\t\t\tgf_filter_pck_set_corrupted(pck, GF_TRUE);\n\n\t\t\t\tgf_filter_pck_set_crypt_flags(pck, ch->pck_encrypted ? GF_FILTER_PCK_CRYPT : 0);\n\t\t\t\tgf_filter_pck_set_seq_num(pck, ch->sample_num);\n\n\n\t\t\t\tsubs_buf = gf_isom_sample_get_subsamples_buffer(read->mov, ch->track, ch->sample_num, &subs_buf_size);\n\t\t\t\tif (subs_buf) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SUBS, &PROP_DATA_NO_COPY(subs_buf, subs_buf_size) );\n\t\t\t\t}\n\n\t\t\t\tif (ch->sai_buffer && ch->sai_buffer_size && ch->pck_encrypted) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_CENC_SAI, &PROP_DATA(ch->sai_buffer, ch->sai_buffer_size) );\n\t\t\t\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\tif (read->sigfrag) {\n\t\t\t\t\tGF_ISOFragmentBoundaryInfo finfo;\n\t\t\t\t\tif (gf_isom_sample_is_fragment_start(read->mov, ch->track, ch->sample_num, &finfo) ) {\n\t\t\t\t\t\tu64 start=0;\n\t\t\t\t\t\tu32 traf_start = finfo.seg_start_plus_one ? 2 : 1;\n\n\t\t\t\t\t\tif (finfo.seg_start_plus_one)\n\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_CUE_START, &PROP_BOOL(GF_TRUE));\n\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FRAG_START, &PROP_UINT(traf_start));\n\n\t\t\t\t\t\tstart = finfo.frag_start;\n\t\t\t\t\t\tif (finfo.seg_start_plus_one) start = finfo.seg_start_plus_one-1;\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FRAG_RANGE, &PROP_FRAC64_INT(start, finfo.mdat_end));\n\n\n\t\t\t\t\t\tif (finfo.moof_template) {\n\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_MOOF_TEMPLATE, &PROP_DATA((u8 *)finfo.moof_template, finfo.moof_template_size));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (finfo.sidx_end) {\n\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SIDX_RANGE, &PROP_FRAC64_INT(finfo.sidx_start , finfo.sidx_end));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FRAG_TFDT, &PROP_LONGUINT(finfo.first_dts));\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t\tif (ch->sender_ntp) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SENDER_NTP, &PROP_LONGUINT(ch->sender_ntp));\n\t\t\t\t\tif (ch->ntp_at_server_ntp) {\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_RECEIVER_NTP, &PROP_LONGUINT(ch->ntp_at_server_ntp));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tch->eos_sent = 0;\n\t\t\t\tch->nb_empty_retry = 0;\n\n\t\t\t\t//this might not be the true end of stream\n\t\t\t\tif ((ch->streamType==GF_STREAM_AUDIO) && (ch->sample_num == gf_isom_get_sample_count(read->mov, ch->track))) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_END_RANGE, &PROP_BOOL(GF_TRUE));\n\t\t\t\t}\n\n\t\t\t\tif (!ch->item_id) {\n\t\t\t\t\tisor_set_sample_groups_and_aux_data(read, ch, pck);\n\t\t\t\t}\n\t\t\t\tif (ch->sample_data_offset && !gf_sys_is_test_mode())\n\t\t\t\t\tgf_filter_pck_set_byte_offset(pck, ch->sample_data_offset);\n\n\t\t\t\tif (ch->set_disc) {\n\t\t\t\t\tch->set_disc = 0;\n\t\t\t\t\tgf_filter_pck_set_clock_type(pck, GF_FILTER_CLOCK_PCR_DISC);\n\t\t\t\t}\n\t\t\t\tgf_filter_pck_send(pck);\n\t\t\t\tisor_reader_release_sample(ch);\n\n\t\t\t\tch->last_valid_sample_data_offset = ch->sample_data_offset;\n\t\t\t\tif (!in_is_flush)\n\t\t\t\t\tnb_pck--;\n\t\t\t} else if (ch->last_state==GF_EOS) {\n\t\t\t\tif (in_is_flush) {\n\t\t\t\t\tgf_filter_pid_send_flush(ch->pid);\n\t\t\t\t}\n\t\t\t\telse if (ch->playing == 2) {\n\t\t\t\t\tif (in_is_eos) {\n\t\t\t\t\t\tch->playing = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnb_forced_end++;\n\t\t\t\t\t\tcheck_forced_end = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tch->nb_empty_retry++;\n\t\t\t\tif (in_is_eos && !ch->eos_sent) {\n\t\t\t\t\tvoid *tfrf;\n\t\t\t\t\tconst void *gf_isom_get_tfrf(GF_ISOFile *movie, u32 trackNumber);\n\n\t\t\t\t\tch->eos_sent = 1;\n\t\t\t\t\tread->eos_signaled = GF_TRUE;\n\n\t\t\t\t\ttfrf = (void *) gf_isom_get_tfrf(read->mov, ch->track);\n\t\t\t\t\tif (tfrf) {\n\t\t\t\t\t\tgf_filter_pid_set_info_str(ch->pid, \"smooth_tfrf\", &PROP_POINTER(tfrf) );\n\t\t\t\t\t\tch->last_has_tfrf = 1;\n\t\t\t\t\t} else if (ch->last_has_tfrf) {\n\t\t\t\t\t\tgf_filter_pid_set_info_str(ch->pid, \"smooth_tfrf\", NULL);\n\t\t\t\t\t\tch->last_has_tfrf = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tgf_filter_pid_set_eos(ch->pid);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else if (ch->last_state==GF_ISOM_INVALID_FILE) {\n\t\t\t\tif (!ch->eos_sent) {\n\t\t\t\t\tch->eos_sent = 1;\n\t\t\t\t\tread->eos_signaled = GF_TRUE;\n\t\t\t\t\tgf_filter_pid_set_eos(ch->pid);\n\t\t\t\t\tch->playing = GF_FALSE;\n\t\t\t\t}\n\t\t\t\treturn ch->last_state;\n\t\t\t} else {\n\t\t\t\tif ((ch->last_state==GF_OK) && ch->sap_only)\n\t\t\t\t\tgf_filter_ask_rt_reschedule(filter, 1);\n\n\t\t\t\tread->force_fetch = GF_TRUE;\n\t\t\t\tch->nb_empty_retry++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//if no sample fetched for 100 calls, consider no sample for this track and don't use it for memory purge\n\t\t//this is typically needed when some tracks are declared in fragmented mode but not present in the stream (at all or for a long time):\n\t\t//for these tracks, min_offset_plus_one is always 1 (no samples) or a much smaller value than for active tracks\n\t\t// hence forever growing mem storage until stuck at max size...\n\t\tif ((ch->nb_empty_retry<100)\n\t\t\t&& (!min_offset_plus_one || (min_offset_plus_one - 1 > ch->last_valid_sample_data_offset))\n\t\t) {\n\t\t\tmin_offset_plus_one = 1 + ch->last_valid_sample_data_offset;\n\t\t}\n\t}\n\tif (read->mem_load_mode && min_offset_plus_one) {\n\t\tisoffin_purge_mem(read, min_offset_plus_one-1);\n\t}\n\n\t//we reached end of playback due to play range request, we must send eos - however for safety reason with DASH, we first need to cancel the input\n\tif (read->pid && check_forced_end && (nb_forced_end==count)) {\n\t\t//abort input\n\t\tGF_FilterEvent evt;\n\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, read->pid);\n\t\tgf_filter_pid_send_event(read->pid, &evt);\n\t}\n\n\tif (!is_active) {\n\t\treturn GF_EOS;\n\t}\n\n\treturn GF_OK;\n\n}",
      "cve_list": [
        "CVE-2024-6061"
      ],
      "cwe_list": [
        "CWE-835"
      ]
    },
    {
      "project": "gpac",
      "filepath": "src/filters/load_text.c",
      "func_name": "swf_svg_add_iso_sample",
      "func_body": "\nstatic GF_Err swf_svg_add_iso_sample(void *user, const u8 *data, u32 length, u64 timestamp, Bool isRap)\n{\n\tGF_FilterPacket *pck;\n\tu8 *pck_data;\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\tif (!data || !length) return GF_BAD_PARAM;\n\n\tif (ctx->seek_state==2) {\n\t\tDouble ts = (Double) timestamp;\n\t\tts/=1000;\n\t\tif (ts<ctx->start_range) return GF_OK;\n\t\tctx->seek_state = 0;\n\t}\n\n\tpck = gf_filter_pck_new_alloc(ctx->opid, length, &pck_data);\n\tif (pck) {\n\t\tmemcpy(pck_data, data, length);\n\t\tgf_filter_pck_set_cts(pck, (u64) (ctx->timescale*timestamp/1000) );\n\t\tgf_filter_pck_set_sap(pck, isRap ? GF_FILTER_SAP_1 : GF_FILTER_SAP_NONE);\n\t\tgf_filter_pck_set_framing(pck, GF_TRUE, GF_FALSE);\n\n\t\tgf_filter_pck_send(pck);\n\t}\n\n\tif (txtin_check_blocking(ctx))\n\t\tctx->is_suspended = GF_TRUE;\n\treturn GF_OK;",
      "cve_list": [
        "CVE-2024-6062"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "gpac",
      "filepath": "src/filters/dmx_m2ts.c",
      "func_name": "m2tsdmx_on_event",
      "func_body": "\nstatic void m2tsdmx_on_event(GF_M2TS_Demuxer *ts, u32 evt_type, void *param)\n{\n\tu32 i, count;\n\tGF_Filter *filter = (GF_Filter *) ts->user;\n\tGF_M2TSDmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tswitch (evt_type) {\n\tcase GF_M2TS_EVT_PAT_UPDATE:\n\t\tbreak;\n\tcase GF_M2TS_EVT_AIT_FOUND:\n\t\tbreak;\n\tcase GF_M2TS_EVT_PAT_FOUND:\n\t\tif (ctx->mux_tune_state==DMX_TUNE_INIT) {\n\t\t\tctx->mux_tune_state = DMX_TUNE_WAIT_PROGS;\n\t\t\tctx->wait_for_progs = gf_list_count(ts->programs);\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_DSMCC_FOUND:\n\t\tbreak;\n\tcase GF_M2TS_EVT_PMT_FOUND:\n\t\tm2tsdmx_setup_program(ctx, param);\n\t\tif (ctx->mux_tune_state == DMX_TUNE_WAIT_PROGS) {\n\t\t\tgf_assert(ctx->wait_for_progs);\n\t\t\tctx->wait_for_progs--;\n\t\t\tif (!ctx->wait_for_progs) {\n\t\t\t\tctx->mux_tune_state = DMX_TUNE_WAIT_SEEK;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_PMT_REPEAT:\n\t\tbreak;\n\tcase GF_M2TS_EVT_PMT_UPDATE:\n\t\tm2tsdmx_setup_program(ctx, param);\n\t\tbreak;\n\n\tcase GF_M2TS_EVT_SDT_FOUND:\n\tcase GF_M2TS_EVT_SDT_UPDATE:\n//\tcase GF_M2TS_EVT_SDT_REPEAT:\n\t\tm2tsdmx_update_sdt(ts, NULL);\n\t\tbreak;\n\tcase GF_M2TS_EVT_DVB_GENERAL:\n\t\tif (ctx->eit_pid) {\n\t\t\tGF_M2TS_SL_PCK *pck = (GF_M2TS_SL_PCK *)param;\n\t\t\tu8 *data;\n\t\t\tGF_FilterPacket *dst_pck = gf_filter_pck_new_alloc(ctx->eit_pid, pck->data_len, &data);\n\t\t\tif (dst_pck) {\n\t\t\t\tmemcpy(data, pck->data, pck->data_len);\n\t\t\t\tgf_filter_pck_send(dst_pck);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_PES_PCK:\n\t\tif (ctx->mux_tune_state) break;\n\t\tm2tsdmx_send_packet(ctx, param);\n\t\tbreak;\n\tcase GF_M2TS_EVT_SL_PCK: /* DMB specific */\n\t\tif (ctx->mux_tune_state) break;\n\t\tm2tsdmx_send_sl_packet(ctx, param);\n\t\tbreak;\n\tcase GF_M2TS_EVT_PES_PCR:\n\t\tif (ctx->mux_tune_state) break;\n\t{\n\t\tu64 pcr;\n\t\tBool map_time = GF_FALSE;\n\t\tGF_M2TS_PES_PCK *pck = ((GF_M2TS_PES_PCK *) param);\n\t\tBool discontinuity = ( ((GF_M2TS_PES_PCK *) param)->flags & GF_M2TS_PES_PCK_DISCONTINUITY) ? 1 : 0;\n\n\t\tgf_fatal_assert(pck->stream);\n\t\tif (!ctx->sigfrag && ctx->index) {\n\t\t\tm2tsdmx_estimate_duration(ctx, (GF_M2TS_ES *) pck->stream);\n\t\t}\n\n\t\tif (ctx->map_time_on_prog_id && (ctx->map_time_on_prog_id==pck->stream->program->number)) {\n\t\t\tmap_time = GF_TRUE;\n\t\t}\n\n\t\t//we forward the PCR on each pid\n\t\tpcr = ((GF_M2TS_PES_PCK *) param)->PTS;\n\t\tpcr /= 300;\n\t\tcount = gf_list_count(pck->stream->program->streams);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_FilterPacket *dst_pck;\n\t\t\tGF_M2TS_PES *stream = gf_list_get(pck->stream->program->streams, i);\n\t\t\tif (!stream->user) continue;\n\n\t\t\tdst_pck = gf_filter_pck_new_shared(stream->user, NULL, 0, NULL);\n\t\t\tif (!dst_pck) continue;\n\n\t\t\tgf_filter_pck_set_cts(dst_pck, pcr);\n\t\t\tgf_filter_pck_set_clock_type(dst_pck, discontinuity ? GF_FILTER_CLOCK_PCR_DISC : GF_FILTER_CLOCK_PCR);\n\t\t\tif (pck->stream->is_seg_start) {\n\t\t\t\tpck->stream->is_seg_start = GF_FALSE;\n\t\t\t\tgf_filter_pck_set_property(dst_pck, GF_PROP_PCK_CUE_START, &PROP_BOOL(GF_TRUE));\n\t\t\t}\n\t\t\tgf_filter_pck_send(dst_pck);\n\n\t\t\tif (map_time && (stream->flags & GF_M2TS_ES_IS_PES) ) {\n\t\t\t\t((GF_M2TS_PES*)stream)->map_pcr = pcr;\n\t\t\t}\n\t\t}\n\n\t\tif (map_time) {\n\t\t\tctx->map_time_on_prog_id = 0;\n\t\t}\n\t}\n\t\tbreak;\n\n\tcase GF_M2TS_EVT_TDT:\n\t\tif (ctx->mux_tune_state) break;\n\t{\n\t\tGF_M2TS_TDT_TOT *tdt = (GF_M2TS_TDT_TOT *)param;\n\t\tu64 utc_ts = gf_net_get_utc_ts(tdt->year, tdt->month, tdt->day, tdt->hour, tdt->minute, tdt->second);\n\t\tcount = gf_list_count(ts->programs );\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_M2TS_Program *prog = gf_list_get(ts->programs, i);\n\t\t\tu32 j, count2 = gf_list_count(prog->streams);\n\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\tGF_M2TS_ES * stream = gf_list_get(prog->streams, j);\n\t\t\t\tif (stream->user && (stream->flags & GF_M2TS_ES_IS_PES)) {\n\t\t\t\t\tGF_M2TS_PES*pes = (GF_M2TS_PES*)stream;\n\t\t\t\t\tpes->map_utc = utc_ts;\n\t\t\t\t\tpes->map_utc_pcr = prog->last_pcr_value/300;\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[M2TS In] Mapping TDT Time %04d-%02d-%02dT%02d:%02d:%02d and PCR time \"LLD\" on program %d\\n\",\n\t\t\t\t                                       tdt->year, tdt->month+1, tdt->day, tdt->hour, tdt->minute, tdt->second, prog->last_pcr_value/300, prog->number));\n\t\t}\n\t}\n\t\tbreak;\n\tcase GF_M2TS_EVT_TOT:\n\t\tbreak;\n\n\tcase GF_M2TS_EVT_DURATION_ESTIMATED:\n\t{\n\t\tu64 duration = ((GF_M2TS_PES_PCK *) param)->PTS;\n\t\tcount = gf_list_count(ts->programs);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_M2TS_Program *prog = gf_list_get(ts->programs, i);\n\t\t\tu32 j, count2;\n\t\t\tcount2 = gf_list_count(prog->streams);\n\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\tGF_M2TS_ES * stream = gf_list_get(prog->streams, j);\n\t\t\t\tif (stream->user) {\n\t\t\t\t\tgf_filter_pid_set_property(stream->user, GF_PROP_PID_DURATION, & PROP_FRAC64_INT(duration, 1000) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbreak;\n\n\tcase GF_M2TS_EVT_TEMI_LOCATION:\n\t{\n\t\tGF_M2TS_TemiLocationDescriptor *temi_l = (GF_M2TS_TemiLocationDescriptor *)param;\n\t\tconst char *url;\n\t\tu32 len;\n\t\tGF_BitStream *bs;\n\t\tGF_M2TS_ES *es=NULL;\n\t\tGF_M2TS_Prop_TEMIInfo *t;\n\t\tif ((temi_l->pid<8192) && (ctx->ts->ess[temi_l->pid])) {\n\t\t\tes = ctx->ts->ess[temi_l->pid];\n\t\t}\n\t\tif (!es || !es->user) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[M2TSDmx] TEMI location not assigned to a given PID, not supported\\n\"));\n\t\t\tbreak;\n\t\t}\n\t\tGF_SAFEALLOC(t, GF_M2TS_Prop_TEMIInfo);\n\t\tif (!t) break;\n\t\tt->timeline_id = temi_l->timeline_id;\n\t\tt->is_loc = GF_TRUE;\n\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tif (ctx->temi_url)\n\t\t\turl = ctx->temi_url;\n\t\telse\n\t\t\turl = temi_l->external_URL;\n\t\tlen = url ? (u32) strlen(url) : 0;\n\t\tgf_bs_write_data(bs, url, len);\n\t\tgf_bs_write_u8(bs, 0);\n\t\tgf_bs_write_int(bs, temi_l->is_announce, 1);\n\t\tgf_bs_write_int(bs, temi_l->is_splicing, 1);\n\t\tgf_bs_write_int(bs, temi_l->reload_external, 1);\n\t\tgf_bs_write_int(bs, 0, 5);\n\t\tif (temi_l->is_announce) {\n\t\t\tgf_bs_write_u32(bs, temi_l->activation_countdown.den);\n\t\t\tgf_bs_write_u32(bs, temi_l->activation_countdown.num);\n\t\t}\n\t\tgf_bs_get_content(bs, &t->data, &t->len);\n\t\tgf_bs_del(bs);\n\n\t\tif (!es->props) {\n\t\t\tes->props = gf_list_new();\n\t\t}\n\t\tgf_list_add(es->props, t);\n\t}\n\tbreak;\n\tcase GF_M2TS_EVT_TEMI_TIMECODE:\n\t{\n\t\tGF_M2TS_TemiTimecodeDescriptor *temi_t = (GF_M2TS_TemiTimecodeDescriptor*)param;\n\t\tGF_BitStream *bs;\n\t\tGF_M2TS_Prop_TEMIInfo *t;\n\t\tGF_M2TS_ES *es=NULL;\n\t\tif ((temi_t->pid<8192) && (ctx->ts->ess[temi_t->pid])) {\n\t\t\tes = ctx->ts->ess[temi_t->pid];\n\t\t}\n\t\tif (!es || !es->user) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[M2TSDmx] TEMI timing not assigned to a given PID, not supported\\n\"));\n\t\t\tbreak;\n\t\t}\n\t\tGF_SAFEALLOC(t, GF_M2TS_Prop_TEMIInfo);\n\t\tif (!t) break;\n\t\tt->type = M2TS_TEMI_INFO;\n\t\tt->timeline_id = temi_t->timeline_id;\n\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_u32(bs, temi_t->media_timescale);\n\t\tgf_bs_write_u64(bs, temi_t->media_timestamp);\n\t\tgf_bs_write_u64(bs, temi_t->pes_pts);\n\t\tgf_bs_write_int(bs, temi_t->force_reload, 1);\n\t\tgf_bs_write_int(bs, temi_t->is_paused, 1);\n\t\tgf_bs_write_int(bs, temi_t->is_discontinuity, 1);\n\t\tgf_bs_write_int(bs, temi_t->ntp ? 1 : 0, 1);\n\t\tgf_bs_write_int(bs, 0, 4);\n\t\tif (temi_t->ntp)\n\t\t\tgf_bs_write_u64(bs, temi_t->ntp);\n\n\t\tgf_bs_get_content(bs, &t->data, &t->len);\n\t\tgf_bs_del(bs);\n\n\t\tif (!es->props) {\n\t\t\tes->props = gf_list_new();\n\t\t}\n\t\tgf_list_add(es->props, t);\n\t}\n\tbreak;\n\tcase GF_M2TS_EVT_ID3:\n\t{\n\t\tGF_M2TS_PES_PCK *pck = (GF_M2TS_PES_PCK*)param;\n\t\tGF_BitStream *bs;\n\t\tGF_M2TS_Prop *t;\n\t\tu32 count = gf_list_count(pck->stream->program->streams);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_M2TS_PES *es = gf_list_get(pck->stream->program->streams, i);\n\t\t\tif (!es->user) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[M2TSDmx] ID3 metadata not assigned to a given PID, not supported\\n\"));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// attach ID3 markers to audio\n\t\t\tGF_FilterPid *opid = (GF_FilterPid *)es->user;\n\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(opid, GF_PROP_PID_STREAM_TYPE);\n\t\t\tif (!p) return;\n\t\t\tif (p->value.uint != GF_STREAM_AUDIO)\n\t\t\t\tcontinue;\n\n\t\t\tGF_SAFEALLOC(t, GF_M2TS_Prop);\n\t\t\tif (!t) break;\n\t\t\tt->type = M2TS_ID3;\n\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, 90000);                     // timescale\n\t\t\tgf_bs_write_u64(bs, pck->PTS);                  // pts\n\t\t\tgf_bs_write_u32(bs, pck->data_len);\t\t\t\t// data length (bytes)\n\t\t\tgf_bs_write_data(bs, pck->data, pck->data_len); // data\n\t\t\tgf_bs_get_content(bs, &t->data, &t->len);\n\t\t\tgf_bs_del(bs);\n\n\t\t\tif (!es->props) {\n\t\t\t\tes->props = gf_list_new();\n\t\t\t}\n\t\t\tgf_list_add(es->props, t);\n\t\t}\n\t}\n\tbreak;\n\tcase GF_M2TS_EVT_SCTE35_SPLICE_INFO:\n\t{\n\t\tGF_M2TS_SL_PCK *pck = (GF_M2TS_SL_PCK*)param;\n\t\tGF_BitStream *bs;\n\t\tGF_M2TS_Prop *t;\n\n\t\t//for now all SCTE35 must be associated with a stream\n\t\tif (!pck->stream) return;\n\n\t\t// convey SCTE35 splice info to all streams of the program\n\t\tu32 count = gf_list_count(pck->stream->program->streams);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_M2TS_PES *es = gf_list_get(pck->stream->program->streams, i);\n\t\t\tif (!es->user) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[M2TSDmx] SCTE35 section not assigned to a given PID, not supported\\n\"));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// attach SCTE35 info to video only\n\t\t\tGF_FilterPid *opid = (GF_FilterPid *)es->user;\n\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(opid, GF_PROP_PID_STREAM_TYPE);\n\t\t\tif (!p) return;\n\t\t\tif (p->value.uint != GF_STREAM_VISUAL)\n\t\t\t\tcontinue;\n\n\t\t\tGF_SAFEALLOC(t, GF_M2TS_Prop);\n\t\t\tif (!t) break;\n\t\t\tt->type = M2TS_SCTE35;\n\t\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t// ANSI/SCTE 67 2017 (13.1.1.3): \"the entire SCTE 35 splice_info_section starting at the table_id and ending with the CRC_32\"\n\t\t\tgf_bs_write_data(bs, pck->data, pck->data_len);\n\t\t\tgf_bs_get_content(bs, &t->data, &t->len);\n\t\t\tgf_bs_del(bs);\n\n\t\t\tif (!es->props) {\n\t\t\t\tes->props = gf_list_new();\n\t\t\t}\n\t\t\tgf_list_add(es->props, t);\n\n\t\t\t// send SCTE35 info only to the first video pid\n\t\t\tbreak;\n\t\t}\n\t}\n\tbreak;\n\tcase GF_M2TS_EVT_STREAM_REMOVED:\n\t{\n\t\tGF_M2TS_ES *es = (GF_M2TS_ES *)param;\n\t\tif (es && es->props) {\n\t\t\twhile (gf_list_count(es->props)) {\n\t\t\t\tGF_M2TS_Prop *t = gf_list_pop_back(es->props);\n\t\t\t\tgf_free(t->data);\n\t\t\t\tgf_free(t);\n\t\t\t}\n\t\t\tgf_list_del(es->props);\n\t\t}\n\t}\n\t\tbreak;\n\t}",
      "cve_list": [
        "CVE-2024-6063"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "gpac",
      "filepath": "src/scene_manager/loader_xmt.c",
      "func_name": "xmt_node_end",
      "func_body": "static void xmt_node_end(void *sax_cbck, const char *name, const char *name_space)\n{\n\tu32 tag;\n\tGF_XMTParser *parser = (GF_XMTParser *)sax_cbck;\n\tXMTNodeStack *top;\n\tGF_Descriptor *desc;\n\tGF_Node *node = NULL;\n\tif (!parser->doc_type || !parser->state) return;\n\n\ttop = (XMTNodeStack *)gf_list_last(parser->nodes);\n\n\tif (!top) {\n\t\t/*check descr*/\n\t\tdesc = (GF_Descriptor*)gf_list_last(parser->descriptors);\n\t\tif (desc && (desc->tag == gf_odf_get_tag_by_name((char *)name)) ) {\n\n\t\t\t/*assign timescales once the ESD has been parsed*/\n\t\t\tif (desc->tag == GF_ODF_ESD_TAG) {\n\t\t\t\tGF_ESD *esd = (GF_ESD*)desc;\n\t\t\t\tGF_StreamContext *sc = gf_sm_stream_new(parser->load->ctx, esd->ESID, esd->decoderConfig ? esd->decoderConfig->streamType : 0, esd->decoderConfig ? esd->decoderConfig->objectTypeIndication : 0);\n\t\t\t\tif (sc && esd->slConfig && esd->slConfig->timestampResolution)\n\t\t\t\t\tsc->timeScale = esd->slConfig->timestampResolution;\n\t\t\t}\n\n\t\t\tgf_list_rem_last(parser->descriptors);\n\t\t\tif (gf_list_count(parser->descriptors)) return;\n\n\t\t\tif ((parser->doc_type==1) && (parser->state==XMT_STATE_HEAD) && parser->load->ctx && !parser->load->ctx->root_od) {\n\t\t\t\tparser->load->ctx->root_od = (GF_ObjectDescriptor *)desc;\n\t\t\t}\n\t\t\telse if (!parser->od_command) {\n\t\t\t\txmt_report(parser, GF_OK, \"Warning: descriptor %s defined outside scene scope - skipping\", name);\n\n\t\t\t\txmt_remove_link_for_descriptor(parser, desc);\n\t\t\t\tgf_odf_desc_del(desc);\n\n\t\t\t} else {\n\t\t\t\tswitch (parser->od_command->tag) {\n\t\t\t\tcase GF_ODF_ESD_UPDATE_TAG:\n\t\t\t\t\tgf_list_add( ((GF_ESDUpdate *)parser->od_command)->ESDescriptors, desc);\n\t\t\t\t\tbreak;\n\t\t\t\t/*same struct for OD update and IPMP update*/\n\t\t\t\tcase GF_ODF_OD_UPDATE_TAG:\n\t\t\t\tcase GF_ODF_IPMP_UPDATE_TAG:\n\t\t\t\t\tgf_list_add( ((GF_ODUpdate *)parser->od_command)->objectDescriptors, desc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t\tif (parser->state == XMT_STATE_HEAD) {\n\t\t\tif ((parser->doc_type == 1) && !strcmp(name, \"Header\")) parser->state = XMT_STATE_BODY;\n\t\t\t/*X3D header*/\n\t\t\telse if ((parser->doc_type == 2) && !strcmp(name, \"head\")) {\n\t\t\t\tparser->state = XMT_STATE_BODY;\n\t\t\t\t/*create a group at root level*/\n\t\t\t\ttag = xmt_get_node_tag(parser, \"Group\");\n\t\t\t\tnode = gf_node_new(parser->load->scene_graph, tag);\n\t\t\t\tgf_node_register(node, NULL);\n\t\t\t\tgf_sg_set_root_node(parser->load->scene_graph, node);\n\t\t\t\tgf_node_init(node);\n\n\t\t\t\t/*create a default top for X3D*/\n\t\t\t\tGF_SAFEALLOC(parser->x3d_root, XMTNodeStack);\n\t\t\t\tif (!parser->x3d_root) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"Failed to allocate X3D root\\n\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tparser->x3d_root->node = node;\n\t\t\t}\n\t\t\t/*XMT-O header*/\n\t\t\telse if ((parser->doc_type == 3) && !strcmp(name, \"head\")) parser->state = XMT_STATE_BODY;\n\t\t}\n\t\telse if (parser->state == XMT_STATE_ELEMENTS) {\n\t\t\tgf_assert((parser->doc_type != 1) || parser->command);\n\t\t\tif (!strcmp(name, \"Replace\") || !strcmp(name, \"Insert\") || !strcmp(name, \"Delete\")) {\n\t\t\t\tparser->command = NULL;\n\t\t\t\tparser->state = XMT_STATE_COMMANDS;\n\t\t\t}\n\t\t\telse if (!strcmp(name, \"repField\")) {\n\t\t\t\tparser->state = XMT_STATE_COMMANDS;\n\t\t\t}\n\t\t\t/*end proto*/\n\t\t\telse if (!strcmp(name, \"ProtoDeclare\") || !strcmp(name, \"ExternProtoDeclare\"))  {\n\t\t\t\tGF_Proto *cur = parser->parsing_proto;\n\t\t\t\txmt_resolve_routes(parser);\n\t\t\t\tparser->parsing_proto = (GF_Proto*)cur->userpriv;\n\t\t\t\tparser->load->scene_graph = cur->parent_graph;\n\t\t\t\tcur->userpriv = NULL;\n\t\t\t}\n\t\t\telse if (parser->proto_field && !strcmp(name, \"field\")) parser->proto_field = NULL;\n\t\t\t/*end X3D body*/\n\t\t\telse if ((parser->doc_type == 2) && !strcmp(name, \"Scene\")) parser->state = XMT_STATE_BODY_END;\n\t\t}\n\t\telse if (parser->state == XMT_STATE_COMMANDS) {\n\t\t\t/*end XMT-A body*/\n\t\t\tif ((parser->doc_type == 1) && !strcmp(name, \"Body\")) parser->state = XMT_STATE_BODY_END;\n\t\t\t/*end X3D body*/\n\t\t\telse if ((parser->doc_type == 2) && !strcmp(name, \"Scene\")) parser->state = XMT_STATE_BODY_END;\n\t\t\t/*end XMT-O body*/\n\t\t\telse if ((parser->doc_type == 3) && !strcmp(name, \"body\")) parser->state = XMT_STATE_BODY_END;\n\n\t\t\t/*end scene command*/\n\t\t\telse if (!strcmp(name, \"Replace\") || !strcmp(name, \"Insert\") || !strcmp(name, \"Delete\") )  {\n\t\t\t\t/*restore parent command if in CommandBuffer*/\n\t\t\t\tif (parser->command && parser->command_buffer && parser->command_buffer->buffer) {\n\t\t\t\t\t//empty <Insert>\n\t\t\t\t\tif ((parser->command->tag==GF_SG_ROUTE_INSERT) && !parser->command->fromNodeID) {\n\t\t\t\t\t\tgf_list_del_item(parser->command_buffer->commandList, parser->command);\n\t\t\t\t\t}\n\n\t\t\t\t\tparser->command = (GF_Command*) parser->command_buffer->buffer;\n\t\t\t\t\tparser->command_buffer->buffer = NULL;\n\t\t\t\t\tparser->command_buffer = NULL;\n\t\t\t\t} else {\n\t\t\t\t\t//empty <Insert>\n\t\t\t\t\tif (parser->command && (parser->command->tag==GF_SG_ROUTE_INSERT) && !parser->command->fromNodeID) {\n\t\t\t\t\t\tgf_list_del_item(parser->scene_au->commands, parser->command);\n\t\t\t\t\t}\n\t\t\t\t\tparser->command = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*end OD command*/\n\t\t\telse if (!strcmp(name, \"ObjectDescriptorUpdate\") || !strcmp(name, \"ObjectDescriptorRemove\")\n\t\t\t         || !strcmp(name, \"ES_DescriptorUpdate\") || !strcmp(name, \"ES_DescriptorRemove\")\n\t\t\t         || !strcmp(name, \"IPMP_DescriptorUpdate\") || !strcmp(name, \"IPMP_DescriptorRemove\") ) {\n\t\t\t\tparser->od_command = NULL;\n\t\t\t}\n\n\t\t\telse if (!strcmp(name, \"par\"))\n\t\t\t\tparser->in_com = 1;\n\n\n\t\t}\n\t\telse if (parser->state == XMT_STATE_BODY_END) {\n\t\t\t/*end XMT-A*/\n\t\t\tif ((parser->doc_type == 1) && !strcmp(name, \"XMT-A\")) parser->state = XMT_STATE_END;\n\t\t\t/*end X3D*/\n\t\t\telse if ((parser->doc_type == 2) && !strcmp(name, \"X3D\")) {\n\t\t\t\twhile (1) {\n\t\t\t\t\tGF_Node *n = (GF_Node *)gf_list_last(parser->script_to_load);\n\t\t\t\t\tif (!n) break;\n\t\t\t\t\tgf_list_rem_last(parser->script_to_load);\n\t\t\t\t\tgf_sg_script_load(n);\n\t\t\t\t}\n\t\t\t\tgf_list_del(parser->script_to_load);\n\t\t\t\tparser->script_to_load = NULL;\n\t\t\t\tparser->state = XMT_STATE_END;\n\t\t\t}\n\t\t\t/*end XMT-O*/\n\t\t\telse if ((parser->doc_type == 3) && !strcmp(name, \"XMT-O\")) parser->state = XMT_STATE_END;\n\t\t}\n\t\treturn;\n\t}\n\t/*only remove created nodes ... */\n\ttag = xmt_get_node_tag(parser, name);\n\tif (!tag) {\n\t\tif (top->container_field.name) {\n\t\t\tif (!strcmp(name, top->container_field.name)) {\n\t\t\t\tif (top->container_field.fieldType==GF_SG_VRML_SFCOMMANDBUFFER) {\n\t\t\t\t\tparser->state = XMT_STATE_ELEMENTS;\n\t\t\t\t\tparser->command = (GF_Command *) (void *) parser->command_buffer->buffer;\n\t\t\t\t\tparser->command_buffer->buffer = NULL;\n\t\t\t\t\tparser->command_buffer = NULL;\n\t\t\t\t}\n\t\t\t\ttop->container_field.far_ptr = NULL;\n\t\t\t\ttop->container_field.name = NULL;\n\t\t\t\ttop->last = NULL;\n\t\t\t}\n\t\t\t/*end of command inside an command (conditional.buffer replace)*/\n\t\t\telse if (!strcmp(name, \"Replace\") || !strcmp(name, \"Insert\") || !strcmp(name, \"Delete\") )  {\n\t\t\t\tif (parser->command_buffer) {\n\t\t\t\t\tif (parser->command_buffer->bufferSize) {\n\t\t\t\t\t\tparser->command_buffer->bufferSize--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSFCommandBuffer *prev = (SFCommandBuffer *) parser->command_buffer->buffer;\n\t\t\t\t\t\tparser->command_buffer->buffer = NULL;\n\t\t\t\t\t\tparser->command_buffer = prev;\n\t\t\t\t\t}\n\t\t\t\t\t/*stay in command parsing mode (state 3) until we find </buffer>*/\n\t\t\t\t\tparser->state = XMT_STATE_COMMANDS;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*end of protofield node(s) content*/\n\t\t\telse if (!strcmp(name, \"node\") || !strcmp(name, \"nodes\")) {\n\t\t\t\ttop->container_field.far_ptr = NULL;\n\t\t\t\ttop->container_field.name = NULL;\n\t\t\t\ttop->last = NULL;\n\t\t\t}\n\t\t}\n\t\t/*SF/MFNode proto field, just pop node stack*/\n\t\telse if (!top->node && !strcmp(name, \"field\")) {\n\t\t\tgf_list_rem_last(parser->nodes);\n\t\t\tgf_free(top);\n\t\t} else if (top->node && top->node->sgprivate->tag == TAG_ProtoNode) {\n\t\t\tif (!strcmp(name, \"node\") || !strcmp(name, \"nodes\")) {\n\t\t\t\ttop->container_field.far_ptr = NULL;\n\t\t\t\ttop->container_field.name = NULL;\n\t\t\t\ttop->last = NULL;\n\t\t\t} else if (!strcmp(name, \"ProtoInstance\")) {\n\t\t\t\tgf_list_rem_last(parser->nodes);\n\t\t\t\tnode = top->node;\n\t\t\t\tgf_free(top);\n\t\t\t\tgoto attach_node;\n\t\t\t}\n\t\t}\n\t} else if (top->node->sgprivate->tag==tag) {\n\t\tnode = top->node;\n\t\tgf_list_rem_last(parser->nodes);\n\t\tgf_free(top);\n\nattach_node:\n\t\ttop = (XMTNodeStack*)gf_list_last(parser->nodes);\n\t\t/*add node to command*/\n\t\tif (!top || (top->container_field.fieldType==GF_SG_VRML_SFCOMMANDBUFFER)) {\n\t\t\tif (parser->doc_type == 1) {\n\t\t\t\tGF_CommandField *inf;\n\t\t\t\tBool single_node = 0;\n\t\t\t\tif (!parser->command) {\n\t\t\t\t\tgf_assert(0);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tswitch (parser->command->tag) {\n\t\t\t\tcase GF_SG_SCENE_REPLACE:\n\t\t\t\t\tif (parser->parsing_proto) {\n\t\t\t\t\t\tgf_sg_proto_add_node_code(parser->parsing_proto, node);\n\t\t\t\t\t\tgf_node_register(node, NULL);\n\t\t\t\t\t} else if (!parser->command->node) {\n\t\t\t\t\t\tparser->command->node = node;\n\t\t\t\t\t\tgf_node_register(node, NULL);\n\t\t\t\t\t} else if (parser->command->node != node) {\n\t\t\t\t\t\txmt_report(parser, GF_OK, \"Warning: top-node already assigned - discarding node %s\", name);\n\t\t\t\t\t\tgf_node_register(node, NULL);\n\t\t\t\t\t\tgf_node_unregister(node, NULL);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_SG_GLOBAL_QUANTIZER:\n\t\t\t\tcase GF_SG_NODE_INSERT:\n\t\t\t\tcase GF_SG_INDEXED_INSERT:\n\t\t\t\tcase GF_SG_INDEXED_REPLACE:\n\t\t\t\t\tsingle_node = 1;\n\t\t\t\tcase GF_SG_NODE_REPLACE:\n\t\t\t\tcase GF_SG_FIELD_REPLACE:\n\t\t\t\tcase GF_SG_MULTIPLE_REPLACE:\n\t\t\t\t\tinf = (GF_CommandField*)gf_list_last(parser->command->command_fields);\n\t\t\t\t\tif (!inf) {\n\t\t\t\t\t\tinf = gf_sg_command_field_new(parser->command);\n\t\t\t\t\t\tinf->fieldType = GF_SG_VRML_SFNODE;\n\t\t\t\t\t}\n\t\t\t\t\tif ((inf->fieldType==GF_SG_VRML_MFNODE) && !inf->node_list) {\n\t\t\t\t\t\tinf->field_ptr = &inf->node_list;\n\t\t\t\t\t\tif (inf->new_node) {\n\t\t\t\t\t\t\tgf_node_list_add_child(& inf->node_list, inf->new_node);\n\t\t\t\t\t\t\tinf->new_node = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (inf->new_node) {\n\t\t\t\t\t\tif (single_node) {\n\t\t\t\t\t\t\tgf_node_unregister(inf->new_node, NULL);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinf->field_ptr = &inf->node_list;\n\t\t\t\t\t\t\tgf_node_list_add_child(& inf->node_list, inf->new_node);\n\t\t\t\t\t\t\tinf->fieldType = GF_SG_VRML_MFNODE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinf->new_node = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tgf_node_register(node, NULL);\n\t\t\t\t\tif (inf->node_list) {\n\t\t\t\t\t\tgf_node_list_add_child(& inf->node_list, node);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinf->new_node = node;\n\t\t\t\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_SG_PROTO_INSERT:\n\t\t\t\t\tif (parser->parsing_proto) {\n\t\t\t\t\t\tgf_sg_proto_add_node_code(parser->parsing_proto, node);\n\t\t\t\t\t\tgf_node_register(node, NULL);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\txmt_report(parser, GF_OK, \"Warning: node %s defined outside scene scope - skipping\", name);\n\t\t\t\t\tgf_node_register(node, NULL);\n\t\t\t\t\tgf_node_unregister(node, NULL);\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*X3D*/\n\t\t\telse if (parser->doc_type == 2) {\n\t\t\t\tif (parser->parsing_proto) {\n\t\t\t\t\tgf_sg_proto_add_node_code(parser->parsing_proto, node);\n\t\t\t\t\tgf_node_register(node, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tM_Group *gr = (M_Group *)gf_sg_get_root_node(parser->load->scene_graph);\n\t\t\t\t\tif (!gr) {\n\t\t\t\t\t\txmt_report(parser, GF_OK, \"Warning: node %s defined outside scene scope - skipping\", name);\n\t\t\t\t\t\tgf_node_register(node, NULL);\n\t\t\t\t\t\tgf_node_unregister(node, NULL);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//node has already been added to its parent with X3d parsing, because of the default container resolving\n//\t\t\t\t\t\tgf_node_list_add_child(& gr->children, node);\n//\t\t\t\t\t\tgf_node_register(node, NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*special case: replace scene has already been applied (progressive loading)*/\n\t\t\telse if ((parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK) && (parser->load->scene_graph->RootNode!=node) ) {\n\t\t\t\tgf_node_register(node, NULL);\n\t\t\t} else {\n\t\t\t\txmt_report(parser, GF_OK, \"Warning: node %s defined outside scene scope - skipping\", name);\n\t\t\t\tgf_node_register(node, NULL);\n\t\t\t\tgf_node_unregister(node, NULL);\n\t\t\t}\n\t\t}\n\t\tif (parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK) {\n\t\t\t/*load scripts*/\n\t\t\tif (!parser->parsing_proto) {\n\t\t\t\tif ((tag==TAG_MPEG4_Script)\n#ifndef GPAC_DISABLE_X3D\n\t\t\t\t        || (tag==TAG_X3D_Script)\n#endif\n\t\t\t\t   ) {\n\t\t\t\t\t/*it may happen that the script uses itself as a field (not sure this is compliant since this\n\t\t\t\t\timplies a cyclic structure, but happens in some X3D conformance seq)*/\n\t\t\t\t\tif (!top || (top->node != node)) {\n\t\t\t\t\t\tif (parser->command) {\n\t\t\t\t\t\t\tif (!parser->command->scripts_to_load) parser->command->scripts_to_load = gf_list_new();\n\t\t\t\t\t\t\tgf_list_add(parser->command->scripts_to_load, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*do not load script until all routes are established!!*/\n\t\t\t\t\t\telse if (parser->doc_type==2) {\n\t\t\t\t\t\t\tgf_list_add(parser->script_to_load, node);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_sg_script_load(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (parser->current_node_tag==tag) {\n\t\tgf_list_rem_last(parser->nodes);\n\t\tgf_free(top);\n\t} else {\n\t\txmt_report(parser, GF_NON_COMPLIANT_BITSTREAM, \"Warning: closing element %s doesn't match created node %s\", name, gf_node_get_class_name(top->node) );\n\t}\n}",
      "cve_list": [
        "CVE-2024-6064"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "gpac",
      "filepath": "src/scene_manager/loader_xmt.c",
      "func_name": "xmt_parse_descriptor",
      "func_body": "GF_Descriptor *xmt_parse_descriptor(GF_XMTParser *parser, char *name, const GF_XMLAttribute *attributes, u32 nb_attributes, GF_Descriptor *parent)\n{\n\tGF_Err e;\n\tu32 i;\n\tu32 fake_desc = 0;\n\tGF_Descriptor *desc;\n\tchar *xmt_desc_name = NULL, *ocr_ref = NULL, *dep_ref = NULL;\n\tu32 binaryID = 0;\n\tu8 tag = gf_odf_get_tag_by_name(name);\n\n\tif (!tag) {\n\t\tif (!parent) return NULL;\n\t\tswitch (parent->tag) {\n\t\tcase GF_ODF_IOD_TAG:\n\t\tcase GF_ODF_OD_TAG:\n\t\t\tif (!strcmp(name, \"Profiles\")) fake_desc = 1;\n\t\t\telse if (!strcmp(name, \"Descr\")) fake_desc = 1;\n\t\t\telse if (!strcmp(name, \"esDescr\")) fake_desc = 1;\n\t\t\telse if (!strcmp(name, \"URL\")) fake_desc = 1;\n\t\t\telse return NULL;\n\t\t\tbreak;\n\t\tcase GF_ODF_ESD_TAG:\n\t\t\tif (!strcmp(name, \"decConfigDescr\")) fake_desc = 1;\n\t\t\telse if (!strcmp(name, \"slConfigDescr\")) fake_desc = 1;\n\t\t\telse return NULL;\n\t\t\tbreak;\n\t\tcase GF_ODF_DCD_TAG:\n\t\t\tif (!strcmp(name, \"decSpecificInfo\")) fake_desc = 1;\n\t\t\telse return NULL;\n\t\t\tbreak;\n\t\tcase GF_ODF_SLC_TAG:\n\t\t\tif (!strcmp(name, \"custom\")) fake_desc = 1;\n\t\t\telse return NULL;\n\t\t\tbreak;\n\t\tcase GF_ODF_MUXINFO_TAG:\n\t\t\tif (!strcmp(name, \"MP4MuxHints\")) fake_desc = 1;\n\t\t\telse return NULL;\n\t\t\tbreak;\n\t\tcase GF_ODF_BIFS_CFG_TAG:\n\t\t\tif (!strcmp(name, \"commandStream\")) fake_desc = 1;\n\t\t\telse if (!strcmp(name, \"size\")) fake_desc = 2;\n\t\t\telse return NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (fake_desc) {\n\t\ttag = parent->tag;\n\t\tdesc = parent;\n\t} else {\n\t\tdesc = gf_odf_desc_new(tag);\n\t\tif (!desc) return NULL;\n\t}\n\n\tfor (i=0; i<nb_attributes; i++) {\n\t\tGF_XMLAttribute *att = (GF_XMLAttribute *) &attributes[i];\n\t\tif (!att->value || !strlen(att->value)) continue;\n\t\tif (!strcmp(att->name, \"binaryID\")) binaryID = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"objectDescriptorID\")) xmt_desc_name = att->value;\n\t\telse if (!strcmp(att->name, \"ES_ID\")) xmt_desc_name = att->value;\n\t\telse if (!strcmp(att->name, \"OCR_ES_ID\")) ocr_ref = att->value;\n\t\telse if (!strcmp(att->name, \"dependsOn_ES_ID\")) dep_ref = att->value;\n\t\telse {\n\t\t\te = gf_odf_set_field(desc, att->name, att->value);\n\t\t\tif (e) xmt_report(parser, e, \"Warning: %s not a valid attribute for descriptor %s\", att->name, name);\n\t\t\t//store src path but do not concatenate, othewise we break BT<->XMT conversion ...\n\t\t\tif ((desc->tag==GF_ODF_MUXINFO_TAG) && (!stricmp(att->name, \"fileName\") || !stricmp(att->name, \"url\"))) {\n\t\t\t\tGF_MuxInfo *mux = (GF_MuxInfo *) desc;\n\t\t\t\tif (!mux->src_url)\n\t\t\t\t\tmux->src_url = gf_strdup(parser->load->src_url ? parser->load->src_url : parser->load->fileName);\n\t\t\t}\n\t\t}\n\t}\n\tif (binaryID || xmt_desc_name) {\n\t\tif ((tag == GF_ODF_IOD_TAG) || (tag == GF_ODF_OD_TAG))\n\t\t\txmt_new_od_link(parser, (GF_ObjectDescriptor *)desc, xmt_desc_name, binaryID);\n\t\telse if (tag == GF_ODF_ESD_TAG) {\n\t\t\txmt_new_esd_link(parser, (GF_ESD *) desc, xmt_desc_name, binaryID);\n\n\t\t\t/*set references once the esd link has been established*/\n\t\t\tif (ocr_ref) xmt_set_depend_id(parser, (GF_ESD *) desc, ocr_ref, 1);\n\t\t\tif (dep_ref) xmt_set_depend_id(parser, (GF_ESD *) desc, dep_ref, 0);\n\t\t}\n\t}\n\n\tif (fake_desc) {\n\t\tif (fake_desc==2) {\n\t\t\tGF_BIFSConfig *bcfg = (GF_BIFSConfig *)desc;\n\t\t\tparser->load->ctx->scene_width = bcfg->pixelWidth;\n\t\t\tparser->load->ctx->scene_height = bcfg->pixelHeight;\n\t\t\tparser->load->ctx->is_pixel_metrics = bcfg->pixelMetrics;\n\t\t}\n\t\treturn NULL;\n\t}\n\tif (parent) {\n\t\te = gf_odf_desc_add_desc(parent, desc);\n\t\tif (e) {\n\t\t\txmt_report(parser, GF_OK, \"Invalid child descriptor\");\n\t\t\txmt_remove_link_for_descriptor(parser, desc);\n\t\t\tgf_odf_desc_del(desc);\n\t\t\treturn NULL;\n\t\t}\n\t\t/*finally check for scene manager streams (scene description, OD, ...)*/\n\t\tif (parent->tag == GF_ODF_ESD_TAG) {\n\t\t\tGF_ESD *esd = (GF_ESD *)parent;\n\t\t\tif (esd->decoderConfig) {\n\t\t\t\tswitch (esd->decoderConfig->streamType) {\n\t\t\t\tcase GF_STREAM_SCENE:\n\t\t\t\tcase GF_STREAM_OD:\n\t\t\t\t\tif (!esd->decoderConfig->objectTypeIndication) esd->decoderConfig->objectTypeIndication = 1;\n\t\t\t\t\t/*watchout for default BIFS stream*/\n\t\t\t\t\tif (parser->scene_es && !parser->base_scene_id && (esd->decoderConfig->streamType==GF_STREAM_SCENE)) {\n\t\t\t\t\t\tparser->scene_es->ESID = parser->base_scene_id = esd->ESID;\n\t\t\t\t\t\tparser->scene_es->timeScale = (esd->slConfig && esd->slConfig->timestampResolution) ? esd->slConfig->timestampResolution : 1000;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar *s_name;\n\t\t\t\t\t\tGF_StreamContext *sc = gf_sm_stream_new(parser->load->ctx, esd->ESID, esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t\t\t/*set default timescale for systems tracks (ignored for other)*/\n\t\t\t\t\t\tif (sc) sc->timeScale = (esd->slConfig && esd->slConfig->timestampResolution) ? esd->slConfig->timestampResolution : 1000;\n\t\t\t\t\t\tif (!parser->base_scene_id && (esd->decoderConfig->streamType==GF_STREAM_SCENE)) parser->base_scene_id = esd->ESID;\n\t\t\t\t\t\telse if (!parser->base_od_id && (esd->decoderConfig->streamType==GF_STREAM_OD)) parser->base_od_id = esd->ESID;\n\n\t\t\t\t\t\ts_name = xmt_get_es_name(parser, esd->ESID);\n\t\t\t\t\t\tif (sc && s_name && !sc->name) sc->name = gf_strdup(s_name);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn desc;\n}",
      "cve_list": [
        "CVE-2024-6064"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "gpac",
      "filepath": "src/scene_manager/loader_xmt.c",
      "func_name": "xmt_remove_link_for_descriptor",
      "func_body": "static void xmt_remove_link_for_descriptor(GF_XMTParser* parser, GF_Descriptor* desc) {\n\n\tu32 i=0;\n\tXMT_ODLink *l, *to_del=NULL;\n\twhile ((l = (XMT_ODLink*)gf_list_enum(parser->od_links, &i)) ) {\n\t\tif (l->od && l->od == (GF_ObjectDescriptor*)desc) {\n\t\t\tl->od = NULL;\n\t\t\tto_del = l;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (to_del) {\n\n\t\ti=0;\n\t\tGF_Descriptor* subdesc;\n\t\twhile ((subdesc = gf_list_enum(((GF_ObjectDescriptor*)desc)->ESDescriptors, &i))) {\n\t\t\tif (subdesc) xmt_remove_link_for_descriptor(parser, subdesc);\n\t\t}\n\n\t\tgf_list_del_item(parser->od_links, to_del);\n\t\tif (to_del->desc_name) gf_free(to_del->desc_name);\n\t\tgf_list_del(to_del->mf_urls);\n\t\tgf_free(to_del);\n\t}\n\n\tXMT_ESDLink *esdl, *esdl_del=NULL;\n\ti=0;\n\twhile ((esdl = (XMT_ESDLink *)gf_list_enum(parser->esd_links, &i))) {\n\t\tif (esdl->esd && esdl->esd == (GF_ESD*)desc) {\n\t\t\tesdl->esd = NULL;\n\t\t\tesdl_del = esdl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (esdl_del) {\n\t\tgf_list_del_item(parser->esd_links, esdl_del);\n\t\tif (esdl_del->desc_name) gf_free(esdl_del->desc_name);\n\t\tgf_free(esdl_del);\n\t}\n\n}",
      "cve_list": [
        "CVE-2024-6064"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "OpenSC",
      "filepath": "src/pkcs15init/pkcs15-authentic.c",
      "func_name": "authentic_emu_update_tokeninfo",
      "func_body": "authentic_emu_update_tokeninfo(struct sc_profile *profile, struct sc_pkcs15_card *p15card,\n\t\tstruct sc_pkcs15_tokeninfo *tinfo)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tunsigned char buffer[8];\n\tint rv,len;\n\n\tsc_format_path(AUTHENTIC_CACHE_TIMESTAMP_PATH, &path);\n\trv = sc_select_file(p15card->card, &path, &file);\n\tif (!rv) {\n\t\trv = sc_get_challenge(p15card->card, buffer, sizeof(buffer));\n\t\tif (rv < 0) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Get challenge error\");\n\t\t}\n\n\t\tlen = file->size > sizeof(buffer) ? sizeof(buffer) : file->size;\n\t\trv = sc_update_binary(p15card->card, 0, buffer, len, 0);\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Update binary error\");\n\t}\n\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}",
      "cve_list": [
        "CVE-2024-1454"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "cpython",
      "filepath": "Modules/_ssl.c",
      "func_name": "X509_STORE_get1_objects",
      "func_body": "X509_STORE_get1_objects(X509_STORE *store)\n{\n    STACK_OF(X509_OBJECT) *ret;\n    if (!X509_STORE_lock(store)) {\n        return NULL;\n    }\n    ret = sk_X509_OBJECT_deep_copy(X509_STORE_get0_objects(store),\n                                   x509_object_dup, X509_OBJECT_free);\n    X509_STORE_unlock(store);\n    return ret;\n}",
      "cve_list": [
        "CVE-2024-0397"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "cpython",
      "filepath": "Modules/_ssl.c",
      "func_name": "_ssl__SSLContext_cert_store_stats_impl",
      "func_body": "_ssl__SSLContext_cert_store_stats_impl(PySSLContext *self)\n/*[clinic end generated code: output=5f356f4d9cca874d input=eb40dd0f6d0e40cf]*/\n{\n    X509_STORE *store;\n    STACK_OF(X509_OBJECT) *objs;\n    X509_OBJECT *obj;\n    int x509 = 0, crl = 0, ca = 0, i;\n\n    store = SSL_CTX_get_cert_store(self->ctx);\n    objs = X509_STORE_get1_objects(store);\n    if (objs == NULL) {\n        PyErr_SetString(PyExc_MemoryError, \"failed to query cert store\");\n        return NULL;\n    }\n\n    for (i = 0; i < sk_X509_OBJECT_num(objs); i++) {\n        obj = sk_X509_OBJECT_value(objs, i);\n        switch (X509_OBJECT_get_type(obj)) {\n            case X509_LU_X509:\n                x509++;\n                if (X509_check_ca(X509_OBJECT_get0_X509(obj))) {\n                    ca++;\n                }\n                break;\n            case X509_LU_CRL:\n                crl++;\n                break;\n            default:\n                /* Ignore unrecognized types. */\n                break;\n        }\n    }\n    sk_X509_OBJECT_pop_free(objs, X509_OBJECT_free);\n    return Py_BuildValue(\"{sisisi}\", \"x509\", x509, \"crl\", crl,\n        \"x509_ca\", ca);\n}",
      "cve_list": [
        "CVE-2024-0397"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "cpython",
      "filepath": "Modules/_ssl.c",
      "func_name": "_ssl__SSLContext_get_ca_certs_impl",
      "func_body": "_ssl__SSLContext_get_ca_certs_impl(PySSLContext *self, int binary_form)\n/*[clinic end generated code: output=0d58f148f37e2938 input=6887b5a09b7f9076]*/\n{\n    X509_STORE *store;\n    STACK_OF(X509_OBJECT) *objs;\n    PyObject *ci = NULL, *rlist = NULL;\n    int i;\n\n    if ((rlist = PyList_New(0)) == NULL) {\n        return NULL;\n    }\n\n    store = SSL_CTX_get_cert_store(self->ctx);\n    objs = X509_STORE_get1_objects(store);\n    if (objs == NULL) {\n        PyErr_SetString(PyExc_MemoryError, \"failed to query cert store\");\n        goto error;\n    }\n\n    for (i = 0; i < sk_X509_OBJECT_num(objs); i++) {\n        X509_OBJECT *obj;\n        X509 *cert;\n\n        obj = sk_X509_OBJECT_value(objs, i);\n        if (X509_OBJECT_get_type(obj) != X509_LU_X509) {\n            /* not a x509 cert */\n            continue;\n        }\n        /* CA for any purpose */\n        cert = X509_OBJECT_get0_X509(obj);\n        if (!X509_check_ca(cert)) {\n            continue;\n        }\n        if (binary_form) {\n            ci = _certificate_to_der(get_state_ctx(self), cert);\n        } else {\n            ci = _decode_certificate(get_state_ctx(self), cert);\n        }\n        if (ci == NULL) {\n            goto error;\n        }\n        if (PyList_Append(rlist, ci) == -1) {\n            goto error;\n        }\n        Py_CLEAR(ci);\n    }\n    sk_X509_OBJECT_pop_free(objs, X509_OBJECT_free);\n    return rlist;\n\n  error:\n    sk_X509_OBJECT_pop_free(objs, X509_OBJECT_free);\n    Py_XDECREF(ci);\n    Py_XDECREF(rlist);\n    return NULL;\n}",
      "cve_list": [
        "CVE-2024-0397"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "cpython",
      "filepath": "Modules/_ssl.c",
      "func_name": "x509_object_dup",
      "func_body": "static X509_OBJECT *x509_object_dup(const X509_OBJECT *obj)\n{\n    int ok;\n    X509_OBJECT *ret = X509_OBJECT_new();\n    if (ret == NULL) {\n        return NULL;\n    }\n    switch (X509_OBJECT_get_type(obj)) {\n        case X509_LU_X509:\n            ok = X509_OBJECT_set1_X509(ret, X509_OBJECT_get0_X509(obj));\n            break;\n        case X509_LU_CRL:\n            /* X509_OBJECT_get0_X509_CRL was not const-correct prior to 3.0.*/\n            ok = X509_OBJECT_set1_X509_CRL(\n                ret, X509_OBJECT_get0_X509_CRL((X509_OBJECT *)obj));\n            break;\n        default:\n            /* We cannot duplicate unrecognized types in a polyfill, but it is\n             * safe to leave an empty object. The caller will ignore it. */\n            ok = 1;\n            break;\n    }\n    if (!ok) {\n        X509_OBJECT_free(ret);\n        return NULL;\n    }\n    return ret;\n}",
      "cve_list": [
        "CVE-2024-0397"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "cpython",
      "filepath": "Modules/posixmodule.c",
      "func_name": "clearSecurityAttributes",
      "func_body": "clearSecurityAttributes(\n    PSECURITY_ATTRIBUTES *securityAttributes,\n    struct _Py_SECURITY_ATTRIBUTE_DATA *data\n) {\n    assert(securityAttributes);\n    assert(data);\n    *securityAttributes = NULL;\n    if (data->acl) {\n        if (LocalFree((void *)data->acl)) {\n            return GetLastError();\n        }\n    }\n    return 0;\n}",
      "cve_list": [
        "CVE-2024-4030"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "cpython",
      "filepath": "Modules/posixmodule.c",
      "func_name": "initializeDefaultSecurityAttributes",
      "func_body": "initializeDefaultSecurityAttributes(\n    PSECURITY_ATTRIBUTES *securityAttributes,\n    struct _Py_SECURITY_ATTRIBUTE_DATA *data\n) {\n    assert(securityAttributes);\n    assert(data);\n    *securityAttributes = NULL;\n    memset(data, 0, sizeof(*data));\n    return 0;\n}",
      "cve_list": [
        "CVE-2024-4030"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "cpython",
      "filepath": "Modules/posixmodule.c",
      "func_name": "initializeMkdir700SecurityAttributes",
      "func_body": "initializeMkdir700SecurityAttributes(\n    PSECURITY_ATTRIBUTES *securityAttributes,\n    struct _Py_SECURITY_ATTRIBUTE_DATA *data\n) {\n    assert(securityAttributes);\n    assert(data);\n    *securityAttributes = NULL;\n    memset(data, 0, sizeof(*data));\n\n    if (!InitializeSecurityDescriptor(&data->sd, SECURITY_DESCRIPTOR_REVISION)\n        || !SetSecurityDescriptorGroup(&data->sd, NULL, TRUE)) {\n        return GetLastError();\n    }\n\n    data->securityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);\n    data->ea[0].grfAccessPermissions = GENERIC_ALL;\n    data->ea[0].grfAccessMode = SET_ACCESS;\n    data->ea[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;\n    data->ea[0].Trustee.TrusteeForm = TRUSTEE_IS_NAME;\n    data->ea[0].Trustee.TrusteeType = TRUSTEE_IS_ALIAS;\n    data->ea[0].Trustee.ptstrName = L\"CURRENT_USER\";\n\n    data->ea[1].grfAccessPermissions = GENERIC_ALL;\n    data->ea[1].grfAccessMode = SET_ACCESS;\n    data->ea[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;\n    data->ea[1].Trustee.TrusteeForm = TRUSTEE_IS_NAME;\n    data->ea[1].Trustee.TrusteeType = TRUSTEE_IS_ALIAS;\n    data->ea[1].Trustee.ptstrName = L\"SYSTEM\";\n\n    data->ea[2].grfAccessPermissions = GENERIC_ALL;\n    data->ea[2].grfAccessMode = SET_ACCESS;\n    data->ea[2].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;\n    data->ea[2].Trustee.TrusteeForm = TRUSTEE_IS_NAME;\n    data->ea[2].Trustee.TrusteeType = TRUSTEE_IS_ALIAS;\n    data->ea[2].Trustee.ptstrName = L\"ADMINISTRATORS\";\n\n    int r = SetEntriesInAclW(3, data->ea, NULL, &data->acl);\n    if (r) {\n        return r;\n    }\n    if (!SetSecurityDescriptorDacl(&data->sd, TRUE, data->acl, FALSE)) {\n        return GetLastError();\n    }\n    data->securityAttributes.lpSecurityDescriptor = &data->sd;\n    *securityAttributes = &data->securityAttributes;\n    return 0;\n}",
      "cve_list": [
        "CVE-2024-4030"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "cpython",
      "filepath": "Modules/posixmodule.c",
      "func_name": "os_mkdir_impl",
      "func_body": "os_mkdir_impl(PyObject *module, path_t *path, int mode, int dir_fd)\n/*[clinic end generated code: output=a70446903abe821f input=a61722e1576fab03]*/\n{\n    int result;\n#ifdef MS_WINDOWS\n    int error = 0;\n    int pathError = 0;\n    SECURITY_ATTRIBUTES *pSecAttr = NULL;\n    struct _Py_SECURITY_ATTRIBUTE_DATA secAttrData;\n#endif\n#ifdef HAVE_MKDIRAT\n    int mkdirat_unavailable = 0;\n#endif\n\n    if (PySys_Audit(\"os.mkdir\", \"Oii\", path->object, mode,\n                    dir_fd == DEFAULT_DIR_FD ? -1 : dir_fd) < 0) {\n        return NULL;\n    }\n\n#ifdef MS_WINDOWS\n    Py_BEGIN_ALLOW_THREADS\n    switch (mode) {\n    case 0x1C0: // 0o700\n        error = initializeMkdir700SecurityAttributes(&pSecAttr, &secAttrData);\n        break;\n    default:\n        error = initializeDefaultSecurityAttributes(&pSecAttr, &secAttrData);\n        break;\n    }\n    if (!error) {\n        result = CreateDirectoryW(path->wide, pSecAttr);\n        error = clearSecurityAttributes(&pSecAttr, &secAttrData);\n    } else {\n        // Ignore error from \"clear\" - we have a more interesting one already\n        clearSecurityAttributes(&pSecAttr, &secAttrData);\n    }\n    Py_END_ALLOW_THREADS\n\n    if (error) {\n        PyErr_SetFromWindowsErr(error);\n        return NULL;\n    }\n    if (!result) {\n        return path_error(path);\n    }\n#else\n    Py_BEGIN_ALLOW_THREADS\n#if HAVE_MKDIRAT\n    if (dir_fd != DEFAULT_DIR_FD) {\n      if (HAVE_MKDIRAT_RUNTIME) {\n        result = mkdirat(dir_fd, path->narrow, mode);\n\n      } else {\n        mkdirat_unavailable = 1;\n      }\n    } else\n#endif\n#if defined(__WATCOMC__) && !defined(__QNX__)\n        result = mkdir(path->narrow);\n#else\n        result = mkdir(path->narrow, mode);\n#endif\n    Py_END_ALLOW_THREADS\n\n#if HAVE_MKDIRAT\n    if (mkdirat_unavailable) {\n        argument_unavailable_error(NULL, \"dir_fd\");\n        return NULL;\n    }\n#endif\n\n    if (result < 0)\n        return path_error(path);\n#endif /* MS_WINDOWS */\n    Py_RETURN_NONE;\n}",
      "cve_list": [
        "CVE-2024-4030"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "cpython",
      "filepath": "Modules/posixmodule.c",
      "func_name": "initializeMkdir700SecurityAttributes",
      "func_body": "initializeMkdir700SecurityAttributes(\n    PSECURITY_ATTRIBUTES *securityAttributes,\n    struct _Py_SECURITY_ATTRIBUTE_DATA *data\n) {\n    assert(securityAttributes);\n    assert(data);\n    *securityAttributes = NULL;\n    memset(data, 0, sizeof(*data));\n\n    if (!InitializeSecurityDescriptor(&data->sd, SECURITY_DESCRIPTOR_REVISION)\n        || !SetSecurityDescriptorGroup(&data->sd, NULL, TRUE)) {\n        return GetLastError();\n    }\n\n    int use_alias = 0;\n    DWORD cbSid = sizeof(data->sid);\n    if (!CreateWellKnownSid(WinCreatorOwnerRightsSid, NULL, (PSID)data->sid, &cbSid)) {\n        use_alias = 1;\n    }\n\n    data->securityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);\n    data->ea[0].grfAccessPermissions = GENERIC_ALL;\n    data->ea[0].grfAccessMode = SET_ACCESS;\n    data->ea[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;\n    if (use_alias) {\n        data->ea[0].Trustee.TrusteeForm = TRUSTEE_IS_NAME;\n        data->ea[0].Trustee.TrusteeType = TRUSTEE_IS_ALIAS;\n        data->ea[0].Trustee.ptstrName = L\"CURRENT_USER\";\n    } else {\n        data->ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;\n        data->ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;\n        data->ea[0].Trustee.ptstrName = (LPWCH)(SID*)data->sid;\n    }\n\n    data->ea[1].grfAccessPermissions = GENERIC_ALL;\n    data->ea[1].grfAccessMode = SET_ACCESS;\n    data->ea[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;\n    data->ea[1].Trustee.TrusteeForm = TRUSTEE_IS_NAME;\n    data->ea[1].Trustee.TrusteeType = TRUSTEE_IS_ALIAS;\n    data->ea[1].Trustee.ptstrName = L\"SYSTEM\";\n\n    data->ea[2].grfAccessPermissions = GENERIC_ALL;\n    data->ea[2].grfAccessMode = SET_ACCESS;\n    data->ea[2].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;\n    data->ea[2].Trustee.TrusteeForm = TRUSTEE_IS_NAME;\n    data->ea[2].Trustee.TrusteeType = TRUSTEE_IS_ALIAS;\n    data->ea[2].Trustee.ptstrName = L\"ADMINISTRATORS\";\n\n    int r = SetEntriesInAclW(3, data->ea, NULL, &data->acl);\n    if (r) {\n        return r;\n    }\n    if (!SetSecurityDescriptorDacl(&data->sd, TRUE, data->acl, FALSE)) {\n        return GetLastError();\n    }\n    data->securityAttributes.lpSecurityDescriptor = &data->sd;\n    *securityAttributes = &data->securityAttributes;\n    return 0;\n}",
      "cve_list": [
        "CVE-2024-4030"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "flatpak",
      "filepath": "app/flatpak-builtins-build.c",
      "func_name": "flatpak_builtin_build",
      "func_body": "flatpak_builtin_build (int argc, char **argv, GCancellable *cancellable, GError **error)\n{\n  g_autoptr(GOptionContext) context = NULL;\n  g_autoptr(FlatpakDeploy) runtime_deploy = NULL;\n  g_autoptr(GBytes) runtime_deploy_data = NULL;\n  g_autoptr(FlatpakDeploy) extensionof_deploy = NULL;\n  g_autoptr(GFile) var = NULL;\n  g_autoptr(GFile) var_tmp = NULL;\n  g_autoptr(GFile) var_lib = NULL;\n  g_autoptr(GFile) usr = NULL;\n  g_autoptr(GFile) res_deploy = NULL;\n  g_autoptr(GFile) res_files = NULL;\n  g_autoptr(GFile) app_files = NULL;\n  gboolean app_files_ro = FALSE;\n  g_autoptr(GFile) runtime_files = NULL;\n  g_autoptr(GFile) metadata = NULL;\n  g_autofree char *metadata_contents = NULL;\n  g_autofree char *runtime_pref = NULL;\n  g_autoptr(FlatpakDecomposed) runtime_ref = NULL;\n  g_autofree char *extensionof_ref = NULL;\n  g_autofree char *extensionof_tag = NULL;\n  g_autofree char *extension_point = NULL;\n  g_autofree char *extension_tmpfs_point = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  g_autoptr(GKeyFile) runtime_metakey = NULL;\n  g_autoptr(FlatpakBwrap) bwrap = NULL;\n  g_auto(GStrv) minimal_envp = NULL;\n  gsize metadata_size;\n  const char *directory = NULL;\n  const char *command = \"/bin/sh\";\n  g_autofree char *id = NULL;\n  int i;\n  int rest_argv_start, rest_argc;\n  g_autoptr(FlatpakContext) arg_context = NULL;\n  g_autoptr(FlatpakContext) app_context = NULL;\n  gboolean custom_usr;\n  FlatpakRunFlags run_flags;\n  const char *group = NULL;\n  const char *runtime_key = NULL;\n  g_autofree char *dest = NULL;\n  gboolean is_app = FALSE;\n  gboolean is_extension = FALSE;\n  gboolean is_app_extension = FALSE;\n  g_autofree char *arch = NULL;\n  g_autofree char *app_info_path = NULL;\n  g_autofree char *app_extensions = NULL;\n  g_autofree char *app_ld_path = NULL;\n  g_autofree char *runtime_extensions = NULL;\n  g_autofree char *runtime_ld_path = NULL;\n  g_autofree char *instance_id_host_dir = NULL;\n  g_autofree char *instance_id = NULL;\n  char pid_str[64];\n  g_autofree char *pid_path = NULL;\n  g_autoptr(GFile) app_id_dir = NULL;\n\n  context = g_option_context_new (_(\"DIRECTORY [COMMAND [ARGUMENT]] - Build in directory\"));\n  g_option_context_set_translation_domain (context, GETTEXT_PACKAGE);\n\n  rest_argc = 0;\n  for (i = 1; i < argc; i++)\n    {\n      /* The non-option is the directory, take it out of the arguments */\n      if (argv[i][0] != '-')\n        {\n          rest_argv_start = i;\n          rest_argc = argc - i;\n          argc = i;\n          break;\n        }\n    }\n\n  arg_context = flatpak_context_new ();\n  g_option_context_add_group (context, flatpak_context_get_options (arg_context));\n\n  if (!flatpak_option_context_parse (context, options, &argc, &argv, FLATPAK_BUILTIN_FLAG_NO_DIR, NULL, cancellable, error))\n    return FALSE;\n\n  if (rest_argc == 0)\n    return usage_error (context, _(\"DIRECTORY must be specified\"), error);\n\n  directory = argv[rest_argv_start];\n  if (rest_argc >= 2)\n    command = argv[rest_argv_start + 1];\n\n  res_deploy = g_file_new_for_commandline_arg (directory);\n  metadata = g_file_get_child (res_deploy, opt_metadata ? opt_metadata : \"metadata\");\n\n  if (!g_file_query_exists (res_deploy, NULL) ||\n      !g_file_query_exists (metadata, NULL))\n    return flatpak_fail (error, _(\"Build directory %s not initialized, use flatpak build-init\"), directory);\n\n  if (!g_file_load_contents (metadata, cancellable, &metadata_contents, &metadata_size, NULL, error))\n    return FALSE;\n\n  metakey = g_key_file_new ();\n  if (!g_key_file_load_from_data (metakey, metadata_contents, metadata_size, 0, error))\n    return FALSE;\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_APPLICATION))\n    {\n      group = FLATPAK_METADATA_GROUP_APPLICATION;\n      is_app = TRUE;\n    }\n  else if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_RUNTIME))\n    {\n      group = FLATPAK_METADATA_GROUP_RUNTIME;\n    }\n  else\n    return flatpak_fail (error, _(\"metadata invalid, not application or runtime\"));\n\n  extensionof_ref = g_key_file_get_string (metakey,\n                                           FLATPAK_METADATA_GROUP_EXTENSION_OF,\n                                           FLATPAK_METADATA_KEY_REF, NULL);\n  if (extensionof_ref != NULL)\n    {\n      is_extension = TRUE;\n      if (g_str_has_prefix (extensionof_ref, \"app/\"))\n        is_app_extension = TRUE;\n    }\n\n  extensionof_tag = g_key_file_get_string (metakey,\n                                           FLATPAK_METADATA_GROUP_EXTENSION_OF,\n                                           FLATPAK_METADATA_KEY_TAG, NULL);\n\n  id = g_key_file_get_string (metakey, group, FLATPAK_METADATA_KEY_NAME, error);\n  if (id == NULL)\n    return FALSE;\n\n  if (opt_runtime)\n    runtime_key = FLATPAK_METADATA_KEY_RUNTIME;\n  else\n    runtime_key = FLATPAK_METADATA_KEY_SDK;\n\n  runtime_pref = g_key_file_get_string (metakey, group, runtime_key, error);\n  if (runtime_pref == NULL)\n    return FALSE;\n\n  runtime_ref = flatpak_decomposed_new_from_pref (FLATPAK_KINDS_RUNTIME, runtime_pref, error);\n  if (runtime_ref == NULL)\n    return FALSE;\n\n  arch = flatpak_decomposed_dup_arch (runtime_ref);\n\n  custom_usr = FALSE;\n  usr = g_file_get_child (res_deploy,  opt_sdk_dir ? opt_sdk_dir : \"usr\");\n  if (g_file_query_exists (usr, cancellable))\n    {\n      custom_usr = TRUE;\n      runtime_files = g_object_ref (usr);\n    }\n  else\n    {\n      runtime_deploy = flatpak_find_deploy_for_ref (flatpak_decomposed_get_ref (runtime_ref), NULL, NULL, cancellable, error);\n      if (runtime_deploy == NULL)\n        return FALSE;\n\n      runtime_deploy_data = flatpak_deploy_get_deploy_data (runtime_deploy, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n      if (runtime_deploy_data == NULL)\n        return FALSE;\n\n      runtime_metakey = flatpak_deploy_get_metadata (runtime_deploy);\n\n      runtime_files = flatpak_deploy_get_files (runtime_deploy);\n    }\n\n  var = g_file_get_child (res_deploy, \"var\");\n  var_tmp = g_file_get_child (var, \"tmp\");\n  if (!flatpak_mkdir_p (var_tmp, cancellable, error))\n    return FALSE;\n  var_lib = g_file_get_child (var, \"lib\");\n  if (!flatpak_mkdir_p (var_lib, cancellable, error))\n    return FALSE;\n\n  res_files = g_file_get_child (res_deploy, \"files\");\n\n  if (is_app)\n    {\n      app_files = g_object_ref (res_files);\n      if (opt_with_appdir)\n        {\n          app_id_dir = flatpak_get_data_dir (id);\n          if (!flatpak_ensure_data_dir (app_id_dir, cancellable, NULL))\n            g_clear_object (&app_id_dir);\n        }\n    }\n  else if (is_extension)\n    {\n      g_autoptr(GKeyFile) x_metakey = NULL;\n      g_autofree char *x_group = NULL;\n      g_autofree char *x_dir = NULL;\n      g_autofree char *x_subdir_suffix = NULL;\n      char *x_subdir = NULL;\n      g_autofree char *bare_extension_point = NULL;\n\n      extensionof_deploy = flatpak_find_deploy_for_ref (extensionof_ref, NULL, NULL, cancellable, error);\n      if (extensionof_deploy == NULL)\n        return FALSE;\n\n      x_metakey = flatpak_deploy_get_metadata (extensionof_deploy);\n\n      /* Since we have tagged extensions, it is possible that an extension could\n       * be listed more than once in the \"parent\" flatpak. In that case, we should\n       * try and disambiguate using the following rules:\n       *\n       * 1. Use the 'tag=' key in the ExtensionOfSection and if not found:\n       * 2. Use the only extension point available if there is only one.\n       * 3. If there are no matching groups, return NULL.\n       * 4. In all other cases, error out.\n       */\n      if (!find_matching_extension_group_in_metakey (x_metakey,\n                                                     id,\n                                                     extensionof_tag,\n                                                     &x_group,\n                                                     error))\n        return FALSE;\n\n      if (x_group == NULL)\n        {\n          /* Failed, look for subdirectories=true parent */\n          char *last_dot = strrchr (id, '.');\n\n          if (last_dot != NULL)\n            {\n              char *parent_id = g_strndup (id, last_dot - id);\n              if (!find_matching_extension_group_in_metakey (x_metakey,\n                                                             parent_id,\n                                                             extensionof_tag,\n                                                             &x_group,\n                                                             error))\n                return FALSE;\n\n              if (x_group != NULL &&\n                  g_key_file_get_boolean (x_metakey, x_group,\n                                          FLATPAK_METADATA_KEY_SUBDIRECTORIES,\n                                          NULL))\n                x_subdir = last_dot + 1;\n            }\n\n          if (x_subdir == NULL)\n            return flatpak_fail (error, _(\"No extension point matching %s in %s\"), id, extensionof_ref);\n        }\n\n      x_dir = g_key_file_get_string (x_metakey, x_group,\n                                     FLATPAK_METADATA_KEY_DIRECTORY, error);\n      if (x_dir == NULL)\n        return FALSE;\n\n      x_subdir_suffix = g_key_file_get_string (x_metakey, x_group,\n                                               FLATPAK_METADATA_KEY_SUBDIRECTORY_SUFFIX,\n                                               NULL);\n\n      if (is_app_extension)\n        {\n          app_files = flatpak_deploy_get_files (extensionof_deploy);\n          app_files_ro = TRUE;\n          if (x_subdir != NULL)\n            extension_tmpfs_point = g_build_filename (\"/app\", x_dir, NULL);\n          bare_extension_point = g_build_filename (\"/app\", x_dir, x_subdir, NULL);\n        }\n      else\n        {\n          if (x_subdir != NULL)\n            extension_tmpfs_point = g_build_filename (\"/usr\", x_dir, NULL);\n          bare_extension_point = g_build_filename (\"/usr\", x_dir, x_subdir, NULL);\n        }\n\n      extension_point = g_build_filename (bare_extension_point, x_subdir_suffix, NULL);\n    }\n\n  app_context = flatpak_app_compute_permissions (metakey,\n                                                 runtime_metakey,\n                                                 error);\n  if (app_context == NULL)\n    return FALSE;\n\n  flatpak_context_allow_host_fs (app_context);\n  flatpak_context_merge (app_context, arg_context);\n\n  minimal_envp = flatpak_run_get_minimal_env (TRUE, FALSE);\n  bwrap = flatpak_bwrap_new (minimal_envp);\n  flatpak_bwrap_add_args (bwrap, flatpak_get_bwrap (), NULL);\n\n  run_flags =\n    FLATPAK_RUN_FLAG_DEVEL | FLATPAK_RUN_FLAG_MULTIARCH | FLATPAK_RUN_FLAG_NO_SESSION_HELPER |\n    FLATPAK_RUN_FLAG_SET_PERSONALITY | FLATPAK_RUN_FLAG_NO_A11Y_BUS_PROXY;\n  if (opt_die_with_parent)\n    run_flags |= FLATPAK_RUN_FLAG_DIE_WITH_PARENT;\n  if (custom_usr)\n    run_flags |= FLATPAK_RUN_FLAG_WRITABLE_ETC;\n\n  run_flags |= flatpak_context_get_run_flags (app_context);\n\n  /* Unless manually specified, we disable dbus proxy */\n  if (!flatpak_context_get_needs_session_bus_proxy (arg_context))\n    run_flags |= FLATPAK_RUN_FLAG_NO_SESSION_BUS_PROXY;\n\n  if (!flatpak_context_get_needs_system_bus_proxy (arg_context))\n    run_flags |= FLATPAK_RUN_FLAG_NO_SYSTEM_BUS_PROXY;\n\n  if (opt_log_session_bus)\n    run_flags |= FLATPAK_RUN_FLAG_LOG_SESSION_BUS;\n\n  if (opt_log_system_bus)\n    run_flags |= FLATPAK_RUN_FLAG_LOG_SYSTEM_BUS;\n\n  /* Never set up an a11y bus for builds */\n  run_flags |= FLATPAK_RUN_FLAG_NO_A11Y_BUS_PROXY;\n\n  if (!flatpak_run_setup_base_argv (bwrap, runtime_files, app_id_dir, arch,\n                                    run_flags, error))\n    return FALSE;\n\n  flatpak_bwrap_add_args (bwrap,\n                          (custom_usr && !opt_readonly)  ? \"--bind\" : \"--ro-bind\", flatpak_file_get_path_cached (runtime_files), \"/usr\",\n                          NULL);\n\n  if (!custom_usr)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--lock-file\", \"/usr/.ref\",\n                            NULL);\n\n  if (app_files)\n    flatpak_bwrap_add_args (bwrap,\n                            (app_files_ro || opt_readonly) ? \"--ro-bind\" : \"--bind\", flatpak_file_get_path_cached (app_files), \"/app\",\n                            NULL);\n  else\n    flatpak_bwrap_add_args (bwrap,\n                            \"--dir\", \"/app\",\n                            NULL);\n\n  if (extension_tmpfs_point)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--tmpfs\", extension_tmpfs_point,\n                            NULL);\n\n  /* We add the actual bind below so that we're not shadowed by other extensions or their tmpfs */\n\n  if (extension_point)\n    dest = g_strdup (extension_point);\n  else if (is_app)\n    dest = g_strdup (\"/app\");\n  else\n    dest = g_strdup (\"/usr\");\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--setenv\", \"FLATPAK_DEST\", dest,\n                          \"--setenv\", \"FLATPAK_ID\", id,\n                          \"--setenv\", \"FLATPAK_ARCH\", arch,\n                          NULL);\n\n  /* Persist some stuff in /var. We can't persist everything because  that breaks /var things\n   * from the host to work. For example the /home -> /var/home on atomic.\n   * The interesting things to contain during the build is /var/tmp (for tempfiles shared during builds)\n   * and things like /var/lib/rpm, if the installation uses packages.\n   */\n  flatpak_bwrap_add_args (bwrap,\n                          \"--bind\", flatpak_file_get_path_cached (var_lib), \"/var/lib\",\n                          NULL);\n  flatpak_bwrap_add_args (bwrap,\n                          \"--bind\", flatpak_file_get_path_cached (var_tmp), \"/var/tmp\",\n                          NULL);\n\n  flatpak_run_apply_env_vars (bwrap, app_context);\n\n  if (is_app)\n    {\n      /* We don't actually know the final branchname yet, so use \"nobranch\" as fallback to avoid unexpected matches.\n         This means any extension point used at build time must have explicit versions to work. */\n      g_autoptr(FlatpakDecomposed) fake_ref =\n        flatpak_decomposed_new_from_parts (FLATPAK_KINDS_APP, id, arch, \"nobranch\", NULL);\n      if (fake_ref != NULL &&\n          !flatpak_run_add_extension_args (bwrap, metakey, fake_ref, FALSE, \"/app\",\n                                           &app_extensions, &app_ld_path,\n                                           cancellable, error))\n        return FALSE;\n    }\n\n  if (!custom_usr &&\n      !flatpak_run_add_extension_args (bwrap, runtime_metakey, runtime_ref, FALSE, \"/usr\",\n                                       &runtime_extensions, &runtime_ld_path,\n                                       cancellable, error))\n    return FALSE;\n\n  flatpak_run_extend_ld_path (bwrap, app_ld_path, runtime_ld_path);\n\n  /* Mount this after the above extensions so we always win */\n  if (extension_point)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--bind\", flatpak_file_get_path_cached (res_files), extension_point,\n                            NULL);\n\n  if (!flatpak_run_add_app_info_args (bwrap,\n                                      app_files, app_files, NULL, app_extensions,\n                                      runtime_files, runtime_files, runtime_deploy_data, runtime_extensions,\n                                      id, NULL,\n                                      runtime_ref,\n                                      app_id_dir, app_context, NULL,\n                                      FALSE, TRUE, TRUE,\n                                      &app_info_path, -1,\n                                      &instance_id_host_dir, NULL,\n                                      &instance_id,\n                                      error))\n    return FALSE;\n\n  if (!flatpak_run_add_environment_args (bwrap, app_info_path, run_flags, id,\n                                         app_context, app_id_dir, NULL, -1,\n                                         instance_id, NULL, cancellable, error))\n    return FALSE;\n\n  for (i = 0; opt_bind_mounts != NULL && opt_bind_mounts[i] != NULL; i++)\n    {\n      char *split = strchr (opt_bind_mounts[i], '=');\n      if (split == NULL)\n        {\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_INVALID_ARGUMENT,\n                       _(\"Missing '=' in bind mount option '%s'\"), opt_bind_mounts[i]);\n          return FALSE;\n        }\n\n      *split++ = 0;\n      flatpak_bwrap_add_args (bwrap,\n                              \"--bind\", split, opt_bind_mounts[i],\n                              NULL);\n    }\n\n  if (opt_build_dir != NULL)\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--chdir\", opt_build_dir,\n                              NULL);\n    }\n\n  flatpak_bwrap_populate_runtime_dir (bwrap, NULL);\n\n  flatpak_bwrap_envp_to_args (bwrap);\n\n  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n    return FALSE;\n\n  flatpak_bwrap_add_args (bwrap, \"--\", command, NULL);\n\n  flatpak_bwrap_append_argsv (bwrap,\n                              &argv[rest_argv_start + 2],\n                              rest_argc - 2);\n\n  g_ptr_array_add (bwrap->argv, NULL);\n\n  g_snprintf (pid_str, sizeof (pid_str), \"%d\", getpid ());\n  pid_path = g_build_filename (instance_id_host_dir, \"pid\", NULL);\n  g_file_set_contents (pid_path, pid_str, -1, NULL);\n\n  /* Ensure we unset O_CLOEXEC */\n  child_setup (bwrap->fds);\n  if (execvpe (flatpak_get_bwrap (), (char **) bwrap->argv->pdata, bwrap->envp) == -1)\n    {\n      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (errno),\n                   _(\"Unable to start app\"));\n      return FALSE;\n    }\n\n  /* Not actually reached... */\n  return TRUE;\n}",
      "cve_list": [
        "CVE-2024-32462"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "flatpak",
      "filepath": "common/flatpak-dir.c",
      "func_name": "flatpak_dir_run_triggers",
      "func_body": "flatpak_dir_run_triggers (FlatpakDir   *self,\n                          GCancellable *cancellable,\n                          GError      **error)\n{\n  gboolean ret = FALSE;\n  g_autoptr(GFileEnumerator) dir_enum = NULL;\n  g_autoptr(GFileInfo) child_info = NULL;\n  g_autoptr(GFile) triggersdir = NULL;\n  GError *temp_error = NULL;\n  const char *triggerspath;\n\n  maybe_reload_dbus_config (cancellable);\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      const char *installation = flatpak_dir_get_id (self);\n\n      if (!flatpak_dir_system_helper_call_run_triggers (self,\n                                                        FLATPAK_HELPER_RUN_TRIGGERS_FLAGS_NONE,\n                                                        installation ? installation : \"\",\n                                                        cancellable,\n                                                        error))\n        return FALSE;\n\n      return TRUE;\n    }\n\n  triggerspath = g_getenv (\"FLATPAK_TRIGGERSDIR\");\n  if (triggerspath == NULL)\n    triggerspath = FLATPAK_TRIGGERDIR;\n\n  g_info (\"running triggers from %s\", triggerspath);\n\n  triggersdir = g_file_new_for_path (triggerspath);\n\n  dir_enum = g_file_enumerate_children (triggersdir, \"standard::type,standard::name\",\n                                        0, cancellable, error);\n  if (!dir_enum)\n    goto out;\n\n  while ((child_info = g_file_enumerator_next_file (dir_enum, cancellable, &temp_error)) != NULL)\n    {\n      g_autoptr(GFile) child = NULL;\n      const char *name;\n      GError *trigger_error = NULL;\n\n      name = g_file_info_get_name (child_info);\n\n      child = g_file_get_child (triggersdir, name);\n\n      if (g_file_info_get_file_type (child_info) == G_FILE_TYPE_REGULAR &&\n          g_str_has_suffix (name, \".trigger\"))\n        {\n          /* We need to canonicalize the basedir, because if has a symlink\n             somewhere the bind mount will be on the target of that, not\n             at that exact path. */\n          g_autofree char *basedir_orig = g_file_get_path (self->basedir);\n          g_autofree char *basedir = realpath (basedir_orig, NULL);\n          g_autoptr(FlatpakBwrap) bwrap = NULL;\n          g_autofree char *commandline = NULL;\n\n          g_info (\"running trigger %s\", name);\n\n          bwrap = flatpak_bwrap_new (NULL);\n\n#ifndef DISABLE_SANDBOXED_TRIGGERS\n          flatpak_bwrap_add_arg (bwrap, flatpak_get_bwrap ());\n          flatpak_bwrap_add_args (bwrap,\n                                  \"--unshare-ipc\",\n                                  \"--unshare-net\",\n                                  \"--unshare-pid\",\n                                  \"--ro-bind\", \"/\", \"/\",\n                                  \"--proc\", \"/proc\",\n                                  \"--dev\", \"/dev\",\n                                  \"--bind\", basedir, basedir,\n                                  \"--\",\n                                  NULL);\n#endif\n          flatpak_bwrap_add_args (bwrap,\n                                  flatpak_file_get_path_cached (child),\n                                  basedir,\n                                  NULL);\n          flatpak_bwrap_finish (bwrap);\n\n          commandline = flatpak_quote_argv ((const char **) bwrap->argv->pdata, -1);\n          g_info (\"Running '%s'\", commandline);\n\n          /* We use LEAVE_DESCRIPTORS_OPEN and close them in the child_setup\n           * to work around a deadlock in GLib < 2.60 */\n          if (!g_spawn_sync (\"/\",\n                             (char **) bwrap->argv->pdata,\n                             NULL,\n                             G_SPAWN_SEARCH_PATH | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,\n                             flatpak_bwrap_child_setup_cb, bwrap->fds,\n                             NULL, NULL,\n                             NULL, &trigger_error))\n            {\n              g_warning (\"Error running trigger %s: %s\", name, trigger_error->message);\n              g_clear_error (&trigger_error);\n            }\n        }\n\n      g_clear_object (&child_info);\n    }\n\n  if (temp_error != NULL)\n    {\n      g_propagate_error (error, temp_error);\n      goto out;\n    }\n\n  ret = TRUE;\nout:\n  return ret;\n}",
      "cve_list": [
        "CVE-2024-32462"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "flatpak",
      "filepath": "common/flatpak-run-dbus.c",
      "func_name": "add_bwrap_wrapper",
      "func_body": "add_bwrap_wrapper (FlatpakBwrap *bwrap,\n                   const char   *app_info_path,\n                   GError      **error)\n{\n  glnx_autofd int app_info_fd = -1;\n  g_auto(GLnxDirFdIterator) dir_iter = { 0 };\n  struct dirent *dent;\n  g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();\n  g_autofree char *proxy_socket_dir = g_build_filename (user_runtime_dir, \".dbus-proxy/\", NULL);\n\n  app_info_fd = open (app_info_path, O_RDONLY | O_CLOEXEC);\n  if (app_info_fd == -1)\n    return glnx_throw_errno_prefix (error, _(\"Failed to open app info file\"));\n\n  if (!glnx_dirfd_iterator_init_at (AT_FDCWD, \"/\", FALSE, &dir_iter, error))\n    return FALSE;\n\n  flatpak_bwrap_add_arg (bwrap, flatpak_get_bwrap ());\n\n  while (TRUE)\n    {\n      glnx_autofd int o_path_fd = -1;\n      struct statfs stfs;\n\n      if (!glnx_dirfd_iterator_next_dent_ensure_dtype (&dir_iter, &dent, NULL, error))\n        return FALSE;\n\n      if (dent == NULL)\n        break;\n\n      if (strcmp (dent->d_name, \".flatpak-info\") == 0)\n        continue;\n\n      /* O_PATH + fstatfs is the magic that we need to statfs without automounting the target */\n      o_path_fd = openat (dir_iter.fd, dent->d_name, O_PATH | O_NOFOLLOW | O_CLOEXEC);\n      if (o_path_fd == -1 || fstatfs (o_path_fd, &stfs) != 0 || stfs.f_type == AUTOFS_SUPER_MAGIC)\n        continue; /* AUTOFS mounts are risky and can cause us to block (see issue #1633), so ignore it. Its unlikely the proxy needs such a directory. */\n\n      if (dent->d_type == DT_DIR)\n        {\n          if (strcmp (dent->d_name, \"tmp\") == 0 ||\n              strcmp (dent->d_name, \"var\") == 0 ||\n              strcmp (dent->d_name, \"run\") == 0)\n            flatpak_bwrap_add_arg (bwrap, \"--bind\");\n          else\n            flatpak_bwrap_add_arg (bwrap, \"--ro-bind\");\n\n          flatpak_bwrap_add_arg_printf (bwrap, \"/%s\", dent->d_name);\n          flatpak_bwrap_add_arg_printf (bwrap, \"/%s\", dent->d_name);\n        }\n      else if (dent->d_type == DT_LNK)\n        {\n          g_autofree gchar *target = NULL;\n\n          target = glnx_readlinkat_malloc (dir_iter.fd, dent->d_name,\n                                           NULL, error);\n          if (target == NULL)\n            return FALSE;\n          flatpak_bwrap_add_args (bwrap, \"--symlink\", target, NULL);\n          flatpak_bwrap_add_arg_printf (bwrap, \"/%s\", dent->d_name);\n        }\n    }\n\n  flatpak_bwrap_add_args (bwrap, \"--bind\", proxy_socket_dir, proxy_socket_dir, NULL);\n\n  /* This is a file rather than a bind mount, because it will then\n     not be unmounted from the namespace when the namespace dies. */\n  flatpak_bwrap_add_args (bwrap, \"--perms\", \"0600\", NULL);\n  flatpak_bwrap_add_args_data_fd (bwrap, \"--file\", g_steal_fd (&app_info_fd), \"/.flatpak-info\");\n\n  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n    return FALSE;\n\n  /* End of options: the next argument will be the executable name */\n  flatpak_bwrap_add_arg (bwrap, \"--\");\n\n  return TRUE;\n}",
      "cve_list": [
        "CVE-2024-32462"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "flatpak",
      "filepath": "common/flatpak-run.c",
      "func_name": "flatpak_run_app",
      "func_body": "flatpak_run_app (FlatpakDecomposed   *app_ref,\n                 FlatpakDeploy       *app_deploy,\n                 const char          *custom_app_path,\n                 FlatpakContext      *extra_context,\n                 const char          *custom_runtime,\n                 const char          *custom_runtime_version,\n                 const char          *custom_runtime_commit,\n                 const char          *custom_usr_path,\n                 int                  parent_pid,\n                 FlatpakRunFlags      flags,\n                 const char          *cwd,\n                 const char          *custom_command,\n                 char                *args[],\n                 int                  n_args,\n                 int                  instance_id_fd,\n                 const char * const  *run_environ,\n                 char               **instance_dir_out,\n                 GCancellable        *cancellable,\n                 GError             **error)\n{\n  g_autoptr(FlatpakDeploy) runtime_deploy = NULL;\n  g_autoptr(GBytes) runtime_deploy_data = NULL;\n  g_autoptr(GBytes) app_deploy_data = NULL;\n  g_autoptr(GFile) app_files = NULL;\n  g_autoptr(GFile) original_app_files = NULL;\n  g_autoptr(GFile) runtime_files = NULL;\n  g_autoptr(GFile) original_runtime_files = NULL;\n  g_autoptr(GFile) bin_ldconfig = NULL;\n  g_autoptr(GFile) app_id_dir = NULL;\n  g_autoptr(GFile) real_app_id_dir = NULL;\n  g_autofree char *default_runtime_pref = NULL;\n  g_autoptr(FlatpakDecomposed) default_runtime = NULL;\n  g_autofree char *default_command = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  g_autoptr(GKeyFile) runtime_metakey = NULL;\n  g_autoptr(FlatpakBwrap) bwrap = NULL;\n  const char *command = \"/bin/sh\";\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakDecomposed) runtime_ref = NULL;\n  int i;\n  g_autoptr(GPtrArray) previous_app_id_dirs = NULL;\n  g_autofree char *app_id = NULL;\n  g_autofree char *app_arch = NULL;\n  g_autofree char *app_info_path = NULL;\n  g_autofree char *app_ld_path = NULL;\n  g_autofree char *instance_id_host_dir = NULL;\n  g_autofree char *instance_id_host_private_dir = NULL;\n  g_autofree char *instance_id = NULL;\n  g_autoptr(FlatpakContext) app_context = NULL;\n  g_autoptr(FlatpakContext) overrides = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autofree char *commandline = NULL;\n  g_autofree char *doc_mount_path = NULL;\n  g_autofree char *app_extensions = NULL;\n  g_autofree char *runtime_extensions = NULL;\n  g_autofree char *runtime_ld_path = NULL;\n  g_autofree char *checksum = NULL;\n  glnx_autofd int per_app_dir_lock_fd = -1;\n  g_autofree char *per_app_dir_lock_path = NULL;\n  g_autofree char *shared_xdg_runtime_dir = NULL;\n  int ld_so_fd = -1;\n  g_autoptr(GFile) runtime_ld_so_conf = NULL;\n  gboolean generate_ld_so_conf = TRUE;\n  gboolean use_ld_so_cache = TRUE;\n  gboolean sandboxed = (flags & FLATPAK_RUN_FLAG_SANDBOX) != 0;\n  gboolean parent_expose_pids = (flags & FLATPAK_RUN_FLAG_PARENT_EXPOSE_PIDS) != 0;\n  gboolean parent_share_pids = (flags & FLATPAK_RUN_FLAG_PARENT_SHARE_PIDS) != 0;\n  const char *app_target_path = \"/app\";\n  const char *runtime_target_path = \"/usr\";\n  struct stat s;\n\n  g_assert (run_environ != NULL);\n\n  g_return_val_if_fail (app_ref != NULL, FALSE);\n\n  /* This check exists to stop accidental usage of `sudo flatpak run`\n     and is not to prevent running as root.\n   */\n  if (running_under_sudo ())\n    return flatpak_fail_error (error, FLATPAK_ERROR,\n                               _(\"\\\"flatpak run\\\" is not intended to be run as `sudo flatpak run`. \"\n                                 \"Use `sudo -i` or `su -l` instead and invoke \\\"flatpak run\\\" from \"\n                                 \"inside the new shell.\"));\n\n  app_id = flatpak_decomposed_dup_id (app_ref);\n  g_return_val_if_fail (app_id != NULL, FALSE);\n  app_arch = flatpak_decomposed_dup_arch (app_ref);\n  g_return_val_if_fail (app_arch != NULL, FALSE);\n\n  /* Check the user is allowed to run this flatpak. */\n  if (!check_parental_controls (app_ref, app_deploy, cancellable, error))\n    return FALSE;\n\n  /* Construct the bwrap context. */\n  bwrap = flatpak_bwrap_new (NULL);\n  flatpak_bwrap_add_arg (bwrap, flatpak_get_bwrap ());\n\n  if (app_deploy == NULL)\n    {\n      g_assert (flatpak_decomposed_is_runtime (app_ref));\n      default_runtime_pref = flatpak_decomposed_dup_pref (app_ref);\n    }\n  else\n    {\n      const gchar *key;\n\n      app_deploy_data = flatpak_deploy_get_deploy_data (app_deploy, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n      if (app_deploy_data == NULL)\n        return FALSE;\n\n      if ((flags & FLATPAK_RUN_FLAG_DEVEL) != 0)\n        key = FLATPAK_METADATA_KEY_SDK;\n      else\n        key = FLATPAK_METADATA_KEY_RUNTIME;\n\n      metakey = flatpak_deploy_get_metadata (app_deploy);\n      default_runtime_pref = g_key_file_get_string (metakey,\n                                                    FLATPAK_METADATA_GROUP_APPLICATION,\n                                                    key, &my_error);\n      if (my_error)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n    }\n\n  default_runtime = flatpak_decomposed_new_from_pref (FLATPAK_KINDS_RUNTIME, default_runtime_pref, error);\n  if (default_runtime == NULL)\n    return FALSE;\n\n  if (custom_runtime != NULL || custom_runtime_version != NULL)\n    {\n      g_auto(GStrv) custom_runtime_parts = NULL;\n      const char *custom_runtime_id = NULL;\n      const char *custom_runtime_arch = NULL;\n\n      if (custom_runtime)\n        {\n          custom_runtime_parts = g_strsplit (custom_runtime, \"/\", 0);\n          for (i = 0; i < 3 && custom_runtime_parts[i] != NULL; i++)\n            {\n              if (strlen (custom_runtime_parts[i]) > 0)\n                {\n                  if (i == 0)\n                    custom_runtime_id = custom_runtime_parts[i];\n                  if (i == 1)\n                    custom_runtime_arch = custom_runtime_parts[i];\n\n                  if (i == 2 && custom_runtime_version == NULL)\n                    custom_runtime_version = custom_runtime_parts[i];\n                }\n            }\n        }\n\n      runtime_ref = flatpak_decomposed_new_from_decomposed (default_runtime,\n                                                            FLATPAK_KINDS_RUNTIME,\n                                                            custom_runtime_id,\n                                                            custom_runtime_arch,\n                                                            custom_runtime_version,\n                                                            error);\n      if (runtime_ref == NULL)\n        return FALSE;\n    }\n  else\n    runtime_ref = flatpak_decomposed_ref (default_runtime);\n\n  runtime_deploy = flatpak_find_deploy_for_ref (flatpak_decomposed_get_ref (runtime_ref), custom_runtime_commit, NULL, cancellable, error);\n  if (runtime_deploy == NULL)\n    return FALSE;\n\n  runtime_deploy_data = flatpak_deploy_get_deploy_data (runtime_deploy, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n  if (runtime_deploy_data == NULL)\n    return FALSE;\n\n  runtime_metakey = flatpak_deploy_get_metadata (runtime_deploy);\n\n  app_context = flatpak_app_compute_permissions (metakey, runtime_metakey, error);\n  if (app_context == NULL)\n    return FALSE;\n\n  if (app_deploy != NULL)\n    {\n      overrides = flatpak_deploy_get_overrides (app_deploy);\n      flatpak_context_merge (app_context, overrides);\n    }\n\n  if (sandboxed)\n    flatpak_context_make_sandboxed (app_context);\n\n  if (extra_context)\n    flatpak_context_merge (app_context, extra_context);\n\n  original_runtime_files = flatpak_deploy_get_files (runtime_deploy);\n\n  if (custom_usr_path != NULL)\n    {\n      runtime_files = g_file_new_for_path (custom_usr_path);\n      /* Mount the original runtime below here instead of /usr */\n      runtime_target_path = \"/run/parent/usr\";\n    }\n  else\n    {\n      runtime_files = g_object_ref (original_runtime_files);\n    }\n\n  bin_ldconfig = g_file_resolve_relative_path (runtime_files, \"bin/ldconfig\");\n  if (!g_file_query_exists (bin_ldconfig, NULL))\n    use_ld_so_cache = FALSE;\n\n  /* We can't use the ld.so cache if we are using a custom /usr or /app,\n   * because we don't have a unique ID for the /usr or /app, so we can't\n   * do cache-invalidation correctly. The caller can either build their\n   * own ld.so.cache before supplying us with the runtime, or supply\n   * their own LD_LIBRARY_PATH. */\n  if (custom_usr_path != NULL || custom_app_path != NULL)\n    use_ld_so_cache = FALSE;\n\n  if (app_deploy != NULL)\n    {\n      g_autofree const char **previous_ids = NULL;\n      gsize len = 0;\n      gboolean do_migrate;\n\n      real_app_id_dir = flatpak_get_data_dir (app_id);\n      original_app_files = flatpak_deploy_get_files (app_deploy);\n\n      previous_app_id_dirs = g_ptr_array_new_with_free_func (g_object_unref);\n      previous_ids = flatpak_deploy_data_get_previous_ids (app_deploy_data, &len);\n\n      do_migrate = !g_file_query_exists (real_app_id_dir, cancellable);\n\n      /* When migrating, find most recent old existing source and rename that to\n       * the new name.\n       *\n       * We ignore other names than that. For more recent names that don't exist\n       * we never ran them so nothing will even reference them. For older names\n       * either they were not used, or they were used but then the more recent\n       * name was used and a symlink to it was created.\n       *\n       * This means we may end up with a chain of symlinks: oldest -> old -> current.\n       * This is unfortunate but not really a problem, but for robustness reasons we\n       * don't want to mess with user files unnecessary. For example, the app dir could\n       * actually be a symlink for other reasons. Imagine for instance that you want to put the\n       * steam games somewhere else so you leave the app dir as a symlink to /mnt/steam.\n       */\n      for (i = len - 1; i >= 0; i--)\n        {\n          g_autoptr(GFile) previous_app_id_dir = NULL;\n          g_autoptr(GFileInfo) previous_app_id_dir_info = NULL;\n          g_autoptr(GError) local_error = NULL;\n\n          previous_app_id_dir = flatpak_get_data_dir (previous_ids[i]);\n          previous_app_id_dir_info = g_file_query_info (previous_app_id_dir,\n                                                        G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK \",\"\n                                                        G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                                        cancellable,\n                                                        &local_error);\n          /* Warn about the migration failures, but don't make them fatal, then you can never run the app */\n          if (previous_app_id_dir_info == NULL)\n            {\n              if  (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND) && do_migrate)\n                {\n                  g_warning (_(\"Failed to migrate from %s: %s\"), flatpak_file_get_path_cached (previous_app_id_dir),\n                             local_error->message);\n                  do_migrate = FALSE; /* Don't migrate older things, they are likely symlinks to the thing that we failed on */\n                }\n\n              g_clear_error (&local_error);\n              continue;\n            }\n\n          if (do_migrate)\n            {\n              do_migrate = FALSE; /* Don't migrate older things, they are likely symlinks to this dir */\n\n              /* Don't migrate a symlink pointing to the new data dir. It was likely left over\n               * from a previous migration and would end up pointing to itself */\n              if (g_file_info_get_is_symlink (previous_app_id_dir_info) &&\n                  g_strcmp0 (g_file_info_get_symlink_target (previous_app_id_dir_info), app_id) == 0)\n                break;\n\n              if (!flatpak_file_rename (previous_app_id_dir, real_app_id_dir, cancellable, &local_error))\n                {\n                  g_warning (_(\"Failed to migrate old app data directory %s to new name %s: %s\"),\n                             flatpak_file_get_path_cached (previous_app_id_dir), app_id,\n                             local_error->message);\n                }\n              else\n                {\n                  /* Leave a symlink in place of the old data dir */\n                  if (!g_file_make_symbolic_link (previous_app_id_dir, app_id, cancellable, &local_error))\n                    {\n                      g_warning (_(\"Failed to create symlink while migrating %s: %s\"),\n                                 flatpak_file_get_path_cached (previous_app_id_dir),\n                                 local_error->message);\n                    }\n                }\n            }\n\n          /* Give app access to this old dir */\n          g_ptr_array_add (previous_app_id_dirs, g_steal_pointer (&previous_app_id_dir));\n        }\n\n      if (!flatpak_ensure_data_dir (real_app_id_dir, cancellable, error))\n        return FALSE;\n\n      if (!sandboxed)\n        app_id_dir = g_object_ref (real_app_id_dir);\n    }\n\n  if (custom_app_path != NULL)\n    {\n      if (strcmp (custom_app_path, \"\") == 0)\n        app_files = NULL;\n      else\n        app_files = g_file_new_for_path (custom_app_path);\n\n      /* Mount the original app below here */\n      app_target_path = \"/run/parent/app\";\n    }\n  else if (original_app_files != NULL)\n    {\n      app_files = g_object_ref (original_app_files);\n    }\n\n  flatpak_run_apply_env_default (bwrap, use_ld_so_cache);\n  flatpak_run_apply_env_vars (bwrap, app_context);\n  flatpak_run_apply_env_prompt (bwrap, app_id);\n\n  if (real_app_id_dir)\n    {\n      g_autoptr(GFile) sandbox_dir = g_file_get_child (real_app_id_dir, \"sandbox\");\n      flatpak_bwrap_set_env (bwrap, \"FLATPAK_SANDBOX_DIR\", flatpak_file_get_path_cached (sandbox_dir), TRUE);\n    }\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", flatpak_file_get_path_cached (runtime_files), \"/usr\",\n                          NULL);\n\n  if (runtime_files == original_runtime_files)\n    {\n      /* All true Flatpak runtimes have files/.ref */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--lock-file\", \"/usr/.ref\",\n                              NULL);\n    }\n  else\n    {\n      g_autoptr(GFile) runtime_child = NULL;\n\n      runtime_child = g_file_get_child (runtime_files, \".ref\");\n\n      /* Lock ${usr}/.ref if it exists */\n      if (g_file_query_exists (runtime_child, NULL))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--lock-file\", \"/usr/.ref\",\n                                NULL);\n\n      /* Put the real Flatpak runtime in /run/parent, so that the\n       * replacement /usr can have symlinks into /run/parent in order\n       * to use the Flatpak runtime's graphics drivers etc. if desired */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\",\n                              flatpak_file_get_path_cached (original_runtime_files),\n                              \"/run/parent/usr\",\n                              \"--lock-file\", \"/run/parent/usr/.ref\",\n                              NULL);\n      flatpak_run_setup_usr_links (bwrap, original_runtime_files,\n                                   \"/run/parent\");\n\n      g_clear_object (&runtime_child);\n      runtime_child = g_file_get_child (original_runtime_files, \"etc\");\n\n      if (g_file_query_exists (runtime_child, NULL))\n        flatpak_bwrap_add_args (bwrap,\n                                \"--symlink\", \"usr/etc\", \"/run/parent/etc\",\n                                NULL);\n    }\n\n  if (app_files != NULL)\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", flatpak_file_get_path_cached (app_files), \"/app\",\n                              NULL);\n\n      if (app_files == original_app_files)\n        {\n          /* All true Flatpak apps have files/.ref */\n          flatpak_bwrap_add_args (bwrap,\n                                  \"--lock-file\", \"/app/.ref\",\n                                  NULL);\n        }\n      else\n        {\n          g_autoptr(GFile) app_child = NULL;\n\n          app_child = g_file_get_child (app_files, \".ref\");\n\n          /* Lock ${app}/.ref if it exists */\n          if (g_file_query_exists (app_child, NULL))\n            flatpak_bwrap_add_args (bwrap,\n                                    \"--lock-file\", \"/app/.ref\",\n                                    NULL);\n        }\n    }\n  else\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dir\", \"/app\",\n                              NULL);\n    }\n\n  if (original_app_files != NULL && app_files != original_app_files)\n    {\n      /* Put the real Flatpak app in /run/parent/app */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\",\n                              flatpak_file_get_path_cached (original_app_files),\n                              \"/run/parent/app\",\n                              \"--lock-file\", \"/run/parent/app/.ref\",\n                              NULL);\n    }\n\n  if (metakey != NULL &&\n      !flatpak_run_add_extension_args (bwrap, metakey, app_ref,\n                                       use_ld_so_cache, app_target_path,\n                                       &app_extensions, &app_ld_path,\n                                       cancellable, error))\n    return FALSE;\n\n  if (!flatpak_run_add_extension_args (bwrap, runtime_metakey, runtime_ref,\n                                       use_ld_so_cache, runtime_target_path,\n                                       &runtime_extensions, &runtime_ld_path,\n                                       cancellable, error))\n    return FALSE;\n\n  if (custom_usr_path == NULL)\n    flatpak_run_extend_ld_path (bwrap, NULL, runtime_ld_path);\n\n  if (custom_app_path == NULL)\n    flatpak_run_extend_ld_path (bwrap, app_ld_path, NULL);\n\n  runtime_ld_so_conf = g_file_resolve_relative_path (runtime_files, \"etc/ld.so.conf\");\n  if (lstat (flatpak_file_get_path_cached (runtime_ld_so_conf), &s) == 0)\n    generate_ld_so_conf = S_ISREG (s.st_mode) && s.st_size == 0;\n\n  /* At this point we have the minimal argv set up, with just the app, runtime and extensions.\n     We can reuse this to generate the ld.so.cache (if needed) */\n  if (use_ld_so_cache)\n    {\n      checksum = calculate_ld_cache_checksum (app_deploy_data, runtime_deploy_data,\n                                              app_extensions, runtime_extensions);\n      ld_so_fd = regenerate_ld_cache (bwrap->argv,\n                                      bwrap->fds,\n                                      app_id_dir,\n                                      checksum,\n                                      runtime_files,\n                                      generate_ld_so_conf,\n                                      cancellable, error);\n      if (ld_so_fd == -1)\n        return FALSE;\n      flatpak_bwrap_add_fd (bwrap, ld_so_fd);\n    }\n\n  flags |= flatpak_context_get_run_flags (app_context);\n\n  if (!flatpak_run_setup_base_argv (bwrap, runtime_files, app_id_dir, app_arch, flags, error))\n    return FALSE;\n\n  if (generate_ld_so_conf)\n    {\n      if (!add_ld_so_conf (bwrap, error))\n        return FALSE;\n    }\n\n  if (ld_so_fd != -1)\n    {\n      /* Don't add to fd_array, its already there */\n      flatpak_bwrap_add_arg (bwrap, \"--ro-bind-data\");\n      flatpak_bwrap_add_arg_printf (bwrap, \"%d\", ld_so_fd);\n      flatpak_bwrap_add_arg (bwrap, \"/etc/ld.so.cache\");\n    }\n\n  if (!flatpak_run_add_app_info_args (bwrap,\n                                      app_files, original_app_files, app_deploy_data, app_extensions,\n                                      runtime_files, original_runtime_files, runtime_deploy_data, runtime_extensions,\n                                      app_id, flatpak_decomposed_get_branch (app_ref),\n                                      runtime_ref, app_id_dir, app_context, extra_context,\n                                      sandboxed, FALSE, flags & FLATPAK_RUN_FLAG_DEVEL,\n                                      &app_info_path, instance_id_fd,\n                                      &instance_id_host_dir, &instance_id_host_private_dir,\n                                      &instance_id, error))\n    return FALSE;\n\n  if (!flatpak_run_save_environ (run_environ,\n                                 instance_id_host_private_dir,\n                                 cancellable,\n                                 error))\n    return FALSE;\n\n  if (!sandboxed)\n    {\n      if (!flatpak_instance_ensure_per_app_dir (app_id,\n                                                &per_app_dir_lock_fd,\n                                                &per_app_dir_lock_path,\n                                                error))\n        return FALSE;\n\n      if (!flatpak_instance_ensure_per_app_xdg_runtime_dir (app_id,\n                                                            per_app_dir_lock_fd,\n                                                            &shared_xdg_runtime_dir,\n                                                            error))\n        return FALSE;\n\n      flatpak_bwrap_add_arg (bwrap, \"--bind\");\n      flatpak_bwrap_add_arg (bwrap, shared_xdg_runtime_dir);\n      flatpak_bwrap_add_arg_printf (bwrap, \"/run/user/%d\", getuid ());\n    }\n\n  if (!flatpak_run_add_dconf_args (bwrap, app_id, metakey, error))\n    return FALSE;\n\n  if (!sandboxed && !(flags & FLATPAK_RUN_FLAG_NO_DOCUMENTS_PORTAL))\n    add_document_portal_args (bwrap, app_id, &doc_mount_path);\n\n  if (!flatpak_run_add_environment_args (bwrap, app_info_path, flags,\n                                         app_id, app_context, app_id_dir, previous_app_id_dirs,\n                                         per_app_dir_lock_fd, instance_id,\n                                         &exports, cancellable, error))\n    return FALSE;\n\n  if (per_app_dir_lock_path != NULL)\n    {\n      static const char lock[] = \"/run/flatpak/per-app-dirs-ref\";\n\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", per_app_dir_lock_path, lock,\n                              \"--lock-file\", lock,\n                              NULL);\n    }\n\n  flatpak_run_add_socket_args_late (bwrap, app_context->shares);\n  add_font_path_args (bwrap);\n  add_icon_path_args (bwrap);\n\n  flatpak_bwrap_add_args (bwrap,\n                          /* Not in base, because we don't want this for flatpak build */\n                          \"--symlink\", \"/app/lib/debug/source\", \"/run/build\",\n                          \"--symlink\", \"/usr/lib/debug/source\", \"/run/build-runtime\",\n                          NULL);\n\n  if (cwd)\n    flatpak_bwrap_add_args (bwrap, \"--chdir\", cwd, NULL);\n\n  if (parent_expose_pids || parent_share_pids)\n    {\n      g_autofree char *userns_path = NULL;\n      g_autofree char *pidns_path = NULL;\n      g_autofree char *userns2_path = NULL;\n      int userns_fd, userns2_fd, pidns_fd;\n\n      if (parent_pid == 0)\n        return flatpak_fail (error, \"No parent pid specified\");\n\n      userns_path = g_strdup_printf (\"/proc/%d/root/run/.userns\", parent_pid);\n\n      userns_fd = open_namespace_fd_if_needed (userns_path, \"/proc/self/ns/user\");\n      if (userns_fd != -1)\n        {\n          flatpak_bwrap_add_args_data_fd (bwrap, \"--userns\", userns_fd, NULL);\n\n          userns2_path = g_strdup_printf (\"/proc/%d/ns/user\", parent_pid);\n          userns2_fd = open_namespace_fd_if_needed (userns2_path, userns_path);\n          if (userns2_fd != -1)\n            flatpak_bwrap_add_args_data_fd (bwrap, \"--userns2\", userns2_fd, NULL);\n        }\n\n      pidns_path = g_strdup_printf (\"/proc/%d/ns/pid\", parent_pid);\n      pidns_fd = open (pidns_path, O_RDONLY|O_CLOEXEC);\n      if (pidns_fd != -1)\n        flatpak_bwrap_add_args_data_fd (bwrap, \"--pidns\", pidns_fd, NULL);\n    }\n\n  flatpak_bwrap_populate_runtime_dir (bwrap, shared_xdg_runtime_dir);\n\n  if (custom_command)\n    {\n      command = custom_command;\n    }\n  else if (metakey)\n    {\n      default_command = g_key_file_get_string (metakey,\n                                               FLATPAK_METADATA_GROUP_APPLICATION,\n                                               FLATPAK_METADATA_KEY_COMMAND,\n                                               &my_error);\n      if (my_error)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n      command = default_command;\n    }\n\n  flatpak_bwrap_sort_envp (bwrap);\n  flatpak_bwrap_envp_to_args (bwrap);\n\n  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n    return FALSE;\n\n  flatpak_bwrap_add_args (bwrap, \"--\", command, NULL);\n\n  if (!add_rest_args (bwrap, app_id,\n                      exports, (flags & FLATPAK_RUN_FLAG_FILE_FORWARDING) != 0,\n                      doc_mount_path,\n                      args, n_args, error))\n    return FALSE;\n\n  /* Hold onto the lock until we execute bwrap */\n  flatpak_bwrap_add_noinherit_fd (bwrap, g_steal_fd (&per_app_dir_lock_fd));\n\n  flatpak_bwrap_finish (bwrap);\n\n  commandline = flatpak_quote_argv ((const char **) bwrap->argv->pdata, -1);\n  g_info (\"Running '%s'\", commandline);\n\n  if ((flags & (FLATPAK_RUN_FLAG_BACKGROUND)) != 0 ||\n      g_getenv (\"FLATPAK_TEST_COVERAGE\") != NULL)\n    {\n      GPid child_pid;\n      char pid_str[64];\n      g_autofree char *pid_path = NULL;\n      GSpawnFlags spawn_flags;\n      GSpawnChildSetupFunc child_setup;\n\n      spawn_flags = G_SPAWN_SEARCH_PATH;\n      if (flags & FLATPAK_RUN_FLAG_DO_NOT_REAP ||\n          (flags & FLATPAK_RUN_FLAG_BACKGROUND) == 0)\n        spawn_flags |= G_SPAWN_DO_NOT_REAP_CHILD;\n\n      if (flags & FLATPAK_RUN_FLAG_BACKGROUND)\n        child_setup = flatpak_bwrap_child_setup_cb;\n      else\n        child_setup = flatpak_bwrap_child_setup_inherit_fds_cb;\n\n      /* Even in the case where we want them closed, we use\n       * LEAVE_DESCRIPTORS_OPEN and close them in the child_setup\n       * to work around a deadlock in GLib < 2.60 */\n      spawn_flags |= G_SPAWN_LEAVE_DESCRIPTORS_OPEN;\n\n      /* flatpak_bwrap_envp_to_args() moved the environment variables to\n       * be set into --setenv instructions in argv, so the environment\n       * in which the bwrap command runs must be empty. */\n      g_assert (bwrap->envp != NULL);\n      g_assert (bwrap->envp[0] == NULL);\n\n      if (!g_spawn_async (NULL,\n                          (char **) bwrap->argv->pdata,\n                          bwrap->envp,\n                          spawn_flags,\n                          child_setup, bwrap->fds,\n                          &child_pid,\n                          error))\n        return FALSE;\n\n      g_snprintf (pid_str, sizeof (pid_str), \"%d\", child_pid);\n      pid_path = g_build_filename (instance_id_host_dir, \"pid\", NULL);\n      g_file_set_contents (pid_path, pid_str, -1, NULL);\n\n      if ((flags & (FLATPAK_RUN_FLAG_BACKGROUND)) == 0)\n        {\n          int wait_status;\n\n          if (waitpid (child_pid, &wait_status, 0) != child_pid)\n            return glnx_throw_errno_prefix (error, \"Failed to wait for child process\");\n\n          if (WIFEXITED (wait_status))\n            exit (WEXITSTATUS (wait_status));\n\n          if (WIFSIGNALED (wait_status))\n            exit (128 + WTERMSIG (wait_status));\n\n          return glnx_throw (error, \"Unknown wait status from waitpid(): %d\", wait_status);\n        }\n    }\n  else\n    {\n      char pid_str[64];\n      g_autofree char *pid_path = NULL;\n\n      g_snprintf (pid_str, sizeof (pid_str), \"%d\", getpid ());\n      pid_path = g_build_filename (instance_id_host_dir, \"pid\", NULL);\n      g_file_set_contents (pid_path, pid_str, -1, NULL);\n\n      /* Ensure we unset O_CLOEXEC for marked fds and rewind fds as needed.\n       * Note that this does not close fds that are not already marked O_CLOEXEC, because\n       * we do want to allow inheriting fds into flatpak run. */\n      flatpak_bwrap_child_setup (bwrap->fds, FALSE);\n\n      /* flatpak_bwrap_envp_to_args() moved the environment variables to\n       * be set into --setenv instructions in argv, so the environment\n       * in which the bwrap command runs must be empty. */\n      g_assert (bwrap->envp != NULL);\n      g_assert (bwrap->envp[0] == NULL);\n\n      if (execvpe (flatpak_get_bwrap (), (char **) bwrap->argv->pdata, bwrap->envp) == -1)\n        {\n          g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (errno),\n                               _(\"Unable to start app\"));\n          return FALSE;\n        }\n      /* Not actually reached... */\n    }\n\n  if (instance_dir_out)\n    *instance_dir_out = g_steal_pointer (&instance_id_host_dir);\n\n  return TRUE;\n}",
      "cve_list": [
        "CVE-2024-32462"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "envoy",
      "filepath": "source/extensions/common/proxy_protocol/proxy_protocol_header.cc",
      "func_name": "Envoy::Extensions::Common::ProxyProtocol::generateV2Header",
      "func_body": "bool generateV2Header(const Network::ProxyProtocolData& proxy_proto_data, Buffer::Instance& out,\n                      bool pass_all_tlvs, const absl::flat_hash_set<uint8_t>& pass_through_tlvs) {\n  uint64_t extension_length = 0;\n  for (auto&& tlv : proxy_proto_data.tlv_vector_) {\n    if (!pass_all_tlvs && !pass_through_tlvs.contains(tlv.type)) {\n      continue;\n    }\n    extension_length += PROXY_PROTO_V2_TLV_TYPE_LENGTH_LEN + tlv.value.size();\n    if (extension_length > std::numeric_limits<uint16_t>::max()) {\n      ENVOY_LOG_MISC(\n          warn, \"Generating Proxy Protocol V2 header: TLVs exceed length limit {}, already got {}\",\n          std::numeric_limits<uint16_t>::max(), extension_length);\n      return false;\n    }\n  }\n\n  ASSERT(extension_length <= std::numeric_limits<uint16_t>::max());\n  if (proxy_proto_data.src_addr_ == nullptr || proxy_proto_data.src_addr_->ip() == nullptr) {\n    IS_ENVOY_BUG(\"Missing or incorrect source IP in proxy_proto_data_\");\n    return false;\n  }\n  if (proxy_proto_data.dst_addr_ == nullptr || proxy_proto_data.dst_addr_->ip() == nullptr) {\n    IS_ENVOY_BUG(\"Missing or incorrect dest IP in proxy_proto_data_\");\n    return false;\n  }\n\n  const auto& src = *proxy_proto_data.src_addr_->ip();\n  const auto& dst = *proxy_proto_data.dst_addr_->ip();\n  generateV2Header(src.addressAsString(), dst.addressAsString(), src.port(), dst.port(),\n                   src.version(), static_cast<uint16_t>(extension_length), out);\n\n  // Generate the TLV vector.\n  for (auto&& tlv : proxy_proto_data.tlv_vector_) {\n    if (!pass_all_tlvs && !pass_through_tlvs.contains(tlv.type)) {\n      continue;\n    }\n    out.add(&tlv.type, 1);\n    uint16_t size = htons(static_cast<uint16_t>(tlv.value.size()));\n    out.add(&size, sizeof(uint16_t));\n    out.add(&tlv.value.front(), tlv.value.size());\n  }\n  return true;\n}",
      "cve_list": [
        "CVE-2024-23327"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "envoy",
      "filepath": "source/extensions/filters/listener/proxy_protocol/proxy_protocol.cc",
      "func_name": "Envoy::Extensions::ListenerFilters::ProxyProtocol::Filter::parseBuffer",
      "func_body": "ReadOrParseState Filter::parseBuffer(Network::ListenerFilterBuffer& buffer) {\n  Network::ConnectionSocket& socket = cb_->socket();\n\n  // We return if a) we do not yet have the header, b) we have the header but not yet all\n  // the extension data.\n  if (!proxy_protocol_header_.has_value()) {\n    const ReadOrParseState read_header_state = readProxyHeader(buffer);\n    if (read_header_state != ReadOrParseState::Done) {\n      return read_header_state;\n    }\n  }\n\n  // After parse the header, the extensions size is discovered. Then extend the buffer\n  // size to receive the extensions.\n  if (proxy_protocol_header_.value().wholeHeaderLength() > max_proxy_protocol_len_) {\n    max_proxy_protocol_len_ = proxy_protocol_header_.value().wholeHeaderLength();\n    // The expected header size is changed, waiting for more data.\n    return ReadOrParseState::TryAgainLater;\n  }\n\n  if (proxy_protocol_header_.has_value()) {\n    const ReadOrParseState read_ext_state = readExtensions(buffer);\n    if (read_ext_state != ReadOrParseState::Done) {\n      return read_ext_state;\n    }\n  }\n\n  if (proxy_protocol_header_.has_value() &&\n      !cb_->filterState().hasData<Network::ProxyProtocolFilterState>(\n          Network::ProxyProtocolFilterState::key())) {\n    auto buf = reinterpret_cast<const uint8_t*>(buffer.rawSlice().mem_);\n    if (proxy_protocol_header_.value().local_command_) {\n      ENVOY_LOG(trace, \"Parsed proxy protocol header, cmd: LOCAL, length: {}, buffer: {}\",\n                proxy_protocol_header_.value().wholeHeaderLength(),\n                Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()));\n\n      cb_->filterState().setData(\n          Network::ProxyProtocolFilterState::key(),\n          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n              socket.connectionInfoProvider().remoteAddress(),\n              socket.connectionInfoProvider().localAddress(), parsed_tlvs_}),\n          StreamInfo::FilterState::StateType::Mutable,\n          StreamInfo::FilterState::LifeSpan::Connection);\n    } else {\n      ENVOY_LOG(\n          trace,\n          \"Parsed proxy protocol header, cmd: PROXY, length: {}, buffer: {}, TLV length: {}, TLV \"\n          \"buffer: {}\",\n          proxy_protocol_header_.value().wholeHeaderLength(),\n          Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()),\n          proxy_protocol_header_.value().extensions_length_,\n          Envoy::Hex::encode(buf + proxy_protocol_header_.value().headerLengthWithoutExtension(),\n                             proxy_protocol_header_.value().extensions_length_));\n      cb_->filterState().setData(\n          Network::ProxyProtocolFilterState::key(),\n          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n              proxy_protocol_header_.value().remote_address_,\n              proxy_protocol_header_.value().local_address_, parsed_tlvs_}),\n          StreamInfo::FilterState::StateType::Mutable,\n          StreamInfo::FilterState::LifeSpan::Connection);\n    }\n  }\n\n  if (proxy_protocol_header_.has_value() && !proxy_protocol_header_.value().local_command_) {\n    // If this is a local_command, we are not to override address\n    // Error check the source and destination fields. Most errors are caught by the address\n    // parsing above, but a malformed IPv6 address may combine with a malformed port and parse as\n    // an IPv6 address when parsing for an IPv4 address(for v1 mode). Remote address refers to the\n    // source address.\n    const auto remote_version = proxy_protocol_header_.value().remote_address_->ip()->version();\n    const auto local_version = proxy_protocol_header_.value().local_address_->ip()->version();\n    if (remote_version != proxy_protocol_header_.value().protocol_version_ ||\n        local_version != proxy_protocol_header_.value().protocol_version_) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n    // Check that both addresses are valid unicast addresses, as required for TCP\n    if (!proxy_protocol_header_.value().remote_address_->ip()->isUnicastAddress() ||\n        !proxy_protocol_header_.value().local_address_->ip()->isUnicastAddress()) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n\n    // Only set the local address if it really changed, and mark it as address being restored.\n    if (*proxy_protocol_header_.value().local_address_ !=\n        *socket.connectionInfoProvider().localAddress()) {\n      socket.connectionInfoProvider().restoreLocalAddress(\n          proxy_protocol_header_.value().local_address_);\n    }\n    socket.connectionInfoProvider().setRemoteAddress(\n        proxy_protocol_header_.value().remote_address_);\n  }\n\n  if (!buffer.drain(proxy_protocol_header_.value().wholeHeaderLength())) {\n    return ReadOrParseState::Error;\n  }\n  return ReadOrParseState::Done;\n}",
      "cve_list": [
        "CVE-2024-23327"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "envoy",
      "filepath": "test/extensions/filters/listener/proxy_protocol/proxy_protocol_test.cc",
      "func_name": "Envoy::Extensions::ListenerFilters::ProxyProtocol::TEST_P",
      "func_body": "TEST_P(ProxyProtocolTest, V2LocalConnectionFilterState) {\n  // A well-formed local proxy protocol v2 header sampled from an AWS NLB healthcheck request,\n  // no address, 1 TLV is present.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x20, 0x00, 0x00, 0x07, 0x00, 0x00, 0x04, 0x0a, 0x0b, 0x0c,\n                                0x0d, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  expectData(\"moredata\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n      Envoy::Network::Address::IpVersion::v6) {\n    EXPECT_EQ(proxy_proto_data.dst_addr_->ip()->addressAsString(), \"::1\");\n  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n             Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(proxy_proto_data.dst_addr_->ip()->addressAsString(), \"127.0.0.1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}",
      "cve_list": [
        "CVE-2024-23327"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "envoy",
      "filepath": "test/extensions/transport_sockets/proxy_protocol/proxy_protocol_integration_test.cc",
      "func_name": "Envoy::TEST_P",
      "func_body": "TEST_P(ProxyProtocolTLVsIntegrationTest, TestV2ProxyProtocolPassWithTypeLocal) {\n  setup(true, {}, {});\n  initialize();\n\n  IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort(\"listener_0\"));\n\n  // A well-formed proxy protocol v2 header sampled from an AWS NLB healthcheck request, with\n  // command type 'LOCAL' (0 for the low 4 bits of the 13th octet).\n  constexpr uint8_t v2_protocol[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51,\n                                     0x55, 0x49, 0x54, 0x0a, 0x20, 0x00, 0x00, 0x00,\n                                     'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  Buffer::OwnedImpl buffer(v2_protocol, sizeof(v2_protocol));\n  ASSERT_TRUE(tcp_client->write(buffer.toString()));\n  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection_));\n  std::string header_start;\n  // - signature\n  // - version and command type, address family and protocol, length of addresses\n  // - src address, dest address\n  if (GetParam() == Envoy::Network::Address::IpVersion::v4) {\n    const char data[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a,\n                         0x21, 0x11, 0x00, 0x0c, 0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00, 0x00, 0x01};\n    header_start = std::string(data, sizeof(data));\n  } else {\n    const char data[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a,\n                         0x21, 0x21, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,\n                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};\n    header_start = std::string(data, sizeof(data));\n  }\n\n  constexpr absl::string_view more_data(\"moredata\");\n  const size_t offset = header_start.length() + (2 * sizeof(uint16_t)); // Skip over the ports\n  std::string observed_data;\n  ASSERT_TRUE(fake_upstream_connection_->waitForData(offset + more_data.length(), &observed_data));\n  EXPECT_THAT(observed_data, testing::StartsWith(header_start));\n  EXPECT_EQ(more_data, absl::string_view(&observed_data[offset], more_data.length()));\n\n  tcp_client->close();\n  ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n}",
      "cve_list": [
        "CVE-2024-23327"
      ],
      "cwe_list": [
        "CWE-476"
      ]
    },
    {
      "project": "envoy",
      "filepath": "source/common/router/router.cc",
      "func_name": "Envoy::Router::Filter::onSoftPerTryTimeout",
      "func_body": "void Filter::onSoftPerTryTimeout(UpstreamRequest& upstream_request) {\n  ASSERT(!upstream_request.retried());\n  // Track this as a timeout for outlier detection purposes even though we didn't\n  // cancel the request yet and might get a 2xx later.\n  updateOutlierDetection(Upstream::Outlier::Result::LocalOriginTimeout, upstream_request,\n                         absl::optional<uint64_t>(enumToInt(timeout_response_code_)));\n  upstream_request.outlierDetectionTimeoutRecorded(true);\n\n  if (!downstream_response_started_ && retry_state_) {\n    RetryStatus retry_status = retry_state_->shouldHedgeRetryPerTryTimeout(\n        [this, can_use_http3 = upstream_request.upstreamStreamOptions().can_use_http3_]() -> void {\n          // Without any knowledge about what's going on in the connection pool, retry the request\n          // with the safest settings which is no early data but keep using or not using alt-svc as\n          // before. In this way, QUIC won't be falsely marked as broken.\n          doRetry(/*can_send_early_data*/ false, can_use_http3, TimeoutRetry::Yes);\n        });\n\n    if (retry_status == RetryStatus::Yes) {\n      runRetryOptionsPredicates(upstream_request);\n      pending_retries_++;\n\n      // Don't increment upstream_host->stats().rq_error_ here, we'll do that\n      // later if 1) we hit global timeout or 2) we get bad response headers\n      // back.\n      upstream_request.retried(true);\n\n      // TODO: cluster stat for hedge attempted.\n    } else if (retry_status == RetryStatus::NoOverflow) {\n      callbacks_->streamInfo().setResponseFlag(StreamInfo::CoreResponseFlag::UpstreamOverflow);\n    } else if (retry_status == RetryStatus::NoRetryLimitExceeded) {\n      callbacks_->streamInfo().setResponseFlag(\n          StreamInfo::CoreResponseFlag::UpstreamRetryLimitExceeded);\n    }\n  }\n}",
      "cve_list": [
        "CVE-2024-23322"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "envoy",
      "filepath": "source/common/router/upstream_request.cc",
      "func_name": "Envoy::Router::UpstreamRequest::onPerTryIdleTimeout",
      "func_body": "void UpstreamRequest::onPerTryIdleTimeout() {\n  ENVOY_STREAM_LOG(debug, \"upstream per try idle timeout\", *parent_.callbacks());\n  if (per_try_timeout_) {\n    // Disable the per try idle timer, so it does not trigger further retries\n    per_try_timeout_->disableTimer();\n  }\n  stream_info_.setResponseFlag(StreamInfo::CoreResponseFlag::StreamIdleTimeout);\n  parent_.onPerTryIdleTimeout(*this);\n}",
      "cve_list": [
        "CVE-2024-23322"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "envoy",
      "filepath": "source/common/router/upstream_request.cc",
      "func_name": "Envoy::Router::UpstreamRequest::onPerTryTimeout",
      "func_body": "void UpstreamRequest::onPerTryTimeout() {\n  if (per_try_idle_timeout_) {\n    // Delete the per try idle timer, so it does not trigger further retries.\n    // The timer has to be deleted to prevent data flow from re-arming it.\n    per_try_idle_timeout_.reset();\n  }\n  // If we've sent anything downstream, ignore the per try timeout and let the response continue\n  // up to the global timeout\n  if (!parent_.downstreamResponseStarted()) {\n    ENVOY_STREAM_LOG(debug, \"upstream per try timeout\", *parent_.callbacks());\n\n    stream_info_.setResponseFlag(StreamInfo::CoreResponseFlag::UpstreamRequestTimeout);\n    parent_.onPerTryTimeout(*this);\n  } else {\n    ENVOY_STREAM_LOG(debug,\n                     \"ignored upstream per try timeout due to already started downstream response\",\n                     *parent_.callbacks());\n  }\n}",
      "cve_list": [
        "CVE-2024-23322"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "envoy",
      "filepath": "test/integration/http_timeout_integration_test.cc",
      "func_name": "Envoy::TEST_P",
      "func_body": "TEST_P(HttpTimeoutIntegrationTest, OriginalRequestCompletesBeforeBackoffTimer) {\n  auto host = config_helper_.createVirtualHost(\"example.com\", \"/test_retry\");\n  host.set_include_is_timeout_retry_header(true);\n  config_helper_.addVirtualHost(host);\n  config_helper_.addConfigModifier(\n      [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n              hcm) -> void {\n        auto* route_config = hcm.mutable_route_config();\n        auto* virtual_host = route_config->mutable_virtual_hosts(1);\n        auto* route = virtual_host->mutable_routes(0)->mutable_route();\n        auto* retry_policy = route->mutable_retry_policy();\n        retry_policy->mutable_per_try_idle_timeout()->set_seconds(0);\n        // per try IDLE timeout is 400 ms\n        retry_policy->mutable_per_try_idle_timeout()->set_nanos(400 * 1000 * 1000);\n      });\n  initialize();\n\n  codec_client_ = makeHttpConnection(makeClientConnection(lookupPort(\"http\")));\n  auto encoder_decoder = codec_client_->startRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"POST\"},\n      {\":path\", \"/test_retry\"},\n      {\":scheme\", \"http\"},\n      {\":authority\", \"example.com\"},\n      {\"x-forwarded-for\", \"10.0.0.1\"},\n      {\"x-envoy-retry-on\", \"5xx\"},\n      // Enable hedge_on_per_try_timeout so that original request is not reset\n      {\"x-envoy-hedge-on-per-try-timeout\", \"true\"},\n      {\"x-envoy-upstream-rq-timeout-ms\", \"500\"},\n      // Make per try timeout the same as the per try idle timeout\n      // NOTE: it can be a bit longer, within the back off interval\n      {\"x-envoy-upstream-rq-per-try-timeout-ms\", \"400\"}});\n  auto response = std::move(encoder_decoder.second);\n  request_encoder_ = &encoder_decoder.first;\n\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n  ASSERT_TRUE(upstream_request_->waitForHeadersComplete());\n  codec_client_->sendData(*request_encoder_, 0, true);\n\n  ASSERT_TRUE(upstream_request_->waitForEndStream(*dispatcher_));\n\n  // Trigger per try timeout (but not global timeout). This will actually trigger\n  // both IDLE and request timeouts in the same I/O operation.\n  timeSystem().advanceTimeWait(std::chrono::milliseconds(400));\n\n  // Trigger retry (there's a 25ms backoff before it's issued).\n  timeSystem().advanceTimeWait(std::chrono::milliseconds(26));\n\n  // Wait for a second request to be sent upstream\n  FakeStreamPtr upstream_request2;\n\n  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request2));\n\n  ASSERT_TRUE(upstream_request2->waitForHeadersComplete());\n\n  // Expect the x-envoy-is-timeout-header to set to indicate to the upstream this is a retry\n  // initiated by a previous per try timeout.\n  EXPECT_EQ(upstream_request2->headers().getEnvoyIsTimeoutRetryValue(), \"true\");\n\n  ASSERT_TRUE(upstream_request2->waitForEndStream(*dispatcher_));\n\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"200\"}};\n\n  // Respond to the second request (it does not matter which request gets response).\n  upstream_request2->encodeHeaders(response_headers, true);\n  ASSERT_TRUE(response->waitForEndStream());\n\n  // The first request should be reset since we used the response from the second request.\n  ASSERT_TRUE(upstream_request_->waitForReset(std::chrono::seconds(15)));\n\n  codec_client_->close();\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n}",
      "cve_list": [
        "CVE-2024-23322"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "envoy",
      "filepath": "source/common/network/address_impl.cc",
      "func_name": "Envoy::Network::Address::Ipv4Instance::forceProtocolUnsupportedForTest",
      "func_body": "Cleanup Ipv4Instance::forceProtocolUnsupportedForTest(bool new_val) {\n  bool old_val = force_ipv4_unsupported_for_test;\n  force_ipv4_unsupported_for_test = new_val;\n  return Cleanup([old_val]() { force_ipv4_unsupported_for_test = old_val; });\n}",
      "cve_list": [
        "CVE-2024-23325"
      ],
      "cwe_list": [
        "CWE-755"
      ]
    },
    {
      "project": "envoy",
      "filepath": "source/common/network/address_impl.cc",
      "func_name": "Envoy::Network::Address::Ipv4Instance::validateProtocolSupported",
      "func_body": "absl::Status Ipv4Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET);\n  if (supported && !force_ipv4_unsupported_for_test) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv4 addresses are not supported on this machine\");\n}",
      "cve_list": [
        "CVE-2024-23325"
      ],
      "cwe_list": [
        "CWE-755"
      ]
    },
    {
      "project": "envoy",
      "filepath": "source/common/network/address_impl.cc",
      "func_name": "Envoy::Network::Address::Ipv6Instance::forceProtocolUnsupportedForTest",
      "func_body": "Cleanup Ipv6Instance::forceProtocolUnsupportedForTest(bool new_val) {\n  bool old_val = force_ipv6_unsupported_for_test;\n  force_ipv6_unsupported_for_test = new_val;\n  return Cleanup([old_val]() { force_ipv6_unsupported_for_test = old_val; });\n}",
      "cve_list": [
        "CVE-2024-23325"
      ],
      "cwe_list": [
        "CWE-755"
      ]
    },
    {
      "project": "envoy",
      "filepath": "source/common/network/address_impl.cc",
      "func_name": "Envoy::Network::Address::Ipv6Instance::validateProtocolSupported",
      "func_body": "absl::Status Ipv6Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET6);\n  if (supported && !force_ipv6_unsupported_for_test) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv6 addresses are not supported on this machine\");\n}",
      "cve_list": [
        "CVE-2024-23325"
      ],
      "cwe_list": [
        "CWE-755"
      ]
    },
    {
      "project": "envoy",
      "filepath": "source/extensions/filters/listener/proxy_protocol/proxy_protocol.cc",
      "func_name": "Envoy::Extensions::ListenerFilters::ProxyProtocol::Filter::parseV2Header",
      "func_body": "bool Filter::parseV2Header(const char* buf) {\n  const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n  uint8_t upper_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 2];\n  uint8_t lower_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 1];\n  size_t hdr_addr_len = (upper_byte << 8) + lower_byte;\n\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_LOCAL) {\n    // This is locally-initiated, e.g. health-check, and should not override remote address.\n    // According to the spec, this address length should be zero for local connection.\n    proxy_protocol_header_.emplace(WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, 0, 0});\n    return true;\n  }\n\n  // Only do connections on behalf of another user, not internally-driven health-checks. If\n  // its not on behalf of someone, or its not AF_INET{6} / STREAM/DGRAM, ignore and\n  // use the real-remote info\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_ONBEHALF_OF) {\n    uint8_t proto_family = buf[PROXY_PROTO_V2_SIGNATURE_LEN + 1];\n    if (((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_STREAM) ||\n        ((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_DGRAM)) {\n      if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET) {\n        PACKED_STRUCT(struct pp_ipv4_addr {\n          uint32_t src_addr;\n          uint32_t dst_addr;\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv4_addr* v4;\n        v4 = reinterpret_cast<const pp_ipv4_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in ra4, la4;\n        memset(&ra4, 0, sizeof(ra4));\n        memset(&la4, 0, sizeof(la4));\n        ra4.sin_family = AF_INET;\n        ra4.sin_port = v4->src_port;\n        ra4.sin_addr.s_addr = v4->src_addr;\n\n        la4.sin_family = AF_INET;\n        la4.sin_port = v4->dst_port;\n        la4.sin_addr.s_addr = v4->dst_addr;\n\n        TRY_NEEDS_AUDIT_ADDRESS {\n          // TODO(ggreenway): make this work without requiring operating system support for an\n          // address family.\n          proxy_protocol_header_.emplace(WireHeader{\n              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET,\n              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET, Network::Address::IpVersion::v4,\n              std::make_shared<Network::Address::Ipv4Instance>(&ra4),\n              std::make_shared<Network::Address::Ipv4Instance>(&la4)});\n        }\n        END_TRY CATCH(const EnvoyException& e, {\n          ENVOY_LOG(debug, \"Proxy protocol failure: {}\", e.what());\n          return false;\n        });\n\n        return true;\n      } else if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET6) {\n        PACKED_STRUCT(struct pp_ipv6_addr {\n          uint8_t src_addr[16];\n          uint8_t dst_addr[16];\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv6_addr* v6;\n        v6 = reinterpret_cast<const pp_ipv6_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in6 ra6, la6;\n        memset(&ra6, 0, sizeof(ra6));\n        memset(&la6, 0, sizeof(la6));\n        ra6.sin6_family = AF_INET6;\n        ra6.sin6_port = v6->src_port;\n        safeMemcpy(&(ra6.sin6_addr.s6_addr), &(v6->src_addr));\n\n        la6.sin6_family = AF_INET6;\n        la6.sin6_port = v6->dst_port;\n        safeMemcpy(&(la6.sin6_addr.s6_addr), &(v6->dst_addr));\n\n        TRY_NEEDS_AUDIT_ADDRESS {\n          proxy_protocol_header_.emplace(WireHeader{\n              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET6,\n              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET6, Network::Address::IpVersion::v6,\n              std::make_shared<Network::Address::Ipv6Instance>(ra6),\n              std::make_shared<Network::Address::Ipv6Instance>(la6)});\n        }\n        END_TRY CATCH(const EnvoyException& e, {\n          // TODO(ggreenway): make this work without requiring operating system support for an\n          // address family.\n          ENVOY_LOG(debug, \"Proxy protocol failure: {}\", e.what());\n          return false;\n        });\n        return true;\n      }\n    }\n  }\n  ENVOY_LOG(debug, \"Unsupported command or address family or transport\");\n  return false;\n}",
      "cve_list": [
        "CVE-2024-23325"
      ],
      "cwe_list": [
        "CWE-755"
      ]
    },
    {
      "project": "envoy",
      "filepath": "source/extensions/transport_sockets/tls/connection_info_impl_base.cc",
      "func_name": "Envoy::Extensions::TransportSockets::Tls::ConnectionInfoImplBase::ipSansPeerCertificate",
      "func_body": "absl::Span<const std::string> ConnectionInfoImplBase::ipSansPeerCertificate() const {\n  if (!cached_ip_san_peer_certificate_.empty()) {\n    return cached_ip_san_peer_certificate_;\n  }\n\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_ip_san_peer_certificate_.empty());\n    return cached_ip_san_peer_certificate_;\n  }\n  cached_ip_san_peer_certificate_ = Utility::getSubjectAltNames(*cert, GEN_IPADD, true);\n  return cached_ip_san_peer_certificate_;\n}",
      "cve_list": [
        "CVE-2024-23325"
      ],
      "cwe_list": [
        "CWE-755"
      ]
    },
    {
      "project": "envoy",
      "filepath": "source/extensions/transport_sockets/tls/utility.cc",
      "func_name": "Envoy::Extensions::TransportSockets::Tls::Utility::getSubjectAltNames",
      "func_body": "std::vector<std::string> Utility::getSubjectAltNames(X509& cert, int type, bool skip_unsupported) {\n  std::vector<std::string> subject_alt_names;\n  bssl::UniquePtr<GENERAL_NAMES> san_names(\n      static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(&cert, NID_subject_alt_name, nullptr, nullptr)));\n  if (san_names == nullptr) {\n    return subject_alt_names;\n  }\n  for (const GENERAL_NAME* san : san_names.get()) {\n    if (san->type == type) {\n      if (skip_unsupported) {\n        // An IP SAN for an unsupported IP version will throw an exception.\n        // TODO(ggreenway): remove this when IP address construction no longer throws.\n        TRY_NEEDS_AUDIT_ADDRESS { subject_alt_names.push_back(generalNameAsString(san)); }\n        END_TRY CATCH(const EnvoyException& e,\n                      { ENVOY_LOG_MISC(debug, \"Error reading SAN, value skipped: {}\", e.what()); });\n      } else {\n        subject_alt_names.push_back(generalNameAsString(san));\n      }\n    }\n  }\n  return subject_alt_names;\n}",
      "cve_list": [
        "CVE-2024-23325"
      ],
      "cwe_list": [
        "CWE-755"
      ]
    },
    {
      "project": "envoy",
      "filepath": "test/extensions/filters/listener/proxy_protocol/proxy_protocol_test.cc",
      "func_name": "Envoy::Extensions::ListenerFilters::ProxyProtocol::TEST_P",
      "func_body": "TEST_P(ProxyProtocolTest, V2UnsupportedIPv6) {\n  // A well-formed ipv6/tcp message, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x21, 0x22, 0x00, 0x24, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n                                0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',\n                                'e',  ' ',  'd',  'a',  't',  'a'};\n\n  connect(false);\n  Cleanup cleaner = Network::Address::Ipv6Instance::forceProtocolUnsupportedForTest(true);\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}",
      "cve_list": [
        "CVE-2024-23325"
      ],
      "cwe_list": [
        "CWE-755"
      ]
    },
    {
      "project": "envoy",
      "filepath": "test/extensions/transport_sockets/tls/integration/ssl_integration_test.cc",
      "func_name": "Envoy::Ssl::TEST_P",
      "func_body": "TEST_P(SslIntegrationTest, LogPeerIpSanUnsupportedIpVersion) {\n  useListenerAccessLog(\"%DOWNSTREAM_PEER_IP_SAN%\");\n  config_helper_.addFilter(\"name: sni-to-header-filter\");\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ClientSslTransportOptions().setSni(\"host.com\"));\n  };\n  initialize();\n  codec_client_ = makeHttpConnection(\n      makeSslClientConnection(ClientSslTransportOptions().setSni(\"www.host.com\")));\n\n  // Disable IP version for the alternate type from the test. The client cert has both an ipv4 and\n  // an ipv6 SAN. This must happen after the client has loaded the cert to send as the client cert.\n  auto disabler = (version_ == Network::Address::IpVersion::v4)\n                      ? Network::Address::Ipv6Instance::forceProtocolUnsupportedForTest\n                      : Network::Address::Ipv4Instance::forceProtocolUnsupportedForTest;\n  Cleanup cleaner(disabler(true));\n\n  Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/\"}, {\":scheme\", \"https\"}, {\":authority\", \"host.com\"}};\n  auto response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  waitForNextUpstreamRequest();\n\n  EXPECT_EQ(\"www.host.com\", upstream_request_->headers()\n                                .get(Http::LowerCaseString(\"x-envoy-client-sni\"))[0]\n                                ->value()\n                                .getStringView());\n\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  upstream_request_->encodeHeaders(response_headers, true);\n  RELEASE_ASSERT(response->waitForEndStream(), \"unexpected timeout\");\n  codec_client_->close();\n\n  checkStats();\n  auto result = waitForAccessLog(listener_access_log_name_);\n  if (version_ == Network::Address::IpVersion::v4) {\n    EXPECT_EQ(result, \"1.2.3.4\");\n  } else {\n    EXPECT_EQ(result, \"0:1:2:3::4\");\n  }\n}",
      "cve_list": [
        "CVE-2024-23325"
      ],
      "cwe_list": [
        "CWE-755"
      ]
    },
    {
      "project": "envoy",
      "filepath": "source/extensions/filters/listener/proxy_protocol/proxy_protocol.cc",
      "func_name": "Envoy::Extensions::ListenerFilters::ProxyProtocol::Filter::parseTlvs",
      "func_body": "bool Filter::parseTlvs(const uint8_t* buf, size_t len) {\n  size_t idx{0};\n  while (idx < len) {\n    const uint8_t tlv_type = buf[idx];\n    idx++;\n\n    if ((idx + 1) >= len) {\n      ENVOY_LOG(debug,\n                fmt::format(\"failed to read proxy protocol extension. No bytes for TLV length. \"\n                            \"Extension length is {}, current index is {}, current type is {}.\",\n                            len, idx, tlv_type));\n      return false;\n    }\n\n    const uint8_t tlv_length_upper = buf[idx];\n    const uint8_t tlv_length_lower = buf[idx + 1];\n    const size_t tlv_value_length = (tlv_length_upper << 8) + tlv_length_lower;\n    idx += 2;\n\n    // Get the value.\n    if ((idx + tlv_value_length - 1) >= len) {\n      ENVOY_LOG(\n          debug,\n          fmt::format(\"failed to read proxy protocol extension. No bytes for TLV value. \"\n                      \"Extension length is {}, current index is {}, current type is {}, current \"\n                      \"value length is {}.\",\n                      len, idx, tlv_type, tlv_length_upper));\n      return false;\n    }\n\n    // Only save to dynamic metadata if this type of TLV is needed.\n    absl::string_view tlv_value(reinterpret_cast<char const*>(buf + idx), tlv_value_length);\n    auto key_value_pair = config_->isTlvTypeNeeded(tlv_type);\n    if (nullptr != key_value_pair) {\n      ProtobufWkt::Value metadata_value;\n      // Sanitize any non utf8 characters.\n      auto sanitised_tlv_value = MessageUtil::sanitizeUtf8String(tlv_value);\n      metadata_value.set_string_value(sanitised_tlv_value.data(), sanitised_tlv_value.size());\n\n      std::string metadata_key = key_value_pair->metadata_namespace().empty()\n                                     ? \"envoy.filters.listener.proxy_protocol\"\n                                     : key_value_pair->metadata_namespace();\n\n      ProtobufWkt::Struct metadata(\n          (*cb_->dynamicMetadata().mutable_filter_metadata())[metadata_key]);\n      metadata.mutable_fields()->insert({key_value_pair->key(), metadata_value});\n      cb_->setDynamicMetadata(metadata_key, metadata);\n    } else {\n      ENVOY_LOG(trace,\n                \"proxy_protocol: Skip TLV of type {} since it's not needed for dynamic metadata\",\n                tlv_type);\n    }\n\n    // Save TLVs to the filter state.\n    if (config_->isPassThroughTlvTypeNeeded(tlv_type)) {\n      ENVOY_LOG(trace, \"proxy_protocol: Storing parsed TLV of type {} to filter state.\", tlv_type);\n      parsed_tlvs_.push_back({tlv_type, {tlv_value.begin(), tlv_value.end()}});\n    }\n\n    idx += tlv_value_length;\n    ASSERT(idx <= len);\n  }\n  return true;\n}",
      "cve_list": [
        "CVE-2024-23324"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "envoy",
      "filepath": "test/extensions/filters/listener/proxy_protocol/proxy_protocol_test.cc",
      "func_name": "Envoy::Extensions::ListenerFilters::ProxyProtocol::TEST_P",
      "func_body": "TEST_P(ProxyProtocolTest, V2ExtractMultipleTlvsOfInterestAndSanitiseNonUtf8) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x39, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  // A TLV of type 0x00 with size of 4 (1 byte is value).\n  constexpr uint8_t tlv1[] = {0x00, 0x00, 0x01, 0xff};\n  // A TLV of type 0x02 with size of 10 bytes (7 bytes are value). Second and last bytes in the\n  // value are non utf8 characters.\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0xfe,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0xc1};\n  // A TLV of type 0x0f with size of 6 bytes (3 bytes are value).\n  constexpr uint8_t tlv3[] = {0x0f, 0x00, 0x03, 0xf0, 0x00, 0x0f};\n  // A TLV of type 0xea with size of 25 bytes (22 bytes are value). 7th and 21st bytes are non utf8\n  // characters.\n  constexpr uint8_t tlv_vpc_id[] = {0xea, 0x00, 0x16, 0x01, 0x76, 0x70, 0x63, 0x2d, 0x30,\n                                    0xc0, 0x35, 0x74, 0x65, 0x73, 0x74, 0x32, 0x66, 0x61,\n                                    0x36, 0x63, 0x36, 0x33, 0x68, 0xf9, 0x37};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_type_authority = proto_config.add_rules();\n  rule_type_authority->set_tlv_type(0x02);\n  rule_type_authority->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  auto rule_vpc_id = proto_config.add_rules();\n  rule_vpc_id->set_tlv_type(0xea);\n  rule_vpc_id->mutable_on_tlv_present()->set_key(\"PP2 vpc id\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(tlv3, sizeof(tlv3));\n  write(tlv_vpc_id, sizeof(tlv_vpc_id));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(2, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n  EXPECT_EQ(1, fields.count(\"PP2 vpc id\"));\n\n  const char replacement = 0x21;\n  auto value_type_authority = fields.at(\"PP2 type authority\").string_value();\n  // Non utf8 characters have been replaced with `0x21` (`!` character).\n  ASSERT_THAT(value_type_authority,\n              ElementsAre(0x66, replacement, 0x6f, 0x2e, 0x63, 0x6f, replacement));\n\n  auto value_vpc_id = fields.at(\"PP2 vpc id\").string_value();\n  ASSERT_THAT(value_vpc_id,\n              ElementsAre(0x01, 0x76, 0x70, 0x63, 0x2d, 0x30, replacement, 0x35, 0x74, 0x65, 0x73,\n                          0x74, 0x32, 0x66, 0x61, 0x36, 0x63, 0x36, 0x33, 0x68, replacement, 0x37));\n  disconnect();\n}",
      "cve_list": [
        "CVE-2024-23324"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "envoy",
      "filepath": "source/common/tls/context_impl.cc",
      "func_name": "Envoy::Extensions::TransportSockets::Tls::ClientContextImpl::newSsl",
      "func_body": "ClientContextImpl::newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) {\n  absl::StatusOr<bssl::UniquePtr<SSL>> ssl_con_or_status(ContextImpl::newSsl(options));\n  if (!ssl_con_or_status.ok()) {\n    return ssl_con_or_status;\n  }\n\n  bssl::UniquePtr<SSL> ssl_con = std::move(ssl_con_or_status.value());\n\n  const std::string server_name_indication = options && options->serverNameOverride().has_value()\n                                                 ? options->serverNameOverride().value()\n                                                 : server_name_indication_;\n  if (!server_name_indication.empty()) {\n    const int rc = SSL_set_tlsext_host_name(ssl_con.get(), server_name_indication.c_str());\n    if (rc != 1) {\n      return absl::InvalidArgumentError(\n          absl::StrCat(\"Failed to create upstream TLS due to failure setting SNI: \",\n                       Utility::getLastCryptoError().value_or(\"unknown\")));\n    }\n  }\n\n  if (options && !options->verifySubjectAltNameListOverride().empty()) {\n    SSL_set_verify(ssl_con.get(), SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, nullptr);\n  }\n\n  // We determine what ALPN using the following precedence:\n  // 1. Option-provided ALPN override.\n  // 2. ALPN statically configured in the upstream TLS context.\n  // 3. Option-provided ALPN fallback.\n\n  // At this point in the code the ALPN has already been set (if present) to the value specified in\n  // the TLS context. We've stored this value in parsed_alpn_protocols_ so we can check that to see\n  // if it's already been set.\n  bool has_alpn_defined = !parsed_alpn_protocols_.empty();\n  if (options) {\n    // ALPN override takes precedence over TLS context specified, so blindly overwrite it.\n    has_alpn_defined |= parseAndSetAlpn(options->applicationProtocolListOverride(), *ssl_con);\n  }\n\n  if (options && !has_alpn_defined && !options->applicationProtocolFallback().empty()) {\n    // If ALPN hasn't already been set (either through TLS context or override), use the fallback.\n    parseAndSetAlpn(options->applicationProtocolFallback(), *ssl_con);\n  }\n\n  if (allow_renegotiation_) {\n    SSL_set_renegotiate_mode(ssl_con.get(), ssl_renegotiate_freely);\n  }\n\n  SSL_set_enforce_rsa_key_usage(ssl_con.get(), enforce_rsa_key_usage_);\n\n  if (max_session_keys_ > 0) {\n    if (session_keys_single_use_) {\n      // Stored single-use session keys, use write/write locks.\n      absl::WriterMutexLock l(&session_keys_mu_);\n      if (!session_keys_.empty()) {\n        // Use the most recently stored session key, since it has the highest\n        // probability of still being recognized/accepted by the server.\n        SSL_SESSION* session = session_keys_.front().get();\n        SSL_set_session(ssl_con.get(), session);\n        // Remove single-use session key (TLS 1.3) after first use.\n        if (SSL_SESSION_should_be_single_use(session)) {\n          session_keys_.pop_front();\n        }\n      }\n    } else {\n      // Never stored single-use session keys, use read/write locks.\n      absl::ReaderMutexLock l(&session_keys_mu_);\n      if (!session_keys_.empty()) {\n        // Use the most recently stored session key, since it has the highest\n        // probability of still being recognized/accepted by the server.\n        SSL_SESSION* session = session_keys_.front().get();\n        SSL_set_session(ssl_con.get(), session);\n      }\n    }\n  }\n\n  return ssl_con;\n}",
      "cve_list": [
        "CVE-2024-32475"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "envoy",
      "filepath": "source/common/tls/ssl_socket.cc",
      "func_name": "Envoy::Extensions::TransportSockets::Tls::ClientSslSocketFactory::createTransportSocket",
      "func_body": "Network::TransportSocketPtr ClientSslSocketFactory::createTransportSocket(\n    Network::TransportSocketOptionsConstSharedPtr transport_socket_options,\n    Upstream::HostDescriptionConstSharedPtr) const {\n  // onAddOrUpdateSecret() could be invoked in the middle of checking the existence of ssl_ctx and\n  // creating SslSocket using ssl_ctx. Capture ssl_ctx_ into a local variable so that we check and\n  // use the same ssl_ctx to create SslSocket.\n  Envoy::Ssl::ClientContextSharedPtr ssl_ctx;\n  {\n    absl::ReaderMutexLock l(&ssl_ctx_mu_);\n    ssl_ctx = ssl_ctx_;\n  }\n  if (ssl_ctx) {\n    auto status_or_socket =\n        SslSocket::create(std::move(ssl_ctx), InitialState::Client, transport_socket_options,\n                          config_->createHandshaker());\n    if (status_or_socket.ok()) {\n      return std::move(status_or_socket.value());\n    }\n    return std::make_unique<ErrorSslSocket>(status_or_socket.status().message());\n  } else {\n    ENVOY_LOG(debug, \"Create NotReadySslSocket\");\n    stats_.upstream_context_secrets_not_ready_.inc();\n    return std::make_unique<NotReadySslSocket>();\n  }\n}",
      "cve_list": [
        "CVE-2024-32475"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "envoy",
      "filepath": "source/common/tls/ssl_socket.cc",
      "func_name": "Envoy::Extensions::TransportSockets::Tls::ErrorSslSocket::ErrorSslSocket",
      "func_body": "  ErrorSslSocket(absl::string_view error) : error_(error) {}",
      "cve_list": [
        "CVE-2024-32475"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "envoy",
      "filepath": "source/common/tls/ssl_socket.cc",
      "func_name": "Envoy::Extensions::TransportSockets::Tls::ErrorSslSocket::failureReason",
      "func_body": "  absl::string_view failureReason() const override { return error_; }",
      "cve_list": [
        "CVE-2024-32475"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "envoy",
      "filepath": "source/common/tls/ssl_socket.cc",
      "func_name": "Envoy::Extensions::TransportSockets::Tls::ServerSslSocketFactory::createDownstreamTransportSocket",
      "func_body": "Network::TransportSocketPtr ServerSslSocketFactory::createDownstreamTransportSocket() const {\n  // onAddOrUpdateSecret() could be invoked in the middle of checking the existence of ssl_ctx and\n  // creating SslSocket using ssl_ctx. Capture ssl_ctx_ into a local variable so that we check and\n  // use the same ssl_ctx to create SslSocket.\n  Envoy::Ssl::ServerContextSharedPtr ssl_ctx;\n  {\n    absl::ReaderMutexLock l(&ssl_ctx_mu_);\n    ssl_ctx = ssl_ctx_;\n  }\n  if (ssl_ctx) {\n    auto status_or_socket = SslSocket::create(std::move(ssl_ctx), InitialState::Server, nullptr,\n                                              config_->createHandshaker());\n    if (status_or_socket.ok()) {\n      return std::move(status_or_socket.value());\n    }\n    return std::make_unique<ErrorSslSocket>(status_or_socket.status().message());\n  } else {\n    ENVOY_LOG(debug, \"Create NotReadySslSocket\");\n    stats_.downstream_context_secrets_not_ready_.inc();\n    return std::make_unique<NotReadySslSocket>();\n  }\n}",
      "cve_list": [
        "CVE-2024-32475"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "envoy",
      "filepath": "source/common/tls/ssl_socket.cc",
      "func_name": "Envoy::Extensions::TransportSockets::Tls::SslSocket::SslSocket",
      "func_body": "SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx,\n                     const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options)\n    : transport_socket_options_(transport_socket_options),\n      ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)) {}",
      "cve_list": [
        "CVE-2024-32475"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "envoy",
      "filepath": "source/common/tls/ssl_socket.cc",
      "func_name": "Envoy::Extensions::TransportSockets::Tls::SslSocket::create",
      "func_body": "SslSocket::create(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,\n                  const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,\n                  Ssl::HandshakerFactoryCb handshaker_factory_cb) {\n  std::unique_ptr<SslSocket> socket(new SslSocket(ctx, transport_socket_options));\n  auto status = socket->initialize(state, handshaker_factory_cb);\n  if (status.ok()) {\n    return socket;\n  } else {\n    return status;\n  }\n}",
      "cve_list": [
        "CVE-2024-32475"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "envoy",
      "filepath": "source/common/tls/ssl_socket.cc",
      "func_name": "Envoy::Extensions::TransportSockets::Tls::SslSocket::initialize",
      "func_body": "absl::Status SslSocket::initialize(InitialState state,\n                                   Ssl::HandshakerFactoryCb handshaker_factory_cb) {\n  auto status_or_ssl = ctx_->newSsl(transport_socket_options_);\n  if (!status_or_ssl.ok()) {\n    return status_or_ssl.status();\n  }\n\n  info_ = std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(\n      std::move(status_or_ssl.value()), ctx_->sslExtendedSocketInfoIndex(), this));\n\n  if (state == InitialState::Client) {\n    SSL_set_connect_state(rawSsl());\n  } else {\n    ASSERT(state == InitialState::Server);\n    SSL_set_accept_state(rawSsl());\n  }\n\n  return absl::OkStatus();\n}",
      "cve_list": [
        "CVE-2024-32475"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "envoy",
      "filepath": "test/extensions/filters/http/dynamic_forward_proxy/proxy_filter_integration_test.cc",
      "func_name": "Envoy::TEST_P",
      "func_body": "TEST_P(ProxyFilterIntegrationTest, UpstreamTlsWithTooLongSni) {\n  upstream_tls_ = true;\n  initializeWithArgs(1024, 1024, \"x-host\");\n  std::string too_long_sni(300, 'a');\n  ASSERT_EQ(too_long_sni.size(), 300); // Validate that the expected constructor was run.\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  const Http::TestRequestHeaderMapImpl request_headers{{\":method\", \"POST\"},\n                                                       {\":path\", \"/test/long/url\"},\n                                                       {\":scheme\", \"http\"},\n                                                       {\":authority\", \"localhost\"},\n                                                       {\"x-host\", too_long_sni}};\n\n  auto response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  ASSERT_TRUE(response->waitForEndStream());\n  EXPECT_EQ(\"503\", response->headers().getStatusValue());\n  // TODO(ggreenway): validate (in access logs probably) that failure reason is set appropriately.\n}",
      "cve_list": [
        "CVE-2024-32475"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "nghttp2",
      "filepath": "lib/nghttp2_helper.c",
      "func_name": "nghttp2_strerror",
      "func_body": "const char *nghttp2_strerror(int error_code) {\n  switch (error_code) {\n  case 0:\n    return \"Success\";\n  case NGHTTP2_ERR_INVALID_ARGUMENT:\n    return \"Invalid argument\";\n  case NGHTTP2_ERR_BUFFER_ERROR:\n    return \"Out of buffer space\";\n  case NGHTTP2_ERR_UNSUPPORTED_VERSION:\n    return \"Unsupported SPDY version\";\n  case NGHTTP2_ERR_WOULDBLOCK:\n    return \"Operation would block\";\n  case NGHTTP2_ERR_PROTO:\n    return \"Protocol error\";\n  case NGHTTP2_ERR_INVALID_FRAME:\n    return \"Invalid frame octets\";\n  case NGHTTP2_ERR_EOF:\n    return \"EOF\";\n  case NGHTTP2_ERR_DEFERRED:\n    return \"Data transfer deferred\";\n  case NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE:\n    return \"No more Stream ID available\";\n  case NGHTTP2_ERR_STREAM_CLOSED:\n    return \"Stream was already closed or invalid\";\n  case NGHTTP2_ERR_STREAM_CLOSING:\n    return \"Stream is closing\";\n  case NGHTTP2_ERR_STREAM_SHUT_WR:\n    return \"The transmission is not allowed for this stream\";\n  case NGHTTP2_ERR_INVALID_STREAM_ID:\n    return \"Stream ID is invalid\";\n  case NGHTTP2_ERR_INVALID_STREAM_STATE:\n    return \"Invalid stream state\";\n  case NGHTTP2_ERR_DEFERRED_DATA_EXIST:\n    return \"Another DATA frame has already been deferred\";\n  case NGHTTP2_ERR_START_STREAM_NOT_ALLOWED:\n    return \"request HEADERS is not allowed\";\n  case NGHTTP2_ERR_GOAWAY_ALREADY_SENT:\n    return \"GOAWAY has already been sent\";\n  case NGHTTP2_ERR_INVALID_HEADER_BLOCK:\n    return \"Invalid header block\";\n  case NGHTTP2_ERR_INVALID_STATE:\n    return \"Invalid state\";\n  case NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE:\n    return \"The user callback function failed due to the temporal error\";\n  case NGHTTP2_ERR_FRAME_SIZE_ERROR:\n    return \"The length of the frame is invalid\";\n  case NGHTTP2_ERR_HEADER_COMP:\n    return \"Header compression/decompression error\";\n  case NGHTTP2_ERR_FLOW_CONTROL:\n    return \"Flow control error\";\n  case NGHTTP2_ERR_INSUFF_BUFSIZE:\n    return \"Insufficient buffer size given to function\";\n  case NGHTTP2_ERR_PAUSE:\n    return \"Callback was paused by the application\";\n  case NGHTTP2_ERR_TOO_MANY_INFLIGHT_SETTINGS:\n    return \"Too many inflight SETTINGS\";\n  case NGHTTP2_ERR_PUSH_DISABLED:\n    return \"Server push is disabled by peer\";\n  case NGHTTP2_ERR_DATA_EXIST:\n    return \"DATA or HEADERS frame has already been submitted for the stream\";\n  case NGHTTP2_ERR_SESSION_CLOSING:\n    return \"The current session is closing\";\n  case NGHTTP2_ERR_HTTP_HEADER:\n    return \"Invalid HTTP header field was received\";\n  case NGHTTP2_ERR_HTTP_MESSAGING:\n    return \"Violation in HTTP messaging rule\";\n  case NGHTTP2_ERR_REFUSED_STREAM:\n    return \"Stream was refused\";\n  case NGHTTP2_ERR_INTERNAL:\n    return \"Internal error\";\n  case NGHTTP2_ERR_CANCEL:\n    return \"Cancel\";\n  case NGHTTP2_ERR_SETTINGS_EXPECTED:\n    return \"When a local endpoint expects to receive SETTINGS frame, it \"\n           \"receives an other type of frame\";\n  case NGHTTP2_ERR_NOMEM:\n    return \"Out of memory\";\n  case NGHTTP2_ERR_CALLBACK_FAILURE:\n    return \"The user callback function failed\";\n  case NGHTTP2_ERR_BAD_CLIENT_MAGIC:\n    return \"Received bad client magic byte string\";\n  case NGHTTP2_ERR_FLOODED:\n    return \"Flooding was detected in this HTTP/2 session, and it must be \"\n           \"closed\";\n  case NGHTTP2_ERR_TOO_MANY_SETTINGS:\n    return \"SETTINGS frame contained more than the maximum allowed entries\";\n  case NGHTTP2_ERR_TOO_MANY_CONTINUATIONS:\n    return \"Too many CONTINUATION frames following a HEADER frame\";\n  default:\n    return \"Unknown error code\";\n  }\n}",
      "cve_list": [
        "CVE-2024-28182"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "nghttp2",
      "filepath": "lib/nghttp2_session.c",
      "func_name": "nghttp2_session_mem_recv2",
      "func_body": "nghttp2_ssize nghttp2_session_mem_recv2(nghttp2_session *session,\n                                        const uint8_t *in, size_t inlen) {\n  const uint8_t *first, *last;\n  nghttp2_inbound_frame *iframe = &session->iframe;\n  size_t readlen;\n  nghttp2_ssize padlen;\n  int rv;\n  int busy = 0;\n  nghttp2_frame_hd cont_hd;\n  nghttp2_stream *stream;\n  size_t pri_fieldlen;\n  nghttp2_mem *mem;\n\n  if (in == NULL) {\n    assert(inlen == 0);\n    in = static_in;\n  }\n\n  first = in;\n  last = in + inlen;\n\n  DEBUGF(\"recv: connection recv_window_size=%d, local_window=%d\\n\",\n         session->recv_window_size, session->local_window_size);\n\n  mem = &session->mem;\n\n  /* We may have idle streams more than we expect (e.g.,\n     nghttp2_session_change_stream_priority() or\n     nghttp2_session_create_idle_stream()).  Adjust them here. */\n  rv = nghttp2_session_adjust_idle_stream(session);\n  if (nghttp2_is_fatal(rv)) {\n    return rv;\n  }\n\n  if (!nghttp2_session_want_read(session)) {\n    return (nghttp2_ssize)inlen;\n  }\n\n  for (;;) {\n    switch (iframe->state) {\n    case NGHTTP2_IB_READ_CLIENT_MAGIC:\n      readlen = nghttp2_min(inlen, iframe->payloadleft);\n\n      if (memcmp(&NGHTTP2_CLIENT_MAGIC[NGHTTP2_CLIENT_MAGIC_LEN -\n                                       iframe->payloadleft],\n                 in, readlen) != 0) {\n        return NGHTTP2_ERR_BAD_CLIENT_MAGIC;\n      }\n\n      iframe->payloadleft -= readlen;\n      in += readlen;\n\n      if (iframe->payloadleft == 0) {\n        session_inbound_frame_reset(session);\n        iframe->state = NGHTTP2_IB_READ_FIRST_SETTINGS;\n      }\n\n      break;\n    case NGHTTP2_IB_READ_FIRST_SETTINGS:\n      DEBUGF(\"recv: [IB_READ_FIRST_SETTINGS]\\n\");\n\n      readlen = inbound_frame_buf_read(iframe, in, last);\n      in += readlen;\n\n      if (nghttp2_buf_mark_avail(&iframe->sbuf)) {\n        return (nghttp2_ssize)(in - first);\n      }\n\n      if (iframe->sbuf.pos[3] != NGHTTP2_SETTINGS ||\n          (iframe->sbuf.pos[4] & NGHTTP2_FLAG_ACK)) {\n        rv = session_call_error_callback(\n            session, NGHTTP2_ERR_SETTINGS_EXPECTED,\n            \"Remote peer returned unexpected data while we expected \"\n            \"SETTINGS frame.  Perhaps, peer does not support HTTP/2 \"\n            \"properly.\");\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        rv = nghttp2_session_terminate_session_with_reason(\n            session, NGHTTP2_PROTOCOL_ERROR, \"SETTINGS expected\");\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        return (nghttp2_ssize)inlen;\n      }\n\n      iframe->state = NGHTTP2_IB_READ_HEAD;\n\n    /* Fall through */\n    case NGHTTP2_IB_READ_HEAD: {\n      int on_begin_frame_called = 0;\n\n      DEBUGF(\"recv: [IB_READ_HEAD]\\n\");\n\n      readlen = inbound_frame_buf_read(iframe, in, last);\n      in += readlen;\n\n      if (nghttp2_buf_mark_avail(&iframe->sbuf)) {\n        return (nghttp2_ssize)(in - first);\n      }\n\n      nghttp2_frame_unpack_frame_hd(&iframe->frame.hd, iframe->sbuf.pos);\n      iframe->payloadleft = iframe->frame.hd.length;\n\n      DEBUGF(\"recv: payloadlen=%zu, type=%u, flags=0x%02x, stream_id=%d\\n\",\n             iframe->frame.hd.length, iframe->frame.hd.type,\n             iframe->frame.hd.flags, iframe->frame.hd.stream_id);\n\n      if (iframe->frame.hd.length > session->local_settings.max_frame_size) {\n        DEBUGF(\"recv: length is too large %zu > %u\\n\", iframe->frame.hd.length,\n               session->local_settings.max_frame_size);\n\n        rv = nghttp2_session_terminate_session_with_reason(\n            session, NGHTTP2_FRAME_SIZE_ERROR, \"too large frame size\");\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        return (nghttp2_ssize)inlen;\n      }\n\n      switch (iframe->frame.hd.type) {\n      case NGHTTP2_DATA: {\n        DEBUGF(\"recv: DATA\\n\");\n\n        iframe->frame.hd.flags &=\n            (NGHTTP2_FLAG_END_STREAM | NGHTTP2_FLAG_PADDED);\n        /* Check stream is open. If it is not open or closing,\n           ignore payload. */\n        busy = 1;\n\n        rv = session_on_data_received_fail_fast(session);\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (nghttp2_ssize)inlen;\n        }\n        if (rv == NGHTTP2_ERR_IGN_PAYLOAD) {\n          DEBUGF(\"recv: DATA not allowed stream_id=%d\\n\",\n                 iframe->frame.hd.stream_id);\n          iframe->state = NGHTTP2_IB_IGN_DATA;\n          break;\n        }\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        rv = inbound_frame_handle_pad(iframe, &iframe->frame.hd);\n        if (rv < 0) {\n          rv = nghttp2_session_terminate_session_with_reason(\n              session, NGHTTP2_PROTOCOL_ERROR,\n              \"DATA: insufficient padding space\");\n\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n          return (nghttp2_ssize)inlen;\n        }\n\n        if (rv == 1) {\n          iframe->state = NGHTTP2_IB_READ_PAD_DATA;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_DATA;\n        break;\n      }\n      case NGHTTP2_HEADERS:\n\n        DEBUGF(\"recv: HEADERS\\n\");\n\n        iframe->frame.hd.flags &=\n            (NGHTTP2_FLAG_END_STREAM | NGHTTP2_FLAG_END_HEADERS |\n             NGHTTP2_FLAG_PADDED | NGHTTP2_FLAG_PRIORITY);\n\n        rv = inbound_frame_handle_pad(iframe, &iframe->frame.hd);\n        if (rv < 0) {\n          rv = nghttp2_session_terminate_session_with_reason(\n              session, NGHTTP2_PROTOCOL_ERROR,\n              \"HEADERS: insufficient padding space\");\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n          return (nghttp2_ssize)inlen;\n        }\n\n        if (rv == 1) {\n          iframe->state = NGHTTP2_IB_READ_NBYTE;\n          break;\n        }\n\n        pri_fieldlen = nghttp2_frame_priority_len(iframe->frame.hd.flags);\n\n        if (pri_fieldlen > 0) {\n          if (iframe->payloadleft < pri_fieldlen) {\n            busy = 1;\n            iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n            break;\n          }\n\n          iframe->state = NGHTTP2_IB_READ_NBYTE;\n\n          inbound_frame_set_mark(iframe, pri_fieldlen);\n\n          break;\n        }\n\n        /* Call on_begin_frame_callback here because\n           session_process_headers_frame() may call\n           on_begin_headers_callback */\n        rv = session_call_on_begin_frame(session, &iframe->frame.hd);\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        on_begin_frame_called = 1;\n\n        rv = session_process_headers_frame(session);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        busy = 1;\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (nghttp2_ssize)inlen;\n        }\n\n        if (rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n          rv = nghttp2_session_add_rst_stream(\n              session, iframe->frame.hd.stream_id, NGHTTP2_INTERNAL_ERROR);\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n          iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n          break;\n        }\n\n        if (rv == NGHTTP2_ERR_IGN_HEADER_BLOCK) {\n          iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_HEADER_BLOCK;\n\n        break;\n      case NGHTTP2_PRIORITY:\n        DEBUGF(\"recv: PRIORITY\\n\");\n\n        iframe->frame.hd.flags = NGHTTP2_FLAG_NONE;\n\n        if (iframe->payloadleft != NGHTTP2_PRIORITY_SPECLEN) {\n          busy = 1;\n\n          iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_NBYTE;\n\n        inbound_frame_set_mark(iframe, NGHTTP2_PRIORITY_SPECLEN);\n\n        break;\n      case NGHTTP2_RST_STREAM:\n      case NGHTTP2_WINDOW_UPDATE:\n#ifdef DEBUGBUILD\n        switch (iframe->frame.hd.type) {\n        case NGHTTP2_RST_STREAM:\n          DEBUGF(\"recv: RST_STREAM\\n\");\n          break;\n        case NGHTTP2_WINDOW_UPDATE:\n          DEBUGF(\"recv: WINDOW_UPDATE\\n\");\n          break;\n        }\n#endif /* DEBUGBUILD */\n\n        iframe->frame.hd.flags = NGHTTP2_FLAG_NONE;\n\n        if (iframe->payloadleft != 4) {\n          busy = 1;\n          iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_NBYTE;\n\n        inbound_frame_set_mark(iframe, 4);\n\n        break;\n      case NGHTTP2_SETTINGS:\n        DEBUGF(\"recv: SETTINGS\\n\");\n\n        iframe->frame.hd.flags &= NGHTTP2_FLAG_ACK;\n\n        if ((iframe->frame.hd.length % NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH) ||\n            ((iframe->frame.hd.flags & NGHTTP2_FLAG_ACK) &&\n             iframe->payloadleft > 0)) {\n          busy = 1;\n          iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n          break;\n        }\n\n        /* Check the settings flood counter early to be safe */\n        if (session->obq_flood_counter_ >= session->max_outbound_ack &&\n            !(iframe->frame.hd.flags & NGHTTP2_FLAG_ACK)) {\n          return NGHTTP2_ERR_FLOODED;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_SETTINGS;\n\n        if (iframe->payloadleft) {\n          nghttp2_settings_entry *min_header_table_size_entry;\n\n          /* We allocate iv with additional one entry, to store the\n             minimum header table size. */\n          iframe->max_niv =\n              iframe->frame.hd.length / NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH + 1;\n\n          if (iframe->max_niv - 1 > session->max_settings) {\n            rv = nghttp2_session_terminate_session_with_reason(\n                session, NGHTTP2_ENHANCE_YOUR_CALM,\n                \"SETTINGS: too many setting entries\");\n            if (nghttp2_is_fatal(rv)) {\n              return rv;\n            }\n            return (nghttp2_ssize)inlen;\n          }\n\n          iframe->iv = nghttp2_mem_malloc(mem, sizeof(nghttp2_settings_entry) *\n                                                   iframe->max_niv);\n\n          if (!iframe->iv) {\n            return NGHTTP2_ERR_NOMEM;\n          }\n\n          min_header_table_size_entry = &iframe->iv[iframe->max_niv - 1];\n          min_header_table_size_entry->settings_id =\n              NGHTTP2_SETTINGS_HEADER_TABLE_SIZE;\n          min_header_table_size_entry->value = UINT32_MAX;\n\n          inbound_frame_set_mark(iframe, NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH);\n          break;\n        }\n\n        busy = 1;\n\n        inbound_frame_set_mark(iframe, 0);\n\n        break;\n      case NGHTTP2_PUSH_PROMISE:\n        DEBUGF(\"recv: PUSH_PROMISE\\n\");\n\n        iframe->frame.hd.flags &=\n            (NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PADDED);\n\n        rv = inbound_frame_handle_pad(iframe, &iframe->frame.hd);\n        if (rv < 0) {\n          rv = nghttp2_session_terminate_session_with_reason(\n              session, NGHTTP2_PROTOCOL_ERROR,\n              \"PUSH_PROMISE: insufficient padding space\");\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n          return (nghttp2_ssize)inlen;\n        }\n\n        if (rv == 1) {\n          iframe->state = NGHTTP2_IB_READ_NBYTE;\n          break;\n        }\n\n        if (iframe->payloadleft < 4) {\n          busy = 1;\n          iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_NBYTE;\n\n        inbound_frame_set_mark(iframe, 4);\n\n        break;\n      case NGHTTP2_PING:\n        DEBUGF(\"recv: PING\\n\");\n\n        iframe->frame.hd.flags &= NGHTTP2_FLAG_ACK;\n\n        if (iframe->payloadleft != 8) {\n          busy = 1;\n          iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_NBYTE;\n        inbound_frame_set_mark(iframe, 8);\n\n        break;\n      case NGHTTP2_GOAWAY:\n        DEBUGF(\"recv: GOAWAY\\n\");\n\n        iframe->frame.hd.flags = NGHTTP2_FLAG_NONE;\n\n        if (iframe->payloadleft < 8) {\n          busy = 1;\n          iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_NBYTE;\n        inbound_frame_set_mark(iframe, 8);\n\n        break;\n      case NGHTTP2_CONTINUATION:\n        DEBUGF(\"recv: unexpected CONTINUATION\\n\");\n\n        /* Receiving CONTINUATION in this state are subject to\n           connection error of type PROTOCOL_ERROR */\n        rv = nghttp2_session_terminate_session_with_reason(\n            session, NGHTTP2_PROTOCOL_ERROR, \"CONTINUATION: unexpected\");\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        return (nghttp2_ssize)inlen;\n      default:\n        DEBUGF(\"recv: extension frame\\n\");\n\n        if (check_ext_type_set(session->user_recv_ext_types,\n                               iframe->frame.hd.type)) {\n          if (!session->callbacks.unpack_extension_callback) {\n            /* Silently ignore unknown frame type. */\n\n            busy = 1;\n\n            iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n\n            break;\n          }\n\n          busy = 1;\n\n          iframe->state = NGHTTP2_IB_READ_EXTENSION_PAYLOAD;\n\n          break;\n        } else {\n          switch (iframe->frame.hd.type) {\n          case NGHTTP2_ALTSVC:\n            if ((session->builtin_recv_ext_types & NGHTTP2_TYPEMASK_ALTSVC) ==\n                0) {\n              busy = 1;\n              iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n              break;\n            }\n\n            DEBUGF(\"recv: ALTSVC\\n\");\n\n            iframe->frame.hd.flags = NGHTTP2_FLAG_NONE;\n            iframe->frame.ext.payload = &iframe->ext_frame_payload.altsvc;\n\n            if (session->server) {\n              busy = 1;\n              iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n              break;\n            }\n\n            if (iframe->payloadleft < 2) {\n              busy = 1;\n              iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n              break;\n            }\n\n            busy = 1;\n\n            iframe->state = NGHTTP2_IB_READ_NBYTE;\n            inbound_frame_set_mark(iframe, 2);\n\n            break;\n          case NGHTTP2_ORIGIN:\n            if (!(session->builtin_recv_ext_types & NGHTTP2_TYPEMASK_ORIGIN)) {\n              busy = 1;\n              iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n              break;\n            }\n\n            DEBUGF(\"recv: ORIGIN\\n\");\n\n            iframe->frame.ext.payload = &iframe->ext_frame_payload.origin;\n\n            if (session->server || iframe->frame.hd.stream_id ||\n                (iframe->frame.hd.flags & 0xf0)) {\n              busy = 1;\n              iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n              break;\n            }\n\n            iframe->frame.hd.flags = NGHTTP2_FLAG_NONE;\n\n            if (iframe->payloadleft) {\n              iframe->raw_lbuf = nghttp2_mem_malloc(mem, iframe->payloadleft);\n\n              if (iframe->raw_lbuf == NULL) {\n                return NGHTTP2_ERR_NOMEM;\n              }\n\n              nghttp2_buf_wrap_init(&iframe->lbuf, iframe->raw_lbuf,\n                                    iframe->payloadleft);\n            } else {\n              busy = 1;\n            }\n\n            iframe->state = NGHTTP2_IB_READ_ORIGIN_PAYLOAD;\n\n            break;\n          case NGHTTP2_PRIORITY_UPDATE:\n            if ((session->builtin_recv_ext_types &\n                 NGHTTP2_TYPEMASK_PRIORITY_UPDATE) == 0) {\n              busy = 1;\n              iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n              break;\n            }\n\n            DEBUGF(\"recv: PRIORITY_UPDATE\\n\");\n\n            iframe->frame.hd.flags = NGHTTP2_FLAG_NONE;\n            iframe->frame.ext.payload =\n                &iframe->ext_frame_payload.priority_update;\n\n            if (!session->server) {\n              rv = nghttp2_session_terminate_session_with_reason(\n                  session, NGHTTP2_PROTOCOL_ERROR,\n                  \"PRIORITY_UPDATE is received from server\");\n              if (nghttp2_is_fatal(rv)) {\n                return rv;\n              }\n              return (nghttp2_ssize)inlen;\n            }\n\n            if (iframe->payloadleft < 4) {\n              busy = 1;\n              iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n              break;\n            }\n\n            if (!session_no_rfc7540_pri_no_fallback(session) ||\n                iframe->payloadleft > sizeof(iframe->raw_sbuf)) {\n              busy = 1;\n              iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n              break;\n            }\n\n            busy = 1;\n\n            iframe->state = NGHTTP2_IB_READ_NBYTE;\n            inbound_frame_set_mark(iframe, iframe->payloadleft);\n\n            break;\n          default:\n            busy = 1;\n\n            iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n\n            break;\n          }\n        }\n      }\n\n      if (!on_begin_frame_called) {\n        switch (iframe->state) {\n        case NGHTTP2_IB_IGN_HEADER_BLOCK:\n        case NGHTTP2_IB_IGN_PAYLOAD:\n        case NGHTTP2_IB_FRAME_SIZE_ERROR:\n        case NGHTTP2_IB_IGN_DATA:\n        case NGHTTP2_IB_IGN_ALL:\n          break;\n        default:\n          rv = session_call_on_begin_frame(session, &iframe->frame.hd);\n\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n        }\n      }\n\n      break;\n    }\n    case NGHTTP2_IB_READ_NBYTE:\n      DEBUGF(\"recv: [IB_READ_NBYTE]\\n\");\n\n      readlen = inbound_frame_buf_read(iframe, in, last);\n      in += readlen;\n      iframe->payloadleft -= readlen;\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu, left=%zu\\n\", readlen,\n             iframe->payloadleft, nghttp2_buf_mark_avail(&iframe->sbuf));\n\n      if (nghttp2_buf_mark_avail(&iframe->sbuf)) {\n        return (nghttp2_ssize)(in - first);\n      }\n\n      switch (iframe->frame.hd.type) {\n      case NGHTTP2_HEADERS:\n        if (iframe->padlen == 0 &&\n            (iframe->frame.hd.flags & NGHTTP2_FLAG_PADDED)) {\n          pri_fieldlen = nghttp2_frame_priority_len(iframe->frame.hd.flags);\n          padlen = inbound_frame_compute_pad(iframe);\n          if (padlen < 0 ||\n              (size_t)padlen + pri_fieldlen > 1 + iframe->payloadleft) {\n            rv = nghttp2_session_terminate_session_with_reason(\n                session, NGHTTP2_PROTOCOL_ERROR, \"HEADERS: invalid padding\");\n            if (nghttp2_is_fatal(rv)) {\n              return rv;\n            }\n            return (nghttp2_ssize)inlen;\n          }\n          iframe->frame.headers.padlen = (size_t)padlen;\n\n          if (pri_fieldlen > 0) {\n            if (iframe->payloadleft < pri_fieldlen) {\n              busy = 1;\n              iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n              break;\n            }\n            iframe->state = NGHTTP2_IB_READ_NBYTE;\n            inbound_frame_set_mark(iframe, pri_fieldlen);\n            break;\n          } else {\n            /* Truncate buffers used for padding spec */\n            inbound_frame_set_mark(iframe, 0);\n          }\n        }\n\n        rv = session_process_headers_frame(session);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        busy = 1;\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (nghttp2_ssize)inlen;\n        }\n\n        if (rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n          rv = nghttp2_session_add_rst_stream(\n              session, iframe->frame.hd.stream_id, NGHTTP2_INTERNAL_ERROR);\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n          iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n          break;\n        }\n\n        if (rv == NGHTTP2_ERR_IGN_HEADER_BLOCK) {\n          iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_HEADER_BLOCK;\n\n        break;\n      case NGHTTP2_PRIORITY:\n        if (!session_no_rfc7540_pri_no_fallback(session) &&\n            session->remote_settings.no_rfc7540_priorities != 1) {\n          rv = session_process_priority_frame(session);\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n\n          if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n            return (nghttp2_ssize)inlen;\n          }\n        }\n\n        session_inbound_frame_reset(session);\n\n        break;\n      case NGHTTP2_RST_STREAM:\n        rv = session_process_rst_stream_frame(session);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (nghttp2_ssize)inlen;\n        }\n\n        session_inbound_frame_reset(session);\n\n        break;\n      case NGHTTP2_PUSH_PROMISE:\n        if (iframe->padlen == 0 &&\n            (iframe->frame.hd.flags & NGHTTP2_FLAG_PADDED)) {\n          padlen = inbound_frame_compute_pad(iframe);\n          if (padlen < 0 || (size_t)padlen + 4 /* promised stream id */\n                                > 1 + iframe->payloadleft) {\n            rv = nghttp2_session_terminate_session_with_reason(\n                session, NGHTTP2_PROTOCOL_ERROR,\n                \"PUSH_PROMISE: invalid padding\");\n            if (nghttp2_is_fatal(rv)) {\n              return rv;\n            }\n            return (nghttp2_ssize)inlen;\n          }\n\n          iframe->frame.push_promise.padlen = (size_t)padlen;\n\n          if (iframe->payloadleft < 4) {\n            busy = 1;\n            iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n            break;\n          }\n\n          iframe->state = NGHTTP2_IB_READ_NBYTE;\n\n          inbound_frame_set_mark(iframe, 4);\n\n          break;\n        }\n\n        rv = session_process_push_promise_frame(session);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        busy = 1;\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (nghttp2_ssize)inlen;\n        }\n\n        if (rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n          rv = nghttp2_session_add_rst_stream(\n              session, iframe->frame.push_promise.promised_stream_id,\n              NGHTTP2_INTERNAL_ERROR);\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n          iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n          break;\n        }\n\n        if (rv == NGHTTP2_ERR_IGN_HEADER_BLOCK) {\n          iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n          break;\n        }\n\n        iframe->state = NGHTTP2_IB_READ_HEADER_BLOCK;\n\n        break;\n      case NGHTTP2_PING:\n        rv = session_process_ping_frame(session);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (nghttp2_ssize)inlen;\n        }\n\n        session_inbound_frame_reset(session);\n\n        break;\n      case NGHTTP2_GOAWAY: {\n        size_t debuglen;\n\n        /* 8 is Last-stream-ID + Error Code */\n        debuglen = iframe->frame.hd.length - 8;\n\n        if (debuglen > 0) {\n          iframe->raw_lbuf = nghttp2_mem_malloc(mem, debuglen);\n\n          if (iframe->raw_lbuf == NULL) {\n            return NGHTTP2_ERR_NOMEM;\n          }\n\n          nghttp2_buf_wrap_init(&iframe->lbuf, iframe->raw_lbuf, debuglen);\n        }\n\n        busy = 1;\n\n        iframe->state = NGHTTP2_IB_READ_GOAWAY_DEBUG;\n\n        break;\n      }\n      case NGHTTP2_WINDOW_UPDATE:\n        rv = session_process_window_update_frame(session);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (nghttp2_ssize)inlen;\n        }\n\n        session_inbound_frame_reset(session);\n\n        break;\n      case NGHTTP2_ALTSVC: {\n        size_t origin_len;\n\n        origin_len = nghttp2_get_uint16(iframe->sbuf.pos);\n\n        DEBUGF(\"recv: origin_len=%zu\\n\", origin_len);\n\n        if (origin_len > iframe->payloadleft) {\n          busy = 1;\n          iframe->state = NGHTTP2_IB_FRAME_SIZE_ERROR;\n          break;\n        }\n\n        if (iframe->frame.hd.length > 2) {\n          iframe->raw_lbuf =\n              nghttp2_mem_malloc(mem, iframe->frame.hd.length - 2);\n\n          if (iframe->raw_lbuf == NULL) {\n            return NGHTTP2_ERR_NOMEM;\n          }\n\n          nghttp2_buf_wrap_init(&iframe->lbuf, iframe->raw_lbuf,\n                                iframe->frame.hd.length);\n        }\n\n        busy = 1;\n\n        iframe->state = NGHTTP2_IB_READ_ALTSVC_PAYLOAD;\n\n        break;\n      case NGHTTP2_PRIORITY_UPDATE:\n        DEBUGF(\"recv: prioritized_stream_id=%d\\n\",\n               nghttp2_get_uint32(iframe->sbuf.pos) & NGHTTP2_STREAM_ID_MASK);\n\n        rv = session_process_priority_update_frame(session);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        session_inbound_frame_reset(session);\n\n        break;\n      }\n      default:\n        /* This is unknown frame */\n        session_inbound_frame_reset(session);\n\n        break;\n      }\n      break;\n    case NGHTTP2_IB_READ_HEADER_BLOCK:\n    case NGHTTP2_IB_IGN_HEADER_BLOCK: {\n      nghttp2_ssize data_readlen;\n      size_t trail_padlen;\n      int final;\n#ifdef DEBUGBUILD\n      if (iframe->state == NGHTTP2_IB_READ_HEADER_BLOCK) {\n        DEBUGF(\"recv: [IB_READ_HEADER_BLOCK]\\n\");\n      } else {\n        DEBUGF(\"recv: [IB_IGN_HEADER_BLOCK]\\n\");\n      }\n#endif /* DEBUGBUILD */\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft - readlen);\n\n      data_readlen = inbound_frame_effective_readlen(\n          iframe, iframe->payloadleft - readlen, readlen);\n\n      if (data_readlen == -1) {\n        /* everything is padding */\n        data_readlen = 0;\n      }\n\n      trail_padlen = nghttp2_frame_trail_padlen(&iframe->frame, iframe->padlen);\n\n      final = (iframe->frame.hd.flags & NGHTTP2_FLAG_END_HEADERS) &&\n              iframe->payloadleft - (size_t)data_readlen == trail_padlen;\n\n      if (data_readlen > 0 || (data_readlen == 0 && final)) {\n        size_t hd_proclen = 0;\n\n        DEBUGF(\"recv: block final=%d\\n\", final);\n\n        rv =\n            inflate_header_block(session, &iframe->frame, &hd_proclen,\n                                 (uint8_t *)in, (size_t)data_readlen, final,\n                                 iframe->state == NGHTTP2_IB_READ_HEADER_BLOCK);\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (nghttp2_ssize)inlen;\n        }\n\n        if (rv == NGHTTP2_ERR_PAUSE) {\n          in += hd_proclen;\n          iframe->payloadleft -= hd_proclen;\n\n          return (nghttp2_ssize)(in - first);\n        }\n\n        if (rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE) {\n          /* The application says no more headers. We decompress the\n             rest of the header block but not invoke on_header_callback\n             and on_frame_recv_callback. */\n          in += hd_proclen;\n          iframe->payloadleft -= hd_proclen;\n\n          /* Use promised stream ID for PUSH_PROMISE */\n          rv = nghttp2_session_add_rst_stream(\n              session,\n              iframe->frame.hd.type == NGHTTP2_PUSH_PROMISE\n                  ? iframe->frame.push_promise.promised_stream_id\n                  : iframe->frame.hd.stream_id,\n              NGHTTP2_INTERNAL_ERROR);\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n          busy = 1;\n          iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n          break;\n        }\n\n        in += readlen;\n        iframe->payloadleft -= readlen;\n\n        if (rv == NGHTTP2_ERR_HEADER_COMP) {\n          /* GOAWAY is already issued */\n          if (iframe->payloadleft == 0) {\n            session_inbound_frame_reset(session);\n          } else {\n            busy = 1;\n            iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n          }\n          break;\n        }\n      } else {\n        in += readlen;\n        iframe->payloadleft -= readlen;\n      }\n\n      if (iframe->payloadleft) {\n        break;\n      }\n\n      if ((iframe->frame.hd.flags & NGHTTP2_FLAG_END_HEADERS) == 0) {\n\n        inbound_frame_set_mark(iframe, NGHTTP2_FRAME_HDLEN);\n\n        iframe->padlen = 0;\n\n        if (iframe->state == NGHTTP2_IB_READ_HEADER_BLOCK) {\n          iframe->state = NGHTTP2_IB_EXPECT_CONTINUATION;\n        } else {\n          iframe->state = NGHTTP2_IB_IGN_CONTINUATION;\n        }\n      } else {\n        if (iframe->state == NGHTTP2_IB_READ_HEADER_BLOCK) {\n          rv = session_after_header_block_received(session);\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n        }\n        session_inbound_frame_reset(session);\n\n        session->num_continuations = 0;\n      }\n      break;\n    }\n    case NGHTTP2_IB_IGN_PAYLOAD:\n      DEBUGF(\"recv: [IB_IGN_PAYLOAD]\\n\");\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n      iframe->payloadleft -= readlen;\n      in += readlen;\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (iframe->payloadleft) {\n        break;\n      }\n\n      switch (iframe->frame.hd.type) {\n      case NGHTTP2_HEADERS:\n      case NGHTTP2_PUSH_PROMISE:\n      case NGHTTP2_CONTINUATION:\n        /* Mark inflater bad so that we won't perform further decoding */\n        session->hd_inflater.ctx.bad = 1;\n        break;\n      default:\n        break;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    case NGHTTP2_IB_FRAME_SIZE_ERROR:\n      DEBUGF(\"recv: [IB_FRAME_SIZE_ERROR]\\n\");\n\n      rv = session_handle_frame_size_error(session);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      assert(iframe->state == NGHTTP2_IB_IGN_ALL);\n\n      return (nghttp2_ssize)inlen;\n    case NGHTTP2_IB_READ_SETTINGS:\n      DEBUGF(\"recv: [IB_READ_SETTINGS]\\n\");\n\n      readlen = inbound_frame_buf_read(iframe, in, last);\n      iframe->payloadleft -= readlen;\n      in += readlen;\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (nghttp2_buf_mark_avail(&iframe->sbuf)) {\n        break;\n      }\n\n      if (readlen > 0) {\n        inbound_frame_set_settings_entry(iframe);\n      }\n      if (iframe->payloadleft) {\n        inbound_frame_set_mark(iframe, NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH);\n        break;\n      }\n\n      rv = session_process_settings_frame(session);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n        return (nghttp2_ssize)inlen;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    case NGHTTP2_IB_READ_GOAWAY_DEBUG:\n      DEBUGF(\"recv: [IB_READ_GOAWAY_DEBUG]\\n\");\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n\n      if (readlen > 0) {\n        iframe->lbuf.last = nghttp2_cpymem(iframe->lbuf.last, in, readlen);\n\n        iframe->payloadleft -= readlen;\n        in += readlen;\n      }\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (iframe->payloadleft) {\n        assert(nghttp2_buf_avail(&iframe->lbuf) > 0);\n\n        break;\n      }\n\n      rv = session_process_goaway_frame(session);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n        return (nghttp2_ssize)inlen;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    case NGHTTP2_IB_EXPECT_CONTINUATION:\n    case NGHTTP2_IB_IGN_CONTINUATION:\n#ifdef DEBUGBUILD\n      if (iframe->state == NGHTTP2_IB_EXPECT_CONTINUATION) {\n        fprintf(stderr, \"recv: [IB_EXPECT_CONTINUATION]\\n\");\n      } else {\n        fprintf(stderr, \"recv: [IB_IGN_CONTINUATION]\\n\");\n      }\n#endif /* DEBUGBUILD */\n\n      if (++session->num_continuations > session->max_continuations) {\n        return NGHTTP2_ERR_TOO_MANY_CONTINUATIONS;\n      }\n\n      readlen = inbound_frame_buf_read(iframe, in, last);\n      in += readlen;\n\n      if (nghttp2_buf_mark_avail(&iframe->sbuf)) {\n        return (nghttp2_ssize)(in - first);\n      }\n\n      nghttp2_frame_unpack_frame_hd(&cont_hd, iframe->sbuf.pos);\n      iframe->payloadleft = cont_hd.length;\n\n      DEBUGF(\"recv: payloadlen=%zu, type=%u, flags=0x%02x, stream_id=%d\\n\",\n             cont_hd.length, cont_hd.type, cont_hd.flags, cont_hd.stream_id);\n\n      if (cont_hd.type != NGHTTP2_CONTINUATION ||\n          cont_hd.stream_id != iframe->frame.hd.stream_id) {\n        DEBUGF(\"recv: expected stream_id=%d, type=%d, but got stream_id=%d, \"\n               \"type=%u\\n\",\n               iframe->frame.hd.stream_id, NGHTTP2_CONTINUATION,\n               cont_hd.stream_id, cont_hd.type);\n        rv = nghttp2_session_terminate_session_with_reason(\n            session, NGHTTP2_PROTOCOL_ERROR,\n            \"unexpected non-CONTINUATION frame or stream_id is invalid\");\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        return (nghttp2_ssize)inlen;\n      }\n\n      /* CONTINUATION won't bear NGHTTP2_PADDED flag */\n\n      iframe->frame.hd.flags =\n          (uint8_t)(iframe->frame.hd.flags |\n                    (cont_hd.flags & NGHTTP2_FLAG_END_HEADERS));\n      iframe->frame.hd.length += cont_hd.length;\n\n      busy = 1;\n\n      if (iframe->state == NGHTTP2_IB_EXPECT_CONTINUATION) {\n        iframe->state = NGHTTP2_IB_READ_HEADER_BLOCK;\n\n        rv = session_call_on_begin_frame(session, &cont_hd);\n\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n      } else {\n        iframe->state = NGHTTP2_IB_IGN_HEADER_BLOCK;\n      }\n\n      break;\n    case NGHTTP2_IB_READ_PAD_DATA:\n      DEBUGF(\"recv: [IB_READ_PAD_DATA]\\n\");\n\n      readlen = inbound_frame_buf_read(iframe, in, last);\n      in += readlen;\n      iframe->payloadleft -= readlen;\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu, left=%zu\\n\", readlen,\n             iframe->payloadleft, nghttp2_buf_mark_avail(&iframe->sbuf));\n\n      if (nghttp2_buf_mark_avail(&iframe->sbuf)) {\n        return (nghttp2_ssize)(in - first);\n      }\n\n      /* Pad Length field is subject to flow control */\n      rv = nghttp2_session_update_recv_connection_window_size(session, readlen);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n        return (nghttp2_ssize)inlen;\n      }\n\n      /* Pad Length field is consumed immediately */\n      rv =\n          nghttp2_session_consume(session, iframe->frame.hd.stream_id, readlen);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n        return (nghttp2_ssize)inlen;\n      }\n\n      stream = nghttp2_session_get_stream(session, iframe->frame.hd.stream_id);\n      if (stream) {\n        rv = nghttp2_session_update_recv_stream_window_size(\n            session, stream, readlen,\n            iframe->payloadleft ||\n                (iframe->frame.hd.flags & NGHTTP2_FLAG_END_STREAM) == 0);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n      }\n\n      busy = 1;\n\n      padlen = inbound_frame_compute_pad(iframe);\n      if (padlen < 0) {\n        rv = nghttp2_session_terminate_session_with_reason(\n            session, NGHTTP2_PROTOCOL_ERROR, \"DATA: invalid padding\");\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n        return (nghttp2_ssize)inlen;\n      }\n\n      iframe->frame.data.padlen = (size_t)padlen;\n\n      iframe->state = NGHTTP2_IB_READ_DATA;\n\n      break;\n    case NGHTTP2_IB_READ_DATA:\n      stream = nghttp2_session_get_stream(session, iframe->frame.hd.stream_id);\n\n      if (!stream) {\n        busy = 1;\n        iframe->state = NGHTTP2_IB_IGN_DATA;\n        break;\n      }\n\n      DEBUGF(\"recv: [IB_READ_DATA]\\n\");\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n      iframe->payloadleft -= readlen;\n      in += readlen;\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (readlen > 0) {\n        nghttp2_ssize data_readlen;\n\n        rv = nghttp2_session_update_recv_connection_window_size(session,\n                                                                readlen);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (nghttp2_ssize)inlen;\n        }\n\n        rv = nghttp2_session_update_recv_stream_window_size(\n            session, stream, readlen,\n            iframe->payloadleft ||\n                (iframe->frame.hd.flags & NGHTTP2_FLAG_END_STREAM) == 0);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        data_readlen = inbound_frame_effective_readlen(\n            iframe, iframe->payloadleft, readlen);\n\n        if (data_readlen == -1) {\n          /* everything is padding */\n          data_readlen = 0;\n        }\n\n        padlen = (nghttp2_ssize)readlen - data_readlen;\n\n        if (padlen > 0) {\n          /* Padding is considered as \"consumed\" immediately */\n          rv = nghttp2_session_consume(session, iframe->frame.hd.stream_id,\n                                       (size_t)padlen);\n\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n\n          if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n            return (nghttp2_ssize)inlen;\n          }\n        }\n\n        DEBUGF(\"recv: data_readlen=%td\\n\", data_readlen);\n\n        if (data_readlen > 0) {\n          if (session_enforce_http_messaging(session)) {\n            if (nghttp2_http_on_data_chunk(stream, (size_t)data_readlen) != 0) {\n              if (session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE) {\n                /* Consume all data for connection immediately here */\n                rv = session_update_connection_consumed_size(\n                    session, (size_t)data_readlen);\n\n                if (nghttp2_is_fatal(rv)) {\n                  return rv;\n                }\n\n                if (iframe->state == NGHTTP2_IB_IGN_DATA) {\n                  return (nghttp2_ssize)inlen;\n                }\n              }\n\n              rv = nghttp2_session_add_rst_stream(\n                  session, iframe->frame.hd.stream_id, NGHTTP2_PROTOCOL_ERROR);\n              if (nghttp2_is_fatal(rv)) {\n                return rv;\n              }\n              busy = 1;\n              iframe->state = NGHTTP2_IB_IGN_DATA;\n              break;\n            }\n          }\n          if (session->callbacks.on_data_chunk_recv_callback) {\n            rv = session->callbacks.on_data_chunk_recv_callback(\n                session, iframe->frame.hd.flags, iframe->frame.hd.stream_id,\n                in - readlen, (size_t)data_readlen, session->user_data);\n            if (rv == NGHTTP2_ERR_PAUSE) {\n              return (nghttp2_ssize)(in - first);\n            }\n\n            if (nghttp2_is_fatal(rv)) {\n              return NGHTTP2_ERR_CALLBACK_FAILURE;\n            }\n          }\n        }\n      }\n\n      if (iframe->payloadleft) {\n        break;\n      }\n\n      rv = session_process_data_frame(session);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    case NGHTTP2_IB_IGN_DATA:\n      DEBUGF(\"recv: [IB_IGN_DATA]\\n\");\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n      iframe->payloadleft -= readlen;\n      in += readlen;\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (readlen > 0) {\n        /* Update connection-level flow control window for ignored\n           DATA frame too */\n        rv = nghttp2_session_update_recv_connection_window_size(session,\n                                                                readlen);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n          return (nghttp2_ssize)inlen;\n        }\n\n        if (session->opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE) {\n\n          /* Ignored DATA is considered as \"consumed\" immediately. */\n          rv = session_update_connection_consumed_size(session, readlen);\n\n          if (nghttp2_is_fatal(rv)) {\n            return rv;\n          }\n\n          if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n            return (nghttp2_ssize)inlen;\n          }\n        }\n      }\n\n      if (iframe->payloadleft) {\n        break;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    case NGHTTP2_IB_IGN_ALL:\n      return (nghttp2_ssize)inlen;\n    case NGHTTP2_IB_READ_EXTENSION_PAYLOAD:\n      DEBUGF(\"recv: [IB_READ_EXTENSION_PAYLOAD]\\n\");\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n      iframe->payloadleft -= readlen;\n      in += readlen;\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (readlen > 0) {\n        rv = session_call_on_extension_chunk_recv_callback(\n            session, in - readlen, readlen);\n        if (nghttp2_is_fatal(rv)) {\n          return rv;\n        }\n\n        if (rv != 0) {\n          busy = 1;\n\n          iframe->state = NGHTTP2_IB_IGN_PAYLOAD;\n\n          break;\n        }\n      }\n\n      if (iframe->payloadleft > 0) {\n        break;\n      }\n\n      rv = session_process_extension_frame(session);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    case NGHTTP2_IB_READ_ALTSVC_PAYLOAD:\n      DEBUGF(\"recv: [IB_READ_ALTSVC_PAYLOAD]\\n\");\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n      if (readlen > 0) {\n        iframe->lbuf.last = nghttp2_cpymem(iframe->lbuf.last, in, readlen);\n\n        iframe->payloadleft -= readlen;\n        in += readlen;\n      }\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (iframe->payloadleft) {\n        assert(nghttp2_buf_avail(&iframe->lbuf) > 0);\n\n        break;\n      }\n\n      rv = session_process_altsvc_frame(session);\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    case NGHTTP2_IB_READ_ORIGIN_PAYLOAD:\n      DEBUGF(\"recv: [IB_READ_ORIGIN_PAYLOAD]\\n\");\n\n      readlen = inbound_frame_payload_readlen(iframe, in, last);\n\n      if (readlen > 0) {\n        iframe->lbuf.last = nghttp2_cpymem(iframe->lbuf.last, in, readlen);\n\n        iframe->payloadleft -= readlen;\n        in += readlen;\n      }\n\n      DEBUGF(\"recv: readlen=%zu, payloadleft=%zu\\n\", readlen,\n             iframe->payloadleft);\n\n      if (iframe->payloadleft) {\n        assert(nghttp2_buf_avail(&iframe->lbuf) > 0);\n\n        break;\n      }\n\n      rv = session_process_origin_frame(session);\n\n      if (nghttp2_is_fatal(rv)) {\n        return rv;\n      }\n\n      if (iframe->state == NGHTTP2_IB_IGN_ALL) {\n        return (nghttp2_ssize)inlen;\n      }\n\n      session_inbound_frame_reset(session);\n\n      break;\n    }\n\n    if (!busy && in == last) {\n      break;\n    }\n\n    busy = 0;\n  }\n\n  assert(in == last);\n\n  return (nghttp2_ssize)(in - first);\n}",
      "cve_list": [
        "CVE-2024-28182"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "nghttp2",
      "filepath": "lib/nghttp2_session.c",
      "func_name": "session_new",
      "func_body": "static int session_new(nghttp2_session **session_ptr,\n                       const nghttp2_session_callbacks *callbacks,\n                       void *user_data, int server,\n                       const nghttp2_option *option, nghttp2_mem *mem) {\n  int rv;\n  size_t nbuffer;\n  size_t max_deflate_dynamic_table_size =\n      NGHTTP2_HD_DEFAULT_MAX_DEFLATE_BUFFER_SIZE;\n  size_t i;\n\n  if (mem == NULL) {\n    mem = nghttp2_mem_default();\n  }\n\n  *session_ptr = nghttp2_mem_calloc(mem, 1, sizeof(nghttp2_session));\n  if (*session_ptr == NULL) {\n    rv = NGHTTP2_ERR_NOMEM;\n    goto fail_session;\n  }\n\n  (*session_ptr)->mem = *mem;\n  mem = &(*session_ptr)->mem;\n\n  /* next_stream_id is initialized in either\n     nghttp2_session_client_new2 or nghttp2_session_server_new2 */\n\n  nghttp2_stream_init(&(*session_ptr)->root, 0, NGHTTP2_STREAM_FLAG_NONE,\n                      NGHTTP2_STREAM_IDLE, NGHTTP2_DEFAULT_WEIGHT, 0, 0, NULL,\n                      mem);\n\n  (*session_ptr)->remote_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE;\n  (*session_ptr)->recv_window_size = 0;\n  (*session_ptr)->consumed_size = 0;\n  (*session_ptr)->recv_reduction = 0;\n  (*session_ptr)->local_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE;\n\n  (*session_ptr)->goaway_flags = NGHTTP2_GOAWAY_NONE;\n  (*session_ptr)->local_last_stream_id = (1u << 31) - 1;\n  (*session_ptr)->remote_last_stream_id = (1u << 31) - 1;\n\n  (*session_ptr)->pending_local_max_concurrent_stream =\n      NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS;\n  (*session_ptr)->pending_enable_push = 1;\n  (*session_ptr)->pending_no_rfc7540_priorities = UINT8_MAX;\n\n  nghttp2_ratelim_init(&(*session_ptr)->stream_reset_ratelim,\n                       NGHTTP2_DEFAULT_STREAM_RESET_BURST,\n                       NGHTTP2_DEFAULT_STREAM_RESET_RATE);\n\n  if (server) {\n    (*session_ptr)->server = 1;\n  }\n\n  init_settings(&(*session_ptr)->remote_settings);\n  init_settings(&(*session_ptr)->local_settings);\n\n  (*session_ptr)->max_incoming_reserved_streams =\n      NGHTTP2_MAX_INCOMING_RESERVED_STREAMS;\n\n  /* Limit max outgoing concurrent streams to sensible value */\n  (*session_ptr)->remote_settings.max_concurrent_streams = 100;\n\n  (*session_ptr)->max_send_header_block_length = NGHTTP2_MAX_HEADERSLEN;\n  (*session_ptr)->max_outbound_ack = NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM;\n  (*session_ptr)->max_settings = NGHTTP2_DEFAULT_MAX_SETTINGS;\n  (*session_ptr)->max_continuations = NGHTTP2_DEFAULT_MAX_CONTINUATIONS;\n\n  if (option) {\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE) &&\n        option->no_auto_window_update) {\n\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_PEER_MAX_CONCURRENT_STREAMS) {\n\n      (*session_ptr)->remote_settings.max_concurrent_streams =\n          option->peer_max_concurrent_streams;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_RESERVED_REMOTE_STREAMS) {\n\n      (*session_ptr)->max_incoming_reserved_streams =\n          option->max_reserved_remote_streams;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_RECV_CLIENT_MAGIC) &&\n        option->no_recv_client_magic) {\n\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_HTTP_MESSAGING) &&\n        option->no_http_messaging) {\n\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_HTTP_MESSAGING;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_USER_RECV_EXT_TYPES) {\n      memcpy((*session_ptr)->user_recv_ext_types, option->user_recv_ext_types,\n             sizeof((*session_ptr)->user_recv_ext_types));\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_BUILTIN_RECV_EXT_TYPES) {\n      (*session_ptr)->builtin_recv_ext_types = option->builtin_recv_ext_types;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_AUTO_PING_ACK) &&\n        option->no_auto_ping_ack) {\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_PING_ACK;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_SEND_HEADER_BLOCK_LENGTH) {\n      (*session_ptr)->max_send_header_block_length =\n          option->max_send_header_block_length;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_DEFLATE_DYNAMIC_TABLE_SIZE) {\n      max_deflate_dynamic_table_size = option->max_deflate_dynamic_table_size;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_CLOSED_STREAMS) &&\n        option->no_closed_streams) {\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_CLOSED_STREAMS;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_OUTBOUND_ACK) {\n      (*session_ptr)->max_outbound_ack = option->max_outbound_ack;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_MAX_SETTINGS) &&\n        option->max_settings) {\n      (*session_ptr)->max_settings = option->max_settings;\n    }\n\n    if ((option->opt_set_mask &\n         NGHTTP2_OPT_SERVER_FALLBACK_RFC7540_PRIORITIES) &&\n        option->server_fallback_rfc7540_priorities) {\n      (*session_ptr)->opt_flags |=\n          NGHTTP2_OPTMASK_SERVER_FALLBACK_RFC7540_PRIORITIES;\n    }\n\n    if ((option->opt_set_mask &\n         NGHTTP2_OPT_NO_RFC9113_LEADING_AND_TRAILING_WS_VALIDATION) &&\n        option->no_rfc9113_leading_and_trailing_ws_validation) {\n      (*session_ptr)->opt_flags |=\n          NGHTTP2_OPTMASK_NO_RFC9113_LEADING_AND_TRAILING_WS_VALIDATION;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_STREAM_RESET_RATE_LIMIT) {\n      nghttp2_ratelim_init(&(*session_ptr)->stream_reset_ratelim,\n                           option->stream_reset_burst,\n                           option->stream_reset_rate);\n    }\n  }\n\n  rv = nghttp2_hd_deflate_init2(&(*session_ptr)->hd_deflater,\n                                max_deflate_dynamic_table_size, mem);\n  if (rv != 0) {\n    goto fail_hd_deflater;\n  }\n  rv = nghttp2_hd_inflate_init(&(*session_ptr)->hd_inflater, mem);\n  if (rv != 0) {\n    goto fail_hd_inflater;\n  }\n\n  nbuffer = ((*session_ptr)->max_send_header_block_length +\n             NGHTTP2_FRAMEBUF_CHUNKLEN - 1) /\n            NGHTTP2_FRAMEBUF_CHUNKLEN;\n\n  if (nbuffer == 0) {\n    nbuffer = 1;\n  }\n\n  /* 1 for Pad Field. */\n  rv = nghttp2_bufs_init3(&(*session_ptr)->aob.framebufs,\n                          NGHTTP2_FRAMEBUF_CHUNKLEN, nbuffer, 1,\n                          NGHTTP2_FRAME_HDLEN + 1, mem);\n  if (rv != 0) {\n    goto fail_aob_framebuf;\n  }\n\n  nghttp2_map_init(&(*session_ptr)->streams, mem);\n\n  active_outbound_item_reset(&(*session_ptr)->aob, mem);\n\n  (*session_ptr)->callbacks = *callbacks;\n  (*session_ptr)->user_data = user_data;\n\n  session_inbound_frame_reset(*session_ptr);\n\n  if (nghttp2_enable_strict_preface) {\n    nghttp2_inbound_frame *iframe = &(*session_ptr)->iframe;\n\n    if (server && ((*session_ptr)->opt_flags &\n                   NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC) == 0) {\n      iframe->state = NGHTTP2_IB_READ_CLIENT_MAGIC;\n      iframe->payloadleft = NGHTTP2_CLIENT_MAGIC_LEN;\n    } else {\n      iframe->state = NGHTTP2_IB_READ_FIRST_SETTINGS;\n    }\n\n    if (!server) {\n      (*session_ptr)->aob.state = NGHTTP2_OB_SEND_CLIENT_MAGIC;\n      nghttp2_bufs_add(&(*session_ptr)->aob.framebufs, NGHTTP2_CLIENT_MAGIC,\n                       NGHTTP2_CLIENT_MAGIC_LEN);\n    }\n  }\n\n  for (i = 0; i < NGHTTP2_EXTPRI_URGENCY_LEVELS; ++i) {\n    nghttp2_pq_init(&(*session_ptr)->sched[i].ob_data, stream_less, mem);\n  }\n\n  return 0;\n\nfail_aob_framebuf:\n  nghttp2_hd_inflate_free(&(*session_ptr)->hd_inflater);\nfail_hd_inflater:\n  nghttp2_hd_deflate_free(&(*session_ptr)->hd_deflater);\nfail_hd_deflater:\n  nghttp2_mem_free(mem, *session_ptr);\nfail_session:\n  return rv;\n}",
      "cve_list": [
        "CVE-2024-28182"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "nghttp2",
      "filepath": "lib/nghttp2_option.c",
      "func_name": "nghttp2_option_set_max_continuations",
      "func_body": "void nghttp2_option_set_max_continuations(nghttp2_option *option, size_t val) {\n  option->opt_set_mask |= NGHTTP2_OPT_MAX_CONTINUATIONS;\n  option->max_continuations = val;\n}",
      "cve_list": [
        "CVE-2024-28182"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "nghttp2",
      "filepath": "lib/nghttp2_session.c",
      "func_name": "session_new",
      "func_body": "static int session_new(nghttp2_session **session_ptr,\n                       const nghttp2_session_callbacks *callbacks,\n                       void *user_data, int server,\n                       const nghttp2_option *option, nghttp2_mem *mem) {\n  int rv;\n  size_t nbuffer;\n  size_t max_deflate_dynamic_table_size =\n      NGHTTP2_HD_DEFAULT_MAX_DEFLATE_BUFFER_SIZE;\n  size_t i;\n\n  if (mem == NULL) {\n    mem = nghttp2_mem_default();\n  }\n\n  *session_ptr = nghttp2_mem_calloc(mem, 1, sizeof(nghttp2_session));\n  if (*session_ptr == NULL) {\n    rv = NGHTTP2_ERR_NOMEM;\n    goto fail_session;\n  }\n\n  (*session_ptr)->mem = *mem;\n  mem = &(*session_ptr)->mem;\n\n  /* next_stream_id is initialized in either\n     nghttp2_session_client_new2 or nghttp2_session_server_new2 */\n\n  nghttp2_stream_init(&(*session_ptr)->root, 0, NGHTTP2_STREAM_FLAG_NONE,\n                      NGHTTP2_STREAM_IDLE, NGHTTP2_DEFAULT_WEIGHT, 0, 0, NULL,\n                      mem);\n\n  (*session_ptr)->remote_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE;\n  (*session_ptr)->recv_window_size = 0;\n  (*session_ptr)->consumed_size = 0;\n  (*session_ptr)->recv_reduction = 0;\n  (*session_ptr)->local_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE;\n\n  (*session_ptr)->goaway_flags = NGHTTP2_GOAWAY_NONE;\n  (*session_ptr)->local_last_stream_id = (1u << 31) - 1;\n  (*session_ptr)->remote_last_stream_id = (1u << 31) - 1;\n\n  (*session_ptr)->pending_local_max_concurrent_stream =\n      NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS;\n  (*session_ptr)->pending_enable_push = 1;\n  (*session_ptr)->pending_no_rfc7540_priorities = UINT8_MAX;\n\n  nghttp2_ratelim_init(&(*session_ptr)->stream_reset_ratelim,\n                       NGHTTP2_DEFAULT_STREAM_RESET_BURST,\n                       NGHTTP2_DEFAULT_STREAM_RESET_RATE);\n\n  if (server) {\n    (*session_ptr)->server = 1;\n  }\n\n  init_settings(&(*session_ptr)->remote_settings);\n  init_settings(&(*session_ptr)->local_settings);\n\n  (*session_ptr)->max_incoming_reserved_streams =\n      NGHTTP2_MAX_INCOMING_RESERVED_STREAMS;\n\n  /* Limit max outgoing concurrent streams to sensible value */\n  (*session_ptr)->remote_settings.max_concurrent_streams = 100;\n\n  (*session_ptr)->max_send_header_block_length = NGHTTP2_MAX_HEADERSLEN;\n  (*session_ptr)->max_outbound_ack = NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM;\n  (*session_ptr)->max_settings = NGHTTP2_DEFAULT_MAX_SETTINGS;\n  (*session_ptr)->max_continuations = NGHTTP2_DEFAULT_MAX_CONTINUATIONS;\n\n  if (option) {\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE) &&\n        option->no_auto_window_update) {\n\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_PEER_MAX_CONCURRENT_STREAMS) {\n\n      (*session_ptr)->remote_settings.max_concurrent_streams =\n          option->peer_max_concurrent_streams;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_RESERVED_REMOTE_STREAMS) {\n\n      (*session_ptr)->max_incoming_reserved_streams =\n          option->max_reserved_remote_streams;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_RECV_CLIENT_MAGIC) &&\n        option->no_recv_client_magic) {\n\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_HTTP_MESSAGING) &&\n        option->no_http_messaging) {\n\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_HTTP_MESSAGING;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_USER_RECV_EXT_TYPES) {\n      memcpy((*session_ptr)->user_recv_ext_types, option->user_recv_ext_types,\n             sizeof((*session_ptr)->user_recv_ext_types));\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_BUILTIN_RECV_EXT_TYPES) {\n      (*session_ptr)->builtin_recv_ext_types = option->builtin_recv_ext_types;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_AUTO_PING_ACK) &&\n        option->no_auto_ping_ack) {\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_PING_ACK;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_SEND_HEADER_BLOCK_LENGTH) {\n      (*session_ptr)->max_send_header_block_length =\n          option->max_send_header_block_length;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_DEFLATE_DYNAMIC_TABLE_SIZE) {\n      max_deflate_dynamic_table_size = option->max_deflate_dynamic_table_size;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_CLOSED_STREAMS) &&\n        option->no_closed_streams) {\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_CLOSED_STREAMS;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_OUTBOUND_ACK) {\n      (*session_ptr)->max_outbound_ack = option->max_outbound_ack;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_MAX_SETTINGS) &&\n        option->max_settings) {\n      (*session_ptr)->max_settings = option->max_settings;\n    }\n\n    if ((option->opt_set_mask &\n         NGHTTP2_OPT_SERVER_FALLBACK_RFC7540_PRIORITIES) &&\n        option->server_fallback_rfc7540_priorities) {\n      (*session_ptr)->opt_flags |=\n          NGHTTP2_OPTMASK_SERVER_FALLBACK_RFC7540_PRIORITIES;\n    }\n\n    if ((option->opt_set_mask &\n         NGHTTP2_OPT_NO_RFC9113_LEADING_AND_TRAILING_WS_VALIDATION) &&\n        option->no_rfc9113_leading_and_trailing_ws_validation) {\n      (*session_ptr)->opt_flags |=\n          NGHTTP2_OPTMASK_NO_RFC9113_LEADING_AND_TRAILING_WS_VALIDATION;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_STREAM_RESET_RATE_LIMIT) {\n      nghttp2_ratelim_init(&(*session_ptr)->stream_reset_ratelim,\n                           option->stream_reset_burst,\n                           option->stream_reset_rate);\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_CONTINUATIONS) {\n      (*session_ptr)->max_continuations = option->max_continuations;\n    }\n  }\n\n  rv = nghttp2_hd_deflate_init2(&(*session_ptr)->hd_deflater,\n                                max_deflate_dynamic_table_size, mem);\n  if (rv != 0) {\n    goto fail_hd_deflater;\n  }\n  rv = nghttp2_hd_inflate_init(&(*session_ptr)->hd_inflater, mem);\n  if (rv != 0) {\n    goto fail_hd_inflater;\n  }\n\n  nbuffer = ((*session_ptr)->max_send_header_block_length +\n             NGHTTP2_FRAMEBUF_CHUNKLEN - 1) /\n            NGHTTP2_FRAMEBUF_CHUNKLEN;\n\n  if (nbuffer == 0) {\n    nbuffer = 1;\n  }\n\n  /* 1 for Pad Field. */\n  rv = nghttp2_bufs_init3(&(*session_ptr)->aob.framebufs,\n                          NGHTTP2_FRAMEBUF_CHUNKLEN, nbuffer, 1,\n                          NGHTTP2_FRAME_HDLEN + 1, mem);\n  if (rv != 0) {\n    goto fail_aob_framebuf;\n  }\n\n  nghttp2_map_init(&(*session_ptr)->streams, mem);\n\n  active_outbound_item_reset(&(*session_ptr)->aob, mem);\n\n  (*session_ptr)->callbacks = *callbacks;\n  (*session_ptr)->user_data = user_data;\n\n  session_inbound_frame_reset(*session_ptr);\n\n  if (nghttp2_enable_strict_preface) {\n    nghttp2_inbound_frame *iframe = &(*session_ptr)->iframe;\n\n    if (server && ((*session_ptr)->opt_flags &\n                   NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC) == 0) {\n      iframe->state = NGHTTP2_IB_READ_CLIENT_MAGIC;\n      iframe->payloadleft = NGHTTP2_CLIENT_MAGIC_LEN;\n    } else {\n      iframe->state = NGHTTP2_IB_READ_FIRST_SETTINGS;\n    }\n\n    if (!server) {\n      (*session_ptr)->aob.state = NGHTTP2_OB_SEND_CLIENT_MAGIC;\n      nghttp2_bufs_add(&(*session_ptr)->aob.framebufs, NGHTTP2_CLIENT_MAGIC,\n                       NGHTTP2_CLIENT_MAGIC_LEN);\n    }\n  }\n\n  for (i = 0; i < NGHTTP2_EXTPRI_URGENCY_LEVELS; ++i) {\n    nghttp2_pq_init(&(*session_ptr)->sched[i].ob_data, stream_less, mem);\n  }\n\n  return 0;\n\nfail_aob_framebuf:\n  nghttp2_hd_inflate_free(&(*session_ptr)->hd_inflater);\nfail_hd_inflater:\n  nghttp2_hd_deflate_free(&(*session_ptr)->hd_deflater);\nfail_hd_deflater:\n  nghttp2_mem_free(mem, *session_ptr);\nfail_session:\n  return rv;\n}",
      "cve_list": [
        "CVE-2024-28182"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "fastecdsa",
      "filepath": "src/curveMath.c",
      "func_name": "curvemath_mul",
      "func_body": "static PyObject * curvemath_mul(PyObject *self, PyObject *args) {\n    char * x, * y, * d, * p, * a, * b, * q, * gx, * gy;\n\n    if (!PyArg_ParseTuple(args, \"sssssssss\", &x, &y, &d, &p, &a, &b, &q, &gx, &gy)) {\n        return NULL;\n    }\n\n    PointZZ_p result;\n    mpz_inits(result.x, result.y, NULL);\n    mpz_t scalar;\n    mpz_init_set_str(scalar, d, 10);\n    CurveZZ_p * curve = buildCurveZZ_p(p, a, b, q, gx, gy, 10);;\n\n    PointZZ_p * point = buildPointZZ_p(x, y, 10);\n    pointZZ_pMul(&result, point, scalar, curve);\n    destroyPointZZ_p(point);\n    destroyCurveZZ_p(curve);\n\n    char * resultX = mpz_get_str(NULL, 10, result.x);\n    char * resultY = mpz_get_str(NULL, 10, result.y);\n    mpz_clears(result.x, result.y, scalar, NULL);\n\n    PyObject * ret = Py_BuildValue(\"ss\", resultX, resultY);\n    free(resultX);\n    free(resultY);\n    return ret;\n}",
      "cve_list": [
        "CVE-2024-21502"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "c-ares",
      "filepath": "src/lib/ares__read_line.c",
      "func_name": "ares__read_line",
      "func_body": "ares_status_t ares__read_line(FILE *fp, char **buf, size_t *bufsize)\n{\n  char  *newbuf;\n  size_t offset = 0;\n  size_t len;\n\n  if (*buf == NULL) {\n    *buf = ares_malloc(128);\n    if (!*buf) {\n      return ARES_ENOMEM;\n    }\n    *bufsize = 128;\n  }\n\n  for (;;) {\n    int bytestoread = (int)(*bufsize - offset);\n\n    if (!fgets(*buf + offset, bytestoread, fp)) {\n      return (offset != 0) ? 0 : (ferror(fp)) ? ARES_EFILE : ARES_EOF;\n    }\n    len = offset + ares_strlen(*buf + offset);\n\n    /* Probably means there was an embedded NULL as the first character in\n     * the line, throw away line */\n    if (len == 0) {\n      offset = 0;\n      continue;\n    }\n\n    if ((*buf)[len - 1] == '\\n') {\n      (*buf)[len - 1] = 0;\n      break;\n    }\n    offset = len;\n    if (len < *bufsize - 1) {\n      continue;\n    }\n\n    /* Allocate more space. */\n    newbuf = ares_realloc(*buf, *bufsize * 2);\n    if (!newbuf) {\n      ares_free(*buf);\n      *buf = NULL;\n      return ARES_ENOMEM;\n    }\n    *buf      = newbuf;\n    *bufsize *= 2;\n  }\n  return ARES_SUCCESS;\n}",
      "cve_list": [
        "CVE-2024-25629"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "fluent-bit",
      "filepath": "src/http_server/api/v1/trace.c",
      "func_name": "api_v1_trace",
      "func_body": "int api_v1_trace(struct flb_hs *hs)\n{\n    if (hs->config->enable_chunk_trace == FLB_TRUE) {\n        mk_vhost_handler(hs->ctx, hs->vid, \"/api/v1/traces/\", cb_traces, hs);\n        mk_vhost_handler(hs->ctx, hs->vid, \"/api/v1/trace/*\", cb_trace, hs);\n    }\n    return 0;\n}",
      "cve_list": [
        "CVE-2024-4323"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "fluent-bit",
      "filepath": "src/http_server/api/v1/trace.c",
      "func_name": "cb_trace",
      "func_body": "static void cb_trace(mk_request_t *request, void *data)\n{\n    flb_sds_t out_buf;\n    msgpack_sbuffer mp_sbuf;\n    msgpack_packer mp_pck;\n    int response = 404;\n    flb_sds_t input_name = NULL;\n\n\n    /* initialize buffers */\n    msgpack_sbuffer_init(&mp_sbuf);\n    msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);\n\n    input_name = get_input_name(request);\n    if (input_name == NULL) {\n        response = 404;\n        goto error;\n    }\n\n    if (request->method == MK_METHOD_POST || request->method == MK_METHOD_GET) {\n        response = http_enable_trace(request, data, input_name, flb_sds_len(input_name), &mp_pck);\n    }\n    else if (request->method == MK_METHOD_DELETE) {\n        response = http_disable_trace(request, data, input_name, flb_sds_len(input_name), &mp_pck);\n    }\nerror:\n    if (response == 404) {\n        msgpack_pack_map(&mp_pck, 1);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_NOTFOUND, HTTP_RESULT_NOTFOUND_LEN);\n    }\n    else if (response == 503) {\n        msgpack_pack_map(&mp_pck, 1);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_ERROR, HTTP_RESULT_ERROR_LEN);\n    }\n\n    if (input_name != NULL) {\n        flb_sds_destroy(input_name);\n    }\n\n    /* Export to JSON */\n    out_buf = flb_msgpack_raw_to_json_sds(mp_sbuf.data, mp_sbuf.size);\n    if (out_buf == NULL) {\n        mk_http_status(request, 503);\n        mk_http_done(request);\n        return;\n    }\n\n    mk_http_status(request, response);\n    mk_http_send(request, out_buf, flb_sds_len(out_buf), NULL);\n    mk_http_done(request);\n\n    msgpack_sbuffer_destroy(&mp_sbuf);\n    flb_sds_destroy(out_buf);\n}",
      "cve_list": [
        "CVE-2024-4323"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "fluent-bit",
      "filepath": "src/http_server/api/v1/trace.c",
      "func_name": "cb_traces",
      "func_body": "static void cb_traces(mk_request_t *request, void *data)\n{\n    flb_sds_t out_buf;\n    msgpack_sbuffer mp_sbuf;\n    msgpack_packer mp_pck;\n    int ret;\n    char *buf = NULL;\n    size_t buf_size;\n    int root_type = MSGPACK_OBJECT_ARRAY;\n    msgpack_unpacked result;\n    flb_sds_t error_msg = NULL;\n    int response = 200;\n    const char *input_name;\n    ssize_t input_nlen;\n    msgpack_object_array *inputs = NULL;\n    size_t off = 0;\n    int i;\n\n    /* initialize buffers */\n    msgpack_sbuffer_init(&mp_sbuf);\n    msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);\n\n    msgpack_unpacked_init(&result);\n    ret = flb_pack_json(request->data.data, request->data.len, &buf, &buf_size,\n                        &root_type, NULL);\n    if (ret == -1) {\n        goto unpack_error;\n    }\n\n    ret = msgpack_unpack_next(&result, buf, buf_size, &off);\n    if (ret != MSGPACK_UNPACK_SUCCESS) {\n        ret = -1;\n        error_msg = flb_sds_create(\"unfinished input\");\n        goto unpack_error;\n    }\n\n    if (result.data.type != MSGPACK_OBJECT_MAP) {\n        response = 503;\n        error_msg = flb_sds_create(\"input is not an object\");\n        goto unpack_error;\n    }\n\n    for (i = 0; i < result.data.via.map.size; i++) {\n        if (result.data.via.map.ptr[i].val.type != MSGPACK_OBJECT_ARRAY) {\n            continue;\n        }\n        if (result.data.via.map.ptr[i].key.type != MSGPACK_OBJECT_STR) {\n            continue;\n        }\n        if (result.data.via.map.ptr[i].key.via.str.size < STR_INPUTS_LEN) {\n            continue;\n        }\n        if (strncmp(result.data.via.map.ptr[i].key.via.str.ptr, STR_INPUTS, STR_INPUTS_LEN)) {\n            continue;\n        }\n        inputs = &result.data.via.map.ptr[i].val.via.array;\n    }\n\n    if (inputs == NULL) {\n        response = 503;\n        error_msg = flb_sds_create(\"inputs not found\");\n        goto unpack_error;\n    }\n\n    msgpack_pack_map(&mp_pck, 2);\n\n    msgpack_pack_str_with_body(&mp_pck, STR_INPUTS, STR_INPUTS_LEN);\n    msgpack_pack_map(&mp_pck, inputs->size);\n\n    for (i = 0; i < inputs->size; i++) {\n\n        if (inputs->ptr[i].type != MSGPACK_OBJECT_STR || inputs->ptr[i].via.str.ptr == NULL) {\n            response = 503;\n            error_msg = flb_sds_create(\"invalid input\");\n            msgpack_sbuffer_clear(&mp_sbuf);\n            goto unpack_error;\n        }\n    }\n\n    for (i = 0; i < inputs->size; i++) {\n\n        input_name = inputs->ptr[i].via.str.ptr;\n        input_nlen = inputs->ptr[i].via.str.size;\n\n        msgpack_pack_str_with_body(&mp_pck, input_name, input_nlen);\n\n        if (request->method == MK_METHOD_POST) {\n\n            ret = msgpack_params_enable_trace((struct flb_hs *)data, &result,\n                                              input_name, input_nlen);\n\n            if (ret != 0) {\n                msgpack_pack_map(&mp_pck, 2);\n                msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n                msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_ERROR, HTTP_RESULT_ERROR_LEN);\n                msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_RETURNCODE,\n                                           HTTP_FIELD_RETURNCODE_LEN);\n                msgpack_pack_int64(&mp_pck, ret);\n            }\n            else {\n                msgpack_pack_map(&mp_pck, 1);\n                msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n                msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n            }\n        }\n        else if (request->method == MK_METHOD_DELETE) {\n            disable_trace_input((struct flb_hs *)data, input_name, input_nlen);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n        }\n        else {\n            msgpack_pack_map(&mp_pck, 2);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_ERROR, HTTP_RESULT_ERROR_LEN);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_MESSAGE, HTTP_FIELD_MESSAGE_LEN);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_METHODNOTALLOWED,\n                                       HTTP_RESULT_METHODNOTALLOWED_LEN);\n        }\n    }\n\n    msgpack_pack_str_with_body(&mp_pck, \"result\", strlen(\"result\"));\nunpack_error:\n    if (buf != NULL) {\n        flb_free(buf);\n    }\n    msgpack_unpacked_destroy(&result);\n    if (response == 404) {\n        msgpack_pack_map(&mp_pck, 1);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_NOTFOUND, HTTP_RESULT_NOTFOUND_LEN);\n    }\n    else if (response == 503) {\n        msgpack_pack_map(&mp_pck, 2);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_MESSAGE, HTTP_FIELD_MESSAGE_LEN);\n        if (error_msg) {\n            msgpack_pack_str_with_body(&mp_pck, error_msg, flb_sds_len(error_msg));\n            flb_sds_destroy(error_msg);\n        }\n        else {\n            msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_UNKNOWNERROR,\n                                       HTTP_RESULT_UNKNOWNERROR_LEN);\n        }\n    }\n    else {\n        msgpack_pack_map(&mp_pck, 1);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n    }\n\n    /* Export to JSON */\n    out_buf = flb_msgpack_raw_to_json_sds(mp_sbuf.data, mp_sbuf.size);\n    if (out_buf == NULL) {\n        out_buf = flb_sds_create(\"serialization error\");\n    }\n    msgpack_sbuffer_destroy(&mp_sbuf);\n\n    mk_http_status(request, response);\n    mk_http_send(request,\n                 out_buf, flb_sds_len(out_buf), NULL);\n    mk_http_done(request);\n\n    flb_sds_destroy(out_buf);\n}",
      "cve_list": [
        "CVE-2024-4323"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "fluent-bit",
      "filepath": "src/http_server/api/v1/trace.c",
      "func_name": "disable_trace_input",
      "func_body": "static int disable_trace_input(struct flb_hs *hs, const char *name, size_t nlen)\n{\n    struct flb_input_instance *in;\n\n\n    in = find_input(hs, name, nlen);\n    if (in == NULL) {\n        return 404;\n    }\n\n    if (in->chunk_trace_ctxt != NULL) {\n        flb_chunk_trace_context_destroy(in);\n    }\n    return 201;\n}",
      "cve_list": [
        "CVE-2024-4323"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "fluent-bit",
      "filepath": "src/http_server/api/v1/trace.c",
      "func_name": "enable_trace_input",
      "func_body": "static int enable_trace_input(struct flb_hs *hs, const char *name, ssize_t nlen, const char *prefix,\n                              const char *output_name, struct mk_list *props)\n{\n    struct flb_input_instance *in;\n\n    in = find_input(hs, name, nlen);\n    if (in == NULL) {\n        flb_error(\"unable to find input: [%d]%.*s\", (int)nlen, (int)nlen, name);\n        return 404;\n    }\n\n    flb_chunk_trace_context_new(in, output_name, prefix, NULL, props);\n\n    if (in->chunk_trace_ctxt == NULL) {\n        flb_error(\"unable to start tracing\");\n        return 503;\n    }\n\n    return 0;\n}",
      "cve_list": [
        "CVE-2024-4323"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "fluent-bit",
      "filepath": "src/http_server/api/v1/trace.c",
      "func_name": "find_input",
      "func_body": "static struct flb_input_instance *find_input(struct flb_hs *hs, const char *name, size_t nlen)\n{\n    struct mk_list *head;\n    struct flb_input_instance *in;\n\n\n    mk_list_foreach(head, &hs->config->inputs) {\n        in = mk_list_entry(head, struct flb_input_instance, _head);\n        if (strlen(in->name) != nlen) {\n            continue;\n        }\n        if (strncmp(name, in->name, nlen) == 0) {\n            return in;\n        }\n        if (in->alias) {\n            if (strcmp(name, in->alias) == 0) {\n                return in;\n            }\n        }\n    }\n    return NULL;\n}",
      "cve_list": [
        "CVE-2024-4323"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "fluent-bit",
      "filepath": "src/http_server/api/v1/trace.c",
      "func_name": "get_input_name",
      "func_body": "static flb_sds_t get_input_name(mk_request_t *request)\n{\n    const char *base = \"/api/v1/trace/\";\n\n\n    if (request->real_path.data == NULL) {\n        return NULL;\n    }\n    if (request->real_path.len < sizeof(base)-1) {\n        return NULL;\n    }\n\n    return flb_sds_create_len(&request->real_path.data[sizeof(base)-1],\n                              request->real_path.len - sizeof(base)-1);\n}",
      "cve_list": [
        "CVE-2024-4323"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "fluent-bit",
      "filepath": "src/http_server/api/v1/trace.c",
      "func_name": "http_disable_trace",
      "func_body": "static int http_disable_trace(mk_request_t *request, void *data,\n                              const char *input_name, size_t input_nlen,\n                              msgpack_packer *mp_pck)\n{\n    struct flb_hs *hs = data;\n    int toggled_on = 503;\n\n\n    toggled_on = disable_trace_input(hs, input_name, input_nlen);\n    if (toggled_on < 300) {\n        msgpack_pack_map(mp_pck, 1);\n        msgpack_pack_str_with_body(mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n        msgpack_pack_str_with_body(mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n        return 201;\n    }\n\n    return toggled_on;\n}",
      "cve_list": [
        "CVE-2024-4323"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "fluent-bit",
      "filepath": "src/http_server/api/v1/trace.c",
      "func_name": "http_enable_trace",
      "func_body": "static int http_enable_trace(mk_request_t *request, void *data,\n                             const char *input_name, ssize_t input_nlen,\n                             msgpack_packer *mp_pck)\n{\n    char *buf = NULL;\n    size_t buf_size;\n    msgpack_unpacked result;\n    int ret = -1;\n    int rc = -1;\n    int i;\n    int x;\n    size_t off = 0;\n    int root_type = MSGPACK_OBJECT_ARRAY;\n    struct flb_hs *hs = data;\n    flb_sds_t prefix = NULL;\n    flb_sds_t output_name = NULL;\n    msgpack_object *key;\n    msgpack_object *val;\n    struct mk_list *props = NULL;\n    struct flb_chunk_trace_limit limit = { 0 };\n    struct flb_input_instance *input_instance;\n\n\n    if (request->method == MK_METHOD_GET) {\n        ret = enable_trace_input(hs, input_name, input_nlen, \"trace.\", \"stdout\", NULL);\n        if (ret == 0) {\n                msgpack_pack_map(mp_pck, 1);\n                msgpack_pack_str_with_body(mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n                msgpack_pack_str_with_body(mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n                return 200;\n        }\n        else {\n            flb_error(\"unable to enable tracing for %.*s\", (int)input_nlen, input_name);\n            goto input_error;\n        }\n    }\n\n    msgpack_unpacked_init(&result);\n    rc = flb_pack_json(request->data.data, request->data.len, &buf, &buf_size,\n                       &root_type, NULL);\n    if (rc == -1) {\n        ret = 503;\n        flb_error(\"unable to parse json parameters\");\n        goto unpack_error;\n    }\n\n    rc = msgpack_unpack_next(&result, buf, buf_size, &off);\n    if (rc != MSGPACK_UNPACK_SUCCESS) {\n        ret = 503;\n        flb_error(\"unable to unpack msgpack parameters for %.*s\", (int)input_nlen, input_name);\n        goto unpack_error;\n    }\n\n    if (result.data.type == MSGPACK_OBJECT_MAP) {\n        for (i = 0; i < result.data.via.map.size; i++) {\n            key = &result.data.via.map.ptr[i].key;\n            val = &result.data.via.map.ptr[i].val;\n\n            if (key->type != MSGPACK_OBJECT_STR) {\n                ret = 503;\n                flb_error(\"non string key in parameters\");\n                goto parse_error;\n            }\n\n            if (strncmp(key->via.str.ptr, \"prefix\", key->via.str.size) == 0) {\n                if (val->type != MSGPACK_OBJECT_STR) {\n                    ret = 503;\n                    flb_error(\"prefix is not a string\");\n                    goto parse_error;\n                }\n                if (prefix != NULL) {\n                    flb_sds_destroy(prefix);\n                }\n                prefix = flb_sds_create_len(val->via.str.ptr, val->via.str.size);\n            }\n            else if (strncmp(key->via.str.ptr, \"output\", key->via.str.size) == 0) {\n                if (val->type != MSGPACK_OBJECT_STR) {\n                    ret = 503;\n                    flb_error(\"output is not a string\");\n                    goto parse_error;\n                }\n                if (output_name != NULL) {\n                    flb_sds_destroy(output_name);\n                }\n                output_name = flb_sds_create_len(val->via.str.ptr, val->via.str.size);\n            }\n            else if (strncmp(key->via.str.ptr, \"params\", key->via.str.size) == 0) {\n                if (val->type != MSGPACK_OBJECT_MAP) {\n                    ret = 503;\n                    flb_error(\"output params is not a maps\");\n                    goto parse_error;\n                }\n                props = flb_calloc(1, sizeof(struct mk_list));\n                flb_kv_init(props);\n                for (x = 0; x < val->via.map.size; x++) {\n                    if (val->via.map.ptr[x].val.type != MSGPACK_OBJECT_STR) {\n                        ret = 503;\n                        flb_error(\"output parameter key is not a string\");\n                        goto parse_error;\n                    }\n                    if (val->via.map.ptr[x].key.type != MSGPACK_OBJECT_STR) {\n                        ret = 503;\n                        flb_error(\"output parameter value is not a string\");\n                        goto parse_error;\n                    }\n                    flb_kv_item_create_len(props,\n                                            (char *)val->via.map.ptr[x].key.via.str.ptr, val->via.map.ptr[x].key.via.str.size,\n                                            (char *)val->via.map.ptr[x].val.via.str.ptr, val->via.map.ptr[x].val.via.str.size);\n                }\n            }\n            else if (strncmp(key->via.str.ptr, \"limit\", key->via.str.size) == 0) {\n                if (val->type != MSGPACK_OBJECT_MAP) {\n                    ret = 503;\n                    flb_error(\"limit must be a map of limit types\");\n                    goto parse_error;\n                }\n                if (val->via.map.size != 1) {\n                    ret = 503;\n                    flb_error(\"limit must have a single limit type\");\n                    goto parse_error;\n                }\n                if (val->via.map.ptr[0].key.type != MSGPACK_OBJECT_STR) {\n                    ret = 503;\n                    flb_error(\"limit type (key) must be a string\");\n                    goto parse_error;\n                }\n                if (val->via.map.ptr[0].val.type != MSGPACK_OBJECT_POSITIVE_INTEGER) {\n                    ret = 503;\n                    flb_error(\"limit type must be an integer\");\n                    goto parse_error;\n                }\n                if (strncmp(val->via.map.ptr[0].key.via.str.ptr, \"seconds\", val->via.map.ptr[0].key.via.str.size) == 0) {\n                    limit.type = FLB_CHUNK_TRACE_LIMIT_TIME;\n                    limit.seconds = val->via.map.ptr[0].val.via.u64;\n                }\n                else if (strncmp(val->via.map.ptr[0].key.via.str.ptr, \"count\", val->via.map.ptr[0].key.via.str.size) == 0) {\n                    limit.type = FLB_CHUNK_TRACE_LIMIT_COUNT;\n                    limit.count = val->via.map.ptr[0].val.via.u64;\n                }\n                else {\n                    ret = 503;\n                    flb_error(\"unknown limit type\");\n                    goto parse_error;\n                }\n            }\n        }\n\n        if (output_name == NULL) {\n            output_name = flb_sds_create(\"stdout\");\n        }\n\n        ret = enable_trace_input(hs, input_name, input_nlen, prefix, output_name, props);\n        if (ret != 0) {\n            flb_error(\"error when enabling tracing\");\n            goto parse_error;\n        }\n\n        if (limit.type != 0) {\n            input_instance = find_input(hs, input_name, input_nlen);\n            if (limit.type == FLB_CHUNK_TRACE_LIMIT_TIME) {\n                flb_chunk_trace_context_set_limit(input_instance->chunk_trace_ctxt, limit.type, limit.seconds);\n            }\n            else if (limit.type == FLB_CHUNK_TRACE_LIMIT_COUNT) {\n                flb_chunk_trace_context_set_limit(input_instance->chunk_trace_ctxt, limit.type, limit.count);\n            }\n        }\n    }\n\n    msgpack_pack_map(mp_pck, 1);\n    msgpack_pack_str_with_body(mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n    msgpack_pack_str_with_body(mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n\n    ret = 200;\nparse_error:\n    if (prefix) flb_sds_destroy(prefix);\n    if (output_name) flb_sds_destroy(output_name);\n    if (props != NULL) {\n        flb_kv_release(props);\n        flb_free(props);\n    }\nunpack_error:\n    msgpack_unpacked_destroy(&result);\n    if (buf != NULL) {\n        flb_free(buf);\n    }\ninput_error:\n    return ret;\n}",
      "cve_list": [
        "CVE-2024-4323"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "fluent-bit",
      "filepath": "src/http_server/api/v1/trace.c",
      "func_name": "msgpack_params_enable_trace",
      "func_body": "static int msgpack_params_enable_trace(struct flb_hs *hs, msgpack_unpacked *result,\n                                       const char *input_name, ssize_t input_nlen)\n{\n    int ret = -1;\n    int i;\n    int x;\n    flb_sds_t prefix = NULL;\n    flb_sds_t output_name = NULL;\n    int toggled_on = -1;\n    msgpack_object *key;\n    msgpack_object *val;\n    struct mk_list *props = NULL;\n    msgpack_object_kv *param;\n    msgpack_object_str *param_key;\n    msgpack_object_str *param_val;\n\n\n    if (result->data.type == MSGPACK_OBJECT_MAP) {\n        for (i = 0; i < result->data.via.map.size; i++) {\n            key = &result->data.via.map.ptr[i].key;\n            val = &result->data.via.map.ptr[i].val;\n\n            if (key->type != MSGPACK_OBJECT_STR) {\n                ret = -1;\n                goto parse_error;\n            }\n\n            if (strncmp(key->via.str.ptr, \"prefix\", key->via.str.size) == 0) {\n                if (val->type != MSGPACK_OBJECT_STR) {\n                    ret = -1;\n                    goto parse_error;\n                }\n                if (prefix != NULL) {\n                    flb_sds_destroy(prefix);\n                }\n                prefix = flb_sds_create_len(val->via.str.ptr, val->via.str.size);\n            }\n            else if (strncmp(key->via.str.ptr, \"output\", key->via.str.size) == 0) {\n                if (val->type != MSGPACK_OBJECT_STR) {\n                    ret = -1;\n                    goto parse_error;\n                }\n                if (output_name != NULL) {\n                    flb_sds_destroy(output_name);\n                }\n                output_name = flb_sds_create_len(val->via.str.ptr, val->via.str.size);\n            }\n            else if (strncmp(key->via.str.ptr, \"params\", key->via.str.size) == 0) {\n                if (val->type != MSGPACK_OBJECT_MAP) {\n                    ret = -1;\n                    goto parse_error;\n                }\n                if (props != NULL) {\n                    flb_free(props);\n                }\n                props = flb_calloc(1, sizeof(struct mk_list));\n                flb_kv_init(props);\n                for (x = 0; x < val->via.map.size; x++) {\n                    param = &val->via.map.ptr[x];\n                    if (param->val.type != MSGPACK_OBJECT_STR) {\n                        ret = -1;\n                        goto parse_error;\n                    }\n                    if (param->key.type != MSGPACK_OBJECT_STR) {\n                        ret = -1;\n                        goto parse_error;\n                    }\n                    param_key = &param->key.via.str;\n                    param_val = &param->val.via.str;\n                    flb_kv_item_create_len(props,\n                                          (char *)param_key->ptr, param_key->size,\n                                          (char *)param_val->ptr, param_val->size);\n                }\n            }\n        }\n\n        if (output_name == NULL) {\n            output_name = flb_sds_create(\"stdout\");\n        }\n\n        toggled_on = enable_trace_input(hs, input_name, input_nlen, prefix, output_name, props);\n        if (!toggled_on) {\n            ret = -1;\n            goto parse_error;\n        }\n    }\n\nparse_error:\n    if (prefix) flb_sds_destroy(prefix);\n    if (output_name) flb_sds_destroy(output_name);\n    if (props != NULL) {\n        flb_kv_release(props);\n        flb_free(props);\n    }\n    return ret;\n}",
      "cve_list": [
        "CVE-2024-4323"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "jasper",
      "filepath": "src/libjasper/jpc/jpc_dec.c",
      "func_name": "jpc_dec_process_sod",
      "func_body": "static int jpc_dec_process_sod(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tint pos;\n\n\tJAS_UNUSED(ms);\n\n\tif (!(tile = dec->curtile)) {\n\t\treturn -1;\n\t}\n\n\tif (!tile->partno) {\n\t\tif (!jpc_dec_cp_isvalid(tile->cp)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_dec_cp_prepare(tile->cp)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_dec_tileinit(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Are packet headers stored in the main header or tile-part header? */\n\tif (dec->pkthdrstreams) {\n\t\t/* Get the stream containing the packet header data for this\n\t\t  tile-part. */\n\t\tif (jpc_streamlist_numstreams(dec->pkthdrstreams) != 0 &&\n\t\t  !(tile->pkthdrstream = jpc_streamlist_remove(dec->pkthdrstreams,\n\t\t  0))) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (tile->pptstab) {\n\t\tif (!tile->pkthdrstream) {\n\t\t\tif (!(tile->pkthdrstream = jas_stream_memopen(0, 0))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tpos = jas_stream_tell(tile->pkthdrstream);\n\t\tjas_stream_seek(tile->pkthdrstream, 0, SEEK_END);\n\t\tif (jpc_pptstabwrite(tile->pkthdrstream, tile->pptstab)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjas_stream_seek(tile->pkthdrstream, pos, SEEK_SET);\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\ttile->pptstab = 0;\n\t}\n\n\tif (jas_get_debug_level() >= 10) {\n\t\tjpc_dec_dump(dec);\n\t}\n\n\tif (jpc_dec_decodepkts(dec, (tile->pkthdrstream) ? tile->pkthdrstream :\n\t  dec->in, dec->in)) {\n\t\tjas_logerrorf(\"jpc_dec_decodepkts failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Gobble any unconsumed tile data. */\n\tif (dec->curtileendoff > 0) {\n\t\tlong curoff;\n\t\tuint_fast32_t n;\n\t\tcuroff = jas_stream_getrwcount(dec->in);\n\t\tif (curoff < dec->curtileendoff) {\n\t\t\tn = dec->curtileendoff - curoff;\n\t\t\tjas_logwarnf(\"warning: ignoring trailing garbage (%lu bytes)\\n\",\n\t\t\t  (unsigned long) n);\n\n\t\t\twhile (n-- > 0) {\n\t\t\t\tif (jas_stream_getc(dec->in) == EOF) {\n\t\t\t\t\tjas_logerrorf(\"read error\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (curoff > dec->curtileendoff) {\n\t\t\tjas_logwarnf(\"warning: not enough tile data (%lu bytes)\\n\",\n\t\t\t  (unsigned long) curoff - dec->curtileendoff);\n\t\t}\n\n\t}\n\n\tif (tile->numparts > 0 && tile->partno == tile->numparts - 1) {\n\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_tilefini(dec, tile);\n\t}\n\n\tdec->curtile = 0;\n\n\t/* Increment the expected tile-part number. */\n\t++tile->partno;\n\n\t/* We should expect to encounter a SOT marker segment next. */\n\tdec->state = JPC_TPHSOT;\n\n\treturn 0;\n}",
      "cve_list": [
        "CVE-2024-31744"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "glewlwyd",
      "filepath": "src/plugin/protocol_oauth2.c",
      "func_name": "callback_oauth2_authorization",
      "func_body": "static int callback_oauth2_authorization(const struct _u_request * request, struct _u_response * response, void * user_data) {\n  const char * response_type = u_map_get(request->map_url, \"response_type\");\n  int result = U_CALLBACK_CONTINUE;\n  char * state_encoded = NULL, * state_param = NULL;\n\n  u_map_put(response->map_header, \"Cache-Control\", \"no-store\");\n  u_map_put(response->map_header, \"Pragma\", \"no-cache\");\n  u_map_put(response->map_header, \"Referrer-Policy\", \"no-referrer\");\n\n  if (u_map_get(request->map_url, \"state\") != NULL) {\n    state_encoded = ulfius_url_encode(u_map_get(request->map_url, \"state\"));\n    state_param = msprintf(\"&state=%s\", state_encoded);\n    o_free(state_encoded);\n  } else {\n    state_param = o_strdup(\"\");\n  }\n\n  if (0 == o_strcmp(\"code\", response_type)) {\n    if (is_authorization_type_enabled((struct _oauth2_config *)user_data, GLEWLWYD_AUTHORIZATION_TYPE_AUTHORIZATION_CODE) && u_map_get(request->map_url, \"redirect_uri\") != NULL) {\n      result = check_auth_type_auth_code_grant(request, response, user_data);\n    } else {\n      response->status = 403;\n    }\n  } else if (0 == o_strcmp(\"token\", response_type)) {\n    if (is_authorization_type_enabled((struct _oauth2_config *)user_data, GLEWLWYD_AUTHORIZATION_TYPE_IMPLICIT) && u_map_get(request->map_url, \"redirect_uri\") != NULL) {\n      result = check_auth_type_implicit_grant(request, response, user_data);\n    } else {\n      response->status = 403;\n    }\n  } else {\n    response->status = 403;\n  }\n  o_free(state_param);\n\n  return result;\n}",
      "cve_list": [
        "CVE-2024-25715"
      ],
      "cwe_list": [
        "CWE-601"
      ]
    },
    {
      "project": "glewlwyd",
      "filepath": "src/plugin/protocol_oauth2.c",
      "func_name": "check_auth_type_auth_code_grant",
      "func_body": "static int check_auth_type_auth_code_grant (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  struct _oauth2_config * config = (struct _oauth2_config *)user_data;\n  char * authorization_code = NULL, * redirect_url, * issued_for, * state_param = NULL, * state_encoded, code_challenge_stored[GLEWLWYD_CODE_CHALLENGE_MAX_LENGTH + 1] = {0};\n  const char * ip_source = get_ip_source(request, config->glewlwyd_config->glewlwyd_config->originating_ip_header);\n  json_t * j_session, * j_client = check_client_valid(config, u_map_get(request->map_url, \"client_id\"), request->auth_basic_user, request->auth_basic_password, u_map_get(request->map_url, \"redirect_uri\"), GLEWLWYD_AUTHORIZATION_TYPE_AUTHORIZATION_CODE, 1, ip_source);\n  int res;\n\n  if (u_map_get(request->map_url, \"state\") != NULL) {\n    state_encoded = ulfius_url_encode(u_map_get(request->map_url, \"state\"));\n    state_param = msprintf(\"&state=%s\", state_encoded);\n    o_free(state_encoded);\n  } else {\n    state_param = o_strdup(\"\");\n  }\n  // Check if client is allowed to perform this request\n  if (check_result_value(j_client, G_OK)) {\n    // Client is allowed to use auth_code grant with this redirection_uri\n    if (!o_strnullempty(u_map_get(request->map_url, \"scope\"))) {\n      if (u_map_has_key(request->map_url, \"g_continue\")) {\n        j_session = validate_session_client_scope(config, request, u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"));\n        if (check_result_value(j_session, G_OK)) {\n          if (json_object_get(json_object_get(j_session, \"session\"), \"authorization_required\") == json_false()) {\n            // User has granted access to the cleaned scope list for this client\n            // Generate code, generate the url and redirect to it\n            issued_for = get_client_hostname(request, config->glewlwyd_config->glewlwyd_config->originating_ip_header);\n            if (issued_for != NULL) {\n              if (config->glewlwyd_config->glewlwyd_callback_trigger_session_used(config->glewlwyd_config, request, json_string_value(json_object_get(json_object_get(j_session, \"session\"), \"scope_filtered\"))) == G_OK) {\n                if ((res = is_code_challenge_valid(config, u_map_get(request->map_url, \"code_challenge\"), u_map_get(request->map_url, \"code_challenge_method\"), code_challenge_stored)) == G_OK) {\n                  if ((authorization_code = generate_authorization_code(config, json_string_value(json_object_get(json_object_get(json_object_get(j_session, \"session\"), \"user\"), \"username\")), u_map_get(request->map_url, \"client_id\"), json_string_value(json_object_get(json_object_get(j_session, \"session\"), \"scope_filtered\")), u_map_get(request->map_url, \"redirect_uri\"), issued_for, u_map_get_case(request->map_header, \"user-agent\"), code_challenge_stored)) != NULL) {\n                    redirect_url = msprintf(\"%s%scode=%s%s\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"), authorization_code, state_param);\n                    ulfius_add_header_to_response(response, \"Location\", redirect_url);\n                    response->status = 302;\n                    o_free(redirect_url);\n                    config->glewlwyd_config->glewlwyd_plugin_callback_metrics_increment_counter(config->glewlwyd_config, GLWD_METRICS_OAUTH2_CODE, 1, \"plugin\", config->name, NULL);\n                  } else {\n                    redirect_url = msprintf(\"%s%serror=server_error\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"));\n                    ulfius_add_header_to_response(response, \"Location\", redirect_url);\n                    o_free(redirect_url);\n                    y_log_message(Y_LOG_LEVEL_ERROR, \"check_auth_type_auth_code_grant - oauth2 - Error generate_authorization_code\");\n                    response->status = 302;\n                  }\n                  o_free(authorization_code);\n                } else if (res == G_ERROR_PARAM) {\n                  redirect_url = msprintf(\"%s%serror=invalid_request\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"));\n                  ulfius_add_header_to_response(response, \"Location\", redirect_url);\n                  o_free(redirect_url);\n                  y_log_message(Y_LOG_LEVEL_DEBUG, \"check_auth_type_auth_code_grant - oauth2 - Invalid code_challenge or code_challenge_method, origin: %s\", get_ip_source(request, config->glewlwyd_config->glewlwyd_config->originating_ip_header));\n                  response->status = 302;\n                } else {\n                  redirect_url = msprintf(\"%s%serror=server_error\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"));\n                  ulfius_add_header_to_response(response, \"Location\", redirect_url);\n                  o_free(redirect_url);\n                  y_log_message(Y_LOG_LEVEL_ERROR, \"check_auth_type_auth_code_grant - oauth2 - Error is_code_challenge_valid\");\n                  response->status = 302;\n                }\n              } else {\n                redirect_url = msprintf(\"%s%serror=server_error\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"));\n                ulfius_add_header_to_response(response, \"Location\", redirect_url);\n                o_free(redirect_url);\n                y_log_message(Y_LOG_LEVEL_ERROR, \"check_auth_type_auth_code_grant - oauth2 - Error glewlwyd_callback_trigger_session_used\");\n                response->status = 302;\n              }\n            } else {\n              redirect_url = msprintf(\"%s%serror=server_error\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"));\n              ulfius_add_header_to_response(response, \"Location\", redirect_url);\n              o_free(redirect_url);\n              y_log_message(Y_LOG_LEVEL_ERROR, \"check_auth_type_auth_code_grant - oauth2 - Error get_client_hostname\");\n              response->status = 302;\n            }\n            o_free(issued_for);\n          } else {\n            // Redirect to login page\n            redirect_url = get_login_url(config, request, \"auth\", u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"), NULL);\n            ulfius_add_header_to_response(response, \"Location\", redirect_url);\n            o_free(redirect_url);\n            response->status = 302;\n          }\n        } else if (check_result_value(j_session, G_ERROR_NOT_FOUND)) {\n          // Redirect to login page\n          redirect_url = get_login_url(config, request, \"auth\", u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"), NULL);\n          ulfius_add_header_to_response(response, \"Location\", redirect_url);\n          o_free(redirect_url);\n          response->status = 302;\n        } else if (check_result_value(j_session, G_ERROR_UNAUTHORIZED)) {\n          // Scope is not allowed for this user\n          response->status = 302;\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_auth_type_auth_code_grant - oauth2 - scope list '%s' is invalid for user '%s', origin: %s\", u_map_get(request->map_url, \"scope\"), json_string_value(json_object_get(json_object_get(json_object_get(j_session, \"session\"), \"user\"), \"username\")), ip_source);\n          redirect_url = msprintf(\"%s%serror=invalid_scope%s\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"), state_param);\n          ulfius_add_header_to_response(response, \"Location\", redirect_url);\n          o_free(redirect_url);\n        } else {\n          redirect_url = msprintf(\"%s%serror=server_error\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"));\n          ulfius_add_header_to_response(response, \"Location\", redirect_url);\n          o_free(redirect_url);\n          y_log_message(Y_LOG_LEVEL_ERROR, \"check_auth_type_auth_code_grant - oauth2 - Error validate_session_client_scope\");\n          response->status = 302;\n        }\n        json_decref(j_session);\n      } else {\n        // Redirect to login page\n        redirect_url = get_login_url(config, request, \"auth\", u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"), NULL);\n        ulfius_add_header_to_response(response, \"Location\", redirect_url);\n        o_free(redirect_url);\n        response->status = 302;\n      }\n    } else {\n      // Scope is not allowed for this user\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"check_auth_type_auth_code_grant - oauth2 - scope list is missing or empty, origin: %s\", ip_source);\n      response->status = 403;\n    }\n  } else {\n    // client is not authorized\n    response->status = 403;\n    config->glewlwyd_config->glewlwyd_plugin_callback_metrics_increment_counter(config->glewlwyd_config, GLWD_METRICS_OAUTH2_UNAUTHORIZED_CLIENT, 1, \"plugin\", config->name, NULL);\n  }\n  o_free(state_param);\n  json_decref(j_client);\n  return U_CALLBACK_CONTINUE;\n}",
      "cve_list": [
        "CVE-2024-25715"
      ],
      "cwe_list": [
        "CWE-601"
      ]
    },
    {
      "project": "glewlwyd",
      "filepath": "src/plugin/protocol_oauth2.c",
      "func_name": "check_auth_type_implicit_grant",
      "func_body": "static int check_auth_type_implicit_grant (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  struct _oauth2_config * config = (struct _oauth2_config *)user_data;\n  const char * ip_source = get_ip_source(request, config->glewlwyd_config->glewlwyd_config->originating_ip_header);\n  char * redirect_url, * issued_for, * state_encoded = NULL, * state_param = NULL;\n  json_t * j_session,\n         * j_client = check_client_valid(config, u_map_get(request->map_url, \"client_id\"), request->auth_basic_user, request->auth_basic_password, u_map_get(request->map_url, \"redirect_uri\"), GLEWLWYD_AUTHORIZATION_TYPE_IMPLICIT, 1, ip_source);\n  char * access_token;\n  time_t now;\n\n  if (u_map_get(request->map_url, \"state\") != NULL) {\n    state_encoded = ulfius_url_encode(u_map_get(request->map_url, \"state\"));\n    state_param = msprintf(\"&state=%s\", state_encoded);\n    o_free(state_encoded);\n  } else {\n    state_param = o_strdup(\"\");\n  }\n  // Check if client is allowed to perform this request\n  if (check_result_value(j_client, G_OK)) {\n    // Client is allowed to use auth_code grant with this redirection_uri\n    if (!o_strnullempty(u_map_get(request->map_url, \"scope\"))) {\n      if (u_map_has_key(request->map_url, \"g_continue\")) {\n        j_session = validate_session_client_scope(config, request, u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"));\n        if (check_result_value(j_session, G_OK)) {\n          if (json_object_get(json_object_get(j_session, \"session\"), \"authorization_required\") == json_false()) {\n            // User has granted access to the cleaned scope list for this client\n            // Generate access token\n            issued_for = get_client_hostname(request, config->glewlwyd_config->glewlwyd_config->originating_ip_header);\n            if (issued_for != NULL) {\n              time(&now);\n              if ((access_token = generate_access_token(config,\n                                                        json_string_value(json_object_get(json_object_get(json_object_get(j_session, \"session\"), \"user\"), \"username\")),\n                                                        u_map_get(request->map_url, \"client_id\"),\n                                                        json_object_get(json_object_get(j_session, \"session\"), \"user\"),\n                                                        json_string_value(json_object_get(json_object_get(j_session, \"session\"), \"scope_filtered\")),\n                                                        now,\n                                                        ip_source)) != NULL) {\n                if (serialize_access_token(config, GLEWLWYD_AUTHORIZATION_TYPE_IMPLICIT, 0, json_string_value(json_object_get(json_object_get(json_object_get(j_session, \"session\"), \"user\"), \"username\")), u_map_get(request->map_url, \"client_id\"), json_string_value(json_object_get(json_object_get(j_session, \"session\"), \"scope_filtered\")), now, issued_for, u_map_get_case(request->map_header, \"user-agent\"), access_token) == G_OK) {\n                  if (config->glewlwyd_config->glewlwyd_callback_trigger_session_used(config->glewlwyd_config, request, json_string_value(json_object_get(json_object_get(j_session, \"session\"), \"scope_filtered\"))) == G_OK) {\n                    redirect_url = msprintf(\"%s%saccess_token=%s&token_type=bearer&expires_in=%\" JSON_INTEGER_FORMAT \"&scope=%s%s\",\n                                            u_map_get(request->map_url, \"redirect_uri\"),\n                                            (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '#')!=NULL?\"&\":\"#\"),\n                                            access_token,\n                                            config->access_token_duration,\n                                            json_string_value(json_object_get(json_object_get(j_session, \"session\"), \"scope_filtered\")),\n                                            state_param);\n                    ulfius_add_header_to_response(response, \"Location\", redirect_url);\n                    o_free(redirect_url);\n                    response->status = 302;\n                    config->glewlwyd_config->glewlwyd_plugin_callback_metrics_increment_counter(config->glewlwyd_config, GLWD_METRICS_OAUTH2_USER_ACCESS_TOKEN, 1, \"plugin\", config->name, \"response_type\", \"code\", NULL);\n                    config->glewlwyd_config->glewlwyd_plugin_callback_metrics_increment_counter(config->glewlwyd_config, GLWD_METRICS_OAUTH2_USER_ACCESS_TOKEN, 1, \"plugin\", config->name, NULL);\n                  } else {\n                    redirect_url = msprintf(\"%s%serror=server_error\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"));\n                    ulfius_add_header_to_response(response, \"Location\", redirect_url);\n                    o_free(redirect_url);\n                    y_log_message(Y_LOG_LEVEL_ERROR, \"check_auth_type_implicit_grant - oauth2 - Error glewlwyd_callback_trigger_session_used\");\n                    response->status = 302;\n                  }\n                } else {\n                  redirect_url = msprintf(\"%s%serror=server_error\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"));\n                  ulfius_add_header_to_response(response, \"Location\", redirect_url);\n                  o_free(redirect_url);\n                  y_log_message(Y_LOG_LEVEL_ERROR, \"check_auth_type_implicit_grant - oauth2 - Error serialize_access_token\");\n                  response->status = 302;\n                }\n              } else {\n                redirect_url = msprintf(\"%s%serror=server_error\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"));\n                ulfius_add_header_to_response(response, \"Location\", redirect_url);\n                o_free(redirect_url);\n                y_log_message(Y_LOG_LEVEL_ERROR, \"check_auth_type_implicit_grant - oauth2 - Error generate_access_token\");\n                response->status = 302;\n              }\n              o_free(access_token);\n            } else {\n              redirect_url = msprintf(\"%s%serror=server_error\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"));\n              ulfius_add_header_to_response(response, \"Location\", redirect_url);\n              o_free(redirect_url);\n              y_log_message(Y_LOG_LEVEL_ERROR, \"check_auth_type_implicit_grant - oauth2 - Error get_client_hostname\");\n              response->status = 302;\n            }\n            o_free(issued_for);\n          } else {\n            // Redirect to login page\n            redirect_url = get_login_url(config, request, \"auth\", u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"), NULL);\n            ulfius_add_header_to_response(response, \"Location\", redirect_url);\n            o_free(redirect_url);\n            response->status = 302;\n          }\n        } else if (check_result_value(j_session, G_ERROR_UNAUTHORIZED)) {\n          // Scope is not allowed for this user\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"check_auth_type_implicit_grant - oauth2 - Scope list '%s' is not allowed for user '%s', origin: %s\", u_map_get(request->map_url, \"scope\"), json_string_value(json_object_get(json_object_get(json_object_get(j_session, \"session\"), \"user\"), \"username\")), ip_source);\n          response->status = 302;\n          redirect_url = msprintf(\"%s%serror=invalid_scope%s\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"), state_param);\n          ulfius_add_header_to_response(response, \"Location\", redirect_url);\n          o_free(redirect_url);\n        } else {\n          redirect_url = msprintf(\"%s%serror=server_error\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"));\n          ulfius_add_header_to_response(response, \"Location\", redirect_url);\n          o_free(redirect_url);\n          y_log_message(Y_LOG_LEVEL_ERROR, \"check_auth_type_implicit_grant - oauth2 - Error validate_session_client_scope\");\n          response->status = 302;\n        }\n        json_decref(j_session);\n      } else {\n        // Redirect to login page\n        redirect_url = get_login_url(config, request, \"auth\", u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"), NULL);\n        ulfius_add_header_to_response(response, \"Location\", redirect_url);\n        o_free(redirect_url);\n        response->status = 302;\n      }\n    } else {\n      // Empty scope is not allowed\n      response->status = 403;\n    }\n  } else {\n    // client is not authorized\n    response->status = 403;\n  }\n  o_free(state_param);\n  json_decref(j_client);\n  return U_CALLBACK_CONTINUE;\n}",
      "cve_list": [
        "CVE-2024-25715"
      ],
      "cwe_list": [
        "CWE-601"
      ]
    },
    {
      "project": "glewlwyd",
      "filepath": "src/plugin/protocol_oauth2.c",
      "func_name": "check_client_valid",
      "func_body": "static json_t * check_client_valid(struct _oauth2_config * config, const char * client_id, const char * client_header_login, const char * client_header_password, const char * redirect_uri, unsigned short authorization_type, int implicit_flow, const char * ip_source) {\n  json_t * j_client, * j_element = NULL, * j_return;\n  int uri_found = 0, authorization_type_enabled;\n  size_t index = 0;\n\n  if (client_id == NULL) {\n    y_log_message(Y_LOG_LEVEL_DEBUG, \"check_client_valid - oauth2 - Error client_id is NULL, origin: %s\", ip_source);\n    return json_pack(\"{si}\", \"result\", G_ERROR_PARAM);\n  } else if (client_header_login != NULL && 0 != o_strcmp(client_header_login, client_id)) {\n    y_log_message(Y_LOG_LEVEL_DEBUG, \"check_client_valid - oauth2 - Error, client_id specified is different from client_id in the basic auth header, origin: %s\", ip_source);\n    return json_pack(\"{si}\", \"result\", G_ERROR_PARAM);\n  }\n  j_client = config->glewlwyd_config->glewlwyd_callback_check_client_valid(config->glewlwyd_config, client_id, client_header_password);\n  if (check_result_value(j_client, G_OK) && json_object_get(json_object_get(j_client, \"client\"), \"enabled\") == json_true()) {\n    if (!implicit_flow && client_header_password == NULL && json_object_get(json_object_get(j_client, \"client\"), \"confidential\") == json_true()) {\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"check_client_valid - oauth2 - Error, confidential client must be authentified with its password, origin: %s\", ip_source);\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n    } else {\n      if (redirect_uri != NULL) {\n        json_array_foreach(json_object_get(json_object_get(j_client, \"client\"), \"redirect_uri\"), index, j_element) {\n          if (0 == o_strcmp(json_string_value(j_element), redirect_uri)) {\n            uri_found = 1;\n          }\n        }\n      }\n\n      authorization_type_enabled = 0;\n      json_array_foreach(json_object_get(json_object_get(j_client, \"client\"), \"authorization_type\"), index, j_element) {\n        if (authorization_type == GLEWLWYD_AUTHORIZATION_TYPE_AUTHORIZATION_CODE && 0 == o_strcmp(json_string_value(j_element), \"code\")) {\n          authorization_type_enabled = 1;\n        } else if (authorization_type == GLEWLWYD_AUTHORIZATION_TYPE_IMPLICIT && 0 == o_strcmp(json_string_value(j_element), \"token\")) {\n          authorization_type_enabled = 1;\n        } else if (authorization_type == GLEWLWYD_AUTHORIZATION_TYPE_RESOURCE_OWNER_PASSWORD_CREDENTIALS && 0 == o_strcmp(json_string_value(j_element), \"password\")) {\n          authorization_type_enabled = 1;\n          uri_found = 1; // bypass redirect_uri check for client credentials since it's not needed\n        } else if (authorization_type == GLEWLWYD_AUTHORIZATION_TYPE_REFRESH_TOKEN && 0 == o_strcmp(json_string_value(j_element), \"refresh_token\")) {\n          authorization_type_enabled = 1;\n          uri_found = 1; // bypass redirect_uri check for client credentials since it's not needed\n        } else if (authorization_type == GLEWLWYD_AUTHORIZATION_TYPE_DELETE_TOKEN && 0 == o_strcmp(json_string_value(j_element), \"delete_token\")) {\n          authorization_type_enabled = 1;\n          uri_found = 1; // bypass redirect_uri check for client credentials since it's not needed\n        } else if (authorization_type == GLEWLWYD_AUTHORIZATION_TYPE_DEVICE_AUTHORIZATION && 0 == o_strcmp(json_string_value(j_element), \"device_authorization\")) {\n          authorization_type_enabled = 1;\n          uri_found = 1; // bypass redirect_uri check for client credentials since it's not needed\n        }\n      }\n      if (!uri_found) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_client_valid - oauth2 - Error, redirect_uri '%s' is invalid for the client '%s', origin: %s\", redirect_uri, client_id, ip_source);\n      }\n      if (!authorization_type_enabled) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_client_valid - oauth2 - Error, authorization type is not enabled for the client '%s', origin: %s\", client_id, ip_source);\n      }\n      if (uri_found && authorization_type_enabled) {\n        j_return = json_pack(\"{sisO}\", \"result\", G_OK, \"client\", json_object_get(j_client, \"client\"));\n      } else {\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_PARAM);\n      }\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_DEBUG, \"check_client_valid - oauth2 - Error, client '%s' is invalid, origin: %s\", client_id, ip_source);\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n  }\n  json_decref(j_client);\n  return j_return;\n}",
      "cve_list": [
        "CVE-2024-25715"
      ],
      "cwe_list": [
        "CWE-601"
      ]
    },
    {
      "project": "glewlwyd",
      "filepath": "src/plugin/protocol_oauth2.c",
      "func_name": "validate_authorization_code",
      "func_body": "static json_t * validate_authorization_code(struct _oauth2_config * config, const char * code, const char * client_id, const char * redirect_uri, const char * code_verifier, const char * ip_source) {\n  char * code_hash = config->glewlwyd_config->glewlwyd_callback_generate_hash(config->glewlwyd_config, code), * expiration_clause = NULL, * scope_list = NULL, * tmp;\n  json_t * j_query, * j_result = NULL, * j_result_scope = NULL, * j_return, * j_element = NULL, * j_scope_param;\n  int res;\n  size_t index = 0;\n  json_int_t maximum_duration = config->refresh_token_duration, maximum_duration_override = -1;\n  int rolling_refresh = config->refresh_token_rolling, rolling_refresh_override = -1;\n\n  if (code_hash != NULL) {\n    if (config->glewlwyd_config->glewlwyd_config->conn->type==HOEL_DB_TYPE_MARIADB) {\n      expiration_clause = o_strdup(\"> NOW()\");\n    } else if (config->glewlwyd_config->glewlwyd_config->conn->type==HOEL_DB_TYPE_PGSQL) {\n      expiration_clause = o_strdup(\"> NOW()\");\n    } else { // HOEL_DB_TYPE_SQLITE\n      expiration_clause = o_strdup(\"> (strftime('%s','now'))\");\n    }\n    j_query = json_pack(\"{sss[ssss]s{sssssssss{ssss}}}\",\n                        \"table\",\n                        GLEWLWYD_PLUGIN_OAUTH2_TABLE_CODE,\n                        \"columns\",\n                          \"gpgc_username AS username\",\n                          \"gpgc_id\",\n                          \"gpgc_code_challenge AS code_challenge\",\n                          \"gpgc_enabled AS enabled\",\n                        \"where\",\n                          \"gpgc_plugin_name\",\n                          config->name,\n                          \"gpgc_client_id\",\n                          client_id,\n                          \"gpgc_redirect_uri\",\n                          redirect_uri,\n                          \"gpgc_code_hash\",\n                          code_hash,\n                          \"gpgc_expires_at\",\n                            \"operator\",\n                            \"raw\",\n                            \"value\",\n                            expiration_clause);\n    o_free(expiration_clause);\n    res = h_select(config->glewlwyd_config->glewlwyd_config->conn, j_query, &j_result, NULL);\n    json_decref(j_query);\n    if (res == H_OK) {\n      if (json_array_size(j_result)) {\n        if (json_integer_value(json_object_get(json_array_get(j_result, 0), \"enabled\"))) {\n          if ((res = validate_code_challenge(config, json_array_get(j_result, 0), code_verifier)) == G_OK) {\n            j_query = json_pack(\"{sss[s]s{sO}}\",\n                                \"table\",\n                                GLEWLWYD_PLUGIN_OAUTH2_TABLE_CODE_SCOPE,\n                                \"columns\",\n                                  \"gpgcs_scope AS name\",\n                                \"where\",\n                                  \"gpgc_id\",\n                                  json_object_get(json_array_get(j_result, 0), \"gpgc_id\"));\n            res = h_select(config->glewlwyd_config->glewlwyd_config->conn, j_query, &j_result_scope, NULL);\n            json_decref(j_query);\n            if (res == H_OK && json_array_size(j_result_scope) > 0) {\n              if (!json_object_set_new(json_array_get(j_result, 0), \"scope\", json_array())) {\n                json_array_foreach(j_result_scope, index, j_element) {\n                  if (scope_list == NULL) {\n                    scope_list = o_strdup(json_string_value(json_object_get(j_element, \"name\")));\n                  } else {\n                    tmp = msprintf(\"%s %s\", scope_list, json_string_value(json_object_get(j_element, \"name\")));\n                    o_free(scope_list);\n                    scope_list = tmp;\n                  }\n                  if ((j_scope_param = get_scope_parameters(config, json_string_value(json_object_get(j_element, \"name\")))) != NULL) {\n                    json_object_update(j_element, j_scope_param);\n                    json_decref(j_scope_param);\n                  }\n                  if (json_object_get(j_element, \"refresh-token-rolling\") != NULL && rolling_refresh_override != 0) {\n                    rolling_refresh_override = json_object_get(j_element, \"refresh-token-rolling\")==json_true();\n                  }\n                  if (json_integer_value(json_object_get(j_element, \"refresh-token-duration\")) && (json_integer_value(json_object_get(j_element, \"refresh-token-duration\")) < maximum_duration_override || maximum_duration_override == -1)) {\n                    maximum_duration_override = json_integer_value(json_object_get(j_element, \"refresh-token-duration\"));\n                  }\n                  json_array_append(json_object_get(json_array_get(j_result, 0), \"scope\"), j_element);\n                }\n                if (rolling_refresh_override > -1) {\n                  rolling_refresh = rolling_refresh_override;\n                }\n                if (maximum_duration_override > -1) {\n                  maximum_duration = maximum_duration_override;\n                }\n                json_object_set_new(json_array_get(j_result, 0), \"scope_list\", json_string(scope_list));\n                json_object_set_new(json_array_get(j_result, 0), \"refresh-token-rolling\", rolling_refresh?json_true():json_false());\n                json_object_set_new(json_array_get(j_result, 0), \"refresh-token-duration\", json_integer(maximum_duration));\n                j_return = json_pack(\"{sisO}\", \"result\", G_OK, \"code\", json_array_get(j_result, 0));\n                o_free(scope_list);\n              } else {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"validate_authorization_code - oauth2 - Error allocating resources for json_array()\");\n                j_return = json_pack(\"{si}\", \"result\", G_ERROR_MEMORY);\n              }\n            } else {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"validate_authorization_code - oauth2 - Error executing j_query (2)\");\n              config->glewlwyd_config->glewlwyd_plugin_callback_metrics_increment_counter(config->glewlwyd_config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n              j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n            }\n            json_decref(j_result_scope);\n          } else if (res == G_ERROR_UNAUTHORIZED) {\n            j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n          } else if (res == G_ERROR_PARAM) {\n            j_return = json_pack(\"{si}\", \"result\", G_ERROR_PARAM);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"validate_authorization_code - oauth2 - Error validate_code_challenge\");\n            j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n          }\n        } else {\n          if (json_true() == json_object_get(config->j_params, \"auth-type-code-revoke-replayed\")) {\n            if (revoke_tokens_from_code(config, json_integer_value(json_object_get(json_array_get(j_result, 0), \"gpgc_id\")), ip_source) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"validate_authorization_code - oauth2 - Error revoke_tokens_from_code\");\n            }\n          }\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n        }\n      } else {\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"validate_authorization_code - oauth2 - Error executing j_query (1)\");\n      config->glewlwyd_config->glewlwyd_plugin_callback_metrics_increment_counter(config->glewlwyd_config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n    }\n    json_decref(j_result);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"validate_authorization_code - oauth2 - Error glewlwyd_callback_generate_hash\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  o_free(code_hash);\n  return j_return;\n}",
      "cve_list": [
        "CVE-2024-25715"
      ],
      "cwe_list": [
        "CWE-601"
      ]
    },
    {
      "project": "glewlwyd",
      "filepath": "src/plugin/protocol_oauth2.c",
      "func_name": "validate_code_challenge",
      "func_body": "static int validate_code_challenge(struct _oauth2_config * config, json_t * j_result_code, const char * code_verifier) {\n  int ret;\n  unsigned char code_verifier_hash[32] = {0}, code_verifier_hash_b64[64] = {0};\n  size_t code_verifier_hash_len = 32, code_verifier_hash_b64_len = 0;\n  gnutls_datum_t key_data;\n\n  if (json_object_get(config->j_params, \"pkce-allowed\") != json_true()) {\n    if (o_strnullempty(code_verifier)) {\n      ret = G_OK;\n    } else {\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"oidc validate_code_challenge - code_verifier unauthorized\");\n      ret = G_ERROR_UNAUTHORIZED;\n    }\n  } else if ((!o_strnullempty(code_verifier) && json_string_null_or_empty(json_object_get(j_result_code, \"code_challenge\"))) || (o_strnullempty(code_verifier) && !json_string_null_or_empty(json_object_get(j_result_code, \"code_challenge\")))) {\n    y_log_message(Y_LOG_LEVEL_DEBUG, \"oidc validate_code_challenge - Invalid code_challenge or code_verifier\");\n    ret = G_ERROR_UNAUTHORIZED;\n  } else {\n    if (is_pkce_char_valid(code_verifier)) {\n      if (0 == o_strncmp(GLEWLWYD_CODE_CHALLENGE_S256_PREFIX, json_string_value(json_object_get(j_result_code, \"code_challenge\")), o_strlen(GLEWLWYD_CODE_CHALLENGE_S256_PREFIX))) {\n        key_data.data = (unsigned char *)code_verifier;\n        key_data.size = (unsigned int)o_strlen(code_verifier);\n        if (gnutls_fingerprint(GNUTLS_DIG_SHA256, &key_data, code_verifier_hash, &code_verifier_hash_len) == GNUTLS_E_SUCCESS) {\n          if (o_base64url_encode(code_verifier_hash, code_verifier_hash_len, code_verifier_hash_b64, &code_verifier_hash_b64_len)) {\n            code_verifier_hash_b64[code_verifier_hash_b64_len] = '\\0';\n            if (0 == o_strcmp(json_string_value(json_object_get(j_result_code, \"code_challenge\"))+o_strlen(GLEWLWYD_CODE_CHALLENGE_S256_PREFIX), (const char *)code_verifier_hash_b64)) {\n              ret = G_OK;\n            } else {\n              y_log_message(Y_LOG_LEVEL_DEBUG, \"oidc validate_code_challenge - Invalid code_challenge value\");\n              ret = G_ERROR_UNAUTHORIZED;\n            }\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"oidc validate_code_challenge - Error o_base64url_encode\");\n            ret = G_ERROR;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"oidc validate_code_challenge - Error gnutls_fingerprint\");\n          ret = G_ERROR;\n        }\n      } else {\n        if (0 == o_strcmp(json_string_value(json_object_get(j_result_code, \"code_challenge\")), code_verifier)) {\n          ret = G_OK;\n        } else {\n          y_log_message(Y_LOG_LEVEL_DEBUG, \"oidc validate_code_challenge - Invalid code_challenge value\");\n          ret = G_ERROR_UNAUTHORIZED;\n        }\n      }\n    } else {\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"oidc validate_code_challenge - Invalid code_challenge character set\");\n      ret = G_ERROR_UNAUTHORIZED;\n    }\n  }\n  return ret;\n}",
      "cve_list": [
        "CVE-2024-25715"
      ],
      "cwe_list": [
        "CWE-601"
      ]
    },
    {
      "project": "dcmtk",
      "filepath": "dcmect/libsrc/enhanced_ct.cc",
      "func_name": "EctEnhancedCT::WriteVisitor::operator ( )",
      "func_body": "    OFCondition operator()(ImagePixel& pixel)\n    {\n        // Avoid compiler warning about unused parameter \"pixel\"\n        (void)pixel;\n        // Input data is checked before\n        Uint16 rows = 0;\n        Uint16 cols = 0;\n        m_CT.getRows(rows);\n        m_CT.getColumns(cols);\n        const size_t numFrames      = m_CT.m_Frames.size();\n        if (numFrames > 2147483647)\n        {\n            DCMECT_ERROR(\"More than 2147483647 frames provided\");\n            return FG_EC_PixelDataTooLarge;\n        }\n        const size_t numPixelsFrame = OFstatic_cast(size_t, rows) * OFstatic_cast(size_t, cols);\n        const size_t numBytesFrame  = m_CT.m_Frames[0]->length;\n        if (numBytesFrame != numPixelsFrame * 2)\n        {\n            DCMECT_ERROR(\"Invalid number of bytes per frame: Expected \" << numPixelsFrame * 2 << \" but got \"\n              << numBytesFrame << \" frame pixel data\");\n            return ECT_InvalidPixelInfo;\n        }\n        // Creates the correct pixel data element, based on the image pixel module used.\n        DcmPixelData* pixData = new DcmPixelData(DCM_PixelData);\n        OFCondition result;\n        if (pixData)\n        {\n            pixData->setVR(EVR_OW);\n            Uint16* ptr          = NULL;\n            size_t numBytesTotal = numBytesFrame * numFrames / 2;\n            if (numBytesTotal <= 4294967294UL)\n            {\n                result = pixData->createUint16Array(OFstatic_cast(Uint32, numBytesTotal), ptr);\n                // copy all frames into CT's frame structure\n                if (ptr)\n                {\n                    for (size_t f = 0; f < numFrames; ++f)\n                    {\n                        memcpy(ptr, m_CT.m_Frames[f]->pixData, numBytesFrame);\n                        ptr += numPixelsFrame;\n                    }\n                    return m_Item.insert(pixData);\n                }\n            }\n            else\n            {\n                result = FG_EC_PixelDataTooLarge;\n                delete pixData;\n            }\n        }\n        return result;\n    }",
      "cve_list": [
        "CVE-2024-27628"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "dcmtk",
      "filepath": "dcmdata/libsrc/dcelem.cc",
      "func_name": "DcmElement::loadValue",
      "func_body": "OFCondition DcmElement::loadValue(DcmInputStream *inStream)\n{\n    /* initialize return value */\n    errorFlag = EC_Normal;\n    /* only if the length of this element does not equal 0, read information */\n    if (getLengthField() != 0)\n    {\n        DcmInputStream *readStream = inStream;\n        OFBool isStreamNew = OFFalse;\n\n        // if the NULL pointer was passed (i.e. we're not in the middle of\n        // a read() cycle, and fValue is NULL (i.e. the attribute value still\n        // remains in file and fLoadValue is not NULL (i.e. we know how to\n        // load the value from that file, then let's do it..\n        if (!readStream && fLoadValue && !fValue)\n        {\n            /* we need to read information from the stream which is */\n            /* accessible through fLoadValue. Hence, reassign readStream */\n            readStream = fLoadValue->create();\n\n            isStreamNew = OFTrue;\n\n            /* reset number of transferred bytes to zero */\n            setTransferredBytes(0);\n        }\n        /* if we have a stream from which we can read */\n        if (readStream)\n        {\n            /* check if the stream reported an error */\n            errorFlag = readStream->status();\n            /* if we encountered the end of the stream, set the error flag correspondingly */\n            if (errorFlag.good() && readStream->eos())\n                errorFlag = EC_EndOfStream;\n            /* if we did not encounter the end of the stream and no error occurred so far, go ahead */\n            else if (errorFlag.good())\n            {\n                /* if the object which holds this element's value does not yet exist, create it */\n                if (!fValue)\n                    fValue = newValueField(); /* also set errorFlag in case of error */\n\n                /* if object could be created  (i.e. we have an object which can be used to capture this element's */\n                /* value) we need to read a certain amount of bytes from the stream */\n                if (fValue)\n                {\n                    /* determine how many bytes shall be read from the stream */\n                    const Uint32 readLength = getLengthField() - getTransferredBytes();\n\n                    /* read a corresponding amount of bytes from the stream, store the information in fValue */\n                    /* increase the counter that counts how many bytes were actually read */\n                    incTransferredBytes(OFstatic_cast(Uint32, readStream->read(&fValue[getTransferredBytes()], readLength)));\n\n                    /* if we have read all the bytes which make up this element's value */\n                    if (getLengthField() == getTransferredBytes())\n                    {\n                        /* call a function which performs certain operations on the information which was read */\n                        postLoadValue();\n                        errorFlag = EC_Normal;\n                    }\n                    /* else set the return value correspondingly */\n                    else if (readStream->eos())\n                    {\n                        errorFlag = EC_InvalidStream; // premature end of stream\n                        DCMDATA_ERROR(\"DcmElement: \" << getTagName() << \" \" << getTag()\n                            << \" larger (\" << getLengthField() << \") than remaining bytes (\"\n                            << getTransferredBytes() << \") in file, premature end of stream\");\n                    }\n                    else\n                        errorFlag = EC_StreamNotifyClient;\n                }\n            }\n            /* if we created the stream from which information was read in this */\n            /* function, we need to we need to delete this object here as well */\n            if (isStreamNew)\n                delete readStream;\n        }\n        else\n        {\n            errorFlag = EC_InvalidStream; // incomplete dataset read from stream\n            DCMDATA_ERROR(\"DcmElement: \" << getTagName() << \" \" << getTag()\n                << \" larger (\" << getLengthField() << \") than remaining bytes (\"\n                << getTransferredBytes() << \") in file, premature end of stream\");\n        }\n    }\n    /* return result value */\n    return errorFlag;\n}",
      "cve_list": [
        "CVE-2024-34509",
        "CVE-2024-34508"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "dcmtk",
      "filepath": "dcmnet/libsrc/dimcmd.cc",
      "func_name": "getString",
      "func_body": "getString(DcmDataset *obj, DcmTagKey t, char *s, int maxlen, OFBool *spacePadded)\n{\n    DcmElement *elem;\n    DcmStack stack;\n    OFCondition ec = EC_Normal;\n    char* aString;\n\n    ec = obj->search(t, stack);\n    elem = (DcmElement*)stack.top();\n    if (ec == EC_Normal && elem != NULL) {\n        if (elem->getLength() == 0) {\n            s[0] = '\\0';\n        } else if (elem->getLength() > (Uint32)maxlen) {\n            return parseErrorWithMsg(\"dimcmd:getString: string too small\", t);\n        } else {\n            ec =  elem->getString(aString);\n            if (ec.good())\n            {\n                strncpy(s, aString, maxlen);\n                if (spacePadded)\n                {\n                    /* before we remove leading and tailing spaces we want to know\n                     * whether the string is actually space padded. Required to communicate\n                     * with dumb peers which send space padded UIDs and fail if they\n                     * receive correct UIDs back.\n                     *\n                     * This test can only detect space padded strings if\n                     * dcmEnableAutomaticInputDataCorrection is false; otherwise the padding\n                     * has already been removed by dcmdata at this stage.\n                     */\n                    size_t s_len = strlen(s);\n                    if ((s_len > 0)&&(s[s_len-1] == ' ')) *spacePadded = OFTrue; else *spacePadded = OFFalse;\n                }\n                DU_stripLeadingAndTrailingSpaces(s);\n            }\n        }\n    }\n    return (ec.good())? ec : DIMSE_PARSEFAILED;\n}",
      "cve_list": [
        "CVE-2024-34509",
        "CVE-2024-34508"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "open5gs",
      "filepath": "src/main.c",
      "func_name": "main",
      "func_body": "int main(int argc, const char *const argv[])\n{\n    /**************************************************************************\n     * Starting up process.\n     *\n     * Keep the order of starting-up\n     */\n    int rv, i, opt;\n    ogs_getopt_t options;\n    struct {\n        char *config_file;\n        char *log_file;\n        char *log_level;\n        char *domain_mask;\n\n        bool enable_debug;\n        bool enable_trace;\n    } optarg;\n    const char *argv_out[argc+1];\n\n    memset(&optarg, 0, sizeof(optarg));\n\n    ogs_getopt_init(&options, (char**)argv);\n    while ((opt = ogs_getopt(&options, \"vhDc:l:e:m:dt\")) != -1) {\n        switch (opt) {\n        case 'v':\n            show_version();\n            return OGS_OK;\n        case 'h':\n            show_help(argv[0]);\n            return OGS_OK;\n        case 'D':\n#if !defined(_WIN32)\n        {\n            pid_t pid;\n            pid = fork();\n\n            ogs_assert(pid >= 0);\n\n            if (pid != 0)\n            {\n                /* Parent */\n                return EXIT_SUCCESS;\n            }\n            /* Child */\n\n            setsid();\n            umask(027);\n        }\n#else\n            printf(\"%s: Not Support in WINDOWS\", argv[0]);\n#endif\n            break;\n        case 'c':\n            optarg.config_file = options.optarg;\n            break;\n        case 'l':\n            optarg.log_file = options.optarg;\n            break;\n        case 'e':\n            optarg.log_level = options.optarg;\n            break;\n        case 'm':\n            optarg.domain_mask = options.optarg;\n            break;\n        case 'd':\n            optarg.enable_debug = true;\n            break;\n        case 't':\n            optarg.enable_trace = true;\n            break;\n        case '?':\n            fprintf(stderr, \"%s: %s\\n\", argv[0], options.errmsg);\n            show_help(argv[0]);\n            return OGS_ERROR;\n        default:\n            fprintf(stderr, \"%s: should not be reached\\n\", OGS_FUNC);\n            return OGS_ERROR;\n        }\n    }\n\n    if (optarg.enable_debug) optarg.log_level = (char*)\"debug\";\n    if (optarg.enable_trace) optarg.log_level = (char*)\"trace\";\n\n    i = 0;\n    argv_out[i++] = argv[0];\n\n    if (optarg.config_file) {\n        argv_out[i++] = \"-c\";\n        argv_out[i++] = optarg.config_file;\n    }\n    if (optarg.log_file) {\n        argv_out[i++] = \"-l\";\n        argv_out[i++] = optarg.log_file;\n    }\n    if (optarg.log_level) {\n        argv_out[i++] = \"-e\";\n        argv_out[i++] = optarg.log_level;\n    }\n    if (optarg.domain_mask) {\n        argv_out[i++] = \"-m\";\n        argv_out[i++] = optarg.domain_mask;\n    }\n\n    argv_out[i] = NULL;\n\n    ogs_signal_init();\n    ogs_setup_signal_thread();\n\n    rv = ogs_app_initialize(OPEN5GS_VERSION, DEFAULT_CONFIG_FILENAME, argv_out);\n    if (rv != OGS_OK) {\n        if (rv == OGS_RETRY)\n            return EXIT_SUCCESS;\n\n        ogs_fatal(\"Open5GS initialization failed. Aborted\");\n        return OGS_ERROR;\n    }\n\n    rv = app_initialize(argv_out);\n    if (rv != OGS_OK) {\n        if (rv == OGS_RETRY)\n            return EXIT_SUCCESS;\n\n        ogs_fatal(\"Open5GS initialization failed. Aborted\");\n        return OGS_ERROR;\n    }\n\n    atexit(terminate);\n    ogs_signal_thread(check_signal);\n\n    ogs_info(\"Open5GS daemon terminating...\");\n\n    return OGS_OK;\n}",
      "cve_list": [
        "CVE-2024-40130"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "open5gs",
      "filepath": "tests/app/5gc-init.c",
      "func_name": "app_initialize",
      "func_body": "int app_initialize(const char *const argv[])\n{\n    const char *argv_out[OGS_ARG_MAX];\n    bool user_config = false;\n    int i = 0;\n\n    for (i = 0; argv[i] && i < OGS_ARG_MAX-3; i++) {\n        if (strcmp(\"-c\", argv[i]) == 0) {\n            user_config = true; \n        }\n        argv_out[i] = argv[i];\n    }\n    argv_out[i] = NULL;\n\n    if (!user_config) {\n        argv_out[i++] = \"-c\";\n        argv_out[i++] = DEFAULT_CONFIG_FILENAME;\n        argv_out[i] = NULL;\n    }\n\n    if (ogs_app()->parameter.no_nrf == 0)\n        nrf_thread = test_child_create(\"nrf\", argv_out);\n    if (ogs_app()->parameter.no_scp == 0)\n        scp_thread = test_child_create(\"scp\", argv_out);\n\n    if (ogs_app()->parameter.no_upf == 0)\n        upf_thread = test_child_create(\"upf\", argv_out);\n    if (ogs_app()->parameter.no_smf == 0)\n        smf_thread = test_child_create(\"smf\", argv_out);\n\n    if (ogs_app()->parameter.no_amf == 0)\n        amf_thread = test_child_create(\"amf\", argv_out);\n\n    if (ogs_app()->parameter.no_ausf == 0)\n        ausf_thread = test_child_create(\"ausf\", argv_out);\n    if (ogs_app()->parameter.no_udm == 0)\n        udm_thread = test_child_create(\"udm\", argv_out);\n    if (ogs_app()->parameter.no_pcf == 0)\n        pcf_thread = test_child_create(\"pcf\", argv_out);\n    if (ogs_app()->parameter.no_nssf == 0)\n        nssf_thread = test_child_create(\"nssf\", argv_out);\n    if (ogs_app()->parameter.no_bsf == 0)\n        bsf_thread = test_child_create(\"bsf\", argv_out);\n    if (ogs_app()->parameter.no_udr == 0)\n        udr_thread = test_child_create(\"udr\", argv_out);\n\n    /*\n     * Wait for all sockets listening\n     * \n     * If freeDiameter is not used, it uses a delay of less than 4 seconds.\n     */\n    ogs_msleep(300);\n\n    return OGS_OK;;\n}",
      "cve_list": [
        "CVE-2024-40130"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "open5gs",
      "filepath": "tests/app/app-init.c",
      "func_name": "app_initialize",
      "func_body": "int app_initialize(const char *const argv[])\n{\n    const char *argv_out[OGS_ARG_MAX];\n    bool user_config = false;\n    int i = 0;\n\n    for (i = 0; argv[i] && i < OGS_ARG_MAX-3; i++) {\n        if (strcmp(\"-c\", argv[i]) == 0) {\n            user_config = true;\n        }\n        argv_out[i] = argv[i];\n    }\n    argv_out[i] = NULL;\n\n    if (!user_config) {\n        argv_out[i++] = \"-c\";\n        argv_out[i++] = DEFAULT_CONFIG_FILENAME;\n        argv_out[i] = NULL;\n    }\n\n    if (ogs_app()->parameter.no_nrf == 0)\n        nrf_thread = test_child_create(\"nrf\", argv_out);\n    if (ogs_app()->parameter.no_scp == 0)\n        scp_thread = test_child_create(\"scp\", argv_out);\n    if (ogs_app()->parameter.no_hss == 0)\n        hss_thread = test_child_create(\"hss\", argv_out);\n    if (ogs_app()->parameter.no_pcrf == 0)\n        pcrf_thread = test_child_create(\"pcrf\", argv_out);\n\n    if (ogs_app()->parameter.no_upf == 0)\n        upf_thread = test_child_create(\"upf\", argv_out);\n    if (ogs_app()->parameter.no_sgwu == 0)\n        sgwu_thread = test_child_create(\"sgwu\", argv_out);\n\n    if (ogs_app()->parameter.no_smf == 0)\n        smf_thread = test_child_create(\"smf\", argv_out);\n    if (ogs_app()->parameter.no_sgwc == 0)\n        sgwc_thread = test_child_create(\"sgwc\", argv_out);\n\n    if (ogs_app()->parameter.no_mme == 0)\n        mme_thread = test_child_create(\"mme\", argv_out);\n    if (ogs_app()->parameter.no_amf == 0)\n        amf_thread = test_child_create(\"amf\", argv_out);\n\n    if (ogs_app()->parameter.no_ausf == 0)\n        ausf_thread = test_child_create(\"ausf\", argv_out);\n    if (ogs_app()->parameter.no_udm == 0)\n        udm_thread = test_child_create(\"udm\", argv_out);\n    if (ogs_app()->parameter.no_pcf == 0)\n        pcf_thread = test_child_create(\"pcf\", argv_out);\n    if (ogs_app()->parameter.no_nssf == 0)\n        nssf_thread = test_child_create(\"nssf\", argv_out);\n    if (ogs_app()->parameter.no_bsf == 0)\n        bsf_thread = test_child_create(\"bsf\", argv_out);\n    if (ogs_app()->parameter.no_udr == 0)\n        udr_thread = test_child_create(\"udr\", argv_out);\n\n    /*\n     * Wait for all sockets listening\n     *\n     * Note that at least 4 seconds are needed if freeDiameter is running.\n     */\n    ogs_msleep(5000);\n\n    return OGS_OK;;\n}",
      "cve_list": [
        "CVE-2024-40130"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "open5gs",
      "filepath": "tests/app/epc-init.c",
      "func_name": "app_initialize",
      "func_body": "int app_initialize(const char *const argv[])\n{\n    const char *argv_out[OGS_ARG_MAX];\n    bool user_config = false;\n    int i = 0;\n\n    for (i = 0; argv[i] && i < OGS_ARG_MAX-3; i++) {\n        if (strcmp(\"-c\", argv[i]) == 0) {\n            user_config = true; \n        }\n        argv_out[i] = argv[i];\n    }\n    argv_out[i] = NULL;\n\n    if (!user_config) {\n        argv_out[i++] = \"-c\";\n        argv_out[i++] = DEFAULT_CONFIG_FILENAME;\n        argv_out[i] = NULL;\n    }\n\n    if (ogs_app()->parameter.no_hss == 0)\n        hss_thread = test_child_create(\"hss\", argv_out);\n    if (ogs_app()->parameter.no_pcrf == 0)\n        pcrf_thread = test_child_create(\"pcrf\", argv_out);\n\n    if (ogs_app()->parameter.no_upf == 0)\n        upf_thread = test_child_create(\"upf\", argv_out);\n    if (ogs_app()->parameter.no_sgwu == 0)\n        sgwu_thread = test_child_create(\"sgwu\", argv_out);\n\n    if (ogs_app()->parameter.no_smf == 0)\n        smf_thread = test_child_create(\"smf\", argv_out);\n    if (ogs_app()->parameter.no_sgwc == 0)\n        sgwc_thread = test_child_create(\"sgwc\", argv_out);\n\n    if (ogs_app()->parameter.no_mme == 0)\n        mme_thread = test_child_create(\"mme\", argv_out);\n\n    /*\n     * Wait for all sockets listening\n     *\n     * Note that at least 4 seconds are needed if freeDiameter is running.\n     */\n    ogs_msleep(5000);\n\n    return OGS_OK;;\n}",
      "cve_list": [
        "CVE-2024-40130"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "open5gs",
      "filepath": "tests/common/application.c",
      "func_name": "run",
      "func_body": "static void run(int argc, const char *const argv[],\n        const char *name, void (*init)(const char * const argv[]))\n{\n    int rv;\n    bool user_config;\n\n    /* '-f sample-XXXX.conf -e error' is always added */\n    const char *argv_out[argc+5], *new_argv[argc+5];\n    int argc_out;\n\n    char conf_file[OGS_MAX_FILEPATH_LEN];\n    \n    user_config = false;\n    for (argc_out = 0; argc_out < argc; argc_out++) {\n        if (strcmp(\"-c\", argv[argc_out]) == 0) {\n            user_config = true; \n        }\n        argv_out[argc_out] = argv[argc_out];\n    }\n    argv_out[argc_out] = NULL;\n\n    if (!user_config) {\n        /* buildroot/configs/XXX-conf.yaml */\n        ogs_snprintf(conf_file, sizeof conf_file, \"%s%s\",\n            MESON_BUILD_ROOT OGS_DIR_SEPARATOR_S\n            \"configs\" OGS_DIR_SEPARATOR_S, name);\n        argv_out[argc_out++] = \"-c\";\n        argv_out[argc_out++] = conf_file;\n        argv_out[argc_out] = NULL;\n    }\n\n    /* buildroot/src/open5gs-main */\n    argv_out[0] = MESON_BUILD_ROOT OGS_DIR_SEPARATOR_S \n            \"src\" OGS_DIR_SEPARATOR_S \"open5gs-main\";\n\n    rv = abts_main(argc_out, argv_out, new_argv);\n    ogs_assert(rv == OGS_OK);\n\n    (*init)(new_argv);\n}",
      "cve_list": [
        "CVE-2024-40130"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "open5gs",
      "filepath": "tests/common/gtpu.c",
      "func_name": "test_gtpu_send_indirect_data_forwarding",
      "func_body": "int test_gtpu_send_indirect_data_forwarding(\n        ogs_socknode_t *node, test_bearer_t *bearer, ogs_pkbuf_t *pkbuf)\n{\n    test_sess_t *sess = NULL;\n\n    ogs_gtp2_header_t gtp_hdesc;\n    ogs_gtp2_extension_header_t ext_hdesc;\n\n    ogs_assert(bearer);\n    sess = bearer->sess;\n    ogs_assert(sess);\n    ogs_assert(pkbuf);\n\n    memset(&gtp_hdesc, 0, sizeof(gtp_hdesc));\n    memset(&ext_hdesc, 0, sizeof(ext_hdesc));\n\n    gtp_hdesc.type = OGS_GTPU_MSGTYPE_GPDU;\n\n    if (bearer->qfi) {\n        gtp_hdesc.teid = sess->handover.upf_dl_teid;\n        ext_hdesc.qos_flow_identifier = bearer->qfi;\n\n    } else if (bearer->ebi) {\n        gtp_hdesc.teid = bearer->handover.ul_teid;\n\n    } else {\n        ogs_fatal(\"No QFI[%d] and EBI[%d]\", bearer->qfi, bearer->ebi);\n        ogs_assert_if_reached();\n    }\n\n    return test_gtpu_send(node, bearer, &gtp_hdesc, &ext_hdesc, pkbuf);\n}",
      "cve_list": [
        "CVE-2024-40130"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "open5gs",
      "filepath": "tests/common/ngap-build.c",
      "func_name": "testngap_build_ng_setup_request",
      "func_body": "ogs_pkbuf_t *testngap_build_ng_setup_request(uint32_t gnb_id, uint8_t bitsize)\n{\n    ogs_pkbuf_t *pkbuf = NULL;\n    int i, j, k, num = 0;\n    ogs_plmn_id_t *plmn_id = NULL;\n    const char *ran_node_name = \"5G gNB-CU\";\n\n    NGAP_NGAP_PDU_t pdu;\n    NGAP_InitiatingMessage_t *initiatingMessage = NULL;\n    NGAP_NGSetupRequest_t *NGSetupRequest = NULL;\n\n    NGAP_NGSetupRequestIEs_t *ie = NULL;\n    NGAP_GlobalRANNodeID_t *GlobalRANNodeID = NULL;\n    NGAP_RANNodeName_t *RANNodeName = NULL;\n    NGAP_GlobalGNB_ID_t *globalGNB_ID = NULL;\n    NGAP_SupportedTAList_t *SupportedTAList = NULL;\n    NGAP_SupportedTAItem_t *SupportedTAItem = NULL;\n    NGAP_BroadcastPLMNItem_t *BroadcastPLMNItem = NULL;\n    NGAP_SliceSupportItem_t *SliceSupportItem = NULL;\n    NGAP_PLMNIdentity_t *pLMNIdentity = NULL;\n    NGAP_PagingDRX_t *PagingDRX = NULL;\n\n    memset(&pdu, 0, sizeof (NGAP_NGAP_PDU_t));\n    pdu.present = NGAP_NGAP_PDU_PR_initiatingMessage;\n    pdu.choice.initiatingMessage = CALLOC(1, sizeof(NGAP_InitiatingMessage_t));\n\n    initiatingMessage = pdu.choice.initiatingMessage;\n    initiatingMessage->procedureCode = NGAP_ProcedureCode_id_NGSetup;\n    initiatingMessage->criticality = NGAP_Criticality_reject;\n    initiatingMessage->value.present =\n        NGAP_InitiatingMessage__value_PR_NGSetupRequest;\n\n    NGSetupRequest = &initiatingMessage->value.choice.NGSetupRequest;\n\n    globalGNB_ID = CALLOC(1, sizeof(NGAP_GlobalGNB_ID_t));\n\n    plmn_id = &test_self()->plmn_support[0].plmn_id;\n    ogs_asn_buffer_to_OCTET_STRING(\n            plmn_id, OGS_PLMN_ID_LEN, &globalGNB_ID->pLMNIdentity);\n\n    ogs_ngap_uint32_to_GNB_ID(gnb_id, bitsize, &globalGNB_ID->gNB_ID);\n\n    ie = CALLOC(1, sizeof(NGAP_NGSetupRequestIEs_t));\n    ASN_SEQUENCE_ADD(&NGSetupRequest->protocolIEs, ie);\n\n    ie->id = NGAP_ProtocolIE_ID_id_GlobalRANNodeID;\n    ie->criticality = NGAP_Criticality_reject;\n    ie->value.present = NGAP_NGSetupRequestIEs__value_PR_GlobalRANNodeID;\n\n    GlobalRANNodeID = &ie->value.choice.GlobalRANNodeID;\n\n    ie = CALLOC(1, sizeof(NGAP_NGSetupRequestIEs_t));\n    ASN_SEQUENCE_ADD(&NGSetupRequest->protocolIEs, ie);\n\n    ie->id = NGAP_ProtocolIE_ID_id_RANNodeName;\n    ie->criticality = NGAP_Criticality_ignore;\n    ie->value.present = NGAP_NGSetupRequestIEs__value_PR_RANNodeName;\n\n    RANNodeName = &ie->value.choice.RANNodeName;\n\n    ie = CALLOC(1, sizeof(NGAP_NGSetupRequestIEs_t));\n    ASN_SEQUENCE_ADD(&NGSetupRequest->protocolIEs, ie);\n\n    ie->id = NGAP_ProtocolIE_ID_id_SupportedTAList;\n    ie->criticality = NGAP_Criticality_reject;\n    ie->value.present = NGAP_NGSetupRequestIEs__value_PR_SupportedTAList;\n\n    SupportedTAList = &ie->value.choice.SupportedTAList;\n\n    ie = CALLOC(1, sizeof(NGAP_NGSetupRequestIEs_t));\n    ASN_SEQUENCE_ADD(&NGSetupRequest->protocolIEs, ie);\n    \n    ie->id = NGAP_ProtocolIE_ID_id_DefaultPagingDRX;\n    ie->criticality = NGAP_Criticality_ignore;\n    ie->value.present = NGAP_NGSetupRequestIEs__value_PR_PagingDRX;\n\n    PagingDRX = &ie->value.choice.PagingDRX;\n\n    GlobalRANNodeID->present = NGAP_GlobalRANNodeID_PR_globalGNB_ID;\n    GlobalRANNodeID->choice.globalGNB_ID = globalGNB_ID;\n\n    ogs_asn_buffer_to_OCTET_STRING((char*)ran_node_name,\n            strlen(ran_node_name), RANNodeName);\n\n    if (test_self()->nr_served_tai[0].list2.num)\n        num = test_self()->nr_served_tai[0].list2.num;\n    else if (test_self()->nr_served_tai[0].list0.tai[0].num)\n        num = test_self()->nr_served_tai[0].list0.tai[0].num;\n    else\n        ogs_assert_if_reached();\n\n    for (i = 0; i < num; i++) {\n        SupportedTAItem = CALLOC(1, sizeof(NGAP_SupportedTAItem_t));\n        if (test_self()->nr_served_tai[0].list2.num)\n            ogs_asn_uint24_to_OCTET_STRING(\n                test_self()->nr_served_tai[0].list2.tai[i].tac,\n                &SupportedTAItem->tAC);\n        else if (test_self()->nr_served_tai[0].list0.tai[0].num)\n            ogs_asn_uint24_to_OCTET_STRING(\n                test_self()->nr_served_tai[0].list0.tai[0].tac[i],\n                    &SupportedTAItem->tAC);\n        else\n            ogs_assert_if_reached();\n\n        for (j = 0; j < test_self()->num_of_plmn_support; j++) {\n            plmn_id = &test_self()->plmn_support[j].plmn_id;\n\n            BroadcastPLMNItem = CALLOC(1, sizeof(NGAP_BroadcastPLMNItem_t));\n\n            ogs_asn_buffer_to_OCTET_STRING(\n                    plmn_id, OGS_PLMN_ID_LEN, &BroadcastPLMNItem->pLMNIdentity);\n\n            for (k = 0; k < test_self()->plmn_support[j].num_of_s_nssai; k++) {\n                ogs_s_nssai_t *s_nssai =\n                    &test_self()->plmn_support[j].s_nssai[k];\n\n                SliceSupportItem = CALLOC(1, sizeof(NGAP_SliceSupportItem_t));\n                ogs_asn_uint8_to_OCTET_STRING(s_nssai->sst,\n                        &SliceSupportItem->s_NSSAI.sST);\n                if (s_nssai->sd.v != OGS_S_NSSAI_NO_SD_VALUE) {\n                    SliceSupportItem->s_NSSAI.sD = CALLOC(1, sizeof(NGAP_SD_t));\n                    ogs_asn_uint24_to_OCTET_STRING(\n                            s_nssai->sd, SliceSupportItem->s_NSSAI.sD);\n                }\n\n                ASN_SEQUENCE_ADD(&BroadcastPLMNItem->tAISliceSupportList.list,\n                                SliceSupportItem);\n            }\n\n            ASN_SEQUENCE_ADD(&SupportedTAItem->broadcastPLMNList.list,\n                    BroadcastPLMNItem);\n        }\n\n        ASN_SEQUENCE_ADD(&SupportedTAList->list, SupportedTAItem);\n    }\n\n    *PagingDRX = NGAP_PagingDRX_v32;\n\n    return ogs_ngap_encode(&pdu);\n}",
      "cve_list": [
        "CVE-2024-40130"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "open5gs",
      "filepath": "tests/common/ngap-build.c",
      "func_name": "testngap_build_ran_configuration_update",
      "func_body": "ogs_pkbuf_t *testngap_build_ran_configuration_update(bool supported_ta_list)\n{\n    ogs_pkbuf_t *pkbuf = NULL;\n    int i, j, k, num;\n    ogs_plmn_id_t *plmn_id = NULL;\n\n    NGAP_NGAP_PDU_t pdu;\n    NGAP_InitiatingMessage_t *initiatingMessage = NULL;\n    NGAP_RANConfigurationUpdate_t *RANConfigurationUpdate = NULL;\n\n    NGAP_RANConfigurationUpdateIEs_t *ie = NULL;\n    NGAP_GlobalRANNodeID_t *GlobalRANNodeID = NULL;\n    NGAP_RANNodeName_t *RANNodeName = NULL;\n    NGAP_GlobalGNB_ID_t *globalGNB_ID = NULL;\n    NGAP_SupportedTAList_t *SupportedTAList = NULL;\n    NGAP_SupportedTAItem_t *SupportedTAItem = NULL;\n    NGAP_BroadcastPLMNItem_t *BroadcastPLMNItem = NULL;\n    NGAP_SliceSupportItem_t *SliceSupportItem = NULL;\n    NGAP_PLMNIdentity_t *pLMNIdentity = NULL;\n\n    memset(&pdu, 0, sizeof (NGAP_NGAP_PDU_t));\n    pdu.present = NGAP_NGAP_PDU_PR_initiatingMessage;\n    pdu.choice.initiatingMessage = CALLOC(1, sizeof(NGAP_InitiatingMessage_t));\n\n    initiatingMessage = pdu.choice.initiatingMessage;\n    initiatingMessage->procedureCode =\n        NGAP_ProcedureCode_id_RANConfigurationUpdate;\n    initiatingMessage->criticality = NGAP_Criticality_reject;\n    initiatingMessage->value.present =\n        NGAP_InitiatingMessage__value_PR_RANConfigurationUpdate;\n\n    RANConfigurationUpdate =\n        &initiatingMessage->value.choice.RANConfigurationUpdate;\n\n    if (supported_ta_list == true) {\n        ie = CALLOC(1, sizeof(NGAP_RANConfigurationUpdateIEs_t));\n        ASN_SEQUENCE_ADD(&RANConfigurationUpdate->protocolIEs, ie);\n\n        ie->id = NGAP_ProtocolIE_ID_id_SupportedTAList;\n        ie->criticality = NGAP_Criticality_reject;\n        ie->value.present =\n            NGAP_RANConfigurationUpdateIEs__value_PR_SupportedTAList;\n\n        SupportedTAList = &ie->value.choice.SupportedTAList;\n\n        if (test_self()->nr_served_tai[0].list2.num)\n            num = test_self()->nr_served_tai[0].list2.num;\n        else if (test_self()->nr_served_tai[0].list0.tai[0].num)\n            num = test_self()->nr_served_tai[0].list0.tai[0].num;\n        else\n            ogs_assert_if_reached();\n\n        for (i = 0; i < num; i++) {\n            SupportedTAItem = CALLOC(1, sizeof(NGAP_SupportedTAItem_t));\n            if (test_self()->nr_served_tai[0].list2.num)\n                ogs_asn_uint24_to_OCTET_STRING(\n                    test_self()->nr_served_tai[0].list2.tai[i].tac,\n                    &SupportedTAItem->tAC);\n            else if (test_self()->nr_served_tai[0].list0.tai[0].num)\n                ogs_asn_uint24_to_OCTET_STRING(\n                    test_self()->nr_served_tai[0].list0.tai[0].tac[i],\n                        &SupportedTAItem->tAC);\n            else\n                ogs_assert_if_reached();\n\n            for (j = 0; j < test_self()->num_of_plmn_support; j++) {\n                plmn_id = &test_self()->plmn_support[j].plmn_id;\n\n                BroadcastPLMNItem = CALLOC(1, sizeof(NGAP_BroadcastPLMNItem_t));\n\n                ogs_asn_buffer_to_OCTET_STRING(\n                        plmn_id, OGS_PLMN_ID_LEN,\n                        &BroadcastPLMNItem->pLMNIdentity);\n\n                for (k = 0; k < test_self()->plmn_support[j].num_of_s_nssai;\n                        k++) {\n                    ogs_s_nssai_t *s_nssai =\n                        &test_self()->plmn_support[j].s_nssai[k];\n\n                    SliceSupportItem = CALLOC(1,\n                            sizeof(NGAP_SliceSupportItem_t));\n                    ogs_asn_uint8_to_OCTET_STRING(s_nssai->sst,\n                            &SliceSupportItem->s_NSSAI.sST);\n                    if (s_nssai->sd.v != OGS_S_NSSAI_NO_SD_VALUE) {\n                        SliceSupportItem->s_NSSAI.sD = CALLOC(\n                                1, sizeof(NGAP_SD_t));\n                        ogs_asn_uint24_to_OCTET_STRING(\n                                s_nssai->sd, SliceSupportItem->s_NSSAI.sD);\n                    }\n\n                    ASN_SEQUENCE_ADD(\n                            &BroadcastPLMNItem->tAISliceSupportList.list,\n                            SliceSupportItem);\n                }\n\n                ASN_SEQUENCE_ADD(&SupportedTAItem->broadcastPLMNList.list,\n                        BroadcastPLMNItem);\n            }\n\n            ASN_SEQUENCE_ADD(&SupportedTAList->list, SupportedTAItem);\n        }\n    }\n\n    return ogs_ngap_encode(&pdu);\n}",
      "cve_list": [
        "CVE-2024-40130"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "open5gs",
      "filepath": "tests/common/s1ap-handler.c",
      "func_name": "tests1ap_handle_handover_command",
      "func_body": "void tests1ap_handle_handover_command(\n        test_ue_t *test_ue, ogs_s1ap_message_t *message)\n{\n    int i;\n    char buf[OGS_ADDRSTRLEN];\n\n    test_sess_t *sess = NULL;\n    test_bearer_t *bearer = NULL;\n\n    S1AP_S1AP_PDU_t pdu;\n    S1AP_SuccessfulOutcome_t *successfulOutcome = NULL;\n    S1AP_HandoverCommand_t *HandoverCommand = NULL;\n\n    S1AP_HandoverCommandIEs_t *ie = NULL;\n    S1AP_MME_UE_S1AP_ID_t *MME_UE_S1AP_ID = NULL;\n    S1AP_ENB_UE_S1AP_ID_t *ENB_UE_S1AP_ID = NULL;\n    S1AP_E_RABSubjecttoDataForwardingList_t\n        *E_RABSubjecttoDataForwardingList = NULL;\n\n    ogs_assert(test_ue);\n    ogs_assert(message);\n\n    successfulOutcome = message->choice.successfulOutcome;\n    ogs_assert(successfulOutcome);\n    HandoverCommand = &successfulOutcome->value.choice.HandoverCommand;\n    ogs_assert(HandoverCommand);\n\n    for (i = 0; i < HandoverCommand->protocolIEs.list.count; i++) {\n        ie = HandoverCommand->protocolIEs.list.array[i];\n        switch (ie->id) {\n        case S1AP_ProtocolIE_ID_id_MME_UE_S1AP_ID:\n            MME_UE_S1AP_ID = &ie->value.choice.MME_UE_S1AP_ID;\n            break;\n        case S1AP_ProtocolIE_ID_id_eNB_UE_S1AP_ID:\n            ENB_UE_S1AP_ID = &ie->value.choice.ENB_UE_S1AP_ID;\n            break;\n        case S1AP_ProtocolIE_ID_id_E_RABSubjecttoDataForwardingList:\n            E_RABSubjecttoDataForwardingList =\n                &ie->value.choice.E_RABSubjecttoDataForwardingList;\n            break;\n        default:\n            break;\n        }\n    }\n\n    if (MME_UE_S1AP_ID)\n        test_ue->mme_ue_s1ap_id = *MME_UE_S1AP_ID;\n    if (ENB_UE_S1AP_ID)\n        test_ue->enb_ue_s1ap_id = *ENB_UE_S1AP_ID;\n\n    if (E_RABSubjecttoDataForwardingList) {\n        for (i = 0; i < E_RABSubjecttoDataForwardingList->list.count; i++) {\n            S1AP_E_RABDataForwardingItemIEs_t *ie = NULL;\n            S1AP_E_RABDataForwardingItem_t *e_rab = NULL;\n\n            ie = (S1AP_E_RABDataForwardingItemIEs_t *)\n                    E_RABSubjecttoDataForwardingList->list.array[i];\n            ogs_assert(ie);\n            e_rab = &ie->value.choice.E_RABDataForwardingItem;\n\n            bearer = test_bearer_find_by_ue_ebi(test_ue, e_rab->e_RAB_ID);\n            ogs_assert(bearer);\n\n            if (e_rab->dL_gTP_TEID) {\n                memcpy(&bearer->handover.dl_teid, e_rab->dL_gTP_TEID->buf,\n                        sizeof(bearer->handover.dl_teid));\n                bearer->handover.dl_teid = be32toh(bearer->handover.dl_teid);\n            }\n            if (e_rab->dL_transportLayerAddress) {\n                ogs_assert(OGS_OK ==\n                        ogs_asn_BIT_STRING_to_ip(\n                            e_rab->dL_transportLayerAddress,\n                            &bearer->handover.dl_ip));\n            }\n            if (e_rab->uL_GTP_TEID) {\n                memcpy(&bearer->handover.ul_teid, e_rab->uL_GTP_TEID->buf,\n                        sizeof(bearer->handover.ul_teid));\n                bearer->handover.ul_teid = be32toh(bearer->handover.ul_teid);\n            }\n            if (e_rab->uL_TransportLayerAddress) {\n                ogs_assert(OGS_OK ==\n                        ogs_asn_BIT_STRING_to_ip(\n                            e_rab->uL_TransportLayerAddress,\n                            &bearer->handover.ul_ip));\n            }\n        }\n    }\n}",
      "cve_list": [
        "CVE-2024-40130"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "open5gs",
      "filepath": "tests/handover/epc-s1-test.c",
      "func_name": "test1_func",
      "func_body": "static void test1_func(abts_case *tc, void *data)\n{\n    int rv;\n    ogs_socknode_t *s1ap1, *s1ap2;\n    ogs_socknode_t *gtpu1, *gtpu2;\n    ogs_pkbuf_t *emmbuf;\n    ogs_pkbuf_t *esmbuf;\n    ogs_pkbuf_t *sendbuf;\n    ogs_pkbuf_t *recvbuf;\n    ogs_pkbuf_t *pkbuf;\n    ogs_s1ap_message_t message;\n\n    ogs_nas_5gs_mobile_identity_suci_t mobile_identity_suci;\n    test_ue_t *test_ue = NULL;\n    test_sess_t *sess = NULL;\n    test_bearer_t *bearer = NULL;\n\n    uint32_t enb_ue_s1ap_id;\n    uint64_t mme_ue_s1ap_id;\n\n    bson_t *doc = NULL;\n\n    /* Setup Test UE & Session Context */\n    memset(&mobile_identity_suci, 0, sizeof(mobile_identity_suci));\n\n    mobile_identity_suci.h.supi_format = OGS_NAS_5GS_SUPI_FORMAT_IMSI;\n    mobile_identity_suci.h.type = OGS_NAS_5GS_MOBILE_IDENTITY_SUCI;\n    mobile_identity_suci.routing_indicator1 = 0;\n    mobile_identity_suci.routing_indicator2 = 0xf;\n    mobile_identity_suci.routing_indicator3 = 0xf;\n    mobile_identity_suci.routing_indicator4 = 0xf;\n    mobile_identity_suci.protection_scheme_id = OGS_PROTECTION_SCHEME_NULL;\n    mobile_identity_suci.home_network_pki_value = 0;\n\n    test_ue = test_ue_add_by_suci(&mobile_identity_suci, \"3746000006\");\n    ogs_assert(test_ue);\n\n    test_ue->e_cgi.cell_id = 0x1234560;\n    test_ue->nas.ksi = OGS_NAS_KSI_NO_KEY_IS_AVAILABLE;\n    test_ue->nas.value = OGS_NAS_ATTACH_TYPE_COMBINED_EPS_IMSI_ATTACH;\n\n    test_ue->k_string = \"465b5ce8b199b49faa5f0a2ee238a6bc\";\n    test_ue->opc_string = \"e8ed289deba952e4283b54e88e6183ca\";\n\n    sess = test_sess_add_by_apn(test_ue, \"internet\", OGS_GTP2_RAT_TYPE_EUTRAN);\n    ogs_assert(sess);\n\n    /* Two eNB connects to MME */\n    s1ap1 = tests1ap_client(AF_INET);\n    ABTS_PTR_NOTNULL(tc, s1ap1);\n\n    s1ap2 = tests1ap_client(AF_INET);\n    ABTS_PTR_NOTNULL(tc, s1ap2);\n\n    /* eNB connects to SGW */\n    gtpu1 = test_gtpu_server(1, AF_INET);\n    ABTS_PTR_NOTNULL(tc, gtpu1);\n\n    gtpu2 = test_gtpu_server(2, AF_INET);\n    ABTS_PTR_NOTNULL(tc, gtpu2);\n\n    /* S1-Setup Reqeust/Response for Source eNB */\n    sendbuf = test_s1ap_build_s1_setup_request(\n            S1AP_ENB_ID_PR_macroENB_ID, 0x1f2);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap1, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    recvbuf = testenb_s1ap_read(s1ap1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(NULL, recvbuf);\n\n    /* S1-Setup Reqeust/Response for Target eNB */\n    sendbuf = test_s1ap_build_s1_setup_request(\n            S1AP_ENB_ID_PR_macroENB_ID, 0x43);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap2, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    recvbuf = testenb_s1ap_read(s1ap2);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(NULL, recvbuf);\n\n    /********** Insert Subscriber in Database */\n    doc = test_db_new_qos_flow(test_ue);\n    ABTS_PTR_NOTNULL(tc, doc);\n    ABTS_INT_EQUAL(tc, OGS_OK, test_db_insert_ue(test_ue, doc));\n\n    /* Send Attach Request */\n    memset(&sess->pdn_connectivity_param,\n            0, sizeof(sess->pdn_connectivity_param));\n    sess->pdn_connectivity_param.eit = 1;\n    sess->pdn_connectivity_param.pco = 1;\n    sess->pdn_connectivity_param.request_type =\n        OGS_NAS_EPS_REQUEST_TYPE_INITIAL;\n    esmbuf = testesm_build_pdn_connectivity_request(sess, false);\n    ABTS_PTR_NOTNULL(tc, esmbuf);\n\n    memset(&test_ue->attach_request_param,\n            0, sizeof(test_ue->attach_request_param));\n    test_ue->attach_request_param.guti = 1;\n    test_ue->attach_request_param.last_visited_registered_tai = 1;\n    test_ue->attach_request_param.drx_parameter = 1;\n    test_ue->attach_request_param.tmsi_status = 1;\n    test_ue->attach_request_param.mobile_station_classmark_2 = 1;\n    test_ue->attach_request_param.additional_update_type = 1;\n    test_ue->attach_request_param.ue_usage_setting = 1;\n    test_ue->attach_request_param.old_guti_type = 1;\n    emmbuf = testemm_build_attach_request(test_ue, esmbuf, true, false);\n    ABTS_PTR_NOTNULL(tc, emmbuf);\n\n    memset(&test_ue->initial_ue_param, 0, sizeof(test_ue->initial_ue_param));\n    test_ue->initial_ue_param.gummei_id = 1;\n    test_ue->initial_ue_param.gummei.mme_gid = 2;\n    test_ue->initial_ue_param.gummei.mme_code = 1;\n    sendbuf = test_s1ap_build_initial_ue_message(\n            test_ue, emmbuf, S1AP_RRC_Establishment_Cause_mo_Signalling, false);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n    rv = testenb_s1ap_send(s1ap1, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive Identity Request */\n    recvbuf = testenb_s1ap_read(s1ap1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    /* Send Identity response */\n    emmbuf = testemm_build_identity_response(test_ue);\n    ABTS_PTR_NOTNULL(tc, emmbuf);\n    sendbuf = test_s1ap_build_uplink_nas_transport(test_ue, emmbuf);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap1, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive Authentication Request */\n    recvbuf = testenb_s1ap_read(s1ap1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    /* Send Authentication response */\n    emmbuf = testemm_build_authentication_response(test_ue);\n    ABTS_PTR_NOTNULL(tc, emmbuf);\n    sendbuf = test_s1ap_build_uplink_nas_transport(test_ue, emmbuf);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap1, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive Security mode Command */\n    recvbuf = testenb_s1ap_read(s1ap1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    /* Send Security mode complete */\n    test_ue->mobile_identity_imeisv_presence = true;\n    emmbuf = testemm_build_security_mode_complete(test_ue);\n    ABTS_PTR_NOTNULL(tc, emmbuf);\n    sendbuf = test_s1ap_build_uplink_nas_transport(test_ue, emmbuf);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap1, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive ESM Information Request */\n    recvbuf = testenb_s1ap_read(s1ap1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    /* Send ESM Information Response */\n    esmbuf = testesm_build_esm_information_response(sess);\n    ABTS_PTR_NOTNULL(tc, esmbuf);\n    sendbuf = test_s1ap_build_uplink_nas_transport(test_ue, esmbuf);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap1, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive Initial Context Setup Request +\n     * Attach Accept +\n     * Activate Default Bearer Context Request */\n    recvbuf = testenb_s1ap_read(s1ap1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    /* Send UE Capability Info Indication */\n    sendbuf = tests1ap_build_ue_radio_capability_info_indication(test_ue);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap1, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Send Initial Context Setup Response */\n    sendbuf = test_s1ap_build_initial_context_setup_response(test_ue);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap1, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Send Attach Complete + Activate default EPS bearer cotext accept */\n    test_ue->nr_cgi.cell_id = 0x1234502;\n    bearer = test_bearer_find_by_ue_ebi(test_ue, 5);\n    ogs_assert(bearer);\n    esmbuf = testesm_build_activate_default_eps_bearer_context_accept(\n            bearer, false);\n    ABTS_PTR_NOTNULL(tc, esmbuf);\n    emmbuf = testemm_build_attach_complete(test_ue, esmbuf);\n    ABTS_PTR_NOTNULL(tc, emmbuf);\n    sendbuf = test_s1ap_build_uplink_nas_transport(test_ue, emmbuf);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap1, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive EMM information */\n    recvbuf = testenb_s1ap_read(s1ap1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    /* Receive E-RAB Setup Request +\n     * Activate dedicated EPS bearer context request */\n    recvbuf = testenb_s1ap_read(s1ap1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    /* Send E-RAB Setup Response */\n    bearer = test_bearer_find_by_ue_ebi(test_ue, 6);\n    ogs_assert(bearer);\n    sendbuf = test_s1ap_build_e_rab_setup_response(bearer);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap1, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Send Activate dedicated EPS bearer context accept */\n    esmbuf = testesm_build_activate_dedicated_eps_bearer_context_accept(bearer);\n    ABTS_PTR_NOTNULL(tc, esmbuf);\n    sendbuf = test_s1ap_build_uplink_nas_transport(test_ue, esmbuf);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap1, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Send ENB configuration transfer */\n    sendbuf = test_s1ap_build_enb_configuration_transfer(0);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap1, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive MME configuration transfer */\n    recvbuf = testenb_s1ap_read(s1ap2);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    /* Send ENB configuration transfer */\n    sendbuf = test_s1ap_build_enb_configuration_transfer(1);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap2, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive MME configuration transfer */\n    recvbuf = testenb_s1ap_read(s1ap1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    /* DELAY is needed in dedicated EPS bearer */\n    ogs_msleep(100);\n\n    /* Send GTP-U ICMP Packet */\n    bearer = test_bearer_find_by_ue_ebi(test_ue, 5);\n    ogs_assert(bearer);\n    rv = test_gtpu_send_ping(gtpu1, bearer, TEST_PING_IPV4);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive GTP-U ICMP Packet */\n    recvbuf = test_gtpu_read(gtpu1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    ogs_pkbuf_free(recvbuf);\n\n    /* Send GTP-U ICMP Packet */\n    bearer = test_bearer_find_by_ue_ebi(test_ue, 6);\n    ogs_assert(bearer);\n    rv = test_gtpu_send_ping(gtpu1, bearer, TEST_PING_IPV4);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive GTP-U ICMP Packet */\n    recvbuf = test_gtpu_read(gtpu1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    ogs_pkbuf_free(recvbuf);\n\n    /* Send Handover Required */\n    sendbuf = test_s1ap_build_handover_required(\n            test_ue, S1AP_HandoverType_intralte,\n            S1AP_ENB_ID_PR_macroENB_ID, 0x43,\n            S1AP_Cause_PR_radioNetwork,\n            S1AP_CauseRadioNetwork_time_critical_handover);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap1, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive Handover Request */\n    recvbuf = testenb_s1ap_read(s1ap2);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    /* Send Handover Request Ack */\n    ogs_list_for_each(&sess->bearer_list, bearer) {\n        bearer->enb_s1u_addr = test_self()->gnb2_addr;\n        bearer->enb_s1u_addr6 = test_self()->gnb2_addr6;\n    }\n    sendbuf = test_s1ap_build_handover_request_ack(test_ue);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap2, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive Handover Command */\n    recvbuf = testenb_s1ap_read(s1ap1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    /* Send GTP-U ICMP Packet */\n    bearer = test_bearer_find_by_ue_ebi(test_ue, 5);\n    ogs_assert(bearer);\n    rv = test_gtpu_send_ping(gtpu1, bearer, TEST_PING_IPV4);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive GTP-U ICMP Packet */\n    recvbuf = test_gtpu_read(gtpu1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n\n    /* Copy ICMP Packet */\n    pkbuf = ogs_pkbuf_alloc(NULL, 200);\n    ogs_assert(pkbuf);\n    ogs_pkbuf_reserve(pkbuf, OGS_GTPV1U_5GC_HEADER_LEN);\n    ogs_pkbuf_put(pkbuf, 200-OGS_GTPV1U_5GC_HEADER_LEN);\n    memset(pkbuf->data, 0, pkbuf->len);\n    memcpy(pkbuf->data, recvbuf->data + 8, recvbuf->len - 8);\n\n    ogs_pkbuf_free(recvbuf);\n\n    /* Send GTP-U Packet with Indirect Data Forwarding */\n    rv = test_gtpu_send_indirect_data_forwarding(gtpu1, bearer, pkbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive GTP-U ICMP Packet */\n    recvbuf = testgnb_gtpu_read(gtpu2);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    ogs_pkbuf_free(recvbuf);\n\n    /* Send eNB Status Transfer */\n    sendbuf = test_s1ap_build_enb_status_transfer(test_ue);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap1, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive MME Status Transfer */\n    recvbuf = testenb_s1ap_read(s1ap2);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    /* Send Handover Notify */\n    test_ue->e_cgi.cell_id = 0xabcdef0;\n    sendbuf = test_s1ap_build_handover_notify(test_ue);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap2, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive End Mark */\n    recvbuf = test_gtpu_read(gtpu1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    ogs_pkbuf_free(recvbuf);\n\n    /* Receive End Mark */\n    recvbuf = test_gtpu_read(gtpu1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    ogs_pkbuf_free(recvbuf);\n\n    /* Send TAU Request */\n    memset(&test_ue->tau_request_param, 0, sizeof(test_ue->tau_request_param));\n    test_ue->tau_request_param.ue_network_capability = 1;\n    test_ue->tau_request_param.last_visited_registered_tai = 1;\n    test_ue->tau_request_param.drx_parameter = 1;\n    test_ue->tau_request_param.eps_bearer_context_status = 1;\n    test_ue->tau_request_param.ms_network_capability = 1;\n    test_ue->tau_request_param.tmsi_status = 1;\n    test_ue->tau_request_param.mobile_station_classmark_2 = 1;\n    test_ue->tau_request_param.ue_usage_setting = 1;\n    emmbuf = testemm_build_tau_request(\n            test_ue, true, OGS_NAS_EPS_UPDATE_TYPE_COMBINED_TA_LA_UPDATING,\n            true, true);\n    ABTS_PTR_NOTNULL(tc, emmbuf);\n    sendbuf = test_s1ap_build_uplink_nas_transport(test_ue, emmbuf);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap2, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive TAU Accept */\n    recvbuf = testenb_s1ap_read(s1ap2);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    /* Receive UE Context Release Command */\n    mme_ue_s1ap_id = test_ue->mme_ue_s1ap_id;\n    enb_ue_s1ap_id = test_ue->enb_ue_s1ap_id;\n\n    recvbuf = testenb_s1ap_read(s1ap1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    /* Send UE Context Release Complete */\n    sendbuf = test_s1ap_build_ue_context_release_complete(test_ue);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap1, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    test_ue->mme_ue_s1ap_id = mme_ue_s1ap_id;\n    test_ue->enb_ue_s1ap_id = enb_ue_s1ap_id;\n\n    /* Send GTP-U ICMP Packet */\n    bearer = test_bearer_find_by_ue_ebi(test_ue, 5);\n    ogs_assert(bearer);\n    rv = test_gtpu_send_ping(gtpu2, bearer, TEST_PING_IPV4);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive GTP-U ICMP Packet */\n    recvbuf = test_gtpu_read(gtpu2);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    ogs_pkbuf_free(recvbuf);\n\n    /* Send GTP-U ICMP Packet */\n    bearer = test_bearer_find_by_ue_ebi(test_ue, 6);\n    ogs_assert(bearer);\n    rv = test_gtpu_send_ping(gtpu2, bearer, TEST_PING_IPV4);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive GTP-U ICMP Packet */\n    recvbuf = test_gtpu_read(gtpu2);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    ogs_pkbuf_free(recvbuf);\n\n    /* Send Handover Required */\n    sendbuf = test_s1ap_build_handover_required(\n            test_ue, S1AP_HandoverType_intralte,\n            S1AP_ENB_ID_PR_macroENB_ID, 0x1f2,\n            S1AP_Cause_PR_radioNetwork,\n            S1AP_CauseRadioNetwork_time_critical_handover);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap2, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive Handover Request */\n    recvbuf = testenb_s1ap_read(s1ap1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    /* Send Handover Request Ack */\n    ogs_list_for_each(&sess->bearer_list, bearer) {\n        bearer->enb_s1u_addr = test_self()->gnb1_addr;\n        bearer->enb_s1u_addr6 = test_self()->gnb1_addr6;\n    }\n    sendbuf = test_s1ap_build_handover_request_ack(test_ue);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap1, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive Handover Command */\n    recvbuf = testenb_s1ap_read(s1ap2);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    /* Send eNB Status Transfer */\n    sendbuf = test_s1ap_build_enb_status_transfer(test_ue);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap2, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive MME Status Transfer */\n    recvbuf = testenb_s1ap_read(s1ap1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    /* Send Handover Notify */\n    test_ue->e_cgi.cell_id = 0x1234560;\n    sendbuf = test_s1ap_build_handover_notify(test_ue);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap1, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive End Mark */\n    recvbuf = test_gtpu_read(gtpu2);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    ogs_pkbuf_free(recvbuf);\n\n    /* Receive End Mark */\n    recvbuf = test_gtpu_read(gtpu2);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    ogs_pkbuf_free(recvbuf);\n\n    /* Receive UE Context Release Command */\n    mme_ue_s1ap_id = test_ue->mme_ue_s1ap_id;\n    enb_ue_s1ap_id = test_ue->enb_ue_s1ap_id;\n\n    recvbuf = testenb_s1ap_read(s1ap2);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    /* Send UE Context Release Complete */\n    sendbuf = test_s1ap_build_ue_context_release_complete(test_ue);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap2, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    test_ue->mme_ue_s1ap_id = mme_ue_s1ap_id;\n    test_ue->enb_ue_s1ap_id = enb_ue_s1ap_id;\n\n    /* Send GTP-U ICMP Packet */\n    bearer = test_bearer_find_by_ue_ebi(test_ue, 5);\n    ogs_assert(bearer);\n    rv = test_gtpu_send_ping(gtpu1, bearer, TEST_PING_IPV4);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive GTP-U ICMP Packet */\n    recvbuf = test_gtpu_read(gtpu1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    ogs_pkbuf_free(recvbuf);\n\n    /* Send GTP-U ICMP Packet */\n    bearer = test_bearer_find_by_ue_ebi(test_ue, 6);\n    ogs_assert(bearer);\n    rv = test_gtpu_send_ping(gtpu1, bearer, TEST_PING_IPV4);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive GTP-U ICMP Packet */\n    recvbuf = test_gtpu_read(gtpu1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    ogs_pkbuf_free(recvbuf);\n\n    /* Send Handover Required */\n    sendbuf = test_s1ap_build_handover_required(\n            test_ue, S1AP_HandoverType_intralte,\n            S1AP_ENB_ID_PR_macroENB_ID, 0x43,\n            S1AP_Cause_PR_radioNetwork,\n            S1AP_CauseRadioNetwork_time_critical_handover);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap1, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive Handover Request */\n    recvbuf = testenb_s1ap_read(s1ap2);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    /* Send Handover Request Ack */\n    ogs_list_for_each(&sess->bearer_list, bearer) {\n        bearer->enb_s1u_addr = test_self()->gnb1_addr;\n        bearer->enb_s1u_addr6 = test_self()->gnb1_addr6;\n    }\n    sendbuf = test_s1ap_build_handover_request_ack(test_ue);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap2, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive Handover Command */\n    recvbuf = testenb_s1ap_read(s1ap1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    /* Send Handover Cancel */\n    sendbuf = test_s1ap_build_handover_cancel(test_ue,\n            S1AP_Cause_PR_radioNetwork,\n            S1AP_CauseRadioNetwork_tS1relocprep_expiry);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap1, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Receive UE Context Release Command */\n    recvbuf = testenb_s1ap_read(s1ap2);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    /* Send UE Context Release Complete */\n    sendbuf = test_s1ap_build_ue_context_release_complete(test_ue);\n    ABTS_PTR_NOTNULL(tc, sendbuf);\n    rv = testenb_s1ap_send(s1ap2, sendbuf);\n    ABTS_INT_EQUAL(tc, OGS_OK, rv);\n\n    /* Recv HandoverCancelAcknowledge */\n    recvbuf = testenb_s1ap_read(s1ap1);\n    ABTS_PTR_NOTNULL(tc, recvbuf);\n    tests1ap_recv(test_ue, recvbuf);\n\n    ogs_msleep(300);\n\n    /********** Remove Subscriber in Database */\n    ABTS_INT_EQUAL(tc, OGS_OK, test_db_remove_ue(test_ue));\n\n    /* eNB disonncect from SGW */\n    testgnb_gtpu_close(gtpu2);\n    testgnb_gtpu_close(gtpu1);\n\n    /* Two eNB disonncect from MME */\n    testenb_s1ap_close(s1ap1);\n    testenb_s1ap_close(s1ap2);\n\n    test_ue_remove(test_ue);\n}",
      "cve_list": [
        "CVE-2024-40130"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "open5gs",
      "filepath": "lib/pfcp/context.c",
      "func_name": "ogs_pfcp_context_init",
      "func_body": "void ogs_pfcp_context_init(void)\n{\n    int i;\n    ogs_assert(context_initialized == 0);\n\n    /* Initialize SMF context */\n    memset(&self, 0, sizeof(ogs_pfcp_context_t));\n\n    self.local_recovery = ogs_time_ntp32_now();\n\n    ogs_log_install_domain(&__ogs_pfcp_domain, \"pfcp\", ogs_core()->log.level);\n\n    ogs_pool_init(&ogs_pfcp_node_pool, ogs_app()->pool.nf);\n\n    ogs_pool_init(&ogs_pfcp_sess_pool, ogs_app()->pool.sess);\n\n    ogs_pool_init(&ogs_pfcp_far_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_FAR);\n    ogs_pool_init(&ogs_pfcp_urr_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_URR);\n    ogs_pool_init(&ogs_pfcp_qer_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_QER);\n    ogs_pool_init(&ogs_pfcp_bar_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_BAR);\n\n    ogs_pool_init(&ogs_pfcp_pdr_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_PDR);\n    ogs_pool_init(&ogs_pfcp_pdr_teid_pool, ogs_pfcp_pdr_pool.size);\n    ogs_pool_random_id_generate(&ogs_pfcp_pdr_teid_pool);\n\n    pdr_random_to_index = ogs_calloc(\n            sizeof(ogs_pool_id_t), ogs_pfcp_pdr_pool.size+1);\n    ogs_assert(pdr_random_to_index);\n    for (i = 0; i < ogs_pfcp_pdr_pool.size; i++)\n        pdr_random_to_index[ogs_pfcp_pdr_teid_pool.array[i]] = i;\n\n    ogs_pool_init(&ogs_pfcp_rule_pool,\n            ogs_app()->pool.sess *\n            OGS_MAX_NUM_OF_PDR * OGS_MAX_NUM_OF_FLOW_IN_PDR);\n\n    ogs_pool_init(&ogs_pfcp_dev_pool, OGS_MAX_NUM_OF_DEV);\n    ogs_pool_init(&ogs_pfcp_subnet_pool, OGS_MAX_NUM_OF_SUBNET);\n\n    self.object_teid_hash = ogs_hash_make();\n    ogs_assert(self.object_teid_hash);\n    self.far_f_teid_hash = ogs_hash_make();\n    ogs_assert(self.far_f_teid_hash);\n    self.far_teid_hash = ogs_hash_make();\n    ogs_assert(self.far_teid_hash);\n\n    context_initialized = 1;\n}",
      "cve_list": [
        "CVE-2024-40129"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "onnx",
      "filepath": "onnx/common/assertions.cc",
      "func_name": "ONNX_NAMESPACE::barf",
      "func_body": "std::string barf(const char* fmt, ...) {\n  constexpr size_t buffer_size = 2048;\n  std::array<char, buffer_size> msg{};\n  va_list args;\n\n  va_start(args, fmt);\n\n  // use fixed length for buffer \"msg\" to avoid buffer overflow\n  vsnprintf(static_cast<char*>(msg.data()), msg.size() - 1, fmt, args);\n\n  // ensure null-terminated string to avoid out of bounds read\n  msg.back() = '\\0';\n  va_end(args);\n\n  return std::string(msg.data());\n}",
      "cve_list": [
        "CVE-2024-27319"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "onnx",
      "filepath": "onnx/checker.cc",
      "func_name": "ONNX_NAMESPACE::checker::check_tensor",
      "func_body": "void check_tensor(const TensorProto& tensor, const CheckerContext& ctx) {\n  enforce_has_field(tensor, data_type);\n  if (tensor.data_type() == TensorProto::UNDEFINED) {\n    fail_check(\"setting data_type field (tensor name: \", tensor.name(), \") to UNDEFINED is not allowed\");\n  }\n\n  int num_value_fields = 0;\n\n  const char* value_field = nullptr;\n\n#define check_data_field(field)             \\\n  bool has_##field = tensor.field().size(); \\\n  if (has_##field) {                        \\\n    ++num_value_fields;                     \\\n    value_field = #field;                   \\\n  }\n\n  check_data_field(float_data);\n  check_data_field(int32_data);\n  check_data_field(string_data);\n  check_data_field(int64_data);\n  check_data_field(raw_data);\n  check_data_field(double_data);\n  check_data_field(uint64_data);\n\n#undef check_data_field\n\n  bool stored_externally = tensor.has_data_location() && tensor.data_location() == TensorProto::EXTERNAL;\n  if (stored_externally) {\n    if (num_value_fields != 0) {\n      fail_check(\n          \"Data of TensorProto ( tensor name: \",\n          tensor.name(),\n          \") is stored externally and should not have data field.\",\n          value_field);\n    }\n\n    bool has_location = false;\n    for (const StringStringEntryProto& entry : tensor.external_data()) {\n      if (entry.has_key() && entry.has_value() && entry.key() == \"location\") {\n        has_location = true;\n        resolve_external_data_location(ctx.get_model_dir(), entry.value(), tensor.name());\n      }\n    }\n    if (!has_location) {\n      fail_check(\"TensorProto ( tensor name: \", tensor.name(), \") is stored externally but doesn't have a location.\");\n    }\n    return;\n  }\n  int64_t nelem = 1;\n  for (auto x : tensor.dims()) {\n    nelem *= x;\n  }\n  if (nelem == 0 && num_value_fields != 0) {\n    fail_check(\"TensorProto (tensor name: \", tensor.name(), \") is 0-element but contains data!\");\n  }\n  if (nelem != 0 && num_value_fields != 1) {\n    fail_check(\"TensorProto (tensor name: \", tensor.name(), \") should contain one and only one value field.\");\n  }\n  if (has_raw_data) {\n    if (tensor.data_type() == TensorProto::STRING) {\n      fail_check(\"STRING data (tensor name: \", tensor.name(), \") should not be stored in raw_data field\");\n    }\n    return;\n  } else {\n#define check_field(field)               \\\n  if (nelem != 0 && !has_##field) {      \\\n    fail_check(                          \\\n        \"values of data_type '\",         \\\n        tensor.data_type(),              \\\n        \"' should be stored in field '\", \\\n        #field,                          \\\n        \"' instead of '\",                \\\n        value_field,                     \\\n        \"'\");                            \\\n  }\n\n    switch (tensor.data_type()) {\n      case TensorProto::FLOAT:\n      case TensorProto::COMPLEX64:\n        check_field(float_data);\n        break;\n\n      case TensorProto::DOUBLE:\n      case TensorProto::COMPLEX128:\n        check_field(double_data);\n        break;\n\n      case TensorProto::INT32:\n      case TensorProto::UINT8:\n      case TensorProto::INT8:\n      case TensorProto::UINT16:\n      case TensorProto::INT16:\n      case TensorProto::BOOL:\n      case TensorProto::FLOAT16:\n      case TensorProto::BFLOAT16:\n      case TensorProto::FLOAT8E4M3FN:\n      case TensorProto::FLOAT8E4M3FNUZ:\n      case TensorProto::FLOAT8E5M2:\n      case TensorProto::FLOAT8E5M2FNUZ:\n      case TensorProto::UINT4:\n      case TensorProto::INT4:\n        check_field(int32_data);\n        break;\n\n      case TensorProto::INT64:\n        check_field(int64_data);\n        break;\n\n      case TensorProto::UINT32:\n      case TensorProto::UINT64:\n        check_field(uint64_data);\n        break;\n\n      case TensorProto::STRING:\n        check_field(string_data);\n        break;\n\n      default:\n        fail_check(\"Unrecognized data_type (tensor name: \", tensor.name(), \"): \", tensor.data_type());\n    }\n  }\n\n#undef check_field\n}",
      "cve_list": [
        "CVE-2024-27318"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "onnx",
      "filepath": "onnx/checker.cc",
      "func_name": "ONNX_NAMESPACE::checker::resolve_external_data_location",
      "func_body": "std::string resolve_external_data_location(\n    const std::string& base_dir,\n    const std::string& location,\n    const std::string& tensor_name) {\n#ifdef _WIN32\n  auto file_path = std::filesystem::path(utf8str_to_wstring(location));\n  if (file_path.is_absolute()) {\n    fail_check(\n        \"Location of external TensorProto ( tensor name: \",\n        tensor_name,\n        \") should be a relative path, but it is an absolute path: \",\n        location);\n  }\n  auto relative_path = file_path.lexically_normal().make_preferred().wstring();\n  // Check that normalized relative path contains \"..\" on Windows.\n  if (relative_path.find(L\"..\", 0) != std::string::npos) {\n    fail_check(\n        \"Data of TensorProto ( tensor name: \",\n        tensor_name,\n        \") should be file inside the \",\n        base_dir,\n        \", but the '\",\n        location,\n        \"' points outside the directory\");\n  }\n  std::wstring data_path = path_join(utf8str_to_wstring(base_dir), relative_path);\n  struct _stat64 buff;\n  if (data_path.empty() || (data_path[0] != '#' && _wstat64(data_path.c_str(), &buff) != 0)) {\n    fail_check(\n        \"Data of TensorProto ( tensor name: \",\n        tensor_name,\n        \") should be stored in \",\n        location,\n        \", but it doesn't exist or is not accessible.\");\n  }\n  return wstring_to_utf8str(data_path);\n#else // POSIX\n  if (location.empty()) {\n    fail_check(\"Location of external TensorProto ( tensor name: \", tensor_name, \") should not be empty.\");\n  } else if (location[0] == '/') {\n    fail_check(\n        \"Location of external TensorProto ( tensor name: \",\n        tensor_name,\n        \") should be a relative path, but it is an absolute path: \",\n        location);\n  }\n  std::string relative_path = clean_relative_path(location);\n  // Check that normalized relative path contains \"..\" on POSIX\n  if (relative_path.find(\"..\", 0) != std::string::npos) {\n    fail_check(\n        \"Data of TensorProto ( tensor name: \",\n        tensor_name,\n        \") should be file inside the \",\n        base_dir,\n        \", but the '\",\n        location,\n        \"' points outside the directory\");\n  }\n  std::string data_path = path_join(base_dir, relative_path);\n  // use stat64 to check whether the file exists\n#if defined(__APPLE__) || defined(__wasm__) || !defined(__GLIBC__)\n  struct stat buffer; // APPLE, wasm and non-glic stdlibs do not have stat64\n  if (data_path.empty() || (data_path[0] != '#' && stat((data_path).c_str(), &buffer) != 0)) {\n#else\n  struct stat64 buffer; // All POSIX under glibc except APPLE and wasm have stat64\n  if (data_path.empty() || (data_path[0] != '#' && stat64((data_path).c_str(), &buffer) != 0)) {\n#endif\n    fail_check(\n        \"Data of TensorProto ( tensor name: \",\n        tensor_name,\n        \") should be stored in \",\n        data_path,\n        \", but it doesn't exist or is not accessible.\");\n  }\n  // Do not allow symlinks or directories.\n  if (data_path.empty() || (data_path[0] != '#' && !S_ISREG(buffer.st_mode))) {\n    fail_check(\n        \"Data of TensorProto ( tensor name: \",\n        tensor_name,\n        \") should be stored in \",\n        data_path,\n        \", but it is not regular file.\");\n  }\n  return data_path;\n#endif\n}\n\nstd::set<std::string> experimental_ops = {\n    \"ATen\",\n    \"Affine\",\n    \"ConstantFill\",\n    \"Crop\",\n    \"DynamicSlice\",\n    \"GRUUnit\",\n    \"GivenTensorFill\",\n    \"ImageScaler\",\n    \"ParametricSoftplus\",\n    \"Scale\",\n    \"ScaledTanh\"};\n\nbool check_is_experimental_op(const NodeProto& node) {\n  return (node.domain() == ONNX_DOMAIN || node.domain() == \"ai.onnx\") && experimental_ops.count(node.op_type());\n}\n\n#undef enforce_has_field\n#undef enforce_non_empty_field\n\n} // namespace checker",
      "cve_list": [
        "CVE-2024-27318"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "onnx",
      "filepath": "onnx/cpp2py_export.cc",
      "func_name": "ONNX_NAMESPACE::PYBIND11_MODULE",
      "func_body": "PYBIND11_MODULE(onnx_cpp2py_export, onnx_cpp2py_export) {\n  onnx_cpp2py_export.doc() = \"Python interface to ONNX\";\n\n  onnx_cpp2py_export.attr(\"ONNX_ML\") = py::bool_(\n#ifdef ONNX_ML\n      true\n#else // ONNX_ML\n      false\n#endif // ONNX_ML\n  );\n\n  // Submodule `schema`\n  auto defs = onnx_cpp2py_export.def_submodule(\"defs\");\n  defs.doc() = \"Schema submodule\";\n  py::register_exception<SchemaError>(defs, \"SchemaError\");\n\n  py::class_<OpSchema> op_schema(defs, \"OpSchema\", \"Schema of an operator.\");\n\n  // Define the class enums first because they are used as default values in function definitions\n  py::enum_<OpSchema::FormalParameterOption>(op_schema, \"FormalParameterOption\")\n      .value(\"Single\", OpSchema::Single)\n      .value(\"Optional\", OpSchema::Optional)\n      .value(\"Variadic\", OpSchema::Variadic);\n\n  py::enum_<OpSchema::DifferentiationCategory>(op_schema, \"DifferentiationCategory\")\n      .value(\"Unknown\", OpSchema::Unknown)\n      .value(\"Differentiable\", OpSchema::Differentiable)\n      .value(\"NonDifferentiable\", OpSchema::NonDifferentiable);\n\n  py::enum_<AttributeProto::AttributeType>(op_schema, \"AttrType\")\n      .value(\"FLOAT\", AttributeProto::FLOAT)\n      .value(\"INT\", AttributeProto::INT)\n      .value(\"STRING\", AttributeProto::STRING)\n      .value(\"TENSOR\", AttributeProto::TENSOR)\n      .value(\"GRAPH\", AttributeProto::GRAPH)\n      .value(\"FLOATS\", AttributeProto::FLOATS)\n      .value(\"INTS\", AttributeProto::INTS)\n      .value(\"STRINGS\", AttributeProto::STRINGS)\n      .value(\"TENSORS\", AttributeProto::TENSORS)\n      .value(\"GRAPHS\", AttributeProto::GRAPHS)\n      .value(\"SPARSE_TENSOR\", AttributeProto::SPARSE_TENSOR)\n      .value(\"SPARSE_TENSORS\", AttributeProto::SPARSE_TENSORS)\n      .value(\"TYPE_PROTO\", AttributeProto::TYPE_PROTO)\n      .value(\"TYPE_PROTOS\", AttributeProto::TYPE_PROTOS);\n\n  py::enum_<OpSchema::SupportType>(op_schema, \"SupportType\")\n      .value(\"COMMON\", OpSchema::SupportType::COMMON)\n      .value(\"EXPERIMENTAL\", OpSchema::SupportType::EXPERIMENTAL);\n\n  py::class_<OpSchema::Attribute>(op_schema, \"Attribute\")\n      .def(\n          py::init([](std::string name, AttributeProto::AttributeType type, std::string description, bool required) {\n            // Construct an attribute.\n            // Use a lambda to swap the order of the arguments to match the Python API\n            return OpSchema::Attribute(std::move(name), std::move(description), type, required);\n          }),\n          py::arg(\"name\"),\n          py::arg(\"type\"),\n          py::arg(\"description\") = \"\",\n          py::kw_only(),\n          py::arg(\"required\") = true)\n      .def(\n          py::init([](std::string name, const py::object& default_value, std::string description) {\n            // Construct an attribute with a default value.\n            // Attributes with default values are not required\n            auto bytes = default_value.attr(\"SerializeToString\")().cast<py::bytes>();\n            AttributeProto proto{};\n            ParseProtoFromPyBytes(&proto, bytes);\n            return OpSchema::Attribute(std::move(name), std::move(description), std::move(proto));\n          }),\n          py::arg(\"name\"),\n          py::arg(\"default_value\"), // type: onnx.AttributeProto\n          py::arg(\"description\") = \"\")\n      .def_readonly(\"name\", &OpSchema::Attribute::name)\n      .def_readonly(\"description\", &OpSchema::Attribute::description)\n      .def_readonly(\"type\", &OpSchema::Attribute::type)\n      .def_property_readonly(\n          \"_default_value\",\n          [](OpSchema::Attribute* attr) -> py::bytes {\n            std::string out;\n            attr->default_value.SerializeToString(&out);\n            return out;\n          })\n      .def_readonly(\"required\", &OpSchema::Attribute::required);\n\n  py::class_<OpSchema::TypeConstraintParam>(op_schema, \"TypeConstraintParam\")\n      .def(\n          py::init<std::string, std::vector<std::string>, std::string>(),\n          py::arg(\"type_param_str\"),\n          py::arg(\"allowed_type_strs\"),\n          py::arg(\"description\") = \"\")\n      .def_readonly(\"type_param_str\", &OpSchema::TypeConstraintParam::type_param_str)\n      .def_readonly(\"allowed_type_strs\", &OpSchema::TypeConstraintParam::allowed_type_strs)\n      .def_readonly(\"description\", &OpSchema::TypeConstraintParam::description);\n\n  py::class_<OpSchema::FormalParameter>(op_schema, \"FormalParameter\")\n      .def(\n          py::init([](std::string name,\n                      std::string type_str,\n                      const std::string& description,\n                      OpSchema::FormalParameterOption param_option,\n                      bool is_homogeneous,\n                      int min_arity,\n                      OpSchema::DifferentiationCategory differentiation_category) {\n            // Use a lambda to swap the order of the arguments to match the Python API\n            return OpSchema::FormalParameter(\n                std::move(name),\n                description,\n                std::move(type_str),\n                param_option,\n                is_homogeneous,\n                min_arity,\n                differentiation_category);\n          }),\n          py::arg(\"name\"),\n          py::arg(\"type_str\"),\n          py::arg(\"description\") = \"\",\n          py::kw_only(),\n          py::arg(\"param_option\") = OpSchema::Single,\n          py::arg(\"is_homogeneous\") = true,\n          py::arg(\"min_arity\") = 1,\n          py::arg(\"differentiation_category\") = OpSchema::DifferentiationCategory::Unknown)\n\n      .def_property_readonly(\"name\", &OpSchema::FormalParameter::GetName)\n      .def_property_readonly(\"types\", &OpSchema::FormalParameter::GetTypes)\n      .def_property_readonly(\"type_str\", &OpSchema::FormalParameter::GetTypeStr)\n      .def_property_readonly(\"description\", &OpSchema::FormalParameter::GetDescription)\n      .def_property_readonly(\"option\", &OpSchema::FormalParameter::GetOption)\n      .def_property_readonly(\"is_homogeneous\", &OpSchema::FormalParameter::GetIsHomogeneous)\n      .def_property_readonly(\"min_arity\", &OpSchema::FormalParameter::GetMinArity)\n      .def_property_readonly(\"differentiation_category\", &OpSchema::FormalParameter::GetDifferentiationCategory);\n\n  op_schema\n      .def(\n          py::init([](std::string name,\n                      std::string domain,\n                      int since_version,\n                      std::string doc,\n                      std::vector<OpSchema::FormalParameter> inputs,\n                      std::vector<OpSchema::FormalParameter> outputs,\n                      std::vector<std::tuple<std::string, std::vector<std::string>, std::string>> type_constraints,\n                      std::vector<OpSchema::Attribute> attributes) {\n            auto self = OpSchema();\n\n            self.SetName(std::move(name)).SetDomain(std::move(domain)).SinceVersion(since_version).SetDoc(doc);\n            // Add inputs and outputs\n            for (auto i = 0; i < inputs.size(); ++i) {\n              self.Input(i, std::move(inputs[i]));\n            }\n            for (auto i = 0; i < outputs.size(); ++i) {\n              self.Output(i, std::move(outputs[i]));\n            }\n            // Add type constraints\n            for (auto& type_constraint : type_constraints) {\n              std::string type_str;\n              std::vector<std::string> constraints;\n              std::string description;\n              tie(type_str, constraints, description) = std::move(type_constraint);\n              self.TypeConstraint(std::move(type_str), std::move(constraints), std::move(description));\n            }\n            // Add attributes\n            for (auto& attribute : attributes) {\n              self.Attr(std::move(attribute));\n            }\n\n            self.Finalize();\n\n            return self;\n          }),\n          py::arg(\"name\"),\n          py::arg(\"domain\"),\n          py::arg(\"since_version\"),\n          py::arg(\"doc\") = \"\",\n          py::kw_only(),\n          py::arg(\"inputs\") = std::vector<OpSchema::FormalParameter>{},\n          py::arg(\"outputs\") = std::vector<OpSchema::FormalParameter>{},\n          py::arg(\"type_constraints\") = std::vector<std::tuple<\n              std::string /* type_str */,\n              std::vector<std::string> /* constraints */,\n              std::string /* description */>>{},\n          py::arg(\"attributes\") = std::vector<OpSchema::Attribute>{})\n      .def_property(\"name\", &OpSchema::Name, [](OpSchema& self, const std::string& name) { self.SetName(name); })\n      .def_property(\n          \"domain\", &OpSchema::domain, [](OpSchema& self, const std::string& domain) { self.SetDomain(domain); })\n      .def_property(\"doc\", &OpSchema::doc, [](OpSchema& self, const std::string& doc) { self.SetDoc(doc); })\n      .def_property_readonly(\"file\", &OpSchema::file)\n      .def_property_readonly(\"line\", &OpSchema::line)\n      .def_property_readonly(\"support_level\", &OpSchema::support_level)\n      .def_property_readonly(\"since_version\", &OpSchema::since_version)\n      .def_property_readonly(\"deprecated\", &OpSchema::deprecated)\n      .def_property_readonly(\"function_opset_versions\", &OpSchema::function_opset_versions)\n      .def_property_readonly(\n          \"context_dependent_function_opset_versions\", &OpSchema::context_dependent_function_opset_versions)\n      .def_property_readonly(\n          \"all_function_opset_versions\",\n          [](OpSchema* op) -> std::vector<int> {\n            std::vector<int> all_function_opset_versions = op->function_opset_versions();\n            std::vector<int> context_dependent_function_opset_versions =\n                op->context_dependent_function_opset_versions();\n            all_function_opset_versions.insert(\n                all_function_opset_versions.end(),\n                context_dependent_function_opset_versions.begin(),\n                context_dependent_function_opset_versions.end());\n            std::sort(all_function_opset_versions.begin(), all_function_opset_versions.end());\n            all_function_opset_versions.erase(\n                std::unique(all_function_opset_versions.begin(), all_function_opset_versions.end()),\n                all_function_opset_versions.end());\n            return all_function_opset_versions;\n          })\n      .def_property_readonly(\"min_input\", &OpSchema::min_input)\n      .def_property_readonly(\"max_input\", &OpSchema::max_input)\n      .def_property_readonly(\"min_output\", &OpSchema::min_output)\n      .def_property_readonly(\"max_output\", &OpSchema::max_output)\n      .def_property_readonly(\"attributes\", &OpSchema::attributes)\n      .def_property_readonly(\"inputs\", &OpSchema::inputs)\n      .def_property_readonly(\"outputs\", &OpSchema::outputs)\n      .def_property_readonly(\"has_type_and_shape_inference_function\", &OpSchema::has_type_and_shape_inference_function)\n      .def_property_readonly(\"has_data_propagation_function\", &OpSchema::has_data_propagation_function)\n      .def_property_readonly(\"type_constraints\", &OpSchema::typeConstraintParams)\n      .def_static(\"is_infinite\", [](int v) { return v == std::numeric_limits<int>::max(); })\n      .def(\n          \"_infer_node_outputs\",\n          CallNodeInferenceFunction,\n          py::arg(\"nodeBytes\"),\n          py::arg(\"valueTypesByNameBytes\"),\n          py::arg(\"inputDataByNameBytes\") = std::unordered_map<std::string, py::bytes>{},\n          py::arg(\"inputSparseDataByNameBytes\") = std::unordered_map<std::string, py::bytes>{},\n          py::arg(\"opsetImports\") = std::unordered_map<std::string, int>{},\n          py::arg(\"irVersion\") = int(IR_VERSION))\n      .def_property_readonly(\"has_function\", &OpSchema::HasFunction)\n      .def_property_readonly(\n          \"_function_body\",\n          [](OpSchema* op) -> py::bytes {\n            std::string bytes = \"\";\n            if (op->HasFunction())\n              op->GetFunction()->SerializeToString(&bytes);\n            return py::bytes(bytes);\n          })\n      .def(\n          \"get_function_with_opset_version\",\n          [](OpSchema* op, int opset_version) -> py::bytes {\n            std::string bytes = \"\";\n            const FunctionProto* function_proto = op->GetFunction(opset_version);\n            if (function_proto) {\n              function_proto->SerializeToString(&bytes);\n            }\n            return py::bytes(bytes);\n          })\n      .def_property_readonly(\"has_context_dependent_function\", &OpSchema::HasContextDependentFunction)\n      .def(\n          \"get_context_dependent_function\",\n          [](OpSchema* op, const py::bytes& bytes, const std::vector<py::bytes>& input_types_bytes) -> py::bytes {\n            NodeProto proto{};\n            ParseProtoFromPyBytes(&proto, bytes);\n            std::string func_bytes = \"\";\n            if (op->HasContextDependentFunction()) {\n              std::vector<TypeProto> input_types;\n              input_types.reserve(input_types_bytes.size());\n              for (auto& type_bytes : input_types_bytes) {\n                TypeProto type_proto{};\n                ParseProtoFromPyBytes(&type_proto, type_bytes);\n                input_types.push_back(type_proto);\n              }\n              FunctionBodyBuildContextImpl ctx(proto, input_types);\n              FunctionProto func_proto;\n              op->BuildContextDependentFunction(ctx, func_proto);\n              func_proto.SerializeToString(&func_bytes);\n            }\n            return py::bytes(func_bytes);\n          })\n      .def(\n          \"get_context_dependent_function_with_opset_version\",\n          [](OpSchema* op, int opset_version, const py::bytes& bytes, const std::vector<py::bytes>& input_types_bytes)\n              -> py::bytes {\n            NodeProto proto{};\n            ParseProtoFromPyBytes(&proto, bytes);\n            std::string func_bytes = \"\";\n            if (op->HasContextDependentFunctionWithOpsetVersion(opset_version)) {\n              std::vector<TypeProto> input_types;\n              input_types.reserve(input_types_bytes.size());\n              for (auto& type_bytes : input_types_bytes) {\n                TypeProto type_proto{};\n                ParseProtoFromPyBytes(&type_proto, type_bytes);\n                input_types.push_back(type_proto);\n              }\n              FunctionBodyBuildContextImpl ctx(proto, input_types);\n              FunctionProto func_proto;\n              op->BuildContextDependentFunction(ctx, func_proto, opset_version);\n              func_proto.SerializeToString(&func_bytes);\n            }\n            return py::bytes(func_bytes);\n          });\n\n  defs.def(\n          \"has_schema\",\n          [](const std::string& op_type, const std::string& domain) -> bool {\n            return OpSchemaRegistry::Schema(op_type, domain) != nullptr;\n          },\n          \"op_type\"_a,\n          \"domain\"_a = ONNX_DOMAIN)\n      .def(\n          \"schema_version_map\",\n          []() -> std::unordered_map<std::string, std::pair<int, int>> {\n            return OpSchemaRegistry::DomainToVersionRange::Instance().Map();\n          })\n      .def(\n          \"get_schema\",\n          [](const std::string& op_type, const int max_inclusive_version, const std::string& domain) -> OpSchema {\n            const auto* schema = OpSchemaRegistry::Schema(op_type, max_inclusive_version, domain);\n            if (!schema) {\n              fail_schema(\n                  \"No schema registered for '\" + op_type + \"' version '\" + std::to_string(max_inclusive_version) +\n                  \"' and domain '\" + domain + \"'!\");\n            }\n            return *schema;\n          },\n          \"op_type\"_a,\n          \"max_inclusive_version\"_a,\n          \"domain\"_a = ONNX_DOMAIN,\n          \"Return the schema of the operator *op_type* and for a specific version.\")\n      .def(\n          \"get_schema\",\n          [](const std::string& op_type, const std::string& domain) -> OpSchema {\n            const auto* schema = OpSchemaRegistry::Schema(op_type, domain);\n            if (!schema) {\n              fail_schema(\"No schema registered for '\" + op_type + \"' and domain '\" + domain + \"'!\");\n            }\n            return *schema;\n          },\n          \"op_type\"_a,\n          \"domain\"_a = ONNX_DOMAIN,\n          \"Return the schema of the operator *op_type* and for a specific version.\")\n      .def(\n          \"get_all_schemas\",\n          []() -> const std::vector<OpSchema> { return OpSchemaRegistry::get_all_schemas(); },\n          \"Return the schema of all existing operators for the latest version.\")\n      .def(\n          \"get_all_schemas_with_history\",\n          []() -> const std::vector<OpSchema> { return OpSchemaRegistry::get_all_schemas_with_history(); },\n          \"Return the schema of all existing operators and all versions.\");\n\n  // Submodule `checker`\n  auto checker = onnx_cpp2py_export.def_submodule(\"checker\");\n  checker.doc() = \"Checker submodule\";\n\n  py::class_<checker::CheckerContext> checker_context(checker, \"CheckerContext\");\n  checker_context.def(py::init<>())\n      .def_property(\"ir_version\", &checker::CheckerContext::get_ir_version, &checker::CheckerContext::set_ir_version)\n      .def_property(\n          \"opset_imports\", &checker::CheckerContext::get_opset_imports, &checker::CheckerContext::set_opset_imports);\n\n  py::class_<checker::LexicalScopeContext> lexical_scope_context(checker, \"LexicalScopeContext\");\n  lexical_scope_context.def(py::init<>());\n\n  py::register_exception<checker::ValidationError>(checker, \"ValidationError\");\n\n  checker.def(\"check_value_info\", [](const py::bytes& bytes, const checker::CheckerContext& ctx) -> void {\n    ValueInfoProto proto{};\n    ParseProtoFromPyBytes(&proto, bytes);\n    checker::check_value_info(proto, ctx);\n  });\n\n  checker.def(\"check_tensor\", [](const py::bytes& bytes, const checker::CheckerContext& ctx) -> void {\n    TensorProto proto{};\n    ParseProtoFromPyBytes(&proto, bytes);\n    checker::check_tensor(proto, ctx);\n  });\n\n  checker.def(\"check_sparse_tensor\", [](const py::bytes& bytes, const checker::CheckerContext& ctx) -> void {\n    SparseTensorProto proto{};\n    ParseProtoFromPyBytes(&proto, bytes);\n    checker::check_sparse_tensor(proto, ctx);\n  });\n\n  checker.def(\n      \"check_attribute\",\n      [](const py::bytes& bytes,\n         const checker::CheckerContext& ctx,\n         const checker::LexicalScopeContext& lex_ctx) -> void {\n        AttributeProto proto{};\n        ParseProtoFromPyBytes(&proto, bytes);\n        checker::check_attribute(proto, ctx, lex_ctx);\n      });\n\n  checker.def(\n      \"check_node\",\n      [](const py::bytes& bytes,\n         const checker::CheckerContext& ctx,\n         const checker::LexicalScopeContext& lex_ctx) -> void {\n        NodeProto proto{};\n        ParseProtoFromPyBytes(&proto, bytes);\n        checker::check_node(proto, ctx, lex_ctx);\n      });\n\n  checker.def(\n      \"check_function\",\n      [](const py::bytes& bytes,\n         const checker::CheckerContext& ctx,\n         const checker::LexicalScopeContext& lex_ctx) -> void {\n        FunctionProto proto{};\n        ParseProtoFromPyBytes(&proto, bytes);\n        checker::check_function(proto, ctx, lex_ctx);\n      });\n\n  checker.def(\n      \"check_graph\",\n      [](const py::bytes& bytes,\n         const checker::CheckerContext& ctx,\n         const checker::LexicalScopeContext& lex_ctx) -> void {\n        GraphProto proto{};\n        ParseProtoFromPyBytes(&proto, bytes);\n        checker::check_graph(proto, ctx, lex_ctx);\n      });\n\n  checker.def(\n      \"check_model\",\n      [](const py::bytes& bytes, bool full_check, bool skip_opset_compatibility_check) -> void {\n        ModelProto proto{};\n        ParseProtoFromPyBytes(&proto, bytes);\n        checker::check_model(proto, full_check, skip_opset_compatibility_check);\n      },\n      \"bytes\"_a,\n      \"full_check\"_a = false,\n      \"skip_opset_compatibility_check\"_a = false);\n\n  checker.def(\n      \"check_model_path\",\n      (void (*)(const std::string& path, bool full_check, bool skip_opset_compatibility_check)) & checker::check_model,\n      \"path\"_a,\n      \"full_check\"_a = false,\n      \"skip_opset_compatibility_check\"_a = false);\n\n  checker.def(\"_resolve_external_data_location\", &checker::resolve_external_data_location);\n\n  // Submodule `version_converter`\n  auto version_converter = onnx_cpp2py_export.def_submodule(\"version_converter\");\n  version_converter.doc() = \"VersionConverter submodule\";\n  py::register_exception<ConvertError>(version_converter, \"ConvertError\");\n\n  version_converter.def(\"convert_version\", [](const py::bytes& bytes, py::int_ target) {\n    ModelProto proto{};\n    ParseProtoFromPyBytes(&proto, bytes);\n    shape_inference::InferShapes(proto);\n    auto result = version_conversion::ConvertVersion(proto, target);\n    std::string out;\n    result.SerializeToString(&out);\n    return py::bytes(out);\n  });\n\n  // Submodule `inliner`\n  auto inliner = onnx_cpp2py_export.def_submodule(\"inliner\");\n  inliner.doc() = \"Inliner submodule\";\n\n  inliner.def(\"inline_local_functions\", [](const py::bytes& bytes, bool convert_version) {\n    ModelProto model{};\n    ParseProtoFromPyBytes(&model, bytes);\n    inliner::InlineLocalFunctions(model, convert_version);\n    std::string out;\n    model.SerializeToString(&out);\n    return py::bytes(out);\n  });\n\n  // inline_selected_functions: Inlines all functions specified in function_ids, unless\n  // exclude is true, in which case it inlines all functions except those specified in\n  // function_ids.\n  inliner.def(\n      \"inline_selected_functions\",\n      [](const py::bytes& bytes, std::vector<std::pair<std::string, std::string>> function_ids, bool exclude) {\n        ModelProto model{};\n        ParseProtoFromPyBytes(&model, bytes);\n        auto function_id_set = inliner::FunctionIdSet::Create(std::move(function_ids), exclude);\n        inliner::InlineSelectedFunctions(model, *function_id_set);\n        std::string out;\n        model.SerializeToString(&out);\n        return py::bytes(out);\n      });\n\n  // Submodule `shape_inference`\n  auto shape_inference = onnx_cpp2py_export.def_submodule(\"shape_inference\");\n  shape_inference.doc() = \"Shape Inference submodule\";\n  py::register_exception<InferenceError>(shape_inference, \"InferenceError\");\n\n  shape_inference.def(\n      \"infer_shapes\",\n      [](const py::bytes& bytes, bool check_type, bool strict_mode, bool data_prop) {\n        ModelProto proto{};\n        ParseProtoFromPyBytes(&proto, bytes);\n        ShapeInferenceOptions options{check_type, strict_mode == true ? 1 : 0, data_prop};\n        shape_inference::InferShapes(proto, OpSchemaRegistry::Instance(), options);\n        std::string out;\n        proto.SerializeToString(&out);\n        return py::bytes(out);\n      },\n      \"bytes\"_a,\n      \"check_type\"_a = false,\n      \"strict_mode\"_a = false,\n      \"data_prop\"_a = false);\n\n  shape_inference.def(\n      \"infer_shapes_path\",\n      [](const std::string& model_path,\n         const std::string& output_path,\n         bool check_type,\n         bool strict_mode,\n         bool data_prop) -> void {\n        ShapeInferenceOptions options{check_type, strict_mode == true ? 1 : 0, data_prop};\n        shape_inference::InferShapes(model_path, output_path, OpSchemaRegistry::Instance(), options);\n      });\n\n  shape_inference.def(\n      \"infer_function_output_types\",\n      [](const py::bytes& function_proto_bytes,\n         const std::vector<py::bytes> input_types_bytes,\n         const std::vector<py::bytes> attributes_bytes) -> std::vector<py::bytes> {\n        FunctionProto proto{};\n        ParseProtoFromPyBytes(&proto, function_proto_bytes);\n\n        std::vector<TypeProto> input_types;\n        input_types.reserve(input_types_bytes.size());\n        for (const py::bytes& bytes : input_types_bytes) {\n          TypeProto type;\n          ParseProtoFromPyBytes(&type, bytes);\n          input_types.push_back(type);\n        }\n\n        std::vector<AttributeProto> attributes;\n        attributes.reserve(attributes_bytes.size());\n        for (const py::bytes& bytes : attributes_bytes) {\n          AttributeProto attr;\n          ParseProtoFromPyBytes(&attr, bytes);\n          attributes.push_back(attr);\n        }\n\n        std::vector<TypeProto> output_types = shape_inference::InferFunctionOutputTypes(proto, input_types, attributes);\n        std::vector<py::bytes> result;\n        result.reserve(output_types.size());\n        for (auto& type_proto : output_types) {\n          std::string out;\n          type_proto.SerializeToString(&out);\n          result.push_back(py::bytes(out));\n        }\n        return result;\n      });\n\n  // Submodule `parser`\n  auto parser = onnx_cpp2py_export.def_submodule(\"parser\");\n  parser.doc() = \"Parser submodule\";\n\n  parser.def(\"parse_model\", Parse<ModelProto>);\n  parser.def(\"parse_graph\", Parse<GraphProto>);\n  parser.def(\"parse_function\", Parse<FunctionProto>);\n  parser.def(\"parse_node\", Parse<NodeProto>);\n\n  // Submodule `printer`\n  auto printer = onnx_cpp2py_export.def_submodule(\"printer\");\n  printer.doc() = \"Printer submodule\";\n\n  printer.def(\"model_to_text\", ProtoBytesToText<ModelProto>);\n  printer.def(\"function_to_text\", ProtoBytesToText<FunctionProto>);\n  printer.def(\"graph_to_text\", ProtoBytesToText<GraphProto>);\n}",
      "cve_list": [
        "CVE-2024-27318"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "rhonabwy",
      "filepath": "src/jws.c",
      "func_name": "r_jws_verify_sig_hmac",
      "func_body": "static int r_jws_verify_sig_hmac(jws_t * jws, jwk_t * jwk) {\n  unsigned char * sig = r_jws_sign_hmac(jws, jwk);\n  int ret;\n\n  if (!o_strnullempty((const char *)jws->signature_b64url) &&\n      !o_strnullempty((const char *)sig) &&\n      o_strlen((const char *)sig) == o_strlen((const char *)jws->signature_b64url) &&\n      0 == gnutls_memcmp(jws->signature_b64url, sig, o_strlen((const char *)sig))) {\n    ret = RHN_OK;\n  } else {\n    ret = RHN_ERROR_INVALID;\n  }\n  o_free(sig);\n  return ret;\n}",
      "cve_list": [
        "CVE-2024-25714"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "pytorch",
      "filepath": "torch/csrc/jit/mobile/interpreter.cpp",
      "func_name": "torch::jit::mobile::InterpreterState::run",
      "func_body": "bool InterpreterState::run(Stack& stack) {\n  while (true) {\n    try {\n      auto& frame = frames_.back();\n      const auto& code = frame.getCode();\n      const auto pc = frame.getPC();\n      auto inst = frame.getInstruction();\n      // If no valid debug handle found then just log pc.\n      // This is possible when we did not save debug handles\n\n      DebugHandle debug_handle = pc;\n      if (auto handle = frame.getDebugHandle()) {\n        debug_handle = *handle;\n      }\n\n      // std::cout << \"RUNNING \" << pc << \" \" << code.instructions_[pc];\n      // if (inst.op == OP) {\n      //   std::cout << \", \" << code.op_names_[inst.X].name;\n      //   if (!code.op_names_[inst.X].overload_name.empty()) {\n      //     std::cout << \".\" << code.op_names_[inst.X].overload_name;\n      //   }\n      // }\n      // std::cout << std::endl;\n\n      // TODO(iliacher): remove the workaround after RecordFunction is in\n      // Dispatcher\n      // Check with iliacher if has been done.\n      // Plus this is not safe as if you throw exception record function will be\n      // left enabled. That is a TODO\n      // NOTE: this recordFunction logic takes up ~2-3% of cpu cycles in some\n      // workflows. do we need it and/or can we opt-out of\n      // isRecordFunctionEnabled with a macro? if we delete it, things appear to\n      // work just fine.\n      bool prev_value = isRecordFunctionEnabled();\n      if (!prev_value) {\n        // enable only for the RecordFunction\n        enableRecordFunction(true);\n      }\n      switch (inst.op) {\n        case OP: {\n          if (at::hasGlobalCallbacks()) {\n            if (auto* mobile_debug_info = static_cast<MobileDebugInfo*>(\n                    c10::ThreadLocalDebugInfo::get(\n                        c10::DebugInfoKind::MOBILE_RUNTIME_INFO))) {\n              mobile_debug_info->setOpIdx(pc);\n            }\n          }\n          if (inst.X < 0 ||\n              static_cast<size_t>(inst.X) >= code.operators_.size()) {\n            throw JITException(\"Invalid OP Instruction\");\n          }\n          RECORD_EDGE_SCOPE_WITH_DEBUG_HANDLE_AND_INPUTS(\n              code.op_names_[inst.X].name, debug_handle, stack);\n          code.operators_[inst.X](stack);\n          frame.step();\n        } break;\n        case OPN: {\n          stack.emplace_back(inst.N);\n          RECORD_EDGE_SCOPE_WITH_DEBUG_HANDLE_AND_INPUTS(\n              code.op_names_[inst.X].name, debug_handle, stack);\n          code.operators_[inst.X](stack);\n          frame.step();\n        } break;\n        case CALL: {\n          auto& function = *frame.getCode().functions_.at(inst.X);\n          callFunction(function, stack);\n        } break;\n        case INTERFACE_CALL: {\n          torch::jit::Function& method =\n              peek(stack, 0, inst.N)\n                  .toObject()\n                  ->type()\n                  ->getMethod(code.constants_[inst.X].toStringRef());\n          RECORD_EDGE_SCOPE_WITH_DEBUG_HANDLE_AND_INPUTS(\n              method.name(), debug_handle, stack);\n          callFunction(method, stack);\n        } break;\n        case LOAD:\n          stack.emplace_back(reg(inst.X));\n          frame.step();\n          break;\n        case MOVE:\n          stack.emplace_back(std::move(reg(inst.X)));\n          frame.step();\n          break;\n        case STORE:\n          reg(inst.X) = pop(stack);\n          frame.step();\n          break;\n        case STOREN:\n          for (size_t i = inst.N; i > 0; --i) {\n            reg(inst.X + i - 1) = pop(stack);\n          }\n          frame.step();\n          break;\n        case DROP:\n          pop(stack);\n          frame.step();\n          break;\n        case DROPR:\n          reg(inst.X) = IValue();\n          frame.step();\n          break;\n        case LOADC:\n          stack.emplace_back(code.constants_[inst.X]);\n          frame.step();\n          break;\n        case GET_ATTR: {\n          auto userObj = pop(stack).toObject();\n          auto value = userObj->getSlot(inst.X);\n          push(stack, std::move(value));\n          frame.step();\n        } break;\n        case SET_ATTR: {\n          auto v = pop(stack);\n          auto userObj = pop(stack).toObject();\n          // Mobile only: since the number of slots is not known, resize the\n          // numAttributes before setSlot.\n          while (static_cast<int>(userObj->type()->numAttributes()) <= inst.X) {\n            std::stringstream ss;\n            ss << userObj->type()->numAttributes();\n            userObj->type()->addAttribute(ss.str(), c10::NoneType::get());\n          }\n          userObj->setSlot(inst.X, std::move(v));\n          frame.step();\n        } break;\n        case JF:\n          frame.jump(pop(stack).toBool() ? 1 : inst.X);\n          break;\n        case JMP:\n          frame.jump(inst.X);\n          break;\n        case LOOP: {\n          // stack: iteration_count, max_iter, cond, loop_carried_deps...\n          auto sframe = stack.end() - (inst.N + 1);\n          int64_t trip_count = sframe[0].toInt();\n          int64_t max_trip_count = sframe[1].toInt();\n          bool cond = sframe[2].toBool();\n          if (trip_count < max_trip_count && cond) {\n            sframe[2] = trip_count;\n            sframe[0] = trip_count + 1;\n            frame.step();\n          } else {\n            size_t n_loop_carried = inst.N - 2;\n            for (const auto i : c10::irange(n_loop_carried)) {\n              sframe[i] = std::move(sframe[i + 3]);\n            }\n            drop(stack, 3); // iteration_count, max_iter, cond\n            frame.jump(inst.X);\n          }\n        } break;\n        case RET:\n          leaveFrame();\n          if (!frames_.empty()) {\n            continue;\n          }\n          return false;\n        case LIST_CONSTRUCT: {\n          listConstruct(stack, *code.types_.at(inst.X), inst.N);\n          frame.step();\n        } break;\n        case LIST_UNPACK: {\n          listUnpack(stack, inst.X);\n          frame.step();\n        } break;\n        case TUPLE_CONSTRUCT: {\n          tupleConstruct(stack, inst.X);\n          frame.step();\n        } break;\n        case TUPLE_SLICE: {\n          tupleSlice(stack, inst.X, inst.X + inst.N);\n          frame.step();\n        } break;\n        case TUPLE_INDEX: {\n          tupleIndex(stack);\n          frame.step();\n        } break;\n        case RAISE_EXCEPTION: {\n          raiseExceptionWithMessage(stack);\n          frame.step();\n        } break;\n        case __IS__: {\n          is(stack);\n          frame.step();\n        } break;\n        case UN_INITIALIZED: {\n          unInitialized(stack);\n          frame.step();\n        } break;\n        case __ISNOT__: {\n          isNot(stack);\n          frame.step();\n        } break;\n        case FORMAT: {\n          format(stack, inst.X);\n          frame.step();\n        } break;\n        case DEVICE: {\n          device(stack);\n          frame.step();\n        } break;\n        case DTYPE: {\n          dtype(stack);\n          frame.step();\n        } break;\n        case DIM: {\n          dim(stack);\n          frame.step();\n        } break;\n        case __NOT__: {\n          _not(stack);\n          frame.step();\n        } break;\n        case DICT_INDEX: {\n          dictIndex(stack);\n          frame.step();\n        } break;\n        case TO_LIST: {\n          toList(stack);\n          frame.step();\n        } break;\n        case NUM_TO_TENSOR: {\n          numToTensorScalar(stack);\n          frame.step();\n        } break;\n        case IS_CUDA: {\n          isCuda(stack);\n          frame.step();\n        } break;\n        case DICT_CONSTRUCT: {\n          dictConstruct(stack, *code.types_.at(inst.X), inst.N);\n          frame.step();\n        } break;\n        case NAMED_TUPLE_CONSTRUCT: {\n          namedTupleConstruct(stack, code.types_.at(inst.X), inst.N);\n          frame.step();\n        } break;\n        case CREATE_OBJECT: {\n          auto type = code.types_.at(inst.X)->expect<c10::ClassType>();\n          createObject(stack, type);\n          frame.step();\n        } break;\n        case ISINSTANCE: {\n          at::ArrayRef<TypePtr> types(&code.types_.at(inst.X), inst.N);\n          isinstance(stack, types);\n          frame.step();\n        } break;\n        case WARN: {\n          drop(stack, 1);\n          // Note: Please don't move the pop(stack) code below into the\n          // TORCH_WARN macro since TORCH_WARN fails to evaluate its arguments\n          // when STRIP_ERROR_MESSAGES is defined (which happens for production\n          // mobile builds). This will cause the stack to be in an inconsistent\n          // state. It has previously resulted in a SEV (S22350).\n          const auto& sref = stack.back().toStringRef();\n          TORCH_WARN(sref);\n          stack.pop_back();\n          frame.step();\n        } break;\n        default:\n          AT_ERROR(toString(inst.op), \" is invalid.\");\n      }\n\n      if (!prev_value) {\n        enableRecordFunction(false);\n      }\n      // This exception must be caught first as it derived from c10::Error\n    } catch (c10::BackendRuntimeException& e) {\n      saveExceptionDebugHandles();\n      TORCH_RETHROW(e);\n    } catch (c10::Error& error) {\n      // Reason for catching and rethrowing the error is so that we can\n      // set the exception pc that is queried later\n      saveExceptionDebugHandles();\n      TORCH_RETHROW(error);\n    } catch (...) {\n      saveExceptionDebugHandles();\n      throw;\n    }\n    //  for (auto val : stack) {\n    //    if (val.isTensor()) {\n    //      std::cout << val.toTensor().sizes() << std::endl;\n    //    } else {\n    //      std::cout << val << std::endl;\n    //    }\n    //  }\n  }\n  return false;\n}",
      "cve_list": [
        "CVE-2024-31583"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "pytorch",
      "filepath": "torch/csrc/jit/runtime/vararg_functions.cpp",
      "func_name": "torch::jit::tupleConstruct",
      "func_body": "void tupleConstruct(Stack& stack, size_t num_inputs) {\n  if (num_inputs > stack.size()) {\n    TORCH_CHECK(false, \"Invalid number of inputs: \", num_inputs);\n  }\n  switch (num_inputs) {\n    case 0:\n      stack.emplace_back(c10::ivalue::Tuple::create());\n      break;\n    case 1:\n      stack.back() = c10::ivalue::Tuple::create(std::move(stack.back()));\n      break;\n    case 2: {\n      auto tuple = c10::ivalue::Tuple::create(\n          std::move(stack[stack.size() - 2]),\n          std::move(stack[stack.size() - 1]));\n      stack.pop_back();\n      stack.back() = std::move(tuple);\n      break;\n    }\n    case 3: {\n      auto tuple = c10::ivalue::Tuple::create(\n          std::move(stack[stack.size() - 3]),\n          std::move(stack[stack.size() - 2]),\n          std::move(stack[stack.size() - 1]));\n      stack.pop_back();\n      stack.pop_back();\n      stack.back() = std::move(tuple);\n      break;\n    }\n    default: {\n      std::vector<IValue> elems{\n          std::make_move_iterator(stack.end() - num_inputs),\n          std::make_move_iterator(stack.end())};\n      drop(stack, num_inputs - 1);\n      stack.back() = c10::ivalue::Tuple::create(std::move(elems));\n      break;\n    }\n  }\n}",
      "cve_list": [
        "CVE-2024-31580"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "pytorch",
      "filepath": "torch/csrc/jit/mobile/flatbuffer_loader.cpp",
      "func_name": "torch::jit::FlatbufferLoader::parseModule",
      "func_body": "mobile::Module FlatbufferLoader::parseModule(\n    mobile::serialization::Module* module,\n    char* end) {\n  module_ = module;\n  all_ivalues_.clear();\n  all_types_.clear();\n  storages_.clear();\n  storage_loaded_.clear();\n  module_parsed_ = false;\n\n  const auto* ivalues = module->ivalues();\n  TORCH_CHECK(\n      ivalues && module->object_types(),\n      \"Parsing flatbuffer module: Corrupted ivalues/object_types field\");\n  TORCH_CHECK(\n      reinterpret_cast<const char*>(ivalues) < end, \"Corrupted ivalues field\");\n  all_ivalues_.resize(ivalues->size());\n  all_types_.resize(module->object_types()->size());\n  storages_.resize(module->storage_data_size());\n  storage_loaded_.resize(module->storage_data_size(), false);\n\n  mobile_ivalue_size_ = module_->mobile_ivalue_size();\n  if (mobile_ivalue_size_ == 0 || mobile_ivalue_size_ > ivalues->size()) {\n    mobile_ivalue_size_ = ivalues->size();\n  }\n\n  for (uint32_t i = 0; i < mobile_ivalue_size_; i++) {\n    const auto* ival = ivalues->Get(i);\n    TORCH_CHECK(\n        reinterpret_cast<const char*>(ival) < end, \"Corrupted ivalue item\")\n    parseAndPopulate(i, ival);\n  }\n  IValue& module_ivalue = getIValue(module->state_obj());\n\n  // register functions\n  for (const auto& f : all_functions_) {\n    uint32_t class_index =\n        ivalues->Get(f.first)->val_as_Function()->class_type();\n    ClassTypePtr class_type = all_types_[class_index];\n    class_type->addMethod(f.second);\n  }\n\n  module_parsed_ = true;\n  auto m = mobile::Module(module_ivalue.toObject(), mcu_);\n  m.set_min_operator_version(module->operator_version());\n  m.set_bytecode_version(module->bytecode_version());\n  return m;\n}",
      "cve_list": [
        "CVE-2024-31584"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "less",
      "filepath": "filename.c",
      "func_name": "metachar",
      "func_body": "static lbool metachar(char c)\n{\n\treturn (strchr(metachars(), c) != NULL);\n}",
      "cve_list": [
        "CVE-2024-32487"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "less",
      "filepath": "filename.c",
      "func_name": "must_quote",
      "func_body": "static lbool must_quote(char c)\n{\n\t/* {{ Maybe the set of must_quote chars should be configurable? }} */\n\treturn (c == '\\n'); \n}",
      "cve_list": [
        "CVE-2024-32487"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "less",
      "filepath": "filename.c",
      "func_name": "shell_quoten",
      "func_body": "public char * shell_quoten(constant char *s, size_t slen)\n{\n\tconstant char *p;\n\tchar *np;\n\tchar *newstr;\n\tsize_t len;\n\tconstant char *esc = get_meta_escape();\n\tsize_t esclen = strlen(esc);\n\tlbool use_quotes = FALSE;\n\tlbool have_quotes = FALSE;\n\n\t/*\n\t * Determine how big a string we need to allocate.\n\t */\n\tlen = 1; /* Trailing null byte */\n\tfor (p = s;  p < s + slen;  p++)\n\t{\n\t\tlen++;\n\t\tif (*p == openquote || *p == closequote)\n\t\t\thave_quotes = TRUE;\n\t\tif (metachar(*p))\n\t\t{\n\t\t\tif (esclen == 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We've got a metachar, but this shell \n\t\t\t\t * doesn't support escape chars.  Use quotes.\n\t\t\t\t */\n\t\t\t\tuse_quotes = TRUE;\n\t\t\t} else if (must_quote(*p))\n\t\t\t{\n\t\t\t\tlen += 3; /* open quote + char + close quote */\n\t\t\t} else\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Allow space for the escape char.\n\t\t\t\t */\n\t\t\t\tlen += esclen;\n\t\t\t}\n\t\t}\n\t}\n\tif (use_quotes)\n\t{\n\t\tif (have_quotes)\n\t\t\t/*\n\t\t\t * We can't quote a string that contains quotes.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\tlen = slen + 3;\n\t}\n\t/*\n\t * Allocate and construct the new string.\n\t */\n\tnewstr = np = (char *) ecalloc(len, sizeof(char));\n\tif (use_quotes)\n\t{\n\t\tSNPRINTF4(newstr, len, \"%c%.*s%c\", openquote, (int) slen, s, closequote);\n\t} else\n\t{\n\t\tconstant char *es = s + slen;\n\t\twhile (s < es)\n\t\t{\n\t\t\tif (!metachar(*s))\n\t\t\t{\n\t\t\t\t*np++ = *s++;\n\t\t\t} else if (must_quote(*s))\n\t\t\t{\n\t\t\t\t/* Surround the char with quotes. */\n\t\t\t\t*np++ = openquote;\n\t\t\t\t*np++ = *s++;\n\t\t\t\t*np++ = closequote;\n\t\t\t} else\n\t\t\t{\n\t\t\t\t/* Insert an escape char before the char. */\n\t\t\t\tstrcpy(np, esc);\n\t\t\t\tnp += esclen;\n\t\t\t\t*np++ = *s++;\n\t\t\t}\n\t\t}\n\t\t*np = '\\0';\n\t}\n\treturn (newstr);\n}",
      "cve_list": [
        "CVE-2024-32487"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "mod_auth_openidc",
      "filepath": "src/util.c",
      "func_name": "oidc_util_get_chunked_cookie",
      "func_body": "char *oidc_util_get_chunked_cookie(request_rec *r, const char *cookieName, int chunkSize) {\n\tchar *cookieValue = NULL, *chunkValue = NULL;\n\tint chunkCount = 0, i = 0;\n\tif (chunkSize == 0)\n\t\treturn oidc_util_get_cookie(r, cookieName);\n\tchunkCount = oidc_util_get_chunked_count(r, cookieName);\n\tif (chunkCount == 0)\n\t\treturn oidc_util_get_cookie(r, cookieName);\n\tif ((chunkCount < 0) || (chunkCount > 99)) {\n\t\toidc_warn(r, \"chunk count out of bounds: %d\", chunkCount);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < chunkCount; i++) {\n\t\tchunkValue = oidc_util_get_cookie(r, oidc_util_get_chunk_cookie_name(r, cookieName, i));\n\t\tif (chunkValue == NULL) {\n\t\t\toidc_warn(r, \"could not find chunk %d; aborting\", i);\n\t\t\tbreak;\n\t\t}\n\t\tcookieValue = apr_psprintf(r->pool, \"%s%s\", cookieValue ? cookieValue : \"\", chunkValue);\n\t}\n\treturn cookieValue;\n}",
      "cve_list": [
        "CVE-2024-24814"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "srs",
      "filepath": "trunk/src/protocol/srs_protocol_http_conn.cpp",
      "func_name": "SrsHttpMessage::set_url",
      "func_body": "srs_error_t SrsHttpMessage::set_url(string url, bool allow_jsonp)\n{\n    srs_error_t err = srs_success;\n    \n    _url = url;\n\n    // parse uri from schema/server:port/path?query\n    std::string uri = _url;\n\n    if (!srs_string_contains(uri, \"://\")) {\n        // use server public ip when host not specified.\n        // to make telnet happy.\n        std::string host = _header.get(\"Host\");\n\n        // If no host in header, we use local discovered IP, IPv4 first.\n        if (host.empty()) {\n            host = srs_get_public_internet_address(true);\n        }\n\n        // The url must starts with slash if no schema. For example, SIP request line starts with \"sip\".\n        if (!host.empty() && !srs_string_starts_with(_url, \"/\")) {\n            host += \"/\";\n        }\n\n        if (!host.empty()) {\n            uri = \"http://\" + host + _url;\n        }\n    }\n\n    if ((err = _uri->initialize(uri)) != srs_success) {\n        return srs_error_wrap(err, \"init uri %s\", uri.c_str());\n    }\n    \n    // parse ext.\n    _ext = srs_path_filext(_uri->get_path());\n    \n    // parse query string.\n    srs_parse_query_string(_uri->get_query(), _query);\n    \n    // parse jsonp request message.\n    if (allow_jsonp) {\n        string callback= query_get(\"callback\");\n        jsonp = !callback.empty();\n\n        if (jsonp) {\n            jsonp_method = query_get(\"method\");\n        }\n\n        if (!srs_is_valid_jsonp_callback(callback)) {\n            return srs_error_new(ERROR_HTTP_JSONP, \"invalid callback=%s\", callback.c_str());\n        }\n    }\n    \n    return err;\n}",
      "cve_list": [
        "CVE-2024-29882"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "srs",
      "filepath": "trunk/src/protocol/srs_protocol_http_conn.cpp",
      "func_name": "srs_is_valid_jsonp_callback",
      "func_body": "bool srs_is_valid_jsonp_callback(std::string callback)\n{\n    for (int i = 0; i < (int)callback.length(); i++) {\n        char ch = callback.at(i);\n        bool is_alpha_beta = (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\n        bool is_number = (ch >= '0' && ch <= '9');\n        if (!is_alpha_beta && !is_number && ch != '.' && ch != '_' && ch != '-') {\n            return false;\n        }\n    }\n    return true;\n}",
      "cve_list": [
        "CVE-2024-29882"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "asterisk",
      "filepath": "res/res_pjsip_endpoint_identifier_ip.c",
      "func_name": "ip_identify",
      "func_body": "static struct ast_sip_endpoint *ip_identify(pjsip_rx_data *rdata)\n{\n\tstruct ast_sockaddr addr = { { 0, } };\n\n\tast_sockaddr_parse(&addr, rdata->pkt_info.src_name, PARSE_PORT_FORBID);\n\tast_sockaddr_set_port(&addr, rdata->pkt_info.src_port);\n\n\treturn common_identify(ip_identify_match_check, &addr);\n}",
      "cve_list": [
        "CVE-2024-35190"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "asterisk",
      "filepath": "res/res_pjsip_endpoint_identifier_ip.c",
      "func_name": "ip_identify_match_check",
      "func_body": "static int ip_identify_match_check(void *obj, void *arg, int flags)\n{\n\tstruct ip_identify_match *identify = obj;\n\tstruct ast_sockaddr *addr = arg;\n\tint sense;\n\n\tsense = ast_apply_ha(identify->matches, addr);\n\tif (sense != AST_SENSE_ALLOW) {\n\t\tast_debug(3, \"Source address %s matches identify '%s'\\n\",\n\t\t\t\tast_sockaddr_stringify(addr),\n\t\t\t\tast_sorcery_object_get_id(identify));\n\t\treturn CMP_MATCH;\n\t} else {\n\t\tast_debug(3, \"Source address %s does not match identify '%s'\\n\",\n\t\t\t\tast_sockaddr_stringify(addr),\n\t\t\t\tast_sorcery_object_get_id(identify));\n\t\treturn 0;\n\t}\n}",
      "cve_list": [
        "CVE-2024-35190"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "Fast-DDS",
      "filepath": "src/cpp/rtps/messages/MessageReceiver.cpp",
      "func_name": "eprosima::fastrtps::rtps::MessageReceiver::proc_Submsg_Data",
      "func_body": "bool MessageReceiver::proc_Submsg_Data(\n        CDRMessage_t* msg,\n        SubmessageHeader_t* smh,\n        EntityId_t& writerID,\n        bool was_decoded) const\n{\n    eprosima::shared_lock<eprosima::shared_mutex> guard(mtx_);\n\n    //READ and PROCESS\n    if (smh->submessageLength < RTPSMESSAGE_DATA_MIN_LENGTH)\n    {\n        EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"Too short submessage received, ignoring\");\n        return false;\n    }\n    //Fill flags bool values\n    bool endiannessFlag = (smh->flags & BIT(0)) != 0;\n    bool inlineQosFlag = (smh->flags & BIT(1)) != 0;\n    bool dataFlag = (smh->flags & BIT(2)) != 0;\n    bool keyFlag = (smh->flags & BIT(3)) != 0;\n    if (keyFlag && dataFlag)\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Message received with Data and Key Flag set, ignoring\");\n        return false;\n    }\n\n    //Assign message endianness\n    if (endiannessFlag)\n    {\n        msg->msg_endian = LITTLEEND;\n    }\n    else\n    {\n        msg->msg_endian = BIGEND;\n    }\n\n    //Extra flags don't matter now. Avoid those bytes\n    msg->pos += 2;\n\n    bool valid = true;\n    int16_t octetsToInlineQos = 0;\n    valid &= CDRMessage::readInt16(msg, &octetsToInlineQos); //it should be 16 in this implementation\n\n    //reader and writer ID\n    RTPSReader* first_reader = nullptr;\n    EntityId_t readerID;\n    valid &= CDRMessage::readEntityId(msg, &readerID);\n\n    //WE KNOW THE READER THAT THE MESSAGE IS DIRECTED TO SO WE LOOK FOR IT:\n    if (!willAReaderAcceptMsgDirectedTo(readerID, first_reader))\n    {\n        return false;\n    }\n\n    //FOUND THE READER.\n    //We ask the reader for a cachechange to store the information.\n    CacheChange_t ch;\n    ch.kind = ALIVE;\n    ch.writerGUID.guidPrefix = source_guid_prefix_;\n    valid &= CDRMessage::readEntityId(msg, &ch.writerGUID.entityId);\n\n    writerID = ch.writerGUID.entityId;\n\n    //Get sequence number\n    valid &= CDRMessage::readSequenceNumber(msg, &ch.sequenceNumber);\n\n    if (!valid)\n    {\n        return false;\n    }\n\n    if (ch.sequenceNumber <= SequenceNumber_t())\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Invalid message received, bad sequence Number\");\n        return false;\n    }\n\n    //Jump ahead if more parameters are before inlineQos (not in this version, maybe if further minor versions.)\n    if (octetsToInlineQos > RTPSMESSAGE_OCTETSTOINLINEQOS_DATASUBMSG)\n    {\n        msg->pos += (octetsToInlineQos - RTPSMESSAGE_OCTETSTOINLINEQOS_DATASUBMSG);\n        if (msg->pos > msg->length)\n        {\n            EPROSIMA_LOG_WARNING(RTPS_MSG_IN,\n                    IDSTRING \"Invalid jump through msg, msg->pos \" << msg->pos << \" > msg->length \" << msg->length);\n            return false;\n        }\n    }\n\n    uint32_t inlineQosSize = 0;\n\n    if (inlineQosFlag)\n    {\n        if (!ParameterList::updateCacheChangeFromInlineQos(ch, msg, inlineQosSize))\n        {\n            EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"SubMessage Data ERROR, Inline Qos ParameterList error\");\n            return false;\n        }\n        ch.inline_qos.data = &msg->buffer[msg->pos - inlineQosSize];\n        ch.inline_qos.max_size = inlineQosSize;\n        ch.inline_qos.length = inlineQosSize;\n        ch.inline_qos.encapsulation = endiannessFlag ? PL_CDR_LE : PL_CDR_BE;\n        ch.inline_qos.pos = 0;\n    }\n\n    if (dataFlag || keyFlag)\n    {\n        uint32_t payload_size;\n        const uint32_t submsg_no_payload_size =\n                RTPSMESSAGE_DATA_EXTRA_INLINEQOS_SIZE + octetsToInlineQos + inlineQosSize;\n\n        // Prevent integer overflow of variable payload_size\n        if (smh->submessageLength < submsg_no_payload_size)\n        {\n            EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload avoided overflow \"\n                    \"(\" << smh->submessageLength << \"/\" << submsg_no_payload_size << \")\");\n            ch.serializedPayload.data = nullptr;\n            ch.inline_qos.data = nullptr;\n            return false;\n        }\n\n        payload_size = smh->submessageLength - submsg_no_payload_size;\n\n        if (dataFlag)\n        {\n            uint32_t next_pos = msg->pos + payload_size;\n            if (msg->length >= next_pos && payload_size > 0)\n            {\n                ch.serializedPayload.data = &msg->buffer[msg->pos];\n                ch.serializedPayload.length = payload_size;\n                ch.serializedPayload.max_size = payload_size;\n                msg->pos = next_pos;\n            }\n            else\n            {\n                EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload value invalid or larger than maximum allowed size\"\n                        \"(\" << payload_size << \"/\" << (msg->length - msg->pos) << \")\");\n                ch.serializedPayload.data = nullptr;\n                ch.inline_qos.data = nullptr;\n                return false;\n            }\n        }\n        else if (keyFlag)\n        {\n            if (payload_size <= 0)\n            {\n                EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload value invalid (\" << payload_size << \")\");\n                ch.serializedPayload.data = nullptr;\n                ch.inline_qos.data = nullptr;\n                return false;\n            }\n\n            if (payload_size <= PARAMETER_KEY_HASH_LENGTH)\n            {\n                memcpy(ch.instanceHandle.value, &msg->buffer[msg->pos], payload_size);\n            }\n            else\n            {\n                EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Ignoring Serialized Payload for too large key-only data (\" <<\n                        payload_size << \")\");\n            }\n            msg->pos += payload_size;\n        }\n    }\n\n    // Set sourcetimestamp\n    if (have_timestamp_)\n    {\n        ch.sourceTimestamp = timestamp_;\n    }\n\n    EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"from Writer \" << ch.writerGUID << \"; possible RTPSReader entities: \" <<\n            associated_readers_.size());\n\n    //Look for the correct reader to add the change\n    process_data_message_function_(readerID, ch, was_decoded);\n\n    IPayloadPool* payload_pool = ch.payload_owner();\n    if (payload_pool)\n    {\n        payload_pool->release_payload(ch);\n    }\n\n    //TODO(Ricardo) If an exception is thrown (ex, by fastcdr), these lines are not executed -> segmentation fault\n    ch.serializedPayload.data = nullptr;\n    ch.inline_qos.data = nullptr;\n\n    EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"Sub Message DATA processed\");\n    return true;\n}",
      "cve_list": [
        "CVE-2024-28231"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "Fast-DDS",
      "filepath": "test/blackbox/common/BlackboxTestsTransportUDP.cpp",
      "func_name": "TEST",
      "func_body": "TEST(TransportUDP, MaliciousManipulatedDataOctetsToNextHeaderIgnore)\n{\n    // Force using UDP transport\n    auto udp_transport = std::make_shared<UDPv4TransportDescriptor>();\n\n    PubSubWriter<UnboundedHelloWorldPubSubType> writer(TEST_TOPIC_NAME);\n    PubSubReader<UnboundedHelloWorldPubSubType> reader(TEST_TOPIC_NAME);\n\n    struct MaliciousManipulatedDataOctetsToNextHeader\n    {\n        std::array<char, 4> rtps_id{ {'R', 'T', 'P', 'S'} };\n        std::array<uint8_t, 2> protocol_version{ {2, 3} };\n        std::array<uint8_t, 2> vendor_id{ {0x01, 0x0F} };\n        GuidPrefix_t sender_prefix{};\n\n        struct DataSubMsg\n        {\n            struct Header\n            {\n                uint8_t submessage_id = 0x15;\n#if FASTDDS_IS_BIG_ENDIAN_TARGET\n                uint8_t flags = 0x04;\n#else\n                uint8_t flags = 0x05;\n#endif  // FASTDDS_IS_BIG_ENDIAN_TARGET\n                uint16_t octets_to_next_header = 0x30;\n                uint16_t extra_flags = 0;\n                uint16_t octets_to_inline_qos = 0x2d;\n                EntityId_t reader_id{};\n                EntityId_t writer_id{};\n                SequenceNumber_t sn{100};\n            };\n\n            struct SerializedData\n            {\n                uint16_t encapsulation;\n                uint16_t encapsulation_opts;\n                octet data[24];\n            };\n\n            Header header;\n            SerializedData payload;\n        }\n        data;\n\n        uint8_t additional_bytes[8] {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};\n\n    };\n\n    UDPMessageSender fake_msg_sender;\n\n    // Set common QoS\n    reader.disable_builtin_transport().add_user_transport_to_pparams(udp_transport)\n            .history_depth(10).reliability(eprosima::fastrtps::RELIABLE_RELIABILITY_QOS);\n    writer.history_depth(10).reliability(eprosima::fastrtps::RELIABLE_RELIABILITY_QOS);\n\n    // Set custom reader locator so we can send malicious data to a known location\n    Locator_t reader_locator;\n    ASSERT_TRUE(IPLocator::setIPv4(reader_locator, \"127.0.0.1\"));\n    reader_locator.port = 7000;\n    reader.add_to_unicast_locator_list(\"127.0.0.1\", 7000);\n\n    // Initialize and wait for discovery\n    reader.init();\n    ASSERT_TRUE(reader.isInitialized());\n    writer.init();\n    ASSERT_TRUE(writer.isInitialized());\n\n    reader.wait_discovery();\n    writer.wait_discovery();\n\n    auto data = default_unbounded_helloworld_data_generator();\n    reader.startReception(data);\n    writer.send(data);\n    ASSERT_TRUE(data.empty());\n\n    // Send malicious data\n    {\n        auto writer_guid = writer.datawriter_guid();\n\n        MaliciousManipulatedDataOctetsToNextHeader malicious_packet{};\n        malicious_packet.sender_prefix = writer_guid.guidPrefix;\n        malicious_packet.data.header.writer_id = writer_guid.entityId;\n        malicious_packet.data.header.reader_id = reader.datareader_guid().entityId;\n        malicious_packet.data.payload.encapsulation = CDR_LE;\n\n        CDRMessage_t msg(0);\n        uint32_t msg_len = static_cast<uint32_t>(sizeof(malicious_packet));\n        msg.init(reinterpret_cast<octet*>(&malicious_packet), msg_len);\n        msg.length = msg_len;\n        msg.pos = msg_len;\n        fake_msg_sender.send(msg, reader_locator);\n    }\n\n    // Block reader until reception finished or timeout.\n    reader.block_for_all();\n}",
      "cve_list": [
        "CVE-2024-28231"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "Fast-DDS",
      "filepath": "test/blackbox/utils/data_generators.cpp",
      "func_name": "default_unbounded_helloworld_data_generator",
      "func_body": "std::list<UnboundedHelloWorld> default_unbounded_helloworld_data_generator(\n        size_t max)\n{\n    uint16_t index = 1;\n    size_t maximum = max ? max : 10;\n    std::list<UnboundedHelloWorld> returnedValue(maximum);\n\n    std::generate(returnedValue.begin(), returnedValue.end(), [&index]\n            {\n                UnboundedHelloWorld hello;\n                hello.index(index);\n                std::stringstream ss;\n                ss << \"HelloWorld \" << index;\n                hello.message(ss.str());\n                ++index;\n                return hello;\n            });\n\n    return returnedValue;\n}",
      "cve_list": [
        "CVE-2024-28231"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "Fast-DDS",
      "filepath": "test/blackbox/common/BlackboxTestsTransportUDP.cpp",
      "func_name": "TEST",
      "func_body": "TEST(TransportUDP, DatagramInjection)\n{\n    using eprosima::fastdds::rtps::DatagramInjectionTransportDescriptor;\n    using eprosima::fastdds::rtps::DatagramInjectionTransport;\n\n    auto low_level_transport = std::make_shared<UDPv4TransportDescriptor>();\n    auto transport = std::make_shared<DatagramInjectionTransportDescriptor>(low_level_transport);\n\n    PubSubWriter<HelloWorldPubSubType> writer(TEST_TOPIC_NAME);\n    writer.disable_builtin_transport().add_user_transport_to_pparams(transport).init();\n    ASSERT_TRUE(writer.isInitialized());\n\n    auto receivers = transport->get_receivers();\n    ASSERT_FALSE(receivers.empty());\n\n    DatagramInjectionTransport::deliver_datagram_from_file(receivers, \"datagrams/16784.bin\");\n    DatagramInjectionTransport::deliver_datagram_from_file(receivers, \"datagrams/20140.bin\");\n    DatagramInjectionTransport::deliver_datagram_from_file(receivers, \"datagrams/20574.bin\");\n    DatagramInjectionTransport::deliver_datagram_from_file(receivers, \"datagrams/20660.bin\");\n}",
      "cve_list": [
        "CVE-2024-30258"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "PackageKit",
      "filepath": "src/pk-transaction.c",
      "func_name": "pk_transaction_finished_emit",
      "func_body": "pk_transaction_finished_emit (PkTransaction *transaction,\n\t\t\t      PkExitEnum exit_enum,\n\t\t\t      guint time_ms)\n{\n\tg_assert (!transaction->priv->emitted_finished);\n\ttransaction->priv->emitted_finished = TRUE;\n\n\tg_debug (\"emitting finished '%s', %i\",\n\t\t pk_exit_enum_to_string (exit_enum),\n\t\t time_ms);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"Finished\",\n\t\t\t\t       g_variant_new (\"(uu)\",\n\t\t\t\t\t\t      exit_enum,\n\t\t\t\t\t\t      time_ms),\n\t\t\t\t       NULL);\n\n\t/* For the transaction list */\n\tg_signal_emit (transaction, signals[SIGNAL_FINISHED], 0);\n}",
      "cve_list": [
        "CVE-2024-0217"
      ],
      "cwe_list": [
        "CWE-416"
      ]
    },
    {
      "project": "plasma-workspace",
      "filepath": "components/calendar/eventpluginsmanager.cpp",
      "func_name": "EventPluginsManager::loadPlugin",
      "func_body": "void EventPluginsManager::loadPlugin(const QString &pluginId)\n{\n    QPluginLoader loader(\"plasmacalendarplugins/\" + QDir::cleanPath(pluginId));\n\n    if (!loader.load()) {\n        qWarning() << \"Could not create Plasma Calendar Plugin: \" << pluginId;\n        qWarning() << loader.errorString();\n        return;\n    }\n\n    QObject *obj = loader.instance();\n    if (obj) {\n        CalendarEvents::CalendarEventsPlugin *eventsPlugin = qobject_cast<CalendarEvents::CalendarEventsPlugin *>(obj);\n        if (eventsPlugin) {\n            qDebug() << \"Loading Calendar plugin\" << eventsPlugin;\n            eventsPlugin->setProperty(\"pluginId\", pluginId);\n            d->plugins << eventsPlugin;\n\n            // Connect the relay signals\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::dataReady, this, &EventPluginsManager::dataReady);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::eventModified, this, &EventPluginsManager::eventModified);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::eventRemoved, this, &EventPluginsManager::eventRemoved);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::alternateCalendarDateReady, this, &EventPluginsManager::alternateCalendarDateReady);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::subLabelReady, this, &EventPluginsManager::subLabelReady);\n        } else {\n            // not our/valid plugin, so unload it\n            loader.unload();\n        }\n    } else {\n        loader.unload();\n    }\n}",
      "cve_list": [
        "CVE-2024-1433"
      ],
      "cwe_list": [
        "CWE-22"
      ]
    },
    {
      "project": "cef",
      "filepath": "libcef/browser/osr/host_display_client_osr.cc",
      "func_name": "CefLayeredWindowUpdaterOSR::OnAllocatedSharedMemory",
      "func_body": "void CefLayeredWindowUpdaterOSR::OnAllocatedSharedMemory(\n    const gfx::Size& pixel_size,\n    base::UnsafeSharedMemoryRegion region) {\n  // Make sure |pixel_size| is sane.\n  size_t expected_bytes;\n  if (!viz::ResourceSizes::MaybeSizeInBytes(\n          pixel_size, viz::SinglePlaneFormat::kRGBA_8888, &expected_bytes)) {\n    DLOG(ERROR) << \"OnAllocatedSharedMemory with size that overflows\";\n    return;\n  }\n\n  auto mapping = region.Map();\n  if (!mapping.IsValid()) {\n    DLOG(ERROR) << \"Shared memory mapping failed.\";\n    return;\n  }\n  if (mapping.size() < expected_bytes) {\n    DLOG(ERROR) << \"Shared memory size was less than expected.\";\n    return;\n  }\n\n  pixel_size_ = pixel_size;\n  shared_memory_ = std::move(mapping);\n}",
      "cve_list": [
        "CVE-2024-21639",
        "CVE-2024-21640"
      ],
      "cwe_list": [
        "CWE-125"
      ]
    },
    {
      "project": "cef",
      "filepath": "libcef/browser/osr/video_consumer_osr.cc",
      "func_name": "CefVideoConsumerOSR::OnFrameCaptured",
      "func_body": "void CefVideoConsumerOSR::OnFrameCaptured(\n    media::mojom::VideoBufferHandlePtr data,\n    media::mojom::VideoFrameInfoPtr info,\n    const gfx::Rect& content_rect,\n    mojo::PendingRemote<viz::mojom::FrameSinkVideoConsumerFrameCallbacks>\n        callbacks) {\n  ScopedVideoFrameDone scoped_done(std::move(callbacks));\n\n  if (info->pixel_format != media::PIXEL_FORMAT_ARGB) {\n    DLOG(ERROR) << \"Unsupported pixel format \" << info->pixel_format;\n    return;\n  }\n\n  CHECK(data->is_read_only_shmem_region());\n  base::ReadOnlySharedMemoryRegion& shmem_region =\n      data->get_read_only_shmem_region();\n\n  // The |data| parameter is not nullable and mojo type mapping for\n  // `base::ReadOnlySharedMemoryRegion` defines that nullable version of it is\n  // the same type, with null check being equivalent to IsValid() check. Given\n  // the above, we should never be able to receive a read only shmem region that\n  // is not valid - mojo will enforce it for us.\n  DCHECK(shmem_region.IsValid());\n\n  base::ReadOnlySharedMemoryMapping mapping = shmem_region.Map();\n  if (!mapping.IsValid()) {\n    DLOG(ERROR) << \"Shared memory mapping failed.\";\n    return;\n  }\n  if (mapping.size() <\n      media::VideoFrame::AllocationSize(info->pixel_format, info->coded_size)) {\n    DLOG(ERROR) << \"Shared memory size was less than expected.\";\n    return;\n  }\n\n  // The SkBitmap's pixels will be marked as immutable, but the installPixels()\n  // API requires a non-const pointer. So, cast away the const.\n  void* const pixels = const_cast<void*>(mapping.memory());\n\n  media::VideoFrameMetadata metadata = info->metadata;\n  gfx::Rect damage_rect;\n\n  if (bounds_in_pixels_) {\n    // Use the bounds passed to RequestRefreshFrame().\n    damage_rect = gfx::Rect(info->coded_size);\n    damage_rect.Intersect(*bounds_in_pixels_);\n    bounds_in_pixels_ = absl::nullopt;\n  } else {\n    // Retrieve the rectangular region of the frame that has changed since the\n    // frame with the directly preceding CAPTURE_COUNTER. If that frame was not\n    // received, typically because it was dropped during transport from the\n    // producer, clients must assume that the entire frame has changed.\n    // This rectangle is relative to the full frame data, i.e. [0, 0,\n    // coded_size.width(), coded_size.height()]. It does not have to be\n    // fully contained within visible_rect.\n    if (metadata.capture_update_rect) {\n      damage_rect = *metadata.capture_update_rect;\n    }\n    if (damage_rect.IsEmpty()) {\n      damage_rect = gfx::Rect(info->coded_size);\n    }\n  }\n\n  view_->OnPaint(damage_rect, info->coded_size, pixels);\n}",
      "cve_list": [
        "CVE-2024-21639",
        "CVE-2024-21640"
      ],
      "cwe_list": [
        "CWE-125"
      ]
    },
    {
      "project": "azure-uamqp-c",
      "filepath": "src/message.c",
      "func_name": "message_add_body_amqp_data",
      "func_body": "int message_add_body_amqp_data(MESSAGE_HANDLE message, BINARY_DATA amqp_data)\n{\n    int result;\n\n    /* Codes_SRS_MESSAGE_01_088: [ If `message` is NULL, `message_add_body_amqp_data` shall fail and return a non-zero value. ]*/\n    if ((message == NULL) ||\n        /* Tests_SRS_MESSAGE_01_089: [ If the `bytes` member of `amqp_data` is NULL and the `size` member is non-zero, `message_add_body_amqp_data` shall fail and return a non-zero value. ]*/\n        ((amqp_data.bytes == NULL) &&\n         (amqp_data.length != 0)))\n    {\n        LogError(\"Bad arguments: message = %p, bytes = %p, length = %u\",\n            message, amqp_data.bytes, (unsigned int)amqp_data.length);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        MESSAGE_BODY_TYPE body_type = internal_get_body_type(message);\n        if ((body_type == MESSAGE_BODY_TYPE_SEQUENCE) ||\n            (body_type == MESSAGE_BODY_TYPE_VALUE))\n        {\n            /* Codes_SRS_MESSAGE_01_091: [ If the body was already set to an AMQP value or a list of AMQP sequences, `message_add_body_amqp_data` shall fail and return a non-zero value. ]*/\n            LogError(\"Body type already set\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            size_t realloc_size = safe_add_size_t(message->body_amqp_data_count, 1);\n            realloc_size = safe_multiply_size_t(sizeof(BODY_AMQP_DATA), realloc_size);\n\n            if (realloc_size == SIZE_MAX)\n            {\n                LogError(\"Invalid size for new_body_amqp_data_items\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                /* Codes_SRS_MESSAGE_01_086: [ `message_add_body_amqp_data` shall add the contents of `amqp_data` to the list of AMQP data values for the body of the message identified by `message`. ]*/\n                BODY_AMQP_DATA* new_body_amqp_data_items = (BODY_AMQP_DATA*)realloc(message->body_amqp_data_items, realloc_size);\n                if (new_body_amqp_data_items == NULL)\n                {\n                    /* Codes_SRS_MESSAGE_01_153: [ If allocating memory to store the added AMQP data fails, `message_add_body_amqp_data` shall fail and return a non-zero value. ]*/\n                    LogError(\"Cannot allocate memory for body AMQP data items\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    message->body_amqp_data_items = new_body_amqp_data_items;\n\n                    if (amqp_data.length == 0)\n                    {\n                        message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes = NULL;\n                        message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_length = 0;\n                        message->body_amqp_data_count++;\n\n                        /* Codes_SRS_MESSAGE_01_087: [ On success it shall return 0. ]*/\n                        result = 0;\n                    }\n                    else\n                    {\n                        message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes = (unsigned char*)malloc(amqp_data.length);\n                        if (message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes == NULL)\n                        {\n                            /* Codes_SRS_MESSAGE_01_153: [ If allocating memory to store the added AMQP data fails, `message_add_body_amqp_data` shall fail and return a non-zero value. ]*/\n                            LogError(\"Cannot allocate memory for body AMQP data to be added\");\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_length = amqp_data.length;\n                            (void)memcpy(message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes, amqp_data.bytes, amqp_data.length);\n                            message->body_amqp_data_count++;\n\n                            /* Codes_SRS_MESSAGE_01_087: [ On success it shall return 0. ]*/\n                            result = 0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return result;\n}",
      "cve_list": [
        "CVE-2024-25110"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-uamqp-c",
      "filepath": "src/message.c",
      "func_name": "message_add_body_amqp_sequence",
      "func_body": "int message_add_body_amqp_sequence(MESSAGE_HANDLE message, AMQP_VALUE sequence_list)\n{\n    int result;\n\n    if ((message == NULL) ||\n        (sequence_list == NULL))\n    {\n        /* Codes_SRS_MESSAGE_01_112: [ If `message` or `sequence` is NULL, `message_add_body_amqp_sequence` shall fail and return a non-zero value. ]*/\n        LogError(\"Bad arguments: message = %p, sequence_list = %p\",\n            message, sequence_list);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        MESSAGE_BODY_TYPE body_type = internal_get_body_type(message);\n        if ((body_type == MESSAGE_BODY_TYPE_DATA) ||\n            (body_type == MESSAGE_BODY_TYPE_VALUE))\n        {\n            /* Codes_SRS_MESSAGE_01_115: [ If the body was already set to an AMQP data list or an AMQP value, `message_add_body_amqp_sequence` shall fail and return a non-zero value. ]*/\n            LogError(\"Body is already set to another body type\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            size_t realloc_size = safe_add_size_t(message->body_amqp_sequence_count, 1);\n            realloc_size = safe_multiply_size_t(sizeof(AMQP_VALUE), realloc_size);\n\n            if (realloc_size == SIZE_MAX)\n            {\n                LogError(\"Invalid size for new_body_amqp_sequence_items\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                AMQP_VALUE* new_body_amqp_sequence_items = (AMQP_VALUE*)realloc(message->body_amqp_sequence_items, realloc_size);\n\n                if (new_body_amqp_sequence_items == NULL)\n                {\n                    /* Codes_SRS_MESSAGE_01_158: [ If allocating memory in order to store the sequence fails, `message_add_body_amqp_sequence` shall fail and return a non-zero value. ]*/\n                    LogError(\"Cannot allocate enough memory for sequence items\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    message->body_amqp_sequence_items = new_body_amqp_sequence_items;\n\n                    /* Codes_SRS_MESSAGE_01_110: [ `message_add_body_amqp_sequence` shall add the contents of `sequence` to the list of AMQP sequences for the body of the message identified by `message`. ]*/\n                    /* Codes_SRS_MESSAGE_01_156: [ The AMQP sequence shall be cloned by calling `amqpvalue_clone`. ]*/\n                    message->body_amqp_sequence_items[message->body_amqp_sequence_count] = amqpvalue_clone(sequence_list);\n                    if (message->body_amqp_sequence_items[message->body_amqp_sequence_count] == NULL)\n                    {\n                        /* Codes_SRS_MESSAGE_01_157: [ If `amqpvalue_clone` fails, `message_add_body_amqp_sequence` shall fail and return a non-zero value. ]*/\n                        LogError(\"Cloning sequence failed\");\n                        result = MU_FAILURE;\n                    }\n                    else\n                    {\n                        /* Codes_SRS_MESSAGE_01_114: [ If adding the AMQP sequence fails, the previous value shall be preserved. ]*/\n                        message->body_amqp_sequence_count++;\n\n                        /* Codes_SRS_MESSAGE_01_111: [ On success it shall return 0. ]*/\n                        result = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    return result;\n}",
      "cve_list": [
        "CVE-2024-25110"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-uamqp-c",
      "filepath": "src/message.c",
      "func_name": "message_clone",
      "func_body": "MESSAGE_HANDLE message_clone(MESSAGE_HANDLE source_message)\n{\n    MESSAGE_HANDLE result;\n\n    if (source_message == NULL)\n    {\n        /* Codes_SRS_MESSAGE_01_062: [If `source_message` is NULL, `message_clone` shall fail and return NULL.] */\n        LogError(\"NULL source_message\");\n        result = NULL;\n    }\n    else\n    {\n        /* Codes_SRS_MESSAGE_01_003: [`message_clone` shall clone a message entirely and on success return a non-NULL handle to the cloned message.] */\n        result = (MESSAGE_HANDLE)message_create();\n        if (result == NULL)\n        {\n            /* Codes_SRS_MESSAGE_01_004: [If allocating memory for the new cloned message fails, `message_clone` shall fail and return NULL.] */\n            LogError(\"Cannot clone message\");\n        }\n        else\n        {\n            result->message_format = source_message->message_format;\n\n            if (source_message->header != NULL)\n            {\n                /* Codes_SRS_MESSAGE_01_005: [If a header exists on the source message it shall be cloned by using `header_clone`.] */\n                result->header = header_clone(source_message->header);\n                if (result->header == NULL)\n                {\n                    /* Codes_SRS_MESSAGE_01_012: [ If any cloning operation for the members of the source message fails, then `message_clone` shall fail and return NULL. ]*/\n                    LogError(\"Cannot clone message header\");\n                    message_destroy(result);\n                    result = NULL;\n                }\n            }\n\n            if ((result != NULL) && (source_message->delivery_annotations != NULL))\n            {\n                /* Codes_SRS_MESSAGE_01_006: [If delivery annotations exist on the source message they shall be cloned by using `annotations_clone`.] */\n                result->delivery_annotations = annotations_clone(source_message->delivery_annotations);\n                if (result->delivery_annotations == NULL)\n                {\n                    /* Codes_SRS_MESSAGE_01_012: [ If any cloning operation for the members of the source message fails, then `message_clone` shall fail and return NULL. ]*/\n                    LogError(\"Cannot clone delivery annotations\");\n                    message_destroy(result);\n                    result = NULL;\n                }\n            }\n\n            if ((result != NULL) && (source_message->message_annotations != NULL))\n            {\n                /* Codes_SRS_MESSAGE_01_007: [If message annotations exist on the source message they shall be cloned by using `annotations_clone`.] */\n                result->message_annotations = annotations_clone(source_message->message_annotations);\n                if (result->message_annotations == NULL)\n                {\n                    /* Codes_SRS_MESSAGE_01_012: [ If any cloning operation for the members of the source message fails, then `message_clone` shall fail and return NULL. ]*/\n                    LogError(\"Cannot clone message annotations\");\n                    message_destroy(result);\n                    result = NULL;\n                }\n            }\n\n            if ((result != NULL) && (source_message->properties != NULL))\n            {\n                /* Codes_SRS_MESSAGE_01_008: [If message properties exist on the source message they shall be cloned by using `properties_clone`.] */\n                result->properties = properties_clone(source_message->properties);\n                if (result->properties == NULL)\n                {\n                    /* Codes_SRS_MESSAGE_01_012: [ If any cloning operation for the members of the source message fails, then `message_clone` shall fail and return NULL. ]*/\n                    LogError(\"Cannot clone message properties\");\n                    message_destroy(result);\n                    result = NULL;\n                }\n            }\n\n            if ((result != NULL) && (source_message->application_properties != NULL))\n            {\n                /* Codes_SRS_MESSAGE_01_009: [If application properties exist on the source message they shall be cloned by using `amqpvalue_clone`.] */\n                result->application_properties = amqpvalue_clone(source_message->application_properties);\n                if (result->application_properties == NULL)\n                {\n                    /* Codes_SRS_MESSAGE_01_012: [ If any cloning operation for the members of the source message fails, then `message_clone` shall fail and return NULL. ]*/\n                    LogError(\"Cannot clone application annotations\");\n                    message_destroy(result);\n                    result = NULL;\n                }\n            }\n\n            if ((result != NULL) && (source_message->footer != NULL))\n            {\n                /* Codes_SRS_MESSAGE_01_010: [If a footer exists on the source message it shall be cloned by using `annotations_clone`.] */\n                result->footer = amqpvalue_clone(source_message->footer);\n                if (result->footer == NULL)\n                {\n                    /* Codes_SRS_MESSAGE_01_012: [ If any cloning operation for the members of the source message fails, then `message_clone` shall fail and return NULL. ]*/\n                    LogError(\"Cannot clone message footer\");\n                    message_destroy(result);\n                    result = NULL;\n                }\n            }\n\n            if ((result != NULL) && (source_message->body_amqp_data_count > 0))\n            {\n                size_t calloc_size = safe_multiply_size_t(source_message->body_amqp_data_count, sizeof(BODY_AMQP_DATA));\n\n                if (calloc_size == SIZE_MAX)\n                {\n                    LogError(\"Invalid size for body_amqp_data_items\");\n                    result = NULL;\n                }\n                else\n                {\n                    result->body_amqp_data_items = (BODY_AMQP_DATA*)calloc(1, calloc_size);\n\n                    if (result->body_amqp_data_items == NULL)\n                    {\n                        /* Codes_SRS_MESSAGE_01_012: [ If any cloning operation for the members of the source message fails, then `message_clone` shall fail and return NULL. ]*/\n                        LogError(\"Cannot allocate memory for body data sections\");\n                        message_destroy(result);\n                        result = NULL;\n                    }\n                    else\n                    {\n                        size_t i;\n\n                        for (i = 0; i < source_message->body_amqp_data_count; i++)\n                        {\n                            result->body_amqp_data_items[i].body_data_section_length = source_message->body_amqp_data_items[i].body_data_section_length;\n\n                            /* Codes_SRS_MESSAGE_01_011: [If an AMQP data has been set as message body on the source message it shall be cloned by allocating memory for the binary payload.] */\n                            result->body_amqp_data_items[i].body_data_section_bytes = (unsigned char*)malloc(source_message->body_amqp_data_items[i].body_data_section_length);\n                            if (result->body_amqp_data_items[i].body_data_section_bytes == NULL)\n                            {\n                                LogError(\"Cannot allocate memory for body data section %u\", (unsigned int)i);\n                                break;\n                            }\n                            else\n                            {\n                                (void)memcpy(result->body_amqp_data_items[i].body_data_section_bytes, source_message->body_amqp_data_items[i].body_data_section_bytes, result->body_amqp_data_items[i].body_data_section_length);\n                            }\n                        }\n\n                        result->body_amqp_data_count = i;\n                        if (i < source_message->body_amqp_data_count)\n                        {\n                            /* Codes_SRS_MESSAGE_01_012: [ If any cloning operation for the members of the source message fails, then `message_clone` shall fail and return NULL. ]*/\n                            message_destroy(result);\n                            result = NULL;\n                        }\n                    }\n                }\n            }\n\n            if ((result != NULL) && (source_message->body_amqp_sequence_count > 0))\n            {\n                size_t calloc_size = safe_multiply_size_t(source_message->body_amqp_sequence_count, sizeof(AMQP_VALUE));\n\n                if (calloc_size == SIZE_MAX)\n                {\n                    LogError(\"Invalid size for body_amqp_sequence_items\");\n                    message_destroy(result);\n                    result = NULL;\n                }\n                else\n                {\n                    result->body_amqp_sequence_items = (AMQP_VALUE*)calloc(1, calloc_size);\n                    if (result->body_amqp_sequence_items == NULL)\n                    {\n                        /* Codes_SRS_MESSAGE_01_012: [ If any cloning operation for the members of the source message fails, then `message_clone` shall fail and return NULL. ]*/\n                        LogError(\"Cannot allocate memory for body AMQP sequences\");\n                        message_destroy(result);\n                        result = NULL;\n                    }\n                    else\n                    {\n                        size_t i;\n\n                        for (i = 0; i < source_message->body_amqp_sequence_count; i++)\n                        {\n                            /* Codes_SRS_MESSAGE_01_160: [ If AMQP sequences are set as AMQP body they shall be cloned by calling `amqpvalue_clone`. ] */\n                            result->body_amqp_sequence_items[i] = amqpvalue_clone(source_message->body_amqp_sequence_items[i]);\n                            if (result->body_amqp_sequence_items[i] == NULL)\n                            {\n                                LogError(\"Cannot clone AMQP sequence %u\", (unsigned int)i);\n                                break;\n                            }\n                        }\n\n                        result->body_amqp_sequence_count = i;\n                        if (i < source_message->body_amqp_sequence_count)\n                        {\n                            /* Codes_SRS_MESSAGE_01_012: [ If any cloning operation for the members of the source message fails, then `message_clone` shall fail and return NULL. ]*/\n                            message_destroy(result);\n                            result = NULL;\n                        }\n                    }\n\t\t\t\t}\n            }\n\n            if ((result != NULL) && (source_message->body_amqp_value != NULL))\n            {\n                /* Codes_SRS_MESSAGE_01_159: [If an AMQP value has been set as message body on the source message it shall be cloned by calling `amqpvalue_clone`. ]*/\n                result->body_amqp_value = amqpvalue_clone(source_message->body_amqp_value);\n                if (result->body_amqp_value == NULL)\n                {\n                    /* Codes_SRS_MESSAGE_01_012: [ If any cloning operation for the members of the source message fails, then `message_clone` shall fail and return NULL. ]*/\n                    LogError(\"Cannot clone body AMQP value\");\n                    message_destroy(result);\n                    result = NULL;\n                }\n            }\n        }\n    }\n\n    return result;\n}",
      "cve_list": [
        "CVE-2024-25110"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-uamqp-c",
      "filepath": "src/link.c",
      "func_name": "link_frame_received",
      "func_body": "static void link_frame_received(void* context, AMQP_VALUE performative, uint32_t payload_size, const unsigned char* payload_bytes)\n{\n    LINK_INSTANCE* link_instance = (LINK_INSTANCE*)context;\n    AMQP_VALUE descriptor = amqpvalue_get_inplace_descriptor(performative);\n\n    if (is_attach_type_by_descriptor(descriptor))\n    {\n        ATTACH_HANDLE attach_handle;\n\n        if (amqpvalue_get_attach(performative, &attach_handle) != 0)\n        {\n            LogError(\"Cannot get attach performative\");\n        }\n        else\n        {\n            if ((link_instance->role == role_receiver) &&\n                (attach_get_initial_delivery_count(attach_handle, &link_instance->delivery_count) != 0))\n            {\n                LogError(\"Cannot get initial delivery count\");\n                remove_all_pending_deliveries(link_instance, true);\n                set_link_state(link_instance, LINK_STATE_DETACHED);\n            }\n            else\n            {\n                if (attach_get_max_message_size(attach_handle, &link_instance->peer_max_message_size) != 0)\n                {\n                    LogError(\"Could not retrieve peer_max_message_size from attach frame\");\n                }\n\n                if ((link_instance->link_state == LINK_STATE_DETACHED) ||\n                    (link_instance->link_state == LINK_STATE_HALF_ATTACHED_ATTACH_SENT))\n                {\n                    if (link_instance->role == role_receiver)\n                    {\n                        link_instance->current_link_credit = link_instance->max_link_credit;\n                        send_flow(link_instance);\n                    }\n                    else\n                    {\n                        link_instance->current_link_credit = 0;\n                    }\n\n                    if (link_instance->link_state == LINK_STATE_DETACHED)\n                    {\n                        set_link_state(link_instance, LINK_STATE_HALF_ATTACHED_ATTACH_RECEIVED);\n                    }\n                    else\n                    {\n                        set_link_state(link_instance, LINK_STATE_ATTACHED);\n                    }\n                }\n            }\n\n            attach_destroy(attach_handle);\n        }\n    }\n    else if (is_flow_type_by_descriptor(descriptor))\n    {\n        FLOW_HANDLE flow_handle;\n        if (amqpvalue_get_flow(performative, &flow_handle) != 0)\n        {\n            LogError(\"Cannot get flow performative\");\n        }\n        else\n        {\n            if (link_instance->role == role_sender)\n            {\n                delivery_number rcv_delivery_count;\n                uint32_t rcv_link_credit;\n\n                if (flow_get_link_credit(flow_handle, &rcv_link_credit) != 0)\n                {\n                    LogError(\"Cannot get link credit\");\n                    remove_all_pending_deliveries(link_instance, true);\n                    set_link_state(link_instance, LINK_STATE_DETACHED);\n                }\n                else if (flow_get_delivery_count(flow_handle, &rcv_delivery_count) != 0)\n                {\n                    LogError(\"Cannot get delivery count\");\n                    remove_all_pending_deliveries(link_instance, true);\n                    set_link_state(link_instance, LINK_STATE_DETACHED);\n                }\n                else\n                {\n                    link_instance->current_link_credit = rcv_delivery_count + rcv_link_credit - link_instance->delivery_count;\n                    if (link_instance->current_link_credit > 0)\n                    {\n                        link_instance->on_link_flow_on(link_instance->callback_context);\n                    }\n                }\n            }\n\n            flow_destroy(flow_handle);\n        }\n    }\n    else if (is_transfer_type_by_descriptor(descriptor))\n    {\n        if (link_instance->on_transfer_received != NULL)\n        {\n            TRANSFER_HANDLE transfer_handle;\n            if (amqpvalue_get_transfer(performative, &transfer_handle) != 0)\n            {\n                LogError(\"Cannot get transfer performative\");\n            }\n            else\n            {\n                AMQP_VALUE delivery_state;\n                bool more;\n                bool is_error;\n\n                if (link_instance->current_link_credit == 0)\n                {\n                    link_instance->current_link_credit = link_instance->max_link_credit;\n                    send_flow(link_instance);\n                }\n\n                more = false;\n                /* Attempt to get more flag, default to false */\n                (void)transfer_get_more(transfer_handle, &more);\n                is_error = false;\n\n                if (transfer_get_delivery_id(transfer_handle, &link_instance->received_delivery_id) != 0)\n                {\n                    /* is this not a continuation transfer? */\n                    if (link_instance->received_payload_size == 0)\n                    {\n                        LogError(\"Could not get the delivery Id from the transfer performative\");\n                        is_error = true;\n                    }\n                }\n\n                if (!is_error)\n                {\n                    /* If this is a continuation transfer or if this is the first chunk of a multi frame transfer */\n                    if ((link_instance->received_payload_size > 0) || more)\n                    {\n                        unsigned char* new_received_payload;;\n                        size_t realloc_size = safe_add_size_t((size_t)link_instance->received_payload_size, payload_size);\n                        if (realloc_size == SIZE_MAX ||\n                            (new_received_payload = (unsigned char*)realloc(link_instance->received_payload, realloc_size)) == NULL)\n                        {\n                            LogError(\"Could not allocate memory for the received payload, size:%zu\", realloc_size);\n                        }\n                        else\n                        {\n                            link_instance->received_payload = new_received_payload;\n                            (void)memcpy(link_instance->received_payload + link_instance->received_payload_size, payload_bytes, payload_size);\n                            link_instance->received_payload_size += payload_size;\n                        }\n                    }\n\n                    if (!more)\n                    {\n                        const unsigned char* indicate_payload_bytes;\n                        uint32_t indicate_payload_size;\n\n                        link_instance->current_link_credit--;\n                        link_instance->delivery_count++;\n                        /* if no previously stored chunks then simply report the current payload */\n                        if (link_instance->received_payload_size > 0)\n                        {\n                            indicate_payload_size = link_instance->received_payload_size;\n                            indicate_payload_bytes = link_instance->received_payload;\n                        }\n                        else\n                        {\n                            indicate_payload_size = payload_size;\n                            indicate_payload_bytes = payload_bytes;\n                        }\n\n                        delivery_state = link_instance->on_transfer_received(link_instance->callback_context, transfer_handle, indicate_payload_size, indicate_payload_bytes);\n\n                        if (link_instance->received_payload_size > 0)\n                        {\n                            free(link_instance->received_payload);\n                            link_instance->received_payload = NULL;\n                            link_instance->received_payload_size = 0;\n                        }\n\n                        if (delivery_state != NULL)\n                        {\n                            if (send_disposition(link_instance, link_instance->received_delivery_id, delivery_state) != 0)\n                            {\n                                LogError(\"Cannot send disposition frame\");\n                            }\n\n                            amqpvalue_destroy(delivery_state);\n                        }\n                    }\n                }\n\n                transfer_destroy(transfer_handle);\n            }\n        }\n    }\n    else if (is_disposition_type_by_descriptor(descriptor))\n    {\n        DISPOSITION_HANDLE disposition;\n        if (amqpvalue_get_disposition(performative, &disposition) != 0)\n        {\n            LogError(\"Cannot get disposition performative\");\n        }\n        else\n        {\n            delivery_number first;\n            delivery_number last;\n\n            if (disposition_get_first(disposition, &first) != 0)\n            {\n                LogError(\"Cannot get first field\");\n            }\n            else\n            {\n                bool settled;\n\n                if (disposition_get_last(disposition, &last) != 0)\n                {\n                    last = first;\n                }\n\n                if (disposition_get_settled(disposition, &settled) != 0)\n                {\n                    settled = false;\n                }\n\n                if (settled && \n                    link_instance->pending_deliveries != NULL)\n                {\n                    LIST_ITEM_HANDLE pending_delivery = singlylinkedlist_get_head_item(link_instance->pending_deliveries);\n                    while (pending_delivery != NULL)\n                    {\n                        LIST_ITEM_HANDLE next_pending_delivery = singlylinkedlist_get_next_item(pending_delivery);\n                        ASYNC_OPERATION_HANDLE pending_delivery_operation = (ASYNC_OPERATION_HANDLE)singlylinkedlist_item_get_value(pending_delivery);\n                        if (pending_delivery_operation == NULL)\n                        {\n                            LogError(\"Cannot obtain pending delivery\");\n                            break;\n                        }\n                        else\n                        {\n                            DELIVERY_INSTANCE* delivery_instance = (DELIVERY_INSTANCE*)GET_ASYNC_OPERATION_CONTEXT(DELIVERY_INSTANCE, pending_delivery_operation);\n\n                            if ((delivery_instance->delivery_id >= first) && (delivery_instance->delivery_id <= last))\n                            {\n                                AMQP_VALUE delivery_state;\n                                if (disposition_get_state(disposition, &delivery_state) == 0)\n                                {\n                                    delivery_instance->on_delivery_settled(delivery_instance->callback_context, delivery_instance->delivery_id, LINK_DELIVERY_SETTLE_REASON_DISPOSITION_RECEIVED, delivery_state);\n                                    async_operation_destroy(pending_delivery_operation);\n                                }\n                                else\n                                {\n                                    LogError(\"Failed getting the disposition state\");\n                                }\n\n                                if (singlylinkedlist_remove(link_instance->pending_deliveries, pending_delivery) != 0)\n                                {\n                                    LogError(\"Cannot remove pending delivery\");\n                                    break;\n                                }\n                            }\n\n                            pending_delivery = next_pending_delivery;\n                        }\n                    }\n                }\n            }\n\n            disposition_destroy(disposition);\n        }\n    }\n    else if (is_detach_type_by_descriptor(descriptor))\n    {\n        DETACH_HANDLE detach;\n\n        /* Set link state appropriately based on whether we received detach condition */\n        if (amqpvalue_get_detach(performative, &detach) != 0)\n        {\n            LogError(\"Cannot get detach performative\");\n        }\n        else\n        {\n            bool closed = false;\n            ERROR_HANDLE error;\n\n            (void)detach_get_closed(detach, &closed);\n\n            /* Received a detach while attached */\n            if (link_instance->link_state == LINK_STATE_ATTACHED)\n            {\n                /* Respond with ack */\n                if (send_detach(link_instance, closed, NULL) != 0)\n                {\n                    LogError(\"Failed sending detach frame\");\n                }\n            }\n            /* Received a closing detach after we sent a non-closing detach. */\n            else if (closed &&\n                ((link_instance->link_state == LINK_STATE_HALF_ATTACHED_ATTACH_SENT) || (link_instance->link_state == LINK_STATE_HALF_ATTACHED_ATTACH_RECEIVED)) &&\n                !link_instance->is_closed)\n            {\n\n                /* In this case, we MUST signal that we closed by reattaching and then sending a closing detach.*/\n                if (send_attach(link_instance, link_instance->name, 0, link_instance->role) != 0)\n                {\n                    LogError(\"Failed sending attach frame\");\n                }\n\n                if (send_detach(link_instance, true, NULL) != 0)\n                {\n                    LogError(\"Failed sending detach frame\");\n                }\n            }\n\n            if (detach_get_error(detach, &error) != 0)\n            {\n                error = NULL;\n            }\n            remove_all_pending_deliveries(link_instance, true);\n            // signal link detach received in order to handle cases like redirect\n            if (link_instance->on_link_detach_received_event_subscription.on_link_detach_received != NULL)\n            {\n                link_instance->on_link_detach_received_event_subscription.on_link_detach_received(link_instance->on_link_detach_received_event_subscription.context, error);\n            }\n\n            if (error != NULL)\n            {\n                set_link_state(link_instance, LINK_STATE_ERROR);\n                error_destroy(error);\n            }\n            else\n            {\n                set_link_state(link_instance, LINK_STATE_DETACHED);\n            }\n\n            detach_destroy(detach);\n        }\n    }\n}",
      "cve_list": [
        "CVE-2024-27099"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "react-native-mmkv",
      "filepath": "android/src/main/cpp/MmkvHostObject.cpp",
      "func_name": "MmkvHostObject::MmkvHostObject",
      "func_body": "MmkvHostObject::MmkvHostObject(const std::string& instanceId, std::string path,\n                               std::string cryptKey) {\n  bool hasEncryptionKey = cryptKey.size() > 0;\n  __android_log_print(ANDROID_LOG_INFO, \"RNMMKV\",\n                      \"Creating MMKV instance \\\"%s\\\"... (Path: %s, Encrypted: %b)\",\n                      instanceId.c_str(), path.c_str(), hasEncryptionKey);\n  std::string* pathPtr = path.size() > 0 ? &path : nullptr;\n  std::string* cryptKeyPtr = cryptKey.size() > 0 ? &cryptKey : nullptr;\n  instance = MMKV::mmkvWithID(instanceId, mmkv::DEFAULT_MMAP_SIZE, MMKV_SINGLE_PROCESS, cryptKeyPtr,\n                              pathPtr);\n\n  if (instance == nullptr) {\n    // Check if instanceId is invalid\n    if (instanceId.empty()) {\n      throw std::runtime_error(\"Failed to create MMKV instance! `id` cannot be empty!\");\n    }\n\n    // Check if encryptionKey is invalid\n    if (cryptKey.size() > 16) {\n      throw std::runtime_error(\n          \"Failed to create MMKV instance! `encryptionKey` cannot be longer than 16 bytes!\");\n    }\n\n    throw std::runtime_error(\"Failed to create MMKV instance!\");\n  }\n}",
      "cve_list": [
        "CVE-2024-21668"
      ],
      "cwe_list": [
        "CWE-532"
      ]
    },
    {
      "project": "iodine",
      "filepath": "ext/iodine/fio.c",
      "func_name": "fio_cluster_client_handler",
      "func_body": "static void fio_cluster_client_handler(struct cluster_pr_s *pr) {\n  /* what to do? */\n  switch ((fio_cluster_message_type_e)pr->type) {\n  case FIO_CLUSTER_MSG_FORWARD: /* fallthrough */\n  case FIO_CLUSTER_MSG_JSON:\n    fio_publish2process(fio_msg_internal_dup(pr->msg));\n    break;\n  case FIO_CLUSTER_MSG_SHUTDOWN:\n    fio_stop();\n    kill(getpid(), SIGINT);\n  case FIO_CLUSTER_MSG_ERROR:         /* fallthrough */\n  case FIO_CLUSTER_MSG_PING:          /* fallthrough */\n  case FIO_CLUSTER_MSG_ROOT:          /* fallthrough */\n  case FIO_CLUSTER_MSG_ROOT_JSON:     /* fallthrough */\n  case FIO_CLUSTER_MSG_PUBSUB_SUB:    /* fallthrough */\n  case FIO_CLUSTER_MSG_PUBSUB_UNSUB:  /* fallthrough */\n  case FIO_CLUSTER_MSG_PATTERN_SUB:   /* fallthrough */\n  case FIO_CLUSTER_MSG_PATTERN_UNSUB: /* fallthrough */\n\n  default:\n    break;\n  }\n}",
      "cve_list": [
        "CVE-2024-22050"
      ],
      "cwe_list": [
        "CWE-22"
      ]
    },
    {
      "project": "iodine",
      "filepath": "ext/iodine/fio.c",
      "func_name": "fio_cluster_listen_on_close",
      "func_body": "static void fio_cluster_listen_on_close(intptr_t uuid,\n                                        fio_protocol_s *protocol) {\n  free(protocol);\n  cluster_data.uuid = -1;\n  if (fio_parent_pid() == getpid()) {\n#if DEBUG\n    FIO_LOG_DEBUG(\"(%d) stopped listening for cluster connections\",\n                  (int)getpid());\n#endif\n    if (fio_data->active)\n      kill(0, SIGINT);\n  }\n  (void)uuid;\n}",
      "cve_list": [
        "CVE-2024-22050"
      ],
      "cwe_list": [
        "CWE-22"
      ]
    },
    {
      "project": "iodine",
      "filepath": "ext/iodine/fio.c",
      "func_name": "fio_cluster_signal_children",
      "func_body": "static void fio_cluster_signal_children(void) {\n  if (fio_parent_pid() != getpid()) {\n    kill(getpid(), SIGINT);\n    return;\n  }\n  fio_cluster_server_sender(fio_msg_internal_create(0, FIO_CLUSTER_MSG_SHUTDOWN,\n                                                    (fio_str_info_s){.len = 0},\n                                                    (fio_str_info_s){.len = 0},\n                                                    0, 1),\n                            -1);\n}",
      "cve_list": [
        "CVE-2024-22050"
      ],
      "cwe_list": [
        "CWE-22"
      ]
    },
    {
      "project": "iodine",
      "filepath": "ext/iodine/fio.c",
      "func_name": "fio_flush",
      "func_body": "ssize_t fio_flush(intptr_t uuid) {\n  if (!uuid_is_valid(uuid))\n    goto invalid;\n  errno = 0;\n  ssize_t flushed = 0;\n  int tmp;\n  /* start critical section */\n  if (fio_trylock(&uuid_data(uuid).sock_lock))\n    goto would_block;\n\n  if (!uuid_data(uuid).packet)\n    goto flush_rw_hook;\n\n  const fio_packet_s *old_packet = uuid_data(uuid).packet;\n  const size_t old_sent = uuid_data(uuid).sent;\n\n  tmp = uuid_data(uuid).packet->write_func(fio_uuid2fd(uuid),\n                                           uuid_data(uuid).packet);\n  if (tmp <= 0) {\n    goto test_errno;\n  }\n\n  if (uuid_data(uuid).packet_count >= FIO_SLOWLORIS_LIMIT &&\n      uuid_data(uuid).packet == old_packet &&\n      uuid_data(uuid).sent >= old_sent &&\n      (uuid_data(uuid).sent - old_sent) < 32768) {\n    /* Slowloris attack assumed */\n    goto attacked;\n  }\n\n  /* end critical section */\n  fio_unlock(&uuid_data(uuid).sock_lock);\n\n  /* test for fio_close marker */\n  if (!uuid_data(uuid).packet && uuid_data(uuid).close)\n    goto closed;\n\n  /* return state */\n  return uuid_data(uuid).open && uuid_data(uuid).packet != NULL;\n\nwould_block:\n  errno = EWOULDBLOCK;\n  return -1;\n\nclosed:\n  fio_force_close(uuid);\n  return -1;\n\nflush_rw_hook:\n  flushed = uuid_data(uuid).rw_hooks->flush(uuid, uuid_data(uuid).rw_udata);\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  if (!flushed)\n    return 0;\n  if (flushed < 0) {\n    goto test_errno;\n  }\n  touchfd(fio_uuid2fd(uuid));\n  return 1;\n\ntest_errno:\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  switch (errno) {\n  case EWOULDBLOCK: /* fallthrough */\n#if EWOULDBLOCK != EAGAIN\n  case EAGAIN: /* fallthrough */\n#endif\n  case ENOTCONN:      /* fallthrough */\n  case EINPROGRESS:   /* fallthrough */\n  case ENOSPC:        /* fallthrough */\n  case EADDRNOTAVAIL: /* fallthrough */\n  case EINTR:\n    return 1;\n  case EFAULT:\n    FIO_LOG_ERROR(\"fio_flush EFAULT - possible memory address error sent to \"\n                  \"Unix socket.\");\n    /* fallthrough */\n  case EPIPE:  /* fallthrough */\n  case EIO:    /* fallthrough */\n  case EINVAL: /* fallthrough */\n  case EBADF:\n    uuid_data(uuid).close = 1;\n    fio_force_close(uuid);\n    return -1;\n  }\n  fprintf(stderr, \"UUID error: %p (%d)\\n\", (void *)uuid, errno);\n  perror(\"No errno handler\");\n  return 0;\n\ninvalid:\n  /* bad UUID */\n  errno = EBADF;\n  return -1;\n\nattacked:\n  /* don't close, just detach from facil.io and mark uuid as invalid */\n  FIO_LOG_WARNING(\"(facil.io) possible Slowloris attack from %.*s\",\n                  (int)fio_peer_addr(uuid).len, fio_peer_addr(uuid).data);\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  fio_clear_fd(fio_uuid2fd(uuid), 0);\n  return -1;\n}",
      "cve_list": [
        "CVE-2024-22050"
      ],
      "cwe_list": [
        "CWE-22"
      ]
    },
    {
      "project": "iodine",
      "filepath": "ext/iodine/fio.c",
      "func_name": "fio_lib_destroy",
      "func_body": "static void __attribute__((destructor)) fio_lib_destroy(void) {\n  uint8_t add_eol = fio_is_master();\n  fio_data->active = 0;\n  fio_on_fork();\n  fio_defer_perform();\n  fio_timer_clear_all();\n  fio_defer_perform();\n  fio_state_callback_force(FIO_CALL_AT_EXIT);\n  fio_state_callback_clear_all();\n  fio_defer_perform();\n  fio_poll_close();\n  fio_free(fio_data);\n  /* memory library destruction must be last */\n  fio_mem_destroy();\n  FIO_LOG_DEBUG(\"(%d) facil.io resources released, exit complete.\",\n                (int)getpid());\n  if (add_eol)\n    fprintf(stderr, \"\\n\"); /* add EOL to logs (logging adds EOL before text */\n}",
      "cve_list": [
        "CVE-2024-22050"
      ],
      "cwe_list": [
        "CWE-22"
      ]
    },
    {
      "project": "iodine",
      "filepath": "ext/iodine/fio.c",
      "func_name": "fio_signal_handler_reset",
      "func_body": "void fio_signal_handler_reset(void) {\n  struct sigaction old;\n  if (fio_signal_set_flag)\n    return;\n  fio_unlock(&fio_signal_set_flag);\n  memset(&old, 0, sizeof(old));\n  sigaction(SIGINT, &fio_old_sig_int, &old);\n  sigaction(SIGTERM, &fio_old_sig_term, &old);\n  sigaction(SIGPIPE, &fio_old_sig_pipe, &old);\n  if (fio_old_sig_chld.sa_handler)\n    sigaction(SIGCHLD, &fio_old_sig_chld, &old);\n#if !FIO_DISABLE_HOT_RESTART\n  sigaction(SIGUSR1, &fio_old_sig_usr1, &old);\n  memset(&fio_old_sig_usr1, 0, sizeof(fio_old_sig_usr1));\n#endif\n  memset(&fio_old_sig_int, 0, sizeof(fio_old_sig_int));\n  memset(&fio_old_sig_term, 0, sizeof(fio_old_sig_term));\n  memset(&fio_old_sig_pipe, 0, sizeof(fio_old_sig_pipe));\n  memset(&fio_old_sig_chld, 0, sizeof(fio_old_sig_chld));\n}",
      "cve_list": [
        "CVE-2024-22050"
      ],
      "cwe_list": [
        "CWE-22"
      ]
    },
    {
      "project": "iodine",
      "filepath": "ext/iodine/fio.c",
      "func_name": "fio_signal_handler_setup",
      "func_body": "static void fio_signal_handler_setup(void) {\n  /* setup signal handling */\n  struct sigaction act;\n  if (fio_trylock(&fio_signal_set_flag))\n    return;\n\n  memset(&act, 0, sizeof(act));\n\n  act.sa_handler = sig_int_handler;\n  sigemptyset(&act.sa_mask);\n  act.sa_flags = SA_RESTART | SA_NOCLDSTOP;\n\n  if (sigaction(SIGINT, &act, &fio_old_sig_int)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n\n  if (sigaction(SIGTERM, &act, &fio_old_sig_term)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#if !FIO_DISABLE_HOT_RESTART\n  if (sigaction(SIGUSR1, &act, &fio_old_sig_usr1)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#endif\n\n  act.sa_handler = SIG_IGN;\n  if (sigaction(SIGPIPE, &act, &fio_old_sig_pipe)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n}",
      "cve_list": [
        "CVE-2024-22050"
      ],
      "cwe_list": [
        "CWE-22"
      ]
    },
    {
      "project": "iodine",
      "filepath": "ext/iodine/fio.c",
      "func_name": "fio_timer_calc_due",
      "func_body": "static struct timespec fio_timer_calc_due(size_t interval) {\n  struct timespec now = fio_last_tick();\n  if (interval >= 1000) {\n    unsigned long long secs = interval / 1000;\n    now.tv_sec += secs;\n    interval -= secs * 1000;\n  }\n  now.tv_nsec += (interval * 1000000UL);\n  if (now.tv_nsec >= 1000000000L) {\n    now.tv_nsec -= 1000000000L;\n    now.tv_sec += 1;\n  }\n  return now;\n}",
      "cve_list": [
        "CVE-2024-22050"
      ],
      "cwe_list": [
        "CWE-22"
      ]
    },
    {
      "project": "iodine",
      "filepath": "ext/iodine/fio.c",
      "func_name": "fio_worker_cleanup",
      "func_body": "static void fio_worker_cleanup(void) {\n  /* switch to winding down */\n  if (fio_data->is_worker)\n    FIO_LOG_INFO(\"(%d) detected exit signal.\", (int)getpid());\n  else\n    FIO_LOG_INFO(\"Server Detected exit signal.\");\n  fio_state_callback_force(FIO_CALL_ON_SHUTDOWN);\n  for (size_t i = 0; i <= fio_data->max_protocol_fd; ++i) {\n    if (fd_data(i).protocol) {\n      fio_defer_push_task(deferred_on_shutdown, (void *)fd2uuid(i), NULL);\n    }\n  }\n  fio_defer_push_task(fio_cycle_unwind, NULL, NULL);\n  fio_defer_perform();\n  for (size_t i = 0; i <= fio_data->max_protocol_fd; ++i) {\n    if (fd_data(i).protocol || fd_data(i).open) {\n      fio_force_close(fd2uuid(i));\n    }\n  }\n  fio_timer_clear_all();\n  fio_defer_perform();\n  if (!fio_data->is_worker) {\n    kill(0, SIGINT);\n    while (wait(NULL) != -1)\n      ;\n  }\n  fio_defer_perform();\n  fio_state_callback_force(FIO_CALL_ON_FINISH);\n  fio_defer_perform();\n  fio_signal_handler_reset();\n  if (fio_data->parent == getpid()) {\n    FIO_LOG_INFO(\"   ---  Shutdown Complete  ---\\n\");\n  } else {\n    FIO_LOG_INFO(\"(%d) cleanup complete.\", (int)getpid());\n  }\n}",
      "cve_list": [
        "CVE-2024-22050"
      ],
      "cwe_list": [
        "CWE-22"
      ]
    },
    {
      "project": "iodine",
      "filepath": "ext/iodine/fio.c",
      "func_name": "sig_int_handler",
      "func_body": "static void sig_int_handler(int sig) {\n  struct sigaction *old = NULL;\n  switch (sig) {\n#if !FIO_DISABLE_HOT_RESTART\n  case SIGUSR1:\n    fio_signal_children_flag = 1;\n    old = &fio_old_sig_usr1;\n    break;\n#endif\n    /* fallthrough */\n  case SIGINT:\n    if (!old)\n      old = &fio_old_sig_int;\n    /* fallthrough */\n  case SIGTERM:\n    if (!old)\n      old = &fio_old_sig_term;\n    fio_stop();\n    break;\n  case SIGPIPE:\n    if (!old)\n      old = &fio_old_sig_pipe;\n  /* fallthrough */\n  default:\n    break;\n  }\n  /* propagate signale handling to previous existing handler (if any) */\n  if (old && old->sa_handler != SIG_IGN && old->sa_handler != SIG_DFL)\n    old->sa_handler(sig);\n}",
      "cve_list": [
        "CVE-2024-22050"
      ],
      "cwe_list": [
        "CWE-22"
      ]
    },
    {
      "project": "iodine",
      "filepath": "ext/iodine/fio_cli.c",
      "func_name": "fio_cli_set_arg",
      "func_body": "static void fio_cli_set_arg(cstr_s arg, char const *value, char const *line,\n                            fio_cli_parser_data_s *parser) {\n  /* handle unnamed argument */\n  if (!line || !arg.len) {\n    if (!value) {\n      goto print_help;\n    }\n    if (!strcmp(value, \"-?\") || !strcasecmp(value, \"-h\") ||\n        !strcasecmp(value, \"-help\") || !strcasecmp(value, \"--help\")) {\n      goto print_help;\n    }\n    cstr_s n = {.len = ++parser->unnamed_count};\n    fio_cli_hash_insert(&fio_values, n.len, n, value, NULL);\n    if (parser->unnamed_max >= 0 &&\n        parser->unnamed_count > parser->unnamed_max) {\n      arg.len = 0;\n      goto error;\n    }\n    return;\n  }\n\n  /* validate data types */\n  char const *type = fio_cli_get_line_type(parser, line);\n  switch ((size_t)type) {\n  case FIO_CLI_BOOL__TYPE_I:\n    if (value && value != parser->argv[parser->pos + 1]) {\n      goto error;\n    }\n    value = \"1\";\n    break;\n  case FIO_CLI_INT__TYPE_I:\n    if (value) {\n      char const *tmp = value;\n      fio_atol((char **)&tmp);\n      if (*tmp) {\n        goto error;\n      }\n    }\n    /* fallthrough */\n  case FIO_CLI_STRING__TYPE_I:\n    if (!value)\n      goto error;\n    if (!value[0])\n      goto finish;\n    break;\n  }\n\n  /* add values using all aliases possible */\n  {\n    cstr_s n = {.data = line};\n    while (n.data[0] == '-') {\n      while (n.data[n.len] && n.data[n.len] != ' ' && n.data[n.len] != ',') {\n        ++n.len;\n      }\n      fio_cli_hash_insert(&fio_values, FIO_CLI_HASH_VAL(n), n, value, NULL);\n      while (n.data[n.len] && (n.data[n.len] == ' ' || n.data[n.len] == ',')) {\n        ++n.len;\n      }\n      n.data += n.len;\n      n.len = 0;\n    }\n  }\n\nfinish:\n\n  /* handle additional argv progress (if value is on separate argv) */\n  if (value && parser->pos < parser->argc &&\n      value == parser->argv[parser->pos + 1])\n    ++parser->pos;\n  return;\n\nerror: /* handle errors*/\n  /* TODO! */\n  fprintf(stderr, \"\\n\\r\\x1B[31mError:\\x1B[0m unknown argument %.*s %s %s\\n\\n\",\n          (int)arg.len, arg.data, arg.len ? \"with value\" : \"\",\n          value ? (value[0] ? value : \"(empty)\") : \"(null)\");\nprint_help:\n  fprintf(stderr, \"\\n%s\\n\",\n          parser->description ? parser->description\n                              : \"This application accepts any of the following \"\n                                \"possible arguments:\");\n  /* print out each line's arguments */\n  char const **pos = parser->names;\n  while (*pos) {\n    switch ((intptr_t)*pos) {\n    case FIO_CLI_STRING__TYPE_I: /* fallthrough */\n    case FIO_CLI_BOOL__TYPE_I:   /* fallthrough */\n    case FIO_CLI_INT__TYPE_I:    /* fallthrough */\n    case FIO_CLI_PRINT__TYPE_I:  /* fallthrough */\n    case FIO_CLI_PRINT_HEADER__TYPE_I:\n      ++pos;\n      continue;\n    }\n    type = (char *)FIO_CLI_STRING__TYPE_I;\n    switch ((intptr_t)pos[1]) {\n    case FIO_CLI_PRINT__TYPE_I:\n      fprintf(stderr, \"%s\\n\", pos[0]);\n      pos += 2;\n      continue;\n    case FIO_CLI_PRINT_HEADER__TYPE_I:\n      fprintf(stderr, \"\\n\\x1B[4m%s\\x1B[0m\\n\", pos[0]);\n      pos += 2;\n      continue;\n\n    case FIO_CLI_STRING__TYPE_I: /* fallthrough */\n    case FIO_CLI_BOOL__TYPE_I:   /* fallthrough */\n    case FIO_CLI_INT__TYPE_I:    /* fallthrough */\n      type = pos[1];\n    }\n    /* print line @ pos, starting with main argument name */\n    int alias_count = 0;\n    int first_len = 0;\n    size_t tmp = 0;\n    char const *const p = *pos;\n    while (p[tmp] == '-') {\n      while (p[tmp] && p[tmp] != ' ' && p[tmp] != ',') {\n        if (!alias_count)\n          ++first_len;\n        ++tmp;\n      }\n      ++alias_count;\n      while (p[tmp] && (p[tmp] == ' ' || p[tmp] == ',')) {\n        ++tmp;\n      }\n    }\n    switch ((size_t)type) {\n    case FIO_CLI_STRING__TYPE_I:\n      fprintf(stderr, \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m <>\\x1B[0m\\t%s\\n\", first_len,\n              p, p + tmp);\n      break;\n    case FIO_CLI_BOOL__TYPE_I:\n      fprintf(stderr, \" \\x1B[1m%.*s\\x1B[0m   \\t%s\\n\", first_len, p, p + tmp);\n      break;\n    case FIO_CLI_INT__TYPE_I:\n      fprintf(stderr, \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m ##\\x1B[0m\\t%s\\n\", first_len,\n              p, p + tmp);\n      break;\n    }\n    /* print aliase information */\n    tmp = first_len;\n    while (p[tmp] && (p[tmp] == ' ' || p[tmp] == ',')) {\n      ++tmp;\n    }\n    while (p[tmp] == '-') {\n      const size_t start = tmp;\n      while (p[tmp] && p[tmp] != ' ' && p[tmp] != ',') {\n        ++tmp;\n      }\n      int padding = first_len - (tmp - start);\n      if (padding < 0)\n        padding = 0;\n      switch ((size_t)type) {\n      case FIO_CLI_STRING__TYPE_I:\n        fprintf(stderr,\n                \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m <>\\x1B[0m%*s\\t(same as \"\n                \"\\x1B[1m%.*s\\x1B[0m)\\n\",\n                (int)(tmp - start), p + start, padding, \"\", first_len, p);\n        break;\n      case FIO_CLI_BOOL__TYPE_I:\n        fprintf(stderr,\n                \" \\x1B[1m%.*s\\x1B[0m   %*s\\t(same as \\x1B[1m%.*s\\x1B[0m)\\n\",\n                (int)(tmp - start), p + start, padding, \"\", first_len, p);\n        break;\n      case FIO_CLI_INT__TYPE_I:\n        fprintf(stderr,\n                \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m ##\\x1B[0m%*s\\t(same as \"\n                \"\\x1B[1m%.*s\\x1B[0m)\\n\",\n                (int)(tmp - start), p + start, padding, \"\", first_len, p);\n        break;\n      }\n    }\n\n    ++pos;\n  }\n  fprintf(stderr, \"\\nUse any of the following input formats:\\n\"\n                  \"\\t-arg <value>\\t-arg=<value>\\t-arg<value>\\n\"\n                  \"\\n\"\n                  \"Use the -h, -help or -? to get this information again.\\n\"\n                  \"\\n\");\n  fio_cli_end();\n  exit(0);\n}",
      "cve_list": [
        "CVE-2024-22050"
      ],
      "cwe_list": [
        "CWE-22"
      ]
    },
    {
      "project": "iodine",
      "filepath": "ext/iodine/fio_tls_missing.c",
      "func_name": "fio_tls_destroy",
      "func_body": "void FIO_TLS_WEAK fio_tls_destroy(fio_tls_s *tls) {\n  if (!tls)\n    return;\n  REQUIRE_LIBRARY();\n  if (fio_atomic_sub(&tls->ref, 1))\n    return;\n  fio_tls_destroy_context(tls);\n  alpn_list_free(&tls->alpn);\n  cert_ary_free(&tls->sni);\n  trust_ary_free(&tls->trust);\n  free(tls);\n}",
      "cve_list": [
        "CVE-2024-22050"
      ],
      "cwe_list": [
        "CWE-22"
      ]
    },
    {
      "project": "iodine",
      "filepath": "ext/iodine/http.c",
      "func_name": "http_sendfile2",
      "func_body": "int http_sendfile2(http_s *h, const char *prefix, size_t prefix_len,\n                   const char *encoded, size_t encoded_len) {\n  if (HTTP_INVALID_HANDLE(h))\n    return -1;\n  struct stat file_data = {.st_size = 0};\n  static uint64_t accept_enc_hash = 0;\n  if (!accept_enc_hash)\n    accept_enc_hash = fiobj_hash_string(\"accept-encoding\", 15);\n  static uint64_t range_hash = 0;\n  if (!range_hash)\n    range_hash = fiobj_hash_string(\"range\", 5);\n\n  /* create filename string */\n  FIOBJ filename = fiobj_str_tmp();\n  if (prefix && prefix_len) {\n    /* start with prefix path */\n    if (encoded && prefix[prefix_len - 1] == '/' && encoded[0] == '/')\n      --prefix_len;\n    fiobj_str_capa_assert(filename, prefix_len + encoded_len + 4);\n    fiobj_str_write(filename, prefix, prefix_len);\n  }\n  {\n    /* decode filename in cases where it's URL encoded */\n    fio_str_info_s tmp = fiobj_obj2cstr(filename);\n    if (encoded) {\n      char *pos = (char *)encoded;\n      const char *end = encoded + encoded_len;\n      while (pos < end) {\n        if (*pos == '%') {\n          // decode hex value (this is a percent encoded value).\n          if (hex2byte((uint8_t *)tmp.data + tmp.len, (uint8_t *)pos + 1))\n            return -1;\n          tmp.len++;\n          pos += 3;\n        } else\n          tmp.data[tmp.len++] = *(pos++);\n      }\n      tmp.data[tmp.len] = 0;\n      fiobj_str_resize(filename, tmp.len);\n      /* test for path manipulations after decoding */\n      if (http_test_encoded_path(tmp.data + prefix_len, tmp.len - prefix_len))\n        return -1;\n    }\n    if (tmp.data[tmp.len - 1] == '/')\n      fiobj_str_write(filename, \"index.html\", 10);\n  }\n  /* test for file existance  */\n\n  int file = -1;\n  uint8_t is_gz = 0;\n\n  fio_str_info_s s = fiobj_obj2cstr(filename);\n  {\n    FIOBJ tmp = fiobj_hash_get2(h->headers, accept_enc_hash);\n    if (!tmp)\n      goto no_gzip_support;\n    fio_str_info_s ac_str = fiobj_obj2cstr(tmp);\n    if (!ac_str.data || !strstr(ac_str.data, \"gzip\"))\n      goto no_gzip_support;\n    if (s.data[s.len - 3] != '.' || s.data[s.len - 2] != 'g' ||\n        s.data[s.len - 1] != 'z') {\n      fiobj_str_write(filename, \".gz\", 3);\n      s = fiobj_obj2cstr(filename);\n      if (!stat(s.data, &file_data) &&\n          (S_ISREG(file_data.st_mode) || S_ISLNK(file_data.st_mode))) {\n        is_gz = 1;\n        goto found_file;\n      }\n      fiobj_str_resize(filename, s.len - 3);\n    }\n  }\nno_gzip_support:\n  if (stat(s.data, &file_data) ||\n      !(S_ISREG(file_data.st_mode) || S_ISLNK(file_data.st_mode)))\n    return -1;\nfound_file:\n  /* set last-modified */\n  {\n    FIOBJ tmp = fiobj_str_buf(32);\n    fiobj_str_resize(\n        tmp, http_time2str(fiobj_obj2cstr(tmp).data, file_data.st_mtime));\n    http_set_header(h, HTTP_HEADER_LAST_MODIFIED, tmp);\n  }\n  /* set cache-control */\n  http_set_header(h, HTTP_HEADER_CACHE_CONTROL, fiobj_dup(HTTP_HVALUE_MAX_AGE));\n  /* set & test etag */\n  uint64_t etag = (uint64_t)file_data.st_size;\n  etag ^= (uint64_t)file_data.st_mtime;\n  etag = fiobj_hash_string(&etag, sizeof(uint64_t));\n  FIOBJ etag_str = fiobj_str_buf(32);\n  fiobj_str_resize(etag_str,\n                   fio_base64_encode(fiobj_obj2cstr(etag_str).data,\n                                     (void *)&etag, sizeof(uint64_t)));\n  /* set */\n  http_set_header(h, HTTP_HEADER_ETAG, etag_str);\n  /* test */\n  {\n    static uint64_t none_match_hash = 0;\n    if (!none_match_hash)\n      none_match_hash = fiobj_hash_string(\"if-none-match\", 13);\n    FIOBJ tmp2 = fiobj_hash_get2(h->headers, none_match_hash);\n    if (tmp2 && fiobj_iseq(tmp2, etag_str)) {\n      h->status = 304;\n      http_finish(h);\n      return 0;\n    }\n  }\n  /* handle range requests */\n  int64_t offset = 0;\n  int64_t length = file_data.st_size;\n  {\n    static uint64_t ifrange_hash = 0;\n    if (!ifrange_hash)\n      ifrange_hash = fiobj_hash_string(\"if-range\", 8);\n    FIOBJ tmp = fiobj_hash_get2(h->headers, ifrange_hash);\n    if (tmp && fiobj_iseq(tmp, etag_str)) {\n      fiobj_hash_delete2(h->headers, range_hash);\n    } else {\n      tmp = fiobj_hash_get2(h->headers, range_hash);\n      if (tmp) {\n        /* range ahead... */\n        if (FIOBJ_TYPE_IS(tmp, FIOBJ_T_ARRAY))\n          tmp = fiobj_ary_index(tmp, 0);\n        fio_str_info_s range = fiobj_obj2cstr(tmp);\n        if (!range.data || memcmp(\"bytes=\", range.data, 6))\n          goto open_file;\n        char *pos = range.data + 6;\n        int64_t start_at = 0, end_at = 0;\n        start_at = fio_atol(&pos);\n        if (start_at >= file_data.st_size)\n          goto open_file;\n        if (start_at >= 0) {\n          pos++;\n          end_at = fio_atol(&pos);\n          if (end_at <= 0)\n            goto open_file;\n        }\n        /* we ignore multimple ranges, only responding with the first range. */\n        if (start_at < 0) {\n          if (0 - start_at < file_data.st_size) {\n            offset = file_data.st_size - start_at;\n            length = 0 - start_at;\n          }\n        } else if (end_at) {\n          offset = start_at;\n          length = end_at - start_at + 1;\n          if (length + start_at > file_data.st_size || length <= 0)\n            length = length - start_at;\n        } else {\n          offset = start_at;\n          length = length - start_at;\n        }\n        h->status = 206;\n\n        {\n          FIOBJ cranges = fiobj_str_buf(1);\n          fiobj_str_printf(cranges, \"bytes %lu-%lu/%lu\",\n                           (unsigned long)start_at,\n                           (unsigned long)(start_at + length - 1),\n                           (unsigned long)file_data.st_size);\n          http_set_header(h, HTTP_HEADER_CONTENT_RANGE, cranges);\n        }\n        http_set_header(h, HTTP_HEADER_ACCEPT_RANGES,\n                        fiobj_dup(HTTP_HVALUE_BYTES));\n      }\n    }\n  }\n  /* test for an OPTIONS request or invalid methods */\n  s = fiobj_obj2cstr(h->method);\n  switch (s.len) {\n  case 7:\n    if (!strncasecmp(\"options\", s.data, 7)) {\n      http_set_header2(h, (fio_str_info_s){.data = (char *)\"allow\", .len = 5},\n                       (fio_str_info_s){.data = (char *)\"GET, HEAD\", .len = 9});\n      h->status = 200;\n      http_finish(h);\n      return 0;\n    }\n    break;\n  case 3:\n    if (!strncasecmp(\"get\", s.data, 3))\n      goto open_file;\n    break;\n  case 4:\n    if (!strncasecmp(\"head\", s.data, 4)) {\n      http_set_header(h, HTTP_HEADER_CONTENT_LENGTH, fiobj_num_new(length));\n      http_finish(h);\n      return 0;\n    }\n    break;\n  }\n  http_send_error(h, 403);\n  return 0;\nopen_file:\n  s = fiobj_obj2cstr(filename);\n  file = open(s.data, O_RDONLY);\n  if (file == -1) {\n    FIO_LOG_ERROR(\"(HTTP) couldn't open file %s!\\n\", s.data);\n    perror(\"     \");\n    http_send_error(h, 500);\n    return 0;\n  }\n  {\n    FIOBJ tmp = 0;\n    uintptr_t pos = 0;\n    if (is_gz) {\n      http_set_header(h, HTTP_HEADER_CONTENT_ENCODING,\n                      fiobj_dup(HTTP_HVALUE_GZIP));\n\n      pos = s.len - 4;\n      while (pos && s.data[pos] != '.')\n        pos--;\n      pos++; /* assuming, but that's fine. */\n      tmp = http_mimetype_find(s.data + pos, s.len - pos - 3);\n\n    } else {\n      pos = s.len - 1;\n      while (pos && s.data[pos] != '.')\n        pos--;\n      pos++; /* assuming, but that's fine. */\n      tmp = http_mimetype_find(s.data + pos, s.len - pos);\n    }\n    if (tmp)\n      http_set_header(h, HTTP_HEADER_CONTENT_TYPE, tmp);\n  }\n  http_sendfile(h, file, length, offset);\n  return 0;\n}",
      "cve_list": [
        "CVE-2024-22050"
      ],
      "cwe_list": [
        "CWE-22"
      ]
    },
    {
      "project": "iodine",
      "filepath": "ext/iodine/http.c",
      "func_name": "http_test_encoded_path",
      "func_body": "static inline int http_test_encoded_path(const char *mem, size_t len) {\n  const char *pos = NULL;\n  const char *end = mem + len;\n  while (mem < end && (pos = memchr(mem, '/', (size_t)len))) {\n    len = end - pos;\n    mem = pos + 1;\n    if (pos[1] == '/')\n      return -1;\n    if (len > 3 && pos[1] == '.' && pos[2] == '.' && pos[3] == '/')\n      return -1;\n  }\n  return 0;\n}",
      "cve_list": [
        "CVE-2024-22050"
      ],
      "cwe_list": [
        "CWE-22"
      ]
    },
    {
      "project": "iodine",
      "filepath": "ext/iodine/http1.c",
      "func_name": "http1_consume_data",
      "func_body": "static inline void http1_consume_data(intptr_t uuid, http1pr_s *p) {\n  if (fio_pending(uuid) > 4) {\n    goto throttle;\n  }\n  ssize_t i = 0;\n  size_t org_len = p->buf_len;\n  int pipeline_limit = 8;\n  if (!p->buf_len)\n    return;\n  do {\n    i = http1_fio_parser(.parser = &p->parser,\n                         .buffer = p->buf + (org_len - p->buf_len),\n                         .length = p->buf_len, .on_request = http1_on_request,\n                         .on_response = http1_on_response,\n                         .on_method = http1_on_method,\n                         .on_status = http1_on_status, .on_path = http1_on_path,\n                         .on_query = http1_on_query,\n                         .on_http_version = http1_on_http_version,\n                         .on_header = http1_on_header,\n                         .on_body_chunk = http1_on_body_chunk,\n                         .on_error = http1_on_error);\n    p->buf_len -= i;\n    --pipeline_limit;\n  } while (i && p->buf_len && pipeline_limit && !p->stop);\n\n  if (p->buf_len && org_len != p->buf_len) {\n    memmove(p->buf, p->buf + (org_len - p->buf_len), p->buf_len);\n  }\n\n  if (p->buf_len == HTTP_MAX_HEADER_LENGTH) {\n    /* no room to read... parser not consuming data */\n    if (p->request.method)\n      http_send_error(&p->request, 413);\n    else {\n      p->request.method = fiobj_str_tmp();\n      http_send_error(&p->request, 413);\n    }\n  }\n\n  if (!pipeline_limit) {\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  return;\n\nthrottle:\n  /* throttle busy clients (slowloris) */\n  p->stop |= 4;\n  fio_suspend(uuid);\n  FIO_LOG_DEBUG(\"(HTTP/1,1) throttling client at %.*s\",\n                (int)fio_peer_addr(uuid).len, fio_peer_addr(uuid).data);\n}",
      "cve_list": [
        "CVE-2024-22050"
      ],
      "cwe_list": [
        "CWE-22"
      ]
    },
    {
      "project": "iodine",
      "filepath": "ext/iodine/http1.c",
      "func_name": "http1_on_error",
      "func_body": "static int http1_on_error(http1_parser_s *parser) {\n  if (parser2http(parser)->close)\n    return -1;\n  FIO_LOG_DEBUG(\"HTTP parser error.\");\n  fio_close(parser2http(parser)->p.uuid);\n  return -1;\n}",
      "cve_list": [
        "CVE-2024-22050"
      ],
      "cwe_list": [
        "CWE-22"
      ]
    },
    {
      "project": "iodine",
      "filepath": "ext/iodine/http1.c",
      "func_name": "http1_on_ready",
      "func_body": "static void http1_on_ready(intptr_t uuid, fio_protocol_s *protocol) {\n  /* resume slow clients from suspension */\n  http1pr_s *p = (http1pr_s *)protocol;\n  if (p->stop & 4) {\n    p->stop ^= 4; /* flip back the bit, so it's zero */\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  (void)protocol;\n}",
      "cve_list": [
        "CVE-2024-22050"
      ],
      "cwe_list": [
        "CWE-22"
      ]
    },
    {
      "project": "iodine",
      "filepath": "ext/iodine/http1.c",
      "func_name": "http1_on_request",
      "func_body": "static int http1_on_request(http1_parser_s *parser) {\n  http1pr_s *p = parser2http(parser);\n  http_on_request_handler______internal(&http1_pr2handle(p), p->p.settings);\n  if (p->request.method && !p->stop)\n    http_finish(&p->request);\n  h1_reset(p);\n  return fio_is_closed(p->p.uuid);\n}",
      "cve_list": [
        "CVE-2024-22050"
      ],
      "cwe_list": [
        "CWE-22"
      ]
    },
    {
      "project": "iodine",
      "filepath": "ext/iodine/http1.c",
      "func_name": "http1_on_response",
      "func_body": "static int http1_on_response(http1_parser_s *parser) {\n  http1pr_s *p = parser2http(parser);\n  http_on_response_handler______internal(&http1_pr2handle(p), p->p.settings);\n  if (p->request.status_str && !p->stop)\n    http_finish(&p->request);\n  h1_reset(p);\n  return fio_is_closed(p->p.uuid);\n}",
      "cve_list": [
        "CVE-2024-22050"
      ],
      "cwe_list": [
        "CWE-22"
      ]
    },
    {
      "project": "iodine",
      "filepath": "ext/iodine/iodine_mustache.c",
      "func_name": "fiobj_mustache_find_obj_absolute",
      "func_body": "static inline VALUE fiobj_mustache_find_obj_absolute(VALUE udata,\n                                                     const char *name,\n                                                     uint32_t name_len) {\n  VALUE tmp;\n  if (!RB_TYPE_P(udata, T_HASH)) {\n    if (name_len == 1 && name[0] == '.')\n      return udata;\n    /* search by method */\n    ID name_id = rb_intern2(name, name_len);\n    if (rb_respond_to(udata, name_id)) {\n      return IodineCaller.call(udata, name_id);\n    }\n    return Qnil;\n  }\n  /* search by Symbol */\n  ID name_id = rb_intern2(name, name_len);\n  VALUE key = ID2SYM(name_id);\n  tmp = rb_hash_lookup2(udata, key, Qundef);\n  if (tmp != Qundef)\n    return tmp;\n  /* search by String */\n  key = rb_sym2str(key);\n  tmp = rb_hash_lookup2(udata, key, Qundef);\n  rb_str_free(key);\n  if (tmp != Qundef)\n    return tmp;\n  /* search by method */\n  tmp = Qnil;\n  if (rb_respond_to(udata, name_id)) {\n    tmp = IodineCaller.call(udata, name_id);\n  }\n\n  return tmp;\n}",
      "cve_list": [
        "CVE-2024-22050"
      ],
      "cwe_list": [
        "CWE-22"
      ]
    },
    {
      "project": "bpftrace",
      "filepath": "tests/utils.cpp",
      "func_name": "bpftrace::file_exists_and_ownedby_root",
      "func_body": "bool file_exists_and_ownedby_root(const char *f)\n{\n  struct stat st;\n  if (stat(f, &st) == 0) {\n    if (st.st_uid != 0) {\n      LOG(ERROR) << \"header file ownership expected to be root: \"\n                 << std::string(f);\n      return false;\n    }\n    return true;\n  }\n  return false;\n}",
      "cve_list": [
        "CVE-2024-2313"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "bpftrace",
      "filepath": "tests/utils.cpp",
      "func_name": "bpftrace::unpack_kheaders_tar_xz",
      "func_body": "std::string unpack_kheaders_tar_xz(const struct utsname &utsname)\n{\n  std::error_code ec;\n#if defined(__ANDROID__)\n  std_filesystem::path path_prefix{ \"/data/local/tmp\" };\n#else\n  std_filesystem::path path_prefix{ \"/tmp\" };\n#endif\n  std_filesystem::path path_kheaders{ PROC_KHEADERS_PATH };\n  if (const char *tmpdir = ::getenv(\"TMPDIR\")) {\n    path_prefix = tmpdir;\n  }\n  path_prefix /= \"kheaders-\";\n  std_filesystem::path shared_path{ path_prefix.string() + utsname.release };\n\n  if (file_exists_and_ownedby_root(shared_path.c_str())) {\n    // already unpacked\n    return shared_path.string();\n  }\n\n  if (!std_filesystem::exists(path_kheaders, ec)) {\n    StderrSilencer silencer;\n    silencer.silence();\n\n    FILE *modprobe = ::popen(\"modprobe kheaders\", \"w\");\n    if (modprobe == nullptr || pclose(modprobe) != 0) {\n      return \"\";\n    }\n\n    if (!std_filesystem::exists(path_kheaders, ec)) {\n      return \"\";\n    }\n  }\n\n  KernelHeaderTmpDir tmpdir{ path_prefix };\n\n  FILE *tar = ::popen((\"tar xf \" + std::string(PROC_KHEADERS_PATH) + \" -C \" +\n                       tmpdir.path)\n                          .c_str(),\n                      \"w\");\n  if (!tar) {\n    return \"\";\n  }\n\n  int rc = ::pclose(tar);\n  if (rc == 0) {\n    tmpdir.move_to(shared_path);\n    return shared_path;\n  }\n\n  return \"\";\n}",
      "cve_list": [
        "CVE-2024-2313"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "bpftrace",
      "filepath": "tests/utils.cpp",
      "func_name": "bpftrace::test::utils::TEST",
      "func_body": "TEST(utils, file_exists_and_ownedby_root)\n{\n  std::string tmpdir = \"/tmp/bpftrace-test-utils-XXXXXX\";\n  std::string file1 = \"/ownedby-user\";\n  std::string file2 = \"/no-exists\";\n  if (::mkdtemp(tmpdir.data()) == nullptr) {\n    throw std::runtime_error(\"creating temporary path for tests failed\");\n  }\n\n  int fd;\n  fd = open((tmpdir + file1).c_str(), O_CREAT, S_IRUSR);\n  close(fd);\n  ASSERT_GE(fd, 0);\n\n  EXPECT_FALSE(file_exists_and_ownedby_root((tmpdir + file1).c_str()));\n  EXPECT_FALSE(file_exists_and_ownedby_root((tmpdir + file2).c_str()));\n  EXPECT_TRUE(file_exists_and_ownedby_root(\"/proc/1/maps\"));\n\n  EXPECT_GT(std_filesystem::remove_all(tmpdir), 0);\n}",
      "cve_list": [
        "CVE-2024-2313"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "bcc",
      "filepath": "src/cc/frontends/clang/kbuild_helper.cc",
      "func_name": "ebpf::file_exists_and_ownedby",
      "func_body": "static inline int file_exists_and_ownedby(const char *f, uid_t uid)\n{\n  struct stat buffer;\n  int ret;\n  if ((ret = stat(f, &buffer)) == 0) {\n    if (buffer.st_uid != uid) {\n      std::cout << \"ERROR: header file ownership unexpected: \" << std::string(f) << \"\\n\";\n      return -1;\n    }\n  }\n  return ret;\n}",
      "cve_list": [
        "CVE-2024-2314"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "bcc",
      "filepath": "src/cc/frontends/clang/kbuild_helper.cc",
      "func_name": "ebpf::get_proc_kheaders",
      "func_body": "int get_proc_kheaders(std::string &dirpath)\n{\n  struct utsname uname_data;\n  char dirpath_tmp[256];\n\n  if (uname(&uname_data))\n    return -errno;\n\n  snprintf(dirpath_tmp, 256, \"%s/kheaders-%s\", get_tmp_dir(),\n           uname_data.release);\n  dirpath = std::string(dirpath_tmp);\n\n  if (file_exists_and_ownedby(dirpath_tmp, 0))\n    return 0;\n\n  // First time so extract it\n  return extract_kheaders(dirpath, uname_data);\n}",
      "cve_list": [
        "CVE-2024-2314"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "bcc",
      "filepath": "src/cc/frontends/clang/kbuild_helper.cc",
      "func_name": "ebpf::proc_kheaders_exists",
      "func_body": "static inline int proc_kheaders_exists(void)\n{\n  return file_exists_and_ownedby(PROC_KHEADERS_PATH, 0);\n}",
      "cve_list": [
        "CVE-2024-2314"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "darkhttpd",
      "filepath": "darkhttpd.c",
      "func_name": "password_equal",
      "func_body": "int password_equal(const char *user_input, const char *secret) {\n    size_t i = 0;\n    size_t j = 0;\n    char out = 0;\n\n    while (1) {\n        /* Out stays zero if the strings are the same. */\n        out |= user_input[i] ^ secret[j];\n\n        /* Stop at end of user_input. */\n        if (user_input[i] == 0) break;\n        i++;\n\n        /* Don't go past end of secret. */\n        if (secret[j] != 0) j++;\n    }\n\n    /* Check length after loop, otherwise early exit would leak length. */\n    out |= (i != j); /* Secret was shorter. */\n    out |= (secret[j] != 0); /* Secret was longer; j is not the end. */\n    return out == 0;\n}",
      "cve_list": [
        "CVE-2024-23771"
      ],
      "cwe_list": [
        "CWE-203"
      ]
    },
    {
      "project": "darkhttpd",
      "filepath": "darkhttpd.c",
      "func_name": "process_request",
      "func_body": "static void process_request(struct connection *conn) {\n    num_requests++;\n\n    if (!parse_request(conn)) {\n        default_reply(conn, 400, \"Bad Request\",\n            \"You sent a request that the server couldn't understand.\");\n    }\n    else if (is_https_redirect(conn)) {\n        redirect_https(conn);\n    }\n    /* fail if: (auth_enabled) AND (client supplied invalid credentials) */\n    else if (auth_key != NULL &&\n            (conn->authorization == NULL ||\n             !password_equal(conn->authorization, auth_key))) {\n        default_reply(conn, 401, \"Unauthorized\",\n            \"Access denied due to invalid credentials.\");\n    }\n    else if (strcmp(conn->method, \"GET\") == 0) {\n        process_get(conn);\n    }\n    else if (strcmp(conn->method, \"HEAD\") == 0) {\n        process_get(conn);\n        conn->header_only = 1;\n    }\n    else {\n        default_reply(conn, 501, \"Not Implemented\",\n                      \"The method you specified is not implemented.\");\n    }\n\n    /* advance state */\n    conn->state = SEND_HEADER;\n\n    /* request not needed anymore */\n    free(conn->request);\n    conn->request = NULL; /* important: don't free it again later */\n}",
      "cve_list": [
        "CVE-2024-23771"
      ],
      "cwe_list": [
        "CWE-203"
      ]
    },
    {
      "project": "darkhttpd",
      "filepath": "darkhttpd.c",
      "func_name": "usage",
      "func_body": "static void usage(const char *argv0) {\n    printf(\"usage:\\t%s /path/to/wwwroot [flags]\\n\\n\", argv0);\n    printf(\"flags:\\t--port number (default: %u, or 80 if running as root)\\n\"\n    \"\\t\\tSpecifies which port to listen on for connections.\\n\"\n    \"\\t\\tPass 0 to let the system choose any free port for you.\\n\\n\", bindport);\n    printf(\"\\t--addr ip (default: all)\\n\"\n    \"\\t\\tIf multiple interfaces are present, specifies\\n\"\n    \"\\t\\twhich one to bind the listening port to.\\n\\n\");\n    printf(\"\\t--maxconn number (default: system maximum)\\n\"\n    \"\\t\\tSpecifies how many concurrent connections to accept.\\n\\n\");\n    printf(\"\\t--log filename (default: stdout)\\n\"\n    \"\\t\\tSpecifies which file to append the request log to.\\n\\n\");\n    printf(\"\\t--syslog\\n\"\n    \"\\t\\tUse syslog for request log.\\n\\n\");\n    printf(\"\\t--chroot (default: don't chroot)\\n\"\n    \"\\t\\tLocks server into wwwroot directory for added security.\\n\\n\");\n    printf(\"\\t--daemon (default: don't daemonize)\\n\"\n    \"\\t\\tDetach from the controlling terminal and run in the background.\\n\\n\");\n    printf(\"\\t--index filename (default: %s)\\n\"\n    \"\\t\\tDefault file to serve when a directory is requested.\\n\\n\",\n        index_name);\n    printf(\"\\t--no-listing\\n\"\n    \"\\t\\tDo not serve listing if directory is requested.\\n\\n\");\n    printf(\"\\t--mimetypes filename (optional)\\n\"\n    \"\\t\\tParses specified file for extension-MIME associations.\\n\\n\");\n    printf(\"\\t--default-mimetype string (optional, default: %s)\\n\"\n    \"\\t\\tFiles with unknown extensions are served as this mimetype.\\n\\n\",\n        octet_stream);\n    printf(\"\\t--uid uid/uname, --gid gid/gname (default: don't privdrop)\\n\"\n    \"\\t\\tDrops privileges to given uid:gid after initialization.\\n\\n\");\n    printf(\"\\t--pidfile filename (default: no pidfile)\\n\"\n    \"\\t\\tWrite PID to the specified file.  Note that if you are\\n\"\n    \"\\t\\tusing --chroot, then the pidfile must be relative to,\\n\"\n    \"\\t\\tand inside the wwwroot.\\n\\n\");\n    printf(\"\\t--no-keepalive\\n\"\n    \"\\t\\tDisables HTTP Keep-Alive functionality.\\n\\n\");\n#ifdef __FreeBSD__\n    printf(\"\\t--accf (default: don't use acceptfilter)\\n\"\n    \"\\t\\tUse acceptfilter.  Needs the accf_http module loaded.\\n\\n\");\n#endif\n    printf(\"\\t--forward host url (default: don't forward)\\n\"\n    \"\\t\\tWeb forward (301 redirect).\\n\"\n    \"\\t\\tRequests to the host are redirected to the corresponding url.\\n\"\n    \"\\t\\tThe option may be specified multiple times, in which case\\n\"\n    \"\\t\\tthe host is matched in order of appearance.\\n\\n\");\n    printf(\"\\t--forward-all url (default: don't forward)\\n\"\n    \"\\t\\tWeb forward (301 redirect).\\n\"\n    \"\\t\\tAll requests are redirected to the corresponding url.\\n\\n\");\n    printf(\"\\t--no-server-id\\n\"\n    \"\\t\\tDon't identify the server type in headers\\n\"\n    \"\\t\\tor directory listings.\\n\\n\");\n    printf(\"\\t--timeout secs (default: %d)\\n\"\n    \"\\t\\tIf a connection is idle for more than this many seconds,\\n\"\n    \"\\t\\tit will be closed. Set to zero to disable timeouts.\\n\\n\",\n    timeout_secs);\n    printf(\"\\t--auth username:password\\n\"\n    \"\\t\\tEnable basic authentication. This is *INSECURE*: passwords\\n\"\n    \"\\t\\tare sent unencrypted over HTTP, plus the password is visible\\n\"\n    \"\\t\\tin ps(1) to other users on the system.\\n\\n\");\n    printf(\"\\t--forward-https\\n\"\n    \"\\t\\tIf the client requested HTTP, forward to HTTPS.\\n\"\n    \"\\t\\tThis is useful if darkhttpd is behind a reverse proxy\\n\"\n    \"\\t\\tthat supports SSL.\\n\\n\");\n    printf(\"\\t--header 'Header: Value'\\n\"\n    \"\\t\\tAdd a custom header to all responses.\\n\"\n    \"\\t\\tThis option can be specified multiple times, in which case\\n\"\n    \"\\t\\tthe headers are added in order of appearance.\\n\\n\");\n#ifdef HAVE_INET6\n    printf(\"\\t--ipv6\\n\"\n    \"\\t\\tListen on IPv6 address.\\n\\n\");\n#else\n    printf(\"\\t(This binary was built without IPv6 support: -DNO_IPV6)\\n\\n\");\n#endif\n}",
      "cve_list": [
        "CVE-2024-23770"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "libhtp",
      "filepath": "htp/htp_request.c",
      "func_name": "htp_connp_REQ_PROTOCOL",
      "func_body": "htp_status_t htp_connp_REQ_PROTOCOL(htp_connp_t *connp) {\n    // Is this a short-style HTTP/0.9 request? If it is,\n    // we will not want to parse request headers.\n    if (connp->in_tx->is_protocol_0_9 == 0) {\n        // Switch to request header parsing.\n        connp->in_state = htp_connp_REQ_HEADERS;\n        connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n    } else {\n        // Let's check if the protocol was simply missing\n        int64_t pos = connp->in_current_read_offset;\n        // Probe if data looks like a header line\n        while (pos < connp->in_current_len) {\n            if (!htp_is_space(connp->in_current_data[pos])) {\n                htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Request line: missing protocol\");\n                connp->in_tx->is_protocol_0_9 = 0;\n                // Switch to request header parsing.\n                connp->in_state = htp_connp_REQ_HEADERS;\n                connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n                return HTP_OK;\n            }\n            pos++;\n        }\n        // We're done with this request.\n        connp->in_state = htp_connp_REQ_FINALIZE;\n    }\n\n    return HTP_OK;\n}",
      "cve_list": [
        "CVE-2024-28871"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "libhtp",
      "filepath": "htp/htp_request.c",
      "func_name": "htp_connp_REQ_HEADERS",
      "func_body": "htp_status_t htp_connp_REQ_HEADERS(htp_connp_t *connp) {\n    for (;;) {\n        if (connp->in_status == HTP_STREAM_CLOSED) {\n            // Parse previous header, if any.\n            if (connp->in_header != NULL) {\n                if (connp->cfg->process_request_header(connp, bstr_ptr(connp->in_header),\n                                                       bstr_len(connp->in_header)) != HTP_OK)\n                    return HTP_ERROR;\n                bstr_free(connp->in_header);\n                connp->in_header = NULL;\n            }\n\n            htp_connp_req_clear_buffer(connp);\n\n            connp->in_tx->request_progress = HTP_REQUEST_TRAILER;\n\n            // We've seen all the request headers.\n            return htp_tx_state_request_headers(connp->in_tx);\n        }\n        IN_COPY_BYTE_OR_RETURN(connp);\n\n        // Have we reached the end of the line?\n        if (connp->in_next_byte == LF) {\n            unsigned char *data;\n            size_t len;\n\n            if (htp_connp_req_consolidate_data(connp, &data, &len) != HTP_OK) {\n                return HTP_ERROR;\n            }\n\n            #ifdef HTP_DEBUG\n            fprint_raw_data(stderr, __func__, data, len);\n            #endif           \n\n            // Should we terminate headers?\n            if (htp_connp_is_line_terminator(connp, data, len, 0)) {\n                // Parse previous header, if any.\n                if (connp->in_header != NULL) {\n                    if (connp->cfg->process_request_header(connp, bstr_ptr(connp->in_header),\n                            bstr_len(connp->in_header)) != HTP_OK) return HTP_ERROR;\n\n                    bstr_free(connp->in_header);\n                    connp->in_header = NULL;\n                }\n\n                htp_connp_req_clear_buffer(connp);\n\n                // We've seen all the request headers.\n                return htp_tx_state_request_headers(connp->in_tx);\n            }\n\n            htp_chomp(data, &len);\n\n            // Check for header folding.\n            if (htp_connp_is_line_folded(data, len) == 0) {\n                // New header line.\n\n                // Parse previous header, if any.\n                if (connp->in_header != NULL) {\n                    if (connp->cfg->process_request_header(connp, bstr_ptr(connp->in_header),\n                            bstr_len(connp->in_header)) != HTP_OK) return HTP_ERROR;\n\n                    bstr_free(connp->in_header);\n                    connp->in_header = NULL;\n                }\n\n                IN_PEEK_NEXT(connp);\n\n                if (connp->in_next_byte != -1 && htp_is_folding_char(connp->in_next_byte) == 0) {\n                    // Because we know this header is not folded, we can process the buffer straight away.\n                    if (connp->cfg->process_request_header(connp, data, len) != HTP_OK) return HTP_ERROR;\n                } else {\n                    // Keep the partial header data for parsing later.\n                    connp->in_header = bstr_dup_mem(data, len);\n                    if (connp->in_header == NULL) return HTP_ERROR;\n                }\n            } else {\n                // Folding; check that there's a previous header line to add to.\n                if (connp->in_header == NULL) {\n                    // Invalid folding.\n\n                    // Warn only once per transaction.\n                    if (!(connp->in_tx->flags & HTP_INVALID_FOLDING)) {\n                        connp->in_tx->flags |= HTP_INVALID_FOLDING;\n                        htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Invalid request field folding\");\n                    }\n\n                    // Keep the header data for parsing later.\n                    size_t trim = 0;\n                    while(trim < len) {\n                        if (!htp_is_folding_char(data[trim])) {\n                            break;\n                        }\n                        trim++;\n                    }\n                    connp->in_header = bstr_dup_mem(data + trim, len - trim);\n                    if (connp->in_header == NULL) return HTP_ERROR;\n                } else {\n                    // Add to the existing header.\n                    if (bstr_len(connp->in_header) < HTP_MAX_HEADER_FOLDED) {\n                        bstr *new_in_header = bstr_add_mem(connp->in_header, data, len);\n                        if (new_in_header == NULL) return HTP_ERROR;\n                        connp->in_header = new_in_header;\n                    } else {\n                        htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Request field length exceeds folded maximum\");\n                    }\n                }\n            }\n\n            htp_connp_req_clear_buffer(connp);\n        }\n    }\n\n    return HTP_ERROR;\n}",
      "cve_list": [
        "CVE-2024-23837"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "libhtp",
      "filepath": "htp/htp_response.c",
      "func_name": "htp_connp_RES_HEADERS",
      "func_body": "htp_status_t htp_connp_RES_HEADERS(htp_connp_t *connp) {\n    int endwithcr;\n    int lfcrending = 0;\n\n    for (;;) {\n        if (connp->out_status == HTP_STREAM_CLOSED) {\n            // Finalize sending raw trailer data.\n            htp_status_t rc = htp_connp_res_receiver_finalize_clear(connp);\n            if (rc != HTP_OK) return rc;\n\n            // Run hook response_TRAILER.\n            rc = htp_hook_run_all(connp->cfg->hook_response_trailer, connp->out_tx);\n            if (rc != HTP_OK) return rc;\n\n            connp->out_state = htp_connp_RES_FINALIZE;\n            return HTP_OK;\n        }\n        OUT_COPY_BYTE_OR_RETURN(connp);\n\n        // Have we reached the end of the line?\n        if (connp->out_next_byte != LF && connp->out_next_byte != CR) {\n            lfcrending = 0;\n        } else {\n            endwithcr = 0;\n            if (connp->out_next_byte == CR) {\n                OUT_PEEK_NEXT(connp);\n                if (connp->out_next_byte == -1) {\n                    return HTP_DATA_BUFFER;\n                } else if (connp->out_next_byte == LF) {\n                    OUT_COPY_BYTE_OR_RETURN(connp);\n                    if (lfcrending) {\n                        // Handling LFCRCRLFCRLF\n                        // These 6 characters mean only 2 end of lines\n                        OUT_PEEK_NEXT(connp);\n                        if (connp->out_next_byte == CR) {\n                            OUT_COPY_BYTE_OR_RETURN(connp);\n                            connp->out_current_consume_offset++;\n                            OUT_PEEK_NEXT(connp);\n                            if (connp->out_next_byte == LF) {\n                                OUT_COPY_BYTE_OR_RETURN(connp);\n                                connp->out_current_consume_offset++;\n                                htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0,\n                                        \"Weird response end of lines mix\");\n                            }\n                        }\n                    }\n                } else if (connp->out_next_byte == CR) {\n                    continue;\n                }\n                lfcrending = 0;\n                endwithcr = 1;\n            } else {\n                // connp->out_next_byte == LF\n                OUT_PEEK_NEXT(connp);\n                lfcrending = 0;\n                if (connp->out_next_byte == CR) {\n                    // hanldes LF-CR sequence as end of line\n                    OUT_COPY_BYTE_OR_RETURN(connp);\n                    lfcrending = 1;\n                }\n            }\n\n            unsigned char *data;\n            size_t len;\n\n            if (htp_connp_res_consolidate_data(connp, &data, &len) != HTP_OK) {\n                return HTP_ERROR;\n            }\n\n            // CRCRLF is not an empty line\n            if (endwithcr && len < 2) {\n                continue;\n            }\n\n            #ifdef HTP_DEBUG\n            fprint_raw_data(stderr, __func__, data, len);\n            #endif\n\n            int next_no_lf = 0;\n            if (connp->out_current_read_offset < connp->out_current_len &&\n                connp->out_current_data[connp->out_current_read_offset] != LF) {\n                next_no_lf = 1;\n            }\n            // Should we terminate headers?\n            if (htp_connp_is_line_terminator(connp, data, len, next_no_lf)) {\n                // Parse previous header, if any.\n                if (connp->out_header != NULL) {\n                    if (connp->cfg->process_response_header(connp, bstr_ptr(connp->out_header),\n                            bstr_len(connp->out_header)) != HTP_OK) return HTP_ERROR;\n\n                    bstr_free(connp->out_header);\n                    connp->out_header = NULL;\n                }\n\n                htp_connp_res_clear_buffer(connp);\n\n                // We've seen all response headers.\n                if (connp->out_tx->response_progress == HTP_RESPONSE_HEADERS) {\n                    // Response headers.\n\n                    // The next step is to determine if this response has a body.\n                    connp->out_state = htp_connp_RES_BODY_DETERMINE;\n                } else {\n                    // Response trailer.\n\n                    // Finalize sending raw trailer data.\n                    htp_status_t rc = htp_connp_res_receiver_finalize_clear(connp);\n                    if (rc != HTP_OK) return rc;\n\n                    // Run hook response_TRAILER.\n                    rc = htp_hook_run_all(connp->cfg->hook_response_trailer, connp->out_tx);\n                    if (rc != HTP_OK) return rc;\n\n                    // The next step is to finalize this response.\n                    connp->out_state = htp_connp_RES_FINALIZE;\n                }\n\n                return HTP_OK;\n            }\n\n            htp_chomp(data, &len);\n\n            // Check for header folding.\n            if (htp_connp_is_line_folded(data, len) == 0) {\n                // New header line.\n\n                // Parse previous header, if any.\n                if (connp->out_header != NULL) {\n                    if (connp->cfg->process_response_header(connp, bstr_ptr(connp->out_header),\n                            bstr_len(connp->out_header)) != HTP_OK) return HTP_ERROR;\n\n                    bstr_free(connp->out_header);\n                    connp->out_header = NULL;\n                }\n\n                OUT_PEEK_NEXT(connp);\n\n                if (htp_is_folding_char(connp->out_next_byte) == 0) {\n                    // Because we know this header is not folded, we can process the buffer straight away.\n                    if (connp->cfg->process_response_header(connp, data, len) != HTP_OK) return HTP_ERROR;\n                } else {\n                    // Keep the partial header data for parsing later.\n                    connp->out_header = bstr_dup_mem(data, len);\n                    if (connp->out_header == NULL) return HTP_ERROR;\n                }\n            } else {\n                // Folding; check that there's a previous header line to add to.\n                if (connp->out_header == NULL) {\n                    // Invalid folding.\n\n                    // Warn only once per transaction.\n                    if (!(connp->out_tx->flags & HTP_INVALID_FOLDING)) {\n                        connp->out_tx->flags |= HTP_INVALID_FOLDING;\n                        htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Invalid response field folding\");\n                    }\n\n                    // Keep the header data for parsing later.\n                    size_t trim = 0;\n                    while(trim < len) {\n                        if (!htp_is_folding_char(data[trim])) {\n                            break;\n                        }\n                        trim++;\n                    }\n                    connp->out_header = bstr_dup_mem(data + trim, len - trim);\n                    if (connp->out_header == NULL) return HTP_ERROR;\n                } else {\n                    size_t colon_pos = 0;\n                    while ((colon_pos < len) && (data[colon_pos] != ':')) colon_pos++;\n\n                    if (colon_pos < len &&\n                        bstr_chr(connp->out_header, ':') >= 0 &&\n                        connp->out_tx->response_protocol_number == HTP_PROTOCOL_1_1) {\n                        // Warn only once per transaction.\n                        if (!(connp->out_tx->flags & HTP_INVALID_FOLDING)) {\n                            connp->out_tx->flags |= HTP_INVALID_FOLDING;\n                            htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Invalid response field folding\");\n                        }\n                        if (connp->cfg->process_response_header(connp, bstr_ptr(connp->out_header),\n                            bstr_len(connp->out_header)) != HTP_OK)\n                            return HTP_ERROR;\n                        bstr_free(connp->out_header);\n                        connp->out_header = bstr_dup_mem(data+1, len-1);\n                        if (connp->out_header == NULL)\n                            return HTP_ERROR;\n                    } else {\n                        // Add to the existing header.\n                        if (bstr_len(connp->out_header) < HTP_MAX_HEADER_FOLDED) {\n                            bstr *new_out_header = bstr_add_mem(connp->out_header, data, len);\n                            if (new_out_header == NULL)\n                                return HTP_ERROR;\n                            connp->out_header = new_out_header;\n                        } else {\n                            htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Response field length exceeds folded maximum\");\n                        }\n                    }\n                }\n            }\n\n            htp_connp_res_clear_buffer(connp);\n        }\n    }\n\n    return HTP_ERROR;\n}",
      "cve_list": [
        "CVE-2024-23837"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "libhtp",
      "filepath": "htp/htp_request.c",
      "func_name": "htp_connp_REQ_PROTOCOL",
      "func_body": "htp_status_t htp_connp_REQ_PROTOCOL(htp_connp_t *connp) {\n    // Is this a short-style HTTP/0.9 request? If it is,\n    // we will not want to parse request headers.\n    if (connp->in_tx->is_protocol_0_9 == 0) {\n        // Switch to request header parsing.\n        connp->in_state = htp_connp_REQ_HEADERS;\n        connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n    } else {\n        // Let's check if the protocol was simply missing\n        int64_t pos = connp->in_current_read_offset;\n        // Probe if data looks like a header line\n        if (connp->in_current_len > connp->in_current_read_offset + HTTP09_MAX_JUNK_LEN) {\n            htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Request line: missing protocol\");\n            connp->in_tx->is_protocol_0_9 = 0;\n            // Switch to request header parsing.\n            connp->in_state = htp_connp_REQ_HEADERS;\n            connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n            return HTP_OK;\n        }\n        while (pos < connp->in_current_len) {\n            if (!htp_is_space(connp->in_current_data[pos])) {\n                htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Request line: missing protocol\");\n                connp->in_tx->is_protocol_0_9 = 0;\n                // Switch to request header parsing.\n                connp->in_state = htp_connp_REQ_HEADERS;\n                connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n                return HTP_OK;\n            }\n            pos++;\n        }\n        // We're done with this request.\n        connp->in_state = htp_connp_REQ_FINALIZE;\n    }\n\n    return HTP_OK;\n}",
      "cve_list": [
        "CVE-2024-28871"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "mynewt-nimble",
      "filepath": "nimble/host/src/ble_hs_conn.c",
      "func_name": "ble_hs_conn_timer",
      "func_body": "ble_hs_conn_timer(void)\n{\n    /* If there are no timeouts configured, then there is nothing to check. */\n#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) == 0 && \\\n    BLE_HS_ATT_SVR_QUEUED_WRITE_TMO == 0\n\n    return BLE_HS_FOREVER;\n#endif\n\n    struct ble_hs_conn *conn;\n    ble_npl_time_t now = ble_npl_time_get();\n    int32_t next_exp_in = BLE_HS_FOREVER;\n    int32_t next_exp_in_new;\n    bool next_exp_in_updated;\n    int32_t time_diff;\n\n    ble_hs_lock();\n\n    /* This loop performs one of two tasks:\n     * 1. Determine if any connections need to be terminated due to timeout. If\n     *    so connection is disconnected.\n     * 2. Otherwise, determine when the next timeout will occur.\n     */\n    SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {\n        if (!(conn->bhc_flags & BLE_HS_CONN_F_TERMINATING)) {\n            next_exp_in_updated = false;\n\n#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) != 0\n            /* Check each connection's rx fragment timer.  If too much time\n             * passes after a partial packet is received, the connection is\n             * terminated.\n             */\n            if (conn->bhc_rx_chan != NULL) {\n                time_diff = conn->bhc_rx_timeout - now;\n\n                if (time_diff <= 0) {\n                    /* ACL reassembly has timed out.*/\n                    ble_gap_terminate_with_conn(conn, BLE_ERR_REM_USER_CONN_TERM);\n                    continue;\n                }\n\n                /* Determine if this connection is the soonest to time out. */\n                if (time_diff < next_exp_in) {\n                    next_exp_in_new = time_diff;\n                    next_exp_in_updated = true;\n                }\n            }\n#endif\n\n#if BLE_HS_ATT_SVR_QUEUED_WRITE_TMO\n            /* Check each connection's rx queued write timer.  If too much\n             * time passes after a prep write is received, the queue is\n             * cleared.\n             */\n            time_diff = ble_att_svr_ticks_until_tmo(&conn->bhc_att_svr, now);\n            if (time_diff <= 0) {\n                /* Queued write has timed out.*/\n                ble_gap_terminate_with_conn(conn, BLE_ERR_REM_USER_CONN_TERM);\n                continue;\n            }\n\n            /* Determine if this connection is the soonest to time out. */\n            if (time_diff < next_exp_in) {\n                next_exp_in_new = time_diff;\n                next_exp_in_updated = true;\n            }\n#endif\n\n            if (next_exp_in_updated) {\n                next_exp_in = next_exp_in_new;\n            }\n        }\n    }\n\n    ble_hs_unlock();\n\n    return next_exp_in;\n}",
      "cve_list": [
        "CVE-2024-24746"
      ],
      "cwe_list": [
        "CWE-835"
      ]
    },
    {
      "project": "cbor2",
      "filepath": "source/tags.c",
      "func_name": "CBORTag_hash",
      "func_body": "CBORTag_hash(CBORTagObject *self)\n{\n    if (!_CBOR2_thread_locals && _CBOR2_init_thread_locals() == -1)\n        return -1;\n\n    Py_hash_t ret = -1;\n    PyObject *running_hashes = NULL;\n    PyObject *tmp = NULL;\n    PyObject *self_id = PyLong_FromVoidPtr(self);\n    if (!self_id)\n        goto exit;\n\n    running_hashes = PyObject_GetAttrString(_CBOR2_thread_locals, \"running_hashes\");\n    if (!running_hashes) {\n        PyErr_Clear();\n        running_hashes = PySet_New(NULL);\n        if (PyObject_SetAttrString(_CBOR2_thread_locals, \"running_hashes\", running_hashes) == -1)\n            goto exit;\n    } else {\n        // Check if __hash__() is already being run against this object in this thread\n        switch (PySet_Contains(running_hashes, self_id)) {\n            case -1:  // error\n                goto exit;\n            case 1:  // this object is already in the set\n                PyErr_SetString(\n                    PyExc_RuntimeError,\n                    \"This CBORTag is not hashable because it contains a reference to itself\"\n                );\n                goto exit;\n        }\n    }\n\n    // Add id(self) to thread_locals.running_hashes\n    if (PySet_Add(running_hashes, self_id) == -1)\n        goto exit;\n\n    tmp = Py_BuildValue(\"(KO)\", self->tag, self->value);\n    if (!tmp)\n        goto exit;\n\n    ret = PyObject_Hash(tmp);\n\n    // Remove id(self) from thread_locals.running_hashes\n    if (PySet_Discard(running_hashes, self_id) == -1) {\n        ret = -1;\n        goto exit;\n    }\n\n    // Check how many more references there are in running_hashes\n    Py_ssize_t length = PySequence_Length(running_hashes);\n    if (length == -1) {\n        ret = -1;\n        goto exit;\n    }\n\n    // If this was the last reference, delete running_hashes from the thread-local variable\n    if (length == 0 && PyObject_DelAttrString(_CBOR2_thread_locals, \"running_hashes\") == -1) {\n        ret = -1;\n        goto exit;\n    }\nexit:\n    Py_CLEAR(self_id);\n    Py_CLEAR(running_hashes);\n    Py_CLEAR(tmp);\n    return ret;\n}",
      "cve_list": [
        "CVE-2024-26134"
      ],
      "cwe_list": [
        "CWE-120"
      ]
    },
    {
      "project": "cbor2",
      "filepath": "source/tags.c",
      "func_name": "CBORTag_hash",
      "func_body": "CBORTag_hash(CBORTagObject *self)\n{\n    if (!_CBOR2_thread_locals && _CBOR2_init_thread_locals() == -1)\n        return -1;\n\n    Py_hash_t ret = -1;\n    PyObject *running_hashes = NULL;\n    PyObject *tmp = NULL;\n    PyObject *self_id = PyLong_FromVoidPtr(self);\n    if (!self_id)\n        goto exit;\n\n    running_hashes = PyObject_GetAttrString(_CBOR2_thread_locals, \"running_hashes\");\n    if (!running_hashes) {\n        PyErr_Clear();\n        running_hashes = PySet_New(NULL);\n        if (PyObject_SetAttrString(_CBOR2_thread_locals, \"running_hashes\", running_hashes) == -1)\n            goto exit;\n    } else {\n        // Check if __hash__() is already being run against this object in this thread\n        switch (PySet_Contains(running_hashes, self_id)) {\n            case -1:  // error\n                goto exit;\n            case 1:  // this object is already in the set\n                PyErr_SetString(\n                    PyExc_RuntimeError,\n                    \"This CBORTag is not hashable because it contains a reference to itself\"\n                );\n                goto exit;\n        }\n    }\n\n    // Add id(self) to thread_locals.running_hashes\n    if (PySet_Add(running_hashes, self_id) == -1)\n        goto exit;\n\n    tmp = Py_BuildValue(\"(KO)\", self->tag, self->value);\n    if (!tmp)\n        goto exit;\n\n    ret = PyObject_Hash(tmp);\n    if (ret == -1)\n        goto exit;\n\n    // Remove id(self) from thread_locals.running_hashes\n    if (PySet_Discard(running_hashes, self_id) == -1) {\n        ret = -1;\n        goto exit;\n    }\n\n    // Check how many more references there are in running_hashes\n    Py_ssize_t length = PySequence_Length(running_hashes);\n    if (length == -1) {\n        ret = -1;\n        goto exit;\n    }\n\n    // If this was the last reference, delete running_hashes from the thread-local variable\n    if (length == 0 && PyObject_DelAttrString(_CBOR2_thread_locals, \"running_hashes\") == -1) {\n        ret = -1;\n        goto exit;\n    }\nexit:\n    Py_CLEAR(self_id);\n    Py_CLEAR(running_hashes);\n    Py_CLEAR(tmp);\n    return ret;\n}",
      "cve_list": [
        "CVE-2024-26134"
      ],
      "cwe_list": [
        "CWE-120"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "dyn_chunk_list_add",
      "func_body": "static_inline void dyn_chunk_list_add(dyn_chunk *list, dyn_chunk *chunk) {\n    chunk->next = list->next;\n    list->next = chunk;\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "dyn_chunk_list_remove",
      "func_body": "static_inline void dyn_chunk_list_remove(dyn_chunk *list, dyn_chunk *chunk) {\n    dyn_chunk *prev = list, *cur;\n    for (cur = prev->next; cur; cur = cur->next) {\n        if (cur == chunk) {\n            prev->next = cur->next;\n            cur->next = NULL;\n            return;\n        }\n        prev = cur;\n    }\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "dyn_free",
      "func_body": "static void dyn_free(void *ctx_ptr, void *ptr) {\n    /* assert(ptr != NULL) */\n    dyn_ctx *ctx = (dyn_ctx *)ctx_ptr;\n    dyn_chunk *chunk = (dyn_chunk *)ptr - 1, *prev;\n    \n    dyn_chunk_list_remove(&ctx->used_list, chunk);\n    for (prev = &ctx->free_list; prev; prev = prev->next) {\n        if (!prev->next || prev->next->size >= chunk->size) {\n            chunk->next = prev->next;\n            prev->next = chunk;\n            break;\n        }\n    }\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "dyn_malloc",
      "func_body": "static void *dyn_malloc(void *ctx_ptr, usize size) {\n    /* assert(size != 0) */\n    const yyjson_alc def = YYJSON_DEFAULT_ALC;\n    dyn_ctx *ctx = (dyn_ctx *)ctx_ptr;\n    dyn_chunk *chunk, *prev, *next;\n    if (unlikely(!dyn_size_align(&size))) return NULL;\n    \n    /* freelist is empty, create new chunk */\n    if (!ctx->free_list.next) {\n        chunk = (dyn_chunk *)def.malloc(def.ctx, size);\n        if (unlikely(!chunk)) return NULL;\n        chunk->size = size;\n        chunk->next = NULL;\n        dyn_chunk_list_add(&ctx->used_list, chunk);\n        return (void *)(chunk + 1);\n    }\n    \n    /* find a large enough chunk, or resize the largest chunk */\n    prev = &ctx->free_list;\n    while (true) {\n        chunk = prev->next;\n        if (chunk->size >= size) { /* enough size, reuse this chunk */\n            prev->next = chunk->next;\n            dyn_chunk_list_add(&ctx->used_list, chunk);\n            return (void *)(chunk + 1);\n        }\n        if (!chunk->next) { /* resize the largest chunk */\n            chunk = (dyn_chunk *)def.realloc(def.ctx, chunk, chunk->size, size);\n            if (unlikely(!chunk)) return NULL;\n            prev->next = NULL;\n            chunk->size = size;\n            dyn_chunk_list_add(&ctx->used_list, chunk);\n            return (void *)(chunk + 1);\n        }\n        prev = chunk;\n    }\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "dyn_realloc",
      "func_body": "static void *dyn_realloc(void *ctx_ptr, void *ptr,\n                          usize old_size, usize size) {\n    /* assert(ptr != NULL && size != 0 && old_size < size) */\n    const yyjson_alc def = YYJSON_DEFAULT_ALC;\n    dyn_ctx *ctx = (dyn_ctx *)ctx_ptr;\n    dyn_chunk *prev, *next, *new_chunk;\n    dyn_chunk *chunk = (dyn_chunk *)ptr - 1;\n    if (unlikely(!dyn_size_align(&size))) return NULL;\n    if (chunk->size >= size) return ptr;\n    \n    dyn_chunk_list_remove(&ctx->used_list, chunk);\n    new_chunk = (dyn_chunk *)def.realloc(def.ctx, chunk, chunk->size, size);\n    if (likely(new_chunk)) {\n        new_chunk->size = size;\n        chunk = new_chunk;\n    }\n    dyn_chunk_list_add(&ctx->used_list, chunk);\n    return new_chunk ? (void *)(new_chunk + 1) : NULL;\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "dyn_size_align",
      "func_body": "static_inline bool dyn_size_align(usize *size) {\n    usize alc_size = *size + sizeof(dyn_chunk);\n    alc_size = size_align_up(alc_size, YYJSON_ALC_DYN_MIN_SIZE);\n    if (unlikely(alc_size < *size)) return false; /* overflow */\n    *size = alc_size;\n    return true;\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "pool_malloc",
      "func_body": "static void *pool_malloc(void *ctx_ptr, usize size) {\n    /* assert(size != 0) */\n    pool_ctx *ctx = (pool_ctx *)ctx_ptr;\n    pool_chunk *next, *prev = NULL, *cur = ctx->free_list;\n    \n    if (unlikely(size >= ctx->size)) return NULL;\n    pool_size_align(&size);\n    \n    while (cur) {\n        if (cur->size < size) {\n            /* not enough space, try next chunk */\n            prev = cur;\n            cur = cur->next;\n            continue;\n        }\n        if (cur->size >= size + sizeof(pool_chunk) * 2) {\n            /* too much space, split this chunk */\n            next = (pool_chunk *)(void *)((u8 *)cur + size);\n            next->size = cur->size - size;\n            next->next = cur->next;\n            cur->size = size;\n        } else {\n            /* just enough space, use whole chunk */\n            next = cur->next;\n        }\n        if (prev) prev->next = next;\n        else ctx->free_list = next;\n        return (void *)(cur + 1);\n    }\n    return NULL;\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "pool_realloc",
      "func_body": "static void *pool_realloc(void *ctx_ptr, void *ptr,\n                          usize old_size, usize size) {\n    /* assert(ptr != NULL && size != 0 && old_size < size) */\n    pool_ctx *ctx = (pool_ctx *)ctx_ptr;\n    pool_chunk *cur = ((pool_chunk *)ptr) - 1, *prev, *next, *tmp;\n    \n    /* check size */\n    if (unlikely(size >= ctx->size)) return NULL;\n    pool_size_align(&old_size);\n    pool_size_align(&size);\n    if (unlikely(old_size == size)) return ptr;\n    \n    /* find next and prev chunk */\n    prev = NULL;\n    next = ctx->free_list;\n    while (next && next < cur) {\n        prev = next;\n        next = next->next;\n    }\n    \n    if ((u8 *)cur + cur->size == (u8 *)next && cur->size + next->size >= size) {\n        /* merge to higher chunk if they are contiguous */\n        usize free_size = cur->size + next->size - size;\n        if (free_size > sizeof(pool_chunk) * 2) {\n            tmp = (pool_chunk *)(void *)((u8 *)cur + size);\n            if (prev) prev->next = tmp;\n            else ctx->free_list = tmp;\n            tmp->next = next->next;\n            tmp->size = free_size;\n            cur->size = size;\n        } else {\n            if (prev) prev->next = next->next;\n            else ctx->free_list = next->next;\n            cur->size += next->size;\n        }\n        return ptr;\n    } else {\n        /* fallback to malloc and memcpy */\n        void *new_ptr = pool_malloc(ctx_ptr, size - sizeof(pool_chunk));\n        if (new_ptr) {\n            memcpy(new_ptr, ptr, cur->size - sizeof(pool_chunk));\n            pool_free(ctx_ptr, ptr);\n        }\n        return new_ptr;\n    }\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "pool_size_align",
      "func_body": "static_inline void pool_size_align(usize *size) {\n    *size = size_align_up(*size, sizeof(pool_chunk)) + sizeof(pool_chunk);\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "read_root_minify",
      "func_body": "static_inline yyjson_doc *read_root_minify(u8 *hdr,\n                                           u8 *cur,\n                                           u8 *end,\n                                           yyjson_alc alc,\n                                           yyjson_read_flag flg,\n                                           yyjson_read_err *err) {\n    \n#define return_err(_pos, _code, _msg) do { \\\n    if (is_truncated_end(hdr, _pos, end, YYJSON_READ_ERROR_##_code, flg)) { \\\n        err->pos = (usize)(end - hdr); \\\n        err->code = YYJSON_READ_ERROR_UNEXPECTED_END; \\\n        err->msg = \"unexpected end of data\"; \\\n    } else { \\\n        err->pos = (usize)(_pos - hdr); \\\n        err->code = YYJSON_READ_ERROR_##_code; \\\n        err->msg = _msg; \\\n    } \\\n    if (val_hdr) alc.free(alc.ctx, (void *)val_hdr); \\\n    return NULL; \\\n} while (false)\n    \n#define val_incr() do { \\\n    val++; \\\n    if (unlikely(val >= val_end)) { \\\n        usize alc_old = alc_len; \\\n        alc_len += alc_len / 2; \\\n        if ((sizeof(usize) < 8) && (alc_len >= alc_max)) goto fail_alloc; \\\n        val_tmp = (yyjson_val *)alc.realloc(alc.ctx, (void *)val_hdr, \\\n            alc_old * sizeof(yyjson_val), \\\n            alc_len * sizeof(yyjson_val)); \\\n        if ((!val_tmp)) goto fail_alloc; \\\n        val = val_tmp + (usize)(val - val_hdr); \\\n        ctn = val_tmp + (usize)(ctn - val_hdr); \\\n        val_hdr = val_tmp; \\\n        val_end = val_tmp + (alc_len - 2); \\\n    } \\\n} while (false)\n    \n    usize dat_len; /* data length in bytes, hint for allocator */\n    usize hdr_len; /* value count used by yyjson_doc */\n    usize alc_len; /* value count allocated */\n    usize alc_max; /* maximum value count for allocator */\n    usize ctn_len; /* the number of elements in current container */\n    yyjson_val *val_hdr; /* the head of allocated values */\n    yyjson_val *val_end; /* the end of allocated values */\n    yyjson_val *val_tmp; /* temporary pointer for realloc */\n    yyjson_val *val; /* current JSON value */\n    yyjson_val *ctn; /* current container */\n    yyjson_val *ctn_parent; /* parent of current container */\n    yyjson_doc *doc; /* the JSON document, equals to val_hdr */\n    const char *msg; /* error message */\n\n    u32 container_depth = 0; /* limit on number of open array and map */\n    bool raw; /* read number as raw */\n    bool inv; /* allow invalid unicode */\n    u8 *raw_end; /* raw end for null-terminator */\n    u8 **pre; /* previous raw end pointer */\n    \n    dat_len = has_read_flag(STOP_WHEN_DONE) ? 256 : (usize)(end - cur);\n    hdr_len = sizeof(yyjson_doc) / sizeof(yyjson_val);\n    hdr_len += (sizeof(yyjson_doc) % sizeof(yyjson_val)) > 0;\n    alc_max = USIZE_MAX / sizeof(yyjson_val);\n    alc_len = hdr_len + (dat_len / YYJSON_READER_ESTIMATED_MINIFY_RATIO) + 4;\n    alc_len = yyjson_min(alc_len, alc_max);\n    \n    val_hdr = (yyjson_val *)alc.malloc(alc.ctx, alc_len * sizeof(yyjson_val));\n    if (unlikely(!val_hdr)) goto fail_alloc;\n    val_end = val_hdr + (alc_len - 2); /* padding for key-value pair reading */\n    val = val_hdr + hdr_len;\n    ctn = val;\n    ctn_len = 0;\n    raw = has_read_flag(NUMBER_AS_RAW) || has_read_flag(BIGNUM_AS_RAW);\n    inv = has_read_flag(ALLOW_INVALID_UNICODE) != 0;\n    raw_end = NULL;\n    pre = raw ? &raw_end : NULL;\n    \n    if (*cur++ == '{') {\n        ctn->tag = YYJSON_TYPE_OBJ;\n        ctn->uni.ofs = 0;\n        goto obj_key_begin;\n    } else {\n        ctn->tag = YYJSON_TYPE_ARR;\n        ctn->uni.ofs = 0;\n        goto arr_val_begin;\n    }\n    \narr_begin:\n    container_depth++;\n    if (unlikely(container_depth >= YYJSON_READER_CONTAINER_RECURSION_LIMIT)) {\n        goto fail_recursion;\n    }\n\n    /* save current container */\n    ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n               (ctn->tag & YYJSON_TAG_MASK);\n    \n    /* create a new array value, save parent container offset */\n    val_incr();\n    val->tag = YYJSON_TYPE_ARR;\n    val->uni.ofs = (usize)((u8 *)val - (u8 *)ctn);\n    \n    /* push the new array value as current container */\n    ctn = val;\n    ctn_len = 0;\n    \narr_val_begin:\n    if (*cur == '{') {\n        cur++;\n        goto obj_begin;\n    }\n    if (*cur == '[') {\n        cur++;\n        goto arr_begin;\n    }\n    if (char_is_number(*cur)) {\n        val_incr();\n        ctn_len++;\n        if (likely(read_number(&cur, pre, flg, val, &msg))) goto arr_val_end;\n        goto fail_number;\n    }\n    if (*cur == '\"') {\n        val_incr();\n        ctn_len++;\n        if (likely(read_string(&cur, end, inv, val, &msg))) goto arr_val_end;\n        goto fail_string;\n    }\n    if (*cur == 't') {\n        val_incr();\n        ctn_len++;\n        if (likely(read_true(&cur, val))) goto arr_val_end;\n        goto fail_literal;\n    }\n    if (*cur == 'f') {\n        val_incr();\n        ctn_len++;\n        if (likely(read_false(&cur, val))) goto arr_val_end;\n        goto fail_literal;\n    }\n    if (*cur == 'n') {\n        val_incr();\n        ctn_len++;\n        if (likely(read_null(&cur, val))) goto arr_val_end;\n        if (has_read_flag(ALLOW_INF_AND_NAN)) {\n            if (read_nan(false, &cur, pre, val)) goto arr_val_end;\n        }\n        goto fail_literal;\n    }\n    if (*cur == ']') {\n        cur++;\n        if (likely(ctn_len == 0)) goto arr_end;\n        if (has_read_flag(ALLOW_TRAILING_COMMAS)) goto arr_end;\n        while (*cur != ',') cur--;\n        goto fail_trailing_comma;\n    }\n    if (char_is_space(*cur)) {\n        while (char_is_space(*++cur));\n        goto arr_val_begin;\n    }\n    if (has_read_flag(ALLOW_INF_AND_NAN) &&\n        (*cur == 'i' || *cur == 'I' || *cur == 'N')) {\n        val_incr();\n        ctn_len++;\n        if (read_inf_or_nan(false, &cur, pre, val)) goto arr_val_end;\n        goto fail_character;\n    }\n    if (has_read_flag(ALLOW_COMMENTS)) {\n        if (skip_spaces_and_comments(&cur)) goto arr_val_begin;\n        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \narr_val_end:\n    if (*cur == ',') {\n        cur++;\n        goto arr_val_begin;\n    }\n    if (*cur == ']') {\n        cur++;\n        goto arr_end;\n    }\n    if (char_is_space(*cur)) {\n        while (char_is_space(*++cur));\n        goto arr_val_end;\n    }\n    if (has_read_flag(ALLOW_COMMENTS)) {\n        if (skip_spaces_and_comments(&cur)) goto arr_val_end;\n        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \narr_end:\n    container_depth--;\n\n    /* get parent container */\n    ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n    \n    /* save the next sibling value offset */\n    ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n    ctn->tag = ((ctn_len) << YYJSON_TAG_BIT) | YYJSON_TYPE_ARR;\n    if (unlikely(ctn == ctn_parent)) goto doc_end;\n    \n    /* pop parent as current container */\n    ctn = ctn_parent;\n    ctn_len = (usize)(ctn->tag >> YYJSON_TAG_BIT);\n    if ((ctn->tag & YYJSON_TYPE_MASK) == YYJSON_TYPE_OBJ) {\n        goto obj_val_end;\n    } else {\n        goto arr_val_end;\n    }\n    \nobj_begin:\n    container_depth++;\n    if (unlikely(container_depth >= YYJSON_READER_CONTAINER_RECURSION_LIMIT)) {\n        goto fail_recursion;\n    }\n\n    /* push container */\n    ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n               (ctn->tag & YYJSON_TAG_MASK);\n    val_incr();\n    val->tag = YYJSON_TYPE_OBJ;\n    /* offset to the parent */\n    val->uni.ofs = (usize)((u8 *)val - (u8 *)ctn);\n    ctn = val;\n    ctn_len = 0;\n    \nobj_key_begin:\n    if (likely(*cur == '\"')) {\n        val_incr();\n        ctn_len++;\n        if (likely(read_string(&cur, end, inv, val, &msg))) goto obj_key_end;\n        goto fail_string;\n    }\n    if (likely(*cur == '}')) {\n        cur++;\n        if (likely(ctn_len == 0)) goto obj_end;\n        if (has_read_flag(ALLOW_TRAILING_COMMAS)) goto obj_end;\n        while (*cur != ',') cur--;\n        goto fail_trailing_comma;\n    }\n    if (char_is_space(*cur)) {\n        while (char_is_space(*++cur));\n        goto obj_key_begin;\n    }\n    if (has_read_flag(ALLOW_COMMENTS)) {\n        if (skip_spaces_and_comments(&cur)) goto obj_key_begin;\n        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \nobj_key_end:\n    if (*cur == ':') {\n        cur++;\n        goto obj_val_begin;\n    }\n    if (char_is_space(*cur)) {\n        while (char_is_space(*++cur));\n        goto obj_key_end;\n    }\n    if (has_read_flag(ALLOW_COMMENTS)) {\n        if (skip_spaces_and_comments(&cur)) goto obj_key_end;\n        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \nobj_val_begin:\n    if (*cur == '\"') {\n        val++;\n        ctn_len++;\n        if (likely(read_string(&cur, end, inv, val, &msg))) goto obj_val_end;\n        goto fail_string;\n    }\n    if (char_is_number(*cur)) {\n        val++;\n        ctn_len++;\n        if (likely(read_number(&cur, pre, flg, val, &msg))) goto obj_val_end;\n        goto fail_number;\n    }\n    if (*cur == '{') {\n        cur++;\n        goto obj_begin;\n    }\n    if (*cur == '[') {\n        cur++;\n        goto arr_begin;\n    }\n    if (*cur == 't') {\n        val++;\n        ctn_len++;\n        if (likely(read_true(&cur, val))) goto obj_val_end;\n        goto fail_literal;\n    }\n    if (*cur == 'f') {\n        val++;\n        ctn_len++;\n        if (likely(read_false(&cur, val))) goto obj_val_end;\n        goto fail_literal;\n    }\n    if (*cur == 'n') {\n        val++;\n        ctn_len++;\n        if (likely(read_null(&cur, val))) goto obj_val_end;\n        if (has_read_flag(ALLOW_INF_AND_NAN)) {\n            if (read_nan(false, &cur, pre, val)) goto obj_val_end;\n        }\n        goto fail_literal;\n    }\n    if (char_is_space(*cur)) {\n        while (char_is_space(*++cur));\n        goto obj_val_begin;\n    }\n    if (has_read_flag(ALLOW_INF_AND_NAN) &&\n        (*cur == 'i' || *cur == 'I' || *cur == 'N')) {\n        val++;\n        ctn_len++;\n        if (read_inf_or_nan(false, &cur, pre, val)) goto obj_val_end;\n        goto fail_character;\n    }\n    if (has_read_flag(ALLOW_COMMENTS)) {\n        if (skip_spaces_and_comments(&cur)) goto obj_val_begin;\n        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \nobj_val_end:\n    if (likely(*cur == ',')) {\n        cur++;\n        goto obj_key_begin;\n    }\n    if (likely(*cur == '}')) {\n        cur++;\n        goto obj_end;\n    }\n    if (char_is_space(*cur)) {\n        while (char_is_space(*++cur));\n        goto obj_val_end;\n    }\n    if (has_read_flag(ALLOW_COMMENTS)) {\n        if (skip_spaces_and_comments(&cur)) goto obj_val_end;\n        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \nobj_end:\n    container_depth--;\n\n    /* pop container */\n    ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n    /* point to the next value */\n    ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n    ctn->tag = (ctn_len << (YYJSON_TAG_BIT - 1)) | YYJSON_TYPE_OBJ;\n    if (unlikely(ctn == ctn_parent)) goto doc_end;\n    ctn = ctn_parent;\n    ctn_len = (usize)(ctn->tag >> YYJSON_TAG_BIT);\n    if ((ctn->tag & YYJSON_TYPE_MASK) == YYJSON_TYPE_OBJ) {\n        goto obj_val_end;\n    } else {\n        goto arr_val_end;\n    }\n    \ndoc_end:\n    /* check invalid contents after json document */\n    if (unlikely(cur < end) && !has_read_flag(STOP_WHEN_DONE)) {\n        if (has_read_flag(ALLOW_COMMENTS)) {\n            skip_spaces_and_comments(&cur);\n            if (byte_match_2(cur, \"/*\")) goto fail_comment;\n        } else {\n            while (char_is_space(*cur)) cur++;\n        }\n        if (unlikely(cur < end)) goto fail_garbage;\n    }\n    \n    if (pre && *pre) **pre = '\\0';\n    doc = (yyjson_doc *)val_hdr;\n    doc->root = val_hdr + hdr_len;\n    doc->alc = alc;\n    doc->dat_read = (usize)(cur - hdr);\n    doc->val_read = (usize)((val - doc->root) + 1);\n    doc->str_pool = has_read_flag(INSITU) ? NULL : (char *)hdr;\n    return doc;\n    \nfail_string:\n    return_err(cur, INVALID_STRING, msg);\nfail_number:\n    return_err(cur, INVALID_NUMBER, msg);\nfail_alloc:\n    return_err(cur, MEMORY_ALLOCATION, \"memory allocation failed\");\nfail_trailing_comma:\n    return_err(cur, JSON_STRUCTURE, \"trailing comma is not allowed\");\nfail_literal:\n    return_err(cur, LITERAL, \"invalid literal\");\nfail_comment:\n    return_err(cur, INVALID_COMMENT, \"unclosed multiline comment\");\nfail_character:\n    return_err(cur, UNEXPECTED_CHARACTER, \"unexpected character\");\nfail_garbage:\n    return_err(cur, UNEXPECTED_CONTENT, \"unexpected content after document\");\nfail_recursion:\n    return_err(cur, RECURSION_DEPTH, \"array and object recursion depth exceeded\");\n    \n#undef val_incr\n#undef return_err\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "read_root_pretty",
      "func_body": "static_inline yyjson_doc *read_root_pretty(u8 *hdr,\n                                           u8 *cur,\n                                           u8 *end,\n                                           yyjson_alc alc,\n                                           yyjson_read_flag flg,\n                                           yyjson_read_err *err) {\n    \n#define return_err(_pos, _code, _msg) do { \\\n    if (is_truncated_end(hdr, _pos, end, YYJSON_READ_ERROR_##_code, flg)) { \\\n        err->pos = (usize)(end - hdr); \\\n        err->code = YYJSON_READ_ERROR_UNEXPECTED_END; \\\n        err->msg = \"unexpected end of data\"; \\\n    } else { \\\n        err->pos = (usize)(_pos - hdr); \\\n        err->code = YYJSON_READ_ERROR_##_code; \\\n        err->msg = _msg; \\\n    } \\\n    if (val_hdr) alc.free(alc.ctx, (void *)val_hdr); \\\n    return NULL; \\\n} while (false)\n    \n#define val_incr() do { \\\n    val++; \\\n    if (unlikely(val >= val_end)) { \\\n        usize alc_old = alc_len; \\\n        alc_len += alc_len / 2; \\\n        if ((sizeof(usize) < 8) && (alc_len >= alc_max)) goto fail_alloc; \\\n        val_tmp = (yyjson_val *)alc.realloc(alc.ctx, (void *)val_hdr, \\\n            alc_old * sizeof(yyjson_val), \\\n            alc_len * sizeof(yyjson_val)); \\\n        if ((!val_tmp)) goto fail_alloc; \\\n        val = val_tmp + (usize)(val - val_hdr); \\\n        ctn = val_tmp + (usize)(ctn - val_hdr); \\\n        val_hdr = val_tmp; \\\n        val_end = val_tmp + (alc_len - 2); \\\n    } \\\n} while (false)\n    \n    usize dat_len; /* data length in bytes, hint for allocator */\n    usize hdr_len; /* value count used by yyjson_doc */\n    usize alc_len; /* value count allocated */\n    usize alc_max; /* maximum value count for allocator */\n    usize ctn_len; /* the number of elements in current container */\n    yyjson_val *val_hdr; /* the head of allocated values */\n    yyjson_val *val_end; /* the end of allocated values */\n    yyjson_val *val_tmp; /* temporary pointer for realloc */\n    yyjson_val *val; /* current JSON value */\n    yyjson_val *ctn; /* current container */\n    yyjson_val *ctn_parent; /* parent of current container */\n    yyjson_doc *doc; /* the JSON document, equals to val_hdr */\n    const char *msg; /* error message */\n\n    u32 container_depth = 0; /* limit on number of open array and map */\n    bool raw; /* read number as raw */\n    bool inv; /* allow invalid unicode */\n    u8 *raw_end; /* raw end for null-terminator */\n    u8 **pre; /* previous raw end pointer */\n    \n    dat_len = has_read_flag(STOP_WHEN_DONE) ? 256 : (usize)(end - cur);\n    hdr_len = sizeof(yyjson_doc) / sizeof(yyjson_val);\n    hdr_len += (sizeof(yyjson_doc) % sizeof(yyjson_val)) > 0;\n    alc_max = USIZE_MAX / sizeof(yyjson_val);\n    alc_len = hdr_len + (dat_len / YYJSON_READER_ESTIMATED_PRETTY_RATIO) + 4;\n    alc_len = yyjson_min(alc_len, alc_max);\n    \n    val_hdr = (yyjson_val *)alc.malloc(alc.ctx, alc_len * sizeof(yyjson_val));\n    if (unlikely(!val_hdr)) goto fail_alloc;\n    val_end = val_hdr + (alc_len - 2); /* padding for key-value pair reading */\n    val = val_hdr + hdr_len;\n    ctn = val;\n    ctn_len = 0;\n    raw = has_read_flag(NUMBER_AS_RAW) || has_read_flag(BIGNUM_AS_RAW);\n    inv = has_read_flag(ALLOW_INVALID_UNICODE) != 0;\n    raw_end = NULL;\n    pre = raw ? &raw_end : NULL;\n    \n    if (*cur++ == '{') {\n        ctn->tag = YYJSON_TYPE_OBJ;\n        ctn->uni.ofs = 0;\n        if (*cur == '\\n') cur++;\n        goto obj_key_begin;\n    } else {\n        ctn->tag = YYJSON_TYPE_ARR;\n        ctn->uni.ofs = 0;\n        if (*cur == '\\n') cur++;\n        goto arr_val_begin;\n    }\n    \narr_begin:\n    container_depth++;\n    if (unlikely(container_depth >= YYJSON_READER_CONTAINER_RECURSION_LIMIT)) {\n        goto fail_recursion;\n    }\n\n    /* save current container */\n    ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n               (ctn->tag & YYJSON_TAG_MASK);\n    \n    /* create a new array value, save parent container offset */\n    val_incr();\n    val->tag = YYJSON_TYPE_ARR;\n    val->uni.ofs = (usize)((u8 *)val - (u8 *)ctn);\n    \n    /* push the new array value as current container */\n    ctn = val;\n    ctn_len = 0;\n    if (*cur == '\\n') cur++;\n    \narr_val_begin:\n#if YYJSON_IS_REAL_GCC\n    while (true) repeat16({\n        if (byte_match_2(cur, \"  \")) cur += 2;\n        else break;\n    })\n#else\n    while (true) repeat16({\n        if (likely(byte_match_2(cur, \"  \"))) cur += 2;\n        else break;\n    })\n#endif\n    \n    if (*cur == '{') {\n        cur++;\n        goto obj_begin;\n    }\n    if (*cur == '[') {\n        cur++;\n        goto arr_begin;\n    }\n    if (char_is_number(*cur)) {\n        val_incr();\n        ctn_len++;\n        if (likely(read_number(&cur, pre, flg, val, &msg))) goto arr_val_end;\n        goto fail_number;\n    }\n    if (*cur == '\"') {\n        val_incr();\n        ctn_len++;\n        if (likely(read_string(&cur, end, inv, val, &msg))) goto arr_val_end;\n        goto fail_string;\n    }\n    if (*cur == 't') {\n        val_incr();\n        ctn_len++;\n        if (likely(read_true(&cur, val))) goto arr_val_end;\n        goto fail_literal;\n    }\n    if (*cur == 'f') {\n        val_incr();\n        ctn_len++;\n        if (likely(read_false(&cur, val))) goto arr_val_end;\n        goto fail_literal;\n    }\n    if (*cur == 'n') {\n        val_incr();\n        ctn_len++;\n        if (likely(read_null(&cur, val))) goto arr_val_end;\n        if (has_read_flag(ALLOW_INF_AND_NAN)) {\n            if (read_nan(false, &cur, pre, val)) goto arr_val_end;\n        }\n        goto fail_literal;\n    }\n    if (*cur == ']') {\n        cur++;\n        if (likely(ctn_len == 0)) goto arr_end;\n        if (has_read_flag(ALLOW_TRAILING_COMMAS)) goto arr_end;\n        while (*cur != ',') cur--;\n        goto fail_trailing_comma;\n    }\n    if (char_is_space(*cur)) {\n        while (char_is_space(*++cur));\n        goto arr_val_begin;\n    }\n    if (has_read_flag(ALLOW_INF_AND_NAN) &&\n        (*cur == 'i' || *cur == 'I' || *cur == 'N')) {\n        val_incr();\n        ctn_len++;\n        if (read_inf_or_nan(false, &cur, pre, val)) goto arr_val_end;\n        goto fail_character;\n    }\n    if (has_read_flag(ALLOW_COMMENTS)) {\n        if (skip_spaces_and_comments(&cur)) goto arr_val_begin;\n        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \narr_val_end:\n    if (byte_match_2(cur, \",\\n\")) {\n        cur += 2;\n        goto arr_val_begin;\n    }\n    if (*cur == ',') {\n        cur++;\n        goto arr_val_begin;\n    }\n    if (*cur == ']') {\n        cur++;\n        goto arr_end;\n    }\n    if (char_is_space(*cur)) {\n        while (char_is_space(*++cur));\n        goto arr_val_end;\n    }\n    if (has_read_flag(ALLOW_COMMENTS)) {\n        if (skip_spaces_and_comments(&cur)) goto arr_val_end;\n        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \narr_end:\n    container_depth--;\n\n    /* get parent container */\n    ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n    \n    /* save the next sibling value offset */\n    ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n    ctn->tag = ((ctn_len) << YYJSON_TAG_BIT) | YYJSON_TYPE_ARR;\n    if (unlikely(ctn == ctn_parent)) goto doc_end;\n    \n    /* pop parent as current container */\n    ctn = ctn_parent;\n    ctn_len = (usize)(ctn->tag >> YYJSON_TAG_BIT);\n    if (*cur == '\\n') cur++;\n    if ((ctn->tag & YYJSON_TYPE_MASK) == YYJSON_TYPE_OBJ) {\n        goto obj_val_end;\n    } else {\n        goto arr_val_end;\n    }\n    \nobj_begin:\n    container_depth++;\n    if (unlikely(container_depth >= YYJSON_READER_CONTAINER_RECURSION_LIMIT)) {\n        goto fail_recursion;\n    }\n\n    /* push container */\n    ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n               (ctn->tag & YYJSON_TAG_MASK);\n    val_incr();\n    val->tag = YYJSON_TYPE_OBJ;\n    /* offset to the parent */\n    val->uni.ofs = (usize)((u8 *)val - (u8 *)ctn);\n    ctn = val;\n    ctn_len = 0;\n    if (*cur == '\\n') cur++;\n    \nobj_key_begin:\n#if YYJSON_IS_REAL_GCC\n    while (true) repeat16({\n        if (byte_match_2(cur, \"  \")) cur += 2;\n        else break;\n    })\n#else\n    while (true) repeat16({\n        if (likely(byte_match_2(cur, \"  \"))) cur += 2;\n        else break;\n    })\n#endif\n    if (likely(*cur == '\"')) {\n        val_incr();\n        ctn_len++;\n        if (likely(read_string(&cur, end, inv, val, &msg))) goto obj_key_end;\n        goto fail_string;\n    }\n    if (likely(*cur == '}')) {\n        cur++;\n        if (likely(ctn_len == 0)) goto obj_end;\n        if (has_read_flag(ALLOW_TRAILING_COMMAS)) goto obj_end;\n        while (*cur != ',') cur--;\n        goto fail_trailing_comma;\n    }\n    if (char_is_space(*cur)) {\n        while (char_is_space(*++cur));\n        goto obj_key_begin;\n    }\n    if (has_read_flag(ALLOW_COMMENTS)) {\n        if (skip_spaces_and_comments(&cur)) goto obj_key_begin;\n        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \nobj_key_end:\n    if (byte_match_2(cur, \": \")) {\n        cur += 2;\n        goto obj_val_begin;\n    }\n    if (*cur == ':') {\n        cur++;\n        goto obj_val_begin;\n    }\n    if (char_is_space(*cur)) {\n        while (char_is_space(*++cur));\n        goto obj_key_end;\n    }\n    if (has_read_flag(ALLOW_COMMENTS)) {\n        if (skip_spaces_and_comments(&cur)) goto obj_key_end;\n        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \nobj_val_begin:\n    if (*cur == '\"') {\n        val++;\n        ctn_len++;\n        if (likely(read_string(&cur, end, inv, val, &msg))) goto obj_val_end;\n        goto fail_string;\n    }\n    if (char_is_number(*cur)) {\n        val++;\n        ctn_len++;\n        if (likely(read_number(&cur, pre, flg, val, &msg))) goto obj_val_end;\n        goto fail_number;\n    }\n    if (*cur == '{') {\n        cur++;\n        goto obj_begin;\n    }\n    if (*cur == '[') {\n        cur++;\n        goto arr_begin;\n    }\n    if (*cur == 't') {\n        val++;\n        ctn_len++;\n        if (likely(read_true(&cur, val))) goto obj_val_end;\n        goto fail_literal;\n    }\n    if (*cur == 'f') {\n        val++;\n        ctn_len++;\n        if (likely(read_false(&cur, val))) goto obj_val_end;\n        goto fail_literal;\n    }\n    if (*cur == 'n') {\n        val++;\n        ctn_len++;\n        if (likely(read_null(&cur, val))) goto obj_val_end;\n        if (has_read_flag(ALLOW_INF_AND_NAN)) {\n            if (read_nan(false, &cur, pre, val)) goto obj_val_end;\n        }\n        goto fail_literal;\n    }\n    if (char_is_space(*cur)) {\n        while (char_is_space(*++cur));\n        goto obj_val_begin;\n    }\n    if (has_read_flag(ALLOW_INF_AND_NAN) &&\n        (*cur == 'i' || *cur == 'I' || *cur == 'N')) {\n        val++;\n        ctn_len++;\n        if (read_inf_or_nan(false, &cur, pre, val)) goto obj_val_end;\n        goto fail_character;\n    }\n    if (has_read_flag(ALLOW_COMMENTS)) {\n        if (skip_spaces_and_comments(&cur)) goto obj_val_begin;\n        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \nobj_val_end:\n    if (byte_match_2(cur, \",\\n\")) {\n        cur += 2;\n        goto obj_key_begin;\n    }\n    if (likely(*cur == ',')) {\n        cur++;\n        goto obj_key_begin;\n    }\n    if (likely(*cur == '}')) {\n        cur++;\n        goto obj_end;\n    }\n    if (char_is_space(*cur)) {\n        while (char_is_space(*++cur));\n        goto obj_val_end;\n    }\n    if (has_read_flag(ALLOW_COMMENTS)) {\n        if (skip_spaces_and_comments(&cur)) goto obj_val_end;\n        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \nobj_end:\n    container_depth--;\n\n    /* pop container */\n    ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n    /* point to the next value */\n    ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n    ctn->tag = (ctn_len << (YYJSON_TAG_BIT - 1)) | YYJSON_TYPE_OBJ;\n    if (unlikely(ctn == ctn_parent)) goto doc_end;\n    ctn = ctn_parent;\n    ctn_len = (usize)(ctn->tag >> YYJSON_TAG_BIT);\n    if (*cur == '\\n') cur++;\n    if ((ctn->tag & YYJSON_TYPE_MASK) == YYJSON_TYPE_OBJ) {\n        goto obj_val_end;\n    } else {\n        goto arr_val_end;\n    }\n    \ndoc_end:\n    /* check invalid contents after json document */\n    if (unlikely(cur < end) && !has_read_flag(STOP_WHEN_DONE)) {\n        if (has_read_flag(ALLOW_COMMENTS)) {\n            skip_spaces_and_comments(&cur);\n            if (byte_match_2(cur, \"/*\")) goto fail_comment;\n        } else {\n            while (char_is_space(*cur)) cur++;\n        }\n        if (unlikely(cur < end)) goto fail_garbage;\n    }\n    \n    if (pre && *pre) **pre = '\\0';\n    doc = (yyjson_doc *)val_hdr;\n    doc->root = val_hdr + hdr_len;\n    doc->alc = alc;\n    doc->dat_read = (usize)(cur - hdr);\n    doc->val_read = (usize)((val - val_hdr)) - hdr_len + 1;\n    doc->str_pool = has_read_flag(INSITU) ? NULL : (char *)hdr;\n    return doc;\n    \nfail_string:\n    return_err(cur, INVALID_STRING, msg);\nfail_number:\n    return_err(cur, INVALID_NUMBER, msg);\nfail_alloc:\n    return_err(cur, MEMORY_ALLOCATION, \"memory allocation failed\");\nfail_trailing_comma:\n    return_err(cur, JSON_STRUCTURE, \"trailing comma is not allowed\");\nfail_literal:\n    return_err(cur, LITERAL, \"invalid literal\");\nfail_comment:\n    return_err(cur, INVALID_COMMENT, \"unclosed multiline comment\");\nfail_character:\n    return_err(cur, UNEXPECTED_CHARACTER, \"unexpected character\");\nfail_garbage:\n    return_err(cur, UNEXPECTED_CONTENT, \"unexpected content after document\");\nfail_recursion:\n    return_err(cur, RECURSION_DEPTH, \"array and object recursion depth exceeded\");\n    \n#undef val_incr\n#undef return_err\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "read_root_single",
      "func_body": "static_noinline yyjson_doc *read_root_single(u8 *hdr,\n                                             u8 *cur,\n                                             u8 *end,\n                                             yyjson_alc alc,\n                                             yyjson_read_flag flg,\n                                             yyjson_read_err *err) {\n    \n#define return_err(_pos, _code, _msg) do { \\\n    if (is_truncated_end(hdr, _pos, end, YYJSON_READ_ERROR_##_code, flg)) { \\\n        err->pos = (usize)(end - hdr); \\\n        err->code = YYJSON_READ_ERROR_UNEXPECTED_END; \\\n        err->msg = \"unexpected end of data\"; \\\n    } else { \\\n        err->pos = (usize)(_pos - hdr); \\\n        err->code = YYJSON_READ_ERROR_##_code; \\\n        err->msg = _msg; \\\n    } \\\n    if (val_hdr) alc.free(alc.ctx, (void *)val_hdr); \\\n    return NULL; \\\n} while (false)\n    \n    usize hdr_len; /* value count used by doc */\n    usize alc_num; /* value count capacity */\n    yyjson_val *val_hdr; /* the head of allocated values */\n    yyjson_val *val; /* current value */\n    yyjson_doc *doc; /* the JSON document, equals to val_hdr */\n    const char *msg; /* error message */\n    \n    bool raw; /* read number as raw */\n    bool inv; /* allow invalid unicode */\n    u8 *raw_end; /* raw end for null-terminator */\n    u8 **pre; /* previous raw end pointer */\n    \n    hdr_len = sizeof(yyjson_doc) / sizeof(yyjson_val);\n    hdr_len += (sizeof(yyjson_doc) % sizeof(yyjson_val)) > 0;\n    alc_num = hdr_len + 1; /* single value */\n    \n    val_hdr = (yyjson_val *)alc.malloc(alc.ctx, alc_num * sizeof(yyjson_val));\n    if (unlikely(!val_hdr)) goto fail_alloc;\n    val = val_hdr + hdr_len;\n    raw = has_read_flag(NUMBER_AS_RAW) || has_read_flag(BIGNUM_AS_RAW);\n    inv = has_read_flag(ALLOW_INVALID_UNICODE) != 0;\n    raw_end = NULL;\n    pre = raw ? &raw_end : NULL;\n    \n    if (char_is_number(*cur)) {\n        if (likely(read_number(&cur, pre, flg, val, &msg))) goto doc_end;\n        goto fail_number;\n    }\n    if (*cur == '\"') {\n        if (likely(read_string(&cur, end, inv, val, &msg))) goto doc_end;\n        goto fail_string;\n    }\n    if (*cur == 't') {\n        if (likely(read_true(&cur, val))) goto doc_end;\n        goto fail_literal;\n    }\n    if (*cur == 'f') {\n        if (likely(read_false(&cur, val))) goto doc_end;\n        goto fail_literal;\n    }\n    if (*cur == 'n') {\n        if (likely(read_null(&cur, val))) goto doc_end;\n        if (has_read_flag(ALLOW_INF_AND_NAN)) {\n            if (read_nan(false, &cur, pre, val)) goto doc_end;\n        }\n        goto fail_literal;\n    }\n    if (has_read_flag(ALLOW_INF_AND_NAN)) {\n        if (read_inf_or_nan(false, &cur, pre, val)) goto doc_end;\n    }\n    goto fail_character;\n    \ndoc_end:\n    /* check invalid contents after json document */\n    if (unlikely(cur < end) && !has_read_flag(STOP_WHEN_DONE)) {\n        if (has_read_flag(ALLOW_COMMENTS)) {\n            if (!skip_spaces_and_comments(&cur)) {\n                if (byte_match_2(cur, \"/*\")) goto fail_comment;\n            }\n        } else {\n            while (char_is_space(*cur)) cur++;\n        }\n        if (unlikely(cur < end)) goto fail_garbage;\n    }\n    \n    if (pre && *pre) **pre = '\\0';\n    doc = (yyjson_doc *)val_hdr;\n    doc->root = val_hdr + hdr_len;\n    doc->alc = alc;\n    doc->dat_read = (usize)(cur - hdr);\n    doc->val_read = 1;\n    doc->str_pool = has_read_flag(INSITU) ? NULL : (char *)hdr;\n    return doc;\n    \nfail_string:\n    return_err(cur, INVALID_STRING, msg);\nfail_number:\n    return_err(cur, INVALID_NUMBER, msg);\nfail_alloc:\n    return_err(cur, MEMORY_ALLOCATION, \"memory allocation failed\");\nfail_literal:\n    return_err(cur, LITERAL, \"invalid literal\");\nfail_comment:\n    return_err(cur, INVALID_COMMENT, \"unclosed multiline comment\");\nfail_character:\n    return_err(cur, UNEXPECTED_CHARACTER, \"unexpected character\");\nfail_garbage:\n    return_err(cur, UNEXPECTED_CONTENT, \"unexpected content after document\");\nfail_recursion:\n    return_err(cur, RECURSION_DEPTH, \"array and object recursion depth exceeded\");\n    \n#undef return_err\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "unsafe_yyjson_equals",
      "func_body": "bool unsafe_yyjson_equals(yyjson_val *lhs, yyjson_val *rhs) {\n    yyjson_type type = unsafe_yyjson_get_type(lhs);\n    if (type != unsafe_yyjson_get_type(rhs)) return false;\n    \n    switch (type) {\n        case YYJSON_TYPE_OBJ: {\n            usize len = unsafe_yyjson_get_len(lhs);\n            if (len != unsafe_yyjson_get_len(rhs)) return false;\n            if (len > 0) {\n                yyjson_obj_iter iter;\n                yyjson_obj_iter_init(rhs, &iter);\n                lhs = unsafe_yyjson_get_first(lhs);\n                while (len-- > 0) {\n                    rhs = yyjson_obj_iter_getn(&iter, lhs->uni.str,\n                                               unsafe_yyjson_get_len(lhs));\n                    if (!rhs) return false;\n                    if (!unsafe_yyjson_equals(lhs + 1, rhs)) return false;\n                    lhs = unsafe_yyjson_get_next(lhs + 1);\n                }\n            }\n            /* yyjson allows duplicate keys, so the check may be inaccurate */\n            return true;\n        }\n        \n        case YYJSON_TYPE_ARR: {\n            usize len = unsafe_yyjson_get_len(lhs);\n            if (len != unsafe_yyjson_get_len(rhs)) return false;\n            if (len > 0) {\n                lhs = unsafe_yyjson_get_first(lhs);\n                rhs = unsafe_yyjson_get_first(rhs);\n                while (len-- > 0) {\n                    if (!unsafe_yyjson_equals(lhs, rhs)) return false;\n                    lhs = unsafe_yyjson_get_next(lhs);\n                    rhs = unsafe_yyjson_get_next(rhs);\n                }\n            }\n            return true;\n        }\n        \n        case YYJSON_TYPE_NUM:\n            return unsafe_yyjson_num_equals(lhs, rhs);\n        \n        case YYJSON_TYPE_RAW:\n        case YYJSON_TYPE_STR:\n            return unsafe_yyjson_str_equals(lhs, rhs);\n        \n        case YYJSON_TYPE_NULL:\n        case YYJSON_TYPE_BOOL:\n            return lhs->tag == rhs->tag;\n        \n        default:\n            return false;\n    }\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "unsafe_yyjson_mut_equals",
      "func_body": "bool unsafe_yyjson_mut_equals(yyjson_mut_val *lhs, yyjson_mut_val *rhs) {\n    yyjson_type type = unsafe_yyjson_get_type(lhs);\n    if (type != unsafe_yyjson_get_type(rhs)) return false;\n    \n    switch (type) {\n        case YYJSON_TYPE_OBJ: {\n            usize len = unsafe_yyjson_get_len(lhs);\n            if (len != unsafe_yyjson_get_len(rhs)) return false;\n            if (len > 0) {\n                yyjson_mut_obj_iter iter;\n                yyjson_mut_obj_iter_init(rhs, &iter);\n                lhs = (yyjson_mut_val *)lhs->uni.ptr;\n                while (len-- > 0) {\n                    rhs = yyjson_mut_obj_iter_getn(&iter, lhs->uni.str,\n                                                   unsafe_yyjson_get_len(lhs));\n                    if (!rhs) return false;\n                    if (!unsafe_yyjson_mut_equals(lhs->next, rhs)) return false;\n                    lhs = lhs->next->next;\n                }\n            }\n            /* yyjson allows duplicate keys, so the check may be inaccurate */\n            return true;\n        }\n        \n        case YYJSON_TYPE_ARR: {\n            usize len = unsafe_yyjson_get_len(lhs);\n            if (len != unsafe_yyjson_get_len(rhs)) return false;\n            if (len > 0) {\n                lhs = (yyjson_mut_val *)lhs->uni.ptr;\n                rhs = (yyjson_mut_val *)rhs->uni.ptr;\n                while (len-- > 0) {\n                    if (!unsafe_yyjson_mut_equals(lhs, rhs)) return false;\n                    lhs = lhs->next;\n                    rhs = rhs->next;\n                }\n            }\n            return true;\n        }\n        \n        case YYJSON_TYPE_NUM:\n            return unsafe_yyjson_num_equals(lhs, rhs);\n        \n        case YYJSON_TYPE_RAW:\n        case YYJSON_TYPE_STR:\n            return unsafe_yyjson_str_equals(lhs, rhs);\n        \n        case YYJSON_TYPE_NULL:\n        case YYJSON_TYPE_BOOL:\n            return lhs->tag == rhs->tag;\n        \n        default:\n            return false;\n    }\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "unsafe_yyjson_num_equals",
      "func_body": "static_inline bool unsafe_yyjson_num_equals(void *lhs, void *rhs) {\n    yyjson_val_uni *luni = &((yyjson_val *)lhs)->uni;\n    yyjson_val_uni *runi = &((yyjson_val *)rhs)->uni;\n    yyjson_subtype lt = unsafe_yyjson_get_subtype(lhs);\n    yyjson_subtype rt = unsafe_yyjson_get_subtype(rhs);\n    if (lt == rt) return luni->u64 == runi->u64;\n    if (lt == YYJSON_SUBTYPE_SINT && rt == YYJSON_SUBTYPE_UINT) {\n        return luni->i64 >= 0 && luni->u64 == runi->u64;\n    }\n    if (lt == YYJSON_SUBTYPE_UINT && rt == YYJSON_SUBTYPE_SINT) {\n        return runi->i64 >= 0 && luni->u64 == runi->u64;\n    }\n    return false;\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "yyjson_alc_dyn_free",
      "func_body": "void yyjson_alc_dyn_free(yyjson_alc *alc) {\n    const yyjson_alc def = YYJSON_DEFAULT_ALC;\n    dyn_ctx *ctx = (dyn_ctx *)(void *)(alc + 1);\n    dyn_chunk *chunk, *next;\n    if (unlikely(!alc)) return;\n    for (chunk = ctx->free_list.next; chunk; chunk = next) {\n        next = chunk->next;\n        def.free(def.ctx, chunk);\n    }\n    for (chunk = ctx->used_list.next; chunk; chunk = next) {\n        next = chunk->next;\n        def.free(def.ctx, chunk);\n    }\n    def.free(def.ctx, alc);\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "yyjson_alc_dyn_new",
      "func_body": "yyjson_alc *yyjson_alc_dyn_new(void) {\n    const yyjson_alc def = YYJSON_DEFAULT_ALC;\n    usize hdr_len = sizeof(yyjson_alc) + sizeof(dyn_ctx);\n    yyjson_alc *alc = (yyjson_alc *)def.malloc(def.ctx, hdr_len);\n    dyn_ctx *ctx = (dyn_ctx *)(void *)(alc + 1);\n    if (unlikely(!alc)) return NULL;\n    alc->malloc = dyn_malloc;\n    alc->realloc = dyn_realloc;\n    alc->free = dyn_free;\n    alc->ctx = alc + 1;\n    memset(ctx, 0, sizeof(*ctx));\n    return alc;\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "yyjson_merge_patch",
      "func_body": "yyjson_mut_val *yyjson_merge_patch(yyjson_mut_doc *doc,\n                                   yyjson_val *orig,\n                                   yyjson_val *patch) {\n    usize idx, max;\n    yyjson_val *key, *orig_val, *patch_val, local_orig;\n    yyjson_mut_val *builder, *mut_key, *mut_val, *merged_val;\n    \n    if (unlikely(!yyjson_is_obj(patch))) {\n        return yyjson_val_mut_copy(doc, patch);\n    }\n    \n    builder = yyjson_mut_obj(doc);\n    if (unlikely(!builder)) return NULL;\n    \n    memset(&local_orig, 0, sizeof(local_orig));\n    if (!yyjson_is_obj(orig)) {\n        orig = &local_orig;\n        orig->tag = builder->tag;\n        orig->uni = builder->uni;\n    }\n    \n    /* If orig is contributing, copy any items not modified by the patch */\n    if (orig != &local_orig) {\n        yyjson_obj_foreach(orig, idx, max, key, orig_val) {\n            patch_val = yyjson_obj_getn(patch,\n                                        unsafe_yyjson_get_str(key),\n                                        unsafe_yyjson_get_len(key));\n            if (!patch_val) {\n                mut_key = yyjson_val_mut_copy(doc, key);\n                mut_val = yyjson_val_mut_copy(doc, orig_val);\n                if (!yyjson_mut_obj_add(builder, mut_key, mut_val)) return NULL;\n            }\n        }\n    }\n\n    /* Merge items modified by the patch. */\n    yyjson_obj_foreach(patch, idx, max, key, patch_val) {\n        /* null indicates the field is removed. */\n        if (unsafe_yyjson_is_null(patch_val)) {\n            continue;\n        }\n        mut_key = yyjson_val_mut_copy(doc, key);\n        orig_val = yyjson_obj_getn(orig,\n                                   unsafe_yyjson_get_str(key),\n                                   unsafe_yyjson_get_len(key));\n        merged_val = yyjson_merge_patch(doc, orig_val, patch_val);\n        if (!yyjson_mut_obj_add(builder, mut_key, merged_val)) return NULL;\n    }\n    \n    return builder;\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "yyjson_mut_doc_free",
      "func_body": "void yyjson_mut_doc_free(yyjson_mut_doc *doc) {\n    if (doc) {\n        yyjson_alc alc = doc->alc;\n        memset(&doc->alc, 0, sizeof(alc));\n        unsafe_yyjson_str_pool_release(&doc->str_pool, &alc);\n        unsafe_yyjson_val_pool_release(&doc->val_pool, &alc);\n        alc.free(alc.ctx, doc);\n    }\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "yyjson_mut_merge_patch",
      "func_body": "yyjson_mut_val *yyjson_mut_merge_patch(yyjson_mut_doc *doc,\n                                       yyjson_mut_val *orig,\n                                       yyjson_mut_val *patch) {\n    usize idx, max;\n    yyjson_mut_val *key, *orig_val, *patch_val, local_orig;\n    yyjson_mut_val *builder, *mut_key, *mut_val, *merged_val;\n    \n    if (unlikely(!yyjson_mut_is_obj(patch))) {\n        return yyjson_mut_val_mut_copy(doc, patch);\n    }\n    \n    builder = yyjson_mut_obj(doc);\n    if (unlikely(!builder)) return NULL;\n    \n    memset(&local_orig, 0, sizeof(local_orig));\n    if (!yyjson_mut_is_obj(orig)) {\n        orig = &local_orig;\n        orig->tag = builder->tag;\n        orig->uni = builder->uni;\n    }\n    \n    /* If orig is contributing, copy any items not modified by the patch */\n    if (orig != &local_orig) {\n        yyjson_mut_obj_foreach(orig, idx, max, key, orig_val) {\n            patch_val = yyjson_mut_obj_getn(patch,\n                                            unsafe_yyjson_get_str(key),\n                                            unsafe_yyjson_get_len(key));\n            if (!patch_val) {\n                mut_key = yyjson_mut_val_mut_copy(doc, key);\n                mut_val = yyjson_mut_val_mut_copy(doc, orig_val);\n                if (!yyjson_mut_obj_add(builder, mut_key, mut_val)) return NULL;\n            }\n        }\n    }\n\n    /* Merge items modified by the patch. */\n    yyjson_mut_obj_foreach(patch, idx, max, key, patch_val) {\n        /* null indicates the field is removed. */\n        if (unsafe_yyjson_is_null(patch_val)) {\n            continue;\n        }\n        mut_key = yyjson_mut_val_mut_copy(doc, key);\n        orig_val = yyjson_mut_obj_getn(orig,\n                                       unsafe_yyjson_get_str(key),\n                                       unsafe_yyjson_get_len(key));\n        merged_val = yyjson_mut_merge_patch(doc, orig_val, patch_val);\n        if (!yyjson_mut_obj_add(builder, mut_key, merged_val)) return NULL;\n    }\n    \n    return builder;\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "yyjson_mut_write_minify",
      "func_body": "static_inline u8 *yyjson_mut_write_minify(const yyjson_mut_val *root,\n                                          usize estimated_val_num,\n                                          yyjson_write_flag flg,\n                                          yyjson_alc alc,\n                                          usize *dat_len,\n                                          yyjson_write_err *err) {\n    \n#define return_err(_code, _msg) do { \\\n    *dat_len = 0; \\\n    err->code = YYJSON_WRITE_ERROR_##_code; \\\n    err->msg = _msg; \\\n    if (hdr) alc.free(alc.ctx, hdr); \\\n    return NULL; \\\n} while (false)\n    \n#define incr_len(_len) do { \\\n    ext_len = (usize)(_len); \\\n    if (unlikely((u8 *)(cur + ext_len) >= (u8 *)ctx)) { \\\n        alc_inc = yyjson_max(alc_len / 2, ext_len); \\\n        alc_inc = size_align_up(alc_inc, sizeof(yyjson_mut_write_ctx)); \\\n        if ((sizeof(usize) < 8) && size_add_is_overflow(alc_len, alc_inc)) \\\n            goto fail_alloc; \\\n        alc_len += alc_inc; \\\n        tmp = (u8 *)alc.realloc(alc.ctx, hdr, alc_len - alc_inc, alc_len); \\\n        if (unlikely(!tmp)) goto fail_alloc; \\\n        ctx_len = (usize)(end - (u8 *)ctx); \\\n        ctx_tmp = (yyjson_mut_write_ctx *)(void *)(tmp + (alc_len - ctx_len)); \\\n        memmove((void *)ctx_tmp, (void *)(tmp + ((u8 *)ctx - hdr)), ctx_len); \\\n        ctx = ctx_tmp; \\\n        cur = tmp + (cur - hdr); \\\n        end = tmp + alc_len; \\\n        hdr = tmp; \\\n    } \\\n} while (false)\n    \n#define check_str_len(_len) do { \\\n    if ((sizeof(usize) < 8) && (_len >= (USIZE_MAX - 16) / 6)) \\\n        goto fail_alloc; \\\n} while (false)\n    \n    yyjson_mut_val *val, *ctn;\n    yyjson_type val_type;\n    usize ctn_len, ctn_len_tmp;\n    bool ctn_obj, ctn_obj_tmp, is_key;\n    u8 *hdr, *cur, *end, *tmp;\n    yyjson_mut_write_ctx *ctx, *ctx_tmp;\n    usize alc_len, alc_inc, ctx_len, ext_len, str_len;\n    const u8 *str_ptr;\n    const char_enc_type *enc_table = get_enc_table_with_flag(flg);\n    bool cpy = (enc_table == enc_table_cpy);\n    bool esc = has_write_flag(ESCAPE_UNICODE) != 0;\n    bool inv = has_write_flag(ALLOW_INVALID_UNICODE) != 0;\n    bool newline = has_write_flag(NEWLINE_AT_END) != 0;\n    \n    alc_len = estimated_val_num * YYJSON_WRITER_ESTIMATED_MINIFY_RATIO + 64;\n    alc_len = size_align_up(alc_len, sizeof(yyjson_mut_write_ctx));\n    hdr = (u8 *)alc.malloc(alc.ctx, alc_len);\n    if (!hdr) goto fail_alloc;\n    cur = hdr;\n    end = hdr + alc_len;\n    ctx = (yyjson_mut_write_ctx *)(void *)end;\n    \ndoc_begin:\n    val = constcast(yyjson_mut_val *)root;\n    val_type = unsafe_yyjson_get_type(val);\n    ctn_obj = (val_type == YYJSON_TYPE_OBJ);\n    ctn_len = unsafe_yyjson_get_len(val) << (u8)ctn_obj;\n    *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n    ctn = val;\n    val = (yyjson_mut_val *)val->uni.ptr; /* tail */\n    val = ctn_obj ? val->next->next : val->next;\n    \nval_begin:\n    val_type = unsafe_yyjson_get_type(val);\n    if (val_type == YYJSON_TYPE_STR) {\n        is_key = ((u8)ctn_obj & (u8)~ctn_len);\n        str_len = unsafe_yyjson_get_len(val);\n        str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n        check_str_len(str_len);\n        incr_len(str_len * 6 + 16);\n        if (likely(cpy) && unsafe_yyjson_get_subtype(val)) {\n            cur = write_string_noesc(cur, str_ptr, str_len);\n        } else {\n            cur = write_string(cur, esc, inv, str_ptr, str_len, enc_table);\n            if (unlikely(!cur)) goto fail_str;\n        }\n        *cur++ = is_key ? ':' : ',';\n        goto val_end;\n    }\n    if (val_type == YYJSON_TYPE_NUM) {\n        incr_len(32);\n        cur = write_number(cur, (yyjson_val *)val, flg);\n        if (unlikely(!cur)) goto fail_num;\n        *cur++ = ',';\n        goto val_end;\n    }\n    if ((val_type & (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) ==\n                    (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) {\n        ctn_len_tmp = unsafe_yyjson_get_len(val);\n        ctn_obj_tmp = (val_type == YYJSON_TYPE_OBJ);\n        incr_len(16);\n        if (unlikely(ctn_len_tmp == 0)) {\n            /* write empty container */\n            *cur++ = (u8)('[' | ((u8)ctn_obj_tmp << 5));\n            *cur++ = (u8)(']' | ((u8)ctn_obj_tmp << 5));\n            *cur++ = ',';\n            goto val_end;\n        } else {\n            /* push context, setup new container */\n            yyjson_mut_write_ctx_set(--ctx, ctn, ctn_len, ctn_obj);\n            ctn_len = ctn_len_tmp << (u8)ctn_obj_tmp;\n            ctn_obj = ctn_obj_tmp;\n            *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n            ctn = val;\n            val = (yyjson_mut_val *)ctn->uni.ptr; /* tail */\n            val = ctn_obj ? val->next->next : val->next;\n            goto val_begin;\n        }\n    }\n    if (val_type == YYJSON_TYPE_BOOL) {\n        incr_len(16);\n        cur = write_bool(cur, unsafe_yyjson_get_bool(val));\n        cur++;\n        goto val_end;\n    }\n    if (val_type == YYJSON_TYPE_NULL) {\n        incr_len(16);\n        cur = write_null(cur);\n        cur++;\n        goto val_end;\n    }\n    if (val_type == YYJSON_TYPE_RAW) {\n        str_len = unsafe_yyjson_get_len(val);\n        str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n        check_str_len(str_len);\n        incr_len(str_len + 2);\n        cur = write_raw(cur, str_ptr, str_len);\n        *cur++ = ',';\n        goto val_end;\n    }\n    goto fail_type;\n    \nval_end:\n    ctn_len--;\n    if (unlikely(ctn_len == 0)) goto ctn_end;\n    val = val->next;\n    goto val_begin;\n    \nctn_end:\n    cur--;\n    *cur++ = (u8)(']' | ((u8)ctn_obj << 5));\n    *cur++ = ',';\n    if (unlikely((u8 *)ctx >= end)) goto doc_end;\n    val = ctn->next;\n    yyjson_mut_write_ctx_get(ctx++, &ctn, &ctn_len, &ctn_obj);\n    ctn_len--;\n    if (likely(ctn_len > 0)) {\n        goto val_begin;\n    } else {\n        goto ctn_end;\n    }\n    \ndoc_end:\n    if (newline) {\n        incr_len(2);\n        *(cur - 1) = '\\n';\n        cur++;\n    }\n    *--cur = '\\0';\n    *dat_len = (usize)(cur - hdr);\n    err->code = YYJSON_WRITE_SUCCESS;\n    err->msg = \"success\";\n    return hdr;\n    \nfail_alloc:\n    return_err(MEMORY_ALLOCATION, \"memory allocation failed\");\nfail_type:\n    return_err(INVALID_VALUE_TYPE, \"invalid JSON value type\");\nfail_num:\n    return_err(NAN_OR_INF, \"nan or inf number is not allowed\");\nfail_str:\n    return_err(INVALID_STRING, \"invalid utf-8 encoding in string\");\n    \n#undef return_err\n#undef incr_len\n#undef check_str_len\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "yyjson_mut_write_pretty",
      "func_body": "static_inline u8 *yyjson_mut_write_pretty(const yyjson_mut_val *root,\n                                          usize estimated_val_num,\n                                          yyjson_write_flag flg,\n                                          yyjson_alc alc,\n                                          usize *dat_len,\n                                          yyjson_write_err *err) {\n    \n#define return_err(_code, _msg) do { \\\n    *dat_len = 0; \\\n    err->code = YYJSON_WRITE_ERROR_##_code; \\\n    err->msg = _msg; \\\n    if (hdr) alc.free(alc.ctx, hdr); \\\n    return NULL; \\\n} while (false)\n    \n#define incr_len(_len) do { \\\n    ext_len = (usize)(_len); \\\n    if (unlikely((u8 *)(cur + ext_len) >= (u8 *)ctx)) { \\\n        alc_inc = yyjson_max(alc_len / 2, ext_len); \\\n        alc_inc = size_align_up(alc_inc, sizeof(yyjson_mut_write_ctx)); \\\n        if ((sizeof(usize) < 8) && size_add_is_overflow(alc_len, alc_inc)) \\\n            goto fail_alloc; \\\n        alc_len += alc_inc; \\\n        tmp = (u8 *)alc.realloc(alc.ctx, hdr, alc_len - alc_inc, alc_len); \\\n        if (unlikely(!tmp)) goto fail_alloc; \\\n        ctx_len = (usize)(end - (u8 *)ctx); \\\n        ctx_tmp = (yyjson_mut_write_ctx *)(void *)(tmp + (alc_len - ctx_len)); \\\n        memmove((void *)ctx_tmp, (void *)(tmp + ((u8 *)ctx - hdr)), ctx_len); \\\n        ctx = ctx_tmp; \\\n        cur = tmp + (cur - hdr); \\\n        end = tmp + alc_len; \\\n        hdr = tmp; \\\n    } \\\n} while (false)\n    \n#define check_str_len(_len) do { \\\n    if ((sizeof(usize) < 8) && (_len >= (USIZE_MAX - 16) / 6)) \\\n        goto fail_alloc; \\\n} while (false)\n    \n    yyjson_mut_val *val, *ctn;\n    yyjson_type val_type;\n    usize ctn_len, ctn_len_tmp;\n    bool ctn_obj, ctn_obj_tmp, is_key, no_indent;\n    u8 *hdr, *cur, *end, *tmp;\n    yyjson_mut_write_ctx *ctx, *ctx_tmp;\n    usize alc_len, alc_inc, ctx_len, ext_len, str_len, level;\n    const u8 *str_ptr;\n    const char_enc_type *enc_table = get_enc_table_with_flag(flg);\n    bool cpy = (enc_table == enc_table_cpy);\n    bool esc = has_write_flag(ESCAPE_UNICODE) != 0;\n    bool inv = has_write_flag(ALLOW_INVALID_UNICODE) != 0;\n    usize spaces = has_write_flag(PRETTY_TWO_SPACES) ? 2 : 4;\n    bool newline = has_write_flag(NEWLINE_AT_END) != 0;\n    \n    alc_len = estimated_val_num * YYJSON_WRITER_ESTIMATED_PRETTY_RATIO + 64;\n    alc_len = size_align_up(alc_len, sizeof(yyjson_mut_write_ctx));\n    hdr = (u8 *)alc.malloc(alc.ctx, alc_len);\n    if (!hdr) goto fail_alloc;\n    cur = hdr;\n    end = hdr + alc_len;\n    ctx = (yyjson_mut_write_ctx *)(void *)end;\n    \ndoc_begin:\n    val = constcast(yyjson_mut_val *)root;\n    val_type = unsafe_yyjson_get_type(val);\n    ctn_obj = (val_type == YYJSON_TYPE_OBJ);\n    ctn_len = unsafe_yyjson_get_len(val) << (u8)ctn_obj;\n    *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n    *cur++ = '\\n';\n    ctn = val;\n    val = (yyjson_mut_val *)val->uni.ptr; /* tail */\n    val = ctn_obj ? val->next->next : val->next;\n    level = 1;\n    \nval_begin:\n    val_type = unsafe_yyjson_get_type(val);\n    if (val_type == YYJSON_TYPE_STR) {\n        is_key = (bool)((u8)ctn_obj & (u8)~ctn_len);\n        no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n        str_len = unsafe_yyjson_get_len(val);\n        str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n        check_str_len(str_len);\n        incr_len(str_len * 6 + 16 + (no_indent ? 0 : level * 4));\n        cur = write_indent(cur, no_indent ? 0 : level, spaces);\n        if (likely(cpy) && unsafe_yyjson_get_subtype(val)) {\n            cur = write_string_noesc(cur, str_ptr, str_len);\n        } else {\n            cur = write_string(cur, esc, inv, str_ptr, str_len, enc_table);\n            if (unlikely(!cur)) goto fail_str;\n        }\n        *cur++ = is_key ? ':' : ',';\n        *cur++ = is_key ? ' ' : '\\n';\n        goto val_end;\n    }\n    if (val_type == YYJSON_TYPE_NUM) {\n        no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n        incr_len(32 + (no_indent ? 0 : level * 4));\n        cur = write_indent(cur, no_indent ? 0 : level, spaces);\n        cur = write_number(cur, (yyjson_val *)val, flg);\n        if (unlikely(!cur)) goto fail_num;\n        *cur++ = ',';\n        *cur++ = '\\n';\n        goto val_end;\n    }\n    if ((val_type & (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) ==\n                    (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) {\n        no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n        ctn_len_tmp = unsafe_yyjson_get_len(val);\n        ctn_obj_tmp = (val_type == YYJSON_TYPE_OBJ);\n        if (unlikely(ctn_len_tmp == 0)) {\n            /* write empty container */\n            incr_len(16 + (no_indent ? 0 : level * 4));\n            cur = write_indent(cur, no_indent ? 0 : level, spaces);\n            *cur++ = (u8)('[' | ((u8)ctn_obj_tmp << 5));\n            *cur++ = (u8)(']' | ((u8)ctn_obj_tmp << 5));\n            *cur++ = ',';\n            *cur++ = '\\n';\n            goto val_end;\n        } else {\n            /* push context, setup new container */\n            incr_len(32 + (no_indent ? 0 : level * 4));\n            yyjson_mut_write_ctx_set(--ctx, ctn, ctn_len, ctn_obj);\n            ctn_len = ctn_len_tmp << (u8)ctn_obj_tmp;\n            ctn_obj = ctn_obj_tmp;\n            cur = write_indent(cur, no_indent ? 0 : level, spaces);\n            level++;\n            *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n            *cur++ = '\\n';\n            ctn = val;\n            val = (yyjson_mut_val *)ctn->uni.ptr; /* tail */\n            val = ctn_obj ? val->next->next : val->next;\n            goto val_begin;\n        }\n    }\n    if (val_type == YYJSON_TYPE_BOOL) {\n        no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n        incr_len(16 + (no_indent ? 0 : level * 4));\n        cur = write_indent(cur, no_indent ? 0 : level, spaces);\n        cur = write_bool(cur, unsafe_yyjson_get_bool(val));\n        cur += 2;\n        goto val_end;\n    }\n    if (val_type == YYJSON_TYPE_NULL) {\n        no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n        incr_len(16 + (no_indent ? 0 : level * 4));\n        cur = write_indent(cur, no_indent ? 0 : level, spaces);\n        cur = write_null(cur);\n        cur += 2;\n        goto val_end;\n    }\n    if (val_type == YYJSON_TYPE_RAW) {\n        str_len = unsafe_yyjson_get_len(val);\n        str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n        check_str_len(str_len);\n        incr_len(str_len + 3);\n        cur = write_raw(cur, str_ptr, str_len);\n        *cur++ = ',';\n        *cur++ = '\\n';\n        goto val_end;\n    }\n    goto fail_type;\n    \nval_end:\n    ctn_len--;\n    if (unlikely(ctn_len == 0)) goto ctn_end;\n    val = val->next;\n    goto val_begin;\n    \nctn_end:\n    cur -= 2;\n    *cur++ = '\\n';\n    incr_len(level * 4);\n    cur = write_indent(cur, --level, spaces);\n    *cur++ = (u8)(']' | ((u8)ctn_obj << 5));\n    if (unlikely((u8 *)ctx >= end)) goto doc_end;\n    val = ctn->next;\n    yyjson_mut_write_ctx_get(ctx++, &ctn, &ctn_len, &ctn_obj);\n    ctn_len--;\n    *cur++ = ',';\n    *cur++ = '\\n';\n    if (likely(ctn_len > 0)) {\n        goto val_begin;\n    } else {\n        goto ctn_end;\n    }\n    \ndoc_end:\n    if (newline) {\n        incr_len(2);\n        *cur++ = '\\n';\n    }\n    *cur = '\\0';\n    *dat_len = (usize)(cur - hdr);\n    err->code = YYJSON_WRITE_SUCCESS;\n    err->msg = \"success\";\n    return hdr;\n    \nfail_alloc:\n    return_err(MEMORY_ALLOCATION, \"memory allocation failed\");\nfail_type:\n    return_err(INVALID_VALUE_TYPE, \"invalid JSON value type\");\nfail_num:\n    return_err(NAN_OR_INF, \"nan or inf number is not allowed\");\nfail_str:\n    return_err(INVALID_STRING, \"invalid utf-8 encoding in string\");\n    \n#undef return_err\n#undef incr_len\n#undef check_str_len\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "yyjson_write_minify",
      "func_body": "static_inline u8 *yyjson_write_minify(const yyjson_val *root,\n                                      const yyjson_write_flag flg,\n                                      const yyjson_alc alc,\n                                      usize *dat_len,\n                                      yyjson_write_err *err) {\n    \n#define return_err(_code, _msg) do { \\\n    *dat_len = 0; \\\n    err->code = YYJSON_WRITE_ERROR_##_code; \\\n    err->msg = _msg; \\\n    if (hdr) alc.free(alc.ctx, hdr); \\\n    return NULL; \\\n} while (false)\n    \n#define incr_len(_len) do { \\\n    ext_len = (usize)(_len); \\\n    if (unlikely((u8 *)(cur + ext_len) >= (u8 *)ctx)) { \\\n        alc_inc = yyjson_max(alc_len / 2, ext_len); \\\n        alc_inc = size_align_up(alc_inc, sizeof(yyjson_write_ctx)); \\\n        if ((sizeof(usize) < 8) && size_add_is_overflow(alc_len, alc_inc)) \\\n            goto fail_alloc; \\\n        alc_len += alc_inc; \\\n        tmp = (u8 *)alc.realloc(alc.ctx, hdr, alc_len - alc_inc, alc_len); \\\n        if (unlikely(!tmp)) goto fail_alloc; \\\n        ctx_len = (usize)(end - (u8 *)ctx); \\\n        ctx_tmp = (yyjson_write_ctx *)(void *)(tmp + (alc_len - ctx_len)); \\\n        memmove((void *)ctx_tmp, (void *)(tmp + ((u8 *)ctx - hdr)), ctx_len); \\\n        ctx = ctx_tmp; \\\n        cur = tmp + (cur - hdr); \\\n        end = tmp + alc_len; \\\n        hdr = tmp; \\\n    } \\\n} while (false)\n    \n#define check_str_len(_len) do { \\\n    if ((sizeof(usize) < 8) && (_len >= (USIZE_MAX - 16) / 6)) \\\n        goto fail_alloc; \\\n} while (false)\n    \n    yyjson_val *val;\n    yyjson_type val_type;\n    usize ctn_len, ctn_len_tmp;\n    bool ctn_obj, ctn_obj_tmp, is_key;\n    u8 *hdr, *cur, *end, *tmp;\n    yyjson_write_ctx *ctx, *ctx_tmp;\n    usize alc_len, alc_inc, ctx_len, ext_len, str_len;\n    const u8 *str_ptr;\n    const char_enc_type *enc_table = get_enc_table_with_flag(flg);\n    bool cpy = (enc_table == enc_table_cpy);\n    bool esc = has_write_flag(ESCAPE_UNICODE) != 0;\n    bool inv = has_write_flag(ALLOW_INVALID_UNICODE) != 0;\n    bool newline = has_write_flag(NEWLINE_AT_END) != 0;\n    \n    alc_len = root->uni.ofs / sizeof(yyjson_val);\n    alc_len = alc_len * YYJSON_WRITER_ESTIMATED_MINIFY_RATIO + 64;\n    alc_len = size_align_up(alc_len, sizeof(yyjson_write_ctx));\n    hdr = (u8 *)alc.malloc(alc.ctx, alc_len);\n    if (!hdr) goto fail_alloc;\n    cur = hdr;\n    end = hdr + alc_len;\n    ctx = (yyjson_write_ctx *)(void *)end;\n    \ndoc_begin:\n    val = constcast(yyjson_val *)root;\n    val_type = unsafe_yyjson_get_type(val);\n    ctn_obj = (val_type == YYJSON_TYPE_OBJ);\n    ctn_len = unsafe_yyjson_get_len(val) << (u8)ctn_obj;\n    *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n    val++;\n    \nval_begin:\n    val_type = unsafe_yyjson_get_type(val);\n    if (val_type == YYJSON_TYPE_STR) {\n        is_key = ((u8)ctn_obj & (u8)~ctn_len);\n        str_len = unsafe_yyjson_get_len(val);\n        str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n        check_str_len(str_len);\n        incr_len(str_len * 6 + 16);\n        if (likely(cpy) && unsafe_yyjson_get_subtype(val)) {\n            cur = write_string_noesc(cur, str_ptr, str_len);\n        } else {\n            cur = write_string(cur, esc, inv, str_ptr, str_len, enc_table);\n            if (unlikely(!cur)) goto fail_str;\n        }\n        *cur++ = is_key ? ':' : ',';\n        goto val_end;\n    }\n    if (val_type == YYJSON_TYPE_NUM) {\n        incr_len(32);\n        cur = write_number(cur, val, flg);\n        if (unlikely(!cur)) goto fail_num;\n        *cur++ = ',';\n        goto val_end;\n    }\n    if ((val_type & (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) ==\n                    (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) {\n        ctn_len_tmp = unsafe_yyjson_get_len(val);\n        ctn_obj_tmp = (val_type == YYJSON_TYPE_OBJ);\n        incr_len(16);\n        if (unlikely(ctn_len_tmp == 0)) {\n            /* write empty container */\n            *cur++ = (u8)('[' | ((u8)ctn_obj_tmp << 5));\n            *cur++ = (u8)(']' | ((u8)ctn_obj_tmp << 5));\n            *cur++ = ',';\n            goto val_end;\n        } else {\n            /* push context, setup new container */\n            yyjson_write_ctx_set(--ctx, ctn_len, ctn_obj);\n            ctn_len = ctn_len_tmp << (u8)ctn_obj_tmp;\n            ctn_obj = ctn_obj_tmp;\n            *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n            val++;\n            goto val_begin;\n        }\n    }\n    if (val_type == YYJSON_TYPE_BOOL) {\n        incr_len(16);\n        cur = write_bool(cur, unsafe_yyjson_get_bool(val));\n        cur++;\n        goto val_end;\n    }\n    if (val_type == YYJSON_TYPE_NULL) {\n        incr_len(16);\n        cur = write_null(cur);\n        cur++;\n        goto val_end;\n    }\n    if (val_type == YYJSON_TYPE_RAW) {\n        str_len = unsafe_yyjson_get_len(val);\n        str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n        check_str_len(str_len);\n        incr_len(str_len + 2);\n        cur = write_raw(cur, str_ptr, str_len);\n        *cur++ = ',';\n        goto val_end;\n    }\n    goto fail_type;\n    \nval_end:\n    val++;\n    ctn_len--;\n    if (unlikely(ctn_len == 0)) goto ctn_end;\n    goto val_begin;\n    \nctn_end:\n    cur--;\n    *cur++ = (u8)(']' | ((u8)ctn_obj << 5));\n    *cur++ = ',';\n    if (unlikely((u8 *)ctx >= end)) goto doc_end;\n    yyjson_write_ctx_get(ctx++, &ctn_len, &ctn_obj);\n    ctn_len--;\n    if (likely(ctn_len > 0)) {\n        goto val_begin;\n    } else {\n        goto ctn_end;\n    }\n    \ndoc_end:\n    if (newline) {\n        incr_len(2);\n        *(cur - 1) = '\\n';\n        cur++;\n    }\n    *--cur = '\\0';\n    *dat_len = (usize)(cur - hdr);\n    memset(err, 0, sizeof(yyjson_write_err));\n    return hdr;\n    \nfail_alloc:\n    return_err(MEMORY_ALLOCATION, \"memory allocation failed\");\nfail_type:\n    return_err(INVALID_VALUE_TYPE, \"invalid JSON value type\");\nfail_num:\n    return_err(NAN_OR_INF, \"nan or inf number is not allowed\");\nfail_str:\n    return_err(INVALID_STRING, \"invalid utf-8 encoding in string\");\n    \n#undef return_err\n#undef incr_len\n#undef check_str_len\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "yyjson_write_pretty",
      "func_body": "static_inline u8 *yyjson_write_pretty(const yyjson_val *root,\n                                      const yyjson_write_flag flg,\n                                      const yyjson_alc alc,\n                                      usize *dat_len,\n                                      yyjson_write_err *err) {\n    \n#define return_err(_code, _msg) do { \\\n    *dat_len = 0; \\\n    err->code = YYJSON_WRITE_ERROR_##_code; \\\n    err->msg = _msg; \\\n    if (hdr) alc.free(alc.ctx, hdr); \\\n    return NULL; \\\n} while (false)\n    \n#define incr_len(_len) do { \\\n    ext_len = (usize)(_len); \\\n    if (unlikely((u8 *)(cur + ext_len) >= (u8 *)ctx)) { \\\n        alc_inc = yyjson_max(alc_len / 2, ext_len); \\\n        alc_inc = size_align_up(alc_inc, sizeof(yyjson_write_ctx)); \\\n        if ((sizeof(usize) < 8) && size_add_is_overflow(alc_len, alc_inc)) \\\n            goto fail_alloc; \\\n        alc_len += alc_inc; \\\n        tmp = (u8 *)alc.realloc(alc.ctx, hdr, alc_len - alc_inc, alc_len); \\\n        if (unlikely(!tmp)) goto fail_alloc; \\\n        ctx_len = (usize)(end - (u8 *)ctx); \\\n        ctx_tmp = (yyjson_write_ctx *)(void *)(tmp + (alc_len - ctx_len)); \\\n        memmove((void *)ctx_tmp, (void *)(tmp + ((u8 *)ctx - hdr)), ctx_len); \\\n        ctx = ctx_tmp; \\\n        cur = tmp + (cur - hdr); \\\n        end = tmp + alc_len; \\\n        hdr = tmp; \\\n    } \\\n} while (false)\n    \n#define check_str_len(_len) do { \\\n    if ((sizeof(usize) < 8) && (_len >= (USIZE_MAX - 16) / 6)) \\\n        goto fail_alloc; \\\n} while (false)\n    \n    yyjson_val *val;\n    yyjson_type val_type;\n    usize ctn_len, ctn_len_tmp;\n    bool ctn_obj, ctn_obj_tmp, is_key, no_indent;\n    u8 *hdr, *cur, *end, *tmp;\n    yyjson_write_ctx *ctx, *ctx_tmp;\n    usize alc_len, alc_inc, ctx_len, ext_len, str_len, level;\n    const u8 *str_ptr;\n    const char_enc_type *enc_table = get_enc_table_with_flag(flg);\n    bool cpy = (enc_table == enc_table_cpy);\n    bool esc = has_write_flag(ESCAPE_UNICODE) != 0;\n    bool inv = has_write_flag(ALLOW_INVALID_UNICODE) != 0;\n    usize spaces = has_write_flag(PRETTY_TWO_SPACES) ? 2 : 4;\n    bool newline = has_write_flag(NEWLINE_AT_END) != 0;\n    \n    alc_len = root->uni.ofs / sizeof(yyjson_val);\n    alc_len = alc_len * YYJSON_WRITER_ESTIMATED_PRETTY_RATIO + 64;\n    alc_len = size_align_up(alc_len, sizeof(yyjson_write_ctx));\n    hdr = (u8 *)alc.malloc(alc.ctx, alc_len);\n    if (!hdr) goto fail_alloc;\n    cur = hdr;\n    end = hdr + alc_len;\n    ctx = (yyjson_write_ctx *)(void *)end;\n    \ndoc_begin:\n    val = constcast(yyjson_val *)root;\n    val_type = unsafe_yyjson_get_type(val);\n    ctn_obj = (val_type == YYJSON_TYPE_OBJ);\n    ctn_len = unsafe_yyjson_get_len(val) << (u8)ctn_obj;\n    *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n    *cur++ = '\\n';\n    val++;\n    level = 1;\n    \nval_begin:\n    val_type = unsafe_yyjson_get_type(val);\n    if (val_type == YYJSON_TYPE_STR) {\n        is_key = (bool)((u8)ctn_obj & (u8)~ctn_len);\n        no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n        str_len = unsafe_yyjson_get_len(val);\n        str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n        check_str_len(str_len);\n        incr_len(str_len * 6 + 16 + (no_indent ? 0 : level * 4));\n        cur = write_indent(cur, no_indent ? 0 : level, spaces);\n        if (likely(cpy) && unsafe_yyjson_get_subtype(val)) {\n            cur = write_string_noesc(cur, str_ptr, str_len);\n        } else {\n            cur = write_string(cur, esc, inv, str_ptr, str_len, enc_table);\n            if (unlikely(!cur)) goto fail_str;\n        }\n        *cur++ = is_key ? ':' : ',';\n        *cur++ = is_key ? ' ' : '\\n';\n        goto val_end;\n    }\n    if (val_type == YYJSON_TYPE_NUM) {\n        no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n        incr_len(32 + (no_indent ? 0 : level * 4));\n        cur = write_indent(cur, no_indent ? 0 : level, spaces);\n        cur = write_number(cur, val, flg);\n        if (unlikely(!cur)) goto fail_num;\n        *cur++ = ',';\n        *cur++ = '\\n';\n        goto val_end;\n    }\n    if ((val_type & (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) ==\n                    (YYJSON_TYPE_ARR & YYJSON_TYPE_OBJ)) {\n        no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n        ctn_len_tmp = unsafe_yyjson_get_len(val);\n        ctn_obj_tmp = (val_type == YYJSON_TYPE_OBJ);\n        if (unlikely(ctn_len_tmp == 0)) {\n            /* write empty container */\n            incr_len(16 + (no_indent ? 0 : level * 4));\n            cur = write_indent(cur, no_indent ? 0 : level, spaces);\n            *cur++ = (u8)('[' | ((u8)ctn_obj_tmp << 5));\n            *cur++ = (u8)(']' | ((u8)ctn_obj_tmp << 5));\n            *cur++ = ',';\n            *cur++ = '\\n';\n            goto val_end;\n        } else {\n            /* push context, setup new container */\n            incr_len(32 + (no_indent ? 0 : level * 4));\n            yyjson_write_ctx_set(--ctx, ctn_len, ctn_obj);\n            ctn_len = ctn_len_tmp << (u8)ctn_obj_tmp;\n            ctn_obj = ctn_obj_tmp;\n            cur = write_indent(cur, no_indent ? 0 : level, spaces);\n            level++;\n            *cur++ = (u8)('[' | ((u8)ctn_obj << 5));\n            *cur++ = '\\n';\n            val++;\n            goto val_begin;\n        }\n    }\n    if (val_type == YYJSON_TYPE_BOOL) {\n        no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n        incr_len(16 + (no_indent ? 0 : level * 4));\n        cur = write_indent(cur, no_indent ? 0 : level, spaces);\n        cur = write_bool(cur, unsafe_yyjson_get_bool(val));\n        cur += 2;\n        goto val_end;\n    }\n    if (val_type == YYJSON_TYPE_NULL) {\n        no_indent = (bool)((u8)ctn_obj & (u8)ctn_len);\n        incr_len(16 + (no_indent ? 0 : level * 4));\n        cur = write_indent(cur, no_indent ? 0 : level, spaces);\n        cur = write_null(cur);\n        cur += 2;\n        goto val_end;\n    }\n    if (val_type == YYJSON_TYPE_RAW) {\n        str_len = unsafe_yyjson_get_len(val);\n        str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n        check_str_len(str_len);\n        incr_len(str_len + 3);\n        cur = write_raw(cur, str_ptr, str_len);\n        *cur++ = ',';\n        *cur++ = '\\n';\n        goto val_end;\n    }\n    goto fail_type;\n    \nval_end:\n    val++;\n    ctn_len--;\n    if (unlikely(ctn_len == 0)) goto ctn_end;\n    goto val_begin;\n    \nctn_end:\n    cur -= 2;\n    *cur++ = '\\n';\n    incr_len(level * 4);\n    cur = write_indent(cur, --level, spaces);\n    *cur++ = (u8)(']' | ((u8)ctn_obj << 5));\n    if (unlikely((u8 *)ctx >= end)) goto doc_end;\n    yyjson_write_ctx_get(ctx++, &ctn_len, &ctn_obj);\n    ctn_len--;\n    *cur++ = ',';\n    *cur++ = '\\n';\n    if (likely(ctn_len > 0)) {\n        goto val_begin;\n    } else {\n        goto ctn_end;\n    }\n    \ndoc_end:\n    if (newline) {\n        incr_len(2);\n        *cur++ = '\\n';\n    }\n    *cur = '\\0';\n    *dat_len = (usize)(cur - hdr);\n    memset(err, 0, sizeof(yyjson_write_err));\n    return hdr;\n    \nfail_alloc:\n    return_err(MEMORY_ALLOCATION, \"memory allocation failed\");\nfail_type:\n    return_err(INVALID_VALUE_TYPE, \"invalid JSON value type\");\nfail_num:\n    return_err(NAN_OR_INF, \"nan or inf number is not allowed\");\nfail_str:\n    return_err(INVALID_STRING, \"invalid utf-8 encoding in string\");\n    \n#undef return_err\n#undef incr_len\n#undef check_str_len\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "orjson",
      "filepath": "include/yyjson/yyjson.c",
      "func_name": "yyjson_write_single",
      "func_body": "static_inline u8 *yyjson_write_single(yyjson_val *val,\n                                      yyjson_write_flag flg,\n                                      yyjson_alc alc,\n                                      usize *dat_len,\n                                      yyjson_write_err *err) {\n    \n#define return_err(_code, _msg) do { \\\n    if (hdr) alc.free(alc.ctx, (void *)hdr); \\\n    *dat_len = 0; \\\n    err->code = YYJSON_WRITE_ERROR_##_code; \\\n    err->msg = _msg; \\\n    return NULL; \\\n} while (false)\n    \n#define incr_len(_len) do { \\\n    hdr = (u8 *)alc.malloc(alc.ctx, _len); \\\n    if (!hdr) goto fail_alloc; \\\n    cur = hdr; \\\n} while (false)\n    \n#define check_str_len(_len) do { \\\n    if ((sizeof(usize) < 8) && (_len >= (USIZE_MAX - 16) / 6)) \\\n        goto fail_alloc; \\\n} while (false)\n    \n    u8 *hdr = NULL, *cur;\n    usize str_len;\n    const u8 *str_ptr;\n    const char_enc_type *enc_table = get_enc_table_with_flag(flg);\n    bool cpy = (enc_table == enc_table_cpy);\n    bool esc = has_write_flag(ESCAPE_UNICODE) != 0;\n    bool inv = has_write_flag(ALLOW_INVALID_UNICODE) != 0;\n    bool newline = has_write_flag(NEWLINE_AT_END) != 0;\n    const usize end_len = 2; /* '\\n' and '\\0' */\n    \n    switch (unsafe_yyjson_get_type(val)) {\n        case YYJSON_TYPE_RAW:\n            str_len = unsafe_yyjson_get_len(val);\n            str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n            check_str_len(str_len);\n            incr_len(str_len + end_len);\n            cur = write_raw(cur, str_ptr, str_len);\n            break;\n            \n        case YYJSON_TYPE_STR:\n            str_len = unsafe_yyjson_get_len(val);\n            str_ptr = (const u8 *)unsafe_yyjson_get_str(val);\n            check_str_len(str_len);\n            incr_len(str_len * 6 + 2 + end_len);\n            if (likely(cpy) && unsafe_yyjson_get_subtype(val)) {\n                cur = write_string_noesc(cur, str_ptr, str_len);\n            } else {\n                cur = write_string(cur, esc, inv, str_ptr, str_len, enc_table);\n                if (unlikely(!cur)) goto fail_str;\n            }\n            break;\n            \n        case YYJSON_TYPE_NUM:\n            incr_len(32 + end_len);\n            cur = write_number(cur, val, flg);\n            if (unlikely(!cur)) goto fail_num;\n            break;\n            \n        case YYJSON_TYPE_BOOL:\n            incr_len(8);\n            cur = write_bool(cur, unsafe_yyjson_get_bool(val));\n            break;\n            \n        case YYJSON_TYPE_NULL:\n            incr_len(8);\n            cur = write_null(cur);\n            break;\n            \n        case YYJSON_TYPE_ARR:\n            incr_len(2 + end_len);\n            byte_copy_2(cur, \"[]\");\n            cur += 2;\n            break;\n            \n        case YYJSON_TYPE_OBJ:\n            incr_len(2 + end_len);\n            byte_copy_2(cur, \"{}\");\n            cur += 2;\n            break;\n            \n        default:\n            goto fail_type;\n    }\n    \n    if (newline) *cur++ = '\\n';\n    *cur = '\\0';\n    *dat_len = (usize)(cur - hdr);\n    memset(err, 0, sizeof(yyjson_write_err));\n    return hdr;\n    \nfail_alloc:\n    return_err(MEMORY_ALLOCATION, \"memory allocation failed\");\nfail_type:\n    return_err(INVALID_VALUE_TYPE, \"invalid JSON value type\");\nfail_num:\n    return_err(NAN_OR_INF, \"nan or inf number is not allowed\");\nfail_str:\n    return_err(INVALID_STRING, \"invalid utf-8 encoding in string\");\n    \n#undef return_err\n#undef check_str_len\n#undef incr_len\n}",
      "cve_list": [
        "CVE-2024-27454"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "esp-idf",
      "filepath": "components/bootloader_support/src/esp_image_format.c",
      "func_name": "image_load",
      "func_body": "static esp_err_t image_load(esp_image_load_mode_t mode, const esp_partition_pos_t *part, esp_image_metadata_t *data)\n{\n#ifdef BOOTLOADER_BUILD\n    bool do_load   = (mode == ESP_IMAGE_LOAD) || (mode == ESP_IMAGE_LOAD_NO_VALIDATE);\n    bool do_verify = (mode == ESP_IMAGE_LOAD) || (mode == ESP_IMAGE_VERIFY) || (mode == ESP_IMAGE_VERIFY_SILENT);\n#else\n    bool do_load   = false; // Can't load the image in app mode\n    bool do_verify = true;  // In app mode is available only verify mode\n#endif\n    bool silent    = (mode == ESP_IMAGE_VERIFY_SILENT);\n    esp_err_t err = ESP_OK;\n    // checksum the image a word at a time. This shaves 30-40ms per MB of image size\n    uint32_t checksum_word = ESP_ROM_CHECKSUM_INITIAL;\n    uint32_t *checksum = (do_verify) ? &checksum_word : NULL;\n    bootloader_sha256_handle_t sha_handle = NULL;\n    bool verify_sha;\n#if (SECURE_BOOT_CHECK_SIGNATURE == 1)\n     /* used for anti-FI checks */\n    uint8_t image_digest[HASH_LEN] = { [ 0 ... 31] = 0xEE };\n    uint8_t verified_digest[HASH_LEN] = { [ 0 ... 31 ] = 0x01 };\n#endif\n\n    if (data == NULL || part == NULL) {\n        return ESP_ERR_INVALID_ARG;\n    }\n\n#if CONFIG_SECURE_BOOT_V2_ENABLED\n    // For Secure Boot V2, we do verify signature on bootloader which includes the SHA calculation.\n    verify_sha = do_verify;\n#else // Secure boot not enabled\n    // For secure boot V1 on ESP32, we don't calculate SHA or verify signature on bootloaders.\n    // (For non-secure boot, we don't verify any SHA-256 hash appended to the bootloader because\n    // esptool.py may have rewritten the header - rely on esptool.py having verified the bootloader at flashing time, instead.)\n    verify_sha = (part->offset != ESP_BOOTLOADER_OFFSET) && do_verify;\n#endif\n\n    if (part->size > SIXTEEN_MB) {\n        err = ESP_ERR_INVALID_ARG;\n        FAIL_LOAD(\"partition size 0x%\"PRIx32\" invalid, larger than 16MB\", part->size);\n    }\n\n    bootloader_sha256_handle_t *p_sha_handle = &sha_handle;\n    CHECK_ERR(process_image_header(data, part->offset, (verify_sha) ? p_sha_handle : NULL, do_verify, silent));\n    CHECK_ERR(process_segments(data, silent, do_load, sha_handle, checksum));\n    bool skip_check_checksum = !do_verify || esp_cpu_dbgr_is_attached();\n    CHECK_ERR(process_checksum(sha_handle, checksum_word, data, silent, skip_check_checksum));\n    CHECK_ERR(process_appended_hash_and_sig(data, part->offset, part->size, do_verify, silent));\n    if (verify_sha) {\n#if (SECURE_BOOT_CHECK_SIGNATURE == 1)\n        // secure boot images have a signature appended\n#if defined(BOOTLOADER_BUILD) && !defined(CONFIG_SECURE_BOOT)\n        // If secure boot is not enabled in hardware, then\n        // skip the signature check in bootloader when the debugger is attached.\n        // This is done to allow for breakpoints in Flash.\n        bool do_verify_sig = !esp_cpu_dbgr_is_attached();\n#else // CONFIG_SECURE_BOOT\n        bool do_verify_sig = true;\n#endif // end checking for JTAG\n        if (do_verify_sig) {\n            err = verify_secure_boot_signature(sha_handle, data, image_digest, verified_digest);\n            sha_handle = NULL; // verify_secure_boot_signature finishes sha_handle\n        }\n#else // SECURE_BOOT_CHECK_SIGNATURE\n        // No secure boot, but SHA-256 can be appended for basic corruption detection\n        if (sha_handle != NULL && !esp_cpu_dbgr_is_attached()) {\n            err = verify_simple_hash(sha_handle, data);\n            sha_handle = NULL; // calling verify_simple_hash finishes sha_handle\n        }\n#endif // SECURE_BOOT_CHECK_SIGNATURE\n    } // verify_sha\n\n    // bootloader may still have a sha256 digest handle open\n    if (sha_handle != NULL) {\n        bootloader_sha256_finish(sha_handle, NULL);\n        sha_handle = NULL;\n    }\n\n    if (err != ESP_OK) {\n        goto err;\n    }\n\n#ifdef BOOTLOADER_BUILD\n\n#if (SECURE_BOOT_CHECK_SIGNATURE == 1)\n    /* If signature was checked in bootloader build, verified_digest should equal image_digest\n\n       This is to detect any fault injection that caused signature verification to not complete normally.\n\n       Any attack which bypasses this check should be of limited use as the RAM contents are still obfuscated, therefore we do the check\n       immediately before we deobfuscate.\n\n       Note: the conditions for making this check are the same as for setting verify_sha above, but on ESP32 SB V1 we move the test for\n       \"only verify signature in bootloader\" into the macro so it's tested multiple times.\n     */\n#if CONFIG_SECURE_BOOT_V2_ENABLED\n    ESP_FAULT_ASSERT(!esp_secure_boot_enabled() || memcmp(image_digest, verified_digest, HASH_LEN) == 0);\n#else // Secure Boot V1 on ESP32, only verify signatures for apps not bootloaders\n    ESP_FAULT_ASSERT(data->start_addr == ESP_BOOTLOADER_OFFSET || memcmp(image_digest, verified_digest, HASH_LEN) == 0);\n#endif\n\n#endif // SECURE_BOOT_CHECK_SIGNATURE\n\n    // Deobfuscate RAM\n    if (do_load && ram_obfs_value[0] != 0 && ram_obfs_value[1] != 0) {\n        for (int i = 0; i < data->image.segment_count; i++) {\n            uint32_t load_addr = data->segments[i].load_addr;\n            if (should_load(load_addr)) {\n                uint32_t *loaded = (uint32_t *)load_addr;\n                for (size_t j = 0; j < data->segments[i].data_len / sizeof(uint32_t); j++) {\n                    loaded[j] ^= (j & 1) ? ram_obfs_value[0] : ram_obfs_value[1];\n                }\n            }\n        }\n#if SOC_CACHE_INTERNAL_MEM_VIA_L1CACHE\n        cache_ll_writeback_all(CACHE_LL_LEVEL_INT_MEM, CACHE_TYPE_DATA, CACHE_LL_ID_ALL);\n#endif\n    }\n\n#if CONFIG_BOOTLOADER_APP_ANTI_ROLLBACK\n    /* For anti-rollback case, reconfirm security version of the application to prevent FI attacks */\n    bool sec_ver = false;\n    if (do_load) {\n        sec_ver = esp_efuse_check_secure_version(data->secure_version);\n        if (!sec_ver) {\n            err = ESP_FAIL;\n            goto err;\n        }\n    }\n    /* Ensure that the security version check passes for image loading scenario */\n    ESP_FAULT_ASSERT(!do_load || sec_ver == true);\n#endif // CONFIG_BOOTLOADER_APP_ANTI_ROLLBACK\n\n#endif // BOOTLOADER_BUILD\n\n    // Success!\n    return ESP_OK;\n\nerr:\n    if (err == ESP_OK) {\n        err = ESP_ERR_IMAGE_INVALID;\n    }\n    if (sha_handle != NULL) {\n        // Need to finish the hash process to free the handle\n        bootloader_sha256_finish(sha_handle, NULL);\n    }\n    // Prevent invalid/incomplete data leaking out\n    bzero(data, sizeof(esp_image_metadata_t));\n    return err;\n}",
      "cve_list": [
        "CVE-2024-28183"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "esp-idf",
      "filepath": "components/bootloader_support/src/esp_image_format.c",
      "func_name": "process_esp_app_desc_data",
      "func_body": "static size_t process_esp_app_desc_data(const uint32_t *src, bootloader_sha256_handle_t sha_handle, uint32_t *checksum, esp_image_metadata_t *metadata)\n{\n    /* Using data_buffer here helps to securely read secure_version\n     * (for anti-rollback) from esp_app_desc_t, preventing FI attack.\n     * We read data from Flash into this buffer, which is covered by sha256.\n     * Therefore, if the flash is under attackers control and contents are modified\n     * the sha256 comparison will fail.\n     *\n     * The esp_app_desc_t structure is located in DROM and is always in segment #0.\n     *\n     * esp_app_desc_t is always at #0 segment (index==0).\n     * secure_version field of esp_app_desc_t is located at #2 word (w_i==1).\n     */\n    uint32_t data_buffer[2];\n    memcpy(data_buffer, src, sizeof(data_buffer));\n    assert(data_buffer[0] == ESP_APP_DESC_MAGIC_WORD);\n    metadata->secure_version = data_buffer[1];\n    if (checksum != NULL) {\n        *checksum ^= data_buffer[0] ^ data_buffer[1];\n    }\n    if (sha_handle != NULL) {\n        bootloader_sha256_data(sha_handle, data_buffer, sizeof(data_buffer));\n    }\n    ESP_FAULT_ASSERT(memcmp(data_buffer, src, sizeof(data_buffer)) == 0);\n    ESP_FAULT_ASSERT(memcmp(&metadata->secure_version, &src[1], sizeof(uint32_t)) == 0);\n    return sizeof(data_buffer);\n}",
      "cve_list": [
        "CVE-2024-28183"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "esp-idf",
      "filepath": "components/bootloader_support/src/esp_image_format.c",
      "func_name": "process_segment",
      "func_body": "static esp_err_t process_segment(int index, uint32_t flash_addr, esp_image_segment_header_t *header, bool silent, bool do_load, bootloader_sha256_handle_t sha_handle, uint32_t *checksum, esp_image_metadata_t *metadata)\n{\n    esp_err_t err;\n\n    /* read segment header */\n    err = bootloader_flash_read(flash_addr, header, sizeof(esp_image_segment_header_t), true);\n    if (err != ESP_OK) {\n        ESP_LOGE(TAG, \"bootloader_flash_read failed at 0x%08\"PRIx32, flash_addr);\n        return err;\n    }\n    if (sha_handle != NULL) {\n        bootloader_sha256_data(sha_handle, header, sizeof(esp_image_segment_header_t));\n    }\n\n    intptr_t load_addr = header->load_addr;\n    uint32_t data_len = header->data_len;\n    uint32_t data_addr = flash_addr + sizeof(esp_image_segment_header_t);\n\n    ESP_LOGV(TAG, \"segment data length 0x%\"PRIx32\" data starts 0x%\"PRIx32, data_len, data_addr);\n\n    CHECK_ERR(verify_segment_header(index, header, data_addr, silent));\n\n    if (data_len % 4 != 0) {\n        FAIL_LOAD(\"unaligned segment length 0x%\"PRIx32, data_len);\n    }\n\n    bool is_mapping = should_map(load_addr);\n    do_load = do_load && should_load(load_addr);\n\n    if (!silent) {\n        ESP_LOGI(TAG, \"segment %d: paddr=%08\"PRIx32\" vaddr=%08x size=%05\"PRIx32\"h (%6\"PRIu32\") %s\",\n                 index, data_addr, load_addr,\n                 data_len, data_len,\n                 (do_load) ? \"load\" : (is_mapping) ? \"map\" : \"\");\n    }\n\n\n#ifdef BOOTLOADER_BUILD\n    /* Before loading segment, check it doesn't clobber bootloader RAM. */\n    if (do_load && data_len > 0) {\n        if (!verify_load_addresses(index, load_addr, load_addr + data_len, true, false)) {\n            return ESP_ERR_IMAGE_INVALID;\n        }\n    }\n#endif // BOOTLOADER_BUILD\n\n    uint32_t free_page_count = bootloader_mmap_get_free_pages();\n    ESP_LOGD(TAG, \"free data page_count 0x%08\"PRIx32, free_page_count);\n\n    uint32_t data_len_remain = data_len;\n    while (data_len_remain > 0) {\n#if (SECURE_BOOT_CHECK_SIGNATURE == 1) && defined(BOOTLOADER_BUILD)\n        /* Double check the address verification done above */\n        ESP_FAULT_ASSERT(!do_load || verify_load_addresses(0, load_addr, load_addr + data_len_remain, false, false));\n#endif\n        uint32_t offset_page = ((data_addr & MMAP_ALIGNED_MASK) != 0) ? 1 : 0;\n        /* Data we could map in case we are not aligned to PAGE boundary is one page size lesser. */\n        data_len = MIN(data_len_remain, ((free_page_count - offset_page) * SPI_FLASH_MMU_PAGE_SIZE));\n        CHECK_ERR(process_segment_data(index, load_addr, data_addr, data_len, do_load, sha_handle, checksum, metadata));\n        data_addr += data_len;\n        data_len_remain -= data_len;\n    }\n\n    return ESP_OK;\n\nerr:\n    if (err == ESP_OK) {\n        err = ESP_ERR_IMAGE_INVALID;\n    }\n\n    return err;\n}",
      "cve_list": [
        "CVE-2024-28183"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "esp-idf",
      "filepath": "components/bootloader_support/src/esp_image_format.c",
      "func_name": "process_segment_data",
      "func_body": "static esp_err_t process_segment_data(int segment, intptr_t load_addr, uint32_t data_addr, uint32_t data_len, bool do_load, bootloader_sha256_handle_t sha_handle, uint32_t *checksum, esp_image_metadata_t *metadata)\n{\n    // If we are not loading, and the checksum is empty, skip processing this\n    // segment for data\n    if (!do_load && checksum == NULL) {\n        ESP_LOGD(TAG, \"skipping checksum for segment\");\n        return ESP_OK;\n    }\n\n    const uint32_t *data = (const uint32_t *)bootloader_mmap(data_addr, data_len);\n    if (!data) {\n        ESP_LOGE(TAG, \"bootloader_mmap(0x%\"PRIx32\", 0x%\"PRIx32\") failed\",\n                 data_addr, data_len);\n        return ESP_FAIL;\n    }\n\n    if (checksum == NULL && sha_handle == NULL) {\n        memcpy((void *)load_addr, data, data_len);\n        bootloader_munmap(data);\n        return ESP_OK;\n    }\n\n#ifdef BOOTLOADER_BUILD\n    // Set up the obfuscation value to use for loading\n    while (ram_obfs_value[0] == 0 || ram_obfs_value[1] == 0) {\n        bootloader_fill_random(ram_obfs_value, sizeof(ram_obfs_value));\n#if CONFIG_IDF_ENV_FPGA\n        /* FPGA doesn't always emulate the RNG */\n        ram_obfs_value[0] ^= 0x33;\n        ram_obfs_value[1] ^= 0x66;\n#endif\n    }\n    uint32_t *dest = (uint32_t *)load_addr;\n#endif\n\n    const uint32_t *src = data;\n\n#if CONFIG_BOOTLOADER_APP_ANTI_ROLLBACK\n    if (segment == 0) {\n        // The esp_app_desc_t structure is located in DROM and is always in segment #0.\n        size_t len = process_esp_app_desc_data(src, sha_handle, checksum, metadata);\n        data_len -= len;\n        src += len / 4;\n        // In BOOTLOADER_BUILD, for DROM (segment #0) we do not load it into dest (only map it), do_load = false.\n    }\n#endif // CONFIG_BOOTLOADER_APP_ANTI_ROLLBACK\n\n    for (size_t i = 0; i < data_len; i += 4) {\n        int w_i = i / 4; // Word index\n        uint32_t w = src[w_i];\n        if (checksum != NULL) {\n            *checksum ^= w;\n        }\n#ifdef BOOTLOADER_BUILD\n        if (do_load) {\n            dest[w_i] = w ^ ((w_i & 1) ? ram_obfs_value[0] : ram_obfs_value[1]);\n        }\n#endif\n        // SHA_CHUNK determined experimentally as the optimum size\n        // to call bootloader_sha256_data() with. This is a bit\n        // counter-intuitive, but it's ~3ms better than using the\n        // SHA256 block size.\n        const size_t SHA_CHUNK = 1024;\n        if (sha_handle != NULL && i % SHA_CHUNK == 0) {\n            bootloader_sha256_data(sha_handle, &src[w_i],\n                                   MIN(SHA_CHUNK, data_len - i));\n        }\n    }\n#if SOC_CACHE_INTERNAL_MEM_VIA_L1CACHE\n    if (do_load && esp_ptr_in_diram_iram((uint32_t *)load_addr)) {\n        cache_ll_writeback_all(CACHE_LL_LEVEL_INT_MEM, CACHE_TYPE_DATA, CACHE_LL_ID_ALL);\n    }\n#endif\n\n    bootloader_munmap(data);\n\n    return ESP_OK;\n}",
      "cve_list": [
        "CVE-2024-28183"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "esp-idf",
      "filepath": "components/bootloader_support/src/esp_image_format.c",
      "func_name": "process_segments",
      "func_body": "static esp_err_t process_segments(esp_image_metadata_t *data, bool silent, bool do_load, bootloader_sha256_handle_t sha_handle, uint32_t *checksum)\n{\n    esp_err_t err = ESP_OK;\n    uint32_t start_segments = data->start_addr + data->image_len;\n    uint32_t next_addr = start_segments;\n    for (int i = 0; i < data->image.segment_count; i++) {\n        esp_image_segment_header_t *header = &data->segments[i];\n        ESP_LOGV(TAG, \"loading segment header %d at offset 0x%\"PRIx32, i, next_addr);\n        CHECK_ERR(process_segment(i, next_addr, header, silent, do_load, sha_handle, checksum, data));\n        next_addr += sizeof(esp_image_segment_header_t);\n        data->segment_data[i] = next_addr;\n        next_addr += header->data_len;\n    }\n    // Segments all loaded, verify length\n    uint32_t end_addr = next_addr;\n    if (end_addr < data->start_addr) {\n        FAIL_LOAD(\"image offset has wrapped\");\n    }\n\n    data->image_len += end_addr - start_segments;\n    ESP_LOGV(TAG, \"image start 0x%08\"PRIx32\" end of last section 0x%08\"PRIx32, data->start_addr, end_addr);\n    return err;\nerr:\n    if (err == ESP_OK) {\n        err = ESP_ERR_IMAGE_INVALID;\n    }\n    return err;\n}",
      "cve_list": [
        "CVE-2024-28183"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "esp-idf",
      "filepath": "components/esp_system/startup_funcs.c",
      "func_name": "ESP_SYSTEM_INIT_FN",
      "func_body": "ESP_SYSTEM_INIT_FN(init_secure, CORE, BIT(0), 150)\n{\n#if CONFIG_BOOTLOADER_APP_ANTI_ROLLBACK\n    // For anti-rollback case, recheck security version before we boot-up the current application\n    const esp_app_desc_t *desc = esp_app_get_description();\n    ESP_RETURN_ON_FALSE(esp_efuse_check_secure_version(desc->secure_version), ESP_FAIL, TAG, \"Incorrect secure version of app\");\n#endif\n\n#ifdef CONFIG_SECURE_FLASH_ENC_ENABLED\n    esp_flash_encryption_init_checks();\n#endif\n\n#if defined(CONFIG_SECURE_BOOT) || defined(CONFIG_SECURE_SIGNED_ON_UPDATE_NO_SECURE_BOOT)\n    // Note: in some configs this may read flash, so placed after flash init\n    esp_secure_boot_init_checks();\n#endif\n\n#if SOC_EFUSE_ECDSA_USE_HARDWARE_K\n    if (esp_efuse_find_purpose(ESP_EFUSE_KEY_PURPOSE_ECDSA_KEY, NULL)) {\n        // ECDSA key purpose block is present and hence permanently enable\n        // the hardware TRNG supplied k mode (most secure mode)\n        ESP_RETURN_ON_ERROR(esp_efuse_write_field_bit(ESP_EFUSE_ECDSA_FORCE_USE_HARDWARE_K), TAG, \"Failed to enable hardware k mode\");\n    }\n#endif\n\n#if CONFIG_SECURE_DISABLE_ROM_DL_MODE\n    ESP_RETURN_ON_ERROR(esp_efuse_disable_rom_download_mode(), TAG, \"Failed to disable ROM download mode\");\n#endif\n\n#if CONFIG_SECURE_ENABLE_SECURE_ROM_DL_MODE\n    ESP_RETURN_ON_ERROR(esp_efuse_enable_rom_secure_download_mode(), TAG, \"Failed to enable Secure Download mode\");\n#endif\n\n#if CONFIG_ESP32_DISABLE_BASIC_ROM_CONSOLE\n    esp_efuse_disable_basic_rom_console();\n#endif\n    return ESP_OK;\n}",
      "cve_list": [
        "CVE-2024-28183"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "esp-idf",
      "filepath": "components/bootloader_support/src/esp_image_format.c",
      "func_name": "process_segment_data",
      "func_body": "static esp_err_t process_segment_data(int segment, intptr_t load_addr, uint32_t data_addr, uint32_t data_len, bool do_load, bootloader_sha256_handle_t sha_handle, uint32_t *checksum, esp_image_metadata_t *metadata)\n{\n    // If we are not loading, and the checksum is empty, skip processing this\n    // segment for data\n    if (!do_load && checksum == NULL) {\n        ESP_LOGD(TAG, \"skipping checksum for segment\");\n        return ESP_OK;\n    }\n\n    const uint32_t *data = (const uint32_t *)bootloader_mmap(data_addr, data_len);\n    if (!data) {\n        ESP_LOGE(TAG, \"bootloader_mmap(0x%\"PRIx32\", 0x%\"PRIx32\") failed\",\n                 data_addr, data_len);\n        return ESP_FAIL;\n    }\n\n    if (checksum == NULL && sha_handle == NULL) {\n        memcpy((void *)load_addr, data, data_len);\n        bootloader_munmap(data);\n        return ESP_OK;\n    }\n\n#ifdef BOOTLOADER_BUILD\n    // Set up the obfuscation value to use for loading\n    while (ram_obfs_value[0] == 0 || ram_obfs_value[1] == 0) {\n        bootloader_fill_random(ram_obfs_value, sizeof(ram_obfs_value));\n#if CONFIG_IDF_ENV_FPGA\n        /* FPGA doesn't always emulate the RNG */\n        ram_obfs_value[0] ^= 0x33;\n        ram_obfs_value[1] ^= 0x66;\n#endif\n    }\n    uint32_t *dest = (uint32_t *)load_addr;\n#endif // BOOTLOADER_BUILD\n\n    const uint32_t *src = data;\n\n#if CONFIG_BOOTLOADER_APP_ANTI_ROLLBACK\n    // Case I: Bootloader verifying application\n    // Case II: Bootloader verifying bootloader\n    // Anti-rollback check should handle only Case I from above.\n    if (segment == 0 && metadata->start_addr != ESP_BOOTLOADER_OFFSET) {\n        ESP_LOGD(TAG, \"additional anti-rollback check 0x%\"PRIx32, data_addr);\n        // The esp_app_desc_t structure is located in DROM and is always in segment #0.\n        size_t len = process_esp_app_desc_data(src, sha_handle, checksum, metadata);\n        data_len -= len;\n        src += len / 4;\n        // In BOOTLOADER_BUILD, for DROM (segment #0) we do not load it into dest (only map it), do_load = false.\n    }\n#endif // CONFIG_BOOTLOADER_APP_ANTI_ROLLBACK\n\n    for (size_t i = 0; i < data_len; i += 4) {\n        int w_i = i / 4; // Word index\n        uint32_t w = src[w_i];\n        if (checksum != NULL) {\n            *checksum ^= w;\n        }\n#ifdef BOOTLOADER_BUILD\n        if (do_load) {\n            dest[w_i] = w ^ ((w_i & 1) ? ram_obfs_value[0] : ram_obfs_value[1]);\n        }\n#endif\n        // SHA_CHUNK determined experimentally as the optimum size\n        // to call bootloader_sha256_data() with. This is a bit\n        // counter-intuitive, but it's ~3ms better than using the\n        // SHA256 block size.\n        const size_t SHA_CHUNK = 1024;\n        if (sha_handle != NULL && i % SHA_CHUNK == 0) {\n            bootloader_sha256_data(sha_handle, &src[w_i],\n                                   MIN(SHA_CHUNK, data_len - i));\n        }\n    }\n#if SOC_CACHE_INTERNAL_MEM_VIA_L1CACHE\n    if (do_load && esp_ptr_in_diram_iram((uint32_t *)load_addr)) {\n        cache_ll_writeback_all(CACHE_LL_LEVEL_INT_MEM, CACHE_TYPE_DATA, CACHE_LL_ID_ALL);\n    }\n#endif\n\n    bootloader_munmap(data);\n\n    return ESP_OK;\n}",
      "cve_list": [
        "CVE-2024-28183"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wix3",
      "filepath": "src/DTF/Tools/SfxCA/SfxUtil.cpp",
      "func_name": "DeleteDirectory",
      "func_body": "bool DeleteDirectory(const wchar_t* szDir)\n{\n        size_t cchDir = wcslen(szDir);\n        size_t cchPathBuf = cchDir + 3 + MAX_PATH;\n        wchar_t* szPath = (wchar_t*) _alloca(cchPathBuf * sizeof(wchar_t));\n        if (szPath == NULL) return false;\n        StringCchCopy(szPath, cchPathBuf, szDir);\n        StringCchCat(szPath, cchPathBuf, L\"\\\\*\");\n        WIN32_FIND_DATA fd;\n        HANDLE hSearch = FindFirstFile(szPath, &fd);\n        while (hSearch != INVALID_HANDLE_VALUE)\n        {\n                StringCchCopy(szPath + cchDir + 1, cchPathBuf - (cchDir + 1), fd.cFileName);\n                if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)\n                {\n                        if (wcscmp(fd.cFileName, L\".\") != 0\n                            && wcscmp(fd.cFileName, L\"..\") != 0\n                            && ((fd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) == 0))\n                        {\n                                DeleteDirectory(szPath);\n                        }\n                }\n                else\n                {\n                        DeleteFile(szPath);\n                }\n                if (!FindNextFile(hSearch, &fd))\n                {\n                        FindClose(hSearch);\n                        hSearch = INVALID_HANDLE_VALUE;\n                }\n        }\n        return RemoveDirectory(szDir) != 0;\n}",
      "cve_list": [
        "CVE-2024-29188"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wix3",
      "filepath": "src/ext/ca/wixca/dll/RemoveFoldersEx.cpp",
      "func_name": "RecursePath",
      "func_body": "static HRESULT RecursePath(\n    __in_z LPCWSTR wzPath,\n    __in_z LPCWSTR wzId,\n    __in_z LPCWSTR wzComponent,\n    __in_z LPCWSTR wzProperty,\n    __in int iMode,\n    __inout DWORD* pdwCounter,\n    __inout MSIHANDLE* phTable,\n    __inout MSIHANDLE* phColumns\n    )\n{\n    HRESULT hr = S_OK;\n    DWORD er;\n    LPWSTR sczSearch = NULL;\n    LPWSTR sczProperty = NULL;\n    HANDLE hFind = INVALID_HANDLE_VALUE;\n    WIN32_FIND_DATAW wfd;\n    LPWSTR sczNext = NULL;\n\n    // Do NOT follow junctions.\n    DWORD dwAttributes = ::GetFileAttributesW(wzPath);\n    if (dwAttributes & FILE_ATTRIBUTE_REPARSE_POINT)\n    {\n        WcaLog(LOGMSG_STANDARD, \"Path is a junction; skipping: %ls\", wzPath);\n        ExitFunction();\n    }\n\n    // First recurse down to all the child directories.\n    hr = StrAllocFormatted(&sczSearch, L\"%s*\", wzPath);\n    ExitOnFailure1(hr, \"Failed to allocate file search string in path: %S\", wzPath);\n\n    hFind = ::FindFirstFileW(sczSearch, &wfd);\n    if (INVALID_HANDLE_VALUE == hFind)\n    {\n        er = ::GetLastError();\n        if (ERROR_PATH_NOT_FOUND == er)\n        {\n            WcaLog(LOGMSG_STANDARD, \"Search path not found: %ls\", sczSearch);\n            ExitFunction1(hr = S_FALSE);\n        }\n        else\n        {\n            hr = HRESULT_FROM_WIN32(er);\n        }\n        ExitOnFailure1(hr, \"Failed to find all files in path: %S\", wzPath);\n    }\n\n    do\n    {\n        // Skip files and the dot directories.\n        if (FILE_ATTRIBUTE_DIRECTORY != (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) || L'.' == wfd.cFileName[0] && (L'\\0' == wfd.cFileName[1] || (L'.' == wfd.cFileName[1] && L'\\0' == wfd.cFileName[2])))\n        {\n            continue;\n        }\n\n        hr = StrAllocFormatted(&sczNext, L\"%s%s\\\\\", wzPath, wfd.cFileName);\n        ExitOnFailure2(hr, \"Failed to concat filename '%S' to string: %S\", wfd.cFileName, wzPath);\n\n        hr = RecursePath(sczNext, wzId, wzComponent, wzProperty, iMode, pdwCounter, phTable, phColumns);\n        ExitOnFailure1(hr, \"Failed to recurse path: %S\", sczNext);\n    } while (::FindNextFileW(hFind, &wfd));\n\n    er = ::GetLastError();\n    if (ERROR_NO_MORE_FILES == er)\n    {\n        hr = S_OK;\n    }\n    else\n    {\n        hr = HRESULT_FROM_WIN32(er);\n        ExitOnFailure1(hr, \"Failed while looping through files in directory: %S\", wzPath);\n    }\n\n    // Finally, set a property that points at our path.\n    hr = StrAllocFormatted(&sczProperty, L\"_%s_%u\", wzProperty, *pdwCounter);\n    ExitOnFailure1(hr, \"Failed to allocate Property for RemoveFile table with property: %S.\", wzProperty);\n\n    ++(*pdwCounter);\n\n    hr = WcaSetProperty(sczProperty, wzPath);\n    ExitOnFailure2(hr, \"Failed to set Property: %S with path: %S\", sczProperty, wzPath);\n\n    // Add the row to remove any files and another row to remove the folder.\n    hr = WcaAddTempRecord(phTable, phColumns, L\"RemoveFile\", NULL, 1, 5, L\"RfxFiles\", wzComponent, L\"*.*\", sczProperty, iMode);\n    ExitOnFailure2(hr, \"Failed to add row to remove all files for WixRemoveFolderEx row: %S under path:\", wzId, wzPath);\n\n    hr = WcaAddTempRecord(phTable, phColumns, L\"RemoveFile\", NULL, 1, 5, L\"RfxFolder\", wzComponent, NULL, sczProperty, iMode);\n    ExitOnFailure2(hr, \"Failed to add row to remove folder for WixRemoveFolderEx row: %S under path: %S\", wzId, wzPath);\n\nLExit:\n    if (INVALID_HANDLE_VALUE != hFind)\n    {\n        ::FindClose(hFind);\n    }\n\n    ReleaseStr(sczNext);\n    ReleaseStr(sczProperty);\n    ReleaseStr(sczSearch);\n    return hr;\n}",
      "cve_list": [
        "CVE-2024-29188"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wix3",
      "filepath": "src/ext/ca/wixca/dll/RemoveFoldersEx.cpp",
      "func_name": "WixRemoveFoldersEx",
      "func_body": "extern \"C\" UINT WINAPI WixRemoveFoldersEx(\n    __in MSIHANDLE hInstall\n    )\n{\n    //AssertSz(FALSE, \"debug WixRemoveFoldersEx\");\n\n    HRESULT hr = S_OK;\n    PMSIHANDLE hView;\n    PMSIHANDLE hRec;\n    LPWSTR sczId = NULL;\n    LPWSTR sczComponent = NULL;\n    LPWSTR sczProperty = NULL;\n    LPWSTR sczPath = NULL;\n    LPWSTR sczExpandedPath = NULL;\n    int iMode = 0;\n    DWORD dwCounter = 0;\n    DWORD_PTR cchLen = 0;\n    MSIHANDLE hTable = NULL;\n    MSIHANDLE hColumns = NULL;\n\n    hr = WcaInitialize(hInstall, \"WixRemoveFoldersEx\");\n    ExitOnFailure(hr, \"Failed to initialize WixRemoveFoldersEx.\");\n\n    // anything to do?\n    if (S_OK != WcaTableExists(L\"WixRemoveFolderEx\"))\n    {\n        WcaLog(LOGMSG_STANDARD, \"WixRemoveFolderEx table doesn't exist, so there are no folders to remove.\");\n        ExitFunction();\n    }\n\n    // query and loop through all the remove folders exceptions\n    hr = WcaOpenExecuteView(vcsRemoveFolderExQuery, &hView);\n    ExitOnFailure(hr, \"Failed to open view on WixRemoveFolderEx table\");\n\n    while (S_OK == (hr = WcaFetchRecord(hView, &hRec)))\n    {\n        hr = WcaGetRecordString(hRec, rfqId, &sczId);\n        ExitOnFailure(hr, \"Failed to get remove folder identity.\");\n\n        hr = WcaGetRecordString(hRec, rfqComponent, &sczComponent);\n        ExitOnFailure(hr, \"Failed to get remove folder component.\");\n\n        hr = WcaGetRecordString(hRec, rfqProperty, &sczProperty);\n        ExitOnFailure(hr, \"Failed to get remove folder property.\");\n\n        hr = WcaGetRecordInteger(hRec, feqMode, &iMode);\n        ExitOnFailure(hr, \"Failed to get remove folder mode\");\n\n        hr = WcaGetProperty(sczProperty, &sczPath);\n        ExitOnFailure2(hr, \"Failed to resolve remove folder property: %S for row: %S\", sczProperty, sczId);\n\n        // fail early if the property isn't set as you probably don't want your installers trying to delete SystemFolder\n        // StringCchLengthW succeeds only if the string is zero characters plus 1 for the terminating null\n        hr = ::StringCchLengthW(sczPath, 1, reinterpret_cast<UINT_PTR*>(&cchLen));\n        if (SUCCEEDED(hr))\n        {\n            ExitOnFailure2(hr = E_INVALIDARG, \"Missing folder property: %S for row: %S\", sczProperty, sczId);\n        }\n\n        hr = PathExpand(&sczExpandedPath, sczPath, PATH_EXPAND_ENVIRONMENT);\n        ExitOnFailure2(hr, \"Failed to expand path: %S for row: %S\", sczPath, sczId);\n\n        hr = PathBackslashTerminate(&sczExpandedPath);\n        ExitOnFailure1(hr, \"Failed to backslash-terminate path: %S\", sczExpandedPath);\n\n        WcaLog(LOGMSG_STANDARD, \"Recursing path: %S for row: %S.\", sczExpandedPath, sczId);\n        hr = RecursePath(sczExpandedPath, sczId, sczComponent, sczProperty, iMode, &dwCounter, &hTable, &hColumns);\n        ExitOnFailure2(hr, \"Failed while navigating path: %S for row: %S\", sczPath, sczId);\n    }\n\n    // reaching the end of the list is actually a good thing, not an error\n    if (E_NOMOREITEMS == hr)\n    {\n        hr = S_OK;\n    }\n    ExitOnFailure(hr, \"Failure occured while processing WixRemoveFolderEx table\");\n\nLExit:\n    if (hColumns)\n    {\n        ::MsiCloseHandle(hColumns);\n    }\n\n    if (hTable)\n    {\n        ::MsiCloseHandle(hTable);\n    }\n\n    ReleaseStr(sczExpandedPath);\n    ReleaseStr(sczPath);\n    ReleaseStr(sczProperty);\n    ReleaseStr(sczComponent);\n    ReleaseStr(sczId);\n\n    DWORD er = SUCCEEDED(hr) ? ERROR_SUCCESS : ERROR_INSTALL_FAILURE;\n    return WcaFinalize(er);\n}",
      "cve_list": [
        "CVE-2024-29188"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wix3",
      "filepath": "src/DTF/Tools/SfxCA/SfxUtil.cpp",
      "func_name": "ExtractToTempDirectory",
      "func_body": "bool ExtractToTempDirectory(__in MSIHANDLE hSession, __in HMODULE hModule,\n        __out_ecount_z(cchTempDirBuf) wchar_t* szTempDir, DWORD cchTempDirBuf)\n{\n        wchar_t szModule[MAX_PATH];\n        DWORD cchCopied = GetModuleFileName(hModule, szModule, MAX_PATH - 1);\n        if (cchCopied == 0)\n        {\n                Log(hSession, L\"Failed to get module path. Error code %d.\", GetLastError());\n                return false;\n        }\n        else if (cchCopied == MAX_PATH - 1)\n        {\n                Log(hSession, L\"Failed to get module path -- path is too long.\");\n                return false;\n        }\n\n        if (szTempDir == NULL || cchTempDirBuf < wcslen(szModule) + 1)\n        {\n                Log(hSession, L\"Temp directory buffer is NULL or too small.\");\n                return false;\n        }\n        StringCchCopy(szTempDir, cchTempDirBuf, szModule);\n        StringCchCat(szTempDir, cchTempDirBuf, L\"-\");\n\n        BOOL fCreatedDirectory = FALSE;\n        DWORD cchTempDir = (DWORD) wcslen(szTempDir);\n        for (int i = 0; i < 10000 && !fCreatedDirectory; i++)\n        {\n                swprintf_s(szTempDir + cchTempDir, cchTempDirBuf - cchTempDir, L\"%d\", i);\n                fCreatedDirectory = ::CreateDirectory(szTempDir, NULL);\n        }\n\n        if (!fCreatedDirectory)\n        {\n                Log(hSession, L\"Failed to create temp directory. Error code %d\", ::GetLastError());\n                return false;\n        }\n\n        Log(hSession, L\"Extracting custom action to temporary directory: %s\\\\\", szTempDir);\n        int err = ExtractCabinet(szModule, szTempDir);\n        if (err != 0)\n        {\n                Log(hSession, L\"Failed to extract to temporary directory. Cabinet error code %d.\", err);\n                DeleteDirectory(szTempDir);\n                return false;\n        }\n        return true;\n}",
      "cve_list": [
        "CVE-2024-29187"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wix3",
      "filepath": "src/burn/engine/cache.cpp",
      "func_name": "CacheCalculateBundleLayoutWorkingPath",
      "func_body": "extern \"C\" HRESULT CacheCalculateBundleLayoutWorkingPath(\n    __in_z LPCWSTR wzBundleId,\n    __deref_out_z LPWSTR* psczWorkingPath\n    )\n{\n    HRESULT hr = S_OK;\n    LPWSTR sczWorkingFolder = NULL;\n\n    hr = CalculateWorkingFolder(wzBundleId, psczWorkingPath, NULL);\n    ExitOnFailure(hr, \"Failed to get working folder for bundle layout.\");\n\n    hr = StrAllocConcat(psczWorkingPath, wzBundleId, 0);\n    ExitOnFailure(hr, \"Failed to append bundle id for bundle layout working path.\");\n\nLExit:\n    ReleaseStr(sczWorkingFolder);\n\n    return hr;\n}",
      "cve_list": [
        "CVE-2024-29187"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wix3",
      "filepath": "src/burn/engine/cache.cpp",
      "func_name": "CacheCalculateBundleWorkingPath",
      "func_body": "extern \"C\" HRESULT CacheCalculateBundleWorkingPath(\n    __in_z LPCWSTR wzBundleId,\n    __in LPCWSTR wzExecutableName,\n    __deref_out_z LPWSTR* psczWorkingPath\n    )\n{\n    Assert(vfInitializedCache);\n\n    HRESULT hr = S_OK;\n    LPWSTR sczWorkingFolder = NULL;\n\n    // If the bundle is running out of the package cache then we use that as the\n    // working folder since we feel safe in the package cache.\n    if (vfRunningFromCache)\n    {\n        hr = PathForCurrentProcess(psczWorkingPath, NULL);\n        ExitOnFailure(hr, \"Failed to get current process path.\");\n    }\n    else // Otherwise, use the real working folder.\n    {\n        hr = CalculateWorkingFolder(wzBundleId, &sczWorkingFolder, NULL);\n        ExitOnFailure(hr, \"Failed to get working folder for bundle.\");\n\n        hr = StrAllocFormatted(psczWorkingPath, L\"%ls%ls\\\\%ls\", sczWorkingFolder, BUNDLE_WORKING_FOLDER_NAME, wzExecutableName);\n        ExitOnFailure(hr, \"Failed to calculate the bundle working path.\");\n    }\n\nLExit:\n    ReleaseStr(sczWorkingFolder);\n\n    return hr;\n}",
      "cve_list": [
        "CVE-2024-29187"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wix3",
      "filepath": "src/burn/engine/cache.cpp",
      "func_name": "CacheCalculateContainerWorkingPath",
      "func_body": "extern \"C\" HRESULT CacheCalculateContainerWorkingPath(\n    __in_z LPCWSTR wzBundleId,\n    __in BURN_CONTAINER* pContainer,\n    __deref_out_z LPWSTR* psczWorkingPath\n    )\n{\n    HRESULT hr = S_OK;\n\n    hr = CalculateWorkingFolder(wzBundleId, psczWorkingPath, NULL);\n    ExitOnFailure(hr, \"Failed to get working folder for container.\");\n\n    hr = StrAllocConcat(psczWorkingPath, pContainer->sczHash, 0);\n    ExitOnFailure(hr, \"Failed to append SHA1 hash as container unverified path.\");\n\nLExit:\n    return hr;\n}",
      "cve_list": [
        "CVE-2024-29187"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wix3",
      "filepath": "src/burn/engine/cache.cpp",
      "func_name": "CacheCalculatePayloadWorkingPath",
      "func_body": "extern \"C\" HRESULT CacheCalculatePayloadWorkingPath(\n    __in_z LPCWSTR wzBundleId,\n    __in BURN_PAYLOAD* pPayload,\n    __deref_out_z LPWSTR* psczWorkingPath\n    )\n{\n    HRESULT hr = S_OK;\n\n    hr = CalculateWorkingFolder(wzBundleId, psczWorkingPath, NULL);\n    ExitOnFailure(hr, \"Failed to get working folder for payload.\");\n\n    hr = StrAllocConcat(psczWorkingPath, pPayload->sczKey, 0);\n    ExitOnFailure(hr, \"Failed to append SHA1 hash as payload unverified path.\");\n\nLExit:\n    return hr;\n}",
      "cve_list": [
        "CVE-2024-29187"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wix3",
      "filepath": "src/burn/engine/cache.cpp",
      "func_name": "CacheCleanup",
      "func_body": "extern \"C\" void CacheCleanup(\n    __in BOOL fPerMachine,\n    __in_z LPCWSTR wzBundleId\n    )\n{\n    HRESULT hr = S_OK;\n    LPWSTR sczFolder = NULL;\n    LPWSTR sczFiles = NULL;\n    LPWSTR sczDelete = NULL;\n    HANDLE hFind = INVALID_HANDLE_VALUE;\n    WIN32_FIND_DATAW wfd = { };\n    DWORD cFileName = 0;\n\n    hr = CacheGetCompletedPath(fPerMachine, UNVERIFIED_CACHE_FOLDER_NAME, &sczFolder);\n    if (SUCCEEDED(hr))\n    {\n        hr = DirEnsureDeleteEx(sczFolder, DIR_DELETE_FILES | DIR_DELETE_RECURSE | DIR_DELETE_SCHEDULE);\n    }\n\n    if (!fPerMachine)\n    {\n        hr = CalculateWorkingFolder(wzBundleId, &sczFolder, NULL);\n        if (SUCCEEDED(hr))\n        {\n            hr = PathConcat(sczFolder, L\"*.*\", &sczFiles);\n            if (SUCCEEDED(hr))\n            {\n                hFind = ::FindFirstFileW(sczFiles, &wfd);\n                if (INVALID_HANDLE_VALUE != hFind)\n                {\n                    do\n                    {\n                        // Skip directories.\n                        if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\n                        {\n                            continue;\n                        }\n\n                        // For extra safety and to silence OACR.\n                        wfd.cFileName[MAX_PATH - 1] = L'\\0';\n\n                        // Skip resume files (they end with \".R\").\n                        cFileName = lstrlenW(wfd.cFileName);\n                        if (2 < cFileName && L'.' == wfd.cFileName[cFileName - 2] && (L'R' == wfd.cFileName[cFileName - 1] || L'r' == wfd.cFileName[cFileName - 1]))\n                        {\n                            continue;\n                        }\n\n                        hr = PathConcat(sczFolder, wfd.cFileName, &sczDelete);\n                        if (SUCCEEDED(hr))\n                        {\n                            hr = FileEnsureDelete(sczDelete);\n                        }\n                    } while (::FindNextFileW(hFind, &wfd));\n                }\n            }\n        }\n    }\n\n    if (INVALID_HANDLE_VALUE != hFind)\n    {\n        ::FindClose(hFind);\n    }\n\n    ReleaseStr(sczDelete);\n    ReleaseStr(sczFiles);\n    ReleaseStr(sczFolder);\n}",
      "cve_list": [
        "CVE-2024-29187"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wix3",
      "filepath": "src/burn/engine/cache.cpp",
      "func_name": "CacheEnsureWorkingFolder",
      "func_body": "extern \"C\" HRESULT CacheEnsureWorkingFolder(\n    __in_z LPCWSTR wzBundleId,\n    __deref_out_z_opt LPWSTR* psczWorkingFolder\n    )\n{\n    HRESULT hr = S_OK;\n    LPWSTR sczWorkingFolder = NULL;\n    BOOL fElevatedWorkingFolder = FALSE;\n    PSECURITY_DESCRIPTOR psd = NULL;\n    LPSECURITY_ATTRIBUTES pWorkingFolderAcl = NULL;\n\n    hr = CalculateWorkingFolder(wzBundleId, &sczWorkingFolder, &fElevatedWorkingFolder);\n    ExitOnFailure(hr, \"Failed to calculate working folder to ensure it exists.\");\n\n    // If elevated, allocate the pWorkingFolderAcl to protect the working folder to only Admins and SYSTEM.\n    if (fElevatedWorkingFolder)\n    {\n        LPCWSTR wzSddl = L\"D:PAI(A;;FA;;;BA)(A;OICIIO;GA;;;BA)(A;;FA;;;SY)(A;OICIIO;GA;;;SY)\";\n        if (!::ConvertStringSecurityDescriptorToSecurityDescriptorW(wzSddl, SDDL_REVISION_1, &psd, NULL))\n        {\n            ExitWithLastError(hr, \"Failed to create the security descriptor for the working folder.\");\n        }\n\n        pWorkingFolderAcl = reinterpret_cast<LPSECURITY_ATTRIBUTES>(MemAlloc(sizeof(SECURITY_ATTRIBUTES), TRUE));\n        pWorkingFolderAcl->nLength = sizeof(SECURITY_ATTRIBUTES);\n        pWorkingFolderAcl->lpSecurityDescriptor = psd;\n        pWorkingFolderAcl->bInheritHandle = FALSE;\n    }\n\n    hr = DirEnsureExists(sczWorkingFolder, pWorkingFolderAcl);\n    ExitOnFailure(hr, \"Failed create working folder.\");\n\n    // Best effort to ensure our working folder is not encrypted.\n    ::DecryptFileW(sczWorkingFolder, 0);\n\n    if (psczWorkingFolder)\n    {\n        hr = StrAllocString(psczWorkingFolder, sczWorkingFolder, 0);\n        ExitOnFailure(hr, \"Failed to copy working folder.\");\n    }\n\nLExit:\n    ReleaseMem(pWorkingFolderAcl);\n    if (psd)\n    {\n        ::LocalFree(psd);\n    }\n    ReleaseStr(sczWorkingFolder);\n\n    return hr;\n}",
      "cve_list": [
        "CVE-2024-29187"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wix3",
      "filepath": "src/burn/engine/cache.cpp",
      "func_name": "CacheRemoveWorkingFolder",
      "func_body": "extern \"C\" HRESULT CacheRemoveWorkingFolder(\n    __in_z_opt LPCWSTR wzBundleId\n    )\n{\n    HRESULT hr = S_OK;\n    LPWSTR sczWorkingFolder = NULL;\n\n    if (vfInitializedCache)\n    {\n        hr = CalculateWorkingFolder(wzBundleId, &sczWorkingFolder, NULL);\n        ExitOnFailure(hr, \"Failed to calculate the working folder to remove it.\");\n\n        // Try to clean out everything in the working folder.\n        hr = DirEnsureDeleteEx(sczWorkingFolder, DIR_DELETE_FILES | DIR_DELETE_RECURSE | DIR_DELETE_SCHEDULE);\n        TraceError(hr, \"Could not delete bundle engine working folder.\");\n    }\n\nLExit:\n    ReleaseStr(sczWorkingFolder);\n\n    return hr;\n}",
      "cve_list": [
        "CVE-2024-29187"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "wix3",
      "filepath": "src/burn/engine/cache.cpp",
      "func_name": "CalculateWorkingFolder",
      "func_body": "static HRESULT CalculateWorkingFolder(\n    __in_z LPCWSTR /*wzBundleId*/,\n    __deref_out_z LPWSTR* psczWorkingFolder,\n    __out_opt BOOL* pfWorkingFolderElevated\n    )\n{\n    HRESULT hr = S_OK;\n    RPC_STATUS rs = RPC_S_OK;\n    BOOL fElevated = FALSE;\n    WCHAR wzTempPath[MAX_PATH] = { };\n    UUID guid = {};\n    WCHAR wzGuid[39];\n\n    if (!vsczWorkingFolder)\n    {\n        ProcElevated(::GetCurrentProcess(), &fElevated);\n\n        if (fElevated)\n        {\n            if (!::GetWindowsDirectoryW(wzTempPath, countof(wzTempPath)))\n            {\n                ExitWithLastError(hr, \"Failed to get windows path for working folder.\");\n            }\n\n            hr = PathFixedBackslashTerminate(wzTempPath, countof(wzTempPath));\n            ExitOnFailure(hr, \"Failed to ensure windows path for working folder ended in backslash.\");\n\n            hr = ::StringCchCatW(wzTempPath, countof(wzTempPath), L\"Temp\\\\\");\n            ExitOnFailure(hr, \"Failed to concat Temp directory on windows path for working folder.\");\n        }\n        else if (0 == ::GetTempPathW(countof(wzTempPath), wzTempPath))\n        {\n            ExitWithLastError(hr, \"Failed to get temp path for working folder.\");\n        }\n\n        rs = ::UuidCreate(&guid);\n        hr = HRESULT_FROM_RPC(rs);\n        ExitOnFailure(hr, \"Failed to create working folder guid.\");\n\n        if (!::StringFromGUID2(guid, wzGuid, countof(wzGuid)))\n        {\n            hr = E_OUTOFMEMORY;\n            ExitOnRootFailure(hr, \"Failed to convert working folder guid into string.\");\n        }\n\n        hr = StrAllocFormatted(&vsczWorkingFolder, L\"%ls%ls\\\\\", wzTempPath, wzGuid);\n        ExitOnFailure(hr, \"Failed to append bundle id on to temp path for working folder.\");\n\n        vfWorkingFolderElevated = fElevated;\n    }\n\n    hr = StrAllocString(psczWorkingFolder, vsczWorkingFolder, 0);\n    ExitOnFailure(hr, \"Failed to copy working folder path.\");\n\n    if (pfWorkingFolderElevated)\n    {\n        *pfWorkingFolderElevated = vfWorkingFolderElevated;\n    }\n\nLExit:\n    return hr;\n}",
      "cve_list": [
        "CVE-2024-29187"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/httpapi_compact.c",
      "func_name": "HTTPAPI_CloneOption",
      "func_body": "HTTPAPI_RESULT HTTPAPI_CloneOption(const char* optionName, const void* value, const void** savedValue)\n{\n    HTTPAPI_RESULT result;\n    size_t certLen;\n    char* tempCert;\n\n    if (\n        (optionName == NULL) ||\n        (value == NULL) ||\n        (savedValue == NULL)\n        )\n    {\n        /*Codes_SRS_HTTPAPI_COMPACT_21_067: [ If the optionName is NULL, the HTTPAPI_CloneOption shall return HTTPAPI_INVALID_ARG. ]*/\n        /*Codes_SRS_HTTPAPI_COMPACT_21_068: [ If the value is NULL, the HTTPAPI_CloneOption shall return HTTPAPI_INVALID_ARG. ]*/\n        /*Codes_SRS_HTTPAPI_COMPACT_21_069: [ If the savedValue is NULL, the HTTPAPI_CloneOption shall return HTTPAPI_INVALID_ARG. ]*/\n        result = HTTPAPI_INVALID_ARG;\n    }\n    else if (strcmp(OPTION_TRUSTED_CERT, optionName) == 0)\n    {\n#ifdef DO_NOT_COPY_TRUSTED_CERTS_STRING\n        *savedValue = (const void*)value;\n        result = HTTPAPI_OK;\n#else\n        certLen = strlen((const char*)value);\n        size_t malloc_size = safe_add_size_t(certLen, 1);\n        malloc_size = safe_multiply_size_t(malloc_size, sizeof(char));\n        if (malloc_size == SIZE_MAX)\n        {\n            tempCert = NULL;\n        }\n        else\n        {\n            tempCert = (char*)malloc(malloc_size);\n        }\n\n        if (tempCert == NULL)\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_070: [ If any memory allocation get fail, the HTTPAPI_CloneOption shall return HTTPAPI_ALLOC_FAILED. ]*/\n            result = HTTPAPI_ALLOC_FAILED;\n        }\n        else\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_072: [ If the HTTPAPI_CloneOption get success setting the option, it shall return HTTPAPI_OK. ]*/\n            (void)strcpy(tempCert, (const char*)value);\n            *savedValue = tempCert;\n            result = HTTPAPI_OK;\n        }\n#endif // DO_NOT_COPY_TRUSTED_CERTS_STRING\n    }\n    else if (strcmp(SU_OPTION_X509_CERT, optionName) == 0 || strcmp(OPTION_X509_ECC_CERT, optionName) == 0)\n    {\n        certLen = strlen((const char*)value);\n        size_t malloc_size = safe_add_size_t(certLen, 1);\n        malloc_size = safe_multiply_size_t(malloc_size, sizeof(char));\n        if (malloc_size == SIZE_MAX)\n        {\n            LogError(\"Invalid malloc size\");\n            tempCert = NULL;\n        }\n        else\n        {\n            tempCert = (char*)malloc(malloc_size);\n        }\n\n        if (tempCert == NULL)\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_070: [ If any memory allocation get fail, the HTTPAPI_CloneOption shall return HTTPAPI_ALLOC_FAILED. ]*/\n            result = HTTPAPI_ALLOC_FAILED;\n        }\n        else\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_072: [ If the HTTPAPI_CloneOption get success setting the option, it shall return HTTPAPI_OK. ]*/\n            (void)strcpy(tempCert, (const char*)value);\n            *savedValue = tempCert;\n            result = HTTPAPI_OK;\n        }\n    }\n    else if (strcmp(SU_OPTION_X509_PRIVATE_KEY, optionName) == 0 || strcmp(OPTION_X509_ECC_KEY, optionName) == 0)\n    {\n        certLen = strlen((const char*)value);\n        size_t malloc_size = safe_add_size_t(certLen, 1);\n        malloc_size = safe_multiply_size_t(malloc_size, sizeof(char));\n        if (malloc_size == SIZE_MAX)\n        {\n            LogError(\"Invalid malloc size\");\n            tempCert = NULL;\n        }\n        else\n        {\n            tempCert = (char*)malloc(malloc_size);\n        }\n\n        if (tempCert == NULL)\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_070: [ If any memory allocation get fail, the HTTPAPI_CloneOption shall return HTTPAPI_ALLOC_FAILED. ]*/\n            result = HTTPAPI_ALLOC_FAILED;\n        }\n        else\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_072: [ If the HTTPAPI_CloneOption get success setting the option, it shall return HTTPAPI_OK. ]*/\n            (void)strcpy(tempCert, (const char*)value);\n            *savedValue = tempCert;\n            result = HTTPAPI_OK;\n        }\n    }\n    else if (strcmp(OPTION_HTTP_PROXY, optionName) == 0)\n    {\n        HTTP_PROXY_OPTIONS* proxy_data = (HTTP_PROXY_OPTIONS*)value;\n\n        HTTP_PROXY_OPTIONS* new_proxy_info = malloc(sizeof(HTTP_PROXY_OPTIONS));\n        if (new_proxy_info == NULL)\n        {\n            LogError(\"unable to allocate proxy option information\");\n            result = HTTPAPI_ERROR;\n        }\n        else\n        {\n            new_proxy_info->host_address = proxy_data->host_address;\n            new_proxy_info->port = proxy_data->port;\n            new_proxy_info->password = proxy_data->password;\n            new_proxy_info->username = proxy_data->username;\n            *savedValue = new_proxy_info;\n            result = HTTPAPI_OK;\n        }\n    }\n    else if (strcmp(OPTION_SET_TLS_RENEGOTIATION, optionName) == 0)\n    {\n        bool* temp = (bool*)malloc(sizeof(bool)); /*shall be freed by HTTPAPIEX_Destroy*/\n        if (temp == NULL)\n        {\n            result = HTTPAPI_ERROR;\n            LogError(\"malloc failed (result = %\" PRI_MU_ENUM \")\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n        }\n        else\n        {\n            *temp = *(bool*)value;\n            *savedValue = temp;\n            result = HTTPAPI_OK;\n        }\n    }\n    else\n    {\n        /*Codes_SRS_HTTPAPI_COMPACT_21_071: [ If the HTTP do not support the optionName, the HTTPAPI_CloneOption shall return HTTPAPI_INVALID_ARG. ]*/\n        result = HTTPAPI_INVALID_ARG;\n        LogInfo(\"unknown option %s\", optionName);\n    }\n    return result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/httpapi_compact.c",
      "func_name": "HTTPAPI_SetOption",
      "func_body": "HTTPAPI_RESULT HTTPAPI_SetOption(HTTP_HANDLE handle, const char* optionName, const void* value)\n{\n    HTTPAPI_RESULT result;\n    HTTP_HANDLE_DATA* http_instance = (HTTP_HANDLE_DATA*)handle;\n\n    if (\n        (http_instance == NULL) ||\n        (optionName == NULL) ||\n        (value == NULL)\n        )\n    {\n        /*Codes_SRS_HTTPAPI_COMPACT_21_059: [ If the handle is NULL, the HTTPAPI_SetOption shall return HTTPAPI_INVALID_ARG. ]*/\n        /*Codes_SRS_HTTPAPI_COMPACT_21_060: [ If the optionName is NULL, the HTTPAPI_SetOption shall return HTTPAPI_INVALID_ARG. ]*/\n        /*Codes_SRS_HTTPAPI_COMPACT_21_061: [ If the value is NULL, the HTTPAPI_SetOption shall return HTTPAPI_INVALID_ARG. ]*/\n        result = HTTPAPI_INVALID_ARG;\n    }\n    else if (strcmp(OPTION_TRUSTED_CERT, optionName) == 0)\n    {\n#ifdef DO_NOT_COPY_TRUSTED_CERTS_STRING\n        result = HTTPAPI_OK;\n        http_instance->certificate = (char*)value;\n#else\n\n        if (http_instance->certificate)\n        {\n            free(http_instance->certificate);\n        }\n\n        size_t len = strlen((char*)value);\n        size_t malloc_size = safe_add_size_t(len, 1);\n        malloc_size = safe_multiply_size_t(malloc_size, sizeof(char));\n        if (malloc_size == SIZE_MAX)\n        {\n            LogError(\"Invalid malloc size\");\n            http_instance->certificate = NULL;\n        }\n        else\n        {\n            http_instance->certificate = (char*)malloc(malloc_size);\n        }\n\n        if (http_instance->certificate == NULL)\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_062: [ If any memory allocation get fail, the HTTPAPI_SetOption shall return HTTPAPI_ALLOC_FAILED. ]*/\n            result = HTTPAPI_ALLOC_FAILED;\n            LogInfo(\"unable to allocate memory for the certificate in HTTPAPI_SetOption\");\n        }\n        else\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_064: [ If the HTTPAPI_SetOption get success setting the option, it shall return HTTPAPI_OK. ]*/\n            (void)strcpy(http_instance->certificate, (const char*)value);\n            result = HTTPAPI_OK;\n        }\n#endif // DO_NOT_COPY_TRUSTED_CERTS_STRING\n    }\n    else if (strcmp(SU_OPTION_X509_CERT, optionName) == 0 || strcmp(OPTION_X509_ECC_CERT, optionName) == 0)\n    {\n        if (http_instance->x509ClientCertificate)\n        {\n            free(http_instance->x509ClientCertificate);\n        }\n\n        size_t len = strlen((char*)value);\n        size_t malloc_size = safe_add_size_t(len, 1);\n        malloc_size = safe_multiply_size_t(malloc_size, sizeof(char));\n        if (malloc_size == SIZE_MAX)\n        {\n            LogError(\"Invalid malloc size\");\n            http_instance->x509ClientCertificate = NULL;\n        }\n        else\n        {\n            http_instance->x509ClientCertificate = (char*)malloc(malloc_size);\n        }\n\n        if (http_instance->x509ClientCertificate == NULL)\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_062: [ If any memory allocation get fail, the HTTPAPI_SetOption shall return HTTPAPI_ALLOC_FAILED. ]*/\n            result = HTTPAPI_ALLOC_FAILED;\n            LogInfo(\"unable to allocate memory for the client certificate in HTTPAPI_SetOption\");\n        }\n        else\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_064: [ If the HTTPAPI_SetOption get success setting the option, it shall return HTTPAPI_OK. ]*/\n            (void)strcpy(http_instance->x509ClientCertificate, (const char*)value);\n            result = HTTPAPI_OK;\n        }\n    }\n    else if (strcmp(SU_OPTION_X509_PRIVATE_KEY, optionName) == 0 || strcmp(OPTION_X509_ECC_KEY, optionName) == 0)\n    {\n        if (http_instance->x509ClientPrivateKey)\n        {\n            free(http_instance->x509ClientPrivateKey);\n        }\n\n        size_t len = strlen((char*)value);\n        size_t malloc_size = safe_add_size_t(len, 1);\n        malloc_size = safe_multiply_size_t(malloc_size, sizeof(char));\n        if (malloc_size == SIZE_MAX)\n        {\n            LogError(\"Invalid malloc size\");\n            http_instance->x509ClientPrivateKey = NULL;\n        }\n        else\n        {\n            http_instance->x509ClientPrivateKey = (char*)malloc(malloc_size);\n        }\n\n        if (http_instance->x509ClientPrivateKey == NULL)\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_062: [ If any memory allocation get fail, the HTTPAPI_SetOption shall return HTTPAPI_ALLOC_FAILED. ]*/\n            result = HTTPAPI_ALLOC_FAILED;\n            LogInfo(\"unable to allocate memory for the client private key in HTTPAPI_SetOption\");\n        }\n        else\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_064: [ If the HTTPAPI_SetOption get success setting the option, it shall return HTTPAPI_OK. ]*/\n            (void)strcpy(http_instance->x509ClientPrivateKey, (const char*)value);\n            result = HTTPAPI_OK;\n        }\n    }\n    else if (strcmp(OPTION_HTTP_PROXY, optionName) == 0)\n    {\n        TLSIO_CONFIG tlsio_config;\n        HTTP_PROXY_IO_CONFIG proxy_config;\n        HTTP_PROXY_OPTIONS* proxy_options = (HTTP_PROXY_OPTIONS*)value;\n\n        if (proxy_options->host_address == NULL)\n        {\n            LogError(\"NULL host_address in proxy options\");\n            result = HTTPAPI_ERROR;\n        }\n        else if (((proxy_options->username == NULL) || (proxy_options->password == NULL)) &&\n                (proxy_options->username != proxy_options->password))\n        {\n            LogError(\"Only one of username and password for proxy settings was NULL\");\n            result = HTTPAPI_ERROR;\n        }\n        else\n        {\n\n            /* Workaround: xio interface is already created when HTTPAPI_CreateConnection is call without proxy support\n             * need to destroy the interface and create a new one with proxy information\n             */\n            OPTIONHANDLER_HANDLE xio_options;\n            if ((xio_options = xio_retrieveoptions(http_instance->xio_handle)) == NULL)\n            {\n                LogError(\"failed saving underlying I/O transport options\");\n                result = HTTPAPI_ERROR;\n            }\n            else\n            {\n                xio_destroy(http_instance->xio_handle);\n\n                proxy_config.hostname = http_instance->hostName;\n                proxy_config.proxy_hostname = proxy_options->host_address;\n                proxy_config.password = proxy_options->password;\n                proxy_config.username = proxy_options->username;\n                proxy_config.proxy_port = proxy_options->port;\n                proxy_config.port = 443;\n\n                tlsio_config.hostname = http_instance->hostName;\n                tlsio_config.port = 443;\n                tlsio_config.underlying_io_interface =  http_proxy_io_get_interface_description();\n                tlsio_config.underlying_io_parameters = &proxy_config;\n                tlsio_config.invoke_on_send_complete_callback_for_fragments = true;\n\n                http_instance->xio_handle = xio_create(platform_get_default_tlsio(), (void*)&tlsio_config);\n\n                if (http_instance->xio_handle == NULL)\n                {\n                    LogError(\"Failed to create xio handle with proxy configuration\");\n                    result = HTTPAPI_ERROR;\n                }\n                else\n                {\n                    if (OptionHandler_FeedOptions(xio_options, http_instance->xio_handle) != OPTIONHANDLER_OK)\n                    {\n                        LogError(\"Failed feeding existing options to new xio instance.\");\n                        result = HTTPAPI_ERROR;\n                    }\n                    else\n                    {\n                        result = HTTPAPI_OK;\n                    }\n                }\n\n                OptionHandler_Destroy(xio_options);\n            }\n        }\n    }\n    else if (strcmp(OPTION_SET_TLS_RENEGOTIATION, optionName) == 0)\n    {\n        bool tls_renegotiation = *(bool*)value;\n        http_instance->tls_renegotiation = tls_renegotiation;\n        result = HTTPAPI_OK;\n    }\n    else\n    {\n        /*Codes_SRS_HTTPAPI_COMPACT_21_063: [ If the HTTP do not support the optionName, the HTTPAPI_SetOption shall return HTTPAPI_INVALID_ARG. ]*/\n        result = HTTPAPI_INVALID_ARG;\n        LogInfo(\"unknown option %s\", optionName);\n    }\n\n    return result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/httpapi_compact.c",
      "func_name": "on_bytes_received",
      "func_body": "static void on_bytes_received(void* context, const unsigned char* buffer, size_t size)\n{\n    unsigned char* new_received_bytes;\n    HTTP_HANDLE_DATA* http_instance = (HTTP_HANDLE_DATA*)context;\n\n    if (http_instance != NULL)\n    {\n\n        if (buffer == NULL)\n        {\n            http_instance->is_io_error = 1;\n            LogError(\"NULL pointer error\");\n        }\n        else\n        {\n            /* Here we got some bytes so we'll buffer them so the receive functions can consumer it */\n            size_t malloc_size = http_instance->received_bytes_count + size;\n            if (malloc_size < size)\n            {\n                // check for int overflow\n                new_received_bytes = NULL;\n                LogError(\"Invalid size parameter\");\n            }\n            else\n            {\n                new_received_bytes = (unsigned char*)realloc(http_instance->received_bytes, malloc_size);\n            }\n\n            if (new_received_bytes == NULL)\n            {\n                http_instance->is_io_error = 1;\n                LogError(\"Error allocating memory for received data\");\n            }\n            else\n            {\n                http_instance->received_bytes = new_received_bytes;\n                if (memcpy(http_instance->received_bytes + http_instance->received_bytes_count, buffer, size) == NULL)\n                {\n                    http_instance->is_io_error = 1;\n                    LogError(\"Error copping received data to the HTTP bufffer\");\n                }\n                else\n                {\n                    http_instance->received_bytes_count += size;\n                }\n            }\n        }\n    }\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/httpapi_tirtos.c",
      "func_name": "HTTPAPI_ExecuteRequest",
      "func_body": "HTTPAPI_RESULT HTTPAPI_ExecuteRequest(HTTP_HANDLE handle,\n        HTTPAPI_REQUEST_TYPE requestType, const char* relativePath,\n        HTTP_HEADERS_HANDLE httpHeadersHandle, const unsigned char* content,\n        size_t contentLength, unsigned int* statusCode,\n        HTTP_HEADERS_HANDLE responseHeadersHandle,\n        BUFFER_HANDLE responseContent)\n{\n    HTTPCli_Handle cli = (HTTPCli_Handle) handle;\n    int ret;\n    int offset;\n    size_t cnt;\n    char contentBuf[CONTENT_BUF_LEN] = {0};\n    char *hname;\n    char *hvalue;\n    const char *method;\n    bool moreFlag;\n\n    method = getHttpMethod(requestType);\n\n    if ((cli == NULL) || (method == NULL) || (relativePath == NULL)\n            || (statusCode == NULL) || (responseHeadersHandle == NULL)) {\n        LogError(\"Invalid arguments: handle=%p, requestType=%d, relativePath=%p, statusCode=%p, responseHeadersHandle=%p\",\n            handle, (int)requestType, relativePath, statusCode, responseHeadersHandle);\n        return (HTTPAPI_INVALID_ARG);\n    }\n    else if (HTTPHeaders_GetHeaderCount(httpHeadersHandle, &cnt)\n            != HTTP_HEADERS_OK) {\n        LogError(\"Cannot get header count\");\n        return (HTTPAPI_QUERY_HEADERS_FAILED);\n    }\n\n    /* Send the request line */\n    ret = HTTPCli_sendRequest(cli, method, relativePath, true);\n    if (ret < 0) {\n        LogError(\"HTTPCli_sendRequest failed, ret=%d\", ret);\n        return (HTTPAPI_SEND_REQUEST_FAILED);\n    }\n\n    /* Send the request headers */\n    while (cnt--) {\n        ret = HTTPHeaders_GetHeader(httpHeadersHandle, cnt, &hname);\n        if (ret != HTTP_HEADERS_OK) {\n            LogError(\"Cannot get request header %d\", cnt);\n            return (HTTPAPI_QUERY_HEADERS_FAILED);\n        }\n\n        ret = splitHeader(hname, &hvalue);\n\n        if (ret == 0) {\n            ret = HTTPCli_sendField(cli, hname, hvalue, false);\n        }\n\n        free(hname);\n        hname = NULL;\n\n        if (ret < 0) {\n            LogError(\"HTTP send field failed, ret=%d\", ret);\n            return (HTTPAPI_SEND_REQUEST_FAILED);\n        }\n    }\n\n    /* Send the last header and request body */\n    ret = HTTPCli_sendField(cli, NULL, NULL, true);\n    if (ret < 0) {\n        LogError(\"HTTP send empty field failed, ret=%d\", ret);\n        return (HTTPAPI_SEND_REQUEST_FAILED);\n    }\n\n    if (content && contentLength != 0) {\n        ret = HTTPCli_sendRequestBody(cli, (const char *)content,\n                contentLength);\n        if (ret < 0) {\n            LogError(\"HTTP send request body failed, ret=%d\", ret);\n            return (HTTPAPI_SEND_REQUEST_FAILED);\n        }\n    }\n\n    /* Get the response status code */\n    ret = HTTPCli_getResponseStatus(cli);\n    if (ret < 0) {\n        LogError(\"HTTP receive response failed, ret=%d\", ret);\n        return (HTTPAPI_RECEIVE_RESPONSE_FAILED);\n    }\n    *statusCode = (unsigned int)ret;\n\n    /* Get the response headers */\n    hname = NULL;\n    cnt = 0;\n    offset = 0;\n    do {\n        ret = HTTPCli_readResponseHeader(cli, contentBuf, CONTENT_BUF_LEN,\n            &moreFlag);\n        if (ret < 0) {\n            LogError(\"HTTP read response header failed, ret=%d\", ret);\n            ret = HTTPAPI_RECEIVE_RESPONSE_FAILED;\n            goto headersDone;\n        }\n        else if (ret == 0) {\n            /* All headers read */\n            goto headersDone;\n        }\n\n        if (cnt < offset + ret) {\n            size_t malloc_size = safe_add_size_t(offset, ret);\n            if (malloc_size == SIZE_MAX)\n            {\n                LogError(\"invalid realloc size\");\n                hname = NULL;\n            }\n            else\n            {\n                hname = (char*)realloc(hname, malloc_size);\n            }\n\n            if (hname == NULL) {\n                LogError(\"Failed reallocating memory\");\n                ret = HTTPAPI_ALLOC_FAILED;\n                goto headersDone;\n            }\n            cnt = offset + ret;\n        }\n\n        memcpy(hname + offset, contentBuf, ret);\n        offset += ret;\n\n        if (moreFlag) {\n            continue;\n        }\n\n        ret = splitHeader(hname, &hvalue);\n        if (ret < 0) {\n            LogError(\"HTTP split header failed, ret=%d\", ret);\n            ret = HTTPAPI_HTTP_HEADERS_FAILED;\n            goto headersDone;\n        }\n\n        ret = HTTPHeaders_AddHeaderNameValuePair(responseHeadersHandle,\n                hname, hvalue);\n        if (ret != HTTP_HEADERS_OK) {\n            LogError(\"Adding the response header failed\");\n            ret = HTTPAPI_HTTP_HEADERS_FAILED;\n            goto headersDone;\n        }\n        offset = 0;\n    } while (1);\n\nheadersDone:\n    free(hname);\n    hname = NULL;\n    if (ret != 0) {\n        return ((HTTPAPI_RESULT)ret);\n    }\n\n    /* Get response body */\n    if (responseContent != NULL) {\n        offset = 0;\n        cnt = 0;\n\n        do {\n            ret = HTTPCli_readResponseBody(cli, contentBuf, CONTENT_BUF_LEN,\n                    &moreFlag);\n\n            if (ret < 0) {\n                LogError(\"HTTP read response body failed, ret=%d\", ret);\n                ret = HTTPAPI_RECEIVE_RESPONSE_FAILED;\n                goto contentDone;\n            }\n\n            if (ret != 0) {\n                cnt = ret;\n                ret = BUFFER_enlarge(responseContent, cnt);\n                if (ret != 0) {\n                    LogError(\"Failed enlarging response buffer\");\n                    ret = HTTPAPI_ALLOC_FAILED;\n                    goto contentDone;\n                }\n\n                ret = BUFFER_content(responseContent,\n                        (const unsigned char **)&hname);\n                if (ret != 0) {\n                    LogError(\"Failed getting the response buffer content\");\n                    ret = HTTPAPI_ALLOC_FAILED;\n                    goto contentDone;\n                }\n\n                memcpy(hname + offset, contentBuf, cnt);\n                offset += cnt;\n            }\n        } while (moreFlag);\n\n    contentDone:\n        if (ret < 0) {\n            BUFFER_unbuild(responseContent);\n            return ((HTTPAPI_RESULT)ret);\n        }\n    }\n\n    return (HTTPAPI_OK);\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/httpapi_winhttp.c",
      "func_name": "ConcatHttpHeaders",
      "func_body": "static char* ConcatHttpHeaders(HTTP_HEADERS_HANDLE httpHeadersHandle, size_t toAlloc, size_t headersCount)\n{\n    size_t i;\n    char* result;\n\n    size_t malloc_size = safe_multiply_size_t(toAlloc, sizeof(char));\n    malloc_size = safe_add_size_t(malloc_size, 1);\n    if (malloc_size == SIZE_MAX)\n    {\n        LogError(\"Invalid malloc size\");\n        result = NULL;\n    }\n    else\n    {\n        result = (char*)malloc(malloc_size);\n    }\n    \n    if (result == NULL)\n    {\n        LogError(\"unable to malloc\");\n    }\n    else\n    {\n        result[0] = '\\0';\n        for (i = 0; i < headersCount; i++)\n        {\n            char* temp;\n            if (HTTPHeaders_GetHeader(httpHeadersHandle, i, &temp) != HTTP_HEADERS_OK)\n            {\n                LogError(\"unable to HTTPHeaders_GetHeader\");\n                break;\n            }\n            else\n            {\n                (void)strcat(result, temp);\n                (void)strcat(result, \"\\r\\n\");\n                free(temp);\n            }\n        }\n    \n        if (i < headersCount)\n        {\n            free(result);\n            result = NULL;\n        }\n        else\n        {\n            /*all is good*/\n        }\n    }\n\n    return result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/httpapi_winhttp.c",
      "func_name": "ConstructHeadersString",
      "func_body": "static HTTPAPI_RESULT ConstructHeadersString(HTTP_HEADERS_HANDLE httpHeadersHandle, wchar_t** httpHeaders)\n{\n    HTTPAPI_RESULT result;\n    size_t headersCount;\n\n    if (HTTPHeaders_GetHeaderCount(httpHeadersHandle, &headersCount) != HTTP_HEADERS_OK)\n    {\n        result = HTTPAPI_ERROR;\n        LogError(\"HTTPHeaders_GetHeaderCount failed (result = %\" PRI_MU_ENUM \").\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n    }\n    else\n    {\n        size_t i;\n\n        /*the total size of all the headers is given by sumof(lengthof(everyheader)+2)*/\n        size_t toAlloc = 0;\n        for (i = 0; i < headersCount; i++)\n        {\n            char *temp;\n            if (HTTPHeaders_GetHeader(httpHeadersHandle, i, &temp) == HTTP_HEADERS_OK)\n            {\n                toAlloc += strlen(temp);\n                toAlloc += 2;\n                free(temp);\n            }\n            else\n            {\n                LogError(\"HTTPHeaders_GetHeader failed\");\n                break;\n            }\n        }\n\n        if (i < headersCount)\n        {\n            result = HTTPAPI_ERROR;\n        }\n        else\n        {\n            char *httpHeadersA;\n            size_t requiredCharactersForHeaders;\n            size_t malloc_size;\n\n            if ((httpHeadersA = ConcatHttpHeaders(httpHeadersHandle, toAlloc, headersCount)) == NULL)\n            {\n                result = HTTPAPI_ERROR;\n                LogError(\"Cannot concatenate headers\");\n            }\n            else if ((requiredCharactersForHeaders = MultiByteToWideChar(CP_ACP, 0, httpHeadersA, -1, NULL, 0)) == 0)\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"MultiByteToWideChar failed, GetLastError=0x%08x (result = %\" PRI_MU_ENUM \")\", GetLastError(), MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n            }\n            else if ((malloc_size = safe_multiply_size_t(safe_add_size_t(requiredCharactersForHeaders, 1), sizeof(wchar_t))) == SIZE_MAX ||\n                (*httpHeaders = (wchar_t*)malloc(malloc_size)) == NULL)\n            {\n                result = HTTPAPI_ALLOC_FAILED;\n                LogError(\"Cannot allocate memory (result = %\" PRI_MU_ENUM \")\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n            }\n            else if (MultiByteToWideChar(CP_ACP, 0, httpHeadersA, -1, *httpHeaders, (int)requiredCharactersForHeaders) == 0)\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"MultiByteToWideChar failed, GetLastError=0x%08x (result = %\" PRI_MU_ENUM \")\", GetLastError(), MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n                free(*httpHeaders);\n                *httpHeaders = NULL;\n            }\n            else\n            {\n                result = HTTPAPI_OK;\n            }\n\n            free(httpHeadersA);\n        }\n    }\n\n    return result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/httpapi_winhttp.c",
      "func_name": "HTTPAPI_CreateConnection",
      "func_body": "HTTP_HANDLE HTTPAPI_CreateConnection(const char* hostName)\n{\n    HTTP_HANDLE_DATA* result;\n    if (g_HTTPAPIState != HTTPAPI_INITIALIZED)\n    {\n        LogError(\"g_HTTPAPIState not HTTPAPI_INITIALIZED\");\n        result = NULL;\n    }\n    else\n    {\n        result = (HTTP_HANDLE_DATA*)malloc(sizeof(HTTP_HANDLE_DATA));\n        if (result == NULL)\n        {\n            LogError(\"malloc returned NULL.\");\n        }\n        else\n        {\n            memset(result, 0, sizeof(*result));\n            wchar_t* hostNameTemp;\n            size_t hostNameTemp_size = MultiByteToWideChar(CP_ACP, 0, hostName, -1, NULL, 0);\n            if (hostNameTemp_size == 0)\n            {\n                LogError(\"MultiByteToWideChar failed\");\n                free(result);\n                result = NULL;\n            }\n            else\n            {\n                size_t malloc_size = safe_multiply_size_t(sizeof(wchar_t), hostNameTemp_size);\n                if (malloc_size == SIZE_MAX)\n                {\n                    LogError(\"Invalid malloc size\");\n                    hostNameTemp = NULL;\n                }\n                else\n                {\n                    hostNameTemp = (wchar_t*)malloc(malloc_size);\n                }\n\n                if (hostNameTemp == NULL)\n                {\n                    LogError(\"malloc failed\");\n                    free(result);\n                    result = NULL;\n                }\n                else\n                {\n                    if (MultiByteToWideChar(CP_ACP, 0, hostName, -1, hostNameTemp, (int)hostNameTemp_size) == 0)\n                    {\n                        LogError(\"MultiByteToWideChar failed\");\n                        free(result);\n                        result = NULL;\n                    }\n                    else\n                    {\n                        result->ConnectionHandle = WinHttpConnect(\n                            g_SessionHandle,\n                            hostNameTemp,\n                            INTERNET_DEFAULT_HTTPS_PORT,\n                            0);\n\n                        if (result->ConnectionHandle == NULL)\n                        {\n                            LogErrorWinHTTPWithGetLastErrorAsString(\"WinHttpConnect returned NULL.\");\n                            free(result);\n                            result = NULL;\n                        }\n                        else\n                        {\n                            result->timeout = 60000;\n                        }\n                    }\n                    free(hostNameTemp);\n                }\n            }\n        }\n    }\n\n    return (HTTP_HANDLE)result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/httpapi_winhttp.c",
      "func_name": "InitiateWinhttpRequest",
      "func_body": "static HTTPAPI_RESULT InitiateWinhttpRequest(HTTP_HANDLE_DATA* handleData, HTTPAPI_REQUEST_TYPE requestType, const char* relativePath, HINTERNET *requestHandle)\n{\n    HTTPAPI_RESULT result;\n    const wchar_t* requestTypeString;\n    size_t requiredCharactersForRelativePath;\n    wchar_t* relativePathTemp = NULL;\n    size_t malloc_size;\n\n    if ((requestTypeString = GetHttpRequestString(requestType)) == NULL)\n    {\n        result = HTTPAPI_INVALID_ARG;\n        LogError(\"requestTypeString was NULL (result = %\" PRI_MU_ENUM \")\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n    }\n    else if ((requiredCharactersForRelativePath = MultiByteToWideChar(CP_ACP, 0, relativePath, -1, NULL, 0)) == 0)\n    {\n        result = HTTPAPI_STRING_PROCESSING_ERROR;\n        LogError(\"MultiByteToWideChar failed, GetLastError=0x%08x\", GetLastError());\n    }\n    else if ((malloc_size = safe_multiply_size_t(safe_add_size_t(requiredCharactersForRelativePath, 1), sizeof(wchar_t))) == SIZE_MAX)\n    {\n        LogError(\"malloc invalid size\");\n        result = HTTPAPI_ALLOC_FAILED;\n    }\n    else if ((relativePathTemp = (wchar_t*)malloc(malloc_size)) == NULL)\n    {\n        result = HTTPAPI_ALLOC_FAILED;\n        LogError(\"malloc failed (result = %\" PRI_MU_ENUM \")\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n    }\n    else if (MultiByteToWideChar(CP_ACP, 0, relativePath, -1, relativePathTemp, (int)requiredCharactersForRelativePath) == 0)\n    {\n        result = HTTPAPI_STRING_PROCESSING_ERROR;\n        LogError(\"MultiByteToWideChar was 0. (result = %\" PRI_MU_ENUM \")\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n    }\n    else if ((*requestHandle = WinHttpOpenRequest(\n            handleData->ConnectionHandle,\n            requestTypeString,\n            relativePathTemp,\n            NULL,\n            WINHTTP_NO_REFERER,\n            WINHTTP_DEFAULT_ACCEPT_TYPES,\n            WINHTTP_FLAG_SECURE)) == NULL)\n    {\n        result = HTTPAPI_OPEN_REQUEST_FAILED;\n        LogErrorWinHTTPWithGetLastErrorAsString(\"WinHttpOpenRequest failed (result = %\" PRI_MU_ENUM \").\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n    }\n    else if ((handleData->x509SchannelHandle != NULL) &&\n            !WinHttpSetOption(\n                *requestHandle,\n                WINHTTP_OPTION_CLIENT_CERT_CONTEXT,\n                (void*)x509_schannel_get_certificate_context(handleData->x509SchannelHandle),\n                sizeof(CERT_CONTEXT)\n    ))\n    {\n        result = HTTPAPI_SET_X509_FAILURE;\n        LogErrorWinHTTPWithGetLastErrorAsString(\"unable to WinHttpSetOption (WINHTTP_OPTION_CLIENT_CERT_CONTEXT)\");\n        (void)WinHttpCloseHandle(*requestHandle);\n        *requestHandle = NULL;\n    }\n    else\n    {\n        result = HTTPAPI_OK;\n    }\n\n    free(relativePathTemp);\n    return result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/httpapi_winhttp.c",
      "func_name": "ReceiveResponseHeaders",
      "func_body": "static HTTPAPI_RESULT ReceiveResponseHeaders(HINTERNET requestHandle, HTTP_HEADERS_HANDLE responseHeadersHandle)\n{\n    HTTPAPI_RESULT result;\n    wchar_t* responseHeadersTemp = NULL;\n    DWORD responseHeadersTempLength = 0;\n\n    // Don't explicictly check return code here - since this should fail (to determine length)\n    // and checking return code means an explicit GetLastError() comparison.  Instead\n    // rely on subsequent WinHttpQueryHeaders() to fail.\n    WinHttpQueryHeaders(\n        requestHandle,\n        WINHTTP_QUERY_RAW_HEADERS_CRLF,\n        WINHTTP_HEADER_NAME_BY_INDEX,\n        WINHTTP_NO_OUTPUT_BUFFER,\n        &responseHeadersTempLength,\n        WINHTTP_NO_HEADER_INDEX);\n\n    size_t malloc_size = safe_add_size_t((size_t)responseHeadersTempLength, 2);\n    if (malloc_size == SIZE_MAX)\n    {\n        LogError(\"Invalid malloc size\");\n        responseHeadersTemp = NULL;\n    }\n    else\n    {\n        responseHeadersTemp = (wchar_t*)malloc(malloc_size);\n    }\n\n    if (responseHeadersTemp == NULL)\n    {\n        result = HTTPAPI_ALLOC_FAILED;\n        LogError(\"malloc failed: (result = %\" PRI_MU_ENUM \")\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n    }\n    else if (! WinHttpQueryHeaders(\n            requestHandle,\n            WINHTTP_QUERY_RAW_HEADERS_CRLF,\n            WINHTTP_HEADER_NAME_BY_INDEX,\n            responseHeadersTemp,\n            &responseHeadersTempLength,\n            WINHTTP_NO_HEADER_INDEX))\n    {\n        result = HTTPAPI_QUERY_HEADERS_FAILED;\n        LogErrorWinHTTPWithGetLastErrorAsString(\"WinHttpQueryHeaders failed (result = %\" PRI_MU_ENUM \")\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n    }\n    else    \n    {\n        wchar_t *next_token = NULL;\n        wchar_t* token = wcstok_s(responseHeadersTemp, L\"\\r\\n\", &next_token);\n        char* tokenTemp = NULL;     \n\n        result = HTTPAPI_OK;\n\n        while ((token != NULL) &&\n            (token[0] != L'\\0'))\n        {\n            size_t tokenTemp_size;\n\n            tokenTemp_size = WideCharToMultiByte(CP_ACP, 0, token, -1, NULL, 0, NULL, NULL);\n            if (tokenTemp_size == 0)\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"WideCharToMultiByte failed\");\n                break;\n            }\n            else if ((malloc_size = safe_multiply_size_t(sizeof(char), tokenTemp_size)) == SIZE_MAX)\n            {\n                result = HTTPAPI_ALLOC_FAILED;\n                LogError(\"invalid malloc size\");\n                break;\n            }\n            else if ((tokenTemp = (char*)malloc(malloc_size)) == NULL)\n            {\n                result = HTTPAPI_ALLOC_FAILED;\n                LogError(\"malloc failed\");\n                break;\n            }\n            else if (WideCharToMultiByte(CP_ACP, 0, token, -1, tokenTemp, (int)tokenTemp_size, NULL, NULL) == 0)\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"WideCharToMultiByte failed\");\n                break;\n            }\n            else\n            {\n                /*breaking the token in 2 parts: everything before the first \":\" and everything after the first \":\"*/\n                /*if there is no such character, then skip it*/\n                /*if there is a : then replace is by a '\\0' and so it breaks the original string in name and value*/\n                char* whereIsColon = strchr(tokenTemp, ':');\n                if (whereIsColon != NULL)\n                {\n                    *whereIsColon = '\\0';\n                    if (HTTPHeaders_AddHeaderNameValuePair(responseHeadersHandle, tokenTemp, whereIsColon + 1) != HTTP_HEADERS_OK)\n                    {\n                        LogError(\"HTTPHeaders_AddHeaderNameValuePair failed\");\n                        result = HTTPAPI_HTTP_HEADERS_FAILED;\n                        break;\n                    }\n                }\n            }\n            free(tokenTemp);\n            tokenTemp = NULL;\n\n            token = wcstok_s(NULL, L\"\\r\\n\", &next_token);\n        }\n\n        free(tokenTemp);\n        tokenTemp = NULL;\n    }\n\n    free(responseHeadersTemp);\n    return result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/socketio_berkeley.c",
      "func_name": "create_network_interface_description",
      "func_body": "static NETWORK_INTERFACE_DESCRIPTION* create_network_interface_description(struct ifreq *ifr, NETWORK_INTERFACE_DESCRIPTION* previous_nid)\n{\n    NETWORK_INTERFACE_DESCRIPTION* result;\n    size_t malloc_size;\n\n    if ((result = (NETWORK_INTERFACE_DESCRIPTION*)malloc(sizeof(NETWORK_INTERFACE_DESCRIPTION))) == NULL)\n    {\n        LogError(\"Failed allocating NETWORK_INTERFACE_DESCRIPTION\");\n    }\n    else if ((malloc_size = safe_multiply_size_t(safe_add_size_t(strlen(ifr->ifr_name), 1), sizeof(char))) == SIZE_MAX)\n    {\n        LogError(\"invalid malloc size\");\n        destroy_network_interface_descriptions(result);\n        result = NULL;\n    }\n    else if ((result->name = (char*)malloc(malloc_size)) == NULL)\n    {\n        LogError(\"failed setting interface description name (malloc failed)\");\n        destroy_network_interface_descriptions(result);\n        result = NULL;\n    }\n    else\n    {\n        strcpy(result->name, ifr->ifr_name);\n\n        char* ip_address;\n        unsigned char* mac = (unsigned char*)ifr->ifr_hwaddr.sa_data;\n        size_t malloc_size = safe_multiply_size_t(sizeof(char), MAC_ADDRESS_STRING_LENGTH);\n\n        if (malloc_size == SIZE_MAX ||\n                (result->mac_address = (char*)malloc(malloc_size)) == NULL)\n        {\n            LogError(\"failed formatting mac address (malloc failed) size:%zu\", malloc_size);\n            destroy_network_interface_descriptions(result);\n            result = NULL;\n        }\n        else if (sprintf(result->mac_address, \"%02X:%02X:%02X:%02X:%02X:%02X\", mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]) <= 0)\n        {\n            LogError(\"failed formatting mac address (sprintf failed)\");\n            destroy_network_interface_descriptions(result);\n            result = NULL;\n        }\n        else if ((ip_address = inet_ntoa(((struct sockaddr_in*)&ifr->ifr_addr)->sin_addr)) == NULL)\n        {\n            LogError(\"failed setting the ip address (inet_ntoa failed)\");\n            destroy_network_interface_descriptions(result);\n            result = NULL;\n        }\n        else if ((malloc_size = safe_multiply_size_t(safe_add_size_t(strlen(ip_address), 1), sizeof(char))) == SIZE_MAX)\n        {\n            LogError(\"invalid malloc size\");\n            destroy_network_interface_descriptions(result);\n            result = NULL;\n        }\n        else if ((result->ip_address = (char*)malloc(malloc_size)) == NULL)\n        {\n            LogError(\"failed setting the ip address (malloc failed)\");\n            destroy_network_interface_descriptions(result);\n            result = NULL;\n        }\n        else\n        {\n            strcpy(result->ip_address, ip_address);\n            result->next = NULL;\n\n            if (previous_nid != NULL)\n            {\n                previous_nid->next = result;\n            }\n        }\n    }\n\n    return result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/socketio_berkeley.c",
      "func_name": "socketio_CloneOption",
      "func_body": "static void* socketio_CloneOption(const char* name, const void* value)\n{\n    void* result;\n\n    if (name != NULL)\n    {\n        result = NULL;\n\n        if (strcmp(name, OPTION_NET_INT_MAC_ADDRESS) == 0)\n        {\n            if (value == NULL)\n            {\n                LogError(\"Failed cloning option %s (value is NULL)\", name);\n            }\n            else\n            {\n                size_t malloc_size = safe_add_size_t(strlen((char*)value), 1);\n                malloc_size = safe_multiply_size_t(malloc_size, sizeof(char));\n                if (malloc_size == SIZE_MAX)\n                {\n                    LogError(\"Invalid malloc size\");\n                }\n                else if ((result = malloc(malloc_size)) == NULL)\n                {\n                    LogError(\"Failed cloning option %s (malloc failed)\", name);\n                }\n                else\n                {\n                    strcpy((char *)result, (char *)value);\n                }\n            }\n        }\n        else\n        {\n            LogError(\"Cannot clone option %s (not suppported)\", name);\n        }\n    }\n    else\n    {\n        result = NULL;\n    }\n    return result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/socketio_berkeley.c",
      "func_name": "socketio_create",
      "func_body": "CONCRETE_IO_HANDLE socketio_create(void* io_create_parameters)\n{\n    SOCKETIO_CONFIG* socket_io_config = io_create_parameters;\n    SOCKET_IO_INSTANCE* result;\n\n    if (socket_io_config == NULL)\n    {\n        LogError(\"Invalid argument: socket_io_config is NULL\");\n        result = NULL;\n    }\n    else\n    {\n        result = malloc(sizeof(SOCKET_IO_INSTANCE));\n        if (result != NULL)\n        {\n            (void)memset(result, 0, sizeof(SOCKET_IO_INSTANCE));\n\n            result->address_type = ADDRESS_TYPE_IP;\n            result->pending_io_list = singlylinkedlist_create();\n            if (result->pending_io_list == NULL)\n            {\n                LogError(\"Failure: singlylinkedlist_create unable to create pending list.\");\n                destroy_socket_io_instance(result);\n                result = NULL;\n            }\n            else\n            {\n                if (socket_io_config->hostname != NULL)\n                {\n                    size_t malloc_size = safe_add_size_t(strlen(socket_io_config->hostname), 1);\n                    if (malloc_size == SIZE_MAX)\n                    {\n                        LogError(\"invalid malloc size\");\n                        result->hostname = NULL;\n                    }\n                    else\n                    {\n                        result->hostname = (char*)malloc(malloc_size);\n                        if (result->hostname != NULL)\n                        {\n                            (void)strcpy(result->hostname, socket_io_config->hostname);\n                        }\n                    }\n\n                    result->socket = INVALID_SOCKET;\n                }\n                else\n                {\n                    result->hostname = NULL;\n                    result->socket = *((int*)socket_io_config->accepted_socket);\n                }\n\n                if ((result->hostname == NULL) && (result->socket == INVALID_SOCKET))\n                {\n                    LogError(\"Failure: hostname == NULL and socket is invalid.\");\n                    destroy_socket_io_instance(result);\n                    result = NULL;\n                }\n                else\n                {\n                    result->port = socket_io_config->port;\n                    result->on_io_open_complete = NULL;\n                    result->dns_resolver = dns_resolver_create(result->hostname, socket_io_config->port, NULL);\n                    result->target_mac_address = NULL;\n                    result->on_bytes_received = NULL;\n                    result->on_io_error = NULL;\n                    result->on_bytes_received_context = NULL;\n                    result->on_io_error_context = NULL;\n                    result->io_state = IO_STATE_CLOSED;\n                }\n            }\n        }\n        else\n        {\n            LogError(\"Allocation Failure: SOCKET_IO_INSTANCE\");\n        }\n    }\n\n    return result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/socketio_berkeley.c",
      "func_name": "socketio_setoption",
      "func_body": "int socketio_setoption(CONCRETE_IO_HANDLE socket_io, const char* optionName, const void* value)\n{\n    int result;\n\n    if (socket_io == NULL ||\n        optionName == NULL ||\n        value == NULL)\n    {\n        result = MU_FAILURE;\n    }\n    else\n    {\n        SOCKET_IO_INSTANCE* socket_io_instance = (SOCKET_IO_INSTANCE*)socket_io;\n\n        if (strcmp(optionName, \"tcp_keepalive\") == 0)\n        {\n            result = setsockopt(socket_io_instance->socket, SOL_SOCKET, SO_KEEPALIVE, value, sizeof(int));\n            if (result == -1) result = errno;\n        }\n        else if (strcmp(optionName, \"tcp_keepalive_time\") == 0)\n        {\n#ifdef __APPLE__\n            result = setsockopt(socket_io_instance->socket, IPPROTO_TCP, TCP_KEEPALIVE, value, sizeof(int));\n#else\n            result = setsockopt(socket_io_instance->socket, SOL_TCP, TCP_KEEPIDLE, value, sizeof(int));\n#endif\n            if (result == -1) result = errno;\n        }\n        else if (strcmp(optionName, \"tcp_keepalive_interval\") == 0)\n        {\n            result = setsockopt(socket_io_instance->socket, SOL_TCP, TCP_KEEPINTVL, value, sizeof(int));\n            if (result == -1) result = errno;\n        }\n        else if (strcmp(optionName, OPTION_NET_INT_MAC_ADDRESS) == 0)\n        {\n#ifdef __APPLE__\n            LogError(\"option not supported.\");\n            result = MU_FAILURE;\n#else\n            size_t malloc_size;\n            if (strlen(value) == 0)\n            {\n                LogError(\"option value must be a valid mac address\");\n                result = MU_FAILURE;\n            }\n            else if ((malloc_size = safe_multiply_size_t(safe_add_size_t(strlen(value), 1), sizeof(char))) == SIZE_MAX)\n            {\n                LogError(\"invalid malloc size\");\n                result = MU_FAILURE;\n                socket_io_instance->target_mac_address = NULL;\n            }\n            else if ((socket_io_instance->target_mac_address = (char*)malloc(malloc_size)) == NULL)\n            {\n                LogError(\"failed setting net_interface_mac_address option (malloc failed)\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                strcpy(socket_io_instance->target_mac_address, value);\n                strtoup(socket_io_instance->target_mac_address);\n                result = 0;\n            }\n#endif\n        }\n        else if (strcmp(optionName, OPTION_ADDRESS_TYPE) == 0)\n        {\n            result = socketio_setaddresstype_option(socket_io_instance, (const char*)value);\n        }\n        else\n        {\n            result = MU_FAILURE;\n        }\n    }\n\n    return result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/socketio_win32.c",
      "func_name": "socketio_create",
      "func_body": "CONCRETE_IO_HANDLE socketio_create(void* io_create_parameters)\n{\n    SOCKETIO_CONFIG* socket_io_config = (SOCKETIO_CONFIG*)io_create_parameters;\n    SOCKET_IO_INSTANCE* result;\n    struct tcp_keepalive tcp_keepalive = { 0, 0, 0 };\n\n    if (socket_io_config == NULL)\n    {\n        LogError(\"Invalid argument: socket_io_config is NULL\");\n        result = NULL;\n    }\n    else\n    {\n        result = (SOCKET_IO_INSTANCE*)malloc(sizeof(SOCKET_IO_INSTANCE));\n\n        if (result != NULL)\n        {\n            (void)memset(result, 0, sizeof(SOCKET_IO_INSTANCE));\n\n            result->address_type = ADDRESS_TYPE_IP;\n            result->pending_io_list = singlylinkedlist_create();\n            if (result->pending_io_list == NULL)\n            {\n                LogError(\"Failure: singlylinkedlist_create unable to create pending list.\");\n                destroy_socket_io_instance(result);\n                result = NULL;\n            }\n            else\n            {\n                if (socket_io_config->hostname != NULL)\n                {\n                    size_t malloc_size = safe_add_size_t(strlen(socket_io_config->hostname), 1);\n                    if (malloc_size == SIZE_MAX)\n                    {\n                        LogError(\"Invalid malloc size\");\n                        result->hostname = NULL;\n                    }\n                    else\n                    {\n                        result->hostname = (char*)malloc(malloc_size);\n                        if (result->hostname != NULL)\n                        {\n                            (void)strcpy(result->hostname, socket_io_config->hostname);\n                        }\n                    }\n\n                    result->socket = INVALID_SOCKET;\n                }\n                else\n                {\n                    result->hostname = NULL;\n                    result->socket = *((SOCKET*)socket_io_config->accepted_socket);\n                }\n\n                if ((result->hostname == NULL) && (result->socket == INVALID_SOCKET))\n                {\n                    LogError(\"Failure: hostname == NULL and socket is invalid.\");\n                    destroy_socket_io_instance(result);\n                    result = NULL;\n                }\n                else if ((result->addrInfo = calloc(1, sizeof(struct addrinfo))) == NULL)\n                {\n                    LogError(\"Failure: addrInfo == NULL.\");\n                    destroy_socket_io_instance(result);\n                    result = NULL;\n                }\n                else\n                {\n                    result->port = socket_io_config->port;\n                    result->on_io_open_complete = NULL;\n                    result->dns_resolver = dns_resolver_create(result->hostname, socket_io_config->port, NULL);\n                    result->on_bytes_received = NULL;\n                    result->on_io_error = NULL;\n                    result->on_bytes_received_context = NULL;\n                    result->on_io_error_context = NULL;\n                    result->io_state = IO_STATE_CLOSED;\n                    result->keep_alive = tcp_keepalive;\n                }\n            }\n        }\n        else\n        {\n            LogError(\"Allocation Failure: SOCKET_IO_INSTANCE\");\n        }\n    }\n\n    return (XIO_HANDLE)result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/string_utils.c",
      "func_name": "IMPLEMENT_MOCKABLE_FUNCTION",
      "func_body": "IMPLEMENT_MOCKABLE_FUNCTION(, wchar_t*, vsprintf_wchar, const wchar_t*, format, va_list, va)\n{\n    wchar_t* result;\n    int neededSize = vswprintf(NULL, 0, format, va);\n    if (neededSize < 0)\n    {\n        LogError(\"failure in swprintf\");\n        result = NULL;\n    }\n    else\n    {\n        size_t malloc_size = safe_add_size_t((unsigned long long)neededSize, 1);\n        malloc_size = safe_multiply_size_t(malloc_size, sizeof(wchar_t));\n        if (malloc_size == SIZE_MAX)\n        {\n            LogError(\"invalid malloc size\");\n            result = NULL;\n            /*return as is*/\n        }\n        else if ((result = (wchar_t*)malloc(malloc_size)) == NULL)\n        {\n            LogError(\"failure in malloc\");\n            /*return as is*/\n        }\n        else\n        {\n            if (vswprintf(result, (unsigned long long)neededSize + 1, format, va) != neededSize)\n            {\n                LogError(\"inconsistent vswprintf behavior\");\n                free(result);\n                result = NULL;\n            }\n        }\n    }\n    return result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/tlsio_mbedtls.c",
      "func_name": "on_underlying_io_bytes_received",
      "func_body": "static void on_underlying_io_bytes_received(void *context, const unsigned char *buffer, size_t size)\n{\n    if (context != NULL)\n    {\n        unsigned char* new_socket_io_read_bytes;\n        TLS_IO_INSTANCE *tls_io_instance = (TLS_IO_INSTANCE *)context;\n\n        size_t realloc_size = safe_add_size_t(tls_io_instance->socket_io_read_byte_count, size);\n        if (realloc_size == SIZE_MAX)\n        {\n            LogError(\"Invalid realloc size\");\n            tls_io_instance->tlsio_state = TLSIO_STATE_ERROR;\n            indicate_error(tls_io_instance);\n        }\n        else if ((new_socket_io_read_bytes = (unsigned char*)realloc(tls_io_instance->socket_io_read_bytes, realloc_size)) == NULL)\n        {\n            LogError(\"realloc failed\");\n            tls_io_instance->tlsio_state = TLSIO_STATE_ERROR;\n            indicate_error(tls_io_instance);\n        }\n        else\n        {\n            tls_io_instance->socket_io_read_bytes = new_socket_io_read_bytes;\n            (void)memcpy(tls_io_instance->socket_io_read_bytes + tls_io_instance->socket_io_read_byte_count, buffer, size);\n            tls_io_instance->socket_io_read_byte_count += size;\n        }\n    }\n    else\n    {\n        LogError(\"NULL value passed in context\");\n    }\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/tlsio_openssl.c",
      "func_name": "openssl_static_locks_install",
      "func_body": "static int openssl_static_locks_install(void)\n{\n    int result;\n\n    if (openssl_locks != NULL)\n    {\n        LogInfo(\"Locks already initialized\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        size_t malloc_size = safe_multiply_size_t(CRYPTO_num_locks(), sizeof(LOCK_HANDLE));\n        if (malloc_size == SIZE_MAX ||\n            (openssl_locks = malloc(malloc_size)) == NULL)\n        {\n            LogError(\"Failed to allocate locks, size:%zu\", malloc_size);\n            result = MU_FAILURE;\n        }\n        else\n        {\n            int i;\n            for (i = 0; i < CRYPTO_num_locks(); i++)\n            {\n                openssl_locks[i] = Lock_Init();\n                if (openssl_locks[i] == NULL)\n                {\n                    LogError(\"Failed to allocate lock %d\", i);\n                    break;\n                }\n            }\n\n            if (i != CRYPTO_num_locks())\n            {\n                int j;\n                for (j = 0; j < i; j++)\n                {\n                    Lock_Deinit(openssl_locks[j]);\n                }\n                result = MU_FAILURE;\n            }\n            else\n            {\n                CRYPTO_set_locking_callback(openssl_static_locks_lock_unlock_cb);\n\n                result = 0;\n            }\n        }\n    }\n    return result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/tlsio_openssl.c",
      "func_name": "tlsio_openssl_setoption",
      "func_body": "int tlsio_openssl_setoption(CONCRETE_IO_HANDLE tls_io, const char* optionName, const void* value)\n{\n    int result;\n\n    if (tls_io == NULL || optionName == NULL)\n    {\n        result = MU_FAILURE;\n    }\n    else\n    {\n        TLS_IO_INSTANCE* tls_io_instance = (TLS_IO_INSTANCE*)tls_io;\n\n        if (strcmp(OPTION_TRUSTED_CERT, optionName) == 0)\n        {\n            const char* cert = (const char*)value;\n            size_t len;\n\n            if (tls_io_instance->certificate != NULL)\n            {\n                // Free the memory if it has been previously allocated\n                free(tls_io_instance->certificate);\n                tls_io_instance->certificate = NULL;\n            }\n\n            // Store the certificate\n            len = strlen(cert);\n            size_t malloc_size = safe_add_size_t(len, 1);\n            if (malloc_size == SIZE_MAX ||\n                (tls_io_instance->certificate = malloc(malloc_size)) == NULL)\n            {\n                LogError(\"malloc failure, size:%zu\", malloc_size);\n                result = MU_FAILURE;\n            }\n            else\n            {\n                strcpy(tls_io_instance->certificate, cert);\n                result = 0;\n            }\n\n            // If we're previously connected then add the cert to the context\n            if (tls_io_instance->ssl_context != NULL)\n            {\n                result = add_certificate_to_store(tls_io_instance, cert);\n            }\n        }\n        else if (strcmp(OPTION_OPENSSL_CIPHER_SUITE, optionName) == 0)\n        {\n            if (tls_io_instance->cipher_list != NULL)\n            {\n                // Free the memory if it has been previously allocated\n                free(tls_io_instance->cipher_list);\n                tls_io_instance->cipher_list = NULL;\n            }\n\n            // Store the cipher suites\n            if (mallocAndStrcpy_s((char**)&tls_io_instance->cipher_list, value) != 0)\n            {\n                LogError(\"unable to mallocAndStrcpy_s %s\", optionName);\n                result = MU_FAILURE;\n            }\n            else\n            {\n                result = 0;\n            }\n        }\n        else if (strcmp(SU_OPTION_X509_CERT, optionName) == 0 || strcmp(OPTION_X509_ECC_CERT, optionName) == 0)\n        {\n            if (tls_io_instance->x509_certificate != NULL)\n            {\n                LogError(\"unable to set x509 options more than once\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                /*let's make a copy of this option*/\n                if (mallocAndStrcpy_s((char**)&tls_io_instance->x509_certificate, value) != 0)\n                {\n                    LogError(\"unable to mallocAndStrcpy_s %s\", optionName);\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    result = 0;\n                }\n            }\n        }\n        else if (strcmp(SU_OPTION_X509_PRIVATE_KEY, optionName) == 0 || strcmp(OPTION_X509_ECC_KEY, optionName) == 0)\n        {\n            if (tls_io_instance->x509_private_key != NULL)\n            {\n                LogError(\"unable to set more than once x509 options\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                /*let's make a copy of this option*/\n                if (mallocAndStrcpy_s((char**)&tls_io_instance->x509_private_key, value) != 0)\n                {\n                    LogError(\"unable to mallocAndStrcpy_s %s\", optionName);\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    result = 0;\n                }\n            }\n        }\n        #ifndef OPENSSL_NO_ENGINE\n        else if (strcmp(OPTION_OPENSSL_ENGINE, optionName) == 0)\n        {\n            ENGINE_load_builtin_engines();\n\n            if (mallocAndStrcpy_s((char**)&tls_io_instance->engine_id, value) != 0)\n            {\n                LogError(\"unable to mallocAndStrcpy_s %s\", optionName);\n                result = MU_FAILURE;\n            }\n            else\n            {\n                result = 0;\n            }\n        }\n        #endif // OPENSSL_NO_ENGINE\n        else if (strcmp(OPTION_OPENSSL_PRIVATE_KEY_TYPE, optionName) == 0)\n        {\n            const OPTION_OPENSSL_KEY_TYPE type = *(const OPTION_OPENSSL_KEY_TYPE*)value;\n            switch (type)\n            {\n            case KEY_TYPE_DEFAULT:\n            case KEY_TYPE_ENGINE:\n                tls_io_instance->x509_private_key_type = type;\n                result = 0;\n                break;\n\n            default:\n                LogError(\"Unknown x509PrivatekeyType type %d\", type);\n                result = MU_FAILURE;\n            }\n        }\n        else if (strcmp(\"tls_validation_callback\", optionName) == 0)\n        {\n#ifdef WIN32\n#pragma warning(push)\n#pragma warning(disable:4055)\n#endif // WIN32\n            tls_io_instance->tls_validation_callback = (TLS_CERTIFICATE_VALIDATION_CALLBACK)value;\n#ifdef WIN32\n#pragma warning(pop)\n#endif // WIN32\n\n            if (tls_io_instance->ssl_context != NULL)\n            {\n                SSL_CTX_set_cert_verify_callback(tls_io_instance->ssl_context, tls_io_instance->tls_validation_callback, tls_io_instance->tls_validation_callback_data);\n            }\n\n            result = 0;\n        }\n        else if (strcmp(\"tls_validation_callback_data\", optionName) == 0)\n        {\n            tls_io_instance->tls_validation_callback_data = (void*)value;\n\n            if (tls_io_instance->ssl_context != NULL)\n            {\n                SSL_CTX_set_cert_verify_callback(tls_io_instance->ssl_context, tls_io_instance->tls_validation_callback, tls_io_instance->tls_validation_callback_data);\n            }\n\n            result = 0;\n        }\n        else if (strcmp(OPTION_TLS_VERSION, optionName) == 0)\n        {\n            if (tls_io_instance->ssl_context != NULL)\n            {\n                LogError(\"Unable to set the tls version after the tls connection is established\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                const int version_option = *(const int*)value;\n                if (version_option == 0 || version_option == 10)\n                {\n                    tls_io_instance->tls_version = VERSION_1_0;\n                }\n                else if (version_option == 11)\n                {\n                    tls_io_instance->tls_version = VERSION_1_1;\n                }\n                else if (version_option == 12)\n                {\n                    tls_io_instance->tls_version = VERSION_1_2;\n                }\n                else\n                {\n                    LogInfo(\"Value of TLS version option %d is not found shall default to version 1.2\", version_option);\n                    tls_io_instance->tls_version = VERSION_1_2;\n                }\n                result = 0;\n            }\n        }\n        else if (strcmp(optionName, OPTION_UNDERLYING_IO_OPTIONS) == 0)\n        {\n            if (OptionHandler_FeedOptions((OPTIONHANDLER_HANDLE)value, (void*)tls_io_instance->underlying_io) != OPTIONHANDLER_OK)\n            {\n                LogError(\"failed feeding options to underlying I/O instance\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                result = 0;\n            }\n        }\n        else if (strcmp(optionName, OPTION_SET_TLS_RENEGOTIATION) == 0)\n        {\n            // No need to do anything for Openssl\n            result = 0;\n        }\n        else if (strcmp(\"ignore_host_name_check\", optionName) == 0)\n        {\n            bool* server_name_check = (bool*)value;\n            tls_io_instance->ignore_host_name_check = *server_name_check;\n            result = 0;\n        }\n        else\n        {\n            if (tls_io_instance->underlying_io == NULL)\n            {\n                result = MU_FAILURE;\n            }\n            else\n            {\n                result = xio_setoption(tls_io_instance->underlying_io, optionName, value);\n            }\n        }\n    }\n\n    return result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/tlsio_schannel.c",
      "func_name": "send_chunk",
      "func_body": "static int send_chunk(CONCRETE_IO_HANDLE tls_io, const void* buffer, size_t size, ON_SEND_COMPLETE on_send_complete, void* callback_context)\n{\n    int result;\n\n    if ((tls_io == NULL) ||\n        (buffer == NULL) ||\n        (size == 0))\n    {\n        LogError(\"invalid argument detected: CONCRETE_IO_HANDLE tls_io = %p, const void* buffer = %p, size_t size = %lu\", tls_io, buffer, (unsigned long)size);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        TLS_IO_INSTANCE* tls_io_instance = (TLS_IO_INSTANCE*)tls_io;\n        if (tls_io_instance->tlsio_state != TLSIO_STATE_OPEN)\n        {\n            LogError(\"invalid tls_io_instance->tlsio_state: %\" PRI_MU_ENUM \"\", MU_ENUM_VALUE(TLSIO_STATE, tls_io_instance->tlsio_state));\n            result = MU_FAILURE;\n        }\n        else\n        {\n            SecPkgContext_StreamSizes  sizes;\n            SECURITY_STATUS status = QueryContextAttributes(&tls_io_instance->security_context, SECPKG_ATTR_STREAM_SIZES, &sizes);\n            if (status != SEC_E_OK)\n            {\n                LogError(\"QueryContextAttributes failed: %x\", status);\n                result = MU_FAILURE;\n            }\n            else\n            {\n                unsigned char* out_buffer;\n                SecBuffer security_buffers[4];\n                SecBufferDesc security_buffers_desc;\n                size_t needed_buffer = safe_add_size_t(sizes.cbHeader, size);\n                needed_buffer = safe_add_size_t(needed_buffer, sizes.cbTrailer);\n                if (needed_buffer == SIZE_MAX ||\n                    (out_buffer = (unsigned char*)malloc(needed_buffer)) == NULL)\n                {\n                    LogError(\"malloc failed, size:%zu\", needed_buffer);\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    (void)memcpy(out_buffer + sizes.cbHeader, buffer, size);\n\n                    security_buffers[0].BufferType = SECBUFFER_STREAM_HEADER;\n                    security_buffers[0].cbBuffer = sizes.cbHeader;\n                    security_buffers[0].pvBuffer = out_buffer;\n                    security_buffers[1].BufferType = SECBUFFER_DATA;\n                    security_buffers[1].cbBuffer = (unsigned long)size;\n                    security_buffers[1].pvBuffer = out_buffer + sizes.cbHeader;\n                    security_buffers[2].BufferType = SECBUFFER_STREAM_TRAILER;\n                    security_buffers[2].cbBuffer = sizes.cbTrailer;\n                    security_buffers[2].pvBuffer = out_buffer + sizes.cbHeader + size;\n                    security_buffers[3].cbBuffer = 0;\n                    security_buffers[3].BufferType = SECBUFFER_EMPTY;\n                    security_buffers[3].pvBuffer = 0;\n\n                    security_buffers_desc.cBuffers = sizeof(security_buffers) / sizeof(security_buffers[0]);\n                    security_buffers_desc.pBuffers = security_buffers;\n                    security_buffers_desc.ulVersion = SECBUFFER_VERSION;\n\n                    status = EncryptMessage(&tls_io_instance->security_context, 0, &security_buffers_desc, 0);\n                    if (FAILED(status))\n                    {\n                        LogError(\"EncryptMessage failed: %x\", status);\n                        result = MU_FAILURE;\n                    }\n                    else\n                    {\n                        if (xio_send(tls_io_instance->socket_io, out_buffer, (size_t)security_buffers[0].cbBuffer + (size_t)security_buffers[1].cbBuffer + (size_t)security_buffers[2].cbBuffer, on_send_complete, callback_context) != 0)\n                        {\n                            LogError(\"xio_send failed\");\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            result = 0;\n                        }\n                    }\n\n                    free(out_buffer);\n                }\n            }\n        }\n    }\n\n    return result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/tlsio_schannel.c",
      "func_name": "tlsio_schannel_create",
      "func_body": "CONCRETE_IO_HANDLE tlsio_schannel_create(void* io_create_parameters)\n{\n    TLSIO_CONFIG* tls_io_config = (TLSIO_CONFIG *) io_create_parameters;\n    TLS_IO_INSTANCE* result;\n\n    if (tls_io_config == NULL)\n    {\n        LogError(\"invalid argument detected: void* io_create_parameters = %p\", tls_io_config);\n        result = NULL;\n    }\n    else\n    {\n        result = (TLS_IO_INSTANCE*)malloc(sizeof(TLS_IO_INSTANCE));\n        if (result == NULL)\n        {\n            LogError(\"malloc failed\");\n        }\n        else\n        {\n            (void)memset(result, 0, sizeof(TLS_IO_INSTANCE));\n\n            size_t malloc_size = safe_add_size_t(strlen(tls_io_config->hostname), 1);\n            malloc_size = safe_multiply_size_t(malloc_size, sizeof(SEC_TCHAR));\n            if (malloc_size == SIZE_MAX ||\n                (result->host_name = (SEC_TCHAR*)malloc(malloc_size)) == NULL)\n            {\n                LogError(\"malloc failed, size:%zu\", malloc_size);\n                free(result);\n                result = NULL;\n            }\n            else\n            {\n                SOCKETIO_CONFIG socketio_config;\n                const IO_INTERFACE_DESCRIPTION* underlying_io_interface;\n                void* io_interface_parameters;\n\n                (void)strcpy(result->host_name, tls_io_config->hostname);\n\n                if (tls_io_config->underlying_io_interface != NULL)\n                {\n                    underlying_io_interface = tls_io_config->underlying_io_interface;\n                    io_interface_parameters = tls_io_config->underlying_io_parameters;\n                }\n                else\n                {\n                    socketio_config.hostname = tls_io_config->hostname;\n                    socketio_config.port = tls_io_config->port;\n                    socketio_config.accepted_socket = NULL;\n\n                    underlying_io_interface = socketio_get_interface_description();\n                    io_interface_parameters = &socketio_config;\n                }\n\n                if (underlying_io_interface == NULL)\n                {\n                    LogError(\"socketio_get_interface_description failed\");\n                    free(result->host_name);\n                    free(result);\n                    result = NULL;\n                }\n                else\n                {\n                    result->socket_io = xio_create(underlying_io_interface, io_interface_parameters);\n                    if (result->socket_io == NULL)\n                    {\n                        LogError(\"xio_create failed\");\n                        free(result->host_name);\n                        free(result);\n                        result = NULL;\n                    }\n                    else\n                    {\n                        result->pending_io_list = singlylinkedlist_create();\n                        if (result->pending_io_list == NULL)\n                        {\n                            LogError(\"Failed creating pending IO list.\");\n                            xio_destroy(result->socket_io);\n                            free(result->host_name);\n                            free(result);\n                            result = NULL;\n                        }\n                        else\n                        {\n                            result->received_bytes = NULL;\n                            result->received_byte_count = 0;\n                            result->buffer_size = 0;\n                            result->tlsio_state = TLSIO_STATE_NOT_OPEN;\n                            result->x509certificate = NULL;\n                            result->x509privatekey = NULL;\n                            result->x509_schannel_handle = NULL;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/tlsio_wolfssl.c",
      "func_name": "on_underlying_io_bytes_received",
      "func_body": "static void on_underlying_io_bytes_received(void* context, const unsigned char* buffer, size_t size)\n{\n    if (context != NULL)\n    {\n        TLS_IO_INSTANCE* tls_io_instance = (TLS_IO_INSTANCE*)context;\n        unsigned char* new_socket_io_read_bytes;\n\n        size_t realloc_size = safe_add_size_t(tls_io_instance->socket_io_read_byte_count, size);\n        if (realloc_size == SIZE_MAX ||\n            (new_socket_io_read_bytes = (unsigned char*)realloc(tls_io_instance->socket_io_read_bytes, realloc_size)) == NULL)\n        {\n            LogError(\"Failed allocating memory for received bytes, size:%zu\", realloc_size);\n            tls_io_instance->tlsio_state = TLSIO_STATE_ERROR;\n            indicate_error(tls_io_instance);\n        }\n        else\n        {\n            tls_io_instance->socket_io_read_bytes = new_socket_io_read_bytes;\n            (void)memcpy(tls_io_instance->socket_io_read_bytes + tls_io_instance->socket_io_read_byte_count, buffer, size);\n            tls_io_instance->socket_io_read_byte_count += size;\n        }\n    }\n    else\n    {\n        LogInfo(\"Supplied context is NULL on bytes_received\");\n    }\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "adapters/x509_schannel.c",
      "func_name": "set_ecc_certificate_info",
      "func_body": "static int set_ecc_certificate_info(X509_SCHANNEL_HANDLE_DATA* x509_handle, unsigned char* x509privatekeyBlob)\n{\n    int result;\n#if _MSC_VER > 1500\n    BCRYPT_ECCKEY_BLOB* pKeyBlob;\n    SECURITY_STATUS status;\n    CRYPT_BIT_BLOB* pPubKeyBlob = &x509_handle->x509certificate_context->pCertInfo->SubjectPublicKeyInfo.PublicKey;\n    CRYPT_ECC_PRIVATE_KEY_INFO* pPrivKeyInfo = (CRYPT_ECC_PRIVATE_KEY_INFO*)x509privatekeyBlob;\n    DWORD pubSize = pPubKeyBlob->cbData - 1;\n    DWORD privSize = pPrivKeyInfo->PrivateKey.cbData;\n    size_t keyBlobSize = safe_add_size_t(safe_add_size_t(sizeof(BCRYPT_ECCKEY_BLOB), pubSize), privSize);\n    BYTE* pubKeyBuf = pPubKeyBlob->pbData + 1;\n    BYTE* privKeyBuf = pPrivKeyInfo->PrivateKey.pbData;\n\n    if (keyBlobSize == SIZE_MAX ||\n        (pKeyBlob = (BCRYPT_ECCKEY_BLOB*)malloc(keyBlobSize)) == NULL)\n    {\n        /*Codes_SRS_X509_SCHANNEL_02_010: [ Otherwise, x509_schannel_create shall fail and return a NULL X509_SCHANNEL_HANDLE. ]*/\n        LogError(\"Failed to malloc NCrypt private key blob, size:%zu\", keyBlobSize);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        pKeyBlob->dwMagic = privSize == ECC_256_MAGIC_NUMBER ? BCRYPT_ECDSA_PRIVATE_P256_MAGIC\n            : privSize == ECC_384_MAGIC_NUMBER ? BCRYPT_ECDSA_PRIVATE_P384_MAGIC\n            : BCRYPT_ECDSA_PRIVATE_P521_MAGIC;\n        pKeyBlob->cbKey = privSize;\n        memcpy((BYTE*)(pKeyBlob + 1), pubKeyBuf, pubSize);\n        memcpy((BYTE*)(pKeyBlob + 1) + pubSize, privKeyBuf, privSize);\n\n        /* Codes_SRS_X509_SCHANNEL_02_005: [ x509_schannel_create shall call CryptAcquireContext. ] */\n        /* at this moment, both the private key and the certificate are decoded for further usage */\n        /* NOTE: As no WinCrypt key storage provider supports ECC keys, NCrypt is used instead */\n        status = NCryptOpenStorageProvider(&x509_handle->hProv, MS_KEY_STORAGE_PROVIDER, 0);\n        if (status != ERROR_SUCCESS)\n        {\n            /* Codes_SRS_X509_SCHANNEL_02_010: [ Otherwise, x509_schannel_create shall fail and return a NULL X509_SCHANNEL_HANDLE. ]*/\n            LogError(\"NCryptOpenStorageProvider failed with error 0x%08X\", status);\n            result = MU_FAILURE;\n        }\n        else\n        {\n            SECURITY_STATUS status2;\n            NCryptBuffer ncBuf = { sizeof(KEY_NAME), NCRYPTBUFFER_PKCS_KEY_NAME, KEY_NAME };\n            NCryptBufferDesc ncBufDesc;\n            ncBufDesc.ulVersion = 0;\n            ncBufDesc.cBuffers = 1;\n            ncBufDesc.pBuffers = &ncBuf;\n\n            CRYPT_KEY_PROV_INFO keyProvInfo = { KEY_NAME, MS_KEY_STORAGE_PROVIDER, 0, 0, 0, NULL, 0 };\n\n            /*Codes_SRS_X509_SCHANNEL_02_006: [ x509_schannel_create shall import the private key by calling CryptImportKey. ] */\n            /*NOTE: As no WinCrypt key storage provider supports ECC keys, NCrypt is used instead*/\n            status = NCryptImportKey(x509_handle->hProv, 0, BCRYPT_ECCPRIVATE_BLOB, &ncBufDesc, &x509_handle->x509hcryptkey, (BYTE*)pKeyBlob, (DWORD)keyBlobSize, NCRYPT_OVERWRITE_KEY_FLAG);\n            if (status == ERROR_SUCCESS)\n            {\n                status2 = NCryptFreeObject(x509_handle->x509hcryptkey);\n                if (status2 != ERROR_SUCCESS)\n                {\n                    LogError(\"NCryptFreeObject for key handle failed with error 0x%08X\", status2);\n                }\n                else\n                {\n                    x509_handle->x509hcryptkey = 0;\n                }\n            }\n\n            status2 = NCryptFreeObject(x509_handle->hProv);\n            if (status2 != ERROR_SUCCESS)\n            {\n                LogError(\"NCryptFreeObject for provider handle failed with error 0x%08X\", status2);\n            }\n            else\n            {\n                x509_handle->hProv = 0;\n            }\n\n            if (status != ERROR_SUCCESS)\n            {\n                /*Codes_SRS_X509_SCHANNEL_02_010: [ Otherwise, x509_schannel_create shall fail and return a NULL X509_SCHANNEL_HANDLE. ]*/\n                LogError(\"NCryptImportKey failed with error 0x%08X\", status);\n                result = MU_FAILURE;\n            }\n            else if (!CertSetCertificateContextProperty(x509_handle->x509certificate_context, CERT_KEY_PROV_INFO_PROP_ID, 0, &keyProvInfo))\n            {\n                /*Codes_SRS_X509_SCHANNEL_02_010: [ Otherwise, x509_schannel_create shall fail and return a NULL X509_SCHANNEL_HANDLE. ]*/\n                LogErrorWinHTTPWithGetLastErrorAsString(\"CertSetCertificateContextProperty failed to set NCrypt key handle property\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                result = 0;\n            }\n        }\n        free(pKeyBlob);\n    }\n#else\n    (void)x509_handle;\n    (void)x509privatekeyBlob;\n    LogError(\"SChannel ECC is not supported in this compliation\");\n    result = MU_FAILURE;\n#endif\n    return result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "src/buffer.c",
      "func_name": "BUFFER_append",
      "func_body": "int BUFFER_append(BUFFER_HANDLE handle1, BUFFER_HANDLE handle2)\n{\n    int result;\n    if ( (handle1 == NULL) || (handle2 == NULL) || (handle1 == handle2) )\n    {\n        /* Codes_SRS_BUFFER_07_023: [BUFFER_append shall return a nonzero upon any error that is encountered.] */\n        result = MU_FAILURE;\n    }\n    else\n    {\n        BUFFER* b1 = (BUFFER*)handle1;\n        BUFFER* b2 = (BUFFER*)handle2;\n        if (b1->buffer == NULL)\n        {\n            /* Codes_SRS_BUFFER_07_023: [BUFFER_append shall return a nonzero upon any error that is encountered.] */\n            result = MU_FAILURE;\n        }\n        else if (b2->buffer == NULL)\n        {\n            /* Codes_SRS_BUFFER_07_023: [BUFFER_append shall return a nonzero upon any error that is encountered.] */\n            result = MU_FAILURE;\n        }\n        else\n        {\n            if (b2->size ==0)\n            {\n                // b2->size = 0, whatever b1->size is, do nothing\n                result = 0;\n            }\n            else\n            {\n                // b2->size != 0, whatever b1->size is\n                unsigned char* temp;\n                size_t malloc_size = safe_add_size_t(b1->size, b2->size);\n                if (malloc_size == SIZE_MAX || \n                    (temp = (unsigned char*)realloc(b1->buffer, malloc_size)) == NULL)\n                {\n                    /* Codes_SRS_BUFFER_07_023: [BUFFER_append shall return a nonzero upon any error that is encountered.] */\n                    LogError(\"Failure: allocating temp buffer.\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    /* Codes_SRS_BUFFER_07_024: [BUFFER_append concatenates b2 onto b1 without modifying b2 and shall return zero on success.]*/\n                    b1->buffer = temp;\n                    // Append the BUFFER\n                    (void)memcpy(&b1->buffer[b1->size], b2->buffer, b2->size);\n                    b1->size += b2->size;\n                    result = 0;\n                }\n            }\n        }\n    }\n    return result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "src/buffer.c",
      "func_name": "BUFFER_append_build",
      "func_body": "int BUFFER_append_build(BUFFER_HANDLE handle, const unsigned char* source, size_t size)\n{\n    int result;\n    if (handle == NULL || source == NULL || size == 0)\n    {\n        /* Codes_SRS_BUFFER_07_029: [ BUFFER_append_build shall return nonzero if handle or source are NULL or if size is 0. ] */\n        LogError(\"BUFFER_append_build failed invalid parameter handle: %p, source: %p, size: %lu\", handle, source, (unsigned long)size);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        if (handle->buffer == NULL)\n        {\n            /* Codes_SRS_BUFFER_07_030: [ if handle->buffer is NULL BUFFER_append_build shall allocate the a buffer of size bytes... ] */\n            if (BUFFER_safemalloc(handle, size) != 0 || handle->buffer == NULL)\n            {\n                /* Codes_SRS_BUFFER_07_035: [ If any error is encountered BUFFER_append_build shall return a non-null value. ] */\n                LogError(\"Failure with BUFFER_safemalloc\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                /* Codes_SRS_BUFFER_07_031: [ ... and copy the contents of source to handle->buffer. ] */\n                (void)memcpy(handle->buffer, source, size);\n                /* Codes_SRS_BUFFER_07_034: [ On success BUFFER_append_build shall return 0 ] */\n                result = 0;\n            }\n        }\n        else\n        {\n            /* Codes_SRS_BUFFER_07_032: [ if handle->buffer is not NULL BUFFER_append_build shall realloc the buffer to be the handle->size + size ] */\n            unsigned char* temp;\n            size_t malloc_size = safe_add_size_t(handle->size, size);\n            if (malloc_size == SIZE_MAX || \n                (temp = (unsigned char*)realloc(handle->buffer, malloc_size)) == NULL)\n            {\n                /* Codes_SRS_BUFFER_07_035: [ If any error is encountered BUFFER_append_build shall return a non-null value. ] */\n                LogError(\"Failure reallocating temporary buffer, size:%zu\", malloc_size);\n                result = MU_FAILURE;\n            }\n            else\n            {\n                /* Codes_SRS_BUFFER_07_033: [ ... and copy the contents of source to the end of the buffer. ] */\n                handle->buffer = temp;\n                // Append the BUFFER\n                (void)memcpy(&handle->buffer[handle->size], source, size);\n                handle->size += size;\n                /* Codes_SRS_BUFFER_07_034: [ On success BUFFER_append_build shall return 0 ] */\n                result = 0;\n            }\n        }\n    }\n    return result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "src/buffer.c",
      "func_name": "BUFFER_enlarge",
      "func_body": "int BUFFER_enlarge(BUFFER_HANDLE handle, size_t enlargeSize)\n{\n    int result;\n    if (handle == NULL)\n    {\n        /* Codes_SRS_BUFFER_07_017: [BUFFER_enlarge shall return a nonzero result if any parameters are NULL or zero.] */\n        LogError(\"Failure: handle is invalid.\");\n        result = MU_FAILURE;\n    }\n    else if (enlargeSize == 0)\n    {\n        /* Codes_SRS_BUFFER_07_017: [BUFFER_enlarge shall return a nonzero result if any parameters are NULL or zero.] */\n        LogError(\"Failure: enlargeSize size is 0.\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        unsigned char* temp;\n        BUFFER* b = (BUFFER*)handle;\n        size_t malloc_size = safe_add_size_t(b->size, enlargeSize);\n        if (malloc_size == SIZE_MAX ||\n            (temp = (unsigned char*)realloc(b->buffer, malloc_size)) == NULL)\n        {\n            /* Codes_SRS_BUFFER_07_018: [BUFFER_enlarge shall return a nonzero result if any error is encountered.] */\n            LogError(\"Failure: allocating temp buffer, size:%zu\", malloc_size);\n            result = MU_FAILURE;\n        }\n        else\n        {\n            b->buffer = temp;\n            b->size += enlargeSize;\n            result = 0;\n        }\n    }\n    return result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "azure-c-shared-utility",
      "filepath": "src/constbuffer.c",
      "func_name": "CONSTBUFFER_Create_Internal",
      "func_body": "static CONSTBUFFER_HANDLE CONSTBUFFER_Create_Internal(const unsigned char* source, size_t size)\n{\n    CONSTBUFFER_HANDLE result;\n    /*Codes_SRS_CONSTBUFFER_02_005: [The non-NULL handle returned by CONSTBUFFER_Create shall have its ref count set to \"1\".]*/\n    /*Codes_SRS_CONSTBUFFER_02_010: [The non-NULL handle returned by CONSTBUFFER_CreateFromBuffer shall have its ref count set to \"1\".]*/\n    size_t malloc_size = sizeof(CONSTBUFFER_HANDLE_DATA) + size;\n    if (malloc_size < size)\n    {\n        result = NULL;\n        LogError(\"invalid size parameter\");\n        /*return as is*/\n    }\n    else\n    {\n        result = (CONSTBUFFER_HANDLE)calloc(1, malloc_size);\n    }\n\n    if (result == NULL)\n    {\n        /*Codes_SRS_CONSTBUFFER_02_003: [If creating the copy fails then CONSTBUFFER_Create shall return NULL.]*/\n        /*Codes_SRS_CONSTBUFFER_02_008: [If copying the content fails, then CONSTBUFFER_CreateFromBuffer shall fail and return NULL.] */\n        LogError(\"unable to malloc\");\n        /*return as is*/\n    }\n    else\n    {\n        INIT_REF_VAR(result->count);\n\n        /*Codes_SRS_CONSTBUFFER_02_002: [Otherwise, CONSTBUFFER_Create shall create a copy of the memory area pointed to by source having size bytes.]*/\n        result->alias.size = size;\n        if (size == 0)\n        {\n            result->alias.buffer = NULL;\n        }\n        else\n        {\n            unsigned char* temp = (unsigned char*)(result + 1);\n            /*Codes_SRS_CONSTBUFFER_02_004: [Otherwise CONSTBUFFER_Create shall return a non-NULL handle.]*/\n            /*Codes_SRS_CONSTBUFFER_02_007: [Otherwise, CONSTBUFFER_CreateFromBuffer shall copy the content of buffer.]*/\n            /*Codes_SRS_CONSTBUFFER_02_009: [Otherwise, CONSTBUFFER_CreateFromBuffer shall return a non-NULL handle.]*/\n            (void)memcpy(temp, source, size);\n            result->alias.buffer = temp;\n        }\n\n        result->buffer_type = CONSTBUFFER_TYPE_COPIED;\n    }\n    return result;\n}",
      "cve_list": [
        "CVE-2024-29195"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "anope",
      "filepath": "modules/commands/ns_resetpass.cpp",
      "func_name": "CommandNSResetPass::Execute",
      "func_body": "\tvoid Execute(CommandSource &source, const std::vector<Anope::string> &params) anope_override\n\t{\n\t\tconst NickAlias *na;\n\n\t\tif (!(na = NickAlias::Find(params[0])))\n\t\t\tsource.Reply(NICK_X_NOT_REGISTERED, params[0].c_str());\n\t\telse if (na->nc->HasExt(\"NS_SUSPENDED\"))\n\t\t\tsource.Reply(NICK_X_SUSPENDED, na->nc->display.c_str());\n\t\telse if (!na->nc->email.equals_ci(params[1]))\n\t\t\tsource.Reply(_(\"Incorrect email address.\"));\n\t\telse\n\t\t{\n\t\t\tif (SendResetEmail(source.GetUser(), na, source.service))\n\t\t\t{\n\t\t\t\tLog(LOG_COMMAND, source, this) << \"for \" << na->nick << \" (group: \" << na->nc->display << \")\";\n\t\t\t\tsource.Reply(_(\"Password reset email for \\002%s\\002 has been sent.\"), na->nick.c_str());\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}",
      "cve_list": [
        "CVE-2024-30187"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "anope",
      "filepath": "modules/commands/ns_resetpass.cpp",
      "func_name": "NSResetPass::OnPreCommand",
      "func_body": "\tEventReturn OnPreCommand(CommandSource &source, Command *command, std::vector<Anope::string> &params) anope_override\n\t{\n\t\tif (command->name == \"nickserv/confirm\" && params.size() > 1)\n\t\t{\n\t\t\tif (Anope::ReadOnly)\n\t\t\t{\n\t\t\t\tsource.Reply(READ_ONLY_MODE);\n\t\t\t\treturn EVENT_STOP;\n\t\t\t}\n\n\t\t\tNickAlias *na = NickAlias::Find(params[0]);\n\n\t\t\tResetInfo *ri = na ? reset.Get(na->nc) : NULL;\n\t\t\tif (na && ri)\n\t\t\t{\n\t\t\t\tNickCore *nc = na->nc;\n\t\t\t\tif (nc->HasExt(\"NS_SUSPENDED\"))\n\t\t\t\t{\n\t\t\t\t\tsource.Reply(NICK_X_SUSPENDED, nc->display.c_str());\n\t\t\t\t\treturn EVENT_STOP;\n\t\t\t\t}\n\n\t\t\t\tconst Anope::string &passcode = params[1];\n\t\t\t\tif (ri->time < Anope::CurTime - 3600)\n\t\t\t\t{\n\t\t\t\t\treset.Unset(nc);\n\t\t\t\t\tsource.Reply(_(\"Your password reset request has expired.\"));\n\t\t\t\t}\n\t\t\t\telse if (passcode.equals_cs(ri->code))\n\t\t\t\t{\n\t\t\t\t\treset.Unset(nc);\n\t\t\t\t\tnc->Shrink<bool>(\"UNCONFIRMED\");\n\n\t\t\t\t\tLog(LOG_COMMAND, source, &commandnsresetpass) << \"to confirm RESETPASS and forcefully identify as \" << na->nick;\n\n\t\t\t\t\tif (source.GetUser())\n\t\t\t\t\t{\n\t\t\t\t\t\tsource.GetUser()->Identify(na);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tsource.Reply(_(\"You are now identified for your nick. Change your password now.\"));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn EVENT_CONTINUE;\n\n\t\t\t\treturn EVENT_STOP;\n\t\t\t}\n\t\t}\n\n\t\treturn EVENT_CONTINUE;\n\t}",
      "cve_list": [
        "CVE-2024-30187"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "Sunshine",
      "filepath": "src/crypto.cpp",
      "func_name": "crypto::cert_chain_t::clear",
      "func_body": "  cert_chain_t::clear() {\n    _certs.clear();\n  }",
      "cve_list": [
        "CVE-2024-31221"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "Sunshine",
      "filepath": "src/nvhttp.cpp",
      "func_name": "nvhttp::erase_all_clients",
      "func_body": "  erase_all_clients() {\n    map_id_client.clear();\n    cert_chain.clear();\n    save_state();\n  }",
      "cve_list": [
        "CVE-2024-31221"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "Sunshine",
      "filepath": "src/nvhttp.cpp",
      "func_name": "nvhttp::start",
      "func_body": "  start() {\n    auto shutdown_event = mail::man->event<bool>(mail::shutdown);\n\n    auto port_http = net::map_port(PORT_HTTP);\n    auto port_https = net::map_port(PORT_HTTPS);\n    auto address_family = net::af_from_enum_string(config::sunshine.address_family);\n\n    bool clean_slate = config::sunshine.flags[config::flag::FRESH_STATE];\n\n    if (!clean_slate) {\n      load_state();\n    }\n\n    conf_intern.pkey = file_handler::read_file(config::nvhttp.pkey.c_str());\n    conf_intern.servercert = file_handler::read_file(config::nvhttp.cert.c_str());\n\n    for (auto &[_, client] : map_id_client) {\n      for (auto &cert : client.certs) {\n        cert_chain.add(crypto::x509(cert));\n      }\n    }\n\n    auto add_cert = std::make_shared<safe::queue_t<crypto::x509_t>>(30);\n\n    // resume doesn't always get the parameter \"localAudioPlayMode\"\n    // launch will store it in host_audio\n    bool host_audio {};\n\n    https_server_t https_server { config::nvhttp.cert, config::nvhttp.pkey };\n    http_server_t http_server;\n\n    // Verify certificates after establishing connection\n    https_server.verify = [add_cert](SSL *ssl) {\n      crypto::x509_t x509 { SSL_get_peer_certificate(ssl) };\n      if (!x509) {\n        BOOST_LOG(info) << \"unknown -- denied\"sv;\n        return 0;\n      }\n\n      int verified = 0;\n\n      auto fg = util::fail_guard([&]() {\n        char subject_name[256];\n\n        X509_NAME_oneline(X509_get_subject_name(x509.get()), subject_name, sizeof(subject_name));\n\n        BOOST_LOG(debug) << subject_name << \" -- \"sv << (verified ? \"verified\"sv : \"denied\"sv);\n      });\n\n      while (add_cert->peek()) {\n        char subject_name[256];\n\n        auto cert = add_cert->pop();\n        X509_NAME_oneline(X509_get_subject_name(cert.get()), subject_name, sizeof(subject_name));\n\n        BOOST_LOG(debug) << \"Added cert [\"sv << subject_name << ']';\n        cert_chain.add(std::move(cert));\n      }\n\n      auto err_str = cert_chain.verify(x509.get());\n      if (err_str) {\n        BOOST_LOG(warning) << \"SSL Verification error :: \"sv << err_str;\n\n        return verified;\n      }\n\n      verified = 1;\n\n      return verified;\n    };\n\n    https_server.on_verify_failed = [](resp_https_t resp, req_https_t req) {\n      pt::ptree tree;\n      auto g = util::fail_guard([&]() {\n        std::ostringstream data;\n\n        pt::write_xml(data, tree);\n        resp->write(data.str());\n        resp->close_connection_after_response = true;\n      });\n\n      tree.put(\"root.<xmlattr>.status_code\"s, 401);\n      tree.put(\"root.<xmlattr>.query\"s, req->path);\n      tree.put(\"root.<xmlattr>.status_message\"s, \"The client is not authorized. Certificate verification failed.\"s);\n    };\n\n    https_server.default_resource[\"GET\"] = not_found<SimpleWeb::HTTPS>;\n    https_server.resource[\"^/serverinfo$\"][\"GET\"] = serverinfo<SimpleWeb::HTTPS>;\n    https_server.resource[\"^/pair$\"][\"GET\"] = [&add_cert](auto resp, auto req) { pair<SimpleWeb::HTTPS>(add_cert, resp, req); };\n    https_server.resource[\"^/applist$\"][\"GET\"] = applist;\n    https_server.resource[\"^/appasset$\"][\"GET\"] = appasset;\n    https_server.resource[\"^/launch$\"][\"GET\"] = [&host_audio](auto resp, auto req) { launch(host_audio, resp, req); };\n    https_server.resource[\"^/resume$\"][\"GET\"] = [&host_audio](auto resp, auto req) { resume(host_audio, resp, req); };\n    https_server.resource[\"^/cancel$\"][\"GET\"] = cancel;\n\n    https_server.config.reuse_address = true;\n    https_server.config.address = net::af_to_any_address_string(address_family);\n    https_server.config.port = port_https;\n\n    http_server.default_resource[\"GET\"] = not_found<SimpleWeb::HTTP>;\n    http_server.resource[\"^/serverinfo$\"][\"GET\"] = serverinfo<SimpleWeb::HTTP>;\n    http_server.resource[\"^/pair$\"][\"GET\"] = [&add_cert](auto resp, auto req) { pair<SimpleWeb::HTTP>(add_cert, resp, req); };\n\n    http_server.config.reuse_address = true;\n    http_server.config.address = net::af_to_any_address_string(address_family);\n    http_server.config.port = port_http;\n\n    auto accept_and_run = [&](auto *http_server) {\n      try {\n        http_server->start();\n      }\n      catch (boost::system::system_error &err) {\n        // It's possible the exception gets thrown after calling http_server->stop() from a different thread\n        if (shutdown_event->peek()) {\n          return;\n        }\n\n        BOOST_LOG(fatal) << \"Couldn't start http server on ports [\"sv << port_https << \", \"sv << port_https << \"]: \"sv << err.what();\n        shutdown_event->raise(true);\n        return;\n      }\n    };\n    std::thread ssl { accept_and_run, &https_server };\n    std::thread tcp { accept_and_run, &http_server };\n\n    // Wait for any event\n    shutdown_event->view();\n\n    https_server.stop();\n    http_server.stop();\n\n    ssl.join();\n    tcp.join();\n  }",
      "cve_list": [
        "CVE-2024-31221"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "Sunshine",
      "filepath": "tools/sunshinesvc.cpp",
      "func_name": "RunTerminationHelper",
      "func_body": "RunTerminationHelper(HANDLE console_token, DWORD pid) {\n  WCHAR module_path[MAX_PATH];\n  GetModuleFileNameW(NULL, module_path, _countof(module_path));\n  std::wstring command;\n\n  command += L'\"';\n  command += module_path;\n  command += L'\"';\n  command += L\" --terminate \" + std::to_wstring(pid);\n\n  STARTUPINFOW startup_info = {};\n  startup_info.cb = sizeof(startup_info);\n  startup_info.lpDesktop = (LPWSTR) L\"winsta0\\\\default\";\n\n  // Execute ourselves as a detached process in the user session with the --terminate argument.\n  // This will allow us to attach to Sunshine's console and send it a Ctrl-C event.\n  PROCESS_INFORMATION process_info;\n  if (!CreateProcessAsUserW(console_token,\n        module_path,\n        (LPWSTR) command.c_str(),\n        NULL,\n        NULL,\n        FALSE,\n        CREATE_UNICODE_ENVIRONMENT | DETACHED_PROCESS,\n        NULL,\n        NULL,\n        &startup_info,\n        &process_info)) {\n    return false;\n  }\n\n  // Wait for the termination helper to complete\n  WaitForSingleObject(process_info.hProcess, INFINITE);\n\n  // Check the exit status of the helper process\n  DWORD exit_code;\n  GetExitCodeProcess(process_info.hProcess, &exit_code);\n\n  // Cleanup handles\n  CloseHandle(process_info.hProcess);\n  CloseHandle(process_info.hThread);\n\n  // If the helper process returned 0, it succeeded\n  return exit_code == 0;\n}",
      "cve_list": [
        "CVE-2024-31226"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "FFmpeg",
      "filepath": "libavcodec/cbs_h266_syntax_template.c",
      "func_name": "FUNC( pps)",
      "func_body": "static int FUNC(pps) (CodedBitstreamContext *ctx, RWContext *rw,\n                      H266RawPPS *current)\n{\n    CodedBitstreamH266Context *h266 = ctx->priv_data;\n    const H266RawSPS *sps;\n    int err, i;\n    unsigned int min_cb_size_y, divisor, ctb_size_y,\n        pic_width_in_ctbs_y, pic_height_in_ctbs_y;\n    uint8_t sub_width_c, sub_height_c, qp_bd_offset;\n\n    static const uint8_t h266_sub_width_c[] = {\n        1, 2, 2, 1\n    };\n    static const uint8_t h266_sub_height_c[] = {\n        1, 2, 1, 1\n    };\n\n    HEADER(\"Picture Parameter Set\");\n\n    CHECK(FUNC(nal_unit_header) (ctx, rw,\n                                 &current->nal_unit_header, VVC_PPS_NUT));\n\n    ub(6, pps_pic_parameter_set_id);\n    ub(4, pps_seq_parameter_set_id);\n    sps = h266->sps[current->pps_seq_parameter_set_id];\n    if (!sps) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"SPS id %d not available.\\n\",\n               current->pps_seq_parameter_set_id);\n        return AVERROR_INVALIDDATA;\n    }\n\n    flag(pps_mixed_nalu_types_in_pic_flag);\n    ue(pps_pic_width_in_luma_samples,\n       1, sps->sps_pic_width_max_in_luma_samples);\n    ue(pps_pic_height_in_luma_samples,\n       1, sps->sps_pic_height_max_in_luma_samples);\n\n    min_cb_size_y = 1 << (sps->sps_log2_min_luma_coding_block_size_minus2 + 2);\n    divisor = FFMAX(min_cb_size_y, 8);\n    if (current->pps_pic_width_in_luma_samples % divisor ||\n        current->pps_pic_height_in_luma_samples % divisor) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR,\n               \"Invalid dimensions: %ux%u not divisible \"\n               \"by %u, MinCbSizeY = %u.\\n\",\n               current->pps_pic_width_in_luma_samples,\n               current->pps_pic_height_in_luma_samples, divisor, min_cb_size_y);\n        return AVERROR_INVALIDDATA;\n    }\n    if (!sps->sps_res_change_in_clvs_allowed_flag &&\n        (current->pps_pic_width_in_luma_samples !=\n         sps->sps_pic_width_max_in_luma_samples ||\n         current->pps_pic_height_in_luma_samples !=\n         sps->sps_pic_height_max_in_luma_samples)) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR,\n               \"Resoltuion change is not allowed, \"\n               \"in max resolution (%ux%u) mismatched with pps(%ux%u).\\n\",\n               sps->sps_pic_width_max_in_luma_samples,\n               sps->sps_pic_height_max_in_luma_samples,\n               current->pps_pic_width_in_luma_samples,\n               current->pps_pic_height_in_luma_samples);\n        return AVERROR_INVALIDDATA;\n    }\n\n    ctb_size_y = 1 << (sps->sps_log2_ctu_size_minus5 + 5);\n    if (sps->sps_ref_wraparound_enabled_flag) {\n        if ((ctb_size_y / min_cb_size_y + 1) >\n            (current->pps_pic_width_in_luma_samples / min_cb_size_y - 1)) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR,\n                   \"Invalid width(%u), ctb_size_y = %u, min_cb_size_y = %u.\\n\",\n                   current->pps_pic_width_in_luma_samples,\n                   ctb_size_y, min_cb_size_y);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    flag(pps_conformance_window_flag);\n    if (current->pps_pic_width_in_luma_samples ==\n        sps->sps_pic_width_max_in_luma_samples &&\n        current->pps_pic_height_in_luma_samples ==\n        sps->sps_pic_height_max_in_luma_samples &&\n        current->pps_conformance_window_flag) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR,\n               \"Conformance window flag should not true.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    sub_width_c = h266_sub_width_c[sps->sps_chroma_format_idc];\n    sub_height_c = h266_sub_height_c[sps->sps_chroma_format_idc];\n    if (current->pps_conformance_window_flag) {\n        ue(pps_conf_win_left_offset, 0, current->pps_pic_width_in_luma_samples);\n        ue(pps_conf_win_right_offset,\n           0, current->pps_pic_width_in_luma_samples);\n        ue(pps_conf_win_top_offset, 0, current->pps_pic_height_in_luma_samples);\n        ue(pps_conf_win_bottom_offset,\n           0, current->pps_pic_height_in_luma_samples);\n        if (sub_width_c *\n            (current->pps_conf_win_left_offset +\n             current->pps_conf_win_right_offset) >=\n            current->pps_pic_width_in_luma_samples ||\n            sub_height_c *\n            (current->pps_conf_win_top_offset +\n             current->pps_conf_win_bottom_offset) >=\n            current->pps_pic_height_in_luma_samples) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR,\n                   \"Invalid pps conformance window: (%u, %u, %u, %u), \"\n                   \"resolution is %ux%u, sub wxh is %ux%u.\\n\",\n                   current->pps_conf_win_left_offset,\n                   current->pps_conf_win_right_offset,\n                   current->pps_conf_win_top_offset,\n                   current->pps_conf_win_bottom_offset,\n                   current->pps_pic_width_in_luma_samples,\n                   current->pps_pic_height_in_luma_samples,\n                   sub_width_c, sub_height_c);\n            return AVERROR_INVALIDDATA;\n        }\n    } else {\n        if (current->pps_pic_width_in_luma_samples ==\n            sps->sps_pic_width_max_in_luma_samples &&\n            current->pps_pic_height_in_luma_samples ==\n            sps->sps_pic_height_max_in_luma_samples) {\n            infer(pps_conf_win_left_offset, sps->sps_conf_win_left_offset);\n            infer(pps_conf_win_right_offset, sps->sps_conf_win_right_offset);\n            infer(pps_conf_win_top_offset, sps->sps_conf_win_top_offset);\n            infer(pps_conf_win_bottom_offset, sps->sps_conf_win_bottom_offset);\n        } else {\n            infer(pps_conf_win_left_offset, 0);\n            infer(pps_conf_win_right_offset, 0);\n            infer(pps_conf_win_top_offset, 0);\n            infer(pps_conf_win_bottom_offset, 0);\n        }\n\n    }\n\n    flag(pps_scaling_window_explicit_signalling_flag);\n    if (!sps->sps_ref_pic_resampling_enabled_flag &&\n        current->pps_scaling_window_explicit_signalling_flag) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR,\n               \"Invalid data: sps_ref_pic_resampling_enabled_flag is false, \"\n               \"but pps_scaling_window_explicit_signalling_flag is true.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (current->pps_scaling_window_explicit_signalling_flag) {\n        se(pps_scaling_win_left_offset,\n           -current->pps_pic_width_in_luma_samples * 15 / sub_width_c,\n           current->pps_pic_width_in_luma_samples / sub_width_c);\n        se(pps_scaling_win_right_offset,\n           -current->pps_pic_width_in_luma_samples * 15 / sub_width_c,\n           current->pps_pic_width_in_luma_samples / sub_width_c);\n        se(pps_scaling_win_top_offset,\n           -current->pps_pic_height_in_luma_samples * 15 / sub_height_c,\n           current->pps_pic_height_in_luma_samples / sub_height_c);\n        se(pps_scaling_win_bottom_offset,\n           -current->pps_pic_height_in_luma_samples * 15 / sub_height_c,\n           current->pps_pic_height_in_luma_samples / sub_height_c);\n    } else {\n        infer(pps_scaling_win_left_offset, current->pps_conf_win_left_offset);\n        infer(pps_scaling_win_right_offset, current->pps_conf_win_right_offset);\n        infer(pps_scaling_win_top_offset, current->pps_conf_win_top_offset);\n        infer(pps_scaling_win_bottom_offset, current->pps_conf_win_bottom_offset);\n    }\n\n    flag(pps_output_flag_present_flag);\n    flag(pps_no_pic_partition_flag);\n    flag(pps_subpic_id_mapping_present_flag);\n\n    if (current->pps_subpic_id_mapping_present_flag) {\n        if (!current->pps_no_pic_partition_flag) {\n            ue(pps_num_subpics_minus1,\n               sps->sps_num_subpics_minus1, sps->sps_num_subpics_minus1);\n        } else {\n            infer(pps_num_subpics_minus1, 0);\n        }\n        ue(pps_subpic_id_len_minus1, sps->sps_subpic_id_len_minus1,\n           sps->sps_subpic_id_len_minus1);\n        for (i = 0; i <= current->pps_num_subpics_minus1; i++) {\n            ubs(sps->sps_subpic_id_len_minus1 + 1, pps_subpic_id[i], 1, i);\n        }\n    }\n\n    for (i = 0; i <= sps->sps_num_subpics_minus1; i++) {\n        if (sps->sps_subpic_id_mapping_explicitly_signalled_flag)\n            current->sub_pic_id_val[i] = current->pps_subpic_id_mapping_present_flag\n                                       ? current->pps_subpic_id[i]\n                                       : sps->sps_subpic_id[i];\n        else\n            current->sub_pic_id_val[i] = i;\n    }\n\n    pic_width_in_ctbs_y = AV_CEIL_RSHIFT\n        (current->pps_pic_width_in_luma_samples, (sps->sps_log2_ctu_size_minus5 + 5));\n    pic_height_in_ctbs_y = AV_CEIL_RSHIFT(\n        current->pps_pic_height_in_luma_samples,(sps->sps_log2_ctu_size_minus5 + 5));\n    if (!current->pps_no_pic_partition_flag) {\n        unsigned int exp_tile_width = 0, exp_tile_height = 0;\n        unsigned int unified_size, remaining_size;\n\n        u(2, pps_log2_ctu_size_minus5,\n          sps->sps_log2_ctu_size_minus5, sps->sps_log2_ctu_size_minus5);\n        ue(pps_num_exp_tile_columns_minus1,\n           0, FFMIN(pic_width_in_ctbs_y - 1, VVC_MAX_TILE_COLUMNS - 1));\n        ue(pps_num_exp_tile_rows_minus1,\n           0, FFMIN(pic_height_in_ctbs_y - 1, VVC_MAX_TILE_ROWS - 1));\n\n        for (i = 0; i <= current->pps_num_exp_tile_columns_minus1; i++) {\n            ues(pps_tile_column_width_minus1[i],\n                0, pic_width_in_ctbs_y - exp_tile_width - 1, 1, i);\n            exp_tile_width += current->pps_tile_column_width_minus1[i] + 1;\n        }\n        for (i = 0; i <= current->pps_num_exp_tile_rows_minus1; i++) {\n            ues(pps_tile_row_height_minus1[i],\n                0, pic_height_in_ctbs_y - exp_tile_height - 1, 1, i);\n            exp_tile_height += current->pps_tile_row_height_minus1[i] + 1;\n        }\n\n        remaining_size = pic_width_in_ctbs_y;\n        for (i = 0; i <= current->pps_num_exp_tile_columns_minus1; i++) {\n          if (current->pps_tile_column_width_minus1[i] >= remaining_size) {\n              av_log(ctx->log_ctx, AV_LOG_ERROR,\n                     \"Tile column width(%d) exceeds picture width\\n\",i);\n              return AVERROR_INVALIDDATA;\n          }\n          current->col_width_val[i] = current->pps_tile_column_width_minus1[i] + 1;\n          remaining_size -= (current->pps_tile_column_width_minus1[i] + 1);\n        }\n        unified_size = current->pps_tile_column_width_minus1[i - 1] + 1;\n        while (remaining_size > 0) {\n            if (current->num_tile_columns > VVC_MAX_TILE_COLUMNS) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR,\n                       \"NumTileColumns(%d) > than VVC_MAX_TILE_COLUMNS(%d)\\n\",\n                       current->num_tile_columns, VVC_MAX_TILE_COLUMNS);\n                return AVERROR_INVALIDDATA;\n            }\n            unified_size = FFMIN(remaining_size, unified_size);\n            current->col_width_val[i] = unified_size;\n            remaining_size -= unified_size;\n            i++;\n        }\n        current->num_tile_columns = i;\n        if (current->num_tile_columns > VVC_MAX_TILE_COLUMNS) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR,\n                   \"NumTileColumns(%d) > than VVC_MAX_TILE_COLUMNS(%d)\\n\",\n                   current->num_tile_columns, VVC_MAX_TILE_COLUMNS);\n            return AVERROR_INVALIDDATA;\n        }\n\n        remaining_size = pic_height_in_ctbs_y;\n        for (i = 0; i <= current->pps_num_exp_tile_rows_minus1; i++) {\n          if (current->pps_tile_row_height_minus1[i] >= remaining_size) {\n              av_log(ctx->log_ctx, AV_LOG_ERROR,\n                     \"Tile row height(%d) exceeds picture height\\n\",i);\n              return AVERROR_INVALIDDATA;\n          }\n          current->row_height_val[i] = current->pps_tile_row_height_minus1[i] + 1;\n          remaining_size -= (current->pps_tile_row_height_minus1[i] + 1);\n        }\n        unified_size = current->pps_tile_row_height_minus1[i - 1] + 1;\n\n        while (remaining_size > 0) {\n            unified_size = FFMIN(remaining_size, unified_size);\n            current->row_height_val[i] = unified_size;\n            remaining_size -= unified_size;\n            i++;\n        }\n        current->num_tile_rows=i;\n        if (current->num_tile_rows > VVC_MAX_TILE_ROWS) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR,\n                   \"NumTileRows(%d) > than VVC_MAX_TILE_ROWS(%d)\\n\",\n                   current->num_tile_rows, VVC_MAX_TILE_ROWS);\n            return AVERROR_INVALIDDATA;\n        }\n\n        current->num_tiles_in_pic = current->num_tile_columns *\n                                    current->num_tile_rows;\n        if (current->num_tiles_in_pic > VVC_MAX_TILES_PER_AU) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR,\n                   \"NumTilesInPic(%d) > than VVC_MAX_TILES_PER_AU(%d)\\n\",\n                   current->num_tiles_in_pic, VVC_MAX_TILES_PER_AU);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (current->num_tiles_in_pic > 1) {\n            flag(pps_loop_filter_across_tiles_enabled_flag);\n            flag(pps_rect_slice_flag);\n        } else {\n            infer(pps_loop_filter_across_tiles_enabled_flag, 0);\n            infer(pps_rect_slice_flag, 1);\n        }\n        if (current->pps_rect_slice_flag)\n            flag(pps_single_slice_per_subpic_flag);\n        else\n            infer(pps_single_slice_per_subpic_flag, 1);\n        if (current->pps_rect_slice_flag &&\n            !current->pps_single_slice_per_subpic_flag) {\n            int j;\n            uint16_t tile_idx = 0, tile_x, tile_y, ctu_x, ctu_y;\n            uint16_t slice_top_left_ctu_x[VVC_MAX_SLICES];\n            uint16_t slice_top_left_ctu_y[VVC_MAX_SLICES];\n            ue(pps_num_slices_in_pic_minus1, 0, VVC_MAX_SLICES - 1);\n            if (current->pps_num_slices_in_pic_minus1 > 1)\n                flag(pps_tile_idx_delta_present_flag);\n            else\n                infer(pps_tile_idx_delta_present_flag, 0);\n            for (i = 0; i < current->pps_num_slices_in_pic_minus1; i++) {\n                tile_x = tile_idx % current->num_tile_columns;\n                tile_y = tile_idx / current->num_tile_columns;\n                if (tile_x != current->num_tile_columns - 1) {\n                    ues(pps_slice_width_in_tiles_minus1[i],\n                        0, current->num_tile_columns - 1, 1, i);\n                } else {\n                    infer(pps_slice_width_in_tiles_minus1[i], 0);\n                }\n                if (tile_y != current->num_tile_rows - 1 &&\n                    (current->pps_tile_idx_delta_present_flag || tile_x == 0)) {\n                    ues(pps_slice_height_in_tiles_minus1[i],\n                        0, current->num_tile_rows - 1, 1, i);\n                } else {\n                    if (tile_y == current->num_tile_rows - 1)\n                        infer(pps_slice_height_in_tiles_minus1[i], 0);\n                    else\n                        infer(pps_slice_height_in_tiles_minus1[i],\n                              current->pps_slice_height_in_tiles_minus1[i - 1]);\n                }\n\n                ctu_x = ctu_y = 0;\n                for (j = 0; j < tile_x; j++) {\n                    ctu_x += current->col_width_val[j];\n                }\n                for (j = 0; j < tile_y; j++) {\n                    ctu_y += current->row_height_val[j];\n                }\n                if (current->pps_slice_width_in_tiles_minus1[i] == 0 &&\n                    current->pps_slice_height_in_tiles_minus1[i] == 0 &&\n                    current->row_height_val[tile_y] > 1) {\n                    int num_slices_in_tile,\n                        uniform_slice_height, remaining_height_in_ctbs_y;\n                    remaining_height_in_ctbs_y =\n                        current->row_height_val[tile_y];\n                    ues(pps_num_exp_slices_in_tile[i],\n                        0, current->row_height_val[tile_y] - 1, 1, i);\n                    if (current->pps_num_exp_slices_in_tile[i] == 0) {\n                        num_slices_in_tile = 1;\n                        current->slice_height_in_ctus[i] = current->row_height_val[tile_y];\n                        slice_top_left_ctu_x[i] = ctu_x;\n                        slice_top_left_ctu_y[i] = ctu_y;\n                    } else {\n                        uint16_t slice_height_in_ctus;\n                        for (j = 0; j < current->pps_num_exp_slices_in_tile[i];\n                             j++) {\n                            ues(pps_exp_slice_height_in_ctus_minus1[i][j], 0,\n                                current->row_height_val[tile_y] - 1, 2,\n                                i, j);\n                            slice_height_in_ctus =\n                                current->\n                                pps_exp_slice_height_in_ctus_minus1[i][j] + 1;\n\n                            current->slice_height_in_ctus[i + j] =\n                                slice_height_in_ctus;\n                            slice_top_left_ctu_x[i + j] = ctu_x;\n                            slice_top_left_ctu_y[i + j] = ctu_y;\n                            ctu_y += slice_height_in_ctus;\n\n                            remaining_height_in_ctbs_y -= slice_height_in_ctus;\n                        }\n                        uniform_slice_height = 1 +\n                            (j == 0 ? current->row_height_val[tile_y] - 1:\n                            current->pps_exp_slice_height_in_ctus_minus1[i][j-1]);\n                        while (remaining_height_in_ctbs_y > uniform_slice_height) {\n                            current->slice_height_in_ctus[i + j] =\n                                                          uniform_slice_height;\n                            slice_top_left_ctu_x[i + j] = ctu_x;\n                            slice_top_left_ctu_y[i + j] = ctu_y;\n                            ctu_y += uniform_slice_height;\n\n                            remaining_height_in_ctbs_y -= uniform_slice_height;\n                            j++;\n                        }\n                        if (remaining_height_in_ctbs_y > 0) {\n                            current->slice_height_in_ctus[i + j] =\n                                remaining_height_in_ctbs_y;\n                            slice_top_left_ctu_x[i + j] = ctu_x;\n                            slice_top_left_ctu_y[i + j] = ctu_y;\n                            j++;\n                        }\n                        num_slices_in_tile = j;\n                    }\n                    i += num_slices_in_tile - 1;\n                } else {\n                    uint16_t height = 0;\n                    infer(pps_num_exp_slices_in_tile[i], 0);\n                    for (j = 0;\n                         j <= current->pps_slice_height_in_tiles_minus1[i];\n                         j++) {\n                        height +=\n                           current->row_height_val[tile_y + j];\n                    }\n                    current->slice_height_in_ctus[i] = height;\n\n                    slice_top_left_ctu_x[i] = ctu_x;\n                    slice_top_left_ctu_y[i] = ctu_y;\n                }\n                if (i < current->pps_num_slices_in_pic_minus1) {\n                    if (current->pps_tile_idx_delta_present_flag) {\n                        // Two conditions must be met:\n                        // 1. NumTilesInPic + 1 <= pps_tile_idx_delta_val[i] <= NumTilesInPic  1\n                        // 2. 0 <= tile_idx + pps_tile_idx_delta_val[i] <= NumTilesInPic  1\n                        // Combining these conditions yields: -tile_idx <= pps_tile_idx_delta_val[i] <= NumTilesInPic - 1 - tile_idx\n                        ses(pps_tile_idx_delta_val[i],\n                            -tile_idx, current->num_tiles_in_pic - 1 - tile_idx, 1, i);\n                        if (current->pps_tile_idx_delta_val[i] == 0) {\n                            av_log(ctx->log_ctx, AV_LOG_ERROR,\n                                   \"pps_tile_idx_delta_val[i] shall not be equal to 0.\\n\");\n                        }\n                        tile_idx += current->pps_tile_idx_delta_val[i];\n                    } else {\n                        infer(pps_tile_idx_delta_val[i], 0);\n                        tile_idx +=\n                            current->pps_slice_width_in_tiles_minus1[i] + 1;\n                        if (tile_idx % current->num_tile_columns == 0) {\n                            tile_idx +=\n                                current->pps_slice_height_in_tiles_minus1[i] *\n                                current->num_tile_columns;\n                        }\n                    }\n                }\n            }\n            if (i == current->pps_num_slices_in_pic_minus1) {\n                uint16_t height = 0;\n\n                tile_x = tile_idx % current->num_tile_columns;\n                tile_y = tile_idx / current->num_tile_columns;\n\n                ctu_x = 0, ctu_y = 0;\n                for (j = 0; j < tile_x; j++) {\n                    ctu_x += current->col_width_val[j];\n                }\n                for (j = 0; j < tile_y; j++) {\n                    ctu_y += current->row_height_val[j];\n                }\n                slice_top_left_ctu_x[i] = ctu_x;\n                slice_top_left_ctu_y[i] = ctu_y;\n\n                current->pps_slice_width_in_tiles_minus1[i] =\n                    current->num_tile_columns - tile_x - 1;\n                current->pps_slice_height_in_tiles_minus1[i] =\n                    current->num_tile_rows - tile_y - 1;\n\n                for (j = 0; j <= current->pps_slice_height_in_tiles_minus1[i];\n                     j++) {\n                    height +=\n                        current->row_height_val[tile_y + j];\n                }\n                current->slice_height_in_ctus[i] = height;\n\n                infer(pps_num_exp_slices_in_tile[i], 0);\n            }\n            //now, we got all slice information, let's resolve NumSlicesInSubpic\n            for (i = 0; i <= sps->sps_num_subpics_minus1; i++) {\n                current->num_slices_in_subpic[i] = 0;\n                for (j = 0; j <= current->pps_num_slices_in_pic_minus1; j++) {\n                    uint16_t pos_x = 0, pos_y = 0;\n                    pos_x = slice_top_left_ctu_x[j];\n                    pos_y = slice_top_left_ctu_y[j];\n                    if ((pos_x >= sps->sps_subpic_ctu_top_left_x[i]) &&\n                        (pos_x <\n                         sps->sps_subpic_ctu_top_left_x[i] +\n                         sps->sps_subpic_width_minus1[i] + 1) &&\n                         (pos_y >= sps->sps_subpic_ctu_top_left_y[i]) &&\n                         (pos_y < sps->sps_subpic_ctu_top_left_y[i] +\n                            sps->sps_subpic_height_minus1[i] + 1)) {\n                        current->num_slices_in_subpic[i]++;\n                    }\n                }\n            }\n        } else {\n            if (current->pps_no_pic_partition_flag)\n                infer(pps_num_slices_in_pic_minus1, 0);\n            else if (current->pps_single_slice_per_subpic_flag)\n                infer(pps_num_slices_in_pic_minus1,\n                      sps->sps_num_subpics_minus1);\n            // else?\n        }\n        if (!current->pps_rect_slice_flag ||\n            current->pps_single_slice_per_subpic_flag ||\n            current->pps_num_slices_in_pic_minus1 > 0)\n            flag(pps_loop_filter_across_slices_enabled_flag);\n        else\n            infer(pps_loop_filter_across_slices_enabled_flag, 0);\n    } else {\n        infer(pps_num_exp_tile_columns_minus1, 0);\n        infer(pps_tile_column_width_minus1[0], pic_width_in_ctbs_y - 1);\n        infer(pps_num_exp_tile_rows_minus1, 0);\n        infer(pps_tile_row_height_minus1[0], pic_height_in_ctbs_y - 1);\n        current->col_width_val[0] = pic_width_in_ctbs_y;\n        current->row_height_val[0] = pic_height_in_ctbs_y;\n        current->num_tile_columns = 1;\n        current->num_tile_rows = 1;\n        current->num_tiles_in_pic = 1;\n    }\n\n    flag(pps_cabac_init_present_flag);\n    for (i = 0; i < 2; i++)\n        ues(pps_num_ref_idx_default_active_minus1[i], 0, 14, 1, i);\n    flag(pps_rpl1_idx_present_flag);\n    flag(pps_weighted_pred_flag);\n    flag(pps_weighted_bipred_flag);\n    flag(pps_ref_wraparound_enabled_flag);\n    if (current->pps_ref_wraparound_enabled_flag) {\n        ue(pps_pic_width_minus_wraparound_offset,\n           0, (current->pps_pic_width_in_luma_samples / min_cb_size_y)\n           - (ctb_size_y / min_cb_size_y) - 2);\n    }\n\n    qp_bd_offset = 6 * sps->sps_bitdepth_minus8;\n    se(pps_init_qp_minus26, -(26 + qp_bd_offset), 37);\n    flag(pps_cu_qp_delta_enabled_flag);\n    flag(pps_chroma_tool_offsets_present_flag);\n    if (current->pps_chroma_tool_offsets_present_flag) {\n        se(pps_cb_qp_offset, -12, 12);\n        se(pps_cr_qp_offset, -12, 12);\n        flag(pps_joint_cbcr_qp_offset_present_flag);\n        if (current->pps_joint_cbcr_qp_offset_present_flag)\n            se(pps_joint_cbcr_qp_offset_value, -12, 12);\n        else\n            infer(pps_joint_cbcr_qp_offset_value, 0);\n        flag(pps_slice_chroma_qp_offsets_present_flag);\n        flag(pps_cu_chroma_qp_offset_list_enabled_flag);\n        if (current->pps_cu_chroma_qp_offset_list_enabled_flag) {\n            ue(pps_chroma_qp_offset_list_len_minus1, 0, 5);\n            for (i = 0; i <= current->pps_chroma_qp_offset_list_len_minus1; i++) {\n                ses(pps_cb_qp_offset_list[i], -12, 12, 1, i);\n                ses(pps_cr_qp_offset_list[i], -12, 12, 1, i);\n                if (current->pps_joint_cbcr_qp_offset_present_flag)\n                    ses(pps_joint_cbcr_qp_offset_list[i], -12, 12, 1, i);\n                else\n                    infer(pps_joint_cbcr_qp_offset_list[i], 0);\n            }\n        }\n    } else {\n        infer(pps_cb_qp_offset, 0);\n        infer(pps_cr_qp_offset, 0);\n        infer(pps_joint_cbcr_qp_offset_present_flag, 0);\n        infer(pps_joint_cbcr_qp_offset_value, 0);\n        infer(pps_slice_chroma_qp_offsets_present_flag, 0);\n        infer(pps_cu_chroma_qp_offset_list_enabled_flag, 0);\n    }\n    flag(pps_deblocking_filter_control_present_flag);\n    if (current->pps_deblocking_filter_control_present_flag) {\n        flag(pps_deblocking_filter_override_enabled_flag);\n        flag(pps_deblocking_filter_disabled_flag);\n        if (!current->pps_no_pic_partition_flag &&\n            current->pps_deblocking_filter_override_enabled_flag)\n            flag(pps_dbf_info_in_ph_flag);\n        else\n            infer(pps_dbf_info_in_ph_flag, 0);\n        if (!current->pps_deblocking_filter_disabled_flag) {\n            se(pps_luma_beta_offset_div2, -12, 12);\n            se(pps_luma_tc_offset_div2, -12, 12);\n            if (current->pps_chroma_tool_offsets_present_flag) {\n                se(pps_cb_beta_offset_div2, -12, 12);\n                se(pps_cb_tc_offset_div2, -12, 12);\n                se(pps_cr_beta_offset_div2, -12, 12);\n                se(pps_cr_tc_offset_div2, -12, 12);\n            } else {\n                infer(pps_cb_beta_offset_div2,\n                      current->pps_luma_beta_offset_div2);\n                infer(pps_cb_tc_offset_div2, current->pps_luma_tc_offset_div2);\n                infer(pps_cr_beta_offset_div2,\n                      current->pps_luma_beta_offset_div2);\n                infer(pps_cr_tc_offset_div2, current->pps_luma_tc_offset_div2);\n            }\n        } else {\n            infer(pps_luma_beta_offset_div2, 0);\n            infer(pps_luma_tc_offset_div2, 0);\n            infer(pps_cb_beta_offset_div2, 0);\n            infer(pps_cb_tc_offset_div2, 0);\n            infer(pps_cr_beta_offset_div2, 0);\n            infer(pps_cr_tc_offset_div2, 0);\n        }\n    } else {\n        infer(pps_deblocking_filter_override_enabled_flag, 0);\n        infer(pps_deblocking_filter_disabled_flag, 0);\n        infer(pps_dbf_info_in_ph_flag, 0);\n        infer(pps_luma_beta_offset_div2, 0);\n        infer(pps_luma_tc_offset_div2, 0);\n        infer(pps_cb_beta_offset_div2, 0);\n        infer(pps_cb_tc_offset_div2, 0);\n        infer(pps_cr_beta_offset_div2, 0);\n        infer(pps_cr_tc_offset_div2, 0);\n    }\n\n    if (!current->pps_no_pic_partition_flag) {\n        flag(pps_rpl_info_in_ph_flag);\n        flag(pps_sao_info_in_ph_flag);\n        flag(pps_alf_info_in_ph_flag);\n        if ((current->pps_weighted_pred_flag ||\n             current->pps_weighted_bipred_flag) &&\n            current->pps_rpl_info_in_ph_flag)\n            flag(pps_wp_info_in_ph_flag);\n        flag(pps_qp_delta_info_in_ph_flag);\n    }\n    flag(pps_picture_header_extension_present_flag);\n    flag(pps_slice_header_extension_present_flag);\n\n    flag(pps_extension_flag);\n    if (current->pps_extension_flag)\n        CHECK(FUNC(extension_data) (ctx, rw, &current->extension_data));\n\n    CHECK(FUNC(rbsp_trailing_bits) (ctx, rw));\n    return 0;\n}",
      "cve_list": [
        "CVE-2024-31581"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "FFmpeg",
      "filepath": "libavfilter/avf_showspectrum.c",
      "func_name": "showspectrumpic_request_frame",
      "func_body": "static int showspectrumpic_request_frame(AVFilterLink *outlink)\n{\n    AVFilterContext *ctx = outlink->src;\n    ShowSpectrumContext *s = ctx->priv;\n    AVFilterLink *inlink = ctx->inputs[0];\n    int ret;\n\n    ret = ff_request_frame(inlink);\n    if (ret == AVERROR_EOF && s->outpicref && s->samples > 0) {\n        int consumed = 0;\n        int x = 0, sz = s->orientation == VERTICAL ? s->w : s->h;\n        unsigned int nb_frame = 0;\n        int ch, spf, spb;\n        int src_offset = 0;\n        AVFrame *fin;\n\n        spf = s->win_size * (s->samples / ((s->win_size * sz) * ceil(s->samples / (float)(s->win_size * sz))));\n        spf = FFMAX(1, spf);\n        s->hop_size = spf;\n\n        spb = (s->samples / (spf * sz)) * spf;\n\n        fin = ff_get_audio_buffer(inlink, spf);\n        if (!fin)\n            return AVERROR(ENOMEM);\n\n        while (x < sz) {\n            int acc_samples = 0;\n            int dst_offset = 0;\n\n            while (nb_frame < s->nb_frames) {\n                AVFrame *cur_frame = s->frames[nb_frame];\n                int cur_frame_samples = cur_frame->nb_samples;\n                int nb_samples = 0;\n\n                if (acc_samples < spf) {\n                    nb_samples = FFMIN(spf - acc_samples, cur_frame_samples - src_offset);\n                    acc_samples += nb_samples;\n                    av_samples_copy(fin->extended_data, cur_frame->extended_data,\n                                    dst_offset, src_offset, nb_samples,\n                                    cur_frame->ch_layout.nb_channels, AV_SAMPLE_FMT_FLTP);\n                }\n\n                src_offset += nb_samples;\n                dst_offset += nb_samples;\n                if (cur_frame_samples <= src_offset) {\n                    av_frame_free(&s->frames[nb_frame]);\n                    nb_frame++;\n                    src_offset = 0;\n                }\n\n                if (acc_samples == spf)\n                    break;\n            }\n\n            ff_filter_execute(ctx, run_channel_fft, fin, NULL, s->nb_display_channels);\n            acalc_magnitudes(s);\n\n            consumed += spf;\n            if (consumed >= spb) {\n                int h = s->orientation == VERTICAL ? s->h : s->w;\n\n                scale_magnitudes(s, 1.f / (consumed / spf));\n                plot_spectrum_column(inlink, fin);\n                consumed = 0;\n                x++;\n                for (ch = 0; ch < s->nb_display_channels; ch++)\n                    memset(s->magnitudes[ch], 0, h * sizeof(float));\n            }\n        }\n\n        av_frame_free(&fin);\n        s->outpicref->pts = 0;\n\n        if (s->legend)\n            draw_legend(ctx, s->samples);\n\n        ret = ff_filter_frame(outlink, s->outpicref);\n        s->outpicref = NULL;\n    }\n\n    return ret;\n}",
      "cve_list": [
        "CVE-2024-31585"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "FFmpeg",
      "filepath": "libavutil/hwcontext.c",
      "func_name": "av_hwframe_ctx_init",
      "func_body": "int av_hwframe_ctx_init(AVBufferRef *ref)\n{\n    AVHWFramesContext *ctx = (AVHWFramesContext*)ref->data;\n    const enum AVPixelFormat *pix_fmt;\n    int ret;\n\n    if (ctx->internal->source_frames) {\n        /* A derived frame context is already initialised. */\n        return 0;\n    }\n\n    /* validate the pixel format */\n    for (pix_fmt = ctx->internal->hw_type->pix_fmts; *pix_fmt != AV_PIX_FMT_NONE; pix_fmt++) {\n        if (*pix_fmt == ctx->format)\n            break;\n    }\n    if (*pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(ctx, AV_LOG_ERROR,\n               \"The hardware pixel format '%s' is not supported by the device type '%s'\\n\",\n               av_get_pix_fmt_name(ctx->format), ctx->internal->hw_type->name);\n        return AVERROR(ENOSYS);\n    }\n\n    /* validate the dimensions */\n    ret = av_image_check_size(ctx->width, ctx->height, 0, ctx);\n    if (ret < 0)\n        return ret;\n\n    /* format-specific init */\n    if (ctx->internal->hw_type->frames_init) {\n        ret = ctx->internal->hw_type->frames_init(ctx);\n        if (ret < 0)\n            return ret;\n    }\n\n    if (ctx->internal->pool_internal && !ctx->pool)\n        ctx->pool = ctx->internal->pool_internal;\n\n    /* preallocate the frames in the pool, if requested */\n    if (ctx->initial_pool_size > 0) {\n        ret = hwframe_pool_prealloc(ref);\n        if (ret < 0)\n            return ret;\n    }\n\n    return 0;\n}",
      "cve_list": [
        "CVE-2024-31578"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "llvm-project",
      "filepath": "llvm/lib/Target/ARM/ARMFrameLowering.cpp",
      "func_name": "ARMFrameLowering::processFunctionBeforeFrameFinalized",
      "func_body": "void ARMFrameLowering::processFunctionBeforeFrameFinalized(\n    MachineFunction &MF, RegScavenger *RS) const {\n  TargetFrameLowering::processFunctionBeforeFrameFinalized(MF, RS);\n  updateLRRestored(MF);\n}",
      "cve_list": [
        "CVE-2024-31852"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "llvm-project",
      "filepath": "llvm/lib/Target/ARM/ARMFrameLowering.cpp",
      "func_name": "ARMFrameLowering::updateLRRestored",
      "func_body": "void ARMFrameLowering::updateLRRestored(MachineFunction &MF) {\n  MachineFrameInfo &MFI = MF.getFrameInfo();\n  if (!MFI.isCalleeSavedInfoValid())\n    return;\n\n  // Check if all terminators do not implicitly use LR. Then we can 'restore' LR\n  // into PC so it is not live out of the return block: Clear the Restored bit\n  // in that case.\n  for (CalleeSavedInfo &Info : MFI.getCalleeSavedInfo()) {\n    if (Info.getReg() != ARM::LR)\n      continue;\n    if (all_of(MF, [](const MachineBasicBlock &MBB) {\n          return all_of(MBB.terminators(), [](const MachineInstr &Term) {\n            return !Term.isReturn() || Term.getOpcode() == ARM::LDMIA_RET ||\n                   Term.getOpcode() == ARM::t2LDMIA_RET ||\n                   Term.getOpcode() == ARM::tPOP_RET;\n          });\n        })) {\n      Info.setRestored(false);\n      break;\n    }\n  }\n}",
      "cve_list": [
        "CVE-2024-31852"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "llvm-project",
      "filepath": "llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp",
      "func_name": "ARMLoadStoreOpt::runOnMachineFunction",
      "func_body": "bool ARMLoadStoreOpt::runOnMachineFunction(MachineFunction &Fn) {\n  if (skipFunction(Fn.getFunction()))\n    return false;\n\n  MF = &Fn;\n  STI = &Fn.getSubtarget<ARMSubtarget>();\n  TL = STI->getTargetLowering();\n  AFI = Fn.getInfo<ARMFunctionInfo>();\n  TII = STI->getInstrInfo();\n  TRI = STI->getRegisterInfo();\n\n  RegClassInfoValid = false;\n  isThumb2 = AFI->isThumb2Function();\n  isThumb1 = AFI->isThumbFunction() && !isThumb2;\n\n  bool Modified = false, ModifiedLDMReturn = false;\n  for (MachineBasicBlock &MBB : Fn) {\n    Modified |= LoadStoreMultipleOpti(MBB);\n    if (STI->hasV5TOps() && !AFI->shouldSignReturnAddress())\n      ModifiedLDMReturn |= MergeReturnIntoLDM(MBB);\n    if (isThumb1)\n      Modified |= CombineMovBx(MBB);\n  }\n  Modified |= ModifiedLDMReturn;\n\n  // If we merged a BX instruction into an LDM, we need to re-calculate whether\n  // LR is restored. This check needs to consider the whole function, not just\n  // the instruction(s) we changed, because there may be other BX returns which\n  // still need LR to be restored.\n  if (ModifiedLDMReturn)\n    ARMFrameLowering::updateLRRestored(Fn);\n\n  Allocator.DestroyAll();\n  return Modified;\n}",
      "cve_list": [
        "CVE-2024-31852"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "unbound",
      "filepath": "services/cache/infra.c",
      "func_name": "infra_create",
      "func_body": "infra_create(struct config_file* cfg)\n{\n\tstruct infra_cache* infra = (struct infra_cache*)calloc(1, \n\t\tsizeof(struct infra_cache));\n\tsize_t maxmem = cfg->infra_cache_numhosts * (sizeof(struct infra_key)+\n\t\tsizeof(struct infra_data)+INFRA_BYTES_NAME);\n\tif(!infra) {\n\t\treturn NULL;\n\t}\n\tinfra->hosts = slabhash_create(cfg->infra_cache_slabs,\n\t\tINFRA_HOST_STARTSIZE, maxmem, &infra_sizefunc, &infra_compfunc,\n\t\t&infra_delkeyfunc, &infra_deldatafunc, NULL);\n\tif(!infra->hosts) {\n\t\tfree(infra);\n\t\treturn NULL;\n\t}\n\tinfra->host_ttl = cfg->host_ttl;\n\tinfra->infra_keep_probing = cfg->infra_keep_probing;\n\tinfra_dp_ratelimit = cfg->ratelimit;\n\tinfra->domain_rates = slabhash_create(cfg->ratelimit_slabs,\n\t\tINFRA_HOST_STARTSIZE, cfg->ratelimit_size,\n\t\t&rate_sizefunc, &rate_compfunc, &rate_delkeyfunc,\n\t\t&rate_deldatafunc, NULL);\n\tif(!infra->domain_rates) {\n\t\tinfra_delete(infra);\n\t\treturn NULL;\n\t}\n\t/* insert config data into ratelimits */\n\tif(!setup_domain_limits(infra, cfg)) {\n\t\tinfra_delete(infra);\n\t\treturn NULL;\n\t}\n\tif(!setup_wait_limits(infra, cfg)) {\n\t\tinfra_delete(infra);\n\t\treturn NULL;\n\t}\n\tinfra_ip_ratelimit = cfg->ip_ratelimit;\n\tinfra->client_ip_rates = slabhash_create(cfg->ip_ratelimit_slabs,\n\t    INFRA_HOST_STARTSIZE, cfg->ip_ratelimit_size, &ip_rate_sizefunc,\n\t    &ip_rate_compfunc, &ip_rate_delkeyfunc, &ip_rate_deldatafunc, NULL);\n\tif(!infra->client_ip_rates) {\n\t\tinfra_delete(infra);\n\t\treturn NULL;\n\t}\n\treturn infra;\n}",
      "cve_list": [
        "CVE-2024-33655"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "unbound",
      "filepath": "services/cache/infra.c",
      "func_name": "infra_delete",
      "func_body": "infra_delete(struct infra_cache* infra)\n{\n\tif(!infra)\n\t\treturn;\n\tslabhash_delete(infra->hosts);\n\tslabhash_delete(infra->domain_rates);\n\ttraverse_postorder(&infra->domain_limits, domain_limit_free, NULL);\n\tslabhash_delete(infra->client_ip_rates);\n\ttraverse_postorder(&infra->wait_limits_netblock,\n\t\twait_limit_netblock_del, NULL);\n\ttraverse_postorder(&infra->wait_limits_cookie_netblock,\n\t\twait_limit_netblock_del, NULL);\n\tfree(infra);\n}",
      "cve_list": [
        "CVE-2024-33655"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "unbound",
      "filepath": "services/cache/infra.c",
      "func_name": "infra_ip_create_ratedata",
      "func_body": "static void infra_ip_create_ratedata(struct infra_cache* infra,\n\tstruct sockaddr_storage* addr, socklen_t addrlen, time_t timenow,\n\tint mesh_wait)\n{\n\thashvalue_type h = hash_addr(addr, addrlen, 0);\n\tstruct ip_rate_key* k = (struct ip_rate_key*)calloc(1, sizeof(*k));\n\tstruct ip_rate_data* d = (struct ip_rate_data*)calloc(1, sizeof(*d));\n\tif(!k || !d) {\n\t\tfree(k);\n\t\tfree(d);\n\t\treturn; /* alloc failure */\n\t}\n\tk->addr = *addr;\n\tk->addrlen = addrlen;\n\tlock_rw_init(&k->entry.lock);\n\tk->entry.hash = h;\n\tk->entry.key = k;\n\tk->entry.data = d;\n\td->qps[0] = 1;\n\td->timestamp[0] = timenow;\n\td->mesh_wait = mesh_wait;\n\tslabhash_insert(infra->client_ip_rates, h, &k->entry, d, NULL);\n}",
      "cve_list": [
        "CVE-2024-33655"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "unbound",
      "filepath": "services/cache/infra.c",
      "func_name": "infra_ip_ratelimit_inc",
      "func_body": "int infra_ip_ratelimit_inc(struct infra_cache* infra,\n\tstruct sockaddr_storage* addr, socklen_t addrlen, time_t timenow,\n\tint has_cookie, int backoff, struct sldns_buffer* buffer)\n{\n\tint max;\n\tstruct lruhash_entry* entry;\n\n\t/* not enabled */\n\tif(!infra_ip_ratelimit) {\n\t\treturn 1;\n\t}\n\t/* find or insert ratedata */\n\tentry = infra_find_ip_ratedata(infra, addr, addrlen, 1);\n\tif(entry) {\n\t\tint premax = infra_rate_max(entry->data, timenow, backoff);\n\t\tint* cur = infra_rate_give_second(entry->data, timenow);\n\t\t(*cur)++;\n\t\tmax = infra_rate_max(entry->data, timenow, backoff);\n\t\tlock_rw_unlock(&entry->lock);\n\t\treturn check_ip_ratelimit(addr, addrlen, buffer, premax, max,\n\t\t\thas_cookie);\n\t}\n\n\t/* create */\n\tinfra_ip_create_ratedata(infra, addr, addrlen, timenow, 0);\n\treturn 1;\n}",
      "cve_list": [
        "CVE-2024-33655"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "unbound",
      "filepath": "services/cache/infra.c",
      "func_name": "infra_wait_limit_allowed",
      "func_body": "int infra_wait_limit_allowed(struct infra_cache* infra, struct comm_reply* rep,\n\tint cookie_valid, struct config_file* cfg)\n{\n\tstruct lruhash_entry* entry;\n\tif(cfg->wait_limit == 0)\n\t\treturn 1;\n\n\tentry = infra_find_ip_ratedata(infra, &rep->client_addr,\n\t\trep->client_addrlen, 0);\n\tif(entry) {\n\t\trbtree_type* tree;\n\t\tstruct wait_limit_netblock_info* w;\n\t\tstruct rate_data* d = (struct rate_data*)entry->data;\n\t\tint mesh_wait = d->mesh_wait;\n\t\tlock_rw_unlock(&entry->lock);\n\n\t\t/* have the wait amount, check how much is allowed */\n\t\tif(cookie_valid)\n\t\t\ttree = &infra->wait_limits_cookie_netblock;\n\t\telse\ttree = &infra->wait_limits_netblock;\n\t\tw = (struct wait_limit_netblock_info*)addr_tree_lookup(tree,\n\t\t\t&rep->client_addr, rep->client_addrlen);\n\t\tif(w) {\n\t\t\tif(w->limit != -1 && mesh_wait > w->limit)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\t/* if there is no IP netblock specific information,\n\t\t\t * use the configured value. */\n\t\t\tif(mesh_wait > (cookie_valid?cfg->wait_limit_cookie:\n\t\t\t\tcfg->wait_limit))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
      "cve_list": [
        "CVE-2024-33655"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "unbound",
      "filepath": "services/cache/infra.c",
      "func_name": "infra_wait_limit_dec",
      "func_body": "void infra_wait_limit_dec(struct infra_cache* infra, struct comm_reply* rep,\n\tstruct config_file* cfg)\n{\n\tstruct lruhash_entry* entry;\n\tif(cfg->wait_limit == 0)\n\t\treturn;\n\n\tentry = infra_find_ip_ratedata(infra, &rep->client_addr,\n\t\trep->client_addrlen, 1);\n\tif(entry) {\n\t\tstruct rate_data* d = (struct rate_data*)entry->data;\n\t\tif(d->mesh_wait > 0)\n\t\t\td->mesh_wait--;\n\t\tlock_rw_unlock(&entry->lock);\n\t}\n}",
      "cve_list": [
        "CVE-2024-33655"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "unbound",
      "filepath": "services/cache/infra.c",
      "func_name": "infra_wait_limit_inc",
      "func_body": "void infra_wait_limit_inc(struct infra_cache* infra, struct comm_reply* rep,\n\ttime_t timenow, struct config_file* cfg)\n{\n\tstruct lruhash_entry* entry;\n\tif(cfg->wait_limit == 0)\n\t\treturn;\n\n\t/* Find it */\n\tentry = infra_find_ip_ratedata(infra, &rep->client_addr,\n\t\trep->client_addrlen, 1);\n\tif(entry) {\n\t\tstruct rate_data* d = (struct rate_data*)entry->data;\n\t\td->mesh_wait++;\n\t\tlock_rw_unlock(&entry->lock);\n\t\treturn;\n\t}\n\n\t/* Create it */\n\tinfra_ip_create_ratedata(infra, &rep->client_addr,\n\t\trep->client_addrlen, timenow, 1);\n}",
      "cve_list": [
        "CVE-2024-33655"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "unbound",
      "filepath": "services/cache/infra.c",
      "func_name": "infra_wait_limit_netblock_insert",
      "func_body": "infra_wait_limit_netblock_insert(struct infra_cache* infra,\n\tstruct config_file* cfg)\n{\n\tstruct config_str2list* p;\n\tstruct wait_limit_netblock_info* d;\n\tfor(p = cfg->wait_limit_netblock; p; p = p->next) {\n\t\td = wait_limit_netblock_findcreate(infra, p->str, 0);\n\t\tif(!d)\n\t\t\treturn 0;\n\t\td->limit = atoi(p->str2);\n\t}\n\tfor(p = cfg->wait_limit_cookie_netblock; p; p = p->next) {\n\t\td = wait_limit_netblock_findcreate(infra, p->str, 1);\n\t\tif(!d)\n\t\t\treturn 0;\n\t\td->limit = atoi(p->str2);\n\t}\n\treturn 1;\n}",
      "cve_list": [
        "CVE-2024-33655"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "unbound",
      "filepath": "services/cache/infra.c",
      "func_name": "setup_wait_limits",
      "func_body": "setup_wait_limits(struct infra_cache* infra, struct config_file* cfg)\n{\n\taddr_tree_init(&infra->wait_limits_netblock);\n\taddr_tree_init(&infra->wait_limits_cookie_netblock);\n\tif(!infra_wait_limit_netblock_insert(infra, cfg))\n\t\treturn 0;\n\taddr_tree_init_parents(&infra->wait_limits_netblock);\n\taddr_tree_init_parents(&infra->wait_limits_cookie_netblock);\n\treturn 1;\n}",
      "cve_list": [
        "CVE-2024-33655"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "unbound",
      "filepath": "services/cache/infra.c",
      "func_name": "wait_limit_netblock_del",
      "func_body": "static void wait_limit_netblock_del(rbnode_type* n, void* ATTR_UNUSED(arg))\n{\n\tfree(n);\n}",
      "cve_list": [
        "CVE-2024-33655"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "unbound",
      "filepath": "services/cache/infra.c",
      "func_name": "wait_limit_netblock_findcreate",
      "func_body": "wait_limit_netblock_findcreate(struct infra_cache* infra, char* str,\n\tint cookie)\n{\n\trbtree_type* tree;\n\tstruct sockaddr_storage addr;\n\tint net;\n\tsocklen_t addrlen;\n\tstruct wait_limit_netblock_info* d;\n\n\tif(!netblockstrtoaddr(str, 0, &addr, &addrlen, &net)) {\n\t\tlog_err(\"cannot parse wait limit netblock '%s'\", str);\n\t\treturn 0;\n\t}\n\n\t/* can we find it? */\n\tif(cookie)\n\t\ttree = &infra->wait_limits_cookie_netblock;\n\telse\n\t\ttree = &infra->wait_limits_netblock;\n\td = (struct wait_limit_netblock_info*)addr_tree_find(tree, &addr,\n\t\taddrlen, net);\n\tif(d)\n\t\treturn d;\n\n\t/* create it */\n\td = (struct wait_limit_netblock_info*)calloc(1, sizeof(*d));\n\tif(!d)\n\t\treturn NULL;\n\td->limit = -1;\n\tif(!addr_tree_insert(tree, &d->node, &addr, addrlen, net)) {\n\t\tlog_err(\"duplicate element in domainlimit tree\");\n\t\tfree(d);\n\t\treturn NULL;\n\t}\n\treturn d;\n}",
      "cve_list": [
        "CVE-2024-33655"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "unbound",
      "filepath": "services/mesh.c",
      "func_name": "mesh_new_client",
      "func_body": "void mesh_new_client(struct mesh_area* mesh, struct query_info* qinfo,\n\tstruct respip_client_info* cinfo, uint16_t qflags,\n\tstruct edns_data* edns, struct comm_reply* rep, uint16_t qid,\n\tint rpz_passthru)\n{\n\tstruct mesh_state* s = NULL;\n\tint unique = unique_mesh_state(edns->opt_list_in, mesh->env);\n\tint was_detached = 0;\n\tint was_noreply = 0;\n\tint added = 0;\n\tint timeout = mesh->env->cfg->serve_expired?\n\t\tmesh->env->cfg->serve_expired_client_timeout:0;\n\tstruct sldns_buffer* r_buffer = rep->c->buffer;\n\tif(rep->c->tcp_req_info) {\n\t\tr_buffer = rep->c->tcp_req_info->spool_buffer;\n\t}\n\tif(!infra_wait_limit_allowed(mesh->env->infra_cache, rep,\n\t\tedns->cookie_valid, mesh->env->cfg)) {\n\t\tverbose(VERB_ALGO, \"Too many queries waiting from the IP. \"\n\t\t\t\"dropping incoming query.\");\n\t\tcomm_point_drop_reply(rep);\n\t\tmesh->stats_dropped++;\n\t\treturn;\n\t}\n\tif(!unique)\n\t\ts = mesh_area_find(mesh, cinfo, qinfo, qflags&(BIT_RD|BIT_CD), 0, 0);\n\t/* does this create a new reply state? */\n\tif(!s || s->list_select == mesh_no_list) {\n\t\tif(!mesh_make_new_space(mesh, rep->c->buffer)) {\n\t\t\tverbose(VERB_ALGO, \"Too many queries. dropping \"\n\t\t\t\t\"incoming query.\");\n\t\t\tcomm_point_drop_reply(rep);\n\t\t\tmesh->stats_dropped++;\n\t\t\treturn;\n\t\t}\n\t\t/* for this new reply state, the reply address is free,\n\t\t * so the limit of reply addresses does not stop reply states*/\n\t} else {\n\t\t/* protect our memory usage from storing reply addresses */\n\t\tif(mesh->num_reply_addrs > mesh->max_reply_states*16) {\n\t\t\tverbose(VERB_ALGO, \"Too many requests queued. \"\n\t\t\t\t\"dropping incoming query.\");\n\t\t\tcomm_point_drop_reply(rep);\n\t\t\tmesh->stats_dropped++;\n\t\t\treturn;\n\t\t}\n\t}\n\t/* see if it already exists, if not, create one */\n\tif(!s) {\n#ifdef UNBOUND_DEBUG\n\t\tstruct rbnode_type* n;\n#endif\n\t\ts = mesh_state_create(mesh->env, qinfo, cinfo,\n\t\t\tqflags&(BIT_RD|BIT_CD), 0, 0);\n\t\tif(!s) {\n\t\t\tlog_err(\"mesh_state_create: out of memory; SERVFAIL\");\n\t\t\tif(!inplace_cb_reply_servfail_call(mesh->env, qinfo, NULL, NULL,\n\t\t\t\tLDNS_RCODE_SERVFAIL, edns, rep, mesh->env->scratch, mesh->env->now_tv))\n\t\t\t\t\tedns->opt_list_inplace_cb_out = NULL;\n\t\t\terror_encode(r_buffer, LDNS_RCODE_SERVFAIL,\n\t\t\t\tqinfo, qid, qflags, edns);\n\t\t\tcomm_point_send_reply(rep);\n\t\t\treturn;\n\t\t}\n\t\t/* set detached (it is now) */\n\t\tmesh->num_detached_states++;\n\t\tif(unique)\n\t\t\tmesh_state_make_unique(s);\n\t\ts->s.rpz_passthru = rpz_passthru;\n\t\t/* copy the edns options we got from the front */\n\t\tif(edns->opt_list_in) {\n\t\t\ts->s.edns_opts_front_in = edns_opt_copy_region(edns->opt_list_in,\n\t\t\t\ts->s.region);\n\t\t\tif(!s->s.edns_opts_front_in) {\n\t\t\t\tlog_err(\"edns_opt_copy_region: out of memory; SERVFAIL\");\n\t\t\t\tif(!inplace_cb_reply_servfail_call(mesh->env, qinfo, NULL,\n\t\t\t\t\tNULL, LDNS_RCODE_SERVFAIL, edns, rep, mesh->env->scratch, mesh->env->now_tv))\n\t\t\t\t\t\tedns->opt_list_inplace_cb_out = NULL;\n\t\t\t\terror_encode(r_buffer, LDNS_RCODE_SERVFAIL,\n\t\t\t\t\tqinfo, qid, qflags, edns);\n\t\t\t\tcomm_point_send_reply(rep);\n\t\t\t\tmesh_state_delete(&s->s);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n#ifdef UNBOUND_DEBUG\n\t\tn =\n#else\n\t\t(void)\n#endif\n\t\trbtree_insert(&mesh->all, &s->node);\n\t\tlog_assert(n != NULL);\n\t\tadded = 1;\n\t}\n\tif(!s->reply_list && !s->cb_list) {\n\t\twas_noreply = 1;\n\t\tif(s->super_set.count == 0) {\n\t\t\twas_detached = 1;\n\t\t}\n\t}\n\t/* add reply to s */\n\tif(!mesh_state_add_reply(s, edns, rep, qid, qflags, qinfo)) {\n\t\tlog_err(\"mesh_new_client: out of memory; SERVFAIL\");\n\t\tgoto servfail_mem;\n\t}\n\tif(rep->c->tcp_req_info) {\n\t\tif(!tcp_req_info_add_meshstate(rep->c->tcp_req_info, mesh, s)) {\n\t\t\tlog_err(\"mesh_new_client: out of memory add tcpreqinfo\");\n\t\t\tgoto servfail_mem;\n\t\t}\n\t}\n\tif(rep->c->use_h2) {\n\t\thttp2_stream_add_meshstate(rep->c->h2_stream, mesh, s);\n\t}\n\t/* add serve expired timer if required and not already there */\n\tif(timeout && !mesh_serve_expired_init(s, timeout)) {\n\t\tlog_err(\"mesh_new_client: out of memory initializing serve expired\");\n\t\tgoto servfail_mem;\n\t}\n#ifdef USE_CACHEDB\n\tif(!timeout && mesh->env->cfg->serve_expired &&\n\t\t!mesh->env->cfg->serve_expired_client_timeout &&\n\t\t(mesh->env->cachedb_enabled &&\n\t\t mesh->env->cfg->cachedb_check_when_serve_expired)) {\n\t\tif(!mesh_serve_expired_init(s, -1)) {\n\t\t\tlog_err(\"mesh_new_client: out of memory initializing serve expired\");\n\t\t\tgoto servfail_mem;\n\t\t}\n\t}\n#endif\n\tinfra_wait_limit_inc(mesh->env->infra_cache, rep, *mesh->env->now,\n\t\tmesh->env->cfg);\n\t/* update statistics */\n\tif(was_detached) {\n\t\tlog_assert(mesh->num_detached_states > 0);\n\t\tmesh->num_detached_states--;\n\t}\n\tif(was_noreply) {\n\t\tmesh->num_reply_states ++;\n\t}\n\tmesh->num_reply_addrs++;\n\tif(s->list_select == mesh_no_list) {\n\t\t/* move to either the forever or the jostle_list */\n\t\tif(mesh->num_forever_states < mesh->max_forever_states) {\n\t\t\tmesh->num_forever_states ++;\n\t\t\tmesh_list_insert(s, &mesh->forever_first,\n\t\t\t\t&mesh->forever_last);\n\t\t\ts->list_select = mesh_forever_list;\n\t\t} else {\n\t\t\tmesh_list_insert(s, &mesh->jostle_first,\n\t\t\t\t&mesh->jostle_last);\n\t\t\ts->list_select = mesh_jostle_list;\n\t\t}\n\t}\n\tif(added)\n\t\tmesh_run(mesh, s, module_event_new, NULL);\n\treturn;\n\nservfail_mem:\n\tif(!inplace_cb_reply_servfail_call(mesh->env, qinfo, &s->s,\n\t\tNULL, LDNS_RCODE_SERVFAIL, edns, rep, mesh->env->scratch, mesh->env->now_tv))\n\t\t\tedns->opt_list_inplace_cb_out = NULL;\n\terror_encode(r_buffer, LDNS_RCODE_SERVFAIL,\n\t\tqinfo, qid, qflags, edns);\n\tcomm_point_send_reply(rep);\n\tif(added)\n\t\tmesh_state_delete(&s->s);\n\treturn;\n}",
      "cve_list": [
        "CVE-2024-33655"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "unbound",
      "filepath": "services/mesh.c",
      "func_name": "mesh_query_done",
      "func_body": "void mesh_query_done(struct mesh_state* mstate)\n{\n\tstruct mesh_reply* r;\n\tstruct mesh_reply* prev = NULL;\n\tstruct sldns_buffer* prev_buffer = NULL;\n\tstruct mesh_cb* c;\n\tstruct reply_info* rep = (mstate->s.return_msg?\n\t\tmstate->s.return_msg->rep:NULL);\n\tstruct timeval tv = {0, 0};\n\tint i = 0;\n\t/* No need for the serve expired timer anymore; we are going to reply. */\n\tif(mstate->s.serve_expired_data) {\n\t\tcomm_timer_delete(mstate->s.serve_expired_data->timer);\n\t\tmstate->s.serve_expired_data->timer = NULL;\n\t}\n\tif(mstate->s.return_rcode == LDNS_RCODE_SERVFAIL ||\n\t\t(rep && FLAGS_GET_RCODE(rep->flags) == LDNS_RCODE_SERVFAIL)) {\n\t\t/* we are SERVFAILing; check for expired answer here */\n\t\tmesh_serve_expired_callback(mstate);\n\t\tif((mstate->reply_list || mstate->cb_list)\n\t\t&& mstate->s.env->cfg->log_servfail\n\t\t&& !mstate->s.env->cfg->val_log_squelch) {\n\t\t\tchar* err = errinf_to_str_servfail(&mstate->s);\n\t\t\tif(err) { log_err(\"%s\", err); }\n\t\t}\n\t}\n\tfor(r = mstate->reply_list; r; r = r->next) {\n\t\tstruct timeval old;\n\t\ttimeval_subtract(&old, mstate->s.env->now_tv, &r->start_time);\n\t\tif(mstate->s.env->cfg->discard_timeout != 0 &&\n\t\t\t((int)old.tv_sec)*1000+((int)old.tv_usec)/1000 >\n\t\t\tmstate->s.env->cfg->discard_timeout) {\n\t\t\t/* Drop the reply, it is too old */\n\t\t\t/* briefly set the reply_list to NULL, so that the\n\t\t\t * tcp req info cleanup routine that calls the mesh\n\t\t\t * to deregister the meshstate for it is not done\n\t\t\t * because the list is NULL and also accounting is not\n\t\t\t * done there, but instead we do that here. */\n\t\t\tstruct mesh_reply* reply_list = mstate->reply_list;\n\t\t\tverbose(VERB_ALGO, \"drop reply, it is older than discard-timeout\");\n\t\t\tinfra_wait_limit_dec(mstate->s.env->infra_cache,\n\t\t\t\t&r->query_reply, mstate->s.env->cfg);\n\t\t\tmstate->reply_list = NULL;\n\t\t\tcomm_point_drop_reply(&r->query_reply);\n\t\t\tmstate->reply_list = reply_list;\n\t\t\tmstate->s.env->mesh->stats_dropped++;\n\t\t\tcontinue;\n\t\t}\n\n\t\ti++;\n\t\ttv = r->start_time;\n\n\t\t/* if a response-ip address block has been stored the\n\t\t *  information should be logged for each client. */\n\t\tif(mstate->s.respip_action_info &&\n\t\t\tmstate->s.respip_action_info->addrinfo) {\n\t\t\trespip_inform_print(mstate->s.respip_action_info,\n\t\t\t\tr->qname, mstate->s.qinfo.qtype,\n\t\t\t\tmstate->s.qinfo.qclass, r->local_alias,\n\t\t\t\t&r->query_reply.client_addr,\n\t\t\t\tr->query_reply.client_addrlen);\n\t\t}\n\n\t\t/* if this query is determined to be dropped during the\n\t\t * mesh processing, this is the point to take that action. */\n\t\tif(mstate->s.is_drop) {\n\t\t\t/* briefly set the reply_list to NULL, so that the\n\t\t\t * tcp req info cleanup routine that calls the mesh\n\t\t\t * to deregister the meshstate for it is not done\n\t\t\t * because the list is NULL and also accounting is not\n\t\t\t * done there, but instead we do that here. */\n\t\t\tstruct mesh_reply* reply_list = mstate->reply_list;\n\t\t\tinfra_wait_limit_dec(mstate->s.env->infra_cache,\n\t\t\t\t&r->query_reply, mstate->s.env->cfg);\n\t\t\tmstate->reply_list = NULL;\n\t\t\tcomm_point_drop_reply(&r->query_reply);\n\t\t\tmstate->reply_list = reply_list;\n\t\t} else {\n\t\t\tstruct sldns_buffer* r_buffer = r->query_reply.c->buffer;\n\t\t\tif(r->query_reply.c->tcp_req_info) {\n\t\t\t\tr_buffer = r->query_reply.c->tcp_req_info->spool_buffer;\n\t\t\t\tprev_buffer = NULL;\n\t\t\t}\n\t\t\tmesh_send_reply(mstate, mstate->s.return_rcode, rep,\n\t\t\t\tr, r_buffer, prev, prev_buffer);\n\t\t\tif(r->query_reply.c->tcp_req_info) {\n\t\t\t\ttcp_req_info_remove_mesh_state(r->query_reply.c->tcp_req_info, mstate);\n\t\t\t\tr_buffer = NULL;\n\t\t\t}\n\t\t\tprev = r;\n\t\t\tprev_buffer = r_buffer;\n\t\t}\n\t}\n\t/* Account for each reply sent. */\n\tif(i > 0 && mstate->s.respip_action_info &&\n\t\tmstate->s.respip_action_info->addrinfo &&\n\t\tmstate->s.env->cfg->stat_extended &&\n\t\tmstate->s.respip_action_info->rpz_used) {\n\t\tif(mstate->s.respip_action_info->rpz_disabled)\n\t\t\tmstate->s.env->mesh->rpz_action[RPZ_DISABLED_ACTION] += i;\n\t\tif(mstate->s.respip_action_info->rpz_cname_override)\n\t\t\tmstate->s.env->mesh->rpz_action[RPZ_CNAME_OVERRIDE_ACTION] += i;\n\t\telse\n\t\t\tmstate->s.env->mesh->rpz_action[respip_action_to_rpz_action(\n\t\t\t\tmstate->s.respip_action_info->action)] += i;\n\t}\n\tif(!mstate->s.is_drop && i > 0) {\n\t\tif(mstate->s.env->cfg->stat_extended\n\t\t\t&& mstate->s.is_cachedb_answer) {\n\t\t\tmstate->s.env->mesh->ans_cachedb += i;\n\t\t}\n\t}\n\n\t/* Mesh area accounting */\n\tif(mstate->reply_list) {\n\t\tmstate->reply_list = NULL;\n\t\tif(!mstate->reply_list && !mstate->cb_list) {\n\t\t\t/* was a reply state, not anymore */\n\t\t\tlog_assert(mstate->s.env->mesh->num_reply_states > 0);\n\t\t\tmstate->s.env->mesh->num_reply_states--;\n\t\t}\n\t\tif(!mstate->reply_list && !mstate->cb_list &&\n\t\t\tmstate->super_set.count == 0)\n\t\t\tmstate->s.env->mesh->num_detached_states++;\n\t}\n\tmstate->replies_sent = 1;\n\n\twhile((c = mstate->cb_list) != NULL) {\n\t\t/* take this cb off the list; so that the list can be\n\t\t * changed, eg. by adds from the callback routine */\n\t\tif(!mstate->reply_list && mstate->cb_list && !c->next) {\n\t\t\t/* was a reply state, not anymore */\n\t\t\tlog_assert(mstate->s.env->mesh->num_reply_states > 0);\n\t\t\tmstate->s.env->mesh->num_reply_states--;\n\t\t}\n\t\tmstate->cb_list = c->next;\n\t\tif(!mstate->reply_list && !mstate->cb_list &&\n\t\t\tmstate->super_set.count == 0)\n\t\t\tmstate->s.env->mesh->num_detached_states++;\n\t\tmesh_do_callback(mstate, mstate->s.return_rcode, rep, c, &tv);\n\t}\n}",
      "cve_list": [
        "CVE-2024-33655"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "unbound",
      "filepath": "services/mesh.c",
      "func_name": "mesh_send_reply",
      "func_body": "mesh_send_reply(struct mesh_state* m, int rcode, struct reply_info* rep,\n\tstruct mesh_reply* r, struct sldns_buffer* r_buffer,\n\tstruct mesh_reply* prev, struct sldns_buffer* prev_buffer)\n{\n\tstruct timeval end_time;\n\tstruct timeval duration;\n\tint secure;\n\t/* briefly set the replylist to null in case the\n\t * meshsendreply calls tcpreqinfo sendreply that\n\t * comm_point_drops because of size, and then the\n\t * null stops the mesh state remove and thus\n\t * reply_list modification and accounting */\n\tstruct mesh_reply* rlist = m->reply_list;\n\n\t/* rpz: apply actions */\n\trcode = mesh_is_udp(r) && mesh_is_rpz_respip_tcponly_action(m)\n\t\t\t? (rcode|BIT_TC) : rcode;\n\n\t/* examine security status */\n\tif(m->s.env->need_to_validate && (!(r->qflags&BIT_CD) ||\n\t\tm->s.env->cfg->ignore_cd) && rep &&\n\t\t(rep->security <= sec_status_bogus ||\n\t\trep->security == sec_status_secure_sentinel_fail)) {\n\t\trcode = LDNS_RCODE_SERVFAIL;\n\t\tif(m->s.env->cfg->stat_extended)\n\t\t\tm->s.env->mesh->ans_bogus++;\n\t}\n\tif(rep && rep->security == sec_status_secure)\n\t\tsecure = 1;\n\telse\tsecure = 0;\n\tif(!rep && rcode == LDNS_RCODE_NOERROR)\n\t\trcode = LDNS_RCODE_SERVFAIL;\n\tif(r->query_reply.c->use_h2) {\n\t\tr->query_reply.c->h2_stream = r->h2_stream;\n\t\t/* Mesh reply won't exist for long anymore. Make it impossible\n\t\t * for HTTP/2 stream to refer to mesh state, in case\n\t\t * connection gets cleanup before HTTP/2 stream close. */\n\t\tr->h2_stream->mesh_state = NULL;\n\t}\n\t/* send the reply */\n\t/* We don't reuse the encoded answer if:\n\t * - either the previous or current response has a local alias.  We could\n\t *   compare the alias records and still reuse the previous answer if they\n\t *   are the same, but that would be complicated and error prone for the\n\t *   relatively minor case. So we err on the side of safety.\n\t * - there are registered callback functions for the given rcode, as these\n\t *   need to be called for each reply. */\n\tif(((rcode != LDNS_RCODE_SERVFAIL &&\n\t\t\t!m->s.env->inplace_cb_lists[inplace_cb_reply]) ||\n\t\t(rcode == LDNS_RCODE_SERVFAIL &&\n\t\t\t!m->s.env->inplace_cb_lists[inplace_cb_reply_servfail])) &&\n\t\tprev && prev_buffer && prev->qflags == r->qflags &&\n\t\t!prev->local_alias && !r->local_alias &&\n\t\tprev->edns.edns_present == r->edns.edns_present &&\n\t\tprev->edns.bits == r->edns.bits &&\n\t\tprev->edns.udp_size == r->edns.udp_size &&\n\t\tedns_opt_list_compare(prev->edns.opt_list_out, r->edns.opt_list_out) == 0 &&\n\t\tedns_opt_list_compare(prev->edns.opt_list_inplace_cb_out, r->edns.opt_list_inplace_cb_out) == 0\n\t\t) {\n\t\t/* if the previous reply is identical to this one, fix ID */\n\t\tif(prev_buffer != r_buffer)\n\t\t\tsldns_buffer_copy(r_buffer, prev_buffer);\n\t\tsldns_buffer_write_at(r_buffer, 0, &r->qid, sizeof(uint16_t));\n\t\tsldns_buffer_write_at(r_buffer, 12, r->qname,\n\t\t\tm->s.qinfo.qname_len);\n\t\tm->reply_list = NULL;\n\t\tcomm_point_send_reply(&r->query_reply);\n\t\tm->reply_list = rlist;\n\t} else if(rcode) {\n\t\tm->s.qinfo.qname = r->qname;\n\t\tm->s.qinfo.local_alias = r->local_alias;\n\t\tif(rcode == LDNS_RCODE_SERVFAIL) {\n\t\t\tif(!inplace_cb_reply_servfail_call(m->s.env, &m->s.qinfo, &m->s,\n\t\t\t\trep, rcode, &r->edns, &r->query_reply, m->s.region, &r->start_time))\n\t\t\t\t\tr->edns.opt_list_inplace_cb_out = NULL;\n\t\t} else {\n\t\t\tif(!inplace_cb_reply_call(m->s.env, &m->s.qinfo, &m->s, rep, rcode,\n\t\t\t\t&r->edns, &r->query_reply, m->s.region, &r->start_time))\n\t\t\t\t\tr->edns.opt_list_inplace_cb_out = NULL;\n\t\t}\n\t\t/* Send along EDE EDNS0 option when SERVFAILing; usually\n\t\t * DNSSEC validation failures */\n\t\t/* Since we are SERVFAILing here, CD bit and rep->security\n\t\t * is already handled. */\n\t\tif(m->s.env->cfg->ede && rep) {\n\t\t\tmesh_find_and_attach_ede_and_reason(m, rep, r);\n\t\t}\n\t\terror_encode(r_buffer, rcode, &m->s.qinfo, r->qid,\n\t\t\tr->qflags, &r->edns);\n\t\tm->reply_list = NULL;\n\t\tcomm_point_send_reply(&r->query_reply);\n\t\tm->reply_list = rlist;\n\t} else {\n\t\tsize_t udp_size = r->edns.udp_size;\n\t\tr->edns.edns_version = EDNS_ADVERTISED_VERSION;\n\t\tr->edns.udp_size = EDNS_ADVERTISED_SIZE;\n\t\tr->edns.ext_rcode = 0;\n\t\tr->edns.bits &= EDNS_DO;\n\t\tif(m->s.env->cfg->disable_edns_do && (r->edns.bits&EDNS_DO))\n\t\t\tr->edns.edns_present = 0;\n\t\tm->s.qinfo.qname = r->qname;\n\t\tm->s.qinfo.local_alias = r->local_alias;\n\n\t\t/* Attach EDE without SERVFAIL if the validation failed.\n\t\t * Need to explicitly check for rep->security otherwise failed\n\t\t * validation paths may attach to a secure answer. */\n\t\tif(m->s.env->cfg->ede && rep &&\n\t\t\t(rep->security <= sec_status_bogus ||\n\t\t\trep->security == sec_status_secure_sentinel_fail)) {\n\t\t\tmesh_find_and_attach_ede_and_reason(m, rep, r);\n\t\t}\n\n\t\tif(!inplace_cb_reply_call(m->s.env, &m->s.qinfo, &m->s, rep,\n\t\t\tLDNS_RCODE_NOERROR, &r->edns, &r->query_reply, m->s.region, &r->start_time) ||\n\t\t\t!reply_info_answer_encode(&m->s.qinfo, rep, r->qid,\n\t\t\tr->qflags, r_buffer, 0, 1, m->s.env->scratch,\n\t\t\tudp_size, &r->edns, (int)(r->edns.bits & EDNS_DO),\n\t\t\tsecure))\n\t\t{\n\t\t\tif(!inplace_cb_reply_servfail_call(m->s.env, &m->s.qinfo, &m->s,\n\t\t\trep, LDNS_RCODE_SERVFAIL, &r->edns, &r->query_reply, m->s.region, &r->start_time))\n\t\t\t\tr->edns.opt_list_inplace_cb_out = NULL;\n\t\t\t/* internal server error (probably malloc failure) so no\n\t\t\t * EDE (RFC8914) needed */\n\t\t\terror_encode(r_buffer, LDNS_RCODE_SERVFAIL,\n\t\t\t\t&m->s.qinfo, r->qid, r->qflags, &r->edns);\n\t\t}\n\t\tm->reply_list = NULL;\n\t\tcomm_point_send_reply(&r->query_reply);\n\t\tm->reply_list = rlist;\n\t}\n\tinfra_wait_limit_dec(m->s.env->infra_cache, &r->query_reply,\n\t\tm->s.env->cfg);\n\t/* account */\n\tlog_assert(m->s.env->mesh->num_reply_addrs > 0);\n\tm->s.env->mesh->num_reply_addrs--;\n\tend_time = *m->s.env->now_tv;\n\ttimeval_subtract(&duration, &end_time, &r->start_time);\n\tverbose(VERB_ALGO, \"query took \" ARG_LL \"d.%6.6d sec\",\n\t\t(long long)duration.tv_sec, (int)duration.tv_usec);\n\tm->s.env->mesh->replies_sent++;\n\ttimeval_add(&m->s.env->mesh->replies_sum_wait, &duration);\n\ttimehist_insert(m->s.env->mesh->histogram, &duration);\n\tif(m->s.env->cfg->stat_extended) {\n\t\tuint16_t rc = FLAGS_GET_RCODE(sldns_buffer_read_u16_at(\n\t\t\tr_buffer, 2));\n\t\tif(secure) m->s.env->mesh->ans_secure++;\n\t\tm->s.env->mesh->ans_rcode[ rc ] ++;\n\t\tif(rc == 0 && LDNS_ANCOUNT(sldns_buffer_begin(r_buffer)) == 0)\n\t\t\tm->s.env->mesh->ans_nodata++;\n\t}\n\t/* Log reply sent */\n\tif(m->s.env->cfg->log_replies) {\n\t\tlog_reply_info(NO_VERBOSE, &m->s.qinfo,\n\t\t\t&r->query_reply.client_addr,\n\t\t\tr->query_reply.client_addrlen, duration, 0, r_buffer,\n\t\t\t(m->s.env->cfg->log_destaddr?(void*)r->query_reply.c->socket->addr:NULL),\n\t\t\tr->query_reply.c->type);\n\t}\n}",
      "cve_list": [
        "CVE-2024-33655"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "unbound",
      "filepath": "services/mesh.c",
      "func_name": "mesh_serve_expired_callback",
      "func_body": "mesh_serve_expired_callback(void* arg)\n{\n\tstruct mesh_state* mstate = (struct mesh_state*) arg;\n\tstruct module_qstate* qstate = &mstate->s;\n\tstruct mesh_reply* r;\n\tstruct mesh_area* mesh = qstate->env->mesh;\n\tstruct dns_msg* msg;\n\tstruct mesh_cb* c;\n\tstruct mesh_reply* prev = NULL;\n\tstruct sldns_buffer* prev_buffer = NULL;\n\tstruct sldns_buffer* r_buffer = NULL;\n\tstruct reply_info* partial_rep = NULL;\n\tstruct ub_packed_rrset_key* alias_rrset = NULL;\n\tstruct reply_info* encode_rep = NULL;\n\tstruct respip_action_info actinfo;\n\tstruct query_info* lookup_qinfo = &qstate->qinfo;\n\tstruct query_info qinfo_tmp;\n\tstruct timeval tv = {0, 0};\n\tint must_validate = (!(qstate->query_flags&BIT_CD)\n\t\t|| qstate->env->cfg->ignore_cd) && qstate->env->need_to_validate;\n\tint i = 0;\n\tif(!qstate->serve_expired_data) return;\n\tverbose(VERB_ALGO, \"Serve expired: Trying to reply with expired data\");\n\tcomm_timer_delete(qstate->serve_expired_data->timer);\n\tqstate->serve_expired_data->timer = NULL;\n\t/* If is_drop or no_cache_lookup (modules that handle their own cache e.g.,\n\t * subnetmod) ignore stale data from the main cache. */\n\tif(qstate->no_cache_lookup || qstate->is_drop) {\n\t\tverbose(VERB_ALGO,\n\t\t\t\"Serve expired: Not allowed to look into cache for stale\");\n\t\treturn;\n\t}\n\t/* The following while is used instead of the `goto lookup_cache`\n\t * like in the worker. */\n\twhile(1) {\n\t\tfptr_ok(fptr_whitelist_serve_expired_lookup(\n\t\t\tqstate->serve_expired_data->get_cached_answer));\n\t\tmsg = (*qstate->serve_expired_data->get_cached_answer)(qstate,\n\t\t\tlookup_qinfo);\n\t\tif(!msg)\n\t\t\treturn;\n\t\t/* Reset these in case we pass a second time from here. */\n\t\tencode_rep = msg->rep;\n\t\tmemset(&actinfo, 0, sizeof(actinfo));\n\t\tactinfo.action = respip_none;\n\t\talias_rrset = NULL;\n\t\tif((mesh->use_response_ip || mesh->use_rpz) &&\n\t\t\t!partial_rep && !apply_respip_action(qstate, &qstate->qinfo,\n\t\t\tqstate->client_info, &actinfo, msg->rep, &alias_rrset, &encode_rep,\n\t\t\tqstate->env->auth_zones)) {\n\t\t\treturn;\n\t\t} else if(partial_rep &&\n\t\t\t!respip_merge_cname(partial_rep, &qstate->qinfo, msg->rep,\n\t\t\tqstate->client_info, must_validate, &encode_rep, qstate->region,\n\t\t\tqstate->env->auth_zones)) {\n\t\t\treturn;\n\t\t}\n\t\tif(!encode_rep || alias_rrset) {\n\t\t\tif(!encode_rep) {\n\t\t\t\t/* Needs drop */\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\t/* A partial CNAME chain is found. */\n\t\t\t\tpartial_rep = encode_rep;\n\t\t\t}\n\t\t}\n\t\t/* We've found a partial reply ending with an\n\t\t* alias.  Replace the lookup qinfo for the\n\t\t* alias target and lookup the cache again to\n\t\t* (possibly) complete the reply.  As we're\n\t\t* passing the \"base\" reply, there will be no\n\t\t* more alias chasing. */\n\t\tif(partial_rep) {\n\t\t\tmemset(&qinfo_tmp, 0, sizeof(qinfo_tmp));\n\t\t\tget_cname_target(alias_rrset, &qinfo_tmp.qname,\n\t\t\t\t&qinfo_tmp.qname_len);\n\t\t\tif(!qinfo_tmp.qname) {\n\t\t\t\tlog_err(\"Serve expired: unexpected: invalid answer alias\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tqinfo_tmp.qtype = qstate->qinfo.qtype;\n\t\t\tqinfo_tmp.qclass = qstate->qinfo.qclass;\n\t\t\tlookup_qinfo = &qinfo_tmp;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif(verbosity >= VERB_ALGO)\n\t\tlog_dns_msg(\"Serve expired lookup\", &qstate->qinfo, msg->rep);\n\n\tfor(r = mstate->reply_list; r; r = r->next) {\n\t\tstruct timeval old;\n\t\ttimeval_subtract(&old, mstate->s.env->now_tv, &r->start_time);\n\t\tif(mstate->s.env->cfg->discard_timeout != 0 &&\n\t\t\t((int)old.tv_sec)*1000+((int)old.tv_usec)/1000 >\n\t\t\tmstate->s.env->cfg->discard_timeout) {\n\t\t\t/* Drop the reply, it is too old */\n\t\t\t/* briefly set the reply_list to NULL, so that the\n\t\t\t * tcp req info cleanup routine that calls the mesh\n\t\t\t * to deregister the meshstate for it is not done\n\t\t\t * because the list is NULL and also accounting is not\n\t\t\t * done there, but instead we do that here. */\n\t\t\tstruct mesh_reply* reply_list = mstate->reply_list;\n\t\t\tverbose(VERB_ALGO, \"drop reply, it is older than discard-timeout\");\n\t\t\tinfra_wait_limit_dec(mstate->s.env->infra_cache,\n\t\t\t\t&r->query_reply, mstate->s.env->cfg);\n\t\t\tmstate->reply_list = NULL;\n\t\t\tcomm_point_drop_reply(&r->query_reply);\n\t\t\tmstate->reply_list = reply_list;\n\t\t\tmstate->s.env->mesh->stats_dropped++;\n\t\t\tcontinue;\n\t\t}\n\n\t\ti++;\n\t\ttv = r->start_time;\n\n\t\t/* If address info is returned, it means the action should be an\n\t\t* 'inform' variant and the information should be logged. */\n\t\tif(actinfo.addrinfo) {\n\t\t\trespip_inform_print(&actinfo, r->qname,\n\t\t\t\tqstate->qinfo.qtype, qstate->qinfo.qclass,\n\t\t\t\tr->local_alias, &r->query_reply.client_addr,\n\t\t\t\tr->query_reply.client_addrlen);\n\t\t}\n\n\t\t/* Add EDE Stale Answer (RCF8914). Ignore global ede as this is\n\t\t * warning instead of an error */\n\t\tif (r->edns.edns_present && qstate->env->cfg->ede_serve_expired &&\n\t\t\tqstate->env->cfg->ede) {\n\t\t\tedns_opt_list_append_ede(&r->edns.opt_list_out,\n\t\t\t\tmstate->s.region, LDNS_EDE_STALE_ANSWER, NULL);\n\t\t}\n\n\t\tr_buffer = r->query_reply.c->buffer;\n\t\tif(r->query_reply.c->tcp_req_info)\n\t\t\tr_buffer = r->query_reply.c->tcp_req_info->spool_buffer;\n\t\tmesh_send_reply(mstate, LDNS_RCODE_NOERROR, msg->rep,\n\t\t\tr, r_buffer, prev, prev_buffer);\n\t\tif(r->query_reply.c->tcp_req_info)\n\t\t\ttcp_req_info_remove_mesh_state(r->query_reply.c->tcp_req_info, mstate);\n\t\tinfra_wait_limit_dec(mstate->s.env->infra_cache,\n\t\t\t&r->query_reply, mstate->s.env->cfg);\n\t\tprev = r;\n\t\tprev_buffer = r_buffer;\n\t}\n\t/* Account for each reply sent. */\n\tif(i > 0) {\n\t\tmesh->ans_expired += i;\n\t\tif(actinfo.addrinfo && qstate->env->cfg->stat_extended &&\n\t\t\tactinfo.rpz_used) {\n\t\t\tif(actinfo.rpz_disabled)\n\t\t\t\tqstate->env->mesh->rpz_action[RPZ_DISABLED_ACTION] += i;\n\t\t\tif(actinfo.rpz_cname_override)\n\t\t\t\tqstate->env->mesh->rpz_action[RPZ_CNAME_OVERRIDE_ACTION] += i;\n\t\t\telse\n\t\t\t\tqstate->env->mesh->rpz_action[\n\t\t\t\t\trespip_action_to_rpz_action(actinfo.action)] += i;\n\t\t}\n\t}\n\n\t/* Mesh area accounting */\n\tif(mstate->reply_list) {\n\t\tmstate->reply_list = NULL;\n\t\tif(!mstate->reply_list && !mstate->cb_list) {\n\t\t\tlog_assert(mesh->num_reply_states > 0);\n\t\t\tmesh->num_reply_states--;\n\t\t\tif(mstate->super_set.count == 0) {\n\t\t\t\tmesh->num_detached_states++;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile((c = mstate->cb_list) != NULL) {\n\t\t/* take this cb off the list; so that the list can be\n\t\t * changed, eg. by adds from the callback routine */\n\t\tif(!mstate->reply_list && mstate->cb_list && !c->next) {\n\t\t\t/* was a reply state, not anymore */\n\t\t\tlog_assert(qstate->env->mesh->num_reply_states > 0);\n\t\t\tqstate->env->mesh->num_reply_states--;\n\t\t}\n\t\tmstate->cb_list = c->next;\n\t\tif(!mstate->reply_list && !mstate->cb_list &&\n\t\t\tmstate->super_set.count == 0)\n\t\t\tqstate->env->mesh->num_detached_states++;\n\t\tmesh_do_callback(mstate, LDNS_RCODE_NOERROR, msg->rep, c, &tv);\n\t}\n}",
      "cve_list": [
        "CVE-2024-33655"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "unbound",
      "filepath": "services/mesh.c",
      "func_name": "mesh_state_cleanup",
      "func_body": "mesh_state_cleanup(struct mesh_state* mstate)\n{\n\tstruct mesh_area* mesh;\n\tint i;\n\tif(!mstate)\n\t\treturn;\n\tmesh = mstate->s.env->mesh;\n\t/* Stop and delete the serve expired timer */\n\tif(mstate->s.serve_expired_data && mstate->s.serve_expired_data->timer) {\n\t\tcomm_timer_delete(mstate->s.serve_expired_data->timer);\n\t\tmstate->s.serve_expired_data->timer = NULL;\n\t}\n\t/* drop unsent replies */\n\tif(!mstate->replies_sent) {\n\t\tstruct mesh_reply* rep = mstate->reply_list;\n\t\tstruct mesh_cb* cb;\n\t\t/* in tcp_req_info, the mstates linked are removed, but\n\t\t * the reply_list is now NULL, so the remove-from-empty-list\n\t\t * takes no time and also it does not do the mesh accounting */\n\t\tmstate->reply_list = NULL;\n\t\tfor(; rep; rep=rep->next) {\n\t\t\tinfra_wait_limit_dec(mesh->env->infra_cache,\n\t\t\t\t&rep->query_reply, mesh->env->cfg);\n\t\t\tcomm_point_drop_reply(&rep->query_reply);\n\t\t\tlog_assert(mesh->num_reply_addrs > 0);\n\t\t\tmesh->num_reply_addrs--;\n\t\t}\n\t\twhile((cb = mstate->cb_list)!=NULL) {\n\t\t\tmstate->cb_list = cb->next;\n\t\t\tfptr_ok(fptr_whitelist_mesh_cb(cb->cb));\n\t\t\t(*cb->cb)(cb->cb_arg, LDNS_RCODE_SERVFAIL, NULL,\n\t\t\t\tsec_status_unchecked, NULL, 0);\n\t\t\tlog_assert(mesh->num_reply_addrs > 0);\n\t\t\tmesh->num_reply_addrs--;\n\t\t}\n\t}\n\n\t/* de-init modules */\n\tfor(i=0; i<mesh->mods.num; i++) {\n\t\tfptr_ok(fptr_whitelist_mod_clear(mesh->mods.mod[i]->clear));\n\t\t(*mesh->mods.mod[i]->clear)(&mstate->s, i);\n\t\tmstate->s.minfo[i] = NULL;\n\t\tmstate->s.ext_state[i] = module_finished;\n\t}\n\talloc_reg_release(mstate->s.env->alloc, mstate->s.region);\n}",
      "cve_list": [
        "CVE-2024-33655"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "unbound",
      "filepath": "services/mesh.c",
      "func_name": "mesh_state_remove_reply",
      "func_body": "void mesh_state_remove_reply(struct mesh_area* mesh, struct mesh_state* m,\n\tstruct comm_point* cp)\n{\n\tstruct mesh_reply* n, *prev = NULL;\n\tn = m->reply_list;\n\t/* when in mesh_cleanup, it sets the reply_list to NULL, so that\n\t * there is no accounting twice */\n\tif(!n) return; /* nothing to remove, also no accounting needed */\n\twhile(n) {\n\t\tif(n->query_reply.c == cp) {\n\t\t\t/* unlink it */\n\t\t\tif(prev) prev->next = n->next;\n\t\t\telse m->reply_list = n->next;\n\t\t\t/* delete it, but allocated in m region */\n\t\t\tlog_assert(mesh->num_reply_addrs > 0);\n\t\t\tmesh->num_reply_addrs--;\n\t\t\tinfra_wait_limit_dec(mesh->env->infra_cache,\n\t\t\t\t&n->query_reply, mesh->env->cfg);\n\n\t\t\t/* prev = prev; */\n\t\t\tn = n->next;\n\t\t\tcontinue;\n\t\t}\n\t\tprev = n;\n\t\tn = n->next;\n\t}\n\t/* it was not detached (because it had a reply list), could be now */\n\tif(!m->reply_list && !m->cb_list\n\t\t&& m->super_set.count == 0) {\n\t\tmesh->num_detached_states++;\n\t}\n\t/* if not replies any more in mstate, it is no longer a reply_state */\n\tif(!m->reply_list && !m->cb_list) {\n\t\tlog_assert(mesh->num_reply_states > 0);\n\t\tmesh->num_reply_states--;\n\t}\n}",
      "cve_list": [
        "CVE-2024-33655"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "unbound",
      "filepath": "util/config_file.c",
      "func_name": "config_create",
      "func_body": "config_create(void)\n{\n\tstruct config_file* cfg;\n\tcfg = (struct config_file*)calloc(1, sizeof(struct config_file));\n\tif(!cfg)\n\t\treturn NULL;\n\t/* the defaults if no config is present */\n\tcfg->verbosity = 1;\n\tcfg->stat_interval = 0;\n\tcfg->stat_cumulative = 0;\n\tcfg->stat_extended = 0;\n\tcfg->stat_inhibit_zero = 1;\n\tcfg->num_threads = 1;\n\tcfg->port = UNBOUND_DNS_PORT;\n\tcfg->do_ip4 = 1;\n\tcfg->do_ip6 = 1;\n\tcfg->do_udp = 1;\n\tcfg->do_tcp = 1;\n\tcfg->tcp_reuse_timeout = 60 * 1000; /* 60s in milisecs */\n\tcfg->max_reuse_tcp_queries = 200;\n\tcfg->tcp_upstream = 0;\n\tcfg->udp_upstream_without_downstream = 0;\n\tcfg->tcp_mss = 0;\n\tcfg->outgoing_tcp_mss = 0;\n\tcfg->tcp_idle_timeout = 30 * 1000; /* 30s in millisecs */\n\tcfg->tcp_auth_query_timeout = 3 * 1000; /* 3s in millisecs */\n\tcfg->do_tcp_keepalive = 0;\n\tcfg->tcp_keepalive_timeout = 120 * 1000; /* 120s in millisecs */\n\tcfg->sock_queue_timeout = 0; /* do not check timeout */\n\tcfg->ssl_service_key = NULL;\n\tcfg->ssl_service_pem = NULL;\n\tcfg->ssl_port = UNBOUND_DNS_OVER_TLS_PORT;\n\tcfg->ssl_upstream = 0;\n\tcfg->tls_cert_bundle = NULL;\n\tcfg->tls_win_cert = 0;\n\tcfg->tls_use_sni = 1;\n\tcfg->https_port = UNBOUND_DNS_OVER_HTTPS_PORT;\n\tif(!(cfg->http_endpoint = strdup(\"/dns-query\"))) goto error_exit;\n\tcfg->http_max_streams = 100;\n\tcfg->http_query_buffer_size = 4*1024*1024;\n\tcfg->http_response_buffer_size = 4*1024*1024;\n\tcfg->http_nodelay = 1;\n\tcfg->use_syslog = 1;\n\tcfg->log_identity = NULL; /* changed later with argv[0] */\n\tcfg->log_time_ascii = 0;\n\tcfg->log_queries = 0;\n\tcfg->log_replies = 0;\n\tcfg->log_tag_queryreply = 0;\n\tcfg->log_local_actions = 0;\n\tcfg->log_servfail = 0;\n\tcfg->log_destaddr = 0;\n#ifndef USE_WINSOCK\n#  ifdef USE_MINI_EVENT\n\t/* select max 1024 sockets */\n\tcfg->outgoing_num_ports = 960;\n\tcfg->num_queries_per_thread = 512;\n#  else\n\t/* libevent can use many sockets */\n\tcfg->outgoing_num_ports = 4096;\n\tcfg->num_queries_per_thread = 1024;\n#  endif\n\tcfg->outgoing_num_tcp = 10;\n\tcfg->incoming_num_tcp = 10;\n#else\n\tcfg->outgoing_num_ports = 48; /* windows is limited in num fds */\n\tcfg->num_queries_per_thread = 24;\n\tcfg->outgoing_num_tcp = 2; /* leaves 64-52=12 for: 4if,1stop,thread4 */\n\tcfg->incoming_num_tcp = 2;\n#endif\n\tcfg->stream_wait_size = 4 * 1024 * 1024;\n\tcfg->edns_buffer_size = 1232; /* from DNS flagday recommendation */\n\tcfg->msg_buffer_size = 65552; /* 64 k + a small margin */\n\tcfg->msg_cache_size = 4 * 1024 * 1024;\n\tcfg->msg_cache_slabs = 4;\n\tcfg->jostle_time = 200;\n\tcfg->rrset_cache_size = 4 * 1024 * 1024;\n\tcfg->rrset_cache_slabs = 4;\n\tcfg->host_ttl = 900;\n\tcfg->bogus_ttl = 60;\n\tcfg->min_ttl = 0;\n\tcfg->max_ttl = 3600 * 24;\n\tcfg->max_negative_ttl = 3600;\n\tcfg->min_negative_ttl = 0;\n\tcfg->prefetch = 0;\n\tcfg->prefetch_key = 0;\n\tcfg->deny_any = 0;\n\tcfg->infra_cache_slabs = 4;\n\tcfg->infra_cache_numhosts = 10000;\n\tcfg->infra_cache_min_rtt = 50;\n\tcfg->infra_cache_max_rtt = 120000;\n\tcfg->infra_keep_probing = 0;\n\tcfg->delay_close = 0;\n\tcfg->udp_connect = 1;\n\tif(!(cfg->outgoing_avail_ports = (int*)calloc(65536, sizeof(int))))\n\t\tgoto error_exit;\n\tinit_outgoing_availports(cfg->outgoing_avail_ports, 65536);\n\tif(!(cfg->username = strdup(UB_USERNAME))) goto error_exit;\n#ifdef HAVE_CHROOT\n\tif(!(cfg->chrootdir = strdup(CHROOT_DIR))) goto error_exit;\n#endif\n\tif(!(cfg->directory = strdup(RUN_DIR))) goto error_exit;\n\tif(!(cfg->logfile = strdup(\"\"))) goto error_exit;\n\tif(!(cfg->pidfile = strdup(PIDFILE))) goto error_exit;\n\tif(!(cfg->target_fetch_policy = strdup(\"3 2 1 0 0\"))) goto error_exit;\n\tcfg->fast_server_permil = 0;\n\tcfg->fast_server_num = 3;\n\tcfg->donotqueryaddrs = NULL;\n\tcfg->donotquery_localhost = 1;\n\tcfg->root_hints = NULL;\n\tcfg->use_systemd = 0;\n\tcfg->do_daemonize = 1;\n\tcfg->if_automatic = 0;\n\tcfg->if_automatic_ports = NULL;\n\tcfg->so_rcvbuf = 0;\n\tcfg->so_sndbuf = 0;\n\tcfg->so_reuseport = REUSEPORT_DEFAULT;\n\tcfg->ip_transparent = 0;\n\tcfg->ip_freebind = 0;\n\tcfg->ip_dscp = 0;\n\tcfg->num_ifs = 0;\n\tcfg->ifs = NULL;\n\tcfg->num_out_ifs = 0;\n\tcfg->out_ifs = NULL;\n\tcfg->stubs = NULL;\n\tcfg->forwards = NULL;\n\tcfg->auths = NULL;\n#ifdef CLIENT_SUBNET\n\tcfg->client_subnet = NULL;\n\tcfg->client_subnet_zone = NULL;\n\tcfg->client_subnet_opcode = LDNS_EDNS_CLIENT_SUBNET;\n\tcfg->client_subnet_always_forward = 0;\n\tcfg->max_client_subnet_ipv4 = 24;\n\tcfg->max_client_subnet_ipv6 = 56;\n\tcfg->min_client_subnet_ipv4 = 0;\n\tcfg->min_client_subnet_ipv6 = 0;\n\tcfg->max_ecs_tree_size_ipv4 = 100;\n\tcfg->max_ecs_tree_size_ipv6 = 100;\n#endif\n\tcfg->views = NULL;\n\tcfg->acls = NULL;\n\tcfg->tcp_connection_limits = NULL;\n\tcfg->harden_short_bufsize = 1;\n\tcfg->harden_large_queries = 0;\n\tcfg->harden_glue = 1;\n\tcfg->harden_dnssec_stripped = 1;\n\tcfg->harden_below_nxdomain = 1;\n\tcfg->harden_referral_path = 0;\n\tcfg->harden_algo_downgrade = 0;\n\tcfg->harden_unknown_additional = 0;\n\tcfg->use_caps_bits_for_id = 0;\n\tcfg->caps_whitelist = NULL;\n\tcfg->private_address = NULL;\n\tcfg->private_domain = NULL;\n\tcfg->unwanted_threshold = 0;\n\tcfg->hide_identity = 0;\n\tcfg->hide_version = 0;\n\tcfg->hide_trustanchor = 0;\n\tcfg->hide_http_user_agent = 0;\n\tcfg->identity = NULL;\n\tcfg->version = NULL;\n\tcfg->http_user_agent = NULL;\n\tcfg->nsid_cfg_str = NULL;\n\tcfg->nsid = NULL;\n\tcfg->nsid_len = 0;\n\tcfg->auto_trust_anchor_file_list = NULL;\n\tcfg->trust_anchor_file_list = NULL;\n\tcfg->trust_anchor_list = NULL;\n\tcfg->trusted_keys_file_list = NULL;\n\tcfg->trust_anchor_signaling = 1;\n\tcfg->root_key_sentinel = 1;\n\tcfg->domain_insecure = NULL;\n\tcfg->val_date_override = 0;\n\tcfg->val_sig_skew_min = 3600; /* at least daylight savings trouble */\n\tcfg->val_sig_skew_max = 86400; /* at most timezone settings trouble */\n\tcfg->val_max_restart = 5;\n\tcfg->val_clean_additional = 1;\n\tcfg->val_log_level = 0;\n\tcfg->val_log_squelch = 0;\n\tcfg->val_permissive_mode = 0;\n\tcfg->aggressive_nsec = 1;\n\tcfg->ignore_cd = 0;\n\tcfg->disable_edns_do = 0;\n\tcfg->serve_expired = 0;\n\tcfg->serve_expired_ttl = 0;\n\tcfg->serve_expired_ttl_reset = 0;\n\tcfg->serve_expired_reply_ttl = 30;\n\tcfg->serve_expired_client_timeout = 0;\n\tcfg->ede_serve_expired = 0;\n\tcfg->serve_original_ttl = 0;\n\tcfg->zonemd_permissive_mode = 0;\n\tcfg->add_holddown = 30*24*3600;\n\tcfg->del_holddown = 30*24*3600;\n\tcfg->keep_missing = 366*24*3600; /* one year plus a little leeway */\n\tcfg->permit_small_holddown = 0;\n\tcfg->key_cache_size = 4 * 1024 * 1024;\n\tcfg->key_cache_slabs = 4;\n\tcfg->neg_cache_size = 1 * 1024 * 1024;\n\tcfg->local_zones = NULL;\n\tcfg->local_zones_nodefault = NULL;\n#ifdef USE_IPSET\n\tcfg->local_zones_ipset = NULL;\n#endif\n\tcfg->local_zones_disable_default = 0;\n\tcfg->local_data = NULL;\n\tcfg->local_zone_overrides = NULL;\n\tcfg->unblock_lan_zones = 0;\n\tcfg->insecure_lan_zones = 0;\n\tcfg->python_script = NULL;\n\tcfg->dynlib_file = NULL;\n\tcfg->remote_control_enable = 0;\n\tcfg->control_ifs.first = NULL;\n\tcfg->control_ifs.last = NULL;\n\tcfg->control_port = UNBOUND_CONTROL_PORT;\n\tcfg->control_use_cert = 1;\n\tcfg->minimal_responses = 1;\n\tcfg->rrset_roundrobin = 1;\n\tcfg->unknown_server_time_limit = 376;\n\tcfg->discard_timeout = 1900; /* msec */\n\tcfg->wait_limit = 1000;\n\tcfg->wait_limit_cookie = 10000;\n\tcfg->wait_limit_netblock = NULL;\n\tcfg->wait_limit_cookie_netblock = NULL;\n\tcfg->max_udp_size = 1232; /* value taken from edns_buffer_size */\n\tif(!(cfg->server_key_file = strdup(RUN_DIR\"/unbound_server.key\")))\n\t\tgoto error_exit;\n\tif(!(cfg->server_cert_file = strdup(RUN_DIR\"/unbound_server.pem\")))\n\t\tgoto error_exit;\n\tif(!(cfg->control_key_file = strdup(RUN_DIR\"/unbound_control.key\")))\n\t\tgoto error_exit;\n\tif(!(cfg->control_cert_file = strdup(RUN_DIR\"/unbound_control.pem\")))\n\t\tgoto error_exit;\n\n#ifdef CLIENT_SUBNET\n\tif(!(cfg->module_conf = strdup(\"subnetcache validator iterator\"))) goto error_exit;\n#else\n\tif(!(cfg->module_conf = strdup(\"validator iterator\"))) goto error_exit;\n#endif\n\tif(!(cfg->val_nsec3_key_iterations =\n\t\tstrdup(\"1024 150 2048 150 4096 150\"))) goto error_exit;\n#if defined(DNSTAP_SOCKET_PATH)\n\tif(!(cfg->dnstap_socket_path = strdup(DNSTAP_SOCKET_PATH)))\n\t\tgoto error_exit;\n#endif\n\tcfg->dnstap_bidirectional = 1;\n\tcfg->dnstap_tls = 1;\n\tcfg->disable_dnssec_lame_check = 0;\n\tcfg->ip_ratelimit_cookie = 0;\n\tcfg->ip_ratelimit = 0;\n\tcfg->ratelimit = 0;\n\tcfg->ip_ratelimit_slabs = 4;\n\tcfg->ratelimit_slabs = 4;\n\tcfg->ip_ratelimit_size = 4*1024*1024;\n\tcfg->ratelimit_size = 4*1024*1024;\n\tcfg->ratelimit_for_domain = NULL;\n\tcfg->ratelimit_below_domain = NULL;\n\tcfg->ip_ratelimit_factor = 10;\n\tcfg->ratelimit_factor = 10;\n\tcfg->ip_ratelimit_backoff = 0;\n\tcfg->ratelimit_backoff = 0;\n\tcfg->outbound_msg_retry = 5;\n\tcfg->max_sent_count = 32;\n\tcfg->max_query_restarts = 11;\n\tcfg->qname_minimisation = 1;\n\tcfg->qname_minimisation_strict = 0;\n\tcfg->shm_enable = 0;\n\tcfg->shm_key = 11777;\n\tcfg->edns_client_strings = NULL;\n\tcfg->edns_client_string_opcode = 65001;\n\tcfg->dnscrypt = 0;\n\tcfg->dnscrypt_port = 0;\n\tcfg->dnscrypt_provider = NULL;\n\tcfg->dnscrypt_provider_cert = NULL;\n\tcfg->dnscrypt_provider_cert_rotated = NULL;\n\tcfg->dnscrypt_secret_key = NULL;\n\tcfg->dnscrypt_shared_secret_cache_size = 4*1024*1024;\n\tcfg->dnscrypt_shared_secret_cache_slabs = 4;\n\tcfg->dnscrypt_nonce_cache_size = 4*1024*1024;\n\tcfg->dnscrypt_nonce_cache_slabs = 4;\n\tcfg->pad_responses = 1;\n\tcfg->pad_responses_block_size = 468; /* from RFC8467 */\n\tcfg->pad_queries = 1;\n\tcfg->pad_queries_block_size = 128; /* from RFC8467 */\n#ifdef USE_IPSECMOD\n\tcfg->ipsecmod_enabled = 1;\n\tcfg->ipsecmod_ignore_bogus = 0;\n\tcfg->ipsecmod_hook = NULL;\n\tcfg->ipsecmod_max_ttl = 3600;\n\tcfg->ipsecmod_whitelist = NULL;\n\tcfg->ipsecmod_strict = 0;\n#endif\n\tcfg->do_answer_cookie = 0;\n\tmemset(cfg->cookie_secret, 0, sizeof(cfg->cookie_secret));\n\tcfg->cookie_secret_len = 16;\n\tinit_cookie_secret(cfg->cookie_secret, cfg->cookie_secret_len);\n#ifdef USE_CACHEDB\n\tif(!(cfg->cachedb_backend = strdup(\"testframe\"))) goto error_exit;\n\tif(!(cfg->cachedb_secret = strdup(\"default\"))) goto error_exit;\n\tcfg->cachedb_no_store = 0;\n\tcfg->cachedb_check_when_serve_expired = 1;\n#ifdef USE_REDIS\n\tif(!(cfg->redis_server_host = strdup(\"127.0.0.1\"))) goto error_exit;\n\tcfg->redis_server_path = NULL;\n\tcfg->redis_server_password = NULL;\n\tcfg->redis_timeout = 100;\n\tcfg->redis_server_port = 6379;\n\tcfg->redis_expire_records = 0;\n\tcfg->redis_logical_db = 0;\n#endif  /* USE_REDIS */\n#endif  /* USE_CACHEDB */\n#ifdef USE_IPSET\n\tcfg->ipset_name_v4 = NULL;\n\tcfg->ipset_name_v6 = NULL;\n#endif\n\tcfg->ede = 0;\n\treturn cfg;\nerror_exit:\n\tconfig_delete(cfg);\n\treturn NULL;\n}",
      "cve_list": [
        "CVE-2024-33655"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "unbound",
      "filepath": "util/config_file.c",
      "func_name": "config_delete",
      "func_body": "config_delete(struct config_file* cfg)\n{\n\tif(!cfg) return;\n\tfree(cfg->username);\n\tfree(cfg->chrootdir);\n\tfree(cfg->directory);\n\tfree(cfg->logfile);\n\tfree(cfg->pidfile);\n\tfree(cfg->if_automatic_ports);\n\tfree(cfg->target_fetch_policy);\n\tfree(cfg->ssl_service_key);\n\tfree(cfg->ssl_service_pem);\n\tfree(cfg->tls_cert_bundle);\n\tconfig_delstrlist(cfg->tls_additional_port);\n\tconfig_delstrlist(cfg->tls_session_ticket_keys.first);\n\tfree(cfg->tls_ciphers);\n\tfree(cfg->tls_ciphersuites);\n\tfree(cfg->http_endpoint);\n\tif(cfg->log_identity) {\n\t\tlog_ident_revert_to_default();\n\t\tfree(cfg->log_identity);\n\t}\n\tconfig_del_strarray(cfg->ifs, cfg->num_ifs);\n\tconfig_del_strarray(cfg->out_ifs, cfg->num_out_ifs);\n\tconfig_delstubs(cfg->stubs);\n\tconfig_delstubs(cfg->forwards);\n\tconfig_delauths(cfg->auths);\n\tconfig_delviews(cfg->views);\n\tconfig_delstrlist(cfg->donotqueryaddrs);\n\tconfig_delstrlist(cfg->root_hints);\n#ifdef CLIENT_SUBNET\n\tconfig_delstrlist(cfg->client_subnet);\n\tconfig_delstrlist(cfg->client_subnet_zone);\n#endif\n\tfree(cfg->identity);\n\tfree(cfg->version);\n\tfree(cfg->http_user_agent);\n\tfree(cfg->nsid_cfg_str);\n\tfree(cfg->nsid);\n\tfree(cfg->module_conf);\n\tfree(cfg->outgoing_avail_ports);\n\tconfig_delstrlist(cfg->caps_whitelist);\n\tconfig_delstrlist(cfg->private_address);\n\tconfig_delstrlist(cfg->private_domain);\n\tconfig_delstrlist(cfg->auto_trust_anchor_file_list);\n\tconfig_delstrlist(cfg->trust_anchor_file_list);\n\tconfig_delstrlist(cfg->trusted_keys_file_list);\n\tconfig_delstrlist(cfg->trust_anchor_list);\n\tconfig_delstrlist(cfg->domain_insecure);\n\tconfig_deldblstrlist(cfg->acls);\n\tconfig_deldblstrlist(cfg->tcp_connection_limits);\n\tfree(cfg->val_nsec3_key_iterations);\n\tconfig_deldblstrlist(cfg->local_zones);\n\tconfig_delstrlist(cfg->local_zones_nodefault);\n#ifdef USE_IPSET\n\tconfig_delstrlist(cfg->local_zones_ipset);\n#endif\n\tconfig_delstrlist(cfg->local_data);\n\tconfig_deltrplstrlist(cfg->local_zone_overrides);\n\tconfig_del_strarray(cfg->tagname, cfg->num_tags);\n\tconfig_del_strbytelist(cfg->local_zone_tags);\n\tconfig_del_strbytelist(cfg->respip_tags);\n\tconfig_deldblstrlist(cfg->acl_view);\n\tconfig_del_strbytelist(cfg->acl_tags);\n\tconfig_deltrplstrlist(cfg->acl_tag_actions);\n\tconfig_deltrplstrlist(cfg->acl_tag_datas);\n\tconfig_deldblstrlist(cfg->interface_actions);\n\tconfig_deldblstrlist(cfg->interface_view);\n\tconfig_del_strbytelist(cfg->interface_tags);\n\tconfig_deltrplstrlist(cfg->interface_tag_actions);\n\tconfig_deltrplstrlist(cfg->interface_tag_datas);\n\tconfig_delstrlist(cfg->control_ifs.first);\n\tconfig_deldblstrlist(cfg->wait_limit_netblock);\n\tconfig_deldblstrlist(cfg->wait_limit_cookie_netblock);\n\tfree(cfg->server_key_file);\n\tfree(cfg->server_cert_file);\n\tfree(cfg->control_key_file);\n\tfree(cfg->control_cert_file);\n\tfree(cfg->nat64_prefix);\n\tfree(cfg->dns64_prefix);\n\tconfig_delstrlist(cfg->dns64_ignore_aaaa);\n\tfree(cfg->dnstap_socket_path);\n\tfree(cfg->dnstap_ip);\n\tfree(cfg->dnstap_tls_server_name);\n\tfree(cfg->dnstap_tls_cert_bundle);\n\tfree(cfg->dnstap_tls_client_key_file);\n\tfree(cfg->dnstap_tls_client_cert_file);\n\tfree(cfg->dnstap_identity);\n\tfree(cfg->dnstap_version);\n\tconfig_deldblstrlist(cfg->ratelimit_for_domain);\n\tconfig_deldblstrlist(cfg->ratelimit_below_domain);\n\tconfig_delstrlist(cfg->python_script);\n\tconfig_delstrlist(cfg->dynlib_file);\n\tconfig_deldblstrlist(cfg->edns_client_strings);\n\tconfig_delstrlist(cfg->proxy_protocol_port);\n#ifdef USE_IPSECMOD\n\tfree(cfg->ipsecmod_hook);\n\tconfig_delstrlist(cfg->ipsecmod_whitelist);\n#endif\n#ifdef USE_CACHEDB\n\tfree(cfg->cachedb_backend);\n\tfree(cfg->cachedb_secret);\n#ifdef USE_REDIS\n\tfree(cfg->redis_server_host);\n\tfree(cfg->redis_server_path);\n\tfree(cfg->redis_server_password);\n#endif  /* USE_REDIS */\n#endif  /* USE_CACHEDB */\n#ifdef USE_IPSET\n\tfree(cfg->ipset_name_v4);\n\tfree(cfg->ipset_name_v6);\n#endif\n\tfree(cfg);\n}",
      "cve_list": [
        "CVE-2024-33655"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "unbound",
      "filepath": "util/config_file.c",
      "func_name": "config_get_option",
      "func_body": "config_get_option(struct config_file* cfg, const char* opt,\n\tvoid (*func)(char*,void*), void* arg)\n{\n\tchar buf[1024], nopt[64];\n\tsize_t len = sizeof(buf);\n\tif(!opt) return 0;\n\tif(opt && opt[strlen(opt)-1] == ':' && strlen(opt)<sizeof(nopt)) {\n\t\tmemmove(nopt, opt, strlen(opt));\n\t\tnopt[strlen(opt)-1] = 0;\n\t\topt = nopt;\n\t}\n\tfptr_ok(fptr_whitelist_print_func(func));\n\tO_DEC(opt, \"verbosity\", verbosity)\n\telse O_DEC(opt, \"statistics-interval\", stat_interval)\n\telse O_YNO(opt, \"statistics-cumulative\", stat_cumulative)\n\telse O_YNO(opt, \"extended-statistics\", stat_extended)\n\telse O_YNO(opt, \"statistics-inhibit-zero\", stat_inhibit_zero)\n\telse O_YNO(opt, \"shm-enable\", shm_enable)\n\telse O_DEC(opt, \"shm-key\", shm_key)\n\telse O_YNO(opt, \"use-syslog\", use_syslog)\n\telse O_STR(opt, \"log-identity\", log_identity)\n\telse O_YNO(opt, \"log-time-ascii\", log_time_ascii)\n\telse O_DEC(opt, \"num-threads\", num_threads)\n\telse O_IFC(opt, \"interface\", num_ifs, ifs)\n\telse O_IFC(opt, \"outgoing-interface\", num_out_ifs, out_ifs)\n\telse O_YNO(opt, \"interface-automatic\", if_automatic)\n\telse O_STR(opt, \"interface-automatic-ports\", if_automatic_ports)\n\telse O_DEC(opt, \"port\", port)\n\telse O_DEC(opt, \"outgoing-range\", outgoing_num_ports)\n\telse O_DEC(opt, \"outgoing-num-tcp\", outgoing_num_tcp)\n\telse O_DEC(opt, \"incoming-num-tcp\", incoming_num_tcp)\n\telse O_MEM(opt, \"stream-wait-size\", stream_wait_size)\n\telse O_DEC(opt, \"edns-buffer-size\", edns_buffer_size)\n\telse O_DEC(opt, \"msg-buffer-size\", msg_buffer_size)\n\telse O_MEM(opt, \"msg-cache-size\", msg_cache_size)\n\telse O_DEC(opt, \"msg-cache-slabs\", msg_cache_slabs)\n\telse O_DEC(opt, \"num-queries-per-thread\", num_queries_per_thread)\n\telse O_UNS(opt, \"jostle-timeout\", jostle_time)\n\telse O_MEM(opt, \"so-rcvbuf\", so_rcvbuf)\n\telse O_MEM(opt, \"so-sndbuf\", so_sndbuf)\n\telse O_YNO(opt, \"so-reuseport\", so_reuseport)\n\telse O_YNO(opt, \"ip-transparent\", ip_transparent)\n\telse O_YNO(opt, \"ip-freebind\", ip_freebind)\n\telse O_DEC(opt, \"ip-dscp\", ip_dscp)\n\telse O_MEM(opt, \"rrset-cache-size\", rrset_cache_size)\n\telse O_DEC(opt, \"rrset-cache-slabs\", rrset_cache_slabs)\n\telse O_YNO(opt, \"prefetch-key\", prefetch_key)\n\telse O_YNO(opt, \"prefetch\", prefetch)\n\telse O_YNO(opt, \"deny-any\", deny_any)\n\telse O_DEC(opt, \"cache-max-ttl\", max_ttl)\n\telse O_DEC(opt, \"cache-max-negative-ttl\", max_negative_ttl)\n\telse O_DEC(opt, \"cache-min-negative-ttl\", min_negative_ttl)\n\telse O_DEC(opt, \"cache-min-ttl\", min_ttl)\n\telse O_DEC(opt, \"infra-host-ttl\", host_ttl)\n\telse O_DEC(opt, \"infra-cache-slabs\", infra_cache_slabs)\n\telse O_DEC(opt, \"infra-cache-min-rtt\", infra_cache_min_rtt)\n\telse O_UNS(opt, \"infra-cache-max-rtt\", infra_cache_max_rtt)\n\telse O_YNO(opt, \"infra-keep-probing\", infra_keep_probing)\n\telse O_MEM(opt, \"infra-cache-numhosts\", infra_cache_numhosts)\n\telse O_UNS(opt, \"delay-close\", delay_close)\n\telse O_YNO(opt, \"udp-connect\", udp_connect)\n\telse O_YNO(opt, \"do-ip4\", do_ip4)\n\telse O_YNO(opt, \"do-ip6\", do_ip6)\n\telse O_YNO(opt, \"do-udp\", do_udp)\n\telse O_YNO(opt, \"do-tcp\", do_tcp)\n\telse O_YNO(opt, \"prefer-ip4\", prefer_ip4)\n\telse O_YNO(opt, \"prefer-ip6\", prefer_ip6)\n\telse O_YNO(opt, \"tcp-upstream\", tcp_upstream)\n\telse O_YNO(opt, \"udp-upstream-without-downstream\", udp_upstream_without_downstream)\n\telse O_DEC(opt, \"tcp-mss\", tcp_mss)\n\telse O_DEC(opt, \"outgoing-tcp-mss\", outgoing_tcp_mss)\n\telse O_DEC(opt, \"tcp-auth-query-timeout\", tcp_auth_query_timeout)\n\telse O_DEC(opt, \"tcp-idle-timeout\", tcp_idle_timeout)\n\telse O_DEC(opt, \"max-reuse-tcp-queries\", max_reuse_tcp_queries)\n\telse O_DEC(opt, \"tcp-reuse-timeout\", tcp_reuse_timeout)\n\telse O_YNO(opt, \"edns-tcp-keepalive\", do_tcp_keepalive)\n\telse O_DEC(opt, \"edns-tcp-keepalive-timeout\", tcp_keepalive_timeout)\n\telse O_DEC(opt, \"sock-queue-timeout\", sock_queue_timeout)\n\telse O_YNO(opt, \"ssl-upstream\", ssl_upstream)\n\telse O_YNO(opt, \"tls-upstream\", ssl_upstream)\n\telse O_STR(opt, \"ssl-service-key\", ssl_service_key)\n\telse O_STR(opt, \"tls-service-key\", ssl_service_key)\n\telse O_STR(opt, \"ssl-service-pem\", ssl_service_pem)\n\telse O_STR(opt, \"tls-service-pem\", ssl_service_pem)\n\telse O_DEC(opt, \"ssl-port\", ssl_port)\n\telse O_DEC(opt, \"tls-port\", ssl_port)\n\telse O_STR(opt, \"ssl-cert-bundle\", tls_cert_bundle)\n\telse O_STR(opt, \"tls-cert-bundle\", tls_cert_bundle)\n\telse O_YNO(opt, \"tls-win-cert\", tls_win_cert)\n\telse O_YNO(opt, \"tls-system-cert\", tls_win_cert)\n\telse O_LST(opt, \"additional-ssl-port\", tls_additional_port)\n\telse O_LST(opt, \"additional-tls-port\", tls_additional_port)\n\telse O_LST(opt, \"tls-additional-ports\", tls_additional_port)\n\telse O_LST(opt, \"tls-additional-port\", tls_additional_port)\n\telse O_LST(opt, \"tls-session-ticket-keys\", tls_session_ticket_keys.first)\n\telse O_STR(opt, \"tls-ciphers\", tls_ciphers)\n\telse O_STR(opt, \"tls-ciphersuites\", tls_ciphersuites)\n\telse O_YNO(opt, \"tls-use-sni\", tls_use_sni)\n\telse O_DEC(opt, \"https-port\", https_port)\n\telse O_STR(opt, \"http-endpoint\", http_endpoint)\n\telse O_UNS(opt, \"http-max-streams\", http_max_streams)\n\telse O_MEM(opt, \"http-query-buffer-size\", http_query_buffer_size)\n\telse O_MEM(opt, \"http-response-buffer-size\", http_response_buffer_size)\n\telse O_YNO(opt, \"http-nodelay\", http_nodelay)\n\telse O_YNO(opt, \"http-notls-downstream\", http_notls_downstream)\n\telse O_YNO(opt, \"use-systemd\", use_systemd)\n\telse O_YNO(opt, \"do-daemonize\", do_daemonize)\n\telse O_STR(opt, \"chroot\", chrootdir)\n\telse O_STR(opt, \"username\", username)\n\telse O_STR(opt, \"directory\", directory)\n\telse O_STR(opt, \"logfile\", logfile)\n\telse O_YNO(opt, \"log-queries\", log_queries)\n\telse O_YNO(opt, \"log-replies\", log_replies)\n\telse O_YNO(opt, \"log-tag-queryreply\", log_tag_queryreply)\n\telse O_YNO(opt, \"log-local-actions\", log_local_actions)\n\telse O_YNO(opt, \"log-servfail\", log_servfail)\n\telse O_YNO(opt, \"log-destaddr\", log_destaddr)\n\telse O_STR(opt, \"pidfile\", pidfile)\n\telse O_YNO(opt, \"hide-identity\", hide_identity)\n\telse O_YNO(opt, \"hide-version\", hide_version)\n\telse O_YNO(opt, \"hide-trustanchor\", hide_trustanchor)\n\telse O_YNO(opt, \"hide-http-user-agent\", hide_http_user_agent)\n\telse O_STR(opt, \"identity\", identity)\n\telse O_STR(opt, \"version\", version)\n\telse O_STR(opt, \"http-user-agent\", http_user_agent)\n\telse O_STR(opt, \"nsid\", nsid_cfg_str)\n\telse O_STR(opt, \"target-fetch-policy\", target_fetch_policy)\n\telse O_YNO(opt, \"harden-short-bufsize\", harden_short_bufsize)\n\telse O_YNO(opt, \"harden-large-queries\", harden_large_queries)\n\telse O_YNO(opt, \"harden-glue\", harden_glue)\n\telse O_YNO(opt, \"harden-dnssec-stripped\", harden_dnssec_stripped)\n\telse O_YNO(opt, \"harden-below-nxdomain\", harden_below_nxdomain)\n\telse O_YNO(opt, \"harden-referral-path\", harden_referral_path)\n\telse O_YNO(opt, \"harden-algo-downgrade\", harden_algo_downgrade)\n\telse O_YNO(opt, \"harden-unknown-additional\", harden_unknown_additional)\n\telse O_YNO(opt, \"use-caps-for-id\", use_caps_bits_for_id)\n\telse O_LST(opt, \"caps-whitelist\", caps_whitelist)\n\telse O_DEC(opt, \"unwanted-reply-threshold\", unwanted_threshold)\n\telse O_YNO(opt, \"do-not-query-localhost\", donotquery_localhost)\n\telse O_STR(opt, \"module-config\", module_conf)\n\telse O_DEC(opt, \"val-bogus-ttl\", bogus_ttl)\n\telse O_YNO(opt, \"val-clean-additional\", val_clean_additional)\n\telse O_DEC(opt, \"val-log-level\", val_log_level)\n\telse O_YNO(opt, \"val-permissive-mode\", val_permissive_mode)\n\telse O_YNO(opt, \"aggressive-nsec\", aggressive_nsec)\n\telse O_YNO(opt, \"ignore-cd-flag\", ignore_cd)\n\telse O_YNO(opt, \"disable-edns-do\", disable_edns_do)\n\telse O_YNO(opt, \"serve-expired\", serve_expired)\n\telse O_DEC(opt, \"serve-expired-ttl\", serve_expired_ttl)\n\telse O_YNO(opt, \"serve-expired-ttl-reset\", serve_expired_ttl_reset)\n\telse O_DEC(opt, \"serve-expired-reply-ttl\", serve_expired_reply_ttl)\n\telse O_DEC(opt, \"serve-expired-client-timeout\", serve_expired_client_timeout)\n\telse O_YNO(opt, \"ede\", ede)\n\telse O_YNO(opt, \"ede-serve-expired\", ede_serve_expired)\n\telse O_YNO(opt, \"serve-original-ttl\", serve_original_ttl)\n\telse O_STR(opt, \"val-nsec3-keysize-iterations\",val_nsec3_key_iterations)\n\telse O_YNO(opt, \"zonemd-permissive-mode\", zonemd_permissive_mode)\n\telse O_UNS(opt, \"add-holddown\", add_holddown)\n\telse O_UNS(opt, \"del-holddown\", del_holddown)\n\telse O_UNS(opt, \"keep-missing\", keep_missing)\n\telse O_YNO(opt, \"permit-small-holddown\", permit_small_holddown)\n\telse O_MEM(opt, \"key-cache-size\", key_cache_size)\n\telse O_DEC(opt, \"key-cache-slabs\", key_cache_slabs)\n\telse O_MEM(opt, \"neg-cache-size\", neg_cache_size)\n\telse O_YNO(opt, \"control-enable\", remote_control_enable)\n\telse O_DEC(opt, \"control-port\", control_port)\n\telse O_STR(opt, \"server-key-file\", server_key_file)\n\telse O_STR(opt, \"server-cert-file\", server_cert_file)\n\telse O_STR(opt, \"control-key-file\", control_key_file)\n\telse O_STR(opt, \"control-cert-file\", control_cert_file)\n\telse O_LST(opt, \"root-hints\", root_hints)\n\telse O_LS2(opt, \"access-control\", acls)\n\telse O_LS2(opt, \"tcp-connection-limit\", tcp_connection_limits)\n\telse O_LST(opt, \"do-not-query-address\", donotqueryaddrs)\n\telse O_LST(opt, \"private-address\", private_address)\n\telse O_LST(opt, \"private-domain\", private_domain)\n\telse O_LST(opt, \"auto-trust-anchor-file\", auto_trust_anchor_file_list)\n\telse O_LST(opt, \"trust-anchor-file\", trust_anchor_file_list)\n\telse O_LST(opt, \"trust-anchor\", trust_anchor_list)\n\telse O_LST(opt, \"trusted-keys-file\", trusted_keys_file_list)\n\telse O_YNO(opt, \"trust-anchor-signaling\", trust_anchor_signaling)\n\telse O_YNO(opt, \"root-key-sentinel\", root_key_sentinel)\n\telse O_LST(opt, \"control-interface\", control_ifs.first)\n\telse O_LST(opt, \"domain-insecure\", domain_insecure)\n\telse O_UNS(opt, \"val-override-date\", val_date_override)\n\telse O_YNO(opt, \"minimal-responses\", minimal_responses)\n\telse O_YNO(opt, \"rrset-roundrobin\", rrset_roundrobin)\n\telse O_DEC(opt, \"unknown-server-time-limit\", unknown_server_time_limit)\n\telse O_DEC(opt, \"discard-timeout\", discard_timeout)\n\telse O_DEC(opt, \"wait-limit\", wait_limit)\n\telse O_DEC(opt, \"wait-limit-cookie\", wait_limit_cookie)\n\telse O_LS2(opt, \"wait-limit-netblock\", wait_limit_netblock)\n\telse O_LS2(opt, \"wait-limit-cookie-netblock\", wait_limit_cookie_netblock)\n#ifdef CLIENT_SUBNET\n\telse O_LST(opt, \"send-client-subnet\", client_subnet)\n\telse O_LST(opt, \"client-subnet-zone\", client_subnet_zone)\n\telse O_DEC(opt, \"max-client-subnet-ipv4\", max_client_subnet_ipv4)\n\telse O_DEC(opt, \"max-client-subnet-ipv6\", max_client_subnet_ipv6)\n\telse O_DEC(opt, \"min-client-subnet-ipv4\", min_client_subnet_ipv4)\n\telse O_DEC(opt, \"min-client-subnet-ipv6\", min_client_subnet_ipv6)\n\telse O_DEC(opt, \"max-ecs-tree-size-ipv4\", max_ecs_tree_size_ipv4)\n\telse O_DEC(opt, \"max-ecs-tree-size-ipv6\", max_ecs_tree_size_ipv6)\n\telse O_YNO(opt, \"client-subnet-always-forward:\",\n\t\tclient_subnet_always_forward)\n#endif\n#ifdef USE_DNSTAP\n\telse O_YNO(opt, \"dnstap-enable\", dnstap)\n\telse O_YNO(opt, \"dnstap-bidirectional\", dnstap_bidirectional)\n\telse O_STR(opt, \"dnstap-socket-path\", dnstap_socket_path)\n\telse O_STR(opt, \"dnstap-ip\", dnstap_ip)\n\telse O_YNO(opt, \"dnstap-tls\", dnstap_tls)\n\telse O_STR(opt, \"dnstap-tls-server-name\", dnstap_tls_server_name)\n\telse O_STR(opt, \"dnstap-tls-cert-bundle\", dnstap_tls_cert_bundle)\n\telse O_STR(opt, \"dnstap-tls-client-key-file\",\n\t\tdnstap_tls_client_key_file)\n\telse O_STR(opt, \"dnstap-tls-client-cert-file\",\n\t\tdnstap_tls_client_cert_file)\n\telse O_YNO(opt, \"dnstap-send-identity\", dnstap_send_identity)\n\telse O_YNO(opt, \"dnstap-send-version\", dnstap_send_version)\n\telse O_STR(opt, \"dnstap-identity\", dnstap_identity)\n\telse O_STR(opt, \"dnstap-version\", dnstap_version)\n\telse O_YNO(opt, \"dnstap-log-resolver-query-messages\",\n\t\tdnstap_log_resolver_query_messages)\n\telse O_YNO(opt, \"dnstap-log-resolver-response-messages\",\n\t\tdnstap_log_resolver_response_messages)\n\telse O_YNO(opt, \"dnstap-log-client-query-messages\",\n\t\tdnstap_log_client_query_messages)\n\telse O_YNO(opt, \"dnstap-log-client-response-messages\",\n\t\tdnstap_log_client_response_messages)\n\telse O_YNO(opt, \"dnstap-log-forwarder-query-messages\",\n\t\tdnstap_log_forwarder_query_messages)\n\telse O_YNO(opt, \"dnstap-log-forwarder-response-messages\",\n\t\tdnstap_log_forwarder_response_messages)\n#endif\n#ifdef USE_DNSCRYPT\n\telse O_YNO(opt, \"dnscrypt-enable\", dnscrypt)\n\telse O_DEC(opt, \"dnscrypt-port\", dnscrypt_port)\n\telse O_STR(opt, \"dnscrypt-provider\", dnscrypt_provider)\n\telse O_LST(opt, \"dnscrypt-provider-cert\", dnscrypt_provider_cert)\n\telse O_LST(opt, \"dnscrypt-provider-cert-rotated\", dnscrypt_provider_cert_rotated)\n\telse O_LST(opt, \"dnscrypt-secret-key\", dnscrypt_secret_key)\n\telse O_MEM(opt, \"dnscrypt-shared-secret-cache-size\",\n\t\tdnscrypt_shared_secret_cache_size)\n\telse O_DEC(opt, \"dnscrypt-shared-secret-cache-slabs\",\n\t\tdnscrypt_shared_secret_cache_slabs)\n\telse O_MEM(opt, \"dnscrypt-nonce-cache-size\",\n\t\tdnscrypt_nonce_cache_size)\n\telse O_DEC(opt, \"dnscrypt-nonce-cache-slabs\",\n\t\tdnscrypt_nonce_cache_slabs)\n#endif\n\telse O_YNO(opt, \"unblock-lan-zones\", unblock_lan_zones)\n\telse O_YNO(opt, \"insecure-lan-zones\", insecure_lan_zones)\n\telse O_DEC(opt, \"max-udp-size\", max_udp_size)\n\telse O_LST(opt, \"python-script\", python_script)\n\telse O_LST(opt, \"dynlib-file\", dynlib_file)\n\telse O_YNO(opt, \"disable-dnssec-lame-check\", disable_dnssec_lame_check)\n\telse O_DEC(opt, \"ip-ratelimit-cookie\", ip_ratelimit_cookie)\n\telse O_DEC(opt, \"ip-ratelimit\", ip_ratelimit)\n\telse O_DEC(opt, \"ratelimit\", ratelimit)\n\telse O_MEM(opt, \"ip-ratelimit-size\", ip_ratelimit_size)\n\telse O_MEM(opt, \"ratelimit-size\", ratelimit_size)\n\telse O_DEC(opt, \"ip-ratelimit-slabs\", ip_ratelimit_slabs)\n\telse O_DEC(opt, \"ratelimit-slabs\", ratelimit_slabs)\n\telse O_LS2(opt, \"ratelimit-for-domain\", ratelimit_for_domain)\n\telse O_LS2(opt, \"ratelimit-below-domain\", ratelimit_below_domain)\n\telse O_DEC(opt, \"ip-ratelimit-factor\", ip_ratelimit_factor)\n\telse O_DEC(opt, \"ratelimit-factor\", ratelimit_factor)\n\telse O_YNO(opt, \"ip-ratelimit-backoff\", ip_ratelimit_backoff)\n\telse O_YNO(opt, \"ratelimit-backoff\", ratelimit_backoff)\n\telse O_UNS(opt, \"outbound-msg-retry\", outbound_msg_retry)\n\telse O_UNS(opt, \"max-sent-count\", max_sent_count)\n\telse O_UNS(opt, \"max-query-restarts\", max_query_restarts)\n\telse O_DEC(opt, \"fast-server-num\", fast_server_num)\n\telse O_DEC(opt, \"fast-server-permil\", fast_server_permil)\n\telse O_DEC(opt, \"val-sig-skew-min\", val_sig_skew_min)\n\telse O_DEC(opt, \"val-sig-skew-max\", val_sig_skew_max)\n\telse O_DEC(opt, \"val-max-restart\", val_max_restart)\n\telse O_YNO(opt, \"qname-minimisation\", qname_minimisation)\n\telse O_YNO(opt, \"qname-minimisation-strict\", qname_minimisation_strict)\n\telse O_IFC(opt, \"define-tag\", num_tags, tagname)\n\telse O_LTG(opt, \"local-zone-tag\", local_zone_tags)\n\telse O_LTG(opt, \"access-control-tag\", acl_tags)\n\telse O_LTG(opt, \"response-ip-tag\", respip_tags)\n\telse O_LS3(opt, \"local-zone-override\", local_zone_overrides)\n\telse O_LS3(opt, \"access-control-tag-action\", acl_tag_actions)\n\telse O_LS3(opt, \"access-control-tag-data\", acl_tag_datas)\n\telse O_LS2(opt, \"access-control-view\", acl_view)\n\telse O_LS2(opt, \"interface-action\", interface_actions)\n\telse O_LTG(opt, \"interface-tag\", interface_tags)\n\telse O_LS3(opt, \"interface-tag-action\", interface_tag_actions)\n\telse O_LS3(opt, \"interface-tag-data\", interface_tag_datas)\n\telse O_LS2(opt, \"interface-view\", interface_view)\n\telse O_YNO(opt, \"pad-responses\", pad_responses)\n\telse O_DEC(opt, \"pad-responses-block-size\", pad_responses_block_size)\n\telse O_YNO(opt, \"pad-queries\", pad_queries)\n\telse O_DEC(opt, \"pad-queries-block-size\", pad_queries_block_size)\n\telse O_LS2(opt, \"edns-client-strings\", edns_client_strings)\n\telse O_LST(opt, \"proxy-protocol-port\", proxy_protocol_port)\n#ifdef USE_IPSECMOD\n\telse O_YNO(opt, \"ipsecmod-enabled\", ipsecmod_enabled)\n\telse O_YNO(opt, \"ipsecmod-ignore-bogus\", ipsecmod_ignore_bogus)\n\telse O_STR(opt, \"ipsecmod-hook\", ipsecmod_hook)\n\telse O_DEC(opt, \"ipsecmod-max-ttl\", ipsecmod_max_ttl)\n\telse O_LST(opt, \"ipsecmod-whitelist\", ipsecmod_whitelist)\n\telse O_YNO(opt, \"ipsecmod-strict\", ipsecmod_strict)\n#endif\n#ifdef USE_CACHEDB\n\telse O_STR(opt, \"backend\", cachedb_backend)\n\telse O_STR(opt, \"secret-seed\", cachedb_secret)\n\telse O_YNO(opt, \"cachedb-no-store\", cachedb_no_store)\n\telse O_YNO(opt, \"cachedb-check-when-serve-expired\", cachedb_check_when_serve_expired)\n#ifdef USE_REDIS\n\telse O_STR(opt, \"redis-server-host\", redis_server_host)\n\telse O_DEC(opt, \"redis-server-port\", redis_server_port)\n\telse O_STR(opt, \"redis-server-path\", redis_server_path)\n\telse O_STR(opt, \"redis-server-password\", redis_server_password)\n\telse O_DEC(opt, \"redis-timeout\", redis_timeout)\n\telse O_YNO(opt, \"redis-expire-records\", redis_expire_records)\n\telse O_DEC(opt, \"redis-logical-db\", redis_logical_db)\n#endif  /* USE_REDIS */\n#endif  /* USE_CACHEDB */\n#ifdef USE_IPSET\n\telse O_STR(opt, \"name-v4\", ipset_name_v4)\n\telse O_STR(opt, \"name-v6\", ipset_name_v6)\n#endif\n\t/* not here:\n\t * outgoing-permit, outgoing-avoid - have list of ports\n\t * local-zone - zones and nodefault variables\n\t * local-data - see below\n\t * local-data-ptr - converted to local-data entries\n\t * stub-zone, name, stub-addr, stub-host, stub-prime\n\t * forward-zone, name, forward-addr, forward-host\n\t */\n\telse return 0;\n\treturn 1;\n}",
      "cve_list": [
        "CVE-2024-33655"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "unbound",
      "filepath": "util/config_file.c",
      "func_name": "config_set_option",
      "func_body": "int config_set_option(struct config_file* cfg, const char* opt,\n\tconst char* val)\n{\n\tchar buf[64];\n\tif(!opt) return 0;\n\tif(opt[strlen(opt)-1] != ':' && strlen(opt)+2<sizeof(buf)) {\n\t\tsnprintf(buf, sizeof(buf), \"%s:\", opt);\n\t\topt = buf;\n\t}\n\tS_NUMBER_OR_ZERO(\"verbosity:\", verbosity)\n\telse if(strcmp(opt, \"statistics-interval:\") == 0) {\n\t\tif(strcmp(val, \"0\") == 0 || strcmp(val, \"\") == 0)\n\t\t\tcfg->stat_interval = 0;\n\t\telse if(atoi(val) == 0)\n\t\t\treturn 0;\n\t\telse cfg->stat_interval = atoi(val);\n\t} else if(strcmp(opt, \"num-threads:\") == 0) {\n\t\t/* not supported, library must have 1 thread in bgworker */\n\t\treturn 0;\n\t} else if(strcmp(opt, \"outgoing-port-permit:\") == 0) {\n\t\treturn cfg_mark_ports(val, 1,\n\t\t\tcfg->outgoing_avail_ports, 65536);\n\t} else if(strcmp(opt, \"outgoing-port-avoid:\") == 0) {\n\t\treturn cfg_mark_ports(val, 0,\n\t\t\tcfg->outgoing_avail_ports, 65536);\n\t} else if(strcmp(opt, \"local-zone:\") == 0) {\n\t\treturn cfg_parse_local_zone(cfg, val);\n\t} else if(strcmp(opt, \"val-override-date:\") == 0) {\n\t\tif(strcmp(val, \"\") == 0 || strcmp(val, \"0\") == 0) {\n\t\t\tcfg->val_date_override = 0;\n\t\t} else if(strlen(val) == 14) {\n\t\t\tcfg->val_date_override = cfg_convert_timeval(val);\n\t\t\treturn cfg->val_date_override != 0;\n\t\t} else {\n\t\t\tif(atoi(val) == 0) return 0;\n\t\t\tcfg->val_date_override = (uint32_t)atoi(val);\n\t\t}\n\t} else if(strcmp(opt, \"local-data-ptr:\") == 0) {\n\t\tchar* ptr = cfg_ptr_reverse((char*)opt);\n\t\treturn cfg_strlist_insert(&cfg->local_data, ptr);\n\t} else if(strcmp(opt, \"logfile:\") == 0) {\n\t\tcfg->use_syslog = 0;\n\t\tfree(cfg->logfile);\n\t\treturn (cfg->logfile = strdup(val)) != NULL;\n\t}\n\telse if(strcmp(opt, \"log-time-ascii:\") == 0)\n\t{ IS_YES_OR_NO; cfg->log_time_ascii = (strcmp(val, \"yes\") == 0);\n\t  log_set_time_asc(cfg->log_time_ascii); }\n\telse S_SIZET_NONZERO(\"max-udp-size:\", max_udp_size)\n\telse S_YNO(\"use-syslog:\", use_syslog)\n\telse S_STR(\"log-identity:\", log_identity)\n\telse S_YNO(\"extended-statistics:\", stat_extended)\n\telse S_YNO(\"statistics-inhibit-zero:\", stat_inhibit_zero)\n\telse S_YNO(\"statistics-cumulative:\", stat_cumulative)\n\telse S_YNO(\"shm-enable:\", shm_enable)\n\telse S_NUMBER_OR_ZERO(\"shm-key:\", shm_key)\n\telse S_YNO(\"do-ip4:\", do_ip4)\n\telse S_YNO(\"do-ip6:\", do_ip6)\n\telse S_YNO(\"do-udp:\", do_udp)\n\telse S_YNO(\"do-tcp:\", do_tcp)\n\telse S_YNO(\"prefer-ip4:\", prefer_ip4)\n\telse S_YNO(\"prefer-ip6:\", prefer_ip6)\n\telse S_YNO(\"tcp-upstream:\", tcp_upstream)\n\telse S_YNO(\"udp-upstream-without-downstream:\",\n\t\tudp_upstream_without_downstream)\n\telse S_NUMBER_NONZERO(\"tcp-mss:\", tcp_mss)\n\telse S_NUMBER_NONZERO(\"outgoing-tcp-mss:\", outgoing_tcp_mss)\n\telse S_NUMBER_NONZERO(\"tcp-auth-query-timeout:\", tcp_auth_query_timeout)\n\telse S_NUMBER_NONZERO(\"tcp-idle-timeout:\", tcp_idle_timeout)\n\telse S_NUMBER_NONZERO(\"max-reuse-tcp-queries:\", max_reuse_tcp_queries)\n\telse S_NUMBER_NONZERO(\"tcp-reuse-timeout:\", tcp_reuse_timeout)\n\telse S_YNO(\"edns-tcp-keepalive:\", do_tcp_keepalive)\n\telse S_NUMBER_NONZERO(\"edns-tcp-keepalive-timeout:\", tcp_keepalive_timeout)\n\telse S_NUMBER_OR_ZERO(\"sock-queue-timeout:\", sock_queue_timeout)\n\telse S_YNO(\"ssl-upstream:\", ssl_upstream)\n\telse S_YNO(\"tls-upstream:\", ssl_upstream)\n\telse S_STR(\"ssl-service-key:\", ssl_service_key)\n\telse S_STR(\"tls-service-key:\", ssl_service_key)\n\telse S_STR(\"ssl-service-pem:\", ssl_service_pem)\n\telse S_STR(\"tls-service-pem:\", ssl_service_pem)\n\telse S_NUMBER_NONZERO(\"ssl-port:\", ssl_port)\n\telse S_NUMBER_NONZERO(\"tls-port:\", ssl_port)\n\telse S_STR(\"ssl-cert-bundle:\", tls_cert_bundle)\n\telse S_STR(\"tls-cert-bundle:\", tls_cert_bundle)\n\telse S_YNO(\"tls-win-cert:\", tls_win_cert)\n\telse S_YNO(\"tls-system-cert:\", tls_win_cert)\n\telse S_STRLIST(\"additional-ssl-port:\", tls_additional_port)\n\telse S_STRLIST(\"additional-tls-port:\", tls_additional_port)\n\telse S_STRLIST(\"tls-additional-ports:\", tls_additional_port)\n\telse S_STRLIST(\"tls-additional-port:\", tls_additional_port)\n\telse S_STRLIST_APPEND(\"tls-session-ticket-keys:\", tls_session_ticket_keys)\n\telse S_STR(\"tls-ciphers:\", tls_ciphers)\n\telse S_STR(\"tls-ciphersuites:\", tls_ciphersuites)\n\telse S_YNO(\"tls-use-sni:\", tls_use_sni)\n\telse S_NUMBER_NONZERO(\"https-port:\", https_port)\n\telse S_STR(\"http-endpoint:\", http_endpoint)\n\telse S_NUMBER_NONZERO(\"http-max-streams:\", http_max_streams)\n\telse S_MEMSIZE(\"http-query-buffer-size:\", http_query_buffer_size)\n\telse S_MEMSIZE(\"http-response-buffer-size:\", http_response_buffer_size)\n\telse S_YNO(\"http-nodelay:\", http_nodelay)\n\telse S_YNO(\"http-notls-downstream:\", http_notls_downstream)\n\telse S_YNO(\"interface-automatic:\", if_automatic)\n\telse S_STR(\"interface-automatic-ports:\", if_automatic_ports)\n\telse S_YNO(\"use-systemd:\", use_systemd)\n\telse S_YNO(\"do-daemonize:\", do_daemonize)\n\telse S_NUMBER_NONZERO(\"port:\", port)\n\telse S_NUMBER_NONZERO(\"outgoing-range:\", outgoing_num_ports)\n\telse S_SIZET_OR_ZERO(\"outgoing-num-tcp:\", outgoing_num_tcp)\n\telse S_SIZET_OR_ZERO(\"incoming-num-tcp:\", incoming_num_tcp)\n\telse S_MEMSIZE(\"stream-wait-size:\", stream_wait_size)\n\telse S_SIZET_NONZERO(\"edns-buffer-size:\", edns_buffer_size)\n\telse S_SIZET_NONZERO(\"msg-buffer-size:\", msg_buffer_size)\n\telse S_MEMSIZE(\"msg-cache-size:\", msg_cache_size)\n\telse S_POW2(\"msg-cache-slabs:\", msg_cache_slabs)\n\telse S_SIZET_NONZERO(\"num-queries-per-thread:\",num_queries_per_thread)\n\telse S_SIZET_OR_ZERO(\"jostle-timeout:\", jostle_time)\n\telse S_MEMSIZE(\"so-rcvbuf:\", so_rcvbuf)\n\telse S_MEMSIZE(\"so-sndbuf:\", so_sndbuf)\n\telse S_YNO(\"so-reuseport:\", so_reuseport)\n\telse S_YNO(\"ip-transparent:\", ip_transparent)\n\telse S_YNO(\"ip-freebind:\", ip_freebind)\n\telse S_NUMBER_OR_ZERO(\"ip-dscp:\", ip_dscp)\n\telse S_MEMSIZE(\"rrset-cache-size:\", rrset_cache_size)\n\telse S_POW2(\"rrset-cache-slabs:\", rrset_cache_slabs)\n\telse S_YNO(\"prefetch:\", prefetch)\n\telse S_YNO(\"prefetch-key:\", prefetch_key)\n\telse S_YNO(\"deny-any:\", deny_any)\n\telse if(strcmp(opt, \"cache-max-ttl:\") == 0)\n\t{ IS_NUMBER_OR_ZERO; cfg->max_ttl = atoi(val); MAX_TTL=(time_t)cfg->max_ttl;}\n\telse if(strcmp(opt, \"cache-max-negative-ttl:\") == 0)\n\t{ IS_NUMBER_OR_ZERO; cfg->max_negative_ttl = atoi(val); MAX_NEG_TTL=(time_t)cfg->max_negative_ttl;}\n\telse if(strcmp(opt, \"cache-min-negative-ttl:\") == 0)\n\t{ IS_NUMBER_OR_ZERO; cfg->min_negative_ttl = atoi(val); MIN_NEG_TTL=(time_t)cfg->min_negative_ttl;}\n\telse if(strcmp(opt, \"cache-min-ttl:\") == 0)\n\t{ IS_NUMBER_OR_ZERO; cfg->min_ttl = atoi(val); MIN_TTL=(time_t)cfg->min_ttl;}\n\telse if(strcmp(opt, \"infra-cache-min-rtt:\") == 0) {\n\t \tIS_NUMBER_OR_ZERO; cfg->infra_cache_min_rtt = atoi(val);\n\t\tRTT_MIN_TIMEOUT=cfg->infra_cache_min_rtt;\n\t}\n\telse if(strcmp(opt, \"infra-cache-max-rtt:\") == 0) {\n\t\tIS_NUMBER_OR_ZERO; cfg->infra_cache_max_rtt = atoi(val);\n\t\tRTT_MAX_TIMEOUT=cfg->infra_cache_max_rtt;\n\t\tUSEFUL_SERVER_TOP_TIMEOUT = RTT_MAX_TIMEOUT;\n\t\tBLACKLIST_PENALTY = USEFUL_SERVER_TOP_TIMEOUT*4;\n\t}\n\telse S_YNO(\"infra-keep-probing:\", infra_keep_probing)\n\telse S_NUMBER_OR_ZERO(\"infra-host-ttl:\", host_ttl)\n\telse S_POW2(\"infra-cache-slabs:\", infra_cache_slabs)\n\telse S_SIZET_NONZERO(\"infra-cache-numhosts:\", infra_cache_numhosts)\n\telse S_NUMBER_OR_ZERO(\"delay-close:\", delay_close)\n\telse S_YNO(\"udp-connect:\", udp_connect)\n\telse S_STR(\"chroot:\", chrootdir)\n\telse S_STR(\"username:\", username)\n\telse S_STR(\"directory:\", directory)\n\telse S_STR(\"pidfile:\", pidfile)\n\telse S_YNO(\"hide-identity:\", hide_identity)\n\telse S_YNO(\"hide-version:\", hide_version)\n\telse S_YNO(\"hide-trustanchor:\", hide_trustanchor)\n\telse S_YNO(\"hide-http-user-agent:\", hide_http_user_agent)\n\telse S_STR(\"identity:\", identity)\n\telse S_STR(\"version:\", version)\n\telse S_STR(\"http-user-agent:\", http_user_agent)\n\telse if(strcmp(opt, \"nsid:\") == 0) {\n\t\tfree(cfg->nsid_cfg_str);\n\t\tif (!(cfg->nsid_cfg_str = strdup(val)))\n\t\t\treturn 0;\n\t\t/* Empty string is just validly unsetting nsid */\n\t\tif (*val == 0) {\n\t\t\tfree(cfg->nsid);\n\t\t\tcfg->nsid = NULL;\n\t\t\tcfg->nsid_len = 0;\n\t\t\treturn 1;\n\t\t}\n\t\tcfg->nsid = cfg_parse_nsid(val, &cfg->nsid_len);\n\t\treturn cfg->nsid != NULL;\n\t}\n\telse S_STRLIST(\"root-hints:\", root_hints)\n\telse S_STR(\"target-fetch-policy:\", target_fetch_policy)\n\telse S_YNO(\"harden-glue:\", harden_glue)\n\telse S_YNO(\"harden-short-bufsize:\", harden_short_bufsize)\n\telse S_YNO(\"harden-large-queries:\", harden_large_queries)\n\telse S_YNO(\"harden-dnssec-stripped:\", harden_dnssec_stripped)\n\telse S_YNO(\"harden-below-nxdomain:\", harden_below_nxdomain)\n\telse S_YNO(\"harden-referral-path:\", harden_referral_path)\n\telse S_YNO(\"harden-algo-downgrade:\", harden_algo_downgrade)\n\telse S_YNO(\"harden-unknown-additional:\", harden_unknown_additional)\n\telse S_YNO(\"use-caps-for-id:\", use_caps_bits_for_id)\n\telse S_STRLIST(\"caps-whitelist:\", caps_whitelist)\n\telse S_SIZET_OR_ZERO(\"unwanted-reply-threshold:\", unwanted_threshold)\n\telse S_STRLIST(\"private-address:\", private_address)\n\telse S_STRLIST(\"private-domain:\", private_domain)\n\telse S_YNO(\"do-not-query-localhost:\", donotquery_localhost)\n\telse S_STRLIST(\"do-not-query-address:\", donotqueryaddrs)\n\telse S_STRLIST(\"auto-trust-anchor-file:\", auto_trust_anchor_file_list)\n\telse S_STRLIST(\"trust-anchor-file:\", trust_anchor_file_list)\n\telse S_STRLIST(\"trust-anchor:\", trust_anchor_list)\n\telse S_STRLIST(\"trusted-keys-file:\", trusted_keys_file_list)\n\telse S_YNO(\"trust-anchor-signaling:\", trust_anchor_signaling)\n\telse S_YNO(\"root-key-sentinel:\", root_key_sentinel)\n\telse S_STRLIST(\"domain-insecure:\", domain_insecure)\n\telse S_NUMBER_OR_ZERO(\"val-bogus-ttl:\", bogus_ttl)\n\telse S_YNO(\"val-clean-additional:\", val_clean_additional)\n\telse S_NUMBER_OR_ZERO(\"val-log-level:\", val_log_level)\n\telse S_YNO(\"val-log-squelch:\", val_log_squelch)\n\telse S_YNO(\"log-queries:\", log_queries)\n\telse S_YNO(\"log-replies:\", log_replies)\n\telse S_YNO(\"log-tag-queryreply:\", log_tag_queryreply)\n\telse S_YNO(\"log-local-actions:\", log_local_actions)\n\telse S_YNO(\"log-servfail:\", log_servfail)\n\telse S_YNO(\"log-destaddr:\", log_destaddr)\n\telse S_YNO(\"val-permissive-mode:\", val_permissive_mode)\n\telse S_YNO(\"aggressive-nsec:\", aggressive_nsec)\n\telse S_YNO(\"ignore-cd-flag:\", ignore_cd)\n\telse S_YNO(\"disable-edns-do:\", disable_edns_do)\n\telse if(strcmp(opt, \"serve-expired:\") == 0)\n\t{ IS_YES_OR_NO; cfg->serve_expired = (strcmp(val, \"yes\") == 0);\n\t  SERVE_EXPIRED = cfg->serve_expired; }\n\telse if(strcmp(opt, \"serve-expired-ttl:\") == 0)\n\t{ IS_NUMBER_OR_ZERO; cfg->serve_expired_ttl = atoi(val); SERVE_EXPIRED_TTL=(time_t)cfg->serve_expired_ttl;}\n\telse S_YNO(\"serve-expired-ttl-reset:\", serve_expired_ttl_reset)\n\telse if(strcmp(opt, \"serve-expired-reply-ttl:\") == 0)\n\t{ IS_NUMBER_OR_ZERO; cfg->serve_expired_reply_ttl = atoi(val); SERVE_EXPIRED_REPLY_TTL=(time_t)cfg->serve_expired_reply_ttl;}\n\telse S_NUMBER_OR_ZERO(\"serve-expired-client-timeout:\", serve_expired_client_timeout)\n\telse S_YNO(\"ede:\", ede)\n\telse S_YNO(\"ede-serve-expired:\", ede_serve_expired)\n\telse S_YNO(\"serve-original-ttl:\", serve_original_ttl)\n\telse S_STR(\"val-nsec3-keysize-iterations:\", val_nsec3_key_iterations)\n\telse S_YNO(\"zonemd-permissive-mode:\", zonemd_permissive_mode)\n\telse S_UNSIGNED_OR_ZERO(\"add-holddown:\", add_holddown)\n\telse S_UNSIGNED_OR_ZERO(\"del-holddown:\", del_holddown)\n\telse S_UNSIGNED_OR_ZERO(\"keep-missing:\", keep_missing)\n\telse if(strcmp(opt, \"permit-small-holddown:\") == 0)\n\t{ IS_YES_OR_NO; cfg->permit_small_holddown = (strcmp(val, \"yes\") == 0);\n\t  autr_permit_small_holddown = cfg->permit_small_holddown; }\n\telse S_MEMSIZE(\"key-cache-size:\", key_cache_size)\n\telse S_POW2(\"key-cache-slabs:\", key_cache_slabs)\n\telse S_MEMSIZE(\"neg-cache-size:\", neg_cache_size)\n\telse S_YNO(\"minimal-responses:\", minimal_responses)\n\telse S_YNO(\"rrset-roundrobin:\", rrset_roundrobin)\n\telse S_NUMBER_OR_ZERO(\"unknown-server-time-limit:\", unknown_server_time_limit)\n\telse S_NUMBER_OR_ZERO(\"discard-timeout:\", discard_timeout)\n\telse S_NUMBER_OR_ZERO(\"wait-limit:\", wait_limit)\n\telse S_NUMBER_OR_ZERO(\"wait-limit-cookie:\", wait_limit_cookie)\n\telse S_STRLIST(\"local-data:\", local_data)\n\telse S_YNO(\"unblock-lan-zones:\", unblock_lan_zones)\n\telse S_YNO(\"insecure-lan-zones:\", insecure_lan_zones)\n\telse S_YNO(\"control-enable:\", remote_control_enable)\n\telse S_STRLIST_APPEND(\"control-interface:\", control_ifs)\n\telse S_NUMBER_NONZERO(\"control-port:\", control_port)\n\telse S_STR(\"server-key-file:\", server_key_file)\n\telse S_STR(\"server-cert-file:\", server_cert_file)\n\telse S_STR(\"control-key-file:\", control_key_file)\n\telse S_STR(\"control-cert-file:\", control_cert_file)\n\telse S_STR(\"module-config:\", module_conf)\n\telse S_STRLIST(\"python-script:\", python_script)\n\telse S_STRLIST(\"dynlib-file:\", dynlib_file)\n\telse S_YNO(\"disable-dnssec-lame-check:\", disable_dnssec_lame_check)\n#ifdef CLIENT_SUBNET\n\t/* Can't set max subnet prefix here, since that value is used when\n\t * generating the address tree. */\n\t/* No client-subnet-always-forward here, module registration depends on\n\t * this option. */\n#endif\n#ifdef USE_DNSTAP\n\telse S_YNO(\"dnstap-enable:\", dnstap)\n\telse S_YNO(\"dnstap-bidirectional:\", dnstap_bidirectional)\n\telse S_STR(\"dnstap-socket-path:\", dnstap_socket_path)\n\telse S_STR(\"dnstap-ip:\", dnstap_ip)\n\telse S_YNO(\"dnstap-tls:\", dnstap_tls)\n\telse S_STR(\"dnstap-tls-server-name:\", dnstap_tls_server_name)\n\telse S_STR(\"dnstap-tls-cert-bundle:\", dnstap_tls_cert_bundle)\n\telse S_STR(\"dnstap-tls-client-key-file:\", dnstap_tls_client_key_file)\n\telse S_STR(\"dnstap-tls-client-cert-file:\",\n\t\tdnstap_tls_client_cert_file)\n\telse S_YNO(\"dnstap-send-identity:\", dnstap_send_identity)\n\telse S_YNO(\"dnstap-send-version:\", dnstap_send_version)\n\telse S_STR(\"dnstap-identity:\", dnstap_identity)\n\telse S_STR(\"dnstap-version:\", dnstap_version)\n\telse S_YNO(\"dnstap-log-resolver-query-messages:\",\n\t\tdnstap_log_resolver_query_messages)\n\telse S_YNO(\"dnstap-log-resolver-response-messages:\",\n\t\tdnstap_log_resolver_response_messages)\n\telse S_YNO(\"dnstap-log-client-query-messages:\",\n\t\tdnstap_log_client_query_messages)\n\telse S_YNO(\"dnstap-log-client-response-messages:\",\n\t\tdnstap_log_client_response_messages)\n\telse S_YNO(\"dnstap-log-forwarder-query-messages:\",\n\t\tdnstap_log_forwarder_query_messages)\n\telse S_YNO(\"dnstap-log-forwarder-response-messages:\",\n\t\tdnstap_log_forwarder_response_messages)\n#endif\n#ifdef USE_DNSCRYPT\n\telse S_YNO(\"dnscrypt-enable:\", dnscrypt)\n\telse S_NUMBER_NONZERO(\"dnscrypt-port:\", dnscrypt_port)\n\telse S_STR(\"dnscrypt-provider:\", dnscrypt_provider)\n\telse S_STRLIST_UNIQ(\"dnscrypt-provider-cert:\", dnscrypt_provider_cert)\n\telse S_STRLIST(\"dnscrypt-provider-cert-rotated:\", dnscrypt_provider_cert_rotated)\n\telse S_STRLIST_UNIQ(\"dnscrypt-secret-key:\", dnscrypt_secret_key)\n\telse S_MEMSIZE(\"dnscrypt-shared-secret-cache-size:\",\n\t\tdnscrypt_shared_secret_cache_size)\n\telse S_POW2(\"dnscrypt-shared-secret-cache-slabs:\",\n\t\tdnscrypt_shared_secret_cache_slabs)\n\telse S_MEMSIZE(\"dnscrypt-nonce-cache-size:\",\n\t\tdnscrypt_nonce_cache_size)\n\telse S_POW2(\"dnscrypt-nonce-cache-slabs:\",\n\t\tdnscrypt_nonce_cache_slabs)\n#endif\n\telse if(strcmp(opt, \"ip-ratelimit-cookie:\") == 0) {\n\t    IS_NUMBER_OR_ZERO; cfg->ip_ratelimit_cookie = atoi(val);\n\t    infra_ip_ratelimit_cookie=cfg->ip_ratelimit_cookie;\n\t}\n\telse if(strcmp(opt, \"ip-ratelimit:\") == 0) {\n\t    IS_NUMBER_OR_ZERO; cfg->ip_ratelimit = atoi(val);\n\t    infra_ip_ratelimit=cfg->ip_ratelimit;\n\t}\n\telse if(strcmp(opt, \"ratelimit:\") == 0) {\n\t    IS_NUMBER_OR_ZERO; cfg->ratelimit = atoi(val);\n\t    infra_dp_ratelimit=cfg->ratelimit;\n\t}\n\telse S_MEMSIZE(\"ip-ratelimit-size:\", ip_ratelimit_size)\n\telse S_MEMSIZE(\"ratelimit-size:\", ratelimit_size)\n\telse S_POW2(\"ip-ratelimit-slabs:\", ip_ratelimit_slabs)\n\telse S_POW2(\"ratelimit-slabs:\", ratelimit_slabs)\n\telse S_NUMBER_OR_ZERO(\"ip-ratelimit-factor:\", ip_ratelimit_factor)\n\telse S_NUMBER_OR_ZERO(\"ratelimit-factor:\", ratelimit_factor)\n\telse S_YNO(\"ip-ratelimit-backoff:\", ip_ratelimit_backoff)\n\telse S_YNO(\"ratelimit-backoff:\", ratelimit_backoff)\n\telse S_NUMBER_NONZERO(\"outbound-msg-retry:\", outbound_msg_retry)\n\telse S_NUMBER_NONZERO(\"max-sent-count:\", max_sent_count)\n\telse S_NUMBER_NONZERO(\"max-query-restarts:\", max_query_restarts)\n\telse S_SIZET_NONZERO(\"fast-server-num:\", fast_server_num)\n\telse S_NUMBER_OR_ZERO(\"fast-server-permil:\", fast_server_permil)\n\telse S_YNO(\"qname-minimisation:\", qname_minimisation)\n\telse S_YNO(\"qname-minimisation-strict:\", qname_minimisation_strict)\n\telse S_YNO(\"pad-responses:\", pad_responses)\n\telse S_SIZET_NONZERO(\"pad-responses-block-size:\", pad_responses_block_size)\n\telse S_YNO(\"pad-queries:\", pad_queries)\n\telse S_SIZET_NONZERO(\"pad-queries-block-size:\", pad_queries_block_size)\n\telse S_STRLIST(\"proxy-protocol-port:\", proxy_protocol_port)\n#ifdef USE_IPSECMOD\n\telse S_YNO(\"ipsecmod-enabled:\", ipsecmod_enabled)\n\telse S_YNO(\"ipsecmod-ignore-bogus:\", ipsecmod_ignore_bogus)\n\telse if(strcmp(opt, \"ipsecmod-max-ttl:\") == 0)\n\t{ IS_NUMBER_OR_ZERO; cfg->ipsecmod_max_ttl = atoi(val); }\n\telse S_YNO(\"ipsecmod-strict:\", ipsecmod_strict)\n#endif\n#ifdef USE_CACHEDB\n\telse S_YNO(\"cachedb-no-store:\", cachedb_no_store)\n\telse S_YNO(\"cachedb-check-when-serve-expired:\", cachedb_check_when_serve_expired)\n#endif /* USE_CACHEDB */\n\telse if(strcmp(opt, \"define-tag:\") ==0) {\n\t\treturn config_add_tag(cfg, val);\n\t/* val_sig_skew_min, max and val_max_restart are copied into val_env\n\t * during init so this does not update val_env with set_option */\n\t} else if(strcmp(opt, \"val-sig-skew-min:\") == 0)\n\t{ IS_NUMBER_OR_ZERO; cfg->val_sig_skew_min = (int32_t)atoi(val); }\n\telse if(strcmp(opt, \"val-sig-skew-max:\") == 0)\n\t{ IS_NUMBER_OR_ZERO; cfg->val_sig_skew_max = (int32_t)atoi(val); }\n\telse if(strcmp(opt, \"val-max-restart:\") == 0)\n\t{ IS_NUMBER_OR_ZERO; cfg->val_max_restart = (int32_t)atoi(val); }\n\telse if (strcmp(opt, \"outgoing-interface:\") == 0) {\n\t\tchar* d = strdup(val);\n\t\tchar** oi =\n\t\t(char**)reallocarray(NULL, (size_t)cfg->num_out_ifs+1, sizeof(char*));\n\t\tif(!d || !oi) { free(d); free(oi); return -1; }\n\t\tif(cfg->out_ifs && cfg->num_out_ifs) {\n\t\t\tmemmove(oi, cfg->out_ifs, cfg->num_out_ifs*sizeof(char*));\n\t\t\tfree(cfg->out_ifs);\n\t\t}\n\t\toi[cfg->num_out_ifs++] = d;\n\t\tcfg->out_ifs = oi;\n\t} else {\n\t\t/* unknown or unsupported (from the set_option interface):\n\t\t * interface, outgoing-interface, access-control,\n\t\t * stub-zone, name, stub-addr, stub-host, stub-prime\n\t\t * forward-first, stub-first, forward-ssl-upstream,\n\t\t * stub-ssl-upstream, forward-zone, auth-zone\n\t\t * name, forward-addr, forward-host,\n\t\t * ratelimit-for-domain, ratelimit-below-domain,\n\t\t * local-zone-tag, access-control-view, interface-*,\n\t\t * send-client-subnet, client-subnet-always-forward,\n\t\t * max-client-subnet-ipv4, max-client-subnet-ipv6,\n\t\t * min-client-subnet-ipv4, min-client-subnet-ipv6,\n\t\t * max-ecs-tree-size-ipv4, max-ecs-tree-size-ipv6, ipsecmod_hook,\n\t\t * ipsecmod_whitelist. */\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
      "cve_list": [
        "CVE-2024-33655"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "Hyprland",
      "filepath": "src/plugins/HookSystem.cpp",
      "func_name": "CFunctionHook::fixInstructionProbeRIPCalls",
      "func_body": "CFunctionHook::SAssembly CFunctionHook::fixInstructionProbeRIPCalls(const SInstructionProbe& probe) {\n    SAssembly returns;\n\n    // analyze the code and fix what we know how to.\n    uint64_t currentAddress = (uint64_t)m_pSource;\n    // actually newline + 1\n    size_t lastAsmNewline = 0;\n    // needle for destination binary\n    size_t      currentDestinationOffset = 0;\n    std::string assemblyBuilder;\n    for (auto& len : probe.insSizes) {\n\n        std::string code = probe.assembly.substr(lastAsmNewline, probe.assembly.find(\"\\n\", lastAsmNewline) - lastAsmNewline);\n        if (code.contains(\"%rip\")) {\n            CVarList       tokens{code, 0, 's'};\n            size_t         plusPresent  = tokens[1][0] == '+' ? 1 : 0;\n            size_t         minusPresent = tokens[1][0] == '-' ? 1 : 0;\n            std::string    addr         = tokens[1].substr((plusPresent || minusPresent), tokens[1].find(\"(%rip)\") - (plusPresent || minusPresent));\n            const uint64_t OFFSET       = (minusPresent ? -1 : 1) * configStringToInt(addr);\n            if (OFFSET == 0)\n                return {};\n            const uint64_t DESTINATION = currentAddress + OFFSET + len;\n\n            if (code.starts_with(\"call\")) {\n                // call +0xdeadbeef(%rip)\n                assemblyBuilder += std::format(\"pushq %rax\\nmovabs $0x{:x}, %rax\\ncallq *%rax\\npopq %rax\\n\", DESTINATION);\n                currentDestinationOffset += 14;\n            } else if (code.starts_with(\"lea\")) {\n                // lea 0xdeadbeef(%rip), %rax\n                assemblyBuilder += std::format(\"movabs $0x{:x}, {}\\n\", DESTINATION, tokens[2]);\n                currentDestinationOffset += 10;\n            } else {\n                auto ADDREND   = code.find(\"(%rip)\");\n                auto ADDRSTART = (code.substr(0, ADDREND).find_last_of(' '));\n\n                if (ADDREND == std::string::npos || ADDRSTART == std::string::npos)\n                    return {};\n\n                const uint64_t PREDICTEDRIP = (uint64_t)m_pTrampolineAddr + currentDestinationOffset + len;\n                const bool     POSITIVE     = DESTINATION > PREDICTEDRIP;\n                const uint64_t NEWRIPOFFSET = POSITIVE ? DESTINATION - PREDICTEDRIP : PREDICTEDRIP - DESTINATION;\n\n                assemblyBuilder += std::format(\"{} {}0x{:x}{}\\n\", code.substr(0, ADDRSTART), POSITIVE ? '+' : '-', NEWRIPOFFSET, code.substr(ADDREND));\n                currentDestinationOffset += len;\n            }\n        } else if (code.contains(\"invalid\")) {\n            std::vector<uint8_t> bytes;\n            bytes.resize(len);\n            memcpy(bytes.data(), (std::byte*)currentAddress, len);\n            if (len == 4 && bytes[0] == 0xF3 && bytes[1] == 0x0F && bytes[2] == 0x1E && bytes[3] == 0xFA) {\n                // F3 0F 1E FA = endbr64, udis doesn't understand that one\n                assemblyBuilder += \"endbr64\\n\";\n                currentDestinationOffset += 4;\n            } else {\n                // raise error, unknown op\n                std::string strBytes;\n                for (auto& b : bytes) {\n                    strBytes += std::format(\"{:x} \", b);\n                }\n                Debug::log(ERR, \"[functionhook] unknown bytes: {}\", strBytes);\n                return {};\n            }\n        } else {\n            assemblyBuilder += code + \"\\n\";\n            currentDestinationOffset += len;\n        }\n\n        lastAsmNewline = probe.assembly.find(\"\\n\", lastAsmNewline) + 1;\n        currentAddress += len;\n    }\n\n    const auto RANDOMDIR = \"/tmp/hypr/\" + g_pTokenManager->getRandomUUID();\n\n    if (!std::filesystem::create_directory(RANDOMDIR))\n        return {};\n\n    std::filesystem::permissions(RANDOMDIR, std::filesystem::perms::owner_all, std::filesystem::perm_options::replace);\n\n    std::ofstream ofs(RANDOMDIR + \"/.hookcode.asm\", std::ios::trunc);\n    ofs << assemblyBuilder;\n    ofs.close();\n    std::string ret = execAndGet(std::string{\"cc -x assembler -c \" + RANDOMDIR + \"/.hookcode.asm -o \" + RANDOMDIR + \"/.hookbinary.o 2>&1 && objcopy -O binary -j .text \" +\n                                             RANDOMDIR + \"/.hookbinary.o \" + RANDOMDIR + \"/.hookbinary2.o 2>&1\"}\n                                     .c_str());\n    Debug::log(LOG, \"[functionhook] assembler returned:\\n{}\", ret);\n    if (!std::filesystem::exists(RANDOMDIR + \"/.hookbinary2.o\")) {\n        std::filesystem::remove(RANDOMDIR + \"/.hookcode.asm\");\n        std::filesystem::remove(RANDOMDIR + \"/.hookbinary.asm\");\n        return {};\n    }\n\n    std::ifstream ifs(RANDOMDIR + \"/.hookbinary2.o\", std::ios::binary);\n    returns = {std::vector<char>(std::istreambuf_iterator<char>(ifs), {})};\n    ifs.close();\n    std::filesystem::remove_all(RANDOMDIR);\n\n    return returns;\n}",
      "cve_list": [
        "CVE-2024-33904"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "liboqs",
      "filepath": "src/kem/ml_kem/pqcrystals-kyber-standard_ml-kem-768-ipd_ref/poly.c",
      "func_name": "poly_frommsg",
      "func_body": "void poly_frommsg(poly *r, const uint8_t msg[KYBER_INDCPA_MSGBYTES])\n{\n  unsigned int i,j;\n\n#if (KYBER_INDCPA_MSGBYTES != KYBER_N/8)\n#error \"KYBER_INDCPA_MSGBYTES must be equal to KYBER_N/8 bytes!\"\n#endif\n\n  for(i=0;i<KYBER_N/8;i++) {\n    for(j=0;j<8;j++) {\n      r->coeffs[8*i+j] = 0;\n      cmov_int16(r->coeffs+8*i+j, ((KYBER_Q+1)/2), (msg[i] >> j)&1);\n    }\n  }\n}",
      "cve_list": [
        "CVE-2024-36405"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "liboqs",
      "filepath": "src/kem/ml_kem/pqcrystals-kyber-standard_ml-kem-768-ipd_ref/verify.c",
      "func_name": "cmov_int16",
      "func_body": "void cmov_int16(int16_t *r, int16_t v, uint16_t b)\n{\n  b = -b;\n  *r ^= b & ((*r) ^ v);\n}",
      "cve_list": [
        "CVE-2024-36405"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "everest-core",
      "filepath": "modules/EvseV2G/v2g_server.cpp",
      "func_name": "v2g_incoming_v2gtp",
      "func_body": "static int v2g_incoming_v2gtp(struct v2g_connection* conn) {\n    int rv;\n\n    /* read and process header */\n    rv = connection_read(conn, conn->buffer, V2GTP_HEADER_LENGTH);\n    if (rv < 0) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(header) failed: %s\",\n             (rv == -1) ? strerror(errno) : \"connection terminated\");\n        return -1;\n    }\n    /* peer closed connection */\n    if (rv == 0)\n        return 1;\n    if (rv != V2GTP_HEADER_LENGTH) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(header) too short: expected %d, got %d\", V2GTP_HEADER_LENGTH, rv);\n        return -1;\n    }\n\n    rv = read_v2gtpHeader(conn->buffer, &conn->payload_len);\n    if (rv == -1) {\n        dlog(DLOG_LEVEL_ERROR, \"Invalid v2gtp header\");\n        return -1;\n    }\n\n    if (conn->payload_len >= UINT32_MAX - V2GTP_HEADER_LENGTH) {\n        dlog(DLOG_LEVEL_ERROR, \"Prevent integer overflow - payload too long: have %d, would need %u\",\n             DEFAULT_BUFFER_SIZE, conn->payload_len);\n        return -1;\n    }\n\n    if (conn->payload_len + V2GTP_HEADER_LENGTH > DEFAULT_BUFFER_SIZE) {\n        dlog(DLOG_LEVEL_ERROR, \"payload too long: have %d, would need %u\", DEFAULT_BUFFER_SIZE,\n             conn->payload_len + V2GTP_HEADER_LENGTH);\n\n        /* we have no way to flush/discard remaining unread data from the socket without reading it in chunks,\n         * but this opens the chance to bind us in a \"endless\" read loop; so to protect us, simply close the connection\n         */\n\n        return -1;\n    }\n    /* read request */\n    rv = connection_read(conn, &conn->buffer[V2GTP_HEADER_LENGTH], conn->payload_len);\n    if (rv < 0) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(payload) failed: %s\",\n             (rv == -1) ? strerror(errno) : \"connection terminated\");\n        return -1;\n    }\n    if (rv != conn->payload_len) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(payload) too short: expected %d, got %d\", conn->payload_len, rv);\n        return -1;\n    }\n    /* adjust buffer pos to decode request */\n    conn->buffer_pos = V2GTP_HEADER_LENGTH;\n    conn->stream.size = conn->payload_len + V2GTP_HEADER_LENGTH;\n\n    return 0;\n}",
      "cve_list": [
        "CVE-2024-37310"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "js-compute-runtime",
      "filepath": "runtime/js-compute-runtime/host_interface/component/fastly_world_adapter.cpp",
      "func_name": "fastly_compute_at_edge_cache_get_user_metadata",
      "func_body": "bool fastly_compute_at_edge_cache_get_user_metadata(fastly_compute_at_edge_cache_handle_t handle,\n                                                    fastly_world_list_u8_t *ret,\n                                                    fastly_compute_at_edge_cache_error_t *err) {\n  size_t default_size = 16 * 1024;\n  ret->ptr = static_cast<uint8_t *>(cabi_malloc(default_size, 4));\n  auto status = fastly::cache_get_user_metadata(handle, reinterpret_cast<char *>(ret->ptr),\n                                                default_size, &ret->len);\n  if (status == FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_BUFFER_LEN) {\n    ret->ptr = static_cast<uint8_t *>(cabi_realloc(ret->ptr, default_size, 4, ret->len));\n    status = fastly::cache_get_user_metadata(handle, reinterpret_cast<char *>(ret->ptr), ret->len,\n                                             &ret->len);\n  }\n  return convert_result(status, err);\n}",
      "cve_list": [
        "CVE-2024-38375"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "js-compute-runtime",
      "filepath": "runtime/js-compute-runtime/host_interface/component/fastly_world_adapter.cpp",
      "func_name": "fastly_compute_at_edge_device_detection_lookup",
      "func_body": "bool fastly_compute_at_edge_device_detection_lookup(\n    fastly_world_string_t *user_agent, fastly_world_string_t *ret,\n    fastly_compute_at_edge_device_detection_error_t *err) {\n  auto default_size = 1024;\n  ret->ptr = static_cast<uint8_t *>(cabi_malloc(default_size, 4));\n  auto status =\n      fastly::device_detection_lookup(reinterpret_cast<char *>(user_agent->ptr), user_agent->len,\n                                      reinterpret_cast<char *>(ret->ptr), default_size, &ret->len);\n  if (status == FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_BUFFER_LEN) {\n    ret->ptr = static_cast<uint8_t *>(cabi_realloc(ret->ptr, default_size, 4, ret->len));\n    status =\n        fastly::device_detection_lookup(reinterpret_cast<char *>(user_agent->ptr), user_agent->len,\n                                        reinterpret_cast<char *>(ret->ptr), ret->len, &ret->len);\n  }\n  return convert_result(status, err);\n}",
      "cve_list": [
        "CVE-2024-38375"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "js-compute-runtime",
      "filepath": "runtime/js-compute-runtime/host_interface/component/fastly_world_adapter.cpp",
      "func_name": "fastly_compute_at_edge_http_req_downstream_tls_cipher_openssl_name",
      "func_body": "bool fastly_compute_at_edge_http_req_downstream_tls_cipher_openssl_name(\n    fastly_world_string_t *ret, fastly_compute_at_edge_types_error_t *err) {\n  auto default_size = 128;\n  ret->ptr = static_cast<uint8_t *>(cabi_malloc(default_size, 4));\n  auto status = fastly::req_downstream_tls_cipher_openssl_name(reinterpret_cast<char *>(ret->ptr),\n                                                               default_size, &ret->len);\n  if (status == FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_BUFFER_LEN) {\n    ret->ptr = static_cast<uint8_t *>(cabi_realloc(ret->ptr, default_size, 4, ret->len));\n    status = fastly::req_downstream_tls_cipher_openssl_name(reinterpret_cast<char *>(ret->ptr),\n                                                            ret->len, &ret->len);\n  }\n  return convert_result(status, err);\n}",
      "cve_list": [
        "CVE-2024-38375"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "js-compute-runtime",
      "filepath": "runtime/js-compute-runtime/host_interface/component/fastly_world_adapter.cpp",
      "func_name": "fastly_compute_at_edge_http_req_downstream_tls_client_hello",
      "func_body": "bool fastly_compute_at_edge_http_req_downstream_tls_client_hello(\n    fastly_world_list_u8_t *ret, fastly_compute_at_edge_types_error_t *err) {\n  auto default_size = 512;\n  ret->ptr = static_cast<uint8_t *>(cabi_malloc(default_size, 4));\n  auto status = fastly::req_downstream_tls_client_hello(ret->ptr, default_size, &ret->len);\n  if (status == FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_BUFFER_LEN) {\n    ret->ptr = static_cast<uint8_t *>(cabi_realloc(ret->ptr, default_size, 4, ret->len));\n    status = fastly::req_downstream_tls_client_hello(ret->ptr, ret->len, &ret->len);\n  }\n  return convert_result(status, err);\n}",
      "cve_list": [
        "CVE-2024-38375"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "js-compute-runtime",
      "filepath": "runtime/js-compute-runtime/host_interface/component/fastly_world_adapter.cpp",
      "func_name": "fastly_compute_at_edge_http_req_downstream_tls_ja3_md5",
      "func_body": "bool fastly_compute_at_edge_http_req_downstream_tls_ja3_md5(\n    fastly_world_list_u8_t *ret, fastly_compute_at_edge_types_error_t *err) {\n  auto default_size = 16;\n  ret->ptr = static_cast<uint8_t *>(cabi_malloc(default_size, 4));\n  auto status = fastly::req_downstream_tls_ja3_md5(ret->ptr, &ret->len);\n  if (status == FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_BUFFER_LEN) {\n    ret->ptr = static_cast<uint8_t *>(cabi_realloc(ret->ptr, default_size, 4, ret->len));\n    status = fastly::req_downstream_tls_ja3_md5(ret->ptr, &ret->len);\n  }\n  return convert_result(status, err);\n}",
      "cve_list": [
        "CVE-2024-38375"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "js-compute-runtime",
      "filepath": "runtime/js-compute-runtime/host_interface/component/fastly_world_adapter.cpp",
      "func_name": "fastly_compute_at_edge_http_req_downstream_tls_protocol",
      "func_body": "bool fastly_compute_at_edge_http_req_downstream_tls_protocol(\n    fastly_world_string_t *ret, fastly_compute_at_edge_types_error_t *err) {\n  auto default_size = 32;\n  ret->ptr = static_cast<uint8_t *>(cabi_malloc(default_size, 4));\n  auto status = fastly::req_downstream_tls_protocol(reinterpret_cast<char *>(ret->ptr),\n                                                    default_size, &ret->len);\n  if (status == FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_BUFFER_LEN) {\n    ret->ptr = static_cast<uint8_t *>(cabi_realloc(ret->ptr, default_size, 4, ret->len));\n    status = fastly::req_downstream_tls_protocol(reinterpret_cast<char *>(ret->ptr), ret->len,\n                                                 &ret->len);\n  }\n  return convert_result(status, err);\n}",
      "cve_list": [
        "CVE-2024-38375"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "js-compute-runtime",
      "filepath": "runtime/js-compute-runtime/host_interface/component/fastly_world_adapter.cpp",
      "func_name": "fastly_compute_at_edge_http_req_downstream_tls_raw_client_certificate",
      "func_body": "bool fastly_compute_at_edge_http_req_downstream_tls_raw_client_certificate(\n    fastly_world_list_u8_t *ret, fastly_compute_at_edge_types_error_t *err) {\n  auto default_size = 4096;\n  ret->ptr = static_cast<uint8_t *>(cabi_malloc(default_size, 4));\n  auto status =\n      fastly::req_downstream_tls_raw_client_certificate(ret->ptr, default_size, &ret->len);\n  if (status == FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_BUFFER_LEN) {\n    ret->ptr = static_cast<uint8_t *>(cabi_realloc(ret->ptr, default_size, 4, ret->len));\n    status = fastly::req_downstream_tls_raw_client_certificate(ret->ptr, ret->len, &ret->len);\n  }\n  return convert_result(status, err);\n}",
      "cve_list": [
        "CVE-2024-38375"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "rapidjson",
      "filepath": "test/unittest/readertest.cpp",
      "func_name": "TestParseDouble",
      "func_body": "static void TestParseDouble() {\n#define TEST_DOUBLE(fullPrecision, str, x) \\\n    { \\\n        StringStream s(str); \\\n        ParseDoubleHandler h; \\\n        Reader reader; \\\n        ASSERT_EQ(kParseErrorNone, reader.Parse<fullPrecision ? kParseFullPrecisionFlag : 0>(s, h).Code()); \\\n        EXPECT_EQ(1u, h.step_); \\\n        internal::Double e(x), a(h.actual_); \\\n        if (fullPrecision) { \\\n            EXPECT_EQ(e.Uint64Value(), a.Uint64Value()); \\\n            if (e.Uint64Value() != a.Uint64Value()) \\\n                printf(\"  String: %s\\n  Actual: %.17g\\nExpected: %.17g\\n\", str, h.actual_, x); \\\n        } \\\n        else { \\\n            EXPECT_EQ(e.Sign(), a.Sign()); /* for 0.0 != -0.0 */ \\\n            EXPECT_DOUBLE_EQ(x, h.actual_); \\\n        } \\\n    }\n\n    TEST_DOUBLE(fullPrecision, \"0.0\", 0.0);\n    TEST_DOUBLE(fullPrecision, \"-0.0\", -0.0); // For checking issue #289\n    TEST_DOUBLE(fullPrecision, \"1.0\", 1.0);\n    TEST_DOUBLE(fullPrecision, \"-1.0\", -1.0);\n    TEST_DOUBLE(fullPrecision, \"1.5\", 1.5);\n    TEST_DOUBLE(fullPrecision, \"-1.5\", -1.5);\n    TEST_DOUBLE(fullPrecision, \"3.1416\", 3.1416);\n    TEST_DOUBLE(fullPrecision, \"1E10\", 1E10);\n    TEST_DOUBLE(fullPrecision, \"1e10\", 1e10);\n    TEST_DOUBLE(fullPrecision, \"1E+10\", 1E+10);\n    TEST_DOUBLE(fullPrecision, \"1E-10\", 1E-10);\n    TEST_DOUBLE(fullPrecision, \"-1E10\", -1E10);\n    TEST_DOUBLE(fullPrecision, \"-1e10\", -1e10);\n    TEST_DOUBLE(fullPrecision, \"-1E+10\", -1E+10);\n    TEST_DOUBLE(fullPrecision, \"-1E-10\", -1E-10);\n    TEST_DOUBLE(fullPrecision, \"1.234E+10\", 1.234E+10);\n    TEST_DOUBLE(fullPrecision, \"1.234E-10\", 1.234E-10);\n    TEST_DOUBLE(fullPrecision, \"1.79769e+308\", 1.79769e+308);\n    TEST_DOUBLE(fullPrecision, \"2.22507e-308\", 2.22507e-308);\n    TEST_DOUBLE(fullPrecision, \"-1.79769e+308\", -1.79769e+308);\n    TEST_DOUBLE(fullPrecision, \"-2.22507e-308\", -2.22507e-308);\n    TEST_DOUBLE(fullPrecision, \"4.9406564584124654e-324\", 4.9406564584124654e-324); // minimum denormal\n    TEST_DOUBLE(fullPrecision, \"2.2250738585072009e-308\", 2.2250738585072009e-308); // Max subnormal double\n    TEST_DOUBLE(fullPrecision, \"2.2250738585072014e-308\", 2.2250738585072014e-308); // Min normal positive double\n    TEST_DOUBLE(fullPrecision, \"1.7976931348623157e+308\", 1.7976931348623157e+308); // Max double\n    TEST_DOUBLE(fullPrecision, \"1e-10000\", 0.0);                                    // must underflow\n    TEST_DOUBLE(fullPrecision, \"18446744073709551616\", 18446744073709551616.0);     // 2^64 (max of uint64_t + 1, force to use double)\n    TEST_DOUBLE(fullPrecision, \"-9223372036854775809\", -9223372036854775809.0);     // -2^63 - 1(min of int64_t + 1, force to use double)\n    TEST_DOUBLE(fullPrecision, \"0.9868011474609375\", 0.9868011474609375);           // https://github.com/Tencent/rapidjson/issues/120\n    TEST_DOUBLE(fullPrecision, \"123e34\", 123e34);                                   // Fast Path Cases In Disguise\n    TEST_DOUBLE(fullPrecision, \"45913141877270640000.0\", 45913141877270640000.0);\n    TEST_DOUBLE(fullPrecision, \"2.2250738585072011e-308\", 2.2250738585072011e-308); // http://www.exploringbinary.com/php-hangs-on-numeric-value-2-2250738585072011e-308/\n    TEST_DOUBLE(fullPrecision, \"1e-00011111111111\", 0.0);                           // Issue #313\n    TEST_DOUBLE(fullPrecision, \"-1e-00011111111111\", -0.0);\n    TEST_DOUBLE(fullPrecision, \"1e-214748363\", 0.0);                                  // Maximum supported negative exponent\n    TEST_DOUBLE(fullPrecision, \"1e-214748364\", 0.0);\n    TEST_DOUBLE(fullPrecision, \"1e-21474836311\", 0.0);\n    TEST_DOUBLE(fullPrecision, \"1.00000000001e-2147483638\", 0.0);\n    TEST_DOUBLE(fullPrecision, \"0.017976931348623157e+310\", 1.7976931348623157e+308); // Max double in another form\n\n    // Since\n    // abs((2^-1022 - 2^-1074) - 2.2250738585072012e-308) = 3.109754131239141401123495768877590405345064751974375599... x 10^-324\n    // abs((2^-1022) - 2.2250738585072012e-308) = 1.830902327173324040642192159804623318305533274168872044... x 10 ^ -324\n    // So 2.2250738585072012e-308 should round to 2^-1022 = 2.2250738585072014e-308\n    TEST_DOUBLE(fullPrecision, \"2.2250738585072012e-308\", 2.2250738585072014e-308); // http://www.exploringbinary.com/java-hangs-when-converting-2-2250738585072012e-308/\n\n    // More closer to normal/subnormal boundary\n    // boundary = 2^-1022 - 2^-1075 = 2.225073858507201136057409796709131975934819546351645648... x 10^-308\n    TEST_DOUBLE(fullPrecision, \"2.22507385850720113605740979670913197593481954635164564e-308\", 2.2250738585072009e-308);\n    TEST_DOUBLE(fullPrecision, \"2.22507385850720113605740979670913197593481954635164565e-308\", 2.2250738585072014e-308);\n\n    // 1.0 is in (1.0 - 2^-54, 1.0 + 2^-53)\n    // 1.0 - 2^-54 = 0.999999999999999944488848768742172978818416595458984375\n    TEST_DOUBLE(fullPrecision, \"0.999999999999999944488848768742172978818416595458984375\", 1.0); // round to even\n    TEST_DOUBLE(fullPrecision, \"0.999999999999999944488848768742172978818416595458984374\", 0.99999999999999989); // previous double\n    TEST_DOUBLE(fullPrecision, \"0.999999999999999944488848768742172978818416595458984376\", 1.0); // next double\n    // 1.0 + 2^-53 = 1.00000000000000011102230246251565404236316680908203125\n    TEST_DOUBLE(fullPrecision, \"1.00000000000000011102230246251565404236316680908203125\", 1.0); // round to even\n    TEST_DOUBLE(fullPrecision, \"1.00000000000000011102230246251565404236316680908203124\", 1.0); // previous double\n    TEST_DOUBLE(fullPrecision, \"1.00000000000000011102230246251565404236316680908203126\", 1.00000000000000022); // next double\n\n    // Numbers from https://github.com/floitsch/double-conversion/blob/master/test/cctest/test-strtod.cc\n\n    TEST_DOUBLE(fullPrecision, \"72057594037927928.0\", 72057594037927928.0);\n    TEST_DOUBLE(fullPrecision, \"72057594037927936.0\", 72057594037927936.0);\n    TEST_DOUBLE(fullPrecision, \"72057594037927932.0\", 72057594037927936.0);\n    TEST_DOUBLE(fullPrecision, \"7205759403792793199999e-5\", 72057594037927928.0);\n    TEST_DOUBLE(fullPrecision, \"7205759403792793200001e-5\", 72057594037927936.0);\n\n    TEST_DOUBLE(fullPrecision, \"9223372036854774784.0\", 9223372036854774784.0);\n    TEST_DOUBLE(fullPrecision, \"9223372036854775808.0\", 9223372036854775808.0);\n    TEST_DOUBLE(fullPrecision, \"9223372036854775296.0\", 9223372036854775808.0);\n    TEST_DOUBLE(fullPrecision, \"922337203685477529599999e-5\", 9223372036854774784.0);\n    TEST_DOUBLE(fullPrecision, \"922337203685477529600001e-5\", 9223372036854775808.0);\n\n    TEST_DOUBLE(fullPrecision, \"10141204801825834086073718800384\", 10141204801825834086073718800384.0);\n    TEST_DOUBLE(fullPrecision, \"10141204801825835211973625643008\", 10141204801825835211973625643008.0);\n    TEST_DOUBLE(fullPrecision, \"10141204801825834649023672221696\", 10141204801825835211973625643008.0);\n    TEST_DOUBLE(fullPrecision, \"1014120480182583464902367222169599999e-5\", 10141204801825834086073718800384.0);\n    TEST_DOUBLE(fullPrecision, \"1014120480182583464902367222169600001e-5\", 10141204801825835211973625643008.0);\n\n    TEST_DOUBLE(fullPrecision, \"5708990770823838890407843763683279797179383808\", 5708990770823838890407843763683279797179383808.0);\n    TEST_DOUBLE(fullPrecision, \"5708990770823839524233143877797980545530986496\", 5708990770823839524233143877797980545530986496.0);\n    TEST_DOUBLE(fullPrecision, \"5708990770823839207320493820740630171355185152\", 5708990770823839524233143877797980545530986496.0);\n    TEST_DOUBLE(fullPrecision, \"5708990770823839207320493820740630171355185151999e-3\", 5708990770823838890407843763683279797179383808.0);\n    TEST_DOUBLE(fullPrecision, \"5708990770823839207320493820740630171355185152001e-3\", 5708990770823839524233143877797980545530986496.0);\n\n    {\n        char n1e308[310];   // '1' followed by 308 '0'\n        n1e308[0] = '1';\n        for (int i = 1; i < 309; i++)\n            n1e308[i] = '0';\n        n1e308[309] = '\\0';\n        TEST_DOUBLE(fullPrecision, n1e308, 1E308);\n    }\n\n    // Cover trimming\n    TEST_DOUBLE(fullPrecision,\n\"2.22507385850720113605740979670913197593481954635164564802342610972482222202107694551652952390813508\"\n\"7914149158913039621106870086438694594645527657207407820621743379988141063267329253552286881372149012\"\n\"9811224514518898490572223072852551331557550159143974763979834118019993239625482890171070818506906306\"\n\"6665599493827577257201576306269066333264756530000924588831643303777979186961204949739037782970490505\"\n\"1080609940730262937128958950003583799967207254304360284078895771796150945516748243471030702609144621\"\n\"5722898802581825451803257070188608721131280795122334262883686223215037756666225039825343359745688844\"\n\"2390026549819838548794829220689472168983109969836584681402285424333066033985088644580400103493397042\"\n\"7567186443383770486037861622771738545623065874679014086723327636718751234567890123456789012345678901\"\n\"e-308\",\n    2.2250738585072014e-308);\n\n    {\n        static const unsigned count = 100; // Tested with 1000000 locally\n        Random r;\n        Reader reader; // Reusing reader to prevent heap allocation\n\n        // Exhaustively test different exponents with random significant\n        for (uint64_t exp = 0; exp < 2047; exp++) {\n            ;\n            for (unsigned i = 0; i < count; i++) {\n                // Need to call r() in two statements for cross-platform coherent sequence.\n                uint64_t u = (exp << 52) | uint64_t(r() & 0x000FFFFF) << 32;\n                u |= uint64_t(r());\n                internal::Double d = internal::Double(u);\n\n                char buffer[32];\n                *internal::dtoa(d.Value(), buffer) = '\\0';\n\n                StringStream s(buffer);\n                ParseDoubleHandler h;\n                ASSERT_EQ(kParseErrorNone, reader.Parse<fullPrecision ? kParseFullPrecisionFlag : 0>(s, h).Code());\n                EXPECT_EQ(1u, h.step_);\n                internal::Double a(h.actual_);\n                if (fullPrecision) {\n                    EXPECT_EQ(d.Uint64Value(), a.Uint64Value());\n                    if (d.Uint64Value() != a.Uint64Value())\n                        printf(\"  String: %s\\n  Actual: %.17g\\nExpected: %.17g\\n\", buffer, h.actual_, d.Value());\n                }\n                else {\n                    EXPECT_EQ(d.Sign(), a.Sign()); // for 0.0 != -0.0\n                    EXPECT_DOUBLE_EQ(d.Value(), h.actual_);\n                }\n            }\n        }\n    }\n\n    // Issue #340\n    TEST_DOUBLE(fullPrecision, \"7.450580596923828e-9\", 7.450580596923828e-9);\n    {\n        internal::Double d(1.0);\n        for (int i = 0; i < 324; i++) {\n            char buffer[32];\n            *internal::dtoa(d.Value(), buffer) = '\\0';\n\n            StringStream s(buffer);\n            ParseDoubleHandler h;\n            Reader reader;\n            ASSERT_EQ(kParseErrorNone, reader.Parse<fullPrecision ? kParseFullPrecisionFlag : 0>(s, h).Code());\n            EXPECT_EQ(1u, h.step_);\n            internal::Double a(h.actual_);\n            if (fullPrecision) {\n                EXPECT_EQ(d.Uint64Value(), a.Uint64Value());\n                if (d.Uint64Value() != a.Uint64Value())\n                    printf(\"  String: %s\\n  Actual: %.17g\\nExpected: %.17g\\n\", buffer, h.actual_, d.Value());\n            }\n            else {\n                EXPECT_EQ(d.Sign(), a.Sign()); // for 0.0 != -0.0\n                EXPECT_DOUBLE_EQ(d.Value(), h.actual_);\n            }\n\n\n            d = d.Value() * 0.5;\n        }\n    }\n#undef TEST_DOUBLE\n}",
      "cve_list": [
        "CVE-2024-38517"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "vnote",
      "filepath": "src/utils/widgetutils.cpp",
      "func_name": "WidgetUtils::openUrlByDesktop",
      "func_body": "void WidgetUtils::openUrlByDesktop(const QUrl &p_url)\n{\n    const auto scheme = p_url.scheme();\n    if (scheme != \"http\" && scheme != \"https\") {\n        // Prompt for user.\n        int ret = MessageBoxHelper::questionYesNo(MessageBoxHelper::Warning,\n                                                  MainWindow::tr(\"Are you sure to open link (%1)?\").arg(p_url.toString()),\n                                                  MainWindow::tr(\"Malicious link might do harm to your device.\"),\n                                                  QString(),\n                                                  nullptr);\n        if (ret == QMessageBox::No) {\n            return;\n        }\n    }\n\n    QDesktopServices::openUrl(p_url);\n}",
      "cve_list": [
        "CVE-2024-39904"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "OpenImageIO",
      "filepath": "src/heif.imageio/heifinput.cpp",
      "func_name": "HeifInput::seek_subimage",
      "func_body": "HeifInput::seek_subimage(int subimage, int miplevel)\n{\n    if (miplevel != 0)\n        return false;\n\n    if (subimage == m_subimage) {\n        return true;  // already there\n    }\n\n    if (subimage >= m_num_subimages) {\n        return false;\n    }\n\n    auto id     = (subimage == 0) ? m_primary_id : m_item_ids[subimage - 1];\n    m_ihandle   = m_ctx->get_image_handle(id);\n    m_has_alpha = m_ihandle.has_alpha_channel();\n    auto chroma = m_has_alpha ? heif_chroma_interleaved_RGBA\n                              : heif_chroma_interleaved_RGB;\n#if 0\n    try {\n        m_himage = m_ihandle.decode_image(heif_colorspace_RGB, chroma);\n    } catch (const heif::Error& err) {\n        std::string e = err.get_message();\n        errorf(\"%s\", e.empty() ? \"unknown exception\" : e.c_str());\n        return false;\n    } catch (const std::exception& err) {\n        std::string e = err.what();\n        errorf(\"%s\", e.empty() ? \"unknown exception\" : e.c_str());\n        return false;\n    }\n#else\n    std::unique_ptr<heif_decoding_options, void (*)(heif_decoding_options*)>\n        options(heif_decoding_options_alloc(), heif_decoding_options_free);\n    options->ignore_transformations = !m_reorient;\n    // print(\"Got decoding options version {}\\n\", options->version);\n    struct heif_image* img_tmp = nullptr;\n    struct heif_error herr = heif_decode_image(m_ihandle.get_raw_image_handle(),\n                                               &img_tmp, heif_colorspace_RGB,\n                                               chroma, options.get());\n    if (img_tmp)\n        m_himage = heif::Image(img_tmp);\n    if (herr.code != heif_error_Ok || !img_tmp) {\n        errorfmt(\"Could not decode image ({})\", herr.message);\n        m_ctx.reset();\n        return false;\n    }\n#endif\n\n    int bits = m_himage.get_bits_per_pixel(heif_channel_interleaved);\n    m_spec   = ImageSpec(m_himage.get_width(heif_channel_interleaved),\n                         m_himage.get_height(heif_channel_interleaved), bits / 8,\n                         TypeUInt8);\n\n    m_spec.attribute(\"oiio:ColorSpace\", \"sRGB\");\n\n#if LIBHEIF_HAVE_VERSION(1, 12, 0)\n    // Libheif >= 1.12 added API call to find out if the image is associated\n    // alpha (i.e. colors are premultiplied).\n    m_associated_alpha = m_himage.is_premultiplied_alpha();\n    m_do_associate     = (!m_associated_alpha && m_spec.alpha_channel >= 0\n                      && !m_keep_unassociated_alpha);\n    if (!m_associated_alpha && m_spec.nchannels >= 4) {\n        // Indicate that file stored unassociated alpha data\n        m_spec.attribute(\"heif:UnassociatedAlpha\", 1);\n        // If we don't have 4 chans, we need not consider\n        m_keep_unassociated_alpha &= (m_spec.nchannels >= 4);\n        if (m_keep_unassociated_alpha) {\n            // Indicate that we are returning unassociated data if the file\n            // had associated and we were asked to keep it that way.\n            m_spec.attribute(\"oiio:UnassociatedAlpha\", 1);\n        }\n    }\n#else\n    m_associated_alpha = true;  // assume/hope\n#endif\n\n    auto meta_ids = m_ihandle.get_list_of_metadata_block_IDs();\n    // std::cout << \"nmeta? \" << meta_ids.size() << \"\\n\";\n    for (auto m : meta_ids) {\n        std::vector<uint8_t> metacontents;\n        try {\n            metacontents = m_ihandle.get_metadata(m);\n        } catch (const heif::Error& err) {\n            if (err.get_code() == heif_error_Usage_error\n                && err.get_subcode() == heif_suberror_Null_pointer_argument) {\n                // a bug in heif_cxx.h means a 0 byte metadata causes a null\n                // ptr error code, which we ignore\n                continue;\n            }\n        }\n        if (Strutil::iequals(m_ihandle.get_metadata_type(m), \"Exif\")\n            && metacontents.size() >= 10) {\n            cspan<uint8_t> s(&metacontents[10], metacontents.size() - 10);\n            decode_exif(s, m_spec);\n        } else if (0  // For now, skip this, I haven't seen anything useful\n                   && Strutil::iequals(m_ihandle.get_metadata_type(m), \"mime\")\n                   && Strutil::iequals(m_ihandle.get_metadata_content_type(m),\n                                       \"application/rdf+xml\")) {\n            decode_xmp(metacontents, m_spec);\n        } else {\n#ifdef DEBUG\n            print(\n                \"Don't know how to decode meta {} type='{}' contenttype='{}'\\n\",\n                m, m_ihandle.get_metadata_type(m),\n                m_ihandle.get_metadata_content_type(m));\n            print(\"---\\n{}\\n---\\n\",\n                  string_view((const char*)metacontents.data(),\n                              metacontents.size()));\n#endif\n        }\n    }\n\n#if LIBHEIF_NUMERIC_VERSION >= MAKE_LIBHEIF_VERSION(1, 16, 0, 0)\n    // Try to discover the orientation. The Exif is unreliable. We have to go\n    // through the transformation properties ourselves. A tricky bit is that\n    // the C++ API doesn't give us a direct way to get the context ptr, we\n    // need to resort to some casting trickery, with knowledge that the C++\n    // heif::Context class consists solely of a std::shared_ptr to a\n    // heif_context.\n    // NO int orientation = m_spec.get_int_attribute(\"Orientation\", 1);\n    int orientation = 1;\n    const heif_context* raw_ctx\n        = reinterpret_cast<std::shared_ptr<heif_context>*>(m_ctx.get())->get();\n    int xpcount = heif_item_get_transformation_properties(raw_ctx, id, nullptr,\n                                                          100);\n    xpcount     = std::min(xpcount, 100);  // clamp to some reasonable limit\n    std::vector<heif_property_id> xprops(xpcount);\n    heif_item_get_transformation_properties(raw_ctx, id, xprops.data(),\n                                            xpcount);\n    for (int i = 0; i < xpcount; ++i) {\n        auto type = heif_item_get_property_type(raw_ctx, id, xprops[i]);\n        if (type == heif_item_property_type_transform_rotation) {\n            int rot = heif_item_get_property_transform_rotation_ccw(raw_ctx, id,\n                                                                    xprops[i]);\n            // cw[] maps to one additional clockwise 90 degree turn\n            static const int cw[] = { 0, 6, 7, 8, 5, 2, 3, 4, 1 };\n            for (int i = 0; i < rot / 90; ++i)\n                orientation = cw[orientation];\n        } else if (type == heif_item_property_type_transform_mirror) {\n            int mirror = heif_item_get_property_transform_mirror(raw_ctx, id,\n                                                                 xprops[i]);\n            //                                1  2  3  4  5  6  7  8\n            static const int mirrorh[] = { 0, 2, 1, 4, 3, 6, 5, 8, 7 };\n            static const int mirrorv[] = { 0, 4, 3, 2, 1, 8, 7, 6, 5 };\n            if (mirror == heif_transform_mirror_direction_vertical) {\n                orientation = mirrorv[orientation];\n            } else if (mirror == heif_transform_mirror_direction_horizontal) {\n                orientation = mirrorh[orientation];\n            }\n        }\n    }\n#else\n    // Prior to libheif 1.16, the get_transformation_properties API was not\n    // available, so we have to rely on the Exif orientation tag.\n    int orientation = m_spec.get_int_attribute(\"Orientation\", 1);\n#endif\n\n    // Erase the orientation metadata because libheif appears to be doing\n    // the rotation-to-canonical-direction for us.\n    if (orientation != 1) {\n        if (m_reorient) {\n            // If libheif auto-reoriented, record the original orientation in\n            // \"oiio:OriginalOrientation\" and set the \"Orientation\" attribute\n            // to 1 since we're presenting the image to the caller in the\n            // usual orientation.\n            m_spec.attribute(\"oiio:OriginalOrientation\", orientation);\n            m_spec.attribute(\"Orientation\", 1);\n        } else {\n            // libheif supplies oriented width & height, so if we are NOT\n            // auto-reorienting and it's one of the orientations that swaps\n            // width and height, we need to do that swap ourselves.\n            // Note: all the orientations that swap width and height are 5-8,\n            // whereas 1-4 preserve aspect ratio.\n            if (orientation >= 5) {\n                std::swap(m_spec.width, m_spec.height);\n                std::swap(m_spec.full_width, m_spec.full_height);\n            }\n        }\n    }\n\n    m_subimage = subimage;\n    return true;\n}",
      "cve_list": [
        "CVE-2024-40630"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "llama.cpp",
      "filepath": "examples/gguf/gguf.cpp",
      "func_name": "gguf_ex_read_0",
      "func_body": "static bool gguf_ex_read_0(const std::string & fname) {\n    struct gguf_init_params params = {\n        /*.no_alloc = */ false,\n        /*.ctx      = */ NULL,\n    };\n\n    struct gguf_context * ctx = gguf_init_from_file(fname.c_str(), params);\n\n    if (!ctx) {\n        fprintf(stderr, \"%s: failed to load '%s'\\n\", __func__, fname.c_str());\n        return false;\n    }\n\n    printf(\"%s: version:      %d\\n\", __func__, gguf_get_version(ctx));\n    printf(\"%s: alignment:   %zu\\n\", __func__, gguf_get_alignment(ctx));\n    printf(\"%s: data offset: %zu\\n\", __func__, gguf_get_data_offset(ctx));\n\n    // kv\n    {\n        const int n_kv = gguf_get_n_kv(ctx);\n\n        printf(\"%s: n_kv: %d\\n\", __func__, n_kv);\n\n        for (int i = 0; i < n_kv; ++i) {\n            const char * key = gguf_get_key(ctx, i);\n\n            printf(\"%s: kv[%d]: key = %s\\n\", __func__, i, key);\n        }\n    }\n\n    // find kv string\n    {\n        const char * findkey = \"some.parameter.string\";\n\n        const int keyidx = gguf_find_key(ctx, findkey);\n        if (keyidx == -1) {\n            printf(\"%s: find key: %s not found.\\n\", __func__, findkey);\n        } else {\n            const char * key_value = gguf_get_val_str(ctx, keyidx);\n            printf(\"%s: find key: %s found, kv[%d] value = %s\\n\", __func__, findkey, keyidx, key_value);\n        }\n    }\n\n    // tensor info\n    {\n        const int n_tensors = gguf_get_n_tensors(ctx);\n\n        printf(\"%s: n_tensors: %d\\n\", __func__, n_tensors);\n\n        for (int i = 0; i < n_tensors; ++i) {\n            const char * name   = gguf_get_tensor_name  (ctx, i);\n            const size_t offset = gguf_get_tensor_offset(ctx, i);\n\n            printf(\"%s: tensor[%d]: name = %s, offset = %zu\\n\", __func__, i, name, offset);\n        }\n    }\n\n    gguf_free(ctx);\n\n    return true;\n}",
      "cve_list": [
        "CVE-2024-41130"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    },
    {
      "project": "llama.cpp",
      "filepath": "ggml/src/ggml.c",
      "func_name": "gguf_init_from_file",
      "func_body": "struct gguf_context * gguf_init_from_file(const char * fname, struct gguf_init_params params) {\n    FILE * file = ggml_fopen(fname, \"rb\");\n    if (!file) {\n        fprintf(stderr, \"%s: failed to open '%s': '%s'\\n\", __func__, fname, strerror(errno));\n        return NULL;\n    }\n\n    // offset from start of file\n    size_t offset = 0;\n\n    char magic[4];\n\n    // check the magic before making allocations\n    {\n        gguf_fread_el(file, &magic, sizeof(magic), &offset);\n\n        for (uint32_t i = 0; i < sizeof(magic); i++) {\n            if (magic[i] != GGUF_MAGIC[i]) {\n                fprintf(stderr, \"%s: invalid magic characters '%c%c%c%c'\\n\", __func__, magic[0], magic[1], magic[2], magic[3]);\n                fclose(file);\n                return NULL;\n            }\n        }\n    }\n\n    bool ok = true;\n\n    struct gguf_context * ctx = GGML_CALLOC(1, sizeof(struct gguf_context));\n\n    // read the header\n    {\n        strncpy(ctx->header.magic, magic, 4);\n\n        ctx->kv    = NULL;\n        ctx->infos = NULL;\n        ctx->data  = NULL;\n\n        ok = ok && gguf_fread_el(file, &ctx->header.version,   sizeof(ctx->header.version),   &offset);\n        ok = ok && gguf_fread_el(file, &ctx->header.n_tensors, sizeof(ctx->header.n_tensors), &offset);\n        ok = ok && gguf_fread_el(file, &ctx->header.n_kv,      sizeof(ctx->header.n_kv),      &offset);\n\n        if (ctx->header.version == 1) {\n            fprintf(stderr, \"%s: GGUFv1 is no longer supported. please use a more up-to-date version\\n\", __func__);\n            fclose(file);\n            gguf_free(ctx);\n            return NULL;\n        }\n\n        // sanity-checks to prevent from integer/buffer overflows\n\n        ok = ok && (ctx->header.n_tensors < (SIZE_MAX/2)/sizeof(struct gguf_tensor_info));\n        ok = ok && (ctx->header.n_tensors < (SIZE_MAX/2)/ggml_tensor_overhead());\n        ok = ok && (ctx->header.n_kv      < (SIZE_MAX/2)/sizeof(struct gguf_kv));\n\n        if (!ok) {\n            fprintf(stderr, \"%s: failed to read header\\n\", __func__);\n            fclose(file);\n            gguf_free(ctx);\n            return NULL;\n        }\n    }\n\n    // read the kv pairs\n    {\n        const uint64_t n_kv = ctx->header.n_kv;\n\n        // header.n_kv will hold the actual value of pairs that were successfully read in the loop below\n        ctx->header.n_kv = 0;\n        ctx->kv = GGML_CALLOC(n_kv, sizeof(struct gguf_kv));\n\n        for (uint64_t i = 0; i < n_kv; ++i) {\n            struct gguf_kv * kv = &ctx->kv[i];\n\n            //fprintf(stderr, \"%s: reading kv %d\\n\", __func__, i);\n\n            ok = ok && gguf_fread_str(file, &kv->key,                    &offset);\n            ok = ok && gguf_fread_el (file, &kv->type, sizeof(kv->type), &offset);\n\n            //fprintf(stderr, \"%s: reading kv with key %s\\n\", __func__, kv->key.data);\n\n            switch (kv->type) {\n                case GGUF_TYPE_UINT8:   ok = ok && gguf_fread_el (file, &kv->value.uint8,   sizeof(kv->value.uint8),   &offset); break;\n                case GGUF_TYPE_INT8:    ok = ok && gguf_fread_el (file, &kv->value.int8,    sizeof(kv->value.int8),    &offset); break;\n                case GGUF_TYPE_UINT16:  ok = ok && gguf_fread_el (file, &kv->value.uint16,  sizeof(kv->value.uint16),  &offset); break;\n                case GGUF_TYPE_INT16:   ok = ok && gguf_fread_el (file, &kv->value.int16,   sizeof(kv->value.int16),   &offset); break;\n                case GGUF_TYPE_UINT32:  ok = ok && gguf_fread_el (file, &kv->value.uint32,  sizeof(kv->value.uint32),  &offset); break;\n                case GGUF_TYPE_INT32:   ok = ok && gguf_fread_el (file, &kv->value.int32,   sizeof(kv->value.int32),   &offset); break;\n                case GGUF_TYPE_FLOAT32: ok = ok && gguf_fread_el (file, &kv->value.float32, sizeof(kv->value.float32), &offset); break;\n                case GGUF_TYPE_UINT64:  ok = ok && gguf_fread_el (file, &kv->value.uint64,  sizeof(kv->value.uint64),  &offset); break;\n                case GGUF_TYPE_INT64:   ok = ok && gguf_fread_el (file, &kv->value.int64,   sizeof(kv->value.int64),   &offset); break;\n                case GGUF_TYPE_FLOAT64: ok = ok && gguf_fread_el (file, &kv->value.float64, sizeof(kv->value.float64), &offset); break;\n                case GGUF_TYPE_BOOL:    ok = ok && gguf_fread_el (file, &kv->value.bool_,   sizeof(kv->value.bool_),   &offset); break;\n                case GGUF_TYPE_STRING:  ok = ok && gguf_fread_str(file, &kv->value.str,                                &offset); break;\n                case GGUF_TYPE_ARRAY:\n                    {\n                        ok = ok && gguf_fread_el(file, &kv->value.arr.type, sizeof(kv->value.arr.type), &offset);\n                        ok = ok && gguf_fread_el(file, &kv->value.arr.n,    sizeof(kv->value.arr.n),    &offset);\n\n                        switch (kv->value.arr.type) {\n                            case GGUF_TYPE_UINT8:\n                            case GGUF_TYPE_INT8:\n                            case GGUF_TYPE_UINT16:\n                            case GGUF_TYPE_INT16:\n                            case GGUF_TYPE_UINT32:\n                            case GGUF_TYPE_INT32:\n                            case GGUF_TYPE_FLOAT32:\n                            case GGUF_TYPE_UINT64:\n                            case GGUF_TYPE_INT64:\n                            case GGUF_TYPE_FLOAT64:\n                            case GGUF_TYPE_BOOL:\n                                {\n                                    // prevent from integer overflow in the malloc below\n                                    if (kv->value.arr.n >= SIZE_MAX/gguf_type_size(kv->value.arr.type)) {\n                                        fprintf(stderr, \"%s: array size is too large (%\" PRIu64 \")\\n\", __func__, kv->value.arr.n);\n                                        fclose(file);\n                                        gguf_free(ctx);\n                                        return NULL;\n                                    }\n\n                                    kv->value.arr.data = GGML_CALLOC(kv->value.arr.n, gguf_type_size(kv->value.arr.type));\n\n                                    ok = ok && gguf_fread_el(file, kv->value.arr.data, kv->value.arr.n * gguf_type_size(kv->value.arr.type), &offset);\n                                } break;\n                            case GGUF_TYPE_STRING:\n                                {\n                                    // prevent from integer overflow in the malloc below\n                                    if (kv->value.arr.n >= SIZE_MAX/sizeof(struct gguf_str)) {\n                                        fprintf(stderr, \"%s: array size is too large (%\" PRIu64 \")\\n\", __func__, kv->value.arr.n);\n                                        fclose(file);\n                                        gguf_free(ctx);\n                                        return NULL;\n                                    }\n\n                                    kv->value.arr.data = GGML_CALLOC(kv->value.arr.n, sizeof(struct gguf_str));\n\n                                    for (uint64_t j = 0; j < kv->value.arr.n; ++j) {\n                                        ok = ok && gguf_fread_str(file, &((struct gguf_str *) kv->value.arr.data)[j], &offset);\n                                    }\n                                } break;\n                            case GGUF_TYPE_ARRAY:\n                            default: GGML_ASSERT(false && \"invalid type\"); break;\n                        }\n                    } break;\n                default: GGML_ASSERT(false && \"invalid type\");\n            }\n\n            if (!ok) {\n                break;\n            }\n\n            ctx->header.n_kv++;\n        }\n\n        if (!ok) {\n            fprintf(stderr, \"%s: failed to read key-value pairs\\n\", __func__);\n            fclose(file);\n            gguf_free(ctx);\n            return NULL;\n        }\n    }\n\n    // read the tensor infos\n    if (ctx->header.n_tensors > 0) {\n        ctx->infos = GGML_CALLOC(ctx->header.n_tensors, sizeof(struct gguf_tensor_info));\n\n        for (uint64_t i = 0; i < ctx->header.n_tensors; ++i) {\n            struct gguf_tensor_info * info = &ctx->infos[i];\n\n            for (int j = 0; j < GGML_MAX_DIMS; ++j) {\n                info->ne[j] = 1;\n            }\n\n            ok = ok && gguf_fread_str(file, &info->name,                          &offset);\n            ok = ok && gguf_fread_el (file, &info->n_dims, sizeof(info->n_dims),  &offset);\n\n            ok = ok && (info->n_dims <= GGML_MAX_DIMS);\n\n            for (uint32_t j = 0; j < info->n_dims; ++j) {\n                ok = ok && gguf_fread_el(file, &info->ne[j], sizeof(info->ne[j]), &offset);\n            }\n\n            ok = ok && gguf_fread_el (file, &info->type,   sizeof(info->type),    &offset);\n            ok = ok && gguf_fread_el (file, &info->offset, sizeof(info->offset),  &offset);\n\n            // TODO: return an error instead of crashing with GGML_ASSERT\n            gguf_tensor_info_sanitize(info);\n\n            // make sure there is no duplicated tensor names\n            for (uint64_t j = 0; j < i && ok; ++j) {\n                if (strcmp(info->name.data, ctx->infos[j].name.data) == 0) {\n                    fprintf(stderr, \"%s: duplicated tensor name %s\\n\", __func__, info->name.data);\n                    ok = false;\n                }\n            }\n\n            if (!ok) {\n                fprintf(stderr, \"%s: failed to read tensor info\\n\", __func__);\n                fclose(file);\n                gguf_free(ctx);\n                return NULL;\n            }\n        }\n    }\n\n    ctx->alignment = GGUF_DEFAULT_ALIGNMENT;\n\n    int alignment_idx = gguf_find_key(ctx, \"general.alignment\");\n    if (alignment_idx != -1) {\n        ctx->alignment = gguf_get_val_u32(ctx, alignment_idx);\n    }\n\n    // we require the data section to be aligned, so take into account any padding\n    {\n        const size_t offset_pad = offset % ctx->alignment;\n\n        if (offset_pad != 0) {\n            offset += ctx->alignment - offset_pad;\n            fseek(file, offset, SEEK_SET);\n        }\n    }\n\n    // store the current file offset - this is where the data section starts\n    ctx->offset = offset;\n\n    // compute the total size of the data section, taking into account the alignment\n    {\n        ctx->size = 0;\n        for (uint64_t i = 0; i < ctx->header.n_tensors; ++i) {\n            struct gguf_tensor_info * info = &ctx->infos[i];\n\n            const int64_t ne =\n                (int64_t) info->ne[0] *\n                (int64_t) info->ne[1] *\n                (int64_t) info->ne[2] *\n                (int64_t) info->ne[3];\n\n            if (ne % ggml_blck_size(info->type) != 0) {\n                fprintf(stderr, \"%s: tensor '%s' of type %d (%s) number of elements (%\" PRId64 \") is not a multiple of block size (%\" PRId64 \")\\n\",\n                        __func__, info->name.data, (int) info->type, ggml_type_name(info->type), ne, ggml_blck_size(info->type));\n                fclose(file);\n                gguf_free(ctx);\n                return NULL;\n            }\n\n            const size_t size_cur = ggml_row_size(info->type, ne);\n\n            ctx->size += GGML_PAD(size_cur, ctx->alignment);\n        }\n    }\n\n    // load the tensor data only if requested\n    if (params.ctx != NULL) {\n        // if the provided gguf_context is no_alloc, then we create \"empty\" tensors and do not read the binary blob\n        // otherwise, we load the binary blob into the created ggml_context as well, and point the \"data\" members of\n        // the ggml_tensor structs to the appropriate locations in the binary blob\n\n        // compute the exact size needed for the new ggml_context\n        const size_t mem_size =\n            params.no_alloc ?\n            (ctx->header.n_tensors    )*ggml_tensor_overhead() :\n            (ctx->header.n_tensors + 1)*ggml_tensor_overhead() + ctx->size;\n\n        struct ggml_init_params pdata = {\n            .mem_size   = mem_size,\n            .mem_buffer = NULL,\n            .no_alloc   = params.no_alloc,\n        };\n\n        *params.ctx = ggml_init(pdata);\n\n        struct ggml_context * ctx_data = *params.ctx;\n\n        struct ggml_tensor * data = NULL;\n\n        if (!params.no_alloc) {\n            data = ggml_new_tensor_1d(ctx_data, GGML_TYPE_I8, ctx->size);\n\n            ok = ok && data != NULL;\n\n            // read the binary blob with the tensor data\n            ok = ok && gguf_fread_el(file, data->data, ctx->size, &offset);\n\n            if (!ok) {\n                fprintf(stderr, \"%s: failed to read tensor data\\n\", __func__);\n                fclose(file);\n                ggml_free(ctx_data);\n                gguf_free(ctx);\n                return NULL;\n            }\n\n            ctx->data = data->data;\n        }\n\n        ggml_set_no_alloc(ctx_data, true);\n\n        // create the tensors\n        for (uint64_t i = 0; i < ctx->header.n_tensors; ++i) {\n            const int64_t ne[GGML_MAX_DIMS] = {\n                ctx->infos[i].ne[0],\n                ctx->infos[i].ne[1],\n                ctx->infos[i].ne[2],\n                ctx->infos[i].ne[3],\n            };\n\n            struct ggml_tensor * cur = ggml_new_tensor(ctx_data, ctx->infos[i].type, ctx->infos[i].n_dims, ne);\n\n            ok = ok && cur != NULL;\n\n            if (!ok) {\n                break;\n            }\n\n            ggml_set_name(cur, ctx->infos[i].name.data);\n\n            // point the data member to the appropriate location in the binary blob using the tensor infos\n            if (!params.no_alloc) {\n              //cur->data = (char *) data->data + ctx->infos[i].offset - ctx->offset; // offset from start of file\n                cur->data = (char *) data->data + ctx->infos[i].offset;               // offset from data\n            }\n        }\n\n        if (!ok) {\n            fprintf(stderr, \"%s: failed to read the tensor data\\n\", __func__);\n            fclose(file);\n            ggml_free(ctx_data);\n            gguf_free(ctx);\n            return NULL;\n        }\n\n        ggml_set_no_alloc(ctx_data, params.no_alloc);\n    }\n\n    fclose(file);\n\n    return ctx;\n}",
      "cve_list": [
        "CVE-2024-41130"
      ],
      "cwe_list": [
        "NVD-CWE-noinfo"
      ]
    }
  ]
}