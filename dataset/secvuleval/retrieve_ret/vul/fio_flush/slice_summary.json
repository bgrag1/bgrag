[
    {
        "cwe": "CWE-203",
        "func_name": "389ds/send_ldap_result_ext",
        "score": 0.6915411949157715,
        "func_before": "void\nsend_ldap_result_ext(\n    Slapi_PBlock *pb,\n    int err,\n    char *matched,\n    char *text,\n    int nentries,\n    struct berval **urls,\n    BerElement *ber)\n{\n    Slapi_Operation *operation;\n    passwdPolicy *pwpolicy = NULL;\n    Connection *conn = NULL;\n    Slapi_DN *sdn = NULL;\n    const char *dn = NULL;\n    ber_tag_t tag;\n    int flush_ber_element = 1;\n    ber_tag_t bind_method = 0;\n    int internal_op;\n    int i, rc, logit = 0;\n    char *pbtext;\n\n    slapi_pblock_get(pb, SLAPI_BIND_METHOD, &bind_method);\n    slapi_pblock_get(pb, SLAPI_OPERATION, &operation);\n    slapi_pblock_get(pb, SLAPI_CONNECTION, &conn);\n\n    if (text) {\n        pbtext = text;\n    } else {\n        slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &pbtext);\n    }\n\n    if (operation == NULL) {\n        slapi_log_err(SLAPI_LOG_ERR, \"send_ldap_result_ext\", \"No operation found: slapi_search_internal_set_pb was incomplete (invalid 'base' ?)\\n\");\n        return;\n    }\n\n    if (operation->o_status == SLAPI_OP_STATUS_RESULT_SENT) {\n        return; /* result already sent */\n    }\n\n    if (ber != NULL) {\n        flush_ber_element = 0;\n    }\n\n    if (err != LDAP_SUCCESS) {\n        /* count the error for snmp */\n        /* first check for security errors */\n        if (err == LDAP_INVALID_CREDENTIALS || err == LDAP_INAPPROPRIATE_AUTH || err == LDAP_AUTH_METHOD_NOT_SUPPORTED || err == LDAP_STRONG_AUTH_NOT_SUPPORTED || err == LDAP_STRONG_AUTH_REQUIRED || err == LDAP_CONFIDENTIALITY_REQUIRED || err == LDAP_INSUFFICIENT_ACCESS || err == LDAP_AUTH_UNKNOWN) {\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsSecurityErrors);\n        } else if (err != LDAP_REFERRAL && err != LDAP_OPT_REFERRALS && err != LDAP_PARTIAL_RESULTS) {\n            /*madman man spec says not to count as normal errors\n                --security errors\n                --referrals\n                -- partially seviced operations will not be conted as an error\n                      */\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsErrors);\n        }\n    }\n\n    slapi_log_err(SLAPI_LOG_TRACE, \"send_ldap_result_ext\", \"=> %d:%s:%s\\n\", err,\n                  matched ? matched : \"\", text ? text : \"\");\n\n    switch (operation->o_tag) {\n    case LBER_DEFAULT:\n        tag = LBER_SEQUENCE;\n        break;\n\n    case LDAP_REQ_SEARCH:\n        tag = LDAP_RES_SEARCH_RESULT;\n        break;\n\n    case LDAP_REQ_DELETE:\n        tag = LDAP_RES_DELETE;\n        break;\n\n    case LDAP_REFERRAL:\n        if (conn && conn->c_ldapversion > LDAP_VERSION2) {\n            tag = LDAP_TAG_REFERRAL;\n            break;\n        }\n    /* FALLTHROUGH */\n\n    default:\n        tag = operation->o_tag + 1;\n        break;\n    }\n\n    internal_op = operation_is_flag_set(operation, OP_FLAG_INTERNAL);\n    if ((conn == NULL) || (internal_op)) {\n        if (operation->o_result_handler != NULL) {\n            operation->o_result_handler(conn, operation, err,\n                                        matched, text, nentries, urls);\n            logit = 1;\n        }\n        goto log_and_return;\n    }\n\n    /* invalid password.  Update the password retry here */\n    /* put this here for now.  It could be a send_result pre-op plugin. */\n    if ((err == LDAP_INVALID_CREDENTIALS) && (bind_method != LDAP_AUTH_SASL)) {\n        slapi_pblock_get(pb, SLAPI_TARGET_SDN, &sdn);\n        dn = slapi_sdn_get_dn(sdn);\n        pwpolicy = new_passwdPolicy(pb, dn);\n        if (pwpolicy && (pwpolicy->pw_lockout == 1)) {\n            if (update_pw_retry(pb) == LDAP_CONSTRAINT_VIOLATION && !pwpolicy->pw_is_legacy) {\n                /*\n                 * If we are not using the legacy pw policy behavior,\n                 * convert the error 49 to 19 (constraint violation)\n                 * and log a message\n                 */\n                err = LDAP_CONSTRAINT_VIOLATION;\n                text = \"Invalid credentials, you now have exceeded the password retry limit.\";\n            }\n        }\n    }\n\n    if (ber == NULL) {\n        if ((ber = der_alloc()) == NULL) {\n            slapi_log_err(SLAPI_LOG_ERR, \"send_ldap_result_ext\", \"ber_alloc failed\\n\");\n            goto log_and_return;\n        }\n    }\n\n    /* there is no admin limit exceeded in v2 - change to size limit XXX */\n    if (err == LDAP_ADMINLIMIT_EXCEEDED &&\n        conn->c_ldapversion < LDAP_VERSION3) {\n        err = LDAP_SIZELIMIT_EXCEEDED;\n    }\n\n    if (conn->c_ldapversion < LDAP_VERSION3 || urls == NULL) {\n        char *save, *buf = NULL;\n\n        /*\n         * if there are v2 referrals to send, construct\n         * the v2 referral string.\n         */\n        if (urls != NULL) {\n            int len;\n\n            /* count the referral */\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsReferrals);\n\n            /*\n             * figure out how much space we need\n             */\n            len = 10; /* strlen(\"Referral:\") + NULL */\n            for (i = 0; urls[i] != NULL; i++) {\n                len += urls[i]->bv_len + 1; /* newline + ref */\n            }\n            if (text != NULL) {\n                len += strlen(text) + 1; /* text + newline */\n            }\n            /*\n             * allocate buffer and fill it in with the error\n             * message plus v2-style referrals.\n             */\n            buf = slapi_ch_malloc(len);\n            *buf = '\\0';\n            if (text != NULL) {\n                strcpy(buf, text);\n                strcat(buf, \"\\n\");\n            }\n            strcat(buf, \"Referral:\");\n            for (i = 0; urls[i] != NULL; i++) {\n                strcat(buf, \"\\n\");\n                strcat(buf, urls[i]->bv_val);\n            }\n            save = text;\n            text = buf;\n        }\n\n        if ((conn->c_ldapversion < LDAP_VERSION3 &&\n             err == LDAP_REFERRAL) ||\n            urls != NULL) {\n            err = LDAP_PARTIAL_RESULTS;\n        }\n        rc = ber_printf(ber, \"{it{ess\", operation->o_msgid, tag, err,\n                        matched ? matched : \"\", pbtext ? pbtext : \"\");\n\n        /*\n         * if this is an LDAPv3 ExtendedResponse to an ExtendedRequest,\n         * check to see if the optional responseName and response OCTET\n         * STRING need to be appended.\n         */\n        if (rc != LBER_ERROR) {\n            rc = check_and_send_extended_result(pb, tag, ber);\n        }\n\n        /*\n         * if this is an LDAPv3 BindResponse, check to see if the\n         * optional serverSaslCreds OCTET STRING is present and needs\n         * to be appended.\n         */\n        if (rc != LBER_ERROR) {\n            rc = check_and_send_SASL_response(pb, tag, ber, conn);\n            /* XXXmcs: should we also check for a missing auth response control? */\n        }\n\n        if (rc != LBER_ERROR) {\n            rc = ber_printf(ber, \"}\"); /* one more } to come */\n        }\n\n        if (buf != NULL) {\n            text = save;\n            slapi_ch_free((void **)&buf);\n        }\n    } else {\n        /*\n         * there are v3 referrals to add to the result\n         */\n        /* count the referral */\n        if (!config_check_referral_mode())\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsReferrals);\n        rc = ber_printf(ber, \"{it{esst{s\", operation->o_msgid, tag, err,\n                        matched ? matched : \"\", text ? text : \"\", LDAP_TAG_REFERRAL,\n                        urls[0]->bv_val);\n        for (i = 1; urls[i] != NULL && rc != LBER_ERROR; i++) {\n            rc = ber_printf(ber, \"s\", urls[i]->bv_val);\n        }\n        if (rc != LBER_ERROR) {\n            rc = ber_printf(ber, \"}\"); /* two more } to come */\n        }\n\n        /*\n         * if this is an LDAPv3 ExtendedResponse to an ExtendedRequest,\n         * check to see if the optional responseName and response OCTET\n         * STRING need to be appended.\n         */\n        if (rc != LBER_ERROR) {\n            rc = check_and_send_extended_result(pb, tag, ber);\n        }\n\n        /*\n         * if this is an LDAPv3 BindResponse, check to see if the\n         * optional serverSaslCreds OCTET STRING is present and needs\n         * to be appended.\n         */\n        if (rc != LBER_ERROR) {\n            rc = check_and_send_SASL_response(pb, tag, ber, conn);\n        }\n\n        if (rc != LBER_ERROR) {\n            rc = ber_printf(ber, \"}\"); /* one more } to come */\n        }\n    }\n    if (err == LDAP_SUCCESS) {\n        /*\n         * Process the Read Entry Controls (if any)\n         */\n        if (process_read_entry_controls(pb, LDAP_CONTROL_PRE_READ_ENTRY)) {\n            err = LDAP_UNAVAILABLE_CRITICAL_EXTENSION;\n            goto log_and_return;\n        }\n        if (process_read_entry_controls(pb, LDAP_CONTROL_POST_READ_ENTRY)) {\n            err = LDAP_UNAVAILABLE_CRITICAL_EXTENSION;\n            goto log_and_return;\n        }\n    }\n    if (operation->o_results.result_controls != NULL && conn->c_ldapversion >= LDAP_VERSION3 && write_controls(ber, operation->o_results.result_controls) != 0) {\n        rc = (int)LBER_ERROR;\n    }\n\n    if (rc != LBER_ERROR) { /* end the LDAPMessage sequence */\n        rc = ber_put_seq(ber);\n    }\n\n    if (rc == LBER_ERROR) {\n        slapi_log_err(SLAPI_LOG_ERR, \"send_ldap_result_ext\", \"ber_printf failed 1\\n\");\n        if (flush_ber_element == 1) {\n            /* we alloced the ber */\n            ber_free(ber, 1 /* freebuf */);\n        }\n        goto log_and_return;\n    }\n\n    if (flush_ber_element) {\n        /* write only one pdu at a time - wait til it's our turn */\n        if (flush_ber(pb, conn, operation, ber, _LDAP_SEND_RESULT) == 0) {\n            logit = 1;\n        }\n    }\n\nlog_and_return:\n    operation->o_status = SLAPI_OP_STATUS_RESULT_SENT; /* in case this has not yet been set */\n\n    if (logit && (operation_is_flag_set(operation, OP_FLAG_ACTION_LOG_ACCESS) ||\n                  (internal_op && config_get_plugin_logging()))) {\n        log_result(pb, operation, err, tag, nentries);\n    }\n\n    slapi_log_err(SLAPI_LOG_TRACE, \"send_ldap_result_ext\", \"<= %d\\n\", err);\n}",
        "func_after": "void\nsend_ldap_result_ext(\n    Slapi_PBlock *pb,\n    int err,\n    char *matched,\n    char *text,\n    int nentries,\n    struct berval **urls,\n    BerElement *ber)\n{\n    Slapi_Operation *operation;\n    passwdPolicy *pwpolicy = NULL;\n    Connection *conn = NULL;\n    Slapi_DN *sdn = NULL;\n    const char *dn = NULL;\n    ber_tag_t tag;\n    int flush_ber_element = 1;\n    ber_tag_t bind_method = 0;\n    int internal_op;\n    int i, rc, logit = 0;\n    char *pbtext;\n\n    slapi_pblock_get(pb, SLAPI_BIND_METHOD, &bind_method);\n    slapi_pblock_get(pb, SLAPI_OPERATION, &operation);\n    slapi_pblock_get(pb, SLAPI_CONNECTION, &conn);\n\n    if (text) {\n        pbtext = text;\n    } else {\n        slapi_pblock_get(pb, SLAPI_RESULT_TEXT, &pbtext);\n    }\n\n    if (operation == NULL) {\n        slapi_log_err(SLAPI_LOG_ERR, \"send_ldap_result_ext\", \"No operation found: slapi_search_internal_set_pb was incomplete (invalid 'base' ?)\\n\");\n        return;\n    }\n\n    if (operation->o_status == SLAPI_OP_STATUS_RESULT_SENT) {\n        return; /* result already sent */\n    }\n\n    if (ber != NULL) {\n        flush_ber_element = 0;\n    }\n\n    if (err != LDAP_SUCCESS) {\n        /* count the error for snmp */\n        /* first check for security errors */\n        if (err == LDAP_INVALID_CREDENTIALS || err == LDAP_INAPPROPRIATE_AUTH || err == LDAP_AUTH_METHOD_NOT_SUPPORTED || err == LDAP_STRONG_AUTH_NOT_SUPPORTED || err == LDAP_STRONG_AUTH_REQUIRED || err == LDAP_CONFIDENTIALITY_REQUIRED || err == LDAP_INSUFFICIENT_ACCESS || err == LDAP_AUTH_UNKNOWN) {\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsSecurityErrors);\n        } else if (err != LDAP_REFERRAL && err != LDAP_OPT_REFERRALS && err != LDAP_PARTIAL_RESULTS) {\n            /*madman man spec says not to count as normal errors\n                --security errors\n                --referrals\n                -- partially seviced operations will not be conted as an error\n                      */\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsErrors);\n        }\n    }\n\n    slapi_log_err(SLAPI_LOG_TRACE, \"send_ldap_result_ext\", \"=> %d:%s:%s\\n\", err,\n                  matched ? matched : \"\", text ? text : \"\");\n\n    switch (operation->o_tag) {\n    case LBER_DEFAULT:\n        tag = LBER_SEQUENCE;\n        break;\n\n    case LDAP_REQ_SEARCH:\n        tag = LDAP_RES_SEARCH_RESULT;\n        break;\n\n    case LDAP_REQ_DELETE:\n        tag = LDAP_RES_DELETE;\n        break;\n\n    case LDAP_REFERRAL:\n        if (conn && conn->c_ldapversion > LDAP_VERSION2) {\n            tag = LDAP_TAG_REFERRAL;\n            break;\n        }\n    /* FALLTHROUGH */\n\n    default:\n        tag = operation->o_tag + 1;\n        break;\n    }\n\n    internal_op = operation_is_flag_set(operation, OP_FLAG_INTERNAL);\n    if ((conn == NULL) || (internal_op)) {\n        if (operation->o_result_handler != NULL) {\n            operation->o_result_handler(conn, operation, err,\n                                        matched, text, nentries, urls);\n            logit = 1;\n        }\n        goto log_and_return;\n    }\n\n    /* invalid password.  Update the password retry here */\n    /* put this here for now.  It could be a send_result pre-op plugin. */\n    if ((err == LDAP_INVALID_CREDENTIALS) && (bind_method != LDAP_AUTH_SASL)) {\n        slapi_pblock_get(pb, SLAPI_TARGET_SDN, &sdn);\n        dn = slapi_sdn_get_dn(sdn);\n        pwpolicy = new_passwdPolicy(pb, dn);\n        if (pwpolicy && (pwpolicy->pw_lockout == 1)) {\n            if (update_pw_retry(pb) == LDAP_CONSTRAINT_VIOLATION && !pwpolicy->pw_is_legacy) {\n                /*\n                 * If we are not using the legacy pw policy behavior,\n                 * convert the error 49 to 19 (constraint violation)\n                 * and log a message\n                 */\n                err = LDAP_CONSTRAINT_VIOLATION;\n                text = \"Invalid credentials, you now have exceeded the password retry limit.\";\n            }\n        }\n    }\n\n    if (ber == NULL) {\n        if ((ber = der_alloc()) == NULL) {\n            slapi_log_err(SLAPI_LOG_ERR, \"send_ldap_result_ext\", \"ber_alloc failed\\n\");\n            goto log_and_return;\n        }\n    }\n\n    /* there is no admin limit exceeded in v2 - change to size limit XXX */\n    if (err == LDAP_ADMINLIMIT_EXCEEDED &&\n        conn->c_ldapversion < LDAP_VERSION3) {\n        err = LDAP_SIZELIMIT_EXCEEDED;\n    }\n\n    if (conn->c_ldapversion < LDAP_VERSION3 || urls == NULL) {\n        char *save, *buf = NULL;\n\n        /*\n         * if there are v2 referrals to send, construct\n         * the v2 referral string.\n         */\n        if (urls != NULL) {\n            int len;\n\n            /* count the referral */\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsReferrals);\n\n            /*\n             * figure out how much space we need\n             */\n            len = 10; /* strlen(\"Referral:\") + NULL */\n            for (i = 0; urls[i] != NULL; i++) {\n                len += urls[i]->bv_len + 1; /* newline + ref */\n            }\n            if (text != NULL) {\n                len += strlen(text) + 1; /* text + newline */\n            }\n            /*\n             * allocate buffer and fill it in with the error\n             * message plus v2-style referrals.\n             */\n            buf = slapi_ch_malloc(len);\n            *buf = '\\0';\n            if (text != NULL) {\n                strcpy(buf, text);\n                strcat(buf, \"\\n\");\n            }\n            strcat(buf, \"Referral:\");\n            for (i = 0; urls[i] != NULL; i++) {\n                strcat(buf, \"\\n\");\n                strcat(buf, urls[i]->bv_val);\n            }\n            save = text;\n            text = buf;\n        }\n\n        if ((conn->c_ldapversion < LDAP_VERSION3 &&\n             err == LDAP_REFERRAL) ||\n            urls != NULL) {\n            err = LDAP_PARTIAL_RESULTS;\n        }\n        rc = ber_printf(ber, \"{it{ess\", operation->o_msgid, tag, err,\n                        matched ? matched : \"\", pbtext ? pbtext : \"\");\n\n        /*\n         * if this is an LDAPv3 ExtendedResponse to an ExtendedRequest,\n         * check to see if the optional responseName and response OCTET\n         * STRING need to be appended.\n         */\n        if (rc != LBER_ERROR) {\n            rc = check_and_send_extended_result(pb, tag, ber);\n        }\n\n        /*\n         * if this is an LDAPv3 BindResponse, check to see if the\n         * optional serverSaslCreds OCTET STRING is present and needs\n         * to be appended.\n         */\n        if (rc != LBER_ERROR) {\n            rc = check_and_send_SASL_response(pb, tag, ber, conn);\n            /* XXXmcs: should we also check for a missing auth response control? */\n        }\n\n        if (rc != LBER_ERROR) {\n            rc = ber_printf(ber, \"}\"); /* one more } to come */\n        }\n\n        if (buf != NULL) {\n            text = save;\n            slapi_ch_free((void **)&buf);\n        }\n    } else {\n        /*\n         * there are v3 referrals to add to the result\n         */\n        /* count the referral */\n        if (!config_check_referral_mode())\n            slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsReferrals);\n        rc = ber_printf(ber, \"{it{esst{s\", operation->o_msgid, tag, err,\n                        matched ? matched : \"\", text ? text : \"\", LDAP_TAG_REFERRAL,\n                        urls[0]->bv_val);\n        for (i = 1; urls[i] != NULL && rc != LBER_ERROR; i++) {\n            rc = ber_printf(ber, \"s\", urls[i]->bv_val);\n        }\n        if (rc != LBER_ERROR) {\n            rc = ber_printf(ber, \"}\"); /* two more } to come */\n        }\n\n        /*\n         * if this is an LDAPv3 ExtendedResponse to an ExtendedRequest,\n         * check to see if the optional responseName and response OCTET\n         * STRING need to be appended.\n         */\n        if (rc != LBER_ERROR) {\n            rc = check_and_send_extended_result(pb, tag, ber);\n        }\n\n        /*\n         * if this is an LDAPv3 BindResponse, check to see if the\n         * optional serverSaslCreds OCTET STRING is present and needs\n         * to be appended.\n         */\n        if (rc != LBER_ERROR) {\n            rc = check_and_send_SASL_response(pb, tag, ber, conn);\n        }\n\n        if (rc != LBER_ERROR) {\n            rc = ber_printf(ber, \"}\"); /* one more } to come */\n        }\n    }\n    if (err == LDAP_SUCCESS) {\n        /*\n         * Process the Read Entry Controls (if any)\n         */\n        if (process_read_entry_controls(pb, LDAP_CONTROL_PRE_READ_ENTRY)) {\n            err = LDAP_UNAVAILABLE_CRITICAL_EXTENSION;\n            goto log_and_return;\n        }\n        if (process_read_entry_controls(pb, LDAP_CONTROL_POST_READ_ENTRY)) {\n            err = LDAP_UNAVAILABLE_CRITICAL_EXTENSION;\n            goto log_and_return;\n        }\n    }\n    if (operation->o_results.result_controls != NULL && conn->c_ldapversion >= LDAP_VERSION3 && write_controls(ber, operation->o_results.result_controls) != 0) {\n        rc = (int)LBER_ERROR;\n    }\n\n    if (rc != LBER_ERROR) { /* end the LDAPMessage sequence */\n        rc = ber_put_seq(ber);\n    }\n\n    if (rc == LBER_ERROR) {\n        slapi_log_err(SLAPI_LOG_ERR, \"send_ldap_result_ext\", \"ber_printf failed 1\\n\");\n        if (flush_ber_element == 1) {\n            /* we alloced the ber */\n            ber_free(ber, 1 /* freebuf */);\n        }\n        goto log_and_return;\n    }\n\n    if (flush_ber_element) {\n        /* write only one pdu at a time - wait til it's our turn */\n        if (flush_ber(pb, conn, operation, ber, _LDAP_SEND_RESULT) == 0) {\n            logit = 1;\n        }\n    }\n\nlog_and_return:\n    operation->o_status = SLAPI_OP_STATUS_RESULT_SENT; /* in case this has not yet been set */\n\n    if (logit && (operation_is_flag_set(operation, OP_FLAG_ACTION_LOG_ACCESS) ||\n                  (internal_op && config_get_plugin_logging()))) {\n        log_result(pb, operation, err, tag, nentries);\n    }\n\n    slapi_log_err(SLAPI_LOG_TRACE, \"send_ldap_result_ext\", \"<= %d\\n\", err);\n}",
        "description": "When performing authentication, the response from the 389-ds-base server varies depending on whether the distinguished name (DN) exists in the LDAP database. This difference can be exploited by an unauthenticated attacker to determine the existence of specific entries within the LDAP directory.",
        "commit": "**Abstracted and Generalized Description:**\n\nAn issue was identified where, during an LDAP bind operation, the system inadvertently disclosed whether a target entry existed or not by reporting 'No such entry' when the bind entry did not exist. This behavior violates the principle of not providing any information about the existence of the target entry. The fix involves modifying the system to avoid returning any additional information during the bind process, thereby enhancing the security by preventing potential enumeration attacks."
    },
    {
        "cwe": "CWE-119",
        "func_name": "torvalds/hugetlb_mcopy_atomic_pte",
        "score": 0.7027592658996582,
        "func_before": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tstruct address_space *mapping = dst_vma->vm_file->f_mapping;\n\t\tpgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
        "func_after": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\tunsigned long size;\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\tmapping = dst_vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\t\tret = -EFAULT;\n\t\tif (idx >= size)\n\t\t\tgoto out_release_nounlock;\n\n\t\t/*\n\t\t * Serialization between remove_inode_hugepages() and\n\t\t * huge_add_to_page_cache() below happens through the\n\t\t * hugetlb_fault_mutex_table that here must be hold by\n\t\t * the caller.\n\t\t */\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\t/*\n\t * Recheck the i_size after holding PT lock to make sure not\n\t * to leave any page mapped (as page_mapped()) beyond the end\n\t * of the i_size (remove_inode_hugepages() is strict about\n\t * enforcing that). If we bail out here, we'll also leave a\n\t * page in the radix tree in the vm_shared case beyond the end\n\t * of the i_size, but remove_inode_hugepages() will take care\n\t * of it as soon as we drop the hugetlb_fault_mutex_table.\n\t */\n\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\tret = -EFAULT;\n\tif (idx >= size)\n\t\tgoto out_release_unlock;\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
        "description": "A flaw was identified in the hugetlb_mcopy_atomic_pte function within the Linux kernel's memory management module, affecting versions prior to 4.13.12. The absence of a proper size check in this function could lead to a denial of service condition, indicated by a BUG.",
        "commit": "A vulnerability was identified in the userfaultfd functionality related to hugetlbfs, where the UFFDIO_COPY operation could inadvertently extend beyond the intended size of the file (i_size). This issue led to a kernel panic (oops) at fs/hugetlbfs/inode.c:484, triggered by the absence of an i_size check in the hugetlb_mcopy_atomic_pte function. Although mmap() operations could succeed beyond the end of the i_size after vmtruncate had removed virtual memory areas (vmas) in those ranges, subsequent faults, including UFFDIO_COPY, should not be allowed to succeed. The proposed solution involves modifying the return value to userland to indicate a SIGBUS-like condition, similar to what a page fault would produce, but this approach was deemed less useful due to the difficulty in distinguishing between SIGSEGV and SIGBUS through meaningful syscall return values."
    },
    {
        "cwe": "CWE-444",
        "func_name": "varnishcache/h2_vfp_body",
        "score": 0.6717072129249573,
        "func_before": "static enum vfp_status v_matchproto_(vfp_pull_f)\nh2_vfp_body(struct vfp_ctx *vc, struct vfp_entry *vfe, void *ptr, ssize_t *lp)\n{\n\tstruct h2_req *r2;\n\tstruct h2_sess *h2;\n\tunsigned l;\n\tenum vfp_status retval = VFP_OK;\n\n\tCHECK_OBJ_NOTNULL(vc, VFP_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(vfe, VFP_ENTRY_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, vfe->priv1, H2_REQ_MAGIC);\n\th2 = r2->h2sess;\n\n\tAN(ptr);\n\tAN(lp);\n\tl = *lp;\n\t*lp = 0;\n\n\tLck_Lock(&h2->sess->mtx);\n\tassert (r2->state == H2_S_OPEN);\n\tr2->cond = &vc->wrk->cond;\n\twhile (h2->mailcall != r2 && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(r2->cond, &h2->sess->mtx, 0));\n\tr2->cond = NULL;\n\tif (h2->error || r2->error) {\n\t\tretval = VFP_ERROR;\n\t} else {\n\t\tassert(h2->mailcall == r2);\n\t\tif (l > h2->rxf_len)\n\t\t\tl = h2->rxf_len;\n\t\tif (l > 0) {\n\t\t\tmemcpy(ptr, h2->rxf_data, l);\n\t\t\th2->rxf_data += l;\n\t\t\th2->rxf_len -= l;\n\t\t}\n\t\t*lp = l;\n\t\tif (h2->rxf_len > 0) {\n\t\t\t/* We ran out of storage: Have VFP call us\n\t\t\t * again with a fresh buffer */\n\t\t\tLck_Unlock(&h2->sess->mtx);\n\t\t\treturn (VFP_OK);\n\t\t}\n\t\tif (h2->rxf_len == 0) {\n\t\t\tif (h2->rxf_flags & H2FF_DATA_END_STREAM) {\n\t\t\t\tretval = VFP_END;\n\t\t\t\tr2->state = H2_S_CLOS_REM;\n\t\t\t}\n\t\t}\n\t\th2->mailcall = NULL;\n\t\tAZ(pthread_cond_signal(h2->cond));\n\t}\n\tLck_Unlock(&h2->sess->mtx);\n\treturn (retval);\n}",
        "func_after": "static enum vfp_status v_matchproto_(vfp_pull_f)\nh2_vfp_body(struct vfp_ctx *vc, struct vfp_entry *vfe, void *ptr, ssize_t *lp)\n{\n\tstruct h2_req *r2;\n\tstruct h2_sess *h2;\n\tunsigned l;\n\tenum vfp_status retval;\n\n\tCHECK_OBJ_NOTNULL(vc, VFP_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(vfe, VFP_ENTRY_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, vfe->priv1, H2_REQ_MAGIC);\n\th2 = r2->h2sess;\n\n\tAN(ptr);\n\tAN(lp);\n\tl = *lp;\n\t*lp = 0;\n\n\tLck_Lock(&h2->sess->mtx);\n\tr2->cond = &vc->wrk->cond;\n\twhile (h2->mailcall != r2 && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(r2->cond, &h2->sess->mtx, 0));\n\tr2->cond = NULL;\n\tif (h2->error || r2->error) {\n\t\tretval = VFP_ERROR;\n\t} else {\n\t\tassert(h2->mailcall == r2);\n\t\tif (l > h2->rxf_len)\n\t\t\tl = h2->rxf_len;\n\t\tif (l > 0) {\n\t\t\tmemcpy(ptr, h2->rxf_data, l);\n\t\t\th2->rxf_data += l;\n\t\t\th2->rxf_len -= l;\n\t\t}\n\t\t*lp = l;\n\t\tif (h2->rxf_len > 0) {\n\t\t\t/* We ran out of storage: Have VFP call us\n\t\t\t * again with a fresh buffer */\n\t\t\tLck_Unlock(&h2->sess->mtx);\n\t\t\treturn (VFP_OK);\n\t\t}\n\t\tif (h2->rxf_len == 0 && r2->state >= H2_S_CLOS_REM)\n\t\t\tretval = VFP_END;\n\t\telse\n\t\t\tretval = VFP_OK;\n\t\th2->mailcall = NULL;\n\t\tAZ(pthread_cond_signal(h2->cond));\n\t}\n\tLck_Unlock(&h2->sess->mtx);\n\treturn (retval);\n}",
        "description": "Varnish Cache, when HTTP/2 is enabled, is susceptible to request smuggling and VCL authorization bypass through the use of an excessively large Content-Length header in a POST request. This vulnerability impacts various versions of Varnish Enterprise and Varnish Cache, including specific releases prior to certain patch levels.",
        "commit": "When processing HTTP/2 (H/2) request bodies, ensure that the total size of received data frames aligns with the advertised content length. If the cumulative size of the data frames does not match the specified content length, the system should appropriately fail the request."
    },
    {
        "cwe": "CWE-385",
        "func_name": "openssl/ecdsa_sign_setup",
        "score": 0.6972721219062805,
        "func_before": "static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,\n\t\t\t\t\tBIGNUM **kinvp, BIGNUM **rp,\n\t\t\t\t\tconst unsigned char *dgst, int dlen)\n{\n\tBN_CTX   *ctx = NULL;\n\tBIGNUM\t *k = NULL, *r = NULL, *order = NULL, *X = NULL;\n\tEC_POINT *tmp_point=NULL;\n\tconst EC_GROUP *group;\n\tint \t ret = 0;\n\n\tif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\n\tif (ctx_in == NULL) \n\t{\n\t\tif ((ctx = BN_CTX_new()) == NULL)\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t\tctx = ctx_in;\n\n\tk     = BN_new();\t/* this value is later returned in *kinvp */\n\tr     = BN_new();\t/* this value is later returned in *rp    */\n\torder = BN_new();\n\tX     = BN_new();\n\tif (!k || !r || !order || !X)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t}\n\tif ((tmp_point = EC_POINT_new(group)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\tif (!EC_GROUP_get_order(group, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\n#ifdef OPENSSL_FIPS\n\tif (!fips_check_ec_prng(eckey))\n\t\tgoto err;\n#endif\n\t\n\tdo\n\t{\n\t\t/* get random k */\t\n\t\tdo\n#ifndef OPENSSL_NO_SHA512\n\t\t\tif (dgst != NULL)\n\t\t\t{\n\t\t\t\tif (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),\n\t\t\t\t\t\t\t   dgst, dlen, ctx))\n\t\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tif (!BN_rand_range(k, order))\n\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\twhile (BN_is_zero(k));\n\n\t\t/* We do not want timing information to leak the length of k,\n\t\t * so we compute G*k using an equivalent scalar of fixed\n\t\t * bit-length. */\n\n\t\tif (!BN_add(k, k, order)) goto err;\n\t\tif (BN_num_bits(k) <= BN_num_bits(order))\n\t\t\tif (!BN_add(k, k, order)) goto err;\n\n\t\t/* compute r the x-coordinate of generator * k */\n\t\tif (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t}\n\t\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#ifndef OPENSSL_NO_EC2M\n\t\telse /* NID_X9_62_characteristic_two_field */\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GF2m(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!BN_nnmod(r, X, order, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t}\n\t}\n\twhile (BN_is_zero(r));\n\n\t/* compute the inverse of k */\n\tif (!BN_mod_inverse(k, k, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\tgoto err;\t\n\t}\n\t/* clear old values if necessary */\n\tif (*rp != NULL)\n\t\tBN_clear_free(*rp);\n\tif (*kinvp != NULL) \n\t\tBN_clear_free(*kinvp);\n\t/* save the pre-computed values  */\n\t*rp    = r;\n\t*kinvp = k;\n\tret = 1;\nerr:\n\tif (!ret)\n\t{\n\t\tif (k != NULL) BN_clear_free(k);\n\t\tif (r != NULL) BN_clear_free(r);\n\t}\n\tif (ctx_in == NULL) \n\t\tBN_CTX_free(ctx);\n\tif (order != NULL)\n\t\tBN_free(order);\n\tif (tmp_point != NULL) \n\t\tEC_POINT_free(tmp_point);\n\tif (X)\n\t\tBN_clear_free(X);\n\treturn(ret);\n}",
        "func_after": "static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,\n\t\t\t\t\tBIGNUM **kinvp, BIGNUM **rp,\n\t\t\t\t\tconst unsigned char *dgst, int dlen)\n{\n\tBN_CTX   *ctx = NULL;\n\tBIGNUM\t *k = NULL, *r = NULL, *order = NULL, *X = NULL;\n\tEC_POINT *tmp_point=NULL;\n\tconst EC_GROUP *group;\n\tint \t ret = 0;\n\n\tif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\n\tif (ctx_in == NULL) \n\t{\n\t\tif ((ctx = BN_CTX_new()) == NULL)\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t\tctx = ctx_in;\n\n\tk     = BN_new();\t/* this value is later returned in *kinvp */\n\tr     = BN_new();\t/* this value is later returned in *rp    */\n\torder = BN_new();\n\tX     = BN_new();\n\tif (!k || !r || !order || !X)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t}\n\tif ((tmp_point = EC_POINT_new(group)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\tif (!EC_GROUP_get_order(group, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\n#ifdef OPENSSL_FIPS\n\tif (!fips_check_ec_prng(eckey))\n\t\tgoto err;\n#endif\n\t\n\tdo\n\t{\n\t\t/* get random k */\t\n\t\tdo\n#ifndef OPENSSL_NO_SHA512\n\t\t\tif (dgst != NULL)\n\t\t\t{\n\t\t\t\tif (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),\n\t\t\t\t\t\t\t   dgst, dlen, ctx))\n\t\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tif (!BN_rand_range(k, order))\n\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\twhile (BN_is_zero(k));\n\n\t\t/* We do not want timing information to leak the length of k,\n\t\t * so we compute G*k using an equivalent scalar of fixed\n\t\t * bit-length. */\n\n\t\tif (!BN_add(k, k, order)) goto err;\n\t\tif (BN_num_bits(k) <= BN_num_bits(order))\n\t\t\tif (!BN_add(k, k, order)) goto err;\n\n\t\t/* compute r the x-coordinate of generator * k */\n\t\tif (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t}\n\t\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#ifndef OPENSSL_NO_EC2M\n\t\telse /* NID_X9_62_characteristic_two_field */\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GF2m(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!BN_nnmod(r, X, order, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t}\n\t}\n\twhile (BN_is_zero(r));\n\n\t/* compute the inverse of k */\n\tif (EC_GROUP_get_mont_data(group) != NULL)\n\t\t{\n\t\t/* We want inverse in constant time, therefore we utilize the\n\t\t * fact order must be prime and use Fermats Little Theorem\n\t\t * instead. */\n\t\tif (!BN_set_word(X, 2) )\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (!BN_mod_sub(X, order, X, order, ctx))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tBN_set_flags(X, BN_FLG_CONSTTIME);\n\t\tif (!BN_mod_exp_mont_consttime(k, k, X, order, ctx, EC_GROUP_get_mont_data(group)))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tif (!BN_mod_inverse(k, k, order, ctx))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\t\n\t\t\t}\n\t\t}\n\n\t/* clear old values if necessary */\n\tif (*rp != NULL)\n\t\tBN_clear_free(*rp);\n\tif (*kinvp != NULL) \n\t\tBN_clear_free(*kinvp);\n\t/* save the pre-computed values  */\n\t*rp    = r;\n\t*kinvp = k;\n\tret = 1;\nerr:\n\tif (!ret)\n\t{\n\t\tif (k != NULL) BN_clear_free(k);\n\t\tif (r != NULL) BN_clear_free(r);\n\t}\n\tif (ctx_in == NULL) \n\t\tBN_CTX_free(ctx);\n\tif (order != NULL)\n\t\tBN_free(order);\n\tif (tmp_point != NULL) \n\t\tEC_POINT_free(tmp_point);\n\tif (X)\n\t\tBN_clear_free(X);\n\treturn(ret);\n}",
        "description": "A timing attack vulnerability was identified in OpenSSL versions prior to 1.0.1u, enabling a malicious user with local access to potentially recover ECDSA P-256 private keys through the exploitation of timing variations in cryptographic operations.",
        "commit": "The vulnerability knowledge has been abstracted and generalized as follows:\n\n\"The implementation of ECDSA includes an option to utilize BN_mod_exp_mont_consttime, a constant-time modular exponentiation function. This enhancement aims to improve the security of ECDSA operations.\""
    },
    {
        "cwe": "CWE-611",
        "func_name": "UIKit0/plist_from_xml",
        "score": 0.6406440138816833,
        "func_before": "PLIST_API void plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)\n{\n    xmlDocPtr plist_doc = xmlParseMemory(plist_xml, length);\n    xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n\n    xml_to_node(root_node, plist);\n    xmlFreeDoc(plist_doc);\n}",
        "func_after": "PLIST_API void plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)\n{\n    /* CVE-2013-0339: disable external entity loading to prevent XXE vulnerability */\n    xmlSetExternalEntityLoader(plist_xml_external_entity_loader);\n\n    /* read XML from memory and disable network access for security reasons */\n    xmlDocPtr plist_doc = xmlReadMemory(plist_xml, length, \"plist_from_xml:memory\", NULL, XML_PARSE_NONET);\n    if (plist_doc) {\n        xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n\n        xml_to_node(root_node, plist);\n        xmlFreeDoc(plist_doc);\n    }\n}",
        "description": "A vulnerability has been identified in the UIKit0 libplist library version 1.12, affecting the plist_from_xml function within the XML Handler component. This issue involves improper handling of XML external entity references, which could lead to potential security risks. To address this, a patch with the identifier c086cb139af7c82845f6d565e636073ff4b37440 has been developed. It is advised to apply this patch to mitigate the vulnerability.",
        "commit": "A security vulnerability related to XML property lists (plists) has been identified, where an attacker could potentially exploit a limited but possible XML External Entity (XXE) flaw. This vulnerability arises from the use of a specially crafted XML file that leverages a custom Document Type Definition (DTD) with an external entity reference. Such a file, when processed by the plistutil tool, could facilitate unauthorized GET requests to arbitrary URLs or disclose local files. Although practical exploitation is constrained, the issue has been addressed to enhance security. This vulnerability is analogous to CVE-2013-0339 observed in libxml2 and aligns with CWE-827. The vulnerability was reported by Lo\u00efc B\u00e9nis from calypt.com."
    }
]