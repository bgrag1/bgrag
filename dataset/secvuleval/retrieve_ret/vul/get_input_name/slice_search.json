[
    {
        "cwe": "CWE-94",
        "func_name": "binutils-gdb/setup_group",
        "score": 0.7621619701385498,
        "func_before": "static bfd_boolean\nsetup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)\n{\n  unsigned int num_group = elf_tdata (abfd)->num_group;\n\n  /* If num_group is zero, read in all SHT_GROUP sections.  The count\n     is set to -1 if there are no SHT_GROUP sections.  */\n  if (num_group == 0)\n    {\n      unsigned int i, shnum;\n\n      /* First count the number of groups.  If we have a SHT_GROUP\n\t section with just a flag word (ie. sh_size is 4), ignore it.  */\n      shnum = elf_numsections (abfd);\n      num_group = 0;\n\n#define IS_VALID_GROUP_SECTION_HEADER(shdr, minsize)\t\\\n\t(   (shdr)->sh_type == SHT_GROUP\t\t\\\n\t && (shdr)->sh_size >= minsize\t\t\t\\\n\t && (shdr)->sh_entsize == GRP_ENTRY_SIZE\t\\\n\t && ((shdr)->sh_size % GRP_ENTRY_SIZE) == 0)\n\n      for (i = 0; i < shnum; i++)\n\t{\n\t  Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];\n\n\t  if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))\n\t    num_group += 1;\n\t}\n\n      if (num_group == 0)\n\t{\n\t  num_group = (unsigned) -1;\n\t  elf_tdata (abfd)->num_group = num_group;\n\t}\n      else\n\t{\n\t  /* We keep a list of elf section headers for group sections,\n\t     so we can find them quickly.  */\n\t  bfd_size_type amt;\n\n\t  elf_tdata (abfd)->num_group = num_group;\n\t  elf_tdata (abfd)->group_sect_ptr = (Elf_Internal_Shdr **)\n              bfd_alloc2 (abfd, num_group, sizeof (Elf_Internal_Shdr *));\n\t  if (elf_tdata (abfd)->group_sect_ptr == NULL)\n\t    return FALSE;\n\n\t  num_group = 0;\n\t  for (i = 0; i < shnum; i++)\n\t    {\n\t      Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];\n\n\t      if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))\n\t\t{\n\t\t  unsigned char *src;\n\t\t  Elf_Internal_Group *dest;\n\n\t\t  /* Add to list of sections.  */\n\t\t  elf_tdata (abfd)->group_sect_ptr[num_group] = shdr;\n\t\t  num_group += 1;\n\n\t\t  /* Read the raw contents.  */\n\t\t  BFD_ASSERT (sizeof (*dest) >= 4);\n\t\t  amt = shdr->sh_size * sizeof (*dest) / 4;\n\t\t  shdr->contents = (unsigned char *)\n                      bfd_alloc2 (abfd, shdr->sh_size, sizeof (*dest) / 4);\n\t\t  /* PR binutils/4110: Handle corrupt group headers.  */\n\t\t  if (shdr->contents == NULL)\n\t\t    {\n\t\t      _bfd_error_handler\n\t\t\t(_(\"%B: Corrupt size field in group section header: 0x%lx\"), abfd, shdr->sh_size);\n\t\t      bfd_set_error (bfd_error_bad_value);\n\t\t      return FALSE;\n\t\t    }\n\n\t\t  memset (shdr->contents, 0, amt);\n\n\t\t  if (bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0\n\t\t      || (bfd_bread (shdr->contents, shdr->sh_size, abfd)\n\t\t\t  != shdr->sh_size))\n\t\t    return FALSE;\n\n\t\t  /* Translate raw contents, a flag word followed by an\n\t\t     array of elf section indices all in target byte order,\n\t\t     to the flag word followed by an array of elf section\n\t\t     pointers.  */\n\t\t  src = shdr->contents + shdr->sh_size;\n\t\t  dest = (Elf_Internal_Group *) (shdr->contents + amt);\n\t\t  while (1)\n\t\t    {\n\t\t      unsigned int idx;\n\n\t\t      src -= 4;\n\t\t      --dest;\n\t\t      idx = H_GET_32 (abfd, src);\n\t\t      if (src == shdr->contents)\n\t\t\t{\n\t\t\t  dest->flags = idx;\n\t\t\t  if (shdr->bfd_section != NULL && (idx & GRP_COMDAT))\n\t\t\t    shdr->bfd_section->flags\n\t\t\t      |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;\n\t\t\t  break;\n\t\t\t}\n\t\t      if (idx >= shnum)\n\t\t\t{\n\t\t\t  ((*_bfd_error_handler)\n\t\t\t   (_(\"%B: invalid SHT_GROUP entry\"), abfd));\n\t\t\t  idx = 0;\n\t\t\t}\n\t\t      dest->shdr = elf_elfsections (abfd)[idx];\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n  if (num_group != (unsigned) -1)\n    {\n      unsigned int i;\n\n      for (i = 0; i < num_group; i++)\n\t{\n\t  Elf_Internal_Shdr *shdr = elf_tdata (abfd)->group_sect_ptr[i];\n\t  Elf_Internal_Group *idx = (Elf_Internal_Group *) shdr->contents;\n\t  unsigned int n_elt = shdr->sh_size / 4;\n\n\t  /* Look through this group's sections to see if current\n\t     section is a member.  */\n\t  while (--n_elt != 0)\n\t    if ((++idx)->shdr == hdr)\n\t      {\n\t\tasection *s = NULL;\n\n\t\t/* We are a member of this group.  Go looking through\n\t\t   other members to see if any others are linked via\n\t\t   next_in_group.  */\n\t\tidx = (Elf_Internal_Group *) shdr->contents;\n\t\tn_elt = shdr->sh_size / 4;\n\t\twhile (--n_elt != 0)\n\t\t  if ((s = (++idx)->shdr->bfd_section) != NULL\n\t\t      && elf_next_in_group (s) != NULL)\n\t\t    break;\n\t\tif (n_elt != 0)\n\t\t  {\n\t\t    /* Snarf the group name from other member, and\n\t\t       insert current section in circular list.  */\n\t\t    elf_group_name (newsect) = elf_group_name (s);\n\t\t    elf_next_in_group (newsect) = elf_next_in_group (s);\n\t\t    elf_next_in_group (s) = newsect;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    const char *gname;\n\n\t\t    gname = group_signature (abfd, shdr);\n\t\t    if (gname == NULL)\n\t\t      return FALSE;\n\t\t    elf_group_name (newsect) = gname;\n\n\t\t    /* Start a circular list with one element.  */\n\t\t    elf_next_in_group (newsect) = newsect;\n\t\t  }\n\n\t\t/* If the group section has been created, point to the\n\t\t   new member.  */\n\t\tif (shdr->bfd_section != NULL)\n\t\t  elf_next_in_group (shdr->bfd_section) = newsect;\n\n\t\ti = num_group - 1;\n\t\tbreak;\n\t      }\n\t}\n    }\n\n  if (elf_group_name (newsect) == NULL)\n    {\n      (*_bfd_error_handler) (_(\"%B: no group info for section %A\"),\n\t\t\t     abfd, newsect);\n    }\n  return TRUE;\n}",
        "func_after": "static bfd_boolean\nsetup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)\n{\n  unsigned int num_group = elf_tdata (abfd)->num_group;\n\n  /* If num_group is zero, read in all SHT_GROUP sections.  The count\n     is set to -1 if there are no SHT_GROUP sections.  */\n  if (num_group == 0)\n    {\n      unsigned int i, shnum;\n\n      /* First count the number of groups.  If we have a SHT_GROUP\n\t section with just a flag word (ie. sh_size is 4), ignore it.  */\n      shnum = elf_numsections (abfd);\n      num_group = 0;\n\n#define IS_VALID_GROUP_SECTION_HEADER(shdr, minsize)\t\\\n\t(   (shdr)->sh_type == SHT_GROUP\t\t\\\n\t && (shdr)->sh_size >= minsize\t\t\t\\\n\t && (shdr)->sh_entsize == GRP_ENTRY_SIZE\t\\\n\t && ((shdr)->sh_size % GRP_ENTRY_SIZE) == 0)\n\n      for (i = 0; i < shnum; i++)\n\t{\n\t  Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];\n\n\t  if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))\n\t    num_group += 1;\n\t}\n\n      if (num_group == 0)\n\t{\n\t  num_group = (unsigned) -1;\n\t  elf_tdata (abfd)->num_group = num_group;\n\t}\n      else\n\t{\n\t  /* We keep a list of elf section headers for group sections,\n\t     so we can find them quickly.  */\n\t  bfd_size_type amt;\n\n\t  elf_tdata (abfd)->num_group = num_group;\n\t  elf_tdata (abfd)->group_sect_ptr = (Elf_Internal_Shdr **)\n              bfd_alloc2 (abfd, num_group, sizeof (Elf_Internal_Shdr *));\n\t  if (elf_tdata (abfd)->group_sect_ptr == NULL)\n\t    return FALSE;\n\n\t  num_group = 0;\n\t  for (i = 0; i < shnum; i++)\n\t    {\n\t      Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];\n\n\t      if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))\n\t\t{\n\t\t  unsigned char *src;\n\t\t  Elf_Internal_Group *dest;\n\n\t\t  /* Add to list of sections.  */\n\t\t  elf_tdata (abfd)->group_sect_ptr[num_group] = shdr;\n\t\t  num_group += 1;\n\n\t\t  /* Read the raw contents.  */\n\t\t  BFD_ASSERT (sizeof (*dest) >= 4);\n\t\t  amt = shdr->sh_size * sizeof (*dest) / 4;\n\t\t  shdr->contents = (unsigned char *)\n                      bfd_alloc2 (abfd, shdr->sh_size, sizeof (*dest) / 4);\n\t\t  /* PR binutils/4110: Handle corrupt group headers.  */\n\t\t  if (shdr->contents == NULL)\n\t\t    {\n\t\t      _bfd_error_handler\n\t\t\t(_(\"%B: corrupt size field in group section header: 0x%lx\"), abfd, shdr->sh_size);\n\t\t      bfd_set_error (bfd_error_bad_value);\n\t\t      -- num_group;\n\t\t      continue;\n\t\t    }\n\n\t\t  memset (shdr->contents, 0, amt);\n\n\t\t  if (bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0\n\t\t      || (bfd_bread (shdr->contents, shdr->sh_size, abfd)\n\t\t\t  != shdr->sh_size))\n\t\t    {\n\t\t      _bfd_error_handler\n\t\t\t(_(\"%B: invalid size field in group section header: 0x%lx\"), abfd, shdr->sh_size);\n\t\t      bfd_set_error (bfd_error_bad_value);\n\t\t      -- num_group;\n\t\t      /* PR 17510: If the group contents are even partially\n\t\t\t corrupt, do not allow any of the contents to be used.  */\n\t\t      memset (shdr->contents, 0, amt);\n\t\t      continue;\n\t\t    }\n\t\t  \n\t\t  /* Translate raw contents, a flag word followed by an\n\t\t     array of elf section indices all in target byte order,\n\t\t     to the flag word followed by an array of elf section\n\t\t     pointers.  */\n\t\t  src = shdr->contents + shdr->sh_size;\n\t\t  dest = (Elf_Internal_Group *) (shdr->contents + amt);\n\t\t  while (1)\n\t\t    {\n\t\t      unsigned int idx;\n\n\t\t      src -= 4;\n\t\t      --dest;\n\t\t      idx = H_GET_32 (abfd, src);\n\t\t      if (src == shdr->contents)\n\t\t\t{\n\t\t\t  dest->flags = idx;\n\t\t\t  if (shdr->bfd_section != NULL && (idx & GRP_COMDAT))\n\t\t\t    shdr->bfd_section->flags\n\t\t\t      |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;\n\t\t\t  break;\n\t\t\t}\n\t\t      if (idx >= shnum)\n\t\t\t{\n\t\t\t  ((*_bfd_error_handler)\n\t\t\t   (_(\"%B: invalid SHT_GROUP entry\"), abfd));\n\t\t\t  idx = 0;\n\t\t\t}\n\t\t      dest->shdr = elf_elfsections (abfd)[idx];\n\t\t    }\n\t\t}\n\t    }\n\n\t  /* PR 17510: Corrupt binaries might contain invalid groups.  */\n\t  if (num_group != (unsigned) elf_tdata (abfd)->num_group)\n\t    {\n\t      elf_tdata (abfd)->num_group = num_group;\n\n\t      /* If all groups are invalid then fail.  */\n\t      if (num_group == 0)\n\t\t{\n\t\t  elf_tdata (abfd)->group_sect_ptr = NULL;\n\t\t  elf_tdata (abfd)->num_group = num_group = -1;\n\t\t  (*_bfd_error_handler) (_(\"%B: no valid group sections found\"), abfd);\n\t\t  bfd_set_error (bfd_error_bad_value);\n\t\t}\n\t    }\n\t}\n    }\n\n  if (num_group != (unsigned) -1)\n    {\n      unsigned int i;\n\n      for (i = 0; i < num_group; i++)\n\t{\n\t  Elf_Internal_Shdr *shdr = elf_tdata (abfd)->group_sect_ptr[i];\n\t  Elf_Internal_Group *idx = (Elf_Internal_Group *) shdr->contents;\n\t  unsigned int n_elt = shdr->sh_size / 4;\n\n\t  /* Look through this group's sections to see if current\n\t     section is a member.  */\n\t  while (--n_elt != 0)\n\t    if ((++idx)->shdr == hdr)\n\t      {\n\t\tasection *s = NULL;\n\n\t\t/* We are a member of this group.  Go looking through\n\t\t   other members to see if any others are linked via\n\t\t   next_in_group.  */\n\t\tidx = (Elf_Internal_Group *) shdr->contents;\n\t\tn_elt = shdr->sh_size / 4;\n\t\twhile (--n_elt != 0)\n\t\t  if ((s = (++idx)->shdr->bfd_section) != NULL\n\t\t      && elf_next_in_group (s) != NULL)\n\t\t    break;\n\t\tif (n_elt != 0)\n\t\t  {\n\t\t    /* Snarf the group name from other member, and\n\t\t       insert current section in circular list.  */\n\t\t    elf_group_name (newsect) = elf_group_name (s);\n\t\t    elf_next_in_group (newsect) = elf_next_in_group (s);\n\t\t    elf_next_in_group (s) = newsect;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    const char *gname;\n\n\t\t    gname = group_signature (abfd, shdr);\n\t\t    if (gname == NULL)\n\t\t      return FALSE;\n\t\t    elf_group_name (newsect) = gname;\n\n\t\t    /* Start a circular list with one element.  */\n\t\t    elf_next_in_group (newsect) = newsect;\n\t\t  }\n\n\t\t/* If the group section has been created, point to the\n\t\t   new member.  */\n\t\tif (shdr->bfd_section != NULL)\n\t\t  elf_next_in_group (shdr->bfd_section) = newsect;\n\n\t\ti = num_group - 1;\n\t\tbreak;\n\t      }\n\t}\n    }\n\n  if (elf_group_name (newsect) == NULL)\n    {\n      (*_bfd_error_handler) (_(\"%B: no group info for section %A\"),\n\t\t\t     abfd, newsect);\n      return FALSE;\n    }\n  return TRUE;\n}",
        "description": "The `setup_group` function in the `bfd/elf.c` file of the GNU binutils library, versions 2.24 and earlier, is vulnerable to a denial of service (crash) and potential arbitrary code execution by remote attackers. This vulnerability arises from the handling of crafted section group headers in an ELF file.",
        "commit": "This patch addresses a potential security vulnerability in applications that utilize the bfd library to parse binaries. Specifically, it enhances the handling of corrupt section group headers, which could be exploited by maliciously crafted binaries to cause issues such as buffer overflows or other security breaches."
    },
    {
        "cwe": "CWE-74",
        "func_name": "flatpak/flatpak_run_add_environment_args",
        "score": 0.7682708501815796,
        "func_before": "gboolean\nflatpak_run_add_environment_args (FlatpakBwrap    *bwrap,\n                                  const char      *app_info_path,\n                                  FlatpakRunFlags  flags,\n                                  const char      *app_id,\n                                  FlatpakContext  *context,\n                                  GFile           *app_id_dir,\n                                  GPtrArray       *previous_app_id_dirs,\n                                  FlatpakExports **exports_out,\n                                  GCancellable    *cancellable,\n                                  GError         **error)\n{\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autoptr(FlatpakBwrap) proxy_arg_bwrap = flatpak_bwrap_new (flatpak_bwrap_empty_env);\n  gboolean has_wayland = FALSE;\n  gboolean allow_x11 = FALSE;\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_IPC) == 0)\n    {\n      g_debug (\"Disallowing ipc access\");\n      flatpak_bwrap_add_args (bwrap, \"--unshare-ipc\", NULL);\n    }\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) == 0)\n    {\n      g_debug (\"Disallowing network access\");\n      flatpak_bwrap_add_args (bwrap, \"--unshare-net\", NULL);\n    }\n\n  if (context->devices & FLATPAK_CONTEXT_DEVICE_ALL)\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dev-bind\", \"/dev\", \"/dev\",\n                              NULL);\n      /* Don't expose the host /dev/shm, just the device nodes, unless explicitly allowed */\n      if (g_file_test (\"/dev/shm\", G_FILE_TEST_IS_DIR))\n        {\n          if ((context->devices & FLATPAK_CONTEXT_DEVICE_SHM) == 0)\n            flatpak_bwrap_add_args (bwrap,\n                                    \"--tmpfs\", \"/dev/shm\",\n                                    NULL);\n        }\n      else if (g_file_test (\"/dev/shm\", G_FILE_TEST_IS_SYMLINK))\n        {\n          g_autofree char *link = flatpak_readlink (\"/dev/shm\", NULL);\n\n          /* On debian (with sysv init) the host /dev/shm is a symlink to /run/shm, so we can't\n             mount on top of it. */\n          if (g_strcmp0 (link, \"/run/shm\") == 0)\n            {\n              if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM &&\n                  g_file_test (\"/run/shm\", G_FILE_TEST_IS_DIR))\n                flatpak_bwrap_add_args (bwrap,\n                                        \"--bind\", \"/run/shm\", \"/run/shm\",\n                                        NULL);\n              else\n                flatpak_bwrap_add_args (bwrap,\n                                        \"--dir\", \"/run/shm\",\n                                        NULL);\n            }\n          else\n            g_warning (\"Unexpected /dev/shm symlink %s\", link);\n        }\n    }\n  else\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dev\", \"/dev\",\n                              NULL);\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_DRI)\n        {\n          g_debug (\"Allowing dri access\");\n          int i;\n          char *dri_devices[] = {\n            \"/dev/dri\",\n            /* mali */\n            \"/dev/mali\",\n            \"/dev/mali0\",\n            \"/dev/umplock\",\n            /* nvidia */\n            \"/dev/nvidiactl\",\n            \"/dev/nvidia-modeset\",\n            /* nvidia OpenCL/CUDA */\n            \"/dev/nvidia-uvm\",\n            \"/dev/nvidia-uvm-tools\",\n          };\n\n          for (i = 0; i < G_N_ELEMENTS (dri_devices); i++)\n            {\n              if (g_file_test (dri_devices[i], G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \"--dev-bind\", dri_devices[i], dri_devices[i], NULL);\n            }\n\n          /* Each Nvidia card gets its own device.\n             This is a fairly arbitrary limit but ASUS sells mining boards supporting 20 in theory. */\n          char nvidia_dev[14]; /* /dev/nvidia plus up to 2 digits */\n          for (i = 0; i < 20; i++)\n            {\n              g_snprintf (nvidia_dev, sizeof (nvidia_dev), \"/dev/nvidia%d\", i);\n              if (g_file_test (nvidia_dev, G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \"--dev-bind\", nvidia_dev, nvidia_dev, NULL);\n            }\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_KVM)\n        {\n          g_debug (\"Allowing kvm access\");\n          if (g_file_test (\"/dev/kvm\", G_FILE_TEST_EXISTS))\n            flatpak_bwrap_add_args (bwrap, \"--dev-bind\", \"/dev/kvm\", \"/dev/kvm\", NULL);\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM)\n        {\n          /* This is a symlink to /run/shm on debian, so bind to real target */\n          g_autofree char *real_dev_shm = realpath (\"/dev/shm\", NULL);\n\n          g_debug (\"Allowing /dev/shm access (as %s)\", real_dev_shm);\n          if (real_dev_shm != NULL)\n              flatpak_bwrap_add_args (bwrap, \"--bind\", real_dev_shm, \"/dev/shm\", NULL);\n        }\n    }\n\n  flatpak_context_append_bwrap_filesystem (context, bwrap, app_id, app_id_dir, previous_app_id_dirs, &exports);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_WAYLAND)\n    {\n      g_debug (\"Allowing wayland access\");\n      has_wayland = flatpak_run_add_wayland_args (bwrap);\n    }\n\n  if ((context->sockets & FLATPAK_CONTEXT_SOCKET_FALLBACK_X11) != 0)\n    allow_x11 = !has_wayland;\n  else\n    allow_x11 = (context->sockets & FLATPAK_CONTEXT_SOCKET_X11) != 0;\n\n  flatpak_run_add_x11_args (bwrap, allow_x11);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_SSH_AUTH)\n    {\n      flatpak_run_add_ssh_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PULSEAUDIO)\n    {\n      g_debug (\"Allowing pulseaudio access\");\n      flatpak_run_add_pulseaudio_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PCSC)\n    {\n      flatpak_run_add_pcsc_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_CUPS)\n    {\n      flatpak_run_add_cups_args (bwrap);\n    }\n\n  flatpak_run_add_session_dbus_args (bwrap, proxy_arg_bwrap, context, flags, app_id);\n  flatpak_run_add_system_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n  flatpak_run_add_a11y_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n\n  if (g_environ_getenv (bwrap->envp, \"LD_LIBRARY_PATH\") != NULL)\n    {\n      /* LD_LIBRARY_PATH is overridden for setuid helper, so pass it as cmdline arg */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--setenv\", \"LD_LIBRARY_PATH\", g_environ_getenv (bwrap->envp, \"LD_LIBRARY_PATH\"),\n                              NULL);\n      flatpak_bwrap_unset_env (bwrap, \"LD_LIBRARY_PATH\");\n    }\n\n  if (g_environ_getenv (bwrap->envp, \"TMPDIR\") != NULL)\n    {\n      /* TMPDIR is overridden for setuid helper, so pass it as cmdline arg */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--setenv\", \"TMPDIR\", g_environ_getenv (bwrap->envp, \"TMPDIR\"),\n                              NULL);\n      flatpak_bwrap_unset_env (bwrap, \"TMPDIR\");\n    }\n\n  /* Must run this before spawning the dbus proxy, to ensure it\n     ends up in the app cgroup */\n  if (!flatpak_run_in_transient_unit (app_id, &my_error))\n    {\n      /* We still run along even if we don't get a cgroup, as nothing\n         really depends on it. Its just nice to have */\n      g_debug (\"Failed to run in transient scope: %s\", my_error->message);\n      g_clear_error (&my_error);\n    }\n\n  if (!flatpak_bwrap_is_empty (proxy_arg_bwrap) &&\n      !start_dbus_proxy (bwrap, proxy_arg_bwrap, app_info_path, error))\n    return FALSE;\n\n  if (exports_out)\n    *exports_out = g_steal_pointer (&exports);\n\n  return TRUE;\n}",
        "func_after": "gboolean\nflatpak_run_add_environment_args (FlatpakBwrap    *bwrap,\n                                  const char      *app_info_path,\n                                  FlatpakRunFlags  flags,\n                                  const char      *app_id,\n                                  FlatpakContext  *context,\n                                  GFile           *app_id_dir,\n                                  GPtrArray       *previous_app_id_dirs,\n                                  FlatpakExports **exports_out,\n                                  GCancellable    *cancellable,\n                                  GError         **error)\n{\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autoptr(FlatpakBwrap) proxy_arg_bwrap = flatpak_bwrap_new (flatpak_bwrap_empty_env);\n  gboolean has_wayland = FALSE;\n  gboolean allow_x11 = FALSE;\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_IPC) == 0)\n    {\n      g_debug (\"Disallowing ipc access\");\n      flatpak_bwrap_add_args (bwrap, \"--unshare-ipc\", NULL);\n    }\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) == 0)\n    {\n      g_debug (\"Disallowing network access\");\n      flatpak_bwrap_add_args (bwrap, \"--unshare-net\", NULL);\n    }\n\n  if (context->devices & FLATPAK_CONTEXT_DEVICE_ALL)\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dev-bind\", \"/dev\", \"/dev\",\n                              NULL);\n      /* Don't expose the host /dev/shm, just the device nodes, unless explicitly allowed */\n      if (g_file_test (\"/dev/shm\", G_FILE_TEST_IS_DIR))\n        {\n          if ((context->devices & FLATPAK_CONTEXT_DEVICE_SHM) == 0)\n            flatpak_bwrap_add_args (bwrap,\n                                    \"--tmpfs\", \"/dev/shm\",\n                                    NULL);\n        }\n      else if (g_file_test (\"/dev/shm\", G_FILE_TEST_IS_SYMLINK))\n        {\n          g_autofree char *link = flatpak_readlink (\"/dev/shm\", NULL);\n\n          /* On debian (with sysv init) the host /dev/shm is a symlink to /run/shm, so we can't\n             mount on top of it. */\n          if (g_strcmp0 (link, \"/run/shm\") == 0)\n            {\n              if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM &&\n                  g_file_test (\"/run/shm\", G_FILE_TEST_IS_DIR))\n                flatpak_bwrap_add_args (bwrap,\n                                        \"--bind\", \"/run/shm\", \"/run/shm\",\n                                        NULL);\n              else\n                flatpak_bwrap_add_args (bwrap,\n                                        \"--dir\", \"/run/shm\",\n                                        NULL);\n            }\n          else\n            g_warning (\"Unexpected /dev/shm symlink %s\", link);\n        }\n    }\n  else\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dev\", \"/dev\",\n                              NULL);\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_DRI)\n        {\n          g_debug (\"Allowing dri access\");\n          int i;\n          char *dri_devices[] = {\n            \"/dev/dri\",\n            /* mali */\n            \"/dev/mali\",\n            \"/dev/mali0\",\n            \"/dev/umplock\",\n            /* nvidia */\n            \"/dev/nvidiactl\",\n            \"/dev/nvidia-modeset\",\n            /* nvidia OpenCL/CUDA */\n            \"/dev/nvidia-uvm\",\n            \"/dev/nvidia-uvm-tools\",\n          };\n\n          for (i = 0; i < G_N_ELEMENTS (dri_devices); i++)\n            {\n              if (g_file_test (dri_devices[i], G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \"--dev-bind\", dri_devices[i], dri_devices[i], NULL);\n            }\n\n          /* Each Nvidia card gets its own device.\n             This is a fairly arbitrary limit but ASUS sells mining boards supporting 20 in theory. */\n          char nvidia_dev[14]; /* /dev/nvidia plus up to 2 digits */\n          for (i = 0; i < 20; i++)\n            {\n              g_snprintf (nvidia_dev, sizeof (nvidia_dev), \"/dev/nvidia%d\", i);\n              if (g_file_test (nvidia_dev, G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \"--dev-bind\", nvidia_dev, nvidia_dev, NULL);\n            }\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_KVM)\n        {\n          g_debug (\"Allowing kvm access\");\n          if (g_file_test (\"/dev/kvm\", G_FILE_TEST_EXISTS))\n            flatpak_bwrap_add_args (bwrap, \"--dev-bind\", \"/dev/kvm\", \"/dev/kvm\", NULL);\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM)\n        {\n          /* This is a symlink to /run/shm on debian, so bind to real target */\n          g_autofree char *real_dev_shm = realpath (\"/dev/shm\", NULL);\n\n          g_debug (\"Allowing /dev/shm access (as %s)\", real_dev_shm);\n          if (real_dev_shm != NULL)\n              flatpak_bwrap_add_args (bwrap, \"--bind\", real_dev_shm, \"/dev/shm\", NULL);\n        }\n    }\n\n  flatpak_context_append_bwrap_filesystem (context, bwrap, app_id, app_id_dir, previous_app_id_dirs, &exports);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_WAYLAND)\n    {\n      g_debug (\"Allowing wayland access\");\n      has_wayland = flatpak_run_add_wayland_args (bwrap);\n    }\n\n  if ((context->sockets & FLATPAK_CONTEXT_SOCKET_FALLBACK_X11) != 0)\n    allow_x11 = !has_wayland;\n  else\n    allow_x11 = (context->sockets & FLATPAK_CONTEXT_SOCKET_X11) != 0;\n\n  flatpak_run_add_x11_args (bwrap, allow_x11);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_SSH_AUTH)\n    {\n      flatpak_run_add_ssh_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PULSEAUDIO)\n    {\n      g_debug (\"Allowing pulseaudio access\");\n      flatpak_run_add_pulseaudio_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PCSC)\n    {\n      flatpak_run_add_pcsc_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_CUPS)\n    {\n      flatpak_run_add_cups_args (bwrap);\n    }\n\n  flatpak_run_add_session_dbus_args (bwrap, proxy_arg_bwrap, context, flags, app_id);\n  flatpak_run_add_system_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n  flatpak_run_add_a11y_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n\n  /* Must run this before spawning the dbus proxy, to ensure it\n     ends up in the app cgroup */\n  if (!flatpak_run_in_transient_unit (app_id, &my_error))\n    {\n      /* We still run along even if we don't get a cgroup, as nothing\n         really depends on it. Its just nice to have */\n      g_debug (\"Failed to run in transient scope: %s\", my_error->message);\n      g_clear_error (&my_error);\n    }\n\n  if (!flatpak_bwrap_is_empty (proxy_arg_bwrap) &&\n      !start_dbus_proxy (bwrap, proxy_arg_bwrap, app_info_path, error))\n    return FALSE;\n\n  if (exports_out)\n    *exports_out = g_steal_pointer (&exports);\n\n  return TRUE;\n}",
        "description": "A vulnerability was identified in the Flatpak portal service (`flatpak-portal`), allowing sandboxed applications to execute arbitrary code on the host system, effectively enabling a sandbox escape. This issue affects versions of Flatpak from 0.11.4 up to but not including fixed versions 1.8.5 and 1.10.0. The Flatpak portal service facilitates launching subprocesses within new sandbox instances, either with the same or more restrictive security settings compared to the calling application. Vulnerable versions pass caller-specified environment variables to non-sandboxed processes on the host system, particularly to the `flatpak run` command used for launching new sandbox instances. Malicious or compromised applications could exploit this by setting environment variables trusted by the `flatpak run` command, thereby executing arbitrary code outside the sandbox. As a temporary workaround, disabling the `flatpak-portal` service mitigates the vulnerability but may prevent many Flatpak applications from functioning correctly. This issue has been resolved in versions 1.8.5 and 1.10.0.",
        "commit": "The vulnerability involves converting all environment variables into arguments for `bwrap`, a tool used to create isolated execution environments. This conversion helps prevent certain environment variables from being filtered out by a setuid `bwrap`. Additionally, it ensures that even if these variables come from an untrusted source, they cannot be used to inject arbitrary code into a non-setuid `bwrap` through mechanisms like `LD_PRELOAD`. By bundling these variables into a `memfd` or temporary file, they are not included in `argv`, making them inaccessible to processes running under a different user ID. This measure is crucial for protecting sensitive information such as tokens or other secrets."
    },
    {
        "cwe": "CWE-440",
        "func_name": "eclipse-openj9/Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex",
        "score": 0.752165675163269,
        "func_before": "JNIEXPORT jint JNICALL Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *env, jclass InterfaceMethodHandle, jlong interfaceArg, jint itableIndex, jlong receiverClassArg)\n   {\n   J9Class  *interfaceClass = (J9Class*)(intptr_t)interfaceArg;\n   J9Class  *receiverClass  = (J9Class*)(intptr_t)receiverClassArg;\n   J9ITable *itableEntry;\n   for (itableEntry = (J9ITable*)receiverClass->iTable; itableEntry; itableEntry = itableEntry->next)\n      if (itableEntry->interfaceClass == interfaceClass)\n         break;\n   TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *itableArray = (UDATA*)(itableEntry+1);\n   return (itableArray[itableIndex] - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } indexAndLiterals =\n      {\n      (UDATA)interfaceClass,\n      (UDATA)itableIndex\n      };\n   J9Object *receiver = (J9Object*)receiverArg;\n   return (jint)jitLookupInterfaceMethod(receiver->clazz, &indexAndLiterals, 0);\n#endif\n   }",
        "func_after": "JNIEXPORT jint JNICALL Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *env, jclass InterfaceMethodHandle, jlong interfaceArg, jint itableIndex, jlong receiverClassArg)\n   {\n   J9Class  *interfaceClass = (J9Class*)(intptr_t)interfaceArg;\n   J9Class  *receiverClass  = (J9Class*)(intptr_t)receiverClassArg;\n   J9ITable *itableEntry;\n   for (itableEntry = (J9ITable*)receiverClass->iTable; itableEntry; itableEntry = itableEntry->next)\n      if (itableEntry->interfaceClass == interfaceClass)\n         break;\n   TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *itableArray = (UDATA*)(itableEntry+1);\n   UDATA vTableOffset = itableArray[itableIndex];\n   J9Method *method = *(J9Method**)((UDATA)receiverClass + vTableOffset);\n   if ((J9_ROM_METHOD_FROM_RAM_METHOD(method)->modifiers & J9AccPublic) == 0)\n      return -1;\n\n   return (vTableOffset - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } indexAndLiterals =\n      {\n      (UDATA)interfaceClass,\n      (UDATA)itableIndex\n      };\n   J9Object *receiver = (J9Object*)receiverArg;\n   return (jint)jitLookupInterfaceMethod(receiver->clazz, &indexAndLiterals, 0);\n#endif\n   }",
        "description": "In versions of Eclipse Openj9 prior to 0.29.0, the Java Virtual Machine (JVM) fails to throw an IllegalAccessError when MethodHandles are used to invoke methods that are not accessible through interfaces.",
        "commit": "The vulnerability involves a situation where an `IllegalAccessError` (IAE) is not being thrown appropriately when an `InterfaceHandle` encounters a non-public method during dispatch. The expected behavior is for the dispatch mechanism implemented by `InterfaceHandle` to mimic that of `invokeinterface`, which throws an `IAE` when attempting to access non-public methods. This discrepancy allows unauthorized access to non-public methods, potentially leading to security vulnerabilities."
    },
    {
        "cwe": "CWE-552",
        "func_name": "util-linux/is_fuse_usermount",
        "score": 0.7647510170936584,
        "func_before": "static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)\n{\n\tstruct libmnt_ns *ns_old;\n\tconst char *type = mnt_fs_get_fstype(cxt->fs);\n\tconst char *optstr;\n\tchar *user_id = NULL;\n\tsize_t sz;\n\tuid_t uid;\n\tchar uidstr[sizeof(stringify_value(ULONG_MAX))];\n\n\t*errsv = 0;\n\n\tif (!type)\n\t\treturn 0;\n\n\tif (strcmp(type, \"fuse\") != 0 &&\n\t    strcmp(type, \"fuseblk\") != 0 &&\n\t    strncmp(type, \"fuse.\", 5) != 0 &&\n\t    strncmp(type, \"fuseblk.\", 8) != 0)\n\t\treturn 0;\n\n\t/* get user_id= from mount table */\n\toptstr = mnt_fs_get_fs_options(cxt->fs);\n\tif (!optstr)\n\t\treturn 0;\n\n\tif (mnt_optstr_get_option(optstr, \"user_id\", &user_id, &sz) != 0)\n\t\treturn 0;\n\n\tif (sz == 0 || user_id == NULL)\n\t\treturn 0;\n\n\t/* get current user */\n\tns_old = mnt_context_switch_origin_ns(cxt);\n\tif (!ns_old) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\n\tuid = getuid();\n\n\tif (!mnt_context_switch_ns(cxt, ns_old)) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\n\tsnprintf(uidstr, sizeof(uidstr), \"%lu\", (unsigned long) uid);\n\treturn strncmp(user_id, uidstr, sz) == 0;\n}",
        "func_after": "static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)\n{\n\tstruct libmnt_ns *ns_old;\n\tconst char *type = mnt_fs_get_fstype(cxt->fs);\n\tconst char *optstr;\n\tuid_t uid, entry_uid;\n\n\t*errsv = 0;\n\n\tif (!type)\n\t\treturn 0;\n\n\tif (strcmp(type, \"fuse\") != 0 &&\n\t    strcmp(type, \"fuseblk\") != 0 &&\n\t    strncmp(type, \"fuse.\", 5) != 0 &&\n\t    strncmp(type, \"fuseblk.\", 8) != 0)\n\t\treturn 0;\n\n\t/* get user_id= from mount table */\n\toptstr = mnt_fs_get_fs_options(cxt->fs);\n\tif (!optstr)\n\t\treturn 0;\n\tif (mnt_optstr_get_uid(optstr, \"user_id\", &entry_uid) != 0)\n\t\treturn 0;\n\n\t/* get current user */\n\tns_old = mnt_context_switch_origin_ns(cxt);\n\tif (!ns_old) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\n\tuid = getuid();\n\n\tif (!mnt_context_switch_ns(cxt, ns_old)) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\n\treturn uid == entry_uid;\n}",
        "description": "A logic error was identified in the libmount library of util-linux, affecting the function responsible for allowing unprivileged users to unmount FUSE filesystems. This flaw enables an unprivileged local attacker to unmount FUSE filesystems owned by other users whose UIDs share a common prefix with the attacker's UID in string form. Exploitation of this vulnerability could lead to a denial of service for applications relying on the affected filesystems.",
        "commit": "An improper user ID (UID) check in the libmount library allows an unprivileged user to unmount FUSE filesystems owned by users with similar UIDs."
    }
]