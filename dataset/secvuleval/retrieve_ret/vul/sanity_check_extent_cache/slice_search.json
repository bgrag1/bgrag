[
    {
        "cwe": "CWE-787",
        "func_name": "OP-TEE/syscall_obj_generate_key",
        "score": 0.7744824290275574,
        "func_before": "TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that maxKeySize follows restrictions */\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tparams = malloc(sizeof(TEE_Attribute) * param_count);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * We have to do it like this because the parity bits aren't\n\t\t * counted when telling the size of the key in bits.\n\t\t */\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}",
        "func_after": "TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that maxKeySize follows restrictions */\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * We have to do it like this because the parity bits aren't\n\t\t * counted when telling the size of the key in bits.\n\t\t */\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}",
        "description": "Linaro/OP-TEE versions 3.3.0 and earlier are vulnerable to a buffer overflow, which could lead to the execution of arbitrary code within the Trusted Execution Environment (TEE) core (kernel) context. This issue affects the optee_os component. The vulnerability has been addressed in versions 3.4.0 and later.",
        "commit": "It was discovered that there is a risk of heap-based overflow due to insufficient checking for allocation overflow in cryptographic function calls. Without verifying the allocation size, there is a possibility of allocating a buffer that is smaller than expected, which could result in attacker-controlled data being written beyond the buffer's boundaries."
    },
    {
        "cwe": "CWE-125",
        "func_name": "the-tcpdump-group/nfsreq_print_noaddr",
        "score": 0.7709197402000427,
        "func_before": "void\nnfsreq_print_noaddr(netdissect_options *ndo,\n                    register const u_char *bp, u_int length,\n                    register const u_char *bp2)\n{\n\tregister const struct sunrpc_msg *rp;\n\tregister const uint32_t *dp;\n\tnfs_type type;\n\tint v3;\n\tuint32_t proc;\n\tuint32_t access_flags;\n\tstruct nfsv3_sattr sa3;\n\n\tND_PRINT((ndo, \"%d\", length));\n\tnfserr = 0;\t\t/* assume no error */\n\trp = (const struct sunrpc_msg *)bp;\n\n\tif (!xid_map_enter(ndo, rp, bp2))\t/* record proc number for later on */\n\t\tgoto trunc;\n\n\tv3 = (EXTRACT_32BITS(&rp->rm_call.cb_vers) == NFS_VER3);\n\tproc = EXTRACT_32BITS(&rp->rm_call.cb_proc);\n\n\tif (!v3 && proc < NFS_NPROCS)\n\t\tproc =  nfsv3_procid[proc];\n\n\tND_PRINT((ndo, \" %s\", tok2str(nfsproc_str, \"proc-%u\", proc)));\n\tswitch (proc) {\n\n\tcase NFSPROC_GETATTR:\n\tcase NFSPROC_SETATTR:\n\tcase NFSPROC_READLINK:\n\tcase NFSPROC_FSSTAT:\n\tcase NFSPROC_FSINFO:\n\tcase NFSPROC_PATHCONF:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    parsefh(ndo, dp, v3) != NULL)\n\t\t\treturn;\n\t\tbreak;\n\n\tcase NFSPROC_LOOKUP:\n\tcase NFSPROC_CREATE:\n\tcase NFSPROC_MKDIR:\n\tcase NFSPROC_REMOVE:\n\tcase NFSPROC_RMDIR:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    parsefhn(ndo, dp, v3) != NULL)\n\t\t\treturn;\n\t\tbreak;\n\n\tcase NFSPROC_ACCESS:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    (dp = parsefh(ndo, dp, v3)) != NULL) {\n\t\t\tND_TCHECK(dp[0]);\n\t\t\taccess_flags = EXTRACT_32BITS(&dp[0]);\n\t\t\tif (access_flags & ~NFSV3ACCESS_FULL) {\n\t\t\t\t/* NFSV3ACCESS definitions aren't up to date */\n\t\t\t\tND_PRINT((ndo, \" %04x\", access_flags));\n\t\t\t} else if ((access_flags & NFSV3ACCESS_FULL) == NFSV3ACCESS_FULL) {\n\t\t\t\tND_PRINT((ndo, \" NFS_ACCESS_FULL\"));\n\t\t\t} else {\n\t\t\t\tchar separator = ' ';\n\t\t\t\tif (access_flags & NFSV3ACCESS_READ) {\n\t\t\t\t\tND_PRINT((ndo, \" NFS_ACCESS_READ\"));\n\t\t\t\t\tseparator = '|';\n\t\t\t\t}\n\t\t\t\tif (access_flags & NFSV3ACCESS_LOOKUP) {\n\t\t\t\t\tND_PRINT((ndo, \"%cNFS_ACCESS_LOOKUP\", separator));\n\t\t\t\t\tseparator = '|';\n\t\t\t\t}\n\t\t\t\tif (access_flags & NFSV3ACCESS_MODIFY) {\n\t\t\t\t\tND_PRINT((ndo, \"%cNFS_ACCESS_MODIFY\", separator));\n\t\t\t\t\tseparator = '|';\n\t\t\t\t}\n\t\t\t\tif (access_flags & NFSV3ACCESS_EXTEND) {\n\t\t\t\t\tND_PRINT((ndo, \"%cNFS_ACCESS_EXTEND\", separator));\n\t\t\t\t\tseparator = '|';\n\t\t\t\t}\n\t\t\t\tif (access_flags & NFSV3ACCESS_DELETE) {\n\t\t\t\t\tND_PRINT((ndo, \"%cNFS_ACCESS_DELETE\", separator));\n\t\t\t\t\tseparator = '|';\n\t\t\t\t}\n\t\t\t\tif (access_flags & NFSV3ACCESS_EXECUTE)\n\t\t\t\t\tND_PRINT((ndo, \"%cNFS_ACCESS_EXECUTE\", separator));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_READ:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    (dp = parsefh(ndo, dp, v3)) != NULL) {\n\t\t\tif (v3) {\n\t\t\t\tND_TCHECK(dp[2]);\n\t\t\t\tND_PRINT((ndo, \" %u bytes @ %\" PRIu64,\n\t\t\t\t       EXTRACT_32BITS(&dp[2]),\n\t\t\t\t       EXTRACT_64BITS(&dp[0])));\n\t\t\t} else {\n\t\t\t\tND_TCHECK(dp[1]);\n\t\t\t\tND_PRINT((ndo, \" %u bytes @ %u\",\n\t\t\t\t    EXTRACT_32BITS(&dp[1]),\n\t\t\t\t    EXTRACT_32BITS(&dp[0])));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_WRITE:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    (dp = parsefh(ndo, dp, v3)) != NULL) {\n\t\t\tif (v3) {\n\t\t\t\tND_TCHECK(dp[2]);\n\t\t\t\tND_PRINT((ndo, \" %u (%u) bytes @ %\" PRIu64,\n\t\t\t\t\t\tEXTRACT_32BITS(&dp[4]),\n\t\t\t\t\t\tEXTRACT_32BITS(&dp[2]),\n\t\t\t\t\t\tEXTRACT_64BITS(&dp[0])));\n\t\t\t\tif (ndo->ndo_vflag) {\n\t\t\t\t\tdp += 3;\n\t\t\t\t\tND_TCHECK(dp[0]);\n\t\t\t\t\tND_PRINT((ndo, \" <%s>\",\n\t\t\t\t\t\ttok2str(nfsv3_writemodes,\n\t\t\t\t\t\t\tNULL, EXTRACT_32BITS(dp))));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tND_TCHECK(dp[3]);\n\t\t\t\tND_PRINT((ndo, \" %u (%u) bytes @ %u (%u)\",\n\t\t\t\t\t\tEXTRACT_32BITS(&dp[3]),\n\t\t\t\t\t\tEXTRACT_32BITS(&dp[2]),\n\t\t\t\t\t\tEXTRACT_32BITS(&dp[1]),\n\t\t\t\t\t\tEXTRACT_32BITS(&dp[0])));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_SYMLINK:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    (dp = parsefhn(ndo, dp, v3)) != NULL) {\n\t\t\tND_PRINT((ndo, \" ->\"));\n\t\t\tif (v3 && (dp = parse_sattr3(ndo, dp, &sa3)) == NULL)\n\t\t\t\tbreak;\n\t\t\tif (parsefn(ndo, dp) == NULL)\n\t\t\t\tbreak;\n\t\t\tif (v3 && ndo->ndo_vflag)\n\t\t\t\tprint_sattr3(ndo, &sa3, ndo->ndo_vflag);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_MKNOD:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    (dp = parsefhn(ndo, dp, v3)) != NULL) {\n\t\t\tND_TCHECK(*dp);\n\t\t\ttype = (nfs_type)EXTRACT_32BITS(dp);\n\t\t\tdp++;\n\t\t\tif ((dp = parse_sattr3(ndo, dp, &sa3)) == NULL)\n\t\t\t\tbreak;\n\t\t\tND_PRINT((ndo, \" %s\", tok2str(type2str, \"unk-ft %d\", type)));\n\t\t\tif (ndo->ndo_vflag && (type == NFCHR || type == NFBLK)) {\n\t\t\t\tND_TCHECK(dp[1]);\n\t\t\t\tND_PRINT((ndo, \" %u/%u\",\n\t\t\t\t       EXTRACT_32BITS(&dp[0]),\n\t\t\t\t       EXTRACT_32BITS(&dp[1])));\n\t\t\t\tdp += 2;\n\t\t\t}\n\t\t\tif (ndo->ndo_vflag)\n\t\t\t\tprint_sattr3(ndo, &sa3, ndo->ndo_vflag);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_RENAME:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    (dp = parsefhn(ndo, dp, v3)) != NULL) {\n\t\t\tND_PRINT((ndo, \" ->\"));\n\t\t\tif (parsefhn(ndo, dp, v3) != NULL)\n\t\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_LINK:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    (dp = parsefh(ndo, dp, v3)) != NULL) {\n\t\t\tND_PRINT((ndo, \" ->\"));\n\t\t\tif (parsefhn(ndo, dp, v3) != NULL)\n\t\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_READDIR:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    (dp = parsefh(ndo, dp, v3)) != NULL) {\n\t\t\tif (v3) {\n\t\t\t\tND_TCHECK(dp[4]);\n\t\t\t\t/*\n\t\t\t\t * We shouldn't really try to interpret the\n\t\t\t\t * offset cookie here.\n\t\t\t\t */\n\t\t\t\tND_PRINT((ndo, \" %u bytes @ %\" PRId64,\n\t\t\t\t    EXTRACT_32BITS(&dp[4]),\n\t\t\t\t    EXTRACT_64BITS(&dp[0])));\n\t\t\t\tif (ndo->ndo_vflag)\n\t\t\t\t\tND_PRINT((ndo, \" verf %08x%08x\", dp[2], dp[3]));\n\t\t\t} else {\n\t\t\t\tND_TCHECK(dp[1]);\n\t\t\t\t/*\n\t\t\t\t * Print the offset as signed, since -1 is\n\t\t\t\t * common, but offsets > 2^31 aren't.\n\t\t\t\t */\n\t\t\t\tND_PRINT((ndo, \" %u bytes @ %d\",\n\t\t\t\t    EXTRACT_32BITS(&dp[1]),\n\t\t\t\t    EXTRACT_32BITS(&dp[0])));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_READDIRPLUS:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    (dp = parsefh(ndo, dp, v3)) != NULL) {\n\t\t\tND_TCHECK(dp[4]);\n\t\t\t/*\n\t\t\t * We don't try to interpret the offset\n\t\t\t * cookie here.\n\t\t\t */\n\t\t\tND_PRINT((ndo, \" %u bytes @ %\" PRId64,\n\t\t\t\tEXTRACT_32BITS(&dp[4]),\n\t\t\t\tEXTRACT_64BITS(&dp[0])));\n\t\t\tif (ndo->ndo_vflag) {\n\t\t\t\tND_TCHECK(dp[5]);\n\t\t\t\tND_PRINT((ndo, \" max %u verf %08x%08x\",\n\t\t\t\t       EXTRACT_32BITS(&dp[5]), dp[2], dp[3]));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_COMMIT:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    (dp = parsefh(ndo, dp, v3)) != NULL) {\n\t\t\tND_TCHECK(dp[2]);\n\t\t\tND_PRINT((ndo, \" %u bytes @ %\" PRIu64,\n\t\t\t\tEXTRACT_32BITS(&dp[2]),\n\t\t\t\tEXTRACT_64BITS(&dp[0])));\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\ntrunc:\n\tif (!nfserr)\n\t\tND_PRINT((ndo, \"%s\", tstr));\n}",
        "func_after": "void\nnfsreq_print_noaddr(netdissect_options *ndo,\n                    register const u_char *bp, u_int length,\n                    register const u_char *bp2)\n{\n\tregister const struct sunrpc_msg *rp;\n\tregister const uint32_t *dp;\n\tnfs_type type;\n\tint v3;\n\tuint32_t proc;\n\tuint32_t access_flags;\n\tstruct nfsv3_sattr sa3;\n\n\tND_PRINT((ndo, \"%d\", length));\n\tnfserr = 0;\t\t/* assume no error */\n\trp = (const struct sunrpc_msg *)bp;\n\n\tif (!xid_map_enter(ndo, rp, bp2))\t/* record proc number for later on */\n\t\tgoto trunc;\n\n\tv3 = (EXTRACT_32BITS(&rp->rm_call.cb_vers) == NFS_VER3);\n\tproc = EXTRACT_32BITS(&rp->rm_call.cb_proc);\n\n\tif (!v3 && proc < NFS_NPROCS)\n\t\tproc =  nfsv3_procid[proc];\n\n\tND_PRINT((ndo, \" %s\", tok2str(nfsproc_str, \"proc-%u\", proc)));\n\tswitch (proc) {\n\n\tcase NFSPROC_GETATTR:\n\tcase NFSPROC_SETATTR:\n\tcase NFSPROC_READLINK:\n\tcase NFSPROC_FSSTAT:\n\tcase NFSPROC_FSINFO:\n\tcase NFSPROC_PATHCONF:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    parsefh(ndo, dp, v3) != NULL)\n\t\t\treturn;\n\t\tbreak;\n\n\tcase NFSPROC_LOOKUP:\n\tcase NFSPROC_CREATE:\n\tcase NFSPROC_MKDIR:\n\tcase NFSPROC_REMOVE:\n\tcase NFSPROC_RMDIR:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    parsefhn(ndo, dp, v3) != NULL)\n\t\t\treturn;\n\t\tbreak;\n\n\tcase NFSPROC_ACCESS:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    (dp = parsefh(ndo, dp, v3)) != NULL) {\n\t\t\tND_TCHECK(dp[0]);\n\t\t\taccess_flags = EXTRACT_32BITS(&dp[0]);\n\t\t\tif (access_flags & ~NFSV3ACCESS_FULL) {\n\t\t\t\t/* NFSV3ACCESS definitions aren't up to date */\n\t\t\t\tND_PRINT((ndo, \" %04x\", access_flags));\n\t\t\t} else if ((access_flags & NFSV3ACCESS_FULL) == NFSV3ACCESS_FULL) {\n\t\t\t\tND_PRINT((ndo, \" NFS_ACCESS_FULL\"));\n\t\t\t} else {\n\t\t\t\tchar separator = ' ';\n\t\t\t\tif (access_flags & NFSV3ACCESS_READ) {\n\t\t\t\t\tND_PRINT((ndo, \" NFS_ACCESS_READ\"));\n\t\t\t\t\tseparator = '|';\n\t\t\t\t}\n\t\t\t\tif (access_flags & NFSV3ACCESS_LOOKUP) {\n\t\t\t\t\tND_PRINT((ndo, \"%cNFS_ACCESS_LOOKUP\", separator));\n\t\t\t\t\tseparator = '|';\n\t\t\t\t}\n\t\t\t\tif (access_flags & NFSV3ACCESS_MODIFY) {\n\t\t\t\t\tND_PRINT((ndo, \"%cNFS_ACCESS_MODIFY\", separator));\n\t\t\t\t\tseparator = '|';\n\t\t\t\t}\n\t\t\t\tif (access_flags & NFSV3ACCESS_EXTEND) {\n\t\t\t\t\tND_PRINT((ndo, \"%cNFS_ACCESS_EXTEND\", separator));\n\t\t\t\t\tseparator = '|';\n\t\t\t\t}\n\t\t\t\tif (access_flags & NFSV3ACCESS_DELETE) {\n\t\t\t\t\tND_PRINT((ndo, \"%cNFS_ACCESS_DELETE\", separator));\n\t\t\t\t\tseparator = '|';\n\t\t\t\t}\n\t\t\t\tif (access_flags & NFSV3ACCESS_EXECUTE)\n\t\t\t\t\tND_PRINT((ndo, \"%cNFS_ACCESS_EXECUTE\", separator));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_READ:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    (dp = parsefh(ndo, dp, v3)) != NULL) {\n\t\t\tif (v3) {\n\t\t\t\tND_TCHECK(dp[2]);\n\t\t\t\tND_PRINT((ndo, \" %u bytes @ %\" PRIu64,\n\t\t\t\t       EXTRACT_32BITS(&dp[2]),\n\t\t\t\t       EXTRACT_64BITS(&dp[0])));\n\t\t\t} else {\n\t\t\t\tND_TCHECK(dp[1]);\n\t\t\t\tND_PRINT((ndo, \" %u bytes @ %u\",\n\t\t\t\t    EXTRACT_32BITS(&dp[1]),\n\t\t\t\t    EXTRACT_32BITS(&dp[0])));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_WRITE:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    (dp = parsefh(ndo, dp, v3)) != NULL) {\n\t\t\tif (v3) {\n\t\t\t\tND_TCHECK(dp[4]);\n\t\t\t\tND_PRINT((ndo, \" %u (%u) bytes @ %\" PRIu64,\n\t\t\t\t\t\tEXTRACT_32BITS(&dp[4]),\n\t\t\t\t\t\tEXTRACT_32BITS(&dp[2]),\n\t\t\t\t\t\tEXTRACT_64BITS(&dp[0])));\n\t\t\t\tif (ndo->ndo_vflag) {\n\t\t\t\t\tND_PRINT((ndo, \" <%s>\",\n\t\t\t\t\t\ttok2str(nfsv3_writemodes,\n\t\t\t\t\t\t\tNULL, EXTRACT_32BITS(&dp[3]))));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tND_TCHECK(dp[3]);\n\t\t\t\tND_PRINT((ndo, \" %u (%u) bytes @ %u (%u)\",\n\t\t\t\t\t\tEXTRACT_32BITS(&dp[3]),\n\t\t\t\t\t\tEXTRACT_32BITS(&dp[2]),\n\t\t\t\t\t\tEXTRACT_32BITS(&dp[1]),\n\t\t\t\t\t\tEXTRACT_32BITS(&dp[0])));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_SYMLINK:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    (dp = parsefhn(ndo, dp, v3)) != NULL) {\n\t\t\tND_PRINT((ndo, \" ->\"));\n\t\t\tif (v3 && (dp = parse_sattr3(ndo, dp, &sa3)) == NULL)\n\t\t\t\tbreak;\n\t\t\tif (parsefn(ndo, dp) == NULL)\n\t\t\t\tbreak;\n\t\t\tif (v3 && ndo->ndo_vflag)\n\t\t\t\tprint_sattr3(ndo, &sa3, ndo->ndo_vflag);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_MKNOD:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    (dp = parsefhn(ndo, dp, v3)) != NULL) {\n\t\t\tND_TCHECK(*dp);\n\t\t\ttype = (nfs_type)EXTRACT_32BITS(dp);\n\t\t\tdp++;\n\t\t\tif ((dp = parse_sattr3(ndo, dp, &sa3)) == NULL)\n\t\t\t\tbreak;\n\t\t\tND_PRINT((ndo, \" %s\", tok2str(type2str, \"unk-ft %d\", type)));\n\t\t\tif (ndo->ndo_vflag && (type == NFCHR || type == NFBLK)) {\n\t\t\t\tND_TCHECK(dp[1]);\n\t\t\t\tND_PRINT((ndo, \" %u/%u\",\n\t\t\t\t       EXTRACT_32BITS(&dp[0]),\n\t\t\t\t       EXTRACT_32BITS(&dp[1])));\n\t\t\t\tdp += 2;\n\t\t\t}\n\t\t\tif (ndo->ndo_vflag)\n\t\t\t\tprint_sattr3(ndo, &sa3, ndo->ndo_vflag);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_RENAME:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    (dp = parsefhn(ndo, dp, v3)) != NULL) {\n\t\t\tND_PRINT((ndo, \" ->\"));\n\t\t\tif (parsefhn(ndo, dp, v3) != NULL)\n\t\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_LINK:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    (dp = parsefh(ndo, dp, v3)) != NULL) {\n\t\t\tND_PRINT((ndo, \" ->\"));\n\t\t\tif (parsefhn(ndo, dp, v3) != NULL)\n\t\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_READDIR:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    (dp = parsefh(ndo, dp, v3)) != NULL) {\n\t\t\tif (v3) {\n\t\t\t\tND_TCHECK(dp[4]);\n\t\t\t\t/*\n\t\t\t\t * We shouldn't really try to interpret the\n\t\t\t\t * offset cookie here.\n\t\t\t\t */\n\t\t\t\tND_PRINT((ndo, \" %u bytes @ %\" PRId64,\n\t\t\t\t    EXTRACT_32BITS(&dp[4]),\n\t\t\t\t    EXTRACT_64BITS(&dp[0])));\n\t\t\t\tif (ndo->ndo_vflag)\n\t\t\t\t\tND_PRINT((ndo, \" verf %08x%08x\", dp[2], dp[3]));\n\t\t\t} else {\n\t\t\t\tND_TCHECK(dp[1]);\n\t\t\t\t/*\n\t\t\t\t * Print the offset as signed, since -1 is\n\t\t\t\t * common, but offsets > 2^31 aren't.\n\t\t\t\t */\n\t\t\t\tND_PRINT((ndo, \" %u bytes @ %d\",\n\t\t\t\t    EXTRACT_32BITS(&dp[1]),\n\t\t\t\t    EXTRACT_32BITS(&dp[0])));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_READDIRPLUS:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    (dp = parsefh(ndo, dp, v3)) != NULL) {\n\t\t\tND_TCHECK(dp[4]);\n\t\t\t/*\n\t\t\t * We don't try to interpret the offset\n\t\t\t * cookie here.\n\t\t\t */\n\t\t\tND_PRINT((ndo, \" %u bytes @ %\" PRId64,\n\t\t\t\tEXTRACT_32BITS(&dp[4]),\n\t\t\t\tEXTRACT_64BITS(&dp[0])));\n\t\t\tif (ndo->ndo_vflag) {\n\t\t\t\tND_TCHECK(dp[5]);\n\t\t\t\tND_PRINT((ndo, \" max %u verf %08x%08x\",\n\t\t\t\t       EXTRACT_32BITS(&dp[5]), dp[2], dp[3]));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase NFSPROC_COMMIT:\n\t\tif ((dp = parsereq(ndo, rp, length)) != NULL &&\n\t\t    (dp = parsefh(ndo, dp, v3)) != NULL) {\n\t\t\tND_TCHECK(dp[2]);\n\t\t\tND_PRINT((ndo, \" %u bytes @ %\" PRIu64,\n\t\t\t\tEXTRACT_32BITS(&dp[2]),\n\t\t\t\tEXTRACT_64BITS(&dp[0])));\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\ntrunc:\n\tif (!nfserr)\n\t\tND_PRINT((ndo, \"%s\", tstr));\n}",
        "description": "The NFS parser in tcpdump, prior to version 4.9.2, suffers from a buffer over-read issue within the interp_reply function.",
        "commit": "The NFSv3 WRITE procedure lacked proper bounds checking, specifically for the length of the opaque data being written. This oversight allowed for a buffer over-read vulnerability. Additionally, the code was updated to ensure that the entire `ar_stat` field is present in the captured data and to clarify the handling of the \"stable\" argument by removing redundant checks. A test case was included to verify the fix for checking before fetching the \"access\" part of the NFSv3 ACCESS results."
    },
    {
        "cwe": "CWE-119",
        "func_name": "torvalds/hugetlb_mcopy_atomic_pte",
        "score": 0.771972119808197,
        "func_before": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tstruct address_space *mapping = dst_vma->vm_file->f_mapping;\n\t\tpgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
        "func_after": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\tunsigned long size;\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\tmapping = dst_vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\t\tret = -EFAULT;\n\t\tif (idx >= size)\n\t\t\tgoto out_release_nounlock;\n\n\t\t/*\n\t\t * Serialization between remove_inode_hugepages() and\n\t\t * huge_add_to_page_cache() below happens through the\n\t\t * hugetlb_fault_mutex_table that here must be hold by\n\t\t * the caller.\n\t\t */\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\t/*\n\t * Recheck the i_size after holding PT lock to make sure not\n\t * to leave any page mapped (as page_mapped()) beyond the end\n\t * of the i_size (remove_inode_hugepages() is strict about\n\t * enforcing that). If we bail out here, we'll also leave a\n\t * page in the radix tree in the vm_shared case beyond the end\n\t * of the i_size, but remove_inode_hugepages() will take care\n\t * of it as soon as we drop the hugetlb_fault_mutex_table.\n\t */\n\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\tret = -EFAULT;\n\tif (idx >= size)\n\t\tgoto out_release_unlock;\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
        "description": "A flaw was identified in the hugetlb_mcopy_atomic_pte function within the Linux kernel's memory management module, affecting versions prior to 4.13.12. The absence of a proper size check in this function could lead to a denial of service condition, indicated by a BUG.",
        "commit": "A vulnerability was identified in the userfaultfd functionality related to hugetlbfs, where the UFFDIO_COPY operation could inadvertently extend beyond the intended size of the file (i_size). This issue led to a kernel panic (oops) at fs/hugetlbfs/inode.c:484, triggered by the absence of an i_size check in the hugetlb_mcopy_atomic_pte function. Although mmap() operations could succeed beyond the end of the i_size after vmtruncate had removed virtual memory areas (vmas) in those ranges, subsequent faults, including UFFDIO_COPY, should not be allowed to succeed. The proposed solution involves modifying the return value to userland to indicate a SIGBUS-like condition, similar to what a page fault would produce, but this approach was deemed less useful due to the difficulty in distinguishing between SIGSEGV and SIGBUS through meaningful syscall return values."
    },
    {
        "cwe": "CWE-369",
        "func_name": "upx/PackLinuxElf64::elf_lookup",
        "score": 0.7643830180168152,
        "func_before": "Elf64_Sym const *PackLinuxElf64__elf_lookup(char const *name) const\n{\n    if (hashtab && dynsym && dynstr) {\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket];\n        unsigned const m = elf_hash(name) % nbucket;\n        if (!nbucket\n        ||  (unsigned)(file_size - ((char const *)buckets - (char const *)(void const *)file_image))\n                <= sizeof(unsigned)*nbucket ) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad nbucket %#x\\n\", nbucket);\n            throwCantPack(msg);\n        }\n        unsigned si;\n        for (si= get_te32(&buckets[m]); 0!=si; si= get_te32(&chains[si])) {\n            char const *const p= get_dynsym_name(si, (unsigned)-1);\n            if (0==strcmp(name, p)) {\n                return &dynsym[si];\n            }\n        }\n    }\n    if (gashtab && dynsym && dynstr) {\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const symbias  = get_te32(&gashtab[1]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket];\n        if (!n_bucket\n        || (void const *)&file_image[file_size] <= (void const *)hasharr) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad n_bucket %#x\\n\", n_bucket);\n            throwCantPack(msg);\n        }\n        if (!n_bitmask\n        || (unsigned)(file_size - ((char const *)bitmask - (char const *)(void const *)file_image))\n                <= sizeof(unsigned)*n_bitmask ) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad n_bitmask %#x\\n\", n_bitmask);\n            throwCantPack(msg);\n        }\n\n        unsigned const h = gnu_hash(name);\n        unsigned const hbit1 = 077& h;\n        unsigned const hbit2 = 077& (h>>gnu_shift);\n        upx_uint64_t const w = get_te64(&bitmask[(n_bitmask -1) & (h>>6)]);\n\n        if (1& (w>>hbit1) & (w>>hbit2)) {\n            unsigned bucket = get_te32(&buckets[h % n_bucket]);\n            if (n_bucket <= bucket) {\n                char msg[80]; snprintf(msg, sizeof(msg),\n                        \"bad DT_GNU_HASH n_bucket{%#x} <= buckets[%d]{%#x}\\n\",\n                        n_bucket, h % n_bucket, bucket);\n                throwCantPack(msg);\n            }\n            if (0!=bucket) {\n                Elf64_Sym const *dsp = &dynsym[bucket];\n                unsigned const *hp = &hasharr[bucket - symbias];\n\n                do if (0==((h ^ get_te32(hp))>>1)) {\n                    unsigned st_name = get_te32(&dsp->st_name);\n                    char const *const p = get_str_name(st_name, (unsigned)-1);\n                    if (0==strcmp(name, p)) {\n                        return dsp;\n                    }\n                } while (++dsp,\n                        (char const *)hp < (char const *)&file_image[file_size]\n                    &&  0==(1u& get_te32(hp++)));\n            }\n        }\n    }\n    return 0;\n\n}",
        "func_after": "Elf64_Sym const *PackLinuxElf64__elf_lookup(char const *name) const\n{\n    if (hashtab && dynsym && dynstr) {\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket];\n        if (!nbucket\n        ||  (unsigned)(file_size - ((char const *)buckets - (char const *)(void const *)file_image))\n                <= sizeof(unsigned)*nbucket ) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad nbucket %#x\\n\", nbucket);\n            throwCantPack(msg);\n        }\n        unsigned const m = elf_hash(name) % nbucket;\n        unsigned si;\n        for (si= get_te32(&buckets[m]); 0!=si; si= get_te32(&chains[si])) {\n            char const *const p= get_dynsym_name(si, (unsigned)-1);\n            if (0==strcmp(name, p)) {\n                return &dynsym[si];\n            }\n        }\n    }\n    if (gashtab && dynsym && dynstr) {\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const symbias  = get_te32(&gashtab[1]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket];\n        if (!n_bucket\n        || (void const *)&file_image[file_size] <= (void const *)hasharr) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad n_bucket %#x\\n\", n_bucket);\n            throwCantPack(msg);\n        }\n        if (!n_bitmask\n        || (unsigned)(file_size - ((char const *)bitmask - (char const *)(void const *)file_image))\n                <= sizeof(unsigned)*n_bitmask ) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad n_bitmask %#x\\n\", n_bitmask);\n            throwCantPack(msg);\n        }\n\n        unsigned const h = gnu_hash(name);\n        unsigned const hbit1 = 077& h;\n        unsigned const hbit2 = 077& (h>>gnu_shift);\n        upx_uint64_t const w = get_te64(&bitmask[(n_bitmask -1) & (h>>6)]);\n\n        if (1& (w>>hbit1) & (w>>hbit2)) {\n            unsigned bucket = get_te32(&buckets[h % n_bucket]);\n            if (n_bucket <= bucket) {\n                char msg[80]; snprintf(msg, sizeof(msg),\n                        \"bad DT_GNU_HASH n_bucket{%#x} <= buckets[%d]{%#x}\\n\",\n                        n_bucket, h % n_bucket, bucket);\n                throwCantPack(msg);\n            }\n            if (0!=bucket) {\n                Elf64_Sym const *dsp = &dynsym[bucket];\n                unsigned const *hp = &hasharr[bucket - symbias];\n\n                do if (0==((h ^ get_te32(hp))>>1)) {\n                    unsigned st_name = get_te32(&dsp->st_name);\n                    char const *const p = get_str_name(st_name, (unsigned)-1);\n                    if (0==strcmp(name, p)) {\n                        return dsp;\n                    }\n                } while (++dsp,\n                        (char const *)hp < (char const *)&file_image[file_size]\n                    &&  0==(1u& get_te32(hp++)));\n            }\n        }\n    }\n    return 0;\n\n}",
        "description": "An floating point exception was discovered in the elf_lookup function within the UPX decompression utility, specifically in version 4.0.0, when processing a specially crafted Mach-O file.",
        "commit": "It was identified that there is a need to avoid setting `nbucket` to zero in the UPX compression tool, as indicated by an issue reported in the GitHub repository. This modification was made in the `p_lx_elf.cpp` file."
    },
    {
        "cwe": "CWE-129",
        "func_name": "admesh/stl_fix_normal_directions",
        "score": 0.7489238381385803,
        "func_before": "void\nstl_fix_normal_directions(stl_file *stl) {\n  char *norm_sw;\n  /*  int edge_num;*/\n  /*  int vnot;*/\n  int checked = 0;\n  int facet_num;\n  /*  int next_facet;*/\n  int i;\n  int j;\n  struct stl_normal {\n    int               facet_num;\n    struct stl_normal *next;\n  };\n  struct stl_normal *head;\n  struct stl_normal *tail;\n  struct stl_normal *newn;\n  struct stl_normal *temp;\n\n  if (stl->error) return;\n\n  /* Initialize linked list. */\n  head = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n  if(head == NULL) perror(\"stl_fix_normal_directions\");\n  tail = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n  if(tail == NULL) perror(\"stl_fix_normal_directions\");\n  head->next = tail;\n  tail->next = tail;\n\n  /* Initialize list that keeps track of already fixed facets. */\n  norm_sw = (char*)calloc(stl->stats.number_of_facets, sizeof(char));\n  if(norm_sw == NULL) perror(\"stl_fix_normal_directions\");\n\n\n  facet_num = 0;\n  /* If normal vector is not within tolerance and backwards:\n     Arbitrarily starts at face 0.  If this one is wrong, we're screwed.  Thankfully, the chances\n     of it being wrong randomly are low if most of the triangles are right: */\n  if(stl_check_normal_vector(stl, 0, 0) == 2)\n    stl_reverse_facet(stl, 0);\n\n  /* Say that we've fixed this facet: */\n  norm_sw[facet_num] = 1;\n  checked++;\n\n  for(;;) {\n    /* Add neighbors_to_list.\n       Add unconnected neighbors to the list:a  */\n    for(j = 0; j < 3; j++) {\n      /* Reverse the neighboring facets if necessary. */\n      if(stl->neighbors_start[facet_num].which_vertex_not[j] > 2) {\n        /* If the facet has a neighbor that is -1, it means that edge isn't shared by another facet */\n        if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n          stl_reverse_facet\n          (stl, stl->neighbors_start[facet_num].neighbor[j]);\n        }\n      }\n      /* If this edge of the facet is connected: */\n      if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n        /* If we haven't fixed this facet yet, add it to the list: */\n        if(norm_sw[stl->neighbors_start[facet_num].neighbor[j]] != 1) {\n          /* Add node to beginning of list. */\n          newn = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n          if(newn == NULL) perror(\"stl_fix_normal_directions\");\n          newn->facet_num = stl->neighbors_start[facet_num].neighbor[j];\n          newn->next = head->next;\n          head->next = newn;\n        }\n      }\n    }\n    /* Get next facet to fix from top of list. */\n    if(head->next != tail) {\n      facet_num = head->next->facet_num;\n      if(norm_sw[facet_num] != 1) { /* If facet is in list mutiple times */\n        norm_sw[facet_num] = 1; /* Record this one as being fixed. */\n        checked++;\n      }\n      temp = head->next;\t/* Delete this facet from the list. */\n      head->next = head->next->next;\n      free(temp);\n    } else { /* if we ran out of facets to fix: */\n      /* All of the facets in this part have been fixed. */\n      stl->stats.number_of_parts += 1;\n      if(checked >= stl->stats.number_of_facets) {\n        /* All of the facets have been checked.  Bail out. */\n        break;\n      } else {\n        /* There is another part here.  Find it and continue. */\n        for(i = 0; i < stl->stats.number_of_facets; i++) {\n          if(norm_sw[i] == 0) {\n            /* This is the first facet of the next part. */\n            facet_num = i;\n            if(stl_check_normal_vector(stl, i, 0) == 2) {\n              stl_reverse_facet(stl, i);\n            }\n\n            norm_sw[facet_num] = 1;\n            checked++;\n            break;\n          }\n        }\n      }\n    }\n  }\n  free(head);\n  free(tail);\n  free(norm_sw);\n}",
        "func_after": "void\nstl_fix_normal_directions(stl_file *stl) {\n  char *norm_sw;\n  /*  int edge_num;*/\n  /*  int vnot;*/\n  int checked = 0;\n  int facet_num;\n  /*  int next_facet;*/\n  int i;\n  int j;\n  struct stl_normal {\n    int               facet_num;\n    struct stl_normal *next;\n  };\n  struct stl_normal *head;\n  struct stl_normal *tail;\n  struct stl_normal *newn;\n  struct stl_normal *temp;\n\n  if (stl->error) return;\n\n  /* Initialize linked list. */\n  head = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n  if(head == NULL) perror(\"stl_fix_normal_directions\");\n  tail = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n  if(tail == NULL) perror(\"stl_fix_normal_directions\");\n  head->next = tail;\n  tail->next = tail;\n\n  /* Initialize list that keeps track of already fixed facets. */\n  norm_sw = (char*)calloc(stl->stats.number_of_facets, sizeof(char));\n  if(norm_sw == NULL) perror(\"stl_fix_normal_directions\");\n\n\n  facet_num = 0;\n  /* If normal vector is not within tolerance and backwards:\n     Arbitrarily starts at face 0.  If this one is wrong, we're screwed.  Thankfully, the chances\n     of it being wrong randomly are low if most of the triangles are right: */\n  if(stl_check_normal_vector(stl, 0, 0) == 2)\n    stl_reverse_facet(stl, 0);\n\n  /* Say that we've fixed this facet: */\n  norm_sw[facet_num] = 1;\n  checked++;\n\n  for(;;) {\n    /* Add neighbors_to_list.\n       Add unconnected neighbors to the list:a  */\n    for(j = 0; j < 3; j++) {\n      /* Reverse the neighboring facets if necessary. */\n      if(stl->neighbors_start[facet_num].which_vertex_not[j] > 2) {\n        /* If the facet has a neighbor that is -1, it means that edge isn't shared by another facet */\n        if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n          stl_reverse_facet\n          (stl, stl->neighbors_start[facet_num].neighbor[j]);\n        }\n      }\n      /* If this edge of the facet is connected: */\n      if(stl->neighbors_start[facet_num].neighbor[j] != -1 &&\n         stl->neighbors_start[facet_num].neighbor[j] < stl->stats.number_of_facets*sizeof(char)) {\n        /* If we haven't fixed this facet yet, add it to the list: */\n        if(norm_sw[stl->neighbors_start[facet_num].neighbor[j]] != 1) {\n          /* Add node to beginning of list. */\n          newn = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n          if(newn == NULL) perror(\"stl_fix_normal_directions\");\n          newn->facet_num = stl->neighbors_start[facet_num].neighbor[j];\n          newn->next = head->next;\n          head->next = newn;\n        }\n      }\n    }\n    /* Get next facet to fix from top of list. */\n    if(head->next != tail) {\n      facet_num = head->next->facet_num;\n      if(norm_sw[facet_num] != 1) { /* If facet is in list mutiple times */\n        norm_sw[facet_num] = 1; /* Record this one as being fixed. */\n        checked++;\n      }\n      temp = head->next;\t/* Delete this facet from the list. */\n      head->next = head->next->next;\n      free(temp);\n    } else { /* if we ran out of facets to fix: */\n      /* All of the facets in this part have been fixed. */\n      stl->stats.number_of_parts += 1;\n      if(checked >= stl->stats.number_of_facets) {\n        /* All of the facets have been checked.  Bail out. */\n        break;\n      } else {\n        /* There is another part here.  Find it and continue. */\n        for(i = 0; i < stl->stats.number_of_facets; i++) {\n          if(norm_sw[i] == 0) {\n            /* This is the first facet of the next part. */\n            facet_num = i;\n            if(stl_check_normal_vector(stl, i, 0) == 2) {\n              stl_reverse_facet(stl, i);\n            }\n\n            norm_sw[facet_num] = 1;\n            checked++;\n            break;\n          }\n        }\n      }\n    }\n  }\n  free(head);\n  free(tail);\n  free(norm_sw);\n}",
        "description": "An improper array index validation vulnerability exists in the stl_fix_normal_directions functionality of ADMesh. A specially-crafted STL file can lead to a heap buffer overflow. An attacker can exploit this by providing a malicious file.",
        "commit": "The vulnerability involves a check for the `neighbor_index` within the `stl_check_normal_vector` function. This fix addresses an issue identified in ticket #60."
    }
]