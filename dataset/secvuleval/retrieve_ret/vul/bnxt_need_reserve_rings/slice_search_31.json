[
    {
        "cwe": "CWE-17",
        "func_name": "torvalds/udf_find_entry",
        "score": 0.7886872887611389,
        "func_before": "static struct fileIdentDesc *udf_find_entry(struct inode *dir,\n\t\t\t\t\t    const struct qstr *child,\n\t\t\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t\t\t    struct fileIdentDesc *cfi)\n{\n\tstruct fileIdentDesc *fi = NULL;\n\tloff_t f_pos;\n\tint block, flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tloff_t size;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint isdotdot = child->len == 2 &&\n\t\tchild->name[0] == '.' && child->name[1] == '.';\n\n\tsize = udf_ext0_offset(dir) + dir->i_size;\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tfibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\tgoto out_err;\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t}\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname)\n\t\tgoto out_err;\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out_err;\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif (fibh->sbh == fibh->ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh->soffset + sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi;\n\n\t\t\tif (poffset >= lfi)\n\t\t\t\tnameptr = (uint8_t *)(fibh->ebh->b_data +\n\t\t\t\t\t\t      poffset - lfi);\n\t\t\telse {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t\tlfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t\tfibh->ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn fi;\n}",
        "func_after": "static struct fileIdentDesc *udf_find_entry(struct inode *dir,\n\t\t\t\t\t    const struct qstr *child,\n\t\t\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t\t\t    struct fileIdentDesc *cfi)\n{\n\tstruct fileIdentDesc *fi = NULL;\n\tloff_t f_pos;\n\tint block, flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tloff_t size;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint isdotdot = child->len == 2 &&\n\t\tchild->name[0] == '.' && child->name[1] == '.';\n\n\tsize = udf_ext0_offset(dir) + dir->i_size;\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tfibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\tgoto out_err;\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t}\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname)\n\t\tgoto out_err;\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out_err;\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif (fibh->sbh == fibh->ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh->soffset + sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi;\n\n\t\t\tif (poffset >= lfi)\n\t\t\t\tnameptr = (uint8_t *)(fibh->ebh->b_data +\n\t\t\t\t\t\t      poffset - lfi);\n\t\t\telse {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t\tlfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t\tfibh->ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,\n\t\t\t\t\tUDF_NAME_LEN);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn fi;\n}",
        "description": "The UDF filesystem implementation in the Linux kernel prior to version 3.18.2 does not verify that sufficient space is allocated for storing a symlink target's name along with a trailing null character. This oversight enables local users to potentially access sensitive information through a specially crafted filesystem image.",
        "commit": "The vulnerability involves a failure to verify whether the resolved path from reading a symbolic link fits within the allocated buffer size. This oversight occurs during the process of reading symlinks, where the code does not account for potential encoding conversions that could increase the path length. Consequently, there is a risk that the path may exceed the buffer capacity, leading to buffer overflow issues."
    },
    {
        "cwe": "CWE-200",
        "func_name": "torvalds/xfs_iget_cache_miss",
        "score": 0.7819686532020569,
        "func_before": "static int\nxfs_iget_cache_miss(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_trans_t\t\t*tp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_inode\t**ipp,\n\txfs_daddr_t\t\tbno,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\tunsigned long\t\tfirst_index, mask;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ino);\n\n\tip = xfs_inode_alloc(mp, ino);\n\tif (!ip)\n\t\treturn ENOMEM;\n\n\terror = xfs_iread(mp, tp, ip, bno, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\txfs_itrace_entry(ip);\n\n\tif ((ip->i_d.di_mode == 0) && !(flags & XFS_IGET_CREATE)) {\n\t\terror = ENOENT;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Preload the radix tree so we can insert safely under the\n\t * write spinlock. Note that we cannot sleep inside the preload\n\t * region.\n\t */\n\tif (radix_tree_preload(GFP_KERNEL)) {\n\t\terror = EAGAIN;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Because the inode hasn't been added to the radix-tree yet it can't\n\t * be found by another thread, so we can do the non-sleeping lock here.\n\t */\n\tif (lock_flags) {\n\t\tif (!xfs_ilock_nowait(ip, lock_flags))\n\t\t\tBUG();\n\t}\n\n\tmask = ~(((XFS_INODE_CLUSTER_SIZE(mp) >> mp->m_sb.sb_inodelog)) - 1);\n\tfirst_index = agino & mask;\n\twrite_lock(&pag->pag_ici_lock);\n\n\t/* insert the new inode */\n\terror = radix_tree_insert(&pag->pag_ici_root, agino, ip);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\t\tXFS_STATS_INC(xs_ig_dup);\n\t\terror = EAGAIN;\n\t\tgoto out_preload_end;\n\t}\n\n\t/* These values _must_ be set before releasing the radix tree lock! */\n\tip->i_udquot = ip->i_gdquot = NULL;\n\txfs_iflags_set(ip, XFS_INEW);\n\n\twrite_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\n\ttrace_xfs_iget_alloc(ip);\n\t*ipp = ip;\n\treturn 0;\n\nout_preload_end:\n\twrite_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\nout_destroy:\n\t__destroy_inode(VFS_I(ip));\n\txfs_inode_free(ip);\n\treturn error;\n}",
        "func_after": "static int\nxfs_iget_cache_miss(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_trans_t\t\t*tp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_inode\t**ipp,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\tunsigned long\t\tfirst_index, mask;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ino);\n\n\tip = xfs_inode_alloc(mp, ino);\n\tif (!ip)\n\t\treturn ENOMEM;\n\n\terror = xfs_iread(mp, tp, ip, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\txfs_itrace_entry(ip);\n\n\tif ((ip->i_d.di_mode == 0) && !(flags & XFS_IGET_CREATE)) {\n\t\terror = ENOENT;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Preload the radix tree so we can insert safely under the\n\t * write spinlock. Note that we cannot sleep inside the preload\n\t * region.\n\t */\n\tif (radix_tree_preload(GFP_KERNEL)) {\n\t\terror = EAGAIN;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Because the inode hasn't been added to the radix-tree yet it can't\n\t * be found by another thread, so we can do the non-sleeping lock here.\n\t */\n\tif (lock_flags) {\n\t\tif (!xfs_ilock_nowait(ip, lock_flags))\n\t\t\tBUG();\n\t}\n\n\tmask = ~(((XFS_INODE_CLUSTER_SIZE(mp) >> mp->m_sb.sb_inodelog)) - 1);\n\tfirst_index = agino & mask;\n\twrite_lock(&pag->pag_ici_lock);\n\n\t/* insert the new inode */\n\terror = radix_tree_insert(&pag->pag_ici_root, agino, ip);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\t\tXFS_STATS_INC(xs_ig_dup);\n\t\terror = EAGAIN;\n\t\tgoto out_preload_end;\n\t}\n\n\t/* These values _must_ be set before releasing the radix tree lock! */\n\tip->i_udquot = ip->i_gdquot = NULL;\n\txfs_iflags_set(ip, XFS_INEW);\n\n\twrite_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\n\ttrace_xfs_iget_alloc(ip);\n\t*ipp = ip;\n\treturn 0;\n\nout_preload_end:\n\twrite_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\nout_destroy:\n\t__destroy_inode(VFS_I(ip));\n\txfs_inode_free(ip);\n\treturn error;\n}",
        "description": "The XFS implementation in the Linux kernel prior to version 2.6.35 fails to check inode allocation btrees before reading inode buffers. This oversight enables remote authenticated users to access unlinked files or modify disk blocks that were previously associated with unlinked files but are now linked to active files through stale NFS filehandles.",
        "commit": "The vulnerability involves using block numbers obtained from bulkstat-based inode lookups to optimize mapping calculations. However, since bulkstat data cannot be trusted, the block numbers should be discarded to ensure accurate and reliable lookups and mappings."
    },
    {
        "cwe": "CWE-755",
        "func_name": "xen-project/map_grant_ref",
        "score": 0.7779207229614258,
        "func_before": "static void\nmap_grant_ref(\n    struct gnttab_map_grant_ref *op)\n{\n    struct domain *ld, *rd, *owner = NULL;\n    struct grant_table *lgt, *rgt;\n    grant_ref_t ref;\n    grant_handle_t handle;\n    mfn_t mfn;\n    struct page_info *pg = NULL;\n    int            rc = GNTST_okay;\n    unsigned int   cache_flags, clear_flags = 0, refcnt = 0, typecnt = 0;\n    bool           host_map_created = false;\n    struct active_grant_entry *act = NULL;\n    struct grant_mapping *mt;\n    grant_entry_header_t *shah;\n    uint16_t *status;\n    bool_t need_iommu;\n\n    ld = current->domain;\n\n    if ( unlikely((op->flags & (GNTMAP_device_map|GNTMAP_host_map)) == 0) )\n    {\n        gdprintk(XENLOG_INFO, \"Bad flags in grant map op: %x\\n\", op->flags);\n        op->status = GNTST_bad_gntref;\n        return;\n    }\n\n    if ( unlikely(paging_mode_external(ld) &&\n                  (op->flags & (GNTMAP_device_map|GNTMAP_application_map|\n                            GNTMAP_contains_pte))) )\n    {\n        gdprintk(XENLOG_INFO, \"No device mapping in HVM domain\\n\");\n        op->status = GNTST_general_error;\n        return;\n    }\n\n    if ( unlikely((rd = rcu_lock_domain_by_id(op->dom)) == NULL) )\n    {\n        gdprintk(XENLOG_INFO, \"Could not find domain %d\\n\", op->dom);\n        op->status = GNTST_bad_domain;\n        return;\n    }\n\n    rc = xsm_grant_mapref(XSM_HOOK, ld, rd, op->flags);\n    if ( rc )\n    {\n        rcu_unlock_domain(rd);\n        op->status = GNTST_permission_denied;\n        return;\n    }\n\n    lgt = ld->grant_table;\n    handle = get_maptrack_handle(lgt);\n    if ( unlikely(handle == INVALID_MAPTRACK_HANDLE) )\n    {\n        rcu_unlock_domain(rd);\n        gdprintk(XENLOG_INFO, \"Failed to obtain maptrack handle\\n\");\n        op->status = GNTST_no_device_space;\n        return;\n    }\n\n    rgt = rd->grant_table;\n    grant_read_lock(rgt);\n\n    /* Bounds check on the grant ref */\n    ref = op->ref;\n    if ( unlikely(ref >= nr_grant_entries(rgt)))\n        PIN_FAIL(unlock_out, GNTST_bad_gntref, \"Bad ref %#x for d%d\\n\",\n                 ref, rgt->domain->domain_id);\n\n    /* This call also ensures the above check cannot be passed speculatively */\n    shah = shared_entry_header(rgt, ref);\n    act = active_entry_acquire(rgt, ref);\n\n    /* Make sure we do not access memory speculatively */\n    status = evaluate_nospec(rgt->gt_version == 1) ? &shah->flags\n                                                 : &status_entry(rgt, ref);\n\n    /* If already pinned, check the active domid and avoid refcnt overflow. */\n    if ( act->pin &&\n         ((act->domid != ld->domain_id) ||\n          (act->pin & 0x80808080U) != 0 ||\n          (act->is_sub_page)) )\n        PIN_FAIL(act_release_out, GNTST_general_error,\n                 \"Bad domain (%d != %d), or risk of counter overflow %08x, or subpage %d\\n\",\n                 act->domid, ld->domain_id, act->pin, act->is_sub_page);\n\n    if ( !act->pin ||\n         (!(op->flags & GNTMAP_readonly) &&\n          !(act->pin & (GNTPIN_hstw_mask|GNTPIN_devw_mask))) )\n    {\n        if ( (rc = _set_status(shah, status, rd, rgt->gt_version, act,\n                               op->flags & GNTMAP_readonly, 1,\n                               ld->domain_id) != GNTST_okay) )\n            goto act_release_out;\n\n        if ( !act->pin )\n        {\n            unsigned long gfn = evaluate_nospec(rgt->gt_version == 1) ?\n                                shared_entry_v1(rgt, ref).frame :\n                                shared_entry_v2(rgt, ref).full_page.frame;\n\n            rc = get_paged_frame(gfn, &mfn, &pg,\n                                 op->flags & GNTMAP_readonly, rd);\n            if ( rc != GNTST_okay )\n                goto unlock_out_clear;\n            act_set_gfn(act, _gfn(gfn));\n            act->domid = ld->domain_id;\n            act->mfn = mfn;\n            act->start = 0;\n            act->length = PAGE_SIZE;\n            act->is_sub_page = false;\n            act->trans_domain = rd;\n            act->trans_gref = ref;\n        }\n    }\n\n    if ( op->flags & GNTMAP_device_map )\n        act->pin += (op->flags & GNTMAP_readonly) ?\n            GNTPIN_devr_inc : GNTPIN_devw_inc;\n    if ( op->flags & GNTMAP_host_map )\n        act->pin += (op->flags & GNTMAP_readonly) ?\n            GNTPIN_hstr_inc : GNTPIN_hstw_inc;\n\n    mfn = act->mfn;\n\n    cache_flags = (shah->flags & (GTF_PAT | GTF_PWT | GTF_PCD) );\n\n    active_entry_release(act);\n    grant_read_unlock(rgt);\n\n    /* pg may be set, with a refcount included, from get_paged_frame(). */\n    if ( !pg )\n    {\n        pg = mfn_valid(mfn) ? mfn_to_page(mfn) : NULL;\n        if ( pg )\n            owner = page_get_owner_and_reference(pg);\n    }\n    else\n        owner = page_get_owner(pg);\n\n    if ( owner )\n        refcnt++;\n\n    if ( !pg || (owner == dom_io) )\n    {\n        /* Only needed the reference to confirm dom_io ownership. */\n        if ( pg )\n        {\n            put_page(pg);\n            refcnt--;\n        }\n\n        if ( paging_mode_external(ld) )\n        {\n            gdprintk(XENLOG_WARNING, \"HVM guests can't grant map iomem\\n\");\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n\n        if ( !iomem_access_permitted(rd, mfn_x(mfn), mfn_x(mfn)) )\n        {\n            gdprintk(XENLOG_WARNING,\n                     \"Iomem mapping not permitted %#\"PRI_mfn\" (domain %d)\\n\",\n                     mfn_x(mfn), rd->domain_id);\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n\n        if ( op->flags & GNTMAP_host_map )\n        {\n            rc = create_grant_host_mapping(op->host_addr, mfn, op->flags,\n                                           cache_flags);\n            if ( rc != GNTST_okay )\n                goto undo_out;\n\n            host_map_created = true;\n        }\n    }\n    else if ( owner == rd || (dom_cow && owner == dom_cow) )\n    {\n        if ( (op->flags & GNTMAP_device_map) && !(op->flags & GNTMAP_readonly) )\n        {\n            if ( (owner == dom_cow) ||\n                 !get_page_type(pg, PGT_writable_page) )\n                goto could_not_pin;\n            typecnt++;\n        }\n\n        if ( op->flags & GNTMAP_host_map )\n        {\n            /*\n             * Only need to grab another reference if device_map claimed\n             * the other one.\n             */\n            if ( op->flags & GNTMAP_device_map )\n            {\n                if ( !get_page(pg, rd) )\n                    goto could_not_pin;\n                refcnt++;\n            }\n\n            if ( gnttab_host_mapping_get_page_type(op->flags & GNTMAP_readonly,\n                                                   ld, rd) )\n            {\n                if ( (owner == dom_cow) ||\n                     !get_page_type(pg, PGT_writable_page) )\n                    goto could_not_pin;\n                typecnt++;\n            }\n\n            rc = create_grant_host_mapping(op->host_addr, mfn, op->flags, 0);\n            if ( rc != GNTST_okay )\n                goto undo_out;\n\n            host_map_created = true;\n        }\n    }\n    else\n    {\n    could_not_pin:\n        if ( !rd->is_dying )\n            gdprintk(XENLOG_WARNING, \"Could not pin grant frame %#\"PRI_mfn\"\\n\",\n                     mfn_x(mfn));\n        rc = GNTST_general_error;\n        goto undo_out;\n    }\n\n    need_iommu = gnttab_need_iommu_mapping(ld);\n    if ( need_iommu )\n    {\n        unsigned int kind;\n\n        double_gt_lock(lgt, rgt);\n\n        /*\n         * We're not translated, so we know that dfns and mfns are\n         * the same things, so the IOMMU entry is always 1-to-1.\n         */\n        kind = mapkind(lgt, rd, mfn);\n        if ( !(op->flags & GNTMAP_readonly) &&\n             !(kind & MAPKIND_WRITE) )\n            kind = IOMMUF_readable | IOMMUF_writable;\n        else if ( !kind )\n            kind = IOMMUF_readable;\n        else\n            kind = 0;\n        if ( kind && iommu_legacy_map(ld, _dfn(mfn_x(mfn)), mfn, 0, kind) )\n        {\n            double_gt_unlock(lgt, rgt);\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n    }\n\n    TRACE_1D(TRC_MEM_PAGE_GRANT_MAP, op->dom);\n\n    /*\n     * All maptrack entry users check mt->flags first before using the\n     * other fields so just ensure the flags field is stored last.\n     *\n     * However, if gnttab_need_iommu_mapping() then this would race\n     * with a concurrent mapkind() call (on an unmap, for example)\n     * and a lock is required.\n     */\n    mt = &maptrack_entry(lgt, handle);\n    mt->domid = op->dom;\n    mt->ref   = op->ref;\n    smp_wmb();\n    write_atomic(&mt->flags, op->flags);\n\n    if ( need_iommu )\n        double_gt_unlock(lgt, rgt);\n\n    op->dev_bus_addr = mfn_to_maddr(mfn);\n    op->handle       = handle;\n    op->status       = GNTST_okay;\n\n    rcu_unlock_domain(rd);\n    return;\n\n undo_out:\n    if ( host_map_created )\n    {\n        replace_grant_host_mapping(op->host_addr, mfn, 0, op->flags);\n        gnttab_flush_tlb(ld);\n    }\n\n    while ( typecnt-- )\n        put_page_type(pg);\n\n    while ( refcnt-- )\n        put_page(pg);\n\n    grant_read_lock(rgt);\n\n    act = active_entry_acquire(rgt, op->ref);\n\n    if ( op->flags & GNTMAP_device_map )\n        act->pin -= (op->flags & GNTMAP_readonly) ?\n            GNTPIN_devr_inc : GNTPIN_devw_inc;\n    if ( op->flags & GNTMAP_host_map )\n        act->pin -= (op->flags & GNTMAP_readonly) ?\n            GNTPIN_hstr_inc : GNTPIN_hstw_inc;\n\n unlock_out_clear:\n    if ( !(op->flags & GNTMAP_readonly) &&\n         !(act->pin & (GNTPIN_hstw_mask|GNTPIN_devw_mask)) )\n        clear_flags |= GTF_writing;\n\n    if ( !act->pin )\n        clear_flags |= GTF_reading;\n\n    if ( clear_flags )\n        gnttab_clear_flags(rd, clear_flags, status);\n\n act_release_out:\n    active_entry_release(act);\n\n unlock_out:\n    grant_read_unlock(rgt);\n    op->status = rc;\n    put_maptrack_handle(lgt, handle);\n    rcu_unlock_domain(rd);\n}",
        "func_after": "static void\nmap_grant_ref(\n    struct gnttab_map_grant_ref *op)\n{\n    struct domain *ld, *rd, *owner = NULL;\n    struct grant_table *lgt, *rgt;\n    grant_ref_t ref;\n    grant_handle_t handle;\n    mfn_t mfn;\n    struct page_info *pg = NULL;\n    int            rc = GNTST_okay;\n    unsigned int   cache_flags, clear_flags = 0, refcnt = 0, typecnt = 0;\n    bool           host_map_created = false;\n    struct active_grant_entry *act = NULL;\n    struct grant_mapping *mt;\n    grant_entry_header_t *shah;\n    uint16_t *status;\n    bool_t need_iommu;\n\n    ld = current->domain;\n\n    if ( unlikely((op->flags & (GNTMAP_device_map|GNTMAP_host_map)) == 0) )\n    {\n        gdprintk(XENLOG_INFO, \"Bad flags in grant map op: %x\\n\", op->flags);\n        op->status = GNTST_bad_gntref;\n        return;\n    }\n\n    if ( unlikely(paging_mode_external(ld) &&\n                  (op->flags & (GNTMAP_device_map|GNTMAP_application_map|\n                            GNTMAP_contains_pte))) )\n    {\n        gdprintk(XENLOG_INFO, \"No device mapping in HVM domain\\n\");\n        op->status = GNTST_general_error;\n        return;\n    }\n\n    if ( unlikely((rd = rcu_lock_domain_by_id(op->dom)) == NULL) )\n    {\n        gdprintk(XENLOG_INFO, \"Could not find domain %d\\n\", op->dom);\n        op->status = GNTST_bad_domain;\n        return;\n    }\n\n    rc = xsm_grant_mapref(XSM_HOOK, ld, rd, op->flags);\n    if ( rc )\n    {\n        rcu_unlock_domain(rd);\n        op->status = GNTST_permission_denied;\n        return;\n    }\n\n    lgt = ld->grant_table;\n    handle = get_maptrack_handle(lgt);\n    if ( unlikely(handle == INVALID_MAPTRACK_HANDLE) )\n    {\n        rcu_unlock_domain(rd);\n        gdprintk(XENLOG_INFO, \"Failed to obtain maptrack handle\\n\");\n        op->status = GNTST_no_device_space;\n        return;\n    }\n\n    rgt = rd->grant_table;\n    grant_read_lock(rgt);\n\n    /* Bounds check on the grant ref */\n    ref = op->ref;\n    if ( unlikely(ref >= nr_grant_entries(rgt)))\n        PIN_FAIL(unlock_out, GNTST_bad_gntref, \"Bad ref %#x for d%d\\n\",\n                 ref, rgt->domain->domain_id);\n\n    /* This call also ensures the above check cannot be passed speculatively */\n    shah = shared_entry_header(rgt, ref);\n    act = active_entry_acquire(rgt, ref);\n\n    /* Make sure we do not access memory speculatively */\n    status = evaluate_nospec(rgt->gt_version == 1) ? &shah->flags\n                                                 : &status_entry(rgt, ref);\n\n    /* If already pinned, check the active domid and avoid refcnt overflow. */\n    if ( act->pin &&\n         ((act->domid != ld->domain_id) ||\n          (act->pin & 0x80808080U) != 0 ||\n          (act->is_sub_page)) )\n        PIN_FAIL(act_release_out, GNTST_general_error,\n                 \"Bad domain (%d != %d), or risk of counter overflow %08x, or subpage %d\\n\",\n                 act->domid, ld->domain_id, act->pin, act->is_sub_page);\n\n    if ( !act->pin ||\n         (!(op->flags & GNTMAP_readonly) &&\n          !(act->pin & (GNTPIN_hstw_mask|GNTPIN_devw_mask))) )\n    {\n        if ( (rc = _set_status(shah, status, rd, rgt->gt_version, act,\n                               op->flags & GNTMAP_readonly, 1,\n                               ld->domain_id)) != GNTST_okay )\n            goto act_release_out;\n\n        if ( !act->pin )\n        {\n            unsigned long gfn = evaluate_nospec(rgt->gt_version == 1) ?\n                                shared_entry_v1(rgt, ref).frame :\n                                shared_entry_v2(rgt, ref).full_page.frame;\n\n            rc = get_paged_frame(gfn, &mfn, &pg,\n                                 op->flags & GNTMAP_readonly, rd);\n            if ( rc != GNTST_okay )\n                goto unlock_out_clear;\n            act_set_gfn(act, _gfn(gfn));\n            act->domid = ld->domain_id;\n            act->mfn = mfn;\n            act->start = 0;\n            act->length = PAGE_SIZE;\n            act->is_sub_page = false;\n            act->trans_domain = rd;\n            act->trans_gref = ref;\n        }\n    }\n\n    if ( op->flags & GNTMAP_device_map )\n        act->pin += (op->flags & GNTMAP_readonly) ?\n            GNTPIN_devr_inc : GNTPIN_devw_inc;\n    if ( op->flags & GNTMAP_host_map )\n        act->pin += (op->flags & GNTMAP_readonly) ?\n            GNTPIN_hstr_inc : GNTPIN_hstw_inc;\n\n    mfn = act->mfn;\n\n    cache_flags = (shah->flags & (GTF_PAT | GTF_PWT | GTF_PCD) );\n\n    active_entry_release(act);\n    grant_read_unlock(rgt);\n\n    /* pg may be set, with a refcount included, from get_paged_frame(). */\n    if ( !pg )\n    {\n        pg = mfn_valid(mfn) ? mfn_to_page(mfn) : NULL;\n        if ( pg )\n            owner = page_get_owner_and_reference(pg);\n    }\n    else\n        owner = page_get_owner(pg);\n\n    if ( owner )\n        refcnt++;\n\n    if ( !pg || (owner == dom_io) )\n    {\n        /* Only needed the reference to confirm dom_io ownership. */\n        if ( pg )\n        {\n            put_page(pg);\n            refcnt--;\n        }\n\n        if ( paging_mode_external(ld) )\n        {\n            gdprintk(XENLOG_WARNING, \"HVM guests can't grant map iomem\\n\");\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n\n        if ( !iomem_access_permitted(rd, mfn_x(mfn), mfn_x(mfn)) )\n        {\n            gdprintk(XENLOG_WARNING,\n                     \"Iomem mapping not permitted %#\"PRI_mfn\" (domain %d)\\n\",\n                     mfn_x(mfn), rd->domain_id);\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n\n        if ( op->flags & GNTMAP_host_map )\n        {\n            rc = create_grant_host_mapping(op->host_addr, mfn, op->flags,\n                                           cache_flags);\n            if ( rc != GNTST_okay )\n                goto undo_out;\n\n            host_map_created = true;\n        }\n    }\n    else if ( owner == rd || (dom_cow && owner == dom_cow) )\n    {\n        if ( (op->flags & GNTMAP_device_map) && !(op->flags & GNTMAP_readonly) )\n        {\n            if ( (owner == dom_cow) ||\n                 !get_page_type(pg, PGT_writable_page) )\n                goto could_not_pin;\n            typecnt++;\n        }\n\n        if ( op->flags & GNTMAP_host_map )\n        {\n            /*\n             * Only need to grab another reference if device_map claimed\n             * the other one.\n             */\n            if ( op->flags & GNTMAP_device_map )\n            {\n                if ( !get_page(pg, rd) )\n                    goto could_not_pin;\n                refcnt++;\n            }\n\n            if ( gnttab_host_mapping_get_page_type(op->flags & GNTMAP_readonly,\n                                                   ld, rd) )\n            {\n                if ( (owner == dom_cow) ||\n                     !get_page_type(pg, PGT_writable_page) )\n                    goto could_not_pin;\n                typecnt++;\n            }\n\n            rc = create_grant_host_mapping(op->host_addr, mfn, op->flags, 0);\n            if ( rc != GNTST_okay )\n                goto undo_out;\n\n            host_map_created = true;\n        }\n    }\n    else\n    {\n    could_not_pin:\n        if ( !rd->is_dying )\n            gdprintk(XENLOG_WARNING, \"Could not pin grant frame %#\"PRI_mfn\"\\n\",\n                     mfn_x(mfn));\n        rc = GNTST_general_error;\n        goto undo_out;\n    }\n\n    need_iommu = gnttab_need_iommu_mapping(ld);\n    if ( need_iommu )\n    {\n        unsigned int kind;\n\n        double_gt_lock(lgt, rgt);\n\n        /*\n         * We're not translated, so we know that dfns and mfns are\n         * the same things, so the IOMMU entry is always 1-to-1.\n         */\n        kind = mapkind(lgt, rd, mfn);\n        if ( !(op->flags & GNTMAP_readonly) &&\n             !(kind & MAPKIND_WRITE) )\n            kind = IOMMUF_readable | IOMMUF_writable;\n        else if ( !kind )\n            kind = IOMMUF_readable;\n        else\n            kind = 0;\n        if ( kind && iommu_legacy_map(ld, _dfn(mfn_x(mfn)), mfn, 0, kind) )\n        {\n            double_gt_unlock(lgt, rgt);\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n    }\n\n    TRACE_1D(TRC_MEM_PAGE_GRANT_MAP, op->dom);\n\n    /*\n     * All maptrack entry users check mt->flags first before using the\n     * other fields so just ensure the flags field is stored last.\n     *\n     * However, if gnttab_need_iommu_mapping() then this would race\n     * with a concurrent mapkind() call (on an unmap, for example)\n     * and a lock is required.\n     */\n    mt = &maptrack_entry(lgt, handle);\n    mt->domid = op->dom;\n    mt->ref   = op->ref;\n    smp_wmb();\n    write_atomic(&mt->flags, op->flags);\n\n    if ( need_iommu )\n        double_gt_unlock(lgt, rgt);\n\n    op->dev_bus_addr = mfn_to_maddr(mfn);\n    op->handle       = handle;\n    op->status       = GNTST_okay;\n\n    rcu_unlock_domain(rd);\n    return;\n\n undo_out:\n    if ( host_map_created )\n    {\n        replace_grant_host_mapping(op->host_addr, mfn, 0, op->flags);\n        gnttab_flush_tlb(ld);\n    }\n\n    while ( typecnt-- )\n        put_page_type(pg);\n\n    while ( refcnt-- )\n        put_page(pg);\n\n    grant_read_lock(rgt);\n\n    act = active_entry_acquire(rgt, op->ref);\n\n    if ( op->flags & GNTMAP_device_map )\n        act->pin -= (op->flags & GNTMAP_readonly) ?\n            GNTPIN_devr_inc : GNTPIN_devw_inc;\n    if ( op->flags & GNTMAP_host_map )\n        act->pin -= (op->flags & GNTMAP_readonly) ?\n            GNTPIN_hstr_inc : GNTPIN_hstw_inc;\n\n unlock_out_clear:\n    if ( !(op->flags & GNTMAP_readonly) &&\n         !(act->pin & (GNTPIN_hstw_mask|GNTPIN_devw_mask)) )\n        clear_flags |= GTF_writing;\n\n    if ( !act->pin )\n        clear_flags |= GTF_reading;\n\n    if ( clear_flags )\n        gnttab_clear_flags(rd, clear_flags, status);\n\n act_release_out:\n    active_entry_release(act);\n\n unlock_out:\n    grant_read_unlock(rgt);\n    op->status = rc;\n    put_maptrack_handle(lgt, handle);\n    rcu_unlock_domain(rd);\n}",
        "description": "An issue was discovered in Xen versions up to 4.13.x, where guest operating system users could trigger a denial of service due to an improper error handling mechanism in the GNTTABOP_map_grant operation. Grant table operations are supposed to return 0 for success and a negative number for errors; however, a coding mistake resulted in one error path returning 1 instead of a negative value. The grant table code in Linux interprets this as a successful operation and continues with incorrectly initialized state. A malicious or buggy guest could manipulate its grant table to exploit this flaw, causing a crash in the Linux-based dom0 or backend domain when a backend domain attempts to map a grant.",
        "commit": "A function within the Xen hypervisor, specifically related to mapping grant references, had its error handling logic inadvertently altered. This change caused the function to return an incorrect status code when a critical operation failed, leading to unexpected behavior in the Linux kernel's network and block device backends. This issue could result in system crashes due to improper handling of guest states."
    },
    {
        "cwe": "CWE-20",
        "func_name": "torvalds/cifs_lookup",
        "score": 0.7845743298530579,
        "func_before": "struct dentry *\ncifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,\n\t    struct nameidata *nd)\n{\n\tint xid;\n\tint rc = 0; /* to get around spurious gcc warning, set to zero here */\n\t__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;\n\t__u16 fileHandle = 0;\n\tbool posix_open = false;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct cifsFileInfo *cfile;\n\tstruct inode *newInode = NULL;\n\tchar *full_path = NULL;\n\tstruct file *filp;\n\n\txid = GetXid();\n\n\tcFYI(1, \"parent inode = 0x%p name is: %s and dentry = 0x%p\",\n\t      parent_dir_inode, direntry->d_name.name, direntry);\n\n\t/* check whether path exists */\n\n\tcifs_sb = CIFS_SB(parent_dir_inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tFreeXid(xid);\n\t\treturn (struct dentry *)tlink;\n\t}\n\tpTcon = tlink_tcon(tlink);\n\n\t/*\n\t * Don't allow the separator character in a path component.\n\t * The VFS will not allow \"/\", but \"\\\" is allowed by posix.\n\t */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {\n\t\tint i;\n\t\tfor (i = 0; i < direntry->d_name.len; i++)\n\t\t\tif (direntry->d_name.name[i] == '\\\\') {\n\t\t\t\tcFYI(1, \"Invalid file name\");\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t}\n\n\t/*\n\t * O_EXCL: optimize away the lookup, but don't hash the dentry. Let\n\t * the VFS handle the create.\n\t */\n\tif (nd && (nd->flags & LOOKUP_EXCL)) {\n\t\td_instantiate(direntry, NULL);\n\t\trc = 0;\n\t\tgoto lookup_out;\n\t}\n\n\t/* can not grab the rename sem here since it would\n\tdeadlock in the cases (beginning of sys_rename itself)\n\tin which we already have the sb rename sem */\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto lookup_out;\n\t}\n\n\tif (direntry->d_inode != NULL) {\n\t\tcFYI(1, \"non-NULL inode in lookup\");\n\t} else {\n\t\tcFYI(1, \"NULL inode in lookup\");\n\t}\n\tcFYI(1, \"Full path: %s inode = 0x%p\", full_path, direntry->d_inode);\n\n\t/* Posix open is only called (at lookup time) for file create now.\n\t * For opens (rather than creates), because we do not know if it\n\t * is a file or directory yet, and current Samba no longer allows\n\t * us to do posix open on dirs, we could end up wasting an open call\n\t * on what turns out to be a dir. For file opens, we wait to call posix\n\t * open till cifs_open.  It could be added here (lookup) in the future\n\t * but the performance tradeoff of the extra network request when EISDIR\n\t * or EACCES is returned would have to be weighed against the 50%\n\t * reduction in network traffic in the other paths.\n\t */\n\tif (pTcon->unix_ext) {\n\t\tif (nd && !(nd->flags & LOOKUP_DIRECTORY) &&\n\t\t     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&\n\t\t     (nd->intent.open.file->f_flags & O_CREAT)) {\n\t\t\trc = cifs_posix_open(full_path, &newInode,\n\t\t\t\t\tparent_dir_inode->i_sb,\n\t\t\t\t\tnd->intent.open.create_mode,\n\t\t\t\t\tnd->intent.open.file->f_flags, &oplock,\n\t\t\t\t\t&fileHandle, xid);\n\t\t\t/*\n\t\t\t * The check below works around a bug in POSIX\n\t\t\t * open in samba versions 3.3.1 and earlier where\n\t\t\t * open could incorrectly fail with invalid parameter.\n\t\t\t * If either that or op not supported returned, follow\n\t\t\t * the normal lookup.\n\t\t\t */\n\t\t\tif ((rc == 0) || (rc == -ENOENT))\n\t\t\t\tposix_open = true;\n\t\t\telse if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))\n\t\t\t\tpTcon->broken_posix_open = true;\n\t\t}\n\t\tif (!posix_open)\n\t\t\trc = cifs_get_inode_info_unix(&newInode, full_path,\n\t\t\t\t\t\tparent_dir_inode->i_sb, xid);\n\t} else\n\t\trc = cifs_get_inode_info(&newInode, full_path, NULL,\n\t\t\t\tparent_dir_inode->i_sb, xid, NULL);\n\n\tif ((rc == 0) && (newInode != NULL)) {\n\t\td_add(direntry, newInode);\n\t\tif (posix_open) {\n\t\t\tfilp = lookup_instantiate_filp(nd, direntry,\n\t\t\t\t\t\t       generic_file_open);\n\t\t\tif (IS_ERR(filp)) {\n\t\t\t\trc = PTR_ERR(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\n\t\t\tcfile = cifs_new_fileinfo(fileHandle, filp, tlink,\n\t\t\t\t\t\t  oplock);\n\t\t\tif (cfile == NULL) {\n\t\t\t\tfput(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t\t}\n\t\t/* since paths are not looked up by component - the parent\n\t\t   directories are presumed to be good here */\n\t\trenew_parental_timestamps(direntry);\n\n\t} else if (rc == -ENOENT) {\n\t\trc = 0;\n\t\tdirentry->d_time = jiffies;\n\t\td_add(direntry, NULL);\n\t/*\tif it was once a directory (but how can we tell?) we could do\n\t\tshrink_dcache_parent(direntry); */\n\t} else if (rc != -EACCES) {\n\t\tcERROR(1, \"Unexpected lookup error %d\", rc);\n\t\t/* We special case check for Access Denied - since that\n\t\tis a common return code */\n\t}\n\nlookup_out:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\tFreeXid(xid);\n\treturn ERR_PTR(rc);\n}",
        "func_after": "struct dentry *\ncifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,\n\t    struct nameidata *nd)\n{\n\tint xid;\n\tint rc = 0; /* to get around spurious gcc warning, set to zero here */\n\t__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;\n\t__u16 fileHandle = 0;\n\tbool posix_open = false;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct cifsFileInfo *cfile;\n\tstruct inode *newInode = NULL;\n\tchar *full_path = NULL;\n\tstruct file *filp;\n\n\txid = GetXid();\n\n\tcFYI(1, \"parent inode = 0x%p name is: %s and dentry = 0x%p\",\n\t      parent_dir_inode, direntry->d_name.name, direntry);\n\n\t/* check whether path exists */\n\n\tcifs_sb = CIFS_SB(parent_dir_inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tFreeXid(xid);\n\t\treturn (struct dentry *)tlink;\n\t}\n\tpTcon = tlink_tcon(tlink);\n\n\t/*\n\t * Don't allow the separator character in a path component.\n\t * The VFS will not allow \"/\", but \"\\\" is allowed by posix.\n\t */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {\n\t\tint i;\n\t\tfor (i = 0; i < direntry->d_name.len; i++)\n\t\t\tif (direntry->d_name.name[i] == '\\\\') {\n\t\t\t\tcFYI(1, \"Invalid file name\");\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t}\n\n\t/*\n\t * O_EXCL: optimize away the lookup, but don't hash the dentry. Let\n\t * the VFS handle the create.\n\t */\n\tif (nd && (nd->flags & LOOKUP_EXCL)) {\n\t\td_instantiate(direntry, NULL);\n\t\trc = 0;\n\t\tgoto lookup_out;\n\t}\n\n\t/* can not grab the rename sem here since it would\n\tdeadlock in the cases (beginning of sys_rename itself)\n\tin which we already have the sb rename sem */\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto lookup_out;\n\t}\n\n\tif (direntry->d_inode != NULL) {\n\t\tcFYI(1, \"non-NULL inode in lookup\");\n\t} else {\n\t\tcFYI(1, \"NULL inode in lookup\");\n\t}\n\tcFYI(1, \"Full path: %s inode = 0x%p\", full_path, direntry->d_inode);\n\n\t/* Posix open is only called (at lookup time) for file create now.\n\t * For opens (rather than creates), because we do not know if it\n\t * is a file or directory yet, and current Samba no longer allows\n\t * us to do posix open on dirs, we could end up wasting an open call\n\t * on what turns out to be a dir. For file opens, we wait to call posix\n\t * open till cifs_open.  It could be added here (lookup) in the future\n\t * but the performance tradeoff of the extra network request when EISDIR\n\t * or EACCES is returned would have to be weighed against the 50%\n\t * reduction in network traffic in the other paths.\n\t */\n\tif (pTcon->unix_ext) {\n\t\tif (nd && !(nd->flags & LOOKUP_DIRECTORY) &&\n\t\t     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&\n\t\t     (nd->intent.open.file->f_flags & O_CREAT)) {\n\t\t\trc = cifs_posix_open(full_path, &newInode,\n\t\t\t\t\tparent_dir_inode->i_sb,\n\t\t\t\t\tnd->intent.open.create_mode,\n\t\t\t\t\tnd->intent.open.file->f_flags, &oplock,\n\t\t\t\t\t&fileHandle, xid);\n\t\t\t/*\n\t\t\t * The check below works around a bug in POSIX\n\t\t\t * open in samba versions 3.3.1 and earlier where\n\t\t\t * open could incorrectly fail with invalid parameter.\n\t\t\t * If either that or op not supported returned, follow\n\t\t\t * the normal lookup.\n\t\t\t */\n\t\t\tswitch (rc) {\n\t\t\tcase 0:\n\t\t\t\t/*\n\t\t\t\t * The server may allow us to open things like\n\t\t\t\t * FIFOs, but the client isn't set up to deal\n\t\t\t\t * with that. If it's not a regular file, just\n\t\t\t\t * close it and proceed as if it were a normal\n\t\t\t\t * lookup.\n\t\t\t\t */\n\t\t\t\tif (newInode && !S_ISREG(newInode->i_mode)) {\n\t\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase -ENOENT:\n\t\t\t\tposix_open = true;\n\t\t\tcase -EOPNOTSUPP:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpTcon->broken_posix_open = true;\n\t\t\t}\n\t\t}\n\t\tif (!posix_open)\n\t\t\trc = cifs_get_inode_info_unix(&newInode, full_path,\n\t\t\t\t\t\tparent_dir_inode->i_sb, xid);\n\t} else\n\t\trc = cifs_get_inode_info(&newInode, full_path, NULL,\n\t\t\t\tparent_dir_inode->i_sb, xid, NULL);\n\n\tif ((rc == 0) && (newInode != NULL)) {\n\t\td_add(direntry, newInode);\n\t\tif (posix_open) {\n\t\t\tfilp = lookup_instantiate_filp(nd, direntry,\n\t\t\t\t\t\t       generic_file_open);\n\t\t\tif (IS_ERR(filp)) {\n\t\t\t\trc = PTR_ERR(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\n\t\t\tcfile = cifs_new_fileinfo(fileHandle, filp, tlink,\n\t\t\t\t\t\t  oplock);\n\t\t\tif (cfile == NULL) {\n\t\t\t\tfput(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t\t}\n\t\t/* since paths are not looked up by component - the parent\n\t\t   directories are presumed to be good here */\n\t\trenew_parental_timestamps(direntry);\n\n\t} else if (rc == -ENOENT) {\n\t\trc = 0;\n\t\tdirentry->d_time = jiffies;\n\t\td_add(direntry, NULL);\n\t/*\tif it was once a directory (but how can we tell?) we could do\n\t\tshrink_dcache_parent(direntry); */\n\t} else if (rc != -EACCES) {\n\t\tcERROR(1, \"Unexpected lookup error %d\", rc);\n\t\t/* We special case check for Access Denied - since that\n\t\tis a common return code */\n\t}\n\nlookup_out:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\tFreeXid(xid);\n\treturn ERR_PTR(rc);\n}",
        "description": "The `cifs_lookup` function in the CIFS directory handling module of the Linux kernel, prior to version 3.2.10, permits local users to trigger a denial of service (OOPS) condition by attempting to access a special file, such as a FIFO.",
        "commit": "The CIFS code attempts to open files during lookup under specific conditions. However, if the file turned out to be a FIFO or another special file type, the open file handle would be leaked, resulting in a dentry reference count mismatch and causing an oops error during unmount. This issue has been resolved by ensuring that the file handle on the server is closed if the file is not a regular file. Additionally, the code has been refactored to use a switch statement instead of a complex if-else structure."
    },
    {
        "cwe": "CWE-787",
        "func_name": "OP-TEE/syscall_obj_generate_key",
        "score": 0.7842671871185303,
        "func_before": "TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that maxKeySize follows restrictions */\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tparams = malloc(sizeof(TEE_Attribute) * param_count);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * We have to do it like this because the parity bits aren't\n\t\t * counted when telling the size of the key in bits.\n\t\t */\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}",
        "func_after": "TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that maxKeySize follows restrictions */\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * We have to do it like this because the parity bits aren't\n\t\t * counted when telling the size of the key in bits.\n\t\t */\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}",
        "description": "Linaro/OP-TEE versions 3.3.0 and earlier are vulnerable to a buffer overflow, which could lead to the execution of arbitrary code within the Trusted Execution Environment (TEE) core (kernel) context. This issue affects the optee_os component. The vulnerability has been addressed in versions 3.4.0 and later.",
        "commit": "It was discovered that there is a risk of heap-based overflow due to insufficient checking for allocation overflow in cryptographic function calls. Without verifying the allocation size, there is a possibility of allocating a buffer that is smaller than expected, which could result in attacker-controlled data being written beyond the buffer's boundaries."
    }
]