[
    {
        "cwe": "CWE-755",
        "func_name": "xen-project/map_grant_ref",
        "score": 0.7891337275505066,
        "func_before": "static void\nmap_grant_ref(\n    struct gnttab_map_grant_ref *op)\n{\n    struct domain *ld, *rd, *owner = NULL;\n    struct grant_table *lgt, *rgt;\n    grant_ref_t ref;\n    grant_handle_t handle;\n    mfn_t mfn;\n    struct page_info *pg = NULL;\n    int            rc = GNTST_okay;\n    unsigned int   cache_flags, clear_flags = 0, refcnt = 0, typecnt = 0;\n    bool           host_map_created = false;\n    struct active_grant_entry *act = NULL;\n    struct grant_mapping *mt;\n    grant_entry_header_t *shah;\n    uint16_t *status;\n    bool_t need_iommu;\n\n    ld = current->domain;\n\n    if ( unlikely((op->flags & (GNTMAP_device_map|GNTMAP_host_map)) == 0) )\n    {\n        gdprintk(XENLOG_INFO, \"Bad flags in grant map op: %x\\n\", op->flags);\n        op->status = GNTST_bad_gntref;\n        return;\n    }\n\n    if ( unlikely(paging_mode_external(ld) &&\n                  (op->flags & (GNTMAP_device_map|GNTMAP_application_map|\n                            GNTMAP_contains_pte))) )\n    {\n        gdprintk(XENLOG_INFO, \"No device mapping in HVM domain\\n\");\n        op->status = GNTST_general_error;\n        return;\n    }\n\n    if ( unlikely((rd = rcu_lock_domain_by_id(op->dom)) == NULL) )\n    {\n        gdprintk(XENLOG_INFO, \"Could not find domain %d\\n\", op->dom);\n        op->status = GNTST_bad_domain;\n        return;\n    }\n\n    rc = xsm_grant_mapref(XSM_HOOK, ld, rd, op->flags);\n    if ( rc )\n    {\n        rcu_unlock_domain(rd);\n        op->status = GNTST_permission_denied;\n        return;\n    }\n\n    lgt = ld->grant_table;\n    handle = get_maptrack_handle(lgt);\n    if ( unlikely(handle == INVALID_MAPTRACK_HANDLE) )\n    {\n        rcu_unlock_domain(rd);\n        gdprintk(XENLOG_INFO, \"Failed to obtain maptrack handle\\n\");\n        op->status = GNTST_no_device_space;\n        return;\n    }\n\n    rgt = rd->grant_table;\n    grant_read_lock(rgt);\n\n    /* Bounds check on the grant ref */\n    ref = op->ref;\n    if ( unlikely(ref >= nr_grant_entries(rgt)))\n        PIN_FAIL(unlock_out, GNTST_bad_gntref, \"Bad ref %#x for d%d\\n\",\n                 ref, rgt->domain->domain_id);\n\n    /* This call also ensures the above check cannot be passed speculatively */\n    shah = shared_entry_header(rgt, ref);\n    act = active_entry_acquire(rgt, ref);\n\n    /* Make sure we do not access memory speculatively */\n    status = evaluate_nospec(rgt->gt_version == 1) ? &shah->flags\n                                                 : &status_entry(rgt, ref);\n\n    /* If already pinned, check the active domid and avoid refcnt overflow. */\n    if ( act->pin &&\n         ((act->domid != ld->domain_id) ||\n          (act->pin & 0x80808080U) != 0 ||\n          (act->is_sub_page)) )\n        PIN_FAIL(act_release_out, GNTST_general_error,\n                 \"Bad domain (%d != %d), or risk of counter overflow %08x, or subpage %d\\n\",\n                 act->domid, ld->domain_id, act->pin, act->is_sub_page);\n\n    if ( !act->pin ||\n         (!(op->flags & GNTMAP_readonly) &&\n          !(act->pin & (GNTPIN_hstw_mask|GNTPIN_devw_mask))) )\n    {\n        if ( (rc = _set_status(shah, status, rd, rgt->gt_version, act,\n                               op->flags & GNTMAP_readonly, 1,\n                               ld->domain_id) != GNTST_okay) )\n            goto act_release_out;\n\n        if ( !act->pin )\n        {\n            unsigned long gfn = evaluate_nospec(rgt->gt_version == 1) ?\n                                shared_entry_v1(rgt, ref).frame :\n                                shared_entry_v2(rgt, ref).full_page.frame;\n\n            rc = get_paged_frame(gfn, &mfn, &pg,\n                                 op->flags & GNTMAP_readonly, rd);\n            if ( rc != GNTST_okay )\n                goto unlock_out_clear;\n            act_set_gfn(act, _gfn(gfn));\n            act->domid = ld->domain_id;\n            act->mfn = mfn;\n            act->start = 0;\n            act->length = PAGE_SIZE;\n            act->is_sub_page = false;\n            act->trans_domain = rd;\n            act->trans_gref = ref;\n        }\n    }\n\n    if ( op->flags & GNTMAP_device_map )\n        act->pin += (op->flags & GNTMAP_readonly) ?\n            GNTPIN_devr_inc : GNTPIN_devw_inc;\n    if ( op->flags & GNTMAP_host_map )\n        act->pin += (op->flags & GNTMAP_readonly) ?\n            GNTPIN_hstr_inc : GNTPIN_hstw_inc;\n\n    mfn = act->mfn;\n\n    cache_flags = (shah->flags & (GTF_PAT | GTF_PWT | GTF_PCD) );\n\n    active_entry_release(act);\n    grant_read_unlock(rgt);\n\n    /* pg may be set, with a refcount included, from get_paged_frame(). */\n    if ( !pg )\n    {\n        pg = mfn_valid(mfn) ? mfn_to_page(mfn) : NULL;\n        if ( pg )\n            owner = page_get_owner_and_reference(pg);\n    }\n    else\n        owner = page_get_owner(pg);\n\n    if ( owner )\n        refcnt++;\n\n    if ( !pg || (owner == dom_io) )\n    {\n        /* Only needed the reference to confirm dom_io ownership. */\n        if ( pg )\n        {\n            put_page(pg);\n            refcnt--;\n        }\n\n        if ( paging_mode_external(ld) )\n        {\n            gdprintk(XENLOG_WARNING, \"HVM guests can't grant map iomem\\n\");\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n\n        if ( !iomem_access_permitted(rd, mfn_x(mfn), mfn_x(mfn)) )\n        {\n            gdprintk(XENLOG_WARNING,\n                     \"Iomem mapping not permitted %#\"PRI_mfn\" (domain %d)\\n\",\n                     mfn_x(mfn), rd->domain_id);\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n\n        if ( op->flags & GNTMAP_host_map )\n        {\n            rc = create_grant_host_mapping(op->host_addr, mfn, op->flags,\n                                           cache_flags);\n            if ( rc != GNTST_okay )\n                goto undo_out;\n\n            host_map_created = true;\n        }\n    }\n    else if ( owner == rd || (dom_cow && owner == dom_cow) )\n    {\n        if ( (op->flags & GNTMAP_device_map) && !(op->flags & GNTMAP_readonly) )\n        {\n            if ( (owner == dom_cow) ||\n                 !get_page_type(pg, PGT_writable_page) )\n                goto could_not_pin;\n            typecnt++;\n        }\n\n        if ( op->flags & GNTMAP_host_map )\n        {\n            /*\n             * Only need to grab another reference if device_map claimed\n             * the other one.\n             */\n            if ( op->flags & GNTMAP_device_map )\n            {\n                if ( !get_page(pg, rd) )\n                    goto could_not_pin;\n                refcnt++;\n            }\n\n            if ( gnttab_host_mapping_get_page_type(op->flags & GNTMAP_readonly,\n                                                   ld, rd) )\n            {\n                if ( (owner == dom_cow) ||\n                     !get_page_type(pg, PGT_writable_page) )\n                    goto could_not_pin;\n                typecnt++;\n            }\n\n            rc = create_grant_host_mapping(op->host_addr, mfn, op->flags, 0);\n            if ( rc != GNTST_okay )\n                goto undo_out;\n\n            host_map_created = true;\n        }\n    }\n    else\n    {\n    could_not_pin:\n        if ( !rd->is_dying )\n            gdprintk(XENLOG_WARNING, \"Could not pin grant frame %#\"PRI_mfn\"\\n\",\n                     mfn_x(mfn));\n        rc = GNTST_general_error;\n        goto undo_out;\n    }\n\n    need_iommu = gnttab_need_iommu_mapping(ld);\n    if ( need_iommu )\n    {\n        unsigned int kind;\n\n        double_gt_lock(lgt, rgt);\n\n        /*\n         * We're not translated, so we know that dfns and mfns are\n         * the same things, so the IOMMU entry is always 1-to-1.\n         */\n        kind = mapkind(lgt, rd, mfn);\n        if ( !(op->flags & GNTMAP_readonly) &&\n             !(kind & MAPKIND_WRITE) )\n            kind = IOMMUF_readable | IOMMUF_writable;\n        else if ( !kind )\n            kind = IOMMUF_readable;\n        else\n            kind = 0;\n        if ( kind && iommu_legacy_map(ld, _dfn(mfn_x(mfn)), mfn, 0, kind) )\n        {\n            double_gt_unlock(lgt, rgt);\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n    }\n\n    TRACE_1D(TRC_MEM_PAGE_GRANT_MAP, op->dom);\n\n    /*\n     * All maptrack entry users check mt->flags first before using the\n     * other fields so just ensure the flags field is stored last.\n     *\n     * However, if gnttab_need_iommu_mapping() then this would race\n     * with a concurrent mapkind() call (on an unmap, for example)\n     * and a lock is required.\n     */\n    mt = &maptrack_entry(lgt, handle);\n    mt->domid = op->dom;\n    mt->ref   = op->ref;\n    smp_wmb();\n    write_atomic(&mt->flags, op->flags);\n\n    if ( need_iommu )\n        double_gt_unlock(lgt, rgt);\n\n    op->dev_bus_addr = mfn_to_maddr(mfn);\n    op->handle       = handle;\n    op->status       = GNTST_okay;\n\n    rcu_unlock_domain(rd);\n    return;\n\n undo_out:\n    if ( host_map_created )\n    {\n        replace_grant_host_mapping(op->host_addr, mfn, 0, op->flags);\n        gnttab_flush_tlb(ld);\n    }\n\n    while ( typecnt-- )\n        put_page_type(pg);\n\n    while ( refcnt-- )\n        put_page(pg);\n\n    grant_read_lock(rgt);\n\n    act = active_entry_acquire(rgt, op->ref);\n\n    if ( op->flags & GNTMAP_device_map )\n        act->pin -= (op->flags & GNTMAP_readonly) ?\n            GNTPIN_devr_inc : GNTPIN_devw_inc;\n    if ( op->flags & GNTMAP_host_map )\n        act->pin -= (op->flags & GNTMAP_readonly) ?\n            GNTPIN_hstr_inc : GNTPIN_hstw_inc;\n\n unlock_out_clear:\n    if ( !(op->flags & GNTMAP_readonly) &&\n         !(act->pin & (GNTPIN_hstw_mask|GNTPIN_devw_mask)) )\n        clear_flags |= GTF_writing;\n\n    if ( !act->pin )\n        clear_flags |= GTF_reading;\n\n    if ( clear_flags )\n        gnttab_clear_flags(rd, clear_flags, status);\n\n act_release_out:\n    active_entry_release(act);\n\n unlock_out:\n    grant_read_unlock(rgt);\n    op->status = rc;\n    put_maptrack_handle(lgt, handle);\n    rcu_unlock_domain(rd);\n}",
        "func_after": "static void\nmap_grant_ref(\n    struct gnttab_map_grant_ref *op)\n{\n    struct domain *ld, *rd, *owner = NULL;\n    struct grant_table *lgt, *rgt;\n    grant_ref_t ref;\n    grant_handle_t handle;\n    mfn_t mfn;\n    struct page_info *pg = NULL;\n    int            rc = GNTST_okay;\n    unsigned int   cache_flags, clear_flags = 0, refcnt = 0, typecnt = 0;\n    bool           host_map_created = false;\n    struct active_grant_entry *act = NULL;\n    struct grant_mapping *mt;\n    grant_entry_header_t *shah;\n    uint16_t *status;\n    bool_t need_iommu;\n\n    ld = current->domain;\n\n    if ( unlikely((op->flags & (GNTMAP_device_map|GNTMAP_host_map)) == 0) )\n    {\n        gdprintk(XENLOG_INFO, \"Bad flags in grant map op: %x\\n\", op->flags);\n        op->status = GNTST_bad_gntref;\n        return;\n    }\n\n    if ( unlikely(paging_mode_external(ld) &&\n                  (op->flags & (GNTMAP_device_map|GNTMAP_application_map|\n                            GNTMAP_contains_pte))) )\n    {\n        gdprintk(XENLOG_INFO, \"No device mapping in HVM domain\\n\");\n        op->status = GNTST_general_error;\n        return;\n    }\n\n    if ( unlikely((rd = rcu_lock_domain_by_id(op->dom)) == NULL) )\n    {\n        gdprintk(XENLOG_INFO, \"Could not find domain %d\\n\", op->dom);\n        op->status = GNTST_bad_domain;\n        return;\n    }\n\n    rc = xsm_grant_mapref(XSM_HOOK, ld, rd, op->flags);\n    if ( rc )\n    {\n        rcu_unlock_domain(rd);\n        op->status = GNTST_permission_denied;\n        return;\n    }\n\n    lgt = ld->grant_table;\n    handle = get_maptrack_handle(lgt);\n    if ( unlikely(handle == INVALID_MAPTRACK_HANDLE) )\n    {\n        rcu_unlock_domain(rd);\n        gdprintk(XENLOG_INFO, \"Failed to obtain maptrack handle\\n\");\n        op->status = GNTST_no_device_space;\n        return;\n    }\n\n    rgt = rd->grant_table;\n    grant_read_lock(rgt);\n\n    /* Bounds check on the grant ref */\n    ref = op->ref;\n    if ( unlikely(ref >= nr_grant_entries(rgt)))\n        PIN_FAIL(unlock_out, GNTST_bad_gntref, \"Bad ref %#x for d%d\\n\",\n                 ref, rgt->domain->domain_id);\n\n    /* This call also ensures the above check cannot be passed speculatively */\n    shah = shared_entry_header(rgt, ref);\n    act = active_entry_acquire(rgt, ref);\n\n    /* Make sure we do not access memory speculatively */\n    status = evaluate_nospec(rgt->gt_version == 1) ? &shah->flags\n                                                 : &status_entry(rgt, ref);\n\n    /* If already pinned, check the active domid and avoid refcnt overflow. */\n    if ( act->pin &&\n         ((act->domid != ld->domain_id) ||\n          (act->pin & 0x80808080U) != 0 ||\n          (act->is_sub_page)) )\n        PIN_FAIL(act_release_out, GNTST_general_error,\n                 \"Bad domain (%d != %d), or risk of counter overflow %08x, or subpage %d\\n\",\n                 act->domid, ld->domain_id, act->pin, act->is_sub_page);\n\n    if ( !act->pin ||\n         (!(op->flags & GNTMAP_readonly) &&\n          !(act->pin & (GNTPIN_hstw_mask|GNTPIN_devw_mask))) )\n    {\n        if ( (rc = _set_status(shah, status, rd, rgt->gt_version, act,\n                               op->flags & GNTMAP_readonly, 1,\n                               ld->domain_id)) != GNTST_okay )\n            goto act_release_out;\n\n        if ( !act->pin )\n        {\n            unsigned long gfn = evaluate_nospec(rgt->gt_version == 1) ?\n                                shared_entry_v1(rgt, ref).frame :\n                                shared_entry_v2(rgt, ref).full_page.frame;\n\n            rc = get_paged_frame(gfn, &mfn, &pg,\n                                 op->flags & GNTMAP_readonly, rd);\n            if ( rc != GNTST_okay )\n                goto unlock_out_clear;\n            act_set_gfn(act, _gfn(gfn));\n            act->domid = ld->domain_id;\n            act->mfn = mfn;\n            act->start = 0;\n            act->length = PAGE_SIZE;\n            act->is_sub_page = false;\n            act->trans_domain = rd;\n            act->trans_gref = ref;\n        }\n    }\n\n    if ( op->flags & GNTMAP_device_map )\n        act->pin += (op->flags & GNTMAP_readonly) ?\n            GNTPIN_devr_inc : GNTPIN_devw_inc;\n    if ( op->flags & GNTMAP_host_map )\n        act->pin += (op->flags & GNTMAP_readonly) ?\n            GNTPIN_hstr_inc : GNTPIN_hstw_inc;\n\n    mfn = act->mfn;\n\n    cache_flags = (shah->flags & (GTF_PAT | GTF_PWT | GTF_PCD) );\n\n    active_entry_release(act);\n    grant_read_unlock(rgt);\n\n    /* pg may be set, with a refcount included, from get_paged_frame(). */\n    if ( !pg )\n    {\n        pg = mfn_valid(mfn) ? mfn_to_page(mfn) : NULL;\n        if ( pg )\n            owner = page_get_owner_and_reference(pg);\n    }\n    else\n        owner = page_get_owner(pg);\n\n    if ( owner )\n        refcnt++;\n\n    if ( !pg || (owner == dom_io) )\n    {\n        /* Only needed the reference to confirm dom_io ownership. */\n        if ( pg )\n        {\n            put_page(pg);\n            refcnt--;\n        }\n\n        if ( paging_mode_external(ld) )\n        {\n            gdprintk(XENLOG_WARNING, \"HVM guests can't grant map iomem\\n\");\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n\n        if ( !iomem_access_permitted(rd, mfn_x(mfn), mfn_x(mfn)) )\n        {\n            gdprintk(XENLOG_WARNING,\n                     \"Iomem mapping not permitted %#\"PRI_mfn\" (domain %d)\\n\",\n                     mfn_x(mfn), rd->domain_id);\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n\n        if ( op->flags & GNTMAP_host_map )\n        {\n            rc = create_grant_host_mapping(op->host_addr, mfn, op->flags,\n                                           cache_flags);\n            if ( rc != GNTST_okay )\n                goto undo_out;\n\n            host_map_created = true;\n        }\n    }\n    else if ( owner == rd || (dom_cow && owner == dom_cow) )\n    {\n        if ( (op->flags & GNTMAP_device_map) && !(op->flags & GNTMAP_readonly) )\n        {\n            if ( (owner == dom_cow) ||\n                 !get_page_type(pg, PGT_writable_page) )\n                goto could_not_pin;\n            typecnt++;\n        }\n\n        if ( op->flags & GNTMAP_host_map )\n        {\n            /*\n             * Only need to grab another reference if device_map claimed\n             * the other one.\n             */\n            if ( op->flags & GNTMAP_device_map )\n            {\n                if ( !get_page(pg, rd) )\n                    goto could_not_pin;\n                refcnt++;\n            }\n\n            if ( gnttab_host_mapping_get_page_type(op->flags & GNTMAP_readonly,\n                                                   ld, rd) )\n            {\n                if ( (owner == dom_cow) ||\n                     !get_page_type(pg, PGT_writable_page) )\n                    goto could_not_pin;\n                typecnt++;\n            }\n\n            rc = create_grant_host_mapping(op->host_addr, mfn, op->flags, 0);\n            if ( rc != GNTST_okay )\n                goto undo_out;\n\n            host_map_created = true;\n        }\n    }\n    else\n    {\n    could_not_pin:\n        if ( !rd->is_dying )\n            gdprintk(XENLOG_WARNING, \"Could not pin grant frame %#\"PRI_mfn\"\\n\",\n                     mfn_x(mfn));\n        rc = GNTST_general_error;\n        goto undo_out;\n    }\n\n    need_iommu = gnttab_need_iommu_mapping(ld);\n    if ( need_iommu )\n    {\n        unsigned int kind;\n\n        double_gt_lock(lgt, rgt);\n\n        /*\n         * We're not translated, so we know that dfns and mfns are\n         * the same things, so the IOMMU entry is always 1-to-1.\n         */\n        kind = mapkind(lgt, rd, mfn);\n        if ( !(op->flags & GNTMAP_readonly) &&\n             !(kind & MAPKIND_WRITE) )\n            kind = IOMMUF_readable | IOMMUF_writable;\n        else if ( !kind )\n            kind = IOMMUF_readable;\n        else\n            kind = 0;\n        if ( kind && iommu_legacy_map(ld, _dfn(mfn_x(mfn)), mfn, 0, kind) )\n        {\n            double_gt_unlock(lgt, rgt);\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n    }\n\n    TRACE_1D(TRC_MEM_PAGE_GRANT_MAP, op->dom);\n\n    /*\n     * All maptrack entry users check mt->flags first before using the\n     * other fields so just ensure the flags field is stored last.\n     *\n     * However, if gnttab_need_iommu_mapping() then this would race\n     * with a concurrent mapkind() call (on an unmap, for example)\n     * and a lock is required.\n     */\n    mt = &maptrack_entry(lgt, handle);\n    mt->domid = op->dom;\n    mt->ref   = op->ref;\n    smp_wmb();\n    write_atomic(&mt->flags, op->flags);\n\n    if ( need_iommu )\n        double_gt_unlock(lgt, rgt);\n\n    op->dev_bus_addr = mfn_to_maddr(mfn);\n    op->handle       = handle;\n    op->status       = GNTST_okay;\n\n    rcu_unlock_domain(rd);\n    return;\n\n undo_out:\n    if ( host_map_created )\n    {\n        replace_grant_host_mapping(op->host_addr, mfn, 0, op->flags);\n        gnttab_flush_tlb(ld);\n    }\n\n    while ( typecnt-- )\n        put_page_type(pg);\n\n    while ( refcnt-- )\n        put_page(pg);\n\n    grant_read_lock(rgt);\n\n    act = active_entry_acquire(rgt, op->ref);\n\n    if ( op->flags & GNTMAP_device_map )\n        act->pin -= (op->flags & GNTMAP_readonly) ?\n            GNTPIN_devr_inc : GNTPIN_devw_inc;\n    if ( op->flags & GNTMAP_host_map )\n        act->pin -= (op->flags & GNTMAP_readonly) ?\n            GNTPIN_hstr_inc : GNTPIN_hstw_inc;\n\n unlock_out_clear:\n    if ( !(op->flags & GNTMAP_readonly) &&\n         !(act->pin & (GNTPIN_hstw_mask|GNTPIN_devw_mask)) )\n        clear_flags |= GTF_writing;\n\n    if ( !act->pin )\n        clear_flags |= GTF_reading;\n\n    if ( clear_flags )\n        gnttab_clear_flags(rd, clear_flags, status);\n\n act_release_out:\n    active_entry_release(act);\n\n unlock_out:\n    grant_read_unlock(rgt);\n    op->status = rc;\n    put_maptrack_handle(lgt, handle);\n    rcu_unlock_domain(rd);\n}",
        "description": "An issue was discovered in Xen versions up to 4.13.x, where guest operating system users could trigger a denial of service due to an improper error handling mechanism in the GNTTABOP_map_grant operation. Grant table operations are supposed to return 0 for success and a negative number for errors; however, a coding mistake resulted in one error path returning 1 instead of a negative value. The grant table code in Linux interprets this as a successful operation and continues with incorrectly initialized state. A malicious or buggy guest could manipulate its grant table to exploit this flaw, causing a crash in the Linux-based dom0 or backend domain when a backend domain attempts to map a grant.",
        "commit": "A function within the Xen hypervisor, specifically related to mapping grant references, had its error handling logic inadvertently altered. This change caused the function to return an incorrect status code when a critical operation failed, leading to unexpected behavior in the Linux kernel's network and block device backends. This issue could result in system crashes due to improper handling of guest states."
    },
    {
        "cwe": "CWE-476",
        "func_name": "ImageMagick/LoadOpenCLDevices",
        "score": 0.7887461185455322,
        "func_before": "static void LoadOpenCLDevices(MagickCLEnv clEnv)\n{\n  cl_context_properties\n    properties[3];\n\n  cl_device_id\n    *devices;\n\n  cl_int\n    status;\n\n  cl_platform_id\n    *platforms;\n\n  cl_uint\n    i,\n    j,\n    next,\n    number_devices,\n    number_platforms;\n\n  size_t\n    length;\n\n  number_platforms=0;\n  if (openCL_library->clGetPlatformIDs(0,NULL,&number_platforms) != CL_SUCCESS)\n    return;\n  if (number_platforms == 0)\n    return;\n  platforms=(cl_platform_id *) AcquireMagickMemory(number_platforms*\n    sizeof(cl_platform_id));\n  if (platforms == (cl_platform_id *) NULL)\n    return;\n  if (openCL_library->clGetPlatformIDs(number_platforms,platforms,NULL) != CL_SUCCESS)\n    {\n       platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n       return;\n    }\n  for (i = 0; i < number_platforms; i++)\n  {\n    number_devices=GetOpenCLDeviceCount(clEnv,platforms[i]);\n    if (number_devices == 0)\n      platforms[i]=(cl_platform_id) NULL;\n    else\n      clEnv->number_devices+=number_devices;\n  }\n  if (clEnv->number_devices == 0)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  clEnv->devices=(MagickCLDevice *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(MagickCLDevice));\n  if (clEnv->devices == (MagickCLDevice *) NULL)\n    {\n      RelinquishMagickCLDevices(clEnv);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  (void) ResetMagickMemory(clEnv->devices,0,clEnv->number_devices*\n    sizeof(MagickCLDevice));\n  devices=(cl_device_id *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(cl_device_id));\n  if (devices == (cl_device_id *) NULL)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  clEnv->number_contexts=(size_t) number_platforms;\n  clEnv->contexts=(cl_context *) AcquireQuantumMemory(clEnv->number_contexts,\n    sizeof(cl_context));\n  if (clEnv->contexts == (cl_context *) NULL)\n    {\n      devices=(cl_device_id *) RelinquishMagickMemory(devices);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  next=0;\n  for (i = 0; i < number_platforms; i++)\n  {\n    if (platforms[i] == (cl_platform_id) NULL)\n      continue;\n\n    status=clEnv->library->clGetDeviceIDs(platforms[i],CL_DEVICE_TYPE_CPU | \n      CL_DEVICE_TYPE_GPU,(cl_uint) clEnv->number_devices,devices,&number_devices);\n    if (status != CL_SUCCESS)\n      continue;\n\n    properties[0]=CL_CONTEXT_PLATFORM;\n    properties[1]=(cl_context_properties) platforms[i];\n    properties[2]=0;\n    clEnv->contexts[i]=openCL_library->clCreateContext(properties,number_devices,\n      devices,NULL,NULL,&status);\n    if (status != CL_SUCCESS)\n      continue;\n\n    for (j = 0; j < number_devices; j++,next++)\n    {\n      MagickCLDevice\n        device;\n\n      device=AcquireMagickCLDevice();\n      if (device == (MagickCLDevice) NULL)\n        break;\n\n      device->context=clEnv->contexts[i];\n      device->deviceID=devices[j];\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,0,NULL,\n        &length);\n      device->platform_name=AcquireQuantumMemory(length,\n        sizeof(*device->platform_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,length,\n        device->platform_name,NULL);\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,0,NULL,\n        &length);\n      device->vendor_name=AcquireQuantumMemory(length,\n        sizeof(*device->vendor_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,length,\n        device->vendor_name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,0,NULL,\n        &length);\n      device->name=AcquireQuantumMemory(length,sizeof(*device->name));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,length,\n        device->name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,0,NULL,\n        &length);\n      device->version=AcquireQuantumMemory(length,sizeof(*device->version));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,length,\n        device->version,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_CLOCK_FREQUENCY,\n        sizeof(cl_uint),&device->max_clock_frequency,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_COMPUTE_UNITS,\n        sizeof(cl_uint),&device->max_compute_units,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_TYPE,\n        sizeof(cl_device_type),&device->type,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_LOCAL_MEM_SIZE,\n        sizeof(cl_ulong),&device->local_memory_size,NULL);\n\n      clEnv->devices[next]=device;\n    }\n  }\n  if (next != clEnv->number_devices)\n    RelinquishMagickCLDevices(clEnv);\n  platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n  devices=(cl_device_id *) RelinquishMagickMemory(devices);\n}",
        "func_after": "static void LoadOpenCLDevices(MagickCLEnv clEnv)\n{\n  cl_context_properties\n    properties[3];\n\n  cl_device_id\n    *devices;\n\n  cl_int\n    status;\n\n  cl_platform_id\n    *platforms;\n\n  cl_uint\n    i,\n    j,\n    next,\n    number_devices,\n    number_platforms;\n\n  size_t\n    length;\n\n  number_platforms=0;\n  if (openCL_library->clGetPlatformIDs(0,NULL,&number_platforms) != CL_SUCCESS)\n    return;\n  if (number_platforms == 0)\n    return;\n  platforms=(cl_platform_id *) AcquireMagickMemory(number_platforms*\n    sizeof(cl_platform_id));\n  if (platforms == (cl_platform_id *) NULL)\n    return;\n  if (openCL_library->clGetPlatformIDs(number_platforms,platforms,NULL) != CL_SUCCESS)\n    {\n       platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n       return;\n    }\n  for (i = 0; i < number_platforms; i++)\n  {\n    number_devices=GetOpenCLDeviceCount(clEnv,platforms[i]);\n    if (number_devices == 0)\n      platforms[i]=(cl_platform_id) NULL;\n    else\n      clEnv->number_devices+=number_devices;\n  }\n  if (clEnv->number_devices == 0)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  clEnv->devices=(MagickCLDevice *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(MagickCLDevice));\n  if (clEnv->devices == (MagickCLDevice *) NULL)\n    {\n      RelinquishMagickCLDevices(clEnv);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  (void) ResetMagickMemory(clEnv->devices,0,clEnv->number_devices*\n    sizeof(MagickCLDevice));\n  devices=(cl_device_id *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(cl_device_id));\n  if (devices == (cl_device_id *) NULL)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  clEnv->number_contexts=(size_t) number_platforms;\n  clEnv->contexts=(cl_context *) AcquireQuantumMemory(clEnv->number_contexts,\n    sizeof(cl_context));\n  if (clEnv->contexts == (cl_context *) NULL)\n    {\n      devices=(cl_device_id *) RelinquishMagickMemory(devices);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  next=0;\n  for (i = 0; i < number_platforms; i++)\n  {\n    if (platforms[i] == (cl_platform_id) NULL)\n      continue;\n\n    status=clEnv->library->clGetDeviceIDs(platforms[i],CL_DEVICE_TYPE_CPU | \n      CL_DEVICE_TYPE_GPU,(cl_uint) clEnv->number_devices,devices,&number_devices);\n    if (status != CL_SUCCESS)\n      continue;\n\n    properties[0]=CL_CONTEXT_PLATFORM;\n    properties[1]=(cl_context_properties) platforms[i];\n    properties[2]=0;\n    clEnv->contexts[i]=openCL_library->clCreateContext(properties,number_devices,\n      devices,NULL,NULL,&status);\n    if (status != CL_SUCCESS)\n      continue;\n\n    for (j = 0; j < number_devices; j++,next++)\n    {\n      MagickCLDevice\n        device;\n\n      device=AcquireMagickCLDevice();\n      if (device == (MagickCLDevice) NULL)\n        break;\n\n      device->context=clEnv->contexts[i];\n      device->deviceID=devices[j];\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,0,NULL,\n        &length);\n      device->platform_name=AcquireCriticalMemory(length*\n        sizeof(*device->platform_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,length,\n        device->platform_name,NULL);\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,0,NULL,\n        &length);\n      device->vendor_name=AcquireQuantumMemory(length,\n        sizeof(*device->vendor_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,length,\n        device->vendor_name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,0,NULL,\n        &length);\n      device->name=AcquireQuantumMemory(length,sizeof(*device->name));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,length,\n        device->name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,0,NULL,\n        &length);\n      device->version=AcquireQuantumMemory(length,sizeof(*device->version));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,length,\n        device->version,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_CLOCK_FREQUENCY,\n        sizeof(cl_uint),&device->max_clock_frequency,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_COMPUTE_UNITS,\n        sizeof(cl_uint),&device->max_compute_units,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_TYPE,\n        sizeof(cl_device_type),&device->type,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_LOCAL_MEM_SIZE,\n        sizeof(cl_ulong),&device->local_memory_size,NULL);\n\n      clEnv->devices[next]=device;\n    }\n  }\n  if (next != clEnv->number_devices)\n    RelinquishMagickCLDevices(clEnv);\n  platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n  devices=(cl_device_id *) RelinquishMagickMemory(devices);\n}",
        "description": "An issue was discovered in ImageMagick where a NULL pointer dereference vulnerability exists in the function responsible for loading OpenCL devices. This flaw allows attackers to trigger a denial of service through the use of a specially crafted file.",
        "commit": "It was discovered that ImageMagick, a popular image processing library, contains a vulnerability related to improper handling of certain image formats, potentially leading to buffer overflows or other memory corruption issues."
    },
    {
        "cwe": "CWE-404",
        "func_name": "wireshark/dissect_iscsi",
        "score": 0.780991792678833,
        "func_before": "static int\ndissect_iscsi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean check_port) {\n    /* Set up structures needed to add the protocol subtree and manage it */\n    guint offset = 0;\n    guint32 available_bytes = tvb_captured_length(tvb);\n    int digestsActive = 1;\n    conversation_t *conversation = NULL;\n    iscsi_session_t *iscsi_session=NULL;\n    guint8 opcode, tmpbyte;\n\n    if (available_bytes < 48) {\n        /* heuristic already rejected the packet if size < 48,\n           assume it's an iscsi packet with a segmented header */\n        pinfo->desegment_offset = offset;\n        pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\n        return -1;\n    }\n\n    opcode = tvb_get_guint8(tvb, offset + 0);\n    opcode &= OPCODE_MASK;\n\n    /* heuristics to verify that the packet looks sane.   the heuristics\n     * are based on the RFC version of iscsi.\n     * (we should retire support for older iscsi versions in wireshark)\n     *      -- ronnie s\n     */\n    /* opcode must be any of the ones from the standard\n     * also check the header that it looks \"sane\"\n     * all reserved or undefined bits in iscsi must be set to zero.\n     */\n    switch(opcode){\n    case ISCSI_OPCODE_NOP_IN:\n        /* top two bits of byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2 and 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_NOP_OUT:\n        /* top bit of byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2 and 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        /* assume ITT and TTT must always be non NULL (ok they can be NULL\n         * from time to time but it usually means we are in the middle\n         * of a zeroed datablock).\n         */\n        if(!tvb_get_letohl(tvb,offset+16) || !tvb_get_letohl(tvb,offset+20)){\n            return 0;\n        }\n        /* all reserved bytes between 32 - 47 must be null */\n        if(tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGIN_COMMAND:\n        /* top two bits in byte 0 must be 0x40 */\n        if((tvb_get_guint8(tvb, offset+0)&0xc0)!=0x40){\n\n            return 0;\n        }\n        /* both the T and C bits can not be set\n         * and the two reserved bits in byte 1 must be 0\n         */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        switch(tmpbyte&0xf0){\n        case 0x80:\n        case 0x40:\n        case 0x00:\n            break;\n        default:\n            return 0;\n        }\n        /* CSG and NSG must not be 2 */\n        if(((tmpbyte & 0x03) == 0x02)\n           || ((tmpbyte & 0x0c) == 0x08)) {\n            return 0;\n        }\n        /* if T bit is set NSG must not be 0 */\n        if(tmpbyte&0x80){\n            if(!(tmpbyte&0x03)){\n                return 0;\n            }\n        }\n        /* should we test that datasegmentlen is non zero? */\n        break;\n    case ISCSI_OPCODE_LOGIN_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n\n            return 0;\n        }\n        /* both the T and C bits can not be set\n         * and the two reserved bits in byte 1 must be 0\n         */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        switch(tmpbyte&0xf0){\n        case 0x80:\n        case 0x40:\n        case 0x00:\n            break;\n        default:\n            return 0;\n        }\n        /* CSG and NSG must not be 2 */\n        if(((tmpbyte & 0x03) == 0x02)\n           || ((tmpbyte & 0x0c) == 0x08)) {\n            return 0;\n        }\n        /* if T bit is set NSG must not be 0 */\n        if(tmpbyte&0x80){\n            if(!(tmpbyte&0x03)){\n                return 0;\n            }\n        }\n        /* the 32bit words at offsets 20, 40, 44 must be zero */\n        if(tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the two bytes at offset 38 must be zero */\n        if(tvb_get_letohs(tvb,offset+38)){\n            return 0;\n        }\n        /* should we test that datasegmentlen is non zero unless we just\n         * entered full featured phase?\n         */\n        break;\n    case ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* top bit in byte 1 must be set */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* Function must be known */\n        if(!try_val_to_str(tmpbyte&0x7f, iscsi_task_management_functions)){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl must be null */\n        if(tvb_get_letohl(tvb,offset+4)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* response must be 0-6 or 255 */\n        tmpbyte=tvb_get_guint8(tvb,offset+2);\n        if(tmpbyte>6 && tmpbyte<255){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb,offset+3)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 20, 36\n         * 40, 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGOUT_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* top bit in byte 1 must be set */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* Reason code must be known */\n        if(!try_val_to_str(tmpbyte&0x7f, iscsi_logout_reasons)){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 32, 36\n         * 40, 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SNACK_REQUEST:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* top 4 bits in byte 1 must be 0x80 */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if((tmpbyte&0xf0)!=0x80){\n            return 0;\n        }\n        /* type must be known */\n        if(!try_val_to_str(tmpbyte&0x0f, iscsi_snack_types)){\n            return 0;\n        }\n        /* for status/snack and datack itt must be 0xffffffff\n         * for rdata/snack ttt must not be 0 or 0xffffffff\n         */\n        switch(tmpbyte&0x0f){\n        case 1:\n        case 2:\n            if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n                return 0;\n            }\n            break;\n        case 3:\n            if(tvb_get_letohl(tvb,offset+20)==0xffffffff){\n                return 0;\n            }\n            if(tvb_get_letohl(tvb,offset+20)==0){\n                return 0;\n            }\n            break;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 24, 32, 36\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+24)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)){\n            return 0;\n        }\n\n        break;\n    case ISCSI_OPCODE_R2T:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl must be null */\n        if(tvb_get_letohl(tvb,offset+4)){\n            return 0;\n        }\n        /* desired data transfer length must not be null */\n        if(!tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_REJECT:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* reason must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_reject_reasons)){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        /* the 32bit words at offsets 8, 12, 20, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the 32bit word at 16 must be 0xffffffff */\n        if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TEXT_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* one of the F and C bits must be set but not both\n         * low 6 bits in byte 1 must be 0\n         */\n        switch(tvb_get_guint8(tvb,offset+1)){\n        case 0x80:\n        case 0x40:\n            break;\n        default:\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 32, 36, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TEXT_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* one of the F and C bits must be set but not both\n         * low 6 bits in byte 1 must be 0\n         */\n        switch(tvb_get_guint8(tvb,offset+1)){\n        case 0x80:\n        case 0x40:\n            break;\n        default:\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 36, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* reserved bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb, offset+1)&0x18){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* if expected data transfer length is set, W and/or R have to be set */\n        if(tvb_get_ntohl(tvb,offset+20)){\n            if(!(tvb_get_guint8(tvb, offset+1)&0x60)){\n                return 0;\n            }\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* top bit in byte 1 must be 1 */\n        tmpbyte=tvb_get_guint8(tvb,offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* the reserved bits in byte 1 must be 0 */\n        if(tmpbyte&0x61){\n            return 0;\n        }\n        /* status must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+3), scsi_status_val)){\n            return 0;\n        }\n        /* the 32bit words at offsets 8, 12\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_ASYNC_MESSAGE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 20, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the 32bit word at 16 must be 0xffffffff */\n        if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGOUT_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* response must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_logout_response)){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb,offset+3)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 20, 36\n         * 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_DATA_OUT:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* low 7 bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb,offset+1)&0x7f){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 24, 32, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+24)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_DATA_IN:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* reserved bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb,offset+1)&0x38){\n            return 0;\n        }\n        /* byte 2 must be reserved */\n        if(tvb_get_guint8(tvb,offset+2)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I0:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I1:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I2:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T0:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T1:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T2:\n        break;\n    default:\n        return 0;\n    } /* end of heuristics check */\n\n\n    /* process multiple iSCSI PDUs per packet */\n    while(available_bytes >= 48 || (iscsi_desegment && available_bytes >= 8)) {\n        const char *opcode_str = NULL;\n        guint32 data_segment_len;\n        guint32 pduLen = 48;\n        guint8 secondPduByte = tvb_get_guint8(tvb, offset + 1);\n        int badPdu = FALSE;\n        guint8 ahsLen=0;\n        guint32 data_segment_offset, data_segment_len_padded;\n\n        /* mask out any extra bits in the opcode byte */\n        opcode = tvb_get_guint8(tvb, offset + 0);\n        opcode &= OPCODE_MASK;\n\n        opcode_str = try_val_to_str(opcode, iscsi_opcodes);\n        if(opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION ||\n           opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\n           opcode == ISCSI_OPCODE_R2T ||\n           opcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\n           opcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\n           opcode == ISCSI_OPCODE_SNACK_REQUEST)\n            data_segment_len = 0;\n        else\n            data_segment_len = tvb_get_ntohl(tvb, offset + 4) & 0x00ffffff;\n\n        if(opcode_str == NULL) {\n            badPdu = TRUE;\n        }\n\n\n        if(!badPdu && check_port) {\n            badPdu = TRUE;\n            if ((opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->srcport)) {\n                badPdu = FALSE;\n            }\n            if (!(opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->destport)) {\n                badPdu = FALSE;\n            }\n            if ((opcode & TARGET_OPCODE_BIT) && pinfo->srcport == iscsi_system_port) {\n                badPdu = FALSE;\n            }\n            if (!(opcode & TARGET_OPCODE_BIT) && pinfo->destport == iscsi_system_port) {\n                badPdu = FALSE;\n            }\n        }\n\n        if(!badPdu && enable_bogosity_filter) {\n            /* try and distinguish between data and real headers */\n            if(data_segment_len > bogus_pdu_data_length_threshold) {\n                badPdu = TRUE;\n            }\n            else if(demand_good_f_bit &&\n                    !(secondPduByte & 0x80) &&\n                    (opcode == ISCSI_OPCODE_NOP_OUT ||\n                     opcode == ISCSI_OPCODE_NOP_IN ||\n                     opcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\n                     opcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\n                     opcode == ISCSI_OPCODE_SCSI_RESPONSE ||\n                     opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\n                     opcode == ISCSI_OPCODE_R2T ||\n                     opcode == ISCSI_OPCODE_ASYNC_MESSAGE ||\n                     opcode == ISCSI_OPCODE_SNACK_REQUEST ||\n                     opcode == ISCSI_OPCODE_REJECT)) {\n                badPdu = TRUE;\n            } else if(opcode==ISCSI_OPCODE_NOP_OUT) {\n                /* TransferTag for NOP-Out should either be -1 or\n                   the tag value we want for a response.\n                   Assume 0 means we are just inside a big all zero\n                   datablock.\n                */\n                if(tvb_get_ntohl(tvb, offset+20)==0){\n                    badPdu = TRUE;\n                }\n            }\n        }\n\n        if(badPdu) {\n            return offset;\n        }\n\n        if(opcode == ISCSI_OPCODE_LOGIN_COMMAND ||\n           opcode == ISCSI_OPCODE_LOGIN_RESPONSE) {\n            if(iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT08) {\n                if((secondPduByte & CSG_MASK) < ISCSI_CSG_OPERATIONAL_NEGOTIATION) {\n                    /* digests are not yet turned on */\n                    digestsActive = 0;\n                }\n            } else {\n                digestsActive = 0;\n            }\n        }\n\n        if(opcode == ISCSI_OPCODE_SCSI_COMMAND) {\n            /* ahsLen */\n            ahsLen = tvb_get_guint8(tvb, offset + 4);\n            pduLen += ahsLen * 4;\n        }\n\n        data_segment_offset = pduLen;\n        data_segment_len_padded = data_segment_len;\n        if((data_segment_len_padded & 3) != 0)\n            data_segment_len_padded += 4 - (data_segment_len_padded & 3);\n        pduLen += data_segment_len_padded;\n\n\n        /* make sure we have a conversation for this session */\n        conversation = find_or_create_conversation(pinfo);\n\n        iscsi_session=(iscsi_session_t *)conversation_get_proto_data(conversation, proto_iscsi);\n        if(!iscsi_session){\n            iscsi_session = wmem_new(wmem_file_scope(), iscsi_session_t);\n            iscsi_session->header_digest = ISCSI_DIGEST_AUTO;\n            iscsi_session->data_digest = ISCSI_DIGEST_AUTO;\n            iscsi_session->itlq = wmem_tree_new(wmem_file_scope());\n            iscsi_session->itl  = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);\n            conversation_add_proto_data(conversation, proto_iscsi, iscsi_session);\n\n            /* DataOut PDUs are often mistaken by DCERPC heuristics to be\n             * that protocol. Now that we know this is iscsi, set a\n             * dissector for this conversation to block other heuristic\n             * dissectors.\n             */\n            conversation_set_dissector(conversation, iscsi_handle);\n        }\n        /* try to autodetect if header digest is used or not */\n        if (digestsActive && (available_bytes >= (guint32) (48+4+ahsLen*4)) &&\n            (iscsi_session->header_digest == ISCSI_DIGEST_AUTO)) {\n            guint32 crc;\n            /* we have enough data to test if HeaderDigest is enabled */\n            crc= ~crc32c_tvb_offset_calculate(tvb, offset, 48+ahsLen*4, CRC32C_PRELOAD);\n            if(crc==tvb_get_ntohl(tvb,48+ahsLen*4)){\n                iscsi_session->header_digest = ISCSI_DIGEST_CRC32;\n            } else {\n                iscsi_session->header_digest = ISCSI_DIGEST_NONE;\n            }\n        }\n\n\n        /* Add header digest length to pdulen */\n        if(digestsActive){\n            switch(iscsi_session->header_digest){\n            case ISCSI_DIGEST_CRC32:\n                pduLen += 4;\n                data_segment_offset += 4;\n                break;\n            case ISCSI_DIGEST_NONE:\n                break;\n            case ISCSI_DIGEST_AUTO:\n                /* oops we don't yet know what digest is used */\n                /* here we should use some default */\n                break;\n            default:\n                DISSECTOR_ASSERT_NOT_REACHED();\n            }\n        }\n\n        /* try to autodetect whether data digest is used */\n        if (digestsActive &&\n            (available_bytes >= data_segment_offset + data_segment_len_padded + 4) &&\n            (iscsi_session->data_digest == ISCSI_DIGEST_AUTO)) {\n            guint32 crc;\n            /* we have enough data to test if DataDigest is enabled */\n            crc = ~crc32c_tvb_offset_calculate(tvb, data_segment_offset, data_segment_len_padded, CRC32C_PRELOAD);\n            if (crc == tvb_get_ntohl(tvb, data_segment_offset + data_segment_len_padded)) {\n                iscsi_session->data_digest = ISCSI_DIGEST_CRC32;\n            } else {\n                iscsi_session->data_digest = ISCSI_DIGEST_NONE;\n            }\n        }\n\n        /* Add data digest length to pdulen */\n        if (digestsActive && data_segment_len > 0) {\n            switch (iscsi_session->data_digest) {\n            case ISCSI_DIGEST_CRC32:\n                pduLen += 4;\n                break;\n            case ISCSI_DIGEST_NONE:\n                break;\n            case ISCSI_DIGEST_AUTO:\n                /* unknown digest, perhaps a new field was introduced? */\n                break;\n            default:\n                DISSECTOR_ASSERT_NOT_REACHED();\n            }\n        }\n\n        /*\n         * Desegmentation check.\n         */\n        if(iscsi_desegment && pinfo->can_desegment) {\n            if(pduLen > available_bytes) {\n                /*\n                 * This frame doesn't have all of the data for\n                 * this message, but we can do reassembly on it.\n                 *\n                 * Tell the TCP dissector where the data for this\n                 * message starts in the data it handed us, and\n                 * how many more bytes we need, and return.\n                 */\n                pinfo->desegment_offset = offset;\n                pinfo->desegment_len = pduLen - available_bytes;\n                return -1;\n            }\n        }\n\n        /* This is to help TCP keep track of PDU boundaries\n           and allows it to find PDUs that are not aligned to\n           the start of a TCP segments.\n           Since it also allows TCP to know what is in the middle\n           of a large PDU, it reduces the probability of a segment\n           in the middle of a large PDU transfer being misdissected as\n           a PDU.\n        */\n        if(!pinfo->fd->visited){\n            if(pduLen>(guint32)tvb_reported_length_remaining(tvb, offset)){\n                pinfo->want_pdu_tracking=2;\n                pinfo->bytes_until_next_pdu=pduLen-tvb_reported_length_remaining(tvb, offset);\n            }\n        }\n\n        if (offset == 0)\n            col_set_str(pinfo->cinfo, COL_INFO, \"\");\n        else\n            col_append_str(pinfo->cinfo, COL_INFO, \", \");\n\n        dissect_iscsi_pdu(tvb, pinfo, tree, offset, opcode, opcode_str, data_segment_len, iscsi_session, conversation);\n        if(pduLen > available_bytes)\n            pduLen = available_bytes;\n        offset += pduLen;\n        available_bytes -= pduLen;\n    }\n\n    return offset;\n}",
        "func_after": "static int\ndissect_iscsi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean check_port) {\n    /* Set up structures needed to add the protocol subtree and manage it */\n    guint offset = 0;\n    guint32 available_bytes = tvb_captured_length(tvb);\n    int digestsActive = 1;\n    conversation_t *conversation = NULL;\n    iscsi_session_t *iscsi_session=NULL;\n    guint8 opcode, tmpbyte;\n\n    if (available_bytes < 48) {\n        /* heuristic already rejected the packet if size < 48,\n           assume it's an iscsi packet with a segmented header */\n        pinfo->desegment_offset = offset;\n        pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\n        return -1;\n    }\n\n    opcode = tvb_get_guint8(tvb, offset + 0);\n    opcode &= OPCODE_MASK;\n\n    /* heuristics to verify that the packet looks sane.   the heuristics\n     * are based on the RFC version of iscsi.\n     * (we should retire support for older iscsi versions in wireshark)\n     *      -- ronnie s\n     */\n    /* opcode must be any of the ones from the standard\n     * also check the header that it looks \"sane\"\n     * all reserved or undefined bits in iscsi must be set to zero.\n     */\n    switch(opcode){\n    case ISCSI_OPCODE_NOP_IN:\n        /* top two bits of byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2 and 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_NOP_OUT:\n        /* top bit of byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2 and 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        /* assume ITT and TTT must always be non NULL (ok they can be NULL\n         * from time to time but it usually means we are in the middle\n         * of a zeroed datablock).\n         */\n        if(!tvb_get_letohl(tvb,offset+16) || !tvb_get_letohl(tvb,offset+20)){\n            return 0;\n        }\n        /* all reserved bytes between 32 - 47 must be null */\n        if(tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGIN_COMMAND:\n        /* top two bits in byte 0 must be 0x40 */\n        if((tvb_get_guint8(tvb, offset+0)&0xc0)!=0x40){\n\n            return 0;\n        }\n        /* both the T and C bits can not be set\n         * and the two reserved bits in byte 1 must be 0\n         */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        switch(tmpbyte&0xf0){\n        case 0x80:\n        case 0x40:\n        case 0x00:\n            break;\n        default:\n            return 0;\n        }\n        /* CSG and NSG must not be 2 */\n        if(((tmpbyte & 0x03) == 0x02)\n           || ((tmpbyte & 0x0c) == 0x08)) {\n            return 0;\n        }\n        /* if T bit is set NSG must not be 0 */\n        if(tmpbyte&0x80){\n            if(!(tmpbyte&0x03)){\n                return 0;\n            }\n        }\n        /* should we test that datasegmentlen is non zero? */\n        break;\n    case ISCSI_OPCODE_LOGIN_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n\n            return 0;\n        }\n        /* both the T and C bits can not be set\n         * and the two reserved bits in byte 1 must be 0\n         */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        switch(tmpbyte&0xf0){\n        case 0x80:\n        case 0x40:\n        case 0x00:\n            break;\n        default:\n            return 0;\n        }\n        /* CSG and NSG must not be 2 */\n        if(((tmpbyte & 0x03) == 0x02)\n           || ((tmpbyte & 0x0c) == 0x08)) {\n            return 0;\n        }\n        /* if T bit is set NSG must not be 0 */\n        if(tmpbyte&0x80){\n            if(!(tmpbyte&0x03)){\n                return 0;\n            }\n        }\n        /* the 32bit words at offsets 20, 40, 44 must be zero */\n        if(tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the two bytes at offset 38 must be zero */\n        if(tvb_get_letohs(tvb,offset+38)){\n            return 0;\n        }\n        /* should we test that datasegmentlen is non zero unless we just\n         * entered full featured phase?\n         */\n        break;\n    case ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* top bit in byte 1 must be set */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* Function must be known */\n        if(!try_val_to_str(tmpbyte&0x7f, iscsi_task_management_functions)){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl must be null */\n        if(tvb_get_letohl(tvb,offset+4)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* response must be 0-6 or 255 */\n        tmpbyte=tvb_get_guint8(tvb,offset+2);\n        if(tmpbyte>6 && tmpbyte<255){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb,offset+3)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 20, 36\n         * 40, 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGOUT_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* top bit in byte 1 must be set */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* Reason code must be known */\n        if(!try_val_to_str(tmpbyte&0x7f, iscsi_logout_reasons)){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 32, 36\n         * 40, 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SNACK_REQUEST:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* top 4 bits in byte 1 must be 0x80 */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if((tmpbyte&0xf0)!=0x80){\n            return 0;\n        }\n        /* type must be known */\n        if(!try_val_to_str(tmpbyte&0x0f, iscsi_snack_types)){\n            return 0;\n        }\n        /* for status/snack and datack itt must be 0xffffffff\n         * for rdata/snack ttt must not be 0 or 0xffffffff\n         */\n        switch(tmpbyte&0x0f){\n        case 1:\n        case 2:\n            if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n                return 0;\n            }\n            break;\n        case 3:\n            if(tvb_get_letohl(tvb,offset+20)==0xffffffff){\n                return 0;\n            }\n            if(tvb_get_letohl(tvb,offset+20)==0){\n                return 0;\n            }\n            break;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 24, 32, 36\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+24)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)){\n            return 0;\n        }\n\n        break;\n    case ISCSI_OPCODE_R2T:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl must be null */\n        if(tvb_get_letohl(tvb,offset+4)){\n            return 0;\n        }\n        /* desired data transfer length must not be null */\n        if(!tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_REJECT:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* reason must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_reject_reasons)){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        /* the 32bit words at offsets 8, 12, 20, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the 32bit word at 16 must be 0xffffffff */\n        if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TEXT_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* one of the F and C bits must be set but not both\n         * low 6 bits in byte 1 must be 0\n         */\n        switch(tvb_get_guint8(tvb,offset+1)){\n        case 0x80:\n        case 0x40:\n            break;\n        default:\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 32, 36, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TEXT_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* one of the F and C bits must be set but not both\n         * low 6 bits in byte 1 must be 0\n         */\n        switch(tvb_get_guint8(tvb,offset+1)){\n        case 0x80:\n        case 0x40:\n            break;\n        default:\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 36, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* reserved bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb, offset+1)&0x18){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* if expected data transfer length is set, W and/or R have to be set */\n        if(tvb_get_ntohl(tvb,offset+20)){\n            if(!(tvb_get_guint8(tvb, offset+1)&0x60)){\n                return 0;\n            }\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* top bit in byte 1 must be 1 */\n        tmpbyte=tvb_get_guint8(tvb,offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* the reserved bits in byte 1 must be 0 */\n        if(tmpbyte&0x61){\n            return 0;\n        }\n        /* status must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+3), scsi_status_val)){\n            return 0;\n        }\n        /* the 32bit words at offsets 8, 12\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_ASYNC_MESSAGE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 20, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the 32bit word at 16 must be 0xffffffff */\n        if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGOUT_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* response must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_logout_response)){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb,offset+3)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 20, 36\n         * 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_DATA_OUT:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* low 7 bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb,offset+1)&0x7f){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 24, 32, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+24)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_DATA_IN:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* reserved bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb,offset+1)&0x38){\n            return 0;\n        }\n        /* byte 2 must be reserved */\n        if(tvb_get_guint8(tvb,offset+2)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I0:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I1:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I2:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T0:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T1:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T2:\n        break;\n    default:\n        return 0;\n    } /* end of heuristics check */\n\n\n    /* process multiple iSCSI PDUs per packet */\n    while(available_bytes >= 48 || (iscsi_desegment && available_bytes >= 8)) {\n        guint32 data_segment_len;\n        guint32 pduLen = 48;\n        guint8 secondPduByte = tvb_get_guint8(tvb, offset + 1);\n        int badPdu = FALSE;\n        guint8 ahsLen=0;\n        guint32 data_segment_offset, data_segment_len_padded;\n\n        /* mask out any extra bits in the opcode byte */\n        opcode = tvb_get_guint8(tvb, offset + 0);\n        opcode &= OPCODE_MASK;\n\n        if(opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION ||\n           opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\n           opcode == ISCSI_OPCODE_R2T ||\n           opcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\n           opcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\n           opcode == ISCSI_OPCODE_SNACK_REQUEST)\n            data_segment_len = 0;\n        else\n            data_segment_len = tvb_get_ntohl(tvb, offset + 4) & 0x00ffffff;\n\n        if (!try_val_to_str(opcode, iscsi_opcodes)) {\n            badPdu = TRUE;\n        }\n\n\n        if(!badPdu && check_port) {\n            badPdu = TRUE;\n            if ((opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->srcport)) {\n                badPdu = FALSE;\n            }\n            if (!(opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->destport)) {\n                badPdu = FALSE;\n            }\n            if ((opcode & TARGET_OPCODE_BIT) && pinfo->srcport == iscsi_system_port) {\n                badPdu = FALSE;\n            }\n            if (!(opcode & TARGET_OPCODE_BIT) && pinfo->destport == iscsi_system_port) {\n                badPdu = FALSE;\n            }\n        }\n\n        if(!badPdu && enable_bogosity_filter) {\n            /* try and distinguish between data and real headers */\n            if(data_segment_len > bogus_pdu_data_length_threshold) {\n                badPdu = TRUE;\n            }\n            else if(demand_good_f_bit &&\n                    !(secondPduByte & 0x80) &&\n                    (opcode == ISCSI_OPCODE_NOP_OUT ||\n                     opcode == ISCSI_OPCODE_NOP_IN ||\n                     opcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\n                     opcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\n                     opcode == ISCSI_OPCODE_SCSI_RESPONSE ||\n                     opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\n                     opcode == ISCSI_OPCODE_R2T ||\n                     opcode == ISCSI_OPCODE_ASYNC_MESSAGE ||\n                     opcode == ISCSI_OPCODE_SNACK_REQUEST ||\n                     opcode == ISCSI_OPCODE_REJECT)) {\n                badPdu = TRUE;\n            } else if(opcode==ISCSI_OPCODE_NOP_OUT) {\n                /* TransferTag for NOP-Out should either be -1 or\n                   the tag value we want for a response.\n                   Assume 0 means we are just inside a big all zero\n                   datablock.\n                */\n                if(tvb_get_ntohl(tvb, offset+20)==0){\n                    badPdu = TRUE;\n                }\n            }\n        }\n\n        if(badPdu) {\n            return offset;\n        }\n\n        if(opcode == ISCSI_OPCODE_LOGIN_COMMAND ||\n           opcode == ISCSI_OPCODE_LOGIN_RESPONSE) {\n            if(iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT08) {\n                if((secondPduByte & CSG_MASK) < ISCSI_CSG_OPERATIONAL_NEGOTIATION) {\n                    /* digests are not yet turned on */\n                    digestsActive = 0;\n                }\n            } else {\n                digestsActive = 0;\n            }\n        }\n\n        if(opcode == ISCSI_OPCODE_SCSI_COMMAND) {\n            /* ahsLen */\n            ahsLen = tvb_get_guint8(tvb, offset + 4);\n            pduLen += ahsLen * 4;\n        }\n\n        data_segment_offset = pduLen;\n        data_segment_len_padded = data_segment_len;\n        if((data_segment_len_padded & 3) != 0)\n            data_segment_len_padded += 4 - (data_segment_len_padded & 3);\n        pduLen += data_segment_len_padded;\n\n\n        /* make sure we have a conversation for this session */\n        conversation = find_or_create_conversation(pinfo);\n\n        iscsi_session=(iscsi_session_t *)conversation_get_proto_data(conversation, proto_iscsi);\n        if(!iscsi_session){\n            iscsi_session = wmem_new(wmem_file_scope(), iscsi_session_t);\n            iscsi_session->header_digest = ISCSI_DIGEST_AUTO;\n            iscsi_session->data_digest = ISCSI_DIGEST_AUTO;\n            iscsi_session->itlq = wmem_tree_new(wmem_file_scope());\n            iscsi_session->itl  = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);\n            conversation_add_proto_data(conversation, proto_iscsi, iscsi_session);\n\n            /* DataOut PDUs are often mistaken by DCERPC heuristics to be\n             * that protocol. Now that we know this is iscsi, set a\n             * dissector for this conversation to block other heuristic\n             * dissectors.\n             */\n            conversation_set_dissector(conversation, iscsi_handle);\n        }\n        /* try to autodetect if header digest is used or not */\n        if (digestsActive && (available_bytes >= (guint32) (48+4+ahsLen*4)) &&\n            (iscsi_session->header_digest == ISCSI_DIGEST_AUTO)) {\n            guint32 crc;\n            /* we have enough data to test if HeaderDigest is enabled */\n            crc= ~crc32c_tvb_offset_calculate(tvb, offset, 48+ahsLen*4, CRC32C_PRELOAD);\n            if(crc==tvb_get_ntohl(tvb,48+ahsLen*4)){\n                iscsi_session->header_digest = ISCSI_DIGEST_CRC32;\n            } else {\n                iscsi_session->header_digest = ISCSI_DIGEST_NONE;\n            }\n        }\n\n\n        /* Add header digest length to pdulen */\n        if(digestsActive){\n            switch(iscsi_session->header_digest){\n            case ISCSI_DIGEST_CRC32:\n                pduLen += 4;\n                data_segment_offset += 4;\n                break;\n            case ISCSI_DIGEST_NONE:\n                break;\n            case ISCSI_DIGEST_AUTO:\n                /* oops we don't yet know what digest is used */\n                /* here we should use some default */\n                break;\n            default:\n                DISSECTOR_ASSERT_NOT_REACHED();\n            }\n        }\n\n        /* try to autodetect whether data digest is used */\n        if (digestsActive &&\n            (available_bytes >= data_segment_offset + data_segment_len_padded + 4) &&\n            (iscsi_session->data_digest == ISCSI_DIGEST_AUTO)) {\n            guint32 crc;\n            /* we have enough data to test if DataDigest is enabled */\n            crc = ~crc32c_tvb_offset_calculate(tvb, data_segment_offset, data_segment_len_padded, CRC32C_PRELOAD);\n            if (crc == tvb_get_ntohl(tvb, data_segment_offset + data_segment_len_padded)) {\n                iscsi_session->data_digest = ISCSI_DIGEST_CRC32;\n            } else {\n                iscsi_session->data_digest = ISCSI_DIGEST_NONE;\n            }\n        }\n\n        /* Add data digest length to pdulen */\n        if (digestsActive && data_segment_len > 0) {\n            switch (iscsi_session->data_digest) {\n            case ISCSI_DIGEST_CRC32:\n                pduLen += 4;\n                break;\n            case ISCSI_DIGEST_NONE:\n                break;\n            case ISCSI_DIGEST_AUTO:\n                /* unknown digest, perhaps a new field was introduced? */\n                break;\n            default:\n                DISSECTOR_ASSERT_NOT_REACHED();\n            }\n        }\n\n        /*\n         * Desegmentation check.\n         */\n        if(iscsi_desegment && pinfo->can_desegment) {\n            if(pduLen > available_bytes) {\n                /*\n                 * This frame doesn't have all of the data for\n                 * this message, but we can do reassembly on it.\n                 *\n                 * Tell the TCP dissector where the data for this\n                 * message starts in the data it handed us, and\n                 * how many more bytes we need, and return.\n                 */\n                pinfo->desegment_offset = offset;\n                pinfo->desegment_len = pduLen - available_bytes;\n                return -1;\n            }\n        }\n\n        /* This is to help TCP keep track of PDU boundaries\n           and allows it to find PDUs that are not aligned to\n           the start of a TCP segments.\n           Since it also allows TCP to know what is in the middle\n           of a large PDU, it reduces the probability of a segment\n           in the middle of a large PDU transfer being misdissected as\n           a PDU.\n        */\n        if(!pinfo->fd->visited){\n            if(pduLen>(guint32)tvb_reported_length_remaining(tvb, offset)){\n                pinfo->want_pdu_tracking=2;\n                pinfo->bytes_until_next_pdu=pduLen-tvb_reported_length_remaining(tvb, offset);\n            }\n        }\n\n        if (offset == 0)\n            col_set_str(pinfo->cinfo, COL_INFO, \"\");\n        else\n            col_append_str(pinfo->cinfo, COL_INFO, \", \");\n\n        dissect_iscsi_pdu(tvb, pinfo, tree, offset, opcode, data_segment_len, iscsi_session, conversation);\n        if(pduLen > available_bytes)\n            pduLen = available_bytes;\n        offset += pduLen;\n        available_bytes -= pduLen;\n    }\n\n    return offset;\n}",
        "description": "A vulnerability in Wireshark versions 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 causes a crash in the iSCSI dissector when processing certain packets or crafted capture files. This issue can be exploited to achieve a denial of service.",
        "commit": "It was discovered that the iSCSI protocol implementation lacked proper handling of invalid opcodes within Reject messages. Specifically, the function responsible for dissecting iSCSI PDUs did not account for such cases, leading to potential crashes when encountering invalid opcodes in Reject messages. This issue has been addressed to ensure robustness against malformed inputs."
    },
    {
        "cwe": "CWE-125",
        "func_name": "torvalds/do_split",
        "score": 0.7903296947479248,
        "func_before": "static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}",
        "func_after": "static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Ensure that neither split block is over half full */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/*\n\t * map index at which we will split\n\t *\n\t * If the sum of active entries didn't exceed half the block size, just\n\t * split it in half by count; each resulting block will have at least\n\t * half the space free.\n\t */\n\tif (i > 0)\n\t\tsplit = count - move;\n\telse\n\t\tsplit = count/2;\n\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}",
        "description": "A memory out-of-bounds read flaw was identified in the Linux kernel prior to version 5.9-rc2, specifically within the ext3/ext4 file system. This flaw occurs when accessing a directory with broken indexing, potentially allowing a local user to crash the system if such a directory exists. The primary risk associated with this vulnerability is a decrease in system availability.",
        "commit": "If a directory passed to the `do_split()` function lacks sufficient active entries to surpass half the block size, it may result in iterating through all \"count\" entries without identifying a split point. In such cases, where `count` equals `move` and `split` becomes zero, an attempt to access a negative index in the `map[]` array could occur. To prevent this, detect this scenario and fall back to splitting at half of the count, ensuring that each split block still has ample space greater than half the block size."
    },
    {
        "cwe": "CWE-787",
        "func_name": "OP-TEE/syscall_obj_generate_key",
        "score": 0.7934525012969971,
        "func_before": "TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that maxKeySize follows restrictions */\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tparams = malloc(sizeof(TEE_Attribute) * param_count);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * We have to do it like this because the parity bits aren't\n\t\t * counted when telling the size of the key in bits.\n\t\t */\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}",
        "func_after": "TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that maxKeySize follows restrictions */\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * We have to do it like this because the parity bits aren't\n\t\t * counted when telling the size of the key in bits.\n\t\t */\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}",
        "description": "Linaro/OP-TEE versions 3.3.0 and earlier are vulnerable to a buffer overflow, which could lead to the execution of arbitrary code within the Trusted Execution Environment (TEE) core (kernel) context. This issue affects the optee_os component. The vulnerability has been addressed in versions 3.4.0 and later.",
        "commit": "It was discovered that there is a risk of heap-based overflow due to insufficient checking for allocation overflow in cryptographic function calls. Without verifying the allocation size, there is a possibility of allocating a buffer that is smaller than expected, which could result in attacker-controlled data being written beyond the buffer's boundaries."
    }
]