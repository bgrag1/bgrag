[
    {
        "cwe": "CWE-252",
        "func_name": "libtiff/createCroppedImage",
        "score": 0.7541905045509338,
        "func_before": "static int\ncreateCroppedImage(struct image_data *image, struct crop_mask *crop, \n                   unsigned char **read_buff_ptr, unsigned char **crop_buff_ptr)\n  {\n  tsize_t   cropsize;\n  unsigned  char *read_buff = NULL;\n  unsigned  char *crop_buff = NULL;\n  unsigned  char *new_buff  = NULL;\n  static    tsize_t  prev_cropsize = 0;\n\n  read_buff = *read_buff_ptr;\n\n  /* process full image, no crop buffer needed */\n  crop_buff = read_buff;\n  *crop_buff_ptr = read_buff;\n  crop->combined_width = image->width;\n  crop->combined_length = image->length;\n\n  cropsize = crop->bufftotal;\n  crop_buff = *crop_buff_ptr;\n  if (!crop_buff)\n    {\n    crop_buff = (unsigned char *)limitMalloc(cropsize);\n    *crop_buff_ptr = crop_buff;\n    _TIFFmemset(crop_buff, 0, cropsize);\n    prev_cropsize = cropsize;\n    }\n  else\n    {\n    if (prev_cropsize < cropsize)\n      {\n      new_buff = _TIFFrealloc(crop_buff, cropsize);\n      if (!new_buff)\n        {\n\tfree (crop_buff);\n        crop_buff = (unsigned char *)limitMalloc(cropsize);\n        }\n      else\n        crop_buff = new_buff;\n      _TIFFmemset(crop_buff, 0, cropsize);\n      }\n    }\n\n  if (!crop_buff)\n    {\n    TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");\n    return (-1);\n    }\n  *crop_buff_ptr = crop_buff;\n\n  if (crop->crop_mode & CROP_INVERT)\n    {\n    switch (crop->photometric)\n      {\n      /* Just change the interpretation */\n      case PHOTOMETRIC_MINISWHITE:\n      case PHOTOMETRIC_MINISBLACK:\n\t   image->photometric = crop->photometric;\n\t   break;\n      case INVERT_DATA_ONLY:\n      case INVERT_DATA_AND_TAG:\n           if (invertImage(image->photometric, image->spp, image->bps, \n                           crop->combined_width, crop->combined_length, crop_buff))\n             {\n             TIFFError(\"createCroppedImage\", \n                       \"Failed to invert colorspace for image or cropped selection\");\n             return (-1);\n             }\n           if (crop->photometric == INVERT_DATA_AND_TAG)\n             {\n             switch (image->photometric)\n               {\n               case PHOTOMETRIC_MINISWHITE:\n \t            image->photometric = PHOTOMETRIC_MINISBLACK;\n\t            break;\n               case PHOTOMETRIC_MINISBLACK:\n \t            image->photometric = PHOTOMETRIC_MINISWHITE;\n\t            break;\n               default:\n\t            break;\n\t       }\n\t     }\n           break;\n      default: break;\n      }\n    }\n\n  if (crop->crop_mode & CROP_MIRROR)\n    {\n    if (mirrorImage(image->spp, image->bps, crop->mirror, \n                    crop->combined_width, crop->combined_length, crop_buff))\n      {\n      TIFFError(\"createCroppedImage\", \"Failed to mirror image or cropped selection %s\", \n\t       (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");\n      return (-1);\n      }\n    }\n\n  if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n    {\n    if (rotateImage(crop->rotation, image, &crop->combined_width, \n                    &crop->combined_length, crop_buff_ptr))\n      {\n      TIFFError(\"createCroppedImage\", \n                \"Failed to rotate image or cropped selection by %\"PRIu16\" degrees\", crop->rotation);\n      return (-1);\n      }\n    }\n\n  if (crop_buff == read_buff) /* we used the read buffer for the crop buffer */\n    *read_buff_ptr = NULL;    /* so we don't try to free it later */\n\n  return (0);\n  }",
        "func_after": "static int\ncreateCroppedImage(struct image_data *image, struct crop_mask *crop, \n                   unsigned char **read_buff_ptr, unsigned char **crop_buff_ptr)\n  {\n  tsize_t   cropsize;\n  unsigned  char *read_buff = NULL;\n  unsigned  char *crop_buff = NULL;\n  unsigned  char *new_buff  = NULL;\n  static    tsize_t  prev_cropsize = 0;\n\n  read_buff = *read_buff_ptr;\n\n  /* process full image, no crop buffer needed */\n  crop_buff = read_buff;\n  *crop_buff_ptr = read_buff;\n  crop->combined_width = image->width;\n  crop->combined_length = image->length;\n\n  cropsize = crop->bufftotal;\n  crop_buff = *crop_buff_ptr;\n  if (!crop_buff)\n    {\n    crop_buff = (unsigned char *)limitMalloc(cropsize);\n    if (!crop_buff)\n    {\n        TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");\n        return (-1);\n    }\n    _TIFFmemset(crop_buff, 0, cropsize);\n    prev_cropsize = cropsize;\n    }\n  else\n    {\n    if (prev_cropsize < cropsize)\n      {\n      new_buff = _TIFFrealloc(crop_buff, cropsize);\n      if (!new_buff)\n        {\n\tfree (crop_buff);\n        crop_buff = (unsigned char *)limitMalloc(cropsize);\n        }\n      else\n        crop_buff = new_buff;\n      if (!crop_buff)\n      {\n          TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");\n          return (-1);\n      }\n      _TIFFmemset(crop_buff, 0, cropsize);\n      }\n    }\n\n  *crop_buff_ptr = crop_buff;\n\n  if (crop->crop_mode & CROP_INVERT)\n    {\n    switch (crop->photometric)\n      {\n      /* Just change the interpretation */\n      case PHOTOMETRIC_MINISWHITE:\n      case PHOTOMETRIC_MINISBLACK:\n\t   image->photometric = crop->photometric;\n\t   break;\n      case INVERT_DATA_ONLY:\n      case INVERT_DATA_AND_TAG:\n           if (invertImage(image->photometric, image->spp, image->bps, \n                           crop->combined_width, crop->combined_length, crop_buff))\n             {\n             TIFFError(\"createCroppedImage\", \n                       \"Failed to invert colorspace for image or cropped selection\");\n             return (-1);\n             }\n           if (crop->photometric == INVERT_DATA_AND_TAG)\n             {\n             switch (image->photometric)\n               {\n               case PHOTOMETRIC_MINISWHITE:\n \t            image->photometric = PHOTOMETRIC_MINISBLACK;\n\t            break;\n               case PHOTOMETRIC_MINISBLACK:\n \t            image->photometric = PHOTOMETRIC_MINISWHITE;\n\t            break;\n               default:\n\t            break;\n\t       }\n\t     }\n           break;\n      default: break;\n      }\n    }\n\n  if (crop->crop_mode & CROP_MIRROR)\n    {\n    if (mirrorImage(image->spp, image->bps, crop->mirror, \n                    crop->combined_width, crop->combined_length, crop_buff))\n      {\n      TIFFError(\"createCroppedImage\", \"Failed to mirror image or cropped selection %s\", \n\t       (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");\n      return (-1);\n      }\n    }\n\n  if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n    {\n    if (rotateImage(crop->rotation, image, &crop->combined_width, \n                    &crop->combined_length, crop_buff_ptr))\n      {\n      TIFFError(\"createCroppedImage\", \n                \"Failed to rotate image or cropped selection by %\"PRIu16\" degrees\", crop->rotation);\n      return (-1);\n      }\n    }\n\n  if (crop_buff == read_buff) /* we used the read buffer for the crop buffer */\n    *read_buff_ptr = NULL;    /* so we don't try to free it later */\n\n  return (0);\n  }",
        "description": "Unchecked return value leading to NULL pointer dereference in the tiffcrop utility of libtiff 4.3.0 enables attackers to trigger a denial-of-service condition through a specially crafted TIFF file. Users who compile libtiff from source can apply the fix available in commit f2b656e2.",
        "commit": "It was identified that checks for the return value of memory allocation functions like `malloc` were missing, which could lead to potential issues if the allocation fails."
    },
    {
        "cwe": "CWE-354",
        "func_name": "systemd/journal_file_offline_close",
        "score": 0.7400813698768616,
        "func_before": "JournalFile* journal_file_offline_close(JournalFile *f) {\n        if (!f)\n                return NULL;\n\n#if HAVE_GCRYPT\n        /* Write the final tag */\n        if (JOURNAL_HEADER_SEALED(f->header) && journal_file_writable(f)) {\n                int r;\n\n                r = journal_file_append_tag(f);\n                if (r < 0)\n                        log_error_errno(r, \"Failed to append tag when closing journal: %m\");\n        }\n#endif\n\n        if (sd_event_source_get_enabled(f->post_change_timer, NULL) > 0)\n                journal_file_post_change(f);\n        sd_event_source_disable_unref(f->post_change_timer);\n\n        journal_file_set_offline(f, true);\n\n        return journal_file_close(f);\n}",
        "func_after": "JournalFile* journal_file_offline_close(JournalFile *f) {\n        if (!f)\n                return NULL;\n\n        journal_file_write_final_tag(f);\n\n        if (sd_event_source_get_enabled(f->post_change_timer, NULL) > 0)\n                journal_file_post_change(f);\n        sd_event_source_disable_unref(f->post_change_timer);\n\n        journal_file_set_offline(f, true);\n\n        return journal_file_close(f);\n}",
        "description": "An issue was discovered in systemd where an attacker can manipulate a sealed log file by truncating it and then resuming the log sealing process. This manipulation allows the attacker to alter the log content without detection, as integrity checks do not reveal any errors.",
        "commit": "The vulnerability involves an issue in the `journalctl` tool where empty log epochs are not properly sealed, allowing attackers to manipulate sealed logs by truncating them and continuing without detection during verification. This defect partially addresses CVE-2023-31438. To fully resolve the issue, the system should enforce that there is exactly one seal per epoch and prevent sealing until an epoch has ended. Additionally, a new journal-file flag, `HEADER_COMPATIBLE_SEALED_CONTINUOUS`, has been introduced to indicate continuous sealing and determine whether missing cryptographic epochs should result in warnings or errors."
    },
    {
        "cwe": "CWE-203",
        "func_name": "barebox/check_passwd",
        "score": 0.7534701228141785,
        "func_before": "static int check_passwd(unsigned char *passwd, size_t length)\n{\n\tstruct digest *d = NULL;\n\tunsigned char *passwd1_sum;\n\tunsigned char *passwd2_sum;\n\tint ret = 0;\n\tint hash_len;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\thash_len = PBKDF2_LENGTH;\n\t} else {\n\t\td = digest_alloc(PASSWD_SUM);\n\t\tif (!d) {\n\t\t\tpr_err(\"No such digest: %s\\n\",\n\t\t\t       PASSWD_SUM ? PASSWD_SUM : \"NULL\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\thash_len = digest_length(d);\n\t}\n\n\tpasswd1_sum = calloc(hash_len * 2, sizeof(unsigned char));\n\tif (!passwd1_sum)\n\t\treturn -ENOMEM;\n\n\tpasswd2_sum = passwd1_sum + hash_len;\n\n\tif (is_passwd_env_enable())\n\t\tret = read_env_passwd(passwd2_sum, hash_len);\n\telse if (is_passwd_default_enable())\n\t\tret = read_default_passwd(passwd2_sum, hash_len);\n\telse\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto err;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\tchar *key = passwd2_sum + PBKDF2_SALT_LEN;\n\t\tchar *salt = passwd2_sum;\n\t\tint keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN;\n\n\t\tret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt,\n\t\t\tPBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, passwd1_sum);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (strncmp(passwd1_sum, key, keylen) == 0)\n\t\t\tret = 1;\n\t} else {\n\t\tret = digest_digest(d, passwd, length, passwd1_sum);\n\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (strncmp(passwd1_sum, passwd2_sum, hash_len) == 0)\n\t\t\tret = 1;\n\t}\n\nerr:\n\tfree(passwd1_sum);\n\tdigest_free(d);\n\n\treturn ret;\n}",
        "func_after": "static int check_passwd(unsigned char *passwd, size_t length)\n{\n\tstruct digest *d = NULL;\n\tunsigned char *passwd1_sum;\n\tunsigned char *passwd2_sum;\n\tint ret = 0;\n\tint hash_len;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\thash_len = PBKDF2_LENGTH;\n\t} else {\n\t\td = digest_alloc(PASSWD_SUM);\n\t\tif (!d) {\n\t\t\tpr_err(\"No such digest: %s\\n\",\n\t\t\t       PASSWD_SUM ? PASSWD_SUM : \"NULL\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\thash_len = digest_length(d);\n\t}\n\n\tpasswd1_sum = calloc(hash_len * 2, sizeof(unsigned char));\n\tif (!passwd1_sum)\n\t\treturn -ENOMEM;\n\n\tpasswd2_sum = passwd1_sum + hash_len;\n\n\tif (is_passwd_env_enable())\n\t\tret = read_env_passwd(passwd2_sum, hash_len);\n\telse if (is_passwd_default_enable())\n\t\tret = read_default_passwd(passwd2_sum, hash_len);\n\telse\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto err;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\tchar *key = passwd2_sum + PBKDF2_SALT_LEN;\n\t\tchar *salt = passwd2_sum;\n\t\tint keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN;\n\n\t\tret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt,\n\t\t\tPBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, passwd1_sum);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (!crypto_memneq(passwd1_sum, key, keylen))\n\t\t\tret = 1;\n\t} else {\n\t\tret = digest_digest(d, passwd, length, passwd1_sum);\n\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (!crypto_memneq(passwd1_sum, passwd2_sum, hash_len))\n\t\t\tret = 1;\n\t}\n\nerr:\n\tfree(passwd1_sum);\n\tdigest_free(d);\n\n\treturn ret;\n}",
        "description": "The Pengutronix barebox, up to version 2021.07.0, suffers from a vulnerability where timing information is leaked due to the use of `strncmp` during hash comparisons.",
        "commit": "Cryptographic verifications should employ a time-constant comparison method to prevent attackers from inferring secret information by observing system behavior. Therefore, it is recommended to use functions like `crypto_memneq()` instead of `memcmp()` for comparing sensitive data such as password hashes."
    },
    {
        "cwe": "CWE-682",
        "func_name": "torvalds/sctp_make_init",
        "score": 0.7627184391021729,
        "func_before": "struct sctp_chunk *sctp_make_init(const struct sctp_association *asoc,\n\t\t\t     const struct sctp_bind_addr *bp,\n\t\t\t     gfp_t gfp, int vparam_len)\n{\n\tsctp_inithdr_t init;\n\tunion sctp_params addrs;\n\tsize_t chunksize;\n\tstruct sctp_chunk *retval = NULL;\n\tint num_types, addrs_len = 0;\n\tstruct sctp_sock *sp;\n\tsctp_supported_addrs_param_t sat;\n\t__be16 types[2];\n\tsctp_adaptation_ind_param_t aiparam;\n\tsctp_supported_ext_param_t ext_param;\n\tint num_ext = 0;\n\t__u8 extensions[3];\n\tsctp_paramhdr_t *auth_chunks = NULL,\n\t\t\t*auth_hmacs = NULL;\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 1: The INIT chunks can contain multiple addresses that\n\t * can be IPv4 and/or IPv6 in any combination.\n\t */\n\tretval = NULL;\n\n\t/* Convert the provided bind address list to raw format. */\n\taddrs = sctp_bind_addrs_to_raw(bp, &addrs_len, gfp);\n\n\tinit.init_tag\t\t   = htonl(asoc->c.my_vtag);\n\tinit.a_rwnd\t\t   = htonl(asoc->rwnd);\n\tinit.num_outbound_streams  = htons(asoc->c.sinit_num_ostreams);\n\tinit.num_inbound_streams   = htons(asoc->c.sinit_max_instreams);\n\tinit.initial_tsn\t   = htonl(asoc->c.initial_tsn);\n\n\t/* How many address types are needed? */\n\tsp = sctp_sk(asoc->base.sk);\n\tnum_types = sp->pf->supported_addrs(sp, types);\n\n\tchunksize = sizeof(init) + addrs_len + SCTP_SAT_LEN(num_types);\n\tchunksize += sizeof(ecap_param);\n\n\tif (sctp_prsctp_enable)\n\t\tchunksize += sizeof(prsctp_param);\n\n\t/* ADDIP: Section 4.2.7:\n\t *  An implementation supporting this extension [ADDIP] MUST list\n\t *  the ASCONF,the ASCONF-ACK, and the AUTH  chunks in its INIT and\n\t *  INIT-ACK parameters.\n\t */\n\tif (sctp_addip_enable) {\n\t\textensions[num_ext] = SCTP_CID_ASCONF;\n\t\textensions[num_ext+1] = SCTP_CID_ASCONF_ACK;\n\t\tnum_ext += 2;\n\t}\n\n\tif (sp->adaptation_ind)\n\t\tchunksize += sizeof(aiparam);\n\n\tchunksize += vparam_len;\n\n\t/* Account for AUTH related parameters */\n\tif (sctp_auth_enable) {\n\t\t/* Add random parameter length*/\n\t\tchunksize += sizeof(asoc->c.auth_random);\n\n\t\t/* Add HMACS parameter length if any were defined */\n\t\tauth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;\n\t\tif (auth_hmacs->length)\n\t\t\tchunksize += ntohs(auth_hmacs->length);\n\t\telse\n\t\t\tauth_hmacs = NULL;\n\n\t\t/* Add CHUNKS parameter length */\n\t\tauth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;\n\t\tif (auth_chunks->length)\n\t\t\tchunksize += ntohs(auth_chunks->length);\n\t\telse\n\t\t\tauth_chunks = NULL;\n\n\t\textensions[num_ext] = SCTP_CID_AUTH;\n\t\tnum_ext += 1;\n\t}\n\n\t/* If we have any extensions to report, account for that */\n\tif (num_ext)\n\t\tchunksize += sizeof(sctp_supported_ext_param_t) + num_ext;\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 3: An INIT chunk MUST NOT contain more than one Host\n\t * Name address parameter. Moreover, the sender of the INIT\n\t * MUST NOT combine any other address types with the Host Name\n\t * address in the INIT. The receiver of INIT MUST ignore any\n\t * other address types if the Host Name address parameter is\n\t * present in the received INIT chunk.\n\t *\n\t * PLEASE DO NOT FIXME [This version does not support Host Name.]\n\t */\n\n\tretval = sctp_make_chunk(asoc, SCTP_CID_INIT, 0, chunksize);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.init_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(init), &init);\n\tretval->param_hdr.v =\n\t\tsctp_addto_chunk(retval, addrs_len, addrs.v);\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 4: This parameter, when present, specifies all the\n\t * address types the sending endpoint can support. The absence\n\t * of this parameter indicates that the sending endpoint can\n\t * support any address type.\n\t */\n\tsat.param_hdr.type = SCTP_PARAM_SUPPORTED_ADDRESS_TYPES;\n\tsat.param_hdr.length = htons(SCTP_SAT_LEN(num_types));\n\tsctp_addto_chunk(retval, sizeof(sat), &sat);\n\tsctp_addto_chunk(retval, num_types * sizeof(__u16), &types);\n\n\tsctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);\n\n\t/* Add the supported extensions parameter.  Be nice and add this\n\t * fist before addiding the parameters for the extensions themselves\n\t */\n\tif (num_ext) {\n\t\text_param.param_hdr.type = SCTP_PARAM_SUPPORTED_EXT;\n\t\text_param.param_hdr.length =\n\t\t\t    htons(sizeof(sctp_supported_ext_param_t) + num_ext);\n\t\tsctp_addto_chunk(retval, sizeof(sctp_supported_ext_param_t),\n\t\t\t\t&ext_param);\n\t\tsctp_addto_param(retval, num_ext, extensions);\n\t}\n\n\tif (sctp_prsctp_enable)\n\t\tsctp_addto_chunk(retval, sizeof(prsctp_param), &prsctp_param);\n\n\tif (sp->adaptation_ind) {\n\t\taiparam.param_hdr.type = SCTP_PARAM_ADAPTATION_LAYER_IND;\n\t\taiparam.param_hdr.length = htons(sizeof(aiparam));\n\t\taiparam.adaptation_ind = htonl(sp->adaptation_ind);\n\t\tsctp_addto_chunk(retval, sizeof(aiparam), &aiparam);\n\t}\n\n\t/* Add SCTP-AUTH chunks to the parameter list */\n\tif (sctp_auth_enable) {\n\t\tsctp_addto_chunk(retval, sizeof(asoc->c.auth_random),\n\t\t\t\t asoc->c.auth_random);\n\t\tif (auth_hmacs)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_hmacs->length),\n\t\t\t\t\tauth_hmacs);\n\t\tif (auth_chunks)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_chunks->length),\n\t\t\t\t\tauth_chunks);\n\t}\nnodata:\n\tkfree(addrs.v);\n\treturn retval;\n}",
        "func_after": "struct sctp_chunk *sctp_make_init(const struct sctp_association *asoc,\n\t\t\t     const struct sctp_bind_addr *bp,\n\t\t\t     gfp_t gfp, int vparam_len)\n{\n\tsctp_inithdr_t init;\n\tunion sctp_params addrs;\n\tsize_t chunksize;\n\tstruct sctp_chunk *retval = NULL;\n\tint num_types, addrs_len = 0;\n\tstruct sctp_sock *sp;\n\tsctp_supported_addrs_param_t sat;\n\t__be16 types[2];\n\tsctp_adaptation_ind_param_t aiparam;\n\tsctp_supported_ext_param_t ext_param;\n\tint num_ext = 0;\n\t__u8 extensions[3];\n\tsctp_paramhdr_t *auth_chunks = NULL,\n\t\t\t*auth_hmacs = NULL;\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 1: The INIT chunks can contain multiple addresses that\n\t * can be IPv4 and/or IPv6 in any combination.\n\t */\n\tretval = NULL;\n\n\t/* Convert the provided bind address list to raw format. */\n\taddrs = sctp_bind_addrs_to_raw(bp, &addrs_len, gfp);\n\n\tinit.init_tag\t\t   = htonl(asoc->c.my_vtag);\n\tinit.a_rwnd\t\t   = htonl(asoc->rwnd);\n\tinit.num_outbound_streams  = htons(asoc->c.sinit_num_ostreams);\n\tinit.num_inbound_streams   = htons(asoc->c.sinit_max_instreams);\n\tinit.initial_tsn\t   = htonl(asoc->c.initial_tsn);\n\n\t/* How many address types are needed? */\n\tsp = sctp_sk(asoc->base.sk);\n\tnum_types = sp->pf->supported_addrs(sp, types);\n\n\tchunksize = sizeof(init) + addrs_len;\n\tchunksize += WORD_ROUND(SCTP_SAT_LEN(num_types));\n\tchunksize += sizeof(ecap_param);\n\n\tif (sctp_prsctp_enable)\n\t\tchunksize += sizeof(prsctp_param);\n\n\t/* ADDIP: Section 4.2.7:\n\t *  An implementation supporting this extension [ADDIP] MUST list\n\t *  the ASCONF,the ASCONF-ACK, and the AUTH  chunks in its INIT and\n\t *  INIT-ACK parameters.\n\t */\n\tif (sctp_addip_enable) {\n\t\textensions[num_ext] = SCTP_CID_ASCONF;\n\t\textensions[num_ext+1] = SCTP_CID_ASCONF_ACK;\n\t\tnum_ext += 2;\n\t}\n\n\tif (sp->adaptation_ind)\n\t\tchunksize += sizeof(aiparam);\n\n\tchunksize += vparam_len;\n\n\t/* Account for AUTH related parameters */\n\tif (sctp_auth_enable) {\n\t\t/* Add random parameter length*/\n\t\tchunksize += sizeof(asoc->c.auth_random);\n\n\t\t/* Add HMACS parameter length if any were defined */\n\t\tauth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;\n\t\tif (auth_hmacs->length)\n\t\t\tchunksize += WORD_ROUND(ntohs(auth_hmacs->length));\n\t\telse\n\t\t\tauth_hmacs = NULL;\n\n\t\t/* Add CHUNKS parameter length */\n\t\tauth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;\n\t\tif (auth_chunks->length)\n\t\t\tchunksize += WORD_ROUND(ntohs(auth_chunks->length));\n\t\telse\n\t\t\tauth_chunks = NULL;\n\n\t\textensions[num_ext] = SCTP_CID_AUTH;\n\t\tnum_ext += 1;\n\t}\n\n\t/* If we have any extensions to report, account for that */\n\tif (num_ext)\n\t\tchunksize += WORD_ROUND(sizeof(sctp_supported_ext_param_t) +\n\t\t\t\t\tnum_ext);\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 3: An INIT chunk MUST NOT contain more than one Host\n\t * Name address parameter. Moreover, the sender of the INIT\n\t * MUST NOT combine any other address types with the Host Name\n\t * address in the INIT. The receiver of INIT MUST ignore any\n\t * other address types if the Host Name address parameter is\n\t * present in the received INIT chunk.\n\t *\n\t * PLEASE DO NOT FIXME [This version does not support Host Name.]\n\t */\n\n\tretval = sctp_make_chunk(asoc, SCTP_CID_INIT, 0, chunksize);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.init_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(init), &init);\n\tretval->param_hdr.v =\n\t\tsctp_addto_chunk(retval, addrs_len, addrs.v);\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 4: This parameter, when present, specifies all the\n\t * address types the sending endpoint can support. The absence\n\t * of this parameter indicates that the sending endpoint can\n\t * support any address type.\n\t */\n\tsat.param_hdr.type = SCTP_PARAM_SUPPORTED_ADDRESS_TYPES;\n\tsat.param_hdr.length = htons(SCTP_SAT_LEN(num_types));\n\tsctp_addto_chunk(retval, sizeof(sat), &sat);\n\tsctp_addto_chunk(retval, num_types * sizeof(__u16), &types);\n\n\tsctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);\n\n\t/* Add the supported extensions parameter.  Be nice and add this\n\t * fist before addiding the parameters for the extensions themselves\n\t */\n\tif (num_ext) {\n\t\text_param.param_hdr.type = SCTP_PARAM_SUPPORTED_EXT;\n\t\text_param.param_hdr.length =\n\t\t\t    htons(sizeof(sctp_supported_ext_param_t) + num_ext);\n\t\tsctp_addto_chunk(retval, sizeof(sctp_supported_ext_param_t),\n\t\t\t\t&ext_param);\n\t\tsctp_addto_param(retval, num_ext, extensions);\n\t}\n\n\tif (sctp_prsctp_enable)\n\t\tsctp_addto_chunk(retval, sizeof(prsctp_param), &prsctp_param);\n\n\tif (sp->adaptation_ind) {\n\t\taiparam.param_hdr.type = SCTP_PARAM_ADAPTATION_LAYER_IND;\n\t\taiparam.param_hdr.length = htons(sizeof(aiparam));\n\t\taiparam.adaptation_ind = htonl(sp->adaptation_ind);\n\t\tsctp_addto_chunk(retval, sizeof(aiparam), &aiparam);\n\t}\n\n\t/* Add SCTP-AUTH chunks to the parameter list */\n\tif (sctp_auth_enable) {\n\t\tsctp_addto_chunk(retval, sizeof(asoc->c.auth_random),\n\t\t\t\t asoc->c.auth_random);\n\t\tif (auth_hmacs)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_hmacs->length),\n\t\t\t\t\tauth_hmacs);\n\t\tif (auth_chunks)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_chunks->length),\n\t\t\t\t\tauth_chunks);\n\t}\nnodata:\n\tkfree(addrs.v);\n\treturn retval;\n}",
        "description": "In the Linux kernel prior to version 2.6.34, when both addip_enable and auth_enable are enabled, the function responsible for creating SCTP chunks does not account for the amount of zero padding during the calculation of chunk lengths for INIT and INIT ACK chunks. This oversight allows remote attackers to exploit this vulnerability by sending specially crafted packets, resulting in a denial of service (OOPS).",
        "commit": "When calculating the INIT/INIT-ACK chunk length, it is essential to consider not only the length of the parameters but also the zero padding length of these parameters, such as the AUTH HMACS parameter and CHUNKS parameter. Failing to account for the zero padding length can lead to a kernel panic, specifically an `skb_over_panic` error, which occurs when attempting to write beyond the buffer's allocated space. This issue arises within the SCTP protocol implementation in the Linux kernel, potentially affecting network communication stability and security."
    },
    {
        "cwe": "CWE-121",
        "func_name": "kernel/chap_server_compute_md5",
        "score": 0.7592402696609497,
        "func_before": "static int chap_server_compute_md5(\n\tstruct iscsi_conn *conn,\n\tstruct iscsi_node_auth *auth,\n\tchar *nr_in_ptr,\n\tchar *nr_out_ptr,\n\tunsigned int *nr_out_len)\n{\n\tunsigned long id;\n\tunsigned char id_as_uchar;\n\tunsigned char digest[MD5_SIGNATURE_SIZE];\n\tunsigned char type, response[MD5_SIGNATURE_SIZE * 2 + 2];\n\tunsigned char identifier[10], *challenge = NULL;\n\tunsigned char *challenge_binhex = NULL;\n\tunsigned char client_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char server_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char chap_n[MAX_CHAP_N_SIZE], chap_r[MAX_RESPONSE_LENGTH];\n\tsize_t compare_len;\n\tstruct iscsi_chap *chap = conn->auth_protocol;\n\tstruct crypto_shash *tfm = NULL;\n\tstruct shash_desc *desc = NULL;\n\tint auth_ret = -1, ret, challenge_len;\n\n\tmemset(identifier, 0, 10);\n\tmemset(chap_n, 0, MAX_CHAP_N_SIZE);\n\tmemset(chap_r, 0, MAX_RESPONSE_LENGTH);\n\tmemset(digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(response, 0, MD5_SIGNATURE_SIZE * 2 + 2);\n\tmemset(client_digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(server_digest, 0, MD5_SIGNATURE_SIZE);\n\n\tchallenge = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge) {\n\t\tpr_err(\"Unable to allocate challenge buffer\\n\");\n\t\tgoto out;\n\t}\n\n\tchallenge_binhex = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge_binhex) {\n\t\tpr_err(\"Unable to allocate challenge_binhex buffer\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Extract CHAP_N.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_N\", MAX_CHAP_N_SIZE, chap_n,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\tif (type == HEX) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Include the terminating NULL in the compare */\n\tcompare_len = strlen(auth->userid) + 1;\n\tif (strncmp(chap_n, auth->userid, compare_len) != 0) {\n\t\tpr_err(\"CHAP_N values do not match!\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_N=%s\\n\", chap_n);\n\t/*\n\t * Extract CHAP_R.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_R\", MAX_RESPONSE_LENGTH, chap_r,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"[server] Got CHAP_R=%s\\n\", chap_r);\n\tchap_string_to_hex(client_digest, chap_r, strlen(chap_r));\n\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\ttfm = NULL;\n\t\tpr_err(\"Unable to allocate struct crypto_shash\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);\n\tif (!desc) {\n\t\tpr_err(\"Unable to allocate struct shash_desc\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, &chap->id, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, (char *)&auth->password,\n\t\t\t\t  strlen(auth->password));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for password\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_finup(desc, chap->challenge,\n\t\t\t\t CHAP_CHALLENGE_LENGTH, server_digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for challenge\\n\");\n\t\tgoto out;\n\t}\n\n\tchap_binaryhex_to_asciihex(response, server_digest, MD5_SIGNATURE_SIZE);\n\tpr_debug(\"[server] MD5 Server Digest: %s\\n\", response);\n\n\tif (memcmp(server_digest, client_digest, MD5_SIGNATURE_SIZE) != 0) {\n\t\tpr_debug(\"[server] MD5 Digests do not match!\\n\\n\");\n\t\tgoto out;\n\t} else\n\t\tpr_debug(\"[server] MD5 Digests match, CHAP connection\"\n\t\t\t\t\" successful.\\n\\n\");\n\t/*\n\t * One way authentication has succeeded, return now if mutual\n\t * authentication is not enabled.\n\t */\n\tif (!auth->authenticate_target) {\n\t\tauth_ret = 0;\n\t\tgoto out;\n\t}\n\t/*\n\t * Get CHAP_I.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_I\", 10, identifier, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_I.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type == HEX)\n\t\tret = kstrtoul(&identifier[2], 0, &id);\n\telse\n\t\tret = kstrtoul(identifier, 0, &id);\n\n\tif (ret < 0) {\n\t\tpr_err(\"kstrtoul() failed for CHAP identifier: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (id > 255) {\n\t\tpr_err(\"chap identifier: %lu greater than 255\\n\", id);\n\t\tgoto out;\n\t}\n\t/*\n\t * RFC 1994 says Identifier is no more than octet (8 bits).\n\t */\n\tpr_debug(\"[server] Got CHAP_I=%lu\\n\", id);\n\t/*\n\t * Get CHAP_C.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_C\", CHAP_CHALLENGE_STR_LEN,\n\t\t\tchallenge, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_C=%s\\n\", challenge);\n\tchallenge_len = chap_string_to_hex(challenge_binhex, challenge,\n\t\t\t\tstrlen(challenge));\n\tif (!challenge_len) {\n\t\tpr_err(\"Unable to convert incoming challenge\\n\");\n\t\tgoto out;\n\t}\n\tif (challenge_len > 1024) {\n\t\tpr_err(\"CHAP_C exceeds maximum binary size of 1024 bytes\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * During mutual authentication, the CHAP_C generated by the\n\t * initiator must not match the original CHAP_C generated by\n\t * the target.\n\t */\n\tif (!memcmp(challenge_binhex, chap->challenge, CHAP_CHALLENGE_LENGTH)) {\n\t\tpr_err(\"initiator CHAP_C matches target CHAP_C, failing\"\n\t\t       \" login attempt\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Generate CHAP_N and CHAP_R for mutual authentication.\n\t */\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* To handle both endiannesses */\n\tid_as_uchar = id;\n\tret = crypto_shash_update(desc, &id_as_uchar, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, auth->password_mutual,\n\t\t\t\t  strlen(auth->password_mutual));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for\"\n\t\t\t\t\" password_mutual\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Convert received challenge to binary hex.\n\t */\n\tret = crypto_shash_finup(desc, challenge_binhex, challenge_len,\n\t\t\t\t digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for ma challenge\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Generate CHAP_N and CHAP_R.\n\t */\n\t*nr_out_len = sprintf(nr_out_ptr, \"CHAP_N=%s\", auth->userid_mutual);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_N=%s\\n\", auth->userid_mutual);\n\t/*\n\t * Convert response from binary hex to ascii hext.\n\t */\n\tchap_binaryhex_to_asciihex(response, digest, MD5_SIGNATURE_SIZE);\n\t*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, \"CHAP_R=0x%s\",\n\t\t\tresponse);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_R=0x%s\\n\", response);\n\tauth_ret = 0;\nout:\n\tkzfree(desc);\n\tif (tfm)\n\t\tcrypto_free_shash(tfm);\n\tkfree(challenge);\n\tkfree(challenge_binhex);\n\treturn auth_ret;\n}",
        "func_after": "static int chap_server_compute_md5(\n\tstruct iscsi_conn *conn,\n\tstruct iscsi_node_auth *auth,\n\tchar *nr_in_ptr,\n\tchar *nr_out_ptr,\n\tunsigned int *nr_out_len)\n{\n\tunsigned long id;\n\tunsigned char id_as_uchar;\n\tunsigned char digest[MD5_SIGNATURE_SIZE];\n\tunsigned char type, response[MD5_SIGNATURE_SIZE * 2 + 2];\n\tunsigned char identifier[10], *challenge = NULL;\n\tunsigned char *challenge_binhex = NULL;\n\tunsigned char client_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char server_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char chap_n[MAX_CHAP_N_SIZE], chap_r[MAX_RESPONSE_LENGTH];\n\tsize_t compare_len;\n\tstruct iscsi_chap *chap = conn->auth_protocol;\n\tstruct crypto_shash *tfm = NULL;\n\tstruct shash_desc *desc = NULL;\n\tint auth_ret = -1, ret, challenge_len;\n\n\tmemset(identifier, 0, 10);\n\tmemset(chap_n, 0, MAX_CHAP_N_SIZE);\n\tmemset(chap_r, 0, MAX_RESPONSE_LENGTH);\n\tmemset(digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(response, 0, MD5_SIGNATURE_SIZE * 2 + 2);\n\tmemset(client_digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(server_digest, 0, MD5_SIGNATURE_SIZE);\n\n\tchallenge = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge) {\n\t\tpr_err(\"Unable to allocate challenge buffer\\n\");\n\t\tgoto out;\n\t}\n\n\tchallenge_binhex = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge_binhex) {\n\t\tpr_err(\"Unable to allocate challenge_binhex buffer\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Extract CHAP_N.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_N\", MAX_CHAP_N_SIZE, chap_n,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\tif (type == HEX) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Include the terminating NULL in the compare */\n\tcompare_len = strlen(auth->userid) + 1;\n\tif (strncmp(chap_n, auth->userid, compare_len) != 0) {\n\t\tpr_err(\"CHAP_N values do not match!\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_N=%s\\n\", chap_n);\n\t/*\n\t * Extract CHAP_R.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_R\", MAX_RESPONSE_LENGTH, chap_r,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (strlen(chap_r) != MD5_SIGNATURE_SIZE * 2) {\n\t\tpr_err(\"Malformed CHAP_R\\n\");\n\t\tgoto out;\n\t}\n\tif (hex2bin(client_digest, chap_r, MD5_SIGNATURE_SIZE) < 0) {\n\t\tpr_err(\"Malformed CHAP_R\\n\");\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"[server] Got CHAP_R=%s\\n\", chap_r);\n\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\ttfm = NULL;\n\t\tpr_err(\"Unable to allocate struct crypto_shash\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);\n\tif (!desc) {\n\t\tpr_err(\"Unable to allocate struct shash_desc\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, &chap->id, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, (char *)&auth->password,\n\t\t\t\t  strlen(auth->password));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for password\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_finup(desc, chap->challenge,\n\t\t\t\t CHAP_CHALLENGE_LENGTH, server_digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for challenge\\n\");\n\t\tgoto out;\n\t}\n\n\tchap_binaryhex_to_asciihex(response, server_digest, MD5_SIGNATURE_SIZE);\n\tpr_debug(\"[server] MD5 Server Digest: %s\\n\", response);\n\n\tif (memcmp(server_digest, client_digest, MD5_SIGNATURE_SIZE) != 0) {\n\t\tpr_debug(\"[server] MD5 Digests do not match!\\n\\n\");\n\t\tgoto out;\n\t} else\n\t\tpr_debug(\"[server] MD5 Digests match, CHAP connection\"\n\t\t\t\t\" successful.\\n\\n\");\n\t/*\n\t * One way authentication has succeeded, return now if mutual\n\t * authentication is not enabled.\n\t */\n\tif (!auth->authenticate_target) {\n\t\tauth_ret = 0;\n\t\tgoto out;\n\t}\n\t/*\n\t * Get CHAP_I.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_I\", 10, identifier, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_I.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type == HEX)\n\t\tret = kstrtoul(&identifier[2], 0, &id);\n\telse\n\t\tret = kstrtoul(identifier, 0, &id);\n\n\tif (ret < 0) {\n\t\tpr_err(\"kstrtoul() failed for CHAP identifier: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (id > 255) {\n\t\tpr_err(\"chap identifier: %lu greater than 255\\n\", id);\n\t\tgoto out;\n\t}\n\t/*\n\t * RFC 1994 says Identifier is no more than octet (8 bits).\n\t */\n\tpr_debug(\"[server] Got CHAP_I=%lu\\n\", id);\n\t/*\n\t * Get CHAP_C.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_C\", CHAP_CHALLENGE_STR_LEN,\n\t\t\tchallenge, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\tchallenge_len = DIV_ROUND_UP(strlen(challenge), 2);\n\tif (!challenge_len) {\n\t\tpr_err(\"Unable to convert incoming challenge\\n\");\n\t\tgoto out;\n\t}\n\tif (challenge_len > 1024) {\n\t\tpr_err(\"CHAP_C exceeds maximum binary size of 1024 bytes\\n\");\n\t\tgoto out;\n\t}\n\tif (hex2bin(challenge_binhex, challenge, challenge_len) < 0) {\n\t\tpr_err(\"Malformed CHAP_C\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_C=%s\\n\", challenge);\n\t/*\n\t * During mutual authentication, the CHAP_C generated by the\n\t * initiator must not match the original CHAP_C generated by\n\t * the target.\n\t */\n\tif (!memcmp(challenge_binhex, chap->challenge, CHAP_CHALLENGE_LENGTH)) {\n\t\tpr_err(\"initiator CHAP_C matches target CHAP_C, failing\"\n\t\t       \" login attempt\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Generate CHAP_N and CHAP_R for mutual authentication.\n\t */\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* To handle both endiannesses */\n\tid_as_uchar = id;\n\tret = crypto_shash_update(desc, &id_as_uchar, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, auth->password_mutual,\n\t\t\t\t  strlen(auth->password_mutual));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for\"\n\t\t\t\t\" password_mutual\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Convert received challenge to binary hex.\n\t */\n\tret = crypto_shash_finup(desc, challenge_binhex, challenge_len,\n\t\t\t\t digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for ma challenge\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Generate CHAP_N and CHAP_R.\n\t */\n\t*nr_out_len = sprintf(nr_out_ptr, \"CHAP_N=%s\", auth->userid_mutual);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_N=%s\\n\", auth->userid_mutual);\n\t/*\n\t * Convert response from binary hex to ascii hext.\n\t */\n\tchap_binaryhex_to_asciihex(response, digest, MD5_SIGNATURE_SIZE);\n\t*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, \"CHAP_R=0x%s\",\n\t\t\tresponse);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_R=0x%s\\n\", response);\n\tauth_ret = 0;\nout:\n\tkzfree(desc);\n\tif (tfm)\n\t\tcrypto_free_shash(tfm);\n\tkfree(challenge);\n\tkfree(challenge_binhex);\n\treturn auth_ret;\n}",
        "description": "A security flaw exists in the chap_server_compute_md5() function within the ISCSI target code of the Linux kernel, where an unauthenticated remote attacker can exploit a stack buffer overflow to overwrite up to 17 bytes of the stack. This vulnerability arises during the processing of an authentication request from an ISCSI initiator. For an attack to be successful, the iSCSI target must be enabled on the victim host. The impact of the overflow varies based on the target's build environment, including the compiler, compile flags, and hardware architecture, potentially leading to a system crash, denial-of-service, or unauthorized access to data exported by the iSCSI target. Although privilege escalation is not conclusively proven, it remains a concern. This vulnerability affects kernel versions 4.18.x, 4.14.x, and 3.10.x.",
        "commit": "Please provide the specific vulnerability knowledge you would like me to abstract and generalize."
    }
]