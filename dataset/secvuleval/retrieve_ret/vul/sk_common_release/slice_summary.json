[
    {
        "cwe": "CWE-89",
        "func_name": "openlink/sqlo_add_table_ref",
        "score": 0.7168245911598206,
        "func_before": "void\nsqlo_add_table_ref (sqlo_t * so, ST ** tree_ret, dk_set_t *res)\n{\n  char tmp[10];\n  ST * tree = *tree_ret;\n  switch (tree->type)\n    {\n    case TABLE_REF:\n      {\n\tST * prev = tree->_.table_ref.table;\n\tif (ST_P (prev, SELECT_STMT))\n\t  {\n\t    tree->type = DERIVED_TABLE;\n\t    sqlp_view_def (NULL, tree->_.table_ref.table, 0);\n\t    sqlo_add_table_ref (so, tree_ret, res);\n\t    return;\n\t  }\n\tsqlo_add_table_ref (so, &tree->_.table_ref.table, res);\n\tif (prev != tree->_.table_ref.table)\n\t  *tree_ret = tree->_.table_ref.table;\n\tbreak;\n      }\n    case TABLE_DOTTED:\n      {\n\tST * with_view = sqlo_with_decl (so, tree);\n\tdbe_table_t *tb = with_view ? NULL : sch_name_to_table (wi_inst.wi_schema, tree->_.table.name);\n\tST * view;\n\tif (!tb && !with_view)\n\t  sqlc_error (so->so_sc->sc_cc, \"S0002\", \"No table %s\", tree->_.table.name);\n\tif (inside_view)\n\t  tree->_.table.name = t_box_copy (tb->tb_name);\n\tif (!with_view)\n\t  {\n\t    sqlc_table_used (so->so_sc, tb);\n\t    view = (ST*) sch_view_def (wi_inst.wi_schema, tb->tb_name);\n\t  }\n\telse\n\t  view = with_view;\n\tif (!view || inside_view)\n\t  {\n\t    remote_table_t * rt = find_remote_table (tb->tb_name, 0);\n\t    t_NEW_VARZ (op_table_t, ot);\n\t    ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts);\n\t    ot->ot_prefix = tree->_.table.prefix;\n\t    snprintf (tmp, sizeof (tmp), \"t%d\", so->so_name_ctr++);\n\t    ot->ot_new_prefix = t_box_string (tmp);\n\t    tree->_.table.prefix = ot->ot_new_prefix;\n\t    ot->ot_table = tb;\n\t    ot->ot_rds = rt ? rt->rt_rds : NULL;\n\t    ot->ot_u_id = (oid_t) unbox (tree->_.table.u_id);\n\t    ot->ot_g_id = (oid_t) unbox (tree->_.table.g_id);\n\t    if (ST_P (view, PROC_TABLE))\n\t      {\n\t\tot->ot_dt = view;\n\t\tsqlo_proc_table_cols (so, ot);\n\t\tot->ot_dt = NULL;\n\t\tot->ot_is_proc_view = 1;\n\t      }\n\t    sqlo_rls_add_condition (so, ot, res, tb);\n\t    t_set_push (&so->so_tables, (void*) ot);\n\t    sco_add_table (so->so_scope, ot);\n\t  }\n\telse\n\t  {\n\t    op_table_t * ot = NULL;\n\t    if (!with_view && !sec_tb_check (tb, (oid_t) unbox (tree->_.table.g_id), (oid_t) unbox (tree->_.table.u_id), GR_SELECT))\n\t      sqlc_new_error (so->so_sc->sc_cc, \"42000\", \"SQ070:SECURITY\", \"Must have select privileges on view %s\", tb->tb_name);\n\t    view = (ST*) t_box_copy_tree ((caddr_t) view);\n\t    if (ST_P (view, UNION_ST) ||\n\t\tST_P (view, UNION_ALL_ST) ||\n\t\tST_P (view, EXCEPT_ST) ||\n\t\tST_P (view, EXCEPT_ALL_ST) ||\n\t\tST_P (view, INTERSECT_ST) ||\n\t\tST_P (view, INTERSECT_ALL_ST))\n\t      {\n\t\tview = sqlp_view_def (NULL, view, 1);\n\t\tview = sqlc_union_dt_wrap (view);\n\t      }\n\t    sqlo_scope (so, &view);\n\t    if (ST_P (view, SELECT_STMT))\n\t      {\n\t\tot = (op_table_t *) so->so_tables->data;\n\t\tot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name;\n\t\tsco_add_table (so->so_scope, ot);\n\t      }\n\t    else\n\t      {\n\t\tt_NEW_VARZ (op_table_t, ot2);\n\t\tmemset (ot2, 0, sizeof (op_table_t));\n\t\tot = ot2;\n\t\tot->ot_dt = view;\n\t\tot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name;\n\t\tot->ot_new_prefix = sqlo_new_prefix (so);\n\t\tot->ot_left_sel = sqlp_union_tree_select (view);\n\t\tif (ST_P (view, PROC_TABLE))\n\t\t  {\n\t\t    sqlo_proc_table_cols (so, ot);\n\t\t    ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts);\n\t\t    ot->ot_is_proc_view = 1;\n\t\t  }\n\t\tsco_add_table (so->so_scope, ot);\n\t\tt_set_push (&so->so_tables, (void*) ot);\n\n\t      }\n\t    sqlo_rls_add_condition (so, ot, res, tb);\n\t    *tree_ret = (ST*) t_list (3, DERIVED_TABLE, ot->ot_dt, ot->ot_new_prefix);\n\t  }\n\tbreak;\n      }\n    case JOINED_TABLE:\n      {\n\tsql_scope_t *old_sco = so->so_scope;\n\tTNEW (sql_scope_t, sco);\n\top_table_t *right_ot, *left_ot;\n\ts_node_t *ptr;\n\tST *j_right;\n\tdk_set_t res_jt = NULL;\n\tint is_jtc, is_natural = (tree->_.join.is_natural &&\n\t    (!tree->_.join.cond || tree->_.join.cond == (ST *) STAR));\n\n\n\tmemset (sco, 0, sizeof (sql_scope_t));\n\tsco->sco_so = so;\n\tsco->sco_fun_refs_allowed = old_sco->sco_fun_refs_allowed;\n\tsco->sco_super = so->so_scope->sco_super;\n\tso->so_scope = sco;\n\n\tif (OJ_RIGHT == tree->_.join.type)\n\t  {\n\t    ST * tmp = tree->_.join.left;\n\t    tree->_.join.left = tree->_.join.right;\n\t    tree->_.join.right = tmp;\n\t    tree->_.join.type = OJ_LEFT;\n\t  }\n\tj_right = tree->_.join.left;\n\twhile (ST_P (j_right, TABLE_REF))\n\t  j_right = j_right->_.table_ref.table;\n\tis_jtc = ST_P (j_right, JOINED_TABLE);\n\tif (tree->_.join.type == OJ_FULL)\n\t  sco->sco_has_jt = 1;\n\tif (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)))\n\t  sco->sco_has_jt = 1;\n\tj_right = tree->_.join.right;\n\twhile (ST_P (j_right, TABLE_REF))\n\t  j_right = j_right->_.table_ref.table;\n\tis_jtc = ST_P (j_right, JOINED_TABLE);\n\tif (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)))\n\t  sco->sco_has_jt = 1;\n\tsqlo_add_table_ref (so, &tree->_.join.left, res);\n\tleft_ot = (op_table_t *) so->so_tables->data;\n\tsqlo_add_table_ref (so, &tree->_.join.right, is_jtc ? &res_jt : res);\n\tright_ot = (op_table_t *) so->so_tables->data;\n\tsqlo_natural_join_cond (so, left_ot, right_ot, tree);\n\tsqlo_scope (so, &(tree->_.join.cond));\n\t/* can be that the right subtree in a ij ends with oj in which case the right ot will be flagged outer. The cond in this case goes to to the top where, i.e. res, not to the join cond of the outer (optional) ot */\nif (J_INNER == tree->_.join.type && right_ot->ot_is_outer)\n  \t  t_st_and (&right_ot->ot_enclosing_where_cond, tree->_.join.cond); /*always ste, even if some joins may be made into dts later*/\n\n\telse\n\t  t_st_and (&right_ot->ot_join_cond, tree->_.join.cond); /*always ste, even if some joins may be made into dts later*/\n\tsco_merge (old_sco, sco);\n\tso->so_scope = old_sco;\n\tif (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)\n\t  right_ot->ot_is_outer = 1;\n\telse if (!sco->sco_has_jt && tree->_.join.type == J_INNER &&\n\t    !ST_P (left_ot->ot_dt, PROC_TABLE) &&\n\t    !ST_P (right_ot->ot_dt, PROC_TABLE))\n\t  {\n\t    t_set_push (res, tree);\n\t    break;\n\t  }\n\tbreak;\n      }\n    case DERIVED_TABLE:\n      {\n\top_table_t * ot;\n\tsqlo_scope (so, &(tree->_.table_ref.table));\n\tif (ST_P (tree->_.table_ref.table, SELECT_STMT))\n\t  {\n\t    ot = (op_table_t *) so->so_tables->data;\n\t    ot->ot_prefix = tree->_.table_ref.range;\n\t    tree->_.table_ref.range = ot->ot_new_prefix;\n/*\t    t_set_push (res, (void *) ot);*/\n\t    sco_add_table (so->so_scope, ot);\n\t    if (ot->ot_trans)\n\t      sqlo_trans_cols (so, ot);\n\t  }\n\telse\n\t  {\n\t    op_table_t *old_ot = so->so_tables ? (op_table_t *) so->so_tables->data : NULL;\n\t    t_NEW_VARZ (op_table_t, ot);\n\t    ot->ot_prefix = tree->_.table_ref.range;\n\t    ot->ot_dt = tree->_.table_ref.table;\n\t    ot->ot_new_prefix = sqlo_new_prefix (so);\n\t    tree->_.table_ref.range = ot->ot_new_prefix;\n\t    if (old_ot)\n\t      ot->ot_left_sel = old_ot->ot_left_sel;\n\t    else\n\t      ot->ot_left_sel = sqlp_union_tree_select (tree->_.table_ref.table);\n\t    if (ST_P (tree->_.table_ref.table, PROC_TABLE))\n\t      sqlo_proc_table_cols (so, ot);\n/*\t    t_set_push (res, (void *) ot);*/\n\t    sco_add_table (so->so_scope, ot);\n\t    t_set_push (&so->so_tables, (void*) ot);\n\t  }\n\tbreak;\n      }\n    }\n}",
        "func_after": "void\nsqlo_add_table_ref (sqlo_t * so, ST ** tree_ret, dk_set_t *res)\n{\n  char tmp[10];\n  ST * tree = *tree_ret;\n  switch (tree->type)\n    {\n    case TABLE_REF:\n      {\n\tST * prev = tree->_.table_ref.table;\n\tif (ST_P (prev, SELECT_STMT))\n\t  {\n\t    tree->type = DERIVED_TABLE;\n\t    sqlp_view_def (NULL, tree->_.table_ref.table, 0);\n\t    sqlo_add_table_ref (so, tree_ret, res);\n\t    return;\n\t  }\n\tsqlo_add_table_ref (so, &tree->_.table_ref.table, res);\n\tif (prev != tree->_.table_ref.table)\n\t  *tree_ret = tree->_.table_ref.table;\n\tbreak;\n      }\n    case TABLE_DOTTED:\n      {\n\tST * with_view = sqlo_with_decl (so, tree);\n\tdbe_table_t *tb = with_view ? NULL : sch_name_to_table (wi_inst.wi_schema, tree->_.table.name);\n\tST * view;\n\tif (!tb && !with_view)\n\t  sqlc_error (so->so_sc->sc_cc, \"S0002\", \"No table %s\", tree->_.table.name);\n\tif (inside_view)\n\t  tree->_.table.name = t_box_copy (tb->tb_name);\n\tif (!with_view)\n\t  {\n\t    sqlc_table_used (so->so_sc, tb);\n\t    view = (ST*) sch_view_def (wi_inst.wi_schema, tb->tb_name);\n\t  }\n\telse\n\t  view = with_view;\n\tif (!view || inside_view)\n\t  {\n\t    remote_table_t * rt = find_remote_table (tb->tb_name, 0);\n\t    t_NEW_VARZ (op_table_t, ot);\n\t    ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts);\n\t    ot->ot_prefix = tree->_.table.prefix;\n\t    snprintf (tmp, sizeof (tmp), \"t%d\", so->so_name_ctr++);\n\t    ot->ot_new_prefix = t_box_string (tmp);\n\t    tree->_.table.prefix = ot->ot_new_prefix;\n\t    ot->ot_table = tb;\n\t    ot->ot_rds = rt ? rt->rt_rds : NULL;\n\t    ot->ot_u_id = (oid_t) unbox (tree->_.table.u_id);\n\t    ot->ot_g_id = (oid_t) unbox (tree->_.table.g_id);\n\t    if (ST_P (view, PROC_TABLE))\n\t      {\n\t\tot->ot_dt = view;\n\t\tsqlo_proc_table_cols (so, ot);\n\t\tot->ot_dt = NULL;\n\t\tot->ot_is_proc_view = 1;\n\t      }\n\t    sqlo_rls_add_condition (so, ot, res, tb);\n\t    t_set_push (&so->so_tables, (void*) ot);\n\t    sco_add_table (so->so_scope, ot);\n\t  }\n\telse\n\t  {\n\t    op_table_t * ot = NULL;\n\t    if (!with_view && !sec_tb_check (tb, (oid_t) unbox (tree->_.table.g_id), (oid_t) unbox (tree->_.table.u_id), GR_SELECT))\n\t      sqlc_new_error (so->so_sc->sc_cc, \"42000\", \"SQ070:SECURITY\", \"Must have select privileges on view %s\", tb->tb_name);\n\t    view = (ST*) t_box_copy_tree ((caddr_t) view);\n\t    if (ST_P (view, UNION_ST) ||\n\t\tST_P (view, UNION_ALL_ST) ||\n\t\tST_P (view, EXCEPT_ST) ||\n\t\tST_P (view, EXCEPT_ALL_ST) ||\n\t\tST_P (view, INTERSECT_ST) ||\n\t\tST_P (view, INTERSECT_ALL_ST))\n\t      {\n\t\tview = sqlp_view_def (NULL, view, 1);\n\t\tview = sqlc_union_dt_wrap (so->so_sc, view);\n\t      }\n\t    sqlo_scope (so, &view);\n\t    if (ST_P (view, SELECT_STMT))\n\t      {\n\t\tot = (op_table_t *) so->so_tables->data;\n\t\tot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name;\n\t\tsco_add_table (so->so_scope, ot);\n\t      }\n\t    else\n\t      {\n\t\tt_NEW_VARZ (op_table_t, ot2);\n\t\tmemset (ot2, 0, sizeof (op_table_t));\n\t\tot = ot2;\n\t\tot->ot_dt = view;\n\t\tot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name;\n\t\tot->ot_new_prefix = sqlo_new_prefix (so);\n\t\tot->ot_left_sel = sqlp_union_tree_select (view);\n\t\tif (ST_P (view, PROC_TABLE))\n\t\t  {\n\t\t    sqlo_proc_table_cols (so, ot);\n\t\t    ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts);\n\t\t    ot->ot_is_proc_view = 1;\n\t\t  }\n\t\tsco_add_table (so->so_scope, ot);\n\t\tt_set_push (&so->so_tables, (void*) ot);\n\n\t      }\n\t    sqlo_rls_add_condition (so, ot, res, tb);\n\t    *tree_ret = (ST*) t_list (3, DERIVED_TABLE, ot->ot_dt, ot->ot_new_prefix);\n\t  }\n\tbreak;\n      }\n    case JOINED_TABLE:\n      {\n\tsql_scope_t *old_sco = so->so_scope;\n\tTNEW (sql_scope_t, sco);\n\top_table_t *right_ot, *left_ot;\n\ts_node_t *ptr;\n\tST *j_right;\n\tdk_set_t res_jt = NULL;\n\tint is_jtc, is_natural = (tree->_.join.is_natural &&\n\t    (!tree->_.join.cond || tree->_.join.cond == (ST *) STAR));\n\n\n\tmemset (sco, 0, sizeof (sql_scope_t));\n\tsco->sco_so = so;\n\tsco->sco_fun_refs_allowed = old_sco->sco_fun_refs_allowed;\n\tsco->sco_super = so->so_scope->sco_super;\n\tso->so_scope = sco;\n\n\tif (OJ_RIGHT == tree->_.join.type)\n\t  {\n\t    ST * tmp = tree->_.join.left;\n\t    tree->_.join.left = tree->_.join.right;\n\t    tree->_.join.right = tmp;\n\t    tree->_.join.type = OJ_LEFT;\n\t  }\n\tj_right = tree->_.join.left;\n\twhile (ST_P (j_right, TABLE_REF))\n\t  j_right = j_right->_.table_ref.table;\n\tis_jtc = ST_P (j_right, JOINED_TABLE);\n\tif (tree->_.join.type == OJ_FULL)\n\t  sco->sco_has_jt = 1;\n\tif (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)))\n\t  sco->sco_has_jt = 1;\n\tj_right = tree->_.join.right;\n\twhile (ST_P (j_right, TABLE_REF))\n\t  j_right = j_right->_.table_ref.table;\n\tis_jtc = ST_P (j_right, JOINED_TABLE);\n\tif (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)))\n\t  sco->sco_has_jt = 1;\n\tsqlo_add_table_ref (so, &tree->_.join.left, res);\n\tleft_ot = (op_table_t *) so->so_tables->data;\n\tsqlo_add_table_ref (so, &tree->_.join.right, is_jtc ? &res_jt : res);\n\tright_ot = (op_table_t *) so->so_tables->data;\n\tsqlo_natural_join_cond (so, left_ot, right_ot, tree);\n\tsqlo_scope (so, &(tree->_.join.cond));\n\t/* can be that the right subtree in a ij ends with oj in which case the right ot will be flagged outer. The cond in this case goes to to the top where, i.e. res, not to the join cond of the outer (optional) ot */\nif (J_INNER == tree->_.join.type && right_ot->ot_is_outer)\n  \t  t_st_and (&right_ot->ot_enclosing_where_cond, tree->_.join.cond); /*always ste, even if some joins may be made into dts later*/\n\n\telse\n\t  t_st_and (&right_ot->ot_join_cond, tree->_.join.cond); /*always ste, even if some joins may be made into dts later*/\n\tsco_merge (old_sco, sco);\n\tso->so_scope = old_sco;\n\tif (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)\n\t  right_ot->ot_is_outer = 1;\n\telse if (!sco->sco_has_jt && tree->_.join.type == J_INNER &&\n\t    !ST_P (left_ot->ot_dt, PROC_TABLE) &&\n\t    !ST_P (right_ot->ot_dt, PROC_TABLE))\n\t  {\n\t    t_set_push (res, tree);\n\t    break;\n\t  }\n\tbreak;\n      }\n    case DERIVED_TABLE:\n      {\n\top_table_t * ot;\n\tsqlo_scope (so, &(tree->_.table_ref.table));\n\tif (ST_P (tree->_.table_ref.table, SELECT_STMT))\n\t  {\n\t    ot = (op_table_t *) so->so_tables->data;\n\t    ot->ot_prefix = tree->_.table_ref.range;\n\t    tree->_.table_ref.range = ot->ot_new_prefix;\n/*\t    t_set_push (res, (void *) ot);*/\n\t    sco_add_table (so->so_scope, ot);\n\t    if (ot->ot_trans)\n\t      sqlo_trans_cols (so, ot);\n\t  }\n\telse\n\t  {\n\t    op_table_t *old_ot = so->so_tables ? (op_table_t *) so->so_tables->data : NULL;\n\t    t_NEW_VARZ (op_table_t, ot);\n\t    ot->ot_prefix = tree->_.table_ref.range;\n\t    ot->ot_dt = tree->_.table_ref.table;\n\t    ot->ot_new_prefix = sqlo_new_prefix (so);\n\t    tree->_.table_ref.range = ot->ot_new_prefix;\n\t    if (old_ot)\n\t      ot->ot_left_sel = old_ot->ot_left_sel;\n\t    else\n\t      ot->ot_left_sel = sqlp_union_tree_select (tree->_.table_ref.table);\n\t    if (ST_P (tree->_.table_ref.table, PROC_TABLE))\n\t      sqlo_proc_table_cols (so, ot);\n/*\t    t_set_push (res, (void *) ot);*/\n\t    sco_add_table (so->so_scope, ot);\n\t    t_set_push (&so->so_tables, (void*) ot);\n\t  }\n\tbreak;\n      }\n    }\n}",
        "description": "An issue in the sqlc_union_dt_wrap component of OpenLink Virtuoso Open Source allows attackers to trigger a Denial of Service (DoS) condition through the use of specially crafted SQL statements.",
        "commit": "The support for fixed non-terminals in union branches is not implemented, which may lead to issues or unexpected behavior in certain scenarios."
    },
    {
        "cwe": "CWE-212",
        "func_name": "linux4sam/secure_decrypt",
        "score": 0.688546895980835,
        "func_before": "int secure_decrypt(void *data, unsigned int data_length, int is_signed)\n{\n\tat91_aes_key_size_t key_size;\n\tunsigned int cmac_key[8], cipher_key[8];\n\tunsigned int iv[AT91_AES_IV_SIZE_WORD];\n\tunsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int fixed_length;\n\tconst unsigned int *cmac;\n\tint rc = -1;\n\n\t/* Init keys */\n\tinit_keys(&key_size, cipher_key, cmac_key, iv);\n\n\t/* Init periph */\n\tat91_aes_init();\n\n\t/* Check signature if required */\n\tif (is_signed) {\n\t\t/* Compute the CMAC */\n\t\tif (at91_aes_cmac(data_length, data, computed_cmac,\n\t\t\t\t  key_size, cmac_key))\n\t\t\tgoto exit;\n\n\t\t/* Check the CMAC */\n\t\tfixed_length = at91_aes_roundup(data_length);\n\t\tcmac = (const unsigned int *)((char *)data + fixed_length);\n\t\tif (!consttime_memequal(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))\n\t\t\tgoto exit;\n\t}\n\n\t/* Decrypt the whole file */\n\tif (at91_aes_cbc(data_length, data, data, 0,\n\t\t\t key_size, cipher_key, iv))\n\t\tgoto exit;\n\n\trc = 0;\nexit:\n\t/* Reset periph */\n\tat91_aes_cleanup();\n\n\t/* Reset keys */\n\tmemset(cmac_key, 0, sizeof(cmac_key));\n\tmemset(cipher_key, 0, sizeof(cipher_key));\n\tmemset(iv, 0, sizeof(iv));\n\n\treturn rc;\n}",
        "func_after": "static int secure_decrypt(void *data, unsigned int data_length, int is_signed)\n{\n\tat91_aes_key_size_t key_size;\n\tunsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int fixed_length;\n\tconst unsigned int *cmac;\n\tint rc = -1;\n\n#if defined(CONFIG_AES_KEY_SIZE_128)\n\tkey_size = AT91_AES_KEY_SIZE_128;\n#elif defined(CONFIG_AES_KEY_SIZE_192)\n\tkey_size = AT91_AES_KEY_SIZE_192;\n#elif defined(CONFIG_AES_KEY_SIZE_256)\n\tkey_size = AT91_AES_KEY_SIZE_256;\n#else\n#error \"bad AES key size\"\n#endif\n\n\t/* Init periph */\n\tat91_aes_init();\n\n\t/* Check signature if required */\n\tif (is_signed) {\n\t\t/* Compute the CMAC */\n\t\tif (at91_aes_cmac(data_length, data, computed_cmac,\n\t\t\t\t  key_size, cmac_key))\n\t\t\tgoto exit;\n\n\t\t/* Check the CMAC */\n\t\tfixed_length = at91_aes_roundup(data_length);\n\t\tcmac = (const unsigned int *)((char *)data + fixed_length);\n\t\tif (!consttime_memequal(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))\n\t\t\tgoto exit;\n\t}\n\n\t/* Decrypt the whole file */\n\tif (at91_aes_cbc(data_length, data, data, 0,\n\t\t\t key_size, cipher_key, iv))\n\t\tgoto exit;\n\n\trc = 0;\nexit:\n\t/* Reset periph */\n\tat91_aes_cleanup();\n\n\treturn rc;\n}",
        "description": "AT91bootstrap versions prior to 3.9.2 fail to adequately clear encryption and authentication keys from memory before transitioning control to a less privileged software component. This failure can be exploited to expose these keys, potentially allowing attackers to encrypt and sign subsequent boot stages, such as the bootloader.",
        "commit": "The vulnerability knowledge has been abstracted and generalized as follows:\n\n\"Keys were moved into static arrays to prevent their copying from the code section to the stack during initialization. By hardcoding the keys into the data section at compile time and ensuring they can be completely wiped after use, this change enhances security by reducing the risk of key exposure.\""
    },
    {
        "cwe": "CWE-354",
        "func_name": "systemd/journal_file_offline_close",
        "score": 0.690020740032196,
        "func_before": "JournalFile* journal_file_offline_close(JournalFile *f) {\n        if (!f)\n                return NULL;\n\n#if HAVE_GCRYPT\n        /* Write the final tag */\n        if (JOURNAL_HEADER_SEALED(f->header) && journal_file_writable(f)) {\n                int r;\n\n                r = journal_file_append_tag(f);\n                if (r < 0)\n                        log_error_errno(r, \"Failed to append tag when closing journal: %m\");\n        }\n#endif\n\n        if (sd_event_source_get_enabled(f->post_change_timer, NULL) > 0)\n                journal_file_post_change(f);\n        sd_event_source_disable_unref(f->post_change_timer);\n\n        journal_file_set_offline(f, true);\n\n        return journal_file_close(f);\n}",
        "func_after": "JournalFile* journal_file_offline_close(JournalFile *f) {\n        if (!f)\n                return NULL;\n\n        journal_file_write_final_tag(f);\n\n        if (sd_event_source_get_enabled(f->post_change_timer, NULL) > 0)\n                journal_file_post_change(f);\n        sd_event_source_disable_unref(f->post_change_timer);\n\n        journal_file_set_offline(f, true);\n\n        return journal_file_close(f);\n}",
        "description": "An issue was discovered in systemd where an attacker can manipulate a sealed log file by truncating it and then resuming the log sealing process. This manipulation allows the attacker to alter the log content without detection, as integrity checks do not reveal any errors.",
        "commit": "The vulnerability involves an issue in the `journalctl` tool where empty log epochs are not properly sealed, allowing attackers to manipulate sealed logs by truncating them and continuing without detection during verification. This defect partially addresses CVE-2023-31438. To fully resolve the issue, the system should enforce that there is exactly one seal per epoch and prevent sealing until an epoch has ended. Additionally, a new journal-file flag, `HEADER_COMPATIBLE_SEALED_CONTINUOUS`, has been introduced to indicate continuous sealing and determine whether missing cryptographic epochs should result in warnings or errors."
    },
    {
        "cwe": "CWE-116",
        "func_name": "flatpak/flatpak_context_load_metadata",
        "score": 0.703731894493103,
        "func_before": "gboolean\nflatpak_context_load_metadata (FlatpakContext *context,\n                               GKeyFile       *metakey,\n                               GError        **error)\n{\n  gboolean remove;\n  g_auto(GStrv) groups = NULL;\n  gsize i;\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SHARED, NULL))\n    {\n      g_auto(GStrv) shares = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                         FLATPAK_METADATA_KEY_SHARED, NULL, error);\n      if (shares == NULL)\n        return FALSE;\n\n      for (i = 0; shares[i] != NULL; i++)\n        {\n          FlatpakContextShares share;\n\n          share = flatpak_context_share_from_string (parse_negated (shares[i], &remove), NULL);\n          if (share == 0)\n            g_info (\"Unknown share type %s\", shares[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_shares (context, share);\n              else\n                flatpak_context_add_shares (context, share);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SOCKETS, NULL))\n    {\n      g_auto(GStrv) sockets = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                          FLATPAK_METADATA_KEY_SOCKETS, NULL, error);\n      if (sockets == NULL)\n        return FALSE;\n\n      for (i = 0; sockets[i] != NULL; i++)\n        {\n          FlatpakContextSockets socket = flatpak_context_socket_from_string (parse_negated (sockets[i], &remove), NULL);\n          if (socket == 0)\n            g_info (\"Unknown socket type %s\", sockets[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_sockets (context, socket);\n              else\n                flatpak_context_add_sockets (context, socket);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_DEVICES, NULL))\n    {\n      g_auto(GStrv) devices = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                          FLATPAK_METADATA_KEY_DEVICES, NULL, error);\n      if (devices == NULL)\n        return FALSE;\n\n\n      for (i = 0; devices[i] != NULL; i++)\n        {\n          FlatpakContextDevices device = flatpak_context_device_from_string (parse_negated (devices[i], &remove), NULL);\n          if (device == 0)\n            g_info (\"Unknown device type %s\", devices[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_devices (context, device);\n              else\n                flatpak_context_add_devices (context, device);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FEATURES, NULL))\n    {\n      g_auto(GStrv) features = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                           FLATPAK_METADATA_KEY_FEATURES, NULL, error);\n      if (features == NULL)\n        return FALSE;\n\n\n      for (i = 0; features[i] != NULL; i++)\n        {\n          FlatpakContextFeatures feature = flatpak_context_feature_from_string (parse_negated (features[i], &remove), NULL);\n          if (feature == 0)\n            g_info (\"Unknown feature type %s\", features[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_features (context, feature);\n              else\n                flatpak_context_add_features (context, feature);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FILESYSTEMS, NULL))\n    {\n      g_auto(GStrv) filesystems = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                              FLATPAK_METADATA_KEY_FILESYSTEMS, NULL, error);\n      if (filesystems == NULL)\n        return FALSE;\n\n      for (i = 0; filesystems[i] != NULL; i++)\n        {\n          const char *fs = parse_negated (filesystems[i], &remove);\n          g_autofree char *filesystem = NULL;\n          FlatpakFilesystemMode mode;\n\n          if (!flatpak_context_parse_filesystem (fs, remove,\n                                                 &filesystem, &mode, NULL))\n            g_info (\"Unknown filesystem type %s\", filesystems[i]);\n          else\n            {\n              g_assert (mode == FLATPAK_FILESYSTEM_MODE_NONE || !remove);\n              flatpak_context_take_filesystem (context, g_steal_pointer (&filesystem), mode);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_PERSISTENT, NULL))\n    {\n      g_auto(GStrv) persistent = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                             FLATPAK_METADATA_KEY_PERSISTENT, NULL, error);\n      if (persistent == NULL)\n        return FALSE;\n\n      for (i = 0; persistent[i] != NULL; i++)\n        flatpak_context_set_persistent (context, persistent[i]);\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, key, NULL);\n          FlatpakPolicy policy;\n\n          if (!flatpak_verify_dbus_name (key, error))\n            return FALSE;\n\n          policy = flatpak_policy_from_string (value, NULL);\n          if ((int) policy != -1)\n            flatpak_context_set_session_bus_policy (context, key, policy);\n        }\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, key, NULL);\n          FlatpakPolicy policy;\n\n          if (!flatpak_verify_dbus_name (key, error))\n            return FALSE;\n\n          policy = flatpak_policy_from_string (value, NULL);\n          if ((int) policy != -1)\n            flatpak_context_set_system_bus_policy (context, key, policy);\n        }\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, key, NULL);\n\n          flatpak_context_set_env_var (context, key, value);\n        }\n    }\n\n  /* unset-environment is higher precedence than Environment, so that\n   * we can put unset keys in both places. Old versions of Flatpak will\n   * interpret the empty string as unset; new versions will obey\n   * unset-environment. */\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT, NULL))\n    {\n      g_auto(GStrv) vars = NULL;\n      gsize vars_count;\n\n      vars = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                         FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT,\n                                         &vars_count, error);\n\n      if (vars == NULL)\n        return FALSE;\n\n      for (i = 0; i < vars_count; i++)\n        {\n          const char *var = vars[i];\n\n          flatpak_context_set_env_var (context, var, NULL);\n        }\n    }\n\n  groups = g_key_file_get_groups (metakey, NULL);\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      const char *group = groups[i];\n      const char *subsystem;\n      int j;\n\n      if (g_str_has_prefix (group, FLATPAK_METADATA_GROUP_PREFIX_POLICY))\n        {\n          g_auto(GStrv) keys = NULL;\n          subsystem = group + strlen (FLATPAK_METADATA_GROUP_PREFIX_POLICY);\n          keys = g_key_file_get_keys (metakey, group, NULL, NULL);\n          for (j = 0; keys != NULL && keys[j] != NULL; j++)\n            {\n              const char *key = keys[j];\n              g_autofree char *policy_key = g_strdup_printf (\"%s.%s\", subsystem, key);\n              g_auto(GStrv) values = NULL;\n              int k;\n\n              values = g_key_file_get_string_list (metakey, group, key, NULL, NULL);\n              for (k = 0; values != NULL && values[k] != NULL; k++)\n                flatpak_context_apply_generic_policy (context, policy_key,\n                                                      values[k]);\n            }\n        }\n    }\n\n  return TRUE;\n}",
        "func_after": "gboolean\nflatpak_context_load_metadata (FlatpakContext *context,\n                               GKeyFile       *metakey,\n                               GError        **error)\n{\n  gboolean remove;\n  g_auto(GStrv) groups = NULL;\n  gsize i;\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SHARED, NULL))\n    {\n      g_auto(GStrv) shares = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                         FLATPAK_METADATA_KEY_SHARED, NULL, error);\n      if (shares == NULL)\n        return FALSE;\n\n      for (i = 0; shares[i] != NULL; i++)\n        {\n          FlatpakContextShares share;\n\n          share = flatpak_context_share_from_string (parse_negated (shares[i], &remove), NULL);\n          if (share == 0)\n            g_info (\"Unknown share type %s\", shares[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_shares (context, share);\n              else\n                flatpak_context_add_shares (context, share);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SOCKETS, NULL))\n    {\n      g_auto(GStrv) sockets = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                          FLATPAK_METADATA_KEY_SOCKETS, NULL, error);\n      if (sockets == NULL)\n        return FALSE;\n\n      for (i = 0; sockets[i] != NULL; i++)\n        {\n          FlatpakContextSockets socket = flatpak_context_socket_from_string (parse_negated (sockets[i], &remove), NULL);\n          if (socket == 0)\n            g_info (\"Unknown socket type %s\", sockets[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_sockets (context, socket);\n              else\n                flatpak_context_add_sockets (context, socket);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_DEVICES, NULL))\n    {\n      g_auto(GStrv) devices = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                          FLATPAK_METADATA_KEY_DEVICES, NULL, error);\n      if (devices == NULL)\n        return FALSE;\n\n\n      for (i = 0; devices[i] != NULL; i++)\n        {\n          FlatpakContextDevices device = flatpak_context_device_from_string (parse_negated (devices[i], &remove), NULL);\n          if (device == 0)\n            g_info (\"Unknown device type %s\", devices[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_devices (context, device);\n              else\n                flatpak_context_add_devices (context, device);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FEATURES, NULL))\n    {\n      g_auto(GStrv) features = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                           FLATPAK_METADATA_KEY_FEATURES, NULL, error);\n      if (features == NULL)\n        return FALSE;\n\n\n      for (i = 0; features[i] != NULL; i++)\n        {\n          FlatpakContextFeatures feature = flatpak_context_feature_from_string (parse_negated (features[i], &remove), NULL);\n          if (feature == 0)\n            g_info (\"Unknown feature type %s\", features[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_features (context, feature);\n              else\n                flatpak_context_add_features (context, feature);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FILESYSTEMS, NULL))\n    {\n      g_auto(GStrv) filesystems = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                              FLATPAK_METADATA_KEY_FILESYSTEMS, NULL, error);\n      if (filesystems == NULL)\n        return FALSE;\n\n      for (i = 0; filesystems[i] != NULL; i++)\n        {\n          const char *fs = parse_negated (filesystems[i], &remove);\n          g_autofree char *filesystem = NULL;\n          g_autoptr(GError) local_error = NULL;\n          FlatpakFilesystemMode mode;\n\n          if (!flatpak_context_parse_filesystem (fs, remove,\n                                                 &filesystem, &mode, &local_error))\n            {\n              if (g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA))\n                {\n                  /* Invalid characters, so just hard-fail. */\n                  g_propagate_error (error, g_steal_pointer (&local_error));\n                  return FALSE;\n                }\n              else\n                {\n                  g_info (\"Unknown filesystem type %s\", filesystems[i]);\n                  g_clear_error (&local_error);\n                }\n            }\n          else\n            {\n              g_assert (mode == FLATPAK_FILESYSTEM_MODE_NONE || !remove);\n              flatpak_context_take_filesystem (context, g_steal_pointer (&filesystem), mode);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_PERSISTENT, NULL))\n    {\n      g_auto(GStrv) persistent = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                             FLATPAK_METADATA_KEY_PERSISTENT, NULL, error);\n      if (persistent == NULL)\n        return FALSE;\n\n      for (i = 0; persistent[i] != NULL; i++)\n        if (!flatpak_context_set_persistent (context, persistent[i], error))\n          return FALSE;\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, key, NULL);\n          FlatpakPolicy policy;\n\n          if (!flatpak_verify_dbus_name (key, error))\n            return FALSE;\n\n          policy = flatpak_policy_from_string (value, NULL);\n          if ((int) policy != -1)\n            flatpak_context_set_session_bus_policy (context, key, policy);\n        }\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, key, NULL);\n          FlatpakPolicy policy;\n\n          if (!flatpak_verify_dbus_name (key, error))\n            return FALSE;\n\n          policy = flatpak_policy_from_string (value, NULL);\n          if ((int) policy != -1)\n            flatpak_context_set_system_bus_policy (context, key, policy);\n        }\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, key, NULL);\n\n          flatpak_context_set_env_var (context, key, value);\n        }\n    }\n\n  /* unset-environment is higher precedence than Environment, so that\n   * we can put unset keys in both places. Old versions of Flatpak will\n   * interpret the empty string as unset; new versions will obey\n   * unset-environment. */\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT, NULL))\n    {\n      g_auto(GStrv) vars = NULL;\n      gsize vars_count;\n\n      vars = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                         FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT,\n                                         &vars_count, error);\n\n      if (vars == NULL)\n        return FALSE;\n\n      for (i = 0; i < vars_count; i++)\n        {\n          const char *var = vars[i];\n\n          flatpak_context_set_env_var (context, var, NULL);\n        }\n    }\n\n  groups = g_key_file_get_groups (metakey, NULL);\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      const char *group = groups[i];\n      const char *subsystem;\n      int j;\n\n      if (g_str_has_prefix (group, FLATPAK_METADATA_GROUP_PREFIX_POLICY))\n        {\n          g_auto(GStrv) keys = NULL;\n          subsystem = group + strlen (FLATPAK_METADATA_GROUP_PREFIX_POLICY);\n          keys = g_key_file_get_keys (metakey, group, NULL, NULL);\n          for (j = 0; keys != NULL && keys[j] != NULL; j++)\n            {\n              const char *key = keys[j];\n              g_autofree char *policy_key = g_strdup_printf (\"%s.%s\", subsystem, key);\n              g_auto(GStrv) values = NULL;\n              int k;\n\n              values = g_key_file_get_string_list (metakey, group, key, NULL, NULL);\n              for (k = 0; values != NULL && values[k] != NULL; k++)\n                flatpak_context_apply_generic_policy (context, policy_key,\n                                                      values[k]);\n            }\n        }\n    }\n\n  return TRUE;\n}",
        "description": "In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, Flatpak allowed attackers to publish applications with elevated permissions while hiding these permissions from users through the `flatpak(1)` command-line interface. This was achieved by setting other permissions to crafted values containing non-printable control characters such as `ESC`. A fix is available in the mentioned versions. As a workaround, users are advised to use a graphical user interface like GNOME Software instead of the command-line interface, or to only install applications from trusted maintainers.",
        "commit": "Rejecting paths containing special characters provided to --filesystem/--persist options to mitigate potential security risks associated with displaying such text."
    },
    {
        "cwe": "CWE-94",
        "func_name": "binutils-gdb/setup_group",
        "score": 0.7029497027397156,
        "func_before": "static bfd_boolean\nsetup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)\n{\n  unsigned int num_group = elf_tdata (abfd)->num_group;\n\n  /* If num_group is zero, read in all SHT_GROUP sections.  The count\n     is set to -1 if there are no SHT_GROUP sections.  */\n  if (num_group == 0)\n    {\n      unsigned int i, shnum;\n\n      /* First count the number of groups.  If we have a SHT_GROUP\n\t section with just a flag word (ie. sh_size is 4), ignore it.  */\n      shnum = elf_numsections (abfd);\n      num_group = 0;\n\n#define IS_VALID_GROUP_SECTION_HEADER(shdr, minsize)\t\\\n\t(   (shdr)->sh_type == SHT_GROUP\t\t\\\n\t && (shdr)->sh_size >= minsize\t\t\t\\\n\t && (shdr)->sh_entsize == GRP_ENTRY_SIZE\t\\\n\t && ((shdr)->sh_size % GRP_ENTRY_SIZE) == 0)\n\n      for (i = 0; i < shnum; i++)\n\t{\n\t  Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];\n\n\t  if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))\n\t    num_group += 1;\n\t}\n\n      if (num_group == 0)\n\t{\n\t  num_group = (unsigned) -1;\n\t  elf_tdata (abfd)->num_group = num_group;\n\t}\n      else\n\t{\n\t  /* We keep a list of elf section headers for group sections,\n\t     so we can find them quickly.  */\n\t  bfd_size_type amt;\n\n\t  elf_tdata (abfd)->num_group = num_group;\n\t  elf_tdata (abfd)->group_sect_ptr = (Elf_Internal_Shdr **)\n              bfd_alloc2 (abfd, num_group, sizeof (Elf_Internal_Shdr *));\n\t  if (elf_tdata (abfd)->group_sect_ptr == NULL)\n\t    return FALSE;\n\n\t  num_group = 0;\n\t  for (i = 0; i < shnum; i++)\n\t    {\n\t      Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];\n\n\t      if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))\n\t\t{\n\t\t  unsigned char *src;\n\t\t  Elf_Internal_Group *dest;\n\n\t\t  /* Add to list of sections.  */\n\t\t  elf_tdata (abfd)->group_sect_ptr[num_group] = shdr;\n\t\t  num_group += 1;\n\n\t\t  /* Read the raw contents.  */\n\t\t  BFD_ASSERT (sizeof (*dest) >= 4);\n\t\t  amt = shdr->sh_size * sizeof (*dest) / 4;\n\t\t  shdr->contents = (unsigned char *)\n                      bfd_alloc2 (abfd, shdr->sh_size, sizeof (*dest) / 4);\n\t\t  /* PR binutils/4110: Handle corrupt group headers.  */\n\t\t  if (shdr->contents == NULL)\n\t\t    {\n\t\t      _bfd_error_handler\n\t\t\t(_(\"%B: Corrupt size field in group section header: 0x%lx\"), abfd, shdr->sh_size);\n\t\t      bfd_set_error (bfd_error_bad_value);\n\t\t      return FALSE;\n\t\t    }\n\n\t\t  memset (shdr->contents, 0, amt);\n\n\t\t  if (bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0\n\t\t      || (bfd_bread (shdr->contents, shdr->sh_size, abfd)\n\t\t\t  != shdr->sh_size))\n\t\t    return FALSE;\n\n\t\t  /* Translate raw contents, a flag word followed by an\n\t\t     array of elf section indices all in target byte order,\n\t\t     to the flag word followed by an array of elf section\n\t\t     pointers.  */\n\t\t  src = shdr->contents + shdr->sh_size;\n\t\t  dest = (Elf_Internal_Group *) (shdr->contents + amt);\n\t\t  while (1)\n\t\t    {\n\t\t      unsigned int idx;\n\n\t\t      src -= 4;\n\t\t      --dest;\n\t\t      idx = H_GET_32 (abfd, src);\n\t\t      if (src == shdr->contents)\n\t\t\t{\n\t\t\t  dest->flags = idx;\n\t\t\t  if (shdr->bfd_section != NULL && (idx & GRP_COMDAT))\n\t\t\t    shdr->bfd_section->flags\n\t\t\t      |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;\n\t\t\t  break;\n\t\t\t}\n\t\t      if (idx >= shnum)\n\t\t\t{\n\t\t\t  ((*_bfd_error_handler)\n\t\t\t   (_(\"%B: invalid SHT_GROUP entry\"), abfd));\n\t\t\t  idx = 0;\n\t\t\t}\n\t\t      dest->shdr = elf_elfsections (abfd)[idx];\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n  if (num_group != (unsigned) -1)\n    {\n      unsigned int i;\n\n      for (i = 0; i < num_group; i++)\n\t{\n\t  Elf_Internal_Shdr *shdr = elf_tdata (abfd)->group_sect_ptr[i];\n\t  Elf_Internal_Group *idx = (Elf_Internal_Group *) shdr->contents;\n\t  unsigned int n_elt = shdr->sh_size / 4;\n\n\t  /* Look through this group's sections to see if current\n\t     section is a member.  */\n\t  while (--n_elt != 0)\n\t    if ((++idx)->shdr == hdr)\n\t      {\n\t\tasection *s = NULL;\n\n\t\t/* We are a member of this group.  Go looking through\n\t\t   other members to see if any others are linked via\n\t\t   next_in_group.  */\n\t\tidx = (Elf_Internal_Group *) shdr->contents;\n\t\tn_elt = shdr->sh_size / 4;\n\t\twhile (--n_elt != 0)\n\t\t  if ((s = (++idx)->shdr->bfd_section) != NULL\n\t\t      && elf_next_in_group (s) != NULL)\n\t\t    break;\n\t\tif (n_elt != 0)\n\t\t  {\n\t\t    /* Snarf the group name from other member, and\n\t\t       insert current section in circular list.  */\n\t\t    elf_group_name (newsect) = elf_group_name (s);\n\t\t    elf_next_in_group (newsect) = elf_next_in_group (s);\n\t\t    elf_next_in_group (s) = newsect;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    const char *gname;\n\n\t\t    gname = group_signature (abfd, shdr);\n\t\t    if (gname == NULL)\n\t\t      return FALSE;\n\t\t    elf_group_name (newsect) = gname;\n\n\t\t    /* Start a circular list with one element.  */\n\t\t    elf_next_in_group (newsect) = newsect;\n\t\t  }\n\n\t\t/* If the group section has been created, point to the\n\t\t   new member.  */\n\t\tif (shdr->bfd_section != NULL)\n\t\t  elf_next_in_group (shdr->bfd_section) = newsect;\n\n\t\ti = num_group - 1;\n\t\tbreak;\n\t      }\n\t}\n    }\n\n  if (elf_group_name (newsect) == NULL)\n    {\n      (*_bfd_error_handler) (_(\"%B: no group info for section %A\"),\n\t\t\t     abfd, newsect);\n    }\n  return TRUE;\n}",
        "func_after": "static bfd_boolean\nsetup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)\n{\n  unsigned int num_group = elf_tdata (abfd)->num_group;\n\n  /* If num_group is zero, read in all SHT_GROUP sections.  The count\n     is set to -1 if there are no SHT_GROUP sections.  */\n  if (num_group == 0)\n    {\n      unsigned int i, shnum;\n\n      /* First count the number of groups.  If we have a SHT_GROUP\n\t section with just a flag word (ie. sh_size is 4), ignore it.  */\n      shnum = elf_numsections (abfd);\n      num_group = 0;\n\n#define IS_VALID_GROUP_SECTION_HEADER(shdr, minsize)\t\\\n\t(   (shdr)->sh_type == SHT_GROUP\t\t\\\n\t && (shdr)->sh_size >= minsize\t\t\t\\\n\t && (shdr)->sh_entsize == GRP_ENTRY_SIZE\t\\\n\t && ((shdr)->sh_size % GRP_ENTRY_SIZE) == 0)\n\n      for (i = 0; i < shnum; i++)\n\t{\n\t  Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];\n\n\t  if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))\n\t    num_group += 1;\n\t}\n\n      if (num_group == 0)\n\t{\n\t  num_group = (unsigned) -1;\n\t  elf_tdata (abfd)->num_group = num_group;\n\t}\n      else\n\t{\n\t  /* We keep a list of elf section headers for group sections,\n\t     so we can find them quickly.  */\n\t  bfd_size_type amt;\n\n\t  elf_tdata (abfd)->num_group = num_group;\n\t  elf_tdata (abfd)->group_sect_ptr = (Elf_Internal_Shdr **)\n              bfd_alloc2 (abfd, num_group, sizeof (Elf_Internal_Shdr *));\n\t  if (elf_tdata (abfd)->group_sect_ptr == NULL)\n\t    return FALSE;\n\n\t  num_group = 0;\n\t  for (i = 0; i < shnum; i++)\n\t    {\n\t      Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];\n\n\t      if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))\n\t\t{\n\t\t  unsigned char *src;\n\t\t  Elf_Internal_Group *dest;\n\n\t\t  /* Add to list of sections.  */\n\t\t  elf_tdata (abfd)->group_sect_ptr[num_group] = shdr;\n\t\t  num_group += 1;\n\n\t\t  /* Read the raw contents.  */\n\t\t  BFD_ASSERT (sizeof (*dest) >= 4);\n\t\t  amt = shdr->sh_size * sizeof (*dest) / 4;\n\t\t  shdr->contents = (unsigned char *)\n                      bfd_alloc2 (abfd, shdr->sh_size, sizeof (*dest) / 4);\n\t\t  /* PR binutils/4110: Handle corrupt group headers.  */\n\t\t  if (shdr->contents == NULL)\n\t\t    {\n\t\t      _bfd_error_handler\n\t\t\t(_(\"%B: corrupt size field in group section header: 0x%lx\"), abfd, shdr->sh_size);\n\t\t      bfd_set_error (bfd_error_bad_value);\n\t\t      -- num_group;\n\t\t      continue;\n\t\t    }\n\n\t\t  memset (shdr->contents, 0, amt);\n\n\t\t  if (bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0\n\t\t      || (bfd_bread (shdr->contents, shdr->sh_size, abfd)\n\t\t\t  != shdr->sh_size))\n\t\t    {\n\t\t      _bfd_error_handler\n\t\t\t(_(\"%B: invalid size field in group section header: 0x%lx\"), abfd, shdr->sh_size);\n\t\t      bfd_set_error (bfd_error_bad_value);\n\t\t      -- num_group;\n\t\t      /* PR 17510: If the group contents are even partially\n\t\t\t corrupt, do not allow any of the contents to be used.  */\n\t\t      memset (shdr->contents, 0, amt);\n\t\t      continue;\n\t\t    }\n\t\t  \n\t\t  /* Translate raw contents, a flag word followed by an\n\t\t     array of elf section indices all in target byte order,\n\t\t     to the flag word followed by an array of elf section\n\t\t     pointers.  */\n\t\t  src = shdr->contents + shdr->sh_size;\n\t\t  dest = (Elf_Internal_Group *) (shdr->contents + amt);\n\t\t  while (1)\n\t\t    {\n\t\t      unsigned int idx;\n\n\t\t      src -= 4;\n\t\t      --dest;\n\t\t      idx = H_GET_32 (abfd, src);\n\t\t      if (src == shdr->contents)\n\t\t\t{\n\t\t\t  dest->flags = idx;\n\t\t\t  if (shdr->bfd_section != NULL && (idx & GRP_COMDAT))\n\t\t\t    shdr->bfd_section->flags\n\t\t\t      |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;\n\t\t\t  break;\n\t\t\t}\n\t\t      if (idx >= shnum)\n\t\t\t{\n\t\t\t  ((*_bfd_error_handler)\n\t\t\t   (_(\"%B: invalid SHT_GROUP entry\"), abfd));\n\t\t\t  idx = 0;\n\t\t\t}\n\t\t      dest->shdr = elf_elfsections (abfd)[idx];\n\t\t    }\n\t\t}\n\t    }\n\n\t  /* PR 17510: Corrupt binaries might contain invalid groups.  */\n\t  if (num_group != (unsigned) elf_tdata (abfd)->num_group)\n\t    {\n\t      elf_tdata (abfd)->num_group = num_group;\n\n\t      /* If all groups are invalid then fail.  */\n\t      if (num_group == 0)\n\t\t{\n\t\t  elf_tdata (abfd)->group_sect_ptr = NULL;\n\t\t  elf_tdata (abfd)->num_group = num_group = -1;\n\t\t  (*_bfd_error_handler) (_(\"%B: no valid group sections found\"), abfd);\n\t\t  bfd_set_error (bfd_error_bad_value);\n\t\t}\n\t    }\n\t}\n    }\n\n  if (num_group != (unsigned) -1)\n    {\n      unsigned int i;\n\n      for (i = 0; i < num_group; i++)\n\t{\n\t  Elf_Internal_Shdr *shdr = elf_tdata (abfd)->group_sect_ptr[i];\n\t  Elf_Internal_Group *idx = (Elf_Internal_Group *) shdr->contents;\n\t  unsigned int n_elt = shdr->sh_size / 4;\n\n\t  /* Look through this group's sections to see if current\n\t     section is a member.  */\n\t  while (--n_elt != 0)\n\t    if ((++idx)->shdr == hdr)\n\t      {\n\t\tasection *s = NULL;\n\n\t\t/* We are a member of this group.  Go looking through\n\t\t   other members to see if any others are linked via\n\t\t   next_in_group.  */\n\t\tidx = (Elf_Internal_Group *) shdr->contents;\n\t\tn_elt = shdr->sh_size / 4;\n\t\twhile (--n_elt != 0)\n\t\t  if ((s = (++idx)->shdr->bfd_section) != NULL\n\t\t      && elf_next_in_group (s) != NULL)\n\t\t    break;\n\t\tif (n_elt != 0)\n\t\t  {\n\t\t    /* Snarf the group name from other member, and\n\t\t       insert current section in circular list.  */\n\t\t    elf_group_name (newsect) = elf_group_name (s);\n\t\t    elf_next_in_group (newsect) = elf_next_in_group (s);\n\t\t    elf_next_in_group (s) = newsect;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    const char *gname;\n\n\t\t    gname = group_signature (abfd, shdr);\n\t\t    if (gname == NULL)\n\t\t      return FALSE;\n\t\t    elf_group_name (newsect) = gname;\n\n\t\t    /* Start a circular list with one element.  */\n\t\t    elf_next_in_group (newsect) = newsect;\n\t\t  }\n\n\t\t/* If the group section has been created, point to the\n\t\t   new member.  */\n\t\tif (shdr->bfd_section != NULL)\n\t\t  elf_next_in_group (shdr->bfd_section) = newsect;\n\n\t\ti = num_group - 1;\n\t\tbreak;\n\t      }\n\t}\n    }\n\n  if (elf_group_name (newsect) == NULL)\n    {\n      (*_bfd_error_handler) (_(\"%B: no group info for section %A\"),\n\t\t\t     abfd, newsect);\n      return FALSE;\n    }\n  return TRUE;\n}",
        "description": "The `setup_group` function in the `bfd/elf.c` file of the GNU binutils library, versions 2.24 and earlier, is vulnerable to a denial of service (crash) and potential arbitrary code execution by remote attackers. This vulnerability arises from the handling of crafted section group headers in an ELF file.",
        "commit": "This patch addresses a potential security vulnerability in applications that utilize the bfd library to parse binaries. Specifically, it enhances the handling of corrupt section group headers, which could be exploited by maliciously crafted binaries to cause issues such as buffer overflows or other security breaches."
    }
]