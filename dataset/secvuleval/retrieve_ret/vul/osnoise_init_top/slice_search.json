[
    {
        "cwe": "CWE-909",
        "func_name": "eclipse-openj9/resolveStaticMethodRefInto",
        "score": 0.7887591123580933,
        "func_before": "J9Method *   \nresolveStaticMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMStaticMethodRef *ramCPEntry)\n{\n\tJ9ROMMethodRef *romMethodRef;\n\tJ9Class *resolvedClass;\n\tJ9Method *method = NULL;\n\tJ9Class *cpClass;\n\tJ9Class *methodClass = NULL;\n\tBOOLEAN isResolvedClassAnInterface = FALSE;\n\tJ9ROMNameAndSignature *nameAndSig = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveStaticMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\ntryAgain:\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\tnameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\t/* Stack allocate a J9NameAndSignature structure for polymorphic signature methods */\n\tJ9NameAndSignature onStackNAS = {NULL, NULL};\n\tJ9UTF8 nullSignature = {0};\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\tif (resolvedClass == NULL) {\n\t\tgoto done;\n\t}\n\tisResolvedClassAnInterface = (J9AccInterface == (resolvedClass->romClass->modifiers & J9AccInterface));\n\n\t/* Find the method. */\n\tlookupOptions |= J9_LOOK_STATIC;\n\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) == J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\tcpClass = NULL;\n\t} else {\n\t\tcpClass = J9_CLASS_FROM_CP(ramCP);\n\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\n\t\tif (J2SE_VERSION(vmStruct->javaVM) >= J2SE_V11) {\n\t\t\t/* This check is only required in Java9 and there have been applications that\n\t\t\t * fail when this check is enabled on Java8.\n\t\t\t */\n\t\t\tif ((cpClass != NULL) && (cpClass->romClass != NULL)) {\n\t\t\t\tUDATA cpType = J9_CP_TYPE(J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass), cpIndex);\n\t\t\t\tif (isResolvedClassAnInterface) {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_STATIC_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_INSTANCE_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_METHOD != cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_STATIC_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_INSTANCE_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_METHOD == cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (isResolvedClassAnInterface) {\n\t\tlookupOptions |= J9_LOOK_INTERFACE;\n\t}\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vmStruct->javaVM)) {\n\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t/**\n\t\t * Check for MH intrinsic methods\n\t\t *\n\t\t * Modify the signature to avoid signature mismatch due to varargs\n\t\t * These methods have special INL send targets\n\t\t */\n\t\tU_8* methodName = J9UTF8_DATA(nameUTF);\n\t\tU_16 methodNameLength = J9UTF8_LENGTH(nameUTF);\n\n\t\tif (isMethodHandleINL(methodName, methodNameLength)) {\n\t\t\t/* Create new J9NameAndSignature */\n\t\t\tonStackNAS.name = nameUTF;\n\t\t\tonStackNAS.signature = &nullSignature;\n\t\t\tnameAndSig = (J9ROMNameAndSignature *)(&onStackNAS);\n\n\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n\t\t\tlookupOptions |= (J9_LOOK_DIRECT_NAS | J9_LOOK_PARTIAL_SIGNATURE);\n\t\t}\n\t}\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, nameAndSig, cpClass, lookupOptions);\n\n\tTrc_VM_resolveStaticMethodRef_lookupMethod(vmStruct, method);\n\n\tif (method == NULL) {\n\t\tgoto done;\n\t}\n\n\tmethodClass = J9_CLASS_FROM_METHOD(method);\n\tif (methodClass != resolvedClass) {\n\t\tif (isResolvedClassAnInterface) {\nincompat:\n\t\t\tif (throwException) {\n\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, NULL);\n\t\t\t}\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Initialize the defining class of the method. */\n\t\n\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CLASS_INIT)) {\n\t\tJ9Class *methodClass = J9_CLASS_FROM_METHOD(method);\n\t\tUDATA initStatus = methodClass->initializeStatus;\n\t\tif (jitCompileTimeResolve && (J9ClassInitSucceeded != initStatus)) {\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t\tif (initStatus != J9ClassInitSucceeded && initStatus != (UDATA)vmStruct) {\n\t\t\t/* Initialize the class if java code is allowed */\n\t\t\tif (canRunJavaCode) {\n\t\t\t\tUDATA preCount = vmStruct->javaVM->hotSwapCount;\n\n\t\t\t\tinitializeClass(vmStruct, methodClass);\n\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\tmethod = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (preCount != vmStruct->javaVM->hotSwapCount) {\n\t\t\t\t\tgoto tryAgain;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Can't initialize the class, so fail the resolve */\n\t\t\t\tmethod = NULL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tif (NULL != ramCPEntry)\n\t{\n\t\tramCPEntry->method = method;\n\t}\n\ndone:\n\tTrc_VM_resolveStaticMethodRef_Exit(vmStruct, method);\n\treturn method;\n}",
        "func_after": "J9Method *   \nresolveStaticMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMStaticMethodRef *ramCPEntry)\n{\n\tJ9ROMMethodRef *romMethodRef;\n\tJ9Class *resolvedClass;\n\tJ9Method *method = NULL;\n\tJ9Class *cpClass;\n\tJ9Class *methodClass = NULL;\n\tBOOLEAN isResolvedClassAnInterface = FALSE;\n\tJ9ROMNameAndSignature *nameAndSig = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveStaticMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\ntryAgain:\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\tnameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\t/* Stack allocate a J9NameAndSignature structure for polymorphic signature methods */\n\tJ9NameAndSignature onStackNAS = {NULL, NULL};\n\tJ9UTF8 nullSignature = {0};\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\tif (resolvedClass == NULL) {\n\t\tgoto done;\n\t}\n\tisResolvedClassAnInterface = (J9AccInterface == (resolvedClass->romClass->modifiers & J9AccInterface));\n\n\t/* Find the method. */\n\tlookupOptions |= J9_LOOK_STATIC;\n\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) == J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\tcpClass = NULL;\n\t} else {\n\t\tcpClass = J9_CLASS_FROM_CP(ramCP);\n\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\n\t\tif (J2SE_VERSION(vmStruct->javaVM) >= J2SE_V11) {\n\t\t\t/* This check is only required in Java9 and there have been applications that\n\t\t\t * fail when this check is enabled on Java8.\n\t\t\t */\n\t\t\tif ((cpClass != NULL) && (cpClass->romClass != NULL)) {\n\t\t\t\tUDATA cpType = J9_CP_TYPE(J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass), cpIndex);\n\t\t\t\tif (isResolvedClassAnInterface) {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_STATIC_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_INSTANCE_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_METHOD != cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_STATIC_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_INSTANCE_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_METHOD == cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (isResolvedClassAnInterface) {\n\t\tlookupOptions |= J9_LOOK_INTERFACE;\n\t}\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vmStruct->javaVM)) {\n\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t/**\n\t\t * Check for MH intrinsic methods\n\t\t *\n\t\t * Modify the signature to avoid signature mismatch due to varargs\n\t\t * These methods have special INL send targets\n\t\t */\n\t\tU_8* methodName = J9UTF8_DATA(nameUTF);\n\t\tU_16 methodNameLength = J9UTF8_LENGTH(nameUTF);\n\n\t\tif (isMethodHandleINL(methodName, methodNameLength)) {\n\t\t\t/* Create new J9NameAndSignature */\n\t\t\tonStackNAS.name = nameUTF;\n\t\t\tonStackNAS.signature = &nullSignature;\n\t\t\tnameAndSig = (J9ROMNameAndSignature *)(&onStackNAS);\n\n\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n\t\t\tlookupOptions |= (J9_LOOK_DIRECT_NAS | J9_LOOK_PARTIAL_SIGNATURE);\n\t\t}\n\t}\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, nameAndSig, cpClass, lookupOptions);\n\n\tTrc_VM_resolveStaticMethodRef_lookupMethod(vmStruct, method);\n\n\tif (method == NULL) {\n\t\tgoto done;\n\t}\n\n\tmethodClass = J9_CLASS_FROM_METHOD(method);\n\tif (methodClass != resolvedClass) {\n\t\tif (isResolvedClassAnInterface) {\nincompat:\n\t\t\tif (throwException) {\n\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, NULL);\n\t\t\t}\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Initialize the defining class of the method. */\n\t\n\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CLASS_INIT)) {\n\t\tJ9Class *methodClass = J9_CLASS_FROM_METHOD(method);\n\t\tUDATA initStatus = methodClass->initializeStatus;\n\t\tif (jitCompileTimeResolve && (J9ClassInitSucceeded != initStatus)) {\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t\tif (initStatus != J9ClassInitSucceeded && initStatus != (UDATA)vmStruct) {\n\t\t\t/* Initialize the class if java code is allowed */\n\t\t\tif (canRunJavaCode) {\n\t\t\t\tUDATA preCount = vmStruct->javaVM->hotSwapCount;\n\n\t\t\t\tinitializeClass(vmStruct, methodClass);\n\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\tmethod = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (preCount != vmStruct->javaVM->hotSwapCount) {\n\t\t\t\t\tgoto tryAgain;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Can't initialize the class, so fail the resolve */\n\t\t\t\tmethod = NULL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\tramCPEntry->method = method;\n\t}\n\ndone:\n\tTrc_VM_resolveStaticMethodRef_Exit(vmStruct, method);\n\treturn method;\n}",
        "description": "In Eclipse OpenJ9 up to version 0.25.0, the use of the `jdk.internal.reflect.ConstantPool` API leads to the JVM pre-resolving certain constant pool entries in some cases. This behavior enables users to invoke static methods or access static members without executing the class initialization method, potentially allowing them to observe uninitialized values.",
        "commit": "When utilizing ConstantPool, ensure that classes are correctly loaded and initialized. Avoid loading classes during \"ifLoaded\" calls, refrain from initializing classes in native methods, and do not update the constant pool when querying from native methods."
    },
    {
        "cwe": "CWE-404",
        "func_name": "wireshark/dissect_iscsi",
        "score": 0.7807881832122803,
        "func_before": "static int\ndissect_iscsi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean check_port) {\n    /* Set up structures needed to add the protocol subtree and manage it */\n    guint offset = 0;\n    guint32 available_bytes = tvb_captured_length(tvb);\n    int digestsActive = 1;\n    conversation_t *conversation = NULL;\n    iscsi_session_t *iscsi_session=NULL;\n    guint8 opcode, tmpbyte;\n\n    if (available_bytes < 48) {\n        /* heuristic already rejected the packet if size < 48,\n           assume it's an iscsi packet with a segmented header */\n        pinfo->desegment_offset = offset;\n        pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\n        return -1;\n    }\n\n    opcode = tvb_get_guint8(tvb, offset + 0);\n    opcode &= OPCODE_MASK;\n\n    /* heuristics to verify that the packet looks sane.   the heuristics\n     * are based on the RFC version of iscsi.\n     * (we should retire support for older iscsi versions in wireshark)\n     *      -- ronnie s\n     */\n    /* opcode must be any of the ones from the standard\n     * also check the header that it looks \"sane\"\n     * all reserved or undefined bits in iscsi must be set to zero.\n     */\n    switch(opcode){\n    case ISCSI_OPCODE_NOP_IN:\n        /* top two bits of byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2 and 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_NOP_OUT:\n        /* top bit of byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2 and 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        /* assume ITT and TTT must always be non NULL (ok they can be NULL\n         * from time to time but it usually means we are in the middle\n         * of a zeroed datablock).\n         */\n        if(!tvb_get_letohl(tvb,offset+16) || !tvb_get_letohl(tvb,offset+20)){\n            return 0;\n        }\n        /* all reserved bytes between 32 - 47 must be null */\n        if(tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGIN_COMMAND:\n        /* top two bits in byte 0 must be 0x40 */\n        if((tvb_get_guint8(tvb, offset+0)&0xc0)!=0x40){\n\n            return 0;\n        }\n        /* both the T and C bits can not be set\n         * and the two reserved bits in byte 1 must be 0\n         */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        switch(tmpbyte&0xf0){\n        case 0x80:\n        case 0x40:\n        case 0x00:\n            break;\n        default:\n            return 0;\n        }\n        /* CSG and NSG must not be 2 */\n        if(((tmpbyte & 0x03) == 0x02)\n           || ((tmpbyte & 0x0c) == 0x08)) {\n            return 0;\n        }\n        /* if T bit is set NSG must not be 0 */\n        if(tmpbyte&0x80){\n            if(!(tmpbyte&0x03)){\n                return 0;\n            }\n        }\n        /* should we test that datasegmentlen is non zero? */\n        break;\n    case ISCSI_OPCODE_LOGIN_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n\n            return 0;\n        }\n        /* both the T and C bits can not be set\n         * and the two reserved bits in byte 1 must be 0\n         */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        switch(tmpbyte&0xf0){\n        case 0x80:\n        case 0x40:\n        case 0x00:\n            break;\n        default:\n            return 0;\n        }\n        /* CSG and NSG must not be 2 */\n        if(((tmpbyte & 0x03) == 0x02)\n           || ((tmpbyte & 0x0c) == 0x08)) {\n            return 0;\n        }\n        /* if T bit is set NSG must not be 0 */\n        if(tmpbyte&0x80){\n            if(!(tmpbyte&0x03)){\n                return 0;\n            }\n        }\n        /* the 32bit words at offsets 20, 40, 44 must be zero */\n        if(tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the two bytes at offset 38 must be zero */\n        if(tvb_get_letohs(tvb,offset+38)){\n            return 0;\n        }\n        /* should we test that datasegmentlen is non zero unless we just\n         * entered full featured phase?\n         */\n        break;\n    case ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* top bit in byte 1 must be set */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* Function must be known */\n        if(!try_val_to_str(tmpbyte&0x7f, iscsi_task_management_functions)){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl must be null */\n        if(tvb_get_letohl(tvb,offset+4)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* response must be 0-6 or 255 */\n        tmpbyte=tvb_get_guint8(tvb,offset+2);\n        if(tmpbyte>6 && tmpbyte<255){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb,offset+3)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 20, 36\n         * 40, 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGOUT_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* top bit in byte 1 must be set */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* Reason code must be known */\n        if(!try_val_to_str(tmpbyte&0x7f, iscsi_logout_reasons)){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 32, 36\n         * 40, 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SNACK_REQUEST:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* top 4 bits in byte 1 must be 0x80 */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if((tmpbyte&0xf0)!=0x80){\n            return 0;\n        }\n        /* type must be known */\n        if(!try_val_to_str(tmpbyte&0x0f, iscsi_snack_types)){\n            return 0;\n        }\n        /* for status/snack and datack itt must be 0xffffffff\n         * for rdata/snack ttt must not be 0 or 0xffffffff\n         */\n        switch(tmpbyte&0x0f){\n        case 1:\n        case 2:\n            if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n                return 0;\n            }\n            break;\n        case 3:\n            if(tvb_get_letohl(tvb,offset+20)==0xffffffff){\n                return 0;\n            }\n            if(tvb_get_letohl(tvb,offset+20)==0){\n                return 0;\n            }\n            break;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 24, 32, 36\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+24)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)){\n            return 0;\n        }\n\n        break;\n    case ISCSI_OPCODE_R2T:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl must be null */\n        if(tvb_get_letohl(tvb,offset+4)){\n            return 0;\n        }\n        /* desired data transfer length must not be null */\n        if(!tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_REJECT:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* reason must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_reject_reasons)){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        /* the 32bit words at offsets 8, 12, 20, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the 32bit word at 16 must be 0xffffffff */\n        if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TEXT_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* one of the F and C bits must be set but not both\n         * low 6 bits in byte 1 must be 0\n         */\n        switch(tvb_get_guint8(tvb,offset+1)){\n        case 0x80:\n        case 0x40:\n            break;\n        default:\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 32, 36, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TEXT_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* one of the F and C bits must be set but not both\n         * low 6 bits in byte 1 must be 0\n         */\n        switch(tvb_get_guint8(tvb,offset+1)){\n        case 0x80:\n        case 0x40:\n            break;\n        default:\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 36, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* reserved bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb, offset+1)&0x18){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* if expected data transfer length is set, W and/or R have to be set */\n        if(tvb_get_ntohl(tvb,offset+20)){\n            if(!(tvb_get_guint8(tvb, offset+1)&0x60)){\n                return 0;\n            }\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* top bit in byte 1 must be 1 */\n        tmpbyte=tvb_get_guint8(tvb,offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* the reserved bits in byte 1 must be 0 */\n        if(tmpbyte&0x61){\n            return 0;\n        }\n        /* status must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+3), scsi_status_val)){\n            return 0;\n        }\n        /* the 32bit words at offsets 8, 12\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_ASYNC_MESSAGE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 20, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the 32bit word at 16 must be 0xffffffff */\n        if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGOUT_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* response must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_logout_response)){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb,offset+3)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 20, 36\n         * 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_DATA_OUT:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* low 7 bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb,offset+1)&0x7f){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 24, 32, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+24)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_DATA_IN:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* reserved bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb,offset+1)&0x38){\n            return 0;\n        }\n        /* byte 2 must be reserved */\n        if(tvb_get_guint8(tvb,offset+2)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I0:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I1:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I2:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T0:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T1:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T2:\n        break;\n    default:\n        return 0;\n    } /* end of heuristics check */\n\n\n    /* process multiple iSCSI PDUs per packet */\n    while(available_bytes >= 48 || (iscsi_desegment && available_bytes >= 8)) {\n        const char *opcode_str = NULL;\n        guint32 data_segment_len;\n        guint32 pduLen = 48;\n        guint8 secondPduByte = tvb_get_guint8(tvb, offset + 1);\n        int badPdu = FALSE;\n        guint8 ahsLen=0;\n        guint32 data_segment_offset, data_segment_len_padded;\n\n        /* mask out any extra bits in the opcode byte */\n        opcode = tvb_get_guint8(tvb, offset + 0);\n        opcode &= OPCODE_MASK;\n\n        opcode_str = try_val_to_str(opcode, iscsi_opcodes);\n        if(opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION ||\n           opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\n           opcode == ISCSI_OPCODE_R2T ||\n           opcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\n           opcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\n           opcode == ISCSI_OPCODE_SNACK_REQUEST)\n            data_segment_len = 0;\n        else\n            data_segment_len = tvb_get_ntohl(tvb, offset + 4) & 0x00ffffff;\n\n        if(opcode_str == NULL) {\n            badPdu = TRUE;\n        }\n\n\n        if(!badPdu && check_port) {\n            badPdu = TRUE;\n            if ((opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->srcport)) {\n                badPdu = FALSE;\n            }\n            if (!(opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->destport)) {\n                badPdu = FALSE;\n            }\n            if ((opcode & TARGET_OPCODE_BIT) && pinfo->srcport == iscsi_system_port) {\n                badPdu = FALSE;\n            }\n            if (!(opcode & TARGET_OPCODE_BIT) && pinfo->destport == iscsi_system_port) {\n                badPdu = FALSE;\n            }\n        }\n\n        if(!badPdu && enable_bogosity_filter) {\n            /* try and distinguish between data and real headers */\n            if(data_segment_len > bogus_pdu_data_length_threshold) {\n                badPdu = TRUE;\n            }\n            else if(demand_good_f_bit &&\n                    !(secondPduByte & 0x80) &&\n                    (opcode == ISCSI_OPCODE_NOP_OUT ||\n                     opcode == ISCSI_OPCODE_NOP_IN ||\n                     opcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\n                     opcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\n                     opcode == ISCSI_OPCODE_SCSI_RESPONSE ||\n                     opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\n                     opcode == ISCSI_OPCODE_R2T ||\n                     opcode == ISCSI_OPCODE_ASYNC_MESSAGE ||\n                     opcode == ISCSI_OPCODE_SNACK_REQUEST ||\n                     opcode == ISCSI_OPCODE_REJECT)) {\n                badPdu = TRUE;\n            } else if(opcode==ISCSI_OPCODE_NOP_OUT) {\n                /* TransferTag for NOP-Out should either be -1 or\n                   the tag value we want for a response.\n                   Assume 0 means we are just inside a big all zero\n                   datablock.\n                */\n                if(tvb_get_ntohl(tvb, offset+20)==0){\n                    badPdu = TRUE;\n                }\n            }\n        }\n\n        if(badPdu) {\n            return offset;\n        }\n\n        if(opcode == ISCSI_OPCODE_LOGIN_COMMAND ||\n           opcode == ISCSI_OPCODE_LOGIN_RESPONSE) {\n            if(iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT08) {\n                if((secondPduByte & CSG_MASK) < ISCSI_CSG_OPERATIONAL_NEGOTIATION) {\n                    /* digests are not yet turned on */\n                    digestsActive = 0;\n                }\n            } else {\n                digestsActive = 0;\n            }\n        }\n\n        if(opcode == ISCSI_OPCODE_SCSI_COMMAND) {\n            /* ahsLen */\n            ahsLen = tvb_get_guint8(tvb, offset + 4);\n            pduLen += ahsLen * 4;\n        }\n\n        data_segment_offset = pduLen;\n        data_segment_len_padded = data_segment_len;\n        if((data_segment_len_padded & 3) != 0)\n            data_segment_len_padded += 4 - (data_segment_len_padded & 3);\n        pduLen += data_segment_len_padded;\n\n\n        /* make sure we have a conversation for this session */\n        conversation = find_or_create_conversation(pinfo);\n\n        iscsi_session=(iscsi_session_t *)conversation_get_proto_data(conversation, proto_iscsi);\n        if(!iscsi_session){\n            iscsi_session = wmem_new(wmem_file_scope(), iscsi_session_t);\n            iscsi_session->header_digest = ISCSI_DIGEST_AUTO;\n            iscsi_session->data_digest = ISCSI_DIGEST_AUTO;\n            iscsi_session->itlq = wmem_tree_new(wmem_file_scope());\n            iscsi_session->itl  = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);\n            conversation_add_proto_data(conversation, proto_iscsi, iscsi_session);\n\n            /* DataOut PDUs are often mistaken by DCERPC heuristics to be\n             * that protocol. Now that we know this is iscsi, set a\n             * dissector for this conversation to block other heuristic\n             * dissectors.\n             */\n            conversation_set_dissector(conversation, iscsi_handle);\n        }\n        /* try to autodetect if header digest is used or not */\n        if (digestsActive && (available_bytes >= (guint32) (48+4+ahsLen*4)) &&\n            (iscsi_session->header_digest == ISCSI_DIGEST_AUTO)) {\n            guint32 crc;\n            /* we have enough data to test if HeaderDigest is enabled */\n            crc= ~crc32c_tvb_offset_calculate(tvb, offset, 48+ahsLen*4, CRC32C_PRELOAD);\n            if(crc==tvb_get_ntohl(tvb,48+ahsLen*4)){\n                iscsi_session->header_digest = ISCSI_DIGEST_CRC32;\n            } else {\n                iscsi_session->header_digest = ISCSI_DIGEST_NONE;\n            }\n        }\n\n\n        /* Add header digest length to pdulen */\n        if(digestsActive){\n            switch(iscsi_session->header_digest){\n            case ISCSI_DIGEST_CRC32:\n                pduLen += 4;\n                data_segment_offset += 4;\n                break;\n            case ISCSI_DIGEST_NONE:\n                break;\n            case ISCSI_DIGEST_AUTO:\n                /* oops we don't yet know what digest is used */\n                /* here we should use some default */\n                break;\n            default:\n                DISSECTOR_ASSERT_NOT_REACHED();\n            }\n        }\n\n        /* try to autodetect whether data digest is used */\n        if (digestsActive &&\n            (available_bytes >= data_segment_offset + data_segment_len_padded + 4) &&\n            (iscsi_session->data_digest == ISCSI_DIGEST_AUTO)) {\n            guint32 crc;\n            /* we have enough data to test if DataDigest is enabled */\n            crc = ~crc32c_tvb_offset_calculate(tvb, data_segment_offset, data_segment_len_padded, CRC32C_PRELOAD);\n            if (crc == tvb_get_ntohl(tvb, data_segment_offset + data_segment_len_padded)) {\n                iscsi_session->data_digest = ISCSI_DIGEST_CRC32;\n            } else {\n                iscsi_session->data_digest = ISCSI_DIGEST_NONE;\n            }\n        }\n\n        /* Add data digest length to pdulen */\n        if (digestsActive && data_segment_len > 0) {\n            switch (iscsi_session->data_digest) {\n            case ISCSI_DIGEST_CRC32:\n                pduLen += 4;\n                break;\n            case ISCSI_DIGEST_NONE:\n                break;\n            case ISCSI_DIGEST_AUTO:\n                /* unknown digest, perhaps a new field was introduced? */\n                break;\n            default:\n                DISSECTOR_ASSERT_NOT_REACHED();\n            }\n        }\n\n        /*\n         * Desegmentation check.\n         */\n        if(iscsi_desegment && pinfo->can_desegment) {\n            if(pduLen > available_bytes) {\n                /*\n                 * This frame doesn't have all of the data for\n                 * this message, but we can do reassembly on it.\n                 *\n                 * Tell the TCP dissector where the data for this\n                 * message starts in the data it handed us, and\n                 * how many more bytes we need, and return.\n                 */\n                pinfo->desegment_offset = offset;\n                pinfo->desegment_len = pduLen - available_bytes;\n                return -1;\n            }\n        }\n\n        /* This is to help TCP keep track of PDU boundaries\n           and allows it to find PDUs that are not aligned to\n           the start of a TCP segments.\n           Since it also allows TCP to know what is in the middle\n           of a large PDU, it reduces the probability of a segment\n           in the middle of a large PDU transfer being misdissected as\n           a PDU.\n        */\n        if(!pinfo->fd->visited){\n            if(pduLen>(guint32)tvb_reported_length_remaining(tvb, offset)){\n                pinfo->want_pdu_tracking=2;\n                pinfo->bytes_until_next_pdu=pduLen-tvb_reported_length_remaining(tvb, offset);\n            }\n        }\n\n        if (offset == 0)\n            col_set_str(pinfo->cinfo, COL_INFO, \"\");\n        else\n            col_append_str(pinfo->cinfo, COL_INFO, \", \");\n\n        dissect_iscsi_pdu(tvb, pinfo, tree, offset, opcode, opcode_str, data_segment_len, iscsi_session, conversation);\n        if(pduLen > available_bytes)\n            pduLen = available_bytes;\n        offset += pduLen;\n        available_bytes -= pduLen;\n    }\n\n    return offset;\n}",
        "func_after": "static int\ndissect_iscsi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean check_port) {\n    /* Set up structures needed to add the protocol subtree and manage it */\n    guint offset = 0;\n    guint32 available_bytes = tvb_captured_length(tvb);\n    int digestsActive = 1;\n    conversation_t *conversation = NULL;\n    iscsi_session_t *iscsi_session=NULL;\n    guint8 opcode, tmpbyte;\n\n    if (available_bytes < 48) {\n        /* heuristic already rejected the packet if size < 48,\n           assume it's an iscsi packet with a segmented header */\n        pinfo->desegment_offset = offset;\n        pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\n        return -1;\n    }\n\n    opcode = tvb_get_guint8(tvb, offset + 0);\n    opcode &= OPCODE_MASK;\n\n    /* heuristics to verify that the packet looks sane.   the heuristics\n     * are based on the RFC version of iscsi.\n     * (we should retire support for older iscsi versions in wireshark)\n     *      -- ronnie s\n     */\n    /* opcode must be any of the ones from the standard\n     * also check the header that it looks \"sane\"\n     * all reserved or undefined bits in iscsi must be set to zero.\n     */\n    switch(opcode){\n    case ISCSI_OPCODE_NOP_IN:\n        /* top two bits of byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2 and 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_NOP_OUT:\n        /* top bit of byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2 and 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        /* assume ITT and TTT must always be non NULL (ok they can be NULL\n         * from time to time but it usually means we are in the middle\n         * of a zeroed datablock).\n         */\n        if(!tvb_get_letohl(tvb,offset+16) || !tvb_get_letohl(tvb,offset+20)){\n            return 0;\n        }\n        /* all reserved bytes between 32 - 47 must be null */\n        if(tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGIN_COMMAND:\n        /* top two bits in byte 0 must be 0x40 */\n        if((tvb_get_guint8(tvb, offset+0)&0xc0)!=0x40){\n\n            return 0;\n        }\n        /* both the T and C bits can not be set\n         * and the two reserved bits in byte 1 must be 0\n         */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        switch(tmpbyte&0xf0){\n        case 0x80:\n        case 0x40:\n        case 0x00:\n            break;\n        default:\n            return 0;\n        }\n        /* CSG and NSG must not be 2 */\n        if(((tmpbyte & 0x03) == 0x02)\n           || ((tmpbyte & 0x0c) == 0x08)) {\n            return 0;\n        }\n        /* if T bit is set NSG must not be 0 */\n        if(tmpbyte&0x80){\n            if(!(tmpbyte&0x03)){\n                return 0;\n            }\n        }\n        /* should we test that datasegmentlen is non zero? */\n        break;\n    case ISCSI_OPCODE_LOGIN_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n\n            return 0;\n        }\n        /* both the T and C bits can not be set\n         * and the two reserved bits in byte 1 must be 0\n         */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        switch(tmpbyte&0xf0){\n        case 0x80:\n        case 0x40:\n        case 0x00:\n            break;\n        default:\n            return 0;\n        }\n        /* CSG and NSG must not be 2 */\n        if(((tmpbyte & 0x03) == 0x02)\n           || ((tmpbyte & 0x0c) == 0x08)) {\n            return 0;\n        }\n        /* if T bit is set NSG must not be 0 */\n        if(tmpbyte&0x80){\n            if(!(tmpbyte&0x03)){\n                return 0;\n            }\n        }\n        /* the 32bit words at offsets 20, 40, 44 must be zero */\n        if(tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the two bytes at offset 38 must be zero */\n        if(tvb_get_letohs(tvb,offset+38)){\n            return 0;\n        }\n        /* should we test that datasegmentlen is non zero unless we just\n         * entered full featured phase?\n         */\n        break;\n    case ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* top bit in byte 1 must be set */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* Function must be known */\n        if(!try_val_to_str(tmpbyte&0x7f, iscsi_task_management_functions)){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl must be null */\n        if(tvb_get_letohl(tvb,offset+4)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* response must be 0-6 or 255 */\n        tmpbyte=tvb_get_guint8(tvb,offset+2);\n        if(tmpbyte>6 && tmpbyte<255){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb,offset+3)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 20, 36\n         * 40, 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGOUT_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* top bit in byte 1 must be set */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* Reason code must be known */\n        if(!try_val_to_str(tmpbyte&0x7f, iscsi_logout_reasons)){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 32, 36\n         * 40, 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SNACK_REQUEST:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* top 4 bits in byte 1 must be 0x80 */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if((tmpbyte&0xf0)!=0x80){\n            return 0;\n        }\n        /* type must be known */\n        if(!try_val_to_str(tmpbyte&0x0f, iscsi_snack_types)){\n            return 0;\n        }\n        /* for status/snack and datack itt must be 0xffffffff\n         * for rdata/snack ttt must not be 0 or 0xffffffff\n         */\n        switch(tmpbyte&0x0f){\n        case 1:\n        case 2:\n            if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n                return 0;\n            }\n            break;\n        case 3:\n            if(tvb_get_letohl(tvb,offset+20)==0xffffffff){\n                return 0;\n            }\n            if(tvb_get_letohl(tvb,offset+20)==0){\n                return 0;\n            }\n            break;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 24, 32, 36\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+24)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)){\n            return 0;\n        }\n\n        break;\n    case ISCSI_OPCODE_R2T:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl must be null */\n        if(tvb_get_letohl(tvb,offset+4)){\n            return 0;\n        }\n        /* desired data transfer length must not be null */\n        if(!tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_REJECT:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* reason must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_reject_reasons)){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        /* the 32bit words at offsets 8, 12, 20, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the 32bit word at 16 must be 0xffffffff */\n        if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TEXT_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* one of the F and C bits must be set but not both\n         * low 6 bits in byte 1 must be 0\n         */\n        switch(tvb_get_guint8(tvb,offset+1)){\n        case 0x80:\n        case 0x40:\n            break;\n        default:\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 32, 36, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TEXT_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* one of the F and C bits must be set but not both\n         * low 6 bits in byte 1 must be 0\n         */\n        switch(tvb_get_guint8(tvb,offset+1)){\n        case 0x80:\n        case 0x40:\n            break;\n        default:\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 36, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* reserved bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb, offset+1)&0x18){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* if expected data transfer length is set, W and/or R have to be set */\n        if(tvb_get_ntohl(tvb,offset+20)){\n            if(!(tvb_get_guint8(tvb, offset+1)&0x60)){\n                return 0;\n            }\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* top bit in byte 1 must be 1 */\n        tmpbyte=tvb_get_guint8(tvb,offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* the reserved bits in byte 1 must be 0 */\n        if(tmpbyte&0x61){\n            return 0;\n        }\n        /* status must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+3), scsi_status_val)){\n            return 0;\n        }\n        /* the 32bit words at offsets 8, 12\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_ASYNC_MESSAGE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 20, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the 32bit word at 16 must be 0xffffffff */\n        if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGOUT_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* response must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_logout_response)){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb,offset+3)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 20, 36\n         * 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_DATA_OUT:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* low 7 bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb,offset+1)&0x7f){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 24, 32, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+24)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_DATA_IN:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* reserved bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb,offset+1)&0x38){\n            return 0;\n        }\n        /* byte 2 must be reserved */\n        if(tvb_get_guint8(tvb,offset+2)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I0:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I1:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I2:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T0:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T1:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T2:\n        break;\n    default:\n        return 0;\n    } /* end of heuristics check */\n\n\n    /* process multiple iSCSI PDUs per packet */\n    while(available_bytes >= 48 || (iscsi_desegment && available_bytes >= 8)) {\n        guint32 data_segment_len;\n        guint32 pduLen = 48;\n        guint8 secondPduByte = tvb_get_guint8(tvb, offset + 1);\n        int badPdu = FALSE;\n        guint8 ahsLen=0;\n        guint32 data_segment_offset, data_segment_len_padded;\n\n        /* mask out any extra bits in the opcode byte */\n        opcode = tvb_get_guint8(tvb, offset + 0);\n        opcode &= OPCODE_MASK;\n\n        if(opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION ||\n           opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\n           opcode == ISCSI_OPCODE_R2T ||\n           opcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\n           opcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\n           opcode == ISCSI_OPCODE_SNACK_REQUEST)\n            data_segment_len = 0;\n        else\n            data_segment_len = tvb_get_ntohl(tvb, offset + 4) & 0x00ffffff;\n\n        if (!try_val_to_str(opcode, iscsi_opcodes)) {\n            badPdu = TRUE;\n        }\n\n\n        if(!badPdu && check_port) {\n            badPdu = TRUE;\n            if ((opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->srcport)) {\n                badPdu = FALSE;\n            }\n            if (!(opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->destport)) {\n                badPdu = FALSE;\n            }\n            if ((opcode & TARGET_OPCODE_BIT) && pinfo->srcport == iscsi_system_port) {\n                badPdu = FALSE;\n            }\n            if (!(opcode & TARGET_OPCODE_BIT) && pinfo->destport == iscsi_system_port) {\n                badPdu = FALSE;\n            }\n        }\n\n        if(!badPdu && enable_bogosity_filter) {\n            /* try and distinguish between data and real headers */\n            if(data_segment_len > bogus_pdu_data_length_threshold) {\n                badPdu = TRUE;\n            }\n            else if(demand_good_f_bit &&\n                    !(secondPduByte & 0x80) &&\n                    (opcode == ISCSI_OPCODE_NOP_OUT ||\n                     opcode == ISCSI_OPCODE_NOP_IN ||\n                     opcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\n                     opcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\n                     opcode == ISCSI_OPCODE_SCSI_RESPONSE ||\n                     opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\n                     opcode == ISCSI_OPCODE_R2T ||\n                     opcode == ISCSI_OPCODE_ASYNC_MESSAGE ||\n                     opcode == ISCSI_OPCODE_SNACK_REQUEST ||\n                     opcode == ISCSI_OPCODE_REJECT)) {\n                badPdu = TRUE;\n            } else if(opcode==ISCSI_OPCODE_NOP_OUT) {\n                /* TransferTag for NOP-Out should either be -1 or\n                   the tag value we want for a response.\n                   Assume 0 means we are just inside a big all zero\n                   datablock.\n                */\n                if(tvb_get_ntohl(tvb, offset+20)==0){\n                    badPdu = TRUE;\n                }\n            }\n        }\n\n        if(badPdu) {\n            return offset;\n        }\n\n        if(opcode == ISCSI_OPCODE_LOGIN_COMMAND ||\n           opcode == ISCSI_OPCODE_LOGIN_RESPONSE) {\n            if(iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT08) {\n                if((secondPduByte & CSG_MASK) < ISCSI_CSG_OPERATIONAL_NEGOTIATION) {\n                    /* digests are not yet turned on */\n                    digestsActive = 0;\n                }\n            } else {\n                digestsActive = 0;\n            }\n        }\n\n        if(opcode == ISCSI_OPCODE_SCSI_COMMAND) {\n            /* ahsLen */\n            ahsLen = tvb_get_guint8(tvb, offset + 4);\n            pduLen += ahsLen * 4;\n        }\n\n        data_segment_offset = pduLen;\n        data_segment_len_padded = data_segment_len;\n        if((data_segment_len_padded & 3) != 0)\n            data_segment_len_padded += 4 - (data_segment_len_padded & 3);\n        pduLen += data_segment_len_padded;\n\n\n        /* make sure we have a conversation for this session */\n        conversation = find_or_create_conversation(pinfo);\n\n        iscsi_session=(iscsi_session_t *)conversation_get_proto_data(conversation, proto_iscsi);\n        if(!iscsi_session){\n            iscsi_session = wmem_new(wmem_file_scope(), iscsi_session_t);\n            iscsi_session->header_digest = ISCSI_DIGEST_AUTO;\n            iscsi_session->data_digest = ISCSI_DIGEST_AUTO;\n            iscsi_session->itlq = wmem_tree_new(wmem_file_scope());\n            iscsi_session->itl  = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);\n            conversation_add_proto_data(conversation, proto_iscsi, iscsi_session);\n\n            /* DataOut PDUs are often mistaken by DCERPC heuristics to be\n             * that protocol. Now that we know this is iscsi, set a\n             * dissector for this conversation to block other heuristic\n             * dissectors.\n             */\n            conversation_set_dissector(conversation, iscsi_handle);\n        }\n        /* try to autodetect if header digest is used or not */\n        if (digestsActive && (available_bytes >= (guint32) (48+4+ahsLen*4)) &&\n            (iscsi_session->header_digest == ISCSI_DIGEST_AUTO)) {\n            guint32 crc;\n            /* we have enough data to test if HeaderDigest is enabled */\n            crc= ~crc32c_tvb_offset_calculate(tvb, offset, 48+ahsLen*4, CRC32C_PRELOAD);\n            if(crc==tvb_get_ntohl(tvb,48+ahsLen*4)){\n                iscsi_session->header_digest = ISCSI_DIGEST_CRC32;\n            } else {\n                iscsi_session->header_digest = ISCSI_DIGEST_NONE;\n            }\n        }\n\n\n        /* Add header digest length to pdulen */\n        if(digestsActive){\n            switch(iscsi_session->header_digest){\n            case ISCSI_DIGEST_CRC32:\n                pduLen += 4;\n                data_segment_offset += 4;\n                break;\n            case ISCSI_DIGEST_NONE:\n                break;\n            case ISCSI_DIGEST_AUTO:\n                /* oops we don't yet know what digest is used */\n                /* here we should use some default */\n                break;\n            default:\n                DISSECTOR_ASSERT_NOT_REACHED();\n            }\n        }\n\n        /* try to autodetect whether data digest is used */\n        if (digestsActive &&\n            (available_bytes >= data_segment_offset + data_segment_len_padded + 4) &&\n            (iscsi_session->data_digest == ISCSI_DIGEST_AUTO)) {\n            guint32 crc;\n            /* we have enough data to test if DataDigest is enabled */\n            crc = ~crc32c_tvb_offset_calculate(tvb, data_segment_offset, data_segment_len_padded, CRC32C_PRELOAD);\n            if (crc == tvb_get_ntohl(tvb, data_segment_offset + data_segment_len_padded)) {\n                iscsi_session->data_digest = ISCSI_DIGEST_CRC32;\n            } else {\n                iscsi_session->data_digest = ISCSI_DIGEST_NONE;\n            }\n        }\n\n        /* Add data digest length to pdulen */\n        if (digestsActive && data_segment_len > 0) {\n            switch (iscsi_session->data_digest) {\n            case ISCSI_DIGEST_CRC32:\n                pduLen += 4;\n                break;\n            case ISCSI_DIGEST_NONE:\n                break;\n            case ISCSI_DIGEST_AUTO:\n                /* unknown digest, perhaps a new field was introduced? */\n                break;\n            default:\n                DISSECTOR_ASSERT_NOT_REACHED();\n            }\n        }\n\n        /*\n         * Desegmentation check.\n         */\n        if(iscsi_desegment && pinfo->can_desegment) {\n            if(pduLen > available_bytes) {\n                /*\n                 * This frame doesn't have all of the data for\n                 * this message, but we can do reassembly on it.\n                 *\n                 * Tell the TCP dissector where the data for this\n                 * message starts in the data it handed us, and\n                 * how many more bytes we need, and return.\n                 */\n                pinfo->desegment_offset = offset;\n                pinfo->desegment_len = pduLen - available_bytes;\n                return -1;\n            }\n        }\n\n        /* This is to help TCP keep track of PDU boundaries\n           and allows it to find PDUs that are not aligned to\n           the start of a TCP segments.\n           Since it also allows TCP to know what is in the middle\n           of a large PDU, it reduces the probability of a segment\n           in the middle of a large PDU transfer being misdissected as\n           a PDU.\n        */\n        if(!pinfo->fd->visited){\n            if(pduLen>(guint32)tvb_reported_length_remaining(tvb, offset)){\n                pinfo->want_pdu_tracking=2;\n                pinfo->bytes_until_next_pdu=pduLen-tvb_reported_length_remaining(tvb, offset);\n            }\n        }\n\n        if (offset == 0)\n            col_set_str(pinfo->cinfo, COL_INFO, \"\");\n        else\n            col_append_str(pinfo->cinfo, COL_INFO, \", \");\n\n        dissect_iscsi_pdu(tvb, pinfo, tree, offset, opcode, data_segment_len, iscsi_session, conversation);\n        if(pduLen > available_bytes)\n            pduLen = available_bytes;\n        offset += pduLen;\n        available_bytes -= pduLen;\n    }\n\n    return offset;\n}",
        "description": "A vulnerability in Wireshark versions 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 causes a crash in the iSCSI dissector when processing certain packets or crafted capture files. This issue can be exploited to achieve a denial of service.",
        "commit": "It was discovered that the iSCSI protocol implementation lacked proper handling of invalid opcodes within Reject messages. Specifically, the function responsible for dissecting iSCSI PDUs did not account for such cases, leading to potential crashes when encountering invalid opcodes in Reject messages. This issue has been addressed to ensure robustness against malformed inputs."
    },
    {
        "cwe": "CWE-532",
        "func_name": "torvalds/klsi_105_get_line_state",
        "score": 0.7751256227493286,
        "func_before": "static int klsi_105_get_line_state(struct usb_serial_port *port,\n\t\t\t\t   unsigned long *line_state_p)\n{\n\tint rc;\n\tu8 *status_buf;\n\t__u16 status;\n\n\tdev_info(&port->serial->dev->dev, \"sending SIO Poll request\\n\");\n\n\tstatus_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);\n\tif (!status_buf)\n\t\treturn -ENOMEM;\n\n\tstatus_buf[0] = 0xff;\n\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, /* value */\n\t\t\t     0, /* index */\n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc < 0)\n\t\tdev_err(&port->dev, \"Reading line status failed (error = %d)\\n\",\n\t\t\trc);\n\telse {\n\t\tstatus = get_unaligned_le16(status_buf);\n\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\n\tkfree(status_buf);\n\treturn rc;\n}",
        "func_after": "static int klsi_105_get_line_state(struct usb_serial_port *port,\n\t\t\t\t   unsigned long *line_state_p)\n{\n\tint rc;\n\tu8 *status_buf;\n\t__u16 status;\n\n\tdev_info(&port->serial->dev->dev, \"sending SIO Poll request\\n\");\n\n\tstatus_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);\n\tif (!status_buf)\n\t\treturn -ENOMEM;\n\n\tstatus_buf[0] = 0xff;\n\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, /* value */\n\t\t\t     0, /* index */\n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc != KLSI_STATUSBUF_LEN) {\n\t\tdev_err(&port->dev, \"reading line status failed: %d\\n\", rc);\n\t\tif (rc >= 0)\n\t\t\trc = -EIO;\n\t} else {\n\t\tstatus = get_unaligned_le16(status_buf);\n\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\n\tkfree(status_buf);\n\treturn rc;\n}",
        "description": "The `klsi_105_get_line_state` function in the Linux kernel's USB serial driver, prior to version 4.9.5, includes uninitialized heap memory content in a log entry when failing to read the line status. This flaw enables local users to extract sensitive information by accessing the log.",
        "commit": "The current implementation of the USB serial driver for the KL5KUSB105 device fails to properly detect short data transfers during attempts to read the line state. Additionally, it logs the contents of an uninitialized heap transfer buffer, which could lead to unintended information disclosure."
    },
    {
        "cwe": "CWE-552",
        "func_name": "util-linux/is_fuse_usermount",
        "score": 0.779995858669281,
        "func_before": "static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)\n{\n\tstruct libmnt_ns *ns_old;\n\tconst char *type = mnt_fs_get_fstype(cxt->fs);\n\tconst char *optstr;\n\tchar *user_id = NULL;\n\tsize_t sz;\n\tuid_t uid;\n\tchar uidstr[sizeof(stringify_value(ULONG_MAX))];\n\n\t*errsv = 0;\n\n\tif (!type)\n\t\treturn 0;\n\n\tif (strcmp(type, \"fuse\") != 0 &&\n\t    strcmp(type, \"fuseblk\") != 0 &&\n\t    strncmp(type, \"fuse.\", 5) != 0 &&\n\t    strncmp(type, \"fuseblk.\", 8) != 0)\n\t\treturn 0;\n\n\t/* get user_id= from mount table */\n\toptstr = mnt_fs_get_fs_options(cxt->fs);\n\tif (!optstr)\n\t\treturn 0;\n\n\tif (mnt_optstr_get_option(optstr, \"user_id\", &user_id, &sz) != 0)\n\t\treturn 0;\n\n\tif (sz == 0 || user_id == NULL)\n\t\treturn 0;\n\n\t/* get current user */\n\tns_old = mnt_context_switch_origin_ns(cxt);\n\tif (!ns_old) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\n\tuid = getuid();\n\n\tif (!mnt_context_switch_ns(cxt, ns_old)) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\n\tsnprintf(uidstr, sizeof(uidstr), \"%lu\", (unsigned long) uid);\n\treturn strncmp(user_id, uidstr, sz) == 0;\n}",
        "func_after": "static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)\n{\n\tstruct libmnt_ns *ns_old;\n\tconst char *type = mnt_fs_get_fstype(cxt->fs);\n\tconst char *optstr;\n\tuid_t uid, entry_uid;\n\n\t*errsv = 0;\n\n\tif (!type)\n\t\treturn 0;\n\n\tif (strcmp(type, \"fuse\") != 0 &&\n\t    strcmp(type, \"fuseblk\") != 0 &&\n\t    strncmp(type, \"fuse.\", 5) != 0 &&\n\t    strncmp(type, \"fuseblk.\", 8) != 0)\n\t\treturn 0;\n\n\t/* get user_id= from mount table */\n\toptstr = mnt_fs_get_fs_options(cxt->fs);\n\tif (!optstr)\n\t\treturn 0;\n\tif (mnt_optstr_get_uid(optstr, \"user_id\", &entry_uid) != 0)\n\t\treturn 0;\n\n\t/* get current user */\n\tns_old = mnt_context_switch_origin_ns(cxt);\n\tif (!ns_old) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\n\tuid = getuid();\n\n\tif (!mnt_context_switch_ns(cxt, ns_old)) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\n\treturn uid == entry_uid;\n}",
        "description": "A logic error was identified in the libmount library of util-linux, affecting the function responsible for allowing unprivileged users to unmount FUSE filesystems. This flaw enables an unprivileged local attacker to unmount FUSE filesystems owned by other users whose UIDs share a common prefix with the attacker's UID in string form. Exploitation of this vulnerability could lead to a denial of service for applications relying on the affected filesystems.",
        "commit": "An improper user ID (UID) check in the libmount library allows an unprivileged user to unmount FUSE filesystems owned by users with similar UIDs."
    },
    {
        "cwe": "CWE-428",
        "func_name": "openbsd/sshsk_open",
        "score": 0.7923720479011536,
        "func_before": "static struct sshsk_provider *\nsshsk_open(const char *path)\n{\n\tstruct sshsk_provider *ret = NULL;\n\tuint32_t version;\n\n\tif (path == NULL || *path == '\\0') {\n\t\terror(\"No FIDO SecurityKeyProvider specified\");\n\t\treturn NULL;\n\t}\n\tif ((ret = calloc(1, sizeof(*ret))) == NULL) {\n\t\terror_f(\"calloc failed\");\n\t\treturn NULL;\n\t}\n\tif ((ret->path = strdup(path)) == NULL) {\n\t\terror_f(\"strdup failed\");\n\t\tgoto fail;\n\t}\n\t/* Skip the rest if we're using the linked in middleware */\n\tif (strcasecmp(ret->path, \"internal\") == 0) {\n\t\tret->sk_enroll = ssh_sk_enroll;\n\t\tret->sk_sign = ssh_sk_sign;\n\t\tret->sk_load_resident_keys = ssh_sk_load_resident_keys;\n\t\treturn ret;\n\t}\n\tif ((ret->dlhandle = dlopen(path, RTLD_NOW)) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlopen failed: %s\", path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_api_version = dlsym(ret->dlhandle,\n\t    \"sk_api_version\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_api_version) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tversion = ret->sk_api_version();\n\tdebug_f(\"provider %s implements version 0x%08lx\", ret->path,\n\t    (u_long)version);\n\tif ((version & SSH_SK_VERSION_MAJOR_MASK) != SSH_SK_VERSION_MAJOR) {\n\t\terror(\"Provider \\\"%s\\\" implements unsupported \"\n\t\t    \"version 0x%08lx (supported: 0x%08lx)\",\n\t\t    path, (u_long)version, (u_long)SSH_SK_VERSION_MAJOR);\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_enroll = dlsym(ret->dlhandle, \"sk_enroll\")) == NULL) {\n\t\terror(\"Provider %s dlsym(sk_enroll) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_sign = dlsym(ret->dlhandle, \"sk_sign\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_sign) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_load_resident_keys = dlsym(ret->dlhandle,\n\t    \"sk_load_resident_keys\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_load_resident_keys) \"\n\t\t    \"failed: %s\", path, dlerror());\n\t\tgoto fail;\n\t}\n\t/* success */\n\treturn ret;\nfail:\n\tsshsk_free(ret);\n\treturn NULL;\n}",
        "func_after": "static struct sshsk_provider *\nsshsk_open(const char *path)\n{\n\tstruct sshsk_provider *ret = NULL;\n\tuint32_t version;\n\n\tif (path == NULL || *path == '\\0') {\n\t\terror(\"No FIDO SecurityKeyProvider specified\");\n\t\treturn NULL;\n\t}\n\tif ((ret = calloc(1, sizeof(*ret))) == NULL) {\n\t\terror_f(\"calloc failed\");\n\t\treturn NULL;\n\t}\n\tif ((ret->path = strdup(path)) == NULL) {\n\t\terror_f(\"strdup failed\");\n\t\tgoto fail;\n\t}\n\t/* Skip the rest if we're using the linked in middleware */\n\tif (strcasecmp(ret->path, \"internal\") == 0) {\n\t\tret->sk_enroll = ssh_sk_enroll;\n\t\tret->sk_sign = ssh_sk_sign;\n\t\tret->sk_load_resident_keys = ssh_sk_load_resident_keys;\n\t\treturn ret;\n\t}\n\tif (lib_contains_symbol(path, \"sk_api_version\") != 0) {\n\t\terror(\"provider %s is not an OpenSSH FIDO library\", path);\n\t\tgoto fail;\n\t}\n\tif ((ret->dlhandle = dlopen(path, RTLD_NOW)) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlopen failed: %s\", path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_api_version = dlsym(ret->dlhandle,\n\t    \"sk_api_version\")) == NULL) {\n\t\tfatal(\"Provider \\\"%s\\\" dlsym(sk_api_version) failed: %s\",\n\t\t    path, dlerror());\n\t}\n\tversion = ret->sk_api_version();\n\tdebug_f(\"provider %s implements version 0x%08lx\", ret->path,\n\t    (u_long)version);\n\tif ((version & SSH_SK_VERSION_MAJOR_MASK) != SSH_SK_VERSION_MAJOR) {\n\t\terror(\"Provider \\\"%s\\\" implements unsupported \"\n\t\t    \"version 0x%08lx (supported: 0x%08lx)\",\n\t\t    path, (u_long)version, (u_long)SSH_SK_VERSION_MAJOR);\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_enroll = dlsym(ret->dlhandle, \"sk_enroll\")) == NULL) {\n\t\terror(\"Provider %s dlsym(sk_enroll) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_sign = dlsym(ret->dlhandle, \"sk_sign\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_sign) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_load_resident_keys = dlsym(ret->dlhandle,\n\t    \"sk_load_resident_keys\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_load_resident_keys) \"\n\t\t    \"failed: %s\", path, dlerror());\n\t\tgoto fail;\n\t}\n\t/* success */\n\treturn ret;\nfail:\n\tsshsk_free(ret);\n\treturn NULL;\n}",
        "description": "The PKCS#11 feature in ssh-agent within OpenSSH versions prior to 9.3p2 suffers from an insecure search path, which could enable remote code execution if the agent is forwarded to a system controlled by an attacker. This vulnerability arises due to the unsafe loading of libraries from directories such as /usr/lib, which may not be secure. Additionally, this issue is a result of an incomplete resolution to another previously identified vulnerability, CVE-2016-10009.",
        "commit": "To ensure the presence of required symbols in FIDO/PKCS11 libraries, the system verifies these symbols using the `nlist(3)` function before loading the libraries with `dlopen()`. This verification step helps prevent potential issues such as the execution of unintended constructors during the library loading process."
    }
]