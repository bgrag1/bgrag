[
    {
        "cwe": "CWE-326",
        "func_name": "torvalds/__ipv6_select_ident",
        "score": 0.7314881682395935,
        "func_before": "static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tu32 hash, id;\n\n\thash = __ipv6_addr_jhash(dst, hashrnd);\n\thash = __ipv6_addr_jhash(src, hash);\n\thash ^= net_hash_mix(net);\n\n\t/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,\n\t * set the hight order instead thus minimizing possible future\n\t * collisions.\n\t */\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\n\treturn id;\n}",
        "func_after": "static u32 __ipv6_select_ident(struct net *net,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tconst struct {\n\t\tstruct in6_addr dst;\n\t\tstruct in6_addr src;\n\t} __aligned(SIPHASH_ALIGNMENT) combined = {\n\t\t.dst = *dst,\n\t\t.src = *src,\n\t};\n\tu32 hash, id;\n\n\t/* Note the following code is not safe, but this is okay. */\n\tif (unlikely(siphash_key_is_zero(&net->ipv4.ip_id_key)))\n\t\tget_random_bytes(&net->ipv4.ip_id_key,\n\t\t\t\t sizeof(net->ipv4.ip_id_key));\n\n\thash = siphash(&combined, sizeof(combined), &net->ipv4.ip_id_key);\n\n\t/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,\n\t * set the hight order instead thus minimizing possible future\n\t * collisions.\n\t */\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\n\treturn id;\n}",
        "description": "In versions of the Linux kernel prior to 5.1.7, an attacker can track devices by analyzing the IP ID values generated by the kernel for connectionless protocols such as UDP and ICMP. By sending traffic to multiple destination IP addresses, it is possible to induce hash collisions within the counter array, potentially revealing the hashing key through enumeration. This vulnerability can be exploited by hosting a specially crafted web page that leverages technologies like WebRTC or gQUIC to direct UDP traffic to IP addresses controlled by the attacker.",
        "commit": "The IP ID generation mechanism in the networking stack is deemed insufficiently secure due to potential vulnerabilities that could be exploited by attackers. Despite recent improvements such as the introduction of a 64-bit key and the Jenkins hash function, these measures are still considered risky. Therefore, it is recommended to transition to using siphash with its 128-bit keys to enhance the security of IP ID generation."
    },
    {
        "cwe": "CWE-824",
        "func_name": "gerbv/gerbv_open_image",
        "score": 0.7495582699775696,
        "func_before": "int\ngerbv_open_image(gerbv_project_t *gerbvProject, gchar const* filename, int idx, int reload,\n\t\tgerbv_HID_Attribute *fattr, int n_fattr, gboolean forceLoadFile)\n{\n    gerb_file_t *fd;\n    gerbv_image_t *parsed_image = NULL, *parsed_image2 = NULL;\n    gint retv = -1;\n    gboolean isPnpFile = FALSE, foundBinary;\n    gerbv_HID_Attribute *attr_list = NULL;\n    int n_attr = 0;\n    /* If we're reloading, we'll pass in our file format attribute list\n     * since this is our hook for letting the user override the fileformat.\n     */\n    if (reload)\n\t{\n\t    /* We're reloading so use the attribute list in memory */\n\t    attr_list =  gerbvProject->file[idx]->image->info->attr_list;\n\t    n_attr =  gerbvProject->file[idx]->image->info->n_attr;\n\t}\n    else\n\t{\n\t    /* We're not reloading so use the attribute list read from the \n\t     * project file if given or NULL otherwise.\n\t     */\n\t    attr_list = fattr;\n\t    n_attr = n_fattr;\n\t}\n    /* if we don't have enough spots, then grow the file list by 2 to account for the possible \n       loading of two images for PNP files */\n    if ((idx+1) >= gerbvProject->max_files) {\n\tgerbvProject->file = g_renew (gerbv_fileinfo_t *,\n\t\t\tgerbvProject->file, gerbvProject->max_files + 2);\n\n\tgerbvProject->file[gerbvProject->max_files] = NULL;\n\tgerbvProject->file[gerbvProject->max_files+1] = NULL;\n\tgerbvProject->max_files += 2;\n    }\n    \n    dprintf(\"In open_image, about to try opening filename = %s\\n\", filename);\n    \n    fd = gerb_fopen(filename);\n    if (fd == NULL) {\n\tGERB_COMPILE_ERROR(_(\"Trying to open \\\"%s\\\": %s\"),\n\t\t\tfilename, strerror(errno));\n\treturn -1;\n    }\n\n    /* Store filename info fd for further use */\n    fd->filename = g_strdup(filename);\n    \n    dprintf(\"In open_image, successfully opened file.  Now check its type....\\n\");\n    /* Here's where we decide what file type we have */\n    /* Note: if the file has some invalid characters in it but still appears to\n       be a valid file, we check with the user if he wants to continue (only\n       if user opens the layer from the menu...if from the command line, we go\n       ahead and try to load it anyways) */\n\n    if (gerber_is_rs274x_p(fd, &foundBinary)) {\n\tdprintf(\"Found RS-274X file\\n\");\n\tif (!foundBinary || forceLoadFile) {\n\t\t/* figure out the directory path in case parse_gerb needs to\n\t\t * load any include files */\n\t\tgchar *currentLoadDirectory = g_path_get_dirname (filename);\n\t\tparsed_image = parse_gerb(fd, currentLoadDirectory);\n\t\tg_free (currentLoadDirectory);\n\t}\n    } else if(drill_file_p(fd, &foundBinary)) {\n\tdprintf(\"Found drill file\\n\");\n\tif (!foundBinary || forceLoadFile)\n\t    parsed_image = parse_drillfile(fd, attr_list, n_attr, reload);\n\t\n    } else if (pick_and_place_check_file_type(fd, &foundBinary)) {\n\tdprintf(\"Found pick-n-place file\\n\");\n\tif (!foundBinary || forceLoadFile) {\n\t\tif (!reload) {\n\t\t\tpick_and_place_parse_file_to_images(fd, &parsed_image, &parsed_image2);\n\t\t} else {\n\t\t\tswitch (gerbvProject->file[idx]->image->layertype) {\n\t\t\tcase GERBV_LAYERTYPE_PICKANDPLACE_TOP:\n\t\t\t\t/* Non NULL pointer is used as \"not to reload\" mark */\n\t\t\t\tparsed_image2 = (void *)!NULL;\n\t\t\t\tpick_and_place_parse_file_to_images(fd, &parsed_image, &parsed_image2);\n\t\t\t\tparsed_image2 = NULL;\n\t\t\t\tbreak;\n\t\t\tcase GERBV_LAYERTYPE_PICKANDPLACE_BOT:\n\t\t\t\t/* Non NULL pointer is used as \"not to reload\" mark */\n\t\t\t\tparsed_image2 = (void *)!NULL;\n\t\t\t\tpick_and_place_parse_file_to_images(fd, &parsed_image2, &parsed_image);\n\t\t\t\tparsed_image2 = NULL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tGERB_COMPILE_ERROR(_(\"%s: unknown pick-and-place board side to reload\"), filename);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tisPnpFile = TRUE;\n\t}\n    } else if (gerber_is_rs274d_p(fd)) {\n\tgchar *str = g_strdup_printf(_(\"Most likely found a RS-274D file \"\n\t\t\t\"\\\"%s\\\" ... trying to open anyways\\n\"), filename);\n\tdprintf(\"%s\", str);\n\tg_warning(\"%s\", str);\n\tg_free (str);\n\n\tif (!foundBinary || forceLoadFile) {\n\t\t/* figure out the directory path in case parse_gerb needs to\n\t\t * load any include files */\n\t\tgchar *currentLoadDirectory = g_path_get_dirname (filename);\n\t\tparsed_image = parse_gerb(fd, currentLoadDirectory);\n\t\tg_free (currentLoadDirectory);\n\t}\n    } else {\n\t/* This is not a known file */\n\tdprintf(\"Unknown filetype\");\n\tGERB_COMPILE_ERROR(_(\"%s: Unknown file type.\"), filename);\n\tparsed_image = NULL;\n    }\n    \n    g_free(fd->filename);\n    gerb_fclose(fd);\n    if (parsed_image == NULL) {\n\treturn -1;\n    }\n    \n    if (parsed_image) {\n\t/* strip the filename to the base */\n\tgchar *baseName = g_path_get_basename (filename);\n\tgchar *displayedName;\n\tif (isPnpFile)\n\t\tdisplayedName = g_strconcat (baseName, _(\" (top)\"), NULL);\n\telse\n\t\tdisplayedName = g_strdup (baseName);\n    \tretv = gerbv_add_parsed_image_to_project (gerbvProject, parsed_image, filename, displayedName, idx, reload);\n    \tg_free (baseName);\n    \tg_free (displayedName);\n    }\n\n    /* Set layer_dirty flag to FALSE */\n    gerbvProject->file[idx]->layer_dirty = FALSE;\n\n    /* for PNP place files, we may need to add a second image for the other\n       board side */\n    if (parsed_image2) {\n      /* strip the filename to the base */\n\tgchar *baseName = g_path_get_basename (filename);\n\tgchar *displayedName;\n\tdisplayedName = g_strconcat (baseName, _(\" (bottom)\"), NULL);\n    \tretv = gerbv_add_parsed_image_to_project (gerbvProject, parsed_image2, filename, displayedName, idx + 1, reload);\n    \tg_free (baseName);\n    \tg_free (displayedName);\n    }\n\n    return retv;\n}",
        "func_after": "int\ngerbv_open_image(gerbv_project_t *gerbvProject, gchar const* filename, int idx, int reload,\n\t\tgerbv_HID_Attribute *fattr, int n_fattr, gboolean forceLoadFile)\n{\n    gerb_file_t *fd;\n    gerbv_image_t *parsed_image = NULL, *parsed_image2 = NULL;\n    gint retv = -1;\n    gboolean isPnpFile = FALSE, foundBinary;\n    gerbv_HID_Attribute *attr_list = NULL;\n    int n_attr = 0;\n    /* If we're reloading, we'll pass in our file format attribute list\n     * since this is our hook for letting the user override the fileformat.\n     */\n    if (reload)\n\t{\n\t    /* We're reloading so use the attribute list in memory */\n\t    attr_list =  gerbvProject->file[idx]->image->info->attr_list;\n\t    n_attr =  gerbvProject->file[idx]->image->info->n_attr;\n\t}\n    else\n\t{\n\t    /* We're not reloading so use the attribute list read from the \n\t     * project file if given or NULL otherwise.\n\t     */\n\t    attr_list = fattr;\n\t    n_attr = n_fattr;\n\t}\n    /* if we don't have enough spots, then grow the file list by 2 to account for the possible \n       loading of two images for PNP files */\n    if ((idx+1) >= gerbvProject->max_files) {\n\tgerbvProject->file = g_renew (gerbv_fileinfo_t *,\n\t\t\tgerbvProject->file, gerbvProject->max_files + 2);\n\n\tgerbvProject->file[gerbvProject->max_files] = NULL;\n\tgerbvProject->file[gerbvProject->max_files+1] = NULL;\n\tgerbvProject->max_files += 2;\n    }\n    \n    dprintf(\"In open_image, about to try opening filename = %s\\n\", filename);\n    \n    fd = gerb_fopen(filename);\n    if (fd == NULL) {\n\tGERB_COMPILE_ERROR(_(\"Trying to open \\\"%s\\\": %s\"),\n\t\t\tfilename, strerror(errno));\n\treturn -1;\n    }\n\n    dprintf(\"In open_image, successfully opened file.  Now check its type....\\n\");\n    /* Here's where we decide what file type we have */\n    /* Note: if the file has some invalid characters in it but still appears to\n       be a valid file, we check with the user if he wants to continue (only\n       if user opens the layer from the menu...if from the command line, we go\n       ahead and try to load it anyways) */\n\n    if (gerber_is_rs274x_p(fd, &foundBinary)) {\n\tdprintf(\"Found RS-274X file\\n\");\n\tif (!foundBinary || forceLoadFile) {\n\t\t/* figure out the directory path in case parse_gerb needs to\n\t\t * load any include files */\n\t\tgchar *currentLoadDirectory = g_path_get_dirname (filename);\n\t\tparsed_image = parse_gerb(fd, currentLoadDirectory);\n\t\tg_free (currentLoadDirectory);\n\t}\n    } else if(drill_file_p(fd, &foundBinary)) {\n\tdprintf(\"Found drill file\\n\");\n\tif (!foundBinary || forceLoadFile)\n\t    parsed_image = parse_drillfile(fd, attr_list, n_attr, reload);\n\t\n    } else if (pick_and_place_check_file_type(fd, &foundBinary)) {\n\tdprintf(\"Found pick-n-place file\\n\");\n\tif (!foundBinary || forceLoadFile) {\n\t\tif (!reload) {\n\t\t\tpick_and_place_parse_file_to_images(fd, &parsed_image, &parsed_image2);\n\t\t} else {\n\t\t\tswitch (gerbvProject->file[idx]->image->layertype) {\n\t\t\tcase GERBV_LAYERTYPE_PICKANDPLACE_TOP:\n\t\t\t\t/* Non NULL pointer is used as \"not to reload\" mark */\n\t\t\t\tparsed_image2 = (void *)!NULL;\n\t\t\t\tpick_and_place_parse_file_to_images(fd, &parsed_image, &parsed_image2);\n\t\t\t\tparsed_image2 = NULL;\n\t\t\t\tbreak;\n\t\t\tcase GERBV_LAYERTYPE_PICKANDPLACE_BOT:\n\t\t\t\t/* Non NULL pointer is used as \"not to reload\" mark */\n\t\t\t\tparsed_image2 = (void *)!NULL;\n\t\t\t\tpick_and_place_parse_file_to_images(fd, &parsed_image2, &parsed_image);\n\t\t\t\tparsed_image2 = NULL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tGERB_COMPILE_ERROR(_(\"%s: unknown pick-and-place board side to reload\"), filename);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tisPnpFile = TRUE;\n\t}\n    } else if (gerber_is_rs274d_p(fd)) {\n\tgchar *str = g_strdup_printf(_(\"Most likely found a RS-274D file \"\n\t\t\t\"\\\"%s\\\" ... trying to open anyways\\n\"), filename);\n\tdprintf(\"%s\", str);\n\tg_warning(\"%s\", str);\n\tg_free (str);\n\n\tif (!foundBinary || forceLoadFile) {\n\t\t/* figure out the directory path in case parse_gerb needs to\n\t\t * load any include files */\n\t\tgchar *currentLoadDirectory = g_path_get_dirname (filename);\n\t\tparsed_image = parse_gerb(fd, currentLoadDirectory);\n\t\tg_free (currentLoadDirectory);\n\t}\n    } else {\n\t/* This is not a known file */\n\tdprintf(\"Unknown filetype\");\n\tGERB_COMPILE_ERROR(_(\"%s: Unknown file type.\"), filename);\n\tparsed_image = NULL;\n    }\n    \n    gerb_fclose(fd);\n    if (parsed_image == NULL) {\n\treturn -1;\n    }\n    \n    if (parsed_image) {\n\t/* strip the filename to the base */\n\tgchar *baseName = g_path_get_basename (filename);\n\tgchar *displayedName;\n\tif (isPnpFile)\n\t\tdisplayedName = g_strconcat (baseName, _(\" (top)\"), NULL);\n\telse\n\t\tdisplayedName = g_strdup (baseName);\n    \tretv = gerbv_add_parsed_image_to_project (gerbvProject, parsed_image, filename, displayedName, idx, reload);\n    \tg_free (baseName);\n    \tg_free (displayedName);\n    }\n\n    /* Set layer_dirty flag to FALSE */\n    gerbvProject->file[idx]->layer_dirty = FALSE;\n\n    /* for PNP place files, we may need to add a second image for the other\n       board side */\n    if (parsed_image2) {\n      /* strip the filename to the base */\n\tgchar *baseName = g_path_get_basename (filename);\n\tgchar *displayedName;\n\tdisplayedName = g_strconcat (baseName, _(\" (bottom)\"), NULL);\n    \tretv = gerbv_add_parsed_image_to_project (gerbvProject, parsed_image2, filename, displayedName, idx + 1, reload);\n    \tg_free (baseName);\n    \tg_free (displayedName);\n    }\n\n    return retv;\n}",
        "description": "A user with control over file input to Gerbv, between versions 2.4.0 and 2.10.0, can trigger a crash and achieve a denial-of-service condition by providing a specially crafted Gerber RS-274X file.",
        "commit": "An out-of-bounds memory access vulnerability related to filename handling was identified. To address this, all filename allocation and deallocation have been centralized within the `gerb_fopen` and `gerb_fclose` functions, eliminating the need for the caller to manage these operations. Additionally, a previously allocated `includeFilename` was not being properly freed, which has now been corrected. Unit tests have been added to ensure proper memory management using Valgrind."
    },
    {
        "cwe": "CWE-407",
        "func_name": "reddit/find_link_ref",
        "score": 0.713615894317627,
        "func_before": "static struct link_ref *\nfind_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n{\n\tunsigned int hash = hash_link_ref(name, length);\n\tstruct link_ref *ref = NULL;\n\n\tref = references[hash % REF_TABLE_SIZE];\n\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash)\n\t\t\treturn ref;\n\n\t\tref = ref->next;\n\t}\n\n\treturn NULL;\n}",
        "func_after": "static struct link_ref *\nfind_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n{\n\tunsigned int hash = hash_link_ref(name, length);\n\tstruct link_ref *ref = NULL;\n\n\tref = references[hash % REF_TABLE_SIZE];\n\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash && ref->label->size == length) {\n\t\t\tif (strncasecmp((char *)ref->label->data, (char *) name, length) == 0) {\n\t\t\t\treturn ref;\n\t\t\t}\n\t\t}\n\n\t\tref = ref->next;\n\t}\n\n\treturn NULL;\n}",
        "description": "Snudown, a Reddit-specific fork of the Sundown Markdown parser with Python integration, was found to be vulnerable to denial of service (DoS) attacks due to weaknesses in its reference table implementation. Specifically, the hash function used for inserting references into a hash table was weak, allowing attackers to generate a large number of collisions. Additionally, the hash table permitted duplicate entries, leading to prolonged retrieval times. These issues collectively make the system susceptible to hash-collision DoS attacks, a form of algorithmic complexity attack. Users are advised to update to version 1.7.0 to mitigate these vulnerabilities.",
        "commit": "A vulnerability related to hash collisions has been identified and addressed by implementing a case-insensitive SipHash function to replace the existing reference hash function. Additionally, changes were made to the `link_ref` structure to include a label, and updates were applied to the `find_link_ref` and `add_link_ref` functions to ensure they compare link labels as well as hashes and disallow duplicate entries, respectively. A cast was added to convert from `uint8_t` to `char` for use with `strncasecmp`. The README markdown was updated to remove TODO items, and support for generating Python 2 wheels was added. Furthermore, logic was included to handle older versions of glibc that do not have the `getrandom` function, impacting the staging environment."
    },
    {
        "cwe": "CWE-772",
        "func_name": "binutils-gdb/display_rel_file",
        "score": 0.7501364946365356,
        "func_before": "static void\ndisplay_rel_file (bfd *abfd, bfd *archive_bfd)\n{\n  long symcount;\n  void *minisyms;\n  unsigned int size;\n  struct size_sym *symsizes;\n  asymbol *synthsyms = NULL;\n\n  if (! dynamic)\n    {\n      if (!(bfd_get_file_flags (abfd) & HAS_SYMS))\n\t{\n\t  non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n\t  return;\n\t}\n    }\n\n  symcount = bfd_read_minisymbols (abfd, dynamic, &minisyms, &size);\n  if (symcount < 0)\n    {\n      if (dynamic && bfd_get_error () == bfd_error_no_symbols)\n\t{\n\t  non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n\t  return;\n\t}\n\n      bfd_fatal (bfd_get_filename (abfd));\n    }\n\n  if (symcount == 0)\n    {\n      non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n      return;\n    }\n\n  if (show_synthetic && size == sizeof (asymbol *))\n    {\n      asymbol **static_syms = NULL;\n      asymbol **dyn_syms = NULL;\n      long static_count = 0;\n      long dyn_count = 0;\n      long synth_count;\n\n      if (dynamic)\n\t{\n\t  dyn_count = symcount;\n\t  dyn_syms = (asymbol **) minisyms;\n\t}\n      else\n\t{\n\t  long storage = bfd_get_dynamic_symtab_upper_bound (abfd);\n\n\t  static_count = symcount;\n\t  static_syms = (asymbol **) minisyms;\n\n\t  if (storage > 0)\n\t    {\n\t      dyn_syms = (asymbol **) xmalloc (storage);\n\t      dyn_count = bfd_canonicalize_dynamic_symtab (abfd, dyn_syms);\n\t      if (dyn_count < 0)\n\t\tbfd_fatal (bfd_get_filename (abfd));\n\t    }\n\t}\n\n      synth_count = bfd_get_synthetic_symtab (abfd, static_count, static_syms,\n\t\t\t\t\t      dyn_count, dyn_syms, &synthsyms);\n      if (synth_count > 0)\n\t{\n\t  asymbol **symp;\n\t  void *new_mini;\n\t  long i;\n\n\t  new_mini = xmalloc ((symcount + synth_count + 1) * sizeof (*symp));\n\t  symp = (asymbol **) new_mini;\n\t  memcpy (symp, minisyms, symcount * sizeof (*symp));\n\t  symp += symcount;\n\t  for (i = 0; i < synth_count; i++)\n\t    *symp++ = synthsyms + i;\n\t  *symp = 0;\n\t  minisyms = new_mini;\n\t  symcount += synth_count;\n\t}\n    }\n\n  /* Discard the symbols we don't want to print.\n     It's OK to do this in place; we'll free the storage anyway\n     (after printing).  */\n\n  symcount = filter_symbols (abfd, dynamic, minisyms, symcount, size);\n\n  symsizes = NULL;\n  if (! no_sort)\n    {\n      sort_bfd = abfd;\n      sort_dynamic = dynamic;\n      sort_x = bfd_make_empty_symbol (abfd);\n      sort_y = bfd_make_empty_symbol (abfd);\n      if (sort_x == NULL || sort_y == NULL)\n\tbfd_fatal (bfd_get_filename (abfd));\n\n      if (! sort_by_size)\n\tqsort (minisyms, symcount, size,\n\t       sorters[sort_numerically][reverse_sort]);\n      else\n\tsymcount = sort_symbols_by_size (abfd, dynamic, minisyms, symcount,\n\t\t\t\t\t size, &symsizes);\n    }\n\n  if (! sort_by_size)\n    print_symbols (abfd, dynamic, minisyms, symcount, size, archive_bfd);\n  else\n    print_size_symbols (abfd, dynamic, symsizes, symcount, archive_bfd);\n\n  if (synthsyms)\n    free (synthsyms);\n  free (minisyms);\n  free (symsizes);\n}",
        "func_after": "static void\ndisplay_rel_file (bfd *abfd, bfd *archive_bfd)\n{\n  long symcount;\n  void *minisyms;\n  unsigned int size;\n  struct size_sym *symsizes;\n  asymbol *synthsyms = NULL;\n\n  if (! dynamic)\n    {\n      if (!(bfd_get_file_flags (abfd) & HAS_SYMS))\n\t{\n\t  non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n\t  return;\n\t}\n    }\n\n  symcount = bfd_read_minisymbols (abfd, dynamic, &minisyms, &size);\n  if (symcount < 0)\n    {\n      if (dynamic && bfd_get_error () == bfd_error_no_symbols)\n\t{\n\t  non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n\t  return;\n\t}\n\n      bfd_fatal (bfd_get_filename (abfd));\n    }\n\n  if (symcount == 0)\n    {\n      non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n      return;\n    }\n\n  if (show_synthetic && size == sizeof (asymbol *))\n    {\n      asymbol **static_syms = NULL;\n      asymbol **dyn_syms = NULL;\n      long static_count = 0;\n      long dyn_count = 0;\n      long synth_count;\n\n      if (dynamic)\n\t{\n\t  dyn_count = symcount;\n\t  dyn_syms = (asymbol **) minisyms;\n\t}\n      else\n\t{\n\t  long storage = bfd_get_dynamic_symtab_upper_bound (abfd);\n\n\t  static_count = symcount;\n\t  static_syms = (asymbol **) minisyms;\n\n\t  if (storage > 0)\n\t    {\n\t      dyn_syms = (asymbol **) xmalloc (storage);\n\t      dyn_count = bfd_canonicalize_dynamic_symtab (abfd, dyn_syms);\n\t      if (dyn_count < 0)\n\t\tbfd_fatal (bfd_get_filename (abfd));\n\t    }\n\t}\n\n      synth_count = bfd_get_synthetic_symtab (abfd, static_count, static_syms,\n\t\t\t\t\t      dyn_count, dyn_syms, &synthsyms);\n      if (synth_count > 0)\n\t{\n\t  asymbol **symp;\n\t  long i;\n\n\t  minisyms = xrealloc (minisyms,\n\t\t\t       (symcount + synth_count + 1) * sizeof (*symp));\n\t  symp = (asymbol **) minisyms + symcount;\n\t  for (i = 0; i < synth_count; i++)\n\t    *symp++ = synthsyms + i;\n\t  *symp = 0;\n\t  symcount += synth_count;\n\t}\n    }\n\n  /* Discard the symbols we don't want to print.\n     It's OK to do this in place; we'll free the storage anyway\n     (after printing).  */\n\n  symcount = filter_symbols (abfd, dynamic, minisyms, symcount, size);\n\n  symsizes = NULL;\n  if (! no_sort)\n    {\n      sort_bfd = abfd;\n      sort_dynamic = dynamic;\n      sort_x = bfd_make_empty_symbol (abfd);\n      sort_y = bfd_make_empty_symbol (abfd);\n      if (sort_x == NULL || sort_y == NULL)\n\tbfd_fatal (bfd_get_filename (abfd));\n\n      if (! sort_by_size)\n\tqsort (minisyms, symcount, size,\n\t       sorters[sort_numerically][reverse_sort]);\n      else\n\tsymcount = sort_symbols_by_size (abfd, dynamic, minisyms, symcount,\n\t\t\t\t\t size, &symsizes);\n    }\n\n  if (! sort_by_size)\n    print_symbols (abfd, dynamic, minisyms, symcount, size, archive_bfd);\n  else\n    print_size_symbols (abfd, dynamic, symsizes, symcount, archive_bfd);\n\n  if (synthsyms)\n    free (synthsyms);\n  free (minisyms);\n  free (symsizes);\n}",
        "description": "The `_bfd_generic_read_minisymbols` function in the BFD library, part of GNU Binutils 2.31, suffers from a memory leak when processing a specially crafted ELF file. This flaw results in excessive memory consumption, potentially leading to a denial of service.",
        "commit": "A memory leak was identified in the `_bfd_generic_read_minisymbols` function within the BFD library. The issue arises when the function fails to free allocated memory (`syms`) before returning with a zero symbol count. Additionally, in the `nm.c` file, the `display_rel_file` function uses `xrealloc` to increase the size of `minisyms` for synthetic symbols, indicating potential issues with memory management in these areas."
    }
]