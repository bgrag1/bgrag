[
    {
        "cwe": "CWE-78",
        "func_name": "emacs/main",
        "score": 0.7484179735183716,
        "func_before": "int\nmain (int argc, char **argv)\n{\n  int i;\n  int nincluded_files;\n  char **included_files;\n  argument *argbuffer;\n  int current_arg, file_count;\n  linebuffer filename_lb;\n  bool help_asked = false;\n  ptrdiff_t len;\n  char *optstring;\n  int opt;\n\n  progname = argv[0];\n  nincluded_files = 0;\n  included_files = xnew (argc, char *);\n  current_arg = 0;\n  file_count = 0;\n\n  /* Allocate enough no matter what happens.  Overkill, but each one\n     is small. */\n  argbuffer = xnew (argc, argument);\n\n  /*\n   * Always find typedefs and structure tags.\n   * Also default to find macro constants, enum constants, struct\n   * members and global variables.  Do it for both etags and ctags.\n   */\n  typedefs = typedefs_or_cplusplus = constantypedefs = true;\n  globals = members = true;\n\n  /* When the optstring begins with a '-' getopt_long does not rearrange the\n     non-options arguments to be at the end, but leaves them alone. */\n  optstring = concat (\"-ac:Cf:Il:o:Qr:RSVhH\",\n\t\t      (CTAGS) ? \"BxdtTuvw\" : \"Di:\",\n\t\t      \"\");\n\n  while ((opt = getopt_long (argc, argv, optstring, longopts, NULL)) != EOF)\n    switch (opt)\n      {\n      case 0:\n\t/* If getopt returns 0, then it has already processed a\n\t   long-named option.  We should do nothing.  */\n\tbreak;\n\n      case 1:\n\t/* This means that a file name has been seen.  Record it. */\n\targbuffer[current_arg].arg_type = at_filename;\n\targbuffer[current_arg].what     = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\t++file_count;\n\tbreak;\n\n      case STDIN:\n\t/* Parse standard input.  Idea by Vivek <vivek@etla.org>. */\n\targbuffer[current_arg].arg_type = at_stdin;\n\targbuffer[current_arg].what     = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\t++file_count;\n\tif (parsing_stdin)\n\t  fatal (\"cannot parse standard input more than once\");\n\tparsing_stdin = true;\n\tbreak;\n\n\t/* Common options. */\n      case 'a': append_to_tagfile = true;\tbreak;\n      case 'C': cplusplus = true;\t\tbreak;\n      case 'f':\t\t/* for compatibility with old makefiles */\n      case 'o':\n\tif (tagfile)\n\t  {\n\t    error (\"-o option may only be given once.\");\n\t    suggest_asking_for_help ();\n\t  }\n\ttagfile = optarg;\n\tbreak;\n      case 'I':\n      case 'S':\t\t/* for backward compatibility */\n\tignoreindent = true;\n\tbreak;\n      case 'l':\n\t{\n\t  language *lang = get_language_from_langname (optarg);\n\t  if (lang != NULL)\n\t    {\n\t      argbuffer[current_arg].lang = lang;\n\t      argbuffer[current_arg].arg_type = at_language;\n\t      ++current_arg;\n\t    }\n\t}\n\tbreak;\n      case 'c':\n\t/* Backward compatibility: support obsolete --ignore-case-regexp. */\n\toptarg = concat (optarg, \"i\", \"\"); /* memory leak here */\n\tFALLTHROUGH;\n      case 'r':\n\targbuffer[current_arg].arg_type = at_regexp;\n\targbuffer[current_arg].what = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\tbreak;\n      case 'R':\n\targbuffer[current_arg].arg_type = at_regexp;\n\targbuffer[current_arg].what = NULL;\n\t++current_arg;\n\tbreak;\n      case 'V':\n\tprint_version ();\n\tbreak;\n      case 'h':\n      case 'H':\n\thelp_asked = true;\n\tbreak;\n      case 'Q':\n\tclass_qualify = 1;\n\tbreak;\n\n\t/* Etags options */\n      case 'D': constantypedefs = false;\t\t\tbreak;\n      case 'i': included_files[nincluded_files++] = optarg;\tbreak;\n\n\t/* Ctags options. */\n      case 'B': searchar = '?';\t\t\t\t\tbreak;\n      case 'd': constantypedefs = true;\t\t\t\tbreak;\n      case 't': typedefs = true;\t\t\t\tbreak;\n      case 'T': typedefs = typedefs_or_cplusplus = true;\tbreak;\n      case 'u': update = true;\t\t\t\t\tbreak;\n      case 'v': vgrind_style = true;\t\t\t\tFALLTHROUGH;\n      case 'x': cxref_style = true;\t\t\t\tbreak;\n      case 'w': no_warnings = true;\t\t\t\tbreak;\n      default:\n\tsuggest_asking_for_help ();\n      }\n\n  /* No more options.  Store the rest of arguments. */\n  for (; optind < argc; optind++)\n    {\n      argbuffer[current_arg].arg_type = at_filename;\n      argbuffer[current_arg].what = argv[optind];\n      len = strlen (argv[optind]);\n      if (whatlen_max < len)\n\twhatlen_max = len;\n      ++current_arg;\n      ++file_count;\n    }\n\n  argbuffer[current_arg].arg_type = at_end;\n\n  if (help_asked)\n    print_help (argbuffer);\n\n  if (nincluded_files == 0 && file_count == 0)\n    {\n      error (\"no input files specified.\");\n      suggest_asking_for_help ();\n    }\n\n  if (tagfile == NULL)\n    tagfile = savestr (CTAGS ? \"tags\" : \"TAGS\");\n  cwd = etags_getcwd ();\t/* the current working directory */\n  if (cwd[strlen (cwd) - 1] != '/')\n    {\n      char *oldcwd = cwd;\n      cwd = concat (oldcwd, \"/\", \"\");\n      free (oldcwd);\n    }\n\n  /* Compute base directory for relative file names. */\n  if (streq (tagfile, \"-\")\n      || strneq (tagfile, \"/dev/\", 5))\n    tagfiledir = cwd;\t\t /* relative file names are relative to cwd */\n  else\n    {\n      canonicalize_filename (tagfile);\n      tagfiledir = absolute_dirname (tagfile, cwd);\n    }\n\n  linebuffer_init (&lb);\n  linebuffer_init (&filename_lb);\n  linebuffer_init (&filebuf);\n  linebuffer_init (&token_name);\n\n  if (!CTAGS)\n    {\n      if (streq (tagfile, \"-\"))\n\t{\n\t  tagf = stdout;\n\t  set_binary_mode (STDOUT_FILENO, O_BINARY);\n\t}\n      else\n\ttagf = fopen (tagfile, append_to_tagfile ? \"ab\" : \"wb\");\n      if (tagf == NULL)\n\tpfatal (tagfile);\n    }\n\n  /*\n   * Loop through files finding functions.\n   */\n  for (i = 0; i < current_arg; i++)\n    {\n      static language *lang;\t/* non-NULL if language is forced */\n      char *this_file;\n\n      switch (argbuffer[i].arg_type)\n\t{\n\tcase at_language:\n\t  lang = argbuffer[i].lang;\n\t  break;\n\tcase at_regexp:\n\t  analyze_regex (argbuffer[i].what);\n\t  break;\n\tcase at_filename:\n\t      this_file = argbuffer[i].what;\n\t      /* Input file named \"-\" means read file names from stdin\n\t\t (one per line) and use them. */\n\t      if (streq (this_file, \"-\"))\n\t\t{\n\t\t  if (parsing_stdin)\n\t\t    fatal (\"cannot parse standard input \"\n\t\t\t   \"AND read file names from it\");\n\t\t  while (readline_internal (&filename_lb, stdin, \"-\") > 0)\n\t\t    process_file_name (filename_lb.buffer, lang);\n\t\t}\n\t      else\n\t\tprocess_file_name (this_file, lang);\n\t  break;\n        case at_stdin:\n          this_file = argbuffer[i].what;\n          process_file (stdin, this_file, lang);\n          break;\n\tdefault:\n\t  error (\"internal error: arg_type\");\n\t}\n    }\n\n  free_regexps ();\n  free (lb.buffer);\n  free (filebuf.buffer);\n  free (token_name.buffer);\n\n  if (!CTAGS || cxref_style)\n    {\n      /* Write the remaining tags to tagf (ETAGS) or stdout (CXREF). */\n      put_entries (nodehead);\n      free_tree (nodehead);\n      nodehead = NULL;\n      if (!CTAGS)\n\t{\n\t  fdesc *fdp;\n\n\t  /* Output file entries that have no tags. */\n\t  for (fdp = fdhead; fdp != NULL; fdp = fdp->next)\n\t    if (!fdp->written)\n\t      fprintf (tagf, \"\\f\\n%s,0\\n\", fdp->taggedfname);\n\n\t  while (nincluded_files-- > 0)\n\t    fprintf (tagf, \"\\f\\n%s,include\\n\", *included_files++);\n\n\t  if (fclose (tagf) == EOF)\n\t    pfatal (tagfile);\n\t}\n\n      return EXIT_SUCCESS;\n    }\n\n  /* From here on, we are in (CTAGS && !cxref_style) */\n  if (update)\n    {\n      char *cmd =\n\txmalloc (strlen (tagfile) + whatlen_max +\n\t\t sizeof \"mv..OTAGS;grep -Fv '\\t\\t' OTAGS >;rm OTAGS\");\n      for (i = 0; i < current_arg; ++i)\n\t{\n\t  switch (argbuffer[i].arg_type)\n\t    {\n\t    case at_filename:\n\t    case at_stdin:\n\t      break;\n\t    default:\n\t      continue;\t\t/* the for loop */\n\t    }\n\t  char *z = stpcpy (cmd, \"mv \");\n\t  z = stpcpy (z, tagfile);\n\t  z = stpcpy (z, \" OTAGS;grep -Fv '\\t\");\n\t  z = stpcpy (z, argbuffer[i].what);\n\t  z = stpcpy (z, \"\\t' OTAGS >\");\n\t  z = stpcpy (z, tagfile);\n\t  strcpy (z, \";rm OTAGS\");\n\t  if (system (cmd) != EXIT_SUCCESS)\n\t    fatal (\"failed to execute shell command\");\n\t}\n      free (cmd);\n      append_to_tagfile = true;\n    }\n\n  tagf = fopen (tagfile, append_to_tagfile ? \"ab\" : \"wb\");\n  if (tagf == NULL)\n    pfatal (tagfile);\n  put_entries (nodehead);\t/* write all the tags (CTAGS) */\n  free_tree (nodehead);\n  nodehead = NULL;\n  if (fclose (tagf) == EOF)\n    pfatal (tagfile);\n\n  if (CTAGS)\n    if (append_to_tagfile || update)\n      {\n\t/* Maybe these should be used:\n\t   setenv (\"LC_COLLATE\", \"C\", 1);\n\t   setenv (\"LC_ALL\", \"C\", 1); */\n\tchar *cmd = xmalloc (8 * strlen (tagfile) + sizeof \"sort -u -o '' ''\");\n#if defined WINDOWSNT || defined MSDOS\n\t/* Quote \"like this\".  No need to escape the quotes in the file name,\n\t   since it is not allowed in file names on these systems.  */\n\tchar *z = stpcpy (cmd, \"sort -u -o \\\"\");\n\tz = stpcpy (z, tagfile);\n\tz = stpcpy (z, \"\\\" \\\"\");\n\tz = stpcpy (z, tagfile);\n\tstpcpy (z, \"\\\"\");\n#else\n\t/* Quote 'like this', and escape the apostrophe in the file name.  */\n\tchar *z = stpcpy (cmd, \"sort -u -o '\");\n\tchar *escaped_tagfile = z;\n\tfor (; *tagfile; *z++ = *tagfile++)\n\t  if (*tagfile == '\\'')\n\t    z = stpcpy (z, \"'\\\\'\");\n\tptrdiff_t escaped_tagfile_len = z - escaped_tagfile;\n\tz = stpcpy (z, \"' '\");\n\tz = mempcpy (z, escaped_tagfile, escaped_tagfile_len);\n\tstrcpy (z, \"'\");\n#endif\n\treturn system (cmd);\n      }\n  return EXIT_SUCCESS;\n}",
        "func_after": "int\nmain (int argc, char **argv)\n{\n  int i;\n  int nincluded_files;\n  char **included_files;\n  argument *argbuffer;\n  int current_arg, file_count;\n  linebuffer filename_lb;\n  bool help_asked = false;\n  ptrdiff_t len;\n  char *optstring;\n  int opt;\n\n  progname = argv[0];\n  nincluded_files = 0;\n  included_files = xnew (argc, char *);\n  current_arg = 0;\n  file_count = 0;\n\n  /* Allocate enough no matter what happens.  Overkill, but each one\n     is small. */\n  argbuffer = xnew (argc, argument);\n\n  /*\n   * Always find typedefs and structure tags.\n   * Also default to find macro constants, enum constants, struct\n   * members and global variables.  Do it for both etags and ctags.\n   */\n  typedefs = typedefs_or_cplusplus = constantypedefs = true;\n  globals = members = true;\n\n  /* When the optstring begins with a '-' getopt_long does not rearrange the\n     non-options arguments to be at the end, but leaves them alone. */\n  optstring = concat (\"-ac:Cf:Il:o:Qr:RSVhH\",\n\t\t      (CTAGS) ? \"BxdtTuvw\" : \"Di:\",\n\t\t      \"\");\n\n  while ((opt = getopt_long (argc, argv, optstring, longopts, NULL)) != EOF)\n    switch (opt)\n      {\n      case 0:\n\t/* If getopt returns 0, then it has already processed a\n\t   long-named option.  We should do nothing.  */\n\tbreak;\n\n      case 1:\n\t/* This means that a file name has been seen.  Record it. */\n\targbuffer[current_arg].arg_type = at_filename;\n\targbuffer[current_arg].what     = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\t++file_count;\n\tbreak;\n\n      case STDIN:\n\t/* Parse standard input.  Idea by Vivek <vivek@etla.org>. */\n\targbuffer[current_arg].arg_type = at_stdin;\n\targbuffer[current_arg].what     = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\t++file_count;\n\tif (parsing_stdin)\n\t  fatal (\"cannot parse standard input more than once\");\n\tparsing_stdin = true;\n\tbreak;\n\n\t/* Common options. */\n      case 'a': append_to_tagfile = true;\tbreak;\n      case 'C': cplusplus = true;\t\tbreak;\n      case 'f':\t\t/* for compatibility with old makefiles */\n      case 'o':\n\tif (tagfile)\n\t  {\n\t    error (\"-o option may only be given once.\");\n\t    suggest_asking_for_help ();\n\t  }\n\ttagfile = optarg;\n\tbreak;\n      case 'I':\n      case 'S':\t\t/* for backward compatibility */\n\tignoreindent = true;\n\tbreak;\n      case 'l':\n\t{\n\t  language *lang = get_language_from_langname (optarg);\n\t  if (lang != NULL)\n\t    {\n\t      argbuffer[current_arg].lang = lang;\n\t      argbuffer[current_arg].arg_type = at_language;\n\t      ++current_arg;\n\t    }\n\t}\n\tbreak;\n      case 'c':\n\t/* Backward compatibility: support obsolete --ignore-case-regexp. */\n\toptarg = concat (optarg, \"i\", \"\"); /* memory leak here */\n\tFALLTHROUGH;\n      case 'r':\n\targbuffer[current_arg].arg_type = at_regexp;\n\targbuffer[current_arg].what = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\tbreak;\n      case 'R':\n\targbuffer[current_arg].arg_type = at_regexp;\n\targbuffer[current_arg].what = NULL;\n\t++current_arg;\n\tbreak;\n      case 'V':\n\tprint_version ();\n\tbreak;\n      case 'h':\n      case 'H':\n\thelp_asked = true;\n\tbreak;\n      case 'Q':\n\tclass_qualify = 1;\n\tbreak;\n\n\t/* Etags options */\n      case 'D': constantypedefs = false;\t\t\tbreak;\n      case 'i': included_files[nincluded_files++] = optarg;\tbreak;\n\n\t/* Ctags options. */\n      case 'B': searchar = '?';\t\t\t\t\tbreak;\n      case 'd': constantypedefs = true;\t\t\t\tbreak;\n      case 't': typedefs = true;\t\t\t\tbreak;\n      case 'T': typedefs = typedefs_or_cplusplus = true;\tbreak;\n      case 'u': update = true;\t\t\t\t\tbreak;\n      case 'v': vgrind_style = true;\t\t\t\tFALLTHROUGH;\n      case 'x': cxref_style = true;\t\t\t\tbreak;\n      case 'w': no_warnings = true;\t\t\t\tbreak;\n      default:\n\tsuggest_asking_for_help ();\n      }\n\n  /* No more options.  Store the rest of arguments. */\n  for (; optind < argc; optind++)\n    {\n      argbuffer[current_arg].arg_type = at_filename;\n      argbuffer[current_arg].what = argv[optind];\n      len = strlen (argv[optind]);\n      if (whatlen_max < len)\n\twhatlen_max = len;\n      ++current_arg;\n      ++file_count;\n    }\n\n  argbuffer[current_arg].arg_type = at_end;\n\n  if (help_asked)\n    print_help (argbuffer);\n\n  if (nincluded_files == 0 && file_count == 0)\n    {\n      error (\"no input files specified.\");\n      suggest_asking_for_help ();\n    }\n\n  if (tagfile == NULL)\n    tagfile = savestr (CTAGS ? \"tags\" : \"TAGS\");\n  cwd = etags_getcwd ();\t/* the current working directory */\n  if (cwd[strlen (cwd) - 1] != '/')\n    {\n      char *oldcwd = cwd;\n      cwd = concat (oldcwd, \"/\", \"\");\n      free (oldcwd);\n    }\n\n  /* Compute base directory for relative file names. */\n  if (streq (tagfile, \"-\")\n      || strneq (tagfile, \"/dev/\", 5))\n    tagfiledir = cwd;\t\t /* relative file names are relative to cwd */\n  else\n    {\n      canonicalize_filename (tagfile);\n      tagfiledir = absolute_dirname (tagfile, cwd);\n    }\n\n  linebuffer_init (&lb);\n  linebuffer_init (&filename_lb);\n  linebuffer_init (&filebuf);\n  linebuffer_init (&token_name);\n\n  if (!CTAGS)\n    {\n      if (streq (tagfile, \"-\"))\n\t{\n\t  tagf = stdout;\n\t  set_binary_mode (STDOUT_FILENO, O_BINARY);\n\t}\n      else\n\ttagf = fopen (tagfile, append_to_tagfile ? \"ab\" : \"wb\");\n      if (tagf == NULL)\n\tpfatal (tagfile);\n    }\n\n  /*\n   * Loop through files finding functions.\n   */\n  for (i = 0; i < current_arg; i++)\n    {\n      static language *lang;\t/* non-NULL if language is forced */\n      char *this_file;\n\n      switch (argbuffer[i].arg_type)\n\t{\n\tcase at_language:\n\t  lang = argbuffer[i].lang;\n\t  break;\n\tcase at_regexp:\n\t  analyze_regex (argbuffer[i].what);\n\t  break;\n\tcase at_filename:\n\t      this_file = argbuffer[i].what;\n\t      /* Input file named \"-\" means read file names from stdin\n\t\t (one per line) and use them. */\n\t      if (streq (this_file, \"-\"))\n\t\t{\n\t\t  if (parsing_stdin)\n\t\t    fatal (\"cannot parse standard input \"\n\t\t\t   \"AND read file names from it\");\n\t\t  while (readline_internal (&filename_lb, stdin, \"-\", false) > 0)\n\t\t    process_file_name (filename_lb.buffer, lang);\n\t\t}\n\t      else\n\t\tprocess_file_name (this_file, lang);\n\t  break;\n        case at_stdin:\n          this_file = argbuffer[i].what;\n          process_file (stdin, this_file, lang);\n          break;\n\tdefault:\n\t  error (\"internal error: arg_type\");\n\t}\n    }\n\n  free_regexps ();\n  free (lb.buffer);\n  free (filebuf.buffer);\n  free (token_name.buffer);\n\n  if (!CTAGS || cxref_style)\n    {\n      /* Write the remaining tags to tagf (ETAGS) or stdout (CXREF). */\n      put_entries (nodehead);\n      free_tree (nodehead);\n      nodehead = NULL;\n      if (!CTAGS)\n\t{\n\t  fdesc *fdp;\n\n\t  /* Output file entries that have no tags. */\n\t  for (fdp = fdhead; fdp != NULL; fdp = fdp->next)\n\t    if (!fdp->written)\n\t      fprintf (tagf, \"\\f\\n%s,0\\n\", fdp->taggedfname);\n\n\t  while (nincluded_files-- > 0)\n\t    fprintf (tagf, \"\\f\\n%s,include\\n\", *included_files++);\n\n\t  if (fclose (tagf) == EOF)\n\t    pfatal (tagfile);\n\t}\n\n      return EXIT_SUCCESS;\n    }\n\n  /* From here on, we are in (CTAGS && !cxref_style) */\n  if (update)\n    {\n      for (i = 0; i < current_arg; ++i)\n\t{\n\t  switch (argbuffer[i].arg_type)\n\t    {\n\t    case at_filename:\n\t    case at_stdin:\n\t      break;\n\t    default:\n\t      continue;\t\t/* the for loop */\n\t    }\n          clean_matched_file_tag (tagfile, argbuffer[i].what);\n\t}\n      append_to_tagfile = true;\n    }\n\n  tagf = fopen (tagfile, append_to_tagfile ? \"ab\" : \"wb\");\n  if (tagf == NULL)\n    pfatal (tagfile);\n  put_entries (nodehead);\t/* write all the tags (CTAGS) */\n  free_tree (nodehead);\n  nodehead = NULL;\n  if (fclose (tagf) == EOF)\n    pfatal (tagfile);\n\n  if (CTAGS)\n    if (append_to_tagfile || update)\n      {\n\t/* Maybe these should be used:\n\t   setenv (\"LC_COLLATE\", \"C\", 1);\n\t   setenv (\"LC_ALL\", \"C\", 1); */\n\tchar *cmd = xmalloc (8 * strlen (tagfile) + sizeof \"sort -u -o '' ''\");\n#if defined WINDOWSNT || defined MSDOS\n\t/* Quote \"like this\".  No need to escape the quotes in the file name,\n\t   since it is not allowed in file names on these systems.  */\n\tchar *z = stpcpy (cmd, \"sort -u -o \\\"\");\n\tz = stpcpy (z, tagfile);\n\tz = stpcpy (z, \"\\\" \\\"\");\n\tz = stpcpy (z, tagfile);\n\tstpcpy (z, \"\\\"\");\n#else\n\t/* Quote 'like this', and escape the apostrophe in the file name.  */\n\tchar *z = stpcpy (cmd, \"sort -u -o '\");\n\tchar *escaped_tagfile = z;\n\tfor (; *tagfile; *z++ = *tagfile++)\n\t  if (*tagfile == '\\'')\n\t    z = stpcpy (z, \"'\\\\'\");\n\tptrdiff_t escaped_tagfile_len = z - escaped_tagfile;\n\tz = stpcpy (z, \"' '\");\n\tz = mempcpy (z, escaped_tagfile, escaped_tagfile_len);\n\tstrcpy (z, \"'\");\n#endif\n\treturn system (cmd);\n      }\n  return EXIT_SUCCESS;\n}",
        "description": "GNU Emacs versions up to 28.2 are vulnerable to command execution through shell metacharacters in source-code file names. This vulnerability arises due to the use of the system C library function within the implementation of the ctags program in lib-src/etags.c. An attacker can exploit this by using commands like \"ctags *\" in a directory containing files whose names are influenced by untrusted input, leading to unintended command execution.",
        "commit": "The vulnerability knowledge describes the addition of new functions and files within the `lib-src/etags.c` and `test/manual/etags/` directories of a software project. Specifically, the `clean_matched_file_tag` and `do_move_file` functions have been introduced, along with modifications to the `readline_internal` function to include a `leave_cr` parameter that controls whether the `\\r` character should be included. Additionally, new test files (`CTAGS.good_crlf`, `CTAGS.good_update`, and `crlf`) have been added to the `test/manual/etags/` directory, and test cases for `ctags -u` have been incorporated into the `Makefile`."
    },
    {
        "cwe": "CWE-416",
        "func_name": "torvalds/ipt_do_table",
        "score": 0.7607502937316895,
        "func_before": "unsigned int\nipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
        "func_after": "unsigned int\nipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = rcu_access_pointer(table->private);\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
        "description": "An issue was discovered in the netfilter component of the Linux kernel prior to version 5.10. This vulnerability involves a use-after-free condition in the packet processing context due to improper handling of per-CPU sequence counts during concurrent iptables rule replacements. This flaw could be exploited by users with the CAP_NET_ADMIN capability in an unprivileged namespace.",
        "commit": "When performing concurrent iptables rules replacement, the system checks the per-CPU sequence count after assigning new information. This sequence count is intended to synchronize with the packet path without using explicit locking. If packets are currently using the old table information, the sequence count is incremented to an odd value and then to an even value after processing. After assigning the new table information, a write memory barrier is executed to ensure all CPUs see the latest value. If the packet path starts with the old table information, the sequence counter remains odd, and the iptables replacement waits until the sequence count is even before freeing the old table information. However, if the CPU delays executing the new table information assignment and memory barrier, another CPU's packet path may still use the old table information. This delay can lead to a use-after-free error in the packet processing context, resulting in a kernel NULL pointer dereference. To fix this issue, either enforce instruction ordering after the new table information assignment or switch to RCU for synchronization."
    },
    {
        "cwe": "CWE-134",
        "func_name": "wireapp/audio_level_json",
        "score": 0.7438474893569946,
        "func_before": "int audio_level_json(struct list *levell,\n\t\t     const char *userid_self, const char *clientid_self,\n\t\t     char **json_str, char **anon_str)\n{\n\tstruct json_object *jobj;\n\tstruct json_object *jarr;\n\tchar uid_anon[ANON_ID_LEN];\n\tchar cid_anon[ANON_CLIENT_LEN];\n\tstruct mbuf *pmb = NULL;\n\tint err = 0;\n\tstruct le *le;\n\n\tif (!levell || !json_str)\n\t\treturn EINVAL;\n\t\n\tjobj = jzon_alloc_object();\n\tif (!jobj)\n\t\treturn ENOMEM;\n\n\tjarr = jzon_alloc_array();\n\tif (!jarr) {\n\t\terr = ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (anon_str) {\n\t\tpmb = mbuf_alloc(512);\n\t\tmbuf_printf(pmb, \"%zu levels: \", list_count(levell));\n\t}\n\t\n\tLIST_FOREACH(levell, le) {\n\t\tstruct audio_level *a = le->data;\n\t\tstruct json_object *ja;\n\t\tconst char *userid = a->userid;\n\t\tconst char *clientid = a->clientid;\n\n\t\tif (a->is_self) {\n\t\t\tif (userid_self)\n\t\t\t\tuserid = userid_self;\n\t\t\tif (clientid_self)\n\t\t\t\tclientid = clientid_self;\n\t\t}\n\n\t\tja = jzon_alloc_object();\n\t\tif (ja) {\n\t\t\tjzon_add_str(ja, \"userid\", userid);\n\t\t\tjzon_add_str(ja, \"clientid\", clientid);\n\t\t\tjzon_add_int(ja, \"audio_level\",\n\t\t\t\t     (int32_t)a->aulevel_smooth);\n\t\t\tjzon_add_int(ja, \"audio_level_now\",\n\t\t\t\t     (int32_t)a->aulevel);\n\t\t}\n\t\tjson_object_array_add(jarr, ja);\n\n\t\t/* add to info string */\n\t\tif (pmb) {\n\t\t\tanon_id(uid_anon, userid);\n\t\t\tanon_client(cid_anon, clientid);\n\t\t\tmbuf_printf(pmb, \"{[%s.%s] audio_level: %d/%d}\",\n\t\t\t\t    uid_anon, cid_anon,\n\t\t\t\t    a->aulevel_smooth, a->aulevel);\n\t\t\tif (le != levell->tail)\n\t\t\t\tmbuf_printf(pmb, \",\");\n\t\t}\t\t\n\t}\n\tjson_object_object_add(jobj, \"audio_levels\", jarr);\n\n\tif (pmb) {\n\t\tpmb->pos = 0;\n\t\tmbuf_strdup(pmb, anon_str, pmb->end);\n\t\tmem_deref(pmb);\n\t}\n\n\tjzon_encode(json_str, jobj);\n out:\t\n\tmem_deref(jobj);\n\n\treturn err;\n}",
        "func_after": "int audio_level_json(struct list *levell,\n\t\t     const char *userid_self, const char *clientid_self,\n\t\t     char **json_str, char **anon_str)\n{\n\tstruct json_object *jobj;\n\tstruct json_object *jarr;\n\tchar uid_anon[ANON_ID_LEN];\n\tchar cid_anon[ANON_CLIENT_LEN];\n\tstruct mbuf *pmb = NULL;\n\tint err = 0;\n\tstruct le *le;\n\n\tif (!levell || !json_str)\n\t\treturn EINVAL;\n\t\n\tjobj = jzon_alloc_object();\n\tif (!jobj)\n\t\treturn ENOMEM;\n\n\tjarr = jzon_alloc_array();\n\tif (!jarr) {\n\t\terr = ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (anon_str) {\n\t\tpmb = mbuf_alloc(512);\n\t\tmbuf_printf(pmb, \"%zu levels: \", list_count(levell));\n\t}\n\t\n\tLIST_FOREACH(levell, le) {\n\t\tstruct audio_level *a = le->data;\n\t\tstruct json_object *ja;\n\t\tconst char *userid = a->userid;\n\t\tconst char *clientid = a->clientid;\n\n\t\tif (a->is_self) {\n\t\t\tif (userid_self)\n\t\t\t\tuserid = userid_self;\n\t\t\tif (clientid_self)\n\t\t\t\tclientid = clientid_self;\n\t\t}\n\n\t\tja = jzon_alloc_object();\n\t\tif (ja) {\n\t\t\tjzon_add_str(ja, \"userid\", \"%s\", userid);\n\t\t\tjzon_add_str(ja, \"clientid\", \"%s\", clientid);\n\t\t\tjzon_add_int(ja, \"audio_level\",\n\t\t\t\t     (int32_t)a->aulevel_smooth);\n\t\t\tjzon_add_int(ja, \"audio_level_now\",\n\t\t\t\t     (int32_t)a->aulevel);\n\t\t}\n\t\tjson_object_array_add(jarr, ja);\n\n\t\t/* add to info string */\n\t\tif (pmb) {\n\t\t\tanon_id(uid_anon, userid);\n\t\t\tanon_client(cid_anon, clientid);\n\t\t\tmbuf_printf(pmb, \"{[%s.%s] audio_level: %d/%d}\",\n\t\t\t\t    uid_anon, cid_anon,\n\t\t\t\t    a->aulevel_smooth, a->aulevel);\n\t\t\tif (le != levell->tail)\n\t\t\t\tmbuf_printf(pmb, \",\");\n\t\t}\t\t\n\t}\n\tjson_object_object_add(jobj, \"audio_levels\", jarr);\n\n\tif (pmb) {\n\t\tpmb->pos = 0;\n\t\tmbuf_strdup(pmb, anon_str, pmb->end);\n\t\tmem_deref(pmb);\n\t}\n\n\tjzon_encode(json_str, jobj);\n out:\t\n\tmem_deref(jobj);\n\n\treturn err;\n}",
        "description": "A remote format string vulnerability in the wire-avs component of Wire, an open-source messenger, affects versions prior to 7.1.12. This vulnerability could lead to a denial of service or the execution of arbitrary code by an attacker. The issue has been addressed in wire-avs version 7.1.12, and there are currently no known workarounds available.",
        "commit": "The process of importing the latest release-7.1 files from an old repository."
    },
    {
        "cwe": "CWE-426",
        "func_name": "openbsd/main",
        "score": 0.7460842132568359,
        "func_before": "int\nmain(int ac, char **av)\n{\n\tint c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;\n\tint sock, fd, ch, result, saved_errno;\n\tu_int nalloc;\n\tchar *shell, *format, *pidstr, *agentsocket = NULL;\n\tfd_set *readsetp = NULL, *writesetp = NULL;\n\tstruct rlimit rlim;\n\textern int optind;\n\textern char *optarg;\n\tpid_t pid;\n\tchar pidstrbuf[1 + 3 * sizeof pid];\n\tstruct timeval *tvp = NULL;\n\tsize_t len;\n\tmode_t prev_mask;\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\t/* drop */\n\tsetegid(getgid());\n\tsetgid(getgid());\n\n#ifdef WITH_OPENSSL\n\tOpenSSL_add_all_algorithms();\n#endif\n\n\twhile ((ch = getopt(ac, av, \"cDdksE:a:t:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'E':\n\t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n\t\t\tif (fingerprint_hash == -1)\n\t\t\t\tfatal(\"Invalid hash algorithm \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (s_flag)\n\t\t\t\tusage();\n\t\t\tc_flag++;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tk_flag++;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (c_flag)\n\t\t\t\tusage();\n\t\t\ts_flag++;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\td_flag++;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\tD_flag++;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tagentsocket = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif ((lifetime = convtime(optarg)) == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid lifetime\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\tac -= optind;\n\tav += optind;\n\n\tif (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))\n\t\tusage();\n\n\tif (ac == 0 && !c_flag && !s_flag) {\n\t\tshell = getenv(\"SHELL\");\n\t\tif (shell != NULL && (len = strlen(shell)) > 2 &&\n\t\t    strncmp(shell + len - 3, \"csh\", 3) == 0)\n\t\t\tc_flag = 1;\n\t}\n\tif (k_flag) {\n\t\tconst char *errstr = NULL;\n\n\t\tpidstr = getenv(SSH_AGENTPID_ENV_NAME);\n\t\tif (pidstr == NULL) {\n\t\t\tfprintf(stderr, \"%s not set, cannot kill agent\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\texit(1);\n\t\t}\n\t\tpid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);\n\t\tif (errstr) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s=\\\"%s\\\", which is not a good PID: %s\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME, pidstr, errstr);\n\t\t\texit(1);\n\t\t}\n\t\tif (kill(pid, SIGTERM) == -1) {\n\t\t\tperror(\"kill\");\n\t\t\texit(1);\n\t\t}\n\t\tformat = c_flag ? \"unsetenv %s;\\n\" : \"unset %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(format, SSH_AGENTPID_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld killed;\\n\", (long)pid);\n\t\texit(0);\n\t}\n\tparent_pid = getpid();\n\n\tif (agentsocket == NULL) {\n\t\t/* Create private directory for agent socket */\n\t\tmktemp_proto(socket_dir, sizeof(socket_dir));\n\t\tif (mkdtemp(socket_dir) == NULL) {\n\t\t\tperror(\"mkdtemp: private socket dir\");\n\t\t\texit(1);\n\t\t}\n\t\tsnprintf(socket_name, sizeof socket_name, \"%s/agent.%ld\", socket_dir,\n\t\t    (long)parent_pid);\n\t} else {\n\t\t/* Try to use specified agent socket */\n\t\tsocket_dir[0] = '\\0';\n\t\tstrlcpy(socket_name, agentsocket, sizeof socket_name);\n\t}\n\n\t/*\n\t * Create socket early so it will exist before command gets run from\n\t * the parent.\n\t */\n\tprev_mask = umask(0177);\n\tsock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);\n\tif (sock < 0) {\n\t\t/* XXX - unix_listener() calls error() not perror() */\n\t\t*socket_name = '\\0'; /* Don't unlink any existing file */\n\t\tcleanup_exit(1);\n\t}\n\tumask(prev_mask);\n\n\t/*\n\t * Fork, and have the parent execute the command, if any, or present\n\t * the socket data.  The child continues as the authentication agent.\n\t */\n\tif (D_flag || d_flag) {\n\t\tlog_init(__progname,\n\t\t    d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,\n\t\t    SYSLOG_FACILITY_AUTH, 1);\n\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld;\\n\", (long)parent_pid);\n\t\tfflush(stdout);\n\t\tgoto skip;\n\t}\n\tpid = fork();\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\tcleanup_exit(1);\n\t}\n\tif (pid != 0) {\t\t/* Parent - execute the given command. */\n\t\tclose(sock);\n\t\tsnprintf(pidstrbuf, sizeof pidstrbuf, \"%ld\", (long)pid);\n\t\tif (ac == 0) {\n\t\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\t\tprintf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\tprintf(\"echo Agent pid %ld;\\n\", (long)pid);\n\t\t\texit(0);\n\t\t}\n\t\tif (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||\n\t\t    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {\n\t\t\tperror(\"setenv\");\n\t\t\texit(1);\n\t\t}\n\t\texecvp(av[0], av);\n\t\tperror(av[0]);\n\t\texit(1);\n\t}\n\t/* child */\n\tlog_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);\n\n\tif (setsid() == -1) {\n\t\terror(\"setsid: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\n\t(void)chdir(\"/\");\n\tif ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\t/* XXX might close listen socket */\n\t\t(void)dup2(fd, STDIN_FILENO);\n\t\t(void)dup2(fd, STDOUT_FILENO);\n\t\t(void)dup2(fd, STDERR_FILENO);\n\t\tif (fd > 2)\n\t\t\tclose(fd);\n\t}\n\n\t/* deny core dumps, since memory contains unencrypted private keys */\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\tif (setrlimit(RLIMIT_CORE, &rlim) < 0) {\n\t\terror(\"setrlimit RLIMIT_CORE: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\nskip:\n\n\tcleanup_pid = getpid();\n\n#ifdef ENABLE_PKCS11\n\tpkcs11_init(0);\n#endif\n\tnew_socket(AUTH_SOCKET, sock);\n\tif (ac > 0)\n\t\tparent_alive_interval = 10;\n\tidtab_init();\n\tsignal(SIGPIPE, SIG_IGN);\n\tsignal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);\n\tsignal(SIGHUP, cleanup_handler);\n\tsignal(SIGTERM, cleanup_handler);\n\tnalloc = 0;\n\n\tif (pledge(\"stdio cpath unix id proc exec\", NULL) == -1)\n\t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n\n\twhile (1) {\n\t\tprepare_select(&readsetp, &writesetp, &max_fd, &nalloc, &tvp);\n\t\tresult = select(max_fd + 1, readsetp, writesetp, NULL, tvp);\n\t\tsaved_errno = errno;\n\t\tif (parent_alive_interval != 0)\n\t\t\tcheck_parent_exists();\n\t\t(void) reaper();\t/* remove expired keys */\n\t\tif (result < 0) {\n\t\t\tif (saved_errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"select: %s\", strerror(saved_errno));\n\t\t} else if (result > 0)\n\t\t\tafter_select(readsetp, writesetp);\n\t}\n\t/* NOTREACHED */\n}",
        "func_after": "int\nmain(int ac, char **av)\n{\n\tint c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;\n\tint sock, fd, ch, result, saved_errno;\n\tu_int nalloc;\n\tchar *shell, *format, *pidstr, *agentsocket = NULL;\n\tfd_set *readsetp = NULL, *writesetp = NULL;\n\tstruct rlimit rlim;\n\textern int optind;\n\textern char *optarg;\n\tpid_t pid;\n\tchar pidstrbuf[1 + 3 * sizeof pid];\n\tstruct timeval *tvp = NULL;\n\tsize_t len;\n\tmode_t prev_mask;\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\t/* drop */\n\tsetegid(getgid());\n\tsetgid(getgid());\n\n#ifdef WITH_OPENSSL\n\tOpenSSL_add_all_algorithms();\n#endif\n\n\twhile ((ch = getopt(ac, av, \"cDdksE:a:P:t:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'E':\n\t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n\t\t\tif (fingerprint_hash == -1)\n\t\t\t\tfatal(\"Invalid hash algorithm \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (s_flag)\n\t\t\t\tusage();\n\t\t\tc_flag++;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tk_flag++;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (pkcs11_whitelist != NULL)\n\t\t\t\tfatal(\"-P option already specified\");\n\t\t\tpkcs11_whitelist = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (c_flag)\n\t\t\t\tusage();\n\t\t\ts_flag++;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\td_flag++;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\tD_flag++;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tagentsocket = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif ((lifetime = convtime(optarg)) == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid lifetime\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\tac -= optind;\n\tav += optind;\n\n\tif (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))\n\t\tusage();\n\n\tif (pkcs11_whitelist == NULL)\n\t\tpkcs11_whitelist = xstrdup(DEFAULT_PKCS11_WHITELIST);\n\n\tif (ac == 0 && !c_flag && !s_flag) {\n\t\tshell = getenv(\"SHELL\");\n\t\tif (shell != NULL && (len = strlen(shell)) > 2 &&\n\t\t    strncmp(shell + len - 3, \"csh\", 3) == 0)\n\t\t\tc_flag = 1;\n\t}\n\tif (k_flag) {\n\t\tconst char *errstr = NULL;\n\n\t\tpidstr = getenv(SSH_AGENTPID_ENV_NAME);\n\t\tif (pidstr == NULL) {\n\t\t\tfprintf(stderr, \"%s not set, cannot kill agent\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\texit(1);\n\t\t}\n\t\tpid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);\n\t\tif (errstr) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s=\\\"%s\\\", which is not a good PID: %s\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME, pidstr, errstr);\n\t\t\texit(1);\n\t\t}\n\t\tif (kill(pid, SIGTERM) == -1) {\n\t\t\tperror(\"kill\");\n\t\t\texit(1);\n\t\t}\n\t\tformat = c_flag ? \"unsetenv %s;\\n\" : \"unset %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(format, SSH_AGENTPID_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld killed;\\n\", (long)pid);\n\t\texit(0);\n\t}\n\tparent_pid = getpid();\n\n\tif (agentsocket == NULL) {\n\t\t/* Create private directory for agent socket */\n\t\tmktemp_proto(socket_dir, sizeof(socket_dir));\n\t\tif (mkdtemp(socket_dir) == NULL) {\n\t\t\tperror(\"mkdtemp: private socket dir\");\n\t\t\texit(1);\n\t\t}\n\t\tsnprintf(socket_name, sizeof socket_name, \"%s/agent.%ld\", socket_dir,\n\t\t    (long)parent_pid);\n\t} else {\n\t\t/* Try to use specified agent socket */\n\t\tsocket_dir[0] = '\\0';\n\t\tstrlcpy(socket_name, agentsocket, sizeof socket_name);\n\t}\n\n\t/*\n\t * Create socket early so it will exist before command gets run from\n\t * the parent.\n\t */\n\tprev_mask = umask(0177);\n\tsock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);\n\tif (sock < 0) {\n\t\t/* XXX - unix_listener() calls error() not perror() */\n\t\t*socket_name = '\\0'; /* Don't unlink any existing file */\n\t\tcleanup_exit(1);\n\t}\n\tumask(prev_mask);\n\n\t/*\n\t * Fork, and have the parent execute the command, if any, or present\n\t * the socket data.  The child continues as the authentication agent.\n\t */\n\tif (D_flag || d_flag) {\n\t\tlog_init(__progname,\n\t\t    d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,\n\t\t    SYSLOG_FACILITY_AUTH, 1);\n\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld;\\n\", (long)parent_pid);\n\t\tfflush(stdout);\n\t\tgoto skip;\n\t}\n\tpid = fork();\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\tcleanup_exit(1);\n\t}\n\tif (pid != 0) {\t\t/* Parent - execute the given command. */\n\t\tclose(sock);\n\t\tsnprintf(pidstrbuf, sizeof pidstrbuf, \"%ld\", (long)pid);\n\t\tif (ac == 0) {\n\t\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\t\tprintf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\tprintf(\"echo Agent pid %ld;\\n\", (long)pid);\n\t\t\texit(0);\n\t\t}\n\t\tif (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||\n\t\t    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {\n\t\t\tperror(\"setenv\");\n\t\t\texit(1);\n\t\t}\n\t\texecvp(av[0], av);\n\t\tperror(av[0]);\n\t\texit(1);\n\t}\n\t/* child */\n\tlog_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);\n\n\tif (setsid() == -1) {\n\t\terror(\"setsid: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\n\t(void)chdir(\"/\");\n\tif ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\t/* XXX might close listen socket */\n\t\t(void)dup2(fd, STDIN_FILENO);\n\t\t(void)dup2(fd, STDOUT_FILENO);\n\t\t(void)dup2(fd, STDERR_FILENO);\n\t\tif (fd > 2)\n\t\t\tclose(fd);\n\t}\n\n\t/* deny core dumps, since memory contains unencrypted private keys */\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\tif (setrlimit(RLIMIT_CORE, &rlim) < 0) {\n\t\terror(\"setrlimit RLIMIT_CORE: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\nskip:\n\n\tcleanup_pid = getpid();\n\n#ifdef ENABLE_PKCS11\n\tpkcs11_init(0);\n#endif\n\tnew_socket(AUTH_SOCKET, sock);\n\tif (ac > 0)\n\t\tparent_alive_interval = 10;\n\tidtab_init();\n\tsignal(SIGPIPE, SIG_IGN);\n\tsignal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);\n\tsignal(SIGHUP, cleanup_handler);\n\tsignal(SIGTERM, cleanup_handler);\n\tnalloc = 0;\n\n\tif (pledge(\"stdio rpath cpath unix id proc exec\", NULL) == -1)\n\t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n\n\twhile (1) {\n\t\tprepare_select(&readsetp, &writesetp, &max_fd, &nalloc, &tvp);\n\t\tresult = select(max_fd + 1, readsetp, writesetp, NULL, tvp);\n\t\tsaved_errno = errno;\n\t\tif (parent_alive_interval != 0)\n\t\t\tcheck_parent_exists();\n\t\t(void) reaper();\t/* remove expired keys */\n\t\tif (result < 0) {\n\t\t\tif (saved_errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"select: %s\", strerror(saved_errno));\n\t\t} else if (result > 0)\n\t\t\tafter_select(readsetp, writesetp);\n\t}\n\t/* NOTREACHED */\n}",
        "description": "An untrusted search path vulnerability exists in the ssh-agent component of OpenSSH versions prior to 7.4. This flaw enables remote attackers to execute arbitrary local PKCS#11 modules by exploiting control over a forwarded agent-socket.",
        "commit": "The addition of a whitelist mechanism to restrict the paths from which `ssh-agent` can load PKCS#11 modules via `ssh-pkcs11-helper`. This enhancement ensures that only specified paths are permitted, thereby enhancing security by preventing unauthorized access to PKCS#11 modules."
    },
    {
        "cwe": "CWE-77",
        "func_name": "ImageMagick/ReadVIDEOImage",
        "score": 0.7432563900947571,
        "func_before": "static Image *ReadVIDEOImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const DelegateInfo\n    *delegate_info;\n\n  Image\n    *image,\n    *images,\n    *next;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CloseBlob(image);\n  (void) DestroyImageList(image);\n  /*\n    Convert VIDEO to PAM with delegate.\n  */\n  images=(Image *) NULL;\n  read_info=CloneImageInfo(image_info);\n  delegate_info=GetDelegateInfo(\"video:decode\",(char *) NULL,exception);\n  if (delegate_info != (const DelegateInfo *) NULL)\n    {\n      char\n        command[MagickPathExtent],\n        message[MagickPathExtent];\n\n      char\n        *options,\n        *sanitized_option;\n\n      const char\n        *intermediate_format,\n        *option;\n\n      int\n        exit_code;\n\n      options=AcquireString(\"\");\n      if (image_info->number_scenes > 0)\n        (void) FormatLocaleString(options,MagickPathExtent,\"-vframes %i\",\n          (int) image_info->number_scenes);\n      option=GetImageOption(image_info,\"video:vsync\");\n      if (option != (const char *) NULL)\n        {\n          sanitized_option=SanitizeDelegateString(option);\n          (void) FormatLocaleString(command,MagickPathExtent,\" -vsync %s\",\n            sanitized_option);\n          DestroyString(sanitized_option);\n          (void) ConcatenateMagickString(options,command,MagickPathExtent);\n        }\n      option=GetImageOption(image_info,\"video:pixel-format\");\n      if (option != (const char *) NULL)\n        {\n          sanitized_option=SanitizeDelegateString(option);\n          (void) FormatLocaleString(command,MagickPathExtent,\" -pix_fmt %s\",\n            sanitized_option);\n          DestroyString(sanitized_option);\n          (void) ConcatenateMagickString(options,command,MagickPathExtent);\n        }\n      else\n        if (LocaleNCompare(image_info->magick,\"APNG\",MagickPathExtent) == 0)\n          (void) ConcatenateMagickString(options,\" -pix_fmt rgba\",\n            MagickPathExtent);\n      intermediate_format=GetIntermediateFormat(image_info);\n      (void) FormatLocaleString(command,MagickPathExtent,\" -vcodec %s\",\n        intermediate_format);\n      (void) ConcatenateMagickString(options,command,MagickPathExtent);\n      AcquireUniqueFilename(read_info->unique);\n      (void) AcquireUniqueSymbolicLink(image_info->filename,\n        read_info->filename);\n      (void) FormatLocaleString(command,MagickPathExtent,\n        GetDelegateCommands(delegate_info),read_info->filename,options,\n        read_info->unique);\n      options=DestroyString(options);\n      (void) CopyMagickString(read_info->magick,intermediate_format,\n        MagickPathExtent);\n      (void) CopyMagickString(read_info->filename,read_info->unique,\n        MagickPathExtent);\n      exit_code=ExternalDelegateCommand(MagickFalse,image_info->verbose,\n        command,message,exception);\n      if (exit_code == 0)\n        images=ReadImage(read_info,exception);\n      else\n        if (*message != '\\0')\n          (void) ThrowMagickException(exception,GetMagickModule(),DelegateError,\n            \"VideoDelegateFailed\",\"`%s'\",message);\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      (void) RelinquishUniqueFileResource(read_info->unique);\n      if (images != (Image *) NULL)\n        for (next=images; next != (Image *) NULL; next=next->next)\n        {\n          (void) CopyMagickString(next->filename,image_info->filename,\n            MagickPathExtent);\n          (void) CopyMagickString(next->magick,image_info->magick,\n            MagickPathExtent);\n        }\n    }\n  read_info=DestroyImageInfo(read_info);\n  return(images);\n}",
        "func_after": "static Image *ReadVIDEOImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const DelegateInfo\n    *delegate_info;\n\n  Image\n    *image,\n    *images,\n    *next;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CloseBlob(image);\n  (void) DestroyImageList(image);\n  /*\n    Convert VIDEO to PAM with delegate.\n  */\n  images=(Image *) NULL;\n  read_info=CloneImageInfo(image_info);\n  delegate_info=GetDelegateInfo(\"video:decode\",(char *) NULL,exception);\n  if (delegate_info != (const DelegateInfo *) NULL)\n    {\n      char\n        command[MagickPathExtent],\n        message[MagickPathExtent];\n\n      char\n        *options;\n\n      const char\n        *intermediate_format,\n        *option;\n\n      int\n        exit_code;\n\n      options=AcquireString(\"\");\n      if (image_info->number_scenes > 0)\n        (void) FormatLocaleString(options,MagickPathExtent,\"-vframes %i\",\n          (int) image_info->number_scenes);\n      option=GetImageOption(image_info,\"video:vsync\");\n      if (option != (const char *) NULL)\n        {\n          FormatSanitizedDelegateOption(command,MagickPathExtent,\n            \" -vsync \\\"%s\\\"\",\" -vsync '%s'\",option);\n          (void) ConcatenateMagickString(options,command,MagickPathExtent);\n        }\n      option=GetImageOption(image_info,\"video:pixel-format\");\n      if (option != (const char *) NULL)\n        {\n          FormatSanitizedDelegateOption(command,MagickPathExtent,\n            \" -pix_fmt \\\"%s\\\"\",\" -pix_fmt '%s'\",option);\n          (void) ConcatenateMagickString(options,command,MagickPathExtent);\n        }\n      else\n        if (LocaleNCompare(image_info->magick,\"APNG\",MagickPathExtent) == 0)\n          (void) ConcatenateMagickString(options,\" -pix_fmt rgba\",\n            MagickPathExtent);\n      intermediate_format=GetIntermediateFormat(image_info);\n      (void) FormatLocaleString(command,MagickPathExtent,\" -vcodec %s\",\n        intermediate_format);\n      (void) ConcatenateMagickString(options,command,MagickPathExtent);\n      AcquireUniqueFilename(read_info->unique);\n      (void) AcquireUniqueSymbolicLink(image_info->filename,\n        read_info->filename);\n      (void) FormatLocaleString(command,MagickPathExtent,\n        GetDelegateCommands(delegate_info),read_info->filename,options,\n        read_info->unique);\n      options=DestroyString(options);\n      (void) CopyMagickString(read_info->magick,intermediate_format,\n        MagickPathExtent);\n      (void) CopyMagickString(read_info->filename,read_info->unique,\n        MagickPathExtent);\n      exit_code=ExternalDelegateCommand(MagickFalse,image_info->verbose,\n        command,message,exception);\n      if (exit_code == 0)\n        images=ReadImage(read_info,exception);\n      else\n        if (*message != '\\0')\n          (void) ThrowMagickException(exception,GetMagickModule(),DelegateError,\n            \"VideoDelegateFailed\",\"`%s'\",message);\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      (void) RelinquishUniqueFileResource(read_info->unique);\n      if (images != (Image *) NULL)\n        for (next=images; next != (Image *) NULL; next=next->next)\n        {\n          (void) CopyMagickString(next->filename,image_info->filename,\n            MagickPathExtent);\n          (void) CopyMagickString(next->magick,image_info->magick,\n            MagickPathExtent);\n        }\n    }\n  read_info=DestroyImageInfo(read_info);\n  return(images);\n}",
        "description": "A vulnerability was identified in ImageMagick that leads to a shell command injection through the use of specific options in video encoding/decoding processes.",
        "commit": "Ensure that options are correctly quoted to address the issue identified in ticket #6338."
    }
]