[
    {
        "cwe": "CWE-787",
        "func_name": "OP-TEE/syscall_obj_generate_key",
        "score": 0.7738968133926392,
        "func_before": "TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that maxKeySize follows restrictions */\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tparams = malloc(sizeof(TEE_Attribute) * param_count);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * We have to do it like this because the parity bits aren't\n\t\t * counted when telling the size of the key in bits.\n\t\t */\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}",
        "func_after": "TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that maxKeySize follows restrictions */\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * We have to do it like this because the parity bits aren't\n\t\t * counted when telling the size of the key in bits.\n\t\t */\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}",
        "description": "Linaro/OP-TEE versions 3.3.0 and earlier are vulnerable to a buffer overflow, which could lead to the execution of arbitrary code within the Trusted Execution Environment (TEE) core (kernel) context. This issue affects the optee_os component. The vulnerability has been addressed in versions 3.4.0 and later.",
        "commit": "It was discovered that there is a risk of heap-based overflow due to insufficient checking for allocation overflow in cryptographic function calls. Without verifying the allocation size, there is a possibility of allocating a buffer that is smaller than expected, which could result in attacker-controlled data being written beyond the buffer's boundaries."
    },
    {
        "cwe": "CWE-407",
        "func_name": "reddit/find_link_ref",
        "score": 0.7240618467330933,
        "func_before": "static struct link_ref *\nfind_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n{\n\tunsigned int hash = hash_link_ref(name, length);\n\tstruct link_ref *ref = NULL;\n\n\tref = references[hash % REF_TABLE_SIZE];\n\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash)\n\t\t\treturn ref;\n\n\t\tref = ref->next;\n\t}\n\n\treturn NULL;\n}",
        "func_after": "static struct link_ref *\nfind_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n{\n\tunsigned int hash = hash_link_ref(name, length);\n\tstruct link_ref *ref = NULL;\n\n\tref = references[hash % REF_TABLE_SIZE];\n\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash && ref->label->size == length) {\n\t\t\tif (strncasecmp((char *)ref->label->data, (char *) name, length) == 0) {\n\t\t\t\treturn ref;\n\t\t\t}\n\t\t}\n\n\t\tref = ref->next;\n\t}\n\n\treturn NULL;\n}",
        "description": "Snudown, a Reddit-specific fork of the Sundown Markdown parser with Python integration, was found to be vulnerable to denial of service (DoS) attacks due to weaknesses in its reference table implementation. Specifically, the hash function used for inserting references into a hash table was weak, allowing attackers to generate a large number of collisions. Additionally, the hash table permitted duplicate entries, leading to prolonged retrieval times. These issues collectively make the system susceptible to hash-collision DoS attacks, a form of algorithmic complexity attack. Users are advised to update to version 1.7.0 to mitigate these vulnerabilities.",
        "commit": "A vulnerability related to hash collisions has been identified and addressed by implementing a case-insensitive SipHash function to replace the existing reference hash function. Additionally, changes were made to the `link_ref` structure to include a label, and updates were applied to the `find_link_ref` and `add_link_ref` functions to ensure they compare link labels as well as hashes and disallow duplicate entries, respectively. A cast was added to convert from `uint8_t` to `char` for use with `strncasecmp`. The README markdown was updated to remove TODO items, and support for generating Python 2 wheels was added. Furthermore, logic was included to handle older versions of glibc that do not have the `getrandom` function, impacting the staging environment."
    },
    {
        "cwe": "CWE-125",
        "func_name": "torvalds/do_split",
        "score": 0.7715775370597839,
        "func_before": "static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}",
        "func_after": "static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Ensure that neither split block is over half full */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/*\n\t * map index at which we will split\n\t *\n\t * If the sum of active entries didn't exceed half the block size, just\n\t * split it in half by count; each resulting block will have at least\n\t * half the space free.\n\t */\n\tif (i > 0)\n\t\tsplit = count - move;\n\telse\n\t\tsplit = count/2;\n\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}",
        "description": "A memory out-of-bounds read flaw was identified in the Linux kernel prior to version 5.9-rc2, specifically within the ext3/ext4 file system. This flaw occurs when accessing a directory with broken indexing, potentially allowing a local user to crash the system if such a directory exists. The primary risk associated with this vulnerability is a decrease in system availability.",
        "commit": "If a directory passed to the `do_split()` function lacks sufficient active entries to surpass half the block size, it may result in iterating through all \"count\" entries without identifying a split point. In such cases, where `count` equals `move` and `split` becomes zero, an attempt to access a negative index in the `map[]` array could occur. To prevent this, detect this scenario and fall back to splitting at half of the count, ensuring that each split block still has ample space greater than half the block size."
    },
    {
        "cwe": "CWE-190",
        "func_name": "torvalds/ring_buffer_resize",
        "score": 0.7746632695198059,
        "func_before": "int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size,\n\t\t\tint cpu_id)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long nr_pages;\n\tint cpu, err = 0;\n\n\t/*\n\t * Always succeed at resizing a non-existent buffer:\n\t */\n\tif (!buffer)\n\t\treturn size;\n\n\t/* Make sure the requested buffer exists */\n\tif (cpu_id != RING_BUFFER_ALL_CPUS &&\n\t    !cpumask_test_cpu(cpu_id, buffer->cpumask))\n\t\treturn size;\n\n\tsize = DIV_ROUND_UP(size, BUF_PAGE_SIZE);\n\tsize *= BUF_PAGE_SIZE;\n\n\t/* we need a minimum of two pages */\n\tif (size < BUF_PAGE_SIZE * 2)\n\t\tsize = BUF_PAGE_SIZE * 2;\n\n\tnr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);\n\n\t/*\n\t * Don't succeed if resizing is disabled, as a reader might be\n\t * manipulating the ring buffer and is expecting a sane state while\n\t * this is true.\n\t */\n\tif (atomic_read(&buffer->resize_disabled))\n\t\treturn -EBUSY;\n\n\t/* prevent another thread from changing buffer sizes */\n\tmutex_lock(&buffer->mutex);\n\n\tif (cpu_id == RING_BUFFER_ALL_CPUS) {\n\t\t/* calculate the pages to update */\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\n\t\t\tcpu_buffer->nr_pages_to_update = nr_pages -\n\t\t\t\t\t\t\tcpu_buffer->nr_pages;\n\t\t\t/*\n\t\t\t * nothing more to do for removing pages or no update\n\t\t\t */\n\t\t\tif (cpu_buffer->nr_pages_to_update <= 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * to add pages, make sure all new pages can be\n\t\t\t * allocated without receiving ENOMEM\n\t\t\t */\n\t\t\tINIT_LIST_HEAD(&cpu_buffer->new_pages);\n\t\t\tif (__rb_allocate_pages(cpu_buffer->nr_pages_to_update,\n\t\t\t\t\t\t&cpu_buffer->new_pages, cpu)) {\n\t\t\t\t/* not enough memory for new pages */\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\n\t\tget_online_cpus();\n\t\t/*\n\t\t * Fire off all the required work handlers\n\t\t * We can't schedule on offline CPUs, but it's not necessary\n\t\t * since we can change their buffer sizes without any race.\n\t\t */\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\t\t\tif (!cpu_buffer->nr_pages_to_update)\n\t\t\t\tcontinue;\n\n\t\t\t/* Can't run something on an offline CPU. */\n\t\t\tif (!cpu_online(cpu)) {\n\t\t\t\trb_update_pages(cpu_buffer);\n\t\t\t\tcpu_buffer->nr_pages_to_update = 0;\n\t\t\t} else {\n\t\t\t\tschedule_work_on(cpu,\n\t\t\t\t\t\t&cpu_buffer->update_pages_work);\n\t\t\t}\n\t\t}\n\n\t\t/* wait for all the updates to complete */\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\t\t\tif (!cpu_buffer->nr_pages_to_update)\n\t\t\t\tcontinue;\n\n\t\t\tif (cpu_online(cpu))\n\t\t\t\twait_for_completion(&cpu_buffer->update_done);\n\t\t\tcpu_buffer->nr_pages_to_update = 0;\n\t\t}\n\n\t\tput_online_cpus();\n\t} else {\n\t\t/* Make sure this CPU has been intitialized */\n\t\tif (!cpumask_test_cpu(cpu_id, buffer->cpumask))\n\t\t\tgoto out;\n\n\t\tcpu_buffer = buffer->buffers[cpu_id];\n\n\t\tif (nr_pages == cpu_buffer->nr_pages)\n\t\t\tgoto out;\n\n\t\tcpu_buffer->nr_pages_to_update = nr_pages -\n\t\t\t\t\t\tcpu_buffer->nr_pages;\n\n\t\tINIT_LIST_HEAD(&cpu_buffer->new_pages);\n\t\tif (cpu_buffer->nr_pages_to_update > 0 &&\n\t\t\t__rb_allocate_pages(cpu_buffer->nr_pages_to_update,\n\t\t\t\t\t    &cpu_buffer->new_pages, cpu_id)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tget_online_cpus();\n\n\t\t/* Can't run something on an offline CPU. */\n\t\tif (!cpu_online(cpu_id))\n\t\t\trb_update_pages(cpu_buffer);\n\t\telse {\n\t\t\tschedule_work_on(cpu_id,\n\t\t\t\t\t &cpu_buffer->update_pages_work);\n\t\t\twait_for_completion(&cpu_buffer->update_done);\n\t\t}\n\n\t\tcpu_buffer->nr_pages_to_update = 0;\n\t\tput_online_cpus();\n\t}\n\n out:\n\t/*\n\t * The ring buffer resize can happen with the ring buffer\n\t * enabled, so that the update disturbs the tracing as little\n\t * as possible. But if the buffer is disabled, we do not need\n\t * to worry about that, and we can take the time to verify\n\t * that the buffer is not corrupt.\n\t */\n\tif (atomic_read(&buffer->record_disabled)) {\n\t\tatomic_inc(&buffer->record_disabled);\n\t\t/*\n\t\t * Even though the buffer was disabled, we must make sure\n\t\t * that it is truly disabled before calling rb_check_pages.\n\t\t * There could have been a race between checking\n\t\t * record_disable and incrementing it.\n\t\t */\n\t\tsynchronize_sched();\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\t\t\trb_check_pages(cpu_buffer);\n\t\t}\n\t\tatomic_dec(&buffer->record_disabled);\n\t}\n\n\tmutex_unlock(&buffer->mutex);\n\treturn size;\n\n out_err:\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tstruct buffer_page *bpage, *tmp;\n\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\tcpu_buffer->nr_pages_to_update = 0;\n\n\t\tif (list_empty(&cpu_buffer->new_pages))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry_safe(bpage, tmp, &cpu_buffer->new_pages,\n\t\t\t\t\tlist) {\n\t\t\tlist_del_init(&bpage->list);\n\t\t\tfree_buffer_page(bpage);\n\t\t}\n\t}\n\tmutex_unlock(&buffer->mutex);\n\treturn err;\n}",
        "func_after": "int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size,\n\t\t\tint cpu_id)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long nr_pages;\n\tint cpu, err = 0;\n\n\t/*\n\t * Always succeed at resizing a non-existent buffer:\n\t */\n\tif (!buffer)\n\t\treturn size;\n\n\t/* Make sure the requested buffer exists */\n\tif (cpu_id != RING_BUFFER_ALL_CPUS &&\n\t    !cpumask_test_cpu(cpu_id, buffer->cpumask))\n\t\treturn size;\n\n\tnr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);\n\n\t/* we need a minimum of two pages */\n\tif (nr_pages < 2)\n\t\tnr_pages = 2;\n\n\tsize = nr_pages * BUF_PAGE_SIZE;\n\n\t/*\n\t * Don't succeed if resizing is disabled, as a reader might be\n\t * manipulating the ring buffer and is expecting a sane state while\n\t * this is true.\n\t */\n\tif (atomic_read(&buffer->resize_disabled))\n\t\treturn -EBUSY;\n\n\t/* prevent another thread from changing buffer sizes */\n\tmutex_lock(&buffer->mutex);\n\n\tif (cpu_id == RING_BUFFER_ALL_CPUS) {\n\t\t/* calculate the pages to update */\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\n\t\t\tcpu_buffer->nr_pages_to_update = nr_pages -\n\t\t\t\t\t\t\tcpu_buffer->nr_pages;\n\t\t\t/*\n\t\t\t * nothing more to do for removing pages or no update\n\t\t\t */\n\t\t\tif (cpu_buffer->nr_pages_to_update <= 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * to add pages, make sure all new pages can be\n\t\t\t * allocated without receiving ENOMEM\n\t\t\t */\n\t\t\tINIT_LIST_HEAD(&cpu_buffer->new_pages);\n\t\t\tif (__rb_allocate_pages(cpu_buffer->nr_pages_to_update,\n\t\t\t\t\t\t&cpu_buffer->new_pages, cpu)) {\n\t\t\t\t/* not enough memory for new pages */\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\n\t\tget_online_cpus();\n\t\t/*\n\t\t * Fire off all the required work handlers\n\t\t * We can't schedule on offline CPUs, but it's not necessary\n\t\t * since we can change their buffer sizes without any race.\n\t\t */\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\t\t\tif (!cpu_buffer->nr_pages_to_update)\n\t\t\t\tcontinue;\n\n\t\t\t/* Can't run something on an offline CPU. */\n\t\t\tif (!cpu_online(cpu)) {\n\t\t\t\trb_update_pages(cpu_buffer);\n\t\t\t\tcpu_buffer->nr_pages_to_update = 0;\n\t\t\t} else {\n\t\t\t\tschedule_work_on(cpu,\n\t\t\t\t\t\t&cpu_buffer->update_pages_work);\n\t\t\t}\n\t\t}\n\n\t\t/* wait for all the updates to complete */\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\t\t\tif (!cpu_buffer->nr_pages_to_update)\n\t\t\t\tcontinue;\n\n\t\t\tif (cpu_online(cpu))\n\t\t\t\twait_for_completion(&cpu_buffer->update_done);\n\t\t\tcpu_buffer->nr_pages_to_update = 0;\n\t\t}\n\n\t\tput_online_cpus();\n\t} else {\n\t\t/* Make sure this CPU has been intitialized */\n\t\tif (!cpumask_test_cpu(cpu_id, buffer->cpumask))\n\t\t\tgoto out;\n\n\t\tcpu_buffer = buffer->buffers[cpu_id];\n\n\t\tif (nr_pages == cpu_buffer->nr_pages)\n\t\t\tgoto out;\n\n\t\tcpu_buffer->nr_pages_to_update = nr_pages -\n\t\t\t\t\t\tcpu_buffer->nr_pages;\n\n\t\tINIT_LIST_HEAD(&cpu_buffer->new_pages);\n\t\tif (cpu_buffer->nr_pages_to_update > 0 &&\n\t\t\t__rb_allocate_pages(cpu_buffer->nr_pages_to_update,\n\t\t\t\t\t    &cpu_buffer->new_pages, cpu_id)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tget_online_cpus();\n\n\t\t/* Can't run something on an offline CPU. */\n\t\tif (!cpu_online(cpu_id))\n\t\t\trb_update_pages(cpu_buffer);\n\t\telse {\n\t\t\tschedule_work_on(cpu_id,\n\t\t\t\t\t &cpu_buffer->update_pages_work);\n\t\t\twait_for_completion(&cpu_buffer->update_done);\n\t\t}\n\n\t\tcpu_buffer->nr_pages_to_update = 0;\n\t\tput_online_cpus();\n\t}\n\n out:\n\t/*\n\t * The ring buffer resize can happen with the ring buffer\n\t * enabled, so that the update disturbs the tracing as little\n\t * as possible. But if the buffer is disabled, we do not need\n\t * to worry about that, and we can take the time to verify\n\t * that the buffer is not corrupt.\n\t */\n\tif (atomic_read(&buffer->record_disabled)) {\n\t\tatomic_inc(&buffer->record_disabled);\n\t\t/*\n\t\t * Even though the buffer was disabled, we must make sure\n\t\t * that it is truly disabled before calling rb_check_pages.\n\t\t * There could have been a race between checking\n\t\t * record_disable and incrementing it.\n\t\t */\n\t\tsynchronize_sched();\n\t\tfor_each_buffer_cpu(buffer, cpu) {\n\t\t\tcpu_buffer = buffer->buffers[cpu];\n\t\t\trb_check_pages(cpu_buffer);\n\t\t}\n\t\tatomic_dec(&buffer->record_disabled);\n\t}\n\n\tmutex_unlock(&buffer->mutex);\n\treturn size;\n\n out_err:\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tstruct buffer_page *bpage, *tmp;\n\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\tcpu_buffer->nr_pages_to_update = 0;\n\n\t\tif (list_empty(&cpu_buffer->new_pages))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry_safe(bpage, tmp, &cpu_buffer->new_pages,\n\t\t\t\t\tlist) {\n\t\t\tlist_del_init(&bpage->list);\n\t\t\tfree_buffer_page(bpage);\n\t\t}\n\t}\n\tmutex_unlock(&buffer->mutex);\n\treturn err;\n}",
        "description": "The `ring_buffer_resize` function in the profiling subsystem of the Linux kernel, prior to version 4.6.1, mishandles specific integer calculations. This flaw enables local users to escalate their privileges by writing to the `/sys/kernel/debug/tracing/buffer_size_kb` file.",
        "commit": "A vulnerability was identified in the ring buffer resizing functionality within the Linux kernel. Specifically, if the size passed to the `ring_buffer_resize()` function exceeds `MAX_LONG - BUF_PAGE_SIZE`, the `DIV_ROUND_UP()` operation will incorrectly return zero. This occurs because the intermediate calculation during the resizing process leads to an overflow, resulting in an incorrect number of buffer pages being allocated. Consequently, the logic fails, potentially causing a kernel crash. To address this issue, the redundant use of `DIV_ROUND_UP()` should be cleaned up, ensuring proper handling of large sizes and preventing overflow."
    },
    {
        "cwe": "CWE-415",
        "func_name": "binutils-gdb/get_num_dynamic_syms",
        "score": 0.7596882581710815,
        "func_before": "static unsigned long\nget_num_dynamic_syms (Filedata * filedata)\n{\n  unsigned long num_of_syms = 0;\n\n  if (!do_histogram && (!do_using_dynamic || do_dyn_syms))\n    return num_of_syms;\n\n  if (dynamic_info[DT_HASH])\n    {\n      unsigned char nb[8];\n      unsigned char nc[8];\n      unsigned int hash_ent_size = 4;\n\n      if ((filedata->file_header.e_machine == EM_ALPHA\n\t   || filedata->file_header.e_machine == EM_S390\n\t   || filedata->file_header.e_machine == EM_S390_OLD)\n\t  && filedata->file_header.e_ident[EI_CLASS] == ELFCLASS64)\n\thash_ent_size = 8;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, dynamic_info[DT_HASH],\n\t\t\t\t     sizeof nb + sizeof nc)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  goto no_hash;\n\t}\n\n      if (fread (nb, hash_ent_size, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of buckets\\n\"));\n\t  goto no_hash;\n\t}\n\n      if (fread (nc, hash_ent_size, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of chains\\n\"));\n\t  goto no_hash;\n\t}\n\n      nbuckets = byte_get (nb, hash_ent_size);\n      nchains = byte_get (nc, hash_ent_size);\n      num_of_syms = nchains;\n\n      buckets = get_dynamic_data (filedata, nbuckets, hash_ent_size);\n      chains  = get_dynamic_data (filedata, nchains, hash_ent_size);\n\n  no_hash:\n      if (num_of_syms == 0)\n\t{\n\t  if (buckets)\n\t    {\n\t      free (buckets);\n\t      buckets = NULL;\n\t    }\n\t  if (chains)\n\t    {\n\t      free (chains);\n\t      buckets = NULL;\n\t    }\n\t  nbuckets = 0;\n\t}\n    }\n\n  if (dynamic_info_DT_GNU_HASH)\n    {\n      unsigned char nb[16];\n      bfd_vma i, maxchain = 0xffffffff, bitmaskwords;\n      bfd_vma buckets_vma;\n      unsigned long hn;\n      bfd_boolean gnu_hash_error = FALSE;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, dynamic_info_DT_GNU_HASH,\n\t\t\t\t     sizeof nb)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      if (fread (nb, 16, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of buckets\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      ngnubuckets = byte_get (nb, 4);\n      gnusymidx = byte_get (nb + 4, 4);\n      bitmaskwords = byte_get (nb + 8, 4);\n      buckets_vma = dynamic_info_DT_GNU_HASH + 16;\n      if (is_32bit_elf)\n\tbuckets_vma += bitmaskwords * 4;\n      else\n\tbuckets_vma += bitmaskwords * 8;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma, 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      gnubuckets = get_dynamic_data (filedata, ngnubuckets, 4);\n\n      if (gnubuckets == NULL)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      for (i = 0; i < ngnubuckets; i++)\n\tif (gnubuckets[i] != 0)\n\t  {\n\t    if (gnubuckets[i] < gnusymidx)\n\t      {\n\t\tgnu_hash_error = TRUE;\n\t\treturn FALSE;\n\t      }\n\n\t    if (maxchain == 0xffffffff || gnubuckets[i] > maxchain)\n\t      maxchain = gnubuckets[i];\n\t  }\n\n      if (maxchain == 0xffffffff)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      maxchain -= gnusymidx;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma\n\t\t\t\t\t   + 4 * (ngnubuckets + maxchain), 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      do\n\t{\n\t  if (fread (nb, 4, 1, filedata->handle) != 1)\n\t    {\n\t      error (_(\"Failed to determine last chain length\\n\"));\n\t  gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  if (maxchain + 1 == 0)\n\t    {\n\t      gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  ++maxchain;\n\t}\n      while ((byte_get (nb, 4) & 1) == 0);\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma + 4 * ngnubuckets, 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      gnuchains = get_dynamic_data (filedata, maxchain, 4);\n      ngnuchains = maxchain;\n\n      if (gnuchains == NULL)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      if (dynamic_info_DT_MIPS_XHASH)\n\t{\n\t  if (fseek (filedata->handle,\n\t\t     (archive_file_offset\n\t\t      + offset_from_vma (filedata, (buckets_vma\n\t\t\t\t\t\t    + 4 * (ngnubuckets\n\t\t\t\t\t\t\t   + maxchain)), 4)),\n\t\t     SEEK_SET))\n\t    {\n\t      error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t      gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  mipsxlat = get_dynamic_data (filedata, maxchain, 4);\n\t}\n\n      for (hn = 0; hn < ngnubuckets; ++hn)\n\tif (gnubuckets[hn] != 0)\n\t  {\n\t    bfd_vma si = gnubuckets[hn];\n\t    bfd_vma off = si - gnusymidx;\n\n\t    do\n\t      {\n\t\tif (dynamic_info_DT_MIPS_XHASH)\n\t\t  {\n\t\t    if (mipsxlat[off] >= num_of_syms)\n\t\t      num_of_syms = mipsxlat[off] + 1;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    if (si >= num_of_syms)\n\t\t      num_of_syms = si + 1;\n\t\t  }\n\t\tsi++;\n\t      }\n\t    while (off < ngnuchains && (gnuchains[off++] & 1) == 0);\n\t  }\n\n  no_gnu_hash:\n      if (gnu_hash_error)\n\t{\n\t  if (mipsxlat)\n\t    {\n\t      free (mipsxlat);\n\t      mipsxlat = NULL;\n\t    }\n\t  if (gnuchains)\n\t    {\n\t      free (gnuchains);\n\t      gnuchains = NULL;\n\t    }\n\t  if (gnubuckets)\n\t    {\n\t      free (gnubuckets);\n\t      gnubuckets = NULL;\n\t    }\n\t  ngnubuckets = 0;\n\t  ngnuchains = 0;\n\t}\n    }\n\n  return num_of_syms;\n}",
        "func_after": "static unsigned long\nget_num_dynamic_syms (Filedata * filedata)\n{\n  unsigned long num_of_syms = 0;\n\n  if (!do_histogram && (!do_using_dynamic || do_dyn_syms))\n    return num_of_syms;\n\n  if (dynamic_info[DT_HASH])\n    {\n      unsigned char nb[8];\n      unsigned char nc[8];\n      unsigned int hash_ent_size = 4;\n\n      if ((filedata->file_header.e_machine == EM_ALPHA\n\t   || filedata->file_header.e_machine == EM_S390\n\t   || filedata->file_header.e_machine == EM_S390_OLD)\n\t  && filedata->file_header.e_ident[EI_CLASS] == ELFCLASS64)\n\thash_ent_size = 8;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, dynamic_info[DT_HASH],\n\t\t\t\t     sizeof nb + sizeof nc)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  goto no_hash;\n\t}\n\n      if (fread (nb, hash_ent_size, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of buckets\\n\"));\n\t  goto no_hash;\n\t}\n\n      if (fread (nc, hash_ent_size, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of chains\\n\"));\n\t  goto no_hash;\n\t}\n\n      nbuckets = byte_get (nb, hash_ent_size);\n      nchains = byte_get (nc, hash_ent_size);\n      num_of_syms = nchains;\n\n      buckets = get_dynamic_data (filedata, nbuckets, hash_ent_size);\n      chains  = get_dynamic_data (filedata, nchains, hash_ent_size);\n\n  no_hash:\n      if (num_of_syms == 0)\n\t{\n\t  if (buckets)\n\t    {\n\t      free (buckets);\n\t      buckets = NULL;\n\t    }\n\t  if (chains)\n\t    {\n\t      free (chains);\n\t      chains = NULL;\n\t    }\n\t  nbuckets = 0;\n\t}\n    }\n\n  if (dynamic_info_DT_GNU_HASH)\n    {\n      unsigned char nb[16];\n      bfd_vma i, maxchain = 0xffffffff, bitmaskwords;\n      bfd_vma buckets_vma;\n      unsigned long hn;\n      bfd_boolean gnu_hash_error = FALSE;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, dynamic_info_DT_GNU_HASH,\n\t\t\t\t     sizeof nb)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      if (fread (nb, 16, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of buckets\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      ngnubuckets = byte_get (nb, 4);\n      gnusymidx = byte_get (nb + 4, 4);\n      bitmaskwords = byte_get (nb + 8, 4);\n      buckets_vma = dynamic_info_DT_GNU_HASH + 16;\n      if (is_32bit_elf)\n\tbuckets_vma += bitmaskwords * 4;\n      else\n\tbuckets_vma += bitmaskwords * 8;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma, 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      gnubuckets = get_dynamic_data (filedata, ngnubuckets, 4);\n\n      if (gnubuckets == NULL)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      for (i = 0; i < ngnubuckets; i++)\n\tif (gnubuckets[i] != 0)\n\t  {\n\t    if (gnubuckets[i] < gnusymidx)\n\t      {\n\t\tgnu_hash_error = TRUE;\n\t\treturn FALSE;\n\t      }\n\n\t    if (maxchain == 0xffffffff || gnubuckets[i] > maxchain)\n\t      maxchain = gnubuckets[i];\n\t  }\n\n      if (maxchain == 0xffffffff)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      maxchain -= gnusymidx;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma\n\t\t\t\t\t   + 4 * (ngnubuckets + maxchain), 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      do\n\t{\n\t  if (fread (nb, 4, 1, filedata->handle) != 1)\n\t    {\n\t      error (_(\"Failed to determine last chain length\\n\"));\n\t  gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  if (maxchain + 1 == 0)\n\t    {\n\t      gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  ++maxchain;\n\t}\n      while ((byte_get (nb, 4) & 1) == 0);\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma + 4 * ngnubuckets, 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      gnuchains = get_dynamic_data (filedata, maxchain, 4);\n      ngnuchains = maxchain;\n\n      if (gnuchains == NULL)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      if (dynamic_info_DT_MIPS_XHASH)\n\t{\n\t  if (fseek (filedata->handle,\n\t\t     (archive_file_offset\n\t\t      + offset_from_vma (filedata, (buckets_vma\n\t\t\t\t\t\t    + 4 * (ngnubuckets\n\t\t\t\t\t\t\t   + maxchain)), 4)),\n\t\t     SEEK_SET))\n\t    {\n\t      error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t      gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  mipsxlat = get_dynamic_data (filedata, maxchain, 4);\n\t}\n\n      for (hn = 0; hn < ngnubuckets; ++hn)\n\tif (gnubuckets[hn] != 0)\n\t  {\n\t    bfd_vma si = gnubuckets[hn];\n\t    bfd_vma off = si - gnusymidx;\n\n\t    do\n\t      {\n\t\tif (dynamic_info_DT_MIPS_XHASH)\n\t\t  {\n\t\t    if (mipsxlat[off] >= num_of_syms)\n\t\t      num_of_syms = mipsxlat[off] + 1;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    if (si >= num_of_syms)\n\t\t      num_of_syms = si + 1;\n\t\t  }\n\t\tsi++;\n\t      }\n\t    while (off < ngnuchains && (gnuchains[off++] & 1) == 0);\n\t  }\n\n  no_gnu_hash:\n      if (gnu_hash_error)\n\t{\n\t  if (mipsxlat)\n\t    {\n\t      free (mipsxlat);\n\t      mipsxlat = NULL;\n\t    }\n\t  if (gnuchains)\n\t    {\n\t      free (gnuchains);\n\t      gnuchains = NULL;\n\t    }\n\t  if (gnubuckets)\n\t    {\n\t      free (gnubuckets);\n\t      gnubuckets = NULL;\n\t    }\n\t  ngnubuckets = 0;\n\t  ngnuchains = 0;\n\t}\n    }\n\n  return num_of_syms;\n}",
        "description": "A double free vulnerability exists in the Binary File Descriptor (BFD), also known as libbfd, within GNU Binutils 2.35 during the processing of symbol tables, specifically as exhibited in the readelf utility through the manipulation of a specially crafted file.",
        "commit": "The vulnerability knowledge has been abstracted and generalized as follows:\n\n\"A typo fix was made in the `readelf` tool to consolidate the functionality of the `--syms` and `--use-dynamic` options with the `--dyn-syms` option.\""
    }
]