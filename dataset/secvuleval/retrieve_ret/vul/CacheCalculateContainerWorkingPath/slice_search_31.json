[
    {
        "cwe": "CWE-119",
        "func_name": "torvalds/hugetlb_mcopy_atomic_pte",
        "score": 0.7275238037109375,
        "func_before": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tstruct address_space *mapping = dst_vma->vm_file->f_mapping;\n\t\tpgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
        "func_after": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\tunsigned long size;\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\tmapping = dst_vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\t\tret = -EFAULT;\n\t\tif (idx >= size)\n\t\t\tgoto out_release_nounlock;\n\n\t\t/*\n\t\t * Serialization between remove_inode_hugepages() and\n\t\t * huge_add_to_page_cache() below happens through the\n\t\t * hugetlb_fault_mutex_table that here must be hold by\n\t\t * the caller.\n\t\t */\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\t/*\n\t * Recheck the i_size after holding PT lock to make sure not\n\t * to leave any page mapped (as page_mapped()) beyond the end\n\t * of the i_size (remove_inode_hugepages() is strict about\n\t * enforcing that). If we bail out here, we'll also leave a\n\t * page in the radix tree in the vm_shared case beyond the end\n\t * of the i_size, but remove_inode_hugepages() will take care\n\t * of it as soon as we drop the hugetlb_fault_mutex_table.\n\t */\n\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\tret = -EFAULT;\n\tif (idx >= size)\n\t\tgoto out_release_unlock;\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
        "description": "A flaw was identified in the hugetlb_mcopy_atomic_pte function within the Linux kernel's memory management module, affecting versions prior to 4.13.12. The absence of a proper size check in this function could lead to a denial of service condition, indicated by a BUG.",
        "commit": "A vulnerability was identified in the userfaultfd functionality related to hugetlbfs, where the UFFDIO_COPY operation could inadvertently extend beyond the intended size of the file (i_size). This issue led to a kernel panic (oops) at fs/hugetlbfs/inode.c:484, triggered by the absence of an i_size check in the hugetlb_mcopy_atomic_pte function. Although mmap() operations could succeed beyond the end of the i_size after vmtruncate had removed virtual memory areas (vmas) in those ranges, subsequent faults, including UFFDIO_COPY, should not be allowed to succeed. The proposed solution involves modifying the return value to userland to indicate a SIGBUS-like condition, similar to what a page fault would produce, but this approach was deemed less useful due to the difficulty in distinguishing between SIGSEGV and SIGBUS through meaningful syscall return values."
    },
    {
        "cwe": "CWE-787",
        "func_name": "OP-TEE/syscall_obj_generate_key",
        "score": 0.7306135296821594,
        "func_before": "TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that maxKeySize follows restrictions */\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tparams = malloc(sizeof(TEE_Attribute) * param_count);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * We have to do it like this because the parity bits aren't\n\t\t * counted when telling the size of the key in bits.\n\t\t */\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}",
        "func_after": "TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that maxKeySize follows restrictions */\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * We have to do it like this because the parity bits aren't\n\t\t * counted when telling the size of the key in bits.\n\t\t */\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}",
        "description": "Linaro/OP-TEE versions 3.3.0 and earlier are vulnerable to a buffer overflow, which could lead to the execution of arbitrary code within the Trusted Execution Environment (TEE) core (kernel) context. This issue affects the optee_os component. The vulnerability has been addressed in versions 3.4.0 and later.",
        "commit": "It was discovered that there is a risk of heap-based overflow due to insufficient checking for allocation overflow in cryptographic function calls. Without verifying the allocation size, there is a possibility of allocating a buffer that is smaller than expected, which could result in attacker-controlled data being written beyond the buffer's boundaries."
    },
    {
        "cwe": "CWE-254",
        "func_name": "android/impeg2d_dec_d_slice",
        "score": 0.7128497362136841,
        "func_before": "IMPEG2D_ERROR_CODES_T impeg2d_dec_d_slice(dec_state_t *ps_dec)\n{\n    UWORD32 i;\n    yuv_buf_t *ps_cur_frm_buf  = &ps_dec->s_cur_frm_buf;\n\n    stream_t   *ps_stream       = &ps_dec->s_bit_stream;\n    UWORD8   *pu1_vld_buf;\n\n    WORD16 i2_dc_diff;\n    UWORD32 u4_frame_width = ps_dec->u2_frame_width;\n    UWORD32 u4_frm_offset = 0;\n    if(ps_dec->u2_picture_structure != FRAME_PICTURE)\n    {\n        u4_frame_width <<= 1;\n        if(ps_dec->u2_picture_structure == BOTTOM_FIELD)\n        {\n            u4_frm_offset = ps_dec->u2_frame_width;\n        }\n    }\n\n    do\n    {\n\n        UWORD32 u4_x_offset, u4_y_offset;\n        UWORD32 u4_blk_pos;\n        WORD16 i2_dc_val;\n\n        UWORD32 u4_dst_x_offset     = u4_frm_offset + (ps_dec->u2_mb_x << 4);\n        UWORD32 u4_dst_y_offset     = (ps_dec->u2_mb_y << 4) * u4_frame_width;\n        UWORD8 *pu1_vld_buf8        = ps_cur_frm_buf->pu1_y + u4_dst_x_offset + u4_dst_y_offset;\n        UWORD32 u4_dst_wd           = u4_frame_width;\n        /*------------------------------------------------------------------*/\n        /* Discard the Macroblock stuffing in case of MPEG-1 stream         */\n        /*------------------------------------------------------------------*/\n        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)\n            impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n\n        /*------------------------------------------------------------------*/\n        /* Flush 2 bits from bitstream [MB_Type and MacroBlockAddrIncrement]*/\n        /*------------------------------------------------------------------*/\n        impeg2d_bit_stream_flush(ps_stream,1);\n\n        if(impeg2d_bit_stream_get(ps_stream, 1) != 0x01)\n        {\n            /* Ignore and continue decoding. */\n        }\n\n        /* Process LUMA blocks of the MB */\n        for(i = 0; i < NUM_LUMA_BLKS; ++i)\n        {\n\n            u4_x_offset    = gai2_impeg2_blk_x_off[i];\n            u4_y_offset    = gai2_impeg2_blk_y_off_frm[i] ;\n            u4_blk_pos     = (u4_y_offset * u4_dst_wd) + u4_x_offset;\n            pu1_vld_buf     = pu1_vld_buf8 + u4_blk_pos;\n\n            i2_dc_diff = impeg2d_get_luma_dc_diff(ps_stream);\n            i2_dc_val = ps_dec->u2_def_dc_pred[Y_LUMA] + i2_dc_diff;\n            ps_dec->u2_def_dc_pred[Y_LUMA] = i2_dc_val;\n            i2_dc_val = CLIP_U8(i2_dc_val);\n\n            ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n        }\n\n\n\n        /* Process U block of the MB */\n\n        u4_dst_x_offset                >>= 1;\n        u4_dst_y_offset                >>= 2;\n        u4_dst_wd                      >>= 1;\n        pu1_vld_buf                     = ps_cur_frm_buf->pu1_u + u4_dst_x_offset + u4_dst_y_offset;\n        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);\n        i2_dc_val                      = ps_dec->u2_def_dc_pred[U_CHROMA] + i2_dc_diff;\n        ps_dec->u2_def_dc_pred[U_CHROMA]    = i2_dc_val;\n        i2_dc_val = CLIP_U8(i2_dc_val);\n        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n\n\n        /* Process V block of the MB */\n\n        pu1_vld_buf                     = ps_cur_frm_buf->pu1_v + u4_dst_x_offset + u4_dst_y_offset;\n        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);\n        i2_dc_val                      = ps_dec->u2_def_dc_pred[V_CHROMA] + i2_dc_diff;\n        ps_dec->u2_def_dc_pred[V_CHROMA]    = i2_dc_val;\n        i2_dc_val = CLIP_U8(i2_dc_val);\n        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n\n        /* Common MB processing Steps */\n\n\n        ps_dec->u2_num_mbs_left--;\n        ps_dec->u2_mb_x++;\n\n        if(ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset)\n        {\n            return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;\n        }\n        else if (ps_dec->u2_mb_x == ps_dec->u2_num_horiz_mb)\n        {\n            ps_dec->u2_mb_x = 0;\n            ps_dec->u2_mb_y++;\n\n        }\n\n        /* Flush end of macro block */\n        impeg2d_bit_stream_flush(ps_stream,1);\n    }\n    while(ps_dec->u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,23) != 0x0);\n    return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}",
        "func_after": "IMPEG2D_ERROR_CODES_T impeg2d_dec_d_slice(dec_state_t *ps_dec)\n{\n    UWORD32 i;\n    yuv_buf_t *ps_cur_frm_buf  = &ps_dec->s_cur_frm_buf;\n\n    stream_t   *ps_stream       = &ps_dec->s_bit_stream;\n    UWORD8   *pu1_vld_buf;\n\n    WORD16 i2_dc_diff;\n    UWORD32 u4_frame_width = ps_dec->u2_frame_width;\n    UWORD32 u4_frm_offset = 0;\n    if(ps_dec->u2_picture_structure != FRAME_PICTURE)\n    {\n        u4_frame_width <<= 1;\n        if(ps_dec->u2_picture_structure == BOTTOM_FIELD)\n        {\n            u4_frm_offset = ps_dec->u2_frame_width;\n        }\n    }\n\n    do\n    {\n\n        UWORD32 u4_x_offset, u4_y_offset;\n        UWORD32 u4_blk_pos;\n        WORD16 i2_dc_val;\n\n        UWORD32 u4_dst_x_offset     = u4_frm_offset + (ps_dec->u2_mb_x << 4);\n        UWORD32 u4_dst_y_offset     = (ps_dec->u2_mb_y << 4) * u4_frame_width;\n        UWORD8 *pu1_vld_buf8        = ps_cur_frm_buf->pu1_y + u4_dst_x_offset + u4_dst_y_offset;\n        UWORD32 u4_dst_wd           = u4_frame_width;\n        /*------------------------------------------------------------------*/\n        /* Discard the Macroblock stuffing in case of MPEG-1 stream         */\n        /*------------------------------------------------------------------*/\n        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&\n                ps_stream->u4_offset < ps_stream->u4_max_offset)\n            impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n\n        /*------------------------------------------------------------------*/\n        /* Flush 2 bits from bitstream [MB_Type and MacroBlockAddrIncrement]*/\n        /*------------------------------------------------------------------*/\n        impeg2d_bit_stream_flush(ps_stream,1);\n\n        if(impeg2d_bit_stream_get(ps_stream, 1) != 0x01)\n        {\n            /* Ignore and continue decoding. */\n        }\n\n        /* Process LUMA blocks of the MB */\n        for(i = 0; i < NUM_LUMA_BLKS; ++i)\n        {\n\n            u4_x_offset    = gai2_impeg2_blk_x_off[i];\n            u4_y_offset    = gai2_impeg2_blk_y_off_frm[i] ;\n            u4_blk_pos     = (u4_y_offset * u4_dst_wd) + u4_x_offset;\n            pu1_vld_buf     = pu1_vld_buf8 + u4_blk_pos;\n\n            i2_dc_diff = impeg2d_get_luma_dc_diff(ps_stream);\n            i2_dc_val = ps_dec->u2_def_dc_pred[Y_LUMA] + i2_dc_diff;\n            ps_dec->u2_def_dc_pred[Y_LUMA] = i2_dc_val;\n            i2_dc_val = CLIP_U8(i2_dc_val);\n\n            ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n        }\n\n\n\n        /* Process U block of the MB */\n\n        u4_dst_x_offset                >>= 1;\n        u4_dst_y_offset                >>= 2;\n        u4_dst_wd                      >>= 1;\n        pu1_vld_buf                     = ps_cur_frm_buf->pu1_u + u4_dst_x_offset + u4_dst_y_offset;\n        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);\n        i2_dc_val                      = ps_dec->u2_def_dc_pred[U_CHROMA] + i2_dc_diff;\n        ps_dec->u2_def_dc_pred[U_CHROMA]    = i2_dc_val;\n        i2_dc_val = CLIP_U8(i2_dc_val);\n        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n\n\n        /* Process V block of the MB */\n\n        pu1_vld_buf                     = ps_cur_frm_buf->pu1_v + u4_dst_x_offset + u4_dst_y_offset;\n        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);\n        i2_dc_val                      = ps_dec->u2_def_dc_pred[V_CHROMA] + i2_dc_diff;\n        ps_dec->u2_def_dc_pred[V_CHROMA]    = i2_dc_val;\n        i2_dc_val = CLIP_U8(i2_dc_val);\n        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n\n        /* Common MB processing Steps */\n\n\n        ps_dec->u2_num_mbs_left--;\n        ps_dec->u2_mb_x++;\n\n        if(ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset)\n        {\n            return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;\n        }\n        else if (ps_dec->u2_mb_x == ps_dec->u2_num_horiz_mb)\n        {\n            ps_dec->u2_mb_x = 0;\n            ps_dec->u2_mb_y++;\n\n        }\n\n        /* Flush end of macro block */\n        impeg2d_bit_stream_flush(ps_stream,1);\n    }\n    while(ps_dec->u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,23) != 0x0);\n    return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}",
        "description": "libstagefright in Android versions prior to March 1, 2016, contains a vulnerability that allows attackers to gain unauthorized access to sensitive information by manipulating Bitstream data. This flaw enables attackers to potentially bypass an unspecified security mechanism, such as Signature or SignatureOrSystem access, through crafted input.",
        "commit": "Fixed bit stream access to ensure that reads do not exceed the allocated size."
    },
    {
        "cwe": "CWE-200",
        "func_name": "torvalds/xfs_iget_cache_miss",
        "score": 0.7301304936408997,
        "func_before": "static int\nxfs_iget_cache_miss(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_trans_t\t\t*tp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_inode\t**ipp,\n\txfs_daddr_t\t\tbno,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\tunsigned long\t\tfirst_index, mask;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ino);\n\n\tip = xfs_inode_alloc(mp, ino);\n\tif (!ip)\n\t\treturn ENOMEM;\n\n\terror = xfs_iread(mp, tp, ip, bno, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\txfs_itrace_entry(ip);\n\n\tif ((ip->i_d.di_mode == 0) && !(flags & XFS_IGET_CREATE)) {\n\t\terror = ENOENT;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Preload the radix tree so we can insert safely under the\n\t * write spinlock. Note that we cannot sleep inside the preload\n\t * region.\n\t */\n\tif (radix_tree_preload(GFP_KERNEL)) {\n\t\terror = EAGAIN;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Because the inode hasn't been added to the radix-tree yet it can't\n\t * be found by another thread, so we can do the non-sleeping lock here.\n\t */\n\tif (lock_flags) {\n\t\tif (!xfs_ilock_nowait(ip, lock_flags))\n\t\t\tBUG();\n\t}\n\n\tmask = ~(((XFS_INODE_CLUSTER_SIZE(mp) >> mp->m_sb.sb_inodelog)) - 1);\n\tfirst_index = agino & mask;\n\twrite_lock(&pag->pag_ici_lock);\n\n\t/* insert the new inode */\n\terror = radix_tree_insert(&pag->pag_ici_root, agino, ip);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\t\tXFS_STATS_INC(xs_ig_dup);\n\t\terror = EAGAIN;\n\t\tgoto out_preload_end;\n\t}\n\n\t/* These values _must_ be set before releasing the radix tree lock! */\n\tip->i_udquot = ip->i_gdquot = NULL;\n\txfs_iflags_set(ip, XFS_INEW);\n\n\twrite_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\n\ttrace_xfs_iget_alloc(ip);\n\t*ipp = ip;\n\treturn 0;\n\nout_preload_end:\n\twrite_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\nout_destroy:\n\t__destroy_inode(VFS_I(ip));\n\txfs_inode_free(ip);\n\treturn error;\n}",
        "func_after": "static int\nxfs_iget_cache_miss(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_trans_t\t\t*tp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_inode\t**ipp,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\tunsigned long\t\tfirst_index, mask;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ino);\n\n\tip = xfs_inode_alloc(mp, ino);\n\tif (!ip)\n\t\treturn ENOMEM;\n\n\terror = xfs_iread(mp, tp, ip, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\txfs_itrace_entry(ip);\n\n\tif ((ip->i_d.di_mode == 0) && !(flags & XFS_IGET_CREATE)) {\n\t\terror = ENOENT;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Preload the radix tree so we can insert safely under the\n\t * write spinlock. Note that we cannot sleep inside the preload\n\t * region.\n\t */\n\tif (radix_tree_preload(GFP_KERNEL)) {\n\t\terror = EAGAIN;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Because the inode hasn't been added to the radix-tree yet it can't\n\t * be found by another thread, so we can do the non-sleeping lock here.\n\t */\n\tif (lock_flags) {\n\t\tif (!xfs_ilock_nowait(ip, lock_flags))\n\t\t\tBUG();\n\t}\n\n\tmask = ~(((XFS_INODE_CLUSTER_SIZE(mp) >> mp->m_sb.sb_inodelog)) - 1);\n\tfirst_index = agino & mask;\n\twrite_lock(&pag->pag_ici_lock);\n\n\t/* insert the new inode */\n\terror = radix_tree_insert(&pag->pag_ici_root, agino, ip);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\t\tXFS_STATS_INC(xs_ig_dup);\n\t\terror = EAGAIN;\n\t\tgoto out_preload_end;\n\t}\n\n\t/* These values _must_ be set before releasing the radix tree lock! */\n\tip->i_udquot = ip->i_gdquot = NULL;\n\txfs_iflags_set(ip, XFS_INEW);\n\n\twrite_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\n\ttrace_xfs_iget_alloc(ip);\n\t*ipp = ip;\n\treturn 0;\n\nout_preload_end:\n\twrite_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\nout_destroy:\n\t__destroy_inode(VFS_I(ip));\n\txfs_inode_free(ip);\n\treturn error;\n}",
        "description": "The XFS implementation in the Linux kernel prior to version 2.6.35 fails to check inode allocation btrees before reading inode buffers. This oversight enables remote authenticated users to access unlinked files or modify disk blocks that were previously associated with unlinked files but are now linked to active files through stale NFS filehandles.",
        "commit": "The vulnerability involves using block numbers obtained from bulkstat-based inode lookups to optimize mapping calculations. However, since bulkstat data cannot be trusted, the block numbers should be discarded to ensure accurate and reliable lookups and mappings."
    },
    {
        "cwe": "CWE-264",
        "func_name": "newlib-cygwin/lsaauth",
        "score": 0.7232112288475037,
        "func_before": "HANDLE\nlsaauth (cygsid &usersid, user_groups &new_groups)\n{\n  cygsidlist tmp_gsids (cygsidlist_auto, 12);\n  cygpsid pgrpsid;\n  LSA_STRING name;\n  HANDLE lsa_hdl = NULL, lsa = NULL;\n  LSA_OPERATIONAL_MODE sec_mode;\n  NTSTATUS status, sub_status;\n  ULONG package_id, size;\n  LUID auth_luid = SYSTEM_LUID;\n  struct {\n    LSA_STRING str;\n    CHAR buf[16];\n  } origin;\n  DWORD ulen = UNLEN + 1;\n  DWORD dlen = MAX_DOMAIN_NAME_LEN + 1;\n  SID_NAME_USE use;\n  cyglsa_t *authinf = NULL;\n  ULONG authinf_size;\n  TOKEN_SOURCE ts;\n  PCYG_TOKEN_GROUPS gsids = NULL;\n  PTOKEN_PRIVILEGES privs = NULL;\n  PACL dacl = NULL;\n  PVOID profile = NULL;\n  LUID luid;\n  QUOTA_LIMITS quota;\n  size_t psize = 0, gsize = 0, dsize = 0;\n  OFFSET offset, sids_offset;\n  int tmpidx, non_well_known_cnt;\n\n  HANDLE user_token = NULL;\n\n  push_self_privilege (SE_TCB_PRIVILEGE, true);\n\n  /* Register as logon process. */\n  RtlInitAnsiString (&name, \"Cygwin\");\n  SetLastError (0);\n  status = LsaRegisterLogonProcess (&name, &lsa_hdl, &sec_mode);\n  if (status != STATUS_SUCCESS)\n    {\n      debug_printf (\"LsaRegisterLogonProcess: %y\", status);\n      __seterrno_from_nt_status (status);\n      goto out;\n    }\n  else if (GetLastError () == ERROR_PROC_NOT_FOUND)\n    {\n      debug_printf (\"Couldn't load Secur32.dll\");\n      goto out;\n    }\n  /* Get handle to our own LSA package. */\n  RtlInitAnsiString (&name, CYG_LSA_PKGNAME);\n  status = LsaLookupAuthenticationPackage (lsa_hdl, &name, &package_id);\n  if (status != STATUS_SUCCESS)\n    {\n      debug_printf (\"LsaLookupAuthenticationPackage: %y\", status);\n      __seterrno_from_nt_status (status);\n      goto out;\n    }\n\n  /* Open policy object. */\n  if (!(lsa = lsa_open_policy (NULL, POLICY_EXECUTE)))\n    goto out;\n\n  /* Create origin. */\n  stpcpy (origin.buf, \"Cygwin\");\n  RtlInitAnsiString (&origin.str, origin.buf);\n  /* Create token source. */\n  memcpy (ts.SourceName, \"Cygwin.1\", 8);\n  ts.SourceIdentifier.HighPart = 0;\n  ts.SourceIdentifier.LowPart = 0x0103;\n\n  /* Create list of groups, the user is member in. */\n  int auth_pos;\n  if (new_groups.issetgroups ())\n    get_setgroups_sidlist (tmp_gsids, usersid, NULL, new_groups, auth_luid,\n\t\t\t   auth_pos);\n  else if (!get_initgroups_sidlist (tmp_gsids, usersid, new_groups.pgsid,\n\t\t\t\t    NULL, auth_luid, auth_pos))\n    goto out;\n\n  tmp_gsids.debug_print (\"tmp_gsids\");\n\n  /* Evaluate size of TOKEN_GROUPS list */\n  non_well_known_cnt =  tmp_gsids.non_well_known_count ();\n  gsize = sizeof (DWORD) + non_well_known_cnt * sizeof (SID_AND_ATTRIBUTES);\n  tmpidx = -1;\n  for (int i = 0; i < non_well_known_cnt; ++i)\n    if ((tmpidx = tmp_gsids.next_non_well_known_sid (tmpidx)) >= 0)\n      gsize += RtlLengthSid (tmp_gsids.sids[tmpidx]);\n\n  /* Retrieve list of privileges of that user.  The MIC SID is created by\n     the LSA here. */\n  if (!(privs = get_priv_list (lsa, usersid, tmp_gsids, psize, NULL)))\n    goto out;\n\n  /* Create DefaultDacl. */\n  dsize = sizeof (ACL) + 3 * sizeof (ACCESS_ALLOWED_ACE)\n\t  + RtlLengthSid (usersid)\n\t  + RtlLengthSid (well_known_admins_sid)\n\t  + RtlLengthSid (well_known_system_sid);\n  dacl = (PACL) alloca (dsize);\n  if (!NT_SUCCESS (RtlCreateAcl (dacl, dsize, ACL_REVISION)))\n    goto out;\n  if (!NT_SUCCESS (RtlAddAccessAllowedAce (dacl, ACL_REVISION, GENERIC_ALL,\n\t\t\t\t\t   usersid)))\n    goto out;\n  if (!NT_SUCCESS (RtlAddAccessAllowedAce (dacl, ACL_REVISION, GENERIC_ALL,\n\t\t\t\t\t   well_known_admins_sid)))\n    goto out;\n  if (!NT_SUCCESS (RtlAddAccessAllowedAce (dacl, ACL_REVISION, GENERIC_ALL,\n\t\t\t\t\t   well_known_system_sid)))\n    goto out;\n\n  /* Evaluate authinf size and allocate authinf. */\n  authinf_size = (authinf->data - (PBYTE) authinf);\n  authinf_size += RtlLengthSid (usersid);\t    /* User SID */\n  authinf_size += gsize;\t\t\t    /* Groups + Group SIDs */\n  /* When trying to define the admins group as primary group on Vista,\n     LsaLogonUser fails with error STATUS_INVALID_OWNER.  As workaround\n     we define \"Local\" as primary group here.  Seteuid32 sets the primary\n     group to the group set in /etc/passwd anyway. */\n  if (new_groups.pgsid == well_known_admins_sid)\n    pgrpsid = well_known_local_sid;\n  else\n    pgrpsid = new_groups.pgsid;\n\n  authinf_size += RtlLengthSid (pgrpsid);\t    /* Primary Group SID */\n\n  authinf_size += psize;\t\t\t    /* Privileges */\n  authinf_size += 0;\t\t\t\t    /* Owner SID */\n  authinf_size += dsize;\t\t\t    /* Default DACL */\n\n  authinf = (cyglsa_t *) alloca (authinf_size);\n  authinf->inf_size = authinf_size - ((PBYTE) &authinf->inf - (PBYTE) authinf);\n\n  authinf->magic = CYG_LSA_MAGIC;\n\n  if (!LookupAccountSidW (NULL, usersid, authinf->username, &ulen,\n\t\t\t  authinf->domain, &dlen, &use))\n    {\n      __seterrno ();\n      goto out;\n    }\n\n  /* Store stuff in authinf with offset relative to start of \"inf\" member,\n     instead of using pointers. */\n  offset = authinf->data - (PBYTE) &authinf->inf;\n\n  authinf->inf.ExpirationTime.LowPart = 0xffffffffL;\n  authinf->inf.ExpirationTime.HighPart = 0x7fffffffL;\n  /* User SID */\n  authinf->inf.User.User.Sid = offset;\n  authinf->inf.User.User.Attributes = 0;\n  RtlCopySid (RtlLengthSid (usersid), (PSID) ((PBYTE) &authinf->inf + offset),\n\t      usersid);\n  offset += RtlLengthSid (usersid);\n  /* Groups */\n  authinf->inf.Groups = offset;\n  gsids = (PCYG_TOKEN_GROUPS) ((PBYTE) &authinf->inf + offset);\n  sids_offset = offset + sizeof (ULONG) + non_well_known_cnt\n\t\t\t\t\t  * sizeof (SID_AND_ATTRIBUTES);\n  gsids->GroupCount = non_well_known_cnt;\n  /* Group SIDs */\n  tmpidx = -1;\n  for (int i = 0; i < non_well_known_cnt; ++i)\n    {\n      if ((tmpidx = tmp_gsids.next_non_well_known_sid (tmpidx)) < 0)\n\tbreak;\n      gsids->Groups[i].Sid = sids_offset;\n      gsids->Groups[i].Attributes = SE_GROUP_MANDATORY\n\t\t\t\t    | SE_GROUP_ENABLED_BY_DEFAULT\n\t\t\t\t    | SE_GROUP_ENABLED;\n      RtlCopySid (RtlLengthSid (tmp_gsids.sids[tmpidx]),\n\t\t  (PSID) ((PBYTE) &authinf->inf + sids_offset),\n\t\t  tmp_gsids.sids[tmpidx]);\n      sids_offset += RtlLengthSid (tmp_gsids.sids[tmpidx]);\n    }\n  offset += gsize;\n  /* Primary Group SID */\n  authinf->inf.PrimaryGroup.PrimaryGroup = offset;\n  RtlCopySid (RtlLengthSid (pgrpsid), (PSID) ((PBYTE) &authinf->inf + offset),\n\t      pgrpsid);\n  offset += RtlLengthSid (pgrpsid);\n  /* Privileges */\n  authinf->inf.Privileges = offset;\n  memcpy ((PBYTE) &authinf->inf + offset, privs, psize);\n  offset += psize;\n  /* Owner */\n  authinf->inf.Owner.Owner = 0;\n  /* Default DACL */\n  authinf->inf.DefaultDacl.DefaultDacl = offset;\n  memcpy ((PBYTE) &authinf->inf + offset, dacl, dsize);\n\n  authinf->checksum = CYG_LSA_MAGIC;\n  PDWORD csp;\n  PDWORD csp_end;\n  csp = (PDWORD) &authinf->username;\n  csp_end = (PDWORD) ((PBYTE) authinf + authinf_size);\n  while (csp < csp_end)\n    authinf->checksum += *csp++;\n\n  /* Try to logon... */\n  status = LsaLogonUser (lsa_hdl, (PLSA_STRING) &origin, Interactive,\n\t\t\t package_id, authinf, authinf_size, NULL, &ts,\n\t\t\t &profile, &size, &luid, &user_token, &quota,\n\t\t\t &sub_status);\n  if (status != STATUS_SUCCESS)\n    {\n      debug_printf (\"LsaLogonUser: %y (sub-status %y)\", status, sub_status);\n      __seterrno_from_nt_status (status);\n      goto out;\n    }\n  if (profile)\n    {\n#ifdef JUST_ANOTHER_NONWORKING_SOLUTION\n      /* See ../lsaauth/cyglsa.c. */\n      cygprf_t *prf = (cygprf_t *) profile;\n      if (prf->magic_pre == MAGIC_PRE && prf->magic_post == MAGIC_POST\n\t  && prf->token)\n\t{\n\t  CloseHandle (user_token);\n\t  user_token = prf->token;\n\t  system_printf (\"Got token through profile: %p\", user_token);\n\t}\n#endif /* JUST_ANOTHER_NONWORKING_SOLUTION */\n      LsaFreeReturnBuffer (profile);\n    }\n  user_token = get_full_privileged_inheritable_token (user_token);\n\nout:\n  if (privs)\n    free (privs);\n  lsa_close_policy (lsa);\n  if (lsa_hdl)\n    LsaDeregisterLogonProcess (lsa_hdl);\n  pop_self_privilege ();\n\n  debug_printf (\"%p = lsaauth ()\", user_token);\n  return user_token;\n}",
        "func_after": "HANDLE\nlsaauth (cygsid &usersid, user_groups &new_groups)\n{\n  cygsidlist tmp_gsids (cygsidlist_auto, 12);\n  cygpsid pgrpsid;\n  LSA_STRING name;\n  HANDLE lsa_hdl = NULL, lsa = NULL;\n  LSA_OPERATIONAL_MODE sec_mode;\n  NTSTATUS status, sub_status;\n  ULONG package_id, size;\n  struct {\n    LSA_STRING str;\n    CHAR buf[16];\n  } origin;\n  DWORD ulen = UNLEN + 1;\n  DWORD dlen = MAX_DOMAIN_NAME_LEN + 1;\n  SID_NAME_USE use;\n  cyglsa_t *authinf = NULL;\n  ULONG authinf_size;\n  TOKEN_SOURCE ts;\n  PCYG_TOKEN_GROUPS gsids = NULL;\n  PTOKEN_PRIVILEGES privs = NULL;\n  PACL dacl = NULL;\n  PVOID profile = NULL;\n  LUID luid;\n  QUOTA_LIMITS quota;\n  size_t psize = 0, gsize = 0, dsize = 0;\n  OFFSET offset, sids_offset;\n  int tmpidx, non_well_known_cnt;\n\n  HANDLE user_token = NULL;\n\n  push_self_privilege (SE_TCB_PRIVILEGE, true);\n\n  /* Register as logon process. */\n  RtlInitAnsiString (&name, \"Cygwin\");\n  SetLastError (0);\n  status = LsaRegisterLogonProcess (&name, &lsa_hdl, &sec_mode);\n  if (status != STATUS_SUCCESS)\n    {\n      debug_printf (\"LsaRegisterLogonProcess: %y\", status);\n      __seterrno_from_nt_status (status);\n      goto out;\n    }\n  else if (GetLastError () == ERROR_PROC_NOT_FOUND)\n    {\n      debug_printf (\"Couldn't load Secur32.dll\");\n      goto out;\n    }\n  /* Get handle to our own LSA package. */\n  RtlInitAnsiString (&name, CYG_LSA_PKGNAME);\n  status = LsaLookupAuthenticationPackage (lsa_hdl, &name, &package_id);\n  if (status != STATUS_SUCCESS)\n    {\n      debug_printf (\"LsaLookupAuthenticationPackage: %y\", status);\n      __seterrno_from_nt_status (status);\n      goto out;\n    }\n\n  /* Open policy object. */\n  if (!(lsa = lsa_open_policy (NULL, POLICY_EXECUTE)))\n    goto out;\n\n  /* Create origin. */\n  stpcpy (origin.buf, \"Cygwin\");\n  RtlInitAnsiString (&origin.str, origin.buf);\n  /* Create token source. */\n  memcpy (ts.SourceName, \"Cygwin.1\", 8);\n  ts.SourceIdentifier.HighPart = 0;\n  ts.SourceIdentifier.LowPart = 0x0103;\n\n  /* Create list of groups, the user is member in. */\n  if (new_groups.issetgroups ())\n    get_setgroups_sidlist (tmp_gsids, usersid, NULL, new_groups);\n  else if (!get_initgroups_sidlist (tmp_gsids, usersid, new_groups.pgsid,\n\t\t\t\t    NULL))\n    goto out;\n\n  tmp_gsids.debug_print (\"tmp_gsids\");\n\n  /* Evaluate size of TOKEN_GROUPS list */\n  non_well_known_cnt =  tmp_gsids.non_well_known_count ();\n  gsize = sizeof (DWORD) + non_well_known_cnt * sizeof (SID_AND_ATTRIBUTES);\n  tmpidx = -1;\n  for (int i = 0; i < non_well_known_cnt; ++i)\n    if ((tmpidx = tmp_gsids.next_non_well_known_sid (tmpidx)) >= 0)\n      gsize += RtlLengthSid (tmp_gsids.sids[tmpidx]);\n\n  /* Retrieve list of privileges of that user.  The MIC SID is created by\n     the LSA here. */\n  if (!(privs = get_priv_list (lsa, usersid, tmp_gsids, psize, NULL)))\n    goto out;\n\n  /* Create DefaultDacl. */\n  dsize = sizeof (ACL) + 3 * sizeof (ACCESS_ALLOWED_ACE)\n\t  + RtlLengthSid (usersid)\n\t  + RtlLengthSid (well_known_admins_sid)\n\t  + RtlLengthSid (well_known_system_sid);\n  dacl = (PACL) alloca (dsize);\n  if (!NT_SUCCESS (RtlCreateAcl (dacl, dsize, ACL_REVISION)))\n    goto out;\n  if (!NT_SUCCESS (RtlAddAccessAllowedAce (dacl, ACL_REVISION, GENERIC_ALL,\n\t\t\t\t\t   usersid)))\n    goto out;\n  if (!NT_SUCCESS (RtlAddAccessAllowedAce (dacl, ACL_REVISION, GENERIC_ALL,\n\t\t\t\t\t   well_known_admins_sid)))\n    goto out;\n  if (!NT_SUCCESS (RtlAddAccessAllowedAce (dacl, ACL_REVISION, GENERIC_ALL,\n\t\t\t\t\t   well_known_system_sid)))\n    goto out;\n\n  /* Evaluate authinf size and allocate authinf. */\n  authinf_size = (authinf->data - (PBYTE) authinf);\n  authinf_size += RtlLengthSid (usersid);\t    /* User SID */\n  authinf_size += gsize;\t\t\t    /* Groups + Group SIDs */\n  /* When trying to define the admins group as primary group on Vista,\n     LsaLogonUser fails with error STATUS_INVALID_OWNER.  As workaround\n     we define \"Local\" as primary group here.  Seteuid32 sets the primary\n     group to the group set in /etc/passwd anyway. */\n  if (new_groups.pgsid == well_known_admins_sid)\n    pgrpsid = well_known_local_sid;\n  else\n    pgrpsid = new_groups.pgsid;\n\n  authinf_size += RtlLengthSid (pgrpsid);\t    /* Primary Group SID */\n\n  authinf_size += psize;\t\t\t    /* Privileges */\n  authinf_size += 0;\t\t\t\t    /* Owner SID */\n  authinf_size += dsize;\t\t\t    /* Default DACL */\n\n  authinf = (cyglsa_t *) alloca (authinf_size);\n  authinf->inf_size = authinf_size - ((PBYTE) &authinf->inf - (PBYTE) authinf);\n\n  authinf->magic = CYG_LSA_MAGIC;\n\n  if (!LookupAccountSidW (NULL, usersid, authinf->username, &ulen,\n\t\t\t  authinf->domain, &dlen, &use))\n    {\n      __seterrno ();\n      goto out;\n    }\n\n  /* Store stuff in authinf with offset relative to start of \"inf\" member,\n     instead of using pointers. */\n  offset = authinf->data - (PBYTE) &authinf->inf;\n\n  authinf->inf.ExpirationTime.LowPart = 0xffffffffL;\n  authinf->inf.ExpirationTime.HighPart = 0x7fffffffL;\n  /* User SID */\n  authinf->inf.User.User.Sid = offset;\n  authinf->inf.User.User.Attributes = 0;\n  RtlCopySid (RtlLengthSid (usersid), (PSID) ((PBYTE) &authinf->inf + offset),\n\t      usersid);\n  offset += RtlLengthSid (usersid);\n  /* Groups */\n  authinf->inf.Groups = offset;\n  gsids = (PCYG_TOKEN_GROUPS) ((PBYTE) &authinf->inf + offset);\n  sids_offset = offset + sizeof (ULONG) + non_well_known_cnt\n\t\t\t\t\t  * sizeof (SID_AND_ATTRIBUTES);\n  gsids->GroupCount = non_well_known_cnt;\n  /* Group SIDs */\n  tmpidx = -1;\n  for (int i = 0; i < non_well_known_cnt; ++i)\n    {\n      if ((tmpidx = tmp_gsids.next_non_well_known_sid (tmpidx)) < 0)\n\tbreak;\n      gsids->Groups[i].Sid = sids_offset;\n      gsids->Groups[i].Attributes = SE_GROUP_MANDATORY\n\t\t\t\t    | SE_GROUP_ENABLED_BY_DEFAULT\n\t\t\t\t    | SE_GROUP_ENABLED;\n      RtlCopySid (RtlLengthSid (tmp_gsids.sids[tmpidx]),\n\t\t  (PSID) ((PBYTE) &authinf->inf + sids_offset),\n\t\t  tmp_gsids.sids[tmpidx]);\n      sids_offset += RtlLengthSid (tmp_gsids.sids[tmpidx]);\n    }\n  offset += gsize;\n  /* Primary Group SID */\n  authinf->inf.PrimaryGroup.PrimaryGroup = offset;\n  RtlCopySid (RtlLengthSid (pgrpsid), (PSID) ((PBYTE) &authinf->inf + offset),\n\t      pgrpsid);\n  offset += RtlLengthSid (pgrpsid);\n  /* Privileges */\n  authinf->inf.Privileges = offset;\n  memcpy ((PBYTE) &authinf->inf + offset, privs, psize);\n  offset += psize;\n  /* Owner */\n  authinf->inf.Owner.Owner = 0;\n  /* Default DACL */\n  authinf->inf.DefaultDacl.DefaultDacl = offset;\n  memcpy ((PBYTE) &authinf->inf + offset, dacl, dsize);\n\n  authinf->checksum = CYG_LSA_MAGIC;\n  PDWORD csp;\n  PDWORD csp_end;\n  csp = (PDWORD) &authinf->username;\n  csp_end = (PDWORD) ((PBYTE) authinf + authinf_size);\n  while (csp < csp_end)\n    authinf->checksum += *csp++;\n\n  /* Try to logon... */\n  status = LsaLogonUser (lsa_hdl, (PLSA_STRING) &origin, Interactive,\n\t\t\t package_id, authinf, authinf_size, NULL, &ts,\n\t\t\t &profile, &size, &luid, &user_token, &quota,\n\t\t\t &sub_status);\n  if (status != STATUS_SUCCESS)\n    {\n      debug_printf (\"LsaLogonUser: %y (sub-status %y)\", status, sub_status);\n      __seterrno_from_nt_status (status);\n      goto out;\n    }\n  if (profile)\n    {\n#ifdef JUST_ANOTHER_NONWORKING_SOLUTION\n      /* See ../lsaauth/cyglsa.c. */\n      cygprf_t *prf = (cygprf_t *) profile;\n      if (prf->magic_pre == MAGIC_PRE && prf->magic_post == MAGIC_POST\n\t  && prf->token)\n\t{\n\t  CloseHandle (user_token);\n\t  user_token = prf->token;\n\t  system_printf (\"Got token through profile: %p\", user_token);\n\t}\n#endif /* JUST_ANOTHER_NONWORKING_SOLUTION */\n      LsaFreeReturnBuffer (profile);\n    }\n  user_token = get_full_privileged_inheritable_token (user_token);\n\nout:\n  if (privs)\n    free (privs);\n  lsa_close_policy (lsa);\n  if (lsa_hdl)\n    LsaDeregisterLogonProcess (lsa_hdl);\n  pop_self_privilege ();\n\n  debug_printf (\"%p = lsaauth ()\", user_token);\n  return user_token;\n}",
        "description": "Cygwin versions prior to 2.5.0 fail to correctly update permissions during user changes, enabling attackers to escalate their privileges.",
        "commit": "The vulnerability involves the creation of a security token without using the caller's credentials in the `sec_auth.cc` file. Specifically, the `get_token_group_sidlist`, `get_initgroups_sidlist`, and `get_setgroups_sidlist` functions have been modified to remove parameters related to authentication (`auth_luid` and `auth_pos`) and the code that adds a logon SID. The `create_token` function now explicitly sets the `auth_luid` to either `ANONYMOUS_LOGON_LUID` or `LOCALSERVICE_LUID` based on the operating system, and no longer handles the logon SID since it is no longer generated. Additionally, the `lsaauth` function has removed unused local variables `auth_luid` and `auth_pos`. A new element `has_broken_whoami` has been added to `wincap.h`, and implemented in `wincap.cc`. This change results in the creation of tokens without proper authentication context, potentially leading to unauthorized access or privilege escalation."
    }
]