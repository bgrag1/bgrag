[
    {
        "cwe": "CWE-20",
        "func_name": "libarchive/archive_read_format_iso9660_read_header",
        "score": 0.7897621989250183,
        "func_before": "static int\narchive_read_format_iso9660_read_header(struct archive_read *a,\n    struct archive_entry *entry)\n{\n\tstruct iso9660 *iso9660;\n\tstruct file_info *file;\n\tint r, rd_r = ARCHIVE_OK;\n\n\tiso9660 = (struct iso9660 *)(a->format->data);\n\n\tif (!a->archive.archive_format) {\n\t\ta->archive.archive_format = ARCHIVE_FORMAT_ISO9660;\n\t\ta->archive.archive_format_name = \"ISO9660\";\n\t}\n\n\tif (iso9660->current_position == 0) {\n\t\tr = choose_volume(a, iso9660);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t}\n\n\tfile = NULL;/* Eliminate a warning. */\n\t/* Get the next entry that appears after the current offset. */\n\tr = next_entry_seek(a, iso9660, &file);\n\tif (r != ARCHIVE_OK)\n\t\treturn (r);\n\n\tif (iso9660->seenJoliet) {\n\t\t/*\n\t\t * Convert UTF-16BE of a filename to local locale MBS\n\t\t * and store the result into a filename field.\n\t\t */\n\t\tif (iso9660->sconv_utf16be == NULL) {\n\t\t\tiso9660->sconv_utf16be =\n\t\t\t    archive_string_conversion_from_charset(\n\t\t\t\t&(a->archive), \"UTF-16BE\", 1);\n\t\t\tif (iso9660->sconv_utf16be == NULL)\n\t\t\t\t/* Coundn't allocate memory */\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif (iso9660->utf16be_path == NULL) {\n\t\t\tiso9660->utf16be_path = malloc(UTF16_NAME_MAX);\n\t\t\tif (iso9660->utf16be_path == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"No memory\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t}\n\t\tif (iso9660->utf16be_previous_path == NULL) {\n\t\t\tiso9660->utf16be_previous_path = malloc(UTF16_NAME_MAX);\n\t\t\tif (iso9660->utf16be_previous_path == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"No memory\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t}\n\n\t\tiso9660->utf16be_path_len = 0;\n\t\tif (build_pathname_utf16be(iso9660->utf16be_path,\n\t\t    UTF16_NAME_MAX, &(iso9660->utf16be_path_len), file) != 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Pathname is too long\");\n\t\t}\n\n\t\tr = archive_entry_copy_pathname_l(entry,\n\t\t    (const char *)iso9660->utf16be_path,\n\t\t    iso9660->utf16be_path_len,\n\t\t    iso9660->sconv_utf16be);\n\t\tif (r != 0) {\n\t\t\tif (errno == ENOMEM) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"No memory for Pathname\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Pathname cannot be converted \"\n\t\t\t    \"from %s to current locale.\",\n\t\t\t    archive_string_conversion_charset_name(\n\t\t\t      iso9660->sconv_utf16be));\n\n\t\t\trd_r = ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\tarchive_string_empty(&iso9660->pathname);\n\t\tarchive_entry_set_pathname(entry,\n\t\t    build_pathname(&iso9660->pathname, file));\n\t}\n\n\tiso9660->entry_bytes_remaining = file->size;\n\t/* Offset for sparse-file-aware clients. */\n\tiso9660->entry_sparse_offset = 0;\n\n\tif (file->offset + file->size > iso9660->volume_size) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"File is beyond end-of-media: %s\",\n\t\t    archive_entry_pathname(entry));\n\t\tiso9660->entry_bytes_remaining = 0;\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\t/* Set up the entry structure with information about this entry. */\n\tarchive_entry_set_mode(entry, file->mode);\n\tarchive_entry_set_uid(entry, file->uid);\n\tarchive_entry_set_gid(entry, file->gid);\n\tarchive_entry_set_nlink(entry, file->nlinks);\n\tif (file->birthtime_is_set)\n\t\tarchive_entry_set_birthtime(entry, file->birthtime, 0);\n\telse\n\t\tarchive_entry_unset_birthtime(entry);\n\tarchive_entry_set_mtime(entry, file->mtime, 0);\n\tarchive_entry_set_ctime(entry, file->ctime, 0);\n\tarchive_entry_set_atime(entry, file->atime, 0);\n\t/* N.B.: Rock Ridge supports 64-bit device numbers. */\n\tarchive_entry_set_rdev(entry, (dev_t)file->rdev);\n\tarchive_entry_set_size(entry, iso9660->entry_bytes_remaining);\n\tif (file->symlink.s != NULL)\n\t\tarchive_entry_copy_symlink(entry, file->symlink.s);\n\n\t/* Note: If the input isn't seekable, we can't rewind to\n\t * return the same body again, so if the next entry refers to\n\t * the same data, we have to return it as a hardlink to the\n\t * original entry. */\n\tif (file->number != -1 &&\n\t    file->number == iso9660->previous_number) {\n\t\tif (iso9660->seenJoliet) {\n\t\t\tr = archive_entry_copy_hardlink_l(entry,\n\t\t\t    (const char *)iso9660->utf16be_previous_path,\n\t\t\t    iso9660->utf16be_previous_path_len,\n\t\t\t    iso9660->sconv_utf16be);\n\t\t\tif (r != 0) {\n\t\t\t\tif (errno == ENOMEM) {\n\t\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t\t    \"No memory for Linkname\");\n\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t\t}\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Linkname cannot be converted \"\n\t\t\t\t    \"from %s to current locale.\",\n\t\t\t\t    archive_string_conversion_charset_name(\n\t\t\t\t      iso9660->sconv_utf16be));\n\t\t\t\trd_r = ARCHIVE_WARN;\n\t\t\t}\n\t\t} else\n\t\t\tarchive_entry_set_hardlink(entry,\n\t\t\t    iso9660->previous_pathname.s);\n\t\tarchive_entry_unset_size(entry);\n\t\tiso9660->entry_bytes_remaining = 0;\n\t\treturn (rd_r);\n\t}\n\n\tif ((file->mode & AE_IFMT) != AE_IFDIR &&\n\t    file->offset < iso9660->current_position) {\n\t\tint64_t r64;\n\n\t\tr64 = __archive_read_seek(a, file->offset, SEEK_SET);\n\t\tif (r64 != (int64_t)file->offset) {\n\t\t\t/* We can't seek backwards to extract it, so issue\n\t\t\t * a warning.  Note that this can only happen if\n\t\t\t * this entry was added to the heap after we passed\n\t\t\t * this offset, that is, only if the directory\n\t\t\t * mentioning this entry is later than the body of\n\t\t\t * the entry. Such layouts are very unusual; most\n\t\t\t * ISO9660 writers lay out and record all directory\n\t\t\t * information first, then store all file bodies. */\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Ignoring out-of-order file @%jx (%s) %jd < %jd\",\n\t\t\t    (intmax_t)file->number,\n\t\t\t    iso9660->pathname.s,\n\t\t\t    (intmax_t)file->offset,\n\t\t\t    (intmax_t)iso9660->current_position);\n\t\t\tiso9660->entry_bytes_remaining = 0;\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t\tiso9660->current_position = (uint64_t)r64;\n\t}\n\n\t/* Initialize zisofs variables. */\n\tiso9660->entry_zisofs.pz = file->pz;\n\tif (file->pz) {\n#ifdef HAVE_ZLIB_H\n\t\tstruct zisofs  *zisofs;\n\n\t\tzisofs = &iso9660->entry_zisofs;\n\t\tzisofs->initialized = 0;\n\t\tzisofs->pz_log2_bs = file->pz_log2_bs;\n\t\tzisofs->pz_uncompressed_size = file->pz_uncompressed_size;\n\t\tzisofs->pz_offset = 0;\n\t\tzisofs->header_avail = 0;\n\t\tzisofs->header_passed = 0;\n\t\tzisofs->block_pointers_avail = 0;\n#endif\n\t\tarchive_entry_set_size(entry, file->pz_uncompressed_size);\n\t}\n\n\tiso9660->previous_number = file->number;\n\tif (iso9660->seenJoliet) {\n\t\tmemcpy(iso9660->utf16be_previous_path, iso9660->utf16be_path,\n\t\t    iso9660->utf16be_path_len);\n\t\tiso9660->utf16be_previous_path_len = iso9660->utf16be_path_len;\n\t} else\n\t\tarchive_strcpy(\n\t\t    &iso9660->previous_pathname, iso9660->pathname.s);\n\n\t/* Reset entry_bytes_remaining if the file is multi extent. */\n\tiso9660->entry_content = file->contents.first;\n\tif (iso9660->entry_content != NULL)\n\t\tiso9660->entry_bytes_remaining = iso9660->entry_content->size;\n\n\tif (archive_entry_filetype(entry) == AE_IFDIR) {\n\t\t/* Overwrite nlinks by proper link number which is\n\t\t * calculated from number of sub directories. */\n\t\tarchive_entry_set_nlink(entry, 2 + file->subdirs);\n\t\t/* Directory data has been read completely. */\n\t\tiso9660->entry_bytes_remaining = 0;\n\t}\n\n\tif (rd_r != ARCHIVE_OK)\n\t\treturn (rd_r);\n\treturn (ARCHIVE_OK);\n}",
        "func_after": "static int\narchive_read_format_iso9660_read_header(struct archive_read *a,\n    struct archive_entry *entry)\n{\n\tstruct iso9660 *iso9660;\n\tstruct file_info *file;\n\tint r, rd_r = ARCHIVE_OK;\n\n\tiso9660 = (struct iso9660 *)(a->format->data);\n\n\tif (!a->archive.archive_format) {\n\t\ta->archive.archive_format = ARCHIVE_FORMAT_ISO9660;\n\t\ta->archive.archive_format_name = \"ISO9660\";\n\t}\n\n\tif (iso9660->current_position == 0) {\n\t\tr = choose_volume(a, iso9660);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t}\n\n\tfile = NULL;/* Eliminate a warning. */\n\t/* Get the next entry that appears after the current offset. */\n\tr = next_entry_seek(a, iso9660, &file);\n\tif (r != ARCHIVE_OK)\n\t\treturn (r);\n\n\tif (iso9660->seenJoliet) {\n\t\t/*\n\t\t * Convert UTF-16BE of a filename to local locale MBS\n\t\t * and store the result into a filename field.\n\t\t */\n\t\tif (iso9660->sconv_utf16be == NULL) {\n\t\t\tiso9660->sconv_utf16be =\n\t\t\t    archive_string_conversion_from_charset(\n\t\t\t\t&(a->archive), \"UTF-16BE\", 1);\n\t\t\tif (iso9660->sconv_utf16be == NULL)\n\t\t\t\t/* Coundn't allocate memory */\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif (iso9660->utf16be_path == NULL) {\n\t\t\tiso9660->utf16be_path = malloc(UTF16_NAME_MAX);\n\t\t\tif (iso9660->utf16be_path == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"No memory\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t}\n\t\tif (iso9660->utf16be_previous_path == NULL) {\n\t\t\tiso9660->utf16be_previous_path = malloc(UTF16_NAME_MAX);\n\t\t\tif (iso9660->utf16be_previous_path == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"No memory\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t}\n\n\t\tiso9660->utf16be_path_len = 0;\n\t\tif (build_pathname_utf16be(iso9660->utf16be_path,\n\t\t    UTF16_NAME_MAX, &(iso9660->utf16be_path_len), file) != 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Pathname is too long\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\n\t\tr = archive_entry_copy_pathname_l(entry,\n\t\t    (const char *)iso9660->utf16be_path,\n\t\t    iso9660->utf16be_path_len,\n\t\t    iso9660->sconv_utf16be);\n\t\tif (r != 0) {\n\t\t\tif (errno == ENOMEM) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"No memory for Pathname\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Pathname cannot be converted \"\n\t\t\t    \"from %s to current locale.\",\n\t\t\t    archive_string_conversion_charset_name(\n\t\t\t      iso9660->sconv_utf16be));\n\n\t\t\trd_r = ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\tconst char *path = build_pathname(&iso9660->pathname, file, 0);\n\t\tif (path == NULL) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Pathname is too long\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t} else {\n\t\t\tarchive_string_empty(&iso9660->pathname);\n\t\t\tarchive_entry_set_pathname(entry, path);\n\t\t}\n\t}\n\n\tiso9660->entry_bytes_remaining = file->size;\n\t/* Offset for sparse-file-aware clients. */\n\tiso9660->entry_sparse_offset = 0;\n\n\tif (file->offset + file->size > iso9660->volume_size) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"File is beyond end-of-media: %s\",\n\t\t    archive_entry_pathname(entry));\n\t\tiso9660->entry_bytes_remaining = 0;\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\t/* Set up the entry structure with information about this entry. */\n\tarchive_entry_set_mode(entry, file->mode);\n\tarchive_entry_set_uid(entry, file->uid);\n\tarchive_entry_set_gid(entry, file->gid);\n\tarchive_entry_set_nlink(entry, file->nlinks);\n\tif (file->birthtime_is_set)\n\t\tarchive_entry_set_birthtime(entry, file->birthtime, 0);\n\telse\n\t\tarchive_entry_unset_birthtime(entry);\n\tarchive_entry_set_mtime(entry, file->mtime, 0);\n\tarchive_entry_set_ctime(entry, file->ctime, 0);\n\tarchive_entry_set_atime(entry, file->atime, 0);\n\t/* N.B.: Rock Ridge supports 64-bit device numbers. */\n\tarchive_entry_set_rdev(entry, (dev_t)file->rdev);\n\tarchive_entry_set_size(entry, iso9660->entry_bytes_remaining);\n\tif (file->symlink.s != NULL)\n\t\tarchive_entry_copy_symlink(entry, file->symlink.s);\n\n\t/* Note: If the input isn't seekable, we can't rewind to\n\t * return the same body again, so if the next entry refers to\n\t * the same data, we have to return it as a hardlink to the\n\t * original entry. */\n\tif (file->number != -1 &&\n\t    file->number == iso9660->previous_number) {\n\t\tif (iso9660->seenJoliet) {\n\t\t\tr = archive_entry_copy_hardlink_l(entry,\n\t\t\t    (const char *)iso9660->utf16be_previous_path,\n\t\t\t    iso9660->utf16be_previous_path_len,\n\t\t\t    iso9660->sconv_utf16be);\n\t\t\tif (r != 0) {\n\t\t\t\tif (errno == ENOMEM) {\n\t\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t\t    \"No memory for Linkname\");\n\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t\t}\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Linkname cannot be converted \"\n\t\t\t\t    \"from %s to current locale.\",\n\t\t\t\t    archive_string_conversion_charset_name(\n\t\t\t\t      iso9660->sconv_utf16be));\n\t\t\t\trd_r = ARCHIVE_WARN;\n\t\t\t}\n\t\t} else\n\t\t\tarchive_entry_set_hardlink(entry,\n\t\t\t    iso9660->previous_pathname.s);\n\t\tarchive_entry_unset_size(entry);\n\t\tiso9660->entry_bytes_remaining = 0;\n\t\treturn (rd_r);\n\t}\n\n\tif ((file->mode & AE_IFMT) != AE_IFDIR &&\n\t    file->offset < iso9660->current_position) {\n\t\tint64_t r64;\n\n\t\tr64 = __archive_read_seek(a, file->offset, SEEK_SET);\n\t\tif (r64 != (int64_t)file->offset) {\n\t\t\t/* We can't seek backwards to extract it, so issue\n\t\t\t * a warning.  Note that this can only happen if\n\t\t\t * this entry was added to the heap after we passed\n\t\t\t * this offset, that is, only if the directory\n\t\t\t * mentioning this entry is later than the body of\n\t\t\t * the entry. Such layouts are very unusual; most\n\t\t\t * ISO9660 writers lay out and record all directory\n\t\t\t * information first, then store all file bodies. */\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Ignoring out-of-order file @%jx (%s) %jd < %jd\",\n\t\t\t    (intmax_t)file->number,\n\t\t\t    iso9660->pathname.s,\n\t\t\t    (intmax_t)file->offset,\n\t\t\t    (intmax_t)iso9660->current_position);\n\t\t\tiso9660->entry_bytes_remaining = 0;\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t\tiso9660->current_position = (uint64_t)r64;\n\t}\n\n\t/* Initialize zisofs variables. */\n\tiso9660->entry_zisofs.pz = file->pz;\n\tif (file->pz) {\n#ifdef HAVE_ZLIB_H\n\t\tstruct zisofs  *zisofs;\n\n\t\tzisofs = &iso9660->entry_zisofs;\n\t\tzisofs->initialized = 0;\n\t\tzisofs->pz_log2_bs = file->pz_log2_bs;\n\t\tzisofs->pz_uncompressed_size = file->pz_uncompressed_size;\n\t\tzisofs->pz_offset = 0;\n\t\tzisofs->header_avail = 0;\n\t\tzisofs->header_passed = 0;\n\t\tzisofs->block_pointers_avail = 0;\n#endif\n\t\tarchive_entry_set_size(entry, file->pz_uncompressed_size);\n\t}\n\n\tiso9660->previous_number = file->number;\n\tif (iso9660->seenJoliet) {\n\t\tmemcpy(iso9660->utf16be_previous_path, iso9660->utf16be_path,\n\t\t    iso9660->utf16be_path_len);\n\t\tiso9660->utf16be_previous_path_len = iso9660->utf16be_path_len;\n\t} else\n\t\tarchive_strcpy(\n\t\t    &iso9660->previous_pathname, iso9660->pathname.s);\n\n\t/* Reset entry_bytes_remaining if the file is multi extent. */\n\tiso9660->entry_content = file->contents.first;\n\tif (iso9660->entry_content != NULL)\n\t\tiso9660->entry_bytes_remaining = iso9660->entry_content->size;\n\n\tif (archive_entry_filetype(entry) == AE_IFDIR) {\n\t\t/* Overwrite nlinks by proper link number which is\n\t\t * calculated from number of sub directories. */\n\t\tarchive_entry_set_nlink(entry, 2 + file->subdirs);\n\t\t/* Directory data has been read completely. */\n\t\tiso9660->entry_bytes_remaining = 0;\n\t}\n\n\tif (rd_r != ARCHIVE_OK)\n\t\treturn (rd_r);\n\treturn (ARCHIVE_OK);\n}",
        "description": "bsdtar in libarchive versions prior to 3.2.0 is susceptible to a denial of service (infinite loop) caused by processing an ISO archive containing a directory that references itself.",
        "commit": "Issue #522: Malformed ISO files can lead to a segmentation fault due to excessive directory recursion. Specifically, the system can crash when assembling ISO paths through recursive directory traversal, reaching up to 130,000 directory levels. This vulnerability is addressed by implementing a limit on directory recursion to 1,000 elements. Future improvements should focus on detecting and tracking directory loops directly."
    },
    {
        "cwe": "CWE-189",
        "func_name": "torvalds/i915_gem_execbuffer2",
        "score": 0.7731053233146667,
        "func_before": "int\ni915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n\tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n\tint ret;\n\n\tif (args->buffer_count < 1) {\n\t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\t/* Copy the new buffer offsets back to the user's exec list. */\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}",
        "func_after": "int\ni915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n\tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n\tint ret;\n\n\tif (args->buffer_count < 1 ||\n\t    args->buffer_count > UINT_MAX / sizeof(*exec2_list)) {\n\t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\t/* Copy the new buffer offsets back to the user's exec list. */\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}",
        "description": "An integer overflow vulnerability exists within the `i915_gem_execbuffer2` function of the DRM subsystem in the Linux kernel prior to version 3.3.5 on 32-bit platforms. This flaw allows local users to trigger a denial of service through an out-of-bounds write or potentially cause other unspecified impacts via a specially crafted ioctl call.",
        "commit": "A vulnerability was identified in the i915 driver of the DRM subsystem within the Linux kernel, where a large `args->buffer_count` value provided by userspace through an ioctl call could cause an integer overflow on 32-bit systems. This overflow affects the calculation of the allocation size for temporary execution buffers, potentially leading to out-of-bounds memory access. This issue arose due to changes introduced in commit 8408c282, which attempted to optimize buffer allocation by first trying a normal large `kmalloc`."
    },
    {
        "cwe": "CWE-119",
        "func_name": "torvalds/hugetlb_mcopy_atomic_pte",
        "score": 0.7862673997879028,
        "func_before": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tstruct address_space *mapping = dst_vma->vm_file->f_mapping;\n\t\tpgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
        "func_after": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\tunsigned long size;\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\tmapping = dst_vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\t\tret = -EFAULT;\n\t\tif (idx >= size)\n\t\t\tgoto out_release_nounlock;\n\n\t\t/*\n\t\t * Serialization between remove_inode_hugepages() and\n\t\t * huge_add_to_page_cache() below happens through the\n\t\t * hugetlb_fault_mutex_table that here must be hold by\n\t\t * the caller.\n\t\t */\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\t/*\n\t * Recheck the i_size after holding PT lock to make sure not\n\t * to leave any page mapped (as page_mapped()) beyond the end\n\t * of the i_size (remove_inode_hugepages() is strict about\n\t * enforcing that). If we bail out here, we'll also leave a\n\t * page in the radix tree in the vm_shared case beyond the end\n\t * of the i_size, but remove_inode_hugepages() will take care\n\t * of it as soon as we drop the hugetlb_fault_mutex_table.\n\t */\n\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\tret = -EFAULT;\n\tif (idx >= size)\n\t\tgoto out_release_unlock;\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
        "description": "A flaw was identified in the hugetlb_mcopy_atomic_pte function within the Linux kernel's memory management module, affecting versions prior to 4.13.12. The absence of a proper size check in this function could lead to a denial of service condition, indicated by a BUG.",
        "commit": "A vulnerability was identified in the userfaultfd functionality related to hugetlbfs, where the UFFDIO_COPY operation could inadvertently extend beyond the intended size of the file (i_size). This issue led to a kernel panic (oops) at fs/hugetlbfs/inode.c:484, triggered by the absence of an i_size check in the hugetlb_mcopy_atomic_pte function. Although mmap() operations could succeed beyond the end of the i_size after vmtruncate had removed virtual memory areas (vmas) in those ranges, subsequent faults, including UFFDIO_COPY, should not be allowed to succeed. The proposed solution involves modifying the return value to userland to indicate a SIGBUS-like condition, similar to what a page fault would produce, but this approach was deemed less useful due to the difficulty in distinguishing between SIGSEGV and SIGBUS through meaningful syscall return values."
    },
    {
        "cwe": "CWE-17",
        "func_name": "torvalds/udf_find_entry",
        "score": 0.7934188842773438,
        "func_before": "static struct fileIdentDesc *udf_find_entry(struct inode *dir,\n\t\t\t\t\t    const struct qstr *child,\n\t\t\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t\t\t    struct fileIdentDesc *cfi)\n{\n\tstruct fileIdentDesc *fi = NULL;\n\tloff_t f_pos;\n\tint block, flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tloff_t size;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint isdotdot = child->len == 2 &&\n\t\tchild->name[0] == '.' && child->name[1] == '.';\n\n\tsize = udf_ext0_offset(dir) + dir->i_size;\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tfibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\tgoto out_err;\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t}\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname)\n\t\tgoto out_err;\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out_err;\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif (fibh->sbh == fibh->ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh->soffset + sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi;\n\n\t\t\tif (poffset >= lfi)\n\t\t\t\tnameptr = (uint8_t *)(fibh->ebh->b_data +\n\t\t\t\t\t\t      poffset - lfi);\n\t\t\telse {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t\tlfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t\tfibh->ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn fi;\n}",
        "func_after": "static struct fileIdentDesc *udf_find_entry(struct inode *dir,\n\t\t\t\t\t    const struct qstr *child,\n\t\t\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t\t\t    struct fileIdentDesc *cfi)\n{\n\tstruct fileIdentDesc *fi = NULL;\n\tloff_t f_pos;\n\tint block, flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tloff_t size;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint isdotdot = child->len == 2 &&\n\t\tchild->name[0] == '.' && child->name[1] == '.';\n\n\tsize = udf_ext0_offset(dir) + dir->i_size;\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tfibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\tgoto out_err;\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t}\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname)\n\t\tgoto out_err;\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out_err;\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif (fibh->sbh == fibh->ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh->soffset + sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi;\n\n\t\t\tif (poffset >= lfi)\n\t\t\t\tnameptr = (uint8_t *)(fibh->ebh->b_data +\n\t\t\t\t\t\t      poffset - lfi);\n\t\t\telse {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t\tlfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t\tfibh->ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,\n\t\t\t\t\tUDF_NAME_LEN);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn fi;\n}",
        "description": "The UDF filesystem implementation in the Linux kernel prior to version 3.18.2 does not verify that sufficient space is allocated for storing a symlink target's name along with a trailing null character. This oversight enables local users to potentially access sensitive information through a specially crafted filesystem image.",
        "commit": "The vulnerability involves a failure to verify whether the resolved path from reading a symbolic link fits within the allocated buffer size. This oversight occurs during the process of reading symlinks, where the code does not account for potential encoding conversions that could increase the path length. Consequently, there is a risk that the path may exceed the buffer capacity, leading to buffer overflow issues."
    },
    {
        "cwe": "CWE-129",
        "func_name": "admesh/stl_fix_normal_directions",
        "score": 0.7662495970726013,
        "func_before": "void\nstl_fix_normal_directions(stl_file *stl) {\n  char *norm_sw;\n  /*  int edge_num;*/\n  /*  int vnot;*/\n  int checked = 0;\n  int facet_num;\n  /*  int next_facet;*/\n  int i;\n  int j;\n  struct stl_normal {\n    int               facet_num;\n    struct stl_normal *next;\n  };\n  struct stl_normal *head;\n  struct stl_normal *tail;\n  struct stl_normal *newn;\n  struct stl_normal *temp;\n\n  if (stl->error) return;\n\n  /* Initialize linked list. */\n  head = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n  if(head == NULL) perror(\"stl_fix_normal_directions\");\n  tail = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n  if(tail == NULL) perror(\"stl_fix_normal_directions\");\n  head->next = tail;\n  tail->next = tail;\n\n  /* Initialize list that keeps track of already fixed facets. */\n  norm_sw = (char*)calloc(stl->stats.number_of_facets, sizeof(char));\n  if(norm_sw == NULL) perror(\"stl_fix_normal_directions\");\n\n\n  facet_num = 0;\n  /* If normal vector is not within tolerance and backwards:\n     Arbitrarily starts at face 0.  If this one is wrong, we're screwed.  Thankfully, the chances\n     of it being wrong randomly are low if most of the triangles are right: */\n  if(stl_check_normal_vector(stl, 0, 0) == 2)\n    stl_reverse_facet(stl, 0);\n\n  /* Say that we've fixed this facet: */\n  norm_sw[facet_num] = 1;\n  checked++;\n\n  for(;;) {\n    /* Add neighbors_to_list.\n       Add unconnected neighbors to the list:a  */\n    for(j = 0; j < 3; j++) {\n      /* Reverse the neighboring facets if necessary. */\n      if(stl->neighbors_start[facet_num].which_vertex_not[j] > 2) {\n        /* If the facet has a neighbor that is -1, it means that edge isn't shared by another facet */\n        if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n          stl_reverse_facet\n          (stl, stl->neighbors_start[facet_num].neighbor[j]);\n        }\n      }\n      /* If this edge of the facet is connected: */\n      if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n        /* If we haven't fixed this facet yet, add it to the list: */\n        if(norm_sw[stl->neighbors_start[facet_num].neighbor[j]] != 1) {\n          /* Add node to beginning of list. */\n          newn = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n          if(newn == NULL) perror(\"stl_fix_normal_directions\");\n          newn->facet_num = stl->neighbors_start[facet_num].neighbor[j];\n          newn->next = head->next;\n          head->next = newn;\n        }\n      }\n    }\n    /* Get next facet to fix from top of list. */\n    if(head->next != tail) {\n      facet_num = head->next->facet_num;\n      if(norm_sw[facet_num] != 1) { /* If facet is in list mutiple times */\n        norm_sw[facet_num] = 1; /* Record this one as being fixed. */\n        checked++;\n      }\n      temp = head->next;\t/* Delete this facet from the list. */\n      head->next = head->next->next;\n      free(temp);\n    } else { /* if we ran out of facets to fix: */\n      /* All of the facets in this part have been fixed. */\n      stl->stats.number_of_parts += 1;\n      if(checked >= stl->stats.number_of_facets) {\n        /* All of the facets have been checked.  Bail out. */\n        break;\n      } else {\n        /* There is another part here.  Find it and continue. */\n        for(i = 0; i < stl->stats.number_of_facets; i++) {\n          if(norm_sw[i] == 0) {\n            /* This is the first facet of the next part. */\n            facet_num = i;\n            if(stl_check_normal_vector(stl, i, 0) == 2) {\n              stl_reverse_facet(stl, i);\n            }\n\n            norm_sw[facet_num] = 1;\n            checked++;\n            break;\n          }\n        }\n      }\n    }\n  }\n  free(head);\n  free(tail);\n  free(norm_sw);\n}",
        "func_after": "void\nstl_fix_normal_directions(stl_file *stl) {\n  char *norm_sw;\n  /*  int edge_num;*/\n  /*  int vnot;*/\n  int checked = 0;\n  int facet_num;\n  /*  int next_facet;*/\n  int i;\n  int j;\n  struct stl_normal {\n    int               facet_num;\n    struct stl_normal *next;\n  };\n  struct stl_normal *head;\n  struct stl_normal *tail;\n  struct stl_normal *newn;\n  struct stl_normal *temp;\n\n  if (stl->error) return;\n\n  /* Initialize linked list. */\n  head = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n  if(head == NULL) perror(\"stl_fix_normal_directions\");\n  tail = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n  if(tail == NULL) perror(\"stl_fix_normal_directions\");\n  head->next = tail;\n  tail->next = tail;\n\n  /* Initialize list that keeps track of already fixed facets. */\n  norm_sw = (char*)calloc(stl->stats.number_of_facets, sizeof(char));\n  if(norm_sw == NULL) perror(\"stl_fix_normal_directions\");\n\n\n  facet_num = 0;\n  /* If normal vector is not within tolerance and backwards:\n     Arbitrarily starts at face 0.  If this one is wrong, we're screwed.  Thankfully, the chances\n     of it being wrong randomly are low if most of the triangles are right: */\n  if(stl_check_normal_vector(stl, 0, 0) == 2)\n    stl_reverse_facet(stl, 0);\n\n  /* Say that we've fixed this facet: */\n  norm_sw[facet_num] = 1;\n  checked++;\n\n  for(;;) {\n    /* Add neighbors_to_list.\n       Add unconnected neighbors to the list:a  */\n    for(j = 0; j < 3; j++) {\n      /* Reverse the neighboring facets if necessary. */\n      if(stl->neighbors_start[facet_num].which_vertex_not[j] > 2) {\n        /* If the facet has a neighbor that is -1, it means that edge isn't shared by another facet */\n        if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n          stl_reverse_facet\n          (stl, stl->neighbors_start[facet_num].neighbor[j]);\n        }\n      }\n      /* If this edge of the facet is connected: */\n      if(stl->neighbors_start[facet_num].neighbor[j] != -1 &&\n         stl->neighbors_start[facet_num].neighbor[j] < stl->stats.number_of_facets*sizeof(char)) {\n        /* If we haven't fixed this facet yet, add it to the list: */\n        if(norm_sw[stl->neighbors_start[facet_num].neighbor[j]] != 1) {\n          /* Add node to beginning of list. */\n          newn = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n          if(newn == NULL) perror(\"stl_fix_normal_directions\");\n          newn->facet_num = stl->neighbors_start[facet_num].neighbor[j];\n          newn->next = head->next;\n          head->next = newn;\n        }\n      }\n    }\n    /* Get next facet to fix from top of list. */\n    if(head->next != tail) {\n      facet_num = head->next->facet_num;\n      if(norm_sw[facet_num] != 1) { /* If facet is in list mutiple times */\n        norm_sw[facet_num] = 1; /* Record this one as being fixed. */\n        checked++;\n      }\n      temp = head->next;\t/* Delete this facet from the list. */\n      head->next = head->next->next;\n      free(temp);\n    } else { /* if we ran out of facets to fix: */\n      /* All of the facets in this part have been fixed. */\n      stl->stats.number_of_parts += 1;\n      if(checked >= stl->stats.number_of_facets) {\n        /* All of the facets have been checked.  Bail out. */\n        break;\n      } else {\n        /* There is another part here.  Find it and continue. */\n        for(i = 0; i < stl->stats.number_of_facets; i++) {\n          if(norm_sw[i] == 0) {\n            /* This is the first facet of the next part. */\n            facet_num = i;\n            if(stl_check_normal_vector(stl, i, 0) == 2) {\n              stl_reverse_facet(stl, i);\n            }\n\n            norm_sw[facet_num] = 1;\n            checked++;\n            break;\n          }\n        }\n      }\n    }\n  }\n  free(head);\n  free(tail);\n  free(norm_sw);\n}",
        "description": "An improper array index validation vulnerability exists in the stl_fix_normal_directions functionality of ADMesh. A specially-crafted STL file can lead to a heap buffer overflow. An attacker can exploit this by providing a malicious file.",
        "commit": "The vulnerability involves a check for the `neighbor_index` within the `stl_check_normal_vector` function. This fix addresses an issue identified in ticket #60."
    }
]