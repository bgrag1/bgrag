[
    {
        "cwe": "CWE-121",
        "func_name": "libtiff/TIFFReadCustomDirectory",
        "score": 0.8049443960189819,
        "func_before": "int\nTIFFReadCustomDirectory(TIFF* tif, toff_t diroff,\n\t\t\tconst TIFFFieldArray* infoarray)\n{\n\tstatic const char module[] = \"TIFFReadCustomDirectory\";\n\tTIFFDirEntry* dir;\n\tuint16_t dircount;\n\tTIFFDirEntry* dp;\n\tuint16_t di;\n\tconst TIFFField* fip;\n\tuint32_t fii;\n        (*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */\n\t_TIFFSetupFields(tif, infoarray);\n\tdircount=TIFFFetchDirectory(tif,diroff,&dir,NULL);\n\tif (!dircount)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"Failed to read custom directory at offset %\" PRIu64,diroff);\n\t\treturn 0;\n\t}\n\tTIFFFreeDirectory(tif);\n\t_TIFFmemset(&tif->tif_dir, 0, sizeof(TIFFDirectory));\n\tTIFFReadDirectoryCheckOrder(tif,dir,dircount);\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\n\t{\n\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\tif (fii == FAILED_FII)\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Unknown field with tag %\"PRIu16\" (0x%\"PRIx16\") encountered\",\n\t\t\t    dp->tdir_tag, dp->tdir_tag);\n\t\t\tif (!_TIFFMergeFields(tif, _TIFFCreateAnonField(tif,\n\t\t\t\t\t\tdp->tdir_tag,\n\t\t\t\t\t\t(TIFFDataType) dp->tdir_type),\n\t\t\t\t\t     1)) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Registering anonymous field with tag %\"PRIu16\" (0x%\"PRIx16\") failed\",\n\t\t\t\t    dp->tdir_tag, dp->tdir_tag);\n\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t} else {\n\t\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\t\t\tassert( fii != FAILED_FII );\n\t\t\t}\n\t\t}\n\t\tif (!dp->tdir_ignore)\n\t\t{\n\t\t\tfip=tif->tif_fields[fii];\n\t\t\tif (fip->field_bit==FIELD_IGNORE)\n\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* check data type */\n\t\t\t\twhile ((fip->field_type!=TIFF_ANY)&&(fip->field_type!=dp->tdir_type))\n\t\t\t\t{\n\t\t\t\t\tfii++;\n\t\t\t\t\tif ((fii==tif->tif_nfields)||\n\t\t\t\t\t    (tif->tif_fields[fii]->field_tag!=(uint32_t)dp->tdir_tag))\n\t\t\t\t\t{\n\t\t\t\t\t\tfii=0xFFFF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfip=tif->tif_fields[fii];\n\t\t\t\t}\n\t\t\t\tif (fii==0xFFFF)\n\t\t\t\t{\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\t    \"Wrong data type %\"PRIu16\" for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t    dp->tdir_type,fip->field_name);\n\t\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* check count if known in advance */\n\t\t\t\t\tif ((fip->field_readcount!=TIFF_VARIABLE)&&\n\t\t\t\t\t    (fip->field_readcount!=TIFF_VARIABLE2))\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32_t expected;\n\t\t\t\t\t\tif (fip->field_readcount==TIFF_SPP)\n\t\t\t\t\t\t\texpected=(uint32_t)tif->tif_dir.td_samplesperpixel;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\texpected=(uint32_t)fip->field_readcount;\n\t\t\t\t\t\tif (!CheckDirCount(tif,dp,expected))\n\t\t\t\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!dp->tdir_ignore) {\n\t\t\t\tswitch (dp->tdir_tag) \n\t\t\t\t{\n\t\t\t\t\tcase EXIFTAG_SUBJECTDISTANCE:\n                        if(fip->field_name != NULL && strncmp(fip->field_name, \"Tag \", 4) != 0 ) {\n                            /* should only be called on a Exif directory */\n                            /* when exifFields[] is active */\n                            (void)TIFFFetchSubjectDistance(tif, dp);\n                        }\n                        else {\n                            (void)TIFFFetchNormalTag(tif, dp, TRUE);\n                        }\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t(void)TIFFFetchNormalTag(tif, dp, TRUE);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} /*-- if (!dp->tdir_ignore) */\n\t\t}\n\t}\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn 1;\n}",
        "func_after": "int\nTIFFReadCustomDirectory(TIFF* tif, toff_t diroff,\n\t\t\tconst TIFFFieldArray* infoarray)\n{\n\tstatic const char module[] = \"TIFFReadCustomDirectory\";\n\tTIFFDirEntry* dir;\n\tuint16_t dircount;\n\tTIFFDirEntry* dp;\n\tuint16_t di;\n\tconst TIFFField* fip;\n\tuint32_t fii;\n        (*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */\n\t_TIFFSetupFields(tif, infoarray);\n\tdircount=TIFFFetchDirectory(tif,diroff,&dir,NULL);\n\tif (!dircount)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"Failed to read custom directory at offset %\" PRIu64,diroff);\n\t\treturn 0;\n\t}\n\tTIFFFreeDirectory(tif);\n\t_TIFFmemset(&tif->tif_dir, 0, sizeof(TIFFDirectory));\n\tTIFFReadDirectoryCheckOrder(tif,dir,dircount);\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\n\t{\n\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\tif (fii == FAILED_FII)\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Unknown field with tag %\"PRIu16\" (0x%\"PRIx16\") encountered\",\n\t\t\t    dp->tdir_tag, dp->tdir_tag);\n\t\t\tif (!_TIFFMergeFields(tif, _TIFFCreateAnonField(tif,\n\t\t\t\t\t\tdp->tdir_tag,\n\t\t\t\t\t\t(TIFFDataType) dp->tdir_type),\n\t\t\t\t\t     1)) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Registering anonymous field with tag %\"PRIu16\" (0x%\"PRIx16\") failed\",\n\t\t\t\t    dp->tdir_tag, dp->tdir_tag);\n\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t} else {\n\t\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\t\t\tassert( fii != FAILED_FII );\n\t\t\t}\n\t\t}\n\t\tif (!dp->tdir_ignore)\n\t\t{\n\t\t\tfip=tif->tif_fields[fii];\n\t\t\tif (fip->field_bit==FIELD_IGNORE)\n\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* check data type */\n\t\t\t\twhile ((fip->field_type!=TIFF_ANY)&&(fip->field_type!=dp->tdir_type))\n\t\t\t\t{\n\t\t\t\t\tfii++;\n\t\t\t\t\tif ((fii==tif->tif_nfields)||\n\t\t\t\t\t    (tif->tif_fields[fii]->field_tag!=(uint32_t)dp->tdir_tag))\n\t\t\t\t\t{\n\t\t\t\t\t\tfii=0xFFFF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfip=tif->tif_fields[fii];\n\t\t\t\t}\n\t\t\t\tif (fii==0xFFFF)\n\t\t\t\t{\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\t    \"Wrong data type %\"PRIu16\" for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t    dp->tdir_type,fip->field_name);\n\t\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* check count if known in advance */\n\t\t\t\t\tif ((fip->field_readcount!=TIFF_VARIABLE)&&\n\t\t\t\t\t    (fip->field_readcount!=TIFF_VARIABLE2))\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32_t expected;\n\t\t\t\t\t\tif (fip->field_readcount==TIFF_SPP)\n\t\t\t\t\t\t\texpected=(uint32_t)tif->tif_dir.td_samplesperpixel;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\texpected=(uint32_t)fip->field_readcount;\n\t\t\t\t\t\tif (!CheckDirCount(tif,dp,expected))\n\t\t\t\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!dp->tdir_ignore) {\n\t\t\t\tswitch (dp->tdir_tag) \n\t\t\t\t{\n\t\t\t\t\tcase EXIFTAG_SUBJECTDISTANCE:\n                        if(!TIFFFieldIsAnonymous(fip)) {\n                            /* should only be called on a Exif directory */\n                            /* when exifFields[] is active */\n                            (void)TIFFFetchSubjectDistance(tif, dp);\n                        }\n                        else {\n                            (void)TIFFFetchNormalTag(tif, dp, TRUE);\n                        }\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t(void)TIFFFetchNormalTag(tif, dp, TRUE);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} /*-- if (!dp->tdir_ignore) */\n\t\t}\n\t}\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn 1;\n}",
        "description": "A stack buffer overflow vulnerability exists in the `main()` function of Libtiffs' `tiffcp.c`. This flaw enables an attacker to exploit it by providing a specially crafted TIFF file to the `tiffcp` tool, resulting in a stack buffer overflow. This can lead to memory corruption and ultimately cause a crash, leading to a denial of service.",
        "commit": "The addition of an extra flag for handling anonymous or unknown tags."
    },
    {
        "cwe": "CWE-119",
        "func_name": "torvalds/hugetlb_mcopy_atomic_pte",
        "score": 0.8080126047134399,
        "func_before": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tstruct address_space *mapping = dst_vma->vm_file->f_mapping;\n\t\tpgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
        "func_after": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\tunsigned long size;\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\tmapping = dst_vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\t\tret = -EFAULT;\n\t\tif (idx >= size)\n\t\t\tgoto out_release_nounlock;\n\n\t\t/*\n\t\t * Serialization between remove_inode_hugepages() and\n\t\t * huge_add_to_page_cache() below happens through the\n\t\t * hugetlb_fault_mutex_table that here must be hold by\n\t\t * the caller.\n\t\t */\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\t/*\n\t * Recheck the i_size after holding PT lock to make sure not\n\t * to leave any page mapped (as page_mapped()) beyond the end\n\t * of the i_size (remove_inode_hugepages() is strict about\n\t * enforcing that). If we bail out here, we'll also leave a\n\t * page in the radix tree in the vm_shared case beyond the end\n\t * of the i_size, but remove_inode_hugepages() will take care\n\t * of it as soon as we drop the hugetlb_fault_mutex_table.\n\t */\n\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\tret = -EFAULT;\n\tif (idx >= size)\n\t\tgoto out_release_unlock;\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
        "description": "A flaw was identified in the hugetlb_mcopy_atomic_pte function within the Linux kernel's memory management module, affecting versions prior to 4.13.12. The absence of a proper size check in this function could lead to a denial of service condition, indicated by a BUG.",
        "commit": "A vulnerability was identified in the userfaultfd functionality related to hugetlbfs, where the UFFDIO_COPY operation could inadvertently extend beyond the intended size of the file (i_size). This issue led to a kernel panic (oops) at fs/hugetlbfs/inode.c:484, triggered by the absence of an i_size check in the hugetlb_mcopy_atomic_pte function. Although mmap() operations could succeed beyond the end of the i_size after vmtruncate had removed virtual memory areas (vmas) in those ranges, subsequent faults, including UFFDIO_COPY, should not be allowed to succeed. The proposed solution involves modifying the return value to userland to indicate a SIGBUS-like condition, similar to what a page fault would produce, but this approach was deemed less useful due to the difficulty in distinguishing between SIGSEGV and SIGBUS through meaningful syscall return values."
    },
    {
        "cwe": "CWE-122",
        "func_name": "vim/find_help_tags",
        "score": 0.7980170249938965,
        "func_before": "int\nfind_help_tags(\n    char_u\t*arg,\n    int\t\t*num_matches,\n    char_u\t***matches,\n    int\t\tkeep_lang)\n{\n    char_u\t*s, *d;\n    int\t\ti;\n    // Specific tags that either have a specific replacement or won't go\n    // through the generic rules.\n    static char *(except_tbl[][2]) = {\n\t{\"*\",\t\t\"star\"},\n\t{\"g*\",\t\t\"gstar\"},\n\t{\"[*\",\t\t\"[star\"},\n\t{\"]*\",\t\t\"]star\"},\n\t{\":*\",\t\t\":star\"},\n\t{\"/*\",\t\t\"/star\"},\n\t{\"/\\\\*\",\t\"/\\\\\\\\star\"},\n\t{\"\\\"*\",\t\t\"quotestar\"},\n\t{\"**\",\t\t\"starstar\"},\n\t{\"cpo-*\",\t\"cpo-star\"},\n\t{\"/\\\\(\\\\)\",\t\"/\\\\\\\\(\\\\\\\\)\"},\n\t{\"/\\\\%(\\\\)\",\t\"/\\\\\\\\%(\\\\\\\\)\"},\n\t{\"?\",\t\t\"?\"},\n\t{\"??\",\t\t\"??\"},\n\t{\":?\",\t\t\":?\"},\n\t{\"?<CR>\",\t\"?<CR>\"},\n\t{\"g?\",\t\t\"g?\"},\n\t{\"g?g?\",\t\"g?g?\"},\n\t{\"g??\",\t\t\"g??\"},\n\t{\"-?\",\t\t\"-?\"},\n\t{\"q?\",\t\t\"q?\"},\n\t{\"v_g?\",\t\"v_g?\"},\n\t{\"/\\\\?\",\t\"/\\\\\\\\?\"},\n\t{\"/\\\\z(\\\\)\",\t\"/\\\\\\\\z(\\\\\\\\)\"},\n\t{\"\\\\=\",\t\t\"\\\\\\\\=\"},\n\t{\":s\\\\=\",\t\":s\\\\\\\\=\"},\n\t{\"[count]\",\t\"\\\\[count]\"},\n\t{\"[quotex]\",\t\"\\\\[quotex]\"},\n\t{\"[range]\",\t\"\\\\[range]\"},\n\t{\":[range]\",\t\":\\\\[range]\"},\n\t{\"[pattern]\",\t\"\\\\[pattern]\"},\n\t{\"\\\\|\",\t\t\"\\\\\\\\bar\"},\n\t{\"\\\\%$\",\t\"/\\\\\\\\%\\\\$\"},\n\t{\"s/\\\\~\",\t\"s/\\\\\\\\\\\\~\"},\n\t{\"s/\\\\U\",\t\"s/\\\\\\\\U\"},\n\t{\"s/\\\\L\",\t\"s/\\\\\\\\L\"},\n\t{\"s/\\\\1\",\t\"s/\\\\\\\\1\"},\n\t{\"s/\\\\2\",\t\"s/\\\\\\\\2\"},\n\t{\"s/\\\\3\",\t\"s/\\\\\\\\3\"},\n\t{\"s/\\\\9\",\t\"s/\\\\\\\\9\"},\n\t{NULL, NULL}\n    };\n    static char *(expr_table[]) = {\"!=?\", \"!~?\", \"<=?\", \"<?\", \"==?\", \"=~?\",\n\t\t\t\t   \">=?\", \">?\", \"is?\", \"isnot?\"};\n    int flags;\n\n    d = IObuff;\t\t    // assume IObuff is long enough!\n    d[0] = NUL;\n\n    if (STRNICMP(arg, \"expr-\", 5) == 0)\n    {\n\t// When the string starting with \"expr-\" and containing '?' and matches\n\t// the table, it is taken literally (but ~ is escaped).  Otherwise '?'\n\t// is recognized as a wildcard.\n\tfor (i = (int)ARRAY_LENGTH(expr_table); --i >= 0; )\n\t    if (STRCMP(arg + 5, expr_table[i]) == 0)\n\t    {\n\t\tint si = 0, di = 0;\n\n\t\tfor (;;)\n\t\t{\n\t\t    if (arg[si] == '~')\n\t\t\td[di++] = '\\\\';\n\t\t    d[di++] = arg[si];\n\t\t    if (arg[si] == NUL)\n\t\t\tbreak;\n\t\t    ++si;\n\t\t}\n\t\tbreak;\n\t    }\n    }\n    else\n    {\n\t// Recognize a few exceptions to the rule.  Some strings that contain\n\t// '*'are changed to \"star\", otherwise '*' is recognized as a wildcard.\n\tfor (i = 0; except_tbl[i][0] != NULL; ++i)\n\t    if (STRCMP(arg, except_tbl[i][0]) == 0)\n\t    {\n\t\tSTRCPY(d, except_tbl[i][1]);\n\t\tbreak;\n\t    }\n    }\n\n    if (d[0] == NUL)\t// no match in table\n    {\n\t// Replace \"\\S\" with \"/\\\\S\", etc.  Otherwise every tag is matched.\n\t// Also replace \"\\%^\" and \"\\%(\", they match every tag too.\n\t// Also \"\\zs\", \"\\z1\", etc.\n\t// Also \"\\@<\", \"\\@=\", \"\\@<=\", etc.\n\t// And also \"\\_$\" and \"\\_^\".\n\tif (arg[0] == '\\\\'\n\t\t&& ((arg[1] != NUL && arg[2] == NUL)\n\t\t    || (vim_strchr((char_u *)\"%_z@\", arg[1]) != NULL\n\t\t\t\t\t\t\t   && arg[2] != NUL)))\n\t{\n\t    STRCPY(d, \"/\\\\\\\\\");\n\t    STRCPY(d + 3, arg + 1);\n\t    // Check for \"/\\\\_$\", should be \"/\\\\_\\$\"\n\t    if (d[3] == '_' && d[4] == '$')\n\t\tSTRCPY(d + 4, \"\\\\$\");\n\t}\n\telse\n\t{\n\t  // Replace:\n\t  // \"[:...:]\" with \"\\[:...:]\"\n\t  // \"[++...]\" with \"\\[++...]\"\n\t  // \"\\{\" with \"\\\\{\"\t\t   -- matching \"} \\}\"\n\t    if ((arg[0] == '[' && (arg[1] == ':'\n\t\t\t || (arg[1] == '+' && arg[2] == '+')))\n\t\t    || (arg[0] == '\\\\' && arg[1] == '{'))\n\t      *d++ = '\\\\';\n\n\t  // If tag starts with \"('\", skip the \"(\". Fixes CTRL-] on ('option'.\n\t  if (*arg == '(' && arg[1] == '\\'')\n\t      arg++;\n\t  for (s = arg; *s; ++s)\n\t  {\n\t    // Replace \"|\" with \"bar\" and '\"' with \"quote\" to match the name of\n\t    // the tags for these commands.\n\t    // Replace \"*\" with \".*\" and \"?\" with \".\" to match command line\n\t    // completion.\n\t    // Insert a backslash before '~', '$' and '.' to avoid their\n\t    // special meaning.\n\t    if (d - IObuff > IOSIZE - 10)\t// getting too long!?\n\t\tbreak;\n\t    switch (*s)\n\t    {\n\t\tcase '|':   STRCPY(d, \"bar\");\n\t\t\t    d += 3;\n\t\t\t    continue;\n\t\tcase '\"':   STRCPY(d, \"quote\");\n\t\t\t    d += 5;\n\t\t\t    continue;\n\t\tcase '*':   *d++ = '.';\n\t\t\t    break;\n\t\tcase '?':   *d++ = '.';\n\t\t\t    continue;\n\t\tcase '$':\n\t\tcase '.':\n\t\tcase '~':   *d++ = '\\\\';\n\t\t\t    break;\n\t    }\n\n\t    // Replace \"^x\" by \"CTRL-X\". Don't do this for \"^_\" to make\n\t    // \":help i_^_CTRL-D\" work.\n\t    // Insert '-' before and after \"CTRL-X\" when applicable.\n\t    if (*s < ' ' || (*s == '^' && s[1] && (ASCII_ISALPHA(s[1])\n\t\t\t   || vim_strchr((char_u *)\"?@[\\\\]^\", s[1]) != NULL)))\n\t    {\n\t\tif (d > IObuff && d[-1] != '_' && d[-1] != '\\\\')\n\t\t    *d++ = '_';\t\t// prepend a '_' to make x_CTRL-x\n\t\tSTRCPY(d, \"CTRL-\");\n\t\td += 5;\n\t\tif (*s < ' ')\n\t\t{\n#ifdef EBCDIC\n\t\t    *d++ = CtrlChar(*s);\n#else\n\t\t    *d++ = *s + '@';\n#endif\n\t\t    if (d[-1] == '\\\\')\n\t\t\t*d++ = '\\\\';\t// double a backslash\n\t\t}\n\t\telse\n\t\t    *d++ = *++s;\n\t\tif (s[1] != NUL && s[1] != '_')\n\t\t    *d++ = '_';\t\t// append a '_'\n\t\tcontinue;\n\t    }\n\t    else if (*s == '^')\t\t// \"^\" or \"CTRL-^\" or \"^_\"\n\t\t*d++ = '\\\\';\n\n\t    // Insert a backslash before a backslash after a slash, for search\n\t    // pattern tags: \"/\\|\" --> \"/\\\\|\".\n\t    else if (s[0] == '\\\\' && s[1] != '\\\\'\n\t\t\t\t\t       && *arg == '/' && s == arg + 1)\n\t\t*d++ = '\\\\';\n\n\t    // \"CTRL-\\_\" -> \"CTRL-\\\\_\" to avoid the special meaning of \"\\_\" in\n\t    // \"CTRL-\\_CTRL-N\"\n\t    if (STRNICMP(s, \"CTRL-\\\\_\", 7) == 0)\n\t    {\n\t\tSTRCPY(d, \"CTRL-\\\\\\\\\");\n\t\td += 7;\n\t\ts += 6;\n\t    }\n\n\t    *d++ = *s;\n\n\t    // If tag contains \"({\" or \"([\", tag terminates at the \"(\".\n\t    // This is for help on functions, e.g.: abs({expr}).\n\t    if (*s == '(' && (s[1] == '{' || s[1] =='['))\n\t\tbreak;\n\n\t    // If tag starts with ', toss everything after a second '. Fixes\n\t    // CTRL-] on 'option'. (would include the trailing '.').\n\t    if (*s == '\\'' && s > arg && *arg == '\\'')\n\t\tbreak;\n\t    // Also '{' and '}'.\n\t    if (*s == '}' && s > arg && *arg == '{')\n\t\tbreak;\n\t  }\n\t  *d = NUL;\n\n\t  if (*IObuff == '`')\n\t  {\n\t      if (d > IObuff + 2 && d[-1] == '`')\n\t      {\n\t\t  // remove the backticks from `command`\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-2] = NUL;\n\t      }\n\t      else if (d > IObuff + 3 && d[-2] == '`' && d[-1] == ',')\n\t      {\n\t\t  // remove the backticks and comma from `command`,\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-3] = NUL;\n\t      }\n\t      else if (d > IObuff + 4 && d[-3] == '`'\n\t\t\t\t\t     && d[-2] == '\\\\' && d[-1] == '.')\n\t      {\n\t\t  // remove the backticks and dot from `command`\\.\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-4] = NUL;\n\t      }\n\t  }\n\t}\n    }\n\n    *matches = (char_u **)\"\";\n    *num_matches = 0;\n    flags = TAG_HELP | TAG_REGEXP | TAG_NAMES | TAG_VERBOSE | TAG_NO_TAGFUNC;\n    if (keep_lang)\n\tflags |= TAG_KEEP_LANG;\n    if (find_tags(IObuff, num_matches, matches, flags, (int)MAXCOL, NULL) == OK\n\t    && *num_matches > 0)\n    {\n\t// Sort the matches found on the heuristic number that is after the\n\t// tag name.\n\tqsort((void *)*matches, (size_t)*num_matches,\n\t\t\t\t\t      sizeof(char_u *), help_compare);\n\t// Delete more than TAG_MANY to reduce the size of the listing.\n\twhile (*num_matches > TAG_MANY)\n\t    vim_free((*matches)[--*num_matches]);\n    }\n    return OK;\n}",
        "func_after": "int\nfind_help_tags(\n    char_u\t*arg,\n    int\t\t*num_matches,\n    char_u\t***matches,\n    int\t\tkeep_lang)\n{\n    char_u\t*s, *d;\n    int\t\ti;\n    // Specific tags that either have a specific replacement or won't go\n    // through the generic rules.\n    static char *(except_tbl[][2]) = {\n\t{\"*\",\t\t\"star\"},\n\t{\"g*\",\t\t\"gstar\"},\n\t{\"[*\",\t\t\"[star\"},\n\t{\"]*\",\t\t\"]star\"},\n\t{\":*\",\t\t\":star\"},\n\t{\"/*\",\t\t\"/star\"},\n\t{\"/\\\\*\",\t\"/\\\\\\\\star\"},\n\t{\"\\\"*\",\t\t\"quotestar\"},\n\t{\"**\",\t\t\"starstar\"},\n\t{\"cpo-*\",\t\"cpo-star\"},\n\t{\"/\\\\(\\\\)\",\t\"/\\\\\\\\(\\\\\\\\)\"},\n\t{\"/\\\\%(\\\\)\",\t\"/\\\\\\\\%(\\\\\\\\)\"},\n\t{\"?\",\t\t\"?\"},\n\t{\"??\",\t\t\"??\"},\n\t{\":?\",\t\t\":?\"},\n\t{\"?<CR>\",\t\"?<CR>\"},\n\t{\"g?\",\t\t\"g?\"},\n\t{\"g?g?\",\t\"g?g?\"},\n\t{\"g??\",\t\t\"g??\"},\n\t{\"-?\",\t\t\"-?\"},\n\t{\"q?\",\t\t\"q?\"},\n\t{\"v_g?\",\t\"v_g?\"},\n\t{\"/\\\\?\",\t\"/\\\\\\\\?\"},\n\t{\"/\\\\z(\\\\)\",\t\"/\\\\\\\\z(\\\\\\\\)\"},\n\t{\"\\\\=\",\t\t\"\\\\\\\\=\"},\n\t{\":s\\\\=\",\t\":s\\\\\\\\=\"},\n\t{\"[count]\",\t\"\\\\[count]\"},\n\t{\"[quotex]\",\t\"\\\\[quotex]\"},\n\t{\"[range]\",\t\"\\\\[range]\"},\n\t{\":[range]\",\t\":\\\\[range]\"},\n\t{\"[pattern]\",\t\"\\\\[pattern]\"},\n\t{\"\\\\|\",\t\t\"\\\\\\\\bar\"},\n\t{\"\\\\%$\",\t\"/\\\\\\\\%\\\\$\"},\n\t{\"s/\\\\~\",\t\"s/\\\\\\\\\\\\~\"},\n\t{\"s/\\\\U\",\t\"s/\\\\\\\\U\"},\n\t{\"s/\\\\L\",\t\"s/\\\\\\\\L\"},\n\t{\"s/\\\\1\",\t\"s/\\\\\\\\1\"},\n\t{\"s/\\\\2\",\t\"s/\\\\\\\\2\"},\n\t{\"s/\\\\3\",\t\"s/\\\\\\\\3\"},\n\t{\"s/\\\\9\",\t\"s/\\\\\\\\9\"},\n\t{NULL, NULL}\n    };\n    static char *(expr_table[]) = {\"!=?\", \"!~?\", \"<=?\", \"<?\", \"==?\", \"=~?\",\n\t\t\t\t   \">=?\", \">?\", \"is?\", \"isnot?\"};\n    int flags;\n\n    d = IObuff;\t\t    // assume IObuff is long enough!\n    d[0] = NUL;\n\n    if (STRNICMP(arg, \"expr-\", 5) == 0)\n    {\n\t// When the string starting with \"expr-\" and containing '?' and matches\n\t// the table, it is taken literally (but ~ is escaped).  Otherwise '?'\n\t// is recognized as a wildcard.\n\tfor (i = (int)ARRAY_LENGTH(expr_table); --i >= 0; )\n\t    if (STRCMP(arg + 5, expr_table[i]) == 0)\n\t    {\n\t\tint si = 0, di = 0;\n\n\t\tfor (;;)\n\t\t{\n\t\t    if (arg[si] == '~')\n\t\t\td[di++] = '\\\\';\n\t\t    d[di++] = arg[si];\n\t\t    if (arg[si] == NUL)\n\t\t\tbreak;\n\t\t    ++si;\n\t\t}\n\t\tbreak;\n\t    }\n    }\n    else\n    {\n\t// Recognize a few exceptions to the rule.  Some strings that contain\n\t// '*'are changed to \"star\", otherwise '*' is recognized as a wildcard.\n\tfor (i = 0; except_tbl[i][0] != NULL; ++i)\n\t    if (STRCMP(arg, except_tbl[i][0]) == 0)\n\t    {\n\t\tSTRCPY(d, except_tbl[i][1]);\n\t\tbreak;\n\t    }\n    }\n\n    if (d[0] == NUL)\t// no match in table\n    {\n\t// Replace \"\\S\" with \"/\\\\S\", etc.  Otherwise every tag is matched.\n\t// Also replace \"\\%^\" and \"\\%(\", they match every tag too.\n\t// Also \"\\zs\", \"\\z1\", etc.\n\t// Also \"\\@<\", \"\\@=\", \"\\@<=\", etc.\n\t// And also \"\\_$\" and \"\\_^\".\n\tif (arg[0] == '\\\\'\n\t\t&& ((arg[1] != NUL && arg[2] == NUL)\n\t\t    || (vim_strchr((char_u *)\"%_z@\", arg[1]) != NULL\n\t\t\t\t\t\t\t   && arg[2] != NUL)))\n\t{\n\t    vim_snprintf((char *)d, IOSIZE, \"/\\\\\\\\%s\", arg + 1);\n\t    // Check for \"/\\\\_$\", should be \"/\\\\_\\$\"\n\t    if (d[3] == '_' && d[4] == '$')\n\t\tSTRCPY(d + 4, \"\\\\$\");\n\t}\n\telse\n\t{\n\t  // Replace:\n\t  // \"[:...:]\" with \"\\[:...:]\"\n\t  // \"[++...]\" with \"\\[++...]\"\n\t  // \"\\{\" with \"\\\\{\"\t\t   -- matching \"} \\}\"\n\t    if ((arg[0] == '[' && (arg[1] == ':'\n\t\t\t || (arg[1] == '+' && arg[2] == '+')))\n\t\t    || (arg[0] == '\\\\' && arg[1] == '{'))\n\t      *d++ = '\\\\';\n\n\t  // If tag starts with \"('\", skip the \"(\". Fixes CTRL-] on ('option'.\n\t  if (*arg == '(' && arg[1] == '\\'')\n\t      arg++;\n\t  for (s = arg; *s; ++s)\n\t  {\n\t    // Replace \"|\" with \"bar\" and '\"' with \"quote\" to match the name of\n\t    // the tags for these commands.\n\t    // Replace \"*\" with \".*\" and \"?\" with \".\" to match command line\n\t    // completion.\n\t    // Insert a backslash before '~', '$' and '.' to avoid their\n\t    // special meaning.\n\t    if (d - IObuff > IOSIZE - 10)\t// getting too long!?\n\t\tbreak;\n\t    switch (*s)\n\t    {\n\t\tcase '|':   STRCPY(d, \"bar\");\n\t\t\t    d += 3;\n\t\t\t    continue;\n\t\tcase '\"':   STRCPY(d, \"quote\");\n\t\t\t    d += 5;\n\t\t\t    continue;\n\t\tcase '*':   *d++ = '.';\n\t\t\t    break;\n\t\tcase '?':   *d++ = '.';\n\t\t\t    continue;\n\t\tcase '$':\n\t\tcase '.':\n\t\tcase '~':   *d++ = '\\\\';\n\t\t\t    break;\n\t    }\n\n\t    // Replace \"^x\" by \"CTRL-X\". Don't do this for \"^_\" to make\n\t    // \":help i_^_CTRL-D\" work.\n\t    // Insert '-' before and after \"CTRL-X\" when applicable.\n\t    if (*s < ' ' || (*s == '^' && s[1] && (ASCII_ISALPHA(s[1])\n\t\t\t   || vim_strchr((char_u *)\"?@[\\\\]^\", s[1]) != NULL)))\n\t    {\n\t\tif (d > IObuff && d[-1] != '_' && d[-1] != '\\\\')\n\t\t    *d++ = '_';\t\t// prepend a '_' to make x_CTRL-x\n\t\tSTRCPY(d, \"CTRL-\");\n\t\td += 5;\n\t\tif (*s < ' ')\n\t\t{\n#ifdef EBCDIC\n\t\t    *d++ = CtrlChar(*s);\n#else\n\t\t    *d++ = *s + '@';\n#endif\n\t\t    if (d[-1] == '\\\\')\n\t\t\t*d++ = '\\\\';\t// double a backslash\n\t\t}\n\t\telse\n\t\t    *d++ = *++s;\n\t\tif (s[1] != NUL && s[1] != '_')\n\t\t    *d++ = '_';\t\t// append a '_'\n\t\tcontinue;\n\t    }\n\t    else if (*s == '^')\t\t// \"^\" or \"CTRL-^\" or \"^_\"\n\t\t*d++ = '\\\\';\n\n\t    // Insert a backslash before a backslash after a slash, for search\n\t    // pattern tags: \"/\\|\" --> \"/\\\\|\".\n\t    else if (s[0] == '\\\\' && s[1] != '\\\\'\n\t\t\t\t\t       && *arg == '/' && s == arg + 1)\n\t\t*d++ = '\\\\';\n\n\t    // \"CTRL-\\_\" -> \"CTRL-\\\\_\" to avoid the special meaning of \"\\_\" in\n\t    // \"CTRL-\\_CTRL-N\"\n\t    if (STRNICMP(s, \"CTRL-\\\\_\", 7) == 0)\n\t    {\n\t\tSTRCPY(d, \"CTRL-\\\\\\\\\");\n\t\td += 7;\n\t\ts += 6;\n\t    }\n\n\t    *d++ = *s;\n\n\t    // If tag contains \"({\" or \"([\", tag terminates at the \"(\".\n\t    // This is for help on functions, e.g.: abs({expr}).\n\t    if (*s == '(' && (s[1] == '{' || s[1] =='['))\n\t\tbreak;\n\n\t    // If tag starts with ', toss everything after a second '. Fixes\n\t    // CTRL-] on 'option'. (would include the trailing '.').\n\t    if (*s == '\\'' && s > arg && *arg == '\\'')\n\t\tbreak;\n\t    // Also '{' and '}'.\n\t    if (*s == '}' && s > arg && *arg == '{')\n\t\tbreak;\n\t  }\n\t  *d = NUL;\n\n\t  if (*IObuff == '`')\n\t  {\n\t      if (d > IObuff + 2 && d[-1] == '`')\n\t      {\n\t\t  // remove the backticks from `command`\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-2] = NUL;\n\t      }\n\t      else if (d > IObuff + 3 && d[-2] == '`' && d[-1] == ',')\n\t      {\n\t\t  // remove the backticks and comma from `command`,\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-3] = NUL;\n\t      }\n\t      else if (d > IObuff + 4 && d[-3] == '`'\n\t\t\t\t\t     && d[-2] == '\\\\' && d[-1] == '.')\n\t      {\n\t\t  // remove the backticks and dot from `command`\\.\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-4] = NUL;\n\t      }\n\t  }\n\t}\n    }\n\n    *matches = (char_u **)\"\";\n    *num_matches = 0;\n    flags = TAG_HELP | TAG_REGEXP | TAG_NAMES | TAG_VERBOSE | TAG_NO_TAGFUNC;\n    if (keep_lang)\n\tflags |= TAG_KEEP_LANG;\n    if (find_tags(IObuff, num_matches, matches, flags, (int)MAXCOL, NULL) == OK\n\t    && *num_matches > 0)\n    {\n\t// Sort the matches found on the heuristic number that is after the\n\t// tag name.\n\tqsort((void *)*matches, (size_t)*num_matches,\n\t\t\t\t\t      sizeof(char_u *), help_compare);\n\t// Delete more than TAG_MANY to reduce the size of the listing.\n\twhile (*num_matches > TAG_MANY)\n\t    vim_free((*matches)[--*num_matches]);\n    }\n    return OK;\n}",
        "description": "vim is susceptible to a Heap-based Buffer Overflow vulnerability.",
        "commit": "output: \"A buffer overflow vulnerability was identified in the handling of long help arguments. The solution implemented involves using snprintf() to prevent such overflows.\""
    },
    {
        "cwe": "CWE-203",
        "func_name": "barebox/check_passwd",
        "score": 0.7984524965286255,
        "func_before": "static int check_passwd(unsigned char *passwd, size_t length)\n{\n\tstruct digest *d = NULL;\n\tunsigned char *passwd1_sum;\n\tunsigned char *passwd2_sum;\n\tint ret = 0;\n\tint hash_len;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\thash_len = PBKDF2_LENGTH;\n\t} else {\n\t\td = digest_alloc(PASSWD_SUM);\n\t\tif (!d) {\n\t\t\tpr_err(\"No such digest: %s\\n\",\n\t\t\t       PASSWD_SUM ? PASSWD_SUM : \"NULL\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\thash_len = digest_length(d);\n\t}\n\n\tpasswd1_sum = calloc(hash_len * 2, sizeof(unsigned char));\n\tif (!passwd1_sum)\n\t\treturn -ENOMEM;\n\n\tpasswd2_sum = passwd1_sum + hash_len;\n\n\tif (is_passwd_env_enable())\n\t\tret = read_env_passwd(passwd2_sum, hash_len);\n\telse if (is_passwd_default_enable())\n\t\tret = read_default_passwd(passwd2_sum, hash_len);\n\telse\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto err;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\tchar *key = passwd2_sum + PBKDF2_SALT_LEN;\n\t\tchar *salt = passwd2_sum;\n\t\tint keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN;\n\n\t\tret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt,\n\t\t\tPBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, passwd1_sum);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (strncmp(passwd1_sum, key, keylen) == 0)\n\t\t\tret = 1;\n\t} else {\n\t\tret = digest_digest(d, passwd, length, passwd1_sum);\n\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (strncmp(passwd1_sum, passwd2_sum, hash_len) == 0)\n\t\t\tret = 1;\n\t}\n\nerr:\n\tfree(passwd1_sum);\n\tdigest_free(d);\n\n\treturn ret;\n}",
        "func_after": "static int check_passwd(unsigned char *passwd, size_t length)\n{\n\tstruct digest *d = NULL;\n\tunsigned char *passwd1_sum;\n\tunsigned char *passwd2_sum;\n\tint ret = 0;\n\tint hash_len;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\thash_len = PBKDF2_LENGTH;\n\t} else {\n\t\td = digest_alloc(PASSWD_SUM);\n\t\tif (!d) {\n\t\t\tpr_err(\"No such digest: %s\\n\",\n\t\t\t       PASSWD_SUM ? PASSWD_SUM : \"NULL\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\thash_len = digest_length(d);\n\t}\n\n\tpasswd1_sum = calloc(hash_len * 2, sizeof(unsigned char));\n\tif (!passwd1_sum)\n\t\treturn -ENOMEM;\n\n\tpasswd2_sum = passwd1_sum + hash_len;\n\n\tif (is_passwd_env_enable())\n\t\tret = read_env_passwd(passwd2_sum, hash_len);\n\telse if (is_passwd_default_enable())\n\t\tret = read_default_passwd(passwd2_sum, hash_len);\n\telse\n\t\tret = -EINVAL;\n\n\tif (ret < 0)\n\t\tgoto err;\n\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\tchar *key = passwd2_sum + PBKDF2_SALT_LEN;\n\t\tchar *salt = passwd2_sum;\n\t\tint keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN;\n\n\t\tret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt,\n\t\t\tPBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, passwd1_sum);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (!crypto_memneq(passwd1_sum, key, keylen))\n\t\t\tret = 1;\n\t} else {\n\t\tret = digest_digest(d, passwd, length, passwd1_sum);\n\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (!crypto_memneq(passwd1_sum, passwd2_sum, hash_len))\n\t\t\tret = 1;\n\t}\n\nerr:\n\tfree(passwd1_sum);\n\tdigest_free(d);\n\n\treturn ret;\n}",
        "description": "The Pengutronix barebox, up to version 2021.07.0, suffers from a vulnerability where timing information is leaked due to the use of `strncmp` during hash comparisons.",
        "commit": "Cryptographic verifications should employ a time-constant comparison method to prevent attackers from inferring secret information by observing system behavior. Therefore, it is recommended to use functions like `crypto_memneq()` instead of `memcmp()` for comparing sensitive data such as password hashes."
    }
]