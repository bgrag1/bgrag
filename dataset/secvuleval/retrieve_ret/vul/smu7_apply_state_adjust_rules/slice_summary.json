[
    {
        "cwe": "CWE-440",
        "func_name": "eclipse-openj9/Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex",
        "score": 0.8056889176368713,
        "func_before": "JNIEXPORT jint JNICALL Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *env, jclass InterfaceMethodHandle, jlong interfaceArg, jint itableIndex, jlong receiverClassArg)\n   {\n   J9Class  *interfaceClass = (J9Class*)(intptr_t)interfaceArg;\n   J9Class  *receiverClass  = (J9Class*)(intptr_t)receiverClassArg;\n   J9ITable *itableEntry;\n   for (itableEntry = (J9ITable*)receiverClass->iTable; itableEntry; itableEntry = itableEntry->next)\n      if (itableEntry->interfaceClass == interfaceClass)\n         break;\n   TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *itableArray = (UDATA*)(itableEntry+1);\n   return (itableArray[itableIndex] - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } indexAndLiterals =\n      {\n      (UDATA)interfaceClass,\n      (UDATA)itableIndex\n      };\n   J9Object *receiver = (J9Object*)receiverArg;\n   return (jint)jitLookupInterfaceMethod(receiver->clazz, &indexAndLiterals, 0);\n#endif\n   }",
        "func_after": "JNIEXPORT jint JNICALL Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *env, jclass InterfaceMethodHandle, jlong interfaceArg, jint itableIndex, jlong receiverClassArg)\n   {\n   J9Class  *interfaceClass = (J9Class*)(intptr_t)interfaceArg;\n   J9Class  *receiverClass  = (J9Class*)(intptr_t)receiverClassArg;\n   J9ITable *itableEntry;\n   for (itableEntry = (J9ITable*)receiverClass->iTable; itableEntry; itableEntry = itableEntry->next)\n      if (itableEntry->interfaceClass == interfaceClass)\n         break;\n   TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *itableArray = (UDATA*)(itableEntry+1);\n   UDATA vTableOffset = itableArray[itableIndex];\n   J9Method *method = *(J9Method**)((UDATA)receiverClass + vTableOffset);\n   if ((J9_ROM_METHOD_FROM_RAM_METHOD(method)->modifiers & J9AccPublic) == 0)\n      return -1;\n\n   return (vTableOffset - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } indexAndLiterals =\n      {\n      (UDATA)interfaceClass,\n      (UDATA)itableIndex\n      };\n   J9Object *receiver = (J9Object*)receiverArg;\n   return (jint)jitLookupInterfaceMethod(receiver->clazz, &indexAndLiterals, 0);\n#endif\n   }",
        "description": "In versions of Eclipse Openj9 prior to 0.29.0, the Java Virtual Machine (JVM) fails to throw an IllegalAccessError when MethodHandles are used to invoke methods that are not accessible through interfaces.",
        "commit": "The vulnerability involves a situation where an `IllegalAccessError` (IAE) is not being thrown appropriately when an `InterfaceHandle` encounters a non-public method during dispatch. The expected behavior is for the dispatch mechanism implemented by `InterfaceHandle` to mimic that of `invokeinterface`, which throws an `IAE` when attempting to access non-public methods. This discrepancy allows unauthorized access to non-public methods, potentially leading to security vulnerabilities."
    },
    {
        "cwe": "CWE-252",
        "func_name": "libtiff/createCroppedImage",
        "score": 0.8266338109970093,
        "func_before": "static int\ncreateCroppedImage(struct image_data *image, struct crop_mask *crop, \n                   unsigned char **read_buff_ptr, unsigned char **crop_buff_ptr)\n  {\n  tsize_t   cropsize;\n  unsigned  char *read_buff = NULL;\n  unsigned  char *crop_buff = NULL;\n  unsigned  char *new_buff  = NULL;\n  static    tsize_t  prev_cropsize = 0;\n\n  read_buff = *read_buff_ptr;\n\n  /* process full image, no crop buffer needed */\n  crop_buff = read_buff;\n  *crop_buff_ptr = read_buff;\n  crop->combined_width = image->width;\n  crop->combined_length = image->length;\n\n  cropsize = crop->bufftotal;\n  crop_buff = *crop_buff_ptr;\n  if (!crop_buff)\n    {\n    crop_buff = (unsigned char *)limitMalloc(cropsize);\n    *crop_buff_ptr = crop_buff;\n    _TIFFmemset(crop_buff, 0, cropsize);\n    prev_cropsize = cropsize;\n    }\n  else\n    {\n    if (prev_cropsize < cropsize)\n      {\n      new_buff = _TIFFrealloc(crop_buff, cropsize);\n      if (!new_buff)\n        {\n\tfree (crop_buff);\n        crop_buff = (unsigned char *)limitMalloc(cropsize);\n        }\n      else\n        crop_buff = new_buff;\n      _TIFFmemset(crop_buff, 0, cropsize);\n      }\n    }\n\n  if (!crop_buff)\n    {\n    TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");\n    return (-1);\n    }\n  *crop_buff_ptr = crop_buff;\n\n  if (crop->crop_mode & CROP_INVERT)\n    {\n    switch (crop->photometric)\n      {\n      /* Just change the interpretation */\n      case PHOTOMETRIC_MINISWHITE:\n      case PHOTOMETRIC_MINISBLACK:\n\t   image->photometric = crop->photometric;\n\t   break;\n      case INVERT_DATA_ONLY:\n      case INVERT_DATA_AND_TAG:\n           if (invertImage(image->photometric, image->spp, image->bps, \n                           crop->combined_width, crop->combined_length, crop_buff))\n             {\n             TIFFError(\"createCroppedImage\", \n                       \"Failed to invert colorspace for image or cropped selection\");\n             return (-1);\n             }\n           if (crop->photometric == INVERT_DATA_AND_TAG)\n             {\n             switch (image->photometric)\n               {\n               case PHOTOMETRIC_MINISWHITE:\n \t            image->photometric = PHOTOMETRIC_MINISBLACK;\n\t            break;\n               case PHOTOMETRIC_MINISBLACK:\n \t            image->photometric = PHOTOMETRIC_MINISWHITE;\n\t            break;\n               default:\n\t            break;\n\t       }\n\t     }\n           break;\n      default: break;\n      }\n    }\n\n  if (crop->crop_mode & CROP_MIRROR)\n    {\n    if (mirrorImage(image->spp, image->bps, crop->mirror, \n                    crop->combined_width, crop->combined_length, crop_buff))\n      {\n      TIFFError(\"createCroppedImage\", \"Failed to mirror image or cropped selection %s\", \n\t       (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");\n      return (-1);\n      }\n    }\n\n  if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n    {\n    if (rotateImage(crop->rotation, image, &crop->combined_width, \n                    &crop->combined_length, crop_buff_ptr))\n      {\n      TIFFError(\"createCroppedImage\", \n                \"Failed to rotate image or cropped selection by %\"PRIu16\" degrees\", crop->rotation);\n      return (-1);\n      }\n    }\n\n  if (crop_buff == read_buff) /* we used the read buffer for the crop buffer */\n    *read_buff_ptr = NULL;    /* so we don't try to free it later */\n\n  return (0);\n  }",
        "func_after": "static int\ncreateCroppedImage(struct image_data *image, struct crop_mask *crop, \n                   unsigned char **read_buff_ptr, unsigned char **crop_buff_ptr)\n  {\n  tsize_t   cropsize;\n  unsigned  char *read_buff = NULL;\n  unsigned  char *crop_buff = NULL;\n  unsigned  char *new_buff  = NULL;\n  static    tsize_t  prev_cropsize = 0;\n\n  read_buff = *read_buff_ptr;\n\n  /* process full image, no crop buffer needed */\n  crop_buff = read_buff;\n  *crop_buff_ptr = read_buff;\n  crop->combined_width = image->width;\n  crop->combined_length = image->length;\n\n  cropsize = crop->bufftotal;\n  crop_buff = *crop_buff_ptr;\n  if (!crop_buff)\n    {\n    crop_buff = (unsigned char *)limitMalloc(cropsize);\n    if (!crop_buff)\n    {\n        TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");\n        return (-1);\n    }\n    _TIFFmemset(crop_buff, 0, cropsize);\n    prev_cropsize = cropsize;\n    }\n  else\n    {\n    if (prev_cropsize < cropsize)\n      {\n      new_buff = _TIFFrealloc(crop_buff, cropsize);\n      if (!new_buff)\n        {\n\tfree (crop_buff);\n        crop_buff = (unsigned char *)limitMalloc(cropsize);\n        }\n      else\n        crop_buff = new_buff;\n      if (!crop_buff)\n      {\n          TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");\n          return (-1);\n      }\n      _TIFFmemset(crop_buff, 0, cropsize);\n      }\n    }\n\n  *crop_buff_ptr = crop_buff;\n\n  if (crop->crop_mode & CROP_INVERT)\n    {\n    switch (crop->photometric)\n      {\n      /* Just change the interpretation */\n      case PHOTOMETRIC_MINISWHITE:\n      case PHOTOMETRIC_MINISBLACK:\n\t   image->photometric = crop->photometric;\n\t   break;\n      case INVERT_DATA_ONLY:\n      case INVERT_DATA_AND_TAG:\n           if (invertImage(image->photometric, image->spp, image->bps, \n                           crop->combined_width, crop->combined_length, crop_buff))\n             {\n             TIFFError(\"createCroppedImage\", \n                       \"Failed to invert colorspace for image or cropped selection\");\n             return (-1);\n             }\n           if (crop->photometric == INVERT_DATA_AND_TAG)\n             {\n             switch (image->photometric)\n               {\n               case PHOTOMETRIC_MINISWHITE:\n \t            image->photometric = PHOTOMETRIC_MINISBLACK;\n\t            break;\n               case PHOTOMETRIC_MINISBLACK:\n \t            image->photometric = PHOTOMETRIC_MINISWHITE;\n\t            break;\n               default:\n\t            break;\n\t       }\n\t     }\n           break;\n      default: break;\n      }\n    }\n\n  if (crop->crop_mode & CROP_MIRROR)\n    {\n    if (mirrorImage(image->spp, image->bps, crop->mirror, \n                    crop->combined_width, crop->combined_length, crop_buff))\n      {\n      TIFFError(\"createCroppedImage\", \"Failed to mirror image or cropped selection %s\", \n\t       (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");\n      return (-1);\n      }\n    }\n\n  if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n    {\n    if (rotateImage(crop->rotation, image, &crop->combined_width, \n                    &crop->combined_length, crop_buff_ptr))\n      {\n      TIFFError(\"createCroppedImage\", \n                \"Failed to rotate image or cropped selection by %\"PRIu16\" degrees\", crop->rotation);\n      return (-1);\n      }\n    }\n\n  if (crop_buff == read_buff) /* we used the read buffer for the crop buffer */\n    *read_buff_ptr = NULL;    /* so we don't try to free it later */\n\n  return (0);\n  }",
        "description": "Unchecked return value leading to NULL pointer dereference in the tiffcrop utility of libtiff 4.3.0 enables attackers to trigger a denial-of-service condition through a specially crafted TIFF file. Users who compile libtiff from source can apply the fix available in commit f2b656e2.",
        "commit": "It was identified that checks for the return value of memory allocation functions like `malloc` were missing, which could lead to potential issues if the allocation fails."
    },
    {
        "cwe": "CWE-770",
        "func_name": "binutils-gdb/_bfd_elf_slurp_version_tables",
        "score": 0.8268322348594666,
        "func_before": "bfd_boolean\n_bfd_elf_slurp_version_tables (bfd *abfd, bfd_boolean default_imported_symver)\n{\n  bfd_byte *contents = NULL;\n  unsigned int freeidx = 0;\n\n  if (elf_dynverref (abfd) != 0)\n    {\n      Elf_Internal_Shdr *hdr;\n      Elf_External_Verneed *everneed;\n      Elf_Internal_Verneed *iverneed;\n      unsigned int i;\n      bfd_byte *contents_end;\n\n      hdr = &elf_tdata (abfd)->dynverref_hdr;\n\n      if (hdr->sh_info == 0 || hdr->sh_size < sizeof (Elf_External_Verneed))\n\t{\nerror_return_bad_verref:\n\t  _bfd_error_handler\n\t    (_(\"%B: .gnu.version_r invalid entry\"), abfd);\n\t  bfd_set_error (bfd_error_bad_value);\nerror_return_verref:\n\t  elf_tdata (abfd)->verref = NULL;\n\t  elf_tdata (abfd)->cverrefs = 0;\n\t  goto error_return;\n\t}\n\n      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);\n      if (contents == NULL)\n\tgoto error_return_verref;\n\n      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n\t  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)\n\tgoto error_return_verref;\n\n      elf_tdata (abfd)->verref = (Elf_Internal_Verneed *)\n\tbfd_zalloc2 (abfd, hdr->sh_info, sizeof (Elf_Internal_Verneed));\n\n      if (elf_tdata (abfd)->verref == NULL)\n\tgoto error_return_verref;\n\n      BFD_ASSERT (sizeof (Elf_External_Verneed)\n\t\t  == sizeof (Elf_External_Vernaux));\n      contents_end = contents + hdr->sh_size - sizeof (Elf_External_Verneed);\n      everneed = (Elf_External_Verneed *) contents;\n      iverneed = elf_tdata (abfd)->verref;\n      for (i = 0; i < hdr->sh_info; i++, iverneed++)\n\t{\n\t  Elf_External_Vernaux *evernaux;\n\t  Elf_Internal_Vernaux *ivernaux;\n\t  unsigned int j;\n\n\t  _bfd_elf_swap_verneed_in (abfd, everneed, iverneed);\n\n\t  iverneed->vn_bfd = abfd;\n\n\t  iverneed->vn_filename =\n\t    bfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t     iverneed->vn_file);\n\t  if (iverneed->vn_filename == NULL)\n\t    goto error_return_bad_verref;\n\n\t  if (iverneed->vn_cnt == 0)\n\t    iverneed->vn_auxptr = NULL;\n\t  else\n\t    {\n\t      iverneed->vn_auxptr = (struct elf_internal_vernaux *)\n                  bfd_alloc2 (abfd, iverneed->vn_cnt,\n                              sizeof (Elf_Internal_Vernaux));\n\t      if (iverneed->vn_auxptr == NULL)\n\t\tgoto error_return_verref;\n\t    }\n\n\t  if (iverneed->vn_aux\n\t      > (size_t) (contents_end - (bfd_byte *) everneed))\n\t    goto error_return_bad_verref;\n\n\t  evernaux = ((Elf_External_Vernaux *)\n\t\t      ((bfd_byte *) everneed + iverneed->vn_aux));\n\t  ivernaux = iverneed->vn_auxptr;\n\t  for (j = 0; j < iverneed->vn_cnt; j++, ivernaux++)\n\t    {\n\t      _bfd_elf_swap_vernaux_in (abfd, evernaux, ivernaux);\n\n\t      ivernaux->vna_nodename =\n\t\tbfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t\t ivernaux->vna_name);\n\t      if (ivernaux->vna_nodename == NULL)\n\t\tgoto error_return_bad_verref;\n\n\t      if (ivernaux->vna_other > freeidx)\n\t\tfreeidx = ivernaux->vna_other;\n\n\t      ivernaux->vna_nextptr = NULL;\n\t      if (ivernaux->vna_next == 0)\n\t\t{\n\t\t  iverneed->vn_cnt = j + 1;\n\t\t  break;\n\t\t}\n\t      if (j + 1 < iverneed->vn_cnt)\n\t\tivernaux->vna_nextptr = ivernaux + 1;\n\n\t      if (ivernaux->vna_next\n\t\t  > (size_t) (contents_end - (bfd_byte *) evernaux))\n\t\tgoto error_return_bad_verref;\n\n\t      evernaux = ((Elf_External_Vernaux *)\n\t\t\t  ((bfd_byte *) evernaux + ivernaux->vna_next));\n\t    }\n\n\t  iverneed->vn_nextref = NULL;\n\t  if (iverneed->vn_next == 0)\n\t    break;\n\t  if (i + 1 < hdr->sh_info)\n\t    iverneed->vn_nextref = iverneed + 1;\n\n\t  if (iverneed->vn_next\n\t      > (size_t) (contents_end - (bfd_byte *) everneed))\n\t    goto error_return_bad_verref;\n\n\t  everneed = ((Elf_External_Verneed *)\n\t\t      ((bfd_byte *) everneed + iverneed->vn_next));\n\t}\n      elf_tdata (abfd)->cverrefs = i;\n\n      free (contents);\n      contents = NULL;\n    }\n\n  if (elf_dynverdef (abfd) != 0)\n    {\n      Elf_Internal_Shdr *hdr;\n      Elf_External_Verdef *everdef;\n      Elf_Internal_Verdef *iverdef;\n      Elf_Internal_Verdef *iverdefarr;\n      Elf_Internal_Verdef iverdefmem;\n      unsigned int i;\n      unsigned int maxidx;\n      bfd_byte *contents_end_def, *contents_end_aux;\n\n      hdr = &elf_tdata (abfd)->dynverdef_hdr;\n\n      if (hdr->sh_info == 0 || hdr->sh_size < sizeof (Elf_External_Verdef))\n\t{\n\terror_return_bad_verdef:\n\t  _bfd_error_handler\n\t    (_(\"%B: .gnu.version_d invalid entry\"), abfd);\n\t  bfd_set_error (bfd_error_bad_value);\n\terror_return_verdef:\n\t  elf_tdata (abfd)->verdef = NULL;\n\t  elf_tdata (abfd)->cverdefs = 0;\n\t  goto error_return;\n\t}\n\n      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);\n      if (contents == NULL)\n\tgoto error_return_verdef;\n      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n\t  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)\n\tgoto error_return_verdef;\n\n      BFD_ASSERT (sizeof (Elf_External_Verdef)\n\t\t  >= sizeof (Elf_External_Verdaux));\n      contents_end_def = contents + hdr->sh_size\n\t\t\t - sizeof (Elf_External_Verdef);\n      contents_end_aux = contents + hdr->sh_size\n\t\t\t - sizeof (Elf_External_Verdaux);\n\n      /* We know the number of entries in the section but not the maximum\n\t index.  Therefore we have to run through all entries and find\n\t the maximum.  */\n      everdef = (Elf_External_Verdef *) contents;\n      maxidx = 0;\n      for (i = 0; i < hdr->sh_info; ++i)\n\t{\n\t  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);\n\n\t  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) == 0)\n\t    goto error_return_bad_verdef;\n\t  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) > maxidx)\n\t    maxidx = iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION);\n\n\t  if (iverdefmem.vd_next == 0)\n\t    break;\n\n\t  if (iverdefmem.vd_next\n\t      > (size_t) (contents_end_def - (bfd_byte *) everdef))\n\t    goto error_return_bad_verdef;\n\n\t  everdef = ((Elf_External_Verdef *)\n\t\t     ((bfd_byte *) everdef + iverdefmem.vd_next));\n\t}\n\n      if (default_imported_symver)\n\t{\n\t  if (freeidx > maxidx)\n\t    maxidx = ++freeidx;\n\t  else\n\t    freeidx = ++maxidx;\n\t}\n\n      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n\tbfd_zalloc2 (abfd, maxidx, sizeof (Elf_Internal_Verdef));\n      if (elf_tdata (abfd)->verdef == NULL)\n\tgoto error_return_verdef;\n\n      elf_tdata (abfd)->cverdefs = maxidx;\n\n      everdef = (Elf_External_Verdef *) contents;\n      iverdefarr = elf_tdata (abfd)->verdef;\n      for (i = 0; i < hdr->sh_info; i++)\n\t{\n\t  Elf_External_Verdaux *everdaux;\n\t  Elf_Internal_Verdaux *iverdaux;\n\t  unsigned int j;\n\n\t  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);\n\n\t  if ((iverdefmem.vd_ndx & VERSYM_VERSION) == 0)\n\t    goto error_return_bad_verdef;\n\n\t  iverdef = &iverdefarr[(iverdefmem.vd_ndx & VERSYM_VERSION) - 1];\n\t  memcpy (iverdef, &iverdefmem, offsetof (Elf_Internal_Verdef, vd_bfd));\n\n\t  iverdef->vd_bfd = abfd;\n\n\t  if (iverdef->vd_cnt == 0)\n\t    iverdef->vd_auxptr = NULL;\n\t  else\n\t    {\n\t      iverdef->vd_auxptr = (struct elf_internal_verdaux *)\n                  bfd_alloc2 (abfd, iverdef->vd_cnt,\n                              sizeof (Elf_Internal_Verdaux));\n\t      if (iverdef->vd_auxptr == NULL)\n\t\tgoto error_return_verdef;\n\t    }\n\n\t  if (iverdef->vd_aux\n\t      > (size_t) (contents_end_aux - (bfd_byte *) everdef))\n\t    goto error_return_bad_verdef;\n\n\t  everdaux = ((Elf_External_Verdaux *)\n\t\t      ((bfd_byte *) everdef + iverdef->vd_aux));\n\t  iverdaux = iverdef->vd_auxptr;\n\t  for (j = 0; j < iverdef->vd_cnt; j++, iverdaux++)\n\t    {\n\t      _bfd_elf_swap_verdaux_in (abfd, everdaux, iverdaux);\n\n\t      iverdaux->vda_nodename =\n\t\tbfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t\t iverdaux->vda_name);\n\t      if (iverdaux->vda_nodename == NULL)\n\t\tgoto error_return_bad_verdef;\n\n\t      iverdaux->vda_nextptr = NULL;\n\t      if (iverdaux->vda_next == 0)\n\t\t{\n\t\t  iverdef->vd_cnt = j + 1;\n\t\t  break;\n\t\t}\n\t      if (j + 1 < iverdef->vd_cnt)\n\t\tiverdaux->vda_nextptr = iverdaux + 1;\n\n\t      if (iverdaux->vda_next\n\t\t  > (size_t) (contents_end_aux - (bfd_byte *) everdaux))\n\t\tgoto error_return_bad_verdef;\n\n\t      everdaux = ((Elf_External_Verdaux *)\n\t\t\t  ((bfd_byte *) everdaux + iverdaux->vda_next));\n\t    }\n\n\t  iverdef->vd_nodename = NULL;\n\t  if (iverdef->vd_cnt)\n\t    iverdef->vd_nodename = iverdef->vd_auxptr->vda_nodename;\n\n\t  iverdef->vd_nextdef = NULL;\n\t  if (iverdef->vd_next == 0)\n\t    break;\n\t  if ((size_t) (iverdef - iverdefarr) + 1 < maxidx)\n\t    iverdef->vd_nextdef = iverdef + 1;\n\n\t  everdef = ((Elf_External_Verdef *)\n\t\t     ((bfd_byte *) everdef + iverdef->vd_next));\n\t}\n\n      free (contents);\n      contents = NULL;\n    }\n  else if (default_imported_symver)\n    {\n      if (freeidx < 3)\n\tfreeidx = 3;\n      else\n\tfreeidx++;\n\n      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n          bfd_zalloc2 (abfd, freeidx, sizeof (Elf_Internal_Verdef));\n      if (elf_tdata (abfd)->verdef == NULL)\n\tgoto error_return;\n\n      elf_tdata (abfd)->cverdefs = freeidx;\n    }\n\n  /* Create a default version based on the soname.  */\n  if (default_imported_symver)\n    {\n      Elf_Internal_Verdef *iverdef;\n      Elf_Internal_Verdaux *iverdaux;\n\n      iverdef = &elf_tdata (abfd)->verdef[freeidx - 1];\n\n      iverdef->vd_version = VER_DEF_CURRENT;\n      iverdef->vd_flags = 0;\n      iverdef->vd_ndx = freeidx;\n      iverdef->vd_cnt = 1;\n\n      iverdef->vd_bfd = abfd;\n\n      iverdef->vd_nodename = bfd_elf_get_dt_soname (abfd);\n      if (iverdef->vd_nodename == NULL)\n\tgoto error_return_verdef;\n      iverdef->vd_nextdef = NULL;\n      iverdef->vd_auxptr = ((struct elf_internal_verdaux *)\n\t\t\t    bfd_zalloc (abfd, sizeof (Elf_Internal_Verdaux)));\n      if (iverdef->vd_auxptr == NULL)\n\tgoto error_return_verdef;\n\n      iverdaux = iverdef->vd_auxptr;\n      iverdaux->vda_nodename = iverdef->vd_nodename;\n    }\n\n  return TRUE;\n\n error_return:\n  if (contents != NULL)\n    free (contents);\n  return FALSE;\n}",
        "func_after": "bfd_boolean\n_bfd_elf_slurp_version_tables (bfd *abfd, bfd_boolean default_imported_symver)\n{\n  bfd_byte *contents = NULL;\n  unsigned int freeidx = 0;\n\n  if (elf_dynverref (abfd) != 0)\n    {\n      Elf_Internal_Shdr *hdr;\n      Elf_External_Verneed *everneed;\n      Elf_Internal_Verneed *iverneed;\n      unsigned int i;\n      bfd_byte *contents_end;\n\n      hdr = &elf_tdata (abfd)->dynverref_hdr;\n\n      if (hdr->sh_info == 0\n\t  || hdr->sh_info > hdr->sh_size / sizeof (Elf_External_Verneed))\n\t{\nerror_return_bad_verref:\n\t  _bfd_error_handler\n\t    (_(\"%B: .gnu.version_r invalid entry\"), abfd);\n\t  bfd_set_error (bfd_error_bad_value);\nerror_return_verref:\n\t  elf_tdata (abfd)->verref = NULL;\n\t  elf_tdata (abfd)->cverrefs = 0;\n\t  goto error_return;\n\t}\n\n      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);\n      if (contents == NULL)\n\tgoto error_return_verref;\n\n      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n\t  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)\n\tgoto error_return_verref;\n\n      elf_tdata (abfd)->verref = (Elf_Internal_Verneed *)\n\tbfd_alloc2 (abfd, hdr->sh_info, sizeof (Elf_Internal_Verneed));\n\n      if (elf_tdata (abfd)->verref == NULL)\n\tgoto error_return_verref;\n\n      BFD_ASSERT (sizeof (Elf_External_Verneed)\n\t\t  == sizeof (Elf_External_Vernaux));\n      contents_end = contents + hdr->sh_size - sizeof (Elf_External_Verneed);\n      everneed = (Elf_External_Verneed *) contents;\n      iverneed = elf_tdata (abfd)->verref;\n      for (i = 0; i < hdr->sh_info; i++, iverneed++)\n\t{\n\t  Elf_External_Vernaux *evernaux;\n\t  Elf_Internal_Vernaux *ivernaux;\n\t  unsigned int j;\n\n\t  _bfd_elf_swap_verneed_in (abfd, everneed, iverneed);\n\n\t  iverneed->vn_bfd = abfd;\n\n\t  iverneed->vn_filename =\n\t    bfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t     iverneed->vn_file);\n\t  if (iverneed->vn_filename == NULL)\n\t    goto error_return_bad_verref;\n\n\t  if (iverneed->vn_cnt == 0)\n\t    iverneed->vn_auxptr = NULL;\n\t  else\n\t    {\n\t      iverneed->vn_auxptr = (struct elf_internal_vernaux *)\n                  bfd_alloc2 (abfd, iverneed->vn_cnt,\n                              sizeof (Elf_Internal_Vernaux));\n\t      if (iverneed->vn_auxptr == NULL)\n\t\tgoto error_return_verref;\n\t    }\n\n\t  if (iverneed->vn_aux\n\t      > (size_t) (contents_end - (bfd_byte *) everneed))\n\t    goto error_return_bad_verref;\n\n\t  evernaux = ((Elf_External_Vernaux *)\n\t\t      ((bfd_byte *) everneed + iverneed->vn_aux));\n\t  ivernaux = iverneed->vn_auxptr;\n\t  for (j = 0; j < iverneed->vn_cnt; j++, ivernaux++)\n\t    {\n\t      _bfd_elf_swap_vernaux_in (abfd, evernaux, ivernaux);\n\n\t      ivernaux->vna_nodename =\n\t\tbfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t\t ivernaux->vna_name);\n\t      if (ivernaux->vna_nodename == NULL)\n\t\tgoto error_return_bad_verref;\n\n\t      if (ivernaux->vna_other > freeidx)\n\t\tfreeidx = ivernaux->vna_other;\n\n\t      ivernaux->vna_nextptr = NULL;\n\t      if (ivernaux->vna_next == 0)\n\t\t{\n\t\t  iverneed->vn_cnt = j + 1;\n\t\t  break;\n\t\t}\n\t      if (j + 1 < iverneed->vn_cnt)\n\t\tivernaux->vna_nextptr = ivernaux + 1;\n\n\t      if (ivernaux->vna_next\n\t\t  > (size_t) (contents_end - (bfd_byte *) evernaux))\n\t\tgoto error_return_bad_verref;\n\n\t      evernaux = ((Elf_External_Vernaux *)\n\t\t\t  ((bfd_byte *) evernaux + ivernaux->vna_next));\n\t    }\n\n\t  iverneed->vn_nextref = NULL;\n\t  if (iverneed->vn_next == 0)\n\t    break;\n\t  if (i + 1 < hdr->sh_info)\n\t    iverneed->vn_nextref = iverneed + 1;\n\n\t  if (iverneed->vn_next\n\t      > (size_t) (contents_end - (bfd_byte *) everneed))\n\t    goto error_return_bad_verref;\n\n\t  everneed = ((Elf_External_Verneed *)\n\t\t      ((bfd_byte *) everneed + iverneed->vn_next));\n\t}\n      elf_tdata (abfd)->cverrefs = i;\n\n      free (contents);\n      contents = NULL;\n    }\n\n  if (elf_dynverdef (abfd) != 0)\n    {\n      Elf_Internal_Shdr *hdr;\n      Elf_External_Verdef *everdef;\n      Elf_Internal_Verdef *iverdef;\n      Elf_Internal_Verdef *iverdefarr;\n      Elf_Internal_Verdef iverdefmem;\n      unsigned int i;\n      unsigned int maxidx;\n      bfd_byte *contents_end_def, *contents_end_aux;\n\n      hdr = &elf_tdata (abfd)->dynverdef_hdr;\n\n      if (hdr->sh_info == 0 || hdr->sh_size < sizeof (Elf_External_Verdef))\n\t{\n\terror_return_bad_verdef:\n\t  _bfd_error_handler\n\t    (_(\"%B: .gnu.version_d invalid entry\"), abfd);\n\t  bfd_set_error (bfd_error_bad_value);\n\terror_return_verdef:\n\t  elf_tdata (abfd)->verdef = NULL;\n\t  elf_tdata (abfd)->cverdefs = 0;\n\t  goto error_return;\n\t}\n\n      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);\n      if (contents == NULL)\n\tgoto error_return_verdef;\n      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n\t  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)\n\tgoto error_return_verdef;\n\n      BFD_ASSERT (sizeof (Elf_External_Verdef)\n\t\t  >= sizeof (Elf_External_Verdaux));\n      contents_end_def = contents + hdr->sh_size\n\t\t\t - sizeof (Elf_External_Verdef);\n      contents_end_aux = contents + hdr->sh_size\n\t\t\t - sizeof (Elf_External_Verdaux);\n\n      /* We know the number of entries in the section but not the maximum\n\t index.  Therefore we have to run through all entries and find\n\t the maximum.  */\n      everdef = (Elf_External_Verdef *) contents;\n      maxidx = 0;\n      for (i = 0; i < hdr->sh_info; ++i)\n\t{\n\t  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);\n\n\t  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) == 0)\n\t    goto error_return_bad_verdef;\n\t  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) > maxidx)\n\t    maxidx = iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION);\n\n\t  if (iverdefmem.vd_next == 0)\n\t    break;\n\n\t  if (iverdefmem.vd_next\n\t      > (size_t) (contents_end_def - (bfd_byte *) everdef))\n\t    goto error_return_bad_verdef;\n\n\t  everdef = ((Elf_External_Verdef *)\n\t\t     ((bfd_byte *) everdef + iverdefmem.vd_next));\n\t}\n\n      if (default_imported_symver)\n\t{\n\t  if (freeidx > maxidx)\n\t    maxidx = ++freeidx;\n\t  else\n\t    freeidx = ++maxidx;\n\t}\n\n      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n\tbfd_zalloc2 (abfd, maxidx, sizeof (Elf_Internal_Verdef));\n      if (elf_tdata (abfd)->verdef == NULL)\n\tgoto error_return_verdef;\n\n      elf_tdata (abfd)->cverdefs = maxidx;\n\n      everdef = (Elf_External_Verdef *) contents;\n      iverdefarr = elf_tdata (abfd)->verdef;\n      for (i = 0; i < hdr->sh_info; i++)\n\t{\n\t  Elf_External_Verdaux *everdaux;\n\t  Elf_Internal_Verdaux *iverdaux;\n\t  unsigned int j;\n\n\t  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);\n\n\t  if ((iverdefmem.vd_ndx & VERSYM_VERSION) == 0)\n\t    goto error_return_bad_verdef;\n\n\t  iverdef = &iverdefarr[(iverdefmem.vd_ndx & VERSYM_VERSION) - 1];\n\t  memcpy (iverdef, &iverdefmem, offsetof (Elf_Internal_Verdef, vd_bfd));\n\n\t  iverdef->vd_bfd = abfd;\n\n\t  if (iverdef->vd_cnt == 0)\n\t    iverdef->vd_auxptr = NULL;\n\t  else\n\t    {\n\t      iverdef->vd_auxptr = (struct elf_internal_verdaux *)\n                  bfd_alloc2 (abfd, iverdef->vd_cnt,\n                              sizeof (Elf_Internal_Verdaux));\n\t      if (iverdef->vd_auxptr == NULL)\n\t\tgoto error_return_verdef;\n\t    }\n\n\t  if (iverdef->vd_aux\n\t      > (size_t) (contents_end_aux - (bfd_byte *) everdef))\n\t    goto error_return_bad_verdef;\n\n\t  everdaux = ((Elf_External_Verdaux *)\n\t\t      ((bfd_byte *) everdef + iverdef->vd_aux));\n\t  iverdaux = iverdef->vd_auxptr;\n\t  for (j = 0; j < iverdef->vd_cnt; j++, iverdaux++)\n\t    {\n\t      _bfd_elf_swap_verdaux_in (abfd, everdaux, iverdaux);\n\n\t      iverdaux->vda_nodename =\n\t\tbfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t\t iverdaux->vda_name);\n\t      if (iverdaux->vda_nodename == NULL)\n\t\tgoto error_return_bad_verdef;\n\n\t      iverdaux->vda_nextptr = NULL;\n\t      if (iverdaux->vda_next == 0)\n\t\t{\n\t\t  iverdef->vd_cnt = j + 1;\n\t\t  break;\n\t\t}\n\t      if (j + 1 < iverdef->vd_cnt)\n\t\tiverdaux->vda_nextptr = iverdaux + 1;\n\n\t      if (iverdaux->vda_next\n\t\t  > (size_t) (contents_end_aux - (bfd_byte *) everdaux))\n\t\tgoto error_return_bad_verdef;\n\n\t      everdaux = ((Elf_External_Verdaux *)\n\t\t\t  ((bfd_byte *) everdaux + iverdaux->vda_next));\n\t    }\n\n\t  iverdef->vd_nodename = NULL;\n\t  if (iverdef->vd_cnt)\n\t    iverdef->vd_nodename = iverdef->vd_auxptr->vda_nodename;\n\n\t  iverdef->vd_nextdef = NULL;\n\t  if (iverdef->vd_next == 0)\n\t    break;\n\t  if ((size_t) (iverdef - iverdefarr) + 1 < maxidx)\n\t    iverdef->vd_nextdef = iverdef + 1;\n\n\t  everdef = ((Elf_External_Verdef *)\n\t\t     ((bfd_byte *) everdef + iverdef->vd_next));\n\t}\n\n      free (contents);\n      contents = NULL;\n    }\n  else if (default_imported_symver)\n    {\n      if (freeidx < 3)\n\tfreeidx = 3;\n      else\n\tfreeidx++;\n\n      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n          bfd_zalloc2 (abfd, freeidx, sizeof (Elf_Internal_Verdef));\n      if (elf_tdata (abfd)->verdef == NULL)\n\tgoto error_return;\n\n      elf_tdata (abfd)->cverdefs = freeidx;\n    }\n\n  /* Create a default version based on the soname.  */\n  if (default_imported_symver)\n    {\n      Elf_Internal_Verdef *iverdef;\n      Elf_Internal_Verdaux *iverdaux;\n\n      iverdef = &elf_tdata (abfd)->verdef[freeidx - 1];\n\n      iverdef->vd_version = VER_DEF_CURRENT;\n      iverdef->vd_flags = 0;\n      iverdef->vd_ndx = freeidx;\n      iverdef->vd_cnt = 1;\n\n      iverdef->vd_bfd = abfd;\n\n      iverdef->vd_nodename = bfd_elf_get_dt_soname (abfd);\n      if (iverdef->vd_nodename == NULL)\n\tgoto error_return_verdef;\n      iverdef->vd_nextdef = NULL;\n      iverdef->vd_auxptr = ((struct elf_internal_verdaux *)\n\t\t\t    bfd_zalloc (abfd, sizeof (Elf_Internal_Verdaux)));\n      if (iverdef->vd_auxptr == NULL)\n\tgoto error_return_verdef;\n\n      iverdaux = iverdef->vd_auxptr;\n      iverdaux->vda_nodename = iverdef->vd_nodename;\n    }\n\n  return TRUE;\n\n error_return:\n  if (contents != NULL)\n    free (contents);\n  return FALSE;\n}",
        "description": "The _bfd_elf_slurp_version_tables function in the BFD library, part of GNU Binutils 2.29, is susceptible to a denial of service attack. This vulnerability arises from excessive memory allocation when processing a specially crafted ELF file, leading to potential application crashes.",
        "commit": "The vulnerability involves a memory allocation issue within the ELF (Executable and Linkable Format) handling module of a binary file format library. Specifically, the code performs a sanity check on the size of the `SHT_GNU_verneed` section, ensuring it meets certain minimum requirements related to the number of version entries (`sh_info`). Additionally, since the code either fully initializes all fields of the version entries or exits with an error, there is no need to zero-initialize the allocated memory for these entries. The fix includes modifying the `_bfd_elf_slurp_version_tables` function to test the `sh_info` field of the `SHT_GNU_verneed` section for validity and to avoid zero-initializing the memory allocated for version references."
    },
    {
        "cwe": "CWE-20",
        "func_name": "libarchive/archive_read_format_iso9660_read_header",
        "score": 0.8372997045516968,
        "func_before": "static int\narchive_read_format_iso9660_read_header(struct archive_read *a,\n    struct archive_entry *entry)\n{\n\tstruct iso9660 *iso9660;\n\tstruct file_info *file;\n\tint r, rd_r = ARCHIVE_OK;\n\n\tiso9660 = (struct iso9660 *)(a->format->data);\n\n\tif (!a->archive.archive_format) {\n\t\ta->archive.archive_format = ARCHIVE_FORMAT_ISO9660;\n\t\ta->archive.archive_format_name = \"ISO9660\";\n\t}\n\n\tif (iso9660->current_position == 0) {\n\t\tr = choose_volume(a, iso9660);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t}\n\n\tfile = NULL;/* Eliminate a warning. */\n\t/* Get the next entry that appears after the current offset. */\n\tr = next_entry_seek(a, iso9660, &file);\n\tif (r != ARCHIVE_OK)\n\t\treturn (r);\n\n\tif (iso9660->seenJoliet) {\n\t\t/*\n\t\t * Convert UTF-16BE of a filename to local locale MBS\n\t\t * and store the result into a filename field.\n\t\t */\n\t\tif (iso9660->sconv_utf16be == NULL) {\n\t\t\tiso9660->sconv_utf16be =\n\t\t\t    archive_string_conversion_from_charset(\n\t\t\t\t&(a->archive), \"UTF-16BE\", 1);\n\t\t\tif (iso9660->sconv_utf16be == NULL)\n\t\t\t\t/* Coundn't allocate memory */\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif (iso9660->utf16be_path == NULL) {\n\t\t\tiso9660->utf16be_path = malloc(UTF16_NAME_MAX);\n\t\t\tif (iso9660->utf16be_path == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"No memory\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t}\n\t\tif (iso9660->utf16be_previous_path == NULL) {\n\t\t\tiso9660->utf16be_previous_path = malloc(UTF16_NAME_MAX);\n\t\t\tif (iso9660->utf16be_previous_path == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"No memory\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t}\n\n\t\tiso9660->utf16be_path_len = 0;\n\t\tif (build_pathname_utf16be(iso9660->utf16be_path,\n\t\t    UTF16_NAME_MAX, &(iso9660->utf16be_path_len), file) != 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Pathname is too long\");\n\t\t}\n\n\t\tr = archive_entry_copy_pathname_l(entry,\n\t\t    (const char *)iso9660->utf16be_path,\n\t\t    iso9660->utf16be_path_len,\n\t\t    iso9660->sconv_utf16be);\n\t\tif (r != 0) {\n\t\t\tif (errno == ENOMEM) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"No memory for Pathname\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Pathname cannot be converted \"\n\t\t\t    \"from %s to current locale.\",\n\t\t\t    archive_string_conversion_charset_name(\n\t\t\t      iso9660->sconv_utf16be));\n\n\t\t\trd_r = ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\tarchive_string_empty(&iso9660->pathname);\n\t\tarchive_entry_set_pathname(entry,\n\t\t    build_pathname(&iso9660->pathname, file));\n\t}\n\n\tiso9660->entry_bytes_remaining = file->size;\n\t/* Offset for sparse-file-aware clients. */\n\tiso9660->entry_sparse_offset = 0;\n\n\tif (file->offset + file->size > iso9660->volume_size) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"File is beyond end-of-media: %s\",\n\t\t    archive_entry_pathname(entry));\n\t\tiso9660->entry_bytes_remaining = 0;\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\t/* Set up the entry structure with information about this entry. */\n\tarchive_entry_set_mode(entry, file->mode);\n\tarchive_entry_set_uid(entry, file->uid);\n\tarchive_entry_set_gid(entry, file->gid);\n\tarchive_entry_set_nlink(entry, file->nlinks);\n\tif (file->birthtime_is_set)\n\t\tarchive_entry_set_birthtime(entry, file->birthtime, 0);\n\telse\n\t\tarchive_entry_unset_birthtime(entry);\n\tarchive_entry_set_mtime(entry, file->mtime, 0);\n\tarchive_entry_set_ctime(entry, file->ctime, 0);\n\tarchive_entry_set_atime(entry, file->atime, 0);\n\t/* N.B.: Rock Ridge supports 64-bit device numbers. */\n\tarchive_entry_set_rdev(entry, (dev_t)file->rdev);\n\tarchive_entry_set_size(entry, iso9660->entry_bytes_remaining);\n\tif (file->symlink.s != NULL)\n\t\tarchive_entry_copy_symlink(entry, file->symlink.s);\n\n\t/* Note: If the input isn't seekable, we can't rewind to\n\t * return the same body again, so if the next entry refers to\n\t * the same data, we have to return it as a hardlink to the\n\t * original entry. */\n\tif (file->number != -1 &&\n\t    file->number == iso9660->previous_number) {\n\t\tif (iso9660->seenJoliet) {\n\t\t\tr = archive_entry_copy_hardlink_l(entry,\n\t\t\t    (const char *)iso9660->utf16be_previous_path,\n\t\t\t    iso9660->utf16be_previous_path_len,\n\t\t\t    iso9660->sconv_utf16be);\n\t\t\tif (r != 0) {\n\t\t\t\tif (errno == ENOMEM) {\n\t\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t\t    \"No memory for Linkname\");\n\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t\t}\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Linkname cannot be converted \"\n\t\t\t\t    \"from %s to current locale.\",\n\t\t\t\t    archive_string_conversion_charset_name(\n\t\t\t\t      iso9660->sconv_utf16be));\n\t\t\t\trd_r = ARCHIVE_WARN;\n\t\t\t}\n\t\t} else\n\t\t\tarchive_entry_set_hardlink(entry,\n\t\t\t    iso9660->previous_pathname.s);\n\t\tarchive_entry_unset_size(entry);\n\t\tiso9660->entry_bytes_remaining = 0;\n\t\treturn (rd_r);\n\t}\n\n\tif ((file->mode & AE_IFMT) != AE_IFDIR &&\n\t    file->offset < iso9660->current_position) {\n\t\tint64_t r64;\n\n\t\tr64 = __archive_read_seek(a, file->offset, SEEK_SET);\n\t\tif (r64 != (int64_t)file->offset) {\n\t\t\t/* We can't seek backwards to extract it, so issue\n\t\t\t * a warning.  Note that this can only happen if\n\t\t\t * this entry was added to the heap after we passed\n\t\t\t * this offset, that is, only if the directory\n\t\t\t * mentioning this entry is later than the body of\n\t\t\t * the entry. Such layouts are very unusual; most\n\t\t\t * ISO9660 writers lay out and record all directory\n\t\t\t * information first, then store all file bodies. */\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Ignoring out-of-order file @%jx (%s) %jd < %jd\",\n\t\t\t    (intmax_t)file->number,\n\t\t\t    iso9660->pathname.s,\n\t\t\t    (intmax_t)file->offset,\n\t\t\t    (intmax_t)iso9660->current_position);\n\t\t\tiso9660->entry_bytes_remaining = 0;\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t\tiso9660->current_position = (uint64_t)r64;\n\t}\n\n\t/* Initialize zisofs variables. */\n\tiso9660->entry_zisofs.pz = file->pz;\n\tif (file->pz) {\n#ifdef HAVE_ZLIB_H\n\t\tstruct zisofs  *zisofs;\n\n\t\tzisofs = &iso9660->entry_zisofs;\n\t\tzisofs->initialized = 0;\n\t\tzisofs->pz_log2_bs = file->pz_log2_bs;\n\t\tzisofs->pz_uncompressed_size = file->pz_uncompressed_size;\n\t\tzisofs->pz_offset = 0;\n\t\tzisofs->header_avail = 0;\n\t\tzisofs->header_passed = 0;\n\t\tzisofs->block_pointers_avail = 0;\n#endif\n\t\tarchive_entry_set_size(entry, file->pz_uncompressed_size);\n\t}\n\n\tiso9660->previous_number = file->number;\n\tif (iso9660->seenJoliet) {\n\t\tmemcpy(iso9660->utf16be_previous_path, iso9660->utf16be_path,\n\t\t    iso9660->utf16be_path_len);\n\t\tiso9660->utf16be_previous_path_len = iso9660->utf16be_path_len;\n\t} else\n\t\tarchive_strcpy(\n\t\t    &iso9660->previous_pathname, iso9660->pathname.s);\n\n\t/* Reset entry_bytes_remaining if the file is multi extent. */\n\tiso9660->entry_content = file->contents.first;\n\tif (iso9660->entry_content != NULL)\n\t\tiso9660->entry_bytes_remaining = iso9660->entry_content->size;\n\n\tif (archive_entry_filetype(entry) == AE_IFDIR) {\n\t\t/* Overwrite nlinks by proper link number which is\n\t\t * calculated from number of sub directories. */\n\t\tarchive_entry_set_nlink(entry, 2 + file->subdirs);\n\t\t/* Directory data has been read completely. */\n\t\tiso9660->entry_bytes_remaining = 0;\n\t}\n\n\tif (rd_r != ARCHIVE_OK)\n\t\treturn (rd_r);\n\treturn (ARCHIVE_OK);\n}",
        "func_after": "static int\narchive_read_format_iso9660_read_header(struct archive_read *a,\n    struct archive_entry *entry)\n{\n\tstruct iso9660 *iso9660;\n\tstruct file_info *file;\n\tint r, rd_r = ARCHIVE_OK;\n\n\tiso9660 = (struct iso9660 *)(a->format->data);\n\n\tif (!a->archive.archive_format) {\n\t\ta->archive.archive_format = ARCHIVE_FORMAT_ISO9660;\n\t\ta->archive.archive_format_name = \"ISO9660\";\n\t}\n\n\tif (iso9660->current_position == 0) {\n\t\tr = choose_volume(a, iso9660);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t}\n\n\tfile = NULL;/* Eliminate a warning. */\n\t/* Get the next entry that appears after the current offset. */\n\tr = next_entry_seek(a, iso9660, &file);\n\tif (r != ARCHIVE_OK)\n\t\treturn (r);\n\n\tif (iso9660->seenJoliet) {\n\t\t/*\n\t\t * Convert UTF-16BE of a filename to local locale MBS\n\t\t * and store the result into a filename field.\n\t\t */\n\t\tif (iso9660->sconv_utf16be == NULL) {\n\t\t\tiso9660->sconv_utf16be =\n\t\t\t    archive_string_conversion_from_charset(\n\t\t\t\t&(a->archive), \"UTF-16BE\", 1);\n\t\t\tif (iso9660->sconv_utf16be == NULL)\n\t\t\t\t/* Coundn't allocate memory */\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif (iso9660->utf16be_path == NULL) {\n\t\t\tiso9660->utf16be_path = malloc(UTF16_NAME_MAX);\n\t\t\tif (iso9660->utf16be_path == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"No memory\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t}\n\t\tif (iso9660->utf16be_previous_path == NULL) {\n\t\t\tiso9660->utf16be_previous_path = malloc(UTF16_NAME_MAX);\n\t\t\tif (iso9660->utf16be_previous_path == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"No memory\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t}\n\n\t\tiso9660->utf16be_path_len = 0;\n\t\tif (build_pathname_utf16be(iso9660->utf16be_path,\n\t\t    UTF16_NAME_MAX, &(iso9660->utf16be_path_len), file) != 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Pathname is too long\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\n\t\tr = archive_entry_copy_pathname_l(entry,\n\t\t    (const char *)iso9660->utf16be_path,\n\t\t    iso9660->utf16be_path_len,\n\t\t    iso9660->sconv_utf16be);\n\t\tif (r != 0) {\n\t\t\tif (errno == ENOMEM) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"No memory for Pathname\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Pathname cannot be converted \"\n\t\t\t    \"from %s to current locale.\",\n\t\t\t    archive_string_conversion_charset_name(\n\t\t\t      iso9660->sconv_utf16be));\n\n\t\t\trd_r = ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\tconst char *path = build_pathname(&iso9660->pathname, file, 0);\n\t\tif (path == NULL) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Pathname is too long\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t} else {\n\t\t\tarchive_string_empty(&iso9660->pathname);\n\t\t\tarchive_entry_set_pathname(entry, path);\n\t\t}\n\t}\n\n\tiso9660->entry_bytes_remaining = file->size;\n\t/* Offset for sparse-file-aware clients. */\n\tiso9660->entry_sparse_offset = 0;\n\n\tif (file->offset + file->size > iso9660->volume_size) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"File is beyond end-of-media: %s\",\n\t\t    archive_entry_pathname(entry));\n\t\tiso9660->entry_bytes_remaining = 0;\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\t/* Set up the entry structure with information about this entry. */\n\tarchive_entry_set_mode(entry, file->mode);\n\tarchive_entry_set_uid(entry, file->uid);\n\tarchive_entry_set_gid(entry, file->gid);\n\tarchive_entry_set_nlink(entry, file->nlinks);\n\tif (file->birthtime_is_set)\n\t\tarchive_entry_set_birthtime(entry, file->birthtime, 0);\n\telse\n\t\tarchive_entry_unset_birthtime(entry);\n\tarchive_entry_set_mtime(entry, file->mtime, 0);\n\tarchive_entry_set_ctime(entry, file->ctime, 0);\n\tarchive_entry_set_atime(entry, file->atime, 0);\n\t/* N.B.: Rock Ridge supports 64-bit device numbers. */\n\tarchive_entry_set_rdev(entry, (dev_t)file->rdev);\n\tarchive_entry_set_size(entry, iso9660->entry_bytes_remaining);\n\tif (file->symlink.s != NULL)\n\t\tarchive_entry_copy_symlink(entry, file->symlink.s);\n\n\t/* Note: If the input isn't seekable, we can't rewind to\n\t * return the same body again, so if the next entry refers to\n\t * the same data, we have to return it as a hardlink to the\n\t * original entry. */\n\tif (file->number != -1 &&\n\t    file->number == iso9660->previous_number) {\n\t\tif (iso9660->seenJoliet) {\n\t\t\tr = archive_entry_copy_hardlink_l(entry,\n\t\t\t    (const char *)iso9660->utf16be_previous_path,\n\t\t\t    iso9660->utf16be_previous_path_len,\n\t\t\t    iso9660->sconv_utf16be);\n\t\t\tif (r != 0) {\n\t\t\t\tif (errno == ENOMEM) {\n\t\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t\t    \"No memory for Linkname\");\n\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t\t}\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Linkname cannot be converted \"\n\t\t\t\t    \"from %s to current locale.\",\n\t\t\t\t    archive_string_conversion_charset_name(\n\t\t\t\t      iso9660->sconv_utf16be));\n\t\t\t\trd_r = ARCHIVE_WARN;\n\t\t\t}\n\t\t} else\n\t\t\tarchive_entry_set_hardlink(entry,\n\t\t\t    iso9660->previous_pathname.s);\n\t\tarchive_entry_unset_size(entry);\n\t\tiso9660->entry_bytes_remaining = 0;\n\t\treturn (rd_r);\n\t}\n\n\tif ((file->mode & AE_IFMT) != AE_IFDIR &&\n\t    file->offset < iso9660->current_position) {\n\t\tint64_t r64;\n\n\t\tr64 = __archive_read_seek(a, file->offset, SEEK_SET);\n\t\tif (r64 != (int64_t)file->offset) {\n\t\t\t/* We can't seek backwards to extract it, so issue\n\t\t\t * a warning.  Note that this can only happen if\n\t\t\t * this entry was added to the heap after we passed\n\t\t\t * this offset, that is, only if the directory\n\t\t\t * mentioning this entry is later than the body of\n\t\t\t * the entry. Such layouts are very unusual; most\n\t\t\t * ISO9660 writers lay out and record all directory\n\t\t\t * information first, then store all file bodies. */\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Ignoring out-of-order file @%jx (%s) %jd < %jd\",\n\t\t\t    (intmax_t)file->number,\n\t\t\t    iso9660->pathname.s,\n\t\t\t    (intmax_t)file->offset,\n\t\t\t    (intmax_t)iso9660->current_position);\n\t\t\tiso9660->entry_bytes_remaining = 0;\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t\tiso9660->current_position = (uint64_t)r64;\n\t}\n\n\t/* Initialize zisofs variables. */\n\tiso9660->entry_zisofs.pz = file->pz;\n\tif (file->pz) {\n#ifdef HAVE_ZLIB_H\n\t\tstruct zisofs  *zisofs;\n\n\t\tzisofs = &iso9660->entry_zisofs;\n\t\tzisofs->initialized = 0;\n\t\tzisofs->pz_log2_bs = file->pz_log2_bs;\n\t\tzisofs->pz_uncompressed_size = file->pz_uncompressed_size;\n\t\tzisofs->pz_offset = 0;\n\t\tzisofs->header_avail = 0;\n\t\tzisofs->header_passed = 0;\n\t\tzisofs->block_pointers_avail = 0;\n#endif\n\t\tarchive_entry_set_size(entry, file->pz_uncompressed_size);\n\t}\n\n\tiso9660->previous_number = file->number;\n\tif (iso9660->seenJoliet) {\n\t\tmemcpy(iso9660->utf16be_previous_path, iso9660->utf16be_path,\n\t\t    iso9660->utf16be_path_len);\n\t\tiso9660->utf16be_previous_path_len = iso9660->utf16be_path_len;\n\t} else\n\t\tarchive_strcpy(\n\t\t    &iso9660->previous_pathname, iso9660->pathname.s);\n\n\t/* Reset entry_bytes_remaining if the file is multi extent. */\n\tiso9660->entry_content = file->contents.first;\n\tif (iso9660->entry_content != NULL)\n\t\tiso9660->entry_bytes_remaining = iso9660->entry_content->size;\n\n\tif (archive_entry_filetype(entry) == AE_IFDIR) {\n\t\t/* Overwrite nlinks by proper link number which is\n\t\t * calculated from number of sub directories. */\n\t\tarchive_entry_set_nlink(entry, 2 + file->subdirs);\n\t\t/* Directory data has been read completely. */\n\t\tiso9660->entry_bytes_remaining = 0;\n\t}\n\n\tif (rd_r != ARCHIVE_OK)\n\t\treturn (rd_r);\n\treturn (ARCHIVE_OK);\n}",
        "description": "bsdtar in libarchive versions prior to 3.2.0 is susceptible to a denial of service (infinite loop) caused by processing an ISO archive containing a directory that references itself.",
        "commit": "Issue #522: Malformed ISO files can lead to a segmentation fault due to excessive directory recursion. Specifically, the system can crash when assembling ISO paths through recursive directory traversal, reaching up to 130,000 directory levels. This vulnerability is addressed by implementing a limit on directory recursion to 1,000 elements. Future improvements should focus on detecting and tracking directory loops directly."
    },
    {
        "cwe": "CWE-444",
        "func_name": "haproxy/http_parse_cont_len_header",
        "score": 0.8145288228988647,
        "func_before": "int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\n\tword.ptr = value->ptr - 1; // -1 for next loop's pre-increment\n\te = value->ptr + value->len;\n\n\twhile (++word.ptr < e) {\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\t*body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}",
        "func_after": "int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\n\tword.ptr = value->ptr;\n\te = value->ptr + value->len;\n\n\twhile (1) {\n\t\tif (word.ptr >= e) {\n\t\t\t/* empty header or empty value */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr))) {\n\t\t\tword.ptr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\t*body_len = cl;\n\t\t*value = word;\n\n\t\t/* Now either n==e and we're done, or n points to the comma,\n\t\t * and we skip it and continue.\n\t\t */\n\t\tif (n++ == e)\n\t\t\tbreak;\n\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}",
        "description": "HAProxy versions up to 2.0.32, 2.1.x, 2.2.x through 2.2.30, 2.3.x, 2.4.x through 2.4.23, 2.5.x, and 2.6.x before 2.6.15, 2.7.x before 2.7.10, and 2.8.x before 2.8.2 forward empty Content-Length headers, which violates RFC 9110 section 8.6. In rare scenarios, an HTTP/1 server positioned behind HAProxy may misinterpret the payload as an additional request.",
        "commit": "A vulnerability was identified in the HTTP content-length header parsing mechanism, where an empty or trailing-comma value could be misinterpreted as an absent header. This oversight allowed such headers to pass through to the backend server without proper validation, potentially exposing vulnerable servers to attacks. The risk varies based on the backend server's handling of content-length headers, but users relying on HAProxy to protect known-vulnerable servers are particularly at risk. A configuration-based workaround involves explicitly rejecting requests with empty content-length headers in the frontend settings. The permanent fix requires modifying the parser to ensure that only valid values are accepted, rejecting any empty values encountered. This change needs to be applied across all supported versions of the software. The modifications were made to functions such as `h1_parse_cont_len_header()` and `http_parse_cont_len_header()`, with additional considerations for compatibility with Lua and future deprecation plans. Comprehensive testing was conducted to validate these changes."
    }
]