[
    {
        "cwe": "CWE-120",
        "func_name": "ClusterLabs/_blackbox_vlogger",
        "score": 0.7340266108512878,
        "func_before": "static void\n_blackbox_vlogger(int32_t target,\n\t\t  struct qb_log_callsite *cs, struct timespec *timestamp, va_list ap)\n{\n\tsize_t max_size;\n\tsize_t actual_size;\n\tuint32_t fn_size;\n\tchar *chunk;\n\tchar *msg_len_pt;\n\tuint32_t msg_len;\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\n\tif (t->instance == NULL) {\n\t\treturn;\n\t}\n\n\tfn_size = strlen(cs->function) + 1;\n\n\tactual_size = 4 * sizeof(uint32_t) + sizeof(uint8_t) + fn_size + sizeof(struct timespec);\n\tmax_size = actual_size + t->max_line_length;\n\n\tchunk = qb_rb_chunk_alloc(t->instance, max_size);\n\n\tif (chunk == NULL) {\n\t\t/* something bad has happened. abort blackbox logging */\n\t\tqb_util_perror(LOG_ERR, \"Blackbox allocation error, aborting blackbox log %s\", t->filename);\n\t\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t\t(struct qb_ringbuffer_s **) &t->instance\n\t\t));\n\t\treturn;\n\t}\n\n\t/* line number */\n\tmemcpy(chunk, &cs->lineno, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* tags */\n\tmemcpy(chunk, &cs->tags, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* log level/priority */\n\tmemcpy(chunk, &cs->priority, sizeof(uint8_t));\n\tchunk += sizeof(uint8_t);\n\n\t/* function name */\n\tmemcpy(chunk, &fn_size, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, cs->function, fn_size);\n\tchunk += fn_size;\n\n\t/* timestamp */\n\tmemcpy(chunk, timestamp, sizeof(struct timespec));\n\tchunk += sizeof(struct timespec);\n\n\t/* log message length */\n\tmsg_len_pt = chunk;\n\tchunk += sizeof(uint32_t);\n\n\t/* log message */\n\tmsg_len = qb_vsnprintf_serialize(chunk, max_size, cs->format, ap);\n\tif (msg_len >= max_size) {\n\t    chunk = msg_len_pt + sizeof(uint32_t); /* Reset */\n\n\t    /* Leave this at QB_LOG_MAX_LEN so as not to overflow the blackbox */\n\t    msg_len = qb_vsnprintf_serialize(chunk, QB_LOG_MAX_LEN,\n\t\t\"Log message too long to be stored in the blackbox.  \"\\\n\t\t\"Maximum is QB_LOG_MAX_LEN\" , ap);\n\t}\n\n\tactual_size += msg_len;\n\n\t/* now that we know the length, write it\n\t */\n\tmemcpy(msg_len_pt, &msg_len, sizeof(uint32_t));\n\n\t(void)qb_rb_chunk_commit(t->instance, actual_size);\n}",
        "func_after": "static void\n_blackbox_vlogger(int32_t target,\n\t\t  struct qb_log_callsite *cs, struct timespec *timestamp, va_list ap)\n{\n\tsize_t max_size;\n\tsize_t actual_size;\n\tuint32_t fn_size;\n\tchar *chunk;\n\tchar *msg_len_pt;\n\tuint32_t msg_len;\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\n\tif (t->instance == NULL) {\n\t\treturn;\n\t}\n\n\tfn_size = strlen(cs->function) + 1;\n\n\tactual_size = 4 * sizeof(uint32_t) + sizeof(uint8_t) + fn_size + sizeof(struct timespec);\n\tmax_size = actual_size + t->max_line_length;\n\n\tchunk = qb_rb_chunk_alloc(t->instance, max_size);\n\n\tif (chunk == NULL) {\n\t\t/* something bad has happened. abort blackbox logging */\n\t\tqb_util_perror(LOG_ERR, \"Blackbox allocation error, aborting blackbox log %s\", t->filename);\n\t\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t\t(struct qb_ringbuffer_s **) &t->instance\n\t\t));\n\t\treturn;\n\t}\n\n\t/* line number */\n\tmemcpy(chunk, &cs->lineno, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* tags */\n\tmemcpy(chunk, &cs->tags, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* log level/priority */\n\tmemcpy(chunk, &cs->priority, sizeof(uint8_t));\n\tchunk += sizeof(uint8_t);\n\n\t/* function name */\n\tmemcpy(chunk, &fn_size, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, cs->function, fn_size);\n\tchunk += fn_size;\n\n\t/* timestamp */\n\tmemcpy(chunk, timestamp, sizeof(struct timespec));\n\tchunk += sizeof(struct timespec);\n\n\t/* log message length */\n\tmsg_len_pt = chunk;\n\tchunk += sizeof(uint32_t);\n\n\t/* log message */\n\tmsg_len = qb_vsnprintf_serialize(chunk, t->max_line_length, cs->format, ap);\n\tif (msg_len >= t->max_line_length) {\n\t    chunk = msg_len_pt + sizeof(uint32_t); /* Reset */\n\n\t    /* Leave this at QB_LOG_MAX_LEN so as not to overflow the blackbox */\n\t    msg_len = qb_vsnprintf_serialize(chunk, QB_LOG_MAX_LEN,\n\t\t\"Log message too long to be stored in the blackbox.  \"\\\n\t\t\"Maximum is QB_LOG_MAX_LEN\" , ap);\n\t}\n\n\tactual_size += msg_len;\n\n\t/* now that we know the length, write it\n\t */\n\tmemcpy(msg_len_pt, &msg_len, sizeof(uint32_t));\n\n\t(void)qb_rb_chunk_commit(t->instance, actual_size);\n}",
        "description": "log_blackbox.c in libqb prior to version 2.0.8 is susceptible to a buffer overflow due to the neglect of considering the header size when processing long log messages.",
        "commit": "The vulnerability knowledge has been abstracted and generalized as follows:\n\n\"A function responsible for serializing log messages potentially suffers from an overflow issue due to improper buffer size calculation. The original implementation used 'max_size' to limit the length of the formatted log message, but failed to account for the additional space required for the log header ('actual_size'). This oversight has been corrected by adjusting the maximum length parameter to 't->max_line_length', ensuring it accurately reflects the remaining buffer space. Additionally, error checks have been introduced to the blackbox calls at the end of the test to ensure proper functionality and to prevent masking of failures.\""
    },
    {
        "cwe": "CWE-287",
        "func_name": "torvalds/ieee80211_change_station",
        "score": 0.7353493571281433,
        "func_before": "static int ieee80211_change_station(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *dev, const u8 *mac,\n\t\t\t\t    struct station_parameters *params)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct sta_info *sta;\n\tstruct ieee80211_sub_if_data *vlansdata;\n\tenum cfg80211_station_type statype;\n\tint err;\n\n\tmutex_lock(&local->sta_mtx);\n\n\tsta = sta_info_get_bss(sdata, mac);\n\tif (!sta) {\n\t\terr = -ENOENT;\n\t\tgoto out_err;\n\t}\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (sdata->u.mesh.user_mpm)\n\t\t\tstatype = CFG80211_STA_MESH_PEER_USER;\n\t\telse\n\t\t\tstatype = CFG80211_STA_MESH_PEER_KERNEL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tstatype = CFG80211_STA_IBSS;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (!test_sta_flag(sta, WLAN_STA_TDLS_PEER)) {\n\t\t\tstatype = CFG80211_STA_AP_STA;\n\t\t\tbreak;\n\t\t}\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tstatype = CFG80211_STA_TDLS_PEER_ACTIVE;\n\t\telse\n\t\t\tstatype = CFG80211_STA_TDLS_PEER_SETUP;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (test_sta_flag(sta, WLAN_STA_ASSOC))\n\t\t\tstatype = CFG80211_STA_AP_CLIENT;\n\t\telse\n\t\t\tstatype = CFG80211_STA_AP_CLIENT_UNASSOC;\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\terr = cfg80211_check_station_change(wiphy, params, statype);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (params->vlan && params->vlan != sta->sdata->dev) {\n\t\tvlansdata = IEEE80211_DEV_TO_SUB_IF(params->vlan);\n\n\t\tif (params->vlan->ieee80211_ptr->use_4addr) {\n\t\t\tif (vlansdata->u.vlan.sta) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\trcu_assign_pointer(vlansdata->u.vlan.sta, sta);\n\t\t\t__ieee80211_check_fast_rx_iface(vlansdata);\n\t\t}\n\n\t\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t\t    sta->sdata->u.vlan.sta)\n\t\t\tRCU_INIT_POINTER(sta->sdata->u.vlan.sta, NULL);\n\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tieee80211_vif_dec_num_mcast(sta->sdata);\n\n\t\tsta->sdata = vlansdata;\n\t\tieee80211_check_fast_xmit(sta);\n\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tieee80211_vif_inc_num_mcast(sta->sdata);\n\n\t\tcfg80211_send_layer2_update(sta->sdata->dev, sta->sta.addr);\n\t}\n\n\terr = sta_apply_parameters(local, sta, params);\n\tif (err)\n\t\tgoto out_err;\n\n\tmutex_unlock(&local->sta_mtx);\n\n\tif ((sdata->vif.type == NL80211_IFTYPE_AP ||\n\t     sdata->vif.type == NL80211_IFTYPE_AP_VLAN) &&\n\t    sta->known_smps_mode != sta->sdata->bss->req_smps &&\n\t    test_sta_flag(sta, WLAN_STA_AUTHORIZED) &&\n\t    sta_info_tx_streams(sta) != 1) {\n\t\tht_dbg(sta->sdata,\n\t\t       \"%pM just authorized and MIMO capable - update SMPS\\n\",\n\t\t       sta->sta.addr);\n\t\tieee80211_send_smps_action(sta->sdata,\n\t\t\tsta->sdata->bss->req_smps,\n\t\t\tsta->sta.addr,\n\t\t\tsta->sdata->vif.bss_conf.bssid);\n\t}\n\n\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t    params->sta_flags_mask & BIT(NL80211_STA_FLAG_AUTHORIZED)) {\n\t\tieee80211_recalc_ps(local);\n\t\tieee80211_recalc_ps_vif(sdata);\n\t}\n\n\treturn 0;\nout_err:\n\tmutex_unlock(&local->sta_mtx);\n\treturn err;\n}",
        "func_after": "static int ieee80211_change_station(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *dev, const u8 *mac,\n\t\t\t\t    struct station_parameters *params)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct sta_info *sta;\n\tstruct ieee80211_sub_if_data *vlansdata;\n\tenum cfg80211_station_type statype;\n\tint err;\n\n\tmutex_lock(&local->sta_mtx);\n\n\tsta = sta_info_get_bss(sdata, mac);\n\tif (!sta) {\n\t\terr = -ENOENT;\n\t\tgoto out_err;\n\t}\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (sdata->u.mesh.user_mpm)\n\t\t\tstatype = CFG80211_STA_MESH_PEER_USER;\n\t\telse\n\t\t\tstatype = CFG80211_STA_MESH_PEER_KERNEL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tstatype = CFG80211_STA_IBSS;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (!test_sta_flag(sta, WLAN_STA_TDLS_PEER)) {\n\t\t\tstatype = CFG80211_STA_AP_STA;\n\t\t\tbreak;\n\t\t}\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tstatype = CFG80211_STA_TDLS_PEER_ACTIVE;\n\t\telse\n\t\t\tstatype = CFG80211_STA_TDLS_PEER_SETUP;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (test_sta_flag(sta, WLAN_STA_ASSOC))\n\t\t\tstatype = CFG80211_STA_AP_CLIENT;\n\t\telse\n\t\t\tstatype = CFG80211_STA_AP_CLIENT_UNASSOC;\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\terr = cfg80211_check_station_change(wiphy, params, statype);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (params->vlan && params->vlan != sta->sdata->dev) {\n\t\tvlansdata = IEEE80211_DEV_TO_SUB_IF(params->vlan);\n\n\t\tif (params->vlan->ieee80211_ptr->use_4addr) {\n\t\t\tif (vlansdata->u.vlan.sta) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\trcu_assign_pointer(vlansdata->u.vlan.sta, sta);\n\t\t\t__ieee80211_check_fast_rx_iface(vlansdata);\n\t\t}\n\n\t\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t\t    sta->sdata->u.vlan.sta)\n\t\t\tRCU_INIT_POINTER(sta->sdata->u.vlan.sta, NULL);\n\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tieee80211_vif_dec_num_mcast(sta->sdata);\n\n\t\tsta->sdata = vlansdata;\n\t\tieee80211_check_fast_xmit(sta);\n\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED)) {\n\t\t\tieee80211_vif_inc_num_mcast(sta->sdata);\n\t\t\tcfg80211_send_layer2_update(sta->sdata->dev,\n\t\t\t\t\t\t    sta->sta.addr);\n\t\t}\n\t}\n\n\terr = sta_apply_parameters(local, sta, params);\n\tif (err)\n\t\tgoto out_err;\n\n\tmutex_unlock(&local->sta_mtx);\n\n\tif ((sdata->vif.type == NL80211_IFTYPE_AP ||\n\t     sdata->vif.type == NL80211_IFTYPE_AP_VLAN) &&\n\t    sta->known_smps_mode != sta->sdata->bss->req_smps &&\n\t    test_sta_flag(sta, WLAN_STA_AUTHORIZED) &&\n\t    sta_info_tx_streams(sta) != 1) {\n\t\tht_dbg(sta->sdata,\n\t\t       \"%pM just authorized and MIMO capable - update SMPS\\n\",\n\t\t       sta->sta.addr);\n\t\tieee80211_send_smps_action(sta->sdata,\n\t\t\tsta->sdata->bss->req_smps,\n\t\t\tsta->sta.addr,\n\t\t\tsta->sdata->vif.bss_conf.bssid);\n\t}\n\n\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t    params->sta_flags_mask & BIT(NL80211_STA_FLAG_AUTHORIZED)) {\n\t\tieee80211_recalc_ps(local);\n\t\tieee80211_recalc_ps_vif(sdata);\n\t}\n\n\treturn 0;\nout_err:\n\tmutex_unlock(&local->sta_mtx);\n\treturn err;\n}",
        "description": "An exploitable denial-of-service vulnerability exists in the Linux kernel prior to version 5.3. An attacker can exploit this vulnerability by inducing Access Points (APs) to send Inter-Access Point Protocol (IAPP) location updates for stations before the necessary authentication process is complete. This could result in various denial-of-service scenarios, including CAM table attacks or traffic flapping if the attacker impersonates existing clients in neighboring APs within the same wireless infrastructure. The attacker can achieve this by forging Authentication and Association Request packets.",
        "commit": "The Layer 2 Update frame is utilized to notify bridges of a station's movement to a new Access Point (AP), even if the station does not transmit any frames afterward. According to IEEE Std 802.11F-2003, this update should occur based on the MLME-ASSOCIATE.indication, which happens before the completion of the 4-way handshake. However, this standard predates the introduction of Robust Security Network (RSN) protocols (IEEE Std 802.11i-2004) and thus does not account for RSN use cases. Additionally, the IEEE Std 802.11F-2003 was withdrawn in 2006 and should no longer be used.\n\nTransmitting the Layer 2 Update frame immediately after association is acceptable for open networks and certain authentication methods like SAE, FT protocol, or FILS, where the station is authenticated by the time association completes. However, it is inappropriate for RSN with PSK or EAP authentication, as full authentication occurs only after the 4-way handshake. Attackers could exploit the premature transmission of the Layer 2 Update frame to disrupt bridge behavior.\n\nTo address this issue, the transmission of the Layer 2 Update frame should be postponed until the station entry is marked as authorized. Similarly, VLAN binding updates should only be sent if the station entry has been authorized."
    },
    {
        "cwe": "CWE-532",
        "func_name": "torvalds/klsi_105_get_line_state",
        "score": 0.7118738293647766,
        "func_before": "static int klsi_105_get_line_state(struct usb_serial_port *port,\n\t\t\t\t   unsigned long *line_state_p)\n{\n\tint rc;\n\tu8 *status_buf;\n\t__u16 status;\n\n\tdev_info(&port->serial->dev->dev, \"sending SIO Poll request\\n\");\n\n\tstatus_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);\n\tif (!status_buf)\n\t\treturn -ENOMEM;\n\n\tstatus_buf[0] = 0xff;\n\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, /* value */\n\t\t\t     0, /* index */\n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc < 0)\n\t\tdev_err(&port->dev, \"Reading line status failed (error = %d)\\n\",\n\t\t\trc);\n\telse {\n\t\tstatus = get_unaligned_le16(status_buf);\n\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\n\tkfree(status_buf);\n\treturn rc;\n}",
        "func_after": "static int klsi_105_get_line_state(struct usb_serial_port *port,\n\t\t\t\t   unsigned long *line_state_p)\n{\n\tint rc;\n\tu8 *status_buf;\n\t__u16 status;\n\n\tdev_info(&port->serial->dev->dev, \"sending SIO Poll request\\n\");\n\n\tstatus_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);\n\tif (!status_buf)\n\t\treturn -ENOMEM;\n\n\tstatus_buf[0] = 0xff;\n\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, /* value */\n\t\t\t     0, /* index */\n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc != KLSI_STATUSBUF_LEN) {\n\t\tdev_err(&port->dev, \"reading line status failed: %d\\n\", rc);\n\t\tif (rc >= 0)\n\t\t\trc = -EIO;\n\t} else {\n\t\tstatus = get_unaligned_le16(status_buf);\n\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\n\tkfree(status_buf);\n\treturn rc;\n}",
        "description": "The `klsi_105_get_line_state` function in the Linux kernel's USB serial driver, prior to version 4.9.5, includes uninitialized heap memory content in a log entry when failing to read the line status. This flaw enables local users to extract sensitive information by accessing the log.",
        "commit": "The current implementation of the USB serial driver for the KL5KUSB105 device fails to properly detect short data transfers during attempts to read the line state. Additionally, it logs the contents of an uninitialized heap transfer buffer, which could lead to unintended information disclosure."
    },
    {
        "cwe": "CWE-295",
        "func_name": "gobby/inf_gtk_certificate_manager_certificate_func",
        "score": 0.7344986200332642,
        "func_before": "static void\ninf_gtk_certificate_manager_certificate_func(InfXmppConnection* connection,\n                                             gnutls_session_t session,\n                                             InfCertificateChain* chain,\n                                             gpointer user_data)\n{\n  InfGtkCertificateManager* manager;\n  InfGtkCertificateManagerPrivate* priv;\n\n  InfGtkCertificateDialogFlags flags;\n  gnutls_x509_crt_t presented_cert;\n  gnutls_x509_crt_t known_cert;\n  gchar* hostname;\n\n  gboolean match_hostname;\n  gboolean issuer_known;\n  gnutls_x509_crt_t root_cert;\n\n  int ret;\n  unsigned int verify;\n  GHashTable* table;\n  gboolean cert_equal;\n  time_t expiration_time;\n\n  InfGtkCertificateManagerQuery* query;\n  gchar* text;\n  GtkWidget* vbox;\n  GtkWidget* label;\n\n  GError* error;\n\n  manager = INF_GTK_CERTIFICATE_MANAGER(user_data);\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  g_object_get(G_OBJECT(connection), \"remote-hostname\", &hostname, NULL);\n  presented_cert = inf_certificate_chain_get_own_certificate(chain);\n\n  match_hostname = gnutls_x509_crt_check_hostname(presented_cert, hostname);\n\n  /* First, validate the certificate */\n  ret = gnutls_certificate_verify_peers2(session, &verify);\n  error = NULL;\n\n  if(ret != GNUTLS_E_SUCCESS)\n    inf_gnutls_set_error(&error, ret);\n\n  /* Remove the GNUTLS_CERT_ISSUER_NOT_KNOWN flag from the verification\n   * result, and if the certificate is still invalid, then set an error. */\n  if(error == NULL)\n  {\n    issuer_known = TRUE;\n    if(verify & GNUTLS_CERT_SIGNER_NOT_FOUND)\n    {\n      issuer_known = FALSE;\n\n      /* Re-validate the certificate for other failure reasons --\n       * unfortunately the gnutls_certificate_verify_peers2() call\n       * does not tell us whether the certificate is otherwise invalid\n       * if a signer is not found already. */\n      /* TODO: Here it would be good to use the verify flags from the\n       * certificate credentials, but GnuTLS does not have API to\n       * retrieve them. */\n      root_cert = inf_certificate_chain_get_root_certificate(chain);\n\n      ret = gnutls_x509_crt_list_verify(\n        inf_certificate_chain_get_raw(chain),\n        inf_certificate_chain_get_n_certificates(chain),\n        &root_cert,\n        1,\n        NULL,\n        0,\n        GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT,\n        &verify\n      );\n\n      if(ret != GNUTLS_E_SUCCESS)\n        inf_gnutls_set_error(&error, ret);\n      else if(verify & GNUTLS_CERT_INVALID)\n        inf_gnutls_certificate_verification_set_error(&error, verify);\n    }\n  }\n\n  /* Look up the host in our database of pinned certificates if we could not\n   * fully verify the certificate, i.e. if either the issuer is not known or\n   * the hostname of the connection does not match the certificate. */\n  table = NULL;\n  if(error == NULL)\n  {\n    known_cert = NULL;\n    if(!match_hostname || !issuer_known)\n    {\n      /* If we cannot load the known host file, then cancel the connection.\n       * Otherwise it might happen that someone shows us a certificate that we\n       * tell the user we don't know, if though actually for that host we expect\n       * a different certificate. */\n      table = inf_gtk_certificate_manager_ref_known_hosts(manager, &error);\n      if(table != NULL)\n        known_cert = g_hash_table_lookup(table, hostname);\n    }\n  }\n\n  /* Next, configure the flags for the dialog to be shown based on the\n   * verification result, and on whether the pinned certificate matches\n   * the one presented by the host or not. */\n  flags = 0;\n  if(error == NULL)\n  {\n    if(known_cert != NULL)\n    {\n      cert_equal = inf_gtk_certificate_manager_compare_fingerprint(\n        known_cert,\n        presented_cert,\n        &error\n      );\n\n      if(error == NULL && cert_equal == FALSE)\n      {\n        if(!match_hostname)\n          flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;\n        if(!issuer_known)\n          flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;\n\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_UNEXPECTED;\n        expiration_time = gnutls_x509_crt_get_expiration_time(known_cert);\n        if(expiration_time != (time_t)(-1))\n        {\n          expiration_time -= INF_GTK_CERTIFICATE_MANAGER_EXPIRATION_TOLERANCE;\n          if(time(NULL) > expiration_time)\n          {\n            flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_OLD_EXPIRED;\n          }\n        }\n      }\n    }\n    else\n    {\n      if(!match_hostname)\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;\n      if(!issuer_known)\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;\n    }\n  }\n\n  /* Now proceed either by accepting the connection, rejecting it, or\n   * bothering the user with an annoying dialog. */\n  if(error == NULL)\n  {\n    if(flags == 0)\n    {\n      if(match_hostname && issuer_known)\n      {\n        /* Remove the pinned entry if we now have a valid certificate for\n         * this host. */\n        if(table != NULL && g_hash_table_remove(table, hostname) == TRUE)\n        {\n          inf_gtk_certificate_manager_write_known_hosts_with_warning(\n            manager,\n            table\n          );\n        }\n      }\n\n      inf_xmpp_connection_certificate_verify_continue(connection);\n    }\n    else\n    {\n      query = g_slice_new(InfGtkCertificateManagerQuery);\n      query->manager = manager;\n      query->known_hosts = table;\n      query->connection = connection;\n      query->dialog = inf_gtk_certificate_dialog_new(\n        priv->parent_window,\n        0,\n        flags,\n        hostname,\n        chain\n      );\n      query->certificate_chain = chain;\n\n      table = NULL;\n\n      g_object_ref(query->connection);\n      inf_certificate_chain_ref(chain);\n\n      g_signal_connect(\n        G_OBJECT(connection),\n        \"notify::status\",\n        G_CALLBACK(inf_gtk_certificate_manager_notify_status_cb),\n        query\n      );\n\n      g_signal_connect(\n        G_OBJECT(query->dialog),\n        \"response\",\n        G_CALLBACK(inf_gtk_certificate_manager_response_cb),\n        query\n      );\n\n      gtk_dialog_add_button(\n        GTK_DIALOG(query->dialog),\n        _(\"_Cancel connection\"),\n        GTK_RESPONSE_REJECT\n      );\n\n      gtk_dialog_add_button(\n        GTK_DIALOG(query->dialog),\n        _(\"C_ontinue connection\"),\n        GTK_RESPONSE_ACCEPT\n      );\n\n      text = g_strdup_printf(\n        _(\"Do you want to continue the connection to host \\\"%s\\\"? If you \"\n          \"choose to continue, this certificate will be trusted in the \"\n          \"future when connecting to this host.\"),\n        hostname\n      );\n\n      label = gtk_label_new(text);\n      gtk_label_set_line_wrap(GTK_LABEL(label), TRUE);\n      gtk_label_set_line_wrap_mode(GTK_LABEL(label), PANGO_WRAP_WORD_CHAR);\n      gtk_label_set_max_width_chars(GTK_LABEL(label), 60);\n      gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.0);\n      gtk_widget_show(label);\n      g_free(text);\n\n      vbox = gtk_dialog_get_content_area(GTK_DIALOG(query->dialog));\n      gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 0);\n\n      priv->queries = g_slist_prepend(priv->queries, query);\n      gtk_window_present(GTK_WINDOW(query->dialog));\n    }\n  }\n  else\n  {\n    inf_xmpp_connection_certificate_verify_cancel(connection, error);\n    g_error_free(error);\n  }\n\n  if(table != NULL) g_hash_table_unref(table);\n  g_free(hostname);\n}",
        "func_after": "static void\ninf_gtk_certificate_manager_certificate_func(InfXmppConnection* connection,\n                                             gnutls_session_t session,\n                                             InfCertificateChain* chain,\n                                             gpointer user_data)\n{\n  InfGtkCertificateManager* manager;\n  InfGtkCertificateManagerPrivate* priv;\n\n  InfGtkCertificateDialogFlags flags;\n  gnutls_x509_crt_t presented_cert;\n  gnutls_x509_crt_t known_cert;\n  gchar* hostname;\n\n  gboolean match_hostname;\n  gboolean issuer_known;\n  gnutls_x509_crt_t root_cert;\n\n  int ret;\n  unsigned int verify;\n  GHashTable* table;\n  gboolean cert_equal;\n  time_t expiration_time;\n\n  InfGtkCertificateManagerQuery* query;\n  gchar* text;\n  GtkWidget* vbox;\n  GtkWidget* label;\n\n  GError* error;\n\n  manager = INF_GTK_CERTIFICATE_MANAGER(user_data);\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  g_object_get(G_OBJECT(connection), \"remote-hostname\", &hostname, NULL);\n  presented_cert = inf_certificate_chain_get_own_certificate(chain);\n\n  match_hostname = gnutls_x509_crt_check_hostname(presented_cert, hostname);\n\n  /* First, validate the certificate */\n  ret = gnutls_certificate_verify_peers2(session, &verify);\n  error = NULL;\n\n  if(ret != GNUTLS_E_SUCCESS)\n    inf_gnutls_set_error(&error, ret);\n\n  /* Remove the GNUTLS_CERT_ISSUER_NOT_KNOWN flag from the verification\n   * result, and if the certificate is still invalid, then set an error. */\n  if(error == NULL)\n  {\n    issuer_known = TRUE;\n    if(verify & GNUTLS_CERT_SIGNER_NOT_FOUND)\n    {\n      issuer_known = FALSE;\n\n      /* Re-validate the certificate for other failure reasons --\n       * unfortunately the gnutls_certificate_verify_peers2() call\n       * does not tell us whether the certificate is otherwise invalid\n       * if a signer is not found already. */\n      /* TODO: Here it would be good to use the verify flags from the\n       * certificate credentials, but GnuTLS does not have API to\n       * retrieve them. */\n      root_cert = inf_certificate_chain_get_root_certificate(chain);\n\n      ret = gnutls_x509_crt_list_verify(\n        inf_certificate_chain_get_raw(chain),\n        inf_certificate_chain_get_n_certificates(chain),\n        &root_cert,\n        1,\n        NULL,\n        0,\n        GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT,\n        &verify\n      );\n\n      if(ret != GNUTLS_E_SUCCESS)\n        inf_gnutls_set_error(&error, ret);\n    }\n\n    if(error == NULL)\n      if(verify & GNUTLS_CERT_INVALID)\n        inf_gnutls_certificate_verification_set_error(&error, verify);\n  }\n\n  /* Look up the host in our database of pinned certificates if we could not\n   * fully verify the certificate, i.e. if either the issuer is not known or\n   * the hostname of the connection does not match the certificate. */\n  table = NULL;\n  if(error == NULL)\n  {\n    known_cert = NULL;\n    if(!match_hostname || !issuer_known)\n    {\n      /* If we cannot load the known host file, then cancel the connection.\n       * Otherwise it might happen that someone shows us a certificate that we\n       * tell the user we don't know, if though actually for that host we expect\n       * a different certificate. */\n      table = inf_gtk_certificate_manager_ref_known_hosts(manager, &error);\n      if(table != NULL)\n        known_cert = g_hash_table_lookup(table, hostname);\n    }\n  }\n\n  /* Next, configure the flags for the dialog to be shown based on the\n   * verification result, and on whether the pinned certificate matches\n   * the one presented by the host or not. */\n  flags = 0;\n  if(error == NULL)\n  {\n    if(known_cert != NULL)\n    {\n      cert_equal = inf_gtk_certificate_manager_compare_fingerprint(\n        known_cert,\n        presented_cert,\n        &error\n      );\n\n      if(error == NULL && cert_equal == FALSE)\n      {\n        if(!match_hostname)\n          flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;\n        if(!issuer_known)\n          flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;\n\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_UNEXPECTED;\n        expiration_time = gnutls_x509_crt_get_expiration_time(known_cert);\n        if(expiration_time != (time_t)(-1))\n        {\n          expiration_time -= INF_GTK_CERTIFICATE_MANAGER_EXPIRATION_TOLERANCE;\n          if(time(NULL) > expiration_time)\n          {\n            flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_OLD_EXPIRED;\n          }\n        }\n      }\n    }\n    else\n    {\n      if(!match_hostname)\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;\n      if(!issuer_known)\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;\n    }\n  }\n\n  /* Now proceed either by accepting the connection, rejecting it, or\n   * bothering the user with an annoying dialog. */\n  if(error == NULL)\n  {\n    if(flags == 0)\n    {\n      if(match_hostname && issuer_known)\n      {\n        /* Remove the pinned entry if we now have a valid certificate for\n         * this host. */\n        if(table != NULL && g_hash_table_remove(table, hostname) == TRUE)\n        {\n          inf_gtk_certificate_manager_write_known_hosts_with_warning(\n            manager,\n            table\n          );\n        }\n      }\n\n      inf_xmpp_connection_certificate_verify_continue(connection);\n    }\n    else\n    {\n      query = g_slice_new(InfGtkCertificateManagerQuery);\n      query->manager = manager;\n      query->known_hosts = table;\n      query->connection = connection;\n      query->dialog = inf_gtk_certificate_dialog_new(\n        priv->parent_window,\n        0,\n        flags,\n        hostname,\n        chain\n      );\n      query->certificate_chain = chain;\n\n      table = NULL;\n\n      g_object_ref(query->connection);\n      inf_certificate_chain_ref(chain);\n\n      g_signal_connect(\n        G_OBJECT(connection),\n        \"notify::status\",\n        G_CALLBACK(inf_gtk_certificate_manager_notify_status_cb),\n        query\n      );\n\n      g_signal_connect(\n        G_OBJECT(query->dialog),\n        \"response\",\n        G_CALLBACK(inf_gtk_certificate_manager_response_cb),\n        query\n      );\n\n      gtk_dialog_add_button(\n        GTK_DIALOG(query->dialog),\n        _(\"_Cancel connection\"),\n        GTK_RESPONSE_REJECT\n      );\n\n      gtk_dialog_add_button(\n        GTK_DIALOG(query->dialog),\n        _(\"C_ontinue connection\"),\n        GTK_RESPONSE_ACCEPT\n      );\n\n      text = g_strdup_printf(\n        _(\"Do you want to continue the connection to host \\\"%s\\\"? If you \"\n          \"choose to continue, this certificate will be trusted in the \"\n          \"future when connecting to this host.\"),\n        hostname\n      );\n\n      label = gtk_label_new(text);\n      gtk_label_set_line_wrap(GTK_LABEL(label), TRUE);\n      gtk_label_set_line_wrap_mode(GTK_LABEL(label), PANGO_WRAP_WORD_CHAR);\n      gtk_label_set_max_width_chars(GTK_LABEL(label), 60);\n      gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.0);\n      gtk_widget_show(label);\n      g_free(text);\n\n      vbox = gtk_dialog_get_content_area(GTK_DIALOG(query->dialog));\n      gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 0);\n\n      priv->queries = g_slist_prepend(priv->queries, query);\n      gtk_window_present(GTK_WINDOW(query->dialog));\n    }\n  }\n  else\n  {\n    inf_xmpp_connection_certificate_verify_cancel(connection, error);\n    g_error_free(error);\n  }\n\n  if(table != NULL) g_hash_table_unref(table);\n  g_free(hostname);\n}",
        "description": "Libinfinity versions prior to 0.6.6-1 do not properly validate expired SSL certificates, enabling remote attackers to exploit this vulnerability through unknown vectors to achieve unspecified impacts.",
        "commit": "Expired certificate validation was addressed in Gobby."
    }
]