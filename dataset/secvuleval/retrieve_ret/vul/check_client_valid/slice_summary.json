[
    {
        "cwe": "CWE-601",
        "func_name": "OpenIDC/oidc_handle_logout",
        "score": 0.735029399394989,
        "func_before": "static int oidc_handle_logout(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\toidc_provider_t *provider = NULL;\n\t/* pickup the command or URL where the user wants to go after logout */\n\tchar *url = NULL;\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_LOGOUT, &url);\n\n\toidc_debug(r, \"enter (url=%s)\", url);\n\n\tif (oidc_is_front_channel_logout(url)) {\n\t\treturn oidc_handle_logout_request(r, c, session, url);\n\t} else if (oidc_is_back_channel_logout(url)) {\n\t\treturn oidc_handle_logout_backchannel(r, c);\n\t}\n\n\tif ((url == NULL) || (apr_strnatcmp(url, \"\") == 0)) {\n\n\t\turl = c->default_slo_url;\n\n\t} else {\n\n\t\t/* do input validation on the logout parameter value */\n\n\t\tconst char *error_description = NULL;\n\t\tapr_uri_t uri;\n\n\t\tif (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {\n\t\t\tconst char *error_description = apr_psprintf(r->pool,\n\t\t\t\t\t\"Logout URL malformed: %s\", url);\n\t\t\toidc_error(r, \"%s\", error_description);\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Malformed URL\", error_description,\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\n\t\t}\n\n\t\tconst char *c_host = oidc_get_current_url_host(r);\n\t\tif ((uri.hostname != NULL)\n\t\t\t\t&& ((strstr(c_host, uri.hostname) == NULL)\n\t\t\t\t\t\t|| (strstr(uri.hostname, c_host) == NULL))) {\n\t\t\terror_description =\n\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n\t\t\toidc_error(r, \"%s\", error_description);\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\", error_description,\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t}\n\n\t\t/* validate the URL to prevent HTTP header splitting */\n\t\tif (((strstr(url, \"\\n\") != NULL) || strstr(url, \"\\r\") != NULL)) {\n\t\t\terror_description =\n\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\"logout value \\\"%s\\\" contains illegal \\\"\\n\\\" or \\\"\\r\\\" character(s)\",\n\t\t\t\t\t\t\turl);\n\t\t\toidc_error(r, \"%s\", error_description);\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\", error_description,\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t}\n\t}\n\n\toidc_get_provider_from_session(r, c, session, &provider);\n\n\tif ((provider != NULL) && (provider->end_session_endpoint != NULL)) {\n\n\t\tconst char *id_token_hint = oidc_session_get_idtoken(r, session);\n\n\t\tchar *logout_request = apr_pstrdup(r->pool,\n\t\t\t\tprovider->end_session_endpoint);\n\t\tif (id_token_hint != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool, \"%s%sid_token_hint=%s\",\n\t\t\t\t\tlogout_request, strchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, id_token_hint));\n\t\t}\n\n\t\tif (url != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool,\n\t\t\t\t\t\"%s%spost_logout_redirect_uri=%s\", logout_request,\n\t\t\t\t\tstrchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, url));\n\t\t}\n\t\turl = logout_request;\n\t}\n\n\treturn oidc_handle_logout_request(r, c, session, url);\n}",
        "func_after": "static int oidc_handle_logout(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\toidc_provider_t *provider = NULL;\n\t/* pickup the command or URL where the user wants to go after logout */\n\tchar *url = NULL;\n\tchar *error_str = NULL;\n\tchar *error_description = NULL;\n\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_LOGOUT, &url);\n\n\toidc_debug(r, \"enter (url=%s)\", url);\n\n\tif (oidc_is_front_channel_logout(url)) {\n\t\treturn oidc_handle_logout_request(r, c, session, url);\n\t} else if (oidc_is_back_channel_logout(url)) {\n\t\treturn oidc_handle_logout_backchannel(r, c);\n\t}\n\n\tif ((url == NULL) || (apr_strnatcmp(url, \"\") == 0)) {\n\n\t\turl = c->default_slo_url;\n\n\t} else {\n\n\t\t/* do input validation on the logout parameter value */\n\t\tif (oidc_validate_post_logout_url(r, url, &error_str,\n\t\t\t\t&error_description) == FALSE) {\n\t\t\treturn oidc_util_html_send_error(r, c->error_template, error_str,\n\t\t\t\t\terror_description,\n\t\t\t\t\tHTTP_BAD_REQUEST);\n\t\t}\n\t}\n\n\toidc_get_provider_from_session(r, c, session, &provider);\n\n\tif ((provider != NULL) && (provider->end_session_endpoint != NULL)) {\n\n\t\tconst char *id_token_hint = oidc_session_get_idtoken(r, session);\n\n\t\tchar *logout_request = apr_pstrdup(r->pool,\n\t\t\t\tprovider->end_session_endpoint);\n\t\tif (id_token_hint != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool, \"%s%sid_token_hint=%s\",\n\t\t\t\t\tlogout_request, strchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, id_token_hint));\n\t\t}\n\n\t\tif (url != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool,\n\t\t\t\t\t\"%s%spost_logout_redirect_uri=%s\", logout_request,\n\t\t\t\t\tstrchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, url));\n\t\t}\n\t\turl = logout_request;\n\t}\n\n\treturn oidc_handle_logout_request(r, c, session, url);\n}",
        "description": "A flaw was identified in mod_auth_openidc versions prior to 2.4.0.1, involving an open redirect vulnerability in URLs that include trailing slashes. This issue is analogous to CVE-2019-3877 found in mod_auth_mellon.",
        "commit": "Improving the validation of the post-logout URL to prevent open redirects."
    },
    {
        "cwe": "CWE-863",
        "func_name": "torvalds/internal_get_user_pages_fast",
        "score": 0.7299482822418213,
        "func_before": "static int internal_get_user_pages_fast(unsigned long start, int nr_pages,\n\t\t\t\t\tunsigned int gup_flags,\n\t\t\t\t\tstruct page **pages)\n{\n\tunsigned long addr, len, end;\n\tint nr_pinned = 0, ret = 0;\n\n\tif (WARN_ON_ONCE(gup_flags & ~(FOLL_WRITE | FOLL_LONGTERM |\n\t\t\t\t       FOLL_FORCE | FOLL_PIN | FOLL_GET)))\n\t\treturn -EINVAL;\n\n\tstart = untagged_addr(start) & PAGE_MASK;\n\taddr = start;\n\tlen = (unsigned long) nr_pages << PAGE_SHIFT;\n\tend = start + len;\n\n\tif (end <= start)\n\t\treturn 0;\n\tif (unlikely(!access_ok((void __user *)start, len)))\n\t\treturn -EFAULT;\n\n\tif (IS_ENABLED(CONFIG_HAVE_FAST_GUP) &&\n\t    gup_fast_permitted(start, end)) {\n\t\tlocal_irq_disable();\n\t\tgup_pgd_range(addr, end, gup_flags, pages, &nr_pinned);\n\t\tlocal_irq_enable();\n\t\tret = nr_pinned;\n\t}\n\n\tif (nr_pinned < nr_pages) {\n\t\t/* Try to get the remaining pages with get_user_pages */\n\t\tstart += nr_pinned << PAGE_SHIFT;\n\t\tpages += nr_pinned;\n\n\t\tret = __gup_longterm_unlocked(start, nr_pages - nr_pinned,\n\t\t\t\t\t      gup_flags, pages);\n\n\t\t/* Have to be a bit careful with return values */\n\t\tif (nr_pinned > 0) {\n\t\t\tif (ret < 0)\n\t\t\t\tret = nr_pinned;\n\t\t\telse\n\t\t\t\tret += nr_pinned;\n\t\t}\n\t}\n\n\treturn ret;\n}",
        "func_after": "static int internal_get_user_pages_fast(unsigned long start, int nr_pages,\n\t\t\t\t\tunsigned int gup_flags,\n\t\t\t\t\tstruct page **pages)\n{\n\tunsigned long addr, len, end;\n\tint nr_pinned = 0, ret = 0;\n\n\tif (WARN_ON_ONCE(gup_flags & ~(FOLL_WRITE | FOLL_LONGTERM |\n\t\t\t\t       FOLL_FORCE | FOLL_PIN | FOLL_GET)))\n\t\treturn -EINVAL;\n\n\tstart = untagged_addr(start) & PAGE_MASK;\n\taddr = start;\n\tlen = (unsigned long) nr_pages << PAGE_SHIFT;\n\tend = start + len;\n\n\tif (end <= start)\n\t\treturn 0;\n\tif (unlikely(!access_ok((void __user *)start, len)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * The FAST_GUP case requires FOLL_WRITE even for pure reads,\n\t * because get_user_pages() may need to cause an early COW in\n\t * order to avoid confusing the normal COW routines. So only\n\t * targets that are already writable are safe to do by just\n\t * looking at the page tables.\n\t */\n\tif (IS_ENABLED(CONFIG_HAVE_FAST_GUP) &&\n\t    gup_fast_permitted(start, end)) {\n\t\tlocal_irq_disable();\n\t\tgup_pgd_range(addr, end, gup_flags | FOLL_WRITE, pages, &nr_pinned);\n\t\tlocal_irq_enable();\n\t\tret = nr_pinned;\n\t}\n\n\tif (nr_pinned < nr_pages) {\n\t\t/* Try to get the remaining pages with get_user_pages */\n\t\tstart += nr_pinned << PAGE_SHIFT;\n\t\tpages += nr_pinned;\n\n\t\tret = __gup_longterm_unlocked(start, nr_pages - nr_pinned,\n\t\t\t\t\t      gup_flags, pages);\n\n\t\t/* Have to be a bit careful with return values */\n\t\tif (nr_pinned > 0) {\n\t\t\tif (ret < 0)\n\t\t\t\tret = nr_pinned;\n\t\t\telse\n\t\t\t\tret += nr_pinned;\n\t\t}\n\t}\n\n\treturn ret;\n}",
        "description": "An issue was discovered in the Linux kernel prior to version 5.7.3, affecting the memory management components located in mm/gup.c and mm/huge_memory.c. The get_user_pages (gup) implementation, when utilized for copy-on-write pages, fails to correctly handle read operation semantics, potentially resulting in unintended write access.",
        "commit": "The vulnerability involves the `get_user_pages()` function in the Linux kernel, which can lead to ambiguous behavior when dealing with copy-on-write (COW) pages. Specifically, the function may return a page pointer that is no longer associated with the original virtual memory area (VM) due to potential COW events. This ambiguity arises because the direction and timing of COW events are undefined, and a page can be unmapped by the thread that performed the `get_user_pages()` call, especially under memory pressure.\n\nTo mitigate this issue, the kernel introduces a change to force a COW event by setting the `FOLL_WRITE` flag when `FOLL_GET` or `FOLL_PIN` is used on a COW mapping. This ensures that the page is properly isolated from other VMs, preventing unintended access or control. However, this change affects the behavior of `get_user_pages_fast()`, which now refuses to follow read-only pages due to the potential need for COW breaking, leading to slower processing in such cases.\n\nThe current semantics are as follows:\n- `__get_user_pages_fast()`: No changes; it does not break COW unless explicitly asked.\n- `get_user_pages_fast()`: Refuses to follow read-only pages, requiring the slow path for COW breaking.\n- `get_user_pages()`: Forces COW breaking for COW mappings when using `FOLL_GET` or `FOLL_PIN`.\n\nThis change aims to clarify the semantics of `get_user_pages()` and reduce the risk of subtle bugs related to COW behavior. While this addresses the ambiguity, it is noted that true shared mappings will still allow pages to change under the user, meaning `get_user_pages()` does not guarantee a \"stable\" page."
    },
    {
        "cwe": "CWE-285",
        "func_name": "ClusterLabs/crm_client_new",
        "score": 0.6981755495071411,
        "func_before": "crm_client_t *\ncrm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)\n{\n    static uid_t uid_server = 0;\n    static gid_t gid_cluster = 0;\n\n    crm_client_t *client = NULL;\n\n    CRM_LOG_ASSERT(c);\n    if (c == NULL) {\n        return NULL;\n    }\n\n    if (gid_cluster == 0) {\n        uid_server = getuid();\n        if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {\n            static bool have_error = FALSE;\n            if(have_error == FALSE) {\n                crm_warn(\"Could not find group for user %s\", CRM_DAEMON_USER);\n                have_error = TRUE;\n            }\n        }\n    }\n\n    if(gid_cluster != 0 && gid_client != 0) {\n        uid_t best_uid = -1; /* Passing -1 to chown(2) means don't change */\n\n        if(uid_client == 0 || uid_server == 0) { /* Someone is priveliged, but the other may not be */\n            best_uid = QB_MAX(uid_client, uid_server);\n            crm_trace(\"Allowing user %u to clean up after disconnect\", best_uid);\n        }\n\n        crm_trace(\"Giving access to group %u\", gid_cluster);\n        qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n    }\n\n    crm_client_init();\n\n    /* TODO: Do our own auth checking, return NULL if unauthorized */\n    client = calloc(1, sizeof(crm_client_t));\n\n    client->ipcs = c;\n    client->kind = CRM_CLIENT_IPC;\n    client->pid = crm_ipcs_client_pid(c);\n\n    client->id = crm_generate_uuid();\n\n    crm_debug(\"Connecting %p for uid=%d gid=%d pid=%u id=%s\", c, uid_client, gid_client, client->pid, client->id);\n\n#if ENABLE_ACL\n    client->user = uid2username(uid_client);\n#endif\n\n    g_hash_table_insert(client_connections, c, client);\n    return client;\n}",
        "func_after": "crm_client_t *\ncrm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)\n{\n    static gid_t gid_cluster = 0;\n\n    crm_client_t *client = NULL;\n\n    CRM_LOG_ASSERT(c);\n    if (c == NULL) {\n        return NULL;\n    }\n\n    if (gid_cluster == 0) {\n        if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {\n            static bool have_error = FALSE;\n            if(have_error == FALSE) {\n                crm_warn(\"Could not find group for user %s\", CRM_DAEMON_USER);\n                have_error = TRUE;\n            }\n        }\n    }\n\n    if (uid_client != 0) {\n        crm_trace(\"Giving access to group %u\", gid_cluster);\n        /* Passing -1 to chown(2) means don't change */\n        qb_ipcs_connection_auth_set(c, -1, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n    }\n\n    crm_client_init();\n\n    /* TODO: Do our own auth checking, return NULL if unauthorized */\n    client = calloc(1, sizeof(crm_client_t));\n\n    client->ipcs = c;\n    client->kind = CRM_CLIENT_IPC;\n    client->pid = crm_ipcs_client_pid(c);\n\n    client->id = crm_generate_uuid();\n\n    crm_debug(\"Connecting %p for uid=%d gid=%d pid=%u id=%s\", c, uid_client, gid_client, client->pid, client->id);\n\n#if ENABLE_ACL\n    client->user = uid2username(uid_client);\n#endif\n\n    g_hash_table_insert(client_connections, c, client);\n    return client;\n}",
        "description": "An authorization flaw exists in Pacemaker versions prior to 1.1.16, where the IPC interface lacks adequate protection. An attacker with an unprivileged account on a Pacemaker node could exploit this flaw to, for instance, compel the Local Resource Manager daemon to execute a script with root privileges, thereby gaining unauthorized root access to the system.",
        "commit": "It was discovered that under certain conditions, unprivileged clients could communicate with some Pacemaker daemons via libqb-facilitated IPC due to flawed authorization decisions. Depending on the capabilities of the affected daemons, this could grant unauthorized users local privilege escalation or allow them to execute arbitrary commands remotely across the cluster. The original vulnerability aimed to permit unprivileged IPC clients to clean up leftover filesystem materials if the server crashes, but this fix inadvertently introduced the described security flaw. A best-effort patch has been proposed to address this issue systematically within libqb."
    },
    {
        "cwe": "CWE-862",
        "func_name": "polkit/polkit_backend_interactive_authority_check_authorization",
        "score": 0.7356017827987671,
        "func_before": "static void\npolkit_backend_interactive_authority_check_authorization (PolkitBackendAuthority         *authority,\n                                                          PolkitSubject                  *caller,\n                                                          PolkitSubject                  *subject,\n                                                          const gchar                    *action_id,\n                                                          PolkitDetails                  *details,\n                                                          PolkitCheckAuthorizationFlags   flags,\n                                                          GCancellable                   *cancellable,\n                                                          GAsyncReadyCallback             callback,\n                                                          gpointer                        user_data)\n{\n  PolkitBackendInteractiveAuthority *interactive_authority;\n  PolkitBackendInteractiveAuthorityPrivate *priv;\n  gchar *caller_str;\n  gchar *subject_str;\n  PolkitIdentity *user_of_caller;\n  PolkitIdentity *user_of_subject;\n  gchar *user_of_caller_str;\n  gchar *user_of_subject_str;\n  PolkitAuthorizationResult *result;\n  PolkitImplicitAuthorization implicit_authorization;\n  GError *error;\n  GSimpleAsyncResult *simple;\n  gboolean has_details;\n  gchar **detail_keys;\n\n  interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);\n  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);\n\n  error = NULL;\n  caller_str = NULL;\n  subject_str = NULL;\n  user_of_caller = NULL;\n  user_of_subject = NULL;\n  user_of_caller_str = NULL;\n  user_of_subject_str = NULL;\n  result = NULL;\n\n  simple = g_simple_async_result_new (G_OBJECT (authority),\n                                      callback,\n                                      user_data,\n                                      polkit_backend_interactive_authority_check_authorization);\n\n  /* handle being called from ourselves */\n  if (caller == NULL)\n    {\n      /* TODO: this is kind of a hack */\n      GDBusConnection *system_bus;\n      system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);\n      caller = polkit_system_bus_name_new (g_dbus_connection_get_unique_name (system_bus));\n      g_object_unref (system_bus);\n    }\n\n  caller_str = polkit_subject_to_string (caller);\n  subject_str = polkit_subject_to_string (subject);\n\n  g_debug (\"%s is inquiring whether %s is authorized for %s\",\n           caller_str,\n           subject_str,\n           action_id);\n\n  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,\n                                                                        caller,\n                                                                        &error);\n  if (error != NULL)\n    {\n      g_simple_async_result_set_from_error (simple, error);\n      g_simple_async_result_complete (simple);\n      g_object_unref (simple);\n      g_error_free (error);\n      goto out;\n    }\n\n  user_of_caller_str = polkit_identity_to_string (user_of_caller);\n  g_debug (\" user of caller is %s\", user_of_caller_str);\n\n  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,\n                                                                         subject,\n                                                                         &error);\n  if (error != NULL)\n    {\n      g_simple_async_result_set_from_error (simple, error);\n      g_simple_async_result_complete (simple);\n      g_object_unref (simple);\n      g_error_free (error);\n      goto out;\n    }\n\n  user_of_subject_str = polkit_identity_to_string (user_of_subject);\n  g_debug (\" user of subject is %s\", user_of_subject_str);\n\n  has_details = FALSE;\n  if (details != NULL)\n    {\n      detail_keys = polkit_details_get_keys (details);\n      if (detail_keys != NULL)\n        {\n          if (g_strv_length (detail_keys) > 0)\n            has_details = TRUE;\n          g_strfreev (detail_keys);\n        }\n    }\n\n  /* Not anyone is allowed to check that process XYZ is allowed to do ABC.\n   * We only allow this if, and only if,\n   *\n   *  - processes may check for another process owned by the *same* user but not\n   *    if details are passed (otherwise you'd be able to spoof the dialog)\n   *\n   *  - processes running as uid 0 may check anything and pass any details\n   *\n   *  - if the action_id has the \"org.freedesktop.policykit.owner\" annotation\n   *    then any uid referenced by that annotation is also allowed to check\n   *    to check anything and pass any details\n   */\n  if (!polkit_identity_equal (user_of_caller, user_of_subject) || has_details)\n    {\n      if (!may_identity_check_authorization (interactive_authority, action_id, user_of_caller))\n        {\n          if (has_details)\n            {\n              g_simple_async_result_set_error (simple,\n                                               POLKIT_ERROR,\n                                               POLKIT_ERROR_NOT_AUTHORIZED,\n                                               \"Only trusted callers (e.g. uid 0 or an action owner) can use CheckAuthorization() and \"\n                                               \"pass details\");\n            }\n          else\n            {\n              g_simple_async_result_set_error (simple,\n                                               POLKIT_ERROR,\n                                               POLKIT_ERROR_NOT_AUTHORIZED,\n                                               \"Only trusted callers (e.g. uid 0 or an action owner) can use CheckAuthorization() for \"\n                                               \"subjects belonging to other identities\");\n            }\n          g_simple_async_result_complete (simple);\n          g_object_unref (simple);\n          goto out;\n        }\n    }\n\n  implicit_authorization = POLKIT_IMPLICIT_AUTHORIZATION_NOT_AUTHORIZED;\n  result = check_authorization_sync (authority,\n                                     caller,\n                                     subject,\n                                     action_id,\n                                     details,\n                                     flags,\n                                     &implicit_authorization,\n                                     FALSE, /* checking_imply */\n                                     &error);\n  if (error != NULL)\n    {\n      g_simple_async_result_set_from_error (simple, error);\n      g_simple_async_result_complete (simple);\n      g_object_unref (simple);\n      g_error_free (error);\n      goto out;\n    }\n\n  /* Caller is up for a challenge! With light sabers! Use an authentication agent if one exists... */\n  if (polkit_authorization_result_get_is_challenge (result) &&\n      (flags & POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION))\n    {\n      AuthenticationAgent *agent;\n\n      agent = get_authentication_agent_for_subject (interactive_authority, subject);\n      if (agent != NULL)\n        {\n          g_object_unref (result);\n          result = NULL;\n\n          g_debug (\" using authentication agent for challenge\");\n\n          authentication_agent_initiate_challenge (agent,\n                                                   subject,\n                                                   user_of_subject,\n                                                   interactive_authority,\n                                                   action_id,\n                                                   details,\n                                                   caller,\n                                                   implicit_authorization,\n                                                   cancellable,\n                                                   check_authorization_challenge_cb,\n                                                   simple);\n\n          /* keep going */\n          goto out;\n        }\n    }\n\n  /* log_result (interactive_authority, action_id, subject, caller, result); */\n\n  /* Otherwise just return the result */\n  g_simple_async_result_set_op_res_gpointer (simple,\n                                             g_object_ref (result),\n                                             g_object_unref);\n  g_simple_async_result_complete (simple);\n  g_object_unref (simple);\n\n out:\n\n  if (user_of_caller != NULL)\n    g_object_unref (user_of_caller);\n\n  if (user_of_subject != NULL)\n    g_object_unref (user_of_subject);\n\n  g_free (caller_str);\n  g_free (subject_str);\n  g_free (user_of_caller_str);\n  g_free (user_of_subject_str);\n\n  if (result != NULL)\n    g_object_unref (result);\n}",
        "func_after": "static void\npolkit_backend_interactive_authority_check_authorization (PolkitBackendAuthority         *authority,\n                                                          PolkitSubject                  *caller,\n                                                          PolkitSubject                  *subject,\n                                                          const gchar                    *action_id,\n                                                          PolkitDetails                  *details,\n                                                          PolkitCheckAuthorizationFlags   flags,\n                                                          GCancellable                   *cancellable,\n                                                          GAsyncReadyCallback             callback,\n                                                          gpointer                        user_data)\n{\n  PolkitBackendInteractiveAuthority *interactive_authority;\n  PolkitBackendInteractiveAuthorityPrivate *priv;\n  gchar *caller_str;\n  gchar *subject_str;\n  PolkitIdentity *user_of_caller;\n  PolkitIdentity *user_of_subject;\n  gboolean user_of_subject_matches;\n  gchar *user_of_caller_str;\n  gchar *user_of_subject_str;\n  PolkitAuthorizationResult *result;\n  PolkitImplicitAuthorization implicit_authorization;\n  GError *error;\n  GSimpleAsyncResult *simple;\n  gboolean has_details;\n  gchar **detail_keys;\n\n  interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);\n  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);\n\n  error = NULL;\n  caller_str = NULL;\n  subject_str = NULL;\n  user_of_caller = NULL;\n  user_of_subject = NULL;\n  user_of_caller_str = NULL;\n  user_of_subject_str = NULL;\n  result = NULL;\n\n  simple = g_simple_async_result_new (G_OBJECT (authority),\n                                      callback,\n                                      user_data,\n                                      polkit_backend_interactive_authority_check_authorization);\n\n  /* handle being called from ourselves */\n  if (caller == NULL)\n    {\n      /* TODO: this is kind of a hack */\n      GDBusConnection *system_bus;\n      system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);\n      caller = polkit_system_bus_name_new (g_dbus_connection_get_unique_name (system_bus));\n      g_object_unref (system_bus);\n    }\n\n  caller_str = polkit_subject_to_string (caller);\n  subject_str = polkit_subject_to_string (subject);\n\n  g_debug (\"%s is inquiring whether %s is authorized for %s\",\n           caller_str,\n           subject_str,\n           action_id);\n\n  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,\n                                                                        caller, NULL,\n                                                                        &error);\n  if (error != NULL)\n    {\n      g_simple_async_result_set_from_error (simple, error);\n      g_simple_async_result_complete (simple);\n      g_object_unref (simple);\n      g_error_free (error);\n      goto out;\n    }\n\n  user_of_caller_str = polkit_identity_to_string (user_of_caller);\n  g_debug (\" user of caller is %s\", user_of_caller_str);\n\n  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,\n                                                                         subject, &user_of_subject_matches,\n                                                                         &error);\n  if (error != NULL)\n    {\n      g_simple_async_result_set_from_error (simple, error);\n      g_simple_async_result_complete (simple);\n      g_object_unref (simple);\n      g_error_free (error);\n      goto out;\n    }\n\n  user_of_subject_str = polkit_identity_to_string (user_of_subject);\n  g_debug (\" user of subject is %s\", user_of_subject_str);\n\n  has_details = FALSE;\n  if (details != NULL)\n    {\n      detail_keys = polkit_details_get_keys (details);\n      if (detail_keys != NULL)\n        {\n          if (g_strv_length (detail_keys) > 0)\n            has_details = TRUE;\n          g_strfreev (detail_keys);\n        }\n    }\n\n  /* Not anyone is allowed to check that process XYZ is allowed to do ABC.\n   * We only allow this if, and only if,\n   *\n   *  - processes may check for another process owned by the *same* user but not\n   *    if details are passed (otherwise you'd be able to spoof the dialog);\n   *    the caller supplies the user_of_subject value, so we additionally\n   *    require it to match at least at one point in time (via\n   *    user_of_subject_matches).\n   *\n   *  - processes running as uid 0 may check anything and pass any details\n   *\n   *  - if the action_id has the \"org.freedesktop.policykit.owner\" annotation\n   *    then any uid referenced by that annotation is also allowed to check\n   *    to check anything and pass any details\n   */\n  if (!user_of_subject_matches\n      || !polkit_identity_equal (user_of_caller, user_of_subject)\n      || has_details)\n    {\n      if (!may_identity_check_authorization (interactive_authority, action_id, user_of_caller))\n        {\n          if (has_details)\n            {\n              g_simple_async_result_set_error (simple,\n                                               POLKIT_ERROR,\n                                               POLKIT_ERROR_NOT_AUTHORIZED,\n                                               \"Only trusted callers (e.g. uid 0 or an action owner) can use CheckAuthorization() and \"\n                                               \"pass details\");\n            }\n          else\n            {\n              g_simple_async_result_set_error (simple,\n                                               POLKIT_ERROR,\n                                               POLKIT_ERROR_NOT_AUTHORIZED,\n                                               \"Only trusted callers (e.g. uid 0 or an action owner) can use CheckAuthorization() for \"\n                                               \"subjects belonging to other identities\");\n            }\n          g_simple_async_result_complete (simple);\n          g_object_unref (simple);\n          goto out;\n        }\n    }\n\n  implicit_authorization = POLKIT_IMPLICIT_AUTHORIZATION_NOT_AUTHORIZED;\n  result = check_authorization_sync (authority,\n                                     caller,\n                                     subject,\n                                     action_id,\n                                     details,\n                                     flags,\n                                     &implicit_authorization,\n                                     FALSE, /* checking_imply */\n                                     &error);\n  if (error != NULL)\n    {\n      g_simple_async_result_set_from_error (simple, error);\n      g_simple_async_result_complete (simple);\n      g_object_unref (simple);\n      g_error_free (error);\n      goto out;\n    }\n\n  /* Caller is up for a challenge! With light sabers! Use an authentication agent if one exists... */\n  if (polkit_authorization_result_get_is_challenge (result) &&\n      (flags & POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION))\n    {\n      AuthenticationAgent *agent;\n\n      agent = get_authentication_agent_for_subject (interactive_authority, subject);\n      if (agent != NULL)\n        {\n          g_object_unref (result);\n          result = NULL;\n\n          g_debug (\" using authentication agent for challenge\");\n\n          authentication_agent_initiate_challenge (agent,\n                                                   subject,\n                                                   user_of_subject,\n                                                   interactive_authority,\n                                                   action_id,\n                                                   details,\n                                                   caller,\n                                                   implicit_authorization,\n                                                   cancellable,\n                                                   check_authorization_challenge_cb,\n                                                   simple);\n\n          /* keep going */\n          goto out;\n        }\n    }\n\n  /* log_result (interactive_authority, action_id, subject, caller, result); */\n\n  /* Otherwise just return the result */\n  g_simple_async_result_set_op_res_gpointer (simple,\n                                             g_object_ref (result),\n                                             g_object_unref);\n  g_simple_async_result_complete (simple);\n  g_object_unref (simple);\n\n out:\n\n  if (user_of_caller != NULL)\n    g_object_unref (user_of_caller);\n\n  if (user_of_subject != NULL)\n    g_object_unref (user_of_subject);\n\n  g_free (caller_str);\n  g_free (subject_str);\n  g_free (user_of_caller_str);\n  g_free (user_of_subject_str);\n\n  if (result != NULL)\n    g_object_unref (result);\n}",
        "description": "A flaw exists in polkit versions prior to 0.116. Specifically, the implementation of the `polkit_backend_interactive_authority_check_authorization` function in polkitd enables unauthorized testing for authentication and triggering of authentication for processes owned by other users. This vulnerability could lead to a local Denial of Service (DoS) and information disclosure.",
        "commit": "**Abstracted and Generalized Description:**\n\nD-Bus clients were permitted to submit the UID of the subject of authorization checks to mitigate race conditions against UID changes, particularly in executables set-UID to root. However, this allowance enabled any client to submit an arbitrary UID, thereby bypassing checks in functions such as CheckAuthorization, RegisterAuthenticationAgent, and UnregisterAuthenticationAgent. An attacker could exploit this vulnerability to:\n\n- Use CheckAuthorization to trigger dialogs in the victim's session or determine if the victim has temporary authorization for certain operations.\n- Use RegisterAuthenticationAgent to interfere with the victim's authentication agent or gather information about operations requiring authorization.\n\nTo address this issue, internal functions like _polkit_unix_process_get_owner() and polkit_unix_process_get_owner() were exposed as a private polkit_unix_process_get_racy_uid__(), explicitly highlighting the risks associated with relying on these functions. This change was implemented in polkit_backend_session_monitor_get_user_for_subject() to return a boolean indicating whether the subject UID can be chosen by the caller. In permission checks requiring the subject to match the caller, the system now fails if the UID is caller-chosen, except for root or root-designated server processes that can still request information about arbitrary subjects."
    }
]