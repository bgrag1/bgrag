[
    {
        "cwe": "CWE-22",
        "func_name": "asterisk/action_getconfig",
        "score": 0.6940338611602783,
        "func_before": "static int action_getconfig(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tconst char *category = astman_get_header(m, \"Category\");\n\tconst char *filter = astman_get_header(m, \"Filter\");\n\tconst char *category_name;\n\tint catcount = 0;\n\tint lineno = 0;\n\tstruct ast_category *cur_category = NULL;\n\tstruct ast_variable *v;\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\n\tif (ast_strlen_zero(fn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\n\tif (restrictedFile(fn)) {\n\t\tastman_send_error(s, m, \"File requires escalated priveledges\");\n\t\treturn 0;\n\t}\n\n\tcfg = ast_config_load2(fn, \"manager\", config_flags);\n\tif (cfg == CONFIG_STATUS_FILEMISSING) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\n\tastman_start_ack(s, m);\n\twhile ((cur_category = ast_category_browse_filtered(cfg, category, cur_category, filter))) {\n\t\tstruct ast_str *templates;\n\n\t\tcategory_name = ast_category_get_name(cur_category);\n\t\tlineno = 0;\n\t\tastman_append(s, \"Category-%06d: %s\\r\\n\", catcount, category_name);\n\n\t\tif (ast_category_is_template(cur_category)) {\n\t\t\tastman_append(s, \"IsTemplate-%06d: %d\\r\\n\", catcount, 1);\n\t\t}\n\n\t\tif ((templates = ast_category_get_templates(cur_category))\n\t\t\t&& ast_str_strlen(templates) > 0) {\n\t\t\tastman_append(s, \"Templates-%06d: %s\\r\\n\", catcount, ast_str_buffer(templates));\n\t\t\tast_free(templates);\n\t\t}\n\n\t\tfor (v = ast_category_first(cur_category); v; v = v->next) {\n\t\t\tastman_append(s, \"Line-%06d-%06d: %s=%s\\r\\n\", catcount, lineno++, v->name, v->value);\n\t\t}\n\n\t\tcatcount++;\n\t}\n\n\tif (!ast_strlen_zero(category) && catcount == 0) { /* TODO: actually, a config with no categories doesn't even get loaded */\n\t\tastman_append(s, \"No categories found\\r\\n\");\n\t}\n\n\tast_config_destroy(cfg);\n\tastman_append(s, \"\\r\\n\");\n\n\treturn 0;\n}",
        "func_after": "static int action_getconfig(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tconst char *category = astman_get_header(m, \"Category\");\n\tconst char *filter = astman_get_header(m, \"Filter\");\n\tconst char *category_name;\n\tint catcount = 0;\n\tint lineno = 0;\n\tint ret = 0;\n\tstruct ast_category *cur_category = NULL;\n\tstruct ast_variable *v;\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\n\tif (ast_strlen_zero(fn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\n\tret = restrictedFile(fn);\n\tif (ret == 1) {\n\t\tastman_send_error(s, m, \"File requires escalated priveledges\");\n\t\treturn 0;\n\t} else if (ret == -1) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t}\n\n\tcfg = ast_config_load2(fn, \"manager\", config_flags);\n\tif (cfg == CONFIG_STATUS_FILEMISSING) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\n\tastman_start_ack(s, m);\n\twhile ((cur_category = ast_category_browse_filtered(cfg, category, cur_category, filter))) {\n\t\tstruct ast_str *templates;\n\n\t\tcategory_name = ast_category_get_name(cur_category);\n\t\tlineno = 0;\n\t\tastman_append(s, \"Category-%06d: %s\\r\\n\", catcount, category_name);\n\n\t\tif (ast_category_is_template(cur_category)) {\n\t\t\tastman_append(s, \"IsTemplate-%06d: %d\\r\\n\", catcount, 1);\n\t\t}\n\n\t\tif ((templates = ast_category_get_templates(cur_category))\n\t\t\t&& ast_str_strlen(templates) > 0) {\n\t\t\tastman_append(s, \"Templates-%06d: %s\\r\\n\", catcount, ast_str_buffer(templates));\n\t\t\tast_free(templates);\n\t\t}\n\n\t\tfor (v = ast_category_first(cur_category); v; v = v->next) {\n\t\t\tastman_append(s, \"Line-%06d-%06d: %s=%s\\r\\n\", catcount, lineno++, v->name, v->value);\n\t\t}\n\n\t\tcatcount++;\n\t}\n\n\tif (!ast_strlen_zero(category) && catcount == 0) { /* TODO: actually, a config with no categories doesn't even get loaded */\n\t\tastman_append(s, \"No categories found\\r\\n\");\n\t}\n\n\tast_config_destroy(cfg);\n\tastman_append(s, \"\\r\\n\");\n\n\treturn 0;\n}",
        "description": "Asterisk, an open-source private branch exchange and telephony toolkit, is vulnerable to an arbitrary file reading issue in versions prior to 18.20.1, 20.5.1, and 21.0.1, as well as certified-asterisk prior to 18.9-cert6. This vulnerability allows unauthorized access to read any arbitrary file, regardless of whether the `live_dangerously` option is enabled. Versions 18.20.1, 20.5.1, and 21.0.1, as well as certified-asterisk prior to 18.9-cert6, have implemented a fix for this issue.",
        "commit": "It was discovered that the GetConfig function in the manager module allowed unauthorized access to files outside of the Asterisk configuration directory by manipulating filenames with \".\" and \"./\", even when the live_dangerously feature was not enabled. This vulnerability has been addressed by implementing a measure to resolve the full path and verify that the file remains within the configuration directory before attempting to access it."
    },
    {
        "cwe": "CWE-121",
        "func_name": "kernel/chap_server_compute_md5",
        "score": 0.6964629888534546,
        "func_before": "static int chap_server_compute_md5(\n\tstruct iscsi_conn *conn,\n\tstruct iscsi_node_auth *auth,\n\tchar *nr_in_ptr,\n\tchar *nr_out_ptr,\n\tunsigned int *nr_out_len)\n{\n\tunsigned long id;\n\tunsigned char id_as_uchar;\n\tunsigned char digest[MD5_SIGNATURE_SIZE];\n\tunsigned char type, response[MD5_SIGNATURE_SIZE * 2 + 2];\n\tunsigned char identifier[10], *challenge = NULL;\n\tunsigned char *challenge_binhex = NULL;\n\tunsigned char client_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char server_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char chap_n[MAX_CHAP_N_SIZE], chap_r[MAX_RESPONSE_LENGTH];\n\tsize_t compare_len;\n\tstruct iscsi_chap *chap = conn->auth_protocol;\n\tstruct crypto_shash *tfm = NULL;\n\tstruct shash_desc *desc = NULL;\n\tint auth_ret = -1, ret, challenge_len;\n\n\tmemset(identifier, 0, 10);\n\tmemset(chap_n, 0, MAX_CHAP_N_SIZE);\n\tmemset(chap_r, 0, MAX_RESPONSE_LENGTH);\n\tmemset(digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(response, 0, MD5_SIGNATURE_SIZE * 2 + 2);\n\tmemset(client_digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(server_digest, 0, MD5_SIGNATURE_SIZE);\n\n\tchallenge = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge) {\n\t\tpr_err(\"Unable to allocate challenge buffer\\n\");\n\t\tgoto out;\n\t}\n\n\tchallenge_binhex = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge_binhex) {\n\t\tpr_err(\"Unable to allocate challenge_binhex buffer\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Extract CHAP_N.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_N\", MAX_CHAP_N_SIZE, chap_n,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\tif (type == HEX) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Include the terminating NULL in the compare */\n\tcompare_len = strlen(auth->userid) + 1;\n\tif (strncmp(chap_n, auth->userid, compare_len) != 0) {\n\t\tpr_err(\"CHAP_N values do not match!\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_N=%s\\n\", chap_n);\n\t/*\n\t * Extract CHAP_R.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_R\", MAX_RESPONSE_LENGTH, chap_r,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"[server] Got CHAP_R=%s\\n\", chap_r);\n\tchap_string_to_hex(client_digest, chap_r, strlen(chap_r));\n\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\ttfm = NULL;\n\t\tpr_err(\"Unable to allocate struct crypto_shash\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);\n\tif (!desc) {\n\t\tpr_err(\"Unable to allocate struct shash_desc\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, &chap->id, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, (char *)&auth->password,\n\t\t\t\t  strlen(auth->password));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for password\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_finup(desc, chap->challenge,\n\t\t\t\t CHAP_CHALLENGE_LENGTH, server_digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for challenge\\n\");\n\t\tgoto out;\n\t}\n\n\tchap_binaryhex_to_asciihex(response, server_digest, MD5_SIGNATURE_SIZE);\n\tpr_debug(\"[server] MD5 Server Digest: %s\\n\", response);\n\n\tif (memcmp(server_digest, client_digest, MD5_SIGNATURE_SIZE) != 0) {\n\t\tpr_debug(\"[server] MD5 Digests do not match!\\n\\n\");\n\t\tgoto out;\n\t} else\n\t\tpr_debug(\"[server] MD5 Digests match, CHAP connection\"\n\t\t\t\t\" successful.\\n\\n\");\n\t/*\n\t * One way authentication has succeeded, return now if mutual\n\t * authentication is not enabled.\n\t */\n\tif (!auth->authenticate_target) {\n\t\tauth_ret = 0;\n\t\tgoto out;\n\t}\n\t/*\n\t * Get CHAP_I.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_I\", 10, identifier, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_I.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type == HEX)\n\t\tret = kstrtoul(&identifier[2], 0, &id);\n\telse\n\t\tret = kstrtoul(identifier, 0, &id);\n\n\tif (ret < 0) {\n\t\tpr_err(\"kstrtoul() failed for CHAP identifier: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (id > 255) {\n\t\tpr_err(\"chap identifier: %lu greater than 255\\n\", id);\n\t\tgoto out;\n\t}\n\t/*\n\t * RFC 1994 says Identifier is no more than octet (8 bits).\n\t */\n\tpr_debug(\"[server] Got CHAP_I=%lu\\n\", id);\n\t/*\n\t * Get CHAP_C.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_C\", CHAP_CHALLENGE_STR_LEN,\n\t\t\tchallenge, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_C=%s\\n\", challenge);\n\tchallenge_len = chap_string_to_hex(challenge_binhex, challenge,\n\t\t\t\tstrlen(challenge));\n\tif (!challenge_len) {\n\t\tpr_err(\"Unable to convert incoming challenge\\n\");\n\t\tgoto out;\n\t}\n\tif (challenge_len > 1024) {\n\t\tpr_err(\"CHAP_C exceeds maximum binary size of 1024 bytes\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * During mutual authentication, the CHAP_C generated by the\n\t * initiator must not match the original CHAP_C generated by\n\t * the target.\n\t */\n\tif (!memcmp(challenge_binhex, chap->challenge, CHAP_CHALLENGE_LENGTH)) {\n\t\tpr_err(\"initiator CHAP_C matches target CHAP_C, failing\"\n\t\t       \" login attempt\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Generate CHAP_N and CHAP_R for mutual authentication.\n\t */\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* To handle both endiannesses */\n\tid_as_uchar = id;\n\tret = crypto_shash_update(desc, &id_as_uchar, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, auth->password_mutual,\n\t\t\t\t  strlen(auth->password_mutual));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for\"\n\t\t\t\t\" password_mutual\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Convert received challenge to binary hex.\n\t */\n\tret = crypto_shash_finup(desc, challenge_binhex, challenge_len,\n\t\t\t\t digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for ma challenge\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Generate CHAP_N and CHAP_R.\n\t */\n\t*nr_out_len = sprintf(nr_out_ptr, \"CHAP_N=%s\", auth->userid_mutual);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_N=%s\\n\", auth->userid_mutual);\n\t/*\n\t * Convert response from binary hex to ascii hext.\n\t */\n\tchap_binaryhex_to_asciihex(response, digest, MD5_SIGNATURE_SIZE);\n\t*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, \"CHAP_R=0x%s\",\n\t\t\tresponse);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_R=0x%s\\n\", response);\n\tauth_ret = 0;\nout:\n\tkzfree(desc);\n\tif (tfm)\n\t\tcrypto_free_shash(tfm);\n\tkfree(challenge);\n\tkfree(challenge_binhex);\n\treturn auth_ret;\n}",
        "func_after": "static int chap_server_compute_md5(\n\tstruct iscsi_conn *conn,\n\tstruct iscsi_node_auth *auth,\n\tchar *nr_in_ptr,\n\tchar *nr_out_ptr,\n\tunsigned int *nr_out_len)\n{\n\tunsigned long id;\n\tunsigned char id_as_uchar;\n\tunsigned char digest[MD5_SIGNATURE_SIZE];\n\tunsigned char type, response[MD5_SIGNATURE_SIZE * 2 + 2];\n\tunsigned char identifier[10], *challenge = NULL;\n\tunsigned char *challenge_binhex = NULL;\n\tunsigned char client_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char server_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char chap_n[MAX_CHAP_N_SIZE], chap_r[MAX_RESPONSE_LENGTH];\n\tsize_t compare_len;\n\tstruct iscsi_chap *chap = conn->auth_protocol;\n\tstruct crypto_shash *tfm = NULL;\n\tstruct shash_desc *desc = NULL;\n\tint auth_ret = -1, ret, challenge_len;\n\n\tmemset(identifier, 0, 10);\n\tmemset(chap_n, 0, MAX_CHAP_N_SIZE);\n\tmemset(chap_r, 0, MAX_RESPONSE_LENGTH);\n\tmemset(digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(response, 0, MD5_SIGNATURE_SIZE * 2 + 2);\n\tmemset(client_digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(server_digest, 0, MD5_SIGNATURE_SIZE);\n\n\tchallenge = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge) {\n\t\tpr_err(\"Unable to allocate challenge buffer\\n\");\n\t\tgoto out;\n\t}\n\n\tchallenge_binhex = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge_binhex) {\n\t\tpr_err(\"Unable to allocate challenge_binhex buffer\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Extract CHAP_N.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_N\", MAX_CHAP_N_SIZE, chap_n,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\tif (type == HEX) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Include the terminating NULL in the compare */\n\tcompare_len = strlen(auth->userid) + 1;\n\tif (strncmp(chap_n, auth->userid, compare_len) != 0) {\n\t\tpr_err(\"CHAP_N values do not match!\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_N=%s\\n\", chap_n);\n\t/*\n\t * Extract CHAP_R.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_R\", MAX_RESPONSE_LENGTH, chap_r,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (strlen(chap_r) != MD5_SIGNATURE_SIZE * 2) {\n\t\tpr_err(\"Malformed CHAP_R\\n\");\n\t\tgoto out;\n\t}\n\tif (hex2bin(client_digest, chap_r, MD5_SIGNATURE_SIZE) < 0) {\n\t\tpr_err(\"Malformed CHAP_R\\n\");\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"[server] Got CHAP_R=%s\\n\", chap_r);\n\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\ttfm = NULL;\n\t\tpr_err(\"Unable to allocate struct crypto_shash\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);\n\tif (!desc) {\n\t\tpr_err(\"Unable to allocate struct shash_desc\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, &chap->id, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, (char *)&auth->password,\n\t\t\t\t  strlen(auth->password));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for password\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_finup(desc, chap->challenge,\n\t\t\t\t CHAP_CHALLENGE_LENGTH, server_digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for challenge\\n\");\n\t\tgoto out;\n\t}\n\n\tchap_binaryhex_to_asciihex(response, server_digest, MD5_SIGNATURE_SIZE);\n\tpr_debug(\"[server] MD5 Server Digest: %s\\n\", response);\n\n\tif (memcmp(server_digest, client_digest, MD5_SIGNATURE_SIZE) != 0) {\n\t\tpr_debug(\"[server] MD5 Digests do not match!\\n\\n\");\n\t\tgoto out;\n\t} else\n\t\tpr_debug(\"[server] MD5 Digests match, CHAP connection\"\n\t\t\t\t\" successful.\\n\\n\");\n\t/*\n\t * One way authentication has succeeded, return now if mutual\n\t * authentication is not enabled.\n\t */\n\tif (!auth->authenticate_target) {\n\t\tauth_ret = 0;\n\t\tgoto out;\n\t}\n\t/*\n\t * Get CHAP_I.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_I\", 10, identifier, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_I.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type == HEX)\n\t\tret = kstrtoul(&identifier[2], 0, &id);\n\telse\n\t\tret = kstrtoul(identifier, 0, &id);\n\n\tif (ret < 0) {\n\t\tpr_err(\"kstrtoul() failed for CHAP identifier: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (id > 255) {\n\t\tpr_err(\"chap identifier: %lu greater than 255\\n\", id);\n\t\tgoto out;\n\t}\n\t/*\n\t * RFC 1994 says Identifier is no more than octet (8 bits).\n\t */\n\tpr_debug(\"[server] Got CHAP_I=%lu\\n\", id);\n\t/*\n\t * Get CHAP_C.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_C\", CHAP_CHALLENGE_STR_LEN,\n\t\t\tchallenge, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\tchallenge_len = DIV_ROUND_UP(strlen(challenge), 2);\n\tif (!challenge_len) {\n\t\tpr_err(\"Unable to convert incoming challenge\\n\");\n\t\tgoto out;\n\t}\n\tif (challenge_len > 1024) {\n\t\tpr_err(\"CHAP_C exceeds maximum binary size of 1024 bytes\\n\");\n\t\tgoto out;\n\t}\n\tif (hex2bin(challenge_binhex, challenge, challenge_len) < 0) {\n\t\tpr_err(\"Malformed CHAP_C\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_C=%s\\n\", challenge);\n\t/*\n\t * During mutual authentication, the CHAP_C generated by the\n\t * initiator must not match the original CHAP_C generated by\n\t * the target.\n\t */\n\tif (!memcmp(challenge_binhex, chap->challenge, CHAP_CHALLENGE_LENGTH)) {\n\t\tpr_err(\"initiator CHAP_C matches target CHAP_C, failing\"\n\t\t       \" login attempt\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Generate CHAP_N and CHAP_R for mutual authentication.\n\t */\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* To handle both endiannesses */\n\tid_as_uchar = id;\n\tret = crypto_shash_update(desc, &id_as_uchar, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, auth->password_mutual,\n\t\t\t\t  strlen(auth->password_mutual));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for\"\n\t\t\t\t\" password_mutual\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Convert received challenge to binary hex.\n\t */\n\tret = crypto_shash_finup(desc, challenge_binhex, challenge_len,\n\t\t\t\t digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for ma challenge\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Generate CHAP_N and CHAP_R.\n\t */\n\t*nr_out_len = sprintf(nr_out_ptr, \"CHAP_N=%s\", auth->userid_mutual);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_N=%s\\n\", auth->userid_mutual);\n\t/*\n\t * Convert response from binary hex to ascii hext.\n\t */\n\tchap_binaryhex_to_asciihex(response, digest, MD5_SIGNATURE_SIZE);\n\t*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, \"CHAP_R=0x%s\",\n\t\t\tresponse);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_R=0x%s\\n\", response);\n\tauth_ret = 0;\nout:\n\tkzfree(desc);\n\tif (tfm)\n\t\tcrypto_free_shash(tfm);\n\tkfree(challenge);\n\tkfree(challenge_binhex);\n\treturn auth_ret;\n}",
        "description": "A security flaw exists in the chap_server_compute_md5() function within the ISCSI target code of the Linux kernel, where an unauthenticated remote attacker can exploit a stack buffer overflow to overwrite up to 17 bytes of the stack. This vulnerability arises during the processing of an authentication request from an ISCSI initiator. For an attack to be successful, the iSCSI target must be enabled on the victim host. The impact of the overflow varies based on the target's build environment, including the compiler, compile flags, and hardware architecture, potentially leading to a system crash, denial-of-service, or unauthorized access to data exported by the iSCSI target. Although privilege escalation is not conclusively proven, it remains a concern. This vulnerability affects kernel versions 4.18.x, 4.14.x, and 3.10.x.",
        "commit": "Please provide the specific vulnerability knowledge you would like me to abstract and generalize."
    },
    {
        "cwe": "CWE-416",
        "func_name": "torvalds/ipt_do_table",
        "score": 0.7033978700637817,
        "func_before": "unsigned int\nipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
        "func_after": "unsigned int\nipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = rcu_access_pointer(table->private);\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
        "description": "An issue was discovered in the netfilter component of the Linux kernel prior to version 5.10. This vulnerability involves a use-after-free condition in the packet processing context due to improper handling of per-CPU sequence counts during concurrent iptables rule replacements. This flaw could be exploited by users with the CAP_NET_ADMIN capability in an unprivileged namespace.",
        "commit": "When performing concurrent iptables rules replacement, the system checks the per-CPU sequence count after assigning new information. This sequence count is intended to synchronize with the packet path without using explicit locking. If packets are currently using the old table information, the sequence count is incremented to an odd value and then to an even value after processing. After assigning the new table information, a write memory barrier is executed to ensure all CPUs see the latest value. If the packet path starts with the old table information, the sequence counter remains odd, and the iptables replacement waits until the sequence count is even before freeing the old table information. However, if the CPU delays executing the new table information assignment and memory barrier, another CPU's packet path may still use the old table information. This delay can lead to a use-after-free error in the packet processing context, resulting in a kernel NULL pointer dereference. To fix this issue, either enforce instruction ordering after the new table information assignment or switch to RCU for synchronization."
    },
    {
        "cwe": "CWE-59",
        "func_name": "acassen/vrrp_print_json",
        "score": 0.6945751905441284,
        "func_before": "void\nvrrp_print_json(void)\n{\n\tFILE *file;\n\telement e;\n\tstruct json_object *array;\n\n\tif (LIST_ISEMPTY(vrrp_data->vrrp))\n\t\treturn;\n\n\tfile = fopen (\"/tmp/keepalived.json\",\"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open /tmp/keepalived.json (%d: %s)\",\n\t\t\terrno, strerror(errno));\n\t\treturn;\n\t}\n\n\tarray = json_object_new_array();\n\n\tfor (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {\n\t\tstruct json_object *instance_json, *json_stats, *json_data,\n\t\t\t*vips, *evips, *track_ifp, *track_script;\n#ifdef _HAVE_FIB_ROUTING_\n\t\tstruct json_object *vroutes, *vrules;\n#endif\n\t\telement f;\n\n\t\tvrrp_t *vrrp = ELEMENT_DATA(e);\n\t\tinstance_json = json_object_new_object();\n\t\tjson_stats = json_object_new_object();\n\t\tjson_data = json_object_new_object();\n\t\tvips = json_object_new_array();\n\t\tevips = json_object_new_array();\n\t\ttrack_ifp = json_object_new_array();\n\t\ttrack_script = json_object_new_array();\n#ifdef _HAVE_FIB_ROUTING_\n\t\tvroutes = json_object_new_array();\n\t\tvrules = json_object_new_array();\n#endif\n\n\t\t// Dump data to json\n\t\tjson_object_object_add(json_data, \"iname\",\n\t\t\tjson_object_new_string(vrrp->iname));\n\t\tjson_object_object_add(json_data, \"dont_track_primary\",\n\t\t\tjson_object_new_int(vrrp->dont_track_primary));\n\t\tjson_object_object_add(json_data, \"skip_check_adv_addr\",\n\t\t\tjson_object_new_int(vrrp->skip_check_adv_addr));\n\t\tjson_object_object_add(json_data, \"strict_mode\",\n\t\t\tjson_object_new_int((int)vrrp->strict_mode));\n#ifdef _HAVE_VRRP_VMAC_\n\t\tjson_object_object_add(json_data, \"vmac_ifname\",\n\t\t\tjson_object_new_string(vrrp->vmac_ifname));\n#endif\n\t\t// Tracked interfaces are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->track_ifp)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_ifp); f; ELEMENT_NEXT(f)) {\n\t\t\t\tinterface_t *ifp = ELEMENT_DATA(f);\n\t\t\t\tjson_object_array_add(track_ifp,\n\t\t\t\t\tjson_object_new_string(ifp->ifname));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_ifp\", track_ifp);\n\n\t\t// Tracked scripts also\n\t\tif (!LIST_ISEMPTY(vrrp->track_script)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_script); f; ELEMENT_NEXT(f)) {\n\t\t\t\ttracked_sc_t *tsc = ELEMENT_DATA(f);\n\t\t\t\tvrrp_script_t *vscript = tsc->scr;\n\t\t\t\tjson_object_array_add(track_script,\n\t\t\t\t\tjson_object_new_string(cmd_str(&vscript->script)));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_script\", track_script);\n\n\t\tjson_object_object_add(json_data, \"ifp_ifname\",\n\t\t\tjson_object_new_string(vrrp->ifp->ifname));\n\t\tjson_object_object_add(json_data, \"master_priority\",\n\t\t\tjson_object_new_int(vrrp->master_priority));\n\t\tjson_object_object_add(json_data, \"last_transition\",\n\t\t\tjson_object_new_double(timeval_to_double(&vrrp->last_transition)));\n\t\tjson_object_object_add(json_data, \"garp_delay\",\n\t\t\tjson_object_new_double(vrrp->garp_delay / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"garp_refresh\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh.tv_sec));\n\t\tjson_object_object_add(json_data, \"garp_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_rep));\n\t\tjson_object_object_add(json_data, \"garp_refresh_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh_rep));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->garp_lower_prio_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_lower_prio_rep));\n\t\tjson_object_object_add(json_data, \"lower_prio_no_advert\",\n\t\t\tjson_object_new_int((int)vrrp->lower_prio_no_advert));\n\t\tjson_object_object_add(json_data, \"higher_prio_send_advert\",\n\t\t\tjson_object_new_int((int)vrrp->higher_prio_send_advert));\n\t\tjson_object_object_add(json_data, \"vrid\",\n\t\t\tjson_object_new_int(vrrp->vrid));\n\t\tjson_object_object_add(json_data, \"base_priority\",\n\t\t\tjson_object_new_int(vrrp->base_priority));\n\t\tjson_object_object_add(json_data, \"effective_priority\",\n\t\t\tjson_object_new_int(vrrp->effective_priority));\n\t\tjson_object_object_add(json_data, \"vipset\",\n\t\t\tjson_object_new_boolean(vrrp->vipset));\n\n\t\t//Virtual IPs are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->vip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *vip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(vip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(vips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vips\", vips);\n\n\t\t//External VIPs are also stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->evip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->evip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *evip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(evip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(evips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"evips\", evips);\n\n\t\tjson_object_object_add(json_data, \"promote_secondaries\",\n\t\t\tjson_object_new_boolean(vrrp->promote_secondaries));\n\n#ifdef _HAVE_FIB_ROUTING_\n\t\t// Dump vroutes\n\t\tif (!LIST_ISEMPTY(vrrp->vroutes)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vroutes); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_route_t *route = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(ROUTE_BUF_SIZE);\n\t\t\t\tformat_iproute(route, buf, ROUTE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vroutes,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vroutes\", vroutes);\n\n\t\t// Dump vrules\n\t\tif (!LIST_ISEMPTY(vrrp->vrules)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vrules); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_rule_t *rule = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(RULE_BUF_SIZE);\n\t\t\t\tformat_iprule(rule, buf, RULE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vrules,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vrules\", vrules);\n#endif\n\n\t\tjson_object_object_add(json_data, \"adver_int\",\n\t\t\tjson_object_new_double(vrrp->adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"master_adver_int\",\n\t\t\tjson_object_new_double(vrrp->master_adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"accept\",\n\t\t\tjson_object_new_int((int)vrrp->accept));\n\t\tjson_object_object_add(json_data, \"nopreempt\",\n\t\t\tjson_object_new_boolean(vrrp->nopreempt));\n\t\tjson_object_object_add(json_data, \"preempt_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->preempt_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"state\",\n\t\t\tjson_object_new_int(vrrp->state));\n\t\tjson_object_object_add(json_data, \"wantstate\",\n\t\t\tjson_object_new_int(vrrp->wantstate));\n\t\tjson_object_object_add(json_data, \"version\",\n\t\t\tjson_object_new_int(vrrp->version));\n\t\tif (vrrp->script_backup)\n\t\t\tjson_object_object_add(json_data, \"script_backup\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_backup)));\n\t\tif (vrrp->script_master)\n\t\t\tjson_object_object_add(json_data, \"script_master\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master)));\n\t\tif (vrrp->script_fault)\n\t\t\tjson_object_object_add(json_data, \"script_fault\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_fault)));\n\t\tif (vrrp->script_stop)\n\t\t\tjson_object_object_add(json_data, \"script_stop\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_stop)));\n\t\tif (vrrp->script)\n\t\t\tjson_object_object_add(json_data, \"script\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script)));\n\t\tif (vrrp->script_master_rx_lower_pri)\n\t\t\tjson_object_object_add(json_data, \"script_master_rx_lower_pri\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master_rx_lower_pri)));\n\t\tjson_object_object_add(json_data, \"smtp_alert\",\n\t\t\tjson_object_new_boolean(vrrp->smtp_alert));\n#ifdef _WITH_VRRP_AUTH_\n\t\tif (vrrp->auth_type) {\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(vrrp->auth_type));\n\n\t\t\tif (vrrp->auth_type != VRRP_AUTH_AH) {\n\t\t\t\tchar auth_data[sizeof(vrrp->auth_data) + 1];\n\t\t\t\tmemcpy(auth_data, vrrp->auth_data, sizeof(vrrp->auth_data));\n\t\t\t\tauth_data[sizeof(vrrp->auth_data)] = '\\0';\n\t\t\t\tjson_object_object_add(json_data, \"auth_data\",\n\t\t\t\t\tjson_object_new_string(auth_data));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(0));\n#endif\n\n\t\t// Dump stats to json\n\t\tjson_object_object_add(json_stats, \"advert_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_rcvd));\n\t\tjson_object_object_add(json_stats, \"advert_sent\",\n\t\t\tjson_object_new_int64(vrrp->stats->advert_sent));\n\t\tjson_object_object_add(json_stats, \"become_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->become_master));\n\t\tjson_object_object_add(json_stats, \"release_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->release_master));\n\t\tjson_object_object_add(json_stats, \"packet_len_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->packet_len_err));\n\t\tjson_object_object_add(json_stats, \"advert_interval_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_interval_err));\n\t\tjson_object_object_add(json_stats, \"ip_ttl_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->ip_ttl_err));\n\t\tjson_object_object_add(json_stats, \"invalid_type_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->invalid_type_rcvd));\n\t\tjson_object_object_add(json_stats, \"addr_list_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->addr_list_err));\n\t\tjson_object_object_add(json_stats, \"invalid_authtype\",\n\t\t\tjson_object_new_int64(vrrp->stats->invalid_authtype));\n#ifdef _WITH_VRRP_AUTH_\n\t\tjson_object_object_add(json_stats, \"authtype_mismatch\",\n\t\t\tjson_object_new_int64(vrrp->stats->authtype_mismatch));\n\t\tjson_object_object_add(json_stats, \"auth_failure\",\n\t\t\tjson_object_new_int64(vrrp->stats->auth_failure));\n#endif\n\t\tjson_object_object_add(json_stats, \"pri_zero_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_rcvd));\n\t\tjson_object_object_add(json_stats, \"pri_zero_sent\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_sent));\n\n\t\t// Add both json_data and json_stats to main instance_json\n\t\tjson_object_object_add(instance_json, \"data\", json_data);\n\t\tjson_object_object_add(instance_json, \"stats\", json_stats);\n\n\t\t// Add instance_json to main array\n\t\tjson_object_array_add(array, instance_json);\n\n\t}\n\tfprintf(file, \"%s\", json_object_to_json_string(array));\n\tfclose(file);\n}",
        "func_after": "void\nvrrp_print_json(void)\n{\n\tFILE *file;\n\telement e;\n\tstruct json_object *array;\n\n\tif (LIST_ISEMPTY(vrrp_data->vrrp))\n\t\treturn;\n\n\tfile = fopen_safe(\"/tmp/keepalived.json\", \"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open /tmp/keepalived.json (%d: %s)\",\n\t\t\terrno, strerror(errno));\n\t\treturn;\n\t}\n\n\tarray = json_object_new_array();\n\n\tfor (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {\n\t\tstruct json_object *instance_json, *json_stats, *json_data,\n\t\t\t*vips, *evips, *track_ifp, *track_script;\n#ifdef _HAVE_FIB_ROUTING_\n\t\tstruct json_object *vroutes, *vrules;\n#endif\n\t\telement f;\n\n\t\tvrrp_t *vrrp = ELEMENT_DATA(e);\n\t\tinstance_json = json_object_new_object();\n\t\tjson_stats = json_object_new_object();\n\t\tjson_data = json_object_new_object();\n\t\tvips = json_object_new_array();\n\t\tevips = json_object_new_array();\n\t\ttrack_ifp = json_object_new_array();\n\t\ttrack_script = json_object_new_array();\n#ifdef _HAVE_FIB_ROUTING_\n\t\tvroutes = json_object_new_array();\n\t\tvrules = json_object_new_array();\n#endif\n\n\t\t// Dump data to json\n\t\tjson_object_object_add(json_data, \"iname\",\n\t\t\tjson_object_new_string(vrrp->iname));\n\t\tjson_object_object_add(json_data, \"dont_track_primary\",\n\t\t\tjson_object_new_int(vrrp->dont_track_primary));\n\t\tjson_object_object_add(json_data, \"skip_check_adv_addr\",\n\t\t\tjson_object_new_int(vrrp->skip_check_adv_addr));\n\t\tjson_object_object_add(json_data, \"strict_mode\",\n\t\t\tjson_object_new_int((int)vrrp->strict_mode));\n#ifdef _HAVE_VRRP_VMAC_\n\t\tjson_object_object_add(json_data, \"vmac_ifname\",\n\t\t\tjson_object_new_string(vrrp->vmac_ifname));\n#endif\n\t\t// Tracked interfaces are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->track_ifp)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_ifp); f; ELEMENT_NEXT(f)) {\n\t\t\t\tinterface_t *ifp = ELEMENT_DATA(f);\n\t\t\t\tjson_object_array_add(track_ifp,\n\t\t\t\t\tjson_object_new_string(ifp->ifname));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_ifp\", track_ifp);\n\n\t\t// Tracked scripts also\n\t\tif (!LIST_ISEMPTY(vrrp->track_script)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_script); f; ELEMENT_NEXT(f)) {\n\t\t\t\ttracked_sc_t *tsc = ELEMENT_DATA(f);\n\t\t\t\tvrrp_script_t *vscript = tsc->scr;\n\t\t\t\tjson_object_array_add(track_script,\n\t\t\t\t\tjson_object_new_string(cmd_str(&vscript->script)));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_script\", track_script);\n\n\t\tjson_object_object_add(json_data, \"ifp_ifname\",\n\t\t\tjson_object_new_string(vrrp->ifp->ifname));\n\t\tjson_object_object_add(json_data, \"master_priority\",\n\t\t\tjson_object_new_int(vrrp->master_priority));\n\t\tjson_object_object_add(json_data, \"last_transition\",\n\t\t\tjson_object_new_double(timeval_to_double(&vrrp->last_transition)));\n\t\tjson_object_object_add(json_data, \"garp_delay\",\n\t\t\tjson_object_new_double(vrrp->garp_delay / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"garp_refresh\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh.tv_sec));\n\t\tjson_object_object_add(json_data, \"garp_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_rep));\n\t\tjson_object_object_add(json_data, \"garp_refresh_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh_rep));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->garp_lower_prio_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_lower_prio_rep));\n\t\tjson_object_object_add(json_data, \"lower_prio_no_advert\",\n\t\t\tjson_object_new_int((int)vrrp->lower_prio_no_advert));\n\t\tjson_object_object_add(json_data, \"higher_prio_send_advert\",\n\t\t\tjson_object_new_int((int)vrrp->higher_prio_send_advert));\n\t\tjson_object_object_add(json_data, \"vrid\",\n\t\t\tjson_object_new_int(vrrp->vrid));\n\t\tjson_object_object_add(json_data, \"base_priority\",\n\t\t\tjson_object_new_int(vrrp->base_priority));\n\t\tjson_object_object_add(json_data, \"effective_priority\",\n\t\t\tjson_object_new_int(vrrp->effective_priority));\n\t\tjson_object_object_add(json_data, \"vipset\",\n\t\t\tjson_object_new_boolean(vrrp->vipset));\n\n\t\t//Virtual IPs are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->vip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *vip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(vip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(vips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vips\", vips);\n\n\t\t//External VIPs are also stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->evip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->evip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *evip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(evip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(evips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"evips\", evips);\n\n\t\tjson_object_object_add(json_data, \"promote_secondaries\",\n\t\t\tjson_object_new_boolean(vrrp->promote_secondaries));\n\n#ifdef _HAVE_FIB_ROUTING_\n\t\t// Dump vroutes\n\t\tif (!LIST_ISEMPTY(vrrp->vroutes)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vroutes); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_route_t *route = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(ROUTE_BUF_SIZE);\n\t\t\t\tformat_iproute(route, buf, ROUTE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vroutes,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vroutes\", vroutes);\n\n\t\t// Dump vrules\n\t\tif (!LIST_ISEMPTY(vrrp->vrules)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vrules); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_rule_t *rule = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(RULE_BUF_SIZE);\n\t\t\t\tformat_iprule(rule, buf, RULE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vrules,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vrules\", vrules);\n#endif\n\n\t\tjson_object_object_add(json_data, \"adver_int\",\n\t\t\tjson_object_new_double(vrrp->adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"master_adver_int\",\n\t\t\tjson_object_new_double(vrrp->master_adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"accept\",\n\t\t\tjson_object_new_int((int)vrrp->accept));\n\t\tjson_object_object_add(json_data, \"nopreempt\",\n\t\t\tjson_object_new_boolean(vrrp->nopreempt));\n\t\tjson_object_object_add(json_data, \"preempt_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->preempt_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"state\",\n\t\t\tjson_object_new_int(vrrp->state));\n\t\tjson_object_object_add(json_data, \"wantstate\",\n\t\t\tjson_object_new_int(vrrp->wantstate));\n\t\tjson_object_object_add(json_data, \"version\",\n\t\t\tjson_object_new_int(vrrp->version));\n\t\tif (vrrp->script_backup)\n\t\t\tjson_object_object_add(json_data, \"script_backup\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_backup)));\n\t\tif (vrrp->script_master)\n\t\t\tjson_object_object_add(json_data, \"script_master\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master)));\n\t\tif (vrrp->script_fault)\n\t\t\tjson_object_object_add(json_data, \"script_fault\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_fault)));\n\t\tif (vrrp->script_stop)\n\t\t\tjson_object_object_add(json_data, \"script_stop\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_stop)));\n\t\tif (vrrp->script)\n\t\t\tjson_object_object_add(json_data, \"script\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script)));\n\t\tif (vrrp->script_master_rx_lower_pri)\n\t\t\tjson_object_object_add(json_data, \"script_master_rx_lower_pri\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master_rx_lower_pri)));\n\t\tjson_object_object_add(json_data, \"smtp_alert\",\n\t\t\tjson_object_new_boolean(vrrp->smtp_alert));\n#ifdef _WITH_VRRP_AUTH_\n\t\tif (vrrp->auth_type) {\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(vrrp->auth_type));\n\n\t\t\tif (vrrp->auth_type != VRRP_AUTH_AH) {\n\t\t\t\tchar auth_data[sizeof(vrrp->auth_data) + 1];\n\t\t\t\tmemcpy(auth_data, vrrp->auth_data, sizeof(vrrp->auth_data));\n\t\t\t\tauth_data[sizeof(vrrp->auth_data)] = '\\0';\n\t\t\t\tjson_object_object_add(json_data, \"auth_data\",\n\t\t\t\t\tjson_object_new_string(auth_data));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(0));\n#endif\n\n\t\t// Dump stats to json\n\t\tjson_object_object_add(json_stats, \"advert_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_rcvd));\n\t\tjson_object_object_add(json_stats, \"advert_sent\",\n\t\t\tjson_object_new_int64(vrrp->stats->advert_sent));\n\t\tjson_object_object_add(json_stats, \"become_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->become_master));\n\t\tjson_object_object_add(json_stats, \"release_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->release_master));\n\t\tjson_object_object_add(json_stats, \"packet_len_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->packet_len_err));\n\t\tjson_object_object_add(json_stats, \"advert_interval_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_interval_err));\n\t\tjson_object_object_add(json_stats, \"ip_ttl_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->ip_ttl_err));\n\t\tjson_object_object_add(json_stats, \"invalid_type_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->invalid_type_rcvd));\n\t\tjson_object_object_add(json_stats, \"addr_list_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->addr_list_err));\n\t\tjson_object_object_add(json_stats, \"invalid_authtype\",\n\t\t\tjson_object_new_int64(vrrp->stats->invalid_authtype));\n#ifdef _WITH_VRRP_AUTH_\n\t\tjson_object_object_add(json_stats, \"authtype_mismatch\",\n\t\t\tjson_object_new_int64(vrrp->stats->authtype_mismatch));\n\t\tjson_object_object_add(json_stats, \"auth_failure\",\n\t\t\tjson_object_new_int64(vrrp->stats->auth_failure));\n#endif\n\t\tjson_object_object_add(json_stats, \"pri_zero_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_rcvd));\n\t\tjson_object_object_add(json_stats, \"pri_zero_sent\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_sent));\n\n\t\t// Add both json_data and json_stats to main instance_json\n\t\tjson_object_object_add(instance_json, \"data\", json_data);\n\t\tjson_object_object_add(instance_json, \"stats\", json_stats);\n\n\t\t// Add instance_json to main array\n\t\tjson_object_array_add(array, instance_json);\n\n\t}\n\tfprintf(file, \"%s\", json_object_to_json_string(array));\n\tfclose(file);\n}",
        "description": "keepalived 2.0.8 failed to verify the presence of symbolic links in file paths when writing data to temporary files during calls to PrintData or PrintStats. This oversight permitted local users to overwrite arbitrary files when the system setting fs.protected_symlinks is disabled, as illustrated by creating a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",
        "commit": "When opening files for write operations, it is crucial to verify that the target path is not a symbolic link. This vulnerability highlights a scenario where a non-privileged user could exploit a symbolic link to overwrite critical system files, such as `/etc/passwd`, by creating a symlink from `/etc/keepalvied.data` to `/etc/passwd`. To mitigate this risk, the solution involves setting the `O_NOFOLLOW` flag whenever a file is opened for writing. However, this change may introduce backward incompatibility in certain setups where the target file is accessed via a symbolic link. In such cases, administrators should adjust their configurations, for instance, by redirecting the actual data file to a temporary location and maintaining the symbolic link to this new location. Despite these adjustments, there is no straightforward way to prevent race conditions when checking if a path is a symbolic link before opening it for writing."
    },
    {
        "cwe": "CWE-119",
        "func_name": "torvalds/hugetlb_mcopy_atomic_pte",
        "score": 0.7017173171043396,
        "func_before": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tstruct address_space *mapping = dst_vma->vm_file->f_mapping;\n\t\tpgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
        "func_after": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\tunsigned long size;\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\tmapping = dst_vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\t\tret = -EFAULT;\n\t\tif (idx >= size)\n\t\t\tgoto out_release_nounlock;\n\n\t\t/*\n\t\t * Serialization between remove_inode_hugepages() and\n\t\t * huge_add_to_page_cache() below happens through the\n\t\t * hugetlb_fault_mutex_table that here must be hold by\n\t\t * the caller.\n\t\t */\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\t/*\n\t * Recheck the i_size after holding PT lock to make sure not\n\t * to leave any page mapped (as page_mapped()) beyond the end\n\t * of the i_size (remove_inode_hugepages() is strict about\n\t * enforcing that). If we bail out here, we'll also leave a\n\t * page in the radix tree in the vm_shared case beyond the end\n\t * of the i_size, but remove_inode_hugepages() will take care\n\t * of it as soon as we drop the hugetlb_fault_mutex_table.\n\t */\n\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\tret = -EFAULT;\n\tif (idx >= size)\n\t\tgoto out_release_unlock;\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
        "description": "A flaw was identified in the hugetlb_mcopy_atomic_pte function within the Linux kernel's memory management module, affecting versions prior to 4.13.12. The absence of a proper size check in this function could lead to a denial of service condition, indicated by a BUG.",
        "commit": "A vulnerability was identified in the userfaultfd functionality related to hugetlbfs, where the UFFDIO_COPY operation could inadvertently extend beyond the intended size of the file (i_size). This issue led to a kernel panic (oops) at fs/hugetlbfs/inode.c:484, triggered by the absence of an i_size check in the hugetlb_mcopy_atomic_pte function. Although mmap() operations could succeed beyond the end of the i_size after vmtruncate had removed virtual memory areas (vmas) in those ranges, subsequent faults, including UFFDIO_COPY, should not be allowed to succeed. The proposed solution involves modifying the return value to userland to indicate a SIGBUS-like condition, similar to what a page fault would produce, but this approach was deemed less useful due to the difficulty in distinguishing between SIGSEGV and SIGBUS through meaningful syscall return values."
    }
]