[
    {
        "cwe": "CWE-346",
        "func_name": "hotplug/udev_monitor_receive_device",
        "score": 0.7131396532058716,
        "func_before": "struct udev_device *udev_monitor_receive_device(struct udev_monitor *udev_monitor)\n{\n\tstruct udev_device *udev_device;\n\tstruct msghdr smsg;\n\tstruct iovec iov;\n\tchar cred_msg[CMSG_SPACE(sizeof(struct ucred))];\n\tchar buf[4096];\n\tsize_t bufpos;\n\tint devpath_set = 0;\n\tint subsystem_set = 0;\n\tint action_set = 0;\n\tint maj = 0;\n\tint min = 0;\n\n\tif (udev_monitor == NULL)\n\t\treturn NULL;\n\tmemset(buf, 0x00, sizeof(buf));\n\tiov.iov_base = &buf;\n\tiov.iov_len = sizeof(buf);\n\tmemset (&smsg, 0x00, sizeof(struct msghdr));\n\tsmsg.msg_iov = &iov;\n\tsmsg.msg_iovlen = 1;\n\tsmsg.msg_control = cred_msg;\n\tsmsg.msg_controllen = sizeof(cred_msg);\n\n\tif (recvmsg(udev_monitor->sock, &smsg, 0) < 0) {\n\t\tif (errno != EINTR)\n\t\t\tinfo(udev_monitor->udev, \"unable to receive message\");\n\t\treturn NULL;\n\t}\n\n\tif (udev_monitor->sun.sun_family != 0) {\n\t\tstruct cmsghdr *cmsg = CMSG_FIRSTHDR(&smsg);\n\t\tstruct ucred *cred = (struct ucred *)CMSG_DATA (cmsg);\n\n\t\tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {\n\t\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (cred->uid != 0) {\n\t\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* skip header */\n\tbufpos = strlen(buf) + 1;\n\tif (bufpos < sizeof(\"a@/d\") || bufpos >= sizeof(buf)) {\n\t\tinfo(udev_monitor->udev, \"invalid message length\");\n\t\treturn NULL;\n\t}\n\n\t/* check message header */\n\tif (strstr(buf, \"@/\") == NULL) {\n\t\tinfo(udev_monitor->udev, \"unrecognized message header\");\n\t\treturn NULL;\n\t}\n\n\tudev_device = device_new(udev_monitor->udev);\n\tif (udev_device == NULL) {\n\t\treturn NULL;\n\t}\n\n\twhile (bufpos < sizeof(buf)) {\n\t\tchar *key;\n\t\tsize_t keylen;\n\n\t\tkey = &buf[bufpos];\n\t\tkeylen = strlen(key);\n\t\tif (keylen == 0)\n\t\t\tbreak;\n\t\tbufpos += keylen + 1;\n\n\t\tif (strncmp(key, \"DEVPATH=\", 8) == 0) {\n\t\t\tchar path[UTIL_PATH_SIZE];\n\n\t\t\tutil_strlcpy(path, udev_get_sys_path(udev_monitor->udev), sizeof(path));\n\t\t\tutil_strlcat(path, &key[8], sizeof(path));\n\t\t\tudev_device_set_syspath(udev_device, path);\n\t\t\tdevpath_set = 1;\n\t\t} else if (strncmp(key, \"SUBSYSTEM=\", 10) == 0) {\n\t\t\tudev_device_set_subsystem(udev_device, &key[10]);\n\t\t\tsubsystem_set = 1;\n\t\t} else if (strncmp(key, \"DEVTYPE=\", 8) == 0) {\n\t\t\tudev_device_set_devtype(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVNAME=\", 8) == 0) {\n\t\t\tudev_device_set_devnode(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVLINKS=\", 9) == 0) {\n\t\t\tchar devlinks[UTIL_PATH_SIZE];\n\t\t\tchar *slink;\n\t\t\tchar *next;\n\n\t\t\tutil_strlcpy(devlinks, &key[9], sizeof(devlinks));\n\t\t\tslink = devlinks;\n\t\t\tnext = strchr(slink, ' ');\n\t\t\twhile (next != NULL) {\n\t\t\t\tnext[0] = '\\0';\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t\t\tslink = &next[1];\n\t\t\t\tnext = strchr(slink, ' ');\n\t\t\t}\n\t\t\tif (slink[0] != '\\0')\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t} else if (strncmp(key, \"DRIVER=\", 7) == 0) {\n\t\t\tudev_device_set_driver(udev_device, &key[7]);\n\t\t} else if (strncmp(key, \"ACTION=\", 7) == 0) {\n\t\t\tudev_device_set_action(udev_device, &key[7]);\n\t\t\taction_set = 1;\n\t\t} else if (strncmp(key, \"MAJOR=\", 6) == 0) {\n\t\t\tmaj = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"MINOR=\", 6) == 0) {\n\t\t\tmin = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"DEVPATH_OLD=\", 12) == 0) {\n\t\t\tudev_device_set_devpath_old(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"PHYSDEVPATH=\", 12) == 0) {\n\t\t\tudev_device_set_physdevpath(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"SEQNUM=\", 7) == 0) {\n\t\t\tudev_device_set_seqnum(udev_device, strtoull(&key[7], NULL, 10));\n\t\t} else if (strncmp(key, \"TIMEOUT=\", 8) == 0) {\n\t\t\tudev_device_set_timeout(udev_device, strtoull(&key[8], NULL, 10));\n\t\t} else if (strncmp(key, \"PHYSDEV\", 7) == 0) {\n\t\t\t/* skip deprecated values */\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tudev_device_add_property_from_string(udev_device, key);\n\t\t}\n\t}\n\tif (!devpath_set || !subsystem_set || !action_set) {\n\t\tinfo(udev_monitor->udev, \"missing values, skip\\n\");\n\t\tudev_device_unref(udev_device);\n\t\treturn NULL;\n\t}\n\tif (maj > 0)\n\t\tudev_device_set_devnum(udev_device, makedev(maj, min));\n\tudev_device_set_info_loaded(udev_device);\n\treturn udev_device;\n}",
        "func_after": "struct udev_device *udev_monitor_receive_device(struct udev_monitor *udev_monitor)\n{\n\tstruct udev_device *udev_device;\n\tstruct msghdr smsg;\n\tstruct iovec iov;\n\tchar cred_msg[CMSG_SPACE(sizeof(struct ucred))];\n\tstruct cmsghdr *cmsg;\n\tstruct ucred *cred;\n\tchar buf[4096];\n\tsize_t bufpos;\n\tint devpath_set = 0;\n\tint subsystem_set = 0;\n\tint action_set = 0;\n\tint maj = 0;\n\tint min = 0;\n\n\tif (udev_monitor == NULL)\n\t\treturn NULL;\n\tmemset(buf, 0x00, sizeof(buf));\n\tiov.iov_base = &buf;\n\tiov.iov_len = sizeof(buf);\n\tmemset (&smsg, 0x00, sizeof(struct msghdr));\n\tsmsg.msg_iov = &iov;\n\tsmsg.msg_iovlen = 1;\n\tsmsg.msg_control = cred_msg;\n\tsmsg.msg_controllen = sizeof(cred_msg);\n\n\tif (recvmsg(udev_monitor->sock, &smsg, 0) < 0) {\n\t\tif (errno != EINTR)\n\t\t\tinfo(udev_monitor->udev, \"unable to receive message\");\n\t\treturn NULL;\n\t}\n\n\tcmsg = CMSG_FIRSTHDR(&smsg);\n\tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {\n\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");\n\t\treturn NULL;\n\t}\n\n\tcred = (struct ucred *)CMSG_DATA(cmsg);\n\tif (cred->uid != 0) {\n\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);\n\t\treturn NULL;\n\t}\n\n\t/* skip header */\n\tbufpos = strlen(buf) + 1;\n\tif (bufpos < sizeof(\"a@/d\") || bufpos >= sizeof(buf)) {\n\t\tinfo(udev_monitor->udev, \"invalid message length\");\n\t\treturn NULL;\n\t}\n\n\t/* check message header */\n\tif (strstr(buf, \"@/\") == NULL) {\n\t\tinfo(udev_monitor->udev, \"unrecognized message header\");\n\t\treturn NULL;\n\t}\n\n\tudev_device = device_new(udev_monitor->udev);\n\tif (udev_device == NULL) {\n\t\treturn NULL;\n\t}\n\n\twhile (bufpos < sizeof(buf)) {\n\t\tchar *key;\n\t\tsize_t keylen;\n\n\t\tkey = &buf[bufpos];\n\t\tkeylen = strlen(key);\n\t\tif (keylen == 0)\n\t\t\tbreak;\n\t\tbufpos += keylen + 1;\n\n\t\tif (strncmp(key, \"DEVPATH=\", 8) == 0) {\n\t\t\tchar path[UTIL_PATH_SIZE];\n\n\t\t\tutil_strlcpy(path, udev_get_sys_path(udev_monitor->udev), sizeof(path));\n\t\t\tutil_strlcat(path, &key[8], sizeof(path));\n\t\t\tudev_device_set_syspath(udev_device, path);\n\t\t\tdevpath_set = 1;\n\t\t} else if (strncmp(key, \"SUBSYSTEM=\", 10) == 0) {\n\t\t\tudev_device_set_subsystem(udev_device, &key[10]);\n\t\t\tsubsystem_set = 1;\n\t\t} else if (strncmp(key, \"DEVTYPE=\", 8) == 0) {\n\t\t\tudev_device_set_devtype(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVNAME=\", 8) == 0) {\n\t\t\tudev_device_set_devnode(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVLINKS=\", 9) == 0) {\n\t\t\tchar devlinks[UTIL_PATH_SIZE];\n\t\t\tchar *slink;\n\t\t\tchar *next;\n\n\t\t\tutil_strlcpy(devlinks, &key[9], sizeof(devlinks));\n\t\t\tslink = devlinks;\n\t\t\tnext = strchr(slink, ' ');\n\t\t\twhile (next != NULL) {\n\t\t\t\tnext[0] = '\\0';\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t\t\tslink = &next[1];\n\t\t\t\tnext = strchr(slink, ' ');\n\t\t\t}\n\t\t\tif (slink[0] != '\\0')\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t} else if (strncmp(key, \"DRIVER=\", 7) == 0) {\n\t\t\tudev_device_set_driver(udev_device, &key[7]);\n\t\t} else if (strncmp(key, \"ACTION=\", 7) == 0) {\n\t\t\tudev_device_set_action(udev_device, &key[7]);\n\t\t\taction_set = 1;\n\t\t} else if (strncmp(key, \"MAJOR=\", 6) == 0) {\n\t\t\tmaj = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"MINOR=\", 6) == 0) {\n\t\t\tmin = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"DEVPATH_OLD=\", 12) == 0) {\n\t\t\tudev_device_set_devpath_old(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"PHYSDEVPATH=\", 12) == 0) {\n\t\t\tudev_device_set_physdevpath(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"SEQNUM=\", 7) == 0) {\n\t\t\tudev_device_set_seqnum(udev_device, strtoull(&key[7], NULL, 10));\n\t\t} else if (strncmp(key, \"TIMEOUT=\", 8) == 0) {\n\t\t\tudev_device_set_timeout(udev_device, strtoull(&key[8], NULL, 10));\n\t\t} else if (strncmp(key, \"PHYSDEV\", 7) == 0) {\n\t\t\t/* skip deprecated values */\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tudev_device_add_property_from_string(udev_device, key);\n\t\t}\n\t}\n\tif (!devpath_set || !subsystem_set || !action_set) {\n\t\tinfo(udev_monitor->udev, \"missing values, skip\\n\");\n\t\tudev_device_unref(udev_device);\n\t\treturn NULL;\n\t}\n\tif (maj > 0)\n\t\tudev_device_set_devnum(udev_device, makedev(maj, min));\n\tudev_device_set_info_loaded(udev_device);\n\treturn udev_device;\n}",
        "description": "udev versions prior to 1.4.1 do not validate whether a NETLINK message originates from kernel space, enabling local users to escalate privileges by transmitting a NETLINK message from user space.",
        "commit": "To enhance protection, the system should disregard any unicast messages received on the netlink socket and any multicast messages on the kernel group that do not originate from the kernel."
    },
    {
        "cwe": "CWE-909",
        "func_name": "eclipse-openj9/resolveStaticMethodRefInto",
        "score": 0.7192001938819885,
        "func_before": "J9Method *   \nresolveStaticMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMStaticMethodRef *ramCPEntry)\n{\n\tJ9ROMMethodRef *romMethodRef;\n\tJ9Class *resolvedClass;\n\tJ9Method *method = NULL;\n\tJ9Class *cpClass;\n\tJ9Class *methodClass = NULL;\n\tBOOLEAN isResolvedClassAnInterface = FALSE;\n\tJ9ROMNameAndSignature *nameAndSig = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveStaticMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\ntryAgain:\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\tnameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\t/* Stack allocate a J9NameAndSignature structure for polymorphic signature methods */\n\tJ9NameAndSignature onStackNAS = {NULL, NULL};\n\tJ9UTF8 nullSignature = {0};\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\tif (resolvedClass == NULL) {\n\t\tgoto done;\n\t}\n\tisResolvedClassAnInterface = (J9AccInterface == (resolvedClass->romClass->modifiers & J9AccInterface));\n\n\t/* Find the method. */\n\tlookupOptions |= J9_LOOK_STATIC;\n\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) == J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\tcpClass = NULL;\n\t} else {\n\t\tcpClass = J9_CLASS_FROM_CP(ramCP);\n\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\n\t\tif (J2SE_VERSION(vmStruct->javaVM) >= J2SE_V11) {\n\t\t\t/* This check is only required in Java9 and there have been applications that\n\t\t\t * fail when this check is enabled on Java8.\n\t\t\t */\n\t\t\tif ((cpClass != NULL) && (cpClass->romClass != NULL)) {\n\t\t\t\tUDATA cpType = J9_CP_TYPE(J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass), cpIndex);\n\t\t\t\tif (isResolvedClassAnInterface) {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_STATIC_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_INSTANCE_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_METHOD != cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_STATIC_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_INSTANCE_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_METHOD == cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (isResolvedClassAnInterface) {\n\t\tlookupOptions |= J9_LOOK_INTERFACE;\n\t}\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vmStruct->javaVM)) {\n\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t/**\n\t\t * Check for MH intrinsic methods\n\t\t *\n\t\t * Modify the signature to avoid signature mismatch due to varargs\n\t\t * These methods have special INL send targets\n\t\t */\n\t\tU_8* methodName = J9UTF8_DATA(nameUTF);\n\t\tU_16 methodNameLength = J9UTF8_LENGTH(nameUTF);\n\n\t\tif (isMethodHandleINL(methodName, methodNameLength)) {\n\t\t\t/* Create new J9NameAndSignature */\n\t\t\tonStackNAS.name = nameUTF;\n\t\t\tonStackNAS.signature = &nullSignature;\n\t\t\tnameAndSig = (J9ROMNameAndSignature *)(&onStackNAS);\n\n\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n\t\t\tlookupOptions |= (J9_LOOK_DIRECT_NAS | J9_LOOK_PARTIAL_SIGNATURE);\n\t\t}\n\t}\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, nameAndSig, cpClass, lookupOptions);\n\n\tTrc_VM_resolveStaticMethodRef_lookupMethod(vmStruct, method);\n\n\tif (method == NULL) {\n\t\tgoto done;\n\t}\n\n\tmethodClass = J9_CLASS_FROM_METHOD(method);\n\tif (methodClass != resolvedClass) {\n\t\tif (isResolvedClassAnInterface) {\nincompat:\n\t\t\tif (throwException) {\n\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, NULL);\n\t\t\t}\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Initialize the defining class of the method. */\n\t\n\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CLASS_INIT)) {\n\t\tJ9Class *methodClass = J9_CLASS_FROM_METHOD(method);\n\t\tUDATA initStatus = methodClass->initializeStatus;\n\t\tif (jitCompileTimeResolve && (J9ClassInitSucceeded != initStatus)) {\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t\tif (initStatus != J9ClassInitSucceeded && initStatus != (UDATA)vmStruct) {\n\t\t\t/* Initialize the class if java code is allowed */\n\t\t\tif (canRunJavaCode) {\n\t\t\t\tUDATA preCount = vmStruct->javaVM->hotSwapCount;\n\n\t\t\t\tinitializeClass(vmStruct, methodClass);\n\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\tmethod = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (preCount != vmStruct->javaVM->hotSwapCount) {\n\t\t\t\t\tgoto tryAgain;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Can't initialize the class, so fail the resolve */\n\t\t\t\tmethod = NULL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tif (NULL != ramCPEntry)\n\t{\n\t\tramCPEntry->method = method;\n\t}\n\ndone:\n\tTrc_VM_resolveStaticMethodRef_Exit(vmStruct, method);\n\treturn method;\n}",
        "func_after": "J9Method *   \nresolveStaticMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMStaticMethodRef *ramCPEntry)\n{\n\tJ9ROMMethodRef *romMethodRef;\n\tJ9Class *resolvedClass;\n\tJ9Method *method = NULL;\n\tJ9Class *cpClass;\n\tJ9Class *methodClass = NULL;\n\tBOOLEAN isResolvedClassAnInterface = FALSE;\n\tJ9ROMNameAndSignature *nameAndSig = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveStaticMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\ntryAgain:\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\tnameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\t/* Stack allocate a J9NameAndSignature structure for polymorphic signature methods */\n\tJ9NameAndSignature onStackNAS = {NULL, NULL};\n\tJ9UTF8 nullSignature = {0};\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\tif (resolvedClass == NULL) {\n\t\tgoto done;\n\t}\n\tisResolvedClassAnInterface = (J9AccInterface == (resolvedClass->romClass->modifiers & J9AccInterface));\n\n\t/* Find the method. */\n\tlookupOptions |= J9_LOOK_STATIC;\n\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) == J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\tcpClass = NULL;\n\t} else {\n\t\tcpClass = J9_CLASS_FROM_CP(ramCP);\n\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\n\t\tif (J2SE_VERSION(vmStruct->javaVM) >= J2SE_V11) {\n\t\t\t/* This check is only required in Java9 and there have been applications that\n\t\t\t * fail when this check is enabled on Java8.\n\t\t\t */\n\t\t\tif ((cpClass != NULL) && (cpClass->romClass != NULL)) {\n\t\t\t\tUDATA cpType = J9_CP_TYPE(J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass), cpIndex);\n\t\t\t\tif (isResolvedClassAnInterface) {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_STATIC_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_INSTANCE_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_METHOD != cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_STATIC_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_INSTANCE_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_METHOD == cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (isResolvedClassAnInterface) {\n\t\tlookupOptions |= J9_LOOK_INTERFACE;\n\t}\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vmStruct->javaVM)) {\n\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t/**\n\t\t * Check for MH intrinsic methods\n\t\t *\n\t\t * Modify the signature to avoid signature mismatch due to varargs\n\t\t * These methods have special INL send targets\n\t\t */\n\t\tU_8* methodName = J9UTF8_DATA(nameUTF);\n\t\tU_16 methodNameLength = J9UTF8_LENGTH(nameUTF);\n\n\t\tif (isMethodHandleINL(methodName, methodNameLength)) {\n\t\t\t/* Create new J9NameAndSignature */\n\t\t\tonStackNAS.name = nameUTF;\n\t\t\tonStackNAS.signature = &nullSignature;\n\t\t\tnameAndSig = (J9ROMNameAndSignature *)(&onStackNAS);\n\n\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n\t\t\tlookupOptions |= (J9_LOOK_DIRECT_NAS | J9_LOOK_PARTIAL_SIGNATURE);\n\t\t}\n\t}\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, nameAndSig, cpClass, lookupOptions);\n\n\tTrc_VM_resolveStaticMethodRef_lookupMethod(vmStruct, method);\n\n\tif (method == NULL) {\n\t\tgoto done;\n\t}\n\n\tmethodClass = J9_CLASS_FROM_METHOD(method);\n\tif (methodClass != resolvedClass) {\n\t\tif (isResolvedClassAnInterface) {\nincompat:\n\t\t\tif (throwException) {\n\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, NULL);\n\t\t\t}\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Initialize the defining class of the method. */\n\t\n\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CLASS_INIT)) {\n\t\tJ9Class *methodClass = J9_CLASS_FROM_METHOD(method);\n\t\tUDATA initStatus = methodClass->initializeStatus;\n\t\tif (jitCompileTimeResolve && (J9ClassInitSucceeded != initStatus)) {\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t\tif (initStatus != J9ClassInitSucceeded && initStatus != (UDATA)vmStruct) {\n\t\t\t/* Initialize the class if java code is allowed */\n\t\t\tif (canRunJavaCode) {\n\t\t\t\tUDATA preCount = vmStruct->javaVM->hotSwapCount;\n\n\t\t\t\tinitializeClass(vmStruct, methodClass);\n\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\tmethod = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (preCount != vmStruct->javaVM->hotSwapCount) {\n\t\t\t\t\tgoto tryAgain;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Can't initialize the class, so fail the resolve */\n\t\t\t\tmethod = NULL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\tramCPEntry->method = method;\n\t}\n\ndone:\n\tTrc_VM_resolveStaticMethodRef_Exit(vmStruct, method);\n\treturn method;\n}",
        "description": "In Eclipse OpenJ9 up to version 0.25.0, the use of the `jdk.internal.reflect.ConstantPool` API leads to the JVM pre-resolving certain constant pool entries in some cases. This behavior enables users to invoke static methods or access static members without executing the class initialization method, potentially allowing them to observe uninitialized values.",
        "commit": "When utilizing ConstantPool, ensure that classes are correctly loaded and initialized. Avoid loading classes during \"ifLoaded\" calls, refrain from initializing classes in native methods, and do not update the constant pool when querying from native methods."
    },
    {
        "cwe": "CWE-404",
        "func_name": "wireshark/dissect_iscsi",
        "score": 0.7092415690422058,
        "func_before": "static int\ndissect_iscsi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean check_port) {\n    /* Set up structures needed to add the protocol subtree and manage it */\n    guint offset = 0;\n    guint32 available_bytes = tvb_captured_length(tvb);\n    int digestsActive = 1;\n    conversation_t *conversation = NULL;\n    iscsi_session_t *iscsi_session=NULL;\n    guint8 opcode, tmpbyte;\n\n    if (available_bytes < 48) {\n        /* heuristic already rejected the packet if size < 48,\n           assume it's an iscsi packet with a segmented header */\n        pinfo->desegment_offset = offset;\n        pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\n        return -1;\n    }\n\n    opcode = tvb_get_guint8(tvb, offset + 0);\n    opcode &= OPCODE_MASK;\n\n    /* heuristics to verify that the packet looks sane.   the heuristics\n     * are based on the RFC version of iscsi.\n     * (we should retire support for older iscsi versions in wireshark)\n     *      -- ronnie s\n     */\n    /* opcode must be any of the ones from the standard\n     * also check the header that it looks \"sane\"\n     * all reserved or undefined bits in iscsi must be set to zero.\n     */\n    switch(opcode){\n    case ISCSI_OPCODE_NOP_IN:\n        /* top two bits of byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2 and 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_NOP_OUT:\n        /* top bit of byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2 and 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        /* assume ITT and TTT must always be non NULL (ok they can be NULL\n         * from time to time but it usually means we are in the middle\n         * of a zeroed datablock).\n         */\n        if(!tvb_get_letohl(tvb,offset+16) || !tvb_get_letohl(tvb,offset+20)){\n            return 0;\n        }\n        /* all reserved bytes between 32 - 47 must be null */\n        if(tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGIN_COMMAND:\n        /* top two bits in byte 0 must be 0x40 */\n        if((tvb_get_guint8(tvb, offset+0)&0xc0)!=0x40){\n\n            return 0;\n        }\n        /* both the T and C bits can not be set\n         * and the two reserved bits in byte 1 must be 0\n         */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        switch(tmpbyte&0xf0){\n        case 0x80:\n        case 0x40:\n        case 0x00:\n            break;\n        default:\n            return 0;\n        }\n        /* CSG and NSG must not be 2 */\n        if(((tmpbyte & 0x03) == 0x02)\n           || ((tmpbyte & 0x0c) == 0x08)) {\n            return 0;\n        }\n        /* if T bit is set NSG must not be 0 */\n        if(tmpbyte&0x80){\n            if(!(tmpbyte&0x03)){\n                return 0;\n            }\n        }\n        /* should we test that datasegmentlen is non zero? */\n        break;\n    case ISCSI_OPCODE_LOGIN_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n\n            return 0;\n        }\n        /* both the T and C bits can not be set\n         * and the two reserved bits in byte 1 must be 0\n         */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        switch(tmpbyte&0xf0){\n        case 0x80:\n        case 0x40:\n        case 0x00:\n            break;\n        default:\n            return 0;\n        }\n        /* CSG and NSG must not be 2 */\n        if(((tmpbyte & 0x03) == 0x02)\n           || ((tmpbyte & 0x0c) == 0x08)) {\n            return 0;\n        }\n        /* if T bit is set NSG must not be 0 */\n        if(tmpbyte&0x80){\n            if(!(tmpbyte&0x03)){\n                return 0;\n            }\n        }\n        /* the 32bit words at offsets 20, 40, 44 must be zero */\n        if(tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the two bytes at offset 38 must be zero */\n        if(tvb_get_letohs(tvb,offset+38)){\n            return 0;\n        }\n        /* should we test that datasegmentlen is non zero unless we just\n         * entered full featured phase?\n         */\n        break;\n    case ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* top bit in byte 1 must be set */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* Function must be known */\n        if(!try_val_to_str(tmpbyte&0x7f, iscsi_task_management_functions)){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl must be null */\n        if(tvb_get_letohl(tvb,offset+4)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* response must be 0-6 or 255 */\n        tmpbyte=tvb_get_guint8(tvb,offset+2);\n        if(tmpbyte>6 && tmpbyte<255){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb,offset+3)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 20, 36\n         * 40, 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGOUT_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* top bit in byte 1 must be set */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* Reason code must be known */\n        if(!try_val_to_str(tmpbyte&0x7f, iscsi_logout_reasons)){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 32, 36\n         * 40, 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SNACK_REQUEST:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* top 4 bits in byte 1 must be 0x80 */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if((tmpbyte&0xf0)!=0x80){\n            return 0;\n        }\n        /* type must be known */\n        if(!try_val_to_str(tmpbyte&0x0f, iscsi_snack_types)){\n            return 0;\n        }\n        /* for status/snack and datack itt must be 0xffffffff\n         * for rdata/snack ttt must not be 0 or 0xffffffff\n         */\n        switch(tmpbyte&0x0f){\n        case 1:\n        case 2:\n            if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n                return 0;\n            }\n            break;\n        case 3:\n            if(tvb_get_letohl(tvb,offset+20)==0xffffffff){\n                return 0;\n            }\n            if(tvb_get_letohl(tvb,offset+20)==0){\n                return 0;\n            }\n            break;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 24, 32, 36\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+24)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)){\n            return 0;\n        }\n\n        break;\n    case ISCSI_OPCODE_R2T:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl must be null */\n        if(tvb_get_letohl(tvb,offset+4)){\n            return 0;\n        }\n        /* desired data transfer length must not be null */\n        if(!tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_REJECT:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* reason must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_reject_reasons)){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        /* the 32bit words at offsets 8, 12, 20, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the 32bit word at 16 must be 0xffffffff */\n        if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TEXT_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* one of the F and C bits must be set but not both\n         * low 6 bits in byte 1 must be 0\n         */\n        switch(tvb_get_guint8(tvb,offset+1)){\n        case 0x80:\n        case 0x40:\n            break;\n        default:\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 32, 36, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TEXT_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* one of the F and C bits must be set but not both\n         * low 6 bits in byte 1 must be 0\n         */\n        switch(tvb_get_guint8(tvb,offset+1)){\n        case 0x80:\n        case 0x40:\n            break;\n        default:\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 36, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* reserved bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb, offset+1)&0x18){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* if expected data transfer length is set, W and/or R have to be set */\n        if(tvb_get_ntohl(tvb,offset+20)){\n            if(!(tvb_get_guint8(tvb, offset+1)&0x60)){\n                return 0;\n            }\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* top bit in byte 1 must be 1 */\n        tmpbyte=tvb_get_guint8(tvb,offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* the reserved bits in byte 1 must be 0 */\n        if(tmpbyte&0x61){\n            return 0;\n        }\n        /* status must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+3), scsi_status_val)){\n            return 0;\n        }\n        /* the 32bit words at offsets 8, 12\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_ASYNC_MESSAGE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 20, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the 32bit word at 16 must be 0xffffffff */\n        if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGOUT_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* response must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_logout_response)){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb,offset+3)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 20, 36\n         * 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_DATA_OUT:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* low 7 bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb,offset+1)&0x7f){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 24, 32, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+24)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_DATA_IN:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* reserved bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb,offset+1)&0x38){\n            return 0;\n        }\n        /* byte 2 must be reserved */\n        if(tvb_get_guint8(tvb,offset+2)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I0:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I1:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I2:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T0:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T1:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T2:\n        break;\n    default:\n        return 0;\n    } /* end of heuristics check */\n\n\n    /* process multiple iSCSI PDUs per packet */\n    while(available_bytes >= 48 || (iscsi_desegment && available_bytes >= 8)) {\n        const char *opcode_str = NULL;\n        guint32 data_segment_len;\n        guint32 pduLen = 48;\n        guint8 secondPduByte = tvb_get_guint8(tvb, offset + 1);\n        int badPdu = FALSE;\n        guint8 ahsLen=0;\n        guint32 data_segment_offset, data_segment_len_padded;\n\n        /* mask out any extra bits in the opcode byte */\n        opcode = tvb_get_guint8(tvb, offset + 0);\n        opcode &= OPCODE_MASK;\n\n        opcode_str = try_val_to_str(opcode, iscsi_opcodes);\n        if(opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION ||\n           opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\n           opcode == ISCSI_OPCODE_R2T ||\n           opcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\n           opcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\n           opcode == ISCSI_OPCODE_SNACK_REQUEST)\n            data_segment_len = 0;\n        else\n            data_segment_len = tvb_get_ntohl(tvb, offset + 4) & 0x00ffffff;\n\n        if(opcode_str == NULL) {\n            badPdu = TRUE;\n        }\n\n\n        if(!badPdu && check_port) {\n            badPdu = TRUE;\n            if ((opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->srcport)) {\n                badPdu = FALSE;\n            }\n            if (!(opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->destport)) {\n                badPdu = FALSE;\n            }\n            if ((opcode & TARGET_OPCODE_BIT) && pinfo->srcport == iscsi_system_port) {\n                badPdu = FALSE;\n            }\n            if (!(opcode & TARGET_OPCODE_BIT) && pinfo->destport == iscsi_system_port) {\n                badPdu = FALSE;\n            }\n        }\n\n        if(!badPdu && enable_bogosity_filter) {\n            /* try and distinguish between data and real headers */\n            if(data_segment_len > bogus_pdu_data_length_threshold) {\n                badPdu = TRUE;\n            }\n            else if(demand_good_f_bit &&\n                    !(secondPduByte & 0x80) &&\n                    (opcode == ISCSI_OPCODE_NOP_OUT ||\n                     opcode == ISCSI_OPCODE_NOP_IN ||\n                     opcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\n                     opcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\n                     opcode == ISCSI_OPCODE_SCSI_RESPONSE ||\n                     opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\n                     opcode == ISCSI_OPCODE_R2T ||\n                     opcode == ISCSI_OPCODE_ASYNC_MESSAGE ||\n                     opcode == ISCSI_OPCODE_SNACK_REQUEST ||\n                     opcode == ISCSI_OPCODE_REJECT)) {\n                badPdu = TRUE;\n            } else if(opcode==ISCSI_OPCODE_NOP_OUT) {\n                /* TransferTag for NOP-Out should either be -1 or\n                   the tag value we want for a response.\n                   Assume 0 means we are just inside a big all zero\n                   datablock.\n                */\n                if(tvb_get_ntohl(tvb, offset+20)==0){\n                    badPdu = TRUE;\n                }\n            }\n        }\n\n        if(badPdu) {\n            return offset;\n        }\n\n        if(opcode == ISCSI_OPCODE_LOGIN_COMMAND ||\n           opcode == ISCSI_OPCODE_LOGIN_RESPONSE) {\n            if(iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT08) {\n                if((secondPduByte & CSG_MASK) < ISCSI_CSG_OPERATIONAL_NEGOTIATION) {\n                    /* digests are not yet turned on */\n                    digestsActive = 0;\n                }\n            } else {\n                digestsActive = 0;\n            }\n        }\n\n        if(opcode == ISCSI_OPCODE_SCSI_COMMAND) {\n            /* ahsLen */\n            ahsLen = tvb_get_guint8(tvb, offset + 4);\n            pduLen += ahsLen * 4;\n        }\n\n        data_segment_offset = pduLen;\n        data_segment_len_padded = data_segment_len;\n        if((data_segment_len_padded & 3) != 0)\n            data_segment_len_padded += 4 - (data_segment_len_padded & 3);\n        pduLen += data_segment_len_padded;\n\n\n        /* make sure we have a conversation for this session */\n        conversation = find_or_create_conversation(pinfo);\n\n        iscsi_session=(iscsi_session_t *)conversation_get_proto_data(conversation, proto_iscsi);\n        if(!iscsi_session){\n            iscsi_session = wmem_new(wmem_file_scope(), iscsi_session_t);\n            iscsi_session->header_digest = ISCSI_DIGEST_AUTO;\n            iscsi_session->data_digest = ISCSI_DIGEST_AUTO;\n            iscsi_session->itlq = wmem_tree_new(wmem_file_scope());\n            iscsi_session->itl  = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);\n            conversation_add_proto_data(conversation, proto_iscsi, iscsi_session);\n\n            /* DataOut PDUs are often mistaken by DCERPC heuristics to be\n             * that protocol. Now that we know this is iscsi, set a\n             * dissector for this conversation to block other heuristic\n             * dissectors.\n             */\n            conversation_set_dissector(conversation, iscsi_handle);\n        }\n        /* try to autodetect if header digest is used or not */\n        if (digestsActive && (available_bytes >= (guint32) (48+4+ahsLen*4)) &&\n            (iscsi_session->header_digest == ISCSI_DIGEST_AUTO)) {\n            guint32 crc;\n            /* we have enough data to test if HeaderDigest is enabled */\n            crc= ~crc32c_tvb_offset_calculate(tvb, offset, 48+ahsLen*4, CRC32C_PRELOAD);\n            if(crc==tvb_get_ntohl(tvb,48+ahsLen*4)){\n                iscsi_session->header_digest = ISCSI_DIGEST_CRC32;\n            } else {\n                iscsi_session->header_digest = ISCSI_DIGEST_NONE;\n            }\n        }\n\n\n        /* Add header digest length to pdulen */\n        if(digestsActive){\n            switch(iscsi_session->header_digest){\n            case ISCSI_DIGEST_CRC32:\n                pduLen += 4;\n                data_segment_offset += 4;\n                break;\n            case ISCSI_DIGEST_NONE:\n                break;\n            case ISCSI_DIGEST_AUTO:\n                /* oops we don't yet know what digest is used */\n                /* here we should use some default */\n                break;\n            default:\n                DISSECTOR_ASSERT_NOT_REACHED();\n            }\n        }\n\n        /* try to autodetect whether data digest is used */\n        if (digestsActive &&\n            (available_bytes >= data_segment_offset + data_segment_len_padded + 4) &&\n            (iscsi_session->data_digest == ISCSI_DIGEST_AUTO)) {\n            guint32 crc;\n            /* we have enough data to test if DataDigest is enabled */\n            crc = ~crc32c_tvb_offset_calculate(tvb, data_segment_offset, data_segment_len_padded, CRC32C_PRELOAD);\n            if (crc == tvb_get_ntohl(tvb, data_segment_offset + data_segment_len_padded)) {\n                iscsi_session->data_digest = ISCSI_DIGEST_CRC32;\n            } else {\n                iscsi_session->data_digest = ISCSI_DIGEST_NONE;\n            }\n        }\n\n        /* Add data digest length to pdulen */\n        if (digestsActive && data_segment_len > 0) {\n            switch (iscsi_session->data_digest) {\n            case ISCSI_DIGEST_CRC32:\n                pduLen += 4;\n                break;\n            case ISCSI_DIGEST_NONE:\n                break;\n            case ISCSI_DIGEST_AUTO:\n                /* unknown digest, perhaps a new field was introduced? */\n                break;\n            default:\n                DISSECTOR_ASSERT_NOT_REACHED();\n            }\n        }\n\n        /*\n         * Desegmentation check.\n         */\n        if(iscsi_desegment && pinfo->can_desegment) {\n            if(pduLen > available_bytes) {\n                /*\n                 * This frame doesn't have all of the data for\n                 * this message, but we can do reassembly on it.\n                 *\n                 * Tell the TCP dissector where the data for this\n                 * message starts in the data it handed us, and\n                 * how many more bytes we need, and return.\n                 */\n                pinfo->desegment_offset = offset;\n                pinfo->desegment_len = pduLen - available_bytes;\n                return -1;\n            }\n        }\n\n        /* This is to help TCP keep track of PDU boundaries\n           and allows it to find PDUs that are not aligned to\n           the start of a TCP segments.\n           Since it also allows TCP to know what is in the middle\n           of a large PDU, it reduces the probability of a segment\n           in the middle of a large PDU transfer being misdissected as\n           a PDU.\n        */\n        if(!pinfo->fd->visited){\n            if(pduLen>(guint32)tvb_reported_length_remaining(tvb, offset)){\n                pinfo->want_pdu_tracking=2;\n                pinfo->bytes_until_next_pdu=pduLen-tvb_reported_length_remaining(tvb, offset);\n            }\n        }\n\n        if (offset == 0)\n            col_set_str(pinfo->cinfo, COL_INFO, \"\");\n        else\n            col_append_str(pinfo->cinfo, COL_INFO, \", \");\n\n        dissect_iscsi_pdu(tvb, pinfo, tree, offset, opcode, opcode_str, data_segment_len, iscsi_session, conversation);\n        if(pduLen > available_bytes)\n            pduLen = available_bytes;\n        offset += pduLen;\n        available_bytes -= pduLen;\n    }\n\n    return offset;\n}",
        "func_after": "static int\ndissect_iscsi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean check_port) {\n    /* Set up structures needed to add the protocol subtree and manage it */\n    guint offset = 0;\n    guint32 available_bytes = tvb_captured_length(tvb);\n    int digestsActive = 1;\n    conversation_t *conversation = NULL;\n    iscsi_session_t *iscsi_session=NULL;\n    guint8 opcode, tmpbyte;\n\n    if (available_bytes < 48) {\n        /* heuristic already rejected the packet if size < 48,\n           assume it's an iscsi packet with a segmented header */\n        pinfo->desegment_offset = offset;\n        pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\n        return -1;\n    }\n\n    opcode = tvb_get_guint8(tvb, offset + 0);\n    opcode &= OPCODE_MASK;\n\n    /* heuristics to verify that the packet looks sane.   the heuristics\n     * are based on the RFC version of iscsi.\n     * (we should retire support for older iscsi versions in wireshark)\n     *      -- ronnie s\n     */\n    /* opcode must be any of the ones from the standard\n     * also check the header that it looks \"sane\"\n     * all reserved or undefined bits in iscsi must be set to zero.\n     */\n    switch(opcode){\n    case ISCSI_OPCODE_NOP_IN:\n        /* top two bits of byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2 and 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_NOP_OUT:\n        /* top bit of byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2 and 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        /* assume ITT and TTT must always be non NULL (ok they can be NULL\n         * from time to time but it usually means we are in the middle\n         * of a zeroed datablock).\n         */\n        if(!tvb_get_letohl(tvb,offset+16) || !tvb_get_letohl(tvb,offset+20)){\n            return 0;\n        }\n        /* all reserved bytes between 32 - 47 must be null */\n        if(tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGIN_COMMAND:\n        /* top two bits in byte 0 must be 0x40 */\n        if((tvb_get_guint8(tvb, offset+0)&0xc0)!=0x40){\n\n            return 0;\n        }\n        /* both the T and C bits can not be set\n         * and the two reserved bits in byte 1 must be 0\n         */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        switch(tmpbyte&0xf0){\n        case 0x80:\n        case 0x40:\n        case 0x00:\n            break;\n        default:\n            return 0;\n        }\n        /* CSG and NSG must not be 2 */\n        if(((tmpbyte & 0x03) == 0x02)\n           || ((tmpbyte & 0x0c) == 0x08)) {\n            return 0;\n        }\n        /* if T bit is set NSG must not be 0 */\n        if(tmpbyte&0x80){\n            if(!(tmpbyte&0x03)){\n                return 0;\n            }\n        }\n        /* should we test that datasegmentlen is non zero? */\n        break;\n    case ISCSI_OPCODE_LOGIN_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n\n            return 0;\n        }\n        /* both the T and C bits can not be set\n         * and the two reserved bits in byte 1 must be 0\n         */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        switch(tmpbyte&0xf0){\n        case 0x80:\n        case 0x40:\n        case 0x00:\n            break;\n        default:\n            return 0;\n        }\n        /* CSG and NSG must not be 2 */\n        if(((tmpbyte & 0x03) == 0x02)\n           || ((tmpbyte & 0x0c) == 0x08)) {\n            return 0;\n        }\n        /* if T bit is set NSG must not be 0 */\n        if(tmpbyte&0x80){\n            if(!(tmpbyte&0x03)){\n                return 0;\n            }\n        }\n        /* the 32bit words at offsets 20, 40, 44 must be zero */\n        if(tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the two bytes at offset 38 must be zero */\n        if(tvb_get_letohs(tvb,offset+38)){\n            return 0;\n        }\n        /* should we test that datasegmentlen is non zero unless we just\n         * entered full featured phase?\n         */\n        break;\n    case ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* top bit in byte 1 must be set */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* Function must be known */\n        if(!try_val_to_str(tmpbyte&0x7f, iscsi_task_management_functions)){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl must be null */\n        if(tvb_get_letohl(tvb,offset+4)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* response must be 0-6 or 255 */\n        tmpbyte=tvb_get_guint8(tvb,offset+2);\n        if(tmpbyte>6 && tmpbyte<255){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb,offset+3)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 20, 36\n         * 40, 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGOUT_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* top bit in byte 1 must be set */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* Reason code must be known */\n        if(!try_val_to_str(tmpbyte&0x7f, iscsi_logout_reasons)){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 32, 36\n         * 40, 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SNACK_REQUEST:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* top 4 bits in byte 1 must be 0x80 */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if((tmpbyte&0xf0)!=0x80){\n            return 0;\n        }\n        /* type must be known */\n        if(!try_val_to_str(tmpbyte&0x0f, iscsi_snack_types)){\n            return 0;\n        }\n        /* for status/snack and datack itt must be 0xffffffff\n         * for rdata/snack ttt must not be 0 or 0xffffffff\n         */\n        switch(tmpbyte&0x0f){\n        case 1:\n        case 2:\n            if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n                return 0;\n            }\n            break;\n        case 3:\n            if(tvb_get_letohl(tvb,offset+20)==0xffffffff){\n                return 0;\n            }\n            if(tvb_get_letohl(tvb,offset+20)==0){\n                return 0;\n            }\n            break;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 24, 32, 36\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+24)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)){\n            return 0;\n        }\n\n        break;\n    case ISCSI_OPCODE_R2T:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl must be null */\n        if(tvb_get_letohl(tvb,offset+4)){\n            return 0;\n        }\n        /* desired data transfer length must not be null */\n        if(!tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_REJECT:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* reason must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_reject_reasons)){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        /* the 32bit words at offsets 8, 12, 20, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the 32bit word at 16 must be 0xffffffff */\n        if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TEXT_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* one of the F and C bits must be set but not both\n         * low 6 bits in byte 1 must be 0\n         */\n        switch(tvb_get_guint8(tvb,offset+1)){\n        case 0x80:\n        case 0x40:\n            break;\n        default:\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 32, 36, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TEXT_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* one of the F and C bits must be set but not both\n         * low 6 bits in byte 1 must be 0\n         */\n        switch(tvb_get_guint8(tvb,offset+1)){\n        case 0x80:\n        case 0x40:\n            break;\n        default:\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 36, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* reserved bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb, offset+1)&0x18){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* if expected data transfer length is set, W and/or R have to be set */\n        if(tvb_get_ntohl(tvb,offset+20)){\n            if(!(tvb_get_guint8(tvb, offset+1)&0x60)){\n                return 0;\n            }\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* top bit in byte 1 must be 1 */\n        tmpbyte=tvb_get_guint8(tvb,offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* the reserved bits in byte 1 must be 0 */\n        if(tmpbyte&0x61){\n            return 0;\n        }\n        /* status must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+3), scsi_status_val)){\n            return 0;\n        }\n        /* the 32bit words at offsets 8, 12\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_ASYNC_MESSAGE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 20, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the 32bit word at 16 must be 0xffffffff */\n        if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGOUT_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* response must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_logout_response)){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb,offset+3)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 20, 36\n         * 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_DATA_OUT:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* low 7 bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb,offset+1)&0x7f){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 24, 32, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+24)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_DATA_IN:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* reserved bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb,offset+1)&0x38){\n            return 0;\n        }\n        /* byte 2 must be reserved */\n        if(tvb_get_guint8(tvb,offset+2)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I0:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I1:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I2:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T0:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T1:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T2:\n        break;\n    default:\n        return 0;\n    } /* end of heuristics check */\n\n\n    /* process multiple iSCSI PDUs per packet */\n    while(available_bytes >= 48 || (iscsi_desegment && available_bytes >= 8)) {\n        guint32 data_segment_len;\n        guint32 pduLen = 48;\n        guint8 secondPduByte = tvb_get_guint8(tvb, offset + 1);\n        int badPdu = FALSE;\n        guint8 ahsLen=0;\n        guint32 data_segment_offset, data_segment_len_padded;\n\n        /* mask out any extra bits in the opcode byte */\n        opcode = tvb_get_guint8(tvb, offset + 0);\n        opcode &= OPCODE_MASK;\n\n        if(opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION ||\n           opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\n           opcode == ISCSI_OPCODE_R2T ||\n           opcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\n           opcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\n           opcode == ISCSI_OPCODE_SNACK_REQUEST)\n            data_segment_len = 0;\n        else\n            data_segment_len = tvb_get_ntohl(tvb, offset + 4) & 0x00ffffff;\n\n        if (!try_val_to_str(opcode, iscsi_opcodes)) {\n            badPdu = TRUE;\n        }\n\n\n        if(!badPdu && check_port) {\n            badPdu = TRUE;\n            if ((opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->srcport)) {\n                badPdu = FALSE;\n            }\n            if (!(opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->destport)) {\n                badPdu = FALSE;\n            }\n            if ((opcode & TARGET_OPCODE_BIT) && pinfo->srcport == iscsi_system_port) {\n                badPdu = FALSE;\n            }\n            if (!(opcode & TARGET_OPCODE_BIT) && pinfo->destport == iscsi_system_port) {\n                badPdu = FALSE;\n            }\n        }\n\n        if(!badPdu && enable_bogosity_filter) {\n            /* try and distinguish between data and real headers */\n            if(data_segment_len > bogus_pdu_data_length_threshold) {\n                badPdu = TRUE;\n            }\n            else if(demand_good_f_bit &&\n                    !(secondPduByte & 0x80) &&\n                    (opcode == ISCSI_OPCODE_NOP_OUT ||\n                     opcode == ISCSI_OPCODE_NOP_IN ||\n                     opcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\n                     opcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\n                     opcode == ISCSI_OPCODE_SCSI_RESPONSE ||\n                     opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\n                     opcode == ISCSI_OPCODE_R2T ||\n                     opcode == ISCSI_OPCODE_ASYNC_MESSAGE ||\n                     opcode == ISCSI_OPCODE_SNACK_REQUEST ||\n                     opcode == ISCSI_OPCODE_REJECT)) {\n                badPdu = TRUE;\n            } else if(opcode==ISCSI_OPCODE_NOP_OUT) {\n                /* TransferTag for NOP-Out should either be -1 or\n                   the tag value we want for a response.\n                   Assume 0 means we are just inside a big all zero\n                   datablock.\n                */\n                if(tvb_get_ntohl(tvb, offset+20)==0){\n                    badPdu = TRUE;\n                }\n            }\n        }\n\n        if(badPdu) {\n            return offset;\n        }\n\n        if(opcode == ISCSI_OPCODE_LOGIN_COMMAND ||\n           opcode == ISCSI_OPCODE_LOGIN_RESPONSE) {\n            if(iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT08) {\n                if((secondPduByte & CSG_MASK) < ISCSI_CSG_OPERATIONAL_NEGOTIATION) {\n                    /* digests are not yet turned on */\n                    digestsActive = 0;\n                }\n            } else {\n                digestsActive = 0;\n            }\n        }\n\n        if(opcode == ISCSI_OPCODE_SCSI_COMMAND) {\n            /* ahsLen */\n            ahsLen = tvb_get_guint8(tvb, offset + 4);\n            pduLen += ahsLen * 4;\n        }\n\n        data_segment_offset = pduLen;\n        data_segment_len_padded = data_segment_len;\n        if((data_segment_len_padded & 3) != 0)\n            data_segment_len_padded += 4 - (data_segment_len_padded & 3);\n        pduLen += data_segment_len_padded;\n\n\n        /* make sure we have a conversation for this session */\n        conversation = find_or_create_conversation(pinfo);\n\n        iscsi_session=(iscsi_session_t *)conversation_get_proto_data(conversation, proto_iscsi);\n        if(!iscsi_session){\n            iscsi_session = wmem_new(wmem_file_scope(), iscsi_session_t);\n            iscsi_session->header_digest = ISCSI_DIGEST_AUTO;\n            iscsi_session->data_digest = ISCSI_DIGEST_AUTO;\n            iscsi_session->itlq = wmem_tree_new(wmem_file_scope());\n            iscsi_session->itl  = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);\n            conversation_add_proto_data(conversation, proto_iscsi, iscsi_session);\n\n            /* DataOut PDUs are often mistaken by DCERPC heuristics to be\n             * that protocol. Now that we know this is iscsi, set a\n             * dissector for this conversation to block other heuristic\n             * dissectors.\n             */\n            conversation_set_dissector(conversation, iscsi_handle);\n        }\n        /* try to autodetect if header digest is used or not */\n        if (digestsActive && (available_bytes >= (guint32) (48+4+ahsLen*4)) &&\n            (iscsi_session->header_digest == ISCSI_DIGEST_AUTO)) {\n            guint32 crc;\n            /* we have enough data to test if HeaderDigest is enabled */\n            crc= ~crc32c_tvb_offset_calculate(tvb, offset, 48+ahsLen*4, CRC32C_PRELOAD);\n            if(crc==tvb_get_ntohl(tvb,48+ahsLen*4)){\n                iscsi_session->header_digest = ISCSI_DIGEST_CRC32;\n            } else {\n                iscsi_session->header_digest = ISCSI_DIGEST_NONE;\n            }\n        }\n\n\n        /* Add header digest length to pdulen */\n        if(digestsActive){\n            switch(iscsi_session->header_digest){\n            case ISCSI_DIGEST_CRC32:\n                pduLen += 4;\n                data_segment_offset += 4;\n                break;\n            case ISCSI_DIGEST_NONE:\n                break;\n            case ISCSI_DIGEST_AUTO:\n                /* oops we don't yet know what digest is used */\n                /* here we should use some default */\n                break;\n            default:\n                DISSECTOR_ASSERT_NOT_REACHED();\n            }\n        }\n\n        /* try to autodetect whether data digest is used */\n        if (digestsActive &&\n            (available_bytes >= data_segment_offset + data_segment_len_padded + 4) &&\n            (iscsi_session->data_digest == ISCSI_DIGEST_AUTO)) {\n            guint32 crc;\n            /* we have enough data to test if DataDigest is enabled */\n            crc = ~crc32c_tvb_offset_calculate(tvb, data_segment_offset, data_segment_len_padded, CRC32C_PRELOAD);\n            if (crc == tvb_get_ntohl(tvb, data_segment_offset + data_segment_len_padded)) {\n                iscsi_session->data_digest = ISCSI_DIGEST_CRC32;\n            } else {\n                iscsi_session->data_digest = ISCSI_DIGEST_NONE;\n            }\n        }\n\n        /* Add data digest length to pdulen */\n        if (digestsActive && data_segment_len > 0) {\n            switch (iscsi_session->data_digest) {\n            case ISCSI_DIGEST_CRC32:\n                pduLen += 4;\n                break;\n            case ISCSI_DIGEST_NONE:\n                break;\n            case ISCSI_DIGEST_AUTO:\n                /* unknown digest, perhaps a new field was introduced? */\n                break;\n            default:\n                DISSECTOR_ASSERT_NOT_REACHED();\n            }\n        }\n\n        /*\n         * Desegmentation check.\n         */\n        if(iscsi_desegment && pinfo->can_desegment) {\n            if(pduLen > available_bytes) {\n                /*\n                 * This frame doesn't have all of the data for\n                 * this message, but we can do reassembly on it.\n                 *\n                 * Tell the TCP dissector where the data for this\n                 * message starts in the data it handed us, and\n                 * how many more bytes we need, and return.\n                 */\n                pinfo->desegment_offset = offset;\n                pinfo->desegment_len = pduLen - available_bytes;\n                return -1;\n            }\n        }\n\n        /* This is to help TCP keep track of PDU boundaries\n           and allows it to find PDUs that are not aligned to\n           the start of a TCP segments.\n           Since it also allows TCP to know what is in the middle\n           of a large PDU, it reduces the probability of a segment\n           in the middle of a large PDU transfer being misdissected as\n           a PDU.\n        */\n        if(!pinfo->fd->visited){\n            if(pduLen>(guint32)tvb_reported_length_remaining(tvb, offset)){\n                pinfo->want_pdu_tracking=2;\n                pinfo->bytes_until_next_pdu=pduLen-tvb_reported_length_remaining(tvb, offset);\n            }\n        }\n\n        if (offset == 0)\n            col_set_str(pinfo->cinfo, COL_INFO, \"\");\n        else\n            col_append_str(pinfo->cinfo, COL_INFO, \", \");\n\n        dissect_iscsi_pdu(tvb, pinfo, tree, offset, opcode, data_segment_len, iscsi_session, conversation);\n        if(pduLen > available_bytes)\n            pduLen = available_bytes;\n        offset += pduLen;\n        available_bytes -= pduLen;\n    }\n\n    return offset;\n}",
        "description": "A vulnerability in Wireshark versions 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 causes a crash in the iSCSI dissector when processing certain packets or crafted capture files. This issue can be exploited to achieve a denial of service.",
        "commit": "It was discovered that the iSCSI protocol implementation lacked proper handling of invalid opcodes within Reject messages. Specifically, the function responsible for dissecting iSCSI PDUs did not account for such cases, leading to potential crashes when encountering invalid opcodes in Reject messages. This issue has been addressed to ensure robustness against malformed inputs."
    },
    {
        "cwe": "CWE-295",
        "func_name": "gobby/inf_gtk_certificate_manager_certificate_func",
        "score": 0.7188605070114136,
        "func_before": "static void\ninf_gtk_certificate_manager_certificate_func(InfXmppConnection* connection,\n                                             gnutls_session_t session,\n                                             InfCertificateChain* chain,\n                                             gpointer user_data)\n{\n  InfGtkCertificateManager* manager;\n  InfGtkCertificateManagerPrivate* priv;\n\n  InfGtkCertificateDialogFlags flags;\n  gnutls_x509_crt_t presented_cert;\n  gnutls_x509_crt_t known_cert;\n  gchar* hostname;\n\n  gboolean match_hostname;\n  gboolean issuer_known;\n  gnutls_x509_crt_t root_cert;\n\n  int ret;\n  unsigned int verify;\n  GHashTable* table;\n  gboolean cert_equal;\n  time_t expiration_time;\n\n  InfGtkCertificateManagerQuery* query;\n  gchar* text;\n  GtkWidget* vbox;\n  GtkWidget* label;\n\n  GError* error;\n\n  manager = INF_GTK_CERTIFICATE_MANAGER(user_data);\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  g_object_get(G_OBJECT(connection), \"remote-hostname\", &hostname, NULL);\n  presented_cert = inf_certificate_chain_get_own_certificate(chain);\n\n  match_hostname = gnutls_x509_crt_check_hostname(presented_cert, hostname);\n\n  /* First, validate the certificate */\n  ret = gnutls_certificate_verify_peers2(session, &verify);\n  error = NULL;\n\n  if(ret != GNUTLS_E_SUCCESS)\n    inf_gnutls_set_error(&error, ret);\n\n  /* Remove the GNUTLS_CERT_ISSUER_NOT_KNOWN flag from the verification\n   * result, and if the certificate is still invalid, then set an error. */\n  if(error == NULL)\n  {\n    issuer_known = TRUE;\n    if(verify & GNUTLS_CERT_SIGNER_NOT_FOUND)\n    {\n      issuer_known = FALSE;\n\n      /* Re-validate the certificate for other failure reasons --\n       * unfortunately the gnutls_certificate_verify_peers2() call\n       * does not tell us whether the certificate is otherwise invalid\n       * if a signer is not found already. */\n      /* TODO: Here it would be good to use the verify flags from the\n       * certificate credentials, but GnuTLS does not have API to\n       * retrieve them. */\n      root_cert = inf_certificate_chain_get_root_certificate(chain);\n\n      ret = gnutls_x509_crt_list_verify(\n        inf_certificate_chain_get_raw(chain),\n        inf_certificate_chain_get_n_certificates(chain),\n        &root_cert,\n        1,\n        NULL,\n        0,\n        GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT,\n        &verify\n      );\n\n      if(ret != GNUTLS_E_SUCCESS)\n        inf_gnutls_set_error(&error, ret);\n      else if(verify & GNUTLS_CERT_INVALID)\n        inf_gnutls_certificate_verification_set_error(&error, verify);\n    }\n  }\n\n  /* Look up the host in our database of pinned certificates if we could not\n   * fully verify the certificate, i.e. if either the issuer is not known or\n   * the hostname of the connection does not match the certificate. */\n  table = NULL;\n  if(error == NULL)\n  {\n    known_cert = NULL;\n    if(!match_hostname || !issuer_known)\n    {\n      /* If we cannot load the known host file, then cancel the connection.\n       * Otherwise it might happen that someone shows us a certificate that we\n       * tell the user we don't know, if though actually for that host we expect\n       * a different certificate. */\n      table = inf_gtk_certificate_manager_ref_known_hosts(manager, &error);\n      if(table != NULL)\n        known_cert = g_hash_table_lookup(table, hostname);\n    }\n  }\n\n  /* Next, configure the flags for the dialog to be shown based on the\n   * verification result, and on whether the pinned certificate matches\n   * the one presented by the host or not. */\n  flags = 0;\n  if(error == NULL)\n  {\n    if(known_cert != NULL)\n    {\n      cert_equal = inf_gtk_certificate_manager_compare_fingerprint(\n        known_cert,\n        presented_cert,\n        &error\n      );\n\n      if(error == NULL && cert_equal == FALSE)\n      {\n        if(!match_hostname)\n          flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;\n        if(!issuer_known)\n          flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;\n\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_UNEXPECTED;\n        expiration_time = gnutls_x509_crt_get_expiration_time(known_cert);\n        if(expiration_time != (time_t)(-1))\n        {\n          expiration_time -= INF_GTK_CERTIFICATE_MANAGER_EXPIRATION_TOLERANCE;\n          if(time(NULL) > expiration_time)\n          {\n            flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_OLD_EXPIRED;\n          }\n        }\n      }\n    }\n    else\n    {\n      if(!match_hostname)\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;\n      if(!issuer_known)\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;\n    }\n  }\n\n  /* Now proceed either by accepting the connection, rejecting it, or\n   * bothering the user with an annoying dialog. */\n  if(error == NULL)\n  {\n    if(flags == 0)\n    {\n      if(match_hostname && issuer_known)\n      {\n        /* Remove the pinned entry if we now have a valid certificate for\n         * this host. */\n        if(table != NULL && g_hash_table_remove(table, hostname) == TRUE)\n        {\n          inf_gtk_certificate_manager_write_known_hosts_with_warning(\n            manager,\n            table\n          );\n        }\n      }\n\n      inf_xmpp_connection_certificate_verify_continue(connection);\n    }\n    else\n    {\n      query = g_slice_new(InfGtkCertificateManagerQuery);\n      query->manager = manager;\n      query->known_hosts = table;\n      query->connection = connection;\n      query->dialog = inf_gtk_certificate_dialog_new(\n        priv->parent_window,\n        0,\n        flags,\n        hostname,\n        chain\n      );\n      query->certificate_chain = chain;\n\n      table = NULL;\n\n      g_object_ref(query->connection);\n      inf_certificate_chain_ref(chain);\n\n      g_signal_connect(\n        G_OBJECT(connection),\n        \"notify::status\",\n        G_CALLBACK(inf_gtk_certificate_manager_notify_status_cb),\n        query\n      );\n\n      g_signal_connect(\n        G_OBJECT(query->dialog),\n        \"response\",\n        G_CALLBACK(inf_gtk_certificate_manager_response_cb),\n        query\n      );\n\n      gtk_dialog_add_button(\n        GTK_DIALOG(query->dialog),\n        _(\"_Cancel connection\"),\n        GTK_RESPONSE_REJECT\n      );\n\n      gtk_dialog_add_button(\n        GTK_DIALOG(query->dialog),\n        _(\"C_ontinue connection\"),\n        GTK_RESPONSE_ACCEPT\n      );\n\n      text = g_strdup_printf(\n        _(\"Do you want to continue the connection to host \\\"%s\\\"? If you \"\n          \"choose to continue, this certificate will be trusted in the \"\n          \"future when connecting to this host.\"),\n        hostname\n      );\n\n      label = gtk_label_new(text);\n      gtk_label_set_line_wrap(GTK_LABEL(label), TRUE);\n      gtk_label_set_line_wrap_mode(GTK_LABEL(label), PANGO_WRAP_WORD_CHAR);\n      gtk_label_set_max_width_chars(GTK_LABEL(label), 60);\n      gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.0);\n      gtk_widget_show(label);\n      g_free(text);\n\n      vbox = gtk_dialog_get_content_area(GTK_DIALOG(query->dialog));\n      gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 0);\n\n      priv->queries = g_slist_prepend(priv->queries, query);\n      gtk_window_present(GTK_WINDOW(query->dialog));\n    }\n  }\n  else\n  {\n    inf_xmpp_connection_certificate_verify_cancel(connection, error);\n    g_error_free(error);\n  }\n\n  if(table != NULL) g_hash_table_unref(table);\n  g_free(hostname);\n}",
        "func_after": "static void\ninf_gtk_certificate_manager_certificate_func(InfXmppConnection* connection,\n                                             gnutls_session_t session,\n                                             InfCertificateChain* chain,\n                                             gpointer user_data)\n{\n  InfGtkCertificateManager* manager;\n  InfGtkCertificateManagerPrivate* priv;\n\n  InfGtkCertificateDialogFlags flags;\n  gnutls_x509_crt_t presented_cert;\n  gnutls_x509_crt_t known_cert;\n  gchar* hostname;\n\n  gboolean match_hostname;\n  gboolean issuer_known;\n  gnutls_x509_crt_t root_cert;\n\n  int ret;\n  unsigned int verify;\n  GHashTable* table;\n  gboolean cert_equal;\n  time_t expiration_time;\n\n  InfGtkCertificateManagerQuery* query;\n  gchar* text;\n  GtkWidget* vbox;\n  GtkWidget* label;\n\n  GError* error;\n\n  manager = INF_GTK_CERTIFICATE_MANAGER(user_data);\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  g_object_get(G_OBJECT(connection), \"remote-hostname\", &hostname, NULL);\n  presented_cert = inf_certificate_chain_get_own_certificate(chain);\n\n  match_hostname = gnutls_x509_crt_check_hostname(presented_cert, hostname);\n\n  /* First, validate the certificate */\n  ret = gnutls_certificate_verify_peers2(session, &verify);\n  error = NULL;\n\n  if(ret != GNUTLS_E_SUCCESS)\n    inf_gnutls_set_error(&error, ret);\n\n  /* Remove the GNUTLS_CERT_ISSUER_NOT_KNOWN flag from the verification\n   * result, and if the certificate is still invalid, then set an error. */\n  if(error == NULL)\n  {\n    issuer_known = TRUE;\n    if(verify & GNUTLS_CERT_SIGNER_NOT_FOUND)\n    {\n      issuer_known = FALSE;\n\n      /* Re-validate the certificate for other failure reasons --\n       * unfortunately the gnutls_certificate_verify_peers2() call\n       * does not tell us whether the certificate is otherwise invalid\n       * if a signer is not found already. */\n      /* TODO: Here it would be good to use the verify flags from the\n       * certificate credentials, but GnuTLS does not have API to\n       * retrieve them. */\n      root_cert = inf_certificate_chain_get_root_certificate(chain);\n\n      ret = gnutls_x509_crt_list_verify(\n        inf_certificate_chain_get_raw(chain),\n        inf_certificate_chain_get_n_certificates(chain),\n        &root_cert,\n        1,\n        NULL,\n        0,\n        GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT,\n        &verify\n      );\n\n      if(ret != GNUTLS_E_SUCCESS)\n        inf_gnutls_set_error(&error, ret);\n    }\n\n    if(error == NULL)\n      if(verify & GNUTLS_CERT_INVALID)\n        inf_gnutls_certificate_verification_set_error(&error, verify);\n  }\n\n  /* Look up the host in our database of pinned certificates if we could not\n   * fully verify the certificate, i.e. if either the issuer is not known or\n   * the hostname of the connection does not match the certificate. */\n  table = NULL;\n  if(error == NULL)\n  {\n    known_cert = NULL;\n    if(!match_hostname || !issuer_known)\n    {\n      /* If we cannot load the known host file, then cancel the connection.\n       * Otherwise it might happen that someone shows us a certificate that we\n       * tell the user we don't know, if though actually for that host we expect\n       * a different certificate. */\n      table = inf_gtk_certificate_manager_ref_known_hosts(manager, &error);\n      if(table != NULL)\n        known_cert = g_hash_table_lookup(table, hostname);\n    }\n  }\n\n  /* Next, configure the flags for the dialog to be shown based on the\n   * verification result, and on whether the pinned certificate matches\n   * the one presented by the host or not. */\n  flags = 0;\n  if(error == NULL)\n  {\n    if(known_cert != NULL)\n    {\n      cert_equal = inf_gtk_certificate_manager_compare_fingerprint(\n        known_cert,\n        presented_cert,\n        &error\n      );\n\n      if(error == NULL && cert_equal == FALSE)\n      {\n        if(!match_hostname)\n          flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;\n        if(!issuer_known)\n          flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;\n\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_UNEXPECTED;\n        expiration_time = gnutls_x509_crt_get_expiration_time(known_cert);\n        if(expiration_time != (time_t)(-1))\n        {\n          expiration_time -= INF_GTK_CERTIFICATE_MANAGER_EXPIRATION_TOLERANCE;\n          if(time(NULL) > expiration_time)\n          {\n            flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_OLD_EXPIRED;\n          }\n        }\n      }\n    }\n    else\n    {\n      if(!match_hostname)\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;\n      if(!issuer_known)\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;\n    }\n  }\n\n  /* Now proceed either by accepting the connection, rejecting it, or\n   * bothering the user with an annoying dialog. */\n  if(error == NULL)\n  {\n    if(flags == 0)\n    {\n      if(match_hostname && issuer_known)\n      {\n        /* Remove the pinned entry if we now have a valid certificate for\n         * this host. */\n        if(table != NULL && g_hash_table_remove(table, hostname) == TRUE)\n        {\n          inf_gtk_certificate_manager_write_known_hosts_with_warning(\n            manager,\n            table\n          );\n        }\n      }\n\n      inf_xmpp_connection_certificate_verify_continue(connection);\n    }\n    else\n    {\n      query = g_slice_new(InfGtkCertificateManagerQuery);\n      query->manager = manager;\n      query->known_hosts = table;\n      query->connection = connection;\n      query->dialog = inf_gtk_certificate_dialog_new(\n        priv->parent_window,\n        0,\n        flags,\n        hostname,\n        chain\n      );\n      query->certificate_chain = chain;\n\n      table = NULL;\n\n      g_object_ref(query->connection);\n      inf_certificate_chain_ref(chain);\n\n      g_signal_connect(\n        G_OBJECT(connection),\n        \"notify::status\",\n        G_CALLBACK(inf_gtk_certificate_manager_notify_status_cb),\n        query\n      );\n\n      g_signal_connect(\n        G_OBJECT(query->dialog),\n        \"response\",\n        G_CALLBACK(inf_gtk_certificate_manager_response_cb),\n        query\n      );\n\n      gtk_dialog_add_button(\n        GTK_DIALOG(query->dialog),\n        _(\"_Cancel connection\"),\n        GTK_RESPONSE_REJECT\n      );\n\n      gtk_dialog_add_button(\n        GTK_DIALOG(query->dialog),\n        _(\"C_ontinue connection\"),\n        GTK_RESPONSE_ACCEPT\n      );\n\n      text = g_strdup_printf(\n        _(\"Do you want to continue the connection to host \\\"%s\\\"? If you \"\n          \"choose to continue, this certificate will be trusted in the \"\n          \"future when connecting to this host.\"),\n        hostname\n      );\n\n      label = gtk_label_new(text);\n      gtk_label_set_line_wrap(GTK_LABEL(label), TRUE);\n      gtk_label_set_line_wrap_mode(GTK_LABEL(label), PANGO_WRAP_WORD_CHAR);\n      gtk_label_set_max_width_chars(GTK_LABEL(label), 60);\n      gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.0);\n      gtk_widget_show(label);\n      g_free(text);\n\n      vbox = gtk_dialog_get_content_area(GTK_DIALOG(query->dialog));\n      gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 0);\n\n      priv->queries = g_slist_prepend(priv->queries, query);\n      gtk_window_present(GTK_WINDOW(query->dialog));\n    }\n  }\n  else\n  {\n    inf_xmpp_connection_certificate_verify_cancel(connection, error);\n    g_error_free(error);\n  }\n\n  if(table != NULL) g_hash_table_unref(table);\n  g_free(hostname);\n}",
        "description": "Libinfinity versions prior to 0.6.6-1 do not properly validate expired SSL certificates, enabling remote attackers to exploit this vulnerability through unknown vectors to achieve unspecified impacts.",
        "commit": "Expired certificate validation was addressed in Gobby."
    }
]