[
    {
        "cwe": "CWE-444",
        "func_name": "ohler55/listen_loop",
        "score": 0.7254841327667236,
        "func_before": "static void*\nlisten_loop(void *x) {\n    int\t\t\toptval = 1;\n    struct pollfd\tpa[100];\n    struct pollfd\t*p;\n    struct _agooErr\terr = AGOO_ERR_INIT;\n    struct sockaddr_in\tclient_addr;\n    int\t\t\tclient_sock;\n    int\t\t\tpcnt = 0;\n    socklen_t\t\talen = 0;\n    agooCon\t\tcon;\n    int\t\t\ti;\n    uint64_t\t\tcnt = 0;\n    agooBind\t\tb;\n\n    for (b = agoo_server.binds, p = pa; NULL != b; b = b->next, p++, pcnt++) {\n\tp->fd = b->fd;\n\tp->events = POLLIN;\n\tp->revents = 0;\n    }\n    memset(&client_addr, 0, sizeof(client_addr));\n    atomic_fetch_add(&agoo_server.running, 1);\n    while (agoo_server.active) {\n\tif (0 > (i = poll(pa, pcnt, 200))) {\n\t    if (EAGAIN == errno) {\n\t\tcontinue;\n\t    }\n\t    agoo_log_cat(&agoo_error_cat, \"Server polling error. %s.\", strerror(errno));\n\t    // Either a signal or something bad like out of memory. Might as well exit.\n\t    break;\n\t}\n\tif (0 == i) { // nothing to read\n\t    continue;\n\t}\n\tfor (b = agoo_server.binds, p = pa; NULL != b; b = b->next, p++) {\n\t    if (0 != (p->revents & POLLIN)) {\n\t\tif (0 > (client_sock = accept(p->fd, (struct sockaddr*)&client_addr, &alen))) {\n\t\t    agoo_log_cat(&agoo_error_cat, \"Server with pid %d accept connection failed. %s.\", getpid(), strerror(errno));\n\t\t} else if (NULL == (con = agoo_con_create(&err, client_sock, ++cnt, b))) {\n\t\t    agoo_log_cat(&agoo_error_cat, \"Server with pid %d accept connection failed. %s.\", getpid(), err.msg);\n\t\t    close(client_sock);\n\t\t    cnt--;\n\t\t    agoo_err_clear(&err);\n\t\t} else {\n\t\t    int\tcon_cnt;\n#ifdef OSX_OS\n\t\t    setsockopt(client_sock, SOL_SOCKET, SO_NOSIGPIPE, &optval, sizeof(optval));\n#endif\n#ifdef PLATFORM_LINUX\n\t\t    setsockopt(client_sock, IPPROTO_TCP, TCP_QUICKACK, &optval, sizeof(optval));\n#endif\n\t\t    fcntl(client_sock, F_SETFL, O_NONBLOCK);\n\t\t    //fcntl(client_sock, F_SETFL, FNDELAY);\n\t\t    setsockopt(client_sock, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval));\n\t\t    setsockopt(client_sock, IPPROTO_TCP, TCP_NODELAY, &optval, sizeof(optval));\n\t\t    agoo_log_cat(&agoo_con_cat, \"Server with pid %d accepted connection %llu on %s [%d]\",\n\t\t\t\t getpid(), (unsigned long long)cnt, b->id, con->sock);\n\n\t\t    con_cnt = atomic_fetch_add(&agoo_server.con_cnt, 1);\n\t\t    if (agoo_server.loop_max > agoo_server.loop_cnt && agoo_server.loop_cnt * LOOP_UP < con_cnt) {\n\t\t\tadd_con_loop();\n\t\t    }\n\t\t    agoo_queue_push(&agoo_server.con_queue, (void*)con);\n\t\t}\n\t    }\n\t    if (0 != (p->revents & (POLLERR | POLLHUP | POLLNVAL))) {\n\t\tif (0 != (p->revents & (POLLHUP | POLLNVAL))) {\n\t\t    agoo_log_cat(&agoo_error_cat, \"Agoo server with pid %d socket on %s closed.\", getpid(), b->id);\n\t\t} else {\n\t\t    agoo_log_cat(&agoo_error_cat, \"Agoo server with pid %d socket on %s error.\", getpid(), b->id);\n\t\t}\n\t\tagoo_server.active = false;\n\t    }\n\t    p->revents = 0;\n\t}\n    }\n    for (b = agoo_server.binds; NULL != b; b = b->next) {\n\tagoo_bind_close(b);\n    }\n    atomic_fetch_sub(&agoo_server.running, 1);\n\n    return NULL;\n}",
        "func_after": "static void*\nlisten_loop(void *x) {\n    int\t\t\toptval = 1;\n    struct pollfd\tpa[100];\n    struct pollfd\t*p;\n    struct _agooErr\terr = AGOO_ERR_INIT;\n    struct sockaddr_in\tclient_addr;\n    int\t\t\tclient_sock;\n    int\t\t\tpcnt = 0;\n    socklen_t\t\talen = 0;\n    agooCon\t\tcon;\n    int\t\t\ti;\n    uint64_t\t\tcnt = 0;\n    agooBind\t\tb;\n\n    for (b = agoo_server.binds, p = pa; NULL != b; b = b->next, p++, pcnt++) {\n\tp->fd = b->fd;\n\tp->events = POLLIN;\n\tp->revents = 0;\n    }\n    memset(&client_addr, 0, sizeof(client_addr));\n    atomic_fetch_add(&agoo_server.running, 1);\n    while (agoo_server.active) {\n\tif (0 > (i = poll(pa, pcnt, 200))) {\n\t    if (EAGAIN == errno) {\n\t\tcontinue;\n\t    }\n\t    agoo_log_cat(&agoo_error_cat, \"Server polling error. %s.\", strerror(errno));\n\t    // Either a signal or something bad like out of memory. Might as well exit.\n\t    break;\n\t}\n\tif (0 == i) { // nothing to read\n\t    continue;\n\t}\n\tfor (b = agoo_server.binds, p = pa; NULL != b; b = b->next, p++) {\n\t    if (0 != (p->revents & POLLIN)) {\n\t\tif (0 > (client_sock = accept(p->fd, (struct sockaddr*)&client_addr, &alen))) {\n\t\t    agoo_log_cat(&agoo_error_cat, \"Server with pid %d accept connection failed. %s.\", getpid(), strerror(errno));\n\t\t} else if (NULL == (con = agoo_con_create(&err, client_sock, ++cnt, b))) {\n\t\t    agoo_log_cat(&agoo_error_cat, \"Server with pid %d accept connection failed. %s.\", getpid(), err.msg);\n\t\t    close(client_sock);\n\t\t    cnt--;\n\t\t    agoo_err_clear(&err);\n\t\t} else {\n\t\t    int\tcon_cnt;\n#ifdef OSX_OS\n\t\t    setsockopt(client_sock, SOL_SOCKET, SO_NOSIGPIPE, &optval, sizeof(optval));\n#endif\n#ifdef PLATFORM_LINUX\n\t\t    setsockopt(client_sock, IPPROTO_TCP, TCP_QUICKACK, &optval, sizeof(optval));\n#endif\n\t\t    fcntl(client_sock, F_SETFL, O_NONBLOCK);\n\t\t    //fcntl(client_sock, F_SETFL, FNDELAY);\n\t\t    setsockopt(client_sock, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval));\n\t\t    setsockopt(client_sock, IPPROTO_TCP, TCP_NODELAY, &optval, sizeof(optval));\n\t\t    agoo_log_cat(&agoo_con_cat, \"Server with pid %d accepted connection %llu on %s [%d] from %s\",\n\t\t\t\t getpid(), (unsigned long long)cnt, b->id, con->sock, con->remote);\n\n\t\t    con_cnt = atomic_fetch_add(&agoo_server.con_cnt, 1);\n\t\t    if (agoo_server.loop_max > agoo_server.loop_cnt && agoo_server.loop_cnt * LOOP_UP < con_cnt) {\n\t\t\tadd_con_loop();\n\t\t    }\n\t\t    agoo_queue_push(&agoo_server.con_queue, (void*)con);\n\t\t}\n\t    }\n\t    if (0 != (p->revents & (POLLERR | POLLHUP | POLLNVAL))) {\n\t\tif (0 != (p->revents & (POLLHUP | POLLNVAL))) {\n\t\t    agoo_log_cat(&agoo_error_cat, \"Agoo server with pid %d socket on %s closed.\", getpid(), b->id);\n\t\t} else {\n\t\t    agoo_log_cat(&agoo_error_cat, \"Agoo server with pid %d socket on %s error.\", getpid(), b->id);\n\t\t}\n\t\tagoo_server.active = false;\n\t    }\n\t    p->revents = 0;\n\t}\n    }\n    for (b = agoo_server.binds; NULL != b; b = b->next) {\n\tagoo_bind_close(b);\n    }\n    atomic_fetch_sub(&agoo_server.running, 1);\n\n    return NULL;\n}",
        "description": "It was discovered that versions of `agoo` prior to 2.14.0 are susceptible to request smuggling attacks, particularly when used as a backend server in conjunction with a frontend proxy. These vulnerabilities arise from improper parsing of `Content-Length` and `Transfer-Encoding` headers, potentially allowing attackers to conduct HTTP request smuggling attacks through a chain of backend servers.",
        "commit": "The addition of the REMOTE_ADDR variable in the codebase indicates that there has been an enhancement to capture the remote address information. This change is ready for integration into the main codebase."
    },
    {
        "cwe": "CWE-416",
        "func_name": "torvalds/ipt_do_table",
        "score": 0.7515797019004822,
        "func_before": "unsigned int\nipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
        "func_after": "unsigned int\nipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = rcu_access_pointer(table->private);\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
        "description": "An issue was discovered in the netfilter component of the Linux kernel prior to version 5.10. This vulnerability involves a use-after-free condition in the packet processing context due to improper handling of per-CPU sequence counts during concurrent iptables rule replacements. This flaw could be exploited by users with the CAP_NET_ADMIN capability in an unprivileged namespace.",
        "commit": "When performing concurrent iptables rules replacement, the system checks the per-CPU sequence count after assigning new information. This sequence count is intended to synchronize with the packet path without using explicit locking. If packets are currently using the old table information, the sequence count is incremented to an odd value and then to an even value after processing. After assigning the new table information, a write memory barrier is executed to ensure all CPUs see the latest value. If the packet path starts with the old table information, the sequence counter remains odd, and the iptables replacement waits until the sequence count is even before freeing the old table information. However, if the CPU delays executing the new table information assignment and memory barrier, another CPU's packet path may still use the old table information. This delay can lead to a use-after-free error in the packet processing context, resulting in a kernel NULL pointer dereference. To fix this issue, either enforce instruction ordering after the new table information assignment or switch to RCU for synchronization."
    },
    {
        "cwe": "CWE-254",
        "func_name": "chromium/DecodeHSTSPreloadRaw",
        "score": 0.7378012537956238,
        "func_before": "bool DecodeHSTSPreloadRaw(const std::string& hostname,\n                          bool* out_found,\n                          PreloadResult* out) {\n  HuffmanDecoder huffman(kHSTSHuffmanTree, sizeof(kHSTSHuffmanTree));\n  BitReader reader(kPreloadedHSTSData, kPreloadedHSTSBits);\n  size_t bit_offset = kHSTSRootPosition;\n  static const char kEndOfString = 0;\n  static const char kEndOfTable = 127;\n\n  *out_found = false;\n\n  if (hostname.empty()) {\n    return true;\n  }\n  // hostname_offset contains one more than the index of the current character\n  // in the hostname that is being considered. It's one greater so that we can\n  // represent the position just before the beginning (with zero).\n  size_t hostname_offset = hostname.size();\n\n  for (;;) {\n    // Seek to the desired location.\n    if (!reader.Seek(bit_offset)) {\n      return false;\n    }\n\n    // Decode the unary length of the common prefix.\n    size_t prefix_length;\n    if (!reader.Unary(&prefix_length)) {\n      return false;\n    }\n\n    // Match each character in the prefix.\n    for (size_t i = 0; i < prefix_length; ++i) {\n      if (hostname_offset == 0) {\n        // We can't match the terminator with a prefix string.\n        return true;\n      }\n\n      char c;\n      if (!huffman.Decode(&reader, &c)) {\n        return false;\n      }\n      if (hostname[hostname_offset - 1] != c) {\n        return true;\n      }\n      hostname_offset--;\n    }\n\n    bool is_first_offset = true;\n    size_t current_offset = 0;\n\n    // Next is the dispatch table.\n    for (;;) {\n      char c;\n      if (!huffman.Decode(&reader, &c)) {\n        return false;\n      }\n      if (c == kEndOfTable) {\n        // No exact match.\n        return true;\n      }\n\n      if (c == kEndOfString) {\n        PreloadResult tmp;\n        if (!reader.Next(&tmp.sts_include_subdomains) ||\n            !reader.Next(&tmp.force_https) ||\n            !reader.Next(&tmp.has_pins)) {\n          return false;\n        }\n\n        tmp.pkp_include_subdomains = tmp.sts_include_subdomains;\n\n        if (tmp.has_pins) {\n          if (!reader.Read(4, &tmp.pinset_id) ||\n              !reader.Read(9, &tmp.domain_id) ||\n              (!tmp.sts_include_subdomains &&\n               !reader.Next(&tmp.pkp_include_subdomains))) {\n            return false;\n          }\n        }\n\n        tmp.hostname_offset = hostname_offset;\n\n        if (hostname_offset == 0 || hostname[hostname_offset - 1] == '.') {\n          *out_found =\n              tmp.sts_include_subdomains || tmp.pkp_include_subdomains;\n          *out = tmp;\n\n          if (hostname_offset > 0) {\n            out->force_https &= tmp.sts_include_subdomains;\n          } else {\n            *out_found = true;\n            return true;\n          }\n        }\n\n        continue;\n      }\n\n      // The entries in a dispatch table are in order thus we can tell if there\n      // will be no match if the current character past the one that we want.\n      if (hostname_offset == 0 || hostname[hostname_offset-1] < c) {\n        return true;\n      }\n\n      if (is_first_offset) {\n        // The first offset is backwards from the current position.\n        uint32 jump_delta_bits;\n        uint32 jump_delta;\n        if (!reader.Read(5, &jump_delta_bits) ||\n            !reader.Read(jump_delta_bits, &jump_delta)) {\n          return false;\n        }\n\n        if (bit_offset < jump_delta) {\n          return false;\n        }\n\n        current_offset = bit_offset - jump_delta;\n        is_first_offset = false;\n      } else {\n        // Subsequent offsets are forward from the target of the first offset.\n        uint32 is_long_jump;\n        if (!reader.Read(1, &is_long_jump)) {\n          return false;\n        }\n\n        uint32 jump_delta;\n        if (!is_long_jump) {\n          if (!reader.Read(7, &jump_delta)) {\n            return false;\n          }\n        } else {\n          uint32 jump_delta_bits;\n          if (!reader.Read(4, &jump_delta_bits) ||\n              !reader.Read(jump_delta_bits + 8, &jump_delta)) {\n            return false;\n          }\n        }\n\n        current_offset += jump_delta;\n        if (current_offset >= bit_offset) {\n          return false;\n        }\n      }\n\n      DCHECK_LT(0u, hostname_offset);\n      if (hostname[hostname_offset - 1] == c) {\n        bit_offset = current_offset;\n        hostname_offset--;\n        break;\n      }\n    }\n  }\n}",
        "func_after": "bool DecodeHSTSPreloadRaw(const std::string& search_hostname,\n                          bool* out_found,\n                          PreloadResult* out) {\n  HuffmanDecoder huffman(kHSTSHuffmanTree, sizeof(kHSTSHuffmanTree));\n  BitReader reader(kPreloadedHSTSData, kPreloadedHSTSBits);\n  size_t bit_offset = kHSTSRootPosition;\n  static const char kEndOfString = 0;\n  static const char kEndOfTable = 127;\n\n  *out_found = false;\n\n  // Ensure that |search_hostname| is a valid hostname before\n  // processing.\n  if (CanonicalizeHost(search_hostname).empty()) {\n    return true;\n  }\n\n  // Normalize any trailing '.' used for DNS suffix searches.\n  std::string hostname = search_hostname;\n  size_t found = hostname.find_last_not_of('.');\n  if (found != std::string::npos) {\n    hostname.erase(found + 1);\n  } else {\n    hostname.clear();\n  }\n\n  // |hostname| has already undergone IDN conversion, so should be\n  // entirely A-Labels. The preload data is entirely normalized to\n  // lower case.\n  base::StringToLowerASCII(&hostname);\n\n  if (hostname.empty()) {\n    return true;\n  }\n\n  // hostname_offset contains one more than the index of the current character\n  // in the hostname that is being considered. It's one greater so that we can\n  // represent the position just before the beginning (with zero).\n  size_t hostname_offset = hostname.size();\n\n  for (;;) {\n    // Seek to the desired location.\n    if (!reader.Seek(bit_offset)) {\n      return false;\n    }\n\n    // Decode the unary length of the common prefix.\n    size_t prefix_length;\n    if (!reader.Unary(&prefix_length)) {\n      return false;\n    }\n\n    // Match each character in the prefix.\n    for (size_t i = 0; i < prefix_length; ++i) {\n      if (hostname_offset == 0) {\n        // We can't match the terminator with a prefix string.\n        return true;\n      }\n\n      char c;\n      if (!huffman.Decode(&reader, &c)) {\n        return false;\n      }\n      if (hostname[hostname_offset - 1] != c) {\n        return true;\n      }\n      hostname_offset--;\n    }\n\n    bool is_first_offset = true;\n    size_t current_offset = 0;\n\n    // Next is the dispatch table.\n    for (;;) {\n      char c;\n      if (!huffman.Decode(&reader, &c)) {\n        return false;\n      }\n      if (c == kEndOfTable) {\n        // No exact match.\n        return true;\n      }\n\n      if (c == kEndOfString) {\n        PreloadResult tmp;\n        if (!reader.Next(&tmp.sts_include_subdomains) ||\n            !reader.Next(&tmp.force_https) ||\n            !reader.Next(&tmp.has_pins)) {\n          return false;\n        }\n\n        tmp.pkp_include_subdomains = tmp.sts_include_subdomains;\n\n        if (tmp.has_pins) {\n          if (!reader.Read(4, &tmp.pinset_id) ||\n              !reader.Read(9, &tmp.domain_id) ||\n              (!tmp.sts_include_subdomains &&\n               !reader.Next(&tmp.pkp_include_subdomains))) {\n            return false;\n          }\n        }\n\n        tmp.hostname_offset = hostname_offset;\n\n        if (hostname_offset == 0 || hostname[hostname_offset - 1] == '.') {\n          *out_found =\n              tmp.sts_include_subdomains || tmp.pkp_include_subdomains;\n          *out = tmp;\n\n          if (hostname_offset > 0) {\n            out->force_https &= tmp.sts_include_subdomains;\n          } else {\n            *out_found = true;\n            return true;\n          }\n        }\n\n        continue;\n      }\n\n      // The entries in a dispatch table are in order thus we can tell if there\n      // will be no match if the current character past the one that we want.\n      if (hostname_offset == 0 || hostname[hostname_offset-1] < c) {\n        return true;\n      }\n\n      if (is_first_offset) {\n        // The first offset is backwards from the current position.\n        uint32 jump_delta_bits;\n        uint32 jump_delta;\n        if (!reader.Read(5, &jump_delta_bits) ||\n            !reader.Read(jump_delta_bits, &jump_delta)) {\n          return false;\n        }\n\n        if (bit_offset < jump_delta) {\n          return false;\n        }\n\n        current_offset = bit_offset - jump_delta;\n        is_first_offset = false;\n      } else {\n        // Subsequent offsets are forward from the target of the first offset.\n        uint32 is_long_jump;\n        if (!reader.Read(1, &is_long_jump)) {\n          return false;\n        }\n\n        uint32 jump_delta;\n        if (!is_long_jump) {\n          if (!reader.Read(7, &jump_delta)) {\n            return false;\n          }\n        } else {\n          uint32 jump_delta_bits;\n          if (!reader.Read(4, &jump_delta_bits) ||\n              !reader.Read(jump_delta_bits + 8, &jump_delta)) {\n            return false;\n          }\n        }\n\n        current_offset += jump_delta;\n        if (current_offset >= bit_offset) {\n          return false;\n        }\n      }\n\n      DCHECK_LT(0u, hostname_offset);\n      if (hostname[hostname_offset - 1] == c) {\n        bit_offset = current_offset;\n        hostname_offset--;\n        break;\n      }\n    }\n  }\n}",
        "description": "The DecodeHSTSPreloadRaw function in Google Chrome, prior to version 43.0.2357.130, fails to properly normalize DNS hostnames before comparing them against HSTS or HPKP preload entries. This oversight enables remote attackers to circumvent intended access restrictions by utilizing strings that either conclude with a . (dot) character or contain non-lowercase characters.",
        "commit": "It was discovered that hostnames should be normalized before searching for HSTS/HPKP preloads. The HSTS/HPKP preload set is pre-normalized at construction time. Since queries originate from the GURL rather than the DNS layer, normalization of the hostname is required before scanning for preloads. Previously, this was handled by CanonicalizeHost(), which utilized the same mechanism as the resolver; however, the storage of preloads has been optimized and no longer uses the resolver-normalized form."
    },
    {
        "cwe": "CWE-22",
        "func_name": "GNOME/extract_archive_thread",
        "score": 0.7427627444267273,
        "func_before": "static void\nextract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tGHashTable           *created_files;\n\tGHashTable           *folders_created_during_extraction;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\n\tr = create_read_object (load_data, &a);\n\tif (r != ARCHIVE_OK) {\n\t\tarchive_read_free(a);\n\t\treturn;\n\t}\n\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tcreated_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, g_object_unref);\n\tfolders_created_during_extraction = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        target_offset, actual_offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\n\t\t/* honor the skip_older and overwrite options */\n\n\t\tif ((g_hash_table_lookup (folders_created_during_extraction, file) == NULL)\n\t\t    && (extract_data->skip_older || ! extract_data->overwrite))\n\t\t{\n\t\t\tGFileInfo *info;\n\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\n\t\t\t\tg_object_unref (info);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\t\t}\n\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\n\t\t/* create the file parents */\n\n\t\tparent = g_file_get_parent (file);\n\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (! _g_file_make_directory_with_parents (parent,\n\t\t\t\t\t\t\t\t   folders_created_during_extraction,\n\t\t\t\t\t\t\t\t   cancellable,\n\t\t\t\t\t\t\t\t   &local_error))\n\t\t\t{\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\telse\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\n\t\t\tif (load_data->error == NULL) {\n\t\t\t\tGFile *grandparent;\n\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\n\t\t/* create the file */\n\n\t\tfiletype = archive_entry_filetype (entry);\n\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; /* treat as a regular file to save the data */\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tif (load_data->error == NULL)\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tactual_offset = 0;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &target_offset)) == ARCHIVE_OK) {\n\t\t\t\t\tgsize bytes_written;\n\n\t\t\t\t\tif (target_offset > actual_offset) {\n\t\t\t\t\t\tif (! _g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, target_offset - actual_offset);\n\t\t\t\t\t\tactual_offset = target_offset;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! g_output_stream_write_all (ostream, buffer, buffer_size, &bytes_written, cancellable, &load_data->error))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tactual_offset += bytes_written;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, bytes_written);\n\t\t\t\t}\n\n\t\t\t\tif ((r == ARCHIVE_EOF) && (target_offset > actual_offset))\n\t\t\t\t\t_g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error);\n\n\t\t\t\t_g_object_unref (ostream);\n\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (load_data->error == NULL)\n\t\trestore_original_file_attributes (created_files, cancellable);\n\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\n\tg_hash_table_unref (folders_created_during_extraction);\n\tg_hash_table_unref (created_files);\n\tg_hash_table_unref (checked_folders);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "func_after": "static void\nextract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tGHashTable           *created_files;\n\tGHashTable           *folders_created_during_extraction;\n\tGHashTable           *external_links;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\n\tr = create_read_object (load_data, &a);\n\tif (r != ARCHIVE_OK) {\n\t\tarchive_read_free(a);\n\t\treturn;\n\t}\n\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tcreated_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, g_object_unref);\n\tfolders_created_during_extraction = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\texternal_links = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        target_offset, actual_offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (_g_path_is_external_to_destination (relative_path, extract_data->destination, external_links)) {\n\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\n\t\t/* honor the skip_older and overwrite options */\n\n\t\tif ((g_hash_table_lookup (folders_created_during_extraction, file) == NULL)\n\t\t    && (extract_data->skip_older || ! extract_data->overwrite))\n\t\t{\n\t\t\tGFileInfo *info;\n\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\n\t\t\t\tg_object_unref (info);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\t\t}\n\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\n\t\t/* create the file parents */\n\n\t\tparent = g_file_get_parent (file);\n\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (! _g_file_make_directory_with_parents (parent,\n\t\t\t\t\t\t\t\t   folders_created_during_extraction,\n\t\t\t\t\t\t\t\t   cancellable,\n\t\t\t\t\t\t\t\t   &local_error))\n\t\t\t{\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\telse\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\n\t\t\tif (load_data->error == NULL) {\n\t\t\t\tGFile *grandparent;\n\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\n\t\t/* create the file */\n\n\t\tfiletype = archive_entry_filetype (entry);\n\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; /* treat as a regular file to save the data */\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tif (load_data->error == NULL)\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tactual_offset = 0;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &target_offset)) == ARCHIVE_OK) {\n\t\t\t\t\tgsize bytes_written;\n\n\t\t\t\t\tif (target_offset > actual_offset) {\n\t\t\t\t\t\tif (! _g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, target_offset - actual_offset);\n\t\t\t\t\t\tactual_offset = target_offset;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! g_output_stream_write_all (ostream, buffer, buffer_size, &bytes_written, cancellable, &load_data->error))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tactual_offset += bytes_written;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, bytes_written);\n\t\t\t\t}\n\n\t\t\t\tif ((r == ARCHIVE_EOF) && (target_offset > actual_offset))\n\t\t\t\t\t_g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error);\n\n\t\t\t\t_g_object_unref (ostream);\n\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\telse if (_symlink_is_external_to_destination (file, archive_entry_symlink (entry), extract_data->destination, external_links))\n\t\t\t\t\tg_hash_table_insert (external_links, g_object_ref (file), GINT_TO_POINTER (1));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (load_data->error == NULL)\n\t\trestore_original_file_attributes (created_files, cancellable);\n\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\n\tg_hash_table_unref (folders_created_during_extraction);\n\tg_hash_table_unref (created_files);\n\tg_hash_table_unref (checked_folders);\n\tg_hash_table_unref (external_links);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "description": "A directory traversal vulnerability exists in File Roller versions 3.6.x before 3.6.4, 3.8.x before 3.8.3, and 3.9.x before 3.9.3 when using libarchive. This flaw allows remote attackers to create arbitrary files by exploiting improper handling of archives during a \"Keep directory structure\" action.",
        "commit": "It was discovered that filenames should be sanitized before extraction to prevent potential security vulnerabilities."
    }
]