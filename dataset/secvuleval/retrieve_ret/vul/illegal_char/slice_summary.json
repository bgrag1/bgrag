[
    {
        "cwe": "CWE-670",
        "func_name": "xen-project/port_is_valid",
        "score": 0.6687142848968506,
        "func_before": "static inline bool_t port_is_valid(struct domain *d, unsigned int p)\n{\n    return p < read_atomic(&d->valid_evtchns);\n}",
        "func_after": "static inline bool_t port_is_valid(struct domain *d, unsigned int p)\n{\n    if ( p >= read_atomic(&d->valid_evtchns) )\n        return false;\n\n    /*\n     * The caller will usually access the event channel afterwards and\n     * may be done without taking the per-domain lock. The barrier is\n     * going in pair the smp_wmb() barrier in evtchn_allocate_port().\n     */\n    smp_rmb();\n\n    return true;\n}",
        "description": "An issue was discovered in Xen through version 4.14.x, where memory barriers are absent during the access or allocation of event channels. Event channels control structures can be accessed without locks as long as the port is deemed valid. However, the absence of an appropriate memory barrier (such as smp_*mb()) allows the compiler and CPU to reorder memory accesses. This could enable a malicious guest to trigger a hypervisor crash, leading to a Denial of Service (DoS). Additionally, information leaks and privilege escalations cannot be ruled out. The vulnerability affects all versions of Xen, with the likelihood of exploitation depending on the CPU and compiler used to build Xen. The exact impact varies based on the compiler's code generation options and the CPU's ability to reorder memory accesses. It is recommended to consult the CPU vendor for guidance on potential vulnerabilities on Arm systems, while x86 systems are only vulnerable if a compiler performs reordering.",
        "commit": "It was discovered that the Xen hypervisor's event channel management lacked appropriate memory barriers during both allocation and access operations. Specifically, while the allocation of an event channel bucket is protected by a per-domain lock, accessing the bucket can occur without the lock being held, relying instead on the `port_is_valid()` function to ensure the port has an associated structure. However, due to potential compiler and processor reordering of memory accesses, there is a risk that updates to `d->valid_evtchns` could occur before the new bucket is fully allocated. To mitigate this issue, memory barriers were added: a write memory barrier during allocation and a read memory barrier when checking if the port is valid. This addresses a reordering problem that could lead to unintended behavior."
    },
    {
        "cwe": "CWE-134",
        "func_name": "wireapp/audio_level_json",
        "score": 0.7232131361961365,
        "func_before": "int audio_level_json(struct list *levell,\n\t\t     const char *userid_self, const char *clientid_self,\n\t\t     char **json_str, char **anon_str)\n{\n\tstruct json_object *jobj;\n\tstruct json_object *jarr;\n\tchar uid_anon[ANON_ID_LEN];\n\tchar cid_anon[ANON_CLIENT_LEN];\n\tstruct mbuf *pmb = NULL;\n\tint err = 0;\n\tstruct le *le;\n\n\tif (!levell || !json_str)\n\t\treturn EINVAL;\n\t\n\tjobj = jzon_alloc_object();\n\tif (!jobj)\n\t\treturn ENOMEM;\n\n\tjarr = jzon_alloc_array();\n\tif (!jarr) {\n\t\terr = ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (anon_str) {\n\t\tpmb = mbuf_alloc(512);\n\t\tmbuf_printf(pmb, \"%zu levels: \", list_count(levell));\n\t}\n\t\n\tLIST_FOREACH(levell, le) {\n\t\tstruct audio_level *a = le->data;\n\t\tstruct json_object *ja;\n\t\tconst char *userid = a->userid;\n\t\tconst char *clientid = a->clientid;\n\n\t\tif (a->is_self) {\n\t\t\tif (userid_self)\n\t\t\t\tuserid = userid_self;\n\t\t\tif (clientid_self)\n\t\t\t\tclientid = clientid_self;\n\t\t}\n\n\t\tja = jzon_alloc_object();\n\t\tif (ja) {\n\t\t\tjzon_add_str(ja, \"userid\", userid);\n\t\t\tjzon_add_str(ja, \"clientid\", clientid);\n\t\t\tjzon_add_int(ja, \"audio_level\",\n\t\t\t\t     (int32_t)a->aulevel_smooth);\n\t\t\tjzon_add_int(ja, \"audio_level_now\",\n\t\t\t\t     (int32_t)a->aulevel);\n\t\t}\n\t\tjson_object_array_add(jarr, ja);\n\n\t\t/* add to info string */\n\t\tif (pmb) {\n\t\t\tanon_id(uid_anon, userid);\n\t\t\tanon_client(cid_anon, clientid);\n\t\t\tmbuf_printf(pmb, \"{[%s.%s] audio_level: %d/%d}\",\n\t\t\t\t    uid_anon, cid_anon,\n\t\t\t\t    a->aulevel_smooth, a->aulevel);\n\t\t\tif (le != levell->tail)\n\t\t\t\tmbuf_printf(pmb, \",\");\n\t\t}\t\t\n\t}\n\tjson_object_object_add(jobj, \"audio_levels\", jarr);\n\n\tif (pmb) {\n\t\tpmb->pos = 0;\n\t\tmbuf_strdup(pmb, anon_str, pmb->end);\n\t\tmem_deref(pmb);\n\t}\n\n\tjzon_encode(json_str, jobj);\n out:\t\n\tmem_deref(jobj);\n\n\treturn err;\n}",
        "func_after": "int audio_level_json(struct list *levell,\n\t\t     const char *userid_self, const char *clientid_self,\n\t\t     char **json_str, char **anon_str)\n{\n\tstruct json_object *jobj;\n\tstruct json_object *jarr;\n\tchar uid_anon[ANON_ID_LEN];\n\tchar cid_anon[ANON_CLIENT_LEN];\n\tstruct mbuf *pmb = NULL;\n\tint err = 0;\n\tstruct le *le;\n\n\tif (!levell || !json_str)\n\t\treturn EINVAL;\n\t\n\tjobj = jzon_alloc_object();\n\tif (!jobj)\n\t\treturn ENOMEM;\n\n\tjarr = jzon_alloc_array();\n\tif (!jarr) {\n\t\terr = ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (anon_str) {\n\t\tpmb = mbuf_alloc(512);\n\t\tmbuf_printf(pmb, \"%zu levels: \", list_count(levell));\n\t}\n\t\n\tLIST_FOREACH(levell, le) {\n\t\tstruct audio_level *a = le->data;\n\t\tstruct json_object *ja;\n\t\tconst char *userid = a->userid;\n\t\tconst char *clientid = a->clientid;\n\n\t\tif (a->is_self) {\n\t\t\tif (userid_self)\n\t\t\t\tuserid = userid_self;\n\t\t\tif (clientid_self)\n\t\t\t\tclientid = clientid_self;\n\t\t}\n\n\t\tja = jzon_alloc_object();\n\t\tif (ja) {\n\t\t\tjzon_add_str(ja, \"userid\", \"%s\", userid);\n\t\t\tjzon_add_str(ja, \"clientid\", \"%s\", clientid);\n\t\t\tjzon_add_int(ja, \"audio_level\",\n\t\t\t\t     (int32_t)a->aulevel_smooth);\n\t\t\tjzon_add_int(ja, \"audio_level_now\",\n\t\t\t\t     (int32_t)a->aulevel);\n\t\t}\n\t\tjson_object_array_add(jarr, ja);\n\n\t\t/* add to info string */\n\t\tif (pmb) {\n\t\t\tanon_id(uid_anon, userid);\n\t\t\tanon_client(cid_anon, clientid);\n\t\t\tmbuf_printf(pmb, \"{[%s.%s] audio_level: %d/%d}\",\n\t\t\t\t    uid_anon, cid_anon,\n\t\t\t\t    a->aulevel_smooth, a->aulevel);\n\t\t\tif (le != levell->tail)\n\t\t\t\tmbuf_printf(pmb, \",\");\n\t\t}\t\t\n\t}\n\tjson_object_object_add(jobj, \"audio_levels\", jarr);\n\n\tif (pmb) {\n\t\tpmb->pos = 0;\n\t\tmbuf_strdup(pmb, anon_str, pmb->end);\n\t\tmem_deref(pmb);\n\t}\n\n\tjzon_encode(json_str, jobj);\n out:\t\n\tmem_deref(jobj);\n\n\treturn err;\n}",
        "description": "A remote format string vulnerability in the wire-avs component of Wire, an open-source messenger, affects versions prior to 7.1.12. This vulnerability could lead to a denial of service or the execution of arbitrary code by an attacker. The issue has been addressed in wire-avs version 7.1.12, and there are currently no known workarounds available.",
        "commit": "The process of importing the latest release-7.1 files from an old repository."
    },
    {
        "cwe": "CWE-22",
        "func_name": "GNOME/extract_archive_thread",
        "score": 0.7325097322463989,
        "func_before": "static void\nextract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tGHashTable           *created_files;\n\tGHashTable           *folders_created_during_extraction;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\n\tr = create_read_object (load_data, &a);\n\tif (r != ARCHIVE_OK) {\n\t\tarchive_read_free(a);\n\t\treturn;\n\t}\n\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tcreated_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, g_object_unref);\n\tfolders_created_during_extraction = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        target_offset, actual_offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\n\t\t/* honor the skip_older and overwrite options */\n\n\t\tif ((g_hash_table_lookup (folders_created_during_extraction, file) == NULL)\n\t\t    && (extract_data->skip_older || ! extract_data->overwrite))\n\t\t{\n\t\t\tGFileInfo *info;\n\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\n\t\t\t\tg_object_unref (info);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\t\t}\n\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\n\t\t/* create the file parents */\n\n\t\tparent = g_file_get_parent (file);\n\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (! _g_file_make_directory_with_parents (parent,\n\t\t\t\t\t\t\t\t   folders_created_during_extraction,\n\t\t\t\t\t\t\t\t   cancellable,\n\t\t\t\t\t\t\t\t   &local_error))\n\t\t\t{\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\telse\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\n\t\t\tif (load_data->error == NULL) {\n\t\t\t\tGFile *grandparent;\n\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\n\t\t/* create the file */\n\n\t\tfiletype = archive_entry_filetype (entry);\n\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; /* treat as a regular file to save the data */\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tif (load_data->error == NULL)\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tactual_offset = 0;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &target_offset)) == ARCHIVE_OK) {\n\t\t\t\t\tgsize bytes_written;\n\n\t\t\t\t\tif (target_offset > actual_offset) {\n\t\t\t\t\t\tif (! _g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, target_offset - actual_offset);\n\t\t\t\t\t\tactual_offset = target_offset;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! g_output_stream_write_all (ostream, buffer, buffer_size, &bytes_written, cancellable, &load_data->error))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tactual_offset += bytes_written;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, bytes_written);\n\t\t\t\t}\n\n\t\t\t\tif ((r == ARCHIVE_EOF) && (target_offset > actual_offset))\n\t\t\t\t\t_g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error);\n\n\t\t\t\t_g_object_unref (ostream);\n\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (load_data->error == NULL)\n\t\trestore_original_file_attributes (created_files, cancellable);\n\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\n\tg_hash_table_unref (folders_created_during_extraction);\n\tg_hash_table_unref (created_files);\n\tg_hash_table_unref (checked_folders);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "func_after": "static void\nextract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tGHashTable           *created_files;\n\tGHashTable           *folders_created_during_extraction;\n\tGHashTable           *external_links;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\n\tr = create_read_object (load_data, &a);\n\tif (r != ARCHIVE_OK) {\n\t\tarchive_read_free(a);\n\t\treturn;\n\t}\n\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tcreated_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, g_object_unref);\n\tfolders_created_during_extraction = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\texternal_links = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        target_offset, actual_offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (_g_path_is_external_to_destination (relative_path, extract_data->destination, external_links)) {\n\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\n\t\t/* honor the skip_older and overwrite options */\n\n\t\tif ((g_hash_table_lookup (folders_created_during_extraction, file) == NULL)\n\t\t    && (extract_data->skip_older || ! extract_data->overwrite))\n\t\t{\n\t\t\tGFileInfo *info;\n\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\n\t\t\t\tg_object_unref (info);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\t\t}\n\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\n\t\t/* create the file parents */\n\n\t\tparent = g_file_get_parent (file);\n\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (! _g_file_make_directory_with_parents (parent,\n\t\t\t\t\t\t\t\t   folders_created_during_extraction,\n\t\t\t\t\t\t\t\t   cancellable,\n\t\t\t\t\t\t\t\t   &local_error))\n\t\t\t{\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\telse\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\n\t\t\tif (load_data->error == NULL) {\n\t\t\t\tGFile *grandparent;\n\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\n\t\t/* create the file */\n\n\t\tfiletype = archive_entry_filetype (entry);\n\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; /* treat as a regular file to save the data */\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tif (load_data->error == NULL)\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tactual_offset = 0;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &target_offset)) == ARCHIVE_OK) {\n\t\t\t\t\tgsize bytes_written;\n\n\t\t\t\t\tif (target_offset > actual_offset) {\n\t\t\t\t\t\tif (! _g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, target_offset - actual_offset);\n\t\t\t\t\t\tactual_offset = target_offset;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! g_output_stream_write_all (ostream, buffer, buffer_size, &bytes_written, cancellable, &load_data->error))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tactual_offset += bytes_written;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, bytes_written);\n\t\t\t\t}\n\n\t\t\t\tif ((r == ARCHIVE_EOF) && (target_offset > actual_offset))\n\t\t\t\t\t_g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error);\n\n\t\t\t\t_g_object_unref (ostream);\n\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\telse if (_symlink_is_external_to_destination (file, archive_entry_symlink (entry), extract_data->destination, external_links))\n\t\t\t\t\tg_hash_table_insert (external_links, g_object_ref (file), GINT_TO_POINTER (1));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (load_data->error == NULL)\n\t\trestore_original_file_attributes (created_files, cancellable);\n\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\n\tg_hash_table_unref (folders_created_during_extraction);\n\tg_hash_table_unref (created_files);\n\tg_hash_table_unref (checked_folders);\n\tg_hash_table_unref (external_links);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "description": "A directory traversal vulnerability exists in File Roller versions 3.6.x before 3.6.4, 3.8.x before 3.8.3, and 3.9.x before 3.9.3 when using libarchive. This flaw allows remote attackers to create arbitrary files by exploiting improper handling of archives during a \"Keep directory structure\" action.",
        "commit": "It was discovered that filenames should be sanitized before extraction to prevent potential security vulnerabilities."
    },
    {
        "cwe": "CWE-116",
        "func_name": "flatpak/flatpak_builtin_info",
        "score": 0.7196044921875,
        "func_before": "gboolean\nflatpak_builtin_info (int argc, char **argv, GCancellable *cancellable, GError **error)\n{\n  g_autoptr(GOptionContext) context = NULL;\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n  g_autoptr(FlatpakDir) dir = NULL;\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autoptr(FlatpakDeploy) deploy = NULL;\n  g_autoptr(GFile) deploy_dir = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  const char *commit = NULL;\n  const char *alt_id = NULL;\n  const char *eol;\n  const char *eol_rebase;\n  const char *name;\n  const char *summary;\n  const char *version;\n  const char *license;\n  const char *pref = NULL;\n  const char *default_branch = NULL;\n  const char *origin = NULL;\n  guint64 size;\n  gboolean search_all = FALSE;\n  gboolean first = TRUE;\n  FlatpakKinds kinds;\n  const char *path;\n  g_autofree char *formatted_size = NULL;\n  gboolean friendly = TRUE;\n  g_autofree const char **subpaths = NULL;\n  int len = 0;\n  int rows, cols;\n  int width;\n\n  context = g_option_context_new (_(\"NAME [BRANCH] - Get info about an installed app or runtime\"));\n  g_option_context_set_translation_domain (context, GETTEXT_PACKAGE);\n\n  if (!flatpak_option_context_parse (context, options, &argc, &argv, FLATPAK_BUILTIN_FLAG_NO_DIR, NULL, cancellable, error))\n    return FALSE;\n\n  if (argc < 2)\n    return usage_error (context, _(\"NAME must be specified\"), error);\n  pref = argv[1];\n\n  if (argc >= 3)\n    default_branch = argv[2];\n\n  if (argc > 3)\n    return usage_error (context, _(\"Too many arguments\"), error);\n\n  kinds = FLATPAK_KINDS_APP | FLATPAK_KINDS_RUNTIME;\n\n  if (!opt_user && !opt_system && opt_installations == NULL)\n    search_all = TRUE;\n\n  dir = flatpak_find_installed_pref (pref, kinds, opt_arch, default_branch,\n                                     search_all, opt_user, opt_system, opt_installations,\n                                     &ref, cancellable, error);\n  if (dir == NULL)\n    return FALSE;\n\n  deploy_data = flatpak_dir_get_deploy_data (dir, ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);\n  if (deploy_data == NULL)\n    return FALSE;\n\n  deploy = flatpak_dir_load_deployed (dir, ref, NULL, cancellable, error);\n  if (deploy == NULL)\n    return FALSE;\n\n  commit = flatpak_deploy_data_get_commit (deploy_data);\n  alt_id = flatpak_deploy_data_get_alt_id (deploy_data);\n  origin = flatpak_deploy_data_get_origin (deploy_data);\n  size = flatpak_deploy_data_get_installed_size (deploy_data);\n  formatted_size = g_format_size (size);\n  deploy_dir = flatpak_deploy_get_dir (deploy);\n  path = flatpak_file_get_path_cached (deploy_dir);\n  subpaths = flatpak_deploy_data_get_subpaths (deploy_data);\n  eol = flatpak_deploy_data_get_eol (deploy_data);\n  eol_rebase = flatpak_deploy_data_get_eol_rebase (deploy_data);\n  name = flatpak_deploy_data_get_appdata_name (deploy_data);\n  summary = flatpak_deploy_data_get_appdata_summary (deploy_data);\n  version = flatpak_deploy_data_get_appdata_version (deploy_data);\n  license = flatpak_deploy_data_get_appdata_license (deploy_data);\n\n  metakey = flatpak_deploy_get_metadata (deploy);\n\n  if (opt_show_ref || opt_show_origin || opt_show_commit || opt_show_size || opt_show_metadata || opt_show_permissions ||\n      opt_file_access || opt_show_location || opt_show_runtime || opt_show_sdk)\n    friendly = FALSE;\n\n  if (friendly)\n    {\n      g_autoptr(GVariant) commit_v = NULL;\n      VarMetadataRef commit_metadata;\n      guint64 timestamp;\n      g_autofree char *formatted_timestamp = NULL;\n      const gchar *subject = NULL;\n      g_autofree char *parent = NULL;\n      g_autofree char *latest = NULL;\n      const char *xa_metadata = NULL;\n      const char *collection_id = NULL;\n\n      flatpak_get_window_size (&rows, &cols);\n\n      if (name)\n        {\n          if (summary)\n            print_wrapped (MIN (cols, 80), \"\\n%s - %s\\n\", name, summary);\n          else\n            print_wrapped (MIN (cols, 80), \"\\n%s\\n\", name);\n        }\n\n      latest = flatpak_dir_read_latest (dir, origin, flatpak_decomposed_get_ref (ref), NULL, NULL, NULL);\n      if (latest == NULL)\n        latest = g_strdup (_(\"ref not present in origin\"));\n\n      if (ostree_repo_load_commit (flatpak_dir_get_repo (dir), commit, &commit_v, NULL, NULL))\n        {\n          VarCommitRef var_commit = var_commit_from_gvariant (commit_v);\n\n          subject = var_commit_get_subject (var_commit);\n          parent = ostree_commit_get_parent (commit_v);\n          timestamp = ostree_commit_get_timestamp (commit_v);\n\n          formatted_timestamp = format_timestamp (timestamp);\n\n          commit_metadata = var_commit_get_metadata (var_commit);\n          xa_metadata = var_metadata_lookup_string (commit_metadata, \"xa.metadata\", NULL);\n          if (xa_metadata == NULL)\n            g_printerr (_(\"Warning: Commit has no flatpak metadata\\n\"));\n\n          collection_id = var_metadata_lookup_string (commit_metadata, \"ostree.collection-binding\", NULL);\n        }\n\n      len = 0;\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Ref:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Arch:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Branch:\"), -1));\n      if (version)\n        len = MAX (len, g_utf8_strlen (_(\"Version:\"), -1));\n      if (license)\n        len = MAX (len, g_utf8_strlen (_(\"License:\"), -1));\n      if (collection_id != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Collection:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installation:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      if (flatpak_decomposed_is_app (ref))\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Runtime:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Sdk:\"), -1));\n        }\n      if (formatted_timestamp)\n        len = MAX (len, g_utf8_strlen (_(\"Date:\"), -1));\n      if (subject)\n        len = MAX (len, g_utf8_strlen (_(\"Subject:\"), -1));\n      if (strcmp (commit, latest) != 0)\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Active commit:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Latest commit:\"), -1));\n        }\n      else\n        len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      if (parent)\n        len = MAX (len, g_utf8_strlen (_(\"Parent:\"), -1));\n      if (alt_id)\n        len = MAX (len, g_utf8_strlen (_(\"Alt-id:\"), -1));\n      if (eol)\n        len = MAX (len, g_utf8_strlen (_(\"End-of-life:\"), -1));\n      if (eol_rebase)\n        len = MAX (len, g_utf8_strlen (_(\"End-of-life-rebase:\"), -1));\n      if (subpaths[0] != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Subdirectories:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Extension:\"), -1));\n\n      width = cols - (len + 1);\n\n      print_aligned_take (len, _(\"ID:\"), flatpak_decomposed_dup_id (ref));\n      print_aligned (len, _(\"Ref:\"), flatpak_decomposed_get_ref (ref));\n      print_aligned_take (len, _(\"Arch:\"), flatpak_decomposed_dup_arch (ref));\n      print_aligned_take (len, _(\"Branch:\"), flatpak_decomposed_dup_branch (ref));\n      if (version)\n        print_aligned (len, _(\"Version:\"), version);\n      if (license)\n        print_aligned (len, _(\"License:\"), license);\n      print_aligned (len, _(\"Origin:\"), origin ? origin : \"-\");\n      if (collection_id)\n        print_aligned (len, _(\"Collection:\"), collection_id);\n      print_aligned (len, _(\"Installation:\"), flatpak_dir_get_name_cached (dir));\n      print_aligned (len, _(\"Installed:\"), formatted_size);\n      if (flatpak_decomposed_is_app (ref))\n        {\n          g_autofree char *runtime = NULL;\n          runtime = g_key_file_get_string (metakey,\n                                           FLATPAK_METADATA_GROUP_APPLICATION,\n                                           FLATPAK_METADATA_KEY_RUNTIME,\n                                           error);\n          print_aligned (len, _(\"Runtime:\"), runtime ? runtime : \"-\");\n        }\n      if (flatpak_decomposed_is_app (ref))\n        {\n          g_autofree char *sdk = NULL;\n          sdk = g_key_file_get_string (metakey,\n                                       FLATPAK_METADATA_GROUP_APPLICATION,\n                                       FLATPAK_METADATA_KEY_SDK,\n                                       error);\n          print_aligned (len, _(\"Sdk:\"), sdk ? sdk : \"-\");\n        }\n      g_print (\"\\n\");\n\n      if (strcmp (commit, latest) != 0)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (commit, width);\n          print_aligned (len, _(\"Active commit:\"), formatted_commit);\n          g_free (formatted_commit);\n          formatted_commit = ellipsize_string (latest, width);\n          print_aligned (len, _(\"Latest commit:\"), formatted_commit);\n        }\n      else\n        {\n          g_autofree char *formatted_commit = ellipsize_string (commit, width);\n          print_aligned (len, _(\"Commit:\"), formatted_commit);\n        }\n      if (parent)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (parent, width);\n          print_aligned (len, _(\"Parent:\"), formatted_commit);\n        }\n      if (subject)\n        print_aligned (len, _(\"Subject:\"), subject);\n      if (formatted_timestamp)\n        print_aligned (len, _(\"Date:\"), formatted_timestamp);\n      if (subpaths[0] != NULL)\n        {\n          g_autofree char *s = g_strjoinv (\",\", (char **) subpaths);\n          print_aligned (len, _(\"Subdirectories:\"), s);\n        }\n\n      if (alt_id)\n        print_aligned (len, _(\"Alt-id:\"), alt_id);\n      if (eol)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol, width);\n          print_aligned (len, _(\"End-of-life:\"), formatted_eol);\n        }\n      if (eol_rebase)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol_rebase, width);\n          print_aligned (len, _(\"End-of-life-rebase:\"), formatted_eol);\n        }\n    }\n  else\n    {\n      if (opt_show_ref)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", flatpak_decomposed_get_ref (ref));\n        }\n\n      if (opt_show_origin)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", origin ? origin : \"-\");\n        }\n\n      if (opt_show_commit)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", commit);\n        }\n\n      if (opt_show_size)\n        {\n          maybe_print_space (&first);\n          g_print (\"%\" G_GUINT64_FORMAT, size);\n        }\n\n      if (opt_show_location)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", path);\n        }\n\n      if (opt_show_runtime)\n        {\n          g_autofree char *runtime = NULL;\n          maybe_print_space (&first);\n\n          runtime = g_key_file_get_string (metakey,\n                                           flatpak_decomposed_get_kind_metadata_group (ref),\n                                           FLATPAK_METADATA_KEY_RUNTIME,\n                                           NULL);\n          g_print (\"%s\", runtime ? runtime : \"-\");\n        }\n\n      if (opt_show_sdk)\n        {\n          g_autofree char *sdk = NULL;\n          maybe_print_space (&first);\n\n          sdk = g_key_file_get_string (metakey,\n                                       flatpak_decomposed_get_kind_metadata_group (ref),\n                                       FLATPAK_METADATA_KEY_SDK,\n                                       NULL);\n          g_print (\"%s\", sdk ? sdk : \"-\");\n        }\n\n      if (!first)\n        g_print (\"\\n\");\n\n      if (opt_show_metadata)\n        {\n          g_autoptr(GFile) file = NULL;\n          g_autofree char *data = NULL;\n          gsize data_size;\n\n          file = g_file_get_child (deploy_dir, \"metadata\");\n\n          if (!g_file_load_contents (file, cancellable, &data, &data_size, NULL, error))\n            return FALSE;\n\n          g_print (\"%s\", data);\n        }\n\n      if (opt_show_permissions || opt_file_access)\n        {\n          g_autoptr(FlatpakContext) app_context = NULL;\n          g_autoptr(GKeyFile) keyfile = NULL;\n          g_autofree gchar *contents = NULL;\n\n          app_context = flatpak_context_load_for_deploy (deploy, error);\n          if (app_context == NULL)\n            return FALSE;\n\n          if (opt_show_permissions)\n            {\n              keyfile = g_key_file_new ();\n              flatpak_context_save_metadata (app_context, TRUE, keyfile);\n              contents = g_key_file_to_data (keyfile, NULL, error);\n              if (contents == NULL)\n                return FALSE;\n\n              g_print (\"%s\", contents);\n            }\n\n          if (opt_file_access)\n            {\n              g_autofree char *id = flatpak_decomposed_dup_id (ref);\n              g_autoptr(FlatpakExports) exports = flatpak_context_get_exports (app_context, id);\n              FlatpakFilesystemMode mode;\n\n              mode = flatpak_exports_path_get_mode (exports, opt_file_access);\n              if (mode == 0)\n                g_print (\"hidden\\n\");\n              else if (mode == FLATPAK_FILESYSTEM_MODE_READ_ONLY)\n                g_print (\"read-only\\n\");\n              else\n                g_print (\"read-write\\n\");\n            }\n        }\n    }\n\n  if (opt_show_extensions)\n    {\n      GList *extensions, *l;\n      g_autofree char *ref_arch = flatpak_decomposed_dup_arch (ref);\n      g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);\n\n      len = MAX (len, g_utf8_strlen (_(\"Extension:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Origin:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Subpaths:\"), -1));\n\n      flatpak_get_window_size (&rows, &cols);\n      width = cols - (len + 1);\n\n      extensions = flatpak_list_extensions (metakey, ref_arch, ref_branch);\n      for (l = extensions; l; l = l->next)\n        {\n          FlatpakExtension *ext = l->data;\n          g_autofree const char **ext_subpaths = NULL;\n          g_autoptr(GBytes) ext_deploy_data = NULL;\n          g_autofree char *formatted = NULL;\n          g_autofree char *ext_formatted_size = NULL;\n          g_autofree char *formatted_commit = NULL;\n\n          if (ext->is_unmaintained)\n            {\n              formatted_commit = g_strdup (_(\"unmaintained\"));\n              origin = NULL;\n              size = 0;\n              ext_formatted_size = g_strdup (_(\"unknown\"));\n              ext_subpaths = NULL;\n            }\n          else\n            {\n              ext_deploy_data = flatpak_dir_get_deploy_data (dir, ext->ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);\n              if (ext_deploy_data == NULL)\n                return FALSE;\n\n              commit = flatpak_deploy_data_get_commit (ext_deploy_data);\n              formatted_commit = ellipsize_string (commit, width);\n              origin = flatpak_deploy_data_get_origin (ext_deploy_data);\n              size = flatpak_deploy_data_get_installed_size (ext_deploy_data);\n              formatted = g_format_size (size);\n              ext_subpaths = flatpak_deploy_data_get_subpaths (ext_deploy_data);\n              if (ext_subpaths && ext_subpaths[0] && size > 0)\n                ext_formatted_size = g_strconcat (\"<\", formatted, NULL);\n              else\n                ext_formatted_size = g_steal_pointer (&formatted);\n            }\n\n          g_print (\"\\n\");\n          print_aligned (len, _(\"Extension:\"), flatpak_decomposed_get_ref (ext->ref));\n          print_aligned (len, _(\"ID:\"), ext->id);\n          print_aligned (len, _(\"Origin:\"), origin ? origin : \"-\");\n          print_aligned (len, _(\"Commit:\"), formatted_commit);\n          print_aligned (len, _(\"Installed:\"), ext_formatted_size);\n\n          if (ext_subpaths && ext_subpaths[0])\n            {\n              g_autofree char *s = g_strjoinv (\",\", (char **) ext_subpaths);\n              print_aligned (len, _(\"Subpaths:\"), s);\n            }\n        }\n\n      g_list_free_full (extensions, (GDestroyNotify) flatpak_extension_free);\n    }\n\n  return TRUE;\n}",
        "func_after": "gboolean\nflatpak_builtin_info (int argc, char **argv, GCancellable *cancellable, GError **error)\n{\n  g_autoptr(GOptionContext) context = NULL;\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n  g_autoptr(FlatpakDir) dir = NULL;\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autoptr(FlatpakDeploy) deploy = NULL;\n  g_autoptr(GFile) deploy_dir = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  const char *commit = NULL;\n  const char *alt_id = NULL;\n  const char *eol;\n  const char *eol_rebase;\n  const char *name;\n  const char *summary;\n  const char *version;\n  const char *license;\n  const char *pref = NULL;\n  const char *default_branch = NULL;\n  const char *origin = NULL;\n  guint64 size;\n  gboolean search_all = FALSE;\n  gboolean first = TRUE;\n  FlatpakKinds kinds;\n  const char *path;\n  g_autofree char *formatted_size = NULL;\n  gboolean friendly = TRUE;\n  g_autofree const char **subpaths = NULL;\n  int len = 0;\n  int rows, cols;\n  int width;\n\n  context = g_option_context_new (_(\"NAME [BRANCH] - Get info about an installed app or runtime\"));\n  g_option_context_set_translation_domain (context, GETTEXT_PACKAGE);\n\n  if (!flatpak_option_context_parse (context, options, &argc, &argv, FLATPAK_BUILTIN_FLAG_NO_DIR, NULL, cancellable, error))\n    return FALSE;\n\n  if (argc < 2)\n    return usage_error (context, _(\"NAME must be specified\"), error);\n  pref = argv[1];\n\n  if (argc >= 3)\n    default_branch = argv[2];\n\n  if (argc > 3)\n    return usage_error (context, _(\"Too many arguments\"), error);\n\n  kinds = FLATPAK_KINDS_APP | FLATPAK_KINDS_RUNTIME;\n\n  if (!opt_user && !opt_system && opt_installations == NULL)\n    search_all = TRUE;\n\n  dir = flatpak_find_installed_pref (pref, kinds, opt_arch, default_branch,\n                                     search_all, opt_user, opt_system, opt_installations,\n                                     &ref, cancellable, error);\n  if (dir == NULL)\n    return FALSE;\n\n  deploy_data = flatpak_dir_get_deploy_data (dir, ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);\n  if (deploy_data == NULL)\n    return FALSE;\n\n  deploy = flatpak_dir_load_deployed (dir, ref, NULL, cancellable, error);\n  if (deploy == NULL)\n    return FALSE;\n\n  commit = flatpak_deploy_data_get_commit (deploy_data);\n  alt_id = flatpak_deploy_data_get_alt_id (deploy_data);\n  origin = flatpak_deploy_data_get_origin (deploy_data);\n  size = flatpak_deploy_data_get_installed_size (deploy_data);\n  formatted_size = g_format_size (size);\n  deploy_dir = flatpak_deploy_get_dir (deploy);\n  path = flatpak_file_get_path_cached (deploy_dir);\n  subpaths = flatpak_deploy_data_get_subpaths (deploy_data);\n  eol = flatpak_deploy_data_get_eol (deploy_data);\n  eol_rebase = flatpak_deploy_data_get_eol_rebase (deploy_data);\n  name = flatpak_deploy_data_get_appdata_name (deploy_data);\n  summary = flatpak_deploy_data_get_appdata_summary (deploy_data);\n  version = flatpak_deploy_data_get_appdata_version (deploy_data);\n  license = flatpak_deploy_data_get_appdata_license (deploy_data);\n\n  metakey = flatpak_deploy_get_metadata (deploy);\n\n  if (opt_show_ref || opt_show_origin || opt_show_commit || opt_show_size || opt_show_metadata || opt_show_permissions ||\n      opt_file_access || opt_show_location || opt_show_runtime || opt_show_sdk)\n    friendly = FALSE;\n\n  if (friendly)\n    {\n      g_autoptr(GVariant) commit_v = NULL;\n      VarMetadataRef commit_metadata;\n      guint64 timestamp;\n      g_autofree char *formatted_timestamp = NULL;\n      const gchar *subject = NULL;\n      g_autofree char *parent = NULL;\n      g_autofree char *latest = NULL;\n      const char *xa_metadata = NULL;\n      const char *collection_id = NULL;\n\n      flatpak_get_window_size (&rows, &cols);\n\n      if (name)\n        {\n          if (summary)\n            print_wrapped (MIN (cols, 80), \"\\n%s - %s\\n\", name, summary);\n          else\n            print_wrapped (MIN (cols, 80), \"\\n%s\\n\", name);\n        }\n\n      latest = flatpak_dir_read_latest (dir, origin, flatpak_decomposed_get_ref (ref), NULL, NULL, NULL);\n      if (latest == NULL)\n        latest = g_strdup (_(\"ref not present in origin\"));\n\n      if (ostree_repo_load_commit (flatpak_dir_get_repo (dir), commit, &commit_v, NULL, NULL))\n        {\n          VarCommitRef var_commit = var_commit_from_gvariant (commit_v);\n\n          subject = var_commit_get_subject (var_commit);\n          parent = ostree_commit_get_parent (commit_v);\n          timestamp = ostree_commit_get_timestamp (commit_v);\n\n          formatted_timestamp = format_timestamp (timestamp);\n\n          commit_metadata = var_commit_get_metadata (var_commit);\n          xa_metadata = var_metadata_lookup_string (commit_metadata, \"xa.metadata\", NULL);\n          if (xa_metadata == NULL)\n            g_printerr (_(\"Warning: Commit has no flatpak metadata\\n\"));\n\n          collection_id = var_metadata_lookup_string (commit_metadata, \"ostree.collection-binding\", NULL);\n        }\n\n      len = 0;\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Ref:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Arch:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Branch:\"), -1));\n      if (version)\n        len = MAX (len, g_utf8_strlen (_(\"Version:\"), -1));\n      if (license)\n        len = MAX (len, g_utf8_strlen (_(\"License:\"), -1));\n      if (collection_id != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Collection:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installation:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      if (flatpak_decomposed_is_app (ref))\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Runtime:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Sdk:\"), -1));\n        }\n      if (formatted_timestamp)\n        len = MAX (len, g_utf8_strlen (_(\"Date:\"), -1));\n      if (subject)\n        len = MAX (len, g_utf8_strlen (_(\"Subject:\"), -1));\n      if (strcmp (commit, latest) != 0)\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Active commit:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Latest commit:\"), -1));\n        }\n      else\n        len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      if (parent)\n        len = MAX (len, g_utf8_strlen (_(\"Parent:\"), -1));\n      if (alt_id)\n        len = MAX (len, g_utf8_strlen (_(\"Alt-id:\"), -1));\n      if (eol)\n        len = MAX (len, g_utf8_strlen (_(\"End-of-life:\"), -1));\n      if (eol_rebase)\n        len = MAX (len, g_utf8_strlen (_(\"End-of-life-rebase:\"), -1));\n      if (subpaths[0] != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Subdirectories:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Extension:\"), -1));\n\n      width = cols - (len + 1);\n\n      print_aligned_take (len, _(\"ID:\"), flatpak_decomposed_dup_id (ref));\n      print_aligned (len, _(\"Ref:\"), flatpak_decomposed_get_ref (ref));\n      print_aligned_take (len, _(\"Arch:\"), flatpak_decomposed_dup_arch (ref));\n      print_aligned_take (len, _(\"Branch:\"), flatpak_decomposed_dup_branch (ref));\n      if (version)\n        print_aligned (len, _(\"Version:\"), version);\n      if (license)\n        print_aligned (len, _(\"License:\"), license);\n      print_aligned (len, _(\"Origin:\"), origin ? origin : \"-\");\n      if (collection_id)\n        print_aligned (len, _(\"Collection:\"), collection_id);\n      print_aligned (len, _(\"Installation:\"), flatpak_dir_get_name_cached (dir));\n      print_aligned (len, _(\"Installed:\"), formatted_size);\n      if (flatpak_decomposed_is_app (ref))\n        {\n          g_autofree char *runtime = NULL;\n          runtime = g_key_file_get_string (metakey,\n                                           FLATPAK_METADATA_GROUP_APPLICATION,\n                                           FLATPAK_METADATA_KEY_RUNTIME,\n                                           error);\n          print_aligned (len, _(\"Runtime:\"), runtime ? runtime : \"-\");\n        }\n      if (flatpak_decomposed_is_app (ref))\n        {\n          g_autofree char *sdk = NULL;\n          sdk = g_key_file_get_string (metakey,\n                                       FLATPAK_METADATA_GROUP_APPLICATION,\n                                       FLATPAK_METADATA_KEY_SDK,\n                                       error);\n          print_aligned (len, _(\"Sdk:\"), sdk ? sdk : \"-\");\n        }\n      g_print (\"\\n\");\n\n      if (strcmp (commit, latest) != 0)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (commit, width);\n          print_aligned (len, _(\"Active commit:\"), formatted_commit);\n          g_free (formatted_commit);\n          formatted_commit = ellipsize_string (latest, width);\n          print_aligned (len, _(\"Latest commit:\"), formatted_commit);\n        }\n      else\n        {\n          g_autofree char *formatted_commit = ellipsize_string (commit, width);\n          print_aligned (len, _(\"Commit:\"), formatted_commit);\n        }\n      if (parent)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (parent, width);\n          print_aligned (len, _(\"Parent:\"), formatted_commit);\n        }\n      if (subject)\n        print_aligned (len, _(\"Subject:\"), subject);\n      if (formatted_timestamp)\n        print_aligned (len, _(\"Date:\"), formatted_timestamp);\n      if (subpaths[0] != NULL)\n        {\n          g_autofree char *s = g_strjoinv (\",\", (char **) subpaths);\n          print_aligned (len, _(\"Subdirectories:\"), s);\n        }\n\n      if (alt_id)\n        print_aligned (len, _(\"Alt-id:\"), alt_id);\n      if (eol)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol, width);\n          print_aligned (len, _(\"End-of-life:\"), formatted_eol);\n        }\n      if (eol_rebase)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol_rebase, width);\n          print_aligned (len, _(\"End-of-life-rebase:\"), formatted_eol);\n        }\n    }\n  else\n    {\n      if (opt_show_ref)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", flatpak_decomposed_get_ref (ref));\n        }\n\n      if (opt_show_origin)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", origin ? origin : \"-\");\n        }\n\n      if (opt_show_commit)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", commit);\n        }\n\n      if (opt_show_size)\n        {\n          maybe_print_space (&first);\n          g_print (\"%\" G_GUINT64_FORMAT, size);\n        }\n\n      if (opt_show_location)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", path);\n        }\n\n      if (opt_show_runtime)\n        {\n          g_autofree char *runtime = NULL;\n          maybe_print_space (&first);\n\n          runtime = g_key_file_get_string (metakey,\n                                           flatpak_decomposed_get_kind_metadata_group (ref),\n                                           FLATPAK_METADATA_KEY_RUNTIME,\n                                           NULL);\n          g_print (\"%s\", runtime ? runtime : \"-\");\n        }\n\n      if (opt_show_sdk)\n        {\n          g_autofree char *sdk = NULL;\n          maybe_print_space (&first);\n\n          sdk = g_key_file_get_string (metakey,\n                                       flatpak_decomposed_get_kind_metadata_group (ref),\n                                       FLATPAK_METADATA_KEY_SDK,\n                                       NULL);\n          g_print (\"%s\", sdk ? sdk : \"-\");\n        }\n\n      if (!first)\n        g_print (\"\\n\");\n\n      if (opt_show_metadata)\n        {\n          g_autoptr(GFile) file = NULL;\n          g_autofree char *data = NULL;\n          gsize data_size;\n\n          file = g_file_get_child (deploy_dir, \"metadata\");\n\n          if (!g_file_load_contents (file, cancellable, &data, &data_size, NULL, error))\n            return FALSE;\n\n          flatpak_print_escaped_string (data,\n                                        FLATPAK_ESCAPE_ALLOW_NEWLINES\n                                        | FLATPAK_ESCAPE_DO_NOT_QUOTE);\n        }\n\n      if (opt_show_permissions || opt_file_access)\n        {\n          g_autoptr(FlatpakContext) app_context = NULL;\n          g_autoptr(GKeyFile) keyfile = NULL;\n          g_autofree gchar *contents = NULL;\n\n          app_context = flatpak_context_load_for_deploy (deploy, error);\n          if (app_context == NULL)\n            return FALSE;\n\n          if (opt_show_permissions)\n            {\n              keyfile = g_key_file_new ();\n              flatpak_context_save_metadata (app_context, TRUE, keyfile);\n              contents = g_key_file_to_data (keyfile, NULL, error);\n              if (contents == NULL)\n                return FALSE;\n\n              flatpak_print_escaped_string (contents,\n                                            FLATPAK_ESCAPE_ALLOW_NEWLINES\n                                            | FLATPAK_ESCAPE_DO_NOT_QUOTE);\n            }\n\n          if (opt_file_access)\n            {\n              g_autofree char *id = flatpak_decomposed_dup_id (ref);\n              g_autoptr(FlatpakExports) exports = flatpak_context_get_exports (app_context, id);\n              FlatpakFilesystemMode mode;\n\n              mode = flatpak_exports_path_get_mode (exports, opt_file_access);\n              if (mode == 0)\n                g_print (\"hidden\\n\");\n              else if (mode == FLATPAK_FILESYSTEM_MODE_READ_ONLY)\n                g_print (\"read-only\\n\");\n              else\n                g_print (\"read-write\\n\");\n            }\n        }\n    }\n\n  if (opt_show_extensions)\n    {\n      GList *extensions, *l;\n      g_autofree char *ref_arch = flatpak_decomposed_dup_arch (ref);\n      g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);\n\n      len = MAX (len, g_utf8_strlen (_(\"Extension:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Origin:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Subpaths:\"), -1));\n\n      flatpak_get_window_size (&rows, &cols);\n      width = cols - (len + 1);\n\n      extensions = flatpak_list_extensions (metakey, ref_arch, ref_branch);\n      for (l = extensions; l; l = l->next)\n        {\n          FlatpakExtension *ext = l->data;\n          g_autofree const char **ext_subpaths = NULL;\n          g_autoptr(GBytes) ext_deploy_data = NULL;\n          g_autofree char *formatted = NULL;\n          g_autofree char *ext_formatted_size = NULL;\n          g_autofree char *formatted_commit = NULL;\n\n          if (ext->is_unmaintained)\n            {\n              formatted_commit = g_strdup (_(\"unmaintained\"));\n              origin = NULL;\n              size = 0;\n              ext_formatted_size = g_strdup (_(\"unknown\"));\n              ext_subpaths = NULL;\n            }\n          else\n            {\n              ext_deploy_data = flatpak_dir_get_deploy_data (dir, ext->ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);\n              if (ext_deploy_data == NULL)\n                return FALSE;\n\n              commit = flatpak_deploy_data_get_commit (ext_deploy_data);\n              formatted_commit = ellipsize_string (commit, width);\n              origin = flatpak_deploy_data_get_origin (ext_deploy_data);\n              size = flatpak_deploy_data_get_installed_size (ext_deploy_data);\n              formatted = g_format_size (size);\n              ext_subpaths = flatpak_deploy_data_get_subpaths (ext_deploy_data);\n              if (ext_subpaths && ext_subpaths[0] && size > 0)\n                ext_formatted_size = g_strconcat (\"<\", formatted, NULL);\n              else\n                ext_formatted_size = g_steal_pointer (&formatted);\n            }\n\n          g_print (\"\\n\");\n          print_aligned (len, _(\"Extension:\"), flatpak_decomposed_get_ref (ext->ref));\n          print_aligned (len, _(\"ID:\"), ext->id);\n          print_aligned (len, _(\"Origin:\"), origin ? origin : \"-\");\n          print_aligned (len, _(\"Commit:\"), formatted_commit);\n          print_aligned (len, _(\"Installed:\"), ext_formatted_size);\n\n          if (ext_subpaths && ext_subpaths[0])\n            {\n              g_autofree char *s = g_strjoinv (\",\", (char **) ext_subpaths);\n              print_aligned (len, _(\"Subpaths:\"), s);\n            }\n        }\n\n      g_list_free_full (extensions, (GDestroyNotify) flatpak_extension_free);\n    }\n\n  return TRUE;\n}",
        "description": "In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, Flatpak allowed attackers to publish applications with elevated permissions while hiding these permissions from users through the `flatpak(1)` command-line interface. This was achieved by setting other permissions to crafted values containing non-printable control characters such as `ESC`. A fix is available in the mentioned versions. As a workaround, users are advised to use a graphical user interface like GNOME Software instead of the command-line interface, or to only install applications from trusted maintainers.",
        "commit": "It is important to escape special characters in permissions and metadata to prevent manipulation of the permissions list's appearance."
    },
    {
        "cwe": "CWE-611",
        "func_name": "UIKit0/plist_from_xml",
        "score": 0.6831129789352417,
        "func_before": "PLIST_API void plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)\n{\n    xmlDocPtr plist_doc = xmlParseMemory(plist_xml, length);\n    xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n\n    xml_to_node(root_node, plist);\n    xmlFreeDoc(plist_doc);\n}",
        "func_after": "PLIST_API void plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)\n{\n    /* CVE-2013-0339: disable external entity loading to prevent XXE vulnerability */\n    xmlSetExternalEntityLoader(plist_xml_external_entity_loader);\n\n    /* read XML from memory and disable network access for security reasons */\n    xmlDocPtr plist_doc = xmlReadMemory(plist_xml, length, \"plist_from_xml:memory\", NULL, XML_PARSE_NONET);\n    if (plist_doc) {\n        xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n\n        xml_to_node(root_node, plist);\n        xmlFreeDoc(plist_doc);\n    }\n}",
        "description": "A vulnerability has been identified in the UIKit0 libplist library version 1.12, affecting the plist_from_xml function within the XML Handler component. This issue involves improper handling of XML external entity references, which could lead to potential security risks. To address this, a patch with the identifier c086cb139af7c82845f6d565e636073ff4b37440 has been developed. It is advised to apply this patch to mitigate the vulnerability.",
        "commit": "A security vulnerability related to XML property lists (plists) has been identified, where an attacker could potentially exploit a limited but possible XML External Entity (XXE) flaw. This vulnerability arises from the use of a specially crafted XML file that leverages a custom Document Type Definition (DTD) with an external entity reference. Such a file, when processed by the plistutil tool, could facilitate unauthorized GET requests to arbitrary URLs or disclose local files. Although practical exploitation is constrained, the issue has been addressed to enhance security. This vulnerability is analogous to CVE-2013-0339 observed in libxml2 and aligns with CWE-827. The vulnerability was reported by Lo\u00efc B\u00e9nis from calypt.com."
    }
]