[
    {
        "cwe": "CWE-787",
        "func_name": "OP-TEE/syscall_obj_generate_key",
        "score": 0.8095554113388062,
        "func_before": "TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that maxKeySize follows restrictions */\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tparams = malloc(sizeof(TEE_Attribute) * param_count);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * We have to do it like this because the parity bits aren't\n\t\t * counted when telling the size of the key in bits.\n\t\t */\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}",
        "func_after": "TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that maxKeySize follows restrictions */\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * We have to do it like this because the parity bits aren't\n\t\t * counted when telling the size of the key in bits.\n\t\t */\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}",
        "description": "Linaro/OP-TEE versions 3.3.0 and earlier are vulnerable to a buffer overflow, which could lead to the execution of arbitrary code within the Trusted Execution Environment (TEE) core (kernel) context. This issue affects the optee_os component. The vulnerability has been addressed in versions 3.4.0 and later.",
        "commit": "It was discovered that there is a risk of heap-based overflow due to insufficient checking for allocation overflow in cryptographic function calls. Without verifying the allocation size, there is a possibility of allocating a buffer that is smaller than expected, which could result in attacker-controlled data being written beyond the buffer's boundaries."
    },
    {
        "cwe": "CWE-131",
        "func_name": "the-tcpdump-group/daemon_msg_findallif_req",
        "score": 0.8062403202056885,
        "func_before": "static int\ndaemon_msg_findallif_req(uint8 ver, struct daemon_slpars *pars, uint32 plen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tpcap_if_t *alldevs = NULL;\t\t// pointer to the header of the interface chain\n\tpcap_if_t *d;\t\t\t\t// temp pointer needed to scan the interface chain\n\tstruct pcap_addr *address;\t\t// pcap structure that keeps a network address of an interface\n\tstruct rpcap_findalldevs_if *findalldevs_if;// rpcap structure that packet all the data of an interface together\n\tuint16 nif = 0;\t\t\t\t// counts the number of interface listed\n\n\t// Discard the rest of the message; there shouldn't be any payload.\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\t// Network error.\n\t\treturn -1;\n\t}\n\n\t// Retrieve the device list\n\tif (pcap_findalldevs(&alldevs, errmsgbuf) == -1)\n\t\tgoto error;\n\n\tif (alldevs == NULL)\n\t{\n\t\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_NOREMOTEIF,\n\t\t\t\"No interfaces found! Make sure libpcap/WinPcap is properly installed\"\n\t\t\t\" and you have the right to access to the remote device.\",\n\t\t\terrbuf) == -1)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// checks the number of interfaces and it computes the total length of the payload\n\tfor (d = alldevs; d != NULL; d = d->next)\n\t{\n\t\tnif++;\n\n\t\tif (d->description)\n\t\t\tplen+= strlen(d->description);\n\t\tif (d->name)\n\t\t\tplen+= strlen(d->name);\n\n\t\tplen+= sizeof(struct rpcap_findalldevs_if);\n\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tplen+= (sizeof(struct rpcap_sockaddr) * 4);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// RPCAP findalldevs command\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf,\n\t    PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_FINDALLIF_REPLY, nif, plen);\n\n\t// send the interface list\n\tfor (d = alldevs; d != NULL; d = d->next)\n\t{\n\t\tuint16 lname, ldescr;\n\n\t\tfindalldevs_if = (struct rpcap_findalldevs_if *) &sendbuf[sendbufidx];\n\n\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_findalldevs_if), NULL,\n\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tmemset(findalldevs_if, 0, sizeof(struct rpcap_findalldevs_if));\n\n\t\tif (d->description) ldescr = (short) strlen(d->description);\n\t\telse ldescr = 0;\n\t\tif (d->name) lname = (short) strlen(d->name);\n\t\telse lname = 0;\n\n\t\tfindalldevs_if->desclen = htons(ldescr);\n\t\tfindalldevs_if->namelen = htons(lname);\n\t\tfindalldevs_if->flags = htonl(d->flags);\n\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tfindalldevs_if->naddr++;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfindalldevs_if->naddr = htons(findalldevs_if->naddr);\n\n\t\tif (sock_bufferize(d->name, lname, sendbuf, &sendbufidx,\n\t\t    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tif (sock_bufferize(d->description, ldescr, sendbuf, &sendbufidx,\n\t\t    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\t// send all addresses\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\tstruct rpcap_sockaddr *sockaddr;\n\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->addr, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->netmask, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->broadaddr, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->dstaddr, sockaddr);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// We no longer need the device list. Free it.\n\tpcap_freealldevs(alldevs);\n\n\t// Send a final command that says \"now send it!\"\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\tif (alldevs)\n\t\tpcap_freealldevs(alldevs);\n\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_FINDALLIF,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "func_after": "static int\ndaemon_msg_findallif_req(uint8 ver, struct daemon_slpars *pars, uint32 plen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tpcap_if_t *alldevs = NULL;\t\t// pointer to the header of the interface chain\n\tpcap_if_t *d;\t\t\t\t// temp pointer needed to scan the interface chain\n\tstruct pcap_addr *address;\t\t// pcap structure that keeps a network address of an interface\n\tstruct rpcap_findalldevs_if *findalldevs_if;// rpcap structure that packet all the data of an interface together\n\tuint32 replylen;\t\t\t// length of reply payload\n\tuint16 nif = 0;\t\t\t\t// counts the number of interface listed\n\n\t// Discard the rest of the message; there shouldn't be any payload.\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\t// Network error.\n\t\treturn -1;\n\t}\n\n\t// Retrieve the device list\n\tif (pcap_findalldevs(&alldevs, errmsgbuf) == -1)\n\t\tgoto error;\n\n\tif (alldevs == NULL)\n\t{\n\t\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_NOREMOTEIF,\n\t\t\t\"No interfaces found! Make sure libpcap/WinPcap is properly installed\"\n\t\t\t\" and you have the right to access to the remote device.\",\n\t\t\terrbuf) == -1)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// This checks the number of interfaces and computes the total\n\t// length of the payload.\n\treplylen = 0;\n\tfor (d = alldevs; d != NULL; d = d->next)\n\t{\n\t\tnif++;\n\n\t\tif (d->description)\n\t\t\treplylen += strlen(d->description);\n\t\tif (d->name)\n\t\t\treplylen += strlen(d->name);\n\n\t\treplylen += sizeof(struct rpcap_findalldevs_if);\n\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\treplylen += (sizeof(struct rpcap_sockaddr) * 4);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// RPCAP findalldevs command\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf,\n\t    PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_FINDALLIF_REPLY, nif, replylen);\n\n\t// send the interface list\n\tfor (d = alldevs; d != NULL; d = d->next)\n\t{\n\t\tuint16 lname, ldescr;\n\n\t\tfindalldevs_if = (struct rpcap_findalldevs_if *) &sendbuf[sendbufidx];\n\n\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_findalldevs_if), NULL,\n\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tmemset(findalldevs_if, 0, sizeof(struct rpcap_findalldevs_if));\n\n\t\tif (d->description) ldescr = (short) strlen(d->description);\n\t\telse ldescr = 0;\n\t\tif (d->name) lname = (short) strlen(d->name);\n\t\telse lname = 0;\n\n\t\tfindalldevs_if->desclen = htons(ldescr);\n\t\tfindalldevs_if->namelen = htons(lname);\n\t\tfindalldevs_if->flags = htonl(d->flags);\n\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tfindalldevs_if->naddr++;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfindalldevs_if->naddr = htons(findalldevs_if->naddr);\n\n\t\tif (sock_bufferize(d->name, lname, sendbuf, &sendbufidx,\n\t\t    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tif (sock_bufferize(d->description, ldescr, sendbuf, &sendbufidx,\n\t\t    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\t// send all addresses\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\tstruct rpcap_sockaddr *sockaddr;\n\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->addr, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->netmask, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->broadaddr, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->dstaddr, sockaddr);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// We no longer need the device list. Free it.\n\tpcap_freealldevs(alldevs);\n\n\t// Send a final command that says \"now send it!\"\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\tif (alldevs)\n\t\tpcap_freealldevs(alldevs);\n\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_FINDALLIF,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "description": "rpcapd/daemon.c in libpcap before 1.9.1 improperly handles certain length values due to the reuse of a variable, potentially exposing an attack vector that involves additional data appended to the end of a request.",
        "commit": "Using the same local variable to calculate both the remaining request length and the reply payload length can lead to confusion and potential errors, especially if the request contains additional data at the end. This practice can result in incorrect handling of packet capture operations, posing a security risk."
    },
    {
        "cwe": "CWE-415",
        "func_name": "binutils-gdb/get_num_dynamic_syms",
        "score": 0.7965371608734131,
        "func_before": "static unsigned long\nget_num_dynamic_syms (Filedata * filedata)\n{\n  unsigned long num_of_syms = 0;\n\n  if (!do_histogram && (!do_using_dynamic || do_dyn_syms))\n    return num_of_syms;\n\n  if (dynamic_info[DT_HASH])\n    {\n      unsigned char nb[8];\n      unsigned char nc[8];\n      unsigned int hash_ent_size = 4;\n\n      if ((filedata->file_header.e_machine == EM_ALPHA\n\t   || filedata->file_header.e_machine == EM_S390\n\t   || filedata->file_header.e_machine == EM_S390_OLD)\n\t  && filedata->file_header.e_ident[EI_CLASS] == ELFCLASS64)\n\thash_ent_size = 8;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, dynamic_info[DT_HASH],\n\t\t\t\t     sizeof nb + sizeof nc)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  goto no_hash;\n\t}\n\n      if (fread (nb, hash_ent_size, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of buckets\\n\"));\n\t  goto no_hash;\n\t}\n\n      if (fread (nc, hash_ent_size, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of chains\\n\"));\n\t  goto no_hash;\n\t}\n\n      nbuckets = byte_get (nb, hash_ent_size);\n      nchains = byte_get (nc, hash_ent_size);\n      num_of_syms = nchains;\n\n      buckets = get_dynamic_data (filedata, nbuckets, hash_ent_size);\n      chains  = get_dynamic_data (filedata, nchains, hash_ent_size);\n\n  no_hash:\n      if (num_of_syms == 0)\n\t{\n\t  if (buckets)\n\t    {\n\t      free (buckets);\n\t      buckets = NULL;\n\t    }\n\t  if (chains)\n\t    {\n\t      free (chains);\n\t      buckets = NULL;\n\t    }\n\t  nbuckets = 0;\n\t}\n    }\n\n  if (dynamic_info_DT_GNU_HASH)\n    {\n      unsigned char nb[16];\n      bfd_vma i, maxchain = 0xffffffff, bitmaskwords;\n      bfd_vma buckets_vma;\n      unsigned long hn;\n      bfd_boolean gnu_hash_error = FALSE;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, dynamic_info_DT_GNU_HASH,\n\t\t\t\t     sizeof nb)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      if (fread (nb, 16, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of buckets\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      ngnubuckets = byte_get (nb, 4);\n      gnusymidx = byte_get (nb + 4, 4);\n      bitmaskwords = byte_get (nb + 8, 4);\n      buckets_vma = dynamic_info_DT_GNU_HASH + 16;\n      if (is_32bit_elf)\n\tbuckets_vma += bitmaskwords * 4;\n      else\n\tbuckets_vma += bitmaskwords * 8;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma, 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      gnubuckets = get_dynamic_data (filedata, ngnubuckets, 4);\n\n      if (gnubuckets == NULL)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      for (i = 0; i < ngnubuckets; i++)\n\tif (gnubuckets[i] != 0)\n\t  {\n\t    if (gnubuckets[i] < gnusymidx)\n\t      {\n\t\tgnu_hash_error = TRUE;\n\t\treturn FALSE;\n\t      }\n\n\t    if (maxchain == 0xffffffff || gnubuckets[i] > maxchain)\n\t      maxchain = gnubuckets[i];\n\t  }\n\n      if (maxchain == 0xffffffff)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      maxchain -= gnusymidx;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma\n\t\t\t\t\t   + 4 * (ngnubuckets + maxchain), 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      do\n\t{\n\t  if (fread (nb, 4, 1, filedata->handle) != 1)\n\t    {\n\t      error (_(\"Failed to determine last chain length\\n\"));\n\t  gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  if (maxchain + 1 == 0)\n\t    {\n\t      gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  ++maxchain;\n\t}\n      while ((byte_get (nb, 4) & 1) == 0);\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma + 4 * ngnubuckets, 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      gnuchains = get_dynamic_data (filedata, maxchain, 4);\n      ngnuchains = maxchain;\n\n      if (gnuchains == NULL)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      if (dynamic_info_DT_MIPS_XHASH)\n\t{\n\t  if (fseek (filedata->handle,\n\t\t     (archive_file_offset\n\t\t      + offset_from_vma (filedata, (buckets_vma\n\t\t\t\t\t\t    + 4 * (ngnubuckets\n\t\t\t\t\t\t\t   + maxchain)), 4)),\n\t\t     SEEK_SET))\n\t    {\n\t      error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t      gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  mipsxlat = get_dynamic_data (filedata, maxchain, 4);\n\t}\n\n      for (hn = 0; hn < ngnubuckets; ++hn)\n\tif (gnubuckets[hn] != 0)\n\t  {\n\t    bfd_vma si = gnubuckets[hn];\n\t    bfd_vma off = si - gnusymidx;\n\n\t    do\n\t      {\n\t\tif (dynamic_info_DT_MIPS_XHASH)\n\t\t  {\n\t\t    if (mipsxlat[off] >= num_of_syms)\n\t\t      num_of_syms = mipsxlat[off] + 1;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    if (si >= num_of_syms)\n\t\t      num_of_syms = si + 1;\n\t\t  }\n\t\tsi++;\n\t      }\n\t    while (off < ngnuchains && (gnuchains[off++] & 1) == 0);\n\t  }\n\n  no_gnu_hash:\n      if (gnu_hash_error)\n\t{\n\t  if (mipsxlat)\n\t    {\n\t      free (mipsxlat);\n\t      mipsxlat = NULL;\n\t    }\n\t  if (gnuchains)\n\t    {\n\t      free (gnuchains);\n\t      gnuchains = NULL;\n\t    }\n\t  if (gnubuckets)\n\t    {\n\t      free (gnubuckets);\n\t      gnubuckets = NULL;\n\t    }\n\t  ngnubuckets = 0;\n\t  ngnuchains = 0;\n\t}\n    }\n\n  return num_of_syms;\n}",
        "func_after": "static unsigned long\nget_num_dynamic_syms (Filedata * filedata)\n{\n  unsigned long num_of_syms = 0;\n\n  if (!do_histogram && (!do_using_dynamic || do_dyn_syms))\n    return num_of_syms;\n\n  if (dynamic_info[DT_HASH])\n    {\n      unsigned char nb[8];\n      unsigned char nc[8];\n      unsigned int hash_ent_size = 4;\n\n      if ((filedata->file_header.e_machine == EM_ALPHA\n\t   || filedata->file_header.e_machine == EM_S390\n\t   || filedata->file_header.e_machine == EM_S390_OLD)\n\t  && filedata->file_header.e_ident[EI_CLASS] == ELFCLASS64)\n\thash_ent_size = 8;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, dynamic_info[DT_HASH],\n\t\t\t\t     sizeof nb + sizeof nc)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  goto no_hash;\n\t}\n\n      if (fread (nb, hash_ent_size, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of buckets\\n\"));\n\t  goto no_hash;\n\t}\n\n      if (fread (nc, hash_ent_size, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of chains\\n\"));\n\t  goto no_hash;\n\t}\n\n      nbuckets = byte_get (nb, hash_ent_size);\n      nchains = byte_get (nc, hash_ent_size);\n      num_of_syms = nchains;\n\n      buckets = get_dynamic_data (filedata, nbuckets, hash_ent_size);\n      chains  = get_dynamic_data (filedata, nchains, hash_ent_size);\n\n  no_hash:\n      if (num_of_syms == 0)\n\t{\n\t  if (buckets)\n\t    {\n\t      free (buckets);\n\t      buckets = NULL;\n\t    }\n\t  if (chains)\n\t    {\n\t      free (chains);\n\t      chains = NULL;\n\t    }\n\t  nbuckets = 0;\n\t}\n    }\n\n  if (dynamic_info_DT_GNU_HASH)\n    {\n      unsigned char nb[16];\n      bfd_vma i, maxchain = 0xffffffff, bitmaskwords;\n      bfd_vma buckets_vma;\n      unsigned long hn;\n      bfd_boolean gnu_hash_error = FALSE;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, dynamic_info_DT_GNU_HASH,\n\t\t\t\t     sizeof nb)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      if (fread (nb, 16, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of buckets\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      ngnubuckets = byte_get (nb, 4);\n      gnusymidx = byte_get (nb + 4, 4);\n      bitmaskwords = byte_get (nb + 8, 4);\n      buckets_vma = dynamic_info_DT_GNU_HASH + 16;\n      if (is_32bit_elf)\n\tbuckets_vma += bitmaskwords * 4;\n      else\n\tbuckets_vma += bitmaskwords * 8;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma, 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      gnubuckets = get_dynamic_data (filedata, ngnubuckets, 4);\n\n      if (gnubuckets == NULL)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      for (i = 0; i < ngnubuckets; i++)\n\tif (gnubuckets[i] != 0)\n\t  {\n\t    if (gnubuckets[i] < gnusymidx)\n\t      {\n\t\tgnu_hash_error = TRUE;\n\t\treturn FALSE;\n\t      }\n\n\t    if (maxchain == 0xffffffff || gnubuckets[i] > maxchain)\n\t      maxchain = gnubuckets[i];\n\t  }\n\n      if (maxchain == 0xffffffff)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      maxchain -= gnusymidx;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma\n\t\t\t\t\t   + 4 * (ngnubuckets + maxchain), 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      do\n\t{\n\t  if (fread (nb, 4, 1, filedata->handle) != 1)\n\t    {\n\t      error (_(\"Failed to determine last chain length\\n\"));\n\t  gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  if (maxchain + 1 == 0)\n\t    {\n\t      gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  ++maxchain;\n\t}\n      while ((byte_get (nb, 4) & 1) == 0);\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma + 4 * ngnubuckets, 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      gnuchains = get_dynamic_data (filedata, maxchain, 4);\n      ngnuchains = maxchain;\n\n      if (gnuchains == NULL)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      if (dynamic_info_DT_MIPS_XHASH)\n\t{\n\t  if (fseek (filedata->handle,\n\t\t     (archive_file_offset\n\t\t      + offset_from_vma (filedata, (buckets_vma\n\t\t\t\t\t\t    + 4 * (ngnubuckets\n\t\t\t\t\t\t\t   + maxchain)), 4)),\n\t\t     SEEK_SET))\n\t    {\n\t      error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t      gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  mipsxlat = get_dynamic_data (filedata, maxchain, 4);\n\t}\n\n      for (hn = 0; hn < ngnubuckets; ++hn)\n\tif (gnubuckets[hn] != 0)\n\t  {\n\t    bfd_vma si = gnubuckets[hn];\n\t    bfd_vma off = si - gnusymidx;\n\n\t    do\n\t      {\n\t\tif (dynamic_info_DT_MIPS_XHASH)\n\t\t  {\n\t\t    if (mipsxlat[off] >= num_of_syms)\n\t\t      num_of_syms = mipsxlat[off] + 1;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    if (si >= num_of_syms)\n\t\t      num_of_syms = si + 1;\n\t\t  }\n\t\tsi++;\n\t      }\n\t    while (off < ngnuchains && (gnuchains[off++] & 1) == 0);\n\t  }\n\n  no_gnu_hash:\n      if (gnu_hash_error)\n\t{\n\t  if (mipsxlat)\n\t    {\n\t      free (mipsxlat);\n\t      mipsxlat = NULL;\n\t    }\n\t  if (gnuchains)\n\t    {\n\t      free (gnuchains);\n\t      gnuchains = NULL;\n\t    }\n\t  if (gnubuckets)\n\t    {\n\t      free (gnubuckets);\n\t      gnubuckets = NULL;\n\t    }\n\t  ngnubuckets = 0;\n\t  ngnuchains = 0;\n\t}\n    }\n\n  return num_of_syms;\n}",
        "description": "A double free vulnerability exists in the Binary File Descriptor (BFD), also known as libbfd, within GNU Binutils 2.35 during the processing of symbol tables, specifically as exhibited in the readelf utility through the manipulation of a specially crafted file.",
        "commit": "The vulnerability knowledge has been abstracted and generalized as follows:\n\n\"A typo fix was made in the `readelf` tool to consolidate the functionality of the `--syms` and `--use-dynamic` options with the `--dyn-syms` option.\""
    },
    {
        "cwe": "CWE-122",
        "func_name": "vim/ins_compl_infercase_gettext",
        "score": 0.7954459190368652,
        "func_before": "static char_u *\nins_compl_infercase_gettext(\n\tchar_u\t*str,\n\tint\tchar_len,\n\tint\tcompl_char_len,\n\tint\tmin_len,\n\tchar_u  **tofree)\n{\n    int\t\t*wca;\t\t\t// Wide character array.\n    char_u\t*p;\n    int\t\ti, c;\n    int\t\thas_lower = FALSE;\n    int\t\twas_letter = FALSE;\n    garray_T\tgap;\n\n    IObuff[0] = NUL;\n\n    // Allocate wide character array for the completion and fill it.\n    wca = ALLOC_MULT(int, char_len);\n    if (wca == NULL)\n\treturn IObuff;\n\n    p = str;\n    for (i = 0; i < char_len; ++i)\n\tif (has_mbyte)\n\t    wca[i] = mb_ptr2char_adv(&p);\n\telse\n\t    wca[i] = *(p++);\n\n    // Rule 1: Were any chars converted to lower?\n    p = compl_orig_text;\n    for (i = 0; i < min_len; ++i)\n    {\n\tif (has_mbyte)\n\t    c = mb_ptr2char_adv(&p);\n\telse\n\t    c = *(p++);\n\tif (MB_ISLOWER(c))\n\t{\n\t    has_lower = TRUE;\n\t    if (MB_ISUPPER(wca[i]))\n\t    {\n\t\t// Rule 1 is satisfied.\n\t\tfor (i = compl_char_len; i < char_len; ++i)\n\t\t    wca[i] = MB_TOLOWER(wca[i]);\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    // Rule 2: No lower case, 2nd consecutive letter converted to\n    // upper case.\n    if (!has_lower)\n    {\n\tp = compl_orig_text;\n\tfor (i = 0; i < min_len; ++i)\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char_adv(&p);\n\t    else\n\t\tc = *(p++);\n\t    if (was_letter && MB_ISUPPER(c) && MB_ISLOWER(wca[i]))\n\t    {\n\t\t// Rule 2 is satisfied.\n\t\tfor (i = compl_char_len; i < char_len; ++i)\n\t\t    wca[i] = MB_TOUPPER(wca[i]);\n\t\tbreak;\n\t    }\n\t    was_letter = MB_ISLOWER(c) || MB_ISUPPER(c);\n\t}\n    }\n\n    // Copy the original case of the part we typed.\n    p = compl_orig_text;\n    for (i = 0; i < min_len; ++i)\n    {\n\tif (has_mbyte)\n\t    c = mb_ptr2char_adv(&p);\n\telse\n\t    c = *(p++);\n\tif (MB_ISLOWER(c))\n\t    wca[i] = MB_TOLOWER(wca[i]);\n\telse if (MB_ISUPPER(c))\n\t    wca[i] = MB_TOUPPER(wca[i]);\n    }\n\n    // Generate encoding specific output from wide character array.\n    p = IObuff;\n    i = 0;\n    ga_init2(&gap, 1, 500);\n    while (i < char_len)\n    {\n\tif (gap.ga_data != NULL)\n\t{\n\t    if (ga_grow(&gap, 10) == FAIL)\n\t    {\n\t\tga_clear(&gap);\n\t\treturn (char_u *)\"[failed]\";\n\t    }\n\t    p = (char_u *)gap.ga_data + gap.ga_len;\n\t    if (has_mbyte)\n\t\tgap.ga_len += (*mb_char2bytes)(wca[i++], p);\n\t    else\n\t    {\n\t\t*p = wca[i++];\n\t\t++gap.ga_len;\n\t    }\n\t}\n\telse if ((p - IObuff) + 6 >= IOSIZE)\n\t{\n\t    // Multi-byte characters can occupy up to five bytes more than\n\t    // ASCII characters, and we also need one byte for NUL, so when\n\t    // getting to six bytes from the edge of IObuff switch to using a\n\t    // growarray.  Add the character in the next round.\n\t    if (ga_grow(&gap, IOSIZE) == FAIL)\n\t\treturn (char_u *)\"[failed]\";\n\t    STRCPY(gap.ga_data, IObuff);\n\t    gap.ga_len = (int)STRLEN(IObuff);\n\t}\n\telse if (has_mbyte)\n\t    p += (*mb_char2bytes)(wca[i++], p);\n\telse\n\t    *(p++) = wca[i++];\n    }\n    vim_free(wca);\n\n    if (gap.ga_data != NULL)\n    {\n\t*tofree = gap.ga_data;\n\treturn gap.ga_data;\n    }\n\n    *p = NUL;\n    return IObuff;\n}",
        "func_after": "static char_u *\nins_compl_infercase_gettext(\n\tchar_u\t*str,\n\tint\tchar_len,\n\tint\tcompl_char_len,\n\tint\tmin_len,\n\tchar_u  **tofree)\n{\n    int\t\t*wca;\t\t\t// Wide character array.\n    char_u\t*p;\n    int\t\ti, c;\n    int\t\thas_lower = FALSE;\n    int\t\twas_letter = FALSE;\n    garray_T\tgap;\n\n    IObuff[0] = NUL;\n\n    // Allocate wide character array for the completion and fill it.\n    wca = ALLOC_MULT(int, char_len);\n    if (wca == NULL)\n\treturn IObuff;\n\n    p = str;\n    for (i = 0; i < char_len; ++i)\n\tif (has_mbyte)\n\t    wca[i] = mb_ptr2char_adv(&p);\n\telse\n\t    wca[i] = *(p++);\n\n    // Rule 1: Were any chars converted to lower?\n    p = compl_orig_text;\n    for (i = 0; i < min_len; ++i)\n    {\n\tif (has_mbyte)\n\t    c = mb_ptr2char_adv(&p);\n\telse\n\t    c = *(p++);\n\tif (MB_ISLOWER(c))\n\t{\n\t    has_lower = TRUE;\n\t    if (MB_ISUPPER(wca[i]))\n\t    {\n\t\t// Rule 1 is satisfied.\n\t\tfor (i = compl_char_len; i < char_len; ++i)\n\t\t    wca[i] = MB_TOLOWER(wca[i]);\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    // Rule 2: No lower case, 2nd consecutive letter converted to\n    // upper case.\n    if (!has_lower)\n    {\n\tp = compl_orig_text;\n\tfor (i = 0; i < min_len; ++i)\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char_adv(&p);\n\t    else\n\t\tc = *(p++);\n\t    if (was_letter && MB_ISUPPER(c) && MB_ISLOWER(wca[i]))\n\t    {\n\t\t// Rule 2 is satisfied.\n\t\tfor (i = compl_char_len; i < char_len; ++i)\n\t\t    wca[i] = MB_TOUPPER(wca[i]);\n\t\tbreak;\n\t    }\n\t    was_letter = MB_ISLOWER(c) || MB_ISUPPER(c);\n\t}\n    }\n\n    // Copy the original case of the part we typed.\n    p = compl_orig_text;\n    for (i = 0; i < min_len; ++i)\n    {\n\tif (has_mbyte)\n\t    c = mb_ptr2char_adv(&p);\n\telse\n\t    c = *(p++);\n\tif (MB_ISLOWER(c))\n\t    wca[i] = MB_TOLOWER(wca[i]);\n\telse if (MB_ISUPPER(c))\n\t    wca[i] = MB_TOUPPER(wca[i]);\n    }\n\n    // Generate encoding specific output from wide character array.\n    p = IObuff;\n    i = 0;\n    ga_init2(&gap, 1, 500);\n    while (i < char_len)\n    {\n\tif (gap.ga_data != NULL)\n\t{\n\t    if (ga_grow(&gap, 10) == FAIL)\n\t    {\n\t\tga_clear(&gap);\n\t\treturn (char_u *)\"[failed]\";\n\t    }\n\t    p = (char_u *)gap.ga_data + gap.ga_len;\n\t    if (has_mbyte)\n\t\tgap.ga_len += (*mb_char2bytes)(wca[i++], p);\n\t    else\n\t    {\n\t\t*p = wca[i++];\n\t\t++gap.ga_len;\n\t    }\n\t}\n\telse if ((p - IObuff) + 6 >= IOSIZE)\n\t{\n\t    // Multi-byte characters can occupy up to five bytes more than\n\t    // ASCII characters, and we also need one byte for NUL, so when\n\t    // getting to six bytes from the edge of IObuff switch to using a\n\t    // growarray.  Add the character in the next round.\n\t    if (ga_grow(&gap, IOSIZE) == FAIL)\n\t\treturn (char_u *)\"[failed]\";\n\t    *p = NUL;\n\t    STRCPY(gap.ga_data, IObuff);\n\t    gap.ga_len = (int)STRLEN(IObuff);\n\t}\n\telse if (has_mbyte)\n\t    p += (*mb_char2bytes)(wca[i++], p);\n\telse\n\t    *(p++) = wca[i++];\n    }\n    vim_free(wca);\n\n    if (gap.ga_data != NULL)\n    {\n\t*tofree = gap.ga_data;\n\treturn gap.ga_data;\n    }\n\n    *p = NUL;\n    return IObuff;\n}",
        "description": "Heap-based Buffer Overflow in the Vim text editor prior to version 9.0.0044.",
        "commit": "Reading past the end of a buffer when processing a long line with the 'infercase' option enabled. Solution involves dynamically allocating the string if necessary."
    },
    {
        "cwe": "CWE-125",
        "func_name": "torvalds/do_split",
        "score": 0.8081527352333069,
        "func_before": "static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Split the existing block in the middle, size-wise */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/* map index at which we will split */\n\tsplit = count - move;\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}",
        "func_after": "static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,\n\t\t\tstruct buffer_head **bh,struct dx_frame *frame,\n\t\t\tstruct dx_hash_info *hinfo)\n{\n\tunsigned blocksize = dir->i_sb->s_blocksize;\n\tunsigned count, continued;\n\tstruct buffer_head *bh2;\n\text4_lblk_t newblock;\n\tu32 hash2;\n\tstruct dx_map_entry *map;\n\tchar *data1 = (*bh)->b_data, *data2;\n\tunsigned split, move, size;\n\tstruct ext4_dir_entry_2 *de = NULL, *de2;\n\tint\tcsum_size = 0;\n\tint\terr = 0, i;\n\n\tif (ext4_has_metadata_csum(dir->i_sb))\n\t\tcsum_size = sizeof(struct ext4_dir_entry_tail);\n\n\tbh2 = ext4_append(handle, dir, &newblock);\n\tif (IS_ERR(bh2)) {\n\t\tbrelse(*bh);\n\t\t*bh = NULL;\n\t\treturn (struct ext4_dir_entry_2 *) bh2;\n\t}\n\n\tBUFFER_TRACE(*bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, *bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tBUFFER_TRACE(frame->bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\n\tdata2 = bh2->b_data;\n\n\t/* create map in the end of data2 block */\n\tmap = (struct dx_map_entry *) (data2 + blocksize);\n\tcount = dx_make_map(dir, (struct ext4_dir_entry_2 *) data1,\n\t\t\t     blocksize, hinfo, map);\n\tmap -= count;\n\tdx_sort_map(map, count);\n\t/* Ensure that neither split block is over half full */\n\tsize = 0;\n\tmove = 0;\n\tfor (i = count-1; i >= 0; i--) {\n\t\t/* is more than half of this entry in 2nd half of the block? */\n\t\tif (size + map[i].size/2 > blocksize/2)\n\t\t\tbreak;\n\t\tsize += map[i].size;\n\t\tmove++;\n\t}\n\t/*\n\t * map index at which we will split\n\t *\n\t * If the sum of active entries didn't exceed half the block size, just\n\t * split it in half by count; each resulting block will have at least\n\t * half the space free.\n\t */\n\tif (i > 0)\n\t\tsplit = count - move;\n\telse\n\t\tsplit = count/2;\n\n\thash2 = map[split].hash;\n\tcontinued = hash2 == map[split - 1].hash;\n\tdxtrace(printk(KERN_INFO \"Split block %lu at %x, %i/%i\\n\",\n\t\t\t(unsigned long)dx_get_block(frame->at),\n\t\t\t\t\thash2, split, count-split));\n\n\t/* Fancy dance to stay within two buffers */\n\tde2 = dx_move_dirents(data1, data2, map + split, count - split,\n\t\t\t      blocksize);\n\tde = dx_pack_dirents(data1, blocksize);\n\tde->rec_len = ext4_rec_len_to_disk(data1 + (blocksize - csum_size) -\n\t\t\t\t\t   (char *) de,\n\t\t\t\t\t   blocksize);\n\tde2->rec_len = ext4_rec_len_to_disk(data2 + (blocksize - csum_size) -\n\t\t\t\t\t    (char *) de2,\n\t\t\t\t\t    blocksize);\n\tif (csum_size) {\n\t\text4_initialize_dirent_tail(*bh, blocksize);\n\t\text4_initialize_dirent_tail(bh2, blocksize);\n\t}\n\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data1,\n\t\t\tblocksize, 1));\n\tdxtrace(dx_show_leaf(dir, hinfo, (struct ext4_dir_entry_2 *) data2,\n\t\t\tblocksize, 1));\n\n\t/* Which block gets the new entry? */\n\tif (hinfo->hash >= hash2) {\n\t\tswap(*bh, bh2);\n\t\tde = de2;\n\t}\n\tdx_insert_block(frame, hash2 + continued, newblock);\n\terr = ext4_handle_dirty_dirblock(handle, dir, bh2);\n\tif (err)\n\t\tgoto journal_error;\n\terr = ext4_handle_dirty_dx_node(handle, dir, frame->bh);\n\tif (err)\n\t\tgoto journal_error;\n\tbrelse(bh2);\n\tdxtrace(dx_show_index(\"frame\", frame->entries));\n\treturn de;\n\njournal_error:\n\tbrelse(*bh);\n\tbrelse(bh2);\n\t*bh = NULL;\n\text4_std_error(dir->i_sb, err);\n\treturn ERR_PTR(err);\n}",
        "description": "A memory out-of-bounds read flaw was identified in the Linux kernel prior to version 5.9-rc2, specifically within the ext3/ext4 file system. This flaw occurs when accessing a directory with broken indexing, potentially allowing a local user to crash the system if such a directory exists. The primary risk associated with this vulnerability is a decrease in system availability.",
        "commit": "If a directory passed to the `do_split()` function lacks sufficient active entries to surpass half the block size, it may result in iterating through all \"count\" entries without identifying a split point. In such cases, where `count` equals `move` and `split` becomes zero, an attempt to access a negative index in the `map[]` array could occur. To prevent this, detect this scenario and fall back to splitting at half of the count, ensuring that each split block still has ample space greater than half the block size."
    }
]