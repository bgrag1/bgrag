[
    {
        "cwe": "CWE-134",
        "func_name": "wireapp/audio_level_json",
        "score": 0.7929584980010986,
        "func_before": "int audio_level_json(struct list *levell,\n\t\t     const char *userid_self, const char *clientid_self,\n\t\t     char **json_str, char **anon_str)\n{\n\tstruct json_object *jobj;\n\tstruct json_object *jarr;\n\tchar uid_anon[ANON_ID_LEN];\n\tchar cid_anon[ANON_CLIENT_LEN];\n\tstruct mbuf *pmb = NULL;\n\tint err = 0;\n\tstruct le *le;\n\n\tif (!levell || !json_str)\n\t\treturn EINVAL;\n\t\n\tjobj = jzon_alloc_object();\n\tif (!jobj)\n\t\treturn ENOMEM;\n\n\tjarr = jzon_alloc_array();\n\tif (!jarr) {\n\t\terr = ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (anon_str) {\n\t\tpmb = mbuf_alloc(512);\n\t\tmbuf_printf(pmb, \"%zu levels: \", list_count(levell));\n\t}\n\t\n\tLIST_FOREACH(levell, le) {\n\t\tstruct audio_level *a = le->data;\n\t\tstruct json_object *ja;\n\t\tconst char *userid = a->userid;\n\t\tconst char *clientid = a->clientid;\n\n\t\tif (a->is_self) {\n\t\t\tif (userid_self)\n\t\t\t\tuserid = userid_self;\n\t\t\tif (clientid_self)\n\t\t\t\tclientid = clientid_self;\n\t\t}\n\n\t\tja = jzon_alloc_object();\n\t\tif (ja) {\n\t\t\tjzon_add_str(ja, \"userid\", userid);\n\t\t\tjzon_add_str(ja, \"clientid\", clientid);\n\t\t\tjzon_add_int(ja, \"audio_level\",\n\t\t\t\t     (int32_t)a->aulevel_smooth);\n\t\t\tjzon_add_int(ja, \"audio_level_now\",\n\t\t\t\t     (int32_t)a->aulevel);\n\t\t}\n\t\tjson_object_array_add(jarr, ja);\n\n\t\t/* add to info string */\n\t\tif (pmb) {\n\t\t\tanon_id(uid_anon, userid);\n\t\t\tanon_client(cid_anon, clientid);\n\t\t\tmbuf_printf(pmb, \"{[%s.%s] audio_level: %d/%d}\",\n\t\t\t\t    uid_anon, cid_anon,\n\t\t\t\t    a->aulevel_smooth, a->aulevel);\n\t\t\tif (le != levell->tail)\n\t\t\t\tmbuf_printf(pmb, \",\");\n\t\t}\t\t\n\t}\n\tjson_object_object_add(jobj, \"audio_levels\", jarr);\n\n\tif (pmb) {\n\t\tpmb->pos = 0;\n\t\tmbuf_strdup(pmb, anon_str, pmb->end);\n\t\tmem_deref(pmb);\n\t}\n\n\tjzon_encode(json_str, jobj);\n out:\t\n\tmem_deref(jobj);\n\n\treturn err;\n}",
        "func_after": "int audio_level_json(struct list *levell,\n\t\t     const char *userid_self, const char *clientid_self,\n\t\t     char **json_str, char **anon_str)\n{\n\tstruct json_object *jobj;\n\tstruct json_object *jarr;\n\tchar uid_anon[ANON_ID_LEN];\n\tchar cid_anon[ANON_CLIENT_LEN];\n\tstruct mbuf *pmb = NULL;\n\tint err = 0;\n\tstruct le *le;\n\n\tif (!levell || !json_str)\n\t\treturn EINVAL;\n\t\n\tjobj = jzon_alloc_object();\n\tif (!jobj)\n\t\treturn ENOMEM;\n\n\tjarr = jzon_alloc_array();\n\tif (!jarr) {\n\t\terr = ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (anon_str) {\n\t\tpmb = mbuf_alloc(512);\n\t\tmbuf_printf(pmb, \"%zu levels: \", list_count(levell));\n\t}\n\t\n\tLIST_FOREACH(levell, le) {\n\t\tstruct audio_level *a = le->data;\n\t\tstruct json_object *ja;\n\t\tconst char *userid = a->userid;\n\t\tconst char *clientid = a->clientid;\n\n\t\tif (a->is_self) {\n\t\t\tif (userid_self)\n\t\t\t\tuserid = userid_self;\n\t\t\tif (clientid_self)\n\t\t\t\tclientid = clientid_self;\n\t\t}\n\n\t\tja = jzon_alloc_object();\n\t\tif (ja) {\n\t\t\tjzon_add_str(ja, \"userid\", \"%s\", userid);\n\t\t\tjzon_add_str(ja, \"clientid\", \"%s\", clientid);\n\t\t\tjzon_add_int(ja, \"audio_level\",\n\t\t\t\t     (int32_t)a->aulevel_smooth);\n\t\t\tjzon_add_int(ja, \"audio_level_now\",\n\t\t\t\t     (int32_t)a->aulevel);\n\t\t}\n\t\tjson_object_array_add(jarr, ja);\n\n\t\t/* add to info string */\n\t\tif (pmb) {\n\t\t\tanon_id(uid_anon, userid);\n\t\t\tanon_client(cid_anon, clientid);\n\t\t\tmbuf_printf(pmb, \"{[%s.%s] audio_level: %d/%d}\",\n\t\t\t\t    uid_anon, cid_anon,\n\t\t\t\t    a->aulevel_smooth, a->aulevel);\n\t\t\tif (le != levell->tail)\n\t\t\t\tmbuf_printf(pmb, \",\");\n\t\t}\t\t\n\t}\n\tjson_object_object_add(jobj, \"audio_levels\", jarr);\n\n\tif (pmb) {\n\t\tpmb->pos = 0;\n\t\tmbuf_strdup(pmb, anon_str, pmb->end);\n\t\tmem_deref(pmb);\n\t}\n\n\tjzon_encode(json_str, jobj);\n out:\t\n\tmem_deref(jobj);\n\n\treturn err;\n}",
        "description": "A remote format string vulnerability in the wire-avs component of Wire, an open-source messenger, affects versions prior to 7.1.12. This vulnerability could lead to a denial of service or the execution of arbitrary code by an attacker. The issue has been addressed in wire-avs version 7.1.12, and there are currently no known workarounds available.",
        "commit": "The process of importing the latest release-7.1 files from an old repository."
    },
    {
        "cwe": "CWE-264",
        "func_name": "newlib-cygwin/lsaauth",
        "score": 0.8003199696540833,
        "func_before": "HANDLE\nlsaauth (cygsid &usersid, user_groups &new_groups)\n{\n  cygsidlist tmp_gsids (cygsidlist_auto, 12);\n  cygpsid pgrpsid;\n  LSA_STRING name;\n  HANDLE lsa_hdl = NULL, lsa = NULL;\n  LSA_OPERATIONAL_MODE sec_mode;\n  NTSTATUS status, sub_status;\n  ULONG package_id, size;\n  LUID auth_luid = SYSTEM_LUID;\n  struct {\n    LSA_STRING str;\n    CHAR buf[16];\n  } origin;\n  DWORD ulen = UNLEN + 1;\n  DWORD dlen = MAX_DOMAIN_NAME_LEN + 1;\n  SID_NAME_USE use;\n  cyglsa_t *authinf = NULL;\n  ULONG authinf_size;\n  TOKEN_SOURCE ts;\n  PCYG_TOKEN_GROUPS gsids = NULL;\n  PTOKEN_PRIVILEGES privs = NULL;\n  PACL dacl = NULL;\n  PVOID profile = NULL;\n  LUID luid;\n  QUOTA_LIMITS quota;\n  size_t psize = 0, gsize = 0, dsize = 0;\n  OFFSET offset, sids_offset;\n  int tmpidx, non_well_known_cnt;\n\n  HANDLE user_token = NULL;\n\n  push_self_privilege (SE_TCB_PRIVILEGE, true);\n\n  /* Register as logon process. */\n  RtlInitAnsiString (&name, \"Cygwin\");\n  SetLastError (0);\n  status = LsaRegisterLogonProcess (&name, &lsa_hdl, &sec_mode);\n  if (status != STATUS_SUCCESS)\n    {\n      debug_printf (\"LsaRegisterLogonProcess: %y\", status);\n      __seterrno_from_nt_status (status);\n      goto out;\n    }\n  else if (GetLastError () == ERROR_PROC_NOT_FOUND)\n    {\n      debug_printf (\"Couldn't load Secur32.dll\");\n      goto out;\n    }\n  /* Get handle to our own LSA package. */\n  RtlInitAnsiString (&name, CYG_LSA_PKGNAME);\n  status = LsaLookupAuthenticationPackage (lsa_hdl, &name, &package_id);\n  if (status != STATUS_SUCCESS)\n    {\n      debug_printf (\"LsaLookupAuthenticationPackage: %y\", status);\n      __seterrno_from_nt_status (status);\n      goto out;\n    }\n\n  /* Open policy object. */\n  if (!(lsa = lsa_open_policy (NULL, POLICY_EXECUTE)))\n    goto out;\n\n  /* Create origin. */\n  stpcpy (origin.buf, \"Cygwin\");\n  RtlInitAnsiString (&origin.str, origin.buf);\n  /* Create token source. */\n  memcpy (ts.SourceName, \"Cygwin.1\", 8);\n  ts.SourceIdentifier.HighPart = 0;\n  ts.SourceIdentifier.LowPart = 0x0103;\n\n  /* Create list of groups, the user is member in. */\n  int auth_pos;\n  if (new_groups.issetgroups ())\n    get_setgroups_sidlist (tmp_gsids, usersid, NULL, new_groups, auth_luid,\n\t\t\t   auth_pos);\n  else if (!get_initgroups_sidlist (tmp_gsids, usersid, new_groups.pgsid,\n\t\t\t\t    NULL, auth_luid, auth_pos))\n    goto out;\n\n  tmp_gsids.debug_print (\"tmp_gsids\");\n\n  /* Evaluate size of TOKEN_GROUPS list */\n  non_well_known_cnt =  tmp_gsids.non_well_known_count ();\n  gsize = sizeof (DWORD) + non_well_known_cnt * sizeof (SID_AND_ATTRIBUTES);\n  tmpidx = -1;\n  for (int i = 0; i < non_well_known_cnt; ++i)\n    if ((tmpidx = tmp_gsids.next_non_well_known_sid (tmpidx)) >= 0)\n      gsize += RtlLengthSid (tmp_gsids.sids[tmpidx]);\n\n  /* Retrieve list of privileges of that user.  The MIC SID is created by\n     the LSA here. */\n  if (!(privs = get_priv_list (lsa, usersid, tmp_gsids, psize, NULL)))\n    goto out;\n\n  /* Create DefaultDacl. */\n  dsize = sizeof (ACL) + 3 * sizeof (ACCESS_ALLOWED_ACE)\n\t  + RtlLengthSid (usersid)\n\t  + RtlLengthSid (well_known_admins_sid)\n\t  + RtlLengthSid (well_known_system_sid);\n  dacl = (PACL) alloca (dsize);\n  if (!NT_SUCCESS (RtlCreateAcl (dacl, dsize, ACL_REVISION)))\n    goto out;\n  if (!NT_SUCCESS (RtlAddAccessAllowedAce (dacl, ACL_REVISION, GENERIC_ALL,\n\t\t\t\t\t   usersid)))\n    goto out;\n  if (!NT_SUCCESS (RtlAddAccessAllowedAce (dacl, ACL_REVISION, GENERIC_ALL,\n\t\t\t\t\t   well_known_admins_sid)))\n    goto out;\n  if (!NT_SUCCESS (RtlAddAccessAllowedAce (dacl, ACL_REVISION, GENERIC_ALL,\n\t\t\t\t\t   well_known_system_sid)))\n    goto out;\n\n  /* Evaluate authinf size and allocate authinf. */\n  authinf_size = (authinf->data - (PBYTE) authinf);\n  authinf_size += RtlLengthSid (usersid);\t    /* User SID */\n  authinf_size += gsize;\t\t\t    /* Groups + Group SIDs */\n  /* When trying to define the admins group as primary group on Vista,\n     LsaLogonUser fails with error STATUS_INVALID_OWNER.  As workaround\n     we define \"Local\" as primary group here.  Seteuid32 sets the primary\n     group to the group set in /etc/passwd anyway. */\n  if (new_groups.pgsid == well_known_admins_sid)\n    pgrpsid = well_known_local_sid;\n  else\n    pgrpsid = new_groups.pgsid;\n\n  authinf_size += RtlLengthSid (pgrpsid);\t    /* Primary Group SID */\n\n  authinf_size += psize;\t\t\t    /* Privileges */\n  authinf_size += 0;\t\t\t\t    /* Owner SID */\n  authinf_size += dsize;\t\t\t    /* Default DACL */\n\n  authinf = (cyglsa_t *) alloca (authinf_size);\n  authinf->inf_size = authinf_size - ((PBYTE) &authinf->inf - (PBYTE) authinf);\n\n  authinf->magic = CYG_LSA_MAGIC;\n\n  if (!LookupAccountSidW (NULL, usersid, authinf->username, &ulen,\n\t\t\t  authinf->domain, &dlen, &use))\n    {\n      __seterrno ();\n      goto out;\n    }\n\n  /* Store stuff in authinf with offset relative to start of \"inf\" member,\n     instead of using pointers. */\n  offset = authinf->data - (PBYTE) &authinf->inf;\n\n  authinf->inf.ExpirationTime.LowPart = 0xffffffffL;\n  authinf->inf.ExpirationTime.HighPart = 0x7fffffffL;\n  /* User SID */\n  authinf->inf.User.User.Sid = offset;\n  authinf->inf.User.User.Attributes = 0;\n  RtlCopySid (RtlLengthSid (usersid), (PSID) ((PBYTE) &authinf->inf + offset),\n\t      usersid);\n  offset += RtlLengthSid (usersid);\n  /* Groups */\n  authinf->inf.Groups = offset;\n  gsids = (PCYG_TOKEN_GROUPS) ((PBYTE) &authinf->inf + offset);\n  sids_offset = offset + sizeof (ULONG) + non_well_known_cnt\n\t\t\t\t\t  * sizeof (SID_AND_ATTRIBUTES);\n  gsids->GroupCount = non_well_known_cnt;\n  /* Group SIDs */\n  tmpidx = -1;\n  for (int i = 0; i < non_well_known_cnt; ++i)\n    {\n      if ((tmpidx = tmp_gsids.next_non_well_known_sid (tmpidx)) < 0)\n\tbreak;\n      gsids->Groups[i].Sid = sids_offset;\n      gsids->Groups[i].Attributes = SE_GROUP_MANDATORY\n\t\t\t\t    | SE_GROUP_ENABLED_BY_DEFAULT\n\t\t\t\t    | SE_GROUP_ENABLED;\n      RtlCopySid (RtlLengthSid (tmp_gsids.sids[tmpidx]),\n\t\t  (PSID) ((PBYTE) &authinf->inf + sids_offset),\n\t\t  tmp_gsids.sids[tmpidx]);\n      sids_offset += RtlLengthSid (tmp_gsids.sids[tmpidx]);\n    }\n  offset += gsize;\n  /* Primary Group SID */\n  authinf->inf.PrimaryGroup.PrimaryGroup = offset;\n  RtlCopySid (RtlLengthSid (pgrpsid), (PSID) ((PBYTE) &authinf->inf + offset),\n\t      pgrpsid);\n  offset += RtlLengthSid (pgrpsid);\n  /* Privileges */\n  authinf->inf.Privileges = offset;\n  memcpy ((PBYTE) &authinf->inf + offset, privs, psize);\n  offset += psize;\n  /* Owner */\n  authinf->inf.Owner.Owner = 0;\n  /* Default DACL */\n  authinf->inf.DefaultDacl.DefaultDacl = offset;\n  memcpy ((PBYTE) &authinf->inf + offset, dacl, dsize);\n\n  authinf->checksum = CYG_LSA_MAGIC;\n  PDWORD csp;\n  PDWORD csp_end;\n  csp = (PDWORD) &authinf->username;\n  csp_end = (PDWORD) ((PBYTE) authinf + authinf_size);\n  while (csp < csp_end)\n    authinf->checksum += *csp++;\n\n  /* Try to logon... */\n  status = LsaLogonUser (lsa_hdl, (PLSA_STRING) &origin, Interactive,\n\t\t\t package_id, authinf, authinf_size, NULL, &ts,\n\t\t\t &profile, &size, &luid, &user_token, &quota,\n\t\t\t &sub_status);\n  if (status != STATUS_SUCCESS)\n    {\n      debug_printf (\"LsaLogonUser: %y (sub-status %y)\", status, sub_status);\n      __seterrno_from_nt_status (status);\n      goto out;\n    }\n  if (profile)\n    {\n#ifdef JUST_ANOTHER_NONWORKING_SOLUTION\n      /* See ../lsaauth/cyglsa.c. */\n      cygprf_t *prf = (cygprf_t *) profile;\n      if (prf->magic_pre == MAGIC_PRE && prf->magic_post == MAGIC_POST\n\t  && prf->token)\n\t{\n\t  CloseHandle (user_token);\n\t  user_token = prf->token;\n\t  system_printf (\"Got token through profile: %p\", user_token);\n\t}\n#endif /* JUST_ANOTHER_NONWORKING_SOLUTION */\n      LsaFreeReturnBuffer (profile);\n    }\n  user_token = get_full_privileged_inheritable_token (user_token);\n\nout:\n  if (privs)\n    free (privs);\n  lsa_close_policy (lsa);\n  if (lsa_hdl)\n    LsaDeregisterLogonProcess (lsa_hdl);\n  pop_self_privilege ();\n\n  debug_printf (\"%p = lsaauth ()\", user_token);\n  return user_token;\n}",
        "func_after": "HANDLE\nlsaauth (cygsid &usersid, user_groups &new_groups)\n{\n  cygsidlist tmp_gsids (cygsidlist_auto, 12);\n  cygpsid pgrpsid;\n  LSA_STRING name;\n  HANDLE lsa_hdl = NULL, lsa = NULL;\n  LSA_OPERATIONAL_MODE sec_mode;\n  NTSTATUS status, sub_status;\n  ULONG package_id, size;\n  struct {\n    LSA_STRING str;\n    CHAR buf[16];\n  } origin;\n  DWORD ulen = UNLEN + 1;\n  DWORD dlen = MAX_DOMAIN_NAME_LEN + 1;\n  SID_NAME_USE use;\n  cyglsa_t *authinf = NULL;\n  ULONG authinf_size;\n  TOKEN_SOURCE ts;\n  PCYG_TOKEN_GROUPS gsids = NULL;\n  PTOKEN_PRIVILEGES privs = NULL;\n  PACL dacl = NULL;\n  PVOID profile = NULL;\n  LUID luid;\n  QUOTA_LIMITS quota;\n  size_t psize = 0, gsize = 0, dsize = 0;\n  OFFSET offset, sids_offset;\n  int tmpidx, non_well_known_cnt;\n\n  HANDLE user_token = NULL;\n\n  push_self_privilege (SE_TCB_PRIVILEGE, true);\n\n  /* Register as logon process. */\n  RtlInitAnsiString (&name, \"Cygwin\");\n  SetLastError (0);\n  status = LsaRegisterLogonProcess (&name, &lsa_hdl, &sec_mode);\n  if (status != STATUS_SUCCESS)\n    {\n      debug_printf (\"LsaRegisterLogonProcess: %y\", status);\n      __seterrno_from_nt_status (status);\n      goto out;\n    }\n  else if (GetLastError () == ERROR_PROC_NOT_FOUND)\n    {\n      debug_printf (\"Couldn't load Secur32.dll\");\n      goto out;\n    }\n  /* Get handle to our own LSA package. */\n  RtlInitAnsiString (&name, CYG_LSA_PKGNAME);\n  status = LsaLookupAuthenticationPackage (lsa_hdl, &name, &package_id);\n  if (status != STATUS_SUCCESS)\n    {\n      debug_printf (\"LsaLookupAuthenticationPackage: %y\", status);\n      __seterrno_from_nt_status (status);\n      goto out;\n    }\n\n  /* Open policy object. */\n  if (!(lsa = lsa_open_policy (NULL, POLICY_EXECUTE)))\n    goto out;\n\n  /* Create origin. */\n  stpcpy (origin.buf, \"Cygwin\");\n  RtlInitAnsiString (&origin.str, origin.buf);\n  /* Create token source. */\n  memcpy (ts.SourceName, \"Cygwin.1\", 8);\n  ts.SourceIdentifier.HighPart = 0;\n  ts.SourceIdentifier.LowPart = 0x0103;\n\n  /* Create list of groups, the user is member in. */\n  if (new_groups.issetgroups ())\n    get_setgroups_sidlist (tmp_gsids, usersid, NULL, new_groups);\n  else if (!get_initgroups_sidlist (tmp_gsids, usersid, new_groups.pgsid,\n\t\t\t\t    NULL))\n    goto out;\n\n  tmp_gsids.debug_print (\"tmp_gsids\");\n\n  /* Evaluate size of TOKEN_GROUPS list */\n  non_well_known_cnt =  tmp_gsids.non_well_known_count ();\n  gsize = sizeof (DWORD) + non_well_known_cnt * sizeof (SID_AND_ATTRIBUTES);\n  tmpidx = -1;\n  for (int i = 0; i < non_well_known_cnt; ++i)\n    if ((tmpidx = tmp_gsids.next_non_well_known_sid (tmpidx)) >= 0)\n      gsize += RtlLengthSid (tmp_gsids.sids[tmpidx]);\n\n  /* Retrieve list of privileges of that user.  The MIC SID is created by\n     the LSA here. */\n  if (!(privs = get_priv_list (lsa, usersid, tmp_gsids, psize, NULL)))\n    goto out;\n\n  /* Create DefaultDacl. */\n  dsize = sizeof (ACL) + 3 * sizeof (ACCESS_ALLOWED_ACE)\n\t  + RtlLengthSid (usersid)\n\t  + RtlLengthSid (well_known_admins_sid)\n\t  + RtlLengthSid (well_known_system_sid);\n  dacl = (PACL) alloca (dsize);\n  if (!NT_SUCCESS (RtlCreateAcl (dacl, dsize, ACL_REVISION)))\n    goto out;\n  if (!NT_SUCCESS (RtlAddAccessAllowedAce (dacl, ACL_REVISION, GENERIC_ALL,\n\t\t\t\t\t   usersid)))\n    goto out;\n  if (!NT_SUCCESS (RtlAddAccessAllowedAce (dacl, ACL_REVISION, GENERIC_ALL,\n\t\t\t\t\t   well_known_admins_sid)))\n    goto out;\n  if (!NT_SUCCESS (RtlAddAccessAllowedAce (dacl, ACL_REVISION, GENERIC_ALL,\n\t\t\t\t\t   well_known_system_sid)))\n    goto out;\n\n  /* Evaluate authinf size and allocate authinf. */\n  authinf_size = (authinf->data - (PBYTE) authinf);\n  authinf_size += RtlLengthSid (usersid);\t    /* User SID */\n  authinf_size += gsize;\t\t\t    /* Groups + Group SIDs */\n  /* When trying to define the admins group as primary group on Vista,\n     LsaLogonUser fails with error STATUS_INVALID_OWNER.  As workaround\n     we define \"Local\" as primary group here.  Seteuid32 sets the primary\n     group to the group set in /etc/passwd anyway. */\n  if (new_groups.pgsid == well_known_admins_sid)\n    pgrpsid = well_known_local_sid;\n  else\n    pgrpsid = new_groups.pgsid;\n\n  authinf_size += RtlLengthSid (pgrpsid);\t    /* Primary Group SID */\n\n  authinf_size += psize;\t\t\t    /* Privileges */\n  authinf_size += 0;\t\t\t\t    /* Owner SID */\n  authinf_size += dsize;\t\t\t    /* Default DACL */\n\n  authinf = (cyglsa_t *) alloca (authinf_size);\n  authinf->inf_size = authinf_size - ((PBYTE) &authinf->inf - (PBYTE) authinf);\n\n  authinf->magic = CYG_LSA_MAGIC;\n\n  if (!LookupAccountSidW (NULL, usersid, authinf->username, &ulen,\n\t\t\t  authinf->domain, &dlen, &use))\n    {\n      __seterrno ();\n      goto out;\n    }\n\n  /* Store stuff in authinf with offset relative to start of \"inf\" member,\n     instead of using pointers. */\n  offset = authinf->data - (PBYTE) &authinf->inf;\n\n  authinf->inf.ExpirationTime.LowPart = 0xffffffffL;\n  authinf->inf.ExpirationTime.HighPart = 0x7fffffffL;\n  /* User SID */\n  authinf->inf.User.User.Sid = offset;\n  authinf->inf.User.User.Attributes = 0;\n  RtlCopySid (RtlLengthSid (usersid), (PSID) ((PBYTE) &authinf->inf + offset),\n\t      usersid);\n  offset += RtlLengthSid (usersid);\n  /* Groups */\n  authinf->inf.Groups = offset;\n  gsids = (PCYG_TOKEN_GROUPS) ((PBYTE) &authinf->inf + offset);\n  sids_offset = offset + sizeof (ULONG) + non_well_known_cnt\n\t\t\t\t\t  * sizeof (SID_AND_ATTRIBUTES);\n  gsids->GroupCount = non_well_known_cnt;\n  /* Group SIDs */\n  tmpidx = -1;\n  for (int i = 0; i < non_well_known_cnt; ++i)\n    {\n      if ((tmpidx = tmp_gsids.next_non_well_known_sid (tmpidx)) < 0)\n\tbreak;\n      gsids->Groups[i].Sid = sids_offset;\n      gsids->Groups[i].Attributes = SE_GROUP_MANDATORY\n\t\t\t\t    | SE_GROUP_ENABLED_BY_DEFAULT\n\t\t\t\t    | SE_GROUP_ENABLED;\n      RtlCopySid (RtlLengthSid (tmp_gsids.sids[tmpidx]),\n\t\t  (PSID) ((PBYTE) &authinf->inf + sids_offset),\n\t\t  tmp_gsids.sids[tmpidx]);\n      sids_offset += RtlLengthSid (tmp_gsids.sids[tmpidx]);\n    }\n  offset += gsize;\n  /* Primary Group SID */\n  authinf->inf.PrimaryGroup.PrimaryGroup = offset;\n  RtlCopySid (RtlLengthSid (pgrpsid), (PSID) ((PBYTE) &authinf->inf + offset),\n\t      pgrpsid);\n  offset += RtlLengthSid (pgrpsid);\n  /* Privileges */\n  authinf->inf.Privileges = offset;\n  memcpy ((PBYTE) &authinf->inf + offset, privs, psize);\n  offset += psize;\n  /* Owner */\n  authinf->inf.Owner.Owner = 0;\n  /* Default DACL */\n  authinf->inf.DefaultDacl.DefaultDacl = offset;\n  memcpy ((PBYTE) &authinf->inf + offset, dacl, dsize);\n\n  authinf->checksum = CYG_LSA_MAGIC;\n  PDWORD csp;\n  PDWORD csp_end;\n  csp = (PDWORD) &authinf->username;\n  csp_end = (PDWORD) ((PBYTE) authinf + authinf_size);\n  while (csp < csp_end)\n    authinf->checksum += *csp++;\n\n  /* Try to logon... */\n  status = LsaLogonUser (lsa_hdl, (PLSA_STRING) &origin, Interactive,\n\t\t\t package_id, authinf, authinf_size, NULL, &ts,\n\t\t\t &profile, &size, &luid, &user_token, &quota,\n\t\t\t &sub_status);\n  if (status != STATUS_SUCCESS)\n    {\n      debug_printf (\"LsaLogonUser: %y (sub-status %y)\", status, sub_status);\n      __seterrno_from_nt_status (status);\n      goto out;\n    }\n  if (profile)\n    {\n#ifdef JUST_ANOTHER_NONWORKING_SOLUTION\n      /* See ../lsaauth/cyglsa.c. */\n      cygprf_t *prf = (cygprf_t *) profile;\n      if (prf->magic_pre == MAGIC_PRE && prf->magic_post == MAGIC_POST\n\t  && prf->token)\n\t{\n\t  CloseHandle (user_token);\n\t  user_token = prf->token;\n\t  system_printf (\"Got token through profile: %p\", user_token);\n\t}\n#endif /* JUST_ANOTHER_NONWORKING_SOLUTION */\n      LsaFreeReturnBuffer (profile);\n    }\n  user_token = get_full_privileged_inheritable_token (user_token);\n\nout:\n  if (privs)\n    free (privs);\n  lsa_close_policy (lsa);\n  if (lsa_hdl)\n    LsaDeregisterLogonProcess (lsa_hdl);\n  pop_self_privilege ();\n\n  debug_printf (\"%p = lsaauth ()\", user_token);\n  return user_token;\n}",
        "description": "Cygwin versions prior to 2.5.0 fail to correctly update permissions during user changes, enabling attackers to escalate their privileges.",
        "commit": "The vulnerability involves the creation of a security token without using the caller's credentials in the `sec_auth.cc` file. Specifically, the `get_token_group_sidlist`, `get_initgroups_sidlist`, and `get_setgroups_sidlist` functions have been modified to remove parameters related to authentication (`auth_luid` and `auth_pos`) and the code that adds a logon SID. The `create_token` function now explicitly sets the `auth_luid` to either `ANONYMOUS_LOGON_LUID` or `LOCALSERVICE_LUID` based on the operating system, and no longer handles the logon SID since it is no longer generated. Additionally, the `lsaauth` function has removed unused local variables `auth_luid` and `auth_pos`. A new element `has_broken_whoami` has been added to `wincap.h`, and implemented in `wincap.cc`. This change results in the creation of tokens without proper authentication context, potentially leading to unauthorized access or privilege escalation."
    },
    {
        "cwe": "CWE-704",
        "func_name": "torvalds/sctp_make_strreset_req",
        "score": 0.7988442182540894,
        "func_before": "struct sctp_chunk *sctp_make_strreset_req(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__u16 stream_num, __be16 *stream_list,\n\t\t\t\t\tbool out, bool in)\n{\n\t__u16 stream_len = stream_num * sizeof(__u16);\n\tstruct sctp_strreset_outreq outreq;\n\tstruct sctp_strreset_inreq inreq;\n\tstruct sctp_chunk *retval;\n\t__u16 outlen, inlen;\n\n\toutlen = (sizeof(outreq) + stream_len) * out;\n\tinlen = (sizeof(inreq) + stream_len) * in;\n\n\tretval = sctp_make_reconf(asoc, outlen + inlen);\n\tif (!retval)\n\t\treturn NULL;\n\n\tif (outlen) {\n\t\toutreq.param_hdr.type = SCTP_PARAM_RESET_OUT_REQUEST;\n\t\toutreq.param_hdr.length = htons(outlen);\n\t\toutreq.request_seq = htonl(asoc->strreset_outseq);\n\t\toutreq.response_seq = htonl(asoc->strreset_inseq - 1);\n\t\toutreq.send_reset_at_tsn = htonl(asoc->next_tsn - 1);\n\n\t\tsctp_addto_chunk(retval, sizeof(outreq), &outreq);\n\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\n\tif (inlen) {\n\t\tinreq.param_hdr.type = SCTP_PARAM_RESET_IN_REQUEST;\n\t\tinreq.param_hdr.length = htons(inlen);\n\t\tinreq.request_seq = htonl(asoc->strreset_outseq + out);\n\n\t\tsctp_addto_chunk(retval, sizeof(inreq), &inreq);\n\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\n\treturn retval;\n}",
        "func_after": "struct sctp_chunk *sctp_make_strreset_req(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__u16 stream_num, __be16 *stream_list,\n\t\t\t\t\tbool out, bool in)\n{\n\t__u16 stream_len = stream_num * sizeof(__u16);\n\tstruct sctp_strreset_outreq outreq;\n\tstruct sctp_strreset_inreq inreq;\n\tstruct sctp_chunk *retval;\n\t__u16 outlen, inlen;\n\n\toutlen = (sizeof(outreq) + stream_len) * out;\n\tinlen = (sizeof(inreq) + stream_len) * in;\n\n\tretval = sctp_make_reconf(asoc, SCTP_PAD4(outlen) + SCTP_PAD4(inlen));\n\tif (!retval)\n\t\treturn NULL;\n\n\tif (outlen) {\n\t\toutreq.param_hdr.type = SCTP_PARAM_RESET_OUT_REQUEST;\n\t\toutreq.param_hdr.length = htons(outlen);\n\t\toutreq.request_seq = htonl(asoc->strreset_outseq);\n\t\toutreq.response_seq = htonl(asoc->strreset_inseq - 1);\n\t\toutreq.send_reset_at_tsn = htonl(asoc->next_tsn - 1);\n\n\t\tsctp_addto_chunk(retval, sizeof(outreq), &outreq);\n\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\n\tif (inlen) {\n\t\tinreq.param_hdr.type = SCTP_PARAM_RESET_IN_REQUEST;\n\t\tinreq.param_hdr.length = htons(inlen);\n\t\tinreq.request_seq = htonl(asoc->strreset_outseq + out);\n\n\t\tsctp_addto_chunk(retval, sizeof(inreq), &inreq);\n\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\n\treturn retval;\n}",
        "description": "A flaw exists in the SCTP network protocol within the Linux kernel, where the `sctp_make_strreset_req` function may allocate insufficient buffer space. When an attempt is made to utilize more buffer than what has been allocated, it triggers a `BUG_ON` condition, resulting in a denial of service (DOS) for local users.",
        "commit": "The `sctp_make_strreset_req()` function repeatedly invokes `sctp_addto_chunk()`, which inherently accounts for padding with each call. Although `inreq` and `outreq` are already 4-byte aligned, the payload is not. The use of `SCTP_PAD4(a + b)` (implicitly done by `_sctp_make_chunk()`) differs from `SCTP_PAD4(a) + SCTP_PAD4(b)`, leading to insufficient padding calculation. This discrepancy potentially results in attempting to use more buffer space than allocated, triggering a `BUG_ON`."
    },
    {
        "cwe": "CWE-74",
        "func_name": "flatpak/flatpak_run_add_environment_args",
        "score": 0.7944835424423218,
        "func_before": "gboolean\nflatpak_run_add_environment_args (FlatpakBwrap    *bwrap,\n                                  const char      *app_info_path,\n                                  FlatpakRunFlags  flags,\n                                  const char      *app_id,\n                                  FlatpakContext  *context,\n                                  GFile           *app_id_dir,\n                                  GPtrArray       *previous_app_id_dirs,\n                                  FlatpakExports **exports_out,\n                                  GCancellable    *cancellable,\n                                  GError         **error)\n{\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autoptr(FlatpakBwrap) proxy_arg_bwrap = flatpak_bwrap_new (flatpak_bwrap_empty_env);\n  gboolean has_wayland = FALSE;\n  gboolean allow_x11 = FALSE;\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_IPC) == 0)\n    {\n      g_debug (\"Disallowing ipc access\");\n      flatpak_bwrap_add_args (bwrap, \"--unshare-ipc\", NULL);\n    }\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) == 0)\n    {\n      g_debug (\"Disallowing network access\");\n      flatpak_bwrap_add_args (bwrap, \"--unshare-net\", NULL);\n    }\n\n  if (context->devices & FLATPAK_CONTEXT_DEVICE_ALL)\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dev-bind\", \"/dev\", \"/dev\",\n                              NULL);\n      /* Don't expose the host /dev/shm, just the device nodes, unless explicitly allowed */\n      if (g_file_test (\"/dev/shm\", G_FILE_TEST_IS_DIR))\n        {\n          if ((context->devices & FLATPAK_CONTEXT_DEVICE_SHM) == 0)\n            flatpak_bwrap_add_args (bwrap,\n                                    \"--tmpfs\", \"/dev/shm\",\n                                    NULL);\n        }\n      else if (g_file_test (\"/dev/shm\", G_FILE_TEST_IS_SYMLINK))\n        {\n          g_autofree char *link = flatpak_readlink (\"/dev/shm\", NULL);\n\n          /* On debian (with sysv init) the host /dev/shm is a symlink to /run/shm, so we can't\n             mount on top of it. */\n          if (g_strcmp0 (link, \"/run/shm\") == 0)\n            {\n              if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM &&\n                  g_file_test (\"/run/shm\", G_FILE_TEST_IS_DIR))\n                flatpak_bwrap_add_args (bwrap,\n                                        \"--bind\", \"/run/shm\", \"/run/shm\",\n                                        NULL);\n              else\n                flatpak_bwrap_add_args (bwrap,\n                                        \"--dir\", \"/run/shm\",\n                                        NULL);\n            }\n          else\n            g_warning (\"Unexpected /dev/shm symlink %s\", link);\n        }\n    }\n  else\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dev\", \"/dev\",\n                              NULL);\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_DRI)\n        {\n          g_debug (\"Allowing dri access\");\n          int i;\n          char *dri_devices[] = {\n            \"/dev/dri\",\n            /* mali */\n            \"/dev/mali\",\n            \"/dev/mali0\",\n            \"/dev/umplock\",\n            /* nvidia */\n            \"/dev/nvidiactl\",\n            \"/dev/nvidia-modeset\",\n            /* nvidia OpenCL/CUDA */\n            \"/dev/nvidia-uvm\",\n            \"/dev/nvidia-uvm-tools\",\n          };\n\n          for (i = 0; i < G_N_ELEMENTS (dri_devices); i++)\n            {\n              if (g_file_test (dri_devices[i], G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \"--dev-bind\", dri_devices[i], dri_devices[i], NULL);\n            }\n\n          /* Each Nvidia card gets its own device.\n             This is a fairly arbitrary limit but ASUS sells mining boards supporting 20 in theory. */\n          char nvidia_dev[14]; /* /dev/nvidia plus up to 2 digits */\n          for (i = 0; i < 20; i++)\n            {\n              g_snprintf (nvidia_dev, sizeof (nvidia_dev), \"/dev/nvidia%d\", i);\n              if (g_file_test (nvidia_dev, G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \"--dev-bind\", nvidia_dev, nvidia_dev, NULL);\n            }\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_KVM)\n        {\n          g_debug (\"Allowing kvm access\");\n          if (g_file_test (\"/dev/kvm\", G_FILE_TEST_EXISTS))\n            flatpak_bwrap_add_args (bwrap, \"--dev-bind\", \"/dev/kvm\", \"/dev/kvm\", NULL);\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM)\n        {\n          /* This is a symlink to /run/shm on debian, so bind to real target */\n          g_autofree char *real_dev_shm = realpath (\"/dev/shm\", NULL);\n\n          g_debug (\"Allowing /dev/shm access (as %s)\", real_dev_shm);\n          if (real_dev_shm != NULL)\n              flatpak_bwrap_add_args (bwrap, \"--bind\", real_dev_shm, \"/dev/shm\", NULL);\n        }\n    }\n\n  flatpak_context_append_bwrap_filesystem (context, bwrap, app_id, app_id_dir, previous_app_id_dirs, &exports);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_WAYLAND)\n    {\n      g_debug (\"Allowing wayland access\");\n      has_wayland = flatpak_run_add_wayland_args (bwrap);\n    }\n\n  if ((context->sockets & FLATPAK_CONTEXT_SOCKET_FALLBACK_X11) != 0)\n    allow_x11 = !has_wayland;\n  else\n    allow_x11 = (context->sockets & FLATPAK_CONTEXT_SOCKET_X11) != 0;\n\n  flatpak_run_add_x11_args (bwrap, allow_x11);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_SSH_AUTH)\n    {\n      flatpak_run_add_ssh_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PULSEAUDIO)\n    {\n      g_debug (\"Allowing pulseaudio access\");\n      flatpak_run_add_pulseaudio_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PCSC)\n    {\n      flatpak_run_add_pcsc_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_CUPS)\n    {\n      flatpak_run_add_cups_args (bwrap);\n    }\n\n  flatpak_run_add_session_dbus_args (bwrap, proxy_arg_bwrap, context, flags, app_id);\n  flatpak_run_add_system_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n  flatpak_run_add_a11y_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n\n  if (g_environ_getenv (bwrap->envp, \"LD_LIBRARY_PATH\") != NULL)\n    {\n      /* LD_LIBRARY_PATH is overridden for setuid helper, so pass it as cmdline arg */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--setenv\", \"LD_LIBRARY_PATH\", g_environ_getenv (bwrap->envp, \"LD_LIBRARY_PATH\"),\n                              NULL);\n      flatpak_bwrap_unset_env (bwrap, \"LD_LIBRARY_PATH\");\n    }\n\n  if (g_environ_getenv (bwrap->envp, \"TMPDIR\") != NULL)\n    {\n      /* TMPDIR is overridden for setuid helper, so pass it as cmdline arg */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--setenv\", \"TMPDIR\", g_environ_getenv (bwrap->envp, \"TMPDIR\"),\n                              NULL);\n      flatpak_bwrap_unset_env (bwrap, \"TMPDIR\");\n    }\n\n  /* Must run this before spawning the dbus proxy, to ensure it\n     ends up in the app cgroup */\n  if (!flatpak_run_in_transient_unit (app_id, &my_error))\n    {\n      /* We still run along even if we don't get a cgroup, as nothing\n         really depends on it. Its just nice to have */\n      g_debug (\"Failed to run in transient scope: %s\", my_error->message);\n      g_clear_error (&my_error);\n    }\n\n  if (!flatpak_bwrap_is_empty (proxy_arg_bwrap) &&\n      !start_dbus_proxy (bwrap, proxy_arg_bwrap, app_info_path, error))\n    return FALSE;\n\n  if (exports_out)\n    *exports_out = g_steal_pointer (&exports);\n\n  return TRUE;\n}",
        "func_after": "gboolean\nflatpak_run_add_environment_args (FlatpakBwrap    *bwrap,\n                                  const char      *app_info_path,\n                                  FlatpakRunFlags  flags,\n                                  const char      *app_id,\n                                  FlatpakContext  *context,\n                                  GFile           *app_id_dir,\n                                  GPtrArray       *previous_app_id_dirs,\n                                  FlatpakExports **exports_out,\n                                  GCancellable    *cancellable,\n                                  GError         **error)\n{\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autoptr(FlatpakBwrap) proxy_arg_bwrap = flatpak_bwrap_new (flatpak_bwrap_empty_env);\n  gboolean has_wayland = FALSE;\n  gboolean allow_x11 = FALSE;\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_IPC) == 0)\n    {\n      g_debug (\"Disallowing ipc access\");\n      flatpak_bwrap_add_args (bwrap, \"--unshare-ipc\", NULL);\n    }\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) == 0)\n    {\n      g_debug (\"Disallowing network access\");\n      flatpak_bwrap_add_args (bwrap, \"--unshare-net\", NULL);\n    }\n\n  if (context->devices & FLATPAK_CONTEXT_DEVICE_ALL)\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dev-bind\", \"/dev\", \"/dev\",\n                              NULL);\n      /* Don't expose the host /dev/shm, just the device nodes, unless explicitly allowed */\n      if (g_file_test (\"/dev/shm\", G_FILE_TEST_IS_DIR))\n        {\n          if ((context->devices & FLATPAK_CONTEXT_DEVICE_SHM) == 0)\n            flatpak_bwrap_add_args (bwrap,\n                                    \"--tmpfs\", \"/dev/shm\",\n                                    NULL);\n        }\n      else if (g_file_test (\"/dev/shm\", G_FILE_TEST_IS_SYMLINK))\n        {\n          g_autofree char *link = flatpak_readlink (\"/dev/shm\", NULL);\n\n          /* On debian (with sysv init) the host /dev/shm is a symlink to /run/shm, so we can't\n             mount on top of it. */\n          if (g_strcmp0 (link, \"/run/shm\") == 0)\n            {\n              if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM &&\n                  g_file_test (\"/run/shm\", G_FILE_TEST_IS_DIR))\n                flatpak_bwrap_add_args (bwrap,\n                                        \"--bind\", \"/run/shm\", \"/run/shm\",\n                                        NULL);\n              else\n                flatpak_bwrap_add_args (bwrap,\n                                        \"--dir\", \"/run/shm\",\n                                        NULL);\n            }\n          else\n            g_warning (\"Unexpected /dev/shm symlink %s\", link);\n        }\n    }\n  else\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dev\", \"/dev\",\n                              NULL);\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_DRI)\n        {\n          g_debug (\"Allowing dri access\");\n          int i;\n          char *dri_devices[] = {\n            \"/dev/dri\",\n            /* mali */\n            \"/dev/mali\",\n            \"/dev/mali0\",\n            \"/dev/umplock\",\n            /* nvidia */\n            \"/dev/nvidiactl\",\n            \"/dev/nvidia-modeset\",\n            /* nvidia OpenCL/CUDA */\n            \"/dev/nvidia-uvm\",\n            \"/dev/nvidia-uvm-tools\",\n          };\n\n          for (i = 0; i < G_N_ELEMENTS (dri_devices); i++)\n            {\n              if (g_file_test (dri_devices[i], G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \"--dev-bind\", dri_devices[i], dri_devices[i], NULL);\n            }\n\n          /* Each Nvidia card gets its own device.\n             This is a fairly arbitrary limit but ASUS sells mining boards supporting 20 in theory. */\n          char nvidia_dev[14]; /* /dev/nvidia plus up to 2 digits */\n          for (i = 0; i < 20; i++)\n            {\n              g_snprintf (nvidia_dev, sizeof (nvidia_dev), \"/dev/nvidia%d\", i);\n              if (g_file_test (nvidia_dev, G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \"--dev-bind\", nvidia_dev, nvidia_dev, NULL);\n            }\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_KVM)\n        {\n          g_debug (\"Allowing kvm access\");\n          if (g_file_test (\"/dev/kvm\", G_FILE_TEST_EXISTS))\n            flatpak_bwrap_add_args (bwrap, \"--dev-bind\", \"/dev/kvm\", \"/dev/kvm\", NULL);\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM)\n        {\n          /* This is a symlink to /run/shm on debian, so bind to real target */\n          g_autofree char *real_dev_shm = realpath (\"/dev/shm\", NULL);\n\n          g_debug (\"Allowing /dev/shm access (as %s)\", real_dev_shm);\n          if (real_dev_shm != NULL)\n              flatpak_bwrap_add_args (bwrap, \"--bind\", real_dev_shm, \"/dev/shm\", NULL);\n        }\n    }\n\n  flatpak_context_append_bwrap_filesystem (context, bwrap, app_id, app_id_dir, previous_app_id_dirs, &exports);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_WAYLAND)\n    {\n      g_debug (\"Allowing wayland access\");\n      has_wayland = flatpak_run_add_wayland_args (bwrap);\n    }\n\n  if ((context->sockets & FLATPAK_CONTEXT_SOCKET_FALLBACK_X11) != 0)\n    allow_x11 = !has_wayland;\n  else\n    allow_x11 = (context->sockets & FLATPAK_CONTEXT_SOCKET_X11) != 0;\n\n  flatpak_run_add_x11_args (bwrap, allow_x11);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_SSH_AUTH)\n    {\n      flatpak_run_add_ssh_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PULSEAUDIO)\n    {\n      g_debug (\"Allowing pulseaudio access\");\n      flatpak_run_add_pulseaudio_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PCSC)\n    {\n      flatpak_run_add_pcsc_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_CUPS)\n    {\n      flatpak_run_add_cups_args (bwrap);\n    }\n\n  flatpak_run_add_session_dbus_args (bwrap, proxy_arg_bwrap, context, flags, app_id);\n  flatpak_run_add_system_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n  flatpak_run_add_a11y_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n\n  /* Must run this before spawning the dbus proxy, to ensure it\n     ends up in the app cgroup */\n  if (!flatpak_run_in_transient_unit (app_id, &my_error))\n    {\n      /* We still run along even if we don't get a cgroup, as nothing\n         really depends on it. Its just nice to have */\n      g_debug (\"Failed to run in transient scope: %s\", my_error->message);\n      g_clear_error (&my_error);\n    }\n\n  if (!flatpak_bwrap_is_empty (proxy_arg_bwrap) &&\n      !start_dbus_proxy (bwrap, proxy_arg_bwrap, app_info_path, error))\n    return FALSE;\n\n  if (exports_out)\n    *exports_out = g_steal_pointer (&exports);\n\n  return TRUE;\n}",
        "description": "A vulnerability was identified in the Flatpak portal service (`flatpak-portal`), allowing sandboxed applications to execute arbitrary code on the host system, effectively enabling a sandbox escape. This issue affects versions of Flatpak from 0.11.4 up to but not including fixed versions 1.8.5 and 1.10.0. The Flatpak portal service facilitates launching subprocesses within new sandbox instances, either with the same or more restrictive security settings compared to the calling application. Vulnerable versions pass caller-specified environment variables to non-sandboxed processes on the host system, particularly to the `flatpak run` command used for launching new sandbox instances. Malicious or compromised applications could exploit this by setting environment variables trusted by the `flatpak run` command, thereby executing arbitrary code outside the sandbox. As a temporary workaround, disabling the `flatpak-portal` service mitigates the vulnerability but may prevent many Flatpak applications from functioning correctly. This issue has been resolved in versions 1.8.5 and 1.10.0.",
        "commit": "The vulnerability involves converting all environment variables into arguments for `bwrap`, a tool used to create isolated execution environments. This conversion helps prevent certain environment variables from being filtered out by a setuid `bwrap`. Additionally, it ensures that even if these variables come from an untrusted source, they cannot be used to inject arbitrary code into a non-setuid `bwrap` through mechanisms like `LD_PRELOAD`. By bundling these variables into a `memfd` or temporary file, they are not included in `argv`, making them inaccessible to processes running under a different user ID. This measure is crucial for protecting sensitive information such as tokens or other secrets."
    },
    {
        "cwe": "CWE-1284",
        "func_name": "Samsung/crypto_bignum_allocate",
        "score": 0.7842175364494324,
        "func_before": "struct bignum *crypto_bignum_allocate(size_t size_bits)\n{\n\tsize_t sz = mpa_StaticVarSizeInU32(size_bits) *\tsizeof(uint32_t);\n\tstruct mpa_numbase_struct *bn = calloc(1, sz);\n\n\tif (!bn)\n\t\treturn NULL;\n\tbn->alloc = sz - MPA_NUMBASE_METADATA_SIZE_IN_U32 * sizeof(uint32_t);\n\treturn (struct bignum *)bn;\n}",
        "func_after": "struct bignum *crypto_bignum_allocate(size_t size_bits)\n{\n\tsize_t sz = mpa_StaticVarSizeInU32(size_bits) *\tsizeof(uint32_t);\n\t// struct mpa_numbase_struct *bn = calloc(1, sz);\n\tstruct mpa_numbase_struct *bn= TEE_Malloc(sz, TEE_MALLOC_FILL_ZERO);\n\tif (!bn)\n\t\treturn NULL;\n\tbn->alloc = sz - MPA_NUMBASE_METADATA_SIZE_IN_U32 * sizeof(uint32_t);\n\treturn (struct bignum *)bn;\n}",
        "description": "The function `tee_obj_free` in Samsung mTower through version 0.3.0 enables a trusted application to cause a Denial of Service (DoS) by calling the function `TEE_AllocateOperation` with a disrupted heap layout, which is associated with `utee_cryp_obj_alloc`.",
        "commit": "A vulnerability has been addressed in a software system, specifically identified by CVE-2022-40761."
    }
]