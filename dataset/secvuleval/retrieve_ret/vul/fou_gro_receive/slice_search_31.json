[
    {
        "cwe": "CWE-754",
        "func_name": "torvalds/copy_params",
        "score": 0.810295581817627,
        "func_before": "static int copy_params(struct dm_ioctl __user *user, struct dm_ioctl *param_kernel,\n\t\t       int ioctl_flags, struct dm_ioctl **param, int *param_flags)\n{\n\tstruct dm_ioctl *dmi;\n\tint secure_data;\n\tconst size_t minimum_data_size = offsetof(struct dm_ioctl, data);\n\n\t/* check_version() already copied version from userspace, avoid TOCTOU */\n\tif (copy_from_user((char *)param_kernel + sizeof(param_kernel->version),\n\t\t\t   (char __user *)user + sizeof(param_kernel->version),\n\t\t\t   minimum_data_size - sizeof(param_kernel->version)))\n\t\treturn -EFAULT;\n\n\tif (param_kernel->data_size < minimum_data_size) {\n\t\tDMERR(\"Invalid data size in the ioctl structure: %u\",\n\t\t      param_kernel->data_size);\n\t\treturn -EINVAL;\n\t}\n\n\tsecure_data = param_kernel->flags & DM_SECURE_DATA_FLAG;\n\n\t*param_flags = secure_data ? DM_WIPE_BUFFER : 0;\n\n\tif (ioctl_flags & IOCTL_FLAGS_NO_PARAMS) {\n\t\tdmi = param_kernel;\n\t\tdmi->data_size = minimum_data_size;\n\t\tgoto data_copied;\n\t}\n\n\t/*\n\t * Use __GFP_HIGH to avoid low memory issues when a device is\n\t * suspended and the ioctl is needed to resume it.\n\t * Use kmalloc() rather than vmalloc() when we can.\n\t */\n\tdmi = NULL;\n\tdmi = kvmalloc(param_kernel->data_size, GFP_NOIO | __GFP_HIGH);\n\n\tif (!dmi) {\n\t\tif (secure_data && clear_user(user, param_kernel->data_size))\n\t\t\treturn -EFAULT;\n\t\treturn -ENOMEM;\n\t}\n\n\t*param_flags |= DM_PARAMS_MALLOC;\n\n\t/* Copy from param_kernel (which was already copied from user) */\n\tmemcpy(dmi, param_kernel, minimum_data_size);\n\n\tif (copy_from_user(&dmi->data, (char __user *)user + minimum_data_size,\n\t\t\t   param_kernel->data_size - minimum_data_size))\n\t\tgoto bad;\ndata_copied:\n\t/* Wipe the user buffer so we do not return it to userspace */\n\tif (secure_data && clear_user(user, param_kernel->data_size))\n\t\tgoto bad;\n\n\t*param = dmi;\n\treturn 0;\n\nbad:\n\tfree_params(dmi, param_kernel->data_size, *param_flags);\n\n\treturn -EFAULT;\n}",
        "func_after": "static int copy_params(struct dm_ioctl __user *user, struct dm_ioctl *param_kernel,\n\t\t       int ioctl_flags, struct dm_ioctl **param, int *param_flags)\n{\n\tstruct dm_ioctl *dmi;\n\tint secure_data;\n\tconst size_t minimum_data_size = offsetof(struct dm_ioctl, data);\n\n\t/* check_version() already copied version from userspace, avoid TOCTOU */\n\tif (copy_from_user((char *)param_kernel + sizeof(param_kernel->version),\n\t\t\t   (char __user *)user + sizeof(param_kernel->version),\n\t\t\t   minimum_data_size - sizeof(param_kernel->version)))\n\t\treturn -EFAULT;\n\n\tif (unlikely(param_kernel->data_size < minimum_data_size) ||\n\t    unlikely(param_kernel->data_size > DM_MAX_TARGETS * DM_MAX_TARGET_PARAMS)) {\n\t\tDMERR(\"Invalid data size in the ioctl structure: %u\",\n\t\t      param_kernel->data_size);\n\t\treturn -EINVAL;\n\t}\n\n\tsecure_data = param_kernel->flags & DM_SECURE_DATA_FLAG;\n\n\t*param_flags = secure_data ? DM_WIPE_BUFFER : 0;\n\n\tif (ioctl_flags & IOCTL_FLAGS_NO_PARAMS) {\n\t\tdmi = param_kernel;\n\t\tdmi->data_size = minimum_data_size;\n\t\tgoto data_copied;\n\t}\n\n\t/*\n\t * Use __GFP_HIGH to avoid low memory issues when a device is\n\t * suspended and the ioctl is needed to resume it.\n\t * Use kmalloc() rather than vmalloc() when we can.\n\t */\n\tdmi = NULL;\n\tdmi = kvmalloc(param_kernel->data_size, GFP_NOIO | __GFP_HIGH);\n\n\tif (!dmi) {\n\t\tif (secure_data && clear_user(user, param_kernel->data_size))\n\t\t\treturn -EFAULT;\n\t\treturn -ENOMEM;\n\t}\n\n\t*param_flags |= DM_PARAMS_MALLOC;\n\n\t/* Copy from param_kernel (which was already copied from user) */\n\tmemcpy(dmi, param_kernel, minimum_data_size);\n\n\tif (copy_from_user(&dmi->data, (char __user *)user + minimum_data_size,\n\t\t\t   param_kernel->data_size - minimum_data_size))\n\t\tgoto bad;\ndata_copied:\n\t/* Wipe the user buffer so we do not return it to userspace */\n\tif (secure_data && clear_user(user, param_kernel->data_size))\n\t\tgoto bad;\n\n\t*param = dmi;\n\treturn 0;\n\nbad:\n\tfree_params(dmi, param_kernel->data_size, *param_flags);\n\n\treturn -EFAULT;\n}",
        "description": "The `dm_table_create` function in the device mapper module of the Linux kernel, up to version 6.7.4, may allocate more than `INT_MAX` bytes during the `alloc_targets` process due to a lack of validation for the `struct dm_ioctl.target_count`. This oversight can lead to a system crash.",
        "commit": "The `kvmalloc` function generates a warning when the requested size exceeds `INT_MAX`. This issue was identified during automated syscall testing. To prevent such warnings, the commit imposes a limit of 1,048,576 targets and restricts the parameter area size to 1,073,741,824 bytes."
    },
    {
        "cwe": "CWE-772",
        "func_name": "binutils-gdb/display_rel_file",
        "score": 0.8076079487800598,
        "func_before": "static void\ndisplay_rel_file (bfd *abfd, bfd *archive_bfd)\n{\n  long symcount;\n  void *minisyms;\n  unsigned int size;\n  struct size_sym *symsizes;\n  asymbol *synthsyms = NULL;\n\n  if (! dynamic)\n    {\n      if (!(bfd_get_file_flags (abfd) & HAS_SYMS))\n\t{\n\t  non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n\t  return;\n\t}\n    }\n\n  symcount = bfd_read_minisymbols (abfd, dynamic, &minisyms, &size);\n  if (symcount < 0)\n    {\n      if (dynamic && bfd_get_error () == bfd_error_no_symbols)\n\t{\n\t  non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n\t  return;\n\t}\n\n      bfd_fatal (bfd_get_filename (abfd));\n    }\n\n  if (symcount == 0)\n    {\n      non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n      return;\n    }\n\n  if (show_synthetic && size == sizeof (asymbol *))\n    {\n      asymbol **static_syms = NULL;\n      asymbol **dyn_syms = NULL;\n      long static_count = 0;\n      long dyn_count = 0;\n      long synth_count;\n\n      if (dynamic)\n\t{\n\t  dyn_count = symcount;\n\t  dyn_syms = (asymbol **) minisyms;\n\t}\n      else\n\t{\n\t  long storage = bfd_get_dynamic_symtab_upper_bound (abfd);\n\n\t  static_count = symcount;\n\t  static_syms = (asymbol **) minisyms;\n\n\t  if (storage > 0)\n\t    {\n\t      dyn_syms = (asymbol **) xmalloc (storage);\n\t      dyn_count = bfd_canonicalize_dynamic_symtab (abfd, dyn_syms);\n\t      if (dyn_count < 0)\n\t\tbfd_fatal (bfd_get_filename (abfd));\n\t    }\n\t}\n\n      synth_count = bfd_get_synthetic_symtab (abfd, static_count, static_syms,\n\t\t\t\t\t      dyn_count, dyn_syms, &synthsyms);\n      if (synth_count > 0)\n\t{\n\t  asymbol **symp;\n\t  void *new_mini;\n\t  long i;\n\n\t  new_mini = xmalloc ((symcount + synth_count + 1) * sizeof (*symp));\n\t  symp = (asymbol **) new_mini;\n\t  memcpy (symp, minisyms, symcount * sizeof (*symp));\n\t  symp += symcount;\n\t  for (i = 0; i < synth_count; i++)\n\t    *symp++ = synthsyms + i;\n\t  *symp = 0;\n\t  minisyms = new_mini;\n\t  symcount += synth_count;\n\t}\n    }\n\n  /* Discard the symbols we don't want to print.\n     It's OK to do this in place; we'll free the storage anyway\n     (after printing).  */\n\n  symcount = filter_symbols (abfd, dynamic, minisyms, symcount, size);\n\n  symsizes = NULL;\n  if (! no_sort)\n    {\n      sort_bfd = abfd;\n      sort_dynamic = dynamic;\n      sort_x = bfd_make_empty_symbol (abfd);\n      sort_y = bfd_make_empty_symbol (abfd);\n      if (sort_x == NULL || sort_y == NULL)\n\tbfd_fatal (bfd_get_filename (abfd));\n\n      if (! sort_by_size)\n\tqsort (minisyms, symcount, size,\n\t       sorters[sort_numerically][reverse_sort]);\n      else\n\tsymcount = sort_symbols_by_size (abfd, dynamic, minisyms, symcount,\n\t\t\t\t\t size, &symsizes);\n    }\n\n  if (! sort_by_size)\n    print_symbols (abfd, dynamic, minisyms, symcount, size, archive_bfd);\n  else\n    print_size_symbols (abfd, dynamic, symsizes, symcount, archive_bfd);\n\n  if (synthsyms)\n    free (synthsyms);\n  free (minisyms);\n  free (symsizes);\n}",
        "func_after": "static void\ndisplay_rel_file (bfd *abfd, bfd *archive_bfd)\n{\n  long symcount;\n  void *minisyms;\n  unsigned int size;\n  struct size_sym *symsizes;\n  asymbol *synthsyms = NULL;\n\n  if (! dynamic)\n    {\n      if (!(bfd_get_file_flags (abfd) & HAS_SYMS))\n\t{\n\t  non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n\t  return;\n\t}\n    }\n\n  symcount = bfd_read_minisymbols (abfd, dynamic, &minisyms, &size);\n  if (symcount < 0)\n    {\n      if (dynamic && bfd_get_error () == bfd_error_no_symbols)\n\t{\n\t  non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n\t  return;\n\t}\n\n      bfd_fatal (bfd_get_filename (abfd));\n    }\n\n  if (symcount == 0)\n    {\n      non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n      return;\n    }\n\n  if (show_synthetic && size == sizeof (asymbol *))\n    {\n      asymbol **static_syms = NULL;\n      asymbol **dyn_syms = NULL;\n      long static_count = 0;\n      long dyn_count = 0;\n      long synth_count;\n\n      if (dynamic)\n\t{\n\t  dyn_count = symcount;\n\t  dyn_syms = (asymbol **) minisyms;\n\t}\n      else\n\t{\n\t  long storage = bfd_get_dynamic_symtab_upper_bound (abfd);\n\n\t  static_count = symcount;\n\t  static_syms = (asymbol **) minisyms;\n\n\t  if (storage > 0)\n\t    {\n\t      dyn_syms = (asymbol **) xmalloc (storage);\n\t      dyn_count = bfd_canonicalize_dynamic_symtab (abfd, dyn_syms);\n\t      if (dyn_count < 0)\n\t\tbfd_fatal (bfd_get_filename (abfd));\n\t    }\n\t}\n\n      synth_count = bfd_get_synthetic_symtab (abfd, static_count, static_syms,\n\t\t\t\t\t      dyn_count, dyn_syms, &synthsyms);\n      if (synth_count > 0)\n\t{\n\t  asymbol **symp;\n\t  long i;\n\n\t  minisyms = xrealloc (minisyms,\n\t\t\t       (symcount + synth_count + 1) * sizeof (*symp));\n\t  symp = (asymbol **) minisyms + symcount;\n\t  for (i = 0; i < synth_count; i++)\n\t    *symp++ = synthsyms + i;\n\t  *symp = 0;\n\t  symcount += synth_count;\n\t}\n    }\n\n  /* Discard the symbols we don't want to print.\n     It's OK to do this in place; we'll free the storage anyway\n     (after printing).  */\n\n  symcount = filter_symbols (abfd, dynamic, minisyms, symcount, size);\n\n  symsizes = NULL;\n  if (! no_sort)\n    {\n      sort_bfd = abfd;\n      sort_dynamic = dynamic;\n      sort_x = bfd_make_empty_symbol (abfd);\n      sort_y = bfd_make_empty_symbol (abfd);\n      if (sort_x == NULL || sort_y == NULL)\n\tbfd_fatal (bfd_get_filename (abfd));\n\n      if (! sort_by_size)\n\tqsort (minisyms, symcount, size,\n\t       sorters[sort_numerically][reverse_sort]);\n      else\n\tsymcount = sort_symbols_by_size (abfd, dynamic, minisyms, symcount,\n\t\t\t\t\t size, &symsizes);\n    }\n\n  if (! sort_by_size)\n    print_symbols (abfd, dynamic, minisyms, symcount, size, archive_bfd);\n  else\n    print_size_symbols (abfd, dynamic, symsizes, symcount, archive_bfd);\n\n  if (synthsyms)\n    free (synthsyms);\n  free (minisyms);\n  free (symsizes);\n}",
        "description": "The `_bfd_generic_read_minisymbols` function in the BFD library, part of GNU Binutils 2.31, suffers from a memory leak when processing a specially crafted ELF file. This flaw results in excessive memory consumption, potentially leading to a denial of service.",
        "commit": "A memory leak was identified in the `_bfd_generic_read_minisymbols` function within the BFD library. The issue arises when the function fails to free allocated memory (`syms`) before returning with a zero symbol count. Additionally, in the `nm.c` file, the `display_rel_file` function uses `xrealloc` to increase the size of `minisyms` for synthetic symbols, indicating potential issues with memory management in these areas."
    },
    {
        "cwe": "CWE-400",
        "func_name": "Exiv2/ProcessUTF8Portion",
        "score": 0.7983296513557434,
        "func_before": "static size_t\nProcessUTF8Portion ( XMLParserAdapter * xmlParser,\n\t\t\t\t\t const XMP_Uns8 *   buffer,\n\t\t\t\t\t size_t\t\t\t\tlength,\n\t\t\t\t\t bool\t\t\t\tlast )\n{\n\tconst XMP_Uns8 * bufEnd = buffer + length;\n\t\n\tconst XMP_Uns8 * spanStart = buffer;\n\tconst XMP_Uns8 * spanEnd;\n\t\t\n\tfor ( spanEnd = spanStart; spanEnd < bufEnd; ++spanEnd ) {\n\n\t\tif ( (0x20 <= *spanEnd) && (*spanEnd <= 0x7E) && (*spanEnd != '&') ) continue;\t// A regular ASCII character.\n\n\t\tif ( *spanEnd >= 0x80 ) {\n\t\t\n\t\t\t// See if this is a multi-byte UTF-8 sequence, or a Latin-1 character to replace.\n\n\t\t\tint uniLen = CountUTF8 ( spanEnd, bufEnd );\n\n\t\t\tif ( uniLen > 0 ) {\n\n\t\t\t\t// A valid UTF-8 character, keep it as-is.\n\t\t\t\tspanEnd += uniLen - 1;\t// ! The loop increment will put back the +1.\n\n\t\t\t} else if ( (uniLen < 0) && (! last) ) {\n\n\t\t\t\t// Have a partial UTF-8 character at the end of the buffer and more input coming.\n\t\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n\t\t\t\treturn (spanEnd - buffer);\n\n\t\t\t} else {\n\n\t\t\t\t// Not a valid UTF-8 sequence. Replace the first byte with the Latin-1 equivalent.\n\t\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n\t\t\t\tconst char * replacement = kReplaceLatin1 [ *spanEnd - 0x80 ];\n\t\t\t\txmlParser->ParseBuffer ( replacement, strlen ( replacement ), false );\n\t\t\t\tspanStart = spanEnd + 1;\t// ! The loop increment will do \"spanEnd = spanStart\".\n\n\t\t\t}\n\t\t\n\t\t} else if ( (*spanEnd < 0x20) || (*spanEnd == 0x7F) ) {\n\n\t\t\t// Replace ASCII controls other than tab, LF, and CR with a space.\n\n\t\t\tif ( (*spanEnd == kTab) || (*spanEnd == kLF) || (*spanEnd == kCR) ) continue;\n\n\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n\t\t\txmlParser->ParseBuffer ( \" \", 1, false );\n\t\t\tspanStart = spanEnd + 1;\t// ! The loop increment will do \"spanEnd = spanStart\".\n\t\t\n\t\t} else {\n\t\t\n\t\t\t// See if this is a numeric escape sequence for a prohibited ASCII control.\n\t\t\t\n\t\t\tXMP_Assert ( *spanEnd == '&' );\n\t\t\tint escLen = CountControlEscape ( spanEnd, bufEnd );\n\t\t\t\n\t\t\tif ( escLen < 0 ) {\n\n\t\t\t\t// Have a partial numeric escape in this buffer, wait for more input.\n\t\t\t\tif ( last ) continue;\t// No more buffers, not an escape, absorb as normal input.\n\t\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n\t\t\t\treturn (spanEnd - buffer);\n\n\t\t\t} else if ( escLen > 0 ) {\n\n\t\t\t\t// Have a complete numeric escape to replace.\n\t\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n\t\t\t\txmlParser->ParseBuffer ( \" \", 1, false );\n\t\t\t\tspanStart = spanEnd + escLen;\n\t\t\t\tspanEnd = spanStart - 1;\t// ! The loop continuation will increment spanEnd!\n\n\t\t\t}\n\n\t\t}\n\t\t\n\t}\n\t\n\tXMP_Assert ( spanEnd == bufEnd );\n\n\tif ( spanStart < bufEnd ) xmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n\tif ( last ) xmlParser->ParseBuffer ( \" \", 1, true );\n\t\n\treturn length;\n\n}",
        "func_after": "static size_t\nProcessUTF8Portion ( XMLParserAdapter * xmlParser,\n\t\t\t\t\t const XMP_Uns8 *   buffer,\n\t\t\t\t\t size_t\t\t\t\tlength,\n\t\t\t\t\t bool\t\t\t\tlast )\n{\n\tconst XMP_Uns8 * bufEnd = buffer + length;\n\t\n\tconst XMP_Uns8 * spanEnd;\n\n\t// `buffer` is copied into this std::string. If `buffer` only\n\t// contains valid UTF-8 and no escape characters, then the copy\n\t// will be identical to the original, but invalid characters are\n\t// replaced - usually with a space character.  This std::string was\n\t// added as a performance fix for:\n\t// https://github.com/Exiv2/exiv2/security/advisories/GHSA-w8mv-g8qq-36mj\n\t// Previously, the code was repeatedly calling\n\t// `xmlParser->ParseBuffer()`, which turned out to have quadratic\n\t// complexity, because expat kept reparsing the entire string from\n\t// the beginning.\n\tstd::string copy;\n\t\t\n\tfor ( spanEnd = buffer; spanEnd < bufEnd; ++spanEnd ) {\n\n\t\tif ( (0x20 <= *spanEnd) && (*spanEnd <= 0x7E) && (*spanEnd != '&') ) {\n\t\t\tcopy.push_back(*spanEnd);\n\t\t\tcontinue;\t// A regular ASCII character.\n\t\t}\n\n\t\tif ( *spanEnd >= 0x80 ) {\n\t\t\n\t\t\t// See if this is a multi-byte UTF-8 sequence, or a Latin-1 character to replace.\n\n\t\t\tint uniLen = CountUTF8 ( spanEnd, bufEnd );\n\n\t\t\tif ( uniLen > 0 ) {\n\n\t\t\t\t// A valid UTF-8 character, keep it as-is.\n\t\t\t\tcopy.append((const char*)spanEnd, uniLen);\n\t\t\t\tspanEnd += uniLen - 1;\t// ! The loop increment will put back the +1.\n\n\t\t\t} else if ( (uniLen < 0) && (! last) ) {\n\n\t\t\t\t// Have a partial UTF-8 character at the end of the buffer and more input coming.\n\t\t\t\txmlParser->ParseBuffer ( copy.c_str(), copy.size(), false );\n\t\t\t\treturn (spanEnd - buffer);\n\n\t\t\t} else {\n\n\t\t\t\t// Not a valid UTF-8 sequence. Replace the first byte with the Latin-1 equivalent.\n\t\t\t\tconst char * replacement = kReplaceLatin1 [ *spanEnd - 0x80 ];\n\t\t\t\tcopy.append ( replacement );\n\n\t\t\t}\n\t\t\n\t\t} else if ( (*spanEnd < 0x20) || (*spanEnd == 0x7F) ) {\n\n\t\t\t// Replace ASCII controls other than tab, LF, and CR with a space.\n\n\t\t\tif ( (*spanEnd == kTab) || (*spanEnd == kLF) || (*spanEnd == kCR) ) {\n\t\t\t\tcopy.push_back(*spanEnd);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcopy.push_back(' ');\n\t\t\n\t\t} else {\n\t\t\n\t\t\t// See if this is a numeric escape sequence for a prohibited ASCII control.\n\t\t\t\n\t\t\tXMP_Assert ( *spanEnd == '&' );\n\t\t\tint escLen = CountControlEscape ( spanEnd, bufEnd );\n\t\t\t\n\t\t\tif ( escLen < 0 ) {\n\n\t\t\t\t// Have a partial numeric escape in this buffer, wait for more input.\n\t\t\t\tif ( last ) {\n\t\t\t\t\tcopy.push_back('&');\n\t\t\t\t\tcontinue;\t// No more buffers, not an escape, absorb as normal input.\n\t\t\t\t}\n\t\t\t\txmlParser->ParseBuffer ( copy.c_str(), copy.size(), false );\n\t\t\t\treturn (spanEnd - buffer);\n\n\t\t\t} else if ( escLen > 0 ) {\n\n\t\t\t\t// Have a complete numeric escape to replace.\n\t\t\t\tcopy.push_back(' ');\n\t\t\t\tspanEnd = spanEnd + escLen - 1;\t// ! The loop continuation will increment spanEnd!\n\n\t\t\t} else {\n\t\t\t\tcopy.push_back('&');\n\t\t\t}\n\n\t\t}\n\t\t\n\t}\n\t\n\tXMP_Assert ( spanEnd == bufEnd );\n\tcopy.push_back(' ');\n\txmlParser->ParseBuffer ( copy.c_str(), copy.size(), true );\n\treturn length;\n\n}",
        "description": "An inefficient algorithm with quadratic complexity was identified in Exiv2 versions up to v0.27.3. This algorithm is activated when Exiv2 writes metadata to a specially crafted image file. An attacker could exploit this vulnerability to cause a denial of service by convincing a victim to run Exiv2 on such an image file. The issue has been resolved in version v0.27.4. It's important to note that this vulnerability primarily affects the less commonly used metadata writing operation compared to the more frequent reading operation.",
        "commit": "output: \"A performance bug characterized by quadratic complexity has been addressed.\""
    },
    {
        "cwe": "CWE-770",
        "func_name": "binutils-gdb/_bfd_elf_slurp_version_tables",
        "score": 0.8023866415023804,
        "func_before": "bfd_boolean\n_bfd_elf_slurp_version_tables (bfd *abfd, bfd_boolean default_imported_symver)\n{\n  bfd_byte *contents = NULL;\n  unsigned int freeidx = 0;\n\n  if (elf_dynverref (abfd) != 0)\n    {\n      Elf_Internal_Shdr *hdr;\n      Elf_External_Verneed *everneed;\n      Elf_Internal_Verneed *iverneed;\n      unsigned int i;\n      bfd_byte *contents_end;\n\n      hdr = &elf_tdata (abfd)->dynverref_hdr;\n\n      if (hdr->sh_info == 0 || hdr->sh_size < sizeof (Elf_External_Verneed))\n\t{\nerror_return_bad_verref:\n\t  _bfd_error_handler\n\t    (_(\"%B: .gnu.version_r invalid entry\"), abfd);\n\t  bfd_set_error (bfd_error_bad_value);\nerror_return_verref:\n\t  elf_tdata (abfd)->verref = NULL;\n\t  elf_tdata (abfd)->cverrefs = 0;\n\t  goto error_return;\n\t}\n\n      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);\n      if (contents == NULL)\n\tgoto error_return_verref;\n\n      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n\t  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)\n\tgoto error_return_verref;\n\n      elf_tdata (abfd)->verref = (Elf_Internal_Verneed *)\n\tbfd_zalloc2 (abfd, hdr->sh_info, sizeof (Elf_Internal_Verneed));\n\n      if (elf_tdata (abfd)->verref == NULL)\n\tgoto error_return_verref;\n\n      BFD_ASSERT (sizeof (Elf_External_Verneed)\n\t\t  == sizeof (Elf_External_Vernaux));\n      contents_end = contents + hdr->sh_size - sizeof (Elf_External_Verneed);\n      everneed = (Elf_External_Verneed *) contents;\n      iverneed = elf_tdata (abfd)->verref;\n      for (i = 0; i < hdr->sh_info; i++, iverneed++)\n\t{\n\t  Elf_External_Vernaux *evernaux;\n\t  Elf_Internal_Vernaux *ivernaux;\n\t  unsigned int j;\n\n\t  _bfd_elf_swap_verneed_in (abfd, everneed, iverneed);\n\n\t  iverneed->vn_bfd = abfd;\n\n\t  iverneed->vn_filename =\n\t    bfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t     iverneed->vn_file);\n\t  if (iverneed->vn_filename == NULL)\n\t    goto error_return_bad_verref;\n\n\t  if (iverneed->vn_cnt == 0)\n\t    iverneed->vn_auxptr = NULL;\n\t  else\n\t    {\n\t      iverneed->vn_auxptr = (struct elf_internal_vernaux *)\n                  bfd_alloc2 (abfd, iverneed->vn_cnt,\n                              sizeof (Elf_Internal_Vernaux));\n\t      if (iverneed->vn_auxptr == NULL)\n\t\tgoto error_return_verref;\n\t    }\n\n\t  if (iverneed->vn_aux\n\t      > (size_t) (contents_end - (bfd_byte *) everneed))\n\t    goto error_return_bad_verref;\n\n\t  evernaux = ((Elf_External_Vernaux *)\n\t\t      ((bfd_byte *) everneed + iverneed->vn_aux));\n\t  ivernaux = iverneed->vn_auxptr;\n\t  for (j = 0; j < iverneed->vn_cnt; j++, ivernaux++)\n\t    {\n\t      _bfd_elf_swap_vernaux_in (abfd, evernaux, ivernaux);\n\n\t      ivernaux->vna_nodename =\n\t\tbfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t\t ivernaux->vna_name);\n\t      if (ivernaux->vna_nodename == NULL)\n\t\tgoto error_return_bad_verref;\n\n\t      if (ivernaux->vna_other > freeidx)\n\t\tfreeidx = ivernaux->vna_other;\n\n\t      ivernaux->vna_nextptr = NULL;\n\t      if (ivernaux->vna_next == 0)\n\t\t{\n\t\t  iverneed->vn_cnt = j + 1;\n\t\t  break;\n\t\t}\n\t      if (j + 1 < iverneed->vn_cnt)\n\t\tivernaux->vna_nextptr = ivernaux + 1;\n\n\t      if (ivernaux->vna_next\n\t\t  > (size_t) (contents_end - (bfd_byte *) evernaux))\n\t\tgoto error_return_bad_verref;\n\n\t      evernaux = ((Elf_External_Vernaux *)\n\t\t\t  ((bfd_byte *) evernaux + ivernaux->vna_next));\n\t    }\n\n\t  iverneed->vn_nextref = NULL;\n\t  if (iverneed->vn_next == 0)\n\t    break;\n\t  if (i + 1 < hdr->sh_info)\n\t    iverneed->vn_nextref = iverneed + 1;\n\n\t  if (iverneed->vn_next\n\t      > (size_t) (contents_end - (bfd_byte *) everneed))\n\t    goto error_return_bad_verref;\n\n\t  everneed = ((Elf_External_Verneed *)\n\t\t      ((bfd_byte *) everneed + iverneed->vn_next));\n\t}\n      elf_tdata (abfd)->cverrefs = i;\n\n      free (contents);\n      contents = NULL;\n    }\n\n  if (elf_dynverdef (abfd) != 0)\n    {\n      Elf_Internal_Shdr *hdr;\n      Elf_External_Verdef *everdef;\n      Elf_Internal_Verdef *iverdef;\n      Elf_Internal_Verdef *iverdefarr;\n      Elf_Internal_Verdef iverdefmem;\n      unsigned int i;\n      unsigned int maxidx;\n      bfd_byte *contents_end_def, *contents_end_aux;\n\n      hdr = &elf_tdata (abfd)->dynverdef_hdr;\n\n      if (hdr->sh_info == 0 || hdr->sh_size < sizeof (Elf_External_Verdef))\n\t{\n\terror_return_bad_verdef:\n\t  _bfd_error_handler\n\t    (_(\"%B: .gnu.version_d invalid entry\"), abfd);\n\t  bfd_set_error (bfd_error_bad_value);\n\terror_return_verdef:\n\t  elf_tdata (abfd)->verdef = NULL;\n\t  elf_tdata (abfd)->cverdefs = 0;\n\t  goto error_return;\n\t}\n\n      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);\n      if (contents == NULL)\n\tgoto error_return_verdef;\n      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n\t  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)\n\tgoto error_return_verdef;\n\n      BFD_ASSERT (sizeof (Elf_External_Verdef)\n\t\t  >= sizeof (Elf_External_Verdaux));\n      contents_end_def = contents + hdr->sh_size\n\t\t\t - sizeof (Elf_External_Verdef);\n      contents_end_aux = contents + hdr->sh_size\n\t\t\t - sizeof (Elf_External_Verdaux);\n\n      /* We know the number of entries in the section but not the maximum\n\t index.  Therefore we have to run through all entries and find\n\t the maximum.  */\n      everdef = (Elf_External_Verdef *) contents;\n      maxidx = 0;\n      for (i = 0; i < hdr->sh_info; ++i)\n\t{\n\t  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);\n\n\t  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) == 0)\n\t    goto error_return_bad_verdef;\n\t  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) > maxidx)\n\t    maxidx = iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION);\n\n\t  if (iverdefmem.vd_next == 0)\n\t    break;\n\n\t  if (iverdefmem.vd_next\n\t      > (size_t) (contents_end_def - (bfd_byte *) everdef))\n\t    goto error_return_bad_verdef;\n\n\t  everdef = ((Elf_External_Verdef *)\n\t\t     ((bfd_byte *) everdef + iverdefmem.vd_next));\n\t}\n\n      if (default_imported_symver)\n\t{\n\t  if (freeidx > maxidx)\n\t    maxidx = ++freeidx;\n\t  else\n\t    freeidx = ++maxidx;\n\t}\n\n      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n\tbfd_zalloc2 (abfd, maxidx, sizeof (Elf_Internal_Verdef));\n      if (elf_tdata (abfd)->verdef == NULL)\n\tgoto error_return_verdef;\n\n      elf_tdata (abfd)->cverdefs = maxidx;\n\n      everdef = (Elf_External_Verdef *) contents;\n      iverdefarr = elf_tdata (abfd)->verdef;\n      for (i = 0; i < hdr->sh_info; i++)\n\t{\n\t  Elf_External_Verdaux *everdaux;\n\t  Elf_Internal_Verdaux *iverdaux;\n\t  unsigned int j;\n\n\t  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);\n\n\t  if ((iverdefmem.vd_ndx & VERSYM_VERSION) == 0)\n\t    goto error_return_bad_verdef;\n\n\t  iverdef = &iverdefarr[(iverdefmem.vd_ndx & VERSYM_VERSION) - 1];\n\t  memcpy (iverdef, &iverdefmem, offsetof (Elf_Internal_Verdef, vd_bfd));\n\n\t  iverdef->vd_bfd = abfd;\n\n\t  if (iverdef->vd_cnt == 0)\n\t    iverdef->vd_auxptr = NULL;\n\t  else\n\t    {\n\t      iverdef->vd_auxptr = (struct elf_internal_verdaux *)\n                  bfd_alloc2 (abfd, iverdef->vd_cnt,\n                              sizeof (Elf_Internal_Verdaux));\n\t      if (iverdef->vd_auxptr == NULL)\n\t\tgoto error_return_verdef;\n\t    }\n\n\t  if (iverdef->vd_aux\n\t      > (size_t) (contents_end_aux - (bfd_byte *) everdef))\n\t    goto error_return_bad_verdef;\n\n\t  everdaux = ((Elf_External_Verdaux *)\n\t\t      ((bfd_byte *) everdef + iverdef->vd_aux));\n\t  iverdaux = iverdef->vd_auxptr;\n\t  for (j = 0; j < iverdef->vd_cnt; j++, iverdaux++)\n\t    {\n\t      _bfd_elf_swap_verdaux_in (abfd, everdaux, iverdaux);\n\n\t      iverdaux->vda_nodename =\n\t\tbfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t\t iverdaux->vda_name);\n\t      if (iverdaux->vda_nodename == NULL)\n\t\tgoto error_return_bad_verdef;\n\n\t      iverdaux->vda_nextptr = NULL;\n\t      if (iverdaux->vda_next == 0)\n\t\t{\n\t\t  iverdef->vd_cnt = j + 1;\n\t\t  break;\n\t\t}\n\t      if (j + 1 < iverdef->vd_cnt)\n\t\tiverdaux->vda_nextptr = iverdaux + 1;\n\n\t      if (iverdaux->vda_next\n\t\t  > (size_t) (contents_end_aux - (bfd_byte *) everdaux))\n\t\tgoto error_return_bad_verdef;\n\n\t      everdaux = ((Elf_External_Verdaux *)\n\t\t\t  ((bfd_byte *) everdaux + iverdaux->vda_next));\n\t    }\n\n\t  iverdef->vd_nodename = NULL;\n\t  if (iverdef->vd_cnt)\n\t    iverdef->vd_nodename = iverdef->vd_auxptr->vda_nodename;\n\n\t  iverdef->vd_nextdef = NULL;\n\t  if (iverdef->vd_next == 0)\n\t    break;\n\t  if ((size_t) (iverdef - iverdefarr) + 1 < maxidx)\n\t    iverdef->vd_nextdef = iverdef + 1;\n\n\t  everdef = ((Elf_External_Verdef *)\n\t\t     ((bfd_byte *) everdef + iverdef->vd_next));\n\t}\n\n      free (contents);\n      contents = NULL;\n    }\n  else if (default_imported_symver)\n    {\n      if (freeidx < 3)\n\tfreeidx = 3;\n      else\n\tfreeidx++;\n\n      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n          bfd_zalloc2 (abfd, freeidx, sizeof (Elf_Internal_Verdef));\n      if (elf_tdata (abfd)->verdef == NULL)\n\tgoto error_return;\n\n      elf_tdata (abfd)->cverdefs = freeidx;\n    }\n\n  /* Create a default version based on the soname.  */\n  if (default_imported_symver)\n    {\n      Elf_Internal_Verdef *iverdef;\n      Elf_Internal_Verdaux *iverdaux;\n\n      iverdef = &elf_tdata (abfd)->verdef[freeidx - 1];\n\n      iverdef->vd_version = VER_DEF_CURRENT;\n      iverdef->vd_flags = 0;\n      iverdef->vd_ndx = freeidx;\n      iverdef->vd_cnt = 1;\n\n      iverdef->vd_bfd = abfd;\n\n      iverdef->vd_nodename = bfd_elf_get_dt_soname (abfd);\n      if (iverdef->vd_nodename == NULL)\n\tgoto error_return_verdef;\n      iverdef->vd_nextdef = NULL;\n      iverdef->vd_auxptr = ((struct elf_internal_verdaux *)\n\t\t\t    bfd_zalloc (abfd, sizeof (Elf_Internal_Verdaux)));\n      if (iverdef->vd_auxptr == NULL)\n\tgoto error_return_verdef;\n\n      iverdaux = iverdef->vd_auxptr;\n      iverdaux->vda_nodename = iverdef->vd_nodename;\n    }\n\n  return TRUE;\n\n error_return:\n  if (contents != NULL)\n    free (contents);\n  return FALSE;\n}",
        "func_after": "bfd_boolean\n_bfd_elf_slurp_version_tables (bfd *abfd, bfd_boolean default_imported_symver)\n{\n  bfd_byte *contents = NULL;\n  unsigned int freeidx = 0;\n\n  if (elf_dynverref (abfd) != 0)\n    {\n      Elf_Internal_Shdr *hdr;\n      Elf_External_Verneed *everneed;\n      Elf_Internal_Verneed *iverneed;\n      unsigned int i;\n      bfd_byte *contents_end;\n\n      hdr = &elf_tdata (abfd)->dynverref_hdr;\n\n      if (hdr->sh_info == 0\n\t  || hdr->sh_info > hdr->sh_size / sizeof (Elf_External_Verneed))\n\t{\nerror_return_bad_verref:\n\t  _bfd_error_handler\n\t    (_(\"%B: .gnu.version_r invalid entry\"), abfd);\n\t  bfd_set_error (bfd_error_bad_value);\nerror_return_verref:\n\t  elf_tdata (abfd)->verref = NULL;\n\t  elf_tdata (abfd)->cverrefs = 0;\n\t  goto error_return;\n\t}\n\n      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);\n      if (contents == NULL)\n\tgoto error_return_verref;\n\n      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n\t  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)\n\tgoto error_return_verref;\n\n      elf_tdata (abfd)->verref = (Elf_Internal_Verneed *)\n\tbfd_alloc2 (abfd, hdr->sh_info, sizeof (Elf_Internal_Verneed));\n\n      if (elf_tdata (abfd)->verref == NULL)\n\tgoto error_return_verref;\n\n      BFD_ASSERT (sizeof (Elf_External_Verneed)\n\t\t  == sizeof (Elf_External_Vernaux));\n      contents_end = contents + hdr->sh_size - sizeof (Elf_External_Verneed);\n      everneed = (Elf_External_Verneed *) contents;\n      iverneed = elf_tdata (abfd)->verref;\n      for (i = 0; i < hdr->sh_info; i++, iverneed++)\n\t{\n\t  Elf_External_Vernaux *evernaux;\n\t  Elf_Internal_Vernaux *ivernaux;\n\t  unsigned int j;\n\n\t  _bfd_elf_swap_verneed_in (abfd, everneed, iverneed);\n\n\t  iverneed->vn_bfd = abfd;\n\n\t  iverneed->vn_filename =\n\t    bfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t     iverneed->vn_file);\n\t  if (iverneed->vn_filename == NULL)\n\t    goto error_return_bad_verref;\n\n\t  if (iverneed->vn_cnt == 0)\n\t    iverneed->vn_auxptr = NULL;\n\t  else\n\t    {\n\t      iverneed->vn_auxptr = (struct elf_internal_vernaux *)\n                  bfd_alloc2 (abfd, iverneed->vn_cnt,\n                              sizeof (Elf_Internal_Vernaux));\n\t      if (iverneed->vn_auxptr == NULL)\n\t\tgoto error_return_verref;\n\t    }\n\n\t  if (iverneed->vn_aux\n\t      > (size_t) (contents_end - (bfd_byte *) everneed))\n\t    goto error_return_bad_verref;\n\n\t  evernaux = ((Elf_External_Vernaux *)\n\t\t      ((bfd_byte *) everneed + iverneed->vn_aux));\n\t  ivernaux = iverneed->vn_auxptr;\n\t  for (j = 0; j < iverneed->vn_cnt; j++, ivernaux++)\n\t    {\n\t      _bfd_elf_swap_vernaux_in (abfd, evernaux, ivernaux);\n\n\t      ivernaux->vna_nodename =\n\t\tbfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t\t ivernaux->vna_name);\n\t      if (ivernaux->vna_nodename == NULL)\n\t\tgoto error_return_bad_verref;\n\n\t      if (ivernaux->vna_other > freeidx)\n\t\tfreeidx = ivernaux->vna_other;\n\n\t      ivernaux->vna_nextptr = NULL;\n\t      if (ivernaux->vna_next == 0)\n\t\t{\n\t\t  iverneed->vn_cnt = j + 1;\n\t\t  break;\n\t\t}\n\t      if (j + 1 < iverneed->vn_cnt)\n\t\tivernaux->vna_nextptr = ivernaux + 1;\n\n\t      if (ivernaux->vna_next\n\t\t  > (size_t) (contents_end - (bfd_byte *) evernaux))\n\t\tgoto error_return_bad_verref;\n\n\t      evernaux = ((Elf_External_Vernaux *)\n\t\t\t  ((bfd_byte *) evernaux + ivernaux->vna_next));\n\t    }\n\n\t  iverneed->vn_nextref = NULL;\n\t  if (iverneed->vn_next == 0)\n\t    break;\n\t  if (i + 1 < hdr->sh_info)\n\t    iverneed->vn_nextref = iverneed + 1;\n\n\t  if (iverneed->vn_next\n\t      > (size_t) (contents_end - (bfd_byte *) everneed))\n\t    goto error_return_bad_verref;\n\n\t  everneed = ((Elf_External_Verneed *)\n\t\t      ((bfd_byte *) everneed + iverneed->vn_next));\n\t}\n      elf_tdata (abfd)->cverrefs = i;\n\n      free (contents);\n      contents = NULL;\n    }\n\n  if (elf_dynverdef (abfd) != 0)\n    {\n      Elf_Internal_Shdr *hdr;\n      Elf_External_Verdef *everdef;\n      Elf_Internal_Verdef *iverdef;\n      Elf_Internal_Verdef *iverdefarr;\n      Elf_Internal_Verdef iverdefmem;\n      unsigned int i;\n      unsigned int maxidx;\n      bfd_byte *contents_end_def, *contents_end_aux;\n\n      hdr = &elf_tdata (abfd)->dynverdef_hdr;\n\n      if (hdr->sh_info == 0 || hdr->sh_size < sizeof (Elf_External_Verdef))\n\t{\n\terror_return_bad_verdef:\n\t  _bfd_error_handler\n\t    (_(\"%B: .gnu.version_d invalid entry\"), abfd);\n\t  bfd_set_error (bfd_error_bad_value);\n\terror_return_verdef:\n\t  elf_tdata (abfd)->verdef = NULL;\n\t  elf_tdata (abfd)->cverdefs = 0;\n\t  goto error_return;\n\t}\n\n      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);\n      if (contents == NULL)\n\tgoto error_return_verdef;\n      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n\t  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)\n\tgoto error_return_verdef;\n\n      BFD_ASSERT (sizeof (Elf_External_Verdef)\n\t\t  >= sizeof (Elf_External_Verdaux));\n      contents_end_def = contents + hdr->sh_size\n\t\t\t - sizeof (Elf_External_Verdef);\n      contents_end_aux = contents + hdr->sh_size\n\t\t\t - sizeof (Elf_External_Verdaux);\n\n      /* We know the number of entries in the section but not the maximum\n\t index.  Therefore we have to run through all entries and find\n\t the maximum.  */\n      everdef = (Elf_External_Verdef *) contents;\n      maxidx = 0;\n      for (i = 0; i < hdr->sh_info; ++i)\n\t{\n\t  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);\n\n\t  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) == 0)\n\t    goto error_return_bad_verdef;\n\t  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) > maxidx)\n\t    maxidx = iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION);\n\n\t  if (iverdefmem.vd_next == 0)\n\t    break;\n\n\t  if (iverdefmem.vd_next\n\t      > (size_t) (contents_end_def - (bfd_byte *) everdef))\n\t    goto error_return_bad_verdef;\n\n\t  everdef = ((Elf_External_Verdef *)\n\t\t     ((bfd_byte *) everdef + iverdefmem.vd_next));\n\t}\n\n      if (default_imported_symver)\n\t{\n\t  if (freeidx > maxidx)\n\t    maxidx = ++freeidx;\n\t  else\n\t    freeidx = ++maxidx;\n\t}\n\n      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n\tbfd_zalloc2 (abfd, maxidx, sizeof (Elf_Internal_Verdef));\n      if (elf_tdata (abfd)->verdef == NULL)\n\tgoto error_return_verdef;\n\n      elf_tdata (abfd)->cverdefs = maxidx;\n\n      everdef = (Elf_External_Verdef *) contents;\n      iverdefarr = elf_tdata (abfd)->verdef;\n      for (i = 0; i < hdr->sh_info; i++)\n\t{\n\t  Elf_External_Verdaux *everdaux;\n\t  Elf_Internal_Verdaux *iverdaux;\n\t  unsigned int j;\n\n\t  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);\n\n\t  if ((iverdefmem.vd_ndx & VERSYM_VERSION) == 0)\n\t    goto error_return_bad_verdef;\n\n\t  iverdef = &iverdefarr[(iverdefmem.vd_ndx & VERSYM_VERSION) - 1];\n\t  memcpy (iverdef, &iverdefmem, offsetof (Elf_Internal_Verdef, vd_bfd));\n\n\t  iverdef->vd_bfd = abfd;\n\n\t  if (iverdef->vd_cnt == 0)\n\t    iverdef->vd_auxptr = NULL;\n\t  else\n\t    {\n\t      iverdef->vd_auxptr = (struct elf_internal_verdaux *)\n                  bfd_alloc2 (abfd, iverdef->vd_cnt,\n                              sizeof (Elf_Internal_Verdaux));\n\t      if (iverdef->vd_auxptr == NULL)\n\t\tgoto error_return_verdef;\n\t    }\n\n\t  if (iverdef->vd_aux\n\t      > (size_t) (contents_end_aux - (bfd_byte *) everdef))\n\t    goto error_return_bad_verdef;\n\n\t  everdaux = ((Elf_External_Verdaux *)\n\t\t      ((bfd_byte *) everdef + iverdef->vd_aux));\n\t  iverdaux = iverdef->vd_auxptr;\n\t  for (j = 0; j < iverdef->vd_cnt; j++, iverdaux++)\n\t    {\n\t      _bfd_elf_swap_verdaux_in (abfd, everdaux, iverdaux);\n\n\t      iverdaux->vda_nodename =\n\t\tbfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t\t iverdaux->vda_name);\n\t      if (iverdaux->vda_nodename == NULL)\n\t\tgoto error_return_bad_verdef;\n\n\t      iverdaux->vda_nextptr = NULL;\n\t      if (iverdaux->vda_next == 0)\n\t\t{\n\t\t  iverdef->vd_cnt = j + 1;\n\t\t  break;\n\t\t}\n\t      if (j + 1 < iverdef->vd_cnt)\n\t\tiverdaux->vda_nextptr = iverdaux + 1;\n\n\t      if (iverdaux->vda_next\n\t\t  > (size_t) (contents_end_aux - (bfd_byte *) everdaux))\n\t\tgoto error_return_bad_verdef;\n\n\t      everdaux = ((Elf_External_Verdaux *)\n\t\t\t  ((bfd_byte *) everdaux + iverdaux->vda_next));\n\t    }\n\n\t  iverdef->vd_nodename = NULL;\n\t  if (iverdef->vd_cnt)\n\t    iverdef->vd_nodename = iverdef->vd_auxptr->vda_nodename;\n\n\t  iverdef->vd_nextdef = NULL;\n\t  if (iverdef->vd_next == 0)\n\t    break;\n\t  if ((size_t) (iverdef - iverdefarr) + 1 < maxidx)\n\t    iverdef->vd_nextdef = iverdef + 1;\n\n\t  everdef = ((Elf_External_Verdef *)\n\t\t     ((bfd_byte *) everdef + iverdef->vd_next));\n\t}\n\n      free (contents);\n      contents = NULL;\n    }\n  else if (default_imported_symver)\n    {\n      if (freeidx < 3)\n\tfreeidx = 3;\n      else\n\tfreeidx++;\n\n      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n          bfd_zalloc2 (abfd, freeidx, sizeof (Elf_Internal_Verdef));\n      if (elf_tdata (abfd)->verdef == NULL)\n\tgoto error_return;\n\n      elf_tdata (abfd)->cverdefs = freeidx;\n    }\n\n  /* Create a default version based on the soname.  */\n  if (default_imported_symver)\n    {\n      Elf_Internal_Verdef *iverdef;\n      Elf_Internal_Verdaux *iverdaux;\n\n      iverdef = &elf_tdata (abfd)->verdef[freeidx - 1];\n\n      iverdef->vd_version = VER_DEF_CURRENT;\n      iverdef->vd_flags = 0;\n      iverdef->vd_ndx = freeidx;\n      iverdef->vd_cnt = 1;\n\n      iverdef->vd_bfd = abfd;\n\n      iverdef->vd_nodename = bfd_elf_get_dt_soname (abfd);\n      if (iverdef->vd_nodename == NULL)\n\tgoto error_return_verdef;\n      iverdef->vd_nextdef = NULL;\n      iverdef->vd_auxptr = ((struct elf_internal_verdaux *)\n\t\t\t    bfd_zalloc (abfd, sizeof (Elf_Internal_Verdaux)));\n      if (iverdef->vd_auxptr == NULL)\n\tgoto error_return_verdef;\n\n      iverdaux = iverdef->vd_auxptr;\n      iverdaux->vda_nodename = iverdef->vd_nodename;\n    }\n\n  return TRUE;\n\n error_return:\n  if (contents != NULL)\n    free (contents);\n  return FALSE;\n}",
        "description": "The _bfd_elf_slurp_version_tables function in the BFD library, part of GNU Binutils 2.29, is susceptible to a denial of service attack. This vulnerability arises from excessive memory allocation when processing a specially crafted ELF file, leading to potential application crashes.",
        "commit": "The vulnerability involves a memory allocation issue within the ELF (Executable and Linkable Format) handling module of a binary file format library. Specifically, the code performs a sanity check on the size of the `SHT_GNU_verneed` section, ensuring it meets certain minimum requirements related to the number of version entries (`sh_info`). Additionally, since the code either fully initializes all fields of the version entries or exits with an error, there is no need to zero-initialize the allocated memory for these entries. The fix includes modifying the `_bfd_elf_slurp_version_tables` function to test the `sh_info` field of the `SHT_GNU_verneed` section for validity and to avoid zero-initializing the memory allocated for version references."
    },
    {
        "cwe": "CWE-319",
        "func_name": "cifsd-team/ntlm_authenticate",
        "score": 0.7544277906417847,
        "func_before": "static int ntlm_authenticate(struct ksmbd_work *work)\n{\n\tstruct smb2_sess_setup_req *req = work->request_buf;\n\tstruct smb2_sess_setup_rsp *rsp = work->response_buf;\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct channel *chann = NULL;\n\tstruct ksmbd_user *user;\n\tu64 prev_id;\n\tint sz, rc;\n\n\tksmbd_debug(SMB, \"authenticate phase\\n\");\n\tif (conn->use_spnego) {\n\t\tunsigned char *spnego_blob;\n\t\tu16 spnego_blob_len;\n\n\t\trc = build_spnego_ntlmssp_auth_blob(&spnego_blob,\n\t\t\t\t\t\t    &spnego_blob_len,\n\t\t\t\t\t\t    0);\n\t\tif (rc)\n\t\t\treturn -ENOMEM;\n\n\t\tsz = le16_to_cpu(rsp->SecurityBufferOffset);\n\t\tmemcpy((char *)&rsp->hdr.ProtocolId + sz, spnego_blob, spnego_blob_len);\n\t\trsp->SecurityBufferLength = cpu_to_le16(spnego_blob_len);\n\t\tkfree(spnego_blob);\n\t\tinc_rfc1001_len(rsp, spnego_blob_len - 1);\n\t}\n\n\tuser = session_user(conn, req);\n\tif (!user) {\n\t\tksmbd_debug(SMB, \"Unknown user name or an error\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* Check for previous session */\n\tprev_id = le64_to_cpu(req->PreviousSessionId);\n\tif (prev_id && prev_id != sess->id)\n\t\tdestroy_previous_session(user, prev_id);\n\n\tif (sess->state == SMB2_SESSION_VALID) {\n\t\t/*\n\t\t * Reuse session if anonymous try to connect\n\t\t * on reauthetication.\n\t\t */\n\t\tif (ksmbd_anonymous_user(user)) {\n\t\t\tksmbd_free_user(user);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!ksmbd_compare_user(sess->user, user))\n\t\t\treturn -EPERM;\n\n\t\tksmbd_free_user(user);\n\t} else {\n\t\tsess->user = user;\n\t}\n\n\tif (user_guest(sess->user)) {\n\t\tif (conn->sign) {\n\t\t\tksmbd_debug(SMB, \"Guest login not allowed when signing enabled\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\trsp->SessionFlags = SMB2_SESSION_FLAG_IS_GUEST_LE;\n\t} else {\n\t\tstruct authenticate_message *authblob;\n\n\t\tauthblob = user_authblob(conn, req);\n\t\tsz = le16_to_cpu(req->SecurityBufferLength);\n\t\trc = ksmbd_decode_ntlmssp_auth_blob(authblob, sz, conn, sess);\n\t\tif (rc) {\n\t\t\tset_user_flag(sess->user, KSMBD_USER_FLAG_BAD_PASSWORD);\n\t\t\tksmbd_debug(SMB, \"authentication failed\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\t/*\n\t\t * If session state is SMB2_SESSION_VALID, We can assume\n\t\t * that it is reauthentication. And the user/password\n\t\t * has been verified, so return it here.\n\t\t */\n\t\tif (sess->state == SMB2_SESSION_VALID) {\n\t\t\tif (conn->binding)\n\t\t\t\tgoto binding_session;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((conn->sign || server_conf.enforced_signing) ||\n\t\t    (req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED))\n\t\t\tsess->sign = true;\n\n\t\tif (conn->vals->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION &&\n\t\t    conn->ops->generate_encryptionkey &&\n\t\t    !(req->Flags & SMB2_SESSION_REQ_FLAG_BINDING)) {\n\t\t\trc = conn->ops->generate_encryptionkey(sess);\n\t\t\tif (rc) {\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"SMB3 encryption key generation failed\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsess->enc = true;\n\t\t\trsp->SessionFlags = SMB2_SESSION_FLAG_ENCRYPT_DATA_LE;\n\t\t\t/*\n\t\t\t * signing is disable if encryption is enable\n\t\t\t * on this session\n\t\t\t */\n\t\t\tsess->sign = false;\n\t\t}\n\t}\n\nbinding_session:\n\tif (conn->dialect >= SMB30_PROT_ID) {\n\t\tchann = lookup_chann_list(sess, conn);\n\t\tif (!chann) {\n\t\t\tchann = kmalloc(sizeof(struct channel), GFP_KERNEL);\n\t\t\tif (!chann)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tchann->conn = conn;\n\t\t\tINIT_LIST_HEAD(&chann->chann_list);\n\t\t\tlist_add(&chann->chann_list, &sess->ksmbd_chann_list);\n\t\t}\n\t}\n\n\tif (conn->ops->generate_signingkey) {\n\t\trc = conn->ops->generate_signingkey(sess, conn);\n\t\tif (rc) {\n\t\t\tksmbd_debug(SMB, \"SMB3 signing key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (conn->dialect > SMB20_PROT_ID) {\n\t\tif (!ksmbd_conn_lookup_dialect(conn)) {\n\t\t\tpr_err(\"fail to verify the dialect\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\treturn 0;\n}",
        "func_after": "static int ntlm_authenticate(struct ksmbd_work *work)\n{\n\tstruct smb2_sess_setup_req *req = work->request_buf;\n\tstruct smb2_sess_setup_rsp *rsp = work->response_buf;\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct channel *chann = NULL;\n\tstruct ksmbd_user *user;\n\tu64 prev_id;\n\tint sz, rc;\n\n\tksmbd_debug(SMB, \"authenticate phase\\n\");\n\tif (conn->use_spnego) {\n\t\tunsigned char *spnego_blob;\n\t\tu16 spnego_blob_len;\n\n\t\trc = build_spnego_ntlmssp_auth_blob(&spnego_blob,\n\t\t\t\t\t\t    &spnego_blob_len,\n\t\t\t\t\t\t    0);\n\t\tif (rc)\n\t\t\treturn -ENOMEM;\n\n\t\tsz = le16_to_cpu(rsp->SecurityBufferOffset);\n\t\tmemcpy((char *)&rsp->hdr.ProtocolId + sz, spnego_blob, spnego_blob_len);\n\t\trsp->SecurityBufferLength = cpu_to_le16(spnego_blob_len);\n\t\tkfree(spnego_blob);\n\t\tinc_rfc1001_len(rsp, spnego_blob_len - 1);\n\t}\n\n\tuser = session_user(conn, req);\n\tif (!user) {\n\t\tksmbd_debug(SMB, \"Unknown user name or an error\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* Check for previous session */\n\tprev_id = le64_to_cpu(req->PreviousSessionId);\n\tif (prev_id && prev_id != sess->id)\n\t\tdestroy_previous_session(user, prev_id);\n\n\tif (sess->state == SMB2_SESSION_VALID) {\n\t\t/*\n\t\t * Reuse session if anonymous try to connect\n\t\t * on reauthetication.\n\t\t */\n\t\tif (ksmbd_anonymous_user(user)) {\n\t\t\tksmbd_free_user(user);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!ksmbd_compare_user(sess->user, user))\n\t\t\treturn -EPERM;\n\n\t\tksmbd_free_user(user);\n\t} else {\n\t\tsess->user = user;\n\t}\n\n\tif (user_guest(sess->user)) {\n\t\tif (conn->sign) {\n\t\t\tksmbd_debug(SMB, \"Guest login not allowed when signing enabled\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\trsp->SessionFlags = SMB2_SESSION_FLAG_IS_GUEST_LE;\n\t} else {\n\t\tstruct authenticate_message *authblob;\n\n\t\tauthblob = user_authblob(conn, req);\n\t\tsz = le16_to_cpu(req->SecurityBufferLength);\n\t\trc = ksmbd_decode_ntlmssp_auth_blob(authblob, sz, conn, sess);\n\t\tif (rc) {\n\t\t\tset_user_flag(sess->user, KSMBD_USER_FLAG_BAD_PASSWORD);\n\t\t\tksmbd_debug(SMB, \"authentication failed\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\t/*\n\t\t * If session state is SMB2_SESSION_VALID, We can assume\n\t\t * that it is reauthentication. And the user/password\n\t\t * has been verified, so return it here.\n\t\t */\n\t\tif (sess->state == SMB2_SESSION_VALID) {\n\t\t\tif (conn->binding)\n\t\t\t\tgoto binding_session;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((conn->sign || server_conf.enforced_signing) ||\n\t\t    (req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED))\n\t\t\tsess->sign = true;\n\n\t\tif (should_encrypt(conn) &&\n\t\t    !(req->Flags & SMB2_SESSION_REQ_FLAG_BINDING)) {\n\t\t\trc = conn->ops->generate_encryptionkey(sess);\n\t\t\tif (rc) {\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"SMB3 encryption key generation failed\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsess->enc = true;\n\t\t\trsp->SessionFlags = SMB2_SESSION_FLAG_ENCRYPT_DATA_LE;\n\t\t\t/*\n\t\t\t * signing is disable if encryption is enable\n\t\t\t * on this session\n\t\t\t */\n\t\t\tsess->sign = false;\n\t\t}\n\t}\n\nbinding_session:\n\tif (conn->dialect >= SMB30_PROT_ID) {\n\t\tchann = lookup_chann_list(sess, conn);\n\t\tif (!chann) {\n\t\t\tchann = kmalloc(sizeof(struct channel), GFP_KERNEL);\n\t\t\tif (!chann)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tchann->conn = conn;\n\t\t\tINIT_LIST_HEAD(&chann->chann_list);\n\t\t\tlist_add(&chann->chann_list, &sess->ksmbd_chann_list);\n\t\t}\n\t}\n\n\tif (conn->ops->generate_signingkey) {\n\t\trc = conn->ops->generate_signingkey(sess, conn);\n\t\tif (rc) {\n\t\t\tksmbd_debug(SMB, \"SMB3 signing key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (conn->dialect > SMB20_PROT_ID) {\n\t\tif (!ksmbd_conn_lookup_dialect(conn)) {\n\t\t\tpr_err(\"fail to verify the dialect\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\treturn 0;\n}",
        "description": "The ksmbd server, utilized in the Linux kernel, may occasionally transmit data in plaintext despite encryption being enabled. This issue arises due to the server setting the SMB2_GLOBAL_CAP_ENCRYPTION flag while employing the SMB 3.1.1 protocol, contrary to the SMB protocol specifications. As a result, when Windows 10 encounters this protocol violation, it disables encryption.",
        "commit": "Setting the SMB2_GLOBAL_CAP_ENCRYPTION flag for SMB 3.1.1 is a violation of the official Microsoft MS-SMB2 specification, which mandates that this flag should only be used for SMB 3.0 and 3.0.2 dialects."
    }
]