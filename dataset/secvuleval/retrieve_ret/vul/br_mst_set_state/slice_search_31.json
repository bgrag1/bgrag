[
    {
        "cwe": "CWE-367",
        "func_name": "torvalds/enter_svm_guest_mode",
        "score": 0.7659640312194824,
        "func_before": "int enter_svm_guest_mode(struct vcpu_svm *svm, u64 vmcb12_gpa,\n\t\t\t struct vmcb *vmcb12)\n{\n\tint ret;\n\n\tsvm->nested.vmcb12_gpa = vmcb12_gpa;\n\tload_nested_vmcb_control(svm, &vmcb12->control);\n\tnested_prepare_vmcb_save(svm, vmcb12);\n\tnested_prepare_vmcb_control(svm);\n\n\tret = nested_svm_load_cr3(&svm->vcpu, vmcb12->save.cr3,\n\t\t\t\t  nested_npt_enabled(svm));\n\tif (ret)\n\t\treturn ret;\n\n\tsvm_set_gif(svm, true);\n\n\treturn 0;\n}",
        "func_after": "int enter_svm_guest_mode(struct vcpu_svm *svm, u64 vmcb12_gpa,\n\t\t\t struct vmcb *vmcb12)\n{\n\tint ret;\n\n\tsvm->nested.vmcb12_gpa = vmcb12_gpa;\n\tnested_prepare_vmcb_save(svm, vmcb12);\n\tnested_prepare_vmcb_control(svm);\n\n\tret = nested_svm_load_cr3(&svm->vcpu, vmcb12->save.cr3,\n\t\t\t\t  nested_npt_enabled(svm));\n\tif (ret)\n\t\treturn ret;\n\n\tsvm_set_gif(svm, true);\n\n\treturn 0;\n}",
        "description": "A use-after-free vulnerability exists in the Linux kernel prior to version 5.11.12 within the AMD KVM SVM nested virtualization module. This flaw allows an AMD KVM guest to potentially bypass access controls on host OS Model-Specific Registers (MSRs) when multiple nested guests are present. The issue arises due to a Time-of-Check to Time-of-Use (TOCTOU) race condition involving a VMCB12 double fetch in the `nested_svm_vmrun` function.",
        "commit": "To avoid race conditions between checking and using nested VMCB controls, ensuring that the VMRUN intercept is consistently reflected to the nested hypervisor rather than being processed by the host is crucial. Without this patch, there is a risk that `svm->nested.hsave` could point to the MSR permission bitmap for nested guests, leading to potential vulnerabilities such as CVE-2021-29657."
    },
    {
        "cwe": "CWE-863",
        "func_name": "torvalds/internal_get_user_pages_fast",
        "score": 0.7905874848365784,
        "func_before": "static int internal_get_user_pages_fast(unsigned long start, int nr_pages,\n\t\t\t\t\tunsigned int gup_flags,\n\t\t\t\t\tstruct page **pages)\n{\n\tunsigned long addr, len, end;\n\tint nr_pinned = 0, ret = 0;\n\n\tif (WARN_ON_ONCE(gup_flags & ~(FOLL_WRITE | FOLL_LONGTERM |\n\t\t\t\t       FOLL_FORCE | FOLL_PIN | FOLL_GET)))\n\t\treturn -EINVAL;\n\n\tstart = untagged_addr(start) & PAGE_MASK;\n\taddr = start;\n\tlen = (unsigned long) nr_pages << PAGE_SHIFT;\n\tend = start + len;\n\n\tif (end <= start)\n\t\treturn 0;\n\tif (unlikely(!access_ok((void __user *)start, len)))\n\t\treturn -EFAULT;\n\n\tif (IS_ENABLED(CONFIG_HAVE_FAST_GUP) &&\n\t    gup_fast_permitted(start, end)) {\n\t\tlocal_irq_disable();\n\t\tgup_pgd_range(addr, end, gup_flags, pages, &nr_pinned);\n\t\tlocal_irq_enable();\n\t\tret = nr_pinned;\n\t}\n\n\tif (nr_pinned < nr_pages) {\n\t\t/* Try to get the remaining pages with get_user_pages */\n\t\tstart += nr_pinned << PAGE_SHIFT;\n\t\tpages += nr_pinned;\n\n\t\tret = __gup_longterm_unlocked(start, nr_pages - nr_pinned,\n\t\t\t\t\t      gup_flags, pages);\n\n\t\t/* Have to be a bit careful with return values */\n\t\tif (nr_pinned > 0) {\n\t\t\tif (ret < 0)\n\t\t\t\tret = nr_pinned;\n\t\t\telse\n\t\t\t\tret += nr_pinned;\n\t\t}\n\t}\n\n\treturn ret;\n}",
        "func_after": "static int internal_get_user_pages_fast(unsigned long start, int nr_pages,\n\t\t\t\t\tunsigned int gup_flags,\n\t\t\t\t\tstruct page **pages)\n{\n\tunsigned long addr, len, end;\n\tint nr_pinned = 0, ret = 0;\n\n\tif (WARN_ON_ONCE(gup_flags & ~(FOLL_WRITE | FOLL_LONGTERM |\n\t\t\t\t       FOLL_FORCE | FOLL_PIN | FOLL_GET)))\n\t\treturn -EINVAL;\n\n\tstart = untagged_addr(start) & PAGE_MASK;\n\taddr = start;\n\tlen = (unsigned long) nr_pages << PAGE_SHIFT;\n\tend = start + len;\n\n\tif (end <= start)\n\t\treturn 0;\n\tif (unlikely(!access_ok((void __user *)start, len)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * The FAST_GUP case requires FOLL_WRITE even for pure reads,\n\t * because get_user_pages() may need to cause an early COW in\n\t * order to avoid confusing the normal COW routines. So only\n\t * targets that are already writable are safe to do by just\n\t * looking at the page tables.\n\t */\n\tif (IS_ENABLED(CONFIG_HAVE_FAST_GUP) &&\n\t    gup_fast_permitted(start, end)) {\n\t\tlocal_irq_disable();\n\t\tgup_pgd_range(addr, end, gup_flags | FOLL_WRITE, pages, &nr_pinned);\n\t\tlocal_irq_enable();\n\t\tret = nr_pinned;\n\t}\n\n\tif (nr_pinned < nr_pages) {\n\t\t/* Try to get the remaining pages with get_user_pages */\n\t\tstart += nr_pinned << PAGE_SHIFT;\n\t\tpages += nr_pinned;\n\n\t\tret = __gup_longterm_unlocked(start, nr_pages - nr_pinned,\n\t\t\t\t\t      gup_flags, pages);\n\n\t\t/* Have to be a bit careful with return values */\n\t\tif (nr_pinned > 0) {\n\t\t\tif (ret < 0)\n\t\t\t\tret = nr_pinned;\n\t\t\telse\n\t\t\t\tret += nr_pinned;\n\t\t}\n\t}\n\n\treturn ret;\n}",
        "description": "An issue was discovered in the Linux kernel prior to version 5.7.3, affecting the memory management components located in mm/gup.c and mm/huge_memory.c. The get_user_pages (gup) implementation, when utilized for copy-on-write pages, fails to correctly handle read operation semantics, potentially resulting in unintended write access.",
        "commit": "The vulnerability involves the `get_user_pages()` function in the Linux kernel, which can lead to ambiguous behavior when dealing with copy-on-write (COW) pages. Specifically, the function may return a page pointer that is no longer associated with the original virtual memory area (VM) due to potential COW events. This ambiguity arises because the direction and timing of COW events are undefined, and a page can be unmapped by the thread that performed the `get_user_pages()` call, especially under memory pressure.\n\nTo mitigate this issue, the kernel introduces a change to force a COW event by setting the `FOLL_WRITE` flag when `FOLL_GET` or `FOLL_PIN` is used on a COW mapping. This ensures that the page is properly isolated from other VMs, preventing unintended access or control. However, this change affects the behavior of `get_user_pages_fast()`, which now refuses to follow read-only pages due to the potential need for COW breaking, leading to slower processing in such cases.\n\nThe current semantics are as follows:\n- `__get_user_pages_fast()`: No changes; it does not break COW unless explicitly asked.\n- `get_user_pages_fast()`: Refuses to follow read-only pages, requiring the slow path for COW breaking.\n- `get_user_pages()`: Forces COW breaking for COW mappings when using `FOLL_GET` or `FOLL_PIN`.\n\nThis change aims to clarify the semantics of `get_user_pages()` and reduce the risk of subtle bugs related to COW behavior. While this addresses the ambiguity, it is noted that true shared mappings will still allow pages to change under the user, meaning `get_user_pages()` does not guarantee a \"stable\" page."
    },
    {
        "cwe": "CWE-212",
        "func_name": "linux4sam/secure_decrypt",
        "score": 0.7673377990722656,
        "func_before": "int secure_decrypt(void *data, unsigned int data_length, int is_signed)\n{\n\tat91_aes_key_size_t key_size;\n\tunsigned int cmac_key[8], cipher_key[8];\n\tunsigned int iv[AT91_AES_IV_SIZE_WORD];\n\tunsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int fixed_length;\n\tconst unsigned int *cmac;\n\tint rc = -1;\n\n\t/* Init keys */\n\tinit_keys(&key_size, cipher_key, cmac_key, iv);\n\n\t/* Init periph */\n\tat91_aes_init();\n\n\t/* Check signature if required */\n\tif (is_signed) {\n\t\t/* Compute the CMAC */\n\t\tif (at91_aes_cmac(data_length, data, computed_cmac,\n\t\t\t\t  key_size, cmac_key))\n\t\t\tgoto exit;\n\n\t\t/* Check the CMAC */\n\t\tfixed_length = at91_aes_roundup(data_length);\n\t\tcmac = (const unsigned int *)((char *)data + fixed_length);\n\t\tif (!consttime_memequal(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))\n\t\t\tgoto exit;\n\t}\n\n\t/* Decrypt the whole file */\n\tif (at91_aes_cbc(data_length, data, data, 0,\n\t\t\t key_size, cipher_key, iv))\n\t\tgoto exit;\n\n\trc = 0;\nexit:\n\t/* Reset periph */\n\tat91_aes_cleanup();\n\n\t/* Reset keys */\n\tmemset(cmac_key, 0, sizeof(cmac_key));\n\tmemset(cipher_key, 0, sizeof(cipher_key));\n\tmemset(iv, 0, sizeof(iv));\n\n\treturn rc;\n}",
        "func_after": "static int secure_decrypt(void *data, unsigned int data_length, int is_signed)\n{\n\tat91_aes_key_size_t key_size;\n\tunsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int fixed_length;\n\tconst unsigned int *cmac;\n\tint rc = -1;\n\n#if defined(CONFIG_AES_KEY_SIZE_128)\n\tkey_size = AT91_AES_KEY_SIZE_128;\n#elif defined(CONFIG_AES_KEY_SIZE_192)\n\tkey_size = AT91_AES_KEY_SIZE_192;\n#elif defined(CONFIG_AES_KEY_SIZE_256)\n\tkey_size = AT91_AES_KEY_SIZE_256;\n#else\n#error \"bad AES key size\"\n#endif\n\n\t/* Init periph */\n\tat91_aes_init();\n\n\t/* Check signature if required */\n\tif (is_signed) {\n\t\t/* Compute the CMAC */\n\t\tif (at91_aes_cmac(data_length, data, computed_cmac,\n\t\t\t\t  key_size, cmac_key))\n\t\t\tgoto exit;\n\n\t\t/* Check the CMAC */\n\t\tfixed_length = at91_aes_roundup(data_length);\n\t\tcmac = (const unsigned int *)((char *)data + fixed_length);\n\t\tif (!consttime_memequal(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))\n\t\t\tgoto exit;\n\t}\n\n\t/* Decrypt the whole file */\n\tif (at91_aes_cbc(data_length, data, data, 0,\n\t\t\t key_size, cipher_key, iv))\n\t\tgoto exit;\n\n\trc = 0;\nexit:\n\t/* Reset periph */\n\tat91_aes_cleanup();\n\n\treturn rc;\n}",
        "description": "AT91bootstrap versions prior to 3.9.2 fail to adequately clear encryption and authentication keys from memory before transitioning control to a less privileged software component. This failure can be exploited to expose these keys, potentially allowing attackers to encrypt and sign subsequent boot stages, such as the bootloader.",
        "commit": "The vulnerability knowledge has been abstracted and generalized as follows:\n\n\"Keys were moved into static arrays to prevent their copying from the code section to the stack during initialization. By hardcoding the keys into the data section at compile time and ensuring they can be completely wiped after use, this change enhances security by reducing the risk of key exposure.\""
    },
    {
        "cwe": "CWE-440",
        "func_name": "eclipse-openj9/Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex",
        "score": 0.7669689655303955,
        "func_before": "JNIEXPORT jint JNICALL Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *env, jclass InterfaceMethodHandle, jlong interfaceArg, jint itableIndex, jlong receiverClassArg)\n   {\n   J9Class  *interfaceClass = (J9Class*)(intptr_t)interfaceArg;\n   J9Class  *receiverClass  = (J9Class*)(intptr_t)receiverClassArg;\n   J9ITable *itableEntry;\n   for (itableEntry = (J9ITable*)receiverClass->iTable; itableEntry; itableEntry = itableEntry->next)\n      if (itableEntry->interfaceClass == interfaceClass)\n         break;\n   TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *itableArray = (UDATA*)(itableEntry+1);\n   return (itableArray[itableIndex] - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } indexAndLiterals =\n      {\n      (UDATA)interfaceClass,\n      (UDATA)itableIndex\n      };\n   J9Object *receiver = (J9Object*)receiverArg;\n   return (jint)jitLookupInterfaceMethod(receiver->clazz, &indexAndLiterals, 0);\n#endif\n   }",
        "func_after": "JNIEXPORT jint JNICALL Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *env, jclass InterfaceMethodHandle, jlong interfaceArg, jint itableIndex, jlong receiverClassArg)\n   {\n   J9Class  *interfaceClass = (J9Class*)(intptr_t)interfaceArg;\n   J9Class  *receiverClass  = (J9Class*)(intptr_t)receiverClassArg;\n   J9ITable *itableEntry;\n   for (itableEntry = (J9ITable*)receiverClass->iTable; itableEntry; itableEntry = itableEntry->next)\n      if (itableEntry->interfaceClass == interfaceClass)\n         break;\n   TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *itableArray = (UDATA*)(itableEntry+1);\n   UDATA vTableOffset = itableArray[itableIndex];\n   J9Method *method = *(J9Method**)((UDATA)receiverClass + vTableOffset);\n   if ((J9_ROM_METHOD_FROM_RAM_METHOD(method)->modifiers & J9AccPublic) == 0)\n      return -1;\n\n   return (vTableOffset - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } indexAndLiterals =\n      {\n      (UDATA)interfaceClass,\n      (UDATA)itableIndex\n      };\n   J9Object *receiver = (J9Object*)receiverArg;\n   return (jint)jitLookupInterfaceMethod(receiver->clazz, &indexAndLiterals, 0);\n#endif\n   }",
        "description": "In versions of Eclipse Openj9 prior to 0.29.0, the Java Virtual Machine (JVM) fails to throw an IllegalAccessError when MethodHandles are used to invoke methods that are not accessible through interfaces.",
        "commit": "The vulnerability involves a situation where an `IllegalAccessError` (IAE) is not being thrown appropriately when an `InterfaceHandle` encounters a non-public method during dispatch. The expected behavior is for the dispatch mechanism implemented by `InterfaceHandle` to mimic that of `invokeinterface`, which throws an `IAE` when attempting to access non-public methods. This discrepancy allows unauthorized access to non-public methods, potentially leading to security vulnerabilities."
    },
    {
        "cwe": "CWE-436",
        "func_name": "xen-project/sh_page_fault",
        "score": 0.7905160784721375,
        "func_before": "static int sh_page_fault(struct vcpu *v,\n                          unsigned long va,\n                          struct cpu_user_regs *regs)\n{\n    struct domain *d = v->domain;\n    walk_t gw;\n    gfn_t gfn = _gfn(0);\n    mfn_t gmfn, sl1mfn = _mfn(0);\n    shadow_l1e_t sl1e, *ptr_sl1e;\n    paddr_t gpa;\n    struct sh_emulate_ctxt emul_ctxt;\n    const struct x86_emulate_ops *emul_ops;\n    int r;\n    p2m_type_t p2mt;\n    uint32_t rc, error_code;\n    bool walk_ok;\n    int version;\n    unsigned int cpl;\n    const struct npfec access = {\n         .read_access = 1,\n         .write_access = !!(regs->error_code & PFEC_write_access),\n         .gla_valid = 1,\n         .kind = npfec_kind_with_gla\n    };\n    const fetch_type_t ft =\n        access.write_access ? ft_demand_write : ft_demand_read;\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n    int fast_emul = 0;\n#endif\n\n    SHADOW_PRINTK(\"%pv va=%#lx err=%#x, rip=%lx\\n\",\n                  v, va, regs->error_code, regs->rip);\n\n    perfc_incr(shadow_fault);\n\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n    /* If faulting frame is successfully emulated in last shadow fault\n     * it's highly likely to reach same emulation action for this frame.\n     * Then try to emulate early to avoid lock aquisition.\n     */\n    if ( v->arch.paging.last_write_emul_ok\n         && v->arch.paging.shadow.last_emulated_frame == (va >> PAGE_SHIFT) )\n    {\n        /* check whether error code is 3, or else fall back to normal path\n         * in case of some validation is required\n         */\n        if ( regs->error_code == (PFEC_write_access | PFEC_page_present) )\n        {\n            fast_emul = 1;\n            gmfn = _mfn(v->arch.paging.shadow.last_emulated_mfn);\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n            /* Fall back to the slow path if we're trying to emulate\n               writes to an out of sync page. */\n            if ( mfn_valid(gmfn) && mfn_is_out_of_sync(gmfn) )\n            {\n                fast_emul = 0;\n                v->arch.paging.last_write_emul_ok = 0;\n                goto page_fault_slow_path;\n            }\n#endif /* OOS */\n\n            perfc_incr(shadow_fault_fast_emulate);\n            goto early_emulation;\n        }\n        else\n            v->arch.paging.last_write_emul_ok = 0;\n    }\n#endif\n\n    //\n    // XXX: Need to think about eventually mapping superpages directly in the\n    //      shadow (when possible), as opposed to splintering them into a\n    //      bunch of 4K maps.\n    //\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_FAST_FAULT_PATH)\n    if ( (regs->error_code & PFEC_reserved_bit) )\n    {\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n        /* First, need to check that this isn't an out-of-sync\n         * shadow l1e.  If it is, we fall back to the slow path, which\n         * will sync it up again. */\n        {\n            shadow_l2e_t sl2e;\n            mfn_t gl1mfn;\n            if ( (__copy_from_user(&sl2e,\n                                   (sh_linear_l2_table(v)\n                                    + shadow_l2_linear_offset(va)),\n                                   sizeof(sl2e)) != 0)\n                 || !(shadow_l2e_get_flags(sl2e) & _PAGE_PRESENT)\n                 || !mfn_valid(gl1mfn = backpointer(mfn_to_page(\n                                  shadow_l2e_get_mfn(sl2e))))\n                 || unlikely(mfn_is_out_of_sync(gl1mfn)) )\n            {\n                /* Hit the slow path as if there had been no\n                 * shadow entry at all, and let it tidy up */\n                ASSERT(regs->error_code & PFEC_page_present);\n                regs->error_code ^= (PFEC_reserved_bit|PFEC_page_present);\n                goto page_fault_slow_path;\n            }\n        }\n#endif /* SHOPT_OUT_OF_SYNC */\n        /* The only reasons for reserved bits to be set in shadow entries\n         * are the two \"magic\" shadow_l1e entries. */\n        if ( likely((__copy_from_user(&sl1e,\n                                      (sh_linear_l1_table(v)\n                                       + shadow_l1_linear_offset(va)),\n                                      sizeof(sl1e)) == 0)\n                    && sh_l1e_is_magic(sl1e)) )\n        {\n\n            if ( sh_l1e_is_gnp(sl1e) )\n            {\n                /* Not-present in a guest PT: pass to the guest as\n                 * a not-present fault (by flipping two bits). */\n                ASSERT(regs->error_code & PFEC_page_present);\n                regs->error_code ^= (PFEC_reserved_bit|PFEC_page_present);\n                sh_reset_early_unshadow(v);\n                perfc_incr(shadow_fault_fast_gnp);\n                SHADOW_PRINTK(\"fast path not-present\\n\");\n                trace_shadow_gen(TRC_SHADOW_FAST_PROPAGATE, va);\n                return 0;\n            }\n#ifdef CONFIG_HVM\n            /* Magic MMIO marker: extract gfn for MMIO address */\n            ASSERT(sh_l1e_is_mmio(sl1e));\n            ASSERT(is_hvm_vcpu(v));\n            gpa = gfn_to_gaddr(sh_l1e_mmio_get_gfn(sl1e)) | (va & ~PAGE_MASK);\n            perfc_incr(shadow_fault_fast_mmio);\n            SHADOW_PRINTK(\"fast path mmio %#\"PRIpaddr\"\\n\", gpa);\n            sh_reset_early_unshadow(v);\n            trace_shadow_gen(TRC_SHADOW_FAST_MMIO, va);\n            return handle_mmio_with_translation(va, gpa >> PAGE_SHIFT, access)\n                   ? EXCRET_fault_fixed : 0;\n#else\n            /* When HVM is not enabled, there shouldn't be MMIO marker */\n            BUG();\n#endif\n        }\n        else\n        {\n            /* This should be exceptionally rare: another vcpu has fixed\n             * the tables between the fault and our reading the l1e.\n             * Retry and let the hardware give us the right fault next time. */\n            perfc_incr(shadow_fault_fast_fail);\n            SHADOW_PRINTK(\"fast path false alarm!\\n\");\n            trace_shadow_gen(TRC_SHADOW_FALSE_FAST_PATH, va);\n            return EXCRET_fault_fixed;\n        }\n    }\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n page_fault_slow_path:\n#endif\n#endif /* SHOPT_FAST_FAULT_PATH */\n\n    /* Detect if this page fault happened while we were already in Xen\n     * doing a shadow operation.  If that happens, the only thing we can\n     * do is let Xen's normal fault handlers try to fix it.  In any case,\n     * a diagnostic trace of the fault will be more useful than\n     * a BUG() when we try to take the lock again. */\n    if ( unlikely(paging_locked_by_me(d)) )\n    {\n        printk(XENLOG_G_ERR \"Recursive shadow fault: lock taken by %s\\n\",\n               d->arch.paging.lock.locker_function);\n        return 0;\n    }\n\n    cpl = is_pv_vcpu(v) ? (regs->ss & 3) : hvm_get_cpl(v);\n\n rewalk:\n\n    error_code = regs->error_code;\n\n    /*\n     * When CR4.SMAP is enabled, instructions which have a side effect of\n     * accessing the system data structures (e.g. mov to %ds accessing the\n     * LDT/GDT, or int $n accessing the IDT) are known as implicit supervisor\n     * accesses.\n     *\n     * The distinction between implicit and explicit accesses form part of the\n     * determination of access rights, controlling whether the access is\n     * successful, or raises a #PF.\n     *\n     * Unfortunately, the processor throws away the implicit/explicit\n     * distinction and does not provide it to the pagefault handler\n     * (i.e. here.) in the #PF error code.  Therefore, we must try to\n     * reconstruct the lost state so it can be fed back into our pagewalk\n     * through the guest tables.\n     *\n     * User mode accesses are easy to reconstruct:\n     *\n     *   If we observe a cpl3 data fetch which was a supervisor walk, this\n     *   must have been an implicit access to a system table.\n     *\n     * Supervisor mode accesses are not easy:\n     *\n     *   In principle, we could decode the instruction under %rip and have the\n     *   instruction emulator tell us if there is an implicit access.\n     *   However, this is racy with other vcpus updating the pagetable or\n     *   rewriting the instruction stream under our feet.\n     *\n     *   Therefore, we do nothing.  (If anyone has a sensible suggestion for\n     *   how to distinguish these cases, xen-devel@ is all ears...)\n     *\n     * As a result, one specific corner case will fail.  If a guest OS with\n     * SMAP enabled ends up mapping a system table with user mappings, sets\n     * EFLAGS.AC to allow explicit accesses to user mappings, and implicitly\n     * accesses the user mapping, hardware and the shadow code will disagree\n     * on whether a #PF should be raised.\n     *\n     * Hardware raises #PF because implicit supervisor accesses to user\n     * mappings are strictly disallowed.  As we can't reconstruct the correct\n     * input, the pagewalk is performed as if it were an explicit access,\n     * which concludes that the access should have succeeded and the shadow\n     * pagetables need modifying.  The shadow pagetables are modified (to the\n     * same value), and we re-enter the guest to re-execute the instruction,\n     * which causes another #PF, and the vcpu livelocks, unable to make\n     * forward progress.\n     *\n     * In practice, this is tolerable.  No production OS will deliberately\n     * construct this corner case (as doing so would mean that a system table\n     * is directly accessable to userspace, and the OS is trivially rootable.)\n     * If this corner case comes about accidentally, then a security-relevant\n     * bug has been tickled.\n     */\n    if ( !(error_code & (PFEC_insn_fetch|PFEC_user_mode)) && cpl == 3 )\n        error_code |= PFEC_implicit;\n\n    /* The walk is done in a lock-free style, with some sanity check\n     * postponed after grabbing paging lock later. Those delayed checks\n     * will make sure no inconsistent mapping being translated into\n     * shadow page table. */\n    version = atomic_read(&d->arch.paging.shadow.gtable_dirty_version);\n    smp_rmb();\n    walk_ok = sh_walk_guest_tables(v, va, &gw, error_code);\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n    regs->error_code &= ~PFEC_page_present;\n    if ( gw.pfec & PFEC_page_present )\n        regs->error_code |= PFEC_page_present;\n#endif\n\n    if ( !walk_ok )\n    {\n        perfc_incr(shadow_fault_bail_real_fault);\n        SHADOW_PRINTK(\"not a shadow fault\\n\");\n        sh_reset_early_unshadow(v);\n        regs->error_code = gw.pfec & PFEC_arch_mask;\n        goto propagate;\n    }\n\n    /* It's possible that the guest has put pagetables in memory that it has\n     * already used for some special purpose (ioreq pages, or granted pages).\n     * If that happens we'll have killed the guest already but it's still not\n     * safe to propagate entries out of the guest PT so get out now. */\n    if ( unlikely(d->is_shutting_down && d->shutdown_code == SHUTDOWN_crash) )\n    {\n        SHADOW_PRINTK(\"guest is shutting down\\n\");\n        goto propagate;\n    }\n\n    /* What mfn is the guest trying to access? */\n    gfn = guest_walk_to_gfn(&gw);\n    gmfn = get_gfn(d, gfn, &p2mt);\n\n    if ( shadow_mode_refcounts(d) &&\n         ((!p2m_is_valid(p2mt) && !p2m_is_grant(p2mt)) ||\n          (!p2m_is_mmio(p2mt) && !mfn_valid(gmfn))) )\n    {\n        perfc_incr(shadow_fault_bail_bad_gfn);\n        SHADOW_PRINTK(\"BAD gfn=%\"SH_PRI_gfn\" gmfn=%\"PRI_mfn\"\\n\",\n                      gfn_x(gfn), mfn_x(gmfn));\n        sh_reset_early_unshadow(v);\n        put_gfn(d, gfn_x(gfn));\n        goto propagate;\n    }\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_VIRTUAL_TLB)\n    /* Remember this successful VA->GFN translation for later. */\n    vtlb_insert(v, va >> PAGE_SHIFT, gfn_x(gfn),\n                regs->error_code | PFEC_page_present);\n#endif /* (SHADOW_OPTIMIZATIONS & SHOPT_VIRTUAL_TLB) */\n\n    paging_lock(d);\n\n    TRACE_CLEAR_PATH_FLAGS;\n\n    /* Make sure there is enough free shadow memory to build a chain of\n     * shadow tables. (We never allocate a top-level shadow on this path,\n     * only a 32b l1, pae l1, or 64b l3+2+1. Note that while\n     * SH_type_l1_shadow isn't correct in the latter case, all page\n     * tables are the same size there.)\n     *\n     * Preallocate shadow pages *before* removing writable accesses\n     * otherwhise an OOS L1 might be demoted and promoted again with\n     * writable mappings. */\n    shadow_prealloc(d,\n                    SH_type_l1_shadow,\n                    GUEST_PAGING_LEVELS < 4 ? 1 : GUEST_PAGING_LEVELS - 1);\n\n    rc = gw_remove_write_accesses(v, va, &gw);\n\n    /* First bit set: Removed write access to a page. */\n    if ( rc & GW_RMWR_FLUSHTLB )\n    {\n        /* Write permission removal is also a hint that other gwalks\n         * overlapping with this one may be inconsistent\n         */\n        perfc_incr(shadow_rm_write_flush_tlb);\n        smp_wmb();\n        atomic_inc(&d->arch.paging.shadow.gtable_dirty_version);\n        flush_tlb_mask(d->dirty_cpumask);\n    }\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n    /* Second bit set: Resynced a page. Re-walk needed. */\n    if ( rc & GW_RMWR_REWALK )\n    {\n        paging_unlock(d);\n        put_gfn(d, gfn_x(gfn));\n        goto rewalk;\n    }\n#endif /* OOS */\n\n    if ( !shadow_check_gwalk(v, va, &gw, version) )\n    {\n        perfc_incr(shadow_inconsistent_gwalk);\n        paging_unlock(d);\n        put_gfn(d, gfn_x(gfn));\n        goto rewalk;\n    }\n\n    shadow_audit_tables(v);\n    sh_audit_gw(v, &gw);\n\n    /* Acquire the shadow.  This must happen before we figure out the rights\n     * for the shadow entry, since we might promote a page here. */\n    ptr_sl1e = shadow_get_and_create_l1e(v, &gw, &sl1mfn, ft);\n    if ( unlikely(ptr_sl1e == NULL) )\n    {\n        /* Couldn't get the sl1e!  Since we know the guest entries\n         * are OK, this can only have been caused by a failed\n         * shadow_set_l*e(), which will have crashed the guest.\n         * Get out of the fault handler immediately. */\n        /* Windows 7 apparently relies on the hardware to do something\n         * it explicitly hasn't promised to do: load l3 values after\n         * the cr3 is loaded.\n         * In any case, in the PAE case, the ASSERT is not true; it can\n         * happen because of actions the guest is taking. */\n#if GUEST_PAGING_LEVELS == 3\n        v->arch.paging.mode->update_cr3(v, 0, false);\n#else\n        ASSERT(d->is_shutting_down);\n#endif\n        paging_unlock(d);\n        put_gfn(d, gfn_x(gfn));\n        trace_shadow_gen(TRC_SHADOW_DOMF_DYING, va);\n        return 0;\n    }\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n    /* Always unsync when writing to L1 page tables. */\n    if ( sh_mfn_is_a_page_table(gmfn)\n         && ft == ft_demand_write )\n        sh_unsync(v, gmfn);\n\n    if ( unlikely(d->is_shutting_down && d->shutdown_code == SHUTDOWN_crash) )\n    {\n        /* We might end up with a crashed domain here if\n         * sh_remove_shadows() in a previous sh_resync() call has\n         * failed. We cannot safely continue since some page is still\n         * OOS but not in the hash table anymore. */\n        paging_unlock(d);\n        put_gfn(d, gfn_x(gfn));\n        return 0;\n    }\n\n    /* Final check: if someone has synced a page, it's possible that\n     * our l1e is stale.  Compare the entries, and rewalk if necessary. */\n    if ( shadow_check_gl1e(v, &gw)  )\n    {\n        perfc_incr(shadow_inconsistent_gwalk);\n        paging_unlock(d);\n        put_gfn(d, gfn_x(gfn));\n        goto rewalk;\n    }\n#endif /* OOS */\n\n    /* Calculate the shadow entry and write it */\n    l1e_propagate_from_guest(v, gw.l1e, gmfn, &sl1e, ft, p2mt);\n    r = shadow_set_l1e(d, ptr_sl1e, sl1e, p2mt, sl1mfn);\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n    if ( mfn_valid(gw.l1mfn)\n         && mfn_is_out_of_sync(gw.l1mfn) )\n    {\n        /* Update the OOS snapshot. */\n        mfn_t snpmfn = oos_snapshot_lookup(d, gw.l1mfn);\n        guest_l1e_t *snp;\n\n        ASSERT(mfn_valid(snpmfn));\n\n        snp = map_domain_page(snpmfn);\n        snp[guest_l1_table_offset(va)] = gw.l1e;\n        unmap_domain_page(snp);\n    }\n#endif /* OOS */\n\n#if SHADOW_OPTIMIZATIONS & SHOPT_PREFETCH\n    /* Prefetch some more shadow entries */\n    sh_prefetch(v, &gw, ptr_sl1e, sl1mfn);\n#endif\n\n    /* Need to emulate accesses to page tables */\n    if ( sh_mfn_is_a_page_table(gmfn)\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n         /* Unless they've been allowed to go out of sync with their\n            shadows and we don't need to unshadow it. */\n         && !(mfn_is_out_of_sync(gmfn)\n              && !(regs->error_code & PFEC_user_mode))\n#endif\n         && (ft == ft_demand_write) )\n    {\n        perfc_incr(shadow_fault_emulate_write);\n        goto emulate;\n    }\n\n    /* Need to hand off device-model MMIO to the device model */\n    if ( p2mt == p2m_mmio_dm )\n    {\n        gpa = guest_walk_to_gpa(&gw);\n        goto mmio;\n    }\n\n    /* Ignore attempts to write to read-only memory. */\n    if ( p2m_is_readonly(p2mt) && (ft == ft_demand_write) )\n    {\n        static unsigned long lastpage;\n        if ( xchg(&lastpage, va & PAGE_MASK) != (va & PAGE_MASK) )\n            gdprintk(XENLOG_DEBUG, \"guest attempted write to read-only memory\"\n                     \" page. va page=%#lx, mfn=%#lx\\n\",\n                     va & PAGE_MASK, mfn_x(gmfn));\n        goto emulate_readonly; /* skip over the instruction */\n    }\n\n    /* In HVM guests, we force CR0.WP always to be set, so that the\n     * pagetables are always write-protected.  If the guest thinks\n     * CR0.WP is clear, we must emulate faulting supervisor writes to\n     * allow the guest to write through read-only PTEs.  Emulate if the\n     * fault was a non-user write to a present page.  */\n    if ( is_hvm_domain(d)\n         && unlikely(!hvm_wp_enabled(v))\n         && regs->error_code == (PFEC_write_access|PFEC_page_present)\n         && mfn_valid(gmfn) )\n    {\n        perfc_incr(shadow_fault_emulate_wp);\n        goto emulate;\n    }\n\n    perfc_incr(shadow_fault_fixed);\n    d->arch.paging.log_dirty.fault_count++;\n    sh_reset_early_unshadow(v);\n\n    trace_shadow_fixup(gw.l1e, va);\n done:\n    sh_audit_gw(v, &gw);\n    SHADOW_PRINTK(\"fixed\\n\");\n    shadow_audit_tables(v);\n    paging_unlock(d);\n    put_gfn(d, gfn_x(gfn));\n    return EXCRET_fault_fixed;\n\n emulate:\n    if ( !shadow_mode_refcounts(d) || !guest_mode(regs) )\n        goto not_a_shadow_fault;\n\n    /*\n     * We do not emulate user writes. Instead we use them as a hint that the\n     * page is no longer a page table. This behaviour differs from native, but\n     * it seems very unlikely that any OS grants user access to page tables.\n     */\n    if ( (regs->error_code & PFEC_user_mode) )\n    {\n        SHADOW_PRINTK(\"user-mode fault to PT, unshadowing mfn %#lx\\n\",\n                      mfn_x(gmfn));\n        perfc_incr(shadow_fault_emulate_failed);\n        sh_remove_shadows(d, gmfn, 0 /* thorough */, 1 /* must succeed */);\n        trace_shadow_emulate_other(TRC_SHADOW_EMULATE_UNSHADOW_USER,\n                                      va, gfn);\n        goto done;\n    }\n\n    /*\n     * Write from userspace to ro-mem needs to jump here to avoid getting\n     * caught by user-mode page-table check above.\n     */\n emulate_readonly:\n\n    /* Unshadow if we are writing to a toplevel pagetable that is\n     * flagged as a dying process, and that is not currently used. */\n    if ( sh_mfn_is_a_page_table(gmfn)\n         && (mfn_to_page(gmfn)->shadow_flags & SHF_pagetable_dying) )\n    {\n        int used = 0;\n        struct vcpu *tmp;\n        for_each_vcpu(d, tmp)\n        {\n#if GUEST_PAGING_LEVELS == 3\n            int i;\n            for ( i = 0; i < 4; i++ )\n            {\n                mfn_t smfn = pagetable_get_mfn(v->arch.shadow_table[i]);\n\n                if ( mfn_valid(smfn) && (mfn_x(smfn) != 0) )\n                {\n                    used |= (mfn_to_page(smfn)->v.sh.back == mfn_x(gmfn));\n\n                    if ( used )\n                        break;\n                }\n            }\n#else /* 32 or 64 */\n            used = mfn_eq(pagetable_get_mfn(tmp->arch.guest_table), gmfn);\n#endif\n            if ( used )\n                break;\n        }\n\n        if ( !used )\n            sh_remove_shadows(d, gmfn, 1 /* fast */, 0 /* can fail */);\n    }\n\n    /*\n     * We don't need to hold the lock for the whole emulation; we will\n     * take it again when we write to the pagetables.\n     */\n    sh_audit_gw(v, &gw);\n    shadow_audit_tables(v);\n    paging_unlock(d);\n    put_gfn(d, gfn_x(gfn));\n\n    this_cpu(trace_emulate_write_val) = 0;\n\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n early_emulation:\n#endif\n    if ( is_hvm_domain(d) )\n    {\n        /*\n         * If we are in the middle of injecting an exception or interrupt then\n         * we should not emulate: it is not the instruction at %eip that caused\n         * the fault. Furthermore it is almost certainly the case the handler\n         * stack is currently considered to be a page table, so we should\n         * unshadow the faulting page before exiting.\n         */\n        if ( unlikely(hvm_event_pending(v)) )\n        {\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n            if ( fast_emul )\n            {\n                perfc_incr(shadow_fault_fast_emulate_fail);\n                v->arch.paging.last_write_emul_ok = 0;\n            }\n#endif\n            gdprintk(XENLOG_DEBUG, \"write to pagetable during event \"\n                     \"injection: cr2=%#lx, mfn=%#lx\\n\",\n                     va, mfn_x(gmfn));\n            sh_remove_shadows(d, gmfn, 0 /* thorough */, 1 /* must succeed */);\n            trace_shadow_emulate_other(TRC_SHADOW_EMULATE_UNSHADOW_EVTINJ,\n                                       va, gfn);\n            return EXCRET_fault_fixed;\n        }\n    }\n\n    SHADOW_PRINTK(\"emulate: eip=%#lx esp=%#lx\\n\", regs->rip, regs->rsp);\n\n    emul_ops = shadow_init_emulation(&emul_ctxt, regs, GUEST_PTE_SIZE);\n\n    r = x86_emulate(&emul_ctxt.ctxt, emul_ops);\n\n#ifdef CONFIG_HVM\n    if ( r == X86EMUL_EXCEPTION )\n    {\n        ASSERT(is_hvm_domain(d));\n        /*\n         * This emulation covers writes to shadow pagetables.  We tolerate #PF\n         * (from accesses spanning pages, concurrent paging updated from\n         * vcpus, etc) and #GP[0]/#SS[0] (from segmentation errors).  Anything\n         * else is an emulation bug, or a guest playing with the instruction\n         * stream under Xen's feet.\n         */\n        if ( emul_ctxt.ctxt.event.type == X86_EVENTTYPE_HW_EXCEPTION &&\n             ((emul_ctxt.ctxt.event.vector == TRAP_page_fault) ||\n              (((emul_ctxt.ctxt.event.vector == TRAP_gp_fault) ||\n                (emul_ctxt.ctxt.event.vector == TRAP_stack_error)) &&\n               emul_ctxt.ctxt.event.error_code == 0)) )\n            hvm_inject_event(&emul_ctxt.ctxt.event);\n        else\n        {\n            SHADOW_PRINTK(\n                \"Unexpected event (type %u, vector %#x) from emulation\\n\",\n                emul_ctxt.ctxt.event.type, emul_ctxt.ctxt.event.vector);\n            r = X86EMUL_UNHANDLEABLE;\n        }\n    }\n#endif\n\n    /*\n     * NB. We do not unshadow on X86EMUL_EXCEPTION. It's not clear that it\n     * would be a good unshadow hint. If we *do* decide to unshadow-on-fault\n     * then it must be 'failable': we cannot require the unshadow to succeed.\n     */\n    if ( r == X86EMUL_UNHANDLEABLE || r == X86EMUL_UNIMPLEMENTED )\n    {\n        perfc_incr(shadow_fault_emulate_failed);\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n        if ( fast_emul )\n        {\n            perfc_incr(shadow_fault_fast_emulate_fail);\n            v->arch.paging.last_write_emul_ok = 0;\n        }\n#endif\n        SHADOW_PRINTK(\"emulator failure (rc=%d), unshadowing mfn %#lx\\n\",\n                       r, mfn_x(gmfn));\n        /* If this is actually a page table, then we have a bug, and need\n         * to support more operations in the emulator.  More likely,\n         * though, this is a hint that this page should not be shadowed. */\n        shadow_remove_all_shadows(d, gmfn);\n\n        trace_shadow_emulate_other(TRC_SHADOW_EMULATE_UNSHADOW_UNHANDLED,\n                                   va, gfn);\n        goto emulate_done;\n    }\n\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n    /* Record successfully emulated information as heuristics to next\n     * fault on same frame for acceleration. But be careful to verify\n     * its attribute still as page table, or else unshadow triggered\n     * in write emulation normally requires a re-sync with guest page\n     * table to recover r/w permission. Incorrect record for such case\n     * will cause unexpected more shadow faults due to propagation is\n     * skipped.\n     */\n    if ( (r == X86EMUL_OKAY) && sh_mfn_is_a_page_table(gmfn) )\n    {\n        if ( !fast_emul )\n        {\n            v->arch.paging.shadow.last_emulated_frame = va >> PAGE_SHIFT;\n            v->arch.paging.shadow.last_emulated_mfn = mfn_x(gmfn);\n            v->arch.paging.last_write_emul_ok = 1;\n        }\n    }\n    else if ( fast_emul )\n        v->arch.paging.last_write_emul_ok = 0;\n#endif\n\n    if ( emul_ctxt.ctxt.retire.singlestep )\n        hvm_inject_hw_exception(TRAP_debug, X86_EVENT_NO_EC);\n\n#if GUEST_PAGING_LEVELS == 3 /* PAE guest */\n    /*\n     * If there are no pending actions, emulate up to four extra instructions\n     * in the hope of catching the \"second half\" of a 64-bit pagetable write.\n     */\n    if ( r == X86EMUL_OKAY && !emul_ctxt.ctxt.retire.raw )\n    {\n        int i, emulation_count=0;\n        this_cpu(trace_emulate_initial_va) = va;\n\n        for ( i = 0 ; i < 4 ; i++ )\n        {\n            shadow_continue_emulation(&emul_ctxt, regs);\n            v->arch.paging.last_write_was_pt = 0;\n            r = x86_emulate(&emul_ctxt.ctxt, emul_ops);\n\n            /*\n             * Only continue the search for the second half if there are no\n             * exceptions or pending actions.  Otherwise, give up and re-enter\n             * the guest.\n             */\n            if ( r == X86EMUL_OKAY && !emul_ctxt.ctxt.retire.raw )\n            {\n                emulation_count++;\n                if ( v->arch.paging.last_write_was_pt )\n                {\n                    perfc_incr(shadow_em_ex_pt);\n                    TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_EMULATION_2ND_PT_WRITTEN);\n                    break; /* Don't emulate past the other half of the write */\n                }\n                else\n                    perfc_incr(shadow_em_ex_non_pt);\n            }\n            else\n            {\n                perfc_incr(shadow_em_ex_fail);\n                TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_EMULATION_LAST_FAILED);\n\n                if ( emul_ctxt.ctxt.retire.singlestep )\n                    hvm_inject_hw_exception(TRAP_debug, X86_EVENT_NO_EC);\n\n                break; /* Don't emulate again if we failed! */\n            }\n        }\n        this_cpu(trace_extra_emulation_count)=emulation_count;\n    }\n#endif /* PAE guest */\n\n    trace_shadow_emulate(gw.l1e, va);\n emulate_done:\n    SHADOW_PRINTK(\"emulated\\n\");\n    return EXCRET_fault_fixed;\n\n mmio:\n    if ( !guest_mode(regs) )\n        goto not_a_shadow_fault;\n#ifdef CONFIG_HVM\n    ASSERT(is_hvm_vcpu(v));\n    perfc_incr(shadow_fault_mmio);\n    sh_audit_gw(v, &gw);\n    SHADOW_PRINTK(\"mmio %#\"PRIpaddr\"\\n\", gpa);\n    shadow_audit_tables(v);\n    sh_reset_early_unshadow(v);\n    paging_unlock(d);\n    put_gfn(d, gfn_x(gfn));\n    trace_shadow_gen(TRC_SHADOW_MMIO, va);\n    return (handle_mmio_with_translation(va, gpa >> PAGE_SHIFT, access)\n            ? EXCRET_fault_fixed : 0);\n#else\n    BUG();\n#endif\n\n not_a_shadow_fault:\n    sh_audit_gw(v, &gw);\n    SHADOW_PRINTK(\"not a shadow fault\\n\");\n    shadow_audit_tables(v);\n    sh_reset_early_unshadow(v);\n    paging_unlock(d);\n    put_gfn(d, gfn_x(gfn));\n\npropagate:\n    trace_not_shadow_fault(gw.l1e, va);\n\n    return 0;\n}",
        "func_after": "static int sh_page_fault(struct vcpu *v,\n                          unsigned long va,\n                          struct cpu_user_regs *regs)\n{\n    struct domain *d = v->domain;\n    walk_t gw;\n    gfn_t gfn = _gfn(0);\n    mfn_t gmfn, sl1mfn = _mfn(0);\n    shadow_l1e_t sl1e, *ptr_sl1e;\n    paddr_t gpa;\n    struct sh_emulate_ctxt emul_ctxt;\n    const struct x86_emulate_ops *emul_ops;\n    int r;\n    p2m_type_t p2mt;\n    uint32_t rc, error_code;\n    bool walk_ok;\n    int version;\n    unsigned int cpl;\n    const struct npfec access = {\n         .read_access = 1,\n         .write_access = !!(regs->error_code & PFEC_write_access),\n         .gla_valid = 1,\n         .kind = npfec_kind_with_gla\n    };\n    const fetch_type_t ft =\n        access.write_access ? ft_demand_write : ft_demand_read;\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n    int fast_emul = 0;\n#endif\n\n    SHADOW_PRINTK(\"%pv va=%#lx err=%#x, rip=%lx\\n\",\n                  v, va, regs->error_code, regs->rip);\n\n    perfc_incr(shadow_fault);\n\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n    /* If faulting frame is successfully emulated in last shadow fault\n     * it's highly likely to reach same emulation action for this frame.\n     * Then try to emulate early to avoid lock aquisition.\n     */\n    if ( v->arch.paging.last_write_emul_ok\n         && v->arch.paging.shadow.last_emulated_frame == (va >> PAGE_SHIFT) )\n    {\n        /* check whether error code is 3, or else fall back to normal path\n         * in case of some validation is required\n         */\n        if ( regs->error_code == (PFEC_write_access | PFEC_page_present) )\n        {\n            fast_emul = 1;\n            gmfn = _mfn(v->arch.paging.shadow.last_emulated_mfn);\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n            /* Fall back to the slow path if we're trying to emulate\n               writes to an out of sync page. */\n            if ( mfn_valid(gmfn) && mfn_is_out_of_sync(gmfn) )\n            {\n                fast_emul = 0;\n                v->arch.paging.last_write_emul_ok = 0;\n                goto page_fault_slow_path;\n            }\n#endif /* OOS */\n\n            perfc_incr(shadow_fault_fast_emulate);\n            goto early_emulation;\n        }\n        else\n            v->arch.paging.last_write_emul_ok = 0;\n    }\n#endif\n\n    //\n    // XXX: Need to think about eventually mapping superpages directly in the\n    //      shadow (when possible), as opposed to splintering them into a\n    //      bunch of 4K maps.\n    //\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_FAST_FAULT_PATH)\n    if ( (regs->error_code & PFEC_reserved_bit) )\n    {\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n        /* First, need to check that this isn't an out-of-sync\n         * shadow l1e.  If it is, we fall back to the slow path, which\n         * will sync it up again. */\n        {\n            shadow_l2e_t sl2e;\n            mfn_t gl1mfn;\n            if ( (__copy_from_user(&sl2e,\n                                   (sh_linear_l2_table(v)\n                                    + shadow_l2_linear_offset(va)),\n                                   sizeof(sl2e)) != 0)\n                 || !(shadow_l2e_get_flags(sl2e) & _PAGE_PRESENT)\n                 || !mfn_valid(gl1mfn = backpointer(mfn_to_page(\n                                  shadow_l2e_get_mfn(sl2e))))\n                 || unlikely(mfn_is_out_of_sync(gl1mfn)) )\n            {\n                /* Hit the slow path as if there had been no\n                 * shadow entry at all, and let it tidy up */\n                ASSERT(regs->error_code & PFEC_page_present);\n                regs->error_code ^= (PFEC_reserved_bit|PFEC_page_present);\n                goto page_fault_slow_path;\n            }\n        }\n#endif /* SHOPT_OUT_OF_SYNC */\n        /* The only reasons for reserved bits to be set in shadow entries\n         * are the two \"magic\" shadow_l1e entries. */\n        if ( likely((__copy_from_user(&sl1e,\n                                      (sh_linear_l1_table(v)\n                                       + shadow_l1_linear_offset(va)),\n                                      sizeof(sl1e)) == 0)\n                    && sh_l1e_is_magic(sl1e)) )\n        {\n\n            if ( sh_l1e_is_gnp(sl1e) )\n            {\n                /* Not-present in a guest PT: pass to the guest as\n                 * a not-present fault (by flipping two bits). */\n                ASSERT(regs->error_code & PFEC_page_present);\n                regs->error_code ^= (PFEC_reserved_bit|PFEC_page_present);\n                sh_reset_early_unshadow(v);\n                perfc_incr(shadow_fault_fast_gnp);\n                SHADOW_PRINTK(\"fast path not-present\\n\");\n                trace_shadow_gen(TRC_SHADOW_FAST_PROPAGATE, va);\n                return 0;\n            }\n#ifdef CONFIG_HVM\n            /* Magic MMIO marker: extract gfn for MMIO address */\n            ASSERT(sh_l1e_is_mmio(sl1e));\n            ASSERT(is_hvm_vcpu(v));\n            gpa = gfn_to_gaddr(sh_l1e_mmio_get_gfn(sl1e)) | (va & ~PAGE_MASK);\n            perfc_incr(shadow_fault_fast_mmio);\n            SHADOW_PRINTK(\"fast path mmio %#\"PRIpaddr\"\\n\", gpa);\n            sh_reset_early_unshadow(v);\n            trace_shadow_gen(TRC_SHADOW_FAST_MMIO, va);\n            return handle_mmio_with_translation(va, gpa >> PAGE_SHIFT, access)\n                   ? EXCRET_fault_fixed : 0;\n#else\n            /* When HVM is not enabled, there shouldn't be MMIO marker */\n            BUG();\n#endif\n        }\n        else\n        {\n            /* This should be exceptionally rare: another vcpu has fixed\n             * the tables between the fault and our reading the l1e.\n             * Retry and let the hardware give us the right fault next time. */\n            perfc_incr(shadow_fault_fast_fail);\n            SHADOW_PRINTK(\"fast path false alarm!\\n\");\n            trace_shadow_gen(TRC_SHADOW_FALSE_FAST_PATH, va);\n            return EXCRET_fault_fixed;\n        }\n    }\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n page_fault_slow_path:\n#endif\n#endif /* SHOPT_FAST_FAULT_PATH */\n\n    /* Detect if this page fault happened while we were already in Xen\n     * doing a shadow operation.  If that happens, the only thing we can\n     * do is let Xen's normal fault handlers try to fix it.  In any case,\n     * a diagnostic trace of the fault will be more useful than\n     * a BUG() when we try to take the lock again. */\n    if ( unlikely(paging_locked_by_me(d)) )\n    {\n        printk(XENLOG_G_ERR \"Recursive shadow fault: lock taken by %s\\n\",\n               d->arch.paging.lock.locker_function);\n        return 0;\n    }\n\n    cpl = is_pv_vcpu(v) ? (regs->ss & 3) : hvm_get_cpl(v);\n\n rewalk:\n\n    error_code = regs->error_code;\n\n    /*\n     * When CR4.SMAP is enabled, instructions which have a side effect of\n     * accessing the system data structures (e.g. mov to %ds accessing the\n     * LDT/GDT, or int $n accessing the IDT) are known as implicit supervisor\n     * accesses.\n     *\n     * The distinction between implicit and explicit accesses form part of the\n     * determination of access rights, controlling whether the access is\n     * successful, or raises a #PF.\n     *\n     * Unfortunately, the processor throws away the implicit/explicit\n     * distinction and does not provide it to the pagefault handler\n     * (i.e. here.) in the #PF error code.  Therefore, we must try to\n     * reconstruct the lost state so it can be fed back into our pagewalk\n     * through the guest tables.\n     *\n     * User mode accesses are easy to reconstruct:\n     *\n     *   If we observe a cpl3 data fetch which was a supervisor walk, this\n     *   must have been an implicit access to a system table.\n     *\n     * Supervisor mode accesses are not easy:\n     *\n     *   In principle, we could decode the instruction under %rip and have the\n     *   instruction emulator tell us if there is an implicit access.\n     *   However, this is racy with other vcpus updating the pagetable or\n     *   rewriting the instruction stream under our feet.\n     *\n     *   Therefore, we do nothing.  (If anyone has a sensible suggestion for\n     *   how to distinguish these cases, xen-devel@ is all ears...)\n     *\n     * As a result, one specific corner case will fail.  If a guest OS with\n     * SMAP enabled ends up mapping a system table with user mappings, sets\n     * EFLAGS.AC to allow explicit accesses to user mappings, and implicitly\n     * accesses the user mapping, hardware and the shadow code will disagree\n     * on whether a #PF should be raised.\n     *\n     * Hardware raises #PF because implicit supervisor accesses to user\n     * mappings are strictly disallowed.  As we can't reconstruct the correct\n     * input, the pagewalk is performed as if it were an explicit access,\n     * which concludes that the access should have succeeded and the shadow\n     * pagetables need modifying.  The shadow pagetables are modified (to the\n     * same value), and we re-enter the guest to re-execute the instruction,\n     * which causes another #PF, and the vcpu livelocks, unable to make\n     * forward progress.\n     *\n     * In practice, this is tolerable.  No production OS will deliberately\n     * construct this corner case (as doing so would mean that a system table\n     * is directly accessable to userspace, and the OS is trivially rootable.)\n     * If this corner case comes about accidentally, then a security-relevant\n     * bug has been tickled.\n     */\n    if ( !(error_code & (PFEC_insn_fetch|PFEC_user_mode)) && cpl == 3 )\n        error_code |= PFEC_implicit;\n\n    /* The walk is done in a lock-free style, with some sanity check\n     * postponed after grabbing paging lock later. Those delayed checks\n     * will make sure no inconsistent mapping being translated into\n     * shadow page table. */\n    version = atomic_read(&d->arch.paging.shadow.gtable_dirty_version);\n    smp_rmb();\n    walk_ok = sh_walk_guest_tables(v, va, &gw, error_code);\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n    regs->error_code &= ~PFEC_page_present;\n    if ( gw.pfec & PFEC_page_present )\n        regs->error_code |= PFEC_page_present;\n#endif\n\n    if ( !walk_ok )\n    {\n        perfc_incr(shadow_fault_bail_real_fault);\n        SHADOW_PRINTK(\"not a shadow fault\\n\");\n        sh_reset_early_unshadow(v);\n        regs->error_code = gw.pfec & PFEC_arch_mask;\n        goto propagate;\n    }\n\n    /* It's possible that the guest has put pagetables in memory that it has\n     * already used for some special purpose (ioreq pages, or granted pages).\n     * If that happens we'll have killed the guest already but it's still not\n     * safe to propagate entries out of the guest PT so get out now. */\n    if ( unlikely(d->is_shutting_down && d->shutdown_code == SHUTDOWN_crash) )\n    {\n        SHADOW_PRINTK(\"guest is shutting down\\n\");\n        goto propagate;\n    }\n\n    /* What mfn is the guest trying to access? */\n    gfn = guest_walk_to_gfn(&gw);\n    gmfn = get_gfn(d, gfn, &p2mt);\n\n    if ( shadow_mode_refcounts(d) &&\n         ((!p2m_is_valid(p2mt) && !p2m_is_grant(p2mt)) ||\n          (!p2m_is_mmio(p2mt) && !mfn_valid(gmfn))) )\n    {\n        perfc_incr(shadow_fault_bail_bad_gfn);\n        SHADOW_PRINTK(\"BAD gfn=%\"SH_PRI_gfn\" gmfn=%\"PRI_mfn\"\\n\",\n                      gfn_x(gfn), mfn_x(gmfn));\n        sh_reset_early_unshadow(v);\n        put_gfn(d, gfn_x(gfn));\n        goto propagate;\n    }\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_VIRTUAL_TLB)\n    /* Remember this successful VA->GFN translation for later. */\n    vtlb_insert(v, va >> PAGE_SHIFT, gfn_x(gfn),\n                regs->error_code | PFEC_page_present);\n#endif /* (SHADOW_OPTIMIZATIONS & SHOPT_VIRTUAL_TLB) */\n\n    paging_lock(d);\n\n    TRACE_CLEAR_PATH_FLAGS;\n\n    /* Make sure there is enough free shadow memory to build a chain of\n     * shadow tables. (We never allocate a top-level shadow on this path,\n     * only a 32b l1, pae l1, or 64b l3+2+1. Note that while\n     * SH_type_l1_shadow isn't correct in the latter case, all page\n     * tables are the same size there.)\n     *\n     * Preallocate shadow pages *before* removing writable accesses\n     * otherwhise an OOS L1 might be demoted and promoted again with\n     * writable mappings. */\n    shadow_prealloc(d,\n                    SH_type_l1_shadow,\n                    GUEST_PAGING_LEVELS < 4 ? 1 : GUEST_PAGING_LEVELS - 1);\n\n    rc = gw_remove_write_accesses(v, va, &gw);\n\n    /* First bit set: Removed write access to a page. */\n    if ( rc & GW_RMWR_FLUSHTLB )\n    {\n        /* Write permission removal is also a hint that other gwalks\n         * overlapping with this one may be inconsistent\n         */\n        perfc_incr(shadow_rm_write_flush_tlb);\n        smp_wmb();\n        atomic_inc(&d->arch.paging.shadow.gtable_dirty_version);\n        flush_tlb_mask(d->dirty_cpumask);\n    }\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n    /* Second bit set: Resynced a page. Re-walk needed. */\n    if ( rc & GW_RMWR_REWALK )\n    {\n        paging_unlock(d);\n        put_gfn(d, gfn_x(gfn));\n        goto rewalk;\n    }\n#endif /* OOS */\n\n    if ( !shadow_check_gwalk(v, va, &gw, version) )\n    {\n        perfc_incr(shadow_inconsistent_gwalk);\n        paging_unlock(d);\n        put_gfn(d, gfn_x(gfn));\n        goto rewalk;\n    }\n\n    shadow_audit_tables(v);\n    sh_audit_gw(v, &gw);\n\n    /* Acquire the shadow.  This must happen before we figure out the rights\n     * for the shadow entry, since we might promote a page here. */\n    ptr_sl1e = shadow_get_and_create_l1e(v, &gw, &sl1mfn, ft);\n    if ( unlikely(ptr_sl1e == NULL) )\n    {\n        /* Couldn't get the sl1e!  Since we know the guest entries\n         * are OK, this can only have been caused by a failed\n         * shadow_set_l*e(), which will have crashed the guest.\n         * Get out of the fault handler immediately. */\n        /* Windows 7 apparently relies on the hardware to do something\n         * it explicitly hasn't promised to do: load l3 values after\n         * the cr3 is loaded.\n         * In any case, in the PAE case, the ASSERT is not true; it can\n         * happen because of actions the guest is taking. */\n#if GUEST_PAGING_LEVELS == 3\n        v->arch.paging.mode->update_cr3(v, 0, false);\n#else\n        ASSERT(d->is_shutting_down);\n#endif\n        paging_unlock(d);\n        put_gfn(d, gfn_x(gfn));\n        trace_shadow_gen(TRC_SHADOW_DOMF_DYING, va);\n        return 0;\n    }\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n    /* Always unsync when writing to L1 page tables. */\n    if ( sh_mfn_is_a_page_table(gmfn)\n         && ft == ft_demand_write )\n        sh_unsync(v, gmfn);\n\n    if ( unlikely(d->is_shutting_down && d->shutdown_code == SHUTDOWN_crash) )\n    {\n        /* We might end up with a crashed domain here if\n         * sh_remove_shadows() in a previous sh_resync() call has\n         * failed. We cannot safely continue since some page is still\n         * OOS but not in the hash table anymore. */\n        paging_unlock(d);\n        put_gfn(d, gfn_x(gfn));\n        return 0;\n    }\n\n    /* Final check: if someone has synced a page, it's possible that\n     * our l1e is stale.  Compare the entries, and rewalk if necessary. */\n    if ( shadow_check_gl1e(v, &gw)  )\n    {\n        perfc_incr(shadow_inconsistent_gwalk);\n        paging_unlock(d);\n        put_gfn(d, gfn_x(gfn));\n        goto rewalk;\n    }\n#endif /* OOS */\n\n    /* Calculate the shadow entry and write it */\n    l1e_propagate_from_guest(v, gw.l1e, gmfn, &sl1e, ft, p2mt);\n    r = shadow_set_l1e(d, ptr_sl1e, sl1e, p2mt, sl1mfn);\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n    if ( mfn_valid(gw.l1mfn)\n         && mfn_is_out_of_sync(gw.l1mfn) )\n    {\n        /* Update the OOS snapshot. */\n        mfn_t snpmfn = oos_snapshot_lookup(d, gw.l1mfn);\n        guest_l1e_t *snp;\n\n        ASSERT(mfn_valid(snpmfn));\n\n        snp = map_domain_page(snpmfn);\n        snp[guest_l1_table_offset(va)] = gw.l1e;\n        unmap_domain_page(snp);\n    }\n#endif /* OOS */\n\n#if SHADOW_OPTIMIZATIONS & SHOPT_PREFETCH\n    /* Prefetch some more shadow entries */\n    sh_prefetch(v, &gw, ptr_sl1e, sl1mfn);\n#endif\n\n    /* Need to emulate accesses to page tables */\n    if ( sh_mfn_is_a_page_table(gmfn)\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n         /* Unless they've been allowed to go out of sync with their\n            shadows and we don't need to unshadow it. */\n         && !(mfn_is_out_of_sync(gmfn)\n              && !(regs->error_code & PFEC_user_mode))\n#endif\n         && (ft == ft_demand_write) )\n    {\n        perfc_incr(shadow_fault_emulate_write);\n        goto emulate;\n    }\n\n    /* Need to hand off device-model MMIO to the device model */\n    if ( p2mt == p2m_mmio_dm )\n    {\n        gpa = guest_walk_to_gpa(&gw);\n        goto mmio;\n    }\n\n    /* Ignore attempts to write to read-only memory. */\n    if ( p2m_is_readonly(p2mt) && (ft == ft_demand_write) )\n    {\n        static unsigned long lastpage;\n        if ( xchg(&lastpage, va & PAGE_MASK) != (va & PAGE_MASK) )\n            gdprintk(XENLOG_DEBUG, \"guest attempted write to read-only memory\"\n                     \" page. va page=%#lx, mfn=%#lx\\n\",\n                     va & PAGE_MASK, mfn_x(gmfn));\n        goto emulate_readonly; /* skip over the instruction */\n    }\n\n    /* In HVM guests, we force CR0.WP always to be set, so that the\n     * pagetables are always write-protected.  If the guest thinks\n     * CR0.WP is clear, we must emulate faulting supervisor writes to\n     * allow the guest to write through read-only PTEs.  Emulate if the\n     * fault was a non-user write to a present page.  */\n    if ( is_hvm_domain(d)\n         && unlikely(!hvm_wp_enabled(v))\n         && regs->error_code == (PFEC_write_access|PFEC_page_present)\n         && mfn_valid(gmfn) )\n    {\n        perfc_incr(shadow_fault_emulate_wp);\n        goto emulate;\n    }\n\n    perfc_incr(shadow_fault_fixed);\n    d->arch.paging.log_dirty.fault_count++;\n    sh_reset_early_unshadow(v);\n\n    trace_shadow_fixup(gw.l1e, va);\n done:\n    sh_audit_gw(v, &gw);\n    SHADOW_PRINTK(\"fixed\\n\");\n    shadow_audit_tables(v);\n    paging_unlock(d);\n    put_gfn(d, gfn_x(gfn));\n    return EXCRET_fault_fixed;\n\n emulate:\n    if ( !shadow_mode_refcounts(d) || !guest_mode(regs) )\n        goto not_a_shadow_fault;\n\n    /*\n     * We do not emulate user writes. Instead we use them as a hint that the\n     * page is no longer a page table. This behaviour differs from native, but\n     * it seems very unlikely that any OS grants user access to page tables.\n     */\n    if ( (regs->error_code & PFEC_user_mode) )\n    {\n        SHADOW_PRINTK(\"user-mode fault to PT, unshadowing mfn %#lx\\n\",\n                      mfn_x(gmfn));\n        perfc_incr(shadow_fault_emulate_failed);\n        sh_remove_shadows(d, gmfn, 0 /* thorough */, 1 /* must succeed */);\n        trace_shadow_emulate_other(TRC_SHADOW_EMULATE_UNSHADOW_USER,\n                                      va, gfn);\n        goto done;\n    }\n\n    /*\n     * Write from userspace to ro-mem needs to jump here to avoid getting\n     * caught by user-mode page-table check above.\n     */\n emulate_readonly:\n\n    /* Unshadow if we are writing to a toplevel pagetable that is\n     * flagged as a dying process, and that is not currently used. */\n    if ( sh_mfn_is_a_page_table(gmfn) && is_hvm_domain(d) &&\n         mfn_to_page(gmfn)->pagetable_dying )\n    {\n        int used = 0;\n        struct vcpu *tmp;\n        for_each_vcpu(d, tmp)\n        {\n#if GUEST_PAGING_LEVELS == 3\n            int i;\n            for ( i = 0; i < 4; i++ )\n            {\n                mfn_t smfn = pagetable_get_mfn(v->arch.shadow_table[i]);\n\n                if ( mfn_valid(smfn) && (mfn_x(smfn) != 0) )\n                {\n                    used |= (mfn_to_page(smfn)->v.sh.back == mfn_x(gmfn));\n\n                    if ( used )\n                        break;\n                }\n            }\n#else /* 32 or 64 */\n            used = mfn_eq(pagetable_get_mfn(tmp->arch.guest_table), gmfn);\n#endif\n            if ( used )\n                break;\n        }\n\n        if ( !used )\n            sh_remove_shadows(d, gmfn, 1 /* fast */, 0 /* can fail */);\n    }\n\n    /*\n     * We don't need to hold the lock for the whole emulation; we will\n     * take it again when we write to the pagetables.\n     */\n    sh_audit_gw(v, &gw);\n    shadow_audit_tables(v);\n    paging_unlock(d);\n    put_gfn(d, gfn_x(gfn));\n\n    this_cpu(trace_emulate_write_val) = 0;\n\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n early_emulation:\n#endif\n    if ( is_hvm_domain(d) )\n    {\n        /*\n         * If we are in the middle of injecting an exception or interrupt then\n         * we should not emulate: it is not the instruction at %eip that caused\n         * the fault. Furthermore it is almost certainly the case the handler\n         * stack is currently considered to be a page table, so we should\n         * unshadow the faulting page before exiting.\n         */\n        if ( unlikely(hvm_event_pending(v)) )\n        {\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n            if ( fast_emul )\n            {\n                perfc_incr(shadow_fault_fast_emulate_fail);\n                v->arch.paging.last_write_emul_ok = 0;\n            }\n#endif\n            gdprintk(XENLOG_DEBUG, \"write to pagetable during event \"\n                     \"injection: cr2=%#lx, mfn=%#lx\\n\",\n                     va, mfn_x(gmfn));\n            sh_remove_shadows(d, gmfn, 0 /* thorough */, 1 /* must succeed */);\n            trace_shadow_emulate_other(TRC_SHADOW_EMULATE_UNSHADOW_EVTINJ,\n                                       va, gfn);\n            return EXCRET_fault_fixed;\n        }\n    }\n\n    SHADOW_PRINTK(\"emulate: eip=%#lx esp=%#lx\\n\", regs->rip, regs->rsp);\n\n    emul_ops = shadow_init_emulation(&emul_ctxt, regs, GUEST_PTE_SIZE);\n\n    r = x86_emulate(&emul_ctxt.ctxt, emul_ops);\n\n#ifdef CONFIG_HVM\n    if ( r == X86EMUL_EXCEPTION )\n    {\n        ASSERT(is_hvm_domain(d));\n        /*\n         * This emulation covers writes to shadow pagetables.  We tolerate #PF\n         * (from accesses spanning pages, concurrent paging updated from\n         * vcpus, etc) and #GP[0]/#SS[0] (from segmentation errors).  Anything\n         * else is an emulation bug, or a guest playing with the instruction\n         * stream under Xen's feet.\n         */\n        if ( emul_ctxt.ctxt.event.type == X86_EVENTTYPE_HW_EXCEPTION &&\n             ((emul_ctxt.ctxt.event.vector == TRAP_page_fault) ||\n              (((emul_ctxt.ctxt.event.vector == TRAP_gp_fault) ||\n                (emul_ctxt.ctxt.event.vector == TRAP_stack_error)) &&\n               emul_ctxt.ctxt.event.error_code == 0)) )\n            hvm_inject_event(&emul_ctxt.ctxt.event);\n        else\n        {\n            SHADOW_PRINTK(\n                \"Unexpected event (type %u, vector %#x) from emulation\\n\",\n                emul_ctxt.ctxt.event.type, emul_ctxt.ctxt.event.vector);\n            r = X86EMUL_UNHANDLEABLE;\n        }\n    }\n#endif\n\n    /*\n     * NB. We do not unshadow on X86EMUL_EXCEPTION. It's not clear that it\n     * would be a good unshadow hint. If we *do* decide to unshadow-on-fault\n     * then it must be 'failable': we cannot require the unshadow to succeed.\n     */\n    if ( r == X86EMUL_UNHANDLEABLE || r == X86EMUL_UNIMPLEMENTED )\n    {\n        perfc_incr(shadow_fault_emulate_failed);\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n        if ( fast_emul )\n        {\n            perfc_incr(shadow_fault_fast_emulate_fail);\n            v->arch.paging.last_write_emul_ok = 0;\n        }\n#endif\n        SHADOW_PRINTK(\"emulator failure (rc=%d), unshadowing mfn %#lx\\n\",\n                       r, mfn_x(gmfn));\n        /* If this is actually a page table, then we have a bug, and need\n         * to support more operations in the emulator.  More likely,\n         * though, this is a hint that this page should not be shadowed. */\n        shadow_remove_all_shadows(d, gmfn);\n\n        trace_shadow_emulate_other(TRC_SHADOW_EMULATE_UNSHADOW_UNHANDLED,\n                                   va, gfn);\n        goto emulate_done;\n    }\n\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n    /* Record successfully emulated information as heuristics to next\n     * fault on same frame for acceleration. But be careful to verify\n     * its attribute still as page table, or else unshadow triggered\n     * in write emulation normally requires a re-sync with guest page\n     * table to recover r/w permission. Incorrect record for such case\n     * will cause unexpected more shadow faults due to propagation is\n     * skipped.\n     */\n    if ( (r == X86EMUL_OKAY) && sh_mfn_is_a_page_table(gmfn) )\n    {\n        if ( !fast_emul )\n        {\n            v->arch.paging.shadow.last_emulated_frame = va >> PAGE_SHIFT;\n            v->arch.paging.shadow.last_emulated_mfn = mfn_x(gmfn);\n            v->arch.paging.last_write_emul_ok = 1;\n        }\n    }\n    else if ( fast_emul )\n        v->arch.paging.last_write_emul_ok = 0;\n#endif\n\n    if ( emul_ctxt.ctxt.retire.singlestep )\n        hvm_inject_hw_exception(TRAP_debug, X86_EVENT_NO_EC);\n\n#if GUEST_PAGING_LEVELS == 3 /* PAE guest */\n    /*\n     * If there are no pending actions, emulate up to four extra instructions\n     * in the hope of catching the \"second half\" of a 64-bit pagetable write.\n     */\n    if ( r == X86EMUL_OKAY && !emul_ctxt.ctxt.retire.raw )\n    {\n        int i, emulation_count=0;\n        this_cpu(trace_emulate_initial_va) = va;\n\n        for ( i = 0 ; i < 4 ; i++ )\n        {\n            shadow_continue_emulation(&emul_ctxt, regs);\n            v->arch.paging.last_write_was_pt = 0;\n            r = x86_emulate(&emul_ctxt.ctxt, emul_ops);\n\n            /*\n             * Only continue the search for the second half if there are no\n             * exceptions or pending actions.  Otherwise, give up and re-enter\n             * the guest.\n             */\n            if ( r == X86EMUL_OKAY && !emul_ctxt.ctxt.retire.raw )\n            {\n                emulation_count++;\n                if ( v->arch.paging.last_write_was_pt )\n                {\n                    perfc_incr(shadow_em_ex_pt);\n                    TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_EMULATION_2ND_PT_WRITTEN);\n                    break; /* Don't emulate past the other half of the write */\n                }\n                else\n                    perfc_incr(shadow_em_ex_non_pt);\n            }\n            else\n            {\n                perfc_incr(shadow_em_ex_fail);\n                TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_EMULATION_LAST_FAILED);\n\n                if ( emul_ctxt.ctxt.retire.singlestep )\n                    hvm_inject_hw_exception(TRAP_debug, X86_EVENT_NO_EC);\n\n                break; /* Don't emulate again if we failed! */\n            }\n        }\n        this_cpu(trace_extra_emulation_count)=emulation_count;\n    }\n#endif /* PAE guest */\n\n    trace_shadow_emulate(gw.l1e, va);\n emulate_done:\n    SHADOW_PRINTK(\"emulated\\n\");\n    return EXCRET_fault_fixed;\n\n mmio:\n    if ( !guest_mode(regs) )\n        goto not_a_shadow_fault;\n#ifdef CONFIG_HVM\n    ASSERT(is_hvm_vcpu(v));\n    perfc_incr(shadow_fault_mmio);\n    sh_audit_gw(v, &gw);\n    SHADOW_PRINTK(\"mmio %#\"PRIpaddr\"\\n\", gpa);\n    shadow_audit_tables(v);\n    sh_reset_early_unshadow(v);\n    paging_unlock(d);\n    put_gfn(d, gfn_x(gfn));\n    trace_shadow_gen(TRC_SHADOW_MMIO, va);\n    return (handle_mmio_with_translation(va, gpa >> PAGE_SHIFT, access)\n            ? EXCRET_fault_fixed : 0);\n#else\n    BUG();\n#endif\n\n not_a_shadow_fault:\n    sh_audit_gw(v, &gw);\n    SHADOW_PRINTK(\"not a shadow fault\\n\");\n    shadow_audit_tables(v);\n    sh_reset_early_unshadow(v);\n    paging_unlock(d);\n    put_gfn(d, gfn_x(gfn));\n\npropagate:\n    trace_not_shadow_fault(gw.l1e, va);\n\n    return 0;\n}",
        "description": "An issue was discovered in Xen versions up to 4.11.x, where x86 PV guest OS users could potentially cause a denial of service (host OS crash) or escalate their privileges to those of the host OS due to an interpretation conflict involving a union data structure related to shadow paging. This problem arose from an incorrect fix applied to address CVE-2017-15595.",
        "commit": "The vulnerability involves modifying the `struct page_info` in the x86/shadow module by reducing the size of the `shadow_flags` field to 16 bits to prevent overlap with the `linear_pt_count` field used in PV domains. To address this change, a new, HVM-only field named `pagetable_dying` was introduced to handle the functionality previously managed by the upper 16 bits of `shadow_flags`. The accesses to `shadow_flags` in functions like `shadow_{pro,de}mote()` were changed to non-atomic, non-bitops operations because atomic operations such as `{test,set,clear}_bit()` are not supported on `uint16_t` fields. This modification is justified by the fact that all updates to `shadow_flags` should occur while holding the paging lock, and other updates use bitwise operations (`|=`, `&=`), which inherently provide some level of atomicity. This change is part of the XSA-280 patch set."
    }
]