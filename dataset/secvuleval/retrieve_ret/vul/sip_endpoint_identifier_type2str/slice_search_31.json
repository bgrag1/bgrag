[
    {
        "cwe": "CWE-346",
        "func_name": "hotplug/udev_monitor_receive_device",
        "score": 0.779789388179779,
        "func_before": "struct udev_device *udev_monitor_receive_device(struct udev_monitor *udev_monitor)\n{\n\tstruct udev_device *udev_device;\n\tstruct msghdr smsg;\n\tstruct iovec iov;\n\tchar cred_msg[CMSG_SPACE(sizeof(struct ucred))];\n\tchar buf[4096];\n\tsize_t bufpos;\n\tint devpath_set = 0;\n\tint subsystem_set = 0;\n\tint action_set = 0;\n\tint maj = 0;\n\tint min = 0;\n\n\tif (udev_monitor == NULL)\n\t\treturn NULL;\n\tmemset(buf, 0x00, sizeof(buf));\n\tiov.iov_base = &buf;\n\tiov.iov_len = sizeof(buf);\n\tmemset (&smsg, 0x00, sizeof(struct msghdr));\n\tsmsg.msg_iov = &iov;\n\tsmsg.msg_iovlen = 1;\n\tsmsg.msg_control = cred_msg;\n\tsmsg.msg_controllen = sizeof(cred_msg);\n\n\tif (recvmsg(udev_monitor->sock, &smsg, 0) < 0) {\n\t\tif (errno != EINTR)\n\t\t\tinfo(udev_monitor->udev, \"unable to receive message\");\n\t\treturn NULL;\n\t}\n\n\tif (udev_monitor->sun.sun_family != 0) {\n\t\tstruct cmsghdr *cmsg = CMSG_FIRSTHDR(&smsg);\n\t\tstruct ucred *cred = (struct ucred *)CMSG_DATA (cmsg);\n\n\t\tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {\n\t\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (cred->uid != 0) {\n\t\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* skip header */\n\tbufpos = strlen(buf) + 1;\n\tif (bufpos < sizeof(\"a@/d\") || bufpos >= sizeof(buf)) {\n\t\tinfo(udev_monitor->udev, \"invalid message length\");\n\t\treturn NULL;\n\t}\n\n\t/* check message header */\n\tif (strstr(buf, \"@/\") == NULL) {\n\t\tinfo(udev_monitor->udev, \"unrecognized message header\");\n\t\treturn NULL;\n\t}\n\n\tudev_device = device_new(udev_monitor->udev);\n\tif (udev_device == NULL) {\n\t\treturn NULL;\n\t}\n\n\twhile (bufpos < sizeof(buf)) {\n\t\tchar *key;\n\t\tsize_t keylen;\n\n\t\tkey = &buf[bufpos];\n\t\tkeylen = strlen(key);\n\t\tif (keylen == 0)\n\t\t\tbreak;\n\t\tbufpos += keylen + 1;\n\n\t\tif (strncmp(key, \"DEVPATH=\", 8) == 0) {\n\t\t\tchar path[UTIL_PATH_SIZE];\n\n\t\t\tutil_strlcpy(path, udev_get_sys_path(udev_monitor->udev), sizeof(path));\n\t\t\tutil_strlcat(path, &key[8], sizeof(path));\n\t\t\tudev_device_set_syspath(udev_device, path);\n\t\t\tdevpath_set = 1;\n\t\t} else if (strncmp(key, \"SUBSYSTEM=\", 10) == 0) {\n\t\t\tudev_device_set_subsystem(udev_device, &key[10]);\n\t\t\tsubsystem_set = 1;\n\t\t} else if (strncmp(key, \"DEVTYPE=\", 8) == 0) {\n\t\t\tudev_device_set_devtype(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVNAME=\", 8) == 0) {\n\t\t\tudev_device_set_devnode(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVLINKS=\", 9) == 0) {\n\t\t\tchar devlinks[UTIL_PATH_SIZE];\n\t\t\tchar *slink;\n\t\t\tchar *next;\n\n\t\t\tutil_strlcpy(devlinks, &key[9], sizeof(devlinks));\n\t\t\tslink = devlinks;\n\t\t\tnext = strchr(slink, ' ');\n\t\t\twhile (next != NULL) {\n\t\t\t\tnext[0] = '\\0';\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t\t\tslink = &next[1];\n\t\t\t\tnext = strchr(slink, ' ');\n\t\t\t}\n\t\t\tif (slink[0] != '\\0')\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t} else if (strncmp(key, \"DRIVER=\", 7) == 0) {\n\t\t\tudev_device_set_driver(udev_device, &key[7]);\n\t\t} else if (strncmp(key, \"ACTION=\", 7) == 0) {\n\t\t\tudev_device_set_action(udev_device, &key[7]);\n\t\t\taction_set = 1;\n\t\t} else if (strncmp(key, \"MAJOR=\", 6) == 0) {\n\t\t\tmaj = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"MINOR=\", 6) == 0) {\n\t\t\tmin = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"DEVPATH_OLD=\", 12) == 0) {\n\t\t\tudev_device_set_devpath_old(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"PHYSDEVPATH=\", 12) == 0) {\n\t\t\tudev_device_set_physdevpath(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"SEQNUM=\", 7) == 0) {\n\t\t\tudev_device_set_seqnum(udev_device, strtoull(&key[7], NULL, 10));\n\t\t} else if (strncmp(key, \"TIMEOUT=\", 8) == 0) {\n\t\t\tudev_device_set_timeout(udev_device, strtoull(&key[8], NULL, 10));\n\t\t} else if (strncmp(key, \"PHYSDEV\", 7) == 0) {\n\t\t\t/* skip deprecated values */\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tudev_device_add_property_from_string(udev_device, key);\n\t\t}\n\t}\n\tif (!devpath_set || !subsystem_set || !action_set) {\n\t\tinfo(udev_monitor->udev, \"missing values, skip\\n\");\n\t\tudev_device_unref(udev_device);\n\t\treturn NULL;\n\t}\n\tif (maj > 0)\n\t\tudev_device_set_devnum(udev_device, makedev(maj, min));\n\tudev_device_set_info_loaded(udev_device);\n\treturn udev_device;\n}",
        "func_after": "struct udev_device *udev_monitor_receive_device(struct udev_monitor *udev_monitor)\n{\n\tstruct udev_device *udev_device;\n\tstruct msghdr smsg;\n\tstruct iovec iov;\n\tchar cred_msg[CMSG_SPACE(sizeof(struct ucred))];\n\tstruct cmsghdr *cmsg;\n\tstruct ucred *cred;\n\tchar buf[4096];\n\tsize_t bufpos;\n\tint devpath_set = 0;\n\tint subsystem_set = 0;\n\tint action_set = 0;\n\tint maj = 0;\n\tint min = 0;\n\n\tif (udev_monitor == NULL)\n\t\treturn NULL;\n\tmemset(buf, 0x00, sizeof(buf));\n\tiov.iov_base = &buf;\n\tiov.iov_len = sizeof(buf);\n\tmemset (&smsg, 0x00, sizeof(struct msghdr));\n\tsmsg.msg_iov = &iov;\n\tsmsg.msg_iovlen = 1;\n\tsmsg.msg_control = cred_msg;\n\tsmsg.msg_controllen = sizeof(cred_msg);\n\n\tif (recvmsg(udev_monitor->sock, &smsg, 0) < 0) {\n\t\tif (errno != EINTR)\n\t\t\tinfo(udev_monitor->udev, \"unable to receive message\");\n\t\treturn NULL;\n\t}\n\n\tcmsg = CMSG_FIRSTHDR(&smsg);\n\tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {\n\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");\n\t\treturn NULL;\n\t}\n\n\tcred = (struct ucred *)CMSG_DATA(cmsg);\n\tif (cred->uid != 0) {\n\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);\n\t\treturn NULL;\n\t}\n\n\t/* skip header */\n\tbufpos = strlen(buf) + 1;\n\tif (bufpos < sizeof(\"a@/d\") || bufpos >= sizeof(buf)) {\n\t\tinfo(udev_monitor->udev, \"invalid message length\");\n\t\treturn NULL;\n\t}\n\n\t/* check message header */\n\tif (strstr(buf, \"@/\") == NULL) {\n\t\tinfo(udev_monitor->udev, \"unrecognized message header\");\n\t\treturn NULL;\n\t}\n\n\tudev_device = device_new(udev_monitor->udev);\n\tif (udev_device == NULL) {\n\t\treturn NULL;\n\t}\n\n\twhile (bufpos < sizeof(buf)) {\n\t\tchar *key;\n\t\tsize_t keylen;\n\n\t\tkey = &buf[bufpos];\n\t\tkeylen = strlen(key);\n\t\tif (keylen == 0)\n\t\t\tbreak;\n\t\tbufpos += keylen + 1;\n\n\t\tif (strncmp(key, \"DEVPATH=\", 8) == 0) {\n\t\t\tchar path[UTIL_PATH_SIZE];\n\n\t\t\tutil_strlcpy(path, udev_get_sys_path(udev_monitor->udev), sizeof(path));\n\t\t\tutil_strlcat(path, &key[8], sizeof(path));\n\t\t\tudev_device_set_syspath(udev_device, path);\n\t\t\tdevpath_set = 1;\n\t\t} else if (strncmp(key, \"SUBSYSTEM=\", 10) == 0) {\n\t\t\tudev_device_set_subsystem(udev_device, &key[10]);\n\t\t\tsubsystem_set = 1;\n\t\t} else if (strncmp(key, \"DEVTYPE=\", 8) == 0) {\n\t\t\tudev_device_set_devtype(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVNAME=\", 8) == 0) {\n\t\t\tudev_device_set_devnode(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVLINKS=\", 9) == 0) {\n\t\t\tchar devlinks[UTIL_PATH_SIZE];\n\t\t\tchar *slink;\n\t\t\tchar *next;\n\n\t\t\tutil_strlcpy(devlinks, &key[9], sizeof(devlinks));\n\t\t\tslink = devlinks;\n\t\t\tnext = strchr(slink, ' ');\n\t\t\twhile (next != NULL) {\n\t\t\t\tnext[0] = '\\0';\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t\t\tslink = &next[1];\n\t\t\t\tnext = strchr(slink, ' ');\n\t\t\t}\n\t\t\tif (slink[0] != '\\0')\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t} else if (strncmp(key, \"DRIVER=\", 7) == 0) {\n\t\t\tudev_device_set_driver(udev_device, &key[7]);\n\t\t} else if (strncmp(key, \"ACTION=\", 7) == 0) {\n\t\t\tudev_device_set_action(udev_device, &key[7]);\n\t\t\taction_set = 1;\n\t\t} else if (strncmp(key, \"MAJOR=\", 6) == 0) {\n\t\t\tmaj = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"MINOR=\", 6) == 0) {\n\t\t\tmin = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"DEVPATH_OLD=\", 12) == 0) {\n\t\t\tudev_device_set_devpath_old(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"PHYSDEVPATH=\", 12) == 0) {\n\t\t\tudev_device_set_physdevpath(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"SEQNUM=\", 7) == 0) {\n\t\t\tudev_device_set_seqnum(udev_device, strtoull(&key[7], NULL, 10));\n\t\t} else if (strncmp(key, \"TIMEOUT=\", 8) == 0) {\n\t\t\tudev_device_set_timeout(udev_device, strtoull(&key[8], NULL, 10));\n\t\t} else if (strncmp(key, \"PHYSDEV\", 7) == 0) {\n\t\t\t/* skip deprecated values */\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tudev_device_add_property_from_string(udev_device, key);\n\t\t}\n\t}\n\tif (!devpath_set || !subsystem_set || !action_set) {\n\t\tinfo(udev_monitor->udev, \"missing values, skip\\n\");\n\t\tudev_device_unref(udev_device);\n\t\treturn NULL;\n\t}\n\tif (maj > 0)\n\t\tudev_device_set_devnum(udev_device, makedev(maj, min));\n\tudev_device_set_info_loaded(udev_device);\n\treturn udev_device;\n}",
        "description": "udev versions prior to 1.4.1 do not validate whether a NETLINK message originates from kernel space, enabling local users to escalate privileges by transmitting a NETLINK message from user space.",
        "commit": "To enhance protection, the system should disregard any unicast messages received on the netlink socket and any multicast messages on the kernel group that do not originate from the kernel."
    },
    {
        "cwe": "CWE-120",
        "func_name": "ros/TransportTCP::connect",
        "score": 0.7860891819000244,
        "func_before": "bool TransportTCP__connect(const std::string& host, int port)\n{\n  if (!isHostAllowed(host))\n    return false; // adios amigo\n\n  sock_ = socket(s_use_ipv6_ ? AF_INET6 : AF_INET, SOCK_STREAM, 0);\n  connected_host_ = host;\n  connected_port_ = port;\n\n  if (sock_ == ROS_INVALID_SOCKET)\n  {\n    ROS_ERROR(\"socket() failed with error [%s]\",  last_socket_error_string());\n    return false;\n  }\n\n  setNonBlocking();\n\n  sockaddr_storage sas;\n  socklen_t sas_len;\n\n  in_addr ina;\n  in6_addr in6a;\n  if (inet_pton(AF_INET, host.c_str(), &ina) == 1)\n  {\n    sockaddr_in *address = (sockaddr_in*) &sas;\n    sas_len = sizeof(sockaddr_in);\n    \n    la_len_ = sizeof(sockaddr_in);\n    address->sin_family = AF_INET;\n    address->sin_port = htons(port);\n    address->sin_addr.s_addr = ina.s_addr;\n  }\n  else if (inet_pton(AF_INET6, host.c_str(), &in6a) == 1)\n  {\n    sockaddr_in6 *address = (sockaddr_in6*) &sas;\n    sas_len = sizeof(sockaddr_in6);\n    la_len_ = sizeof(sockaddr_in6);\n    address->sin6_family = AF_INET6;\n    address->sin6_port = htons(port);\n    memcpy(address->sin6_addr.s6_addr, in6a.s6_addr, sizeof(in6a.s6_addr));\n  }\n  else\n  {\n    struct addrinfo* addr;\n    struct addrinfo hints;\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = AF_UNSPEC;\n\n    if (getaddrinfo(host.c_str(), NULL, &hints, &addr) != 0)\n    {\n      close();\n      ROS_ERROR(\"couldn't resolve publisher host [%s]\", host.c_str());\n      return false;\n    }\n\n    bool found = false;\n    struct addrinfo* it = addr;\n    char namebuf[128];\n    for (; it; it = it->ai_next)\n    {\n      if (!s_use_ipv6_ && it->ai_family == AF_INET)\n      {\n        sockaddr_in *address = (sockaddr_in*) &sas;\n        sas_len = sizeof(*address);\n        \n        memcpy(address, it->ai_addr, it->ai_addrlen);\n        address->sin_family = it->ai_family;\n        address->sin_port = htons(port);\n\t\n        strcpy(namebuf, inet_ntoa(address->sin_addr));\n        found = true;\n        break;\n      }\n      if (s_use_ipv6_ && it->ai_family == AF_INET6)\n      {\n        sockaddr_in6 *address = (sockaddr_in6*) &sas;\n        sas_len = sizeof(*address);\n      \n        memcpy(address, it->ai_addr, it->ai_addrlen);\n        address->sin6_family = it->ai_family;\n        address->sin6_port = htons((u_short) port);\n      \n        // TODO IPV6: does inet_ntop need other includes for Windows?\n        inet_ntop(AF_INET6, (void*)&(address->sin6_addr), namebuf, sizeof(namebuf));\n        found = true;\n        break;\n      }\n    }\n\n    freeaddrinfo(addr);\n\n    if (!found)\n    {\n      ROS_ERROR(\"Couldn't resolve an address for [%s]\\n\", host.c_str());\n      return false;\n    }\n\n    ROSCPP_LOG_DEBUG(\"Resolved publisher host [%s] to [%s] for socket [%d]\", host.c_str(), namebuf, sock_);\n  }\n\n  int ret = ::connect(sock_, (sockaddr*) &sas, sas_len);\n  // windows might need some time to sleep (input from service robotics hack) add this if testing proves it is necessary.\n  // ROS_ASSERT((flags_ & SYNCHRONOUS) || ret != 0);\n  if (((flags_ & SYNCHRONOUS) && ret != 0) || // synchronous, connect() should return 0\n      (!(flags_ & SYNCHRONOUS) && ret != 0 && last_socket_error() != ROS_SOCKETS_ASYNCHRONOUS_CONNECT_RETURN)) \n      // asynchronous, connect() may return 0 or -1. When return -1, WSAGetLastError()=WSAEWOULDBLOCK/errno=EINPROGRESS\n  {\n    ROSCPP_CONN_LOG_DEBUG(\"Connect to tcpros publisher [%s:%d] failed with error [%d, %s]\", host.c_str(), port, ret, last_socket_error_string());\n    close();\n\n    return false;\n  }\n\n  // from daniel stonier:\n#ifdef WIN32\n  // This is hackish, but windows fails at recv() if its slow to connect (e.g. happens with wireless)\n  // recv() needs to check if its connected or not when its asynchronous?\n  Sleep(100);\n#endif\n\n\n  std::stringstream ss;\n  ss << host << \":\" << port << \" on socket \" << sock_;\n  cached_remote_host_ = ss.str();\n\n  if (!initializeSocket())\n  {\n    return false;\n  }\n\n  if (flags_ & SYNCHRONOUS)\n  {\n    ROSCPP_CONN_LOG_DEBUG(\"connect() succeeded to [%s:%d] on socket [%d]\", host.c_str(), port, sock_);\n  }\n  else\n  {\n    ROSCPP_CONN_LOG_DEBUG(\"Async connect() in progress to [%s:%d] on socket [%d]\", host.c_str(), port, sock_);\n  }\n\n  return true;\n}",
        "func_after": "bool TransportTCP__connect(const std::string& host, int port)\n{\n  if (!isHostAllowed(host))\n    return false; // adios amigo\n\n  sock_ = socket(s_use_ipv6_ ? AF_INET6 : AF_INET, SOCK_STREAM, 0);\n  connected_host_ = host;\n  connected_port_ = port;\n\n  if (sock_ == ROS_INVALID_SOCKET)\n  {\n    ROS_ERROR(\"socket() failed with error [%s]\",  last_socket_error_string());\n    return false;\n  }\n\n  setNonBlocking();\n\n  sockaddr_storage sas;\n  socklen_t sas_len;\n\n  in_addr ina;\n  in6_addr in6a;\n  if (inet_pton(AF_INET, host.c_str(), &ina) == 1)\n  {\n    sockaddr_in *address = (sockaddr_in*) &sas;\n    sas_len = sizeof(sockaddr_in);\n    \n    la_len_ = sizeof(sockaddr_in);\n    address->sin_family = AF_INET;\n    address->sin_port = htons(port);\n    address->sin_addr.s_addr = ina.s_addr;\n  }\n  else if (inet_pton(AF_INET6, host.c_str(), &in6a) == 1)\n  {\n    sockaddr_in6 *address = (sockaddr_in6*) &sas;\n    sas_len = sizeof(sockaddr_in6);\n    la_len_ = sizeof(sockaddr_in6);\n    address->sin6_family = AF_INET6;\n    address->sin6_port = htons(port);\n    memcpy(address->sin6_addr.s6_addr, in6a.s6_addr, sizeof(in6a.s6_addr));\n  }\n  else\n  {\n    struct addrinfo* addr;\n    struct addrinfo hints;\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = AF_UNSPEC;\n\n    if (getaddrinfo(host.c_str(), NULL, &hints, &addr) != 0)\n    {\n      close();\n      ROS_ERROR(\"couldn't resolve publisher host [%s]\", host.c_str());\n      return false;\n    }\n\n    bool found = false;\n    struct addrinfo* it = addr;\n    char namebuf[128] = {};\n    for (; it; it = it->ai_next)\n    {\n      if (!s_use_ipv6_ && it->ai_family == AF_INET)\n      {\n        sockaddr_in *address = (sockaddr_in*) &sas;\n        sas_len = sizeof(*address);\n        \n        memcpy(address, it->ai_addr, it->ai_addrlen);\n        address->sin_family = it->ai_family;\n        address->sin_port = htons(port);\n\t\n        strncpy(namebuf, inet_ntoa(address->sin_addr), sizeof(namebuf)-1);\n        found = true;\n        break;\n      }\n      if (s_use_ipv6_ && it->ai_family == AF_INET6)\n      {\n        sockaddr_in6 *address = (sockaddr_in6*) &sas;\n        sas_len = sizeof(*address);\n      \n        memcpy(address, it->ai_addr, it->ai_addrlen);\n        address->sin6_family = it->ai_family;\n        address->sin6_port = htons((u_short) port);\n      \n        // TODO IPV6: does inet_ntop need other includes for Windows?\n        inet_ntop(AF_INET6, (void*)&(address->sin6_addr), namebuf, sizeof(namebuf));\n        found = true;\n        break;\n      }\n    }\n\n    freeaddrinfo(addr);\n\n    if (!found)\n    {\n      ROS_ERROR(\"Couldn't resolve an address for [%s]\\n\", host.c_str());\n      return false;\n    }\n\n    ROSCPP_LOG_DEBUG(\"Resolved publisher host [%s] to [%s] for socket [%d]\", host.c_str(), namebuf, sock_);\n  }\n\n  int ret = ::connect(sock_, (sockaddr*) &sas, sas_len);\n  // windows might need some time to sleep (input from service robotics hack) add this if testing proves it is necessary.\n  // ROS_ASSERT((flags_ & SYNCHRONOUS) || ret != 0);\n  if (((flags_ & SYNCHRONOUS) && ret != 0) || // synchronous, connect() should return 0\n      (!(flags_ & SYNCHRONOUS) && ret != 0 && last_socket_error() != ROS_SOCKETS_ASYNCHRONOUS_CONNECT_RETURN)) \n      // asynchronous, connect() may return 0 or -1. When return -1, WSAGetLastError()=WSAEWOULDBLOCK/errno=EINPROGRESS\n  {\n    ROSCPP_CONN_LOG_DEBUG(\"Connect to tcpros publisher [%s:%d] failed with error [%d, %s]\", host.c_str(), port, ret, last_socket_error_string());\n    close();\n\n    return false;\n  }\n\n  // from daniel stonier:\n#ifdef WIN32\n  // This is hackish, but windows fails at recv() if its slow to connect (e.g. happens with wireless)\n  // recv() needs to check if its connected or not when its asynchronous?\n  Sleep(100);\n#endif\n\n\n  std::stringstream ss;\n  ss << host << \":\" << port << \" on socket \" << sock_;\n  cached_remote_host_ = ss.str();\n\n  if (!initializeSocket())\n  {\n    return false;\n  }\n\n  if (flags_ & SYNCHRONOUS)\n  {\n    ROSCPP_CONN_LOG_DEBUG(\"connect() succeeded to [%s:%d] on socket [%d]\", host.c_str(), port, sock_);\n  }\n  else\n  {\n    ROSCPP_CONN_LOG_DEBUG(\"Async connect() in progress to [%s:%d] on socket [%d]\", host.c_str(), port, sock_);\n  }\n\n  return true;\n}",
        "description": "An issue was discovered in ROS communications-related packages (such as ros_comm or ros-melodic-ros-comm) up to version 1.14.3. A buffer overflow vulnerability allows attackers to cause a denial of service and potentially execute arbitrary code by utilizing an IP address with an excessively long hostname.",
        "commit": "The vulnerability involves an issue with string validation or comparison logic that has been addressed through a fix."
    },
    {
        "cwe": "CWE-440",
        "func_name": "eclipse-openj9/Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex",
        "score": 0.7602814435958862,
        "func_before": "JNIEXPORT jint JNICALL Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *env, jclass InterfaceMethodHandle, jlong interfaceArg, jint itableIndex, jlong receiverClassArg)\n   {\n   J9Class  *interfaceClass = (J9Class*)(intptr_t)interfaceArg;\n   J9Class  *receiverClass  = (J9Class*)(intptr_t)receiverClassArg;\n   J9ITable *itableEntry;\n   for (itableEntry = (J9ITable*)receiverClass->iTable; itableEntry; itableEntry = itableEntry->next)\n      if (itableEntry->interfaceClass == interfaceClass)\n         break;\n   TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *itableArray = (UDATA*)(itableEntry+1);\n   return (itableArray[itableIndex] - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } indexAndLiterals =\n      {\n      (UDATA)interfaceClass,\n      (UDATA)itableIndex\n      };\n   J9Object *receiver = (J9Object*)receiverArg;\n   return (jint)jitLookupInterfaceMethod(receiver->clazz, &indexAndLiterals, 0);\n#endif\n   }",
        "func_after": "JNIEXPORT jint JNICALL Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *env, jclass InterfaceMethodHandle, jlong interfaceArg, jint itableIndex, jlong receiverClassArg)\n   {\n   J9Class  *interfaceClass = (J9Class*)(intptr_t)interfaceArg;\n   J9Class  *receiverClass  = (J9Class*)(intptr_t)receiverClassArg;\n   J9ITable *itableEntry;\n   for (itableEntry = (J9ITable*)receiverClass->iTable; itableEntry; itableEntry = itableEntry->next)\n      if (itableEntry->interfaceClass == interfaceClass)\n         break;\n   TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *itableArray = (UDATA*)(itableEntry+1);\n   UDATA vTableOffset = itableArray[itableIndex];\n   J9Method *method = *(J9Method**)((UDATA)receiverClass + vTableOffset);\n   if ((J9_ROM_METHOD_FROM_RAM_METHOD(method)->modifiers & J9AccPublic) == 0)\n      return -1;\n\n   return (vTableOffset - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } indexAndLiterals =\n      {\n      (UDATA)interfaceClass,\n      (UDATA)itableIndex\n      };\n   J9Object *receiver = (J9Object*)receiverArg;\n   return (jint)jitLookupInterfaceMethod(receiver->clazz, &indexAndLiterals, 0);\n#endif\n   }",
        "description": "In versions of Eclipse Openj9 prior to 0.29.0, the Java Virtual Machine (JVM) fails to throw an IllegalAccessError when MethodHandles are used to invoke methods that are not accessible through interfaces.",
        "commit": "The vulnerability involves a situation where an `IllegalAccessError` (IAE) is not being thrown appropriately when an `InterfaceHandle` encounters a non-public method during dispatch. The expected behavior is for the dispatch mechanism implemented by `InterfaceHandle` to mimic that of `invokeinterface`, which throws an `IAE` when attempting to access non-public methods. This discrepancy allows unauthorized access to non-public methods, potentially leading to security vulnerabilities."
    },
    {
        "cwe": "CWE-755",
        "func_name": "xen-project/map_grant_ref",
        "score": 0.7862663865089417,
        "func_before": "static void\nmap_grant_ref(\n    struct gnttab_map_grant_ref *op)\n{\n    struct domain *ld, *rd, *owner = NULL;\n    struct grant_table *lgt, *rgt;\n    grant_ref_t ref;\n    grant_handle_t handle;\n    mfn_t mfn;\n    struct page_info *pg = NULL;\n    int            rc = GNTST_okay;\n    unsigned int   cache_flags, clear_flags = 0, refcnt = 0, typecnt = 0;\n    bool           host_map_created = false;\n    struct active_grant_entry *act = NULL;\n    struct grant_mapping *mt;\n    grant_entry_header_t *shah;\n    uint16_t *status;\n    bool_t need_iommu;\n\n    ld = current->domain;\n\n    if ( unlikely((op->flags & (GNTMAP_device_map|GNTMAP_host_map)) == 0) )\n    {\n        gdprintk(XENLOG_INFO, \"Bad flags in grant map op: %x\\n\", op->flags);\n        op->status = GNTST_bad_gntref;\n        return;\n    }\n\n    if ( unlikely(paging_mode_external(ld) &&\n                  (op->flags & (GNTMAP_device_map|GNTMAP_application_map|\n                            GNTMAP_contains_pte))) )\n    {\n        gdprintk(XENLOG_INFO, \"No device mapping in HVM domain\\n\");\n        op->status = GNTST_general_error;\n        return;\n    }\n\n    if ( unlikely((rd = rcu_lock_domain_by_id(op->dom)) == NULL) )\n    {\n        gdprintk(XENLOG_INFO, \"Could not find domain %d\\n\", op->dom);\n        op->status = GNTST_bad_domain;\n        return;\n    }\n\n    rc = xsm_grant_mapref(XSM_HOOK, ld, rd, op->flags);\n    if ( rc )\n    {\n        rcu_unlock_domain(rd);\n        op->status = GNTST_permission_denied;\n        return;\n    }\n\n    lgt = ld->grant_table;\n    handle = get_maptrack_handle(lgt);\n    if ( unlikely(handle == INVALID_MAPTRACK_HANDLE) )\n    {\n        rcu_unlock_domain(rd);\n        gdprintk(XENLOG_INFO, \"Failed to obtain maptrack handle\\n\");\n        op->status = GNTST_no_device_space;\n        return;\n    }\n\n    rgt = rd->grant_table;\n    grant_read_lock(rgt);\n\n    /* Bounds check on the grant ref */\n    ref = op->ref;\n    if ( unlikely(ref >= nr_grant_entries(rgt)))\n        PIN_FAIL(unlock_out, GNTST_bad_gntref, \"Bad ref %#x for d%d\\n\",\n                 ref, rgt->domain->domain_id);\n\n    /* This call also ensures the above check cannot be passed speculatively */\n    shah = shared_entry_header(rgt, ref);\n    act = active_entry_acquire(rgt, ref);\n\n    /* Make sure we do not access memory speculatively */\n    status = evaluate_nospec(rgt->gt_version == 1) ? &shah->flags\n                                                 : &status_entry(rgt, ref);\n\n    /* If already pinned, check the active domid and avoid refcnt overflow. */\n    if ( act->pin &&\n         ((act->domid != ld->domain_id) ||\n          (act->pin & 0x80808080U) != 0 ||\n          (act->is_sub_page)) )\n        PIN_FAIL(act_release_out, GNTST_general_error,\n                 \"Bad domain (%d != %d), or risk of counter overflow %08x, or subpage %d\\n\",\n                 act->domid, ld->domain_id, act->pin, act->is_sub_page);\n\n    if ( !act->pin ||\n         (!(op->flags & GNTMAP_readonly) &&\n          !(act->pin & (GNTPIN_hstw_mask|GNTPIN_devw_mask))) )\n    {\n        if ( (rc = _set_status(shah, status, rd, rgt->gt_version, act,\n                               op->flags & GNTMAP_readonly, 1,\n                               ld->domain_id) != GNTST_okay) )\n            goto act_release_out;\n\n        if ( !act->pin )\n        {\n            unsigned long gfn = evaluate_nospec(rgt->gt_version == 1) ?\n                                shared_entry_v1(rgt, ref).frame :\n                                shared_entry_v2(rgt, ref).full_page.frame;\n\n            rc = get_paged_frame(gfn, &mfn, &pg,\n                                 op->flags & GNTMAP_readonly, rd);\n            if ( rc != GNTST_okay )\n                goto unlock_out_clear;\n            act_set_gfn(act, _gfn(gfn));\n            act->domid = ld->domain_id;\n            act->mfn = mfn;\n            act->start = 0;\n            act->length = PAGE_SIZE;\n            act->is_sub_page = false;\n            act->trans_domain = rd;\n            act->trans_gref = ref;\n        }\n    }\n\n    if ( op->flags & GNTMAP_device_map )\n        act->pin += (op->flags & GNTMAP_readonly) ?\n            GNTPIN_devr_inc : GNTPIN_devw_inc;\n    if ( op->flags & GNTMAP_host_map )\n        act->pin += (op->flags & GNTMAP_readonly) ?\n            GNTPIN_hstr_inc : GNTPIN_hstw_inc;\n\n    mfn = act->mfn;\n\n    cache_flags = (shah->flags & (GTF_PAT | GTF_PWT | GTF_PCD) );\n\n    active_entry_release(act);\n    grant_read_unlock(rgt);\n\n    /* pg may be set, with a refcount included, from get_paged_frame(). */\n    if ( !pg )\n    {\n        pg = mfn_valid(mfn) ? mfn_to_page(mfn) : NULL;\n        if ( pg )\n            owner = page_get_owner_and_reference(pg);\n    }\n    else\n        owner = page_get_owner(pg);\n\n    if ( owner )\n        refcnt++;\n\n    if ( !pg || (owner == dom_io) )\n    {\n        /* Only needed the reference to confirm dom_io ownership. */\n        if ( pg )\n        {\n            put_page(pg);\n            refcnt--;\n        }\n\n        if ( paging_mode_external(ld) )\n        {\n            gdprintk(XENLOG_WARNING, \"HVM guests can't grant map iomem\\n\");\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n\n        if ( !iomem_access_permitted(rd, mfn_x(mfn), mfn_x(mfn)) )\n        {\n            gdprintk(XENLOG_WARNING,\n                     \"Iomem mapping not permitted %#\"PRI_mfn\" (domain %d)\\n\",\n                     mfn_x(mfn), rd->domain_id);\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n\n        if ( op->flags & GNTMAP_host_map )\n        {\n            rc = create_grant_host_mapping(op->host_addr, mfn, op->flags,\n                                           cache_flags);\n            if ( rc != GNTST_okay )\n                goto undo_out;\n\n            host_map_created = true;\n        }\n    }\n    else if ( owner == rd || (dom_cow && owner == dom_cow) )\n    {\n        if ( (op->flags & GNTMAP_device_map) && !(op->flags & GNTMAP_readonly) )\n        {\n            if ( (owner == dom_cow) ||\n                 !get_page_type(pg, PGT_writable_page) )\n                goto could_not_pin;\n            typecnt++;\n        }\n\n        if ( op->flags & GNTMAP_host_map )\n        {\n            /*\n             * Only need to grab another reference if device_map claimed\n             * the other one.\n             */\n            if ( op->flags & GNTMAP_device_map )\n            {\n                if ( !get_page(pg, rd) )\n                    goto could_not_pin;\n                refcnt++;\n            }\n\n            if ( gnttab_host_mapping_get_page_type(op->flags & GNTMAP_readonly,\n                                                   ld, rd) )\n            {\n                if ( (owner == dom_cow) ||\n                     !get_page_type(pg, PGT_writable_page) )\n                    goto could_not_pin;\n                typecnt++;\n            }\n\n            rc = create_grant_host_mapping(op->host_addr, mfn, op->flags, 0);\n            if ( rc != GNTST_okay )\n                goto undo_out;\n\n            host_map_created = true;\n        }\n    }\n    else\n    {\n    could_not_pin:\n        if ( !rd->is_dying )\n            gdprintk(XENLOG_WARNING, \"Could not pin grant frame %#\"PRI_mfn\"\\n\",\n                     mfn_x(mfn));\n        rc = GNTST_general_error;\n        goto undo_out;\n    }\n\n    need_iommu = gnttab_need_iommu_mapping(ld);\n    if ( need_iommu )\n    {\n        unsigned int kind;\n\n        double_gt_lock(lgt, rgt);\n\n        /*\n         * We're not translated, so we know that dfns and mfns are\n         * the same things, so the IOMMU entry is always 1-to-1.\n         */\n        kind = mapkind(lgt, rd, mfn);\n        if ( !(op->flags & GNTMAP_readonly) &&\n             !(kind & MAPKIND_WRITE) )\n            kind = IOMMUF_readable | IOMMUF_writable;\n        else if ( !kind )\n            kind = IOMMUF_readable;\n        else\n            kind = 0;\n        if ( kind && iommu_legacy_map(ld, _dfn(mfn_x(mfn)), mfn, 0, kind) )\n        {\n            double_gt_unlock(lgt, rgt);\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n    }\n\n    TRACE_1D(TRC_MEM_PAGE_GRANT_MAP, op->dom);\n\n    /*\n     * All maptrack entry users check mt->flags first before using the\n     * other fields so just ensure the flags field is stored last.\n     *\n     * However, if gnttab_need_iommu_mapping() then this would race\n     * with a concurrent mapkind() call (on an unmap, for example)\n     * and a lock is required.\n     */\n    mt = &maptrack_entry(lgt, handle);\n    mt->domid = op->dom;\n    mt->ref   = op->ref;\n    smp_wmb();\n    write_atomic(&mt->flags, op->flags);\n\n    if ( need_iommu )\n        double_gt_unlock(lgt, rgt);\n\n    op->dev_bus_addr = mfn_to_maddr(mfn);\n    op->handle       = handle;\n    op->status       = GNTST_okay;\n\n    rcu_unlock_domain(rd);\n    return;\n\n undo_out:\n    if ( host_map_created )\n    {\n        replace_grant_host_mapping(op->host_addr, mfn, 0, op->flags);\n        gnttab_flush_tlb(ld);\n    }\n\n    while ( typecnt-- )\n        put_page_type(pg);\n\n    while ( refcnt-- )\n        put_page(pg);\n\n    grant_read_lock(rgt);\n\n    act = active_entry_acquire(rgt, op->ref);\n\n    if ( op->flags & GNTMAP_device_map )\n        act->pin -= (op->flags & GNTMAP_readonly) ?\n            GNTPIN_devr_inc : GNTPIN_devw_inc;\n    if ( op->flags & GNTMAP_host_map )\n        act->pin -= (op->flags & GNTMAP_readonly) ?\n            GNTPIN_hstr_inc : GNTPIN_hstw_inc;\n\n unlock_out_clear:\n    if ( !(op->flags & GNTMAP_readonly) &&\n         !(act->pin & (GNTPIN_hstw_mask|GNTPIN_devw_mask)) )\n        clear_flags |= GTF_writing;\n\n    if ( !act->pin )\n        clear_flags |= GTF_reading;\n\n    if ( clear_flags )\n        gnttab_clear_flags(rd, clear_flags, status);\n\n act_release_out:\n    active_entry_release(act);\n\n unlock_out:\n    grant_read_unlock(rgt);\n    op->status = rc;\n    put_maptrack_handle(lgt, handle);\n    rcu_unlock_domain(rd);\n}",
        "func_after": "static void\nmap_grant_ref(\n    struct gnttab_map_grant_ref *op)\n{\n    struct domain *ld, *rd, *owner = NULL;\n    struct grant_table *lgt, *rgt;\n    grant_ref_t ref;\n    grant_handle_t handle;\n    mfn_t mfn;\n    struct page_info *pg = NULL;\n    int            rc = GNTST_okay;\n    unsigned int   cache_flags, clear_flags = 0, refcnt = 0, typecnt = 0;\n    bool           host_map_created = false;\n    struct active_grant_entry *act = NULL;\n    struct grant_mapping *mt;\n    grant_entry_header_t *shah;\n    uint16_t *status;\n    bool_t need_iommu;\n\n    ld = current->domain;\n\n    if ( unlikely((op->flags & (GNTMAP_device_map|GNTMAP_host_map)) == 0) )\n    {\n        gdprintk(XENLOG_INFO, \"Bad flags in grant map op: %x\\n\", op->flags);\n        op->status = GNTST_bad_gntref;\n        return;\n    }\n\n    if ( unlikely(paging_mode_external(ld) &&\n                  (op->flags & (GNTMAP_device_map|GNTMAP_application_map|\n                            GNTMAP_contains_pte))) )\n    {\n        gdprintk(XENLOG_INFO, \"No device mapping in HVM domain\\n\");\n        op->status = GNTST_general_error;\n        return;\n    }\n\n    if ( unlikely((rd = rcu_lock_domain_by_id(op->dom)) == NULL) )\n    {\n        gdprintk(XENLOG_INFO, \"Could not find domain %d\\n\", op->dom);\n        op->status = GNTST_bad_domain;\n        return;\n    }\n\n    rc = xsm_grant_mapref(XSM_HOOK, ld, rd, op->flags);\n    if ( rc )\n    {\n        rcu_unlock_domain(rd);\n        op->status = GNTST_permission_denied;\n        return;\n    }\n\n    lgt = ld->grant_table;\n    handle = get_maptrack_handle(lgt);\n    if ( unlikely(handle == INVALID_MAPTRACK_HANDLE) )\n    {\n        rcu_unlock_domain(rd);\n        gdprintk(XENLOG_INFO, \"Failed to obtain maptrack handle\\n\");\n        op->status = GNTST_no_device_space;\n        return;\n    }\n\n    rgt = rd->grant_table;\n    grant_read_lock(rgt);\n\n    /* Bounds check on the grant ref */\n    ref = op->ref;\n    if ( unlikely(ref >= nr_grant_entries(rgt)))\n        PIN_FAIL(unlock_out, GNTST_bad_gntref, \"Bad ref %#x for d%d\\n\",\n                 ref, rgt->domain->domain_id);\n\n    /* This call also ensures the above check cannot be passed speculatively */\n    shah = shared_entry_header(rgt, ref);\n    act = active_entry_acquire(rgt, ref);\n\n    /* Make sure we do not access memory speculatively */\n    status = evaluate_nospec(rgt->gt_version == 1) ? &shah->flags\n                                                 : &status_entry(rgt, ref);\n\n    /* If already pinned, check the active domid and avoid refcnt overflow. */\n    if ( act->pin &&\n         ((act->domid != ld->domain_id) ||\n          (act->pin & 0x80808080U) != 0 ||\n          (act->is_sub_page)) )\n        PIN_FAIL(act_release_out, GNTST_general_error,\n                 \"Bad domain (%d != %d), or risk of counter overflow %08x, or subpage %d\\n\",\n                 act->domid, ld->domain_id, act->pin, act->is_sub_page);\n\n    if ( !act->pin ||\n         (!(op->flags & GNTMAP_readonly) &&\n          !(act->pin & (GNTPIN_hstw_mask|GNTPIN_devw_mask))) )\n    {\n        if ( (rc = _set_status(shah, status, rd, rgt->gt_version, act,\n                               op->flags & GNTMAP_readonly, 1,\n                               ld->domain_id)) != GNTST_okay )\n            goto act_release_out;\n\n        if ( !act->pin )\n        {\n            unsigned long gfn = evaluate_nospec(rgt->gt_version == 1) ?\n                                shared_entry_v1(rgt, ref).frame :\n                                shared_entry_v2(rgt, ref).full_page.frame;\n\n            rc = get_paged_frame(gfn, &mfn, &pg,\n                                 op->flags & GNTMAP_readonly, rd);\n            if ( rc != GNTST_okay )\n                goto unlock_out_clear;\n            act_set_gfn(act, _gfn(gfn));\n            act->domid = ld->domain_id;\n            act->mfn = mfn;\n            act->start = 0;\n            act->length = PAGE_SIZE;\n            act->is_sub_page = false;\n            act->trans_domain = rd;\n            act->trans_gref = ref;\n        }\n    }\n\n    if ( op->flags & GNTMAP_device_map )\n        act->pin += (op->flags & GNTMAP_readonly) ?\n            GNTPIN_devr_inc : GNTPIN_devw_inc;\n    if ( op->flags & GNTMAP_host_map )\n        act->pin += (op->flags & GNTMAP_readonly) ?\n            GNTPIN_hstr_inc : GNTPIN_hstw_inc;\n\n    mfn = act->mfn;\n\n    cache_flags = (shah->flags & (GTF_PAT | GTF_PWT | GTF_PCD) );\n\n    active_entry_release(act);\n    grant_read_unlock(rgt);\n\n    /* pg may be set, with a refcount included, from get_paged_frame(). */\n    if ( !pg )\n    {\n        pg = mfn_valid(mfn) ? mfn_to_page(mfn) : NULL;\n        if ( pg )\n            owner = page_get_owner_and_reference(pg);\n    }\n    else\n        owner = page_get_owner(pg);\n\n    if ( owner )\n        refcnt++;\n\n    if ( !pg || (owner == dom_io) )\n    {\n        /* Only needed the reference to confirm dom_io ownership. */\n        if ( pg )\n        {\n            put_page(pg);\n            refcnt--;\n        }\n\n        if ( paging_mode_external(ld) )\n        {\n            gdprintk(XENLOG_WARNING, \"HVM guests can't grant map iomem\\n\");\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n\n        if ( !iomem_access_permitted(rd, mfn_x(mfn), mfn_x(mfn)) )\n        {\n            gdprintk(XENLOG_WARNING,\n                     \"Iomem mapping not permitted %#\"PRI_mfn\" (domain %d)\\n\",\n                     mfn_x(mfn), rd->domain_id);\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n\n        if ( op->flags & GNTMAP_host_map )\n        {\n            rc = create_grant_host_mapping(op->host_addr, mfn, op->flags,\n                                           cache_flags);\n            if ( rc != GNTST_okay )\n                goto undo_out;\n\n            host_map_created = true;\n        }\n    }\n    else if ( owner == rd || (dom_cow && owner == dom_cow) )\n    {\n        if ( (op->flags & GNTMAP_device_map) && !(op->flags & GNTMAP_readonly) )\n        {\n            if ( (owner == dom_cow) ||\n                 !get_page_type(pg, PGT_writable_page) )\n                goto could_not_pin;\n            typecnt++;\n        }\n\n        if ( op->flags & GNTMAP_host_map )\n        {\n            /*\n             * Only need to grab another reference if device_map claimed\n             * the other one.\n             */\n            if ( op->flags & GNTMAP_device_map )\n            {\n                if ( !get_page(pg, rd) )\n                    goto could_not_pin;\n                refcnt++;\n            }\n\n            if ( gnttab_host_mapping_get_page_type(op->flags & GNTMAP_readonly,\n                                                   ld, rd) )\n            {\n                if ( (owner == dom_cow) ||\n                     !get_page_type(pg, PGT_writable_page) )\n                    goto could_not_pin;\n                typecnt++;\n            }\n\n            rc = create_grant_host_mapping(op->host_addr, mfn, op->flags, 0);\n            if ( rc != GNTST_okay )\n                goto undo_out;\n\n            host_map_created = true;\n        }\n    }\n    else\n    {\n    could_not_pin:\n        if ( !rd->is_dying )\n            gdprintk(XENLOG_WARNING, \"Could not pin grant frame %#\"PRI_mfn\"\\n\",\n                     mfn_x(mfn));\n        rc = GNTST_general_error;\n        goto undo_out;\n    }\n\n    need_iommu = gnttab_need_iommu_mapping(ld);\n    if ( need_iommu )\n    {\n        unsigned int kind;\n\n        double_gt_lock(lgt, rgt);\n\n        /*\n         * We're not translated, so we know that dfns and mfns are\n         * the same things, so the IOMMU entry is always 1-to-1.\n         */\n        kind = mapkind(lgt, rd, mfn);\n        if ( !(op->flags & GNTMAP_readonly) &&\n             !(kind & MAPKIND_WRITE) )\n            kind = IOMMUF_readable | IOMMUF_writable;\n        else if ( !kind )\n            kind = IOMMUF_readable;\n        else\n            kind = 0;\n        if ( kind && iommu_legacy_map(ld, _dfn(mfn_x(mfn)), mfn, 0, kind) )\n        {\n            double_gt_unlock(lgt, rgt);\n            rc = GNTST_general_error;\n            goto undo_out;\n        }\n    }\n\n    TRACE_1D(TRC_MEM_PAGE_GRANT_MAP, op->dom);\n\n    /*\n     * All maptrack entry users check mt->flags first before using the\n     * other fields so just ensure the flags field is stored last.\n     *\n     * However, if gnttab_need_iommu_mapping() then this would race\n     * with a concurrent mapkind() call (on an unmap, for example)\n     * and a lock is required.\n     */\n    mt = &maptrack_entry(lgt, handle);\n    mt->domid = op->dom;\n    mt->ref   = op->ref;\n    smp_wmb();\n    write_atomic(&mt->flags, op->flags);\n\n    if ( need_iommu )\n        double_gt_unlock(lgt, rgt);\n\n    op->dev_bus_addr = mfn_to_maddr(mfn);\n    op->handle       = handle;\n    op->status       = GNTST_okay;\n\n    rcu_unlock_domain(rd);\n    return;\n\n undo_out:\n    if ( host_map_created )\n    {\n        replace_grant_host_mapping(op->host_addr, mfn, 0, op->flags);\n        gnttab_flush_tlb(ld);\n    }\n\n    while ( typecnt-- )\n        put_page_type(pg);\n\n    while ( refcnt-- )\n        put_page(pg);\n\n    grant_read_lock(rgt);\n\n    act = active_entry_acquire(rgt, op->ref);\n\n    if ( op->flags & GNTMAP_device_map )\n        act->pin -= (op->flags & GNTMAP_readonly) ?\n            GNTPIN_devr_inc : GNTPIN_devw_inc;\n    if ( op->flags & GNTMAP_host_map )\n        act->pin -= (op->flags & GNTMAP_readonly) ?\n            GNTPIN_hstr_inc : GNTPIN_hstw_inc;\n\n unlock_out_clear:\n    if ( !(op->flags & GNTMAP_readonly) &&\n         !(act->pin & (GNTPIN_hstw_mask|GNTPIN_devw_mask)) )\n        clear_flags |= GTF_writing;\n\n    if ( !act->pin )\n        clear_flags |= GTF_reading;\n\n    if ( clear_flags )\n        gnttab_clear_flags(rd, clear_flags, status);\n\n act_release_out:\n    active_entry_release(act);\n\n unlock_out:\n    grant_read_unlock(rgt);\n    op->status = rc;\n    put_maptrack_handle(lgt, handle);\n    rcu_unlock_domain(rd);\n}",
        "description": "An issue was discovered in Xen versions up to 4.13.x, where guest operating system users could trigger a denial of service due to an improper error handling mechanism in the GNTTABOP_map_grant operation. Grant table operations are supposed to return 0 for success and a negative number for errors; however, a coding mistake resulted in one error path returning 1 instead of a negative value. The grant table code in Linux interprets this as a successful operation and continues with incorrectly initialized state. A malicious or buggy guest could manipulate its grant table to exploit this flaw, causing a crash in the Linux-based dom0 or backend domain when a backend domain attempts to map a grant.",
        "commit": "A function within the Xen hypervisor, specifically related to mapping grant references, had its error handling logic inadvertently altered. This change caused the function to return an incorrect status code when a critical operation failed, leading to unexpected behavior in the Linux kernel's network and block device backends. This issue could result in system crashes due to improper handling of guest states."
    },
    {
        "cwe": "CWE-1284",
        "func_name": "Samsung/crypto_bignum_allocate",
        "score": 0.7649147510528564,
        "func_before": "struct bignum *crypto_bignum_allocate(size_t size_bits)\n{\n\tsize_t sz = mpa_StaticVarSizeInU32(size_bits) *\tsizeof(uint32_t);\n\tstruct mpa_numbase_struct *bn = calloc(1, sz);\n\n\tif (!bn)\n\t\treturn NULL;\n\tbn->alloc = sz - MPA_NUMBASE_METADATA_SIZE_IN_U32 * sizeof(uint32_t);\n\treturn (struct bignum *)bn;\n}",
        "func_after": "struct bignum *crypto_bignum_allocate(size_t size_bits)\n{\n\tsize_t sz = mpa_StaticVarSizeInU32(size_bits) *\tsizeof(uint32_t);\n\t// struct mpa_numbase_struct *bn = calloc(1, sz);\n\tstruct mpa_numbase_struct *bn= TEE_Malloc(sz, TEE_MALLOC_FILL_ZERO);\n\tif (!bn)\n\t\treturn NULL;\n\tbn->alloc = sz - MPA_NUMBASE_METADATA_SIZE_IN_U32 * sizeof(uint32_t);\n\treturn (struct bignum *)bn;\n}",
        "description": "The function `tee_obj_free` in Samsung mTower through version 0.3.0 enables a trusted application to cause a Denial of Service (DoS) by calling the function `TEE_AllocateOperation` with a disrupted heap layout, which is associated with `utee_cryp_obj_alloc`.",
        "commit": "A vulnerability has been addressed in a software system, specifically identified by CVE-2022-40761."
    }
]