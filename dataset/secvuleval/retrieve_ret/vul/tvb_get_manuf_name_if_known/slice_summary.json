[
    {
        "cwe": "CWE-1284",
        "func_name": "Samsung/crypto_bignum_allocate",
        "score": 0.7318032383918762,
        "func_before": "struct bignum *crypto_bignum_allocate(size_t size_bits)\n{\n\tsize_t sz = mpa_StaticVarSizeInU32(size_bits) *\tsizeof(uint32_t);\n\tstruct mpa_numbase_struct *bn = calloc(1, sz);\n\n\tif (!bn)\n\t\treturn NULL;\n\tbn->alloc = sz - MPA_NUMBASE_METADATA_SIZE_IN_U32 * sizeof(uint32_t);\n\treturn (struct bignum *)bn;\n}",
        "func_after": "struct bignum *crypto_bignum_allocate(size_t size_bits)\n{\n\tsize_t sz = mpa_StaticVarSizeInU32(size_bits) *\tsizeof(uint32_t);\n\t// struct mpa_numbase_struct *bn = calloc(1, sz);\n\tstruct mpa_numbase_struct *bn= TEE_Malloc(sz, TEE_MALLOC_FILL_ZERO);\n\tif (!bn)\n\t\treturn NULL;\n\tbn->alloc = sz - MPA_NUMBASE_METADATA_SIZE_IN_U32 * sizeof(uint32_t);\n\treturn (struct bignum *)bn;\n}",
        "description": "The function `tee_obj_free` in Samsung mTower through version 0.3.0 enables a trusted application to cause a Denial of Service (DoS) by calling the function `TEE_AllocateOperation` with a disrupted heap layout, which is associated with `utee_cryp_obj_alloc`.",
        "commit": "A vulnerability has been addressed in a software system, specifically identified by CVE-2022-40761."
    },
    {
        "cwe": "CWE-134",
        "func_name": "wireapp/audio_level_json",
        "score": 0.7407761812210083,
        "func_before": "int audio_level_json(struct list *levell,\n\t\t     const char *userid_self, const char *clientid_self,\n\t\t     char **json_str, char **anon_str)\n{\n\tstruct json_object *jobj;\n\tstruct json_object *jarr;\n\tchar uid_anon[ANON_ID_LEN];\n\tchar cid_anon[ANON_CLIENT_LEN];\n\tstruct mbuf *pmb = NULL;\n\tint err = 0;\n\tstruct le *le;\n\n\tif (!levell || !json_str)\n\t\treturn EINVAL;\n\t\n\tjobj = jzon_alloc_object();\n\tif (!jobj)\n\t\treturn ENOMEM;\n\n\tjarr = jzon_alloc_array();\n\tif (!jarr) {\n\t\terr = ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (anon_str) {\n\t\tpmb = mbuf_alloc(512);\n\t\tmbuf_printf(pmb, \"%zu levels: \", list_count(levell));\n\t}\n\t\n\tLIST_FOREACH(levell, le) {\n\t\tstruct audio_level *a = le->data;\n\t\tstruct json_object *ja;\n\t\tconst char *userid = a->userid;\n\t\tconst char *clientid = a->clientid;\n\n\t\tif (a->is_self) {\n\t\t\tif (userid_self)\n\t\t\t\tuserid = userid_self;\n\t\t\tif (clientid_self)\n\t\t\t\tclientid = clientid_self;\n\t\t}\n\n\t\tja = jzon_alloc_object();\n\t\tif (ja) {\n\t\t\tjzon_add_str(ja, \"userid\", userid);\n\t\t\tjzon_add_str(ja, \"clientid\", clientid);\n\t\t\tjzon_add_int(ja, \"audio_level\",\n\t\t\t\t     (int32_t)a->aulevel_smooth);\n\t\t\tjzon_add_int(ja, \"audio_level_now\",\n\t\t\t\t     (int32_t)a->aulevel);\n\t\t}\n\t\tjson_object_array_add(jarr, ja);\n\n\t\t/* add to info string */\n\t\tif (pmb) {\n\t\t\tanon_id(uid_anon, userid);\n\t\t\tanon_client(cid_anon, clientid);\n\t\t\tmbuf_printf(pmb, \"{[%s.%s] audio_level: %d/%d}\",\n\t\t\t\t    uid_anon, cid_anon,\n\t\t\t\t    a->aulevel_smooth, a->aulevel);\n\t\t\tif (le != levell->tail)\n\t\t\t\tmbuf_printf(pmb, \",\");\n\t\t}\t\t\n\t}\n\tjson_object_object_add(jobj, \"audio_levels\", jarr);\n\n\tif (pmb) {\n\t\tpmb->pos = 0;\n\t\tmbuf_strdup(pmb, anon_str, pmb->end);\n\t\tmem_deref(pmb);\n\t}\n\n\tjzon_encode(json_str, jobj);\n out:\t\n\tmem_deref(jobj);\n\n\treturn err;\n}",
        "func_after": "int audio_level_json(struct list *levell,\n\t\t     const char *userid_self, const char *clientid_self,\n\t\t     char **json_str, char **anon_str)\n{\n\tstruct json_object *jobj;\n\tstruct json_object *jarr;\n\tchar uid_anon[ANON_ID_LEN];\n\tchar cid_anon[ANON_CLIENT_LEN];\n\tstruct mbuf *pmb = NULL;\n\tint err = 0;\n\tstruct le *le;\n\n\tif (!levell || !json_str)\n\t\treturn EINVAL;\n\t\n\tjobj = jzon_alloc_object();\n\tif (!jobj)\n\t\treturn ENOMEM;\n\n\tjarr = jzon_alloc_array();\n\tif (!jarr) {\n\t\terr = ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (anon_str) {\n\t\tpmb = mbuf_alloc(512);\n\t\tmbuf_printf(pmb, \"%zu levels: \", list_count(levell));\n\t}\n\t\n\tLIST_FOREACH(levell, le) {\n\t\tstruct audio_level *a = le->data;\n\t\tstruct json_object *ja;\n\t\tconst char *userid = a->userid;\n\t\tconst char *clientid = a->clientid;\n\n\t\tif (a->is_self) {\n\t\t\tif (userid_self)\n\t\t\t\tuserid = userid_self;\n\t\t\tif (clientid_self)\n\t\t\t\tclientid = clientid_self;\n\t\t}\n\n\t\tja = jzon_alloc_object();\n\t\tif (ja) {\n\t\t\tjzon_add_str(ja, \"userid\", \"%s\", userid);\n\t\t\tjzon_add_str(ja, \"clientid\", \"%s\", clientid);\n\t\t\tjzon_add_int(ja, \"audio_level\",\n\t\t\t\t     (int32_t)a->aulevel_smooth);\n\t\t\tjzon_add_int(ja, \"audio_level_now\",\n\t\t\t\t     (int32_t)a->aulevel);\n\t\t}\n\t\tjson_object_array_add(jarr, ja);\n\n\t\t/* add to info string */\n\t\tif (pmb) {\n\t\t\tanon_id(uid_anon, userid);\n\t\t\tanon_client(cid_anon, clientid);\n\t\t\tmbuf_printf(pmb, \"{[%s.%s] audio_level: %d/%d}\",\n\t\t\t\t    uid_anon, cid_anon,\n\t\t\t\t    a->aulevel_smooth, a->aulevel);\n\t\t\tif (le != levell->tail)\n\t\t\t\tmbuf_printf(pmb, \",\");\n\t\t}\t\t\n\t}\n\tjson_object_object_add(jobj, \"audio_levels\", jarr);\n\n\tif (pmb) {\n\t\tpmb->pos = 0;\n\t\tmbuf_strdup(pmb, anon_str, pmb->end);\n\t\tmem_deref(pmb);\n\t}\n\n\tjzon_encode(json_str, jobj);\n out:\t\n\tmem_deref(jobj);\n\n\treturn err;\n}",
        "description": "A remote format string vulnerability in the wire-avs component of Wire, an open-source messenger, affects versions prior to 7.1.12. This vulnerability could lead to a denial of service or the execution of arbitrary code by an attacker. The issue has been addressed in wire-avs version 7.1.12, and there are currently no known workarounds available.",
        "commit": "The process of importing the latest release-7.1 files from an old repository."
    },
    {
        "cwe": "CWE-121",
        "func_name": "kernel/chap_server_compute_md5",
        "score": 0.7504315972328186,
        "func_before": "static int chap_server_compute_md5(\n\tstruct iscsi_conn *conn,\n\tstruct iscsi_node_auth *auth,\n\tchar *nr_in_ptr,\n\tchar *nr_out_ptr,\n\tunsigned int *nr_out_len)\n{\n\tunsigned long id;\n\tunsigned char id_as_uchar;\n\tunsigned char digest[MD5_SIGNATURE_SIZE];\n\tunsigned char type, response[MD5_SIGNATURE_SIZE * 2 + 2];\n\tunsigned char identifier[10], *challenge = NULL;\n\tunsigned char *challenge_binhex = NULL;\n\tunsigned char client_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char server_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char chap_n[MAX_CHAP_N_SIZE], chap_r[MAX_RESPONSE_LENGTH];\n\tsize_t compare_len;\n\tstruct iscsi_chap *chap = conn->auth_protocol;\n\tstruct crypto_shash *tfm = NULL;\n\tstruct shash_desc *desc = NULL;\n\tint auth_ret = -1, ret, challenge_len;\n\n\tmemset(identifier, 0, 10);\n\tmemset(chap_n, 0, MAX_CHAP_N_SIZE);\n\tmemset(chap_r, 0, MAX_RESPONSE_LENGTH);\n\tmemset(digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(response, 0, MD5_SIGNATURE_SIZE * 2 + 2);\n\tmemset(client_digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(server_digest, 0, MD5_SIGNATURE_SIZE);\n\n\tchallenge = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge) {\n\t\tpr_err(\"Unable to allocate challenge buffer\\n\");\n\t\tgoto out;\n\t}\n\n\tchallenge_binhex = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge_binhex) {\n\t\tpr_err(\"Unable to allocate challenge_binhex buffer\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Extract CHAP_N.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_N\", MAX_CHAP_N_SIZE, chap_n,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\tif (type == HEX) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Include the terminating NULL in the compare */\n\tcompare_len = strlen(auth->userid) + 1;\n\tif (strncmp(chap_n, auth->userid, compare_len) != 0) {\n\t\tpr_err(\"CHAP_N values do not match!\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_N=%s\\n\", chap_n);\n\t/*\n\t * Extract CHAP_R.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_R\", MAX_RESPONSE_LENGTH, chap_r,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"[server] Got CHAP_R=%s\\n\", chap_r);\n\tchap_string_to_hex(client_digest, chap_r, strlen(chap_r));\n\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\ttfm = NULL;\n\t\tpr_err(\"Unable to allocate struct crypto_shash\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);\n\tif (!desc) {\n\t\tpr_err(\"Unable to allocate struct shash_desc\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, &chap->id, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, (char *)&auth->password,\n\t\t\t\t  strlen(auth->password));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for password\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_finup(desc, chap->challenge,\n\t\t\t\t CHAP_CHALLENGE_LENGTH, server_digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for challenge\\n\");\n\t\tgoto out;\n\t}\n\n\tchap_binaryhex_to_asciihex(response, server_digest, MD5_SIGNATURE_SIZE);\n\tpr_debug(\"[server] MD5 Server Digest: %s\\n\", response);\n\n\tif (memcmp(server_digest, client_digest, MD5_SIGNATURE_SIZE) != 0) {\n\t\tpr_debug(\"[server] MD5 Digests do not match!\\n\\n\");\n\t\tgoto out;\n\t} else\n\t\tpr_debug(\"[server] MD5 Digests match, CHAP connection\"\n\t\t\t\t\" successful.\\n\\n\");\n\t/*\n\t * One way authentication has succeeded, return now if mutual\n\t * authentication is not enabled.\n\t */\n\tif (!auth->authenticate_target) {\n\t\tauth_ret = 0;\n\t\tgoto out;\n\t}\n\t/*\n\t * Get CHAP_I.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_I\", 10, identifier, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_I.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type == HEX)\n\t\tret = kstrtoul(&identifier[2], 0, &id);\n\telse\n\t\tret = kstrtoul(identifier, 0, &id);\n\n\tif (ret < 0) {\n\t\tpr_err(\"kstrtoul() failed for CHAP identifier: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (id > 255) {\n\t\tpr_err(\"chap identifier: %lu greater than 255\\n\", id);\n\t\tgoto out;\n\t}\n\t/*\n\t * RFC 1994 says Identifier is no more than octet (8 bits).\n\t */\n\tpr_debug(\"[server] Got CHAP_I=%lu\\n\", id);\n\t/*\n\t * Get CHAP_C.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_C\", CHAP_CHALLENGE_STR_LEN,\n\t\t\tchallenge, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_C=%s\\n\", challenge);\n\tchallenge_len = chap_string_to_hex(challenge_binhex, challenge,\n\t\t\t\tstrlen(challenge));\n\tif (!challenge_len) {\n\t\tpr_err(\"Unable to convert incoming challenge\\n\");\n\t\tgoto out;\n\t}\n\tif (challenge_len > 1024) {\n\t\tpr_err(\"CHAP_C exceeds maximum binary size of 1024 bytes\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * During mutual authentication, the CHAP_C generated by the\n\t * initiator must not match the original CHAP_C generated by\n\t * the target.\n\t */\n\tif (!memcmp(challenge_binhex, chap->challenge, CHAP_CHALLENGE_LENGTH)) {\n\t\tpr_err(\"initiator CHAP_C matches target CHAP_C, failing\"\n\t\t       \" login attempt\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Generate CHAP_N and CHAP_R for mutual authentication.\n\t */\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* To handle both endiannesses */\n\tid_as_uchar = id;\n\tret = crypto_shash_update(desc, &id_as_uchar, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, auth->password_mutual,\n\t\t\t\t  strlen(auth->password_mutual));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for\"\n\t\t\t\t\" password_mutual\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Convert received challenge to binary hex.\n\t */\n\tret = crypto_shash_finup(desc, challenge_binhex, challenge_len,\n\t\t\t\t digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for ma challenge\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Generate CHAP_N and CHAP_R.\n\t */\n\t*nr_out_len = sprintf(nr_out_ptr, \"CHAP_N=%s\", auth->userid_mutual);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_N=%s\\n\", auth->userid_mutual);\n\t/*\n\t * Convert response from binary hex to ascii hext.\n\t */\n\tchap_binaryhex_to_asciihex(response, digest, MD5_SIGNATURE_SIZE);\n\t*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, \"CHAP_R=0x%s\",\n\t\t\tresponse);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_R=0x%s\\n\", response);\n\tauth_ret = 0;\nout:\n\tkzfree(desc);\n\tif (tfm)\n\t\tcrypto_free_shash(tfm);\n\tkfree(challenge);\n\tkfree(challenge_binhex);\n\treturn auth_ret;\n}",
        "func_after": "static int chap_server_compute_md5(\n\tstruct iscsi_conn *conn,\n\tstruct iscsi_node_auth *auth,\n\tchar *nr_in_ptr,\n\tchar *nr_out_ptr,\n\tunsigned int *nr_out_len)\n{\n\tunsigned long id;\n\tunsigned char id_as_uchar;\n\tunsigned char digest[MD5_SIGNATURE_SIZE];\n\tunsigned char type, response[MD5_SIGNATURE_SIZE * 2 + 2];\n\tunsigned char identifier[10], *challenge = NULL;\n\tunsigned char *challenge_binhex = NULL;\n\tunsigned char client_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char server_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char chap_n[MAX_CHAP_N_SIZE], chap_r[MAX_RESPONSE_LENGTH];\n\tsize_t compare_len;\n\tstruct iscsi_chap *chap = conn->auth_protocol;\n\tstruct crypto_shash *tfm = NULL;\n\tstruct shash_desc *desc = NULL;\n\tint auth_ret = -1, ret, challenge_len;\n\n\tmemset(identifier, 0, 10);\n\tmemset(chap_n, 0, MAX_CHAP_N_SIZE);\n\tmemset(chap_r, 0, MAX_RESPONSE_LENGTH);\n\tmemset(digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(response, 0, MD5_SIGNATURE_SIZE * 2 + 2);\n\tmemset(client_digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(server_digest, 0, MD5_SIGNATURE_SIZE);\n\n\tchallenge = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge) {\n\t\tpr_err(\"Unable to allocate challenge buffer\\n\");\n\t\tgoto out;\n\t}\n\n\tchallenge_binhex = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge_binhex) {\n\t\tpr_err(\"Unable to allocate challenge_binhex buffer\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Extract CHAP_N.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_N\", MAX_CHAP_N_SIZE, chap_n,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\tif (type == HEX) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Include the terminating NULL in the compare */\n\tcompare_len = strlen(auth->userid) + 1;\n\tif (strncmp(chap_n, auth->userid, compare_len) != 0) {\n\t\tpr_err(\"CHAP_N values do not match!\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_N=%s\\n\", chap_n);\n\t/*\n\t * Extract CHAP_R.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_R\", MAX_RESPONSE_LENGTH, chap_r,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (strlen(chap_r) != MD5_SIGNATURE_SIZE * 2) {\n\t\tpr_err(\"Malformed CHAP_R\\n\");\n\t\tgoto out;\n\t}\n\tif (hex2bin(client_digest, chap_r, MD5_SIGNATURE_SIZE) < 0) {\n\t\tpr_err(\"Malformed CHAP_R\\n\");\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"[server] Got CHAP_R=%s\\n\", chap_r);\n\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\ttfm = NULL;\n\t\tpr_err(\"Unable to allocate struct crypto_shash\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);\n\tif (!desc) {\n\t\tpr_err(\"Unable to allocate struct shash_desc\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, &chap->id, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, (char *)&auth->password,\n\t\t\t\t  strlen(auth->password));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for password\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_finup(desc, chap->challenge,\n\t\t\t\t CHAP_CHALLENGE_LENGTH, server_digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for challenge\\n\");\n\t\tgoto out;\n\t}\n\n\tchap_binaryhex_to_asciihex(response, server_digest, MD5_SIGNATURE_SIZE);\n\tpr_debug(\"[server] MD5 Server Digest: %s\\n\", response);\n\n\tif (memcmp(server_digest, client_digest, MD5_SIGNATURE_SIZE) != 0) {\n\t\tpr_debug(\"[server] MD5 Digests do not match!\\n\\n\");\n\t\tgoto out;\n\t} else\n\t\tpr_debug(\"[server] MD5 Digests match, CHAP connection\"\n\t\t\t\t\" successful.\\n\\n\");\n\t/*\n\t * One way authentication has succeeded, return now if mutual\n\t * authentication is not enabled.\n\t */\n\tif (!auth->authenticate_target) {\n\t\tauth_ret = 0;\n\t\tgoto out;\n\t}\n\t/*\n\t * Get CHAP_I.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_I\", 10, identifier, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_I.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type == HEX)\n\t\tret = kstrtoul(&identifier[2], 0, &id);\n\telse\n\t\tret = kstrtoul(identifier, 0, &id);\n\n\tif (ret < 0) {\n\t\tpr_err(\"kstrtoul() failed for CHAP identifier: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (id > 255) {\n\t\tpr_err(\"chap identifier: %lu greater than 255\\n\", id);\n\t\tgoto out;\n\t}\n\t/*\n\t * RFC 1994 says Identifier is no more than octet (8 bits).\n\t */\n\tpr_debug(\"[server] Got CHAP_I=%lu\\n\", id);\n\t/*\n\t * Get CHAP_C.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_C\", CHAP_CHALLENGE_STR_LEN,\n\t\t\tchallenge, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\tchallenge_len = DIV_ROUND_UP(strlen(challenge), 2);\n\tif (!challenge_len) {\n\t\tpr_err(\"Unable to convert incoming challenge\\n\");\n\t\tgoto out;\n\t}\n\tif (challenge_len > 1024) {\n\t\tpr_err(\"CHAP_C exceeds maximum binary size of 1024 bytes\\n\");\n\t\tgoto out;\n\t}\n\tif (hex2bin(challenge_binhex, challenge, challenge_len) < 0) {\n\t\tpr_err(\"Malformed CHAP_C\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_C=%s\\n\", challenge);\n\t/*\n\t * During mutual authentication, the CHAP_C generated by the\n\t * initiator must not match the original CHAP_C generated by\n\t * the target.\n\t */\n\tif (!memcmp(challenge_binhex, chap->challenge, CHAP_CHALLENGE_LENGTH)) {\n\t\tpr_err(\"initiator CHAP_C matches target CHAP_C, failing\"\n\t\t       \" login attempt\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Generate CHAP_N and CHAP_R for mutual authentication.\n\t */\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* To handle both endiannesses */\n\tid_as_uchar = id;\n\tret = crypto_shash_update(desc, &id_as_uchar, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, auth->password_mutual,\n\t\t\t\t  strlen(auth->password_mutual));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for\"\n\t\t\t\t\" password_mutual\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Convert received challenge to binary hex.\n\t */\n\tret = crypto_shash_finup(desc, challenge_binhex, challenge_len,\n\t\t\t\t digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for ma challenge\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Generate CHAP_N and CHAP_R.\n\t */\n\t*nr_out_len = sprintf(nr_out_ptr, \"CHAP_N=%s\", auth->userid_mutual);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_N=%s\\n\", auth->userid_mutual);\n\t/*\n\t * Convert response from binary hex to ascii hext.\n\t */\n\tchap_binaryhex_to_asciihex(response, digest, MD5_SIGNATURE_SIZE);\n\t*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, \"CHAP_R=0x%s\",\n\t\t\tresponse);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_R=0x%s\\n\", response);\n\tauth_ret = 0;\nout:\n\tkzfree(desc);\n\tif (tfm)\n\t\tcrypto_free_shash(tfm);\n\tkfree(challenge);\n\tkfree(challenge_binhex);\n\treturn auth_ret;\n}",
        "description": "A security flaw exists in the chap_server_compute_md5() function within the ISCSI target code of the Linux kernel, where an unauthenticated remote attacker can exploit a stack buffer overflow to overwrite up to 17 bytes of the stack. This vulnerability arises during the processing of an authentication request from an ISCSI initiator. For an attack to be successful, the iSCSI target must be enabled on the victim host. The impact of the overflow varies based on the target's build environment, including the compiler, compile flags, and hardware architecture, potentially leading to a system crash, denial-of-service, or unauthorized access to data exported by the iSCSI target. Although privilege escalation is not conclusively proven, it remains a concern. This vulnerability affects kernel versions 4.18.x, 4.14.x, and 3.10.x.",
        "commit": "Please provide the specific vulnerability knowledge you would like me to abstract and generalize."
    },
    {
        "cwe": "CWE-776",
        "func_name": "libexpat/externalParEntProcessor",
        "score": 0.7045387625694275,
        "func_before": "static enum XML_Error PTRCALL\nexternalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: /* start == end */\n    default:\n      break;\n    }\n  }\n  /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.\n     However, when parsing an external subset, doProlog will not accept a BOM\n     as valid, and report a syntax error, so we have to skip the BOM\n  */\n  else if (tok == XML_TOK_BOM) {\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}",
        "func_after": "static enum XML_Error PTRCALL\nexternalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: /* start == end */\n    default:\n      break;\n    }\n  }\n  /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.\n     However, when parsing an external subset, doProlog will not accept a BOM\n     as valid, and report a syntax error, so we have to skip the BOM\n  */\n  else if (tok == XML_TOK_BOM) {\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);\n}",
        "description": "In versions of libexpat prior to 2.2.8, maliciously crafted XML input could cause the parser to prematurely transition from DTD parsing to document parsing. Subsequently, invoking functions such as XML_GetCurrentLineNumber or XML_GetCurrentColumnNumber led to a heap-based buffer over-read.",
        "commit": "output: \"Denial of service vulnerability due to improper handling of internal entities within the XML parsing process.\""
    },
    {
        "cwe": "CWE-617",
        "func_name": "jerryscript-project/ecma_op_object_get_property_names",
        "score": 0.753816545009613,
        "func_before": "ecma_collection_t *\necma_op_object_get_property_names (ecma_object_t *obj_p, /**< object */\n                                   uint32_t opts) /**< any combination of ecma_list_properties_options_t values  */\n{\n  JERRY_ASSERT (obj_p != NULL\n                && !ecma_is_lexical_environment (obj_p));\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_IS_PROXY (obj_p))\n  {\n    return ecma_proxy_object_own_property_keys (obj_p);\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  if (ecma_op_object_is_fast_array (obj_p))\n  {\n    return ecma_fast_array_get_property_names (obj_p, opts);\n  }\n\n  ecma_collection_t *ret_p = ecma_new_collection ();\n  ecma_collection_t *skipped_non_enumerable_p = ecma_new_collection ();\n\n  const bool is_enumerable_only = (opts & ECMA_LIST_ENUMERABLE) != 0;\n  const bool is_array_indices_only = (opts & ECMA_LIST_ARRAY_INDICES) != 0;\n  const bool is_with_prototype_chain = (opts & ECMA_LIST_PROTOTYPE) != 0;\n#if ENABLED (JERRY_ES2015)\n  const bool is_symbols = (opts & ECMA_LIST_SYMBOLS) != 0;\n  const bool is_symbols_only = (opts & ECMA_LIST_SYMBOLS_ONLY) != 0;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  const size_t bitmap_row_size = sizeof (uint32_t) * JERRY_BITSINBYTE;\n  const size_t names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size;\n  JERRY_VLA (uint32_t, names_hashes_bitmap, names_hashes_bitmap_size);\n\n  memset (names_hashes_bitmap, 0, names_hashes_bitmap_size * sizeof (names_hashes_bitmap[0]));\n\n  while (true)\n  {\n    const ecma_object_type_t type = ecma_get_object_type (obj_p);\n    const bool obj_is_builtin = ecma_get_object_is_builtin (obj_p);\n    ecma_length_t string_named_properties_count = 0;\n    ecma_length_t array_index_named_properties_count = 0;\n#if ENABLED (JERRY_ES2015)\n    ecma_length_t symbol_named_properties_count = 0;\n#endif /* ENABLED (JERRY_ES2015) */\n    ecma_collection_t *prop_names_p = ecma_new_collection ();\n\n#if ENABLED (JERRY_ES2015)\n    if (JERRY_LIKELY (!is_symbols_only))\n    {\n#endif /* ENABLED (JERRY_ES2015) */\n\n      if (obj_is_builtin)\n      {\n        if (type == ECMA_OBJECT_TYPE_FUNCTION && ecma_builtin_function_is_routine (obj_p))\n        {\n          ecma_builtin_routine_list_lazy_property_names (obj_p,\n                                                          opts,\n                                                          prop_names_p,\n                                                          skipped_non_enumerable_p);\n        }\n        else\n        {\n          ecma_builtin_list_lazy_property_names (obj_p,\n                                                 opts,\n                                                 prop_names_p,\n                                                 skipped_non_enumerable_p);\n        }\n      }\n      else\n      {\n        switch (type)\n        {\n          case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:\n          {\n  #if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n            if (ecma_object_is_typedarray (obj_p))\n            {\n              ecma_op_typedarray_list_lazy_property_names (obj_p, prop_names_p);\n            }\n  #endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n            break;\n          }\n          case ECMA_OBJECT_TYPE_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_function_list_lazy_property_names (obj_p,\n                                                         opts,\n                                                         prop_names_p,\n                                                         skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_external_function_list_lazy_property_names (obj_p,\n                                                                  opts,\n                                                                  prop_names_p,\n                                                                  skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_bound_function_list_lazy_property_names (obj_p,\n                                                               opts,\n                                                               prop_names_p,\n                                                               skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_CLASS:\n          {\n            ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n            if (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_STRING_UL)\n            {\n              ecma_op_string_list_lazy_property_names (obj_p,\n                                                       opts,\n                                                       prop_names_p,\n                                                       skipped_non_enumerable_p);\n            }\n\n            break;\n          }\n          case ECMA_OBJECT_TYPE_ARRAY:\n          {\n            ecma_op_array_list_lazy_property_names (obj_p,\n                                                    opts,\n                                                    prop_names_p,\n                                                    skipped_non_enumerable_p);\n            break;\n          }\n          default:\n          {\n            JERRY_ASSERT (type == ECMA_OBJECT_TYPE_GENERAL);\n\n            break;\n          }\n        }\n      }\n#if ENABLED (JERRY_ES2015)\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    ecma_value_t *buffer_p = prop_names_p->buffer_p;\n    uint32_t lazy_prop_name_count = prop_names_p->item_count;\n\n    const size_t own_names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size;\n    JERRY_VLA (uint32_t, own_names_hashes_bitmap, own_names_hashes_bitmap_size);\n    memset (own_names_hashes_bitmap, 0, own_names_hashes_bitmap_size * sizeof (own_names_hashes_bitmap[0]));\n\n    for (uint32_t i = 0; i < prop_names_p->item_count; i++)\n    {\n      ecma_string_t *name_p = ecma_get_string_from_value (buffer_p[i]);\n\n      if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)\n      {\n        array_index_named_properties_count++;\n      }\n#if ENABLED (JERRY_ES2015)\n      else if (ecma_prop_name_is_symbol (name_p))\n      {\n        symbol_named_properties_count++;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      else\n      {\n        string_named_properties_count++;\n      }\n\n#if ENABLED (JERRY_ES2015)\n      /* Symbols are never lazy listed */\n      JERRY_ASSERT (!ecma_prop_name_is_symbol (name_p));\n#endif /* ENABLED (JERRY_ES2015) */\n\n      uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n      uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n      uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n      if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0)\n      {\n        own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n      }\n    }\n\n    jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp;\n\n    if (ecma_op_object_is_fast_array (obj_p) && prop_iter_cp != JMEM_CP_NULL)\n    {\n      ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;\n\n      uint32_t length = ext_obj_p->u.array.length;\n      array_index_named_properties_count = length - ecma_fast_array_get_hole_count (obj_p);\n\n      ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, prop_iter_cp);\n\n      for (uint32_t i = 0; i < length; i++)\n      {\n        if (ecma_is_value_array_hole (values_p[i]))\n        {\n          continue;\n        }\n\n        ecma_string_t *index_str_p = ecma_new_ecma_string_from_uint32 (i);\n\n        uint8_t hash = (uint8_t) ecma_string_hash (index_str_p);\n        uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n        uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n        bool is_add = true;\n\n        if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0)\n        {\n          buffer_p = prop_names_p->buffer_p;\n\n          for (uint32_t j = 0; j < prop_names_p->item_count; j++)\n          {\n            ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n            if (ecma_compare_ecma_strings (index_str_p, current_name_p))\n            {\n              is_add = false;\n              break;\n            }\n          }\n        }\n\n        if (is_add)\n        {\n          own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n\n          ecma_collection_push_back (prop_names_p, ecma_make_string_value (index_str_p));\n        }\n      }\n    }\n    else\n    {\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n      if (prop_iter_cp != JMEM_CP_NULL)\n      {\n        ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n        if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n        {\n          prop_iter_cp = prop_iter_p->next_property_cp;\n        }\n      }\n  #endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n      while (prop_iter_cp != JMEM_CP_NULL)\n      {\n        ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n        JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n        for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)\n        {\n          ecma_property_t *property_p = prop_iter_p->types + i;\n\n          if (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA\n              || ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR)\n          {\n            ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n            if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_MAGIC\n                && prop_pair_p->names_cp[i] >= LIT_NON_INTERNAL_MAGIC_STRING__COUNT\n                && prop_pair_p->names_cp[i] < LIT_MAGIC_STRING__COUNT)\n            {\n              /* Internal properties are never enumerated. */\n              continue;\n            }\n\n            ecma_string_t *name_p = ecma_string_from_property_name (*property_p,\n                                                                    prop_pair_p->names_cp[i]);\n\n            if (!(is_enumerable_only && !ecma_is_property_enumerable (*property_p)))\n            {\n  #if ENABLED (JERRY_ES2015)\n              /* We skip the current property in the following cases:\n                 1. We don't want to list symbols (is_symbols and is_symbols_only are false)\n                    and the current property is a symbol.\n                 2. We only want to list symbols (is_symbols_only is true) and the current\n                    property is NOT a symbol. */\n              bool is_symbol = ecma_prop_name_is_symbol (name_p);\n              if ((!(is_symbols || is_symbols_only) && is_symbol) || (is_symbols_only && !is_symbol))\n              {\n                ecma_deref_ecma_string (name_p);\n                continue;\n              }\n  #endif /* ENABLED (JERRY_ES2015) */\n\n              uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n              uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n              uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n              bool is_add = true;\n\n              if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0)\n              {\n                buffer_p = prop_names_p->buffer_p;\n\n                for (uint32_t j = 0; j < prop_names_p->item_count; j++)\n                {\n                  ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n                  if (ecma_compare_ecma_strings (name_p, current_name_p))\n                  {\n                    is_add = false;\n                    break;\n                  }\n                }\n              }\n\n              if (is_add)\n              {\n                if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)\n                {\n                  /* The name is a valid array index. */\n                  array_index_named_properties_count++;\n                }\n                else if (!is_array_indices_only)\n                {\n  #if ENABLED (JERRY_ES2015)\n                  if (ecma_prop_name_is_symbol (name_p))\n                  {\n                    symbol_named_properties_count++;\n                  }\n                  else\n                  {\n  #endif /* ENABLED (JERRY_ES2015) */\n                    string_named_properties_count++;\n  #if ENABLED (JERRY_ES2015)\n                  }\n  #endif /* ENABLED (JERRY_ES2015) */\n                }\n                else\n                {\n                  ecma_deref_ecma_string (name_p);\n                  continue;\n                }\n\n                own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n\n                ecma_collection_push_back (prop_names_p, ecma_make_prop_name_value (name_p));\n              }\n              else\n              {\n                ecma_deref_ecma_string (name_p);\n              }\n            }\n            else\n            {\n              JERRY_ASSERT (is_enumerable_only && !ecma_is_property_enumerable (*property_p));\n\n              ecma_collection_push_back (skipped_non_enumerable_p, ecma_make_prop_name_value (name_p));\n            }\n          }\n        }\n\n        prop_iter_cp = prop_iter_p->next_property_cp;\n      }\n    }\n\n    ecma_length_t all_properties_count = array_index_named_properties_count + string_named_properties_count;\n\n#if ENABLED (JERRY_ES2015)\n    all_properties_count += symbol_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    /* Second pass: collecting property names into an array. */\n    JMEM_DEFINE_LOCAL_ARRAY (names_p, all_properties_count, ecma_string_t *);\n\n    ecma_string_t **string_names_p = names_p + array_index_named_properties_count;\n#if ENABLED (JERRY_ES2015)\n    ecma_string_t **symbol_names_p = string_names_p + string_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    uint32_t array_index_name_pos = 0;\n    uint32_t string_name_pos = string_named_properties_count;\n    uint32_t lazy_string_name_pos = 0;\n#if ENABLED (JERRY_ES2015)\n    uint32_t symbol_name_pos = symbol_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    buffer_p = prop_names_p->buffer_p;\n\n    for (uint32_t i = 0; i < prop_names_p->item_count; i++)\n    {\n      ecma_string_t *name_p = ecma_get_prop_name_from_value (buffer_p[i]);\n      ecma_ref_ecma_string (name_p);\n\n      uint32_t index = ecma_string_get_array_index (name_p);\n\n      if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n      {\n        JERRY_ASSERT (array_index_name_pos < array_index_named_properties_count);\n\n        uint32_t insertion_pos = 0;\n        while (insertion_pos < array_index_name_pos\n               && index > ecma_string_get_array_index (names_p[insertion_pos]))\n        {\n          insertion_pos++;\n        }\n\n        if (insertion_pos == array_index_name_pos)\n        {\n          names_p[array_index_name_pos++] = name_p;\n        }\n        else\n        {\n          JERRY_ASSERT (insertion_pos < array_index_name_pos);\n          JERRY_ASSERT (index <= ecma_string_get_array_index (names_p[insertion_pos]));\n\n          uint32_t move_pos = array_index_name_pos++;\n\n          while (move_pos > insertion_pos)\n          {\n            names_p[move_pos] = names_p[move_pos - 1u];\n\n            move_pos--;\n          }\n\n          names_p[insertion_pos] = name_p;\n        }\n      }\n#if ENABLED (JERRY_ES2015)\n      else if (ecma_prop_name_is_symbol (name_p))\n      {\n        // Put in the symbols in reverse order.\n        JERRY_ASSERT (symbol_name_pos > 0);\n        JERRY_ASSERT (symbol_name_pos <= symbol_named_properties_count);\n\n        symbol_names_p[--symbol_name_pos] = name_p;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      else\n      {\n        // Put in the strings in reverse order.\n        JERRY_ASSERT (string_name_pos > 0);\n        JERRY_ASSERT (string_name_pos <= string_named_properties_count);\n\n        if (i < lazy_prop_name_count)\n        {\n          string_names_p[lazy_string_name_pos++] = name_p;\n        }\n        else\n        {\n          string_names_p[--string_name_pos] = name_p;\n        }\n      }\n    }\n\n    JERRY_ASSERT (array_index_name_pos == array_index_named_properties_count);\n    JERRY_ASSERT (string_name_pos - lazy_string_name_pos == 0);\n#if ENABLED (JERRY_ES2015)\n    JERRY_ASSERT (symbol_name_pos == 0);\n#endif /* ENABLED (JERRY_ES2015) */\n\n    ecma_collection_free (prop_names_p);\n\n    /* Third pass:\n     *   embedding own property names of current object of prototype chain to aggregate property names collection */\n    for (uint32_t i = 0; i < all_properties_count; i++)\n    {\n      bool is_append = true;\n\n      ecma_string_t *name_p = names_p[i];\n\n      uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n      uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n      uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n      if ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0)\n      {\n        /* This hash has not been used before (for non-skipped). */\n        names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n      }\n      else\n      {\n        /* Name with same hash has already occured. */\n        buffer_p = ret_p->buffer_p;\n\n        for (uint32_t j = 0; j < ret_p->item_count; j++)\n        {\n          ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n          if (ecma_compare_ecma_strings (name_p, current_name_p))\n          {\n            is_append = false;\n            break;\n          }\n        }\n      }\n\n      if (is_append)\n      {\n        buffer_p = skipped_non_enumerable_p->buffer_p;\n\n        for (uint32_t j = 0; j < skipped_non_enumerable_p->item_count; j++)\n        {\n          ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n          if (ecma_compare_ecma_strings (name_p, current_name_p))\n          {\n            is_append = false;\n            break;\n          }\n        }\n      }\n\n      if (is_append)\n      {\n        JERRY_ASSERT ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0);\n\n        ecma_collection_push_back (ret_p, ecma_make_prop_name_value (name_p));\n      }\n      else\n      {\n        ecma_deref_ecma_string (name_p);\n      }\n\n    }\n\n    JMEM_FINALIZE_LOCAL_ARRAY (names_p);\n\n    if (!is_with_prototype_chain || obj_p->u2.prototype_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_p->u2.prototype_cp);\n  }\n\n  ecma_collection_free (skipped_non_enumerable_p);\n\n  return ret_p;\n}",
        "func_after": "ecma_collection_t *\necma_op_object_get_property_names (ecma_object_t *obj_p, /**< object */\n                                   uint32_t opts) /**< any combination of ecma_list_properties_options_t values  */\n{\n  JERRY_ASSERT (obj_p != NULL\n                && !ecma_is_lexical_environment (obj_p));\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_IS_PROXY (obj_p))\n  {\n    /* Integrated a part of ECMA 262 v6 7.3.21 EnumerableOwnNames operation. */\n    ecma_collection_t *proxy_keys = ecma_proxy_object_own_property_keys (obj_p);\n    if (JERRY_UNLIKELY (proxy_keys == NULL))\n    {\n      return proxy_keys;\n    }\n    ecma_collection_t *return_keys = ecma_new_collection ();\n\n    /* Move valid elements to the output collection */\n    for (uint32_t i = 0; i < proxy_keys->item_count; i++)\n    {\n      ecma_value_t entry = proxy_keys->buffer_p[i];\n      ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (entry);\n      bool prop_is_symbol = ecma_prop_name_is_symbol (prop_name_p);\n\n      if (prop_is_symbol && ((opts & (ECMA_LIST_SYMBOLS | ECMA_LIST_SYMBOLS_ONLY)) != 0))\n      {\n        ecma_collection_push_back (return_keys, entry);\n      }\n      else if (!prop_is_symbol && (opts & ECMA_LIST_SYMBOLS_ONLY) == 0)\n      {\n        ecma_collection_push_back (return_keys, entry);\n      }\n      else\n      {\n        ecma_free_value (entry);\n      }\n    }\n\n    ecma_collection_destroy (proxy_keys);\n    return return_keys;\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  if (ecma_op_object_is_fast_array (obj_p))\n  {\n    return ecma_fast_array_get_property_names (obj_p, opts);\n  }\n\n  ecma_collection_t *ret_p = ecma_new_collection ();\n  ecma_collection_t *skipped_non_enumerable_p = ecma_new_collection ();\n\n  const bool is_enumerable_only = (opts & ECMA_LIST_ENUMERABLE) != 0;\n  const bool is_array_indices_only = (opts & ECMA_LIST_ARRAY_INDICES) != 0;\n  const bool is_with_prototype_chain = (opts & ECMA_LIST_PROTOTYPE) != 0;\n#if ENABLED (JERRY_ES2015)\n  const bool is_symbols = (opts & ECMA_LIST_SYMBOLS) != 0;\n  const bool is_symbols_only = (opts & ECMA_LIST_SYMBOLS_ONLY) != 0;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  const size_t bitmap_row_size = sizeof (uint32_t) * JERRY_BITSINBYTE;\n  const size_t names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size;\n  JERRY_VLA (uint32_t, names_hashes_bitmap, names_hashes_bitmap_size);\n\n  memset (names_hashes_bitmap, 0, names_hashes_bitmap_size * sizeof (names_hashes_bitmap[0]));\n\n  while (true)\n  {\n    const ecma_object_type_t type = ecma_get_object_type (obj_p);\n    const bool obj_is_builtin = ecma_get_object_is_builtin (obj_p);\n    ecma_length_t string_named_properties_count = 0;\n    ecma_length_t array_index_named_properties_count = 0;\n#if ENABLED (JERRY_ES2015)\n    ecma_length_t symbol_named_properties_count = 0;\n#endif /* ENABLED (JERRY_ES2015) */\n    ecma_collection_t *prop_names_p = ecma_new_collection ();\n\n#if ENABLED (JERRY_ES2015)\n    if (JERRY_LIKELY (!is_symbols_only))\n    {\n#endif /* ENABLED (JERRY_ES2015) */\n\n      if (obj_is_builtin)\n      {\n        if (type == ECMA_OBJECT_TYPE_FUNCTION && ecma_builtin_function_is_routine (obj_p))\n        {\n          ecma_builtin_routine_list_lazy_property_names (obj_p,\n                                                          opts,\n                                                          prop_names_p,\n                                                          skipped_non_enumerable_p);\n        }\n        else\n        {\n          ecma_builtin_list_lazy_property_names (obj_p,\n                                                 opts,\n                                                 prop_names_p,\n                                                 skipped_non_enumerable_p);\n        }\n      }\n      else\n      {\n        switch (type)\n        {\n          case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:\n          {\n  #if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n            if (ecma_object_is_typedarray (obj_p))\n            {\n              ecma_op_typedarray_list_lazy_property_names (obj_p, prop_names_p);\n            }\n  #endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n            break;\n          }\n          case ECMA_OBJECT_TYPE_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_function_list_lazy_property_names (obj_p,\n                                                         opts,\n                                                         prop_names_p,\n                                                         skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_external_function_list_lazy_property_names (obj_p,\n                                                                  opts,\n                                                                  prop_names_p,\n                                                                  skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_bound_function_list_lazy_property_names (obj_p,\n                                                               opts,\n                                                               prop_names_p,\n                                                               skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_CLASS:\n          {\n            ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n            if (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_STRING_UL)\n            {\n              ecma_op_string_list_lazy_property_names (obj_p,\n                                                       opts,\n                                                       prop_names_p,\n                                                       skipped_non_enumerable_p);\n            }\n\n            break;\n          }\n          case ECMA_OBJECT_TYPE_ARRAY:\n          {\n            ecma_op_array_list_lazy_property_names (obj_p,\n                                                    opts,\n                                                    prop_names_p,\n                                                    skipped_non_enumerable_p);\n            break;\n          }\n          default:\n          {\n            JERRY_ASSERT (type == ECMA_OBJECT_TYPE_GENERAL);\n\n            break;\n          }\n        }\n      }\n#if ENABLED (JERRY_ES2015)\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    ecma_value_t *buffer_p = prop_names_p->buffer_p;\n    uint32_t lazy_prop_name_count = prop_names_p->item_count;\n\n    const size_t own_names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size;\n    JERRY_VLA (uint32_t, own_names_hashes_bitmap, own_names_hashes_bitmap_size);\n    memset (own_names_hashes_bitmap, 0, own_names_hashes_bitmap_size * sizeof (own_names_hashes_bitmap[0]));\n\n    for (uint32_t i = 0; i < prop_names_p->item_count; i++)\n    {\n      ecma_string_t *name_p = ecma_get_string_from_value (buffer_p[i]);\n\n      if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)\n      {\n        array_index_named_properties_count++;\n      }\n#if ENABLED (JERRY_ES2015)\n      else if (ecma_prop_name_is_symbol (name_p))\n      {\n        symbol_named_properties_count++;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      else\n      {\n        string_named_properties_count++;\n      }\n\n#if ENABLED (JERRY_ES2015)\n      /* Symbols are never lazy listed */\n      JERRY_ASSERT (!ecma_prop_name_is_symbol (name_p));\n#endif /* ENABLED (JERRY_ES2015) */\n\n      uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n      uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n      uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n      if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0)\n      {\n        own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n      }\n    }\n\n    jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp;\n\n    if (ecma_op_object_is_fast_array (obj_p) && prop_iter_cp != JMEM_CP_NULL)\n    {\n      ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;\n\n      uint32_t length = ext_obj_p->u.array.length;\n      array_index_named_properties_count = length - ecma_fast_array_get_hole_count (obj_p);\n\n      ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, prop_iter_cp);\n\n      for (uint32_t i = 0; i < length; i++)\n      {\n        if (ecma_is_value_array_hole (values_p[i]))\n        {\n          continue;\n        }\n\n        ecma_string_t *index_str_p = ecma_new_ecma_string_from_uint32 (i);\n\n        uint8_t hash = (uint8_t) ecma_string_hash (index_str_p);\n        uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n        uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n        bool is_add = true;\n\n        if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0)\n        {\n          buffer_p = prop_names_p->buffer_p;\n\n          for (uint32_t j = 0; j < prop_names_p->item_count; j++)\n          {\n            ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n            if (ecma_compare_ecma_strings (index_str_p, current_name_p))\n            {\n              is_add = false;\n              break;\n            }\n          }\n        }\n\n        if (is_add)\n        {\n          own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n\n          ecma_collection_push_back (prop_names_p, ecma_make_string_value (index_str_p));\n        }\n      }\n    }\n    else\n    {\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n      if (prop_iter_cp != JMEM_CP_NULL)\n      {\n        ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n        if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n        {\n          prop_iter_cp = prop_iter_p->next_property_cp;\n        }\n      }\n  #endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n      while (prop_iter_cp != JMEM_CP_NULL)\n      {\n        ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n        JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n        for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)\n        {\n          ecma_property_t *property_p = prop_iter_p->types + i;\n\n          if (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA\n              || ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR)\n          {\n            ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n            if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_MAGIC\n                && prop_pair_p->names_cp[i] >= LIT_NON_INTERNAL_MAGIC_STRING__COUNT\n                && prop_pair_p->names_cp[i] < LIT_MAGIC_STRING__COUNT)\n            {\n              /* Internal properties are never enumerated. */\n              continue;\n            }\n\n            ecma_string_t *name_p = ecma_string_from_property_name (*property_p,\n                                                                    prop_pair_p->names_cp[i]);\n\n            if (!(is_enumerable_only && !ecma_is_property_enumerable (*property_p)))\n            {\n  #if ENABLED (JERRY_ES2015)\n              /* We skip the current property in the following cases:\n                 1. We don't want to list symbols (is_symbols and is_symbols_only are false)\n                    and the current property is a symbol.\n                 2. We only want to list symbols (is_symbols_only is true) and the current\n                    property is NOT a symbol. */\n              bool is_symbol = ecma_prop_name_is_symbol (name_p);\n              if ((!(is_symbols || is_symbols_only) && is_symbol) || (is_symbols_only && !is_symbol))\n              {\n                ecma_deref_ecma_string (name_p);\n                continue;\n              }\n  #endif /* ENABLED (JERRY_ES2015) */\n\n              uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n              uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n              uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n              bool is_add = true;\n\n              if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0)\n              {\n                buffer_p = prop_names_p->buffer_p;\n\n                for (uint32_t j = 0; j < prop_names_p->item_count; j++)\n                {\n                  ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n                  if (ecma_compare_ecma_strings (name_p, current_name_p))\n                  {\n                    is_add = false;\n                    break;\n                  }\n                }\n              }\n\n              if (is_add)\n              {\n                if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)\n                {\n                  /* The name is a valid array index. */\n                  array_index_named_properties_count++;\n                }\n                else if (!is_array_indices_only)\n                {\n  #if ENABLED (JERRY_ES2015)\n                  if (ecma_prop_name_is_symbol (name_p))\n                  {\n                    symbol_named_properties_count++;\n                  }\n                  else\n                  {\n  #endif /* ENABLED (JERRY_ES2015) */\n                    string_named_properties_count++;\n  #if ENABLED (JERRY_ES2015)\n                  }\n  #endif /* ENABLED (JERRY_ES2015) */\n                }\n                else\n                {\n                  ecma_deref_ecma_string (name_p);\n                  continue;\n                }\n\n                own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n\n                ecma_collection_push_back (prop_names_p, ecma_make_prop_name_value (name_p));\n              }\n              else\n              {\n                ecma_deref_ecma_string (name_p);\n              }\n            }\n            else\n            {\n              JERRY_ASSERT (is_enumerable_only && !ecma_is_property_enumerable (*property_p));\n\n              ecma_collection_push_back (skipped_non_enumerable_p, ecma_make_prop_name_value (name_p));\n            }\n          }\n        }\n\n        prop_iter_cp = prop_iter_p->next_property_cp;\n      }\n    }\n\n    ecma_length_t all_properties_count = array_index_named_properties_count + string_named_properties_count;\n\n#if ENABLED (JERRY_ES2015)\n    all_properties_count += symbol_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    /* Second pass: collecting property names into an array. */\n    JMEM_DEFINE_LOCAL_ARRAY (names_p, all_properties_count, ecma_string_t *);\n\n    ecma_string_t **string_names_p = names_p + array_index_named_properties_count;\n#if ENABLED (JERRY_ES2015)\n    ecma_string_t **symbol_names_p = string_names_p + string_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    uint32_t array_index_name_pos = 0;\n    uint32_t string_name_pos = string_named_properties_count;\n    uint32_t lazy_string_name_pos = 0;\n#if ENABLED (JERRY_ES2015)\n    uint32_t symbol_name_pos = symbol_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    buffer_p = prop_names_p->buffer_p;\n\n    for (uint32_t i = 0; i < prop_names_p->item_count; i++)\n    {\n      ecma_string_t *name_p = ecma_get_prop_name_from_value (buffer_p[i]);\n      ecma_ref_ecma_string (name_p);\n\n      uint32_t index = ecma_string_get_array_index (name_p);\n\n      if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n      {\n        JERRY_ASSERT (array_index_name_pos < array_index_named_properties_count);\n\n        uint32_t insertion_pos = 0;\n        while (insertion_pos < array_index_name_pos\n               && index > ecma_string_get_array_index (names_p[insertion_pos]))\n        {\n          insertion_pos++;\n        }\n\n        if (insertion_pos == array_index_name_pos)\n        {\n          names_p[array_index_name_pos++] = name_p;\n        }\n        else\n        {\n          JERRY_ASSERT (insertion_pos < array_index_name_pos);\n          JERRY_ASSERT (index <= ecma_string_get_array_index (names_p[insertion_pos]));\n\n          uint32_t move_pos = array_index_name_pos++;\n\n          while (move_pos > insertion_pos)\n          {\n            names_p[move_pos] = names_p[move_pos - 1u];\n\n            move_pos--;\n          }\n\n          names_p[insertion_pos] = name_p;\n        }\n      }\n#if ENABLED (JERRY_ES2015)\n      else if (ecma_prop_name_is_symbol (name_p))\n      {\n        // Put in the symbols in reverse order.\n        JERRY_ASSERT (symbol_name_pos > 0);\n        JERRY_ASSERT (symbol_name_pos <= symbol_named_properties_count);\n\n        symbol_names_p[--symbol_name_pos] = name_p;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      else\n      {\n        // Put in the strings in reverse order.\n        JERRY_ASSERT (string_name_pos > 0);\n        JERRY_ASSERT (string_name_pos <= string_named_properties_count);\n\n        if (i < lazy_prop_name_count)\n        {\n          string_names_p[lazy_string_name_pos++] = name_p;\n        }\n        else\n        {\n          string_names_p[--string_name_pos] = name_p;\n        }\n      }\n    }\n\n    JERRY_ASSERT (array_index_name_pos == array_index_named_properties_count);\n    JERRY_ASSERT (string_name_pos - lazy_string_name_pos == 0);\n#if ENABLED (JERRY_ES2015)\n    JERRY_ASSERT (symbol_name_pos == 0);\n#endif /* ENABLED (JERRY_ES2015) */\n\n    ecma_collection_free (prop_names_p);\n\n    /* Third pass:\n     *   embedding own property names of current object of prototype chain to aggregate property names collection */\n    for (uint32_t i = 0; i < all_properties_count; i++)\n    {\n      bool is_append = true;\n\n      ecma_string_t *name_p = names_p[i];\n\n      uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n      uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n      uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n      if ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0)\n      {\n        /* This hash has not been used before (for non-skipped). */\n        names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n      }\n      else\n      {\n        /* Name with same hash has already occured. */\n        buffer_p = ret_p->buffer_p;\n\n        for (uint32_t j = 0; j < ret_p->item_count; j++)\n        {\n          ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n          if (ecma_compare_ecma_strings (name_p, current_name_p))\n          {\n            is_append = false;\n            break;\n          }\n        }\n      }\n\n      if (is_append)\n      {\n        buffer_p = skipped_non_enumerable_p->buffer_p;\n\n        for (uint32_t j = 0; j < skipped_non_enumerable_p->item_count; j++)\n        {\n          ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n          if (ecma_compare_ecma_strings (name_p, current_name_p))\n          {\n            is_append = false;\n            break;\n          }\n        }\n      }\n\n      if (is_append)\n      {\n        JERRY_ASSERT ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0);\n\n        ecma_collection_push_back (ret_p, ecma_make_prop_name_value (name_p));\n      }\n      else\n      {\n        ecma_deref_ecma_string (name_p);\n      }\n\n    }\n\n    JMEM_FINALIZE_LOCAL_ARRAY (names_p);\n\n    if (!is_with_prototype_chain || obj_p->u2.prototype_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_p->u2.prototype_cp);\n  }\n\n  ecma_collection_free (skipped_non_enumerable_p);\n\n  return ret_p;\n}",
        "description": "JerryScript 2.2.0 allows attackers to trigger a denial of service (assertion failure) due to an unintended property key query result when interacting with a Proxy object.",
        "commit": "The property key query for Proxy objects in JerryScript always returned all keys, regardless of whether any symbols were requested or present in the resulting array."
    }
]