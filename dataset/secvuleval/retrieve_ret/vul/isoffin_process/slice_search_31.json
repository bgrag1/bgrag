[
    {
        "cwe": "CWE-835",
        "func_name": "torvalds/schedule",
        "score": 0.778049111366272,
        "func_before": "asmlinkage void __sched schedule(void)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq *rq;\n\tint cpu;\n\nneed_resched:\n\tpreempt_disable();\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\trcu_note_context_switch(cpu);\n\tprev = rq->curr;\n\n\trelease_kernel_lock(prev);\nneed_resched_nonpreemptible:\n\n\tschedule_debug(prev);\n\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\n\traw_spin_lock_irq(&rq->lock);\n\tclear_tsk_need_resched(prev);\n\n\tswitch_count = &prev->nivcsw;\n\tif (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\t/*\n\t\t\t * If a worker is going to sleep, notify and\n\t\t\t * ask workqueue whether it wants to wake up a\n\t\t\t * task to maintain concurrency.  If so, wake\n\t\t\t * up the task.\n\t\t\t */\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev, cpu);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup);\n\t\t\t}\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP);\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\n\tpre_schedule(rq, prev);\n\n\tif (unlikely(!rq->nr_running))\n\t\tidle_balance(cpu, rq);\n\n\tput_prev_task(rq, prev);\n\tnext = pick_next_task(rq);\n\n\tif (likely(prev != next)) {\n\t\tsched_info_switch(prev, next);\n\t\tperf_event_task_sched_out(prev, next);\n\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t++*switch_count;\n\n\t\tcontext_switch(rq, prev, next); /* unlocks the rq */\n\t\t/*\n\t\t * The context switch have flipped the stack from under us\n\t\t * and restored the local variables which were saved when\n\t\t * this task called schedule() in the past. prev == current\n\t\t * is still correct, but it can be moved to another cpu/rq.\n\t\t */\n\t\tcpu = smp_processor_id();\n\t\trq = cpu_rq(cpu);\n\t} else\n\t\traw_spin_unlock_irq(&rq->lock);\n\n\tpost_schedule(rq);\n\n\tif (unlikely(reacquire_kernel_lock(prev)))\n\t\tgoto need_resched_nonpreemptible;\n\n\tpreempt_enable_no_resched();\n\tif (need_resched())\n\t\tgoto need_resched;\n}",
        "func_after": "asmlinkage void __sched schedule(void)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq *rq;\n\tint cpu;\n\nneed_resched:\n\tpreempt_disable();\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\trcu_note_context_switch(cpu);\n\tprev = rq->curr;\n\n\trelease_kernel_lock(prev);\nneed_resched_nonpreemptible:\n\n\tschedule_debug(prev);\n\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\n\traw_spin_lock_irq(&rq->lock);\n\n\tswitch_count = &prev->nivcsw;\n\tif (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\t/*\n\t\t\t * If a worker is going to sleep, notify and\n\t\t\t * ask workqueue whether it wants to wake up a\n\t\t\t * task to maintain concurrency.  If so, wake\n\t\t\t * up the task.\n\t\t\t */\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev, cpu);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup);\n\t\t\t}\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP);\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\n\tpre_schedule(rq, prev);\n\n\tif (unlikely(!rq->nr_running))\n\t\tidle_balance(cpu, rq);\n\n\tput_prev_task(rq, prev);\n\tnext = pick_next_task(rq);\n\tclear_tsk_need_resched(prev);\n\trq->skip_clock_update = 0;\n\n\tif (likely(prev != next)) {\n\t\tsched_info_switch(prev, next);\n\t\tperf_event_task_sched_out(prev, next);\n\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t++*switch_count;\n\t\tWARN_ON_ONCE(test_tsk_need_resched(next));\n\n\t\tcontext_switch(rq, prev, next); /* unlocks the rq */\n\t\t/*\n\t\t * The context switch have flipped the stack from under us\n\t\t * and restored the local variables which were saved when\n\t\t * this task called schedule() in the past. prev == current\n\t\t * is still correct, but it can be moved to another cpu/rq.\n\t\t */\n\t\tcpu = smp_processor_id();\n\t\trq = cpu_rq(cpu);\n\t} else\n\t\traw_spin_unlock_irq(&rq->lock);\n\n\tpost_schedule(rq);\n\n\tif (unlikely(reacquire_kernel_lock(prev)))\n\t\tgoto need_resched_nonpreemptible;\n\n\tpreempt_enable_no_resched();\n\tif (need_resched())\n\t\tgoto need_resched;\n}",
        "description": "The Linux kernel prior to version 2.6.37 fails to correctly implement a specific clock-update optimization. This deficiency enables local users to trigger a denial of service (system hang) by executing an application that runs code in an infinite loop.",
        "commit": "The `idle_balance()` function in the scheduler module of the Linux kernel inadvertently leaves tasks vulnerable to `set_tsk_need_resched()` by dropping and retaking the runqueue lock (`rq->lock`). To address this issue, the optimization should be made robust by clearing the need for rescheduling after returning from balancing and in `setup_thread_stack()`. Additionally, the logic for the `skip_clock_update` optimization needs to be adjusted to ensure it correctly handles cases where a sleeping task is woken up before it successfully deschedules. This adjustment involves checking if the current task has been dequeued before setting the flag to avoid unnecessary clock updates. Finally, the flag should be cleared unconditionally in the `schedule()` function rather than conditionally in `put_prev_task()`."
    },
    {
        "cwe": "CWE-400",
        "func_name": "Exiv2/ProcessUTF8Portion",
        "score": 0.7705472111701965,
        "func_before": "static size_t\nProcessUTF8Portion ( XMLParserAdapter * xmlParser,\n\t\t\t\t\t const XMP_Uns8 *   buffer,\n\t\t\t\t\t size_t\t\t\t\tlength,\n\t\t\t\t\t bool\t\t\t\tlast )\n{\n\tconst XMP_Uns8 * bufEnd = buffer + length;\n\t\n\tconst XMP_Uns8 * spanStart = buffer;\n\tconst XMP_Uns8 * spanEnd;\n\t\t\n\tfor ( spanEnd = spanStart; spanEnd < bufEnd; ++spanEnd ) {\n\n\t\tif ( (0x20 <= *spanEnd) && (*spanEnd <= 0x7E) && (*spanEnd != '&') ) continue;\t// A regular ASCII character.\n\n\t\tif ( *spanEnd >= 0x80 ) {\n\t\t\n\t\t\t// See if this is a multi-byte UTF-8 sequence, or a Latin-1 character to replace.\n\n\t\t\tint uniLen = CountUTF8 ( spanEnd, bufEnd );\n\n\t\t\tif ( uniLen > 0 ) {\n\n\t\t\t\t// A valid UTF-8 character, keep it as-is.\n\t\t\t\tspanEnd += uniLen - 1;\t// ! The loop increment will put back the +1.\n\n\t\t\t} else if ( (uniLen < 0) && (! last) ) {\n\n\t\t\t\t// Have a partial UTF-8 character at the end of the buffer and more input coming.\n\t\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n\t\t\t\treturn (spanEnd - buffer);\n\n\t\t\t} else {\n\n\t\t\t\t// Not a valid UTF-8 sequence. Replace the first byte with the Latin-1 equivalent.\n\t\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n\t\t\t\tconst char * replacement = kReplaceLatin1 [ *spanEnd - 0x80 ];\n\t\t\t\txmlParser->ParseBuffer ( replacement, strlen ( replacement ), false );\n\t\t\t\tspanStart = spanEnd + 1;\t// ! The loop increment will do \"spanEnd = spanStart\".\n\n\t\t\t}\n\t\t\n\t\t} else if ( (*spanEnd < 0x20) || (*spanEnd == 0x7F) ) {\n\n\t\t\t// Replace ASCII controls other than tab, LF, and CR with a space.\n\n\t\t\tif ( (*spanEnd == kTab) || (*spanEnd == kLF) || (*spanEnd == kCR) ) continue;\n\n\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n\t\t\txmlParser->ParseBuffer ( \" \", 1, false );\n\t\t\tspanStart = spanEnd + 1;\t// ! The loop increment will do \"spanEnd = spanStart\".\n\t\t\n\t\t} else {\n\t\t\n\t\t\t// See if this is a numeric escape sequence for a prohibited ASCII control.\n\t\t\t\n\t\t\tXMP_Assert ( *spanEnd == '&' );\n\t\t\tint escLen = CountControlEscape ( spanEnd, bufEnd );\n\t\t\t\n\t\t\tif ( escLen < 0 ) {\n\n\t\t\t\t// Have a partial numeric escape in this buffer, wait for more input.\n\t\t\t\tif ( last ) continue;\t// No more buffers, not an escape, absorb as normal input.\n\t\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n\t\t\t\treturn (spanEnd - buffer);\n\n\t\t\t} else if ( escLen > 0 ) {\n\n\t\t\t\t// Have a complete numeric escape to replace.\n\t\t\t\txmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n\t\t\t\txmlParser->ParseBuffer ( \" \", 1, false );\n\t\t\t\tspanStart = spanEnd + escLen;\n\t\t\t\tspanEnd = spanStart - 1;\t// ! The loop continuation will increment spanEnd!\n\n\t\t\t}\n\n\t\t}\n\t\t\n\t}\n\t\n\tXMP_Assert ( spanEnd == bufEnd );\n\n\tif ( spanStart < bufEnd ) xmlParser->ParseBuffer ( spanStart, (spanEnd - spanStart), false );\n\tif ( last ) xmlParser->ParseBuffer ( \" \", 1, true );\n\t\n\treturn length;\n\n}",
        "func_after": "static size_t\nProcessUTF8Portion ( XMLParserAdapter * xmlParser,\n\t\t\t\t\t const XMP_Uns8 *   buffer,\n\t\t\t\t\t size_t\t\t\t\tlength,\n\t\t\t\t\t bool\t\t\t\tlast )\n{\n\tconst XMP_Uns8 * bufEnd = buffer + length;\n\t\n\tconst XMP_Uns8 * spanEnd;\n\n\t// `buffer` is copied into this std::string. If `buffer` only\n\t// contains valid UTF-8 and no escape characters, then the copy\n\t// will be identical to the original, but invalid characters are\n\t// replaced - usually with a space character.  This std::string was\n\t// added as a performance fix for:\n\t// https://github.com/Exiv2/exiv2/security/advisories/GHSA-w8mv-g8qq-36mj\n\t// Previously, the code was repeatedly calling\n\t// `xmlParser->ParseBuffer()`, which turned out to have quadratic\n\t// complexity, because expat kept reparsing the entire string from\n\t// the beginning.\n\tstd::string copy;\n\t\t\n\tfor ( spanEnd = buffer; spanEnd < bufEnd; ++spanEnd ) {\n\n\t\tif ( (0x20 <= *spanEnd) && (*spanEnd <= 0x7E) && (*spanEnd != '&') ) {\n\t\t\tcopy.push_back(*spanEnd);\n\t\t\tcontinue;\t// A regular ASCII character.\n\t\t}\n\n\t\tif ( *spanEnd >= 0x80 ) {\n\t\t\n\t\t\t// See if this is a multi-byte UTF-8 sequence, or a Latin-1 character to replace.\n\n\t\t\tint uniLen = CountUTF8 ( spanEnd, bufEnd );\n\n\t\t\tif ( uniLen > 0 ) {\n\n\t\t\t\t// A valid UTF-8 character, keep it as-is.\n\t\t\t\tcopy.append((const char*)spanEnd, uniLen);\n\t\t\t\tspanEnd += uniLen - 1;\t// ! The loop increment will put back the +1.\n\n\t\t\t} else if ( (uniLen < 0) && (! last) ) {\n\n\t\t\t\t// Have a partial UTF-8 character at the end of the buffer and more input coming.\n\t\t\t\txmlParser->ParseBuffer ( copy.c_str(), copy.size(), false );\n\t\t\t\treturn (spanEnd - buffer);\n\n\t\t\t} else {\n\n\t\t\t\t// Not a valid UTF-8 sequence. Replace the first byte with the Latin-1 equivalent.\n\t\t\t\tconst char * replacement = kReplaceLatin1 [ *spanEnd - 0x80 ];\n\t\t\t\tcopy.append ( replacement );\n\n\t\t\t}\n\t\t\n\t\t} else if ( (*spanEnd < 0x20) || (*spanEnd == 0x7F) ) {\n\n\t\t\t// Replace ASCII controls other than tab, LF, and CR with a space.\n\n\t\t\tif ( (*spanEnd == kTab) || (*spanEnd == kLF) || (*spanEnd == kCR) ) {\n\t\t\t\tcopy.push_back(*spanEnd);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcopy.push_back(' ');\n\t\t\n\t\t} else {\n\t\t\n\t\t\t// See if this is a numeric escape sequence for a prohibited ASCII control.\n\t\t\t\n\t\t\tXMP_Assert ( *spanEnd == '&' );\n\t\t\tint escLen = CountControlEscape ( spanEnd, bufEnd );\n\t\t\t\n\t\t\tif ( escLen < 0 ) {\n\n\t\t\t\t// Have a partial numeric escape in this buffer, wait for more input.\n\t\t\t\tif ( last ) {\n\t\t\t\t\tcopy.push_back('&');\n\t\t\t\t\tcontinue;\t// No more buffers, not an escape, absorb as normal input.\n\t\t\t\t}\n\t\t\t\txmlParser->ParseBuffer ( copy.c_str(), copy.size(), false );\n\t\t\t\treturn (spanEnd - buffer);\n\n\t\t\t} else if ( escLen > 0 ) {\n\n\t\t\t\t// Have a complete numeric escape to replace.\n\t\t\t\tcopy.push_back(' ');\n\t\t\t\tspanEnd = spanEnd + escLen - 1;\t// ! The loop continuation will increment spanEnd!\n\n\t\t\t} else {\n\t\t\t\tcopy.push_back('&');\n\t\t\t}\n\n\t\t}\n\t\t\n\t}\n\t\n\tXMP_Assert ( spanEnd == bufEnd );\n\tcopy.push_back(' ');\n\txmlParser->ParseBuffer ( copy.c_str(), copy.size(), true );\n\treturn length;\n\n}",
        "description": "An inefficient algorithm with quadratic complexity was identified in Exiv2 versions up to v0.27.3. This algorithm is activated when Exiv2 writes metadata to a specially crafted image file. An attacker could exploit this vulnerability to cause a denial of service by convincing a victim to run Exiv2 on such an image file. The issue has been resolved in version v0.27.4. It's important to note that this vulnerability primarily affects the less commonly used metadata writing operation compared to the more frequent reading operation.",
        "commit": "output: \"A performance bug characterized by quadratic complexity has been addressed.\""
    },
    {
        "cwe": "CWE-369",
        "func_name": "upx/PackLinuxElf64::elf_lookup",
        "score": 0.7727935314178467,
        "func_before": "Elf64_Sym const *PackLinuxElf64__elf_lookup(char const *name) const\n{\n    if (hashtab && dynsym && dynstr) {\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket];\n        unsigned const m = elf_hash(name) % nbucket;\n        if (!nbucket\n        ||  (unsigned)(file_size - ((char const *)buckets - (char const *)(void const *)file_image))\n                <= sizeof(unsigned)*nbucket ) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad nbucket %#x\\n\", nbucket);\n            throwCantPack(msg);\n        }\n        unsigned si;\n        for (si= get_te32(&buckets[m]); 0!=si; si= get_te32(&chains[si])) {\n            char const *const p= get_dynsym_name(si, (unsigned)-1);\n            if (0==strcmp(name, p)) {\n                return &dynsym[si];\n            }\n        }\n    }\n    if (gashtab && dynsym && dynstr) {\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const symbias  = get_te32(&gashtab[1]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket];\n        if (!n_bucket\n        || (void const *)&file_image[file_size] <= (void const *)hasharr) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad n_bucket %#x\\n\", n_bucket);\n            throwCantPack(msg);\n        }\n        if (!n_bitmask\n        || (unsigned)(file_size - ((char const *)bitmask - (char const *)(void const *)file_image))\n                <= sizeof(unsigned)*n_bitmask ) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad n_bitmask %#x\\n\", n_bitmask);\n            throwCantPack(msg);\n        }\n\n        unsigned const h = gnu_hash(name);\n        unsigned const hbit1 = 077& h;\n        unsigned const hbit2 = 077& (h>>gnu_shift);\n        upx_uint64_t const w = get_te64(&bitmask[(n_bitmask -1) & (h>>6)]);\n\n        if (1& (w>>hbit1) & (w>>hbit2)) {\n            unsigned bucket = get_te32(&buckets[h % n_bucket]);\n            if (n_bucket <= bucket) {\n                char msg[80]; snprintf(msg, sizeof(msg),\n                        \"bad DT_GNU_HASH n_bucket{%#x} <= buckets[%d]{%#x}\\n\",\n                        n_bucket, h % n_bucket, bucket);\n                throwCantPack(msg);\n            }\n            if (0!=bucket) {\n                Elf64_Sym const *dsp = &dynsym[bucket];\n                unsigned const *hp = &hasharr[bucket - symbias];\n\n                do if (0==((h ^ get_te32(hp))>>1)) {\n                    unsigned st_name = get_te32(&dsp->st_name);\n                    char const *const p = get_str_name(st_name, (unsigned)-1);\n                    if (0==strcmp(name, p)) {\n                        return dsp;\n                    }\n                } while (++dsp,\n                        (char const *)hp < (char const *)&file_image[file_size]\n                    &&  0==(1u& get_te32(hp++)));\n            }\n        }\n    }\n    return 0;\n\n}",
        "func_after": "Elf64_Sym const *PackLinuxElf64__elf_lookup(char const *name) const\n{\n    if (hashtab && dynsym && dynstr) {\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket];\n        if (!nbucket\n        ||  (unsigned)(file_size - ((char const *)buckets - (char const *)(void const *)file_image))\n                <= sizeof(unsigned)*nbucket ) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad nbucket %#x\\n\", nbucket);\n            throwCantPack(msg);\n        }\n        unsigned const m = elf_hash(name) % nbucket;\n        unsigned si;\n        for (si= get_te32(&buckets[m]); 0!=si; si= get_te32(&chains[si])) {\n            char const *const p= get_dynsym_name(si, (unsigned)-1);\n            if (0==strcmp(name, p)) {\n                return &dynsym[si];\n            }\n        }\n    }\n    if (gashtab && dynsym && dynstr) {\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const symbias  = get_te32(&gashtab[1]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket];\n        if (!n_bucket\n        || (void const *)&file_image[file_size] <= (void const *)hasharr) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad n_bucket %#x\\n\", n_bucket);\n            throwCantPack(msg);\n        }\n        if (!n_bitmask\n        || (unsigned)(file_size - ((char const *)bitmask - (char const *)(void const *)file_image))\n                <= sizeof(unsigned)*n_bitmask ) {\n            char msg[80]; snprintf(msg, sizeof(msg),\n                \"bad n_bitmask %#x\\n\", n_bitmask);\n            throwCantPack(msg);\n        }\n\n        unsigned const h = gnu_hash(name);\n        unsigned const hbit1 = 077& h;\n        unsigned const hbit2 = 077& (h>>gnu_shift);\n        upx_uint64_t const w = get_te64(&bitmask[(n_bitmask -1) & (h>>6)]);\n\n        if (1& (w>>hbit1) & (w>>hbit2)) {\n            unsigned bucket = get_te32(&buckets[h % n_bucket]);\n            if (n_bucket <= bucket) {\n                char msg[80]; snprintf(msg, sizeof(msg),\n                        \"bad DT_GNU_HASH n_bucket{%#x} <= buckets[%d]{%#x}\\n\",\n                        n_bucket, h % n_bucket, bucket);\n                throwCantPack(msg);\n            }\n            if (0!=bucket) {\n                Elf64_Sym const *dsp = &dynsym[bucket];\n                unsigned const *hp = &hasharr[bucket - symbias];\n\n                do if (0==((h ^ get_te32(hp))>>1)) {\n                    unsigned st_name = get_te32(&dsp->st_name);\n                    char const *const p = get_str_name(st_name, (unsigned)-1);\n                    if (0==strcmp(name, p)) {\n                        return dsp;\n                    }\n                } while (++dsp,\n                        (char const *)hp < (char const *)&file_image[file_size]\n                    &&  0==(1u& get_te32(hp++)));\n            }\n        }\n    }\n    return 0;\n\n}",
        "description": "An floating point exception was discovered in the elf_lookup function within the UPX decompression utility, specifically in version 4.0.0, when processing a specially crafted Mach-O file.",
        "commit": "It was identified that there is a need to avoid setting `nbucket` to zero in the UPX compression tool, as indicated by an issue reported in the GitHub repository. This modification was made in the `p_lx_elf.cpp` file."
    },
    {
        "cwe": "CWE-770",
        "func_name": "binutils-gdb/_bfd_elf_slurp_version_tables",
        "score": 0.7724741697311401,
        "func_before": "bfd_boolean\n_bfd_elf_slurp_version_tables (bfd *abfd, bfd_boolean default_imported_symver)\n{\n  bfd_byte *contents = NULL;\n  unsigned int freeidx = 0;\n\n  if (elf_dynverref (abfd) != 0)\n    {\n      Elf_Internal_Shdr *hdr;\n      Elf_External_Verneed *everneed;\n      Elf_Internal_Verneed *iverneed;\n      unsigned int i;\n      bfd_byte *contents_end;\n\n      hdr = &elf_tdata (abfd)->dynverref_hdr;\n\n      if (hdr->sh_info == 0 || hdr->sh_size < sizeof (Elf_External_Verneed))\n\t{\nerror_return_bad_verref:\n\t  _bfd_error_handler\n\t    (_(\"%B: .gnu.version_r invalid entry\"), abfd);\n\t  bfd_set_error (bfd_error_bad_value);\nerror_return_verref:\n\t  elf_tdata (abfd)->verref = NULL;\n\t  elf_tdata (abfd)->cverrefs = 0;\n\t  goto error_return;\n\t}\n\n      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);\n      if (contents == NULL)\n\tgoto error_return_verref;\n\n      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n\t  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)\n\tgoto error_return_verref;\n\n      elf_tdata (abfd)->verref = (Elf_Internal_Verneed *)\n\tbfd_zalloc2 (abfd, hdr->sh_info, sizeof (Elf_Internal_Verneed));\n\n      if (elf_tdata (abfd)->verref == NULL)\n\tgoto error_return_verref;\n\n      BFD_ASSERT (sizeof (Elf_External_Verneed)\n\t\t  == sizeof (Elf_External_Vernaux));\n      contents_end = contents + hdr->sh_size - sizeof (Elf_External_Verneed);\n      everneed = (Elf_External_Verneed *) contents;\n      iverneed = elf_tdata (abfd)->verref;\n      for (i = 0; i < hdr->sh_info; i++, iverneed++)\n\t{\n\t  Elf_External_Vernaux *evernaux;\n\t  Elf_Internal_Vernaux *ivernaux;\n\t  unsigned int j;\n\n\t  _bfd_elf_swap_verneed_in (abfd, everneed, iverneed);\n\n\t  iverneed->vn_bfd = abfd;\n\n\t  iverneed->vn_filename =\n\t    bfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t     iverneed->vn_file);\n\t  if (iverneed->vn_filename == NULL)\n\t    goto error_return_bad_verref;\n\n\t  if (iverneed->vn_cnt == 0)\n\t    iverneed->vn_auxptr = NULL;\n\t  else\n\t    {\n\t      iverneed->vn_auxptr = (struct elf_internal_vernaux *)\n                  bfd_alloc2 (abfd, iverneed->vn_cnt,\n                              sizeof (Elf_Internal_Vernaux));\n\t      if (iverneed->vn_auxptr == NULL)\n\t\tgoto error_return_verref;\n\t    }\n\n\t  if (iverneed->vn_aux\n\t      > (size_t) (contents_end - (bfd_byte *) everneed))\n\t    goto error_return_bad_verref;\n\n\t  evernaux = ((Elf_External_Vernaux *)\n\t\t      ((bfd_byte *) everneed + iverneed->vn_aux));\n\t  ivernaux = iverneed->vn_auxptr;\n\t  for (j = 0; j < iverneed->vn_cnt; j++, ivernaux++)\n\t    {\n\t      _bfd_elf_swap_vernaux_in (abfd, evernaux, ivernaux);\n\n\t      ivernaux->vna_nodename =\n\t\tbfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t\t ivernaux->vna_name);\n\t      if (ivernaux->vna_nodename == NULL)\n\t\tgoto error_return_bad_verref;\n\n\t      if (ivernaux->vna_other > freeidx)\n\t\tfreeidx = ivernaux->vna_other;\n\n\t      ivernaux->vna_nextptr = NULL;\n\t      if (ivernaux->vna_next == 0)\n\t\t{\n\t\t  iverneed->vn_cnt = j + 1;\n\t\t  break;\n\t\t}\n\t      if (j + 1 < iverneed->vn_cnt)\n\t\tivernaux->vna_nextptr = ivernaux + 1;\n\n\t      if (ivernaux->vna_next\n\t\t  > (size_t) (contents_end - (bfd_byte *) evernaux))\n\t\tgoto error_return_bad_verref;\n\n\t      evernaux = ((Elf_External_Vernaux *)\n\t\t\t  ((bfd_byte *) evernaux + ivernaux->vna_next));\n\t    }\n\n\t  iverneed->vn_nextref = NULL;\n\t  if (iverneed->vn_next == 0)\n\t    break;\n\t  if (i + 1 < hdr->sh_info)\n\t    iverneed->vn_nextref = iverneed + 1;\n\n\t  if (iverneed->vn_next\n\t      > (size_t) (contents_end - (bfd_byte *) everneed))\n\t    goto error_return_bad_verref;\n\n\t  everneed = ((Elf_External_Verneed *)\n\t\t      ((bfd_byte *) everneed + iverneed->vn_next));\n\t}\n      elf_tdata (abfd)->cverrefs = i;\n\n      free (contents);\n      contents = NULL;\n    }\n\n  if (elf_dynverdef (abfd) != 0)\n    {\n      Elf_Internal_Shdr *hdr;\n      Elf_External_Verdef *everdef;\n      Elf_Internal_Verdef *iverdef;\n      Elf_Internal_Verdef *iverdefarr;\n      Elf_Internal_Verdef iverdefmem;\n      unsigned int i;\n      unsigned int maxidx;\n      bfd_byte *contents_end_def, *contents_end_aux;\n\n      hdr = &elf_tdata (abfd)->dynverdef_hdr;\n\n      if (hdr->sh_info == 0 || hdr->sh_size < sizeof (Elf_External_Verdef))\n\t{\n\terror_return_bad_verdef:\n\t  _bfd_error_handler\n\t    (_(\"%B: .gnu.version_d invalid entry\"), abfd);\n\t  bfd_set_error (bfd_error_bad_value);\n\terror_return_verdef:\n\t  elf_tdata (abfd)->verdef = NULL;\n\t  elf_tdata (abfd)->cverdefs = 0;\n\t  goto error_return;\n\t}\n\n      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);\n      if (contents == NULL)\n\tgoto error_return_verdef;\n      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n\t  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)\n\tgoto error_return_verdef;\n\n      BFD_ASSERT (sizeof (Elf_External_Verdef)\n\t\t  >= sizeof (Elf_External_Verdaux));\n      contents_end_def = contents + hdr->sh_size\n\t\t\t - sizeof (Elf_External_Verdef);\n      contents_end_aux = contents + hdr->sh_size\n\t\t\t - sizeof (Elf_External_Verdaux);\n\n      /* We know the number of entries in the section but not the maximum\n\t index.  Therefore we have to run through all entries and find\n\t the maximum.  */\n      everdef = (Elf_External_Verdef *) contents;\n      maxidx = 0;\n      for (i = 0; i < hdr->sh_info; ++i)\n\t{\n\t  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);\n\n\t  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) == 0)\n\t    goto error_return_bad_verdef;\n\t  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) > maxidx)\n\t    maxidx = iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION);\n\n\t  if (iverdefmem.vd_next == 0)\n\t    break;\n\n\t  if (iverdefmem.vd_next\n\t      > (size_t) (contents_end_def - (bfd_byte *) everdef))\n\t    goto error_return_bad_verdef;\n\n\t  everdef = ((Elf_External_Verdef *)\n\t\t     ((bfd_byte *) everdef + iverdefmem.vd_next));\n\t}\n\n      if (default_imported_symver)\n\t{\n\t  if (freeidx > maxidx)\n\t    maxidx = ++freeidx;\n\t  else\n\t    freeidx = ++maxidx;\n\t}\n\n      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n\tbfd_zalloc2 (abfd, maxidx, sizeof (Elf_Internal_Verdef));\n      if (elf_tdata (abfd)->verdef == NULL)\n\tgoto error_return_verdef;\n\n      elf_tdata (abfd)->cverdefs = maxidx;\n\n      everdef = (Elf_External_Verdef *) contents;\n      iverdefarr = elf_tdata (abfd)->verdef;\n      for (i = 0; i < hdr->sh_info; i++)\n\t{\n\t  Elf_External_Verdaux *everdaux;\n\t  Elf_Internal_Verdaux *iverdaux;\n\t  unsigned int j;\n\n\t  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);\n\n\t  if ((iverdefmem.vd_ndx & VERSYM_VERSION) == 0)\n\t    goto error_return_bad_verdef;\n\n\t  iverdef = &iverdefarr[(iverdefmem.vd_ndx & VERSYM_VERSION) - 1];\n\t  memcpy (iverdef, &iverdefmem, offsetof (Elf_Internal_Verdef, vd_bfd));\n\n\t  iverdef->vd_bfd = abfd;\n\n\t  if (iverdef->vd_cnt == 0)\n\t    iverdef->vd_auxptr = NULL;\n\t  else\n\t    {\n\t      iverdef->vd_auxptr = (struct elf_internal_verdaux *)\n                  bfd_alloc2 (abfd, iverdef->vd_cnt,\n                              sizeof (Elf_Internal_Verdaux));\n\t      if (iverdef->vd_auxptr == NULL)\n\t\tgoto error_return_verdef;\n\t    }\n\n\t  if (iverdef->vd_aux\n\t      > (size_t) (contents_end_aux - (bfd_byte *) everdef))\n\t    goto error_return_bad_verdef;\n\n\t  everdaux = ((Elf_External_Verdaux *)\n\t\t      ((bfd_byte *) everdef + iverdef->vd_aux));\n\t  iverdaux = iverdef->vd_auxptr;\n\t  for (j = 0; j < iverdef->vd_cnt; j++, iverdaux++)\n\t    {\n\t      _bfd_elf_swap_verdaux_in (abfd, everdaux, iverdaux);\n\n\t      iverdaux->vda_nodename =\n\t\tbfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t\t iverdaux->vda_name);\n\t      if (iverdaux->vda_nodename == NULL)\n\t\tgoto error_return_bad_verdef;\n\n\t      iverdaux->vda_nextptr = NULL;\n\t      if (iverdaux->vda_next == 0)\n\t\t{\n\t\t  iverdef->vd_cnt = j + 1;\n\t\t  break;\n\t\t}\n\t      if (j + 1 < iverdef->vd_cnt)\n\t\tiverdaux->vda_nextptr = iverdaux + 1;\n\n\t      if (iverdaux->vda_next\n\t\t  > (size_t) (contents_end_aux - (bfd_byte *) everdaux))\n\t\tgoto error_return_bad_verdef;\n\n\t      everdaux = ((Elf_External_Verdaux *)\n\t\t\t  ((bfd_byte *) everdaux + iverdaux->vda_next));\n\t    }\n\n\t  iverdef->vd_nodename = NULL;\n\t  if (iverdef->vd_cnt)\n\t    iverdef->vd_nodename = iverdef->vd_auxptr->vda_nodename;\n\n\t  iverdef->vd_nextdef = NULL;\n\t  if (iverdef->vd_next == 0)\n\t    break;\n\t  if ((size_t) (iverdef - iverdefarr) + 1 < maxidx)\n\t    iverdef->vd_nextdef = iverdef + 1;\n\n\t  everdef = ((Elf_External_Verdef *)\n\t\t     ((bfd_byte *) everdef + iverdef->vd_next));\n\t}\n\n      free (contents);\n      contents = NULL;\n    }\n  else if (default_imported_symver)\n    {\n      if (freeidx < 3)\n\tfreeidx = 3;\n      else\n\tfreeidx++;\n\n      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n          bfd_zalloc2 (abfd, freeidx, sizeof (Elf_Internal_Verdef));\n      if (elf_tdata (abfd)->verdef == NULL)\n\tgoto error_return;\n\n      elf_tdata (abfd)->cverdefs = freeidx;\n    }\n\n  /* Create a default version based on the soname.  */\n  if (default_imported_symver)\n    {\n      Elf_Internal_Verdef *iverdef;\n      Elf_Internal_Verdaux *iverdaux;\n\n      iverdef = &elf_tdata (abfd)->verdef[freeidx - 1];\n\n      iverdef->vd_version = VER_DEF_CURRENT;\n      iverdef->vd_flags = 0;\n      iverdef->vd_ndx = freeidx;\n      iverdef->vd_cnt = 1;\n\n      iverdef->vd_bfd = abfd;\n\n      iverdef->vd_nodename = bfd_elf_get_dt_soname (abfd);\n      if (iverdef->vd_nodename == NULL)\n\tgoto error_return_verdef;\n      iverdef->vd_nextdef = NULL;\n      iverdef->vd_auxptr = ((struct elf_internal_verdaux *)\n\t\t\t    bfd_zalloc (abfd, sizeof (Elf_Internal_Verdaux)));\n      if (iverdef->vd_auxptr == NULL)\n\tgoto error_return_verdef;\n\n      iverdaux = iverdef->vd_auxptr;\n      iverdaux->vda_nodename = iverdef->vd_nodename;\n    }\n\n  return TRUE;\n\n error_return:\n  if (contents != NULL)\n    free (contents);\n  return FALSE;\n}",
        "func_after": "bfd_boolean\n_bfd_elf_slurp_version_tables (bfd *abfd, bfd_boolean default_imported_symver)\n{\n  bfd_byte *contents = NULL;\n  unsigned int freeidx = 0;\n\n  if (elf_dynverref (abfd) != 0)\n    {\n      Elf_Internal_Shdr *hdr;\n      Elf_External_Verneed *everneed;\n      Elf_Internal_Verneed *iverneed;\n      unsigned int i;\n      bfd_byte *contents_end;\n\n      hdr = &elf_tdata (abfd)->dynverref_hdr;\n\n      if (hdr->sh_info == 0\n\t  || hdr->sh_info > hdr->sh_size / sizeof (Elf_External_Verneed))\n\t{\nerror_return_bad_verref:\n\t  _bfd_error_handler\n\t    (_(\"%B: .gnu.version_r invalid entry\"), abfd);\n\t  bfd_set_error (bfd_error_bad_value);\nerror_return_verref:\n\t  elf_tdata (abfd)->verref = NULL;\n\t  elf_tdata (abfd)->cverrefs = 0;\n\t  goto error_return;\n\t}\n\n      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);\n      if (contents == NULL)\n\tgoto error_return_verref;\n\n      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n\t  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)\n\tgoto error_return_verref;\n\n      elf_tdata (abfd)->verref = (Elf_Internal_Verneed *)\n\tbfd_alloc2 (abfd, hdr->sh_info, sizeof (Elf_Internal_Verneed));\n\n      if (elf_tdata (abfd)->verref == NULL)\n\tgoto error_return_verref;\n\n      BFD_ASSERT (sizeof (Elf_External_Verneed)\n\t\t  == sizeof (Elf_External_Vernaux));\n      contents_end = contents + hdr->sh_size - sizeof (Elf_External_Verneed);\n      everneed = (Elf_External_Verneed *) contents;\n      iverneed = elf_tdata (abfd)->verref;\n      for (i = 0; i < hdr->sh_info; i++, iverneed++)\n\t{\n\t  Elf_External_Vernaux *evernaux;\n\t  Elf_Internal_Vernaux *ivernaux;\n\t  unsigned int j;\n\n\t  _bfd_elf_swap_verneed_in (abfd, everneed, iverneed);\n\n\t  iverneed->vn_bfd = abfd;\n\n\t  iverneed->vn_filename =\n\t    bfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t     iverneed->vn_file);\n\t  if (iverneed->vn_filename == NULL)\n\t    goto error_return_bad_verref;\n\n\t  if (iverneed->vn_cnt == 0)\n\t    iverneed->vn_auxptr = NULL;\n\t  else\n\t    {\n\t      iverneed->vn_auxptr = (struct elf_internal_vernaux *)\n                  bfd_alloc2 (abfd, iverneed->vn_cnt,\n                              sizeof (Elf_Internal_Vernaux));\n\t      if (iverneed->vn_auxptr == NULL)\n\t\tgoto error_return_verref;\n\t    }\n\n\t  if (iverneed->vn_aux\n\t      > (size_t) (contents_end - (bfd_byte *) everneed))\n\t    goto error_return_bad_verref;\n\n\t  evernaux = ((Elf_External_Vernaux *)\n\t\t      ((bfd_byte *) everneed + iverneed->vn_aux));\n\t  ivernaux = iverneed->vn_auxptr;\n\t  for (j = 0; j < iverneed->vn_cnt; j++, ivernaux++)\n\t    {\n\t      _bfd_elf_swap_vernaux_in (abfd, evernaux, ivernaux);\n\n\t      ivernaux->vna_nodename =\n\t\tbfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t\t ivernaux->vna_name);\n\t      if (ivernaux->vna_nodename == NULL)\n\t\tgoto error_return_bad_verref;\n\n\t      if (ivernaux->vna_other > freeidx)\n\t\tfreeidx = ivernaux->vna_other;\n\n\t      ivernaux->vna_nextptr = NULL;\n\t      if (ivernaux->vna_next == 0)\n\t\t{\n\t\t  iverneed->vn_cnt = j + 1;\n\t\t  break;\n\t\t}\n\t      if (j + 1 < iverneed->vn_cnt)\n\t\tivernaux->vna_nextptr = ivernaux + 1;\n\n\t      if (ivernaux->vna_next\n\t\t  > (size_t) (contents_end - (bfd_byte *) evernaux))\n\t\tgoto error_return_bad_verref;\n\n\t      evernaux = ((Elf_External_Vernaux *)\n\t\t\t  ((bfd_byte *) evernaux + ivernaux->vna_next));\n\t    }\n\n\t  iverneed->vn_nextref = NULL;\n\t  if (iverneed->vn_next == 0)\n\t    break;\n\t  if (i + 1 < hdr->sh_info)\n\t    iverneed->vn_nextref = iverneed + 1;\n\n\t  if (iverneed->vn_next\n\t      > (size_t) (contents_end - (bfd_byte *) everneed))\n\t    goto error_return_bad_verref;\n\n\t  everneed = ((Elf_External_Verneed *)\n\t\t      ((bfd_byte *) everneed + iverneed->vn_next));\n\t}\n      elf_tdata (abfd)->cverrefs = i;\n\n      free (contents);\n      contents = NULL;\n    }\n\n  if (elf_dynverdef (abfd) != 0)\n    {\n      Elf_Internal_Shdr *hdr;\n      Elf_External_Verdef *everdef;\n      Elf_Internal_Verdef *iverdef;\n      Elf_Internal_Verdef *iverdefarr;\n      Elf_Internal_Verdef iverdefmem;\n      unsigned int i;\n      unsigned int maxidx;\n      bfd_byte *contents_end_def, *contents_end_aux;\n\n      hdr = &elf_tdata (abfd)->dynverdef_hdr;\n\n      if (hdr->sh_info == 0 || hdr->sh_size < sizeof (Elf_External_Verdef))\n\t{\n\terror_return_bad_verdef:\n\t  _bfd_error_handler\n\t    (_(\"%B: .gnu.version_d invalid entry\"), abfd);\n\t  bfd_set_error (bfd_error_bad_value);\n\terror_return_verdef:\n\t  elf_tdata (abfd)->verdef = NULL;\n\t  elf_tdata (abfd)->cverdefs = 0;\n\t  goto error_return;\n\t}\n\n      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);\n      if (contents == NULL)\n\tgoto error_return_verdef;\n      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n\t  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)\n\tgoto error_return_verdef;\n\n      BFD_ASSERT (sizeof (Elf_External_Verdef)\n\t\t  >= sizeof (Elf_External_Verdaux));\n      contents_end_def = contents + hdr->sh_size\n\t\t\t - sizeof (Elf_External_Verdef);\n      contents_end_aux = contents + hdr->sh_size\n\t\t\t - sizeof (Elf_External_Verdaux);\n\n      /* We know the number of entries in the section but not the maximum\n\t index.  Therefore we have to run through all entries and find\n\t the maximum.  */\n      everdef = (Elf_External_Verdef *) contents;\n      maxidx = 0;\n      for (i = 0; i < hdr->sh_info; ++i)\n\t{\n\t  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);\n\n\t  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) == 0)\n\t    goto error_return_bad_verdef;\n\t  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) > maxidx)\n\t    maxidx = iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION);\n\n\t  if (iverdefmem.vd_next == 0)\n\t    break;\n\n\t  if (iverdefmem.vd_next\n\t      > (size_t) (contents_end_def - (bfd_byte *) everdef))\n\t    goto error_return_bad_verdef;\n\n\t  everdef = ((Elf_External_Verdef *)\n\t\t     ((bfd_byte *) everdef + iverdefmem.vd_next));\n\t}\n\n      if (default_imported_symver)\n\t{\n\t  if (freeidx > maxidx)\n\t    maxidx = ++freeidx;\n\t  else\n\t    freeidx = ++maxidx;\n\t}\n\n      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n\tbfd_zalloc2 (abfd, maxidx, sizeof (Elf_Internal_Verdef));\n      if (elf_tdata (abfd)->verdef == NULL)\n\tgoto error_return_verdef;\n\n      elf_tdata (abfd)->cverdefs = maxidx;\n\n      everdef = (Elf_External_Verdef *) contents;\n      iverdefarr = elf_tdata (abfd)->verdef;\n      for (i = 0; i < hdr->sh_info; i++)\n\t{\n\t  Elf_External_Verdaux *everdaux;\n\t  Elf_Internal_Verdaux *iverdaux;\n\t  unsigned int j;\n\n\t  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);\n\n\t  if ((iverdefmem.vd_ndx & VERSYM_VERSION) == 0)\n\t    goto error_return_bad_verdef;\n\n\t  iverdef = &iverdefarr[(iverdefmem.vd_ndx & VERSYM_VERSION) - 1];\n\t  memcpy (iverdef, &iverdefmem, offsetof (Elf_Internal_Verdef, vd_bfd));\n\n\t  iverdef->vd_bfd = abfd;\n\n\t  if (iverdef->vd_cnt == 0)\n\t    iverdef->vd_auxptr = NULL;\n\t  else\n\t    {\n\t      iverdef->vd_auxptr = (struct elf_internal_verdaux *)\n                  bfd_alloc2 (abfd, iverdef->vd_cnt,\n                              sizeof (Elf_Internal_Verdaux));\n\t      if (iverdef->vd_auxptr == NULL)\n\t\tgoto error_return_verdef;\n\t    }\n\n\t  if (iverdef->vd_aux\n\t      > (size_t) (contents_end_aux - (bfd_byte *) everdef))\n\t    goto error_return_bad_verdef;\n\n\t  everdaux = ((Elf_External_Verdaux *)\n\t\t      ((bfd_byte *) everdef + iverdef->vd_aux));\n\t  iverdaux = iverdef->vd_auxptr;\n\t  for (j = 0; j < iverdef->vd_cnt; j++, iverdaux++)\n\t    {\n\t      _bfd_elf_swap_verdaux_in (abfd, everdaux, iverdaux);\n\n\t      iverdaux->vda_nodename =\n\t\tbfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t\t iverdaux->vda_name);\n\t      if (iverdaux->vda_nodename == NULL)\n\t\tgoto error_return_bad_verdef;\n\n\t      iverdaux->vda_nextptr = NULL;\n\t      if (iverdaux->vda_next == 0)\n\t\t{\n\t\t  iverdef->vd_cnt = j + 1;\n\t\t  break;\n\t\t}\n\t      if (j + 1 < iverdef->vd_cnt)\n\t\tiverdaux->vda_nextptr = iverdaux + 1;\n\n\t      if (iverdaux->vda_next\n\t\t  > (size_t) (contents_end_aux - (bfd_byte *) everdaux))\n\t\tgoto error_return_bad_verdef;\n\n\t      everdaux = ((Elf_External_Verdaux *)\n\t\t\t  ((bfd_byte *) everdaux + iverdaux->vda_next));\n\t    }\n\n\t  iverdef->vd_nodename = NULL;\n\t  if (iverdef->vd_cnt)\n\t    iverdef->vd_nodename = iverdef->vd_auxptr->vda_nodename;\n\n\t  iverdef->vd_nextdef = NULL;\n\t  if (iverdef->vd_next == 0)\n\t    break;\n\t  if ((size_t) (iverdef - iverdefarr) + 1 < maxidx)\n\t    iverdef->vd_nextdef = iverdef + 1;\n\n\t  everdef = ((Elf_External_Verdef *)\n\t\t     ((bfd_byte *) everdef + iverdef->vd_next));\n\t}\n\n      free (contents);\n      contents = NULL;\n    }\n  else if (default_imported_symver)\n    {\n      if (freeidx < 3)\n\tfreeidx = 3;\n      else\n\tfreeidx++;\n\n      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n          bfd_zalloc2 (abfd, freeidx, sizeof (Elf_Internal_Verdef));\n      if (elf_tdata (abfd)->verdef == NULL)\n\tgoto error_return;\n\n      elf_tdata (abfd)->cverdefs = freeidx;\n    }\n\n  /* Create a default version based on the soname.  */\n  if (default_imported_symver)\n    {\n      Elf_Internal_Verdef *iverdef;\n      Elf_Internal_Verdaux *iverdaux;\n\n      iverdef = &elf_tdata (abfd)->verdef[freeidx - 1];\n\n      iverdef->vd_version = VER_DEF_CURRENT;\n      iverdef->vd_flags = 0;\n      iverdef->vd_ndx = freeidx;\n      iverdef->vd_cnt = 1;\n\n      iverdef->vd_bfd = abfd;\n\n      iverdef->vd_nodename = bfd_elf_get_dt_soname (abfd);\n      if (iverdef->vd_nodename == NULL)\n\tgoto error_return_verdef;\n      iverdef->vd_nextdef = NULL;\n      iverdef->vd_auxptr = ((struct elf_internal_verdaux *)\n\t\t\t    bfd_zalloc (abfd, sizeof (Elf_Internal_Verdaux)));\n      if (iverdef->vd_auxptr == NULL)\n\tgoto error_return_verdef;\n\n      iverdaux = iverdef->vd_auxptr;\n      iverdaux->vda_nodename = iverdef->vd_nodename;\n    }\n\n  return TRUE;\n\n error_return:\n  if (contents != NULL)\n    free (contents);\n  return FALSE;\n}",
        "description": "The _bfd_elf_slurp_version_tables function in the BFD library, part of GNU Binutils 2.29, is susceptible to a denial of service attack. This vulnerability arises from excessive memory allocation when processing a specially crafted ELF file, leading to potential application crashes.",
        "commit": "The vulnerability involves a memory allocation issue within the ELF (Executable and Linkable Format) handling module of a binary file format library. Specifically, the code performs a sanity check on the size of the `SHT_GNU_verneed` section, ensuring it meets certain minimum requirements related to the number of version entries (`sh_info`). Additionally, since the code either fully initializes all fields of the version entries or exits with an error, there is no need to zero-initialize the allocated memory for these entries. The fix includes modifying the `_bfd_elf_slurp_version_tables` function to test the `sh_info` field of the `SHT_GNU_verneed` section for validity and to avoid zero-initializing the memory allocated for version references."
    },
    {
        "cwe": "CWE-415",
        "func_name": "binutils-gdb/get_num_dynamic_syms",
        "score": 0.770553469657898,
        "func_before": "static unsigned long\nget_num_dynamic_syms (Filedata * filedata)\n{\n  unsigned long num_of_syms = 0;\n\n  if (!do_histogram && (!do_using_dynamic || do_dyn_syms))\n    return num_of_syms;\n\n  if (dynamic_info[DT_HASH])\n    {\n      unsigned char nb[8];\n      unsigned char nc[8];\n      unsigned int hash_ent_size = 4;\n\n      if ((filedata->file_header.e_machine == EM_ALPHA\n\t   || filedata->file_header.e_machine == EM_S390\n\t   || filedata->file_header.e_machine == EM_S390_OLD)\n\t  && filedata->file_header.e_ident[EI_CLASS] == ELFCLASS64)\n\thash_ent_size = 8;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, dynamic_info[DT_HASH],\n\t\t\t\t     sizeof nb + sizeof nc)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  goto no_hash;\n\t}\n\n      if (fread (nb, hash_ent_size, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of buckets\\n\"));\n\t  goto no_hash;\n\t}\n\n      if (fread (nc, hash_ent_size, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of chains\\n\"));\n\t  goto no_hash;\n\t}\n\n      nbuckets = byte_get (nb, hash_ent_size);\n      nchains = byte_get (nc, hash_ent_size);\n      num_of_syms = nchains;\n\n      buckets = get_dynamic_data (filedata, nbuckets, hash_ent_size);\n      chains  = get_dynamic_data (filedata, nchains, hash_ent_size);\n\n  no_hash:\n      if (num_of_syms == 0)\n\t{\n\t  if (buckets)\n\t    {\n\t      free (buckets);\n\t      buckets = NULL;\n\t    }\n\t  if (chains)\n\t    {\n\t      free (chains);\n\t      buckets = NULL;\n\t    }\n\t  nbuckets = 0;\n\t}\n    }\n\n  if (dynamic_info_DT_GNU_HASH)\n    {\n      unsigned char nb[16];\n      bfd_vma i, maxchain = 0xffffffff, bitmaskwords;\n      bfd_vma buckets_vma;\n      unsigned long hn;\n      bfd_boolean gnu_hash_error = FALSE;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, dynamic_info_DT_GNU_HASH,\n\t\t\t\t     sizeof nb)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      if (fread (nb, 16, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of buckets\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      ngnubuckets = byte_get (nb, 4);\n      gnusymidx = byte_get (nb + 4, 4);\n      bitmaskwords = byte_get (nb + 8, 4);\n      buckets_vma = dynamic_info_DT_GNU_HASH + 16;\n      if (is_32bit_elf)\n\tbuckets_vma += bitmaskwords * 4;\n      else\n\tbuckets_vma += bitmaskwords * 8;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma, 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      gnubuckets = get_dynamic_data (filedata, ngnubuckets, 4);\n\n      if (gnubuckets == NULL)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      for (i = 0; i < ngnubuckets; i++)\n\tif (gnubuckets[i] != 0)\n\t  {\n\t    if (gnubuckets[i] < gnusymidx)\n\t      {\n\t\tgnu_hash_error = TRUE;\n\t\treturn FALSE;\n\t      }\n\n\t    if (maxchain == 0xffffffff || gnubuckets[i] > maxchain)\n\t      maxchain = gnubuckets[i];\n\t  }\n\n      if (maxchain == 0xffffffff)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      maxchain -= gnusymidx;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma\n\t\t\t\t\t   + 4 * (ngnubuckets + maxchain), 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      do\n\t{\n\t  if (fread (nb, 4, 1, filedata->handle) != 1)\n\t    {\n\t      error (_(\"Failed to determine last chain length\\n\"));\n\t  gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  if (maxchain + 1 == 0)\n\t    {\n\t      gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  ++maxchain;\n\t}\n      while ((byte_get (nb, 4) & 1) == 0);\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma + 4 * ngnubuckets, 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      gnuchains = get_dynamic_data (filedata, maxchain, 4);\n      ngnuchains = maxchain;\n\n      if (gnuchains == NULL)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      if (dynamic_info_DT_MIPS_XHASH)\n\t{\n\t  if (fseek (filedata->handle,\n\t\t     (archive_file_offset\n\t\t      + offset_from_vma (filedata, (buckets_vma\n\t\t\t\t\t\t    + 4 * (ngnubuckets\n\t\t\t\t\t\t\t   + maxchain)), 4)),\n\t\t     SEEK_SET))\n\t    {\n\t      error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t      gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  mipsxlat = get_dynamic_data (filedata, maxchain, 4);\n\t}\n\n      for (hn = 0; hn < ngnubuckets; ++hn)\n\tif (gnubuckets[hn] != 0)\n\t  {\n\t    bfd_vma si = gnubuckets[hn];\n\t    bfd_vma off = si - gnusymidx;\n\n\t    do\n\t      {\n\t\tif (dynamic_info_DT_MIPS_XHASH)\n\t\t  {\n\t\t    if (mipsxlat[off] >= num_of_syms)\n\t\t      num_of_syms = mipsxlat[off] + 1;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    if (si >= num_of_syms)\n\t\t      num_of_syms = si + 1;\n\t\t  }\n\t\tsi++;\n\t      }\n\t    while (off < ngnuchains && (gnuchains[off++] & 1) == 0);\n\t  }\n\n  no_gnu_hash:\n      if (gnu_hash_error)\n\t{\n\t  if (mipsxlat)\n\t    {\n\t      free (mipsxlat);\n\t      mipsxlat = NULL;\n\t    }\n\t  if (gnuchains)\n\t    {\n\t      free (gnuchains);\n\t      gnuchains = NULL;\n\t    }\n\t  if (gnubuckets)\n\t    {\n\t      free (gnubuckets);\n\t      gnubuckets = NULL;\n\t    }\n\t  ngnubuckets = 0;\n\t  ngnuchains = 0;\n\t}\n    }\n\n  return num_of_syms;\n}",
        "func_after": "static unsigned long\nget_num_dynamic_syms (Filedata * filedata)\n{\n  unsigned long num_of_syms = 0;\n\n  if (!do_histogram && (!do_using_dynamic || do_dyn_syms))\n    return num_of_syms;\n\n  if (dynamic_info[DT_HASH])\n    {\n      unsigned char nb[8];\n      unsigned char nc[8];\n      unsigned int hash_ent_size = 4;\n\n      if ((filedata->file_header.e_machine == EM_ALPHA\n\t   || filedata->file_header.e_machine == EM_S390\n\t   || filedata->file_header.e_machine == EM_S390_OLD)\n\t  && filedata->file_header.e_ident[EI_CLASS] == ELFCLASS64)\n\thash_ent_size = 8;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, dynamic_info[DT_HASH],\n\t\t\t\t     sizeof nb + sizeof nc)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  goto no_hash;\n\t}\n\n      if (fread (nb, hash_ent_size, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of buckets\\n\"));\n\t  goto no_hash;\n\t}\n\n      if (fread (nc, hash_ent_size, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of chains\\n\"));\n\t  goto no_hash;\n\t}\n\n      nbuckets = byte_get (nb, hash_ent_size);\n      nchains = byte_get (nc, hash_ent_size);\n      num_of_syms = nchains;\n\n      buckets = get_dynamic_data (filedata, nbuckets, hash_ent_size);\n      chains  = get_dynamic_data (filedata, nchains, hash_ent_size);\n\n  no_hash:\n      if (num_of_syms == 0)\n\t{\n\t  if (buckets)\n\t    {\n\t      free (buckets);\n\t      buckets = NULL;\n\t    }\n\t  if (chains)\n\t    {\n\t      free (chains);\n\t      chains = NULL;\n\t    }\n\t  nbuckets = 0;\n\t}\n    }\n\n  if (dynamic_info_DT_GNU_HASH)\n    {\n      unsigned char nb[16];\n      bfd_vma i, maxchain = 0xffffffff, bitmaskwords;\n      bfd_vma buckets_vma;\n      unsigned long hn;\n      bfd_boolean gnu_hash_error = FALSE;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, dynamic_info_DT_GNU_HASH,\n\t\t\t\t     sizeof nb)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      if (fread (nb, 16, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of buckets\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      ngnubuckets = byte_get (nb, 4);\n      gnusymidx = byte_get (nb + 4, 4);\n      bitmaskwords = byte_get (nb + 8, 4);\n      buckets_vma = dynamic_info_DT_GNU_HASH + 16;\n      if (is_32bit_elf)\n\tbuckets_vma += bitmaskwords * 4;\n      else\n\tbuckets_vma += bitmaskwords * 8;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma, 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      gnubuckets = get_dynamic_data (filedata, ngnubuckets, 4);\n\n      if (gnubuckets == NULL)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      for (i = 0; i < ngnubuckets; i++)\n\tif (gnubuckets[i] != 0)\n\t  {\n\t    if (gnubuckets[i] < gnusymidx)\n\t      {\n\t\tgnu_hash_error = TRUE;\n\t\treturn FALSE;\n\t      }\n\n\t    if (maxchain == 0xffffffff || gnubuckets[i] > maxchain)\n\t      maxchain = gnubuckets[i];\n\t  }\n\n      if (maxchain == 0xffffffff)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      maxchain -= gnusymidx;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma\n\t\t\t\t\t   + 4 * (ngnubuckets + maxchain), 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      do\n\t{\n\t  if (fread (nb, 4, 1, filedata->handle) != 1)\n\t    {\n\t      error (_(\"Failed to determine last chain length\\n\"));\n\t  gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  if (maxchain + 1 == 0)\n\t    {\n\t      gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  ++maxchain;\n\t}\n      while ((byte_get (nb, 4) & 1) == 0);\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma + 4 * ngnubuckets, 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      gnuchains = get_dynamic_data (filedata, maxchain, 4);\n      ngnuchains = maxchain;\n\n      if (gnuchains == NULL)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      if (dynamic_info_DT_MIPS_XHASH)\n\t{\n\t  if (fseek (filedata->handle,\n\t\t     (archive_file_offset\n\t\t      + offset_from_vma (filedata, (buckets_vma\n\t\t\t\t\t\t    + 4 * (ngnubuckets\n\t\t\t\t\t\t\t   + maxchain)), 4)),\n\t\t     SEEK_SET))\n\t    {\n\t      error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t      gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  mipsxlat = get_dynamic_data (filedata, maxchain, 4);\n\t}\n\n      for (hn = 0; hn < ngnubuckets; ++hn)\n\tif (gnubuckets[hn] != 0)\n\t  {\n\t    bfd_vma si = gnubuckets[hn];\n\t    bfd_vma off = si - gnusymidx;\n\n\t    do\n\t      {\n\t\tif (dynamic_info_DT_MIPS_XHASH)\n\t\t  {\n\t\t    if (mipsxlat[off] >= num_of_syms)\n\t\t      num_of_syms = mipsxlat[off] + 1;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    if (si >= num_of_syms)\n\t\t      num_of_syms = si + 1;\n\t\t  }\n\t\tsi++;\n\t      }\n\t    while (off < ngnuchains && (gnuchains[off++] & 1) == 0);\n\t  }\n\n  no_gnu_hash:\n      if (gnu_hash_error)\n\t{\n\t  if (mipsxlat)\n\t    {\n\t      free (mipsxlat);\n\t      mipsxlat = NULL;\n\t    }\n\t  if (gnuchains)\n\t    {\n\t      free (gnuchains);\n\t      gnuchains = NULL;\n\t    }\n\t  if (gnubuckets)\n\t    {\n\t      free (gnubuckets);\n\t      gnubuckets = NULL;\n\t    }\n\t  ngnubuckets = 0;\n\t  ngnuchains = 0;\n\t}\n    }\n\n  return num_of_syms;\n}",
        "description": "A double free vulnerability exists in the Binary File Descriptor (BFD), also known as libbfd, within GNU Binutils 2.35 during the processing of symbol tables, specifically as exhibited in the readelf utility through the manipulation of a specially crafted file.",
        "commit": "The vulnerability knowledge has been abstracted and generalized as follows:\n\n\"A typo fix was made in the `readelf` tool to consolidate the functionality of the `--syms` and `--use-dynamic` options with the `--dyn-syms` option.\""
    }
]