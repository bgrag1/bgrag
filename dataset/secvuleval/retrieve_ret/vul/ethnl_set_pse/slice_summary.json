[
    {
        "cwe": "CWE-90",
        "func_name": "krb5/krb5_ldap_put_principal",
        "score": 0.7467918992042542,
        "func_before": "krb5_error_code\nkrb5_ldap_put_principal(krb5_context context, krb5_db_entry *entry,\n                        char **db_args)\n{\n    int                         l=0, kerberos_principal_object_type=0;\n    unsigned int                ntrees=0, tre=0;\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL, *ent=NULL;\n    char                        **subtreelist = NULL;\n    char                        *user=NULL, *subtree=NULL, *principal_dn=NULL;\n    char                        **values=NULL, *strval[10]={NULL}, errbuf[1024];\n    char                        *filtuser=NULL;\n    struct berval               **bersecretkey=NULL;\n    LDAPMod                     **mods=NULL;\n    krb5_boolean                create_standalone=FALSE;\n    krb5_boolean                krb_identity_exists=FALSE, establish_links=FALSE;\n    char                        *standalone_principal_dn=NULL;\n    krb5_tl_data                *tl_data=NULL;\n    krb5_key_data               **keys=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    osa_princ_ent_rec           princ_ent = {0};\n    xargs_t                     xargs = {0};\n    char                        *polname = NULL;\n    OPERATION optype;\n    krb5_boolean                found_entry = FALSE;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    SETUP_CONTEXT();\n    if (ldap_context->lrparams == NULL || ldap_context->container_dn == NULL)\n        return EINVAL;\n\n    /* get ldap handle */\n    GET_HANDLE();\n\n    if (!is_principal_in_realm(ldap_context, entry->princ)) {\n        st = EINVAL;\n        k5_setmsg(context, st,\n                  _(\"Principal does not belong to the default realm\"));\n        goto cleanup;\n    }\n\n    /* get the principal information to act on */\n    if (((st=krb5_unparse_name(context, entry->princ, &user)) != 0) ||\n        ((st=krb5_ldap_unparse_principal_name(user)) != 0))\n        goto cleanup;\n    filtuser = ldap_filter_correct(user);\n    if (filtuser == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Identity the type of operation, it can be\n     * add principal or modify principal.\n     * hack if the entry->mask has KRB_PRINCIPAL flag set\n     * then it is a add operation\n     */\n    if (entry->mask & KADM5_PRINCIPAL)\n        optype = ADD_PRINCIPAL;\n    else\n        optype = MODIFY_PRINCIPAL;\n\n    if (((st=krb5_get_princ_type(context, entry, &kerberos_principal_object_type)) != 0) ||\n        ((st=krb5_get_userdn(context, entry, &principal_dn)) != 0))\n        goto cleanup;\n\n    if ((st=process_db_args(context, db_args, &xargs, optype)) != 0)\n        goto cleanup;\n\n    if (entry->mask & KADM5_LOAD) {\n        unsigned int     tree = 0;\n        int              numlentries = 0;\n        char             *filter = NULL;\n\n        /*  A load operation is special, will do a mix-in (add krbprinc\n         *  attrs to a non-krb object entry) if an object exists with a\n         *  matching krbprincipalname attribute so try to find existing\n         *  object and set principal_dn.  This assumes that the\n         *  krbprincipalname attribute is unique (only one object entry has\n         *  a particular krbprincipalname attribute).\n         */\n        if (asprintf(&filter, FILTER\"%s))\", filtuser) < 0) {\n            filter = NULL;\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        /* get the current subtree list */\n        if ((st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees)) != 0)\n            goto cleanup;\n\n        found_entry = FALSE;\n        /* search for entry with matching krbprincipalname attribute */\n        for (tree = 0; found_entry == FALSE && tree < ntrees; ++tree) {\n            if (principal_dn == NULL) {\n                LDAP_SEARCH_1(subtreelist[tree], ldap_context->lrparams->search_scope, filter, principal_attributes, IGNORE_STATUS);\n            } else {\n                /* just look for entry with principal_dn */\n                LDAP_SEARCH_1(principal_dn, LDAP_SCOPE_BASE, filter, principal_attributes, IGNORE_STATUS);\n            }\n            if (st == LDAP_SUCCESS) {\n                numlentries = ldap_count_entries(ld, result);\n                if (numlentries > 1) {\n                    free(filter);\n                    st = EINVAL;\n                    k5_setmsg(context, st,\n                              _(\"operation can not continue, more than one \"\n                                \"entry with principal name \\\"%s\\\" found\"),\n                              user);\n                    goto cleanup;\n                } else if (numlentries == 1) {\n                    found_entry = TRUE;\n                    if (principal_dn == NULL) {\n                        ent = ldap_first_entry(ld, result);\n                        if (ent != NULL) {\n                            /* setting principal_dn will cause that entry to be modified further down */\n                            if ((principal_dn = ldap_get_dn(ld, ent)) == NULL) {\n                                ldap_get_option (ld, LDAP_OPT_RESULT_CODE, &st);\n                                st = set_ldap_error (context, st, 0);\n                                free(filter);\n                                goto cleanup;\n                            }\n                        }\n                    }\n                }\n            } else if (st != LDAP_NO_SUCH_OBJECT) {\n                /* could not perform search, return with failure */\n                st = set_ldap_error (context, st, 0);\n                free(filter);\n                goto cleanup;\n            }\n            ldap_msgfree(result);\n            result = NULL;\n            /*\n             * If it isn't found then assume a standalone princ entry is to\n             * be created.\n             */\n        } /* end for (tree = 0; principal_dn == ... */\n\n        free(filter);\n\n        if (found_entry == FALSE && principal_dn != NULL) {\n            /*\n             * if principal_dn is null then there is code further down to\n             * deal with setting standalone_principal_dn.  Also note that\n             * this will set create_standalone true for\n             * non-mix-in entries which is okay if loading from a dump.\n             */\n            create_standalone = TRUE;\n            standalone_principal_dn = strdup(principal_dn);\n            CHECK_NULL(standalone_principal_dn);\n        }\n    } /* end if (entry->mask & KADM5_LOAD */\n\n    /* time to generate the DN information with the help of\n     * containerdn, principalcontainerreference or\n     * realmcontainerdn information\n     */\n    if (principal_dn == NULL && xargs.dn == NULL) { /* creation of standalone principal */\n        /* get the subtree information */\n        if (entry->princ->length == 2 && entry->princ->data[0].length == strlen(\"krbtgt\") &&\n            strncmp(entry->princ->data[0].data, \"krbtgt\", entry->princ->data[0].length) == 0) {\n            /* if the principal is a inter-realm principal, always created in the realm container */\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        } else if (xargs.containerdn) {\n            if ((st=checkattributevalue(ld, xargs.containerdn, NULL, NULL, NULL)) != 0) {\n                if (st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION) {\n                    int ost = st;\n                    st = EINVAL;\n                    k5_wrapmsg(context, ost, st, _(\"'%s' not found\"),\n                               xargs.containerdn);\n                }\n                goto cleanup;\n            }\n            subtree = strdup(xargs.containerdn);\n        } else if (ldap_context->lrparams->containerref && strlen(ldap_context->lrparams->containerref) != 0) {\n            /*\n             * Here the subtree should be changed with\n             * principalcontainerreference attribute value\n             */\n            subtree = strdup(ldap_context->lrparams->containerref);\n        } else {\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        }\n        CHECK_NULL(subtree);\n\n        if (asprintf(&standalone_principal_dn, \"krbprincipalname=%s,%s\",\n                     filtuser, subtree) < 0)\n            standalone_principal_dn = NULL;\n        CHECK_NULL(standalone_principal_dn);\n        /*\n         * free subtree when you are done using the subtree\n         * set the boolean create_standalone to TRUE\n         */\n        create_standalone = TRUE;\n        free(subtree);\n        subtree = NULL;\n    }\n\n    /*\n     * If the DN information is presented by the user, time to\n     * validate the input to ensure that the DN falls under\n     * any of the subtrees\n     */\n    if (xargs.dn_from_kbd == TRUE) {\n        /* make sure the DN falls in the subtree */\n        int              dnlen=0, subtreelen=0;\n        char             *dn=NULL;\n        krb5_boolean     outofsubtree=TRUE;\n\n        if (xargs.dn != NULL) {\n            dn = xargs.dn;\n        } else if (xargs.linkdn != NULL) {\n            dn = xargs.linkdn;\n        } else if (standalone_principal_dn != NULL) {\n            /*\n             * Even though the standalone_principal_dn is constructed\n             * within this function, there is the containerdn input\n             * from the user that can become part of the it.\n             */\n            dn = standalone_principal_dn;\n        }\n\n        /* Get the current subtree list if we haven't already done so. */\n        if (subtreelist == NULL) {\n            st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees);\n            if (st)\n                goto cleanup;\n        }\n\n        for (tre=0; tre<ntrees; ++tre) {\n            if (subtreelist[tre] == NULL || strlen(subtreelist[tre]) == 0) {\n                outofsubtree = FALSE;\n                break;\n            } else {\n                dnlen = strlen (dn);\n                subtreelen = strlen(subtreelist[tre]);\n                if ((dnlen >= subtreelen) && (strcasecmp((dn + dnlen - subtreelen), subtreelist[tre]) == 0)) {\n                    outofsubtree = FALSE;\n                    break;\n                }\n            }\n        }\n\n        if (outofsubtree == TRUE) {\n            st = EINVAL;\n            k5_setmsg(context, st, _(\"DN is out of the realm subtree\"));\n            goto cleanup;\n        }\n\n        /*\n         * dn value will be set either by dn, linkdn or the standalone_principal_dn\n         * In the first 2 cases, the dn should be existing and in the last case we\n         * are supposed to create the ldap object. so the below should not be\n         * executed for the last case.\n         */\n\n        if (standalone_principal_dn == NULL) {\n            /*\n             * If the ldap object is missing, this results in an error.\n             */\n\n            /*\n             * Search for krbprincipalname attribute here.\n             * This is to find if a kerberos identity is already present\n             * on the ldap object, in which case adding a kerberos identity\n             * on the ldap object should result in an error.\n             */\n            char  *attributes[]={\"krbticketpolicyreference\", \"krbprincipalname\", NULL};\n\n            ldap_msgfree(result);\n            result = NULL;\n            LDAP_SEARCH_1(dn, LDAP_SCOPE_BASE, 0, attributes, IGNORE_STATUS);\n            if (st == LDAP_SUCCESS) {\n                ent = ldap_first_entry(ld, result);\n                if (ent != NULL) {\n                    if ((values=ldap_get_values(ld, ent, \"krbticketpolicyreference\")) != NULL) {\n                        ldap_value_free(values);\n                    }\n\n                    if ((values=ldap_get_values(ld, ent, \"krbprincipalname\")) != NULL) {\n                        krb_identity_exists = TRUE;\n                        ldap_value_free(values);\n                    }\n                }\n            } else {\n                st = set_ldap_error(context, st, OP_SEARCH);\n                goto cleanup;\n            }\n        }\n    }\n\n    /*\n     * If xargs.dn is set then the request is to add a\n     * kerberos principal on a ldap object, but if\n     * there is one already on the ldap object this\n     * should result in an error.\n     */\n\n    if (xargs.dn != NULL && krb_identity_exists == TRUE) {\n        st = EINVAL;\n        snprintf(errbuf, sizeof(errbuf),\n                 _(\"ldap object is already kerberized\"));\n        k5_setmsg(context, st, \"%s\", errbuf);\n        goto cleanup;\n    }\n\n    if (xargs.linkdn != NULL) {\n        /*\n         * link information can be changed using modprinc.\n         * However, link information can be changed only on the\n         * standalone kerberos principal objects. A standalone\n         * kerberos principal object is of type krbprincipal\n         * structural objectclass.\n         *\n         * NOTE: kerberos principals on an ldap object can't be\n         * linked to other ldap objects.\n         */\n        if (optype == MODIFY_PRINCIPAL &&\n            kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT) {\n            st = EINVAL;\n            snprintf(errbuf, sizeof(errbuf),\n                     _(\"link information can not be set/updated as the \"\n                       \"kerberos principal belongs to an ldap object\"));\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n        /*\n         * Check the link information. If there is already a link\n         * existing then this operation is not allowed.\n         */\n        {\n            char **linkdns=NULL;\n            int  j=0;\n\n            if ((st=krb5_get_linkdn(context, entry, &linkdns)) != 0) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Failed getting object references\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            }\n            if (linkdns != NULL) {\n                st = EINVAL;\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"kerberos principal is already linked to a ldap \"\n                           \"object\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                for (j=0; linkdns[j] != NULL; ++j)\n                    free (linkdns[j]);\n                free (linkdns);\n                goto cleanup;\n            }\n        }\n\n        establish_links = TRUE;\n    }\n\n    if (entry->mask & KADM5_LAST_SUCCESS) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_success)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastSuccessfulAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_LAST_FAILED) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_failed)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastFailedAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free(strval[0]);\n    }\n\n    if (entry->mask & KADM5_FAIL_AUTH_COUNT) {\n        krb5_kvno fail_auth_count;\n\n        fail_auth_count = entry->fail_auth_count;\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            fail_auth_count++;\n\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_REPLACE,\n                                       fail_auth_count);\n        if (st != 0)\n            goto cleanup;\n    } else if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT) {\n        int attr_mask = 0;\n        krb5_boolean has_fail_count;\n\n        /* Check if the krbLoginFailedCount attribute exists.  (Through\n         * krb5 1.8.1, it wasn't set in new entries.) */\n        st = krb5_get_attributes_mask(context, entry, &attr_mask);\n        if (st != 0)\n            goto cleanup;\n        has_fail_count = ((attr_mask & KDB_FAIL_AUTH_COUNT_ATTR) != 0);\n\n        /*\n         * If the client library and server supports RFC 4525,\n         * then use it to increment by one the value of the\n         * krbLoginFailedCount attribute. Otherwise, assert the\n         * (provided) old value by deleting it before adding.\n         */\n#ifdef LDAP_MOD_INCREMENT\n        if (ldap_server_handle->server_info->modify_increment &&\n            has_fail_count) {\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_INCREMENT, 1);\n            if (st != 0)\n                goto cleanup;\n        } else {\n#endif /* LDAP_MOD_INCREMENT */\n            if (has_fail_count) {\n                st = krb5_add_int_mem_ldap_mod(&mods,\n                                               \"krbLoginFailedCount\",\n                                               LDAP_MOD_DELETE,\n                                               entry->fail_auth_count);\n                if (st != 0)\n                    goto cleanup;\n            }\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_ADD,\n                                           entry->fail_auth_count + 1);\n            if (st != 0)\n                goto cleanup;\n#ifdef LDAP_MOD_INCREMENT\n        }\n#endif\n    } else if (optype == ADD_PRINCIPAL) {\n        /* Initialize krbLoginFailedCount in new entries to help avoid a\n         * race during the first failed login. */\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_ADD, 0);\n    }\n\n    if (entry->mask & KADM5_MAX_LIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxticketlife\", LDAP_MOD_REPLACE, entry->max_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_MAX_RLIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxrenewableage\", LDAP_MOD_REPLACE,\n                                          entry->max_renewable_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_ATTRIBUTES) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbticketflags\", LDAP_MOD_REPLACE,\n                                          entry->attributes)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINCIPAL) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = user;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalname\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINC_EXPIRE_TIME) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalexpiration\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_PW_EXPIRATION) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpasswordexpiration\",\n                                          LDAP_MOD_REPLACE,\n                                          strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_POLICY || entry->mask & KADM5_KEY_HIST) {\n        memset(&princ_ent, 0, sizeof(princ_ent));\n        for (tl_data=entry->tl_data; tl_data; tl_data=tl_data->tl_data_next) {\n            if (tl_data->tl_data_type == KRB5_TL_KADM_DATA) {\n                if ((st = krb5_lookup_tl_kadm_data(tl_data, &princ_ent)) != 0) {\n                    goto cleanup;\n                }\n                break;\n            }\n        }\n    }\n\n    if (entry->mask & KADM5_POLICY) {\n        if (princ_ent.aux_attributes & KADM5_POLICY) {\n            memset(strval, 0, sizeof(strval));\n            if ((st = krb5_ldap_name_to_policydn (context, princ_ent.policy, &polname)) != 0)\n                goto cleanup;\n            strval[0] = polname;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n        } else {\n            st = EINVAL;\n            k5_setmsg(context, st, \"Password policy value null\");\n            goto cleanup;\n        }\n    } else if (entry->mask & KADM5_LOAD && found_entry == TRUE) {\n        /*\n         * a load is special in that existing entries must have attrs that\n         * removed.\n         */\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_POLICY_CLR) {\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_KEY_HIST) {\n        bersecretkey = krb5_encode_histkey(&princ_ent);\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        st = krb5_add_ber_mem_ldap_mod(&mods, \"krbpwdhistory\",\n                                       LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                       bersecretkey);\n        if (st != 0)\n            goto cleanup;\n        free_berdata(bersecretkey);\n        bersecretkey = NULL;\n    }\n\n    if (entry->mask & KADM5_KEY_DATA || entry->mask & KADM5_KVNO) {\n        krb5_kvno mkvno;\n\n        if ((st=krb5_dbe_lookup_mkvno(context, entry, &mkvno)) != 0)\n            goto cleanup;\n        bersecretkey = krb5_encode_krbsecretkey (entry->key_data,\n                                                 entry->n_key_data, mkvno);\n\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n        /* An empty list of bervals is only accepted for modify operations,\n         * not add operations. */\n        if (bersecretkey[0] != NULL || !create_standalone) {\n            st = krb5_add_ber_mem_ldap_mod(&mods, \"krbprincipalkey\",\n                                           LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                           bersecretkey);\n            if (st != 0)\n                goto cleanup;\n        }\n\n        if (!(entry->mask & KADM5_PRINCIPAL)) {\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n                goto cleanup;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods,\n                                              \"krbpasswordexpiration\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n        /* Update last password change whenever a new key is set */\n        {\n            krb5_timestamp last_pw_changed;\n            if ((st=krb5_dbe_lookup_last_pwd_change(context, entry,\n                                                    &last_pw_changed)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(last_pw_changed)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastPwdChange\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n    } /* Modify Key data ends here */\n\n    /* Auth indicators will also be stored in krbExtraData when processing\n     * tl_data. */\n    st = update_ldap_mod_auth_ind(context, entry, &mods);\n    if (st != 0)\n        goto cleanup;\n\n    /* Set tl_data */\n    if (entry->tl_data != NULL) {\n        int count = 0;\n        struct berval **ber_tl_data = NULL;\n        krb5_tl_data *ptr;\n        krb5_timestamp unlock_time;\n        for (ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n            if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                || ptr->tl_data_type == KDB_TL_USER_INFO\n                || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                continue;\n            count++;\n        }\n        if (count != 0) {\n            int j;\n            ber_tl_data = (struct berval **) calloc (count + 1,\n                                                     sizeof (struct berval*));\n            if (ber_tl_data == NULL) {\n                st = ENOMEM;\n                goto cleanup;\n            }\n            for (j = 0, ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n                /* Ignore tl_data that are stored in separate directory\n                 * attributes */\n                if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                    || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                    || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                    || ptr->tl_data_type == KDB_TL_USER_INFO\n                    || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                    || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                    continue;\n                if ((st = tl_data2berval (ptr, &ber_tl_data[j])) != 0)\n                    break;\n                j++;\n            }\n            if (st == 0) {\n                ber_tl_data[count] = NULL;\n                st=krb5_add_ber_mem_ldap_mod(&mods, \"krbExtraData\",\n                                             LDAP_MOD_REPLACE |\n                                             LDAP_MOD_BVALUES, ber_tl_data);\n            }\n            free_berdata(ber_tl_data);\n            if (st != 0)\n                goto cleanup;\n        }\n        if ((st=krb5_dbe_lookup_last_admin_unlock(context, entry,\n                                                  &unlock_time)) != 0)\n            goto cleanup;\n        if (unlock_time != 0) {\n            /* Update last admin unlock */\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(unlock_time)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastAdminUnlock\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n    }\n\n    /* Directory specific attribute */\n    if (xargs.tktpolicydn != NULL) {\n        int tmask=0;\n\n        if (strlen(xargs.tktpolicydn) != 0) {\n            st = checkattributevalue(ld, xargs.tktpolicydn, \"objectclass\", policyclass, &tmask);\n            CHECK_CLASS_VALIDITY(st, tmask, _(\"ticket policy object value: \"));\n\n            strval[0] = xargs.tktpolicydn;\n            strval[1] = NULL;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n\n        } else {\n            /* if xargs.tktpolicydn is a empty string, then delete\n             * already existing krbticketpolicyreference attr */\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n                goto cleanup;\n        }\n\n    }\n\n    if (establish_links == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = xargs.linkdn;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbObjectReferences\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    /*\n     * in case mods is NULL then return\n     * not sure but can happen in a modprinc\n     * so no need to return an error\n     * addprinc will at least have the principal name\n     * and the keys passed in\n     */\n    if (mods == NULL)\n        goto cleanup;\n\n    if (create_standalone == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = \"krbprincipal\";\n        strval[1] = \"krbprincipalaux\";\n        strval[2] = \"krbTicketPolicyAux\";\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n            goto cleanup;\n\n        st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n        if (st == LDAP_ALREADY_EXISTS && entry->mask & KADM5_LOAD) {\n            /* a load operation must replace an existing entry */\n            st = ldap_delete_ext_s(ld, standalone_principal_dn, NULL, NULL);\n            if (st != LDAP_SUCCESS) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Principal delete failed (trying to replace \"\n                           \"entry): %s\"), ldap_err2string(st));\n                st = translate_ldap_error (st, OP_ADD);\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            } else {\n                st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n            }\n        }\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"Principal add failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_ADD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n    } else {\n        /*\n         * Here existing ldap object is modified and can be related\n         * to any attribute, so always ensure that the ldap\n         * object is extended with all the kerberos related\n         * objectclasses so that there are no constraint\n         * violations.\n         */\n        {\n            char *attrvalues[] = {\"krbprincipalaux\", \"krbTicketPolicyAux\", NULL};\n            int p, q, r=0, amask=0;\n\n            if ((st=checkattributevalue(ld, (xargs.dn) ? xargs.dn : principal_dn,\n                                        \"objectclass\", attrvalues, &amask)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            for (p=1, q=0; p<=2; p<<=1, ++q) {\n                if ((p & amask) == 0)\n                    strval[r++] = attrvalues[q];\n            }\n            if (r != 0) {\n                if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n                    goto cleanup;\n            }\n        }\n        if (xargs.dn != NULL)\n            st=ldap_modify_ext_s(ld, xargs.dn, mods, NULL, NULL);\n        else\n            st = ldap_modify_ext_s(ld, principal_dn, mods, NULL, NULL);\n\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"User modification failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_MOD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            entry->fail_auth_count++;\n    }\n\ncleanup:\n    if (user)\n        free(user);\n\n    if (filtuser)\n        free(filtuser);\n\n    free_xargs(xargs);\n\n    if (standalone_principal_dn)\n        free(standalone_principal_dn);\n\n    if (principal_dn)\n        free (principal_dn);\n\n    if (polname != NULL)\n        free(polname);\n\n    for (tre = 0; tre < ntrees; tre++)\n        free(subtreelist[tre]);\n    free(subtreelist);\n\n    if (subtree)\n        free (subtree);\n\n    if (bersecretkey) {\n        for (l=0; bersecretkey[l]; ++l) {\n            if (bersecretkey[l]->bv_val)\n                free (bersecretkey[l]->bv_val);\n            free (bersecretkey[l]);\n        }\n        free (bersecretkey);\n    }\n\n    if (keys)\n        free (keys);\n\n    ldap_mods_free(mods, 1);\n    ldap_osa_free_princ_ent(&princ_ent);\n    ldap_msgfree(result);\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return(st);\n}",
        "func_after": "krb5_error_code\nkrb5_ldap_put_principal(krb5_context context, krb5_db_entry *entry,\n                        char **db_args)\n{\n    int                         l=0, kerberos_principal_object_type=0;\n    unsigned int                ntrees=0, tre=0;\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL, *ent=NULL;\n    char                        **subtreelist = NULL;\n    char                        *user=NULL, *subtree=NULL, *principal_dn=NULL;\n    char                        *strval[10]={NULL}, errbuf[1024];\n    char                        *filtuser=NULL;\n    struct berval               **bersecretkey=NULL;\n    LDAPMod                     **mods=NULL;\n    krb5_boolean                create_standalone=FALSE;\n    krb5_boolean                establish_links=FALSE;\n    char                        *standalone_principal_dn=NULL;\n    krb5_tl_data                *tl_data=NULL;\n    krb5_key_data               **keys=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    osa_princ_ent_rec           princ_ent = {0};\n    xargs_t                     xargs = {0};\n    char                        *polname = NULL;\n    OPERATION optype;\n    krb5_boolean                found_entry = FALSE;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    SETUP_CONTEXT();\n    if (ldap_context->lrparams == NULL || ldap_context->container_dn == NULL)\n        return EINVAL;\n\n    /* get ldap handle */\n    GET_HANDLE();\n\n    if (!is_principal_in_realm(ldap_context, entry->princ)) {\n        st = EINVAL;\n        k5_setmsg(context, st,\n                  _(\"Principal does not belong to the default realm\"));\n        goto cleanup;\n    }\n\n    /* get the principal information to act on */\n    if (((st=krb5_unparse_name(context, entry->princ, &user)) != 0) ||\n        ((st=krb5_ldap_unparse_principal_name(user)) != 0))\n        goto cleanup;\n    filtuser = ldap_filter_correct(user);\n    if (filtuser == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Identity the type of operation, it can be\n     * add principal or modify principal.\n     * hack if the entry->mask has KRB_PRINCIPAL flag set\n     * then it is a add operation\n     */\n    if (entry->mask & KADM5_PRINCIPAL)\n        optype = ADD_PRINCIPAL;\n    else\n        optype = MODIFY_PRINCIPAL;\n\n    if (((st=krb5_get_princ_type(context, entry, &kerberos_principal_object_type)) != 0) ||\n        ((st=krb5_get_userdn(context, entry, &principal_dn)) != 0))\n        goto cleanup;\n\n    if ((st=process_db_args(context, db_args, &xargs, optype)) != 0)\n        goto cleanup;\n\n    if (entry->mask & KADM5_LOAD) {\n        unsigned int     tree = 0;\n        int              numlentries = 0;\n        char             *filter = NULL;\n\n        /*  A load operation is special, will do a mix-in (add krbprinc\n         *  attrs to a non-krb object entry) if an object exists with a\n         *  matching krbprincipalname attribute so try to find existing\n         *  object and set principal_dn.  This assumes that the\n         *  krbprincipalname attribute is unique (only one object entry has\n         *  a particular krbprincipalname attribute).\n         */\n        if (asprintf(&filter, FILTER\"%s))\", filtuser) < 0) {\n            filter = NULL;\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        /* get the current subtree list */\n        if ((st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees)) != 0)\n            goto cleanup;\n\n        found_entry = FALSE;\n        /* search for entry with matching krbprincipalname attribute */\n        for (tree = 0; found_entry == FALSE && tree < ntrees; ++tree) {\n            if (principal_dn == NULL) {\n                LDAP_SEARCH_1(subtreelist[tree], ldap_context->lrparams->search_scope, filter, principal_attributes, IGNORE_STATUS);\n            } else {\n                /* just look for entry with principal_dn */\n                LDAP_SEARCH_1(principal_dn, LDAP_SCOPE_BASE, filter, principal_attributes, IGNORE_STATUS);\n            }\n            if (st == LDAP_SUCCESS) {\n                numlentries = ldap_count_entries(ld, result);\n                if (numlentries > 1) {\n                    free(filter);\n                    st = EINVAL;\n                    k5_setmsg(context, st,\n                              _(\"operation can not continue, more than one \"\n                                \"entry with principal name \\\"%s\\\" found\"),\n                              user);\n                    goto cleanup;\n                } else if (numlentries == 1) {\n                    found_entry = TRUE;\n                    if (principal_dn == NULL) {\n                        ent = ldap_first_entry(ld, result);\n                        if (ent != NULL) {\n                            /* setting principal_dn will cause that entry to be modified further down */\n                            if ((principal_dn = ldap_get_dn(ld, ent)) == NULL) {\n                                ldap_get_option (ld, LDAP_OPT_RESULT_CODE, &st);\n                                st = set_ldap_error (context, st, 0);\n                                free(filter);\n                                goto cleanup;\n                            }\n                        }\n                    }\n                }\n            } else if (st != LDAP_NO_SUCH_OBJECT) {\n                /* could not perform search, return with failure */\n                st = set_ldap_error (context, st, 0);\n                free(filter);\n                goto cleanup;\n            }\n            ldap_msgfree(result);\n            result = NULL;\n            /*\n             * If it isn't found then assume a standalone princ entry is to\n             * be created.\n             */\n        } /* end for (tree = 0; principal_dn == ... */\n\n        free(filter);\n\n        if (found_entry == FALSE && principal_dn != NULL) {\n            /*\n             * if principal_dn is null then there is code further down to\n             * deal with setting standalone_principal_dn.  Also note that\n             * this will set create_standalone true for\n             * non-mix-in entries which is okay if loading from a dump.\n             */\n            create_standalone = TRUE;\n            standalone_principal_dn = strdup(principal_dn);\n            CHECK_NULL(standalone_principal_dn);\n        }\n    } /* end if (entry->mask & KADM5_LOAD */\n\n    /* time to generate the DN information with the help of\n     * containerdn, principalcontainerreference or\n     * realmcontainerdn information\n     */\n    if (principal_dn == NULL && xargs.dn == NULL) { /* creation of standalone principal */\n        /* get the subtree information */\n        if (entry->princ->length == 2 && entry->princ->data[0].length == strlen(\"krbtgt\") &&\n            strncmp(entry->princ->data[0].data, \"krbtgt\", entry->princ->data[0].length) == 0) {\n            /* if the principal is a inter-realm principal, always created in the realm container */\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        } else if (xargs.containerdn) {\n            if ((st=checkattributevalue(ld, xargs.containerdn, NULL, NULL, NULL)) != 0) {\n                if (st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION) {\n                    int ost = st;\n                    st = EINVAL;\n                    k5_wrapmsg(context, ost, st, _(\"'%s' not found\"),\n                               xargs.containerdn);\n                }\n                goto cleanup;\n            }\n            subtree = strdup(xargs.containerdn);\n        } else if (ldap_context->lrparams->containerref && strlen(ldap_context->lrparams->containerref) != 0) {\n            /*\n             * Here the subtree should be changed with\n             * principalcontainerreference attribute value\n             */\n            subtree = strdup(ldap_context->lrparams->containerref);\n        } else {\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        }\n        CHECK_NULL(subtree);\n\n        if (asprintf(&standalone_principal_dn, \"krbprincipalname=%s,%s\",\n                     filtuser, subtree) < 0)\n            standalone_principal_dn = NULL;\n        CHECK_NULL(standalone_principal_dn);\n        /*\n         * free subtree when you are done using the subtree\n         * set the boolean create_standalone to TRUE\n         */\n        create_standalone = TRUE;\n        free(subtree);\n        subtree = NULL;\n    }\n\n    /*\n     * If the DN information is presented by the user, time to\n     * validate the input to ensure that the DN falls under\n     * any of the subtrees\n     */\n    if (xargs.dn_from_kbd == TRUE) {\n        /* Get the current subtree list if we haven't already done so. */\n        if (subtreelist == NULL) {\n            st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees);\n            if (st)\n                goto cleanup;\n        }\n\n        st = validate_xargs(context, ldap_server_handle, &xargs,\n                            standalone_principal_dn, subtreelist, ntrees);\n        if (st)\n            goto cleanup;\n    }\n\n    if (xargs.linkdn != NULL) {\n        /*\n         * link information can be changed using modprinc.\n         * However, link information can be changed only on the\n         * standalone kerberos principal objects. A standalone\n         * kerberos principal object is of type krbprincipal\n         * structural objectclass.\n         *\n         * NOTE: kerberos principals on an ldap object can't be\n         * linked to other ldap objects.\n         */\n        if (optype == MODIFY_PRINCIPAL &&\n            kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT) {\n            st = EINVAL;\n            snprintf(errbuf, sizeof(errbuf),\n                     _(\"link information can not be set/updated as the \"\n                       \"kerberos principal belongs to an ldap object\"));\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n        /*\n         * Check the link information. If there is already a link\n         * existing then this operation is not allowed.\n         */\n        {\n            char **linkdns=NULL;\n            int  j=0;\n\n            if ((st=krb5_get_linkdn(context, entry, &linkdns)) != 0) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Failed getting object references\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            }\n            if (linkdns != NULL) {\n                st = EINVAL;\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"kerberos principal is already linked to a ldap \"\n                           \"object\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                for (j=0; linkdns[j] != NULL; ++j)\n                    free (linkdns[j]);\n                free (linkdns);\n                goto cleanup;\n            }\n        }\n\n        establish_links = TRUE;\n    }\n\n    if (entry->mask & KADM5_LAST_SUCCESS) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_success)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastSuccessfulAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_LAST_FAILED) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_failed)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastFailedAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free(strval[0]);\n    }\n\n    if (entry->mask & KADM5_FAIL_AUTH_COUNT) {\n        krb5_kvno fail_auth_count;\n\n        fail_auth_count = entry->fail_auth_count;\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            fail_auth_count++;\n\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_REPLACE,\n                                       fail_auth_count);\n        if (st != 0)\n            goto cleanup;\n    } else if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT) {\n        int attr_mask = 0;\n        krb5_boolean has_fail_count;\n\n        /* Check if the krbLoginFailedCount attribute exists.  (Through\n         * krb5 1.8.1, it wasn't set in new entries.) */\n        st = krb5_get_attributes_mask(context, entry, &attr_mask);\n        if (st != 0)\n            goto cleanup;\n        has_fail_count = ((attr_mask & KDB_FAIL_AUTH_COUNT_ATTR) != 0);\n\n        /*\n         * If the client library and server supports RFC 4525,\n         * then use it to increment by one the value of the\n         * krbLoginFailedCount attribute. Otherwise, assert the\n         * (provided) old value by deleting it before adding.\n         */\n#ifdef LDAP_MOD_INCREMENT\n        if (ldap_server_handle->server_info->modify_increment &&\n            has_fail_count) {\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_INCREMENT, 1);\n            if (st != 0)\n                goto cleanup;\n        } else {\n#endif /* LDAP_MOD_INCREMENT */\n            if (has_fail_count) {\n                st = krb5_add_int_mem_ldap_mod(&mods,\n                                               \"krbLoginFailedCount\",\n                                               LDAP_MOD_DELETE,\n                                               entry->fail_auth_count);\n                if (st != 0)\n                    goto cleanup;\n            }\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_ADD,\n                                           entry->fail_auth_count + 1);\n            if (st != 0)\n                goto cleanup;\n#ifdef LDAP_MOD_INCREMENT\n        }\n#endif\n    } else if (optype == ADD_PRINCIPAL) {\n        /* Initialize krbLoginFailedCount in new entries to help avoid a\n         * race during the first failed login. */\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_ADD, 0);\n    }\n\n    if (entry->mask & KADM5_MAX_LIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxticketlife\", LDAP_MOD_REPLACE, entry->max_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_MAX_RLIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxrenewableage\", LDAP_MOD_REPLACE,\n                                          entry->max_renewable_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_ATTRIBUTES) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbticketflags\", LDAP_MOD_REPLACE,\n                                          entry->attributes)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINCIPAL) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = user;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalname\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINC_EXPIRE_TIME) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalexpiration\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_PW_EXPIRATION) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpasswordexpiration\",\n                                          LDAP_MOD_REPLACE,\n                                          strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_POLICY || entry->mask & KADM5_KEY_HIST) {\n        memset(&princ_ent, 0, sizeof(princ_ent));\n        for (tl_data=entry->tl_data; tl_data; tl_data=tl_data->tl_data_next) {\n            if (tl_data->tl_data_type == KRB5_TL_KADM_DATA) {\n                if ((st = krb5_lookup_tl_kadm_data(tl_data, &princ_ent)) != 0) {\n                    goto cleanup;\n                }\n                break;\n            }\n        }\n    }\n\n    if (entry->mask & KADM5_POLICY) {\n        if (princ_ent.aux_attributes & KADM5_POLICY) {\n            memset(strval, 0, sizeof(strval));\n            if ((st = krb5_ldap_name_to_policydn (context, princ_ent.policy, &polname)) != 0)\n                goto cleanup;\n            strval[0] = polname;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n        } else {\n            st = EINVAL;\n            k5_setmsg(context, st, \"Password policy value null\");\n            goto cleanup;\n        }\n    } else if (entry->mask & KADM5_LOAD && found_entry == TRUE) {\n        /*\n         * a load is special in that existing entries must have attrs that\n         * removed.\n         */\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_POLICY_CLR) {\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_KEY_HIST) {\n        bersecretkey = krb5_encode_histkey(&princ_ent);\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        st = krb5_add_ber_mem_ldap_mod(&mods, \"krbpwdhistory\",\n                                       LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                       bersecretkey);\n        if (st != 0)\n            goto cleanup;\n        free_berdata(bersecretkey);\n        bersecretkey = NULL;\n    }\n\n    if (entry->mask & KADM5_KEY_DATA || entry->mask & KADM5_KVNO) {\n        krb5_kvno mkvno;\n\n        if ((st=krb5_dbe_lookup_mkvno(context, entry, &mkvno)) != 0)\n            goto cleanup;\n        bersecretkey = krb5_encode_krbsecretkey (entry->key_data,\n                                                 entry->n_key_data, mkvno);\n\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n        /* An empty list of bervals is only accepted for modify operations,\n         * not add operations. */\n        if (bersecretkey[0] != NULL || !create_standalone) {\n            st = krb5_add_ber_mem_ldap_mod(&mods, \"krbprincipalkey\",\n                                           LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                           bersecretkey);\n            if (st != 0)\n                goto cleanup;\n        }\n\n        if (!(entry->mask & KADM5_PRINCIPAL)) {\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n                goto cleanup;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods,\n                                              \"krbpasswordexpiration\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n        /* Update last password change whenever a new key is set */\n        {\n            krb5_timestamp last_pw_changed;\n            if ((st=krb5_dbe_lookup_last_pwd_change(context, entry,\n                                                    &last_pw_changed)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(last_pw_changed)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastPwdChange\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n    } /* Modify Key data ends here */\n\n    /* Auth indicators will also be stored in krbExtraData when processing\n     * tl_data. */\n    st = update_ldap_mod_auth_ind(context, entry, &mods);\n    if (st != 0)\n        goto cleanup;\n\n    /* Set tl_data */\n    if (entry->tl_data != NULL) {\n        int count = 0;\n        struct berval **ber_tl_data = NULL;\n        krb5_tl_data *ptr;\n        krb5_timestamp unlock_time;\n        for (ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n            if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                || ptr->tl_data_type == KDB_TL_USER_INFO\n                || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                continue;\n            count++;\n        }\n        if (count != 0) {\n            int j;\n            ber_tl_data = (struct berval **) calloc (count + 1,\n                                                     sizeof (struct berval*));\n            if (ber_tl_data == NULL) {\n                st = ENOMEM;\n                goto cleanup;\n            }\n            for (j = 0, ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n                /* Ignore tl_data that are stored in separate directory\n                 * attributes */\n                if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                    || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                    || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                    || ptr->tl_data_type == KDB_TL_USER_INFO\n                    || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                    || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                    continue;\n                if ((st = tl_data2berval (ptr, &ber_tl_data[j])) != 0)\n                    break;\n                j++;\n            }\n            if (st == 0) {\n                ber_tl_data[count] = NULL;\n                st=krb5_add_ber_mem_ldap_mod(&mods, \"krbExtraData\",\n                                             LDAP_MOD_REPLACE |\n                                             LDAP_MOD_BVALUES, ber_tl_data);\n            }\n            free_berdata(ber_tl_data);\n            if (st != 0)\n                goto cleanup;\n        }\n        if ((st=krb5_dbe_lookup_last_admin_unlock(context, entry,\n                                                  &unlock_time)) != 0)\n            goto cleanup;\n        if (unlock_time != 0) {\n            /* Update last admin unlock */\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(unlock_time)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastAdminUnlock\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n    }\n\n    /* Directory specific attribute */\n    if (xargs.tktpolicydn != NULL) {\n        int tmask=0;\n\n        if (strlen(xargs.tktpolicydn) != 0) {\n            st = checkattributevalue(ld, xargs.tktpolicydn, \"objectclass\", policyclass, &tmask);\n            CHECK_CLASS_VALIDITY(st, tmask, _(\"ticket policy object value: \"));\n\n            strval[0] = xargs.tktpolicydn;\n            strval[1] = NULL;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n\n        } else {\n            /* if xargs.tktpolicydn is a empty string, then delete\n             * already existing krbticketpolicyreference attr */\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n                goto cleanup;\n        }\n\n    }\n\n    if (establish_links == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = xargs.linkdn;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbObjectReferences\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    /*\n     * in case mods is NULL then return\n     * not sure but can happen in a modprinc\n     * so no need to return an error\n     * addprinc will at least have the principal name\n     * and the keys passed in\n     */\n    if (mods == NULL)\n        goto cleanup;\n\n    if (create_standalone == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = \"krbprincipal\";\n        strval[1] = \"krbprincipalaux\";\n        strval[2] = \"krbTicketPolicyAux\";\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n            goto cleanup;\n\n        st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n        if (st == LDAP_ALREADY_EXISTS && entry->mask & KADM5_LOAD) {\n            /* a load operation must replace an existing entry */\n            st = ldap_delete_ext_s(ld, standalone_principal_dn, NULL, NULL);\n            if (st != LDAP_SUCCESS) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Principal delete failed (trying to replace \"\n                           \"entry): %s\"), ldap_err2string(st));\n                st = translate_ldap_error (st, OP_ADD);\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            } else {\n                st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n            }\n        }\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"Principal add failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_ADD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n    } else {\n        /*\n         * Here existing ldap object is modified and can be related\n         * to any attribute, so always ensure that the ldap\n         * object is extended with all the kerberos related\n         * objectclasses so that there are no constraint\n         * violations.\n         */\n        {\n            char *attrvalues[] = {\"krbprincipalaux\", \"krbTicketPolicyAux\", NULL};\n            int p, q, r=0, amask=0;\n\n            if ((st=checkattributevalue(ld, (xargs.dn) ? xargs.dn : principal_dn,\n                                        \"objectclass\", attrvalues, &amask)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            for (p=1, q=0; p<=2; p<<=1, ++q) {\n                if ((p & amask) == 0)\n                    strval[r++] = attrvalues[q];\n            }\n            if (r != 0) {\n                if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n                    goto cleanup;\n            }\n        }\n        if (xargs.dn != NULL)\n            st=ldap_modify_ext_s(ld, xargs.dn, mods, NULL, NULL);\n        else\n            st = ldap_modify_ext_s(ld, principal_dn, mods, NULL, NULL);\n\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"User modification failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_MOD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            entry->fail_auth_count++;\n    }\n\ncleanup:\n    if (user)\n        free(user);\n\n    if (filtuser)\n        free(filtuser);\n\n    free_xargs(xargs);\n\n    if (standalone_principal_dn)\n        free(standalone_principal_dn);\n\n    if (principal_dn)\n        free (principal_dn);\n\n    if (polname != NULL)\n        free(polname);\n\n    for (tre = 0; tre < ntrees; tre++)\n        free(subtreelist[tre]);\n    free(subtreelist);\n\n    if (subtree)\n        free (subtree);\n\n    if (bersecretkey) {\n        for (l=0; bersecretkey[l]; ++l) {\n            if (bersecretkey[l]->bv_val)\n                free (bersecretkey[l]->bv_val);\n            free (bersecretkey[l]);\n        }\n        free (bersecretkey);\n    }\n\n    if (keys)\n        free (keys);\n\n    ldap_mods_free(mods, 1);\n    ldap_osa_free_princ_ent(&princ_ent);\n    ldap_msgfree(result);\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return(st);\n}",
        "description": "An authenticated kadmin user with permissions to add principals to an LDAP Kerberos database can trigger a denial of service through a NULL pointer dereference or bypass a DN container check by providing tagged data that is internal to the database module.",
        "commit": "It was discovered that the LDAP DN checking mechanism in the MIT krb5 library had several vulnerabilities. Specifically, the `KDB_TL_USER_INFO` tl-data, which is intended to be internal to the LDAP KDB module, could be inadvertently sent by kadmin clients due to insufficient type number validation. This allowed authenticated kadmin users with permission to add principals to an LDAP Kerberos database to either cause a null dereference in kadmind or bypass intended DN container checks by manipulating tagged data.\n\nTo address these issues, the type number for `KDB_TL_USER_INFO` was set to less than 256, and filtering was implemented in `kadm5_create_principal_3()` to exclude such low type numbers. Additionally, in the LDAP KDB module, checks for container membership were enhanced by factoring out the checks into helper functions and applying them to all relevant client-influenced DNs during `put_principal` operations. These changes aimed to prevent unauthorized access and ensure proper DN validation."
    },
    {
        "cwe": "CWE-444",
        "func_name": "haproxy/http_parse_cont_len_header",
        "score": 0.7333402037620544,
        "func_before": "int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\n\tword.ptr = value->ptr - 1; // -1 for next loop's pre-increment\n\te = value->ptr + value->len;\n\n\twhile (++word.ptr < e) {\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\t*body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}",
        "func_after": "int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\n\tword.ptr = value->ptr;\n\te = value->ptr + value->len;\n\n\twhile (1) {\n\t\tif (word.ptr >= e) {\n\t\t\t/* empty header or empty value */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr))) {\n\t\t\tword.ptr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\t*body_len = cl;\n\t\t*value = word;\n\n\t\t/* Now either n==e and we're done, or n points to the comma,\n\t\t * and we skip it and continue.\n\t\t */\n\t\tif (n++ == e)\n\t\t\tbreak;\n\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}",
        "description": "HAProxy versions up to 2.0.32, 2.1.x, 2.2.x through 2.2.30, 2.3.x, 2.4.x through 2.4.23, 2.5.x, and 2.6.x before 2.6.15, 2.7.x before 2.7.10, and 2.8.x before 2.8.2 forward empty Content-Length headers, which violates RFC 9110 section 8.6. In rare scenarios, an HTTP/1 server positioned behind HAProxy may misinterpret the payload as an additional request.",
        "commit": "A vulnerability was identified in the HTTP content-length header parsing mechanism, where an empty or trailing-comma value could be misinterpreted as an absent header. This oversight allowed such headers to pass through to the backend server without proper validation, potentially exposing vulnerable servers to attacks. The risk varies based on the backend server's handling of content-length headers, but users relying on HAProxy to protect known-vulnerable servers are particularly at risk. A configuration-based workaround involves explicitly rejecting requests with empty content-length headers in the frontend settings. The permanent fix requires modifying the parser to ensure that only valid values are accepted, rejecting any empty values encountered. This change needs to be applied across all supported versions of the software. The modifications were made to functions such as `h1_parse_cont_len_header()` and `http_parse_cont_len_header()`, with additional considerations for compatibility with Lua and future deprecation plans. Comprehensive testing was conducted to validate these changes."
    },
    {
        "cwe": "CWE-78",
        "func_name": "emacs/main",
        "score": 0.7493195533752441,
        "func_before": "int\nmain (int argc, char **argv)\n{\n  int i;\n  int nincluded_files;\n  char **included_files;\n  argument *argbuffer;\n  int current_arg, file_count;\n  linebuffer filename_lb;\n  bool help_asked = false;\n  ptrdiff_t len;\n  char *optstring;\n  int opt;\n\n  progname = argv[0];\n  nincluded_files = 0;\n  included_files = xnew (argc, char *);\n  current_arg = 0;\n  file_count = 0;\n\n  /* Allocate enough no matter what happens.  Overkill, but each one\n     is small. */\n  argbuffer = xnew (argc, argument);\n\n  /*\n   * Always find typedefs and structure tags.\n   * Also default to find macro constants, enum constants, struct\n   * members and global variables.  Do it for both etags and ctags.\n   */\n  typedefs = typedefs_or_cplusplus = constantypedefs = true;\n  globals = members = true;\n\n  /* When the optstring begins with a '-' getopt_long does not rearrange the\n     non-options arguments to be at the end, but leaves them alone. */\n  optstring = concat (\"-ac:Cf:Il:o:Qr:RSVhH\",\n\t\t      (CTAGS) ? \"BxdtTuvw\" : \"Di:\",\n\t\t      \"\");\n\n  while ((opt = getopt_long (argc, argv, optstring, longopts, NULL)) != EOF)\n    switch (opt)\n      {\n      case 0:\n\t/* If getopt returns 0, then it has already processed a\n\t   long-named option.  We should do nothing.  */\n\tbreak;\n\n      case 1:\n\t/* This means that a file name has been seen.  Record it. */\n\targbuffer[current_arg].arg_type = at_filename;\n\targbuffer[current_arg].what     = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\t++file_count;\n\tbreak;\n\n      case STDIN:\n\t/* Parse standard input.  Idea by Vivek <vivek@etla.org>. */\n\targbuffer[current_arg].arg_type = at_stdin;\n\targbuffer[current_arg].what     = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\t++file_count;\n\tif (parsing_stdin)\n\t  fatal (\"cannot parse standard input more than once\");\n\tparsing_stdin = true;\n\tbreak;\n\n\t/* Common options. */\n      case 'a': append_to_tagfile = true;\tbreak;\n      case 'C': cplusplus = true;\t\tbreak;\n      case 'f':\t\t/* for compatibility with old makefiles */\n      case 'o':\n\tif (tagfile)\n\t  {\n\t    error (\"-o option may only be given once.\");\n\t    suggest_asking_for_help ();\n\t  }\n\ttagfile = optarg;\n\tbreak;\n      case 'I':\n      case 'S':\t\t/* for backward compatibility */\n\tignoreindent = true;\n\tbreak;\n      case 'l':\n\t{\n\t  language *lang = get_language_from_langname (optarg);\n\t  if (lang != NULL)\n\t    {\n\t      argbuffer[current_arg].lang = lang;\n\t      argbuffer[current_arg].arg_type = at_language;\n\t      ++current_arg;\n\t    }\n\t}\n\tbreak;\n      case 'c':\n\t/* Backward compatibility: support obsolete --ignore-case-regexp. */\n\toptarg = concat (optarg, \"i\", \"\"); /* memory leak here */\n\tFALLTHROUGH;\n      case 'r':\n\targbuffer[current_arg].arg_type = at_regexp;\n\targbuffer[current_arg].what = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\tbreak;\n      case 'R':\n\targbuffer[current_arg].arg_type = at_regexp;\n\targbuffer[current_arg].what = NULL;\n\t++current_arg;\n\tbreak;\n      case 'V':\n\tprint_version ();\n\tbreak;\n      case 'h':\n      case 'H':\n\thelp_asked = true;\n\tbreak;\n      case 'Q':\n\tclass_qualify = 1;\n\tbreak;\n\n\t/* Etags options */\n      case 'D': constantypedefs = false;\t\t\tbreak;\n      case 'i': included_files[nincluded_files++] = optarg;\tbreak;\n\n\t/* Ctags options. */\n      case 'B': searchar = '?';\t\t\t\t\tbreak;\n      case 'd': constantypedefs = true;\t\t\t\tbreak;\n      case 't': typedefs = true;\t\t\t\tbreak;\n      case 'T': typedefs = typedefs_or_cplusplus = true;\tbreak;\n      case 'u': update = true;\t\t\t\t\tbreak;\n      case 'v': vgrind_style = true;\t\t\t\tFALLTHROUGH;\n      case 'x': cxref_style = true;\t\t\t\tbreak;\n      case 'w': no_warnings = true;\t\t\t\tbreak;\n      default:\n\tsuggest_asking_for_help ();\n      }\n\n  /* No more options.  Store the rest of arguments. */\n  for (; optind < argc; optind++)\n    {\n      argbuffer[current_arg].arg_type = at_filename;\n      argbuffer[current_arg].what = argv[optind];\n      len = strlen (argv[optind]);\n      if (whatlen_max < len)\n\twhatlen_max = len;\n      ++current_arg;\n      ++file_count;\n    }\n\n  argbuffer[current_arg].arg_type = at_end;\n\n  if (help_asked)\n    print_help (argbuffer);\n\n  if (nincluded_files == 0 && file_count == 0)\n    {\n      error (\"no input files specified.\");\n      suggest_asking_for_help ();\n    }\n\n  if (tagfile == NULL)\n    tagfile = savestr (CTAGS ? \"tags\" : \"TAGS\");\n  cwd = etags_getcwd ();\t/* the current working directory */\n  if (cwd[strlen (cwd) - 1] != '/')\n    {\n      char *oldcwd = cwd;\n      cwd = concat (oldcwd, \"/\", \"\");\n      free (oldcwd);\n    }\n\n  /* Compute base directory for relative file names. */\n  if (streq (tagfile, \"-\")\n      || strneq (tagfile, \"/dev/\", 5))\n    tagfiledir = cwd;\t\t /* relative file names are relative to cwd */\n  else\n    {\n      canonicalize_filename (tagfile);\n      tagfiledir = absolute_dirname (tagfile, cwd);\n    }\n\n  linebuffer_init (&lb);\n  linebuffer_init (&filename_lb);\n  linebuffer_init (&filebuf);\n  linebuffer_init (&token_name);\n\n  if (!CTAGS)\n    {\n      if (streq (tagfile, \"-\"))\n\t{\n\t  tagf = stdout;\n\t  set_binary_mode (STDOUT_FILENO, O_BINARY);\n\t}\n      else\n\ttagf = fopen (tagfile, append_to_tagfile ? \"ab\" : \"wb\");\n      if (tagf == NULL)\n\tpfatal (tagfile);\n    }\n\n  /*\n   * Loop through files finding functions.\n   */\n  for (i = 0; i < current_arg; i++)\n    {\n      static language *lang;\t/* non-NULL if language is forced */\n      char *this_file;\n\n      switch (argbuffer[i].arg_type)\n\t{\n\tcase at_language:\n\t  lang = argbuffer[i].lang;\n\t  break;\n\tcase at_regexp:\n\t  analyze_regex (argbuffer[i].what);\n\t  break;\n\tcase at_filename:\n\t      this_file = argbuffer[i].what;\n\t      /* Input file named \"-\" means read file names from stdin\n\t\t (one per line) and use them. */\n\t      if (streq (this_file, \"-\"))\n\t\t{\n\t\t  if (parsing_stdin)\n\t\t    fatal (\"cannot parse standard input \"\n\t\t\t   \"AND read file names from it\");\n\t\t  while (readline_internal (&filename_lb, stdin, \"-\") > 0)\n\t\t    process_file_name (filename_lb.buffer, lang);\n\t\t}\n\t      else\n\t\tprocess_file_name (this_file, lang);\n\t  break;\n        case at_stdin:\n          this_file = argbuffer[i].what;\n          process_file (stdin, this_file, lang);\n          break;\n\tdefault:\n\t  error (\"internal error: arg_type\");\n\t}\n    }\n\n  free_regexps ();\n  free (lb.buffer);\n  free (filebuf.buffer);\n  free (token_name.buffer);\n\n  if (!CTAGS || cxref_style)\n    {\n      /* Write the remaining tags to tagf (ETAGS) or stdout (CXREF). */\n      put_entries (nodehead);\n      free_tree (nodehead);\n      nodehead = NULL;\n      if (!CTAGS)\n\t{\n\t  fdesc *fdp;\n\n\t  /* Output file entries that have no tags. */\n\t  for (fdp = fdhead; fdp != NULL; fdp = fdp->next)\n\t    if (!fdp->written)\n\t      fprintf (tagf, \"\\f\\n%s,0\\n\", fdp->taggedfname);\n\n\t  while (nincluded_files-- > 0)\n\t    fprintf (tagf, \"\\f\\n%s,include\\n\", *included_files++);\n\n\t  if (fclose (tagf) == EOF)\n\t    pfatal (tagfile);\n\t}\n\n      return EXIT_SUCCESS;\n    }\n\n  /* From here on, we are in (CTAGS && !cxref_style) */\n  if (update)\n    {\n      char *cmd =\n\txmalloc (strlen (tagfile) + whatlen_max +\n\t\t sizeof \"mv..OTAGS;grep -Fv '\\t\\t' OTAGS >;rm OTAGS\");\n      for (i = 0; i < current_arg; ++i)\n\t{\n\t  switch (argbuffer[i].arg_type)\n\t    {\n\t    case at_filename:\n\t    case at_stdin:\n\t      break;\n\t    default:\n\t      continue;\t\t/* the for loop */\n\t    }\n\t  char *z = stpcpy (cmd, \"mv \");\n\t  z = stpcpy (z, tagfile);\n\t  z = stpcpy (z, \" OTAGS;grep -Fv '\\t\");\n\t  z = stpcpy (z, argbuffer[i].what);\n\t  z = stpcpy (z, \"\\t' OTAGS >\");\n\t  z = stpcpy (z, tagfile);\n\t  strcpy (z, \";rm OTAGS\");\n\t  if (system (cmd) != EXIT_SUCCESS)\n\t    fatal (\"failed to execute shell command\");\n\t}\n      free (cmd);\n      append_to_tagfile = true;\n    }\n\n  tagf = fopen (tagfile, append_to_tagfile ? \"ab\" : \"wb\");\n  if (tagf == NULL)\n    pfatal (tagfile);\n  put_entries (nodehead);\t/* write all the tags (CTAGS) */\n  free_tree (nodehead);\n  nodehead = NULL;\n  if (fclose (tagf) == EOF)\n    pfatal (tagfile);\n\n  if (CTAGS)\n    if (append_to_tagfile || update)\n      {\n\t/* Maybe these should be used:\n\t   setenv (\"LC_COLLATE\", \"C\", 1);\n\t   setenv (\"LC_ALL\", \"C\", 1); */\n\tchar *cmd = xmalloc (8 * strlen (tagfile) + sizeof \"sort -u -o '' ''\");\n#if defined WINDOWSNT || defined MSDOS\n\t/* Quote \"like this\".  No need to escape the quotes in the file name,\n\t   since it is not allowed in file names on these systems.  */\n\tchar *z = stpcpy (cmd, \"sort -u -o \\\"\");\n\tz = stpcpy (z, tagfile);\n\tz = stpcpy (z, \"\\\" \\\"\");\n\tz = stpcpy (z, tagfile);\n\tstpcpy (z, \"\\\"\");\n#else\n\t/* Quote 'like this', and escape the apostrophe in the file name.  */\n\tchar *z = stpcpy (cmd, \"sort -u -o '\");\n\tchar *escaped_tagfile = z;\n\tfor (; *tagfile; *z++ = *tagfile++)\n\t  if (*tagfile == '\\'')\n\t    z = stpcpy (z, \"'\\\\'\");\n\tptrdiff_t escaped_tagfile_len = z - escaped_tagfile;\n\tz = stpcpy (z, \"' '\");\n\tz = mempcpy (z, escaped_tagfile, escaped_tagfile_len);\n\tstrcpy (z, \"'\");\n#endif\n\treturn system (cmd);\n      }\n  return EXIT_SUCCESS;\n}",
        "func_after": "int\nmain (int argc, char **argv)\n{\n  int i;\n  int nincluded_files;\n  char **included_files;\n  argument *argbuffer;\n  int current_arg, file_count;\n  linebuffer filename_lb;\n  bool help_asked = false;\n  ptrdiff_t len;\n  char *optstring;\n  int opt;\n\n  progname = argv[0];\n  nincluded_files = 0;\n  included_files = xnew (argc, char *);\n  current_arg = 0;\n  file_count = 0;\n\n  /* Allocate enough no matter what happens.  Overkill, but each one\n     is small. */\n  argbuffer = xnew (argc, argument);\n\n  /*\n   * Always find typedefs and structure tags.\n   * Also default to find macro constants, enum constants, struct\n   * members and global variables.  Do it for both etags and ctags.\n   */\n  typedefs = typedefs_or_cplusplus = constantypedefs = true;\n  globals = members = true;\n\n  /* When the optstring begins with a '-' getopt_long does not rearrange the\n     non-options arguments to be at the end, but leaves them alone. */\n  optstring = concat (\"-ac:Cf:Il:o:Qr:RSVhH\",\n\t\t      (CTAGS) ? \"BxdtTuvw\" : \"Di:\",\n\t\t      \"\");\n\n  while ((opt = getopt_long (argc, argv, optstring, longopts, NULL)) != EOF)\n    switch (opt)\n      {\n      case 0:\n\t/* If getopt returns 0, then it has already processed a\n\t   long-named option.  We should do nothing.  */\n\tbreak;\n\n      case 1:\n\t/* This means that a file name has been seen.  Record it. */\n\targbuffer[current_arg].arg_type = at_filename;\n\targbuffer[current_arg].what     = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\t++file_count;\n\tbreak;\n\n      case STDIN:\n\t/* Parse standard input.  Idea by Vivek <vivek@etla.org>. */\n\targbuffer[current_arg].arg_type = at_stdin;\n\targbuffer[current_arg].what     = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\t++file_count;\n\tif (parsing_stdin)\n\t  fatal (\"cannot parse standard input more than once\");\n\tparsing_stdin = true;\n\tbreak;\n\n\t/* Common options. */\n      case 'a': append_to_tagfile = true;\tbreak;\n      case 'C': cplusplus = true;\t\tbreak;\n      case 'f':\t\t/* for compatibility with old makefiles */\n      case 'o':\n\tif (tagfile)\n\t  {\n\t    error (\"-o option may only be given once.\");\n\t    suggest_asking_for_help ();\n\t  }\n\ttagfile = optarg;\n\tbreak;\n      case 'I':\n      case 'S':\t\t/* for backward compatibility */\n\tignoreindent = true;\n\tbreak;\n      case 'l':\n\t{\n\t  language *lang = get_language_from_langname (optarg);\n\t  if (lang != NULL)\n\t    {\n\t      argbuffer[current_arg].lang = lang;\n\t      argbuffer[current_arg].arg_type = at_language;\n\t      ++current_arg;\n\t    }\n\t}\n\tbreak;\n      case 'c':\n\t/* Backward compatibility: support obsolete --ignore-case-regexp. */\n\toptarg = concat (optarg, \"i\", \"\"); /* memory leak here */\n\tFALLTHROUGH;\n      case 'r':\n\targbuffer[current_arg].arg_type = at_regexp;\n\targbuffer[current_arg].what = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\tbreak;\n      case 'R':\n\targbuffer[current_arg].arg_type = at_regexp;\n\targbuffer[current_arg].what = NULL;\n\t++current_arg;\n\tbreak;\n      case 'V':\n\tprint_version ();\n\tbreak;\n      case 'h':\n      case 'H':\n\thelp_asked = true;\n\tbreak;\n      case 'Q':\n\tclass_qualify = 1;\n\tbreak;\n\n\t/* Etags options */\n      case 'D': constantypedefs = false;\t\t\tbreak;\n      case 'i': included_files[nincluded_files++] = optarg;\tbreak;\n\n\t/* Ctags options. */\n      case 'B': searchar = '?';\t\t\t\t\tbreak;\n      case 'd': constantypedefs = true;\t\t\t\tbreak;\n      case 't': typedefs = true;\t\t\t\tbreak;\n      case 'T': typedefs = typedefs_or_cplusplus = true;\tbreak;\n      case 'u': update = true;\t\t\t\t\tbreak;\n      case 'v': vgrind_style = true;\t\t\t\tFALLTHROUGH;\n      case 'x': cxref_style = true;\t\t\t\tbreak;\n      case 'w': no_warnings = true;\t\t\t\tbreak;\n      default:\n\tsuggest_asking_for_help ();\n      }\n\n  /* No more options.  Store the rest of arguments. */\n  for (; optind < argc; optind++)\n    {\n      argbuffer[current_arg].arg_type = at_filename;\n      argbuffer[current_arg].what = argv[optind];\n      len = strlen (argv[optind]);\n      if (whatlen_max < len)\n\twhatlen_max = len;\n      ++current_arg;\n      ++file_count;\n    }\n\n  argbuffer[current_arg].arg_type = at_end;\n\n  if (help_asked)\n    print_help (argbuffer);\n\n  if (nincluded_files == 0 && file_count == 0)\n    {\n      error (\"no input files specified.\");\n      suggest_asking_for_help ();\n    }\n\n  if (tagfile == NULL)\n    tagfile = savestr (CTAGS ? \"tags\" : \"TAGS\");\n  cwd = etags_getcwd ();\t/* the current working directory */\n  if (cwd[strlen (cwd) - 1] != '/')\n    {\n      char *oldcwd = cwd;\n      cwd = concat (oldcwd, \"/\", \"\");\n      free (oldcwd);\n    }\n\n  /* Compute base directory for relative file names. */\n  if (streq (tagfile, \"-\")\n      || strneq (tagfile, \"/dev/\", 5))\n    tagfiledir = cwd;\t\t /* relative file names are relative to cwd */\n  else\n    {\n      canonicalize_filename (tagfile);\n      tagfiledir = absolute_dirname (tagfile, cwd);\n    }\n\n  linebuffer_init (&lb);\n  linebuffer_init (&filename_lb);\n  linebuffer_init (&filebuf);\n  linebuffer_init (&token_name);\n\n  if (!CTAGS)\n    {\n      if (streq (tagfile, \"-\"))\n\t{\n\t  tagf = stdout;\n\t  set_binary_mode (STDOUT_FILENO, O_BINARY);\n\t}\n      else\n\ttagf = fopen (tagfile, append_to_tagfile ? \"ab\" : \"wb\");\n      if (tagf == NULL)\n\tpfatal (tagfile);\n    }\n\n  /*\n   * Loop through files finding functions.\n   */\n  for (i = 0; i < current_arg; i++)\n    {\n      static language *lang;\t/* non-NULL if language is forced */\n      char *this_file;\n\n      switch (argbuffer[i].arg_type)\n\t{\n\tcase at_language:\n\t  lang = argbuffer[i].lang;\n\t  break;\n\tcase at_regexp:\n\t  analyze_regex (argbuffer[i].what);\n\t  break;\n\tcase at_filename:\n\t      this_file = argbuffer[i].what;\n\t      /* Input file named \"-\" means read file names from stdin\n\t\t (one per line) and use them. */\n\t      if (streq (this_file, \"-\"))\n\t\t{\n\t\t  if (parsing_stdin)\n\t\t    fatal (\"cannot parse standard input \"\n\t\t\t   \"AND read file names from it\");\n\t\t  while (readline_internal (&filename_lb, stdin, \"-\", false) > 0)\n\t\t    process_file_name (filename_lb.buffer, lang);\n\t\t}\n\t      else\n\t\tprocess_file_name (this_file, lang);\n\t  break;\n        case at_stdin:\n          this_file = argbuffer[i].what;\n          process_file (stdin, this_file, lang);\n          break;\n\tdefault:\n\t  error (\"internal error: arg_type\");\n\t}\n    }\n\n  free_regexps ();\n  free (lb.buffer);\n  free (filebuf.buffer);\n  free (token_name.buffer);\n\n  if (!CTAGS || cxref_style)\n    {\n      /* Write the remaining tags to tagf (ETAGS) or stdout (CXREF). */\n      put_entries (nodehead);\n      free_tree (nodehead);\n      nodehead = NULL;\n      if (!CTAGS)\n\t{\n\t  fdesc *fdp;\n\n\t  /* Output file entries that have no tags. */\n\t  for (fdp = fdhead; fdp != NULL; fdp = fdp->next)\n\t    if (!fdp->written)\n\t      fprintf (tagf, \"\\f\\n%s,0\\n\", fdp->taggedfname);\n\n\t  while (nincluded_files-- > 0)\n\t    fprintf (tagf, \"\\f\\n%s,include\\n\", *included_files++);\n\n\t  if (fclose (tagf) == EOF)\n\t    pfatal (tagfile);\n\t}\n\n      return EXIT_SUCCESS;\n    }\n\n  /* From here on, we are in (CTAGS && !cxref_style) */\n  if (update)\n    {\n      for (i = 0; i < current_arg; ++i)\n\t{\n\t  switch (argbuffer[i].arg_type)\n\t    {\n\t    case at_filename:\n\t    case at_stdin:\n\t      break;\n\t    default:\n\t      continue;\t\t/* the for loop */\n\t    }\n          clean_matched_file_tag (tagfile, argbuffer[i].what);\n\t}\n      append_to_tagfile = true;\n    }\n\n  tagf = fopen (tagfile, append_to_tagfile ? \"ab\" : \"wb\");\n  if (tagf == NULL)\n    pfatal (tagfile);\n  put_entries (nodehead);\t/* write all the tags (CTAGS) */\n  free_tree (nodehead);\n  nodehead = NULL;\n  if (fclose (tagf) == EOF)\n    pfatal (tagfile);\n\n  if (CTAGS)\n    if (append_to_tagfile || update)\n      {\n\t/* Maybe these should be used:\n\t   setenv (\"LC_COLLATE\", \"C\", 1);\n\t   setenv (\"LC_ALL\", \"C\", 1); */\n\tchar *cmd = xmalloc (8 * strlen (tagfile) + sizeof \"sort -u -o '' ''\");\n#if defined WINDOWSNT || defined MSDOS\n\t/* Quote \"like this\".  No need to escape the quotes in the file name,\n\t   since it is not allowed in file names on these systems.  */\n\tchar *z = stpcpy (cmd, \"sort -u -o \\\"\");\n\tz = stpcpy (z, tagfile);\n\tz = stpcpy (z, \"\\\" \\\"\");\n\tz = stpcpy (z, tagfile);\n\tstpcpy (z, \"\\\"\");\n#else\n\t/* Quote 'like this', and escape the apostrophe in the file name.  */\n\tchar *z = stpcpy (cmd, \"sort -u -o '\");\n\tchar *escaped_tagfile = z;\n\tfor (; *tagfile; *z++ = *tagfile++)\n\t  if (*tagfile == '\\'')\n\t    z = stpcpy (z, \"'\\\\'\");\n\tptrdiff_t escaped_tagfile_len = z - escaped_tagfile;\n\tz = stpcpy (z, \"' '\");\n\tz = mempcpy (z, escaped_tagfile, escaped_tagfile_len);\n\tstrcpy (z, \"'\");\n#endif\n\treturn system (cmd);\n      }\n  return EXIT_SUCCESS;\n}",
        "description": "GNU Emacs versions up to 28.2 are vulnerable to command execution through shell metacharacters in source-code file names. This vulnerability arises due to the use of the system C library function within the implementation of the ctags program in lib-src/etags.c. An attacker can exploit this by using commands like \"ctags *\" in a directory containing files whose names are influenced by untrusted input, leading to unintended command execution.",
        "commit": "The vulnerability knowledge describes the addition of new functions and files within the `lib-src/etags.c` and `test/manual/etags/` directories of a software project. Specifically, the `clean_matched_file_tag` and `do_move_file` functions have been introduced, along with modifications to the `readline_internal` function to include a `leave_cr` parameter that controls whether the `\\r` character should be included. Additionally, new test files (`CTAGS.good_crlf`, `CTAGS.good_update`, and `crlf`) have been added to the `test/manual/etags/` directory, and test cases for `ctags -u` have been incorporated into the `Makefile`."
    },
    {
        "cwe": "CWE-89",
        "func_name": "openlink/sqlo_add_table_ref",
        "score": 0.7536768913269043,
        "func_before": "void\nsqlo_add_table_ref (sqlo_t * so, ST ** tree_ret, dk_set_t *res)\n{\n  char tmp[10];\n  ST * tree = *tree_ret;\n  switch (tree->type)\n    {\n    case TABLE_REF:\n      {\n\tST * prev = tree->_.table_ref.table;\n\tif (ST_P (prev, SELECT_STMT))\n\t  {\n\t    tree->type = DERIVED_TABLE;\n\t    sqlp_view_def (NULL, tree->_.table_ref.table, 0);\n\t    sqlo_add_table_ref (so, tree_ret, res);\n\t    return;\n\t  }\n\tsqlo_add_table_ref (so, &tree->_.table_ref.table, res);\n\tif (prev != tree->_.table_ref.table)\n\t  *tree_ret = tree->_.table_ref.table;\n\tbreak;\n      }\n    case TABLE_DOTTED:\n      {\n\tST * with_view = sqlo_with_decl (so, tree);\n\tdbe_table_t *tb = with_view ? NULL : sch_name_to_table (wi_inst.wi_schema, tree->_.table.name);\n\tST * view;\n\tif (!tb && !with_view)\n\t  sqlc_error (so->so_sc->sc_cc, \"S0002\", \"No table %s\", tree->_.table.name);\n\tif (inside_view)\n\t  tree->_.table.name = t_box_copy (tb->tb_name);\n\tif (!with_view)\n\t  {\n\t    sqlc_table_used (so->so_sc, tb);\n\t    view = (ST*) sch_view_def (wi_inst.wi_schema, tb->tb_name);\n\t  }\n\telse\n\t  view = with_view;\n\tif (!view || inside_view)\n\t  {\n\t    remote_table_t * rt = find_remote_table (tb->tb_name, 0);\n\t    t_NEW_VARZ (op_table_t, ot);\n\t    ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts);\n\t    ot->ot_prefix = tree->_.table.prefix;\n\t    snprintf (tmp, sizeof (tmp), \"t%d\", so->so_name_ctr++);\n\t    ot->ot_new_prefix = t_box_string (tmp);\n\t    tree->_.table.prefix = ot->ot_new_prefix;\n\t    ot->ot_table = tb;\n\t    ot->ot_rds = rt ? rt->rt_rds : NULL;\n\t    ot->ot_u_id = (oid_t) unbox (tree->_.table.u_id);\n\t    ot->ot_g_id = (oid_t) unbox (tree->_.table.g_id);\n\t    if (ST_P (view, PROC_TABLE))\n\t      {\n\t\tot->ot_dt = view;\n\t\tsqlo_proc_table_cols (so, ot);\n\t\tot->ot_dt = NULL;\n\t\tot->ot_is_proc_view = 1;\n\t      }\n\t    sqlo_rls_add_condition (so, ot, res, tb);\n\t    t_set_push (&so->so_tables, (void*) ot);\n\t    sco_add_table (so->so_scope, ot);\n\t  }\n\telse\n\t  {\n\t    op_table_t * ot = NULL;\n\t    if (!with_view && !sec_tb_check (tb, (oid_t) unbox (tree->_.table.g_id), (oid_t) unbox (tree->_.table.u_id), GR_SELECT))\n\t      sqlc_new_error (so->so_sc->sc_cc, \"42000\", \"SQ070:SECURITY\", \"Must have select privileges on view %s\", tb->tb_name);\n\t    view = (ST*) t_box_copy_tree ((caddr_t) view);\n\t    if (ST_P (view, UNION_ST) ||\n\t\tST_P (view, UNION_ALL_ST) ||\n\t\tST_P (view, EXCEPT_ST) ||\n\t\tST_P (view, EXCEPT_ALL_ST) ||\n\t\tST_P (view, INTERSECT_ST) ||\n\t\tST_P (view, INTERSECT_ALL_ST))\n\t      {\n\t\tview = sqlp_view_def (NULL, view, 1);\n\t\tview = sqlc_union_dt_wrap (view);\n\t      }\n\t    sqlo_scope (so, &view);\n\t    if (ST_P (view, SELECT_STMT))\n\t      {\n\t\tot = (op_table_t *) so->so_tables->data;\n\t\tot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name;\n\t\tsco_add_table (so->so_scope, ot);\n\t      }\n\t    else\n\t      {\n\t\tt_NEW_VARZ (op_table_t, ot2);\n\t\tmemset (ot2, 0, sizeof (op_table_t));\n\t\tot = ot2;\n\t\tot->ot_dt = view;\n\t\tot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name;\n\t\tot->ot_new_prefix = sqlo_new_prefix (so);\n\t\tot->ot_left_sel = sqlp_union_tree_select (view);\n\t\tif (ST_P (view, PROC_TABLE))\n\t\t  {\n\t\t    sqlo_proc_table_cols (so, ot);\n\t\t    ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts);\n\t\t    ot->ot_is_proc_view = 1;\n\t\t  }\n\t\tsco_add_table (so->so_scope, ot);\n\t\tt_set_push (&so->so_tables, (void*) ot);\n\n\t      }\n\t    sqlo_rls_add_condition (so, ot, res, tb);\n\t    *tree_ret = (ST*) t_list (3, DERIVED_TABLE, ot->ot_dt, ot->ot_new_prefix);\n\t  }\n\tbreak;\n      }\n    case JOINED_TABLE:\n      {\n\tsql_scope_t *old_sco = so->so_scope;\n\tTNEW (sql_scope_t, sco);\n\top_table_t *right_ot, *left_ot;\n\ts_node_t *ptr;\n\tST *j_right;\n\tdk_set_t res_jt = NULL;\n\tint is_jtc, is_natural = (tree->_.join.is_natural &&\n\t    (!tree->_.join.cond || tree->_.join.cond == (ST *) STAR));\n\n\n\tmemset (sco, 0, sizeof (sql_scope_t));\n\tsco->sco_so = so;\n\tsco->sco_fun_refs_allowed = old_sco->sco_fun_refs_allowed;\n\tsco->sco_super = so->so_scope->sco_super;\n\tso->so_scope = sco;\n\n\tif (OJ_RIGHT == tree->_.join.type)\n\t  {\n\t    ST * tmp = tree->_.join.left;\n\t    tree->_.join.left = tree->_.join.right;\n\t    tree->_.join.right = tmp;\n\t    tree->_.join.type = OJ_LEFT;\n\t  }\n\tj_right = tree->_.join.left;\n\twhile (ST_P (j_right, TABLE_REF))\n\t  j_right = j_right->_.table_ref.table;\n\tis_jtc = ST_P (j_right, JOINED_TABLE);\n\tif (tree->_.join.type == OJ_FULL)\n\t  sco->sco_has_jt = 1;\n\tif (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)))\n\t  sco->sco_has_jt = 1;\n\tj_right = tree->_.join.right;\n\twhile (ST_P (j_right, TABLE_REF))\n\t  j_right = j_right->_.table_ref.table;\n\tis_jtc = ST_P (j_right, JOINED_TABLE);\n\tif (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)))\n\t  sco->sco_has_jt = 1;\n\tsqlo_add_table_ref (so, &tree->_.join.left, res);\n\tleft_ot = (op_table_t *) so->so_tables->data;\n\tsqlo_add_table_ref (so, &tree->_.join.right, is_jtc ? &res_jt : res);\n\tright_ot = (op_table_t *) so->so_tables->data;\n\tsqlo_natural_join_cond (so, left_ot, right_ot, tree);\n\tsqlo_scope (so, &(tree->_.join.cond));\n\t/* can be that the right subtree in a ij ends with oj in which case the right ot will be flagged outer. The cond in this case goes to to the top where, i.e. res, not to the join cond of the outer (optional) ot */\nif (J_INNER == tree->_.join.type && right_ot->ot_is_outer)\n  \t  t_st_and (&right_ot->ot_enclosing_where_cond, tree->_.join.cond); /*always ste, even if some joins may be made into dts later*/\n\n\telse\n\t  t_st_and (&right_ot->ot_join_cond, tree->_.join.cond); /*always ste, even if some joins may be made into dts later*/\n\tsco_merge (old_sco, sco);\n\tso->so_scope = old_sco;\n\tif (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)\n\t  right_ot->ot_is_outer = 1;\n\telse if (!sco->sco_has_jt && tree->_.join.type == J_INNER &&\n\t    !ST_P (left_ot->ot_dt, PROC_TABLE) &&\n\t    !ST_P (right_ot->ot_dt, PROC_TABLE))\n\t  {\n\t    t_set_push (res, tree);\n\t    break;\n\t  }\n\tbreak;\n      }\n    case DERIVED_TABLE:\n      {\n\top_table_t * ot;\n\tsqlo_scope (so, &(tree->_.table_ref.table));\n\tif (ST_P (tree->_.table_ref.table, SELECT_STMT))\n\t  {\n\t    ot = (op_table_t *) so->so_tables->data;\n\t    ot->ot_prefix = tree->_.table_ref.range;\n\t    tree->_.table_ref.range = ot->ot_new_prefix;\n/*\t    t_set_push (res, (void *) ot);*/\n\t    sco_add_table (so->so_scope, ot);\n\t    if (ot->ot_trans)\n\t      sqlo_trans_cols (so, ot);\n\t  }\n\telse\n\t  {\n\t    op_table_t *old_ot = so->so_tables ? (op_table_t *) so->so_tables->data : NULL;\n\t    t_NEW_VARZ (op_table_t, ot);\n\t    ot->ot_prefix = tree->_.table_ref.range;\n\t    ot->ot_dt = tree->_.table_ref.table;\n\t    ot->ot_new_prefix = sqlo_new_prefix (so);\n\t    tree->_.table_ref.range = ot->ot_new_prefix;\n\t    if (old_ot)\n\t      ot->ot_left_sel = old_ot->ot_left_sel;\n\t    else\n\t      ot->ot_left_sel = sqlp_union_tree_select (tree->_.table_ref.table);\n\t    if (ST_P (tree->_.table_ref.table, PROC_TABLE))\n\t      sqlo_proc_table_cols (so, ot);\n/*\t    t_set_push (res, (void *) ot);*/\n\t    sco_add_table (so->so_scope, ot);\n\t    t_set_push (&so->so_tables, (void*) ot);\n\t  }\n\tbreak;\n      }\n    }\n}",
        "func_after": "void\nsqlo_add_table_ref (sqlo_t * so, ST ** tree_ret, dk_set_t *res)\n{\n  char tmp[10];\n  ST * tree = *tree_ret;\n  switch (tree->type)\n    {\n    case TABLE_REF:\n      {\n\tST * prev = tree->_.table_ref.table;\n\tif (ST_P (prev, SELECT_STMT))\n\t  {\n\t    tree->type = DERIVED_TABLE;\n\t    sqlp_view_def (NULL, tree->_.table_ref.table, 0);\n\t    sqlo_add_table_ref (so, tree_ret, res);\n\t    return;\n\t  }\n\tsqlo_add_table_ref (so, &tree->_.table_ref.table, res);\n\tif (prev != tree->_.table_ref.table)\n\t  *tree_ret = tree->_.table_ref.table;\n\tbreak;\n      }\n    case TABLE_DOTTED:\n      {\n\tST * with_view = sqlo_with_decl (so, tree);\n\tdbe_table_t *tb = with_view ? NULL : sch_name_to_table (wi_inst.wi_schema, tree->_.table.name);\n\tST * view;\n\tif (!tb && !with_view)\n\t  sqlc_error (so->so_sc->sc_cc, \"S0002\", \"No table %s\", tree->_.table.name);\n\tif (inside_view)\n\t  tree->_.table.name = t_box_copy (tb->tb_name);\n\tif (!with_view)\n\t  {\n\t    sqlc_table_used (so->so_sc, tb);\n\t    view = (ST*) sch_view_def (wi_inst.wi_schema, tb->tb_name);\n\t  }\n\telse\n\t  view = with_view;\n\tif (!view || inside_view)\n\t  {\n\t    remote_table_t * rt = find_remote_table (tb->tb_name, 0);\n\t    t_NEW_VARZ (op_table_t, ot);\n\t    ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts);\n\t    ot->ot_prefix = tree->_.table.prefix;\n\t    snprintf (tmp, sizeof (tmp), \"t%d\", so->so_name_ctr++);\n\t    ot->ot_new_prefix = t_box_string (tmp);\n\t    tree->_.table.prefix = ot->ot_new_prefix;\n\t    ot->ot_table = tb;\n\t    ot->ot_rds = rt ? rt->rt_rds : NULL;\n\t    ot->ot_u_id = (oid_t) unbox (tree->_.table.u_id);\n\t    ot->ot_g_id = (oid_t) unbox (tree->_.table.g_id);\n\t    if (ST_P (view, PROC_TABLE))\n\t      {\n\t\tot->ot_dt = view;\n\t\tsqlo_proc_table_cols (so, ot);\n\t\tot->ot_dt = NULL;\n\t\tot->ot_is_proc_view = 1;\n\t      }\n\t    sqlo_rls_add_condition (so, ot, res, tb);\n\t    t_set_push (&so->so_tables, (void*) ot);\n\t    sco_add_table (so->so_scope, ot);\n\t  }\n\telse\n\t  {\n\t    op_table_t * ot = NULL;\n\t    if (!with_view && !sec_tb_check (tb, (oid_t) unbox (tree->_.table.g_id), (oid_t) unbox (tree->_.table.u_id), GR_SELECT))\n\t      sqlc_new_error (so->so_sc->sc_cc, \"42000\", \"SQ070:SECURITY\", \"Must have select privileges on view %s\", tb->tb_name);\n\t    view = (ST*) t_box_copy_tree ((caddr_t) view);\n\t    if (ST_P (view, UNION_ST) ||\n\t\tST_P (view, UNION_ALL_ST) ||\n\t\tST_P (view, EXCEPT_ST) ||\n\t\tST_P (view, EXCEPT_ALL_ST) ||\n\t\tST_P (view, INTERSECT_ST) ||\n\t\tST_P (view, INTERSECT_ALL_ST))\n\t      {\n\t\tview = sqlp_view_def (NULL, view, 1);\n\t\tview = sqlc_union_dt_wrap (so->so_sc, view);\n\t      }\n\t    sqlo_scope (so, &view);\n\t    if (ST_P (view, SELECT_STMT))\n\t      {\n\t\tot = (op_table_t *) so->so_tables->data;\n\t\tot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name;\n\t\tsco_add_table (so->so_scope, ot);\n\t      }\n\t    else\n\t      {\n\t\tt_NEW_VARZ (op_table_t, ot2);\n\t\tmemset (ot2, 0, sizeof (op_table_t));\n\t\tot = ot2;\n\t\tot->ot_dt = view;\n\t\tot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name;\n\t\tot->ot_new_prefix = sqlo_new_prefix (so);\n\t\tot->ot_left_sel = sqlp_union_tree_select (view);\n\t\tif (ST_P (view, PROC_TABLE))\n\t\t  {\n\t\t    sqlo_proc_table_cols (so, ot);\n\t\t    ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts);\n\t\t    ot->ot_is_proc_view = 1;\n\t\t  }\n\t\tsco_add_table (so->so_scope, ot);\n\t\tt_set_push (&so->so_tables, (void*) ot);\n\n\t      }\n\t    sqlo_rls_add_condition (so, ot, res, tb);\n\t    *tree_ret = (ST*) t_list (3, DERIVED_TABLE, ot->ot_dt, ot->ot_new_prefix);\n\t  }\n\tbreak;\n      }\n    case JOINED_TABLE:\n      {\n\tsql_scope_t *old_sco = so->so_scope;\n\tTNEW (sql_scope_t, sco);\n\top_table_t *right_ot, *left_ot;\n\ts_node_t *ptr;\n\tST *j_right;\n\tdk_set_t res_jt = NULL;\n\tint is_jtc, is_natural = (tree->_.join.is_natural &&\n\t    (!tree->_.join.cond || tree->_.join.cond == (ST *) STAR));\n\n\n\tmemset (sco, 0, sizeof (sql_scope_t));\n\tsco->sco_so = so;\n\tsco->sco_fun_refs_allowed = old_sco->sco_fun_refs_allowed;\n\tsco->sco_super = so->so_scope->sco_super;\n\tso->so_scope = sco;\n\n\tif (OJ_RIGHT == tree->_.join.type)\n\t  {\n\t    ST * tmp = tree->_.join.left;\n\t    tree->_.join.left = tree->_.join.right;\n\t    tree->_.join.right = tmp;\n\t    tree->_.join.type = OJ_LEFT;\n\t  }\n\tj_right = tree->_.join.left;\n\twhile (ST_P (j_right, TABLE_REF))\n\t  j_right = j_right->_.table_ref.table;\n\tis_jtc = ST_P (j_right, JOINED_TABLE);\n\tif (tree->_.join.type == OJ_FULL)\n\t  sco->sco_has_jt = 1;\n\tif (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)))\n\t  sco->sco_has_jt = 1;\n\tj_right = tree->_.join.right;\n\twhile (ST_P (j_right, TABLE_REF))\n\t  j_right = j_right->_.table_ref.table;\n\tis_jtc = ST_P (j_right, JOINED_TABLE);\n\tif (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)))\n\t  sco->sco_has_jt = 1;\n\tsqlo_add_table_ref (so, &tree->_.join.left, res);\n\tleft_ot = (op_table_t *) so->so_tables->data;\n\tsqlo_add_table_ref (so, &tree->_.join.right, is_jtc ? &res_jt : res);\n\tright_ot = (op_table_t *) so->so_tables->data;\n\tsqlo_natural_join_cond (so, left_ot, right_ot, tree);\n\tsqlo_scope (so, &(tree->_.join.cond));\n\t/* can be that the right subtree in a ij ends with oj in which case the right ot will be flagged outer. The cond in this case goes to to the top where, i.e. res, not to the join cond of the outer (optional) ot */\nif (J_INNER == tree->_.join.type && right_ot->ot_is_outer)\n  \t  t_st_and (&right_ot->ot_enclosing_where_cond, tree->_.join.cond); /*always ste, even if some joins may be made into dts later*/\n\n\telse\n\t  t_st_and (&right_ot->ot_join_cond, tree->_.join.cond); /*always ste, even if some joins may be made into dts later*/\n\tsco_merge (old_sco, sco);\n\tso->so_scope = old_sco;\n\tif (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)\n\t  right_ot->ot_is_outer = 1;\n\telse if (!sco->sco_has_jt && tree->_.join.type == J_INNER &&\n\t    !ST_P (left_ot->ot_dt, PROC_TABLE) &&\n\t    !ST_P (right_ot->ot_dt, PROC_TABLE))\n\t  {\n\t    t_set_push (res, tree);\n\t    break;\n\t  }\n\tbreak;\n      }\n    case DERIVED_TABLE:\n      {\n\top_table_t * ot;\n\tsqlo_scope (so, &(tree->_.table_ref.table));\n\tif (ST_P (tree->_.table_ref.table, SELECT_STMT))\n\t  {\n\t    ot = (op_table_t *) so->so_tables->data;\n\t    ot->ot_prefix = tree->_.table_ref.range;\n\t    tree->_.table_ref.range = ot->ot_new_prefix;\n/*\t    t_set_push (res, (void *) ot);*/\n\t    sco_add_table (so->so_scope, ot);\n\t    if (ot->ot_trans)\n\t      sqlo_trans_cols (so, ot);\n\t  }\n\telse\n\t  {\n\t    op_table_t *old_ot = so->so_tables ? (op_table_t *) so->so_tables->data : NULL;\n\t    t_NEW_VARZ (op_table_t, ot);\n\t    ot->ot_prefix = tree->_.table_ref.range;\n\t    ot->ot_dt = tree->_.table_ref.table;\n\t    ot->ot_new_prefix = sqlo_new_prefix (so);\n\t    tree->_.table_ref.range = ot->ot_new_prefix;\n\t    if (old_ot)\n\t      ot->ot_left_sel = old_ot->ot_left_sel;\n\t    else\n\t      ot->ot_left_sel = sqlp_union_tree_select (tree->_.table_ref.table);\n\t    if (ST_P (tree->_.table_ref.table, PROC_TABLE))\n\t      sqlo_proc_table_cols (so, ot);\n/*\t    t_set_push (res, (void *) ot);*/\n\t    sco_add_table (so->so_scope, ot);\n\t    t_set_push (&so->so_tables, (void*) ot);\n\t  }\n\tbreak;\n      }\n    }\n}",
        "description": "An issue in the sqlc_union_dt_wrap component of OpenLink Virtuoso Open Source allows attackers to trigger a Denial of Service (DoS) condition through the use of specially crafted SQL statements.",
        "commit": "The support for fixed non-terminals in union branches is not implemented, which may lead to issues or unexpected behavior in certain scenarios."
    },
    {
        "cwe": "CWE-77",
        "func_name": "ImageMagick/ReadVIDEOImage",
        "score": 0.7450671195983887,
        "func_before": "static Image *ReadVIDEOImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const DelegateInfo\n    *delegate_info;\n\n  Image\n    *image,\n    *images,\n    *next;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CloseBlob(image);\n  (void) DestroyImageList(image);\n  /*\n    Convert VIDEO to PAM with delegate.\n  */\n  images=(Image *) NULL;\n  read_info=CloneImageInfo(image_info);\n  delegate_info=GetDelegateInfo(\"video:decode\",(char *) NULL,exception);\n  if (delegate_info != (const DelegateInfo *) NULL)\n    {\n      char\n        command[MagickPathExtent],\n        message[MagickPathExtent];\n\n      char\n        *options,\n        *sanitized_option;\n\n      const char\n        *intermediate_format,\n        *option;\n\n      int\n        exit_code;\n\n      options=AcquireString(\"\");\n      if (image_info->number_scenes > 0)\n        (void) FormatLocaleString(options,MagickPathExtent,\"-vframes %i\",\n          (int) image_info->number_scenes);\n      option=GetImageOption(image_info,\"video:vsync\");\n      if (option != (const char *) NULL)\n        {\n          sanitized_option=SanitizeDelegateString(option);\n          (void) FormatLocaleString(command,MagickPathExtent,\" -vsync %s\",\n            sanitized_option);\n          DestroyString(sanitized_option);\n          (void) ConcatenateMagickString(options,command,MagickPathExtent);\n        }\n      option=GetImageOption(image_info,\"video:pixel-format\");\n      if (option != (const char *) NULL)\n        {\n          sanitized_option=SanitizeDelegateString(option);\n          (void) FormatLocaleString(command,MagickPathExtent,\" -pix_fmt %s\",\n            sanitized_option);\n          DestroyString(sanitized_option);\n          (void) ConcatenateMagickString(options,command,MagickPathExtent);\n        }\n      else\n        if (LocaleNCompare(image_info->magick,\"APNG\",MagickPathExtent) == 0)\n          (void) ConcatenateMagickString(options,\" -pix_fmt rgba\",\n            MagickPathExtent);\n      intermediate_format=GetIntermediateFormat(image_info);\n      (void) FormatLocaleString(command,MagickPathExtent,\" -vcodec %s\",\n        intermediate_format);\n      (void) ConcatenateMagickString(options,command,MagickPathExtent);\n      AcquireUniqueFilename(read_info->unique);\n      (void) AcquireUniqueSymbolicLink(image_info->filename,\n        read_info->filename);\n      (void) FormatLocaleString(command,MagickPathExtent,\n        GetDelegateCommands(delegate_info),read_info->filename,options,\n        read_info->unique);\n      options=DestroyString(options);\n      (void) CopyMagickString(read_info->magick,intermediate_format,\n        MagickPathExtent);\n      (void) CopyMagickString(read_info->filename,read_info->unique,\n        MagickPathExtent);\n      exit_code=ExternalDelegateCommand(MagickFalse,image_info->verbose,\n        command,message,exception);\n      if (exit_code == 0)\n        images=ReadImage(read_info,exception);\n      else\n        if (*message != '\\0')\n          (void) ThrowMagickException(exception,GetMagickModule(),DelegateError,\n            \"VideoDelegateFailed\",\"`%s'\",message);\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      (void) RelinquishUniqueFileResource(read_info->unique);\n      if (images != (Image *) NULL)\n        for (next=images; next != (Image *) NULL; next=next->next)\n        {\n          (void) CopyMagickString(next->filename,image_info->filename,\n            MagickPathExtent);\n          (void) CopyMagickString(next->magick,image_info->magick,\n            MagickPathExtent);\n        }\n    }\n  read_info=DestroyImageInfo(read_info);\n  return(images);\n}",
        "func_after": "static Image *ReadVIDEOImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const DelegateInfo\n    *delegate_info;\n\n  Image\n    *image,\n    *images,\n    *next;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CloseBlob(image);\n  (void) DestroyImageList(image);\n  /*\n    Convert VIDEO to PAM with delegate.\n  */\n  images=(Image *) NULL;\n  read_info=CloneImageInfo(image_info);\n  delegate_info=GetDelegateInfo(\"video:decode\",(char *) NULL,exception);\n  if (delegate_info != (const DelegateInfo *) NULL)\n    {\n      char\n        command[MagickPathExtent],\n        message[MagickPathExtent];\n\n      char\n        *options;\n\n      const char\n        *intermediate_format,\n        *option;\n\n      int\n        exit_code;\n\n      options=AcquireString(\"\");\n      if (image_info->number_scenes > 0)\n        (void) FormatLocaleString(options,MagickPathExtent,\"-vframes %i\",\n          (int) image_info->number_scenes);\n      option=GetImageOption(image_info,\"video:vsync\");\n      if (option != (const char *) NULL)\n        {\n          FormatSanitizedDelegateOption(command,MagickPathExtent,\n            \" -vsync \\\"%s\\\"\",\" -vsync '%s'\",option);\n          (void) ConcatenateMagickString(options,command,MagickPathExtent);\n        }\n      option=GetImageOption(image_info,\"video:pixel-format\");\n      if (option != (const char *) NULL)\n        {\n          FormatSanitizedDelegateOption(command,MagickPathExtent,\n            \" -pix_fmt \\\"%s\\\"\",\" -pix_fmt '%s'\",option);\n          (void) ConcatenateMagickString(options,command,MagickPathExtent);\n        }\n      else\n        if (LocaleNCompare(image_info->magick,\"APNG\",MagickPathExtent) == 0)\n          (void) ConcatenateMagickString(options,\" -pix_fmt rgba\",\n            MagickPathExtent);\n      intermediate_format=GetIntermediateFormat(image_info);\n      (void) FormatLocaleString(command,MagickPathExtent,\" -vcodec %s\",\n        intermediate_format);\n      (void) ConcatenateMagickString(options,command,MagickPathExtent);\n      AcquireUniqueFilename(read_info->unique);\n      (void) AcquireUniqueSymbolicLink(image_info->filename,\n        read_info->filename);\n      (void) FormatLocaleString(command,MagickPathExtent,\n        GetDelegateCommands(delegate_info),read_info->filename,options,\n        read_info->unique);\n      options=DestroyString(options);\n      (void) CopyMagickString(read_info->magick,intermediate_format,\n        MagickPathExtent);\n      (void) CopyMagickString(read_info->filename,read_info->unique,\n        MagickPathExtent);\n      exit_code=ExternalDelegateCommand(MagickFalse,image_info->verbose,\n        command,message,exception);\n      if (exit_code == 0)\n        images=ReadImage(read_info,exception);\n      else\n        if (*message != '\\0')\n          (void) ThrowMagickException(exception,GetMagickModule(),DelegateError,\n            \"VideoDelegateFailed\",\"`%s'\",message);\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      (void) RelinquishUniqueFileResource(read_info->unique);\n      if (images != (Image *) NULL)\n        for (next=images; next != (Image *) NULL; next=next->next)\n        {\n          (void) CopyMagickString(next->filename,image_info->filename,\n            MagickPathExtent);\n          (void) CopyMagickString(next->magick,image_info->magick,\n            MagickPathExtent);\n        }\n    }\n  read_info=DestroyImageInfo(read_info);\n  return(images);\n}",
        "description": "A vulnerability was identified in ImageMagick that leads to a shell command injection through the use of specific options in video encoding/decoding processes.",
        "commit": "Ensure that options are correctly quoted to address the issue identified in ticket #6338."
    }
]