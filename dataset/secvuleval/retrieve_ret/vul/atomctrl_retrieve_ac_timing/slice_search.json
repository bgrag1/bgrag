[
    {
        "cwe": "CWE-682",
        "func_name": "torvalds/sctp_make_init",
        "score": 0.7877271175384521,
        "func_before": "struct sctp_chunk *sctp_make_init(const struct sctp_association *asoc,\n\t\t\t     const struct sctp_bind_addr *bp,\n\t\t\t     gfp_t gfp, int vparam_len)\n{\n\tsctp_inithdr_t init;\n\tunion sctp_params addrs;\n\tsize_t chunksize;\n\tstruct sctp_chunk *retval = NULL;\n\tint num_types, addrs_len = 0;\n\tstruct sctp_sock *sp;\n\tsctp_supported_addrs_param_t sat;\n\t__be16 types[2];\n\tsctp_adaptation_ind_param_t aiparam;\n\tsctp_supported_ext_param_t ext_param;\n\tint num_ext = 0;\n\t__u8 extensions[3];\n\tsctp_paramhdr_t *auth_chunks = NULL,\n\t\t\t*auth_hmacs = NULL;\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 1: The INIT chunks can contain multiple addresses that\n\t * can be IPv4 and/or IPv6 in any combination.\n\t */\n\tretval = NULL;\n\n\t/* Convert the provided bind address list to raw format. */\n\taddrs = sctp_bind_addrs_to_raw(bp, &addrs_len, gfp);\n\n\tinit.init_tag\t\t   = htonl(asoc->c.my_vtag);\n\tinit.a_rwnd\t\t   = htonl(asoc->rwnd);\n\tinit.num_outbound_streams  = htons(asoc->c.sinit_num_ostreams);\n\tinit.num_inbound_streams   = htons(asoc->c.sinit_max_instreams);\n\tinit.initial_tsn\t   = htonl(asoc->c.initial_tsn);\n\n\t/* How many address types are needed? */\n\tsp = sctp_sk(asoc->base.sk);\n\tnum_types = sp->pf->supported_addrs(sp, types);\n\n\tchunksize = sizeof(init) + addrs_len + SCTP_SAT_LEN(num_types);\n\tchunksize += sizeof(ecap_param);\n\n\tif (sctp_prsctp_enable)\n\t\tchunksize += sizeof(prsctp_param);\n\n\t/* ADDIP: Section 4.2.7:\n\t *  An implementation supporting this extension [ADDIP] MUST list\n\t *  the ASCONF,the ASCONF-ACK, and the AUTH  chunks in its INIT and\n\t *  INIT-ACK parameters.\n\t */\n\tif (sctp_addip_enable) {\n\t\textensions[num_ext] = SCTP_CID_ASCONF;\n\t\textensions[num_ext+1] = SCTP_CID_ASCONF_ACK;\n\t\tnum_ext += 2;\n\t}\n\n\tif (sp->adaptation_ind)\n\t\tchunksize += sizeof(aiparam);\n\n\tchunksize += vparam_len;\n\n\t/* Account for AUTH related parameters */\n\tif (sctp_auth_enable) {\n\t\t/* Add random parameter length*/\n\t\tchunksize += sizeof(asoc->c.auth_random);\n\n\t\t/* Add HMACS parameter length if any were defined */\n\t\tauth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;\n\t\tif (auth_hmacs->length)\n\t\t\tchunksize += ntohs(auth_hmacs->length);\n\t\telse\n\t\t\tauth_hmacs = NULL;\n\n\t\t/* Add CHUNKS parameter length */\n\t\tauth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;\n\t\tif (auth_chunks->length)\n\t\t\tchunksize += ntohs(auth_chunks->length);\n\t\telse\n\t\t\tauth_chunks = NULL;\n\n\t\textensions[num_ext] = SCTP_CID_AUTH;\n\t\tnum_ext += 1;\n\t}\n\n\t/* If we have any extensions to report, account for that */\n\tif (num_ext)\n\t\tchunksize += sizeof(sctp_supported_ext_param_t) + num_ext;\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 3: An INIT chunk MUST NOT contain more than one Host\n\t * Name address parameter. Moreover, the sender of the INIT\n\t * MUST NOT combine any other address types with the Host Name\n\t * address in the INIT. The receiver of INIT MUST ignore any\n\t * other address types if the Host Name address parameter is\n\t * present in the received INIT chunk.\n\t *\n\t * PLEASE DO NOT FIXME [This version does not support Host Name.]\n\t */\n\n\tretval = sctp_make_chunk(asoc, SCTP_CID_INIT, 0, chunksize);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.init_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(init), &init);\n\tretval->param_hdr.v =\n\t\tsctp_addto_chunk(retval, addrs_len, addrs.v);\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 4: This parameter, when present, specifies all the\n\t * address types the sending endpoint can support. The absence\n\t * of this parameter indicates that the sending endpoint can\n\t * support any address type.\n\t */\n\tsat.param_hdr.type = SCTP_PARAM_SUPPORTED_ADDRESS_TYPES;\n\tsat.param_hdr.length = htons(SCTP_SAT_LEN(num_types));\n\tsctp_addto_chunk(retval, sizeof(sat), &sat);\n\tsctp_addto_chunk(retval, num_types * sizeof(__u16), &types);\n\n\tsctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);\n\n\t/* Add the supported extensions parameter.  Be nice and add this\n\t * fist before addiding the parameters for the extensions themselves\n\t */\n\tif (num_ext) {\n\t\text_param.param_hdr.type = SCTP_PARAM_SUPPORTED_EXT;\n\t\text_param.param_hdr.length =\n\t\t\t    htons(sizeof(sctp_supported_ext_param_t) + num_ext);\n\t\tsctp_addto_chunk(retval, sizeof(sctp_supported_ext_param_t),\n\t\t\t\t&ext_param);\n\t\tsctp_addto_param(retval, num_ext, extensions);\n\t}\n\n\tif (sctp_prsctp_enable)\n\t\tsctp_addto_chunk(retval, sizeof(prsctp_param), &prsctp_param);\n\n\tif (sp->adaptation_ind) {\n\t\taiparam.param_hdr.type = SCTP_PARAM_ADAPTATION_LAYER_IND;\n\t\taiparam.param_hdr.length = htons(sizeof(aiparam));\n\t\taiparam.adaptation_ind = htonl(sp->adaptation_ind);\n\t\tsctp_addto_chunk(retval, sizeof(aiparam), &aiparam);\n\t}\n\n\t/* Add SCTP-AUTH chunks to the parameter list */\n\tif (sctp_auth_enable) {\n\t\tsctp_addto_chunk(retval, sizeof(asoc->c.auth_random),\n\t\t\t\t asoc->c.auth_random);\n\t\tif (auth_hmacs)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_hmacs->length),\n\t\t\t\t\tauth_hmacs);\n\t\tif (auth_chunks)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_chunks->length),\n\t\t\t\t\tauth_chunks);\n\t}\nnodata:\n\tkfree(addrs.v);\n\treturn retval;\n}",
        "func_after": "struct sctp_chunk *sctp_make_init(const struct sctp_association *asoc,\n\t\t\t     const struct sctp_bind_addr *bp,\n\t\t\t     gfp_t gfp, int vparam_len)\n{\n\tsctp_inithdr_t init;\n\tunion sctp_params addrs;\n\tsize_t chunksize;\n\tstruct sctp_chunk *retval = NULL;\n\tint num_types, addrs_len = 0;\n\tstruct sctp_sock *sp;\n\tsctp_supported_addrs_param_t sat;\n\t__be16 types[2];\n\tsctp_adaptation_ind_param_t aiparam;\n\tsctp_supported_ext_param_t ext_param;\n\tint num_ext = 0;\n\t__u8 extensions[3];\n\tsctp_paramhdr_t *auth_chunks = NULL,\n\t\t\t*auth_hmacs = NULL;\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 1: The INIT chunks can contain multiple addresses that\n\t * can be IPv4 and/or IPv6 in any combination.\n\t */\n\tretval = NULL;\n\n\t/* Convert the provided bind address list to raw format. */\n\taddrs = sctp_bind_addrs_to_raw(bp, &addrs_len, gfp);\n\n\tinit.init_tag\t\t   = htonl(asoc->c.my_vtag);\n\tinit.a_rwnd\t\t   = htonl(asoc->rwnd);\n\tinit.num_outbound_streams  = htons(asoc->c.sinit_num_ostreams);\n\tinit.num_inbound_streams   = htons(asoc->c.sinit_max_instreams);\n\tinit.initial_tsn\t   = htonl(asoc->c.initial_tsn);\n\n\t/* How many address types are needed? */\n\tsp = sctp_sk(asoc->base.sk);\n\tnum_types = sp->pf->supported_addrs(sp, types);\n\n\tchunksize = sizeof(init) + addrs_len;\n\tchunksize += WORD_ROUND(SCTP_SAT_LEN(num_types));\n\tchunksize += sizeof(ecap_param);\n\n\tif (sctp_prsctp_enable)\n\t\tchunksize += sizeof(prsctp_param);\n\n\t/* ADDIP: Section 4.2.7:\n\t *  An implementation supporting this extension [ADDIP] MUST list\n\t *  the ASCONF,the ASCONF-ACK, and the AUTH  chunks in its INIT and\n\t *  INIT-ACK parameters.\n\t */\n\tif (sctp_addip_enable) {\n\t\textensions[num_ext] = SCTP_CID_ASCONF;\n\t\textensions[num_ext+1] = SCTP_CID_ASCONF_ACK;\n\t\tnum_ext += 2;\n\t}\n\n\tif (sp->adaptation_ind)\n\t\tchunksize += sizeof(aiparam);\n\n\tchunksize += vparam_len;\n\n\t/* Account for AUTH related parameters */\n\tif (sctp_auth_enable) {\n\t\t/* Add random parameter length*/\n\t\tchunksize += sizeof(asoc->c.auth_random);\n\n\t\t/* Add HMACS parameter length if any were defined */\n\t\tauth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;\n\t\tif (auth_hmacs->length)\n\t\t\tchunksize += WORD_ROUND(ntohs(auth_hmacs->length));\n\t\telse\n\t\t\tauth_hmacs = NULL;\n\n\t\t/* Add CHUNKS parameter length */\n\t\tauth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;\n\t\tif (auth_chunks->length)\n\t\t\tchunksize += WORD_ROUND(ntohs(auth_chunks->length));\n\t\telse\n\t\t\tauth_chunks = NULL;\n\n\t\textensions[num_ext] = SCTP_CID_AUTH;\n\t\tnum_ext += 1;\n\t}\n\n\t/* If we have any extensions to report, account for that */\n\tif (num_ext)\n\t\tchunksize += WORD_ROUND(sizeof(sctp_supported_ext_param_t) +\n\t\t\t\t\tnum_ext);\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 3: An INIT chunk MUST NOT contain more than one Host\n\t * Name address parameter. Moreover, the sender of the INIT\n\t * MUST NOT combine any other address types with the Host Name\n\t * address in the INIT. The receiver of INIT MUST ignore any\n\t * other address types if the Host Name address parameter is\n\t * present in the received INIT chunk.\n\t *\n\t * PLEASE DO NOT FIXME [This version does not support Host Name.]\n\t */\n\n\tretval = sctp_make_chunk(asoc, SCTP_CID_INIT, 0, chunksize);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.init_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(init), &init);\n\tretval->param_hdr.v =\n\t\tsctp_addto_chunk(retval, addrs_len, addrs.v);\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 4: This parameter, when present, specifies all the\n\t * address types the sending endpoint can support. The absence\n\t * of this parameter indicates that the sending endpoint can\n\t * support any address type.\n\t */\n\tsat.param_hdr.type = SCTP_PARAM_SUPPORTED_ADDRESS_TYPES;\n\tsat.param_hdr.length = htons(SCTP_SAT_LEN(num_types));\n\tsctp_addto_chunk(retval, sizeof(sat), &sat);\n\tsctp_addto_chunk(retval, num_types * sizeof(__u16), &types);\n\n\tsctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);\n\n\t/* Add the supported extensions parameter.  Be nice and add this\n\t * fist before addiding the parameters for the extensions themselves\n\t */\n\tif (num_ext) {\n\t\text_param.param_hdr.type = SCTP_PARAM_SUPPORTED_EXT;\n\t\text_param.param_hdr.length =\n\t\t\t    htons(sizeof(sctp_supported_ext_param_t) + num_ext);\n\t\tsctp_addto_chunk(retval, sizeof(sctp_supported_ext_param_t),\n\t\t\t\t&ext_param);\n\t\tsctp_addto_param(retval, num_ext, extensions);\n\t}\n\n\tif (sctp_prsctp_enable)\n\t\tsctp_addto_chunk(retval, sizeof(prsctp_param), &prsctp_param);\n\n\tif (sp->adaptation_ind) {\n\t\taiparam.param_hdr.type = SCTP_PARAM_ADAPTATION_LAYER_IND;\n\t\taiparam.param_hdr.length = htons(sizeof(aiparam));\n\t\taiparam.adaptation_ind = htonl(sp->adaptation_ind);\n\t\tsctp_addto_chunk(retval, sizeof(aiparam), &aiparam);\n\t}\n\n\t/* Add SCTP-AUTH chunks to the parameter list */\n\tif (sctp_auth_enable) {\n\t\tsctp_addto_chunk(retval, sizeof(asoc->c.auth_random),\n\t\t\t\t asoc->c.auth_random);\n\t\tif (auth_hmacs)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_hmacs->length),\n\t\t\t\t\tauth_hmacs);\n\t\tif (auth_chunks)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_chunks->length),\n\t\t\t\t\tauth_chunks);\n\t}\nnodata:\n\tkfree(addrs.v);\n\treturn retval;\n}",
        "description": "In the Linux kernel prior to version 2.6.34, when both addip_enable and auth_enable are enabled, the function responsible for creating SCTP chunks does not account for the amount of zero padding during the calculation of chunk lengths for INIT and INIT ACK chunks. This oversight allows remote attackers to exploit this vulnerability by sending specially crafted packets, resulting in a denial of service (OOPS).",
        "commit": "When calculating the INIT/INIT-ACK chunk length, it is essential to consider not only the length of the parameters but also the zero padding length of these parameters, such as the AUTH HMACS parameter and CHUNKS parameter. Failing to account for the zero padding length can lead to a kernel panic, specifically an `skb_over_panic` error, which occurs when attempting to write beyond the buffer's allocated space. This issue arises within the SCTP protocol implementation in the Linux kernel, potentially affecting network communication stability and security."
    },
    {
        "cwe": "CWE-911",
        "func_name": "torvalds/u32_destroy_key",
        "score": 0.7284348011016846,
        "func_before": "static int u32_destroy_key(struct tc_u_knode *n, bool free_pf)\n{\n\tstruct tc_u_hnode *ht = rtnl_dereference(n->ht_down);\n\n\ttcf_exts_destroy(&n->exts);\n\ttcf_exts_put_net(&n->exts);\n\tif (ht && --ht->refcnt == 0)\n\t\tkfree(ht);\n#ifdef CONFIG_CLS_U32_PERF\n\tif (free_pf)\n\t\tfree_percpu(n->pf);\n#endif\n#ifdef CONFIG_CLS_U32_MARK\n\tif (free_pf)\n\t\tfree_percpu(n->pcpu_success);\n#endif\n\tkfree(n);\n\treturn 0;\n}",
        "func_after": "static void u32_destroy_key(struct tc_u_knode *n, bool free_pf)\n{\n\ttcf_exts_put_net(&n->exts);\n#ifdef CONFIG_CLS_U32_PERF\n\tif (free_pf)\n\t\tfree_percpu(n->pf);\n#endif\n#ifdef CONFIG_CLS_U32_MARK\n\tif (free_pf)\n\t\tfree_percpu(n->pcpu_success);\n#endif\n\t__u32_destroy_key(n);\n}",
        "description": "An Improper Update of Reference Count vulnerability in the networking scheduler component of the Linux Kernel enables a local attacker to achieve privilege escalation to root. This issue impacts Linux Kernel versions prior to 5.18 and versions 4.14 and later.",
        "commit": "A vulnerability was identified in the Linux kernel where an extra `put_net()` operation is detected prematurely. Specifically, functions such as `u32_init_knode()` and `tcf_exts_init()` populate the `->exts.net` pointer without elevating the reference count on the network namespace (`netns`). The reference count is incremented only when `tcf_exts_get_net()` is called. Consequently, two calls to `u32_destroy_key()` from `u32_change()` attempt to release an invalid reference on the `netns`, leading to a refcount decrement hitting zero and potential memory leaks. This issue occurs in the Linux kernel prior to a specific version, affecting the handling of network traffic classification and filtering mechanisms."
    },
    {
        "cwe": "CWE-502",
        "func_name": "godotengine/MultiplayerAPI::_process_rpc",
        "score": 0.759040892124176,
        "func_before": "void MultiplayerAPI___process_rpc(Node *p_node, const StringName &p_name, int p_from, const uint8_t *p_packet, int p_packet_len, int p_offset) {\n\n\tERR_EXPLAIN(\"Invalid packet received. Size too small.\");\n\tERR_FAIL_COND(p_offset >= p_packet_len);\n\n\t// Check that remote can call the RPC on this node.\n\tRPCMode rpc_mode = RPC_MODE_DISABLED;\n\tconst Map<StringName, RPCMode>::Element *E = p_node->get_node_rpc_mode(p_name);\n\tif (E) {\n\t\trpc_mode = E->get();\n\t} else if (p_node->get_script_instance()) {\n\t\trpc_mode = p_node->get_script_instance()->get_rpc_mode(p_name);\n\t}\n\n\tERR_EXPLAIN(\"RPC '\" + String(p_name) + \"' is not allowed from: \" + itos(p_from) + \". Mode is \" + itos((int)rpc_mode) + \", master is \" + itos(p_node->get_network_master()) + \".\");\n\tERR_FAIL_COND(!_can_call_mode(p_node, rpc_mode, p_from));\n\n\tint argc = p_packet[p_offset];\n\tVector<Variant> args;\n\tVector<const Variant *> argp;\n\targs.resize(argc);\n\targp.resize(argc);\n\n\tp_offset++;\n\n\tfor (int i = 0; i < argc; i++) {\n\n\t\tERR_EXPLAIN(\"Invalid packet received. Size too small.\");\n\t\tERR_FAIL_COND(p_offset >= p_packet_len);\n\n\t\tint vlen;\n\t\tError err = decode_variant(args.write[i], &p_packet[p_offset], p_packet_len - p_offset, &vlen);\n\t\tERR_EXPLAIN(\"Invalid packet received. Unable to decode RPC argument.\");\n\t\tERR_FAIL_COND(err != OK);\n\n\t\targp.write[i] = &args[i];\n\t\tp_offset += vlen;\n\t}\n\n\tVariant::CallError ce;\n\n\tp_node->call(p_name, (const Variant **)argp.ptr(), argc, ce);\n\tif (ce.error != Variant::CallError::CALL_OK) {\n\t\tString error = Variant::get_call_error_text(p_node, p_name, (const Variant **)argp.ptr(), argc, ce);\n\t\terror = \"RPC - \" + error;\n\t\tERR_PRINTS(error);\n\t}\n}",
        "func_after": "void MultiplayerAPI___process_rpc(Node *p_node, const StringName &p_name, int p_from, const uint8_t *p_packet, int p_packet_len, int p_offset) {\n\n\tERR_EXPLAIN(\"Invalid packet received. Size too small.\");\n\tERR_FAIL_COND(p_offset >= p_packet_len);\n\n\t// Check that remote can call the RPC on this node.\n\tRPCMode rpc_mode = RPC_MODE_DISABLED;\n\tconst Map<StringName, RPCMode>::Element *E = p_node->get_node_rpc_mode(p_name);\n\tif (E) {\n\t\trpc_mode = E->get();\n\t} else if (p_node->get_script_instance()) {\n\t\trpc_mode = p_node->get_script_instance()->get_rpc_mode(p_name);\n\t}\n\n\tERR_EXPLAIN(\"RPC '\" + String(p_name) + \"' is not allowed from: \" + itos(p_from) + \". Mode is \" + itos((int)rpc_mode) + \", master is \" + itos(p_node->get_network_master()) + \".\");\n\tERR_FAIL_COND(!_can_call_mode(p_node, rpc_mode, p_from));\n\n\tint argc = p_packet[p_offset];\n\tVector<Variant> args;\n\tVector<const Variant *> argp;\n\targs.resize(argc);\n\targp.resize(argc);\n\n\tp_offset++;\n\n\tfor (int i = 0; i < argc; i++) {\n\n\t\tERR_EXPLAIN(\"Invalid packet received. Size too small.\");\n\t\tERR_FAIL_COND(p_offset >= p_packet_len);\n\n\t\tint vlen;\n\t\tError err = decode_variant(args.write[i], &p_packet[p_offset], p_packet_len - p_offset, &vlen, network_peer->is_object_decoding_allowed());\n\t\tERR_EXPLAIN(\"Invalid packet received. Unable to decode RPC argument.\");\n\t\tERR_FAIL_COND(err != OK);\n\n\t\targp.write[i] = &args[i];\n\t\tp_offset += vlen;\n\t}\n\n\tVariant::CallError ce;\n\n\tp_node->call(p_name, (const Variant **)argp.ptr(), argc, ce);\n\tif (ce.error != Variant::CallError::CALL_OK) {\n\t\tString error = Variant::get_call_error_text(p_node, p_name, (const Variant **)argp.ptr(), argc, ce);\n\t\terror = \"RPC - \" + error;\n\t\tERR_PRINTS(error);\n\t}\n}",
        "description": "In Godot versions up to 3.1, remote code execution is possible due to an incorrect application of the deserialization policy.",
        "commit": "The Multiplayer API has been updated to honor the allow_object_decoding setting."
    },
    {
        "cwe": "CWE-120",
        "func_name": "ClusterLabs/_blackbox_vlogger",
        "score": 0.7863468527793884,
        "func_before": "static void\n_blackbox_vlogger(int32_t target,\n\t\t  struct qb_log_callsite *cs, struct timespec *timestamp, va_list ap)\n{\n\tsize_t max_size;\n\tsize_t actual_size;\n\tuint32_t fn_size;\n\tchar *chunk;\n\tchar *msg_len_pt;\n\tuint32_t msg_len;\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\n\tif (t->instance == NULL) {\n\t\treturn;\n\t}\n\n\tfn_size = strlen(cs->function) + 1;\n\n\tactual_size = 4 * sizeof(uint32_t) + sizeof(uint8_t) + fn_size + sizeof(struct timespec);\n\tmax_size = actual_size + t->max_line_length;\n\n\tchunk = qb_rb_chunk_alloc(t->instance, max_size);\n\n\tif (chunk == NULL) {\n\t\t/* something bad has happened. abort blackbox logging */\n\t\tqb_util_perror(LOG_ERR, \"Blackbox allocation error, aborting blackbox log %s\", t->filename);\n\t\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t\t(struct qb_ringbuffer_s **) &t->instance\n\t\t));\n\t\treturn;\n\t}\n\n\t/* line number */\n\tmemcpy(chunk, &cs->lineno, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* tags */\n\tmemcpy(chunk, &cs->tags, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* log level/priority */\n\tmemcpy(chunk, &cs->priority, sizeof(uint8_t));\n\tchunk += sizeof(uint8_t);\n\n\t/* function name */\n\tmemcpy(chunk, &fn_size, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, cs->function, fn_size);\n\tchunk += fn_size;\n\n\t/* timestamp */\n\tmemcpy(chunk, timestamp, sizeof(struct timespec));\n\tchunk += sizeof(struct timespec);\n\n\t/* log message length */\n\tmsg_len_pt = chunk;\n\tchunk += sizeof(uint32_t);\n\n\t/* log message */\n\tmsg_len = qb_vsnprintf_serialize(chunk, max_size, cs->format, ap);\n\tif (msg_len >= max_size) {\n\t    chunk = msg_len_pt + sizeof(uint32_t); /* Reset */\n\n\t    /* Leave this at QB_LOG_MAX_LEN so as not to overflow the blackbox */\n\t    msg_len = qb_vsnprintf_serialize(chunk, QB_LOG_MAX_LEN,\n\t\t\"Log message too long to be stored in the blackbox.  \"\\\n\t\t\"Maximum is QB_LOG_MAX_LEN\" , ap);\n\t}\n\n\tactual_size += msg_len;\n\n\t/* now that we know the length, write it\n\t */\n\tmemcpy(msg_len_pt, &msg_len, sizeof(uint32_t));\n\n\t(void)qb_rb_chunk_commit(t->instance, actual_size);\n}",
        "func_after": "static void\n_blackbox_vlogger(int32_t target,\n\t\t  struct qb_log_callsite *cs, struct timespec *timestamp, va_list ap)\n{\n\tsize_t max_size;\n\tsize_t actual_size;\n\tuint32_t fn_size;\n\tchar *chunk;\n\tchar *msg_len_pt;\n\tuint32_t msg_len;\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\n\tif (t->instance == NULL) {\n\t\treturn;\n\t}\n\n\tfn_size = strlen(cs->function) + 1;\n\n\tactual_size = 4 * sizeof(uint32_t) + sizeof(uint8_t) + fn_size + sizeof(struct timespec);\n\tmax_size = actual_size + t->max_line_length;\n\n\tchunk = qb_rb_chunk_alloc(t->instance, max_size);\n\n\tif (chunk == NULL) {\n\t\t/* something bad has happened. abort blackbox logging */\n\t\tqb_util_perror(LOG_ERR, \"Blackbox allocation error, aborting blackbox log %s\", t->filename);\n\t\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t\t(struct qb_ringbuffer_s **) &t->instance\n\t\t));\n\t\treturn;\n\t}\n\n\t/* line number */\n\tmemcpy(chunk, &cs->lineno, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* tags */\n\tmemcpy(chunk, &cs->tags, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* log level/priority */\n\tmemcpy(chunk, &cs->priority, sizeof(uint8_t));\n\tchunk += sizeof(uint8_t);\n\n\t/* function name */\n\tmemcpy(chunk, &fn_size, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, cs->function, fn_size);\n\tchunk += fn_size;\n\n\t/* timestamp */\n\tmemcpy(chunk, timestamp, sizeof(struct timespec));\n\tchunk += sizeof(struct timespec);\n\n\t/* log message length */\n\tmsg_len_pt = chunk;\n\tchunk += sizeof(uint32_t);\n\n\t/* log message */\n\tmsg_len = qb_vsnprintf_serialize(chunk, t->max_line_length, cs->format, ap);\n\tif (msg_len >= t->max_line_length) {\n\t    chunk = msg_len_pt + sizeof(uint32_t); /* Reset */\n\n\t    /* Leave this at QB_LOG_MAX_LEN so as not to overflow the blackbox */\n\t    msg_len = qb_vsnprintf_serialize(chunk, QB_LOG_MAX_LEN,\n\t\t\"Log message too long to be stored in the blackbox.  \"\\\n\t\t\"Maximum is QB_LOG_MAX_LEN\" , ap);\n\t}\n\n\tactual_size += msg_len;\n\n\t/* now that we know the length, write it\n\t */\n\tmemcpy(msg_len_pt, &msg_len, sizeof(uint32_t));\n\n\t(void)qb_rb_chunk_commit(t->instance, actual_size);\n}",
        "description": "log_blackbox.c in libqb prior to version 2.0.8 is susceptible to a buffer overflow due to the neglect of considering the header size when processing long log messages.",
        "commit": "The vulnerability knowledge has been abstracted and generalized as follows:\n\n\"A function responsible for serializing log messages potentially suffers from an overflow issue due to improper buffer size calculation. The original implementation used 'max_size' to limit the length of the formatted log message, but failed to account for the additional space required for the log header ('actual_size'). This oversight has been corrected by adjusting the maximum length parameter to 't->max_line_length', ensuring it accurately reflects the remaining buffer space. Additionally, error checks have been introduced to the blackbox calls at the end of the test to ensure proper functionality and to prevent masking of failures.\""
    },
    {
        "cwe": "CWE-668",
        "func_name": "xen-project/sh_guess_wrmap",
        "score": 0.7507222294807434,
        "func_before": "static int sh_guess_wrmap(struct vcpu *v, unsigned long vaddr, mfn_t gmfn)\n/* Look up this vaddr in the current shadow and see if it's a writeable\n * mapping of this gmfn.  If so, remove it.  Returns 1 if it worked. */\n{\n    struct domain *d = v->domain;\n    shadow_l1e_t sl1e, *sl1p;\n    shadow_l2e_t *sl2p;\n    shadow_l3e_t *sl3p;\n#if SHADOW_PAGING_LEVELS >= 4\n    shadow_l4e_t *sl4p;\n#endif\n    mfn_t sl1mfn;\n    int r;\n\n    /* Carefully look in the shadow linear map for the l1e we expect */\n#if SHADOW_PAGING_LEVELS >= 4\n    sl4p = sh_linear_l4_table(v) + shadow_l4_linear_offset(vaddr);\n    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )\n        return 0;\n    sl3p = sh_linear_l3_table(v) + shadow_l3_linear_offset(vaddr);\n    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )\n        return 0;\n#else /* SHADOW_PAGING_LEVELS == 3 */\n    sl3p = ((shadow_l3e_t *) v->arch.paging.shadow.l3table)\n        + shadow_l3_linear_offset(vaddr);\n    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )\n        return 0;\n#endif\n    sl2p = sh_linear_l2_table(v) + shadow_l2_linear_offset(vaddr);\n    if ( !(shadow_l2e_get_flags(*sl2p) & _PAGE_PRESENT) )\n        return 0;\n    sl1p = sh_linear_l1_table(v) + shadow_l1_linear_offset(vaddr);\n    sl1e = *sl1p;\n    if ( ((shadow_l1e_get_flags(sl1e) & (_PAGE_PRESENT|_PAGE_RW))\n          != (_PAGE_PRESENT|_PAGE_RW))\n         || (mfn_x(shadow_l1e_get_mfn(sl1e)) != mfn_x(gmfn)) )\n        return 0;\n\n    /* Found it!  Need to remove its write permissions. */\n    sl1mfn = shadow_l2e_get_mfn(*sl2p);\n    sl1e = shadow_l1e_remove_flags(sl1e, _PAGE_RW);\n    r = shadow_set_l1e(d, sl1p, sl1e, p2m_ram_rw, sl1mfn);\n    if ( r & SHADOW_SET_ERROR ) {\n        /* Can only currently happen if we found a grant-mapped\n         * page.  Just make the guess fail. */\n        return 0;\n    }\n    TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_WRMAP_GUESS_FOUND);\n    return 1;\n}",
        "func_after": "static int sh_guess_wrmap(struct vcpu *v, unsigned long vaddr, mfn_t gmfn)\n/* Look up this vaddr in the current shadow and see if it's a writeable\n * mapping of this gmfn.  If so, remove it.  Returns 1 if it worked. */\n{\n    struct domain *d = v->domain;\n    shadow_l1e_t sl1e, *sl1p;\n    shadow_l2e_t *sl2p;\n    shadow_l3e_t *sl3p;\n#if SHADOW_PAGING_LEVELS >= 4\n    shadow_l4e_t *sl4p;\n#endif\n    mfn_t sl1mfn;\n    int r;\n\n    /* Carefully look in the shadow linear map for the l1e we expect */\n#if SHADOW_PAGING_LEVELS >= 4\n    /* Is a shadow linear map is installed in the first place? */\n    sl4p  = v->arch.paging.shadow.guest_vtable;\n    sl4p += shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START);\n    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )\n        return 0;\n    sl4p = sh_linear_l4_table(v) + shadow_l4_linear_offset(vaddr);\n    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )\n        return 0;\n    sl3p = sh_linear_l3_table(v) + shadow_l3_linear_offset(vaddr);\n    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )\n        return 0;\n#else /* SHADOW_PAGING_LEVELS == 3 */\n    sl3p = ((shadow_l3e_t *) v->arch.paging.shadow.l3table)\n        + shadow_l3_linear_offset(vaddr);\n    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )\n        return 0;\n#endif\n    sl2p = sh_linear_l2_table(v) + shadow_l2_linear_offset(vaddr);\n    if ( !(shadow_l2e_get_flags(*sl2p) & _PAGE_PRESENT) )\n        return 0;\n    sl1p = sh_linear_l1_table(v) + shadow_l1_linear_offset(vaddr);\n    sl1e = *sl1p;\n    if ( ((shadow_l1e_get_flags(sl1e) & (_PAGE_PRESENT|_PAGE_RW))\n          != (_PAGE_PRESENT|_PAGE_RW))\n         || (mfn_x(shadow_l1e_get_mfn(sl1e)) != mfn_x(gmfn)) )\n        return 0;\n\n    /* Found it!  Need to remove its write permissions. */\n    sl1mfn = shadow_l2e_get_mfn(*sl2p);\n    sl1e = shadow_l1e_remove_flags(sl1e, _PAGE_RW);\n    r = shadow_set_l1e(d, sl1p, sl1e, p2m_ram_rw, sl1mfn);\n    if ( r & SHADOW_SET_ERROR ) {\n        /* Can only currently happen if we found a grant-mapped\n         * page.  Just make the guess fail. */\n        return 0;\n    }\n    TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_WRMAP_GUESS_FOUND);\n    return 1;\n}",
        "description": "An issue was discovered in Xen versions up to 4.9.x, where x86 HVM guest OS users could potentially cause a denial of service (hypervisor crash) or escalate privileges due to improper handling of self-linear shadow mappings in translated guests.",
        "commit": "A vulnerability was identified in the x86/shadow component of the Xen hypervisor, specifically within the `sh_guess_wrmap()` function. The fix for XSA-243/CVE-2017-15592 introduced a change in behavior for `sh_guest_wrmap()`, which now needs to handle cases where no shadow linear mapping is present. The issue arises because `guest_vtable` maps the guest's page table rather than Xen's page table, leading to incorrect checks for the presence of a shadow linear slot. As a result, a shadow HVM vCPU switching to 4-level paging mode with an L4 page table containing a mapping that aliases Xen's `SH_LINEAR_PT_VIRT_START` can pass the safety check when it should fail. Consequently, Xen encounters a page fault due to the missing mapping. This problem is part of XSA-243."
    }
]