[
    {
        "cwe": "CWE-776",
        "func_name": "libexpat/externalParEntProcessor",
        "score": 0.700202465057373,
        "func_before": "static enum XML_Error PTRCALL\nexternalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: /* start == end */\n    default:\n      break;\n    }\n  }\n  /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.\n     However, when parsing an external subset, doProlog will not accept a BOM\n     as valid, and report a syntax error, so we have to skip the BOM\n  */\n  else if (tok == XML_TOK_BOM) {\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}",
        "func_after": "static enum XML_Error PTRCALL\nexternalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: /* start == end */\n    default:\n      break;\n    }\n  }\n  /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.\n     However, when parsing an external subset, doProlog will not accept a BOM\n     as valid, and report a syntax error, so we have to skip the BOM\n  */\n  else if (tok == XML_TOK_BOM) {\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);\n}",
        "description": "In versions of libexpat prior to 2.2.8, maliciously crafted XML input could cause the parser to prematurely transition from DTD parsing to document parsing. Subsequently, invoking functions such as XML_GetCurrentLineNumber or XML_GetCurrentColumnNumber led to a heap-based buffer over-read.",
        "commit": "output: \"Denial of service vulnerability due to improper handling of internal entities within the XML parsing process.\""
    },
    {
        "cwe": "CWE-22",
        "func_name": "GNOME/extract_archive_thread",
        "score": 0.7525305151939392,
        "func_before": "static void\nextract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tGHashTable           *created_files;\n\tGHashTable           *folders_created_during_extraction;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\n\tr = create_read_object (load_data, &a);\n\tif (r != ARCHIVE_OK) {\n\t\tarchive_read_free(a);\n\t\treturn;\n\t}\n\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tcreated_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, g_object_unref);\n\tfolders_created_during_extraction = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        target_offset, actual_offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\n\t\t/* honor the skip_older and overwrite options */\n\n\t\tif ((g_hash_table_lookup (folders_created_during_extraction, file) == NULL)\n\t\t    && (extract_data->skip_older || ! extract_data->overwrite))\n\t\t{\n\t\t\tGFileInfo *info;\n\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\n\t\t\t\tg_object_unref (info);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\t\t}\n\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\n\t\t/* create the file parents */\n\n\t\tparent = g_file_get_parent (file);\n\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (! _g_file_make_directory_with_parents (parent,\n\t\t\t\t\t\t\t\t   folders_created_during_extraction,\n\t\t\t\t\t\t\t\t   cancellable,\n\t\t\t\t\t\t\t\t   &local_error))\n\t\t\t{\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\telse\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\n\t\t\tif (load_data->error == NULL) {\n\t\t\t\tGFile *grandparent;\n\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\n\t\t/* create the file */\n\n\t\tfiletype = archive_entry_filetype (entry);\n\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; /* treat as a regular file to save the data */\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tif (load_data->error == NULL)\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tactual_offset = 0;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &target_offset)) == ARCHIVE_OK) {\n\t\t\t\t\tgsize bytes_written;\n\n\t\t\t\t\tif (target_offset > actual_offset) {\n\t\t\t\t\t\tif (! _g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, target_offset - actual_offset);\n\t\t\t\t\t\tactual_offset = target_offset;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! g_output_stream_write_all (ostream, buffer, buffer_size, &bytes_written, cancellable, &load_data->error))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tactual_offset += bytes_written;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, bytes_written);\n\t\t\t\t}\n\n\t\t\t\tif ((r == ARCHIVE_EOF) && (target_offset > actual_offset))\n\t\t\t\t\t_g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error);\n\n\t\t\t\t_g_object_unref (ostream);\n\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (load_data->error == NULL)\n\t\trestore_original_file_attributes (created_files, cancellable);\n\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\n\tg_hash_table_unref (folders_created_during_extraction);\n\tg_hash_table_unref (created_files);\n\tg_hash_table_unref (checked_folders);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "func_after": "static void\nextract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tGHashTable           *created_files;\n\tGHashTable           *folders_created_during_extraction;\n\tGHashTable           *external_links;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\n\tr = create_read_object (load_data, &a);\n\tif (r != ARCHIVE_OK) {\n\t\tarchive_read_free(a);\n\t\treturn;\n\t}\n\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tcreated_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, g_object_unref);\n\tfolders_created_during_extraction = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\texternal_links = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        target_offset, actual_offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (_g_path_is_external_to_destination (relative_path, extract_data->destination, external_links)) {\n\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\n\t\t/* honor the skip_older and overwrite options */\n\n\t\tif ((g_hash_table_lookup (folders_created_during_extraction, file) == NULL)\n\t\t    && (extract_data->skip_older || ! extract_data->overwrite))\n\t\t{\n\t\t\tGFileInfo *info;\n\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\n\t\t\t\tg_object_unref (info);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\t\t}\n\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\n\t\t/* create the file parents */\n\n\t\tparent = g_file_get_parent (file);\n\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (! _g_file_make_directory_with_parents (parent,\n\t\t\t\t\t\t\t\t   folders_created_during_extraction,\n\t\t\t\t\t\t\t\t   cancellable,\n\t\t\t\t\t\t\t\t   &local_error))\n\t\t\t{\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\telse\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\n\t\t\tif (load_data->error == NULL) {\n\t\t\t\tGFile *grandparent;\n\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\n\t\t/* create the file */\n\n\t\tfiletype = archive_entry_filetype (entry);\n\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; /* treat as a regular file to save the data */\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tif (load_data->error == NULL)\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tactual_offset = 0;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &target_offset)) == ARCHIVE_OK) {\n\t\t\t\t\tgsize bytes_written;\n\n\t\t\t\t\tif (target_offset > actual_offset) {\n\t\t\t\t\t\tif (! _g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, target_offset - actual_offset);\n\t\t\t\t\t\tactual_offset = target_offset;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! g_output_stream_write_all (ostream, buffer, buffer_size, &bytes_written, cancellable, &load_data->error))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tactual_offset += bytes_written;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, bytes_written);\n\t\t\t\t}\n\n\t\t\t\tif ((r == ARCHIVE_EOF) && (target_offset > actual_offset))\n\t\t\t\t\t_g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error);\n\n\t\t\t\t_g_object_unref (ostream);\n\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\telse if (_symlink_is_external_to_destination (file, archive_entry_symlink (entry), extract_data->destination, external_links))\n\t\t\t\t\tg_hash_table_insert (external_links, g_object_ref (file), GINT_TO_POINTER (1));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (load_data->error == NULL)\n\t\trestore_original_file_attributes (created_files, cancellable);\n\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\n\tg_hash_table_unref (folders_created_during_extraction);\n\tg_hash_table_unref (created_files);\n\tg_hash_table_unref (checked_folders);\n\tg_hash_table_unref (external_links);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "description": "A directory traversal vulnerability exists in File Roller versions 3.6.x before 3.6.4, 3.8.x before 3.8.3, and 3.9.x before 3.9.3 when using libarchive. This flaw allows remote attackers to create arbitrary files by exploiting improper handling of archives during a \"Keep directory structure\" action.",
        "commit": "It was discovered that filenames should be sanitized before extraction to prevent potential security vulnerabilities."
    },
    {
        "cwe": "CWE-116",
        "func_name": "flatpak/flatpak_builtin_info",
        "score": 0.7389984726905823,
        "func_before": "gboolean\nflatpak_builtin_info (int argc, char **argv, GCancellable *cancellable, GError **error)\n{\n  g_autoptr(GOptionContext) context = NULL;\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n  g_autoptr(FlatpakDir) dir = NULL;\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autoptr(FlatpakDeploy) deploy = NULL;\n  g_autoptr(GFile) deploy_dir = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  const char *commit = NULL;\n  const char *alt_id = NULL;\n  const char *eol;\n  const char *eol_rebase;\n  const char *name;\n  const char *summary;\n  const char *version;\n  const char *license;\n  const char *pref = NULL;\n  const char *default_branch = NULL;\n  const char *origin = NULL;\n  guint64 size;\n  gboolean search_all = FALSE;\n  gboolean first = TRUE;\n  FlatpakKinds kinds;\n  const char *path;\n  g_autofree char *formatted_size = NULL;\n  gboolean friendly = TRUE;\n  g_autofree const char **subpaths = NULL;\n  int len = 0;\n  int rows, cols;\n  int width;\n\n  context = g_option_context_new (_(\"NAME [BRANCH] - Get info about an installed app or runtime\"));\n  g_option_context_set_translation_domain (context, GETTEXT_PACKAGE);\n\n  if (!flatpak_option_context_parse (context, options, &argc, &argv, FLATPAK_BUILTIN_FLAG_NO_DIR, NULL, cancellable, error))\n    return FALSE;\n\n  if (argc < 2)\n    return usage_error (context, _(\"NAME must be specified\"), error);\n  pref = argv[1];\n\n  if (argc >= 3)\n    default_branch = argv[2];\n\n  if (argc > 3)\n    return usage_error (context, _(\"Too many arguments\"), error);\n\n  kinds = FLATPAK_KINDS_APP | FLATPAK_KINDS_RUNTIME;\n\n  if (!opt_user && !opt_system && opt_installations == NULL)\n    search_all = TRUE;\n\n  dir = flatpak_find_installed_pref (pref, kinds, opt_arch, default_branch,\n                                     search_all, opt_user, opt_system, opt_installations,\n                                     &ref, cancellable, error);\n  if (dir == NULL)\n    return FALSE;\n\n  deploy_data = flatpak_dir_get_deploy_data (dir, ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);\n  if (deploy_data == NULL)\n    return FALSE;\n\n  deploy = flatpak_dir_load_deployed (dir, ref, NULL, cancellable, error);\n  if (deploy == NULL)\n    return FALSE;\n\n  commit = flatpak_deploy_data_get_commit (deploy_data);\n  alt_id = flatpak_deploy_data_get_alt_id (deploy_data);\n  origin = flatpak_deploy_data_get_origin (deploy_data);\n  size = flatpak_deploy_data_get_installed_size (deploy_data);\n  formatted_size = g_format_size (size);\n  deploy_dir = flatpak_deploy_get_dir (deploy);\n  path = flatpak_file_get_path_cached (deploy_dir);\n  subpaths = flatpak_deploy_data_get_subpaths (deploy_data);\n  eol = flatpak_deploy_data_get_eol (deploy_data);\n  eol_rebase = flatpak_deploy_data_get_eol_rebase (deploy_data);\n  name = flatpak_deploy_data_get_appdata_name (deploy_data);\n  summary = flatpak_deploy_data_get_appdata_summary (deploy_data);\n  version = flatpak_deploy_data_get_appdata_version (deploy_data);\n  license = flatpak_deploy_data_get_appdata_license (deploy_data);\n\n  metakey = flatpak_deploy_get_metadata (deploy);\n\n  if (opt_show_ref || opt_show_origin || opt_show_commit || opt_show_size || opt_show_metadata || opt_show_permissions ||\n      opt_file_access || opt_show_location || opt_show_runtime || opt_show_sdk)\n    friendly = FALSE;\n\n  if (friendly)\n    {\n      g_autoptr(GVariant) commit_v = NULL;\n      VarMetadataRef commit_metadata;\n      guint64 timestamp;\n      g_autofree char *formatted_timestamp = NULL;\n      const gchar *subject = NULL;\n      g_autofree char *parent = NULL;\n      g_autofree char *latest = NULL;\n      const char *xa_metadata = NULL;\n      const char *collection_id = NULL;\n\n      flatpak_get_window_size (&rows, &cols);\n\n      if (name)\n        {\n          if (summary)\n            print_wrapped (MIN (cols, 80), \"\\n%s - %s\\n\", name, summary);\n          else\n            print_wrapped (MIN (cols, 80), \"\\n%s\\n\", name);\n        }\n\n      latest = flatpak_dir_read_latest (dir, origin, flatpak_decomposed_get_ref (ref), NULL, NULL, NULL);\n      if (latest == NULL)\n        latest = g_strdup (_(\"ref not present in origin\"));\n\n      if (ostree_repo_load_commit (flatpak_dir_get_repo (dir), commit, &commit_v, NULL, NULL))\n        {\n          VarCommitRef var_commit = var_commit_from_gvariant (commit_v);\n\n          subject = var_commit_get_subject (var_commit);\n          parent = ostree_commit_get_parent (commit_v);\n          timestamp = ostree_commit_get_timestamp (commit_v);\n\n          formatted_timestamp = format_timestamp (timestamp);\n\n          commit_metadata = var_commit_get_metadata (var_commit);\n          xa_metadata = var_metadata_lookup_string (commit_metadata, \"xa.metadata\", NULL);\n          if (xa_metadata == NULL)\n            g_printerr (_(\"Warning: Commit has no flatpak metadata\\n\"));\n\n          collection_id = var_metadata_lookup_string (commit_metadata, \"ostree.collection-binding\", NULL);\n        }\n\n      len = 0;\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Ref:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Arch:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Branch:\"), -1));\n      if (version)\n        len = MAX (len, g_utf8_strlen (_(\"Version:\"), -1));\n      if (license)\n        len = MAX (len, g_utf8_strlen (_(\"License:\"), -1));\n      if (collection_id != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Collection:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installation:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      if (flatpak_decomposed_is_app (ref))\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Runtime:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Sdk:\"), -1));\n        }\n      if (formatted_timestamp)\n        len = MAX (len, g_utf8_strlen (_(\"Date:\"), -1));\n      if (subject)\n        len = MAX (len, g_utf8_strlen (_(\"Subject:\"), -1));\n      if (strcmp (commit, latest) != 0)\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Active commit:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Latest commit:\"), -1));\n        }\n      else\n        len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      if (parent)\n        len = MAX (len, g_utf8_strlen (_(\"Parent:\"), -1));\n      if (alt_id)\n        len = MAX (len, g_utf8_strlen (_(\"Alt-id:\"), -1));\n      if (eol)\n        len = MAX (len, g_utf8_strlen (_(\"End-of-life:\"), -1));\n      if (eol_rebase)\n        len = MAX (len, g_utf8_strlen (_(\"End-of-life-rebase:\"), -1));\n      if (subpaths[0] != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Subdirectories:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Extension:\"), -1));\n\n      width = cols - (len + 1);\n\n      print_aligned_take (len, _(\"ID:\"), flatpak_decomposed_dup_id (ref));\n      print_aligned (len, _(\"Ref:\"), flatpak_decomposed_get_ref (ref));\n      print_aligned_take (len, _(\"Arch:\"), flatpak_decomposed_dup_arch (ref));\n      print_aligned_take (len, _(\"Branch:\"), flatpak_decomposed_dup_branch (ref));\n      if (version)\n        print_aligned (len, _(\"Version:\"), version);\n      if (license)\n        print_aligned (len, _(\"License:\"), license);\n      print_aligned (len, _(\"Origin:\"), origin ? origin : \"-\");\n      if (collection_id)\n        print_aligned (len, _(\"Collection:\"), collection_id);\n      print_aligned (len, _(\"Installation:\"), flatpak_dir_get_name_cached (dir));\n      print_aligned (len, _(\"Installed:\"), formatted_size);\n      if (flatpak_decomposed_is_app (ref))\n        {\n          g_autofree char *runtime = NULL;\n          runtime = g_key_file_get_string (metakey,\n                                           FLATPAK_METADATA_GROUP_APPLICATION,\n                                           FLATPAK_METADATA_KEY_RUNTIME,\n                                           error);\n          print_aligned (len, _(\"Runtime:\"), runtime ? runtime : \"-\");\n        }\n      if (flatpak_decomposed_is_app (ref))\n        {\n          g_autofree char *sdk = NULL;\n          sdk = g_key_file_get_string (metakey,\n                                       FLATPAK_METADATA_GROUP_APPLICATION,\n                                       FLATPAK_METADATA_KEY_SDK,\n                                       error);\n          print_aligned (len, _(\"Sdk:\"), sdk ? sdk : \"-\");\n        }\n      g_print (\"\\n\");\n\n      if (strcmp (commit, latest) != 0)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (commit, width);\n          print_aligned (len, _(\"Active commit:\"), formatted_commit);\n          g_free (formatted_commit);\n          formatted_commit = ellipsize_string (latest, width);\n          print_aligned (len, _(\"Latest commit:\"), formatted_commit);\n        }\n      else\n        {\n          g_autofree char *formatted_commit = ellipsize_string (commit, width);\n          print_aligned (len, _(\"Commit:\"), formatted_commit);\n        }\n      if (parent)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (parent, width);\n          print_aligned (len, _(\"Parent:\"), formatted_commit);\n        }\n      if (subject)\n        print_aligned (len, _(\"Subject:\"), subject);\n      if (formatted_timestamp)\n        print_aligned (len, _(\"Date:\"), formatted_timestamp);\n      if (subpaths[0] != NULL)\n        {\n          g_autofree char *s = g_strjoinv (\",\", (char **) subpaths);\n          print_aligned (len, _(\"Subdirectories:\"), s);\n        }\n\n      if (alt_id)\n        print_aligned (len, _(\"Alt-id:\"), alt_id);\n      if (eol)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol, width);\n          print_aligned (len, _(\"End-of-life:\"), formatted_eol);\n        }\n      if (eol_rebase)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol_rebase, width);\n          print_aligned (len, _(\"End-of-life-rebase:\"), formatted_eol);\n        }\n    }\n  else\n    {\n      if (opt_show_ref)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", flatpak_decomposed_get_ref (ref));\n        }\n\n      if (opt_show_origin)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", origin ? origin : \"-\");\n        }\n\n      if (opt_show_commit)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", commit);\n        }\n\n      if (opt_show_size)\n        {\n          maybe_print_space (&first);\n          g_print (\"%\" G_GUINT64_FORMAT, size);\n        }\n\n      if (opt_show_location)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", path);\n        }\n\n      if (opt_show_runtime)\n        {\n          g_autofree char *runtime = NULL;\n          maybe_print_space (&first);\n\n          runtime = g_key_file_get_string (metakey,\n                                           flatpak_decomposed_get_kind_metadata_group (ref),\n                                           FLATPAK_METADATA_KEY_RUNTIME,\n                                           NULL);\n          g_print (\"%s\", runtime ? runtime : \"-\");\n        }\n\n      if (opt_show_sdk)\n        {\n          g_autofree char *sdk = NULL;\n          maybe_print_space (&first);\n\n          sdk = g_key_file_get_string (metakey,\n                                       flatpak_decomposed_get_kind_metadata_group (ref),\n                                       FLATPAK_METADATA_KEY_SDK,\n                                       NULL);\n          g_print (\"%s\", sdk ? sdk : \"-\");\n        }\n\n      if (!first)\n        g_print (\"\\n\");\n\n      if (opt_show_metadata)\n        {\n          g_autoptr(GFile) file = NULL;\n          g_autofree char *data = NULL;\n          gsize data_size;\n\n          file = g_file_get_child (deploy_dir, \"metadata\");\n\n          if (!g_file_load_contents (file, cancellable, &data, &data_size, NULL, error))\n            return FALSE;\n\n          g_print (\"%s\", data);\n        }\n\n      if (opt_show_permissions || opt_file_access)\n        {\n          g_autoptr(FlatpakContext) app_context = NULL;\n          g_autoptr(GKeyFile) keyfile = NULL;\n          g_autofree gchar *contents = NULL;\n\n          app_context = flatpak_context_load_for_deploy (deploy, error);\n          if (app_context == NULL)\n            return FALSE;\n\n          if (opt_show_permissions)\n            {\n              keyfile = g_key_file_new ();\n              flatpak_context_save_metadata (app_context, TRUE, keyfile);\n              contents = g_key_file_to_data (keyfile, NULL, error);\n              if (contents == NULL)\n                return FALSE;\n\n              g_print (\"%s\", contents);\n            }\n\n          if (opt_file_access)\n            {\n              g_autofree char *id = flatpak_decomposed_dup_id (ref);\n              g_autoptr(FlatpakExports) exports = flatpak_context_get_exports (app_context, id);\n              FlatpakFilesystemMode mode;\n\n              mode = flatpak_exports_path_get_mode (exports, opt_file_access);\n              if (mode == 0)\n                g_print (\"hidden\\n\");\n              else if (mode == FLATPAK_FILESYSTEM_MODE_READ_ONLY)\n                g_print (\"read-only\\n\");\n              else\n                g_print (\"read-write\\n\");\n            }\n        }\n    }\n\n  if (opt_show_extensions)\n    {\n      GList *extensions, *l;\n      g_autofree char *ref_arch = flatpak_decomposed_dup_arch (ref);\n      g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);\n\n      len = MAX (len, g_utf8_strlen (_(\"Extension:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Origin:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Subpaths:\"), -1));\n\n      flatpak_get_window_size (&rows, &cols);\n      width = cols - (len + 1);\n\n      extensions = flatpak_list_extensions (metakey, ref_arch, ref_branch);\n      for (l = extensions; l; l = l->next)\n        {\n          FlatpakExtension *ext = l->data;\n          g_autofree const char **ext_subpaths = NULL;\n          g_autoptr(GBytes) ext_deploy_data = NULL;\n          g_autofree char *formatted = NULL;\n          g_autofree char *ext_formatted_size = NULL;\n          g_autofree char *formatted_commit = NULL;\n\n          if (ext->is_unmaintained)\n            {\n              formatted_commit = g_strdup (_(\"unmaintained\"));\n              origin = NULL;\n              size = 0;\n              ext_formatted_size = g_strdup (_(\"unknown\"));\n              ext_subpaths = NULL;\n            }\n          else\n            {\n              ext_deploy_data = flatpak_dir_get_deploy_data (dir, ext->ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);\n              if (ext_deploy_data == NULL)\n                return FALSE;\n\n              commit = flatpak_deploy_data_get_commit (ext_deploy_data);\n              formatted_commit = ellipsize_string (commit, width);\n              origin = flatpak_deploy_data_get_origin (ext_deploy_data);\n              size = flatpak_deploy_data_get_installed_size (ext_deploy_data);\n              formatted = g_format_size (size);\n              ext_subpaths = flatpak_deploy_data_get_subpaths (ext_deploy_data);\n              if (ext_subpaths && ext_subpaths[0] && size > 0)\n                ext_formatted_size = g_strconcat (\"<\", formatted, NULL);\n              else\n                ext_formatted_size = g_steal_pointer (&formatted);\n            }\n\n          g_print (\"\\n\");\n          print_aligned (len, _(\"Extension:\"), flatpak_decomposed_get_ref (ext->ref));\n          print_aligned (len, _(\"ID:\"), ext->id);\n          print_aligned (len, _(\"Origin:\"), origin ? origin : \"-\");\n          print_aligned (len, _(\"Commit:\"), formatted_commit);\n          print_aligned (len, _(\"Installed:\"), ext_formatted_size);\n\n          if (ext_subpaths && ext_subpaths[0])\n            {\n              g_autofree char *s = g_strjoinv (\",\", (char **) ext_subpaths);\n              print_aligned (len, _(\"Subpaths:\"), s);\n            }\n        }\n\n      g_list_free_full (extensions, (GDestroyNotify) flatpak_extension_free);\n    }\n\n  return TRUE;\n}",
        "func_after": "gboolean\nflatpak_builtin_info (int argc, char **argv, GCancellable *cancellable, GError **error)\n{\n  g_autoptr(GOptionContext) context = NULL;\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n  g_autoptr(FlatpakDir) dir = NULL;\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autoptr(FlatpakDeploy) deploy = NULL;\n  g_autoptr(GFile) deploy_dir = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  const char *commit = NULL;\n  const char *alt_id = NULL;\n  const char *eol;\n  const char *eol_rebase;\n  const char *name;\n  const char *summary;\n  const char *version;\n  const char *license;\n  const char *pref = NULL;\n  const char *default_branch = NULL;\n  const char *origin = NULL;\n  guint64 size;\n  gboolean search_all = FALSE;\n  gboolean first = TRUE;\n  FlatpakKinds kinds;\n  const char *path;\n  g_autofree char *formatted_size = NULL;\n  gboolean friendly = TRUE;\n  g_autofree const char **subpaths = NULL;\n  int len = 0;\n  int rows, cols;\n  int width;\n\n  context = g_option_context_new (_(\"NAME [BRANCH] - Get info about an installed app or runtime\"));\n  g_option_context_set_translation_domain (context, GETTEXT_PACKAGE);\n\n  if (!flatpak_option_context_parse (context, options, &argc, &argv, FLATPAK_BUILTIN_FLAG_NO_DIR, NULL, cancellable, error))\n    return FALSE;\n\n  if (argc < 2)\n    return usage_error (context, _(\"NAME must be specified\"), error);\n  pref = argv[1];\n\n  if (argc >= 3)\n    default_branch = argv[2];\n\n  if (argc > 3)\n    return usage_error (context, _(\"Too many arguments\"), error);\n\n  kinds = FLATPAK_KINDS_APP | FLATPAK_KINDS_RUNTIME;\n\n  if (!opt_user && !opt_system && opt_installations == NULL)\n    search_all = TRUE;\n\n  dir = flatpak_find_installed_pref (pref, kinds, opt_arch, default_branch,\n                                     search_all, opt_user, opt_system, opt_installations,\n                                     &ref, cancellable, error);\n  if (dir == NULL)\n    return FALSE;\n\n  deploy_data = flatpak_dir_get_deploy_data (dir, ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);\n  if (deploy_data == NULL)\n    return FALSE;\n\n  deploy = flatpak_dir_load_deployed (dir, ref, NULL, cancellable, error);\n  if (deploy == NULL)\n    return FALSE;\n\n  commit = flatpak_deploy_data_get_commit (deploy_data);\n  alt_id = flatpak_deploy_data_get_alt_id (deploy_data);\n  origin = flatpak_deploy_data_get_origin (deploy_data);\n  size = flatpak_deploy_data_get_installed_size (deploy_data);\n  formatted_size = g_format_size (size);\n  deploy_dir = flatpak_deploy_get_dir (deploy);\n  path = flatpak_file_get_path_cached (deploy_dir);\n  subpaths = flatpak_deploy_data_get_subpaths (deploy_data);\n  eol = flatpak_deploy_data_get_eol (deploy_data);\n  eol_rebase = flatpak_deploy_data_get_eol_rebase (deploy_data);\n  name = flatpak_deploy_data_get_appdata_name (deploy_data);\n  summary = flatpak_deploy_data_get_appdata_summary (deploy_data);\n  version = flatpak_deploy_data_get_appdata_version (deploy_data);\n  license = flatpak_deploy_data_get_appdata_license (deploy_data);\n\n  metakey = flatpak_deploy_get_metadata (deploy);\n\n  if (opt_show_ref || opt_show_origin || opt_show_commit || opt_show_size || opt_show_metadata || opt_show_permissions ||\n      opt_file_access || opt_show_location || opt_show_runtime || opt_show_sdk)\n    friendly = FALSE;\n\n  if (friendly)\n    {\n      g_autoptr(GVariant) commit_v = NULL;\n      VarMetadataRef commit_metadata;\n      guint64 timestamp;\n      g_autofree char *formatted_timestamp = NULL;\n      const gchar *subject = NULL;\n      g_autofree char *parent = NULL;\n      g_autofree char *latest = NULL;\n      const char *xa_metadata = NULL;\n      const char *collection_id = NULL;\n\n      flatpak_get_window_size (&rows, &cols);\n\n      if (name)\n        {\n          if (summary)\n            print_wrapped (MIN (cols, 80), \"\\n%s - %s\\n\", name, summary);\n          else\n            print_wrapped (MIN (cols, 80), \"\\n%s\\n\", name);\n        }\n\n      latest = flatpak_dir_read_latest (dir, origin, flatpak_decomposed_get_ref (ref), NULL, NULL, NULL);\n      if (latest == NULL)\n        latest = g_strdup (_(\"ref not present in origin\"));\n\n      if (ostree_repo_load_commit (flatpak_dir_get_repo (dir), commit, &commit_v, NULL, NULL))\n        {\n          VarCommitRef var_commit = var_commit_from_gvariant (commit_v);\n\n          subject = var_commit_get_subject (var_commit);\n          parent = ostree_commit_get_parent (commit_v);\n          timestamp = ostree_commit_get_timestamp (commit_v);\n\n          formatted_timestamp = format_timestamp (timestamp);\n\n          commit_metadata = var_commit_get_metadata (var_commit);\n          xa_metadata = var_metadata_lookup_string (commit_metadata, \"xa.metadata\", NULL);\n          if (xa_metadata == NULL)\n            g_printerr (_(\"Warning: Commit has no flatpak metadata\\n\"));\n\n          collection_id = var_metadata_lookup_string (commit_metadata, \"ostree.collection-binding\", NULL);\n        }\n\n      len = 0;\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Ref:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Arch:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Branch:\"), -1));\n      if (version)\n        len = MAX (len, g_utf8_strlen (_(\"Version:\"), -1));\n      if (license)\n        len = MAX (len, g_utf8_strlen (_(\"License:\"), -1));\n      if (collection_id != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Collection:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installation:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      if (flatpak_decomposed_is_app (ref))\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Runtime:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Sdk:\"), -1));\n        }\n      if (formatted_timestamp)\n        len = MAX (len, g_utf8_strlen (_(\"Date:\"), -1));\n      if (subject)\n        len = MAX (len, g_utf8_strlen (_(\"Subject:\"), -1));\n      if (strcmp (commit, latest) != 0)\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Active commit:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Latest commit:\"), -1));\n        }\n      else\n        len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      if (parent)\n        len = MAX (len, g_utf8_strlen (_(\"Parent:\"), -1));\n      if (alt_id)\n        len = MAX (len, g_utf8_strlen (_(\"Alt-id:\"), -1));\n      if (eol)\n        len = MAX (len, g_utf8_strlen (_(\"End-of-life:\"), -1));\n      if (eol_rebase)\n        len = MAX (len, g_utf8_strlen (_(\"End-of-life-rebase:\"), -1));\n      if (subpaths[0] != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Subdirectories:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Extension:\"), -1));\n\n      width = cols - (len + 1);\n\n      print_aligned_take (len, _(\"ID:\"), flatpak_decomposed_dup_id (ref));\n      print_aligned (len, _(\"Ref:\"), flatpak_decomposed_get_ref (ref));\n      print_aligned_take (len, _(\"Arch:\"), flatpak_decomposed_dup_arch (ref));\n      print_aligned_take (len, _(\"Branch:\"), flatpak_decomposed_dup_branch (ref));\n      if (version)\n        print_aligned (len, _(\"Version:\"), version);\n      if (license)\n        print_aligned (len, _(\"License:\"), license);\n      print_aligned (len, _(\"Origin:\"), origin ? origin : \"-\");\n      if (collection_id)\n        print_aligned (len, _(\"Collection:\"), collection_id);\n      print_aligned (len, _(\"Installation:\"), flatpak_dir_get_name_cached (dir));\n      print_aligned (len, _(\"Installed:\"), formatted_size);\n      if (flatpak_decomposed_is_app (ref))\n        {\n          g_autofree char *runtime = NULL;\n          runtime = g_key_file_get_string (metakey,\n                                           FLATPAK_METADATA_GROUP_APPLICATION,\n                                           FLATPAK_METADATA_KEY_RUNTIME,\n                                           error);\n          print_aligned (len, _(\"Runtime:\"), runtime ? runtime : \"-\");\n        }\n      if (flatpak_decomposed_is_app (ref))\n        {\n          g_autofree char *sdk = NULL;\n          sdk = g_key_file_get_string (metakey,\n                                       FLATPAK_METADATA_GROUP_APPLICATION,\n                                       FLATPAK_METADATA_KEY_SDK,\n                                       error);\n          print_aligned (len, _(\"Sdk:\"), sdk ? sdk : \"-\");\n        }\n      g_print (\"\\n\");\n\n      if (strcmp (commit, latest) != 0)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (commit, width);\n          print_aligned (len, _(\"Active commit:\"), formatted_commit);\n          g_free (formatted_commit);\n          formatted_commit = ellipsize_string (latest, width);\n          print_aligned (len, _(\"Latest commit:\"), formatted_commit);\n        }\n      else\n        {\n          g_autofree char *formatted_commit = ellipsize_string (commit, width);\n          print_aligned (len, _(\"Commit:\"), formatted_commit);\n        }\n      if (parent)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (parent, width);\n          print_aligned (len, _(\"Parent:\"), formatted_commit);\n        }\n      if (subject)\n        print_aligned (len, _(\"Subject:\"), subject);\n      if (formatted_timestamp)\n        print_aligned (len, _(\"Date:\"), formatted_timestamp);\n      if (subpaths[0] != NULL)\n        {\n          g_autofree char *s = g_strjoinv (\",\", (char **) subpaths);\n          print_aligned (len, _(\"Subdirectories:\"), s);\n        }\n\n      if (alt_id)\n        print_aligned (len, _(\"Alt-id:\"), alt_id);\n      if (eol)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol, width);\n          print_aligned (len, _(\"End-of-life:\"), formatted_eol);\n        }\n      if (eol_rebase)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol_rebase, width);\n          print_aligned (len, _(\"End-of-life-rebase:\"), formatted_eol);\n        }\n    }\n  else\n    {\n      if (opt_show_ref)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", flatpak_decomposed_get_ref (ref));\n        }\n\n      if (opt_show_origin)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", origin ? origin : \"-\");\n        }\n\n      if (opt_show_commit)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", commit);\n        }\n\n      if (opt_show_size)\n        {\n          maybe_print_space (&first);\n          g_print (\"%\" G_GUINT64_FORMAT, size);\n        }\n\n      if (opt_show_location)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", path);\n        }\n\n      if (opt_show_runtime)\n        {\n          g_autofree char *runtime = NULL;\n          maybe_print_space (&first);\n\n          runtime = g_key_file_get_string (metakey,\n                                           flatpak_decomposed_get_kind_metadata_group (ref),\n                                           FLATPAK_METADATA_KEY_RUNTIME,\n                                           NULL);\n          g_print (\"%s\", runtime ? runtime : \"-\");\n        }\n\n      if (opt_show_sdk)\n        {\n          g_autofree char *sdk = NULL;\n          maybe_print_space (&first);\n\n          sdk = g_key_file_get_string (metakey,\n                                       flatpak_decomposed_get_kind_metadata_group (ref),\n                                       FLATPAK_METADATA_KEY_SDK,\n                                       NULL);\n          g_print (\"%s\", sdk ? sdk : \"-\");\n        }\n\n      if (!first)\n        g_print (\"\\n\");\n\n      if (opt_show_metadata)\n        {\n          g_autoptr(GFile) file = NULL;\n          g_autofree char *data = NULL;\n          gsize data_size;\n\n          file = g_file_get_child (deploy_dir, \"metadata\");\n\n          if (!g_file_load_contents (file, cancellable, &data, &data_size, NULL, error))\n            return FALSE;\n\n          flatpak_print_escaped_string (data,\n                                        FLATPAK_ESCAPE_ALLOW_NEWLINES\n                                        | FLATPAK_ESCAPE_DO_NOT_QUOTE);\n        }\n\n      if (opt_show_permissions || opt_file_access)\n        {\n          g_autoptr(FlatpakContext) app_context = NULL;\n          g_autoptr(GKeyFile) keyfile = NULL;\n          g_autofree gchar *contents = NULL;\n\n          app_context = flatpak_context_load_for_deploy (deploy, error);\n          if (app_context == NULL)\n            return FALSE;\n\n          if (opt_show_permissions)\n            {\n              keyfile = g_key_file_new ();\n              flatpak_context_save_metadata (app_context, TRUE, keyfile);\n              contents = g_key_file_to_data (keyfile, NULL, error);\n              if (contents == NULL)\n                return FALSE;\n\n              flatpak_print_escaped_string (contents,\n                                            FLATPAK_ESCAPE_ALLOW_NEWLINES\n                                            | FLATPAK_ESCAPE_DO_NOT_QUOTE);\n            }\n\n          if (opt_file_access)\n            {\n              g_autofree char *id = flatpak_decomposed_dup_id (ref);\n              g_autoptr(FlatpakExports) exports = flatpak_context_get_exports (app_context, id);\n              FlatpakFilesystemMode mode;\n\n              mode = flatpak_exports_path_get_mode (exports, opt_file_access);\n              if (mode == 0)\n                g_print (\"hidden\\n\");\n              else if (mode == FLATPAK_FILESYSTEM_MODE_READ_ONLY)\n                g_print (\"read-only\\n\");\n              else\n                g_print (\"read-write\\n\");\n            }\n        }\n    }\n\n  if (opt_show_extensions)\n    {\n      GList *extensions, *l;\n      g_autofree char *ref_arch = flatpak_decomposed_dup_arch (ref);\n      g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);\n\n      len = MAX (len, g_utf8_strlen (_(\"Extension:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Origin:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Subpaths:\"), -1));\n\n      flatpak_get_window_size (&rows, &cols);\n      width = cols - (len + 1);\n\n      extensions = flatpak_list_extensions (metakey, ref_arch, ref_branch);\n      for (l = extensions; l; l = l->next)\n        {\n          FlatpakExtension *ext = l->data;\n          g_autofree const char **ext_subpaths = NULL;\n          g_autoptr(GBytes) ext_deploy_data = NULL;\n          g_autofree char *formatted = NULL;\n          g_autofree char *ext_formatted_size = NULL;\n          g_autofree char *formatted_commit = NULL;\n\n          if (ext->is_unmaintained)\n            {\n              formatted_commit = g_strdup (_(\"unmaintained\"));\n              origin = NULL;\n              size = 0;\n              ext_formatted_size = g_strdup (_(\"unknown\"));\n              ext_subpaths = NULL;\n            }\n          else\n            {\n              ext_deploy_data = flatpak_dir_get_deploy_data (dir, ext->ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);\n              if (ext_deploy_data == NULL)\n                return FALSE;\n\n              commit = flatpak_deploy_data_get_commit (ext_deploy_data);\n              formatted_commit = ellipsize_string (commit, width);\n              origin = flatpak_deploy_data_get_origin (ext_deploy_data);\n              size = flatpak_deploy_data_get_installed_size (ext_deploy_data);\n              formatted = g_format_size (size);\n              ext_subpaths = flatpak_deploy_data_get_subpaths (ext_deploy_data);\n              if (ext_subpaths && ext_subpaths[0] && size > 0)\n                ext_formatted_size = g_strconcat (\"<\", formatted, NULL);\n              else\n                ext_formatted_size = g_steal_pointer (&formatted);\n            }\n\n          g_print (\"\\n\");\n          print_aligned (len, _(\"Extension:\"), flatpak_decomposed_get_ref (ext->ref));\n          print_aligned (len, _(\"ID:\"), ext->id);\n          print_aligned (len, _(\"Origin:\"), origin ? origin : \"-\");\n          print_aligned (len, _(\"Commit:\"), formatted_commit);\n          print_aligned (len, _(\"Installed:\"), ext_formatted_size);\n\n          if (ext_subpaths && ext_subpaths[0])\n            {\n              g_autofree char *s = g_strjoinv (\",\", (char **) ext_subpaths);\n              print_aligned (len, _(\"Subpaths:\"), s);\n            }\n        }\n\n      g_list_free_full (extensions, (GDestroyNotify) flatpak_extension_free);\n    }\n\n  return TRUE;\n}",
        "description": "In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, Flatpak allowed attackers to publish applications with elevated permissions while hiding these permissions from users through the `flatpak(1)` command-line interface. This was achieved by setting other permissions to crafted values containing non-printable control characters such as `ESC`. A fix is available in the mentioned versions. As a workaround, users are advised to use a graphical user interface like GNOME Software instead of the command-line interface, or to only install applications from trusted maintainers.",
        "commit": "It is important to escape special characters in permissions and metadata to prevent manipulation of the permissions list's appearance."
    },
    {
        "cwe": "CWE-662",
        "func_name": "torvalds/do_fontx_ioctl",
        "score": 0.7294511795043945,
        "func_before": "static inline int do_fontx_ioctl(int cmd,\n\t\tstruct consolefontdesc __user *user_cfd,\n\t\tstruct console_font_op *op)\n{\n\tstruct consolefontdesc cfdarg;\n\tint i;\n\n\tif (copy_from_user(&cfdarg, user_cfd, sizeof(struct consolefontdesc)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase PIO_FONTX:\n\t\top->op = KD_FONT_OP_SET;\n\t\top->flags = KD_FONT_FLAG_OLD;\n\t\top->width = 8;\n\t\top->height = cfdarg.charheight;\n\t\top->charcount = cfdarg.charcount;\n\t\top->data = cfdarg.chardata;\n\t\treturn con_font_op(vc_cons[fg_console].d, op);\n\tcase GIO_FONTX: {\n\t\top->op = KD_FONT_OP_GET;\n\t\top->flags = KD_FONT_FLAG_OLD;\n\t\top->width = 8;\n\t\top->height = cfdarg.charheight;\n\t\top->charcount = cfdarg.charcount;\n\t\top->data = cfdarg.chardata;\n\t\ti = con_font_op(vc_cons[fg_console].d, op);\n\t\tif (i)\n\t\t\treturn i;\n\t\tcfdarg.charheight = op->height;\n\t\tcfdarg.charcount = op->charcount;\n\t\tif (copy_to_user(user_cfd, &cfdarg, sizeof(struct consolefontdesc)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}",
        "func_after": "static inline int do_fontx_ioctl(struct vc_data *vc, int cmd,\n\t\tstruct consolefontdesc __user *user_cfd,\n\t\tstruct console_font_op *op)\n{\n\tstruct consolefontdesc cfdarg;\n\tint i;\n\n\tif (copy_from_user(&cfdarg, user_cfd, sizeof(struct consolefontdesc)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase PIO_FONTX:\n\t\top->op = KD_FONT_OP_SET;\n\t\top->flags = KD_FONT_FLAG_OLD;\n\t\top->width = 8;\n\t\top->height = cfdarg.charheight;\n\t\top->charcount = cfdarg.charcount;\n\t\top->data = cfdarg.chardata;\n\t\treturn con_font_op(vc, op);\n\n\tcase GIO_FONTX:\n\t\top->op = KD_FONT_OP_GET;\n\t\top->flags = KD_FONT_FLAG_OLD;\n\t\top->width = 8;\n\t\top->height = cfdarg.charheight;\n\t\top->charcount = cfdarg.charcount;\n\t\top->data = cfdarg.chardata;\n\t\ti = con_font_op(vc, op);\n\t\tif (i)\n\t\t\treturn i;\n\t\tcfdarg.charheight = op->height;\n\t\tcfdarg.charcount = op->charcount;\n\t\tif (copy_to_user(user_cfd, &cfdarg, sizeof(struct consolefontdesc)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}",
        "description": "A flaw was identified in the Linux Kernel where access to a global variable used for managing the foreground console is not adequately synchronized, resulting in a use-after-free error within the function responsible for font operations.",
        "commit": "Some font-related terminal I/O control operations previously utilized the current foreground virtual console (VC) for their execution. This practice has been discontinued to address a data race condition involving the `fg_console` variable. Notably, both Michael Ellerman and Jiri Slaby have observed that these I/O control operations are deprecated and should have been removed earlier. They suggest that most systems now use the `KDFONTOP` ioctl instead. Additionally, Michael notes that BusyBox's `loadfont` program transitioned to using `KDFONTOP` precisely due to this bug, which was identified approximately 12 years ago."
    },
    {
        "cwe": "CWE-122",
        "func_name": "vim/find_help_tags",
        "score": 0.7459341883659363,
        "func_before": "int\nfind_help_tags(\n    char_u\t*arg,\n    int\t\t*num_matches,\n    char_u\t***matches,\n    int\t\tkeep_lang)\n{\n    char_u\t*s, *d;\n    int\t\ti;\n    // Specific tags that either have a specific replacement or won't go\n    // through the generic rules.\n    static char *(except_tbl[][2]) = {\n\t{\"*\",\t\t\"star\"},\n\t{\"g*\",\t\t\"gstar\"},\n\t{\"[*\",\t\t\"[star\"},\n\t{\"]*\",\t\t\"]star\"},\n\t{\":*\",\t\t\":star\"},\n\t{\"/*\",\t\t\"/star\"},\n\t{\"/\\\\*\",\t\"/\\\\\\\\star\"},\n\t{\"\\\"*\",\t\t\"quotestar\"},\n\t{\"**\",\t\t\"starstar\"},\n\t{\"cpo-*\",\t\"cpo-star\"},\n\t{\"/\\\\(\\\\)\",\t\"/\\\\\\\\(\\\\\\\\)\"},\n\t{\"/\\\\%(\\\\)\",\t\"/\\\\\\\\%(\\\\\\\\)\"},\n\t{\"?\",\t\t\"?\"},\n\t{\"??\",\t\t\"??\"},\n\t{\":?\",\t\t\":?\"},\n\t{\"?<CR>\",\t\"?<CR>\"},\n\t{\"g?\",\t\t\"g?\"},\n\t{\"g?g?\",\t\"g?g?\"},\n\t{\"g??\",\t\t\"g??\"},\n\t{\"-?\",\t\t\"-?\"},\n\t{\"q?\",\t\t\"q?\"},\n\t{\"v_g?\",\t\"v_g?\"},\n\t{\"/\\\\?\",\t\"/\\\\\\\\?\"},\n\t{\"/\\\\z(\\\\)\",\t\"/\\\\\\\\z(\\\\\\\\)\"},\n\t{\"\\\\=\",\t\t\"\\\\\\\\=\"},\n\t{\":s\\\\=\",\t\":s\\\\\\\\=\"},\n\t{\"[count]\",\t\"\\\\[count]\"},\n\t{\"[quotex]\",\t\"\\\\[quotex]\"},\n\t{\"[range]\",\t\"\\\\[range]\"},\n\t{\":[range]\",\t\":\\\\[range]\"},\n\t{\"[pattern]\",\t\"\\\\[pattern]\"},\n\t{\"\\\\|\",\t\t\"\\\\\\\\bar\"},\n\t{\"\\\\%$\",\t\"/\\\\\\\\%\\\\$\"},\n\t{\"s/\\\\~\",\t\"s/\\\\\\\\\\\\~\"},\n\t{\"s/\\\\U\",\t\"s/\\\\\\\\U\"},\n\t{\"s/\\\\L\",\t\"s/\\\\\\\\L\"},\n\t{\"s/\\\\1\",\t\"s/\\\\\\\\1\"},\n\t{\"s/\\\\2\",\t\"s/\\\\\\\\2\"},\n\t{\"s/\\\\3\",\t\"s/\\\\\\\\3\"},\n\t{\"s/\\\\9\",\t\"s/\\\\\\\\9\"},\n\t{NULL, NULL}\n    };\n    static char *(expr_table[]) = {\"!=?\", \"!~?\", \"<=?\", \"<?\", \"==?\", \"=~?\",\n\t\t\t\t   \">=?\", \">?\", \"is?\", \"isnot?\"};\n    int flags;\n\n    d = IObuff;\t\t    // assume IObuff is long enough!\n    d[0] = NUL;\n\n    if (STRNICMP(arg, \"expr-\", 5) == 0)\n    {\n\t// When the string starting with \"expr-\" and containing '?' and matches\n\t// the table, it is taken literally (but ~ is escaped).  Otherwise '?'\n\t// is recognized as a wildcard.\n\tfor (i = (int)ARRAY_LENGTH(expr_table); --i >= 0; )\n\t    if (STRCMP(arg + 5, expr_table[i]) == 0)\n\t    {\n\t\tint si = 0, di = 0;\n\n\t\tfor (;;)\n\t\t{\n\t\t    if (arg[si] == '~')\n\t\t\td[di++] = '\\\\';\n\t\t    d[di++] = arg[si];\n\t\t    if (arg[si] == NUL)\n\t\t\tbreak;\n\t\t    ++si;\n\t\t}\n\t\tbreak;\n\t    }\n    }\n    else\n    {\n\t// Recognize a few exceptions to the rule.  Some strings that contain\n\t// '*'are changed to \"star\", otherwise '*' is recognized as a wildcard.\n\tfor (i = 0; except_tbl[i][0] != NULL; ++i)\n\t    if (STRCMP(arg, except_tbl[i][0]) == 0)\n\t    {\n\t\tSTRCPY(d, except_tbl[i][1]);\n\t\tbreak;\n\t    }\n    }\n\n    if (d[0] == NUL)\t// no match in table\n    {\n\t// Replace \"\\S\" with \"/\\\\S\", etc.  Otherwise every tag is matched.\n\t// Also replace \"\\%^\" and \"\\%(\", they match every tag too.\n\t// Also \"\\zs\", \"\\z1\", etc.\n\t// Also \"\\@<\", \"\\@=\", \"\\@<=\", etc.\n\t// And also \"\\_$\" and \"\\_^\".\n\tif (arg[0] == '\\\\'\n\t\t&& ((arg[1] != NUL && arg[2] == NUL)\n\t\t    || (vim_strchr((char_u *)\"%_z@\", arg[1]) != NULL\n\t\t\t\t\t\t\t   && arg[2] != NUL)))\n\t{\n\t    STRCPY(d, \"/\\\\\\\\\");\n\t    STRCPY(d + 3, arg + 1);\n\t    // Check for \"/\\\\_$\", should be \"/\\\\_\\$\"\n\t    if (d[3] == '_' && d[4] == '$')\n\t\tSTRCPY(d + 4, \"\\\\$\");\n\t}\n\telse\n\t{\n\t  // Replace:\n\t  // \"[:...:]\" with \"\\[:...:]\"\n\t  // \"[++...]\" with \"\\[++...]\"\n\t  // \"\\{\" with \"\\\\{\"\t\t   -- matching \"} \\}\"\n\t    if ((arg[0] == '[' && (arg[1] == ':'\n\t\t\t || (arg[1] == '+' && arg[2] == '+')))\n\t\t    || (arg[0] == '\\\\' && arg[1] == '{'))\n\t      *d++ = '\\\\';\n\n\t  // If tag starts with \"('\", skip the \"(\". Fixes CTRL-] on ('option'.\n\t  if (*arg == '(' && arg[1] == '\\'')\n\t      arg++;\n\t  for (s = arg; *s; ++s)\n\t  {\n\t    // Replace \"|\" with \"bar\" and '\"' with \"quote\" to match the name of\n\t    // the tags for these commands.\n\t    // Replace \"*\" with \".*\" and \"?\" with \".\" to match command line\n\t    // completion.\n\t    // Insert a backslash before '~', '$' and '.' to avoid their\n\t    // special meaning.\n\t    if (d - IObuff > IOSIZE - 10)\t// getting too long!?\n\t\tbreak;\n\t    switch (*s)\n\t    {\n\t\tcase '|':   STRCPY(d, \"bar\");\n\t\t\t    d += 3;\n\t\t\t    continue;\n\t\tcase '\"':   STRCPY(d, \"quote\");\n\t\t\t    d += 5;\n\t\t\t    continue;\n\t\tcase '*':   *d++ = '.';\n\t\t\t    break;\n\t\tcase '?':   *d++ = '.';\n\t\t\t    continue;\n\t\tcase '$':\n\t\tcase '.':\n\t\tcase '~':   *d++ = '\\\\';\n\t\t\t    break;\n\t    }\n\n\t    // Replace \"^x\" by \"CTRL-X\". Don't do this for \"^_\" to make\n\t    // \":help i_^_CTRL-D\" work.\n\t    // Insert '-' before and after \"CTRL-X\" when applicable.\n\t    if (*s < ' ' || (*s == '^' && s[1] && (ASCII_ISALPHA(s[1])\n\t\t\t   || vim_strchr((char_u *)\"?@[\\\\]^\", s[1]) != NULL)))\n\t    {\n\t\tif (d > IObuff && d[-1] != '_' && d[-1] != '\\\\')\n\t\t    *d++ = '_';\t\t// prepend a '_' to make x_CTRL-x\n\t\tSTRCPY(d, \"CTRL-\");\n\t\td += 5;\n\t\tif (*s < ' ')\n\t\t{\n#ifdef EBCDIC\n\t\t    *d++ = CtrlChar(*s);\n#else\n\t\t    *d++ = *s + '@';\n#endif\n\t\t    if (d[-1] == '\\\\')\n\t\t\t*d++ = '\\\\';\t// double a backslash\n\t\t}\n\t\telse\n\t\t    *d++ = *++s;\n\t\tif (s[1] != NUL && s[1] != '_')\n\t\t    *d++ = '_';\t\t// append a '_'\n\t\tcontinue;\n\t    }\n\t    else if (*s == '^')\t\t// \"^\" or \"CTRL-^\" or \"^_\"\n\t\t*d++ = '\\\\';\n\n\t    // Insert a backslash before a backslash after a slash, for search\n\t    // pattern tags: \"/\\|\" --> \"/\\\\|\".\n\t    else if (s[0] == '\\\\' && s[1] != '\\\\'\n\t\t\t\t\t       && *arg == '/' && s == arg + 1)\n\t\t*d++ = '\\\\';\n\n\t    // \"CTRL-\\_\" -> \"CTRL-\\\\_\" to avoid the special meaning of \"\\_\" in\n\t    // \"CTRL-\\_CTRL-N\"\n\t    if (STRNICMP(s, \"CTRL-\\\\_\", 7) == 0)\n\t    {\n\t\tSTRCPY(d, \"CTRL-\\\\\\\\\");\n\t\td += 7;\n\t\ts += 6;\n\t    }\n\n\t    *d++ = *s;\n\n\t    // If tag contains \"({\" or \"([\", tag terminates at the \"(\".\n\t    // This is for help on functions, e.g.: abs({expr}).\n\t    if (*s == '(' && (s[1] == '{' || s[1] =='['))\n\t\tbreak;\n\n\t    // If tag starts with ', toss everything after a second '. Fixes\n\t    // CTRL-] on 'option'. (would include the trailing '.').\n\t    if (*s == '\\'' && s > arg && *arg == '\\'')\n\t\tbreak;\n\t    // Also '{' and '}'.\n\t    if (*s == '}' && s > arg && *arg == '{')\n\t\tbreak;\n\t  }\n\t  *d = NUL;\n\n\t  if (*IObuff == '`')\n\t  {\n\t      if (d > IObuff + 2 && d[-1] == '`')\n\t      {\n\t\t  // remove the backticks from `command`\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-2] = NUL;\n\t      }\n\t      else if (d > IObuff + 3 && d[-2] == '`' && d[-1] == ',')\n\t      {\n\t\t  // remove the backticks and comma from `command`,\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-3] = NUL;\n\t      }\n\t      else if (d > IObuff + 4 && d[-3] == '`'\n\t\t\t\t\t     && d[-2] == '\\\\' && d[-1] == '.')\n\t      {\n\t\t  // remove the backticks and dot from `command`\\.\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-4] = NUL;\n\t      }\n\t  }\n\t}\n    }\n\n    *matches = (char_u **)\"\";\n    *num_matches = 0;\n    flags = TAG_HELP | TAG_REGEXP | TAG_NAMES | TAG_VERBOSE | TAG_NO_TAGFUNC;\n    if (keep_lang)\n\tflags |= TAG_KEEP_LANG;\n    if (find_tags(IObuff, num_matches, matches, flags, (int)MAXCOL, NULL) == OK\n\t    && *num_matches > 0)\n    {\n\t// Sort the matches found on the heuristic number that is after the\n\t// tag name.\n\tqsort((void *)*matches, (size_t)*num_matches,\n\t\t\t\t\t      sizeof(char_u *), help_compare);\n\t// Delete more than TAG_MANY to reduce the size of the listing.\n\twhile (*num_matches > TAG_MANY)\n\t    vim_free((*matches)[--*num_matches]);\n    }\n    return OK;\n}",
        "func_after": "int\nfind_help_tags(\n    char_u\t*arg,\n    int\t\t*num_matches,\n    char_u\t***matches,\n    int\t\tkeep_lang)\n{\n    char_u\t*s, *d;\n    int\t\ti;\n    // Specific tags that either have a specific replacement or won't go\n    // through the generic rules.\n    static char *(except_tbl[][2]) = {\n\t{\"*\",\t\t\"star\"},\n\t{\"g*\",\t\t\"gstar\"},\n\t{\"[*\",\t\t\"[star\"},\n\t{\"]*\",\t\t\"]star\"},\n\t{\":*\",\t\t\":star\"},\n\t{\"/*\",\t\t\"/star\"},\n\t{\"/\\\\*\",\t\"/\\\\\\\\star\"},\n\t{\"\\\"*\",\t\t\"quotestar\"},\n\t{\"**\",\t\t\"starstar\"},\n\t{\"cpo-*\",\t\"cpo-star\"},\n\t{\"/\\\\(\\\\)\",\t\"/\\\\\\\\(\\\\\\\\)\"},\n\t{\"/\\\\%(\\\\)\",\t\"/\\\\\\\\%(\\\\\\\\)\"},\n\t{\"?\",\t\t\"?\"},\n\t{\"??\",\t\t\"??\"},\n\t{\":?\",\t\t\":?\"},\n\t{\"?<CR>\",\t\"?<CR>\"},\n\t{\"g?\",\t\t\"g?\"},\n\t{\"g?g?\",\t\"g?g?\"},\n\t{\"g??\",\t\t\"g??\"},\n\t{\"-?\",\t\t\"-?\"},\n\t{\"q?\",\t\t\"q?\"},\n\t{\"v_g?\",\t\"v_g?\"},\n\t{\"/\\\\?\",\t\"/\\\\\\\\?\"},\n\t{\"/\\\\z(\\\\)\",\t\"/\\\\\\\\z(\\\\\\\\)\"},\n\t{\"\\\\=\",\t\t\"\\\\\\\\=\"},\n\t{\":s\\\\=\",\t\":s\\\\\\\\=\"},\n\t{\"[count]\",\t\"\\\\[count]\"},\n\t{\"[quotex]\",\t\"\\\\[quotex]\"},\n\t{\"[range]\",\t\"\\\\[range]\"},\n\t{\":[range]\",\t\":\\\\[range]\"},\n\t{\"[pattern]\",\t\"\\\\[pattern]\"},\n\t{\"\\\\|\",\t\t\"\\\\\\\\bar\"},\n\t{\"\\\\%$\",\t\"/\\\\\\\\%\\\\$\"},\n\t{\"s/\\\\~\",\t\"s/\\\\\\\\\\\\~\"},\n\t{\"s/\\\\U\",\t\"s/\\\\\\\\U\"},\n\t{\"s/\\\\L\",\t\"s/\\\\\\\\L\"},\n\t{\"s/\\\\1\",\t\"s/\\\\\\\\1\"},\n\t{\"s/\\\\2\",\t\"s/\\\\\\\\2\"},\n\t{\"s/\\\\3\",\t\"s/\\\\\\\\3\"},\n\t{\"s/\\\\9\",\t\"s/\\\\\\\\9\"},\n\t{NULL, NULL}\n    };\n    static char *(expr_table[]) = {\"!=?\", \"!~?\", \"<=?\", \"<?\", \"==?\", \"=~?\",\n\t\t\t\t   \">=?\", \">?\", \"is?\", \"isnot?\"};\n    int flags;\n\n    d = IObuff;\t\t    // assume IObuff is long enough!\n    d[0] = NUL;\n\n    if (STRNICMP(arg, \"expr-\", 5) == 0)\n    {\n\t// When the string starting with \"expr-\" and containing '?' and matches\n\t// the table, it is taken literally (but ~ is escaped).  Otherwise '?'\n\t// is recognized as a wildcard.\n\tfor (i = (int)ARRAY_LENGTH(expr_table); --i >= 0; )\n\t    if (STRCMP(arg + 5, expr_table[i]) == 0)\n\t    {\n\t\tint si = 0, di = 0;\n\n\t\tfor (;;)\n\t\t{\n\t\t    if (arg[si] == '~')\n\t\t\td[di++] = '\\\\';\n\t\t    d[di++] = arg[si];\n\t\t    if (arg[si] == NUL)\n\t\t\tbreak;\n\t\t    ++si;\n\t\t}\n\t\tbreak;\n\t    }\n    }\n    else\n    {\n\t// Recognize a few exceptions to the rule.  Some strings that contain\n\t// '*'are changed to \"star\", otherwise '*' is recognized as a wildcard.\n\tfor (i = 0; except_tbl[i][0] != NULL; ++i)\n\t    if (STRCMP(arg, except_tbl[i][0]) == 0)\n\t    {\n\t\tSTRCPY(d, except_tbl[i][1]);\n\t\tbreak;\n\t    }\n    }\n\n    if (d[0] == NUL)\t// no match in table\n    {\n\t// Replace \"\\S\" with \"/\\\\S\", etc.  Otherwise every tag is matched.\n\t// Also replace \"\\%^\" and \"\\%(\", they match every tag too.\n\t// Also \"\\zs\", \"\\z1\", etc.\n\t// Also \"\\@<\", \"\\@=\", \"\\@<=\", etc.\n\t// And also \"\\_$\" and \"\\_^\".\n\tif (arg[0] == '\\\\'\n\t\t&& ((arg[1] != NUL && arg[2] == NUL)\n\t\t    || (vim_strchr((char_u *)\"%_z@\", arg[1]) != NULL\n\t\t\t\t\t\t\t   && arg[2] != NUL)))\n\t{\n\t    vim_snprintf((char *)d, IOSIZE, \"/\\\\\\\\%s\", arg + 1);\n\t    // Check for \"/\\\\_$\", should be \"/\\\\_\\$\"\n\t    if (d[3] == '_' && d[4] == '$')\n\t\tSTRCPY(d + 4, \"\\\\$\");\n\t}\n\telse\n\t{\n\t  // Replace:\n\t  // \"[:...:]\" with \"\\[:...:]\"\n\t  // \"[++...]\" with \"\\[++...]\"\n\t  // \"\\{\" with \"\\\\{\"\t\t   -- matching \"} \\}\"\n\t    if ((arg[0] == '[' && (arg[1] == ':'\n\t\t\t || (arg[1] == '+' && arg[2] == '+')))\n\t\t    || (arg[0] == '\\\\' && arg[1] == '{'))\n\t      *d++ = '\\\\';\n\n\t  // If tag starts with \"('\", skip the \"(\". Fixes CTRL-] on ('option'.\n\t  if (*arg == '(' && arg[1] == '\\'')\n\t      arg++;\n\t  for (s = arg; *s; ++s)\n\t  {\n\t    // Replace \"|\" with \"bar\" and '\"' with \"quote\" to match the name of\n\t    // the tags for these commands.\n\t    // Replace \"*\" with \".*\" and \"?\" with \".\" to match command line\n\t    // completion.\n\t    // Insert a backslash before '~', '$' and '.' to avoid their\n\t    // special meaning.\n\t    if (d - IObuff > IOSIZE - 10)\t// getting too long!?\n\t\tbreak;\n\t    switch (*s)\n\t    {\n\t\tcase '|':   STRCPY(d, \"bar\");\n\t\t\t    d += 3;\n\t\t\t    continue;\n\t\tcase '\"':   STRCPY(d, \"quote\");\n\t\t\t    d += 5;\n\t\t\t    continue;\n\t\tcase '*':   *d++ = '.';\n\t\t\t    break;\n\t\tcase '?':   *d++ = '.';\n\t\t\t    continue;\n\t\tcase '$':\n\t\tcase '.':\n\t\tcase '~':   *d++ = '\\\\';\n\t\t\t    break;\n\t    }\n\n\t    // Replace \"^x\" by \"CTRL-X\". Don't do this for \"^_\" to make\n\t    // \":help i_^_CTRL-D\" work.\n\t    // Insert '-' before and after \"CTRL-X\" when applicable.\n\t    if (*s < ' ' || (*s == '^' && s[1] && (ASCII_ISALPHA(s[1])\n\t\t\t   || vim_strchr((char_u *)\"?@[\\\\]^\", s[1]) != NULL)))\n\t    {\n\t\tif (d > IObuff && d[-1] != '_' && d[-1] != '\\\\')\n\t\t    *d++ = '_';\t\t// prepend a '_' to make x_CTRL-x\n\t\tSTRCPY(d, \"CTRL-\");\n\t\td += 5;\n\t\tif (*s < ' ')\n\t\t{\n#ifdef EBCDIC\n\t\t    *d++ = CtrlChar(*s);\n#else\n\t\t    *d++ = *s + '@';\n#endif\n\t\t    if (d[-1] == '\\\\')\n\t\t\t*d++ = '\\\\';\t// double a backslash\n\t\t}\n\t\telse\n\t\t    *d++ = *++s;\n\t\tif (s[1] != NUL && s[1] != '_')\n\t\t    *d++ = '_';\t\t// append a '_'\n\t\tcontinue;\n\t    }\n\t    else if (*s == '^')\t\t// \"^\" or \"CTRL-^\" or \"^_\"\n\t\t*d++ = '\\\\';\n\n\t    // Insert a backslash before a backslash after a slash, for search\n\t    // pattern tags: \"/\\|\" --> \"/\\\\|\".\n\t    else if (s[0] == '\\\\' && s[1] != '\\\\'\n\t\t\t\t\t       && *arg == '/' && s == arg + 1)\n\t\t*d++ = '\\\\';\n\n\t    // \"CTRL-\\_\" -> \"CTRL-\\\\_\" to avoid the special meaning of \"\\_\" in\n\t    // \"CTRL-\\_CTRL-N\"\n\t    if (STRNICMP(s, \"CTRL-\\\\_\", 7) == 0)\n\t    {\n\t\tSTRCPY(d, \"CTRL-\\\\\\\\\");\n\t\td += 7;\n\t\ts += 6;\n\t    }\n\n\t    *d++ = *s;\n\n\t    // If tag contains \"({\" or \"([\", tag terminates at the \"(\".\n\t    // This is for help on functions, e.g.: abs({expr}).\n\t    if (*s == '(' && (s[1] == '{' || s[1] =='['))\n\t\tbreak;\n\n\t    // If tag starts with ', toss everything after a second '. Fixes\n\t    // CTRL-] on 'option'. (would include the trailing '.').\n\t    if (*s == '\\'' && s > arg && *arg == '\\'')\n\t\tbreak;\n\t    // Also '{' and '}'.\n\t    if (*s == '}' && s > arg && *arg == '{')\n\t\tbreak;\n\t  }\n\t  *d = NUL;\n\n\t  if (*IObuff == '`')\n\t  {\n\t      if (d > IObuff + 2 && d[-1] == '`')\n\t      {\n\t\t  // remove the backticks from `command`\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-2] = NUL;\n\t      }\n\t      else if (d > IObuff + 3 && d[-2] == '`' && d[-1] == ',')\n\t      {\n\t\t  // remove the backticks and comma from `command`,\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-3] = NUL;\n\t      }\n\t      else if (d > IObuff + 4 && d[-3] == '`'\n\t\t\t\t\t     && d[-2] == '\\\\' && d[-1] == '.')\n\t      {\n\t\t  // remove the backticks and dot from `command`\\.\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-4] = NUL;\n\t      }\n\t  }\n\t}\n    }\n\n    *matches = (char_u **)\"\";\n    *num_matches = 0;\n    flags = TAG_HELP | TAG_REGEXP | TAG_NAMES | TAG_VERBOSE | TAG_NO_TAGFUNC;\n    if (keep_lang)\n\tflags |= TAG_KEEP_LANG;\n    if (find_tags(IObuff, num_matches, matches, flags, (int)MAXCOL, NULL) == OK\n\t    && *num_matches > 0)\n    {\n\t// Sort the matches found on the heuristic number that is after the\n\t// tag name.\n\tqsort((void *)*matches, (size_t)*num_matches,\n\t\t\t\t\t      sizeof(char_u *), help_compare);\n\t// Delete more than TAG_MANY to reduce the size of the listing.\n\twhile (*num_matches > TAG_MANY)\n\t    vim_free((*matches)[--*num_matches]);\n    }\n    return OK;\n}",
        "description": "vim is susceptible to a Heap-based Buffer Overflow vulnerability.",
        "commit": "output: \"A buffer overflow vulnerability was identified in the handling of long help arguments. The solution implemented involves using snprintf() to prevent such overflows.\""
    }
]