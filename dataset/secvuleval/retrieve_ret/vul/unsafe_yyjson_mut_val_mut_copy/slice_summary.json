[
    {
        "cwe": "CWE-1284",
        "func_name": "Samsung/crypto_bignum_allocate",
        "score": 0.7488757967948914,
        "func_before": "struct bignum *crypto_bignum_allocate(size_t size_bits)\n{\n\tsize_t sz = mpa_StaticVarSizeInU32(size_bits) *\tsizeof(uint32_t);\n\tstruct mpa_numbase_struct *bn = calloc(1, sz);\n\n\tif (!bn)\n\t\treturn NULL;\n\tbn->alloc = sz - MPA_NUMBASE_METADATA_SIZE_IN_U32 * sizeof(uint32_t);\n\treturn (struct bignum *)bn;\n}",
        "func_after": "struct bignum *crypto_bignum_allocate(size_t size_bits)\n{\n\tsize_t sz = mpa_StaticVarSizeInU32(size_bits) *\tsizeof(uint32_t);\n\t// struct mpa_numbase_struct *bn = calloc(1, sz);\n\tstruct mpa_numbase_struct *bn= TEE_Malloc(sz, TEE_MALLOC_FILL_ZERO);\n\tif (!bn)\n\t\treturn NULL;\n\tbn->alloc = sz - MPA_NUMBASE_METADATA_SIZE_IN_U32 * sizeof(uint32_t);\n\treturn (struct bignum *)bn;\n}",
        "description": "The function `tee_obj_free` in Samsung mTower through version 0.3.0 enables a trusted application to cause a Denial of Service (DoS) by calling the function `TEE_AllocateOperation` with a disrupted heap layout, which is associated with `utee_cryp_obj_alloc`.",
        "commit": "A vulnerability has been addressed in a software system, specifically identified by CVE-2022-40761."
    },
    {
        "cwe": "CWE-116",
        "func_name": "flatpak/flatpak_context_load_metadata",
        "score": 0.7558092474937439,
        "func_before": "gboolean\nflatpak_context_load_metadata (FlatpakContext *context,\n                               GKeyFile       *metakey,\n                               GError        **error)\n{\n  gboolean remove;\n  g_auto(GStrv) groups = NULL;\n  gsize i;\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SHARED, NULL))\n    {\n      g_auto(GStrv) shares = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                         FLATPAK_METADATA_KEY_SHARED, NULL, error);\n      if (shares == NULL)\n        return FALSE;\n\n      for (i = 0; shares[i] != NULL; i++)\n        {\n          FlatpakContextShares share;\n\n          share = flatpak_context_share_from_string (parse_negated (shares[i], &remove), NULL);\n          if (share == 0)\n            g_info (\"Unknown share type %s\", shares[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_shares (context, share);\n              else\n                flatpak_context_add_shares (context, share);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SOCKETS, NULL))\n    {\n      g_auto(GStrv) sockets = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                          FLATPAK_METADATA_KEY_SOCKETS, NULL, error);\n      if (sockets == NULL)\n        return FALSE;\n\n      for (i = 0; sockets[i] != NULL; i++)\n        {\n          FlatpakContextSockets socket = flatpak_context_socket_from_string (parse_negated (sockets[i], &remove), NULL);\n          if (socket == 0)\n            g_info (\"Unknown socket type %s\", sockets[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_sockets (context, socket);\n              else\n                flatpak_context_add_sockets (context, socket);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_DEVICES, NULL))\n    {\n      g_auto(GStrv) devices = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                          FLATPAK_METADATA_KEY_DEVICES, NULL, error);\n      if (devices == NULL)\n        return FALSE;\n\n\n      for (i = 0; devices[i] != NULL; i++)\n        {\n          FlatpakContextDevices device = flatpak_context_device_from_string (parse_negated (devices[i], &remove), NULL);\n          if (device == 0)\n            g_info (\"Unknown device type %s\", devices[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_devices (context, device);\n              else\n                flatpak_context_add_devices (context, device);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FEATURES, NULL))\n    {\n      g_auto(GStrv) features = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                           FLATPAK_METADATA_KEY_FEATURES, NULL, error);\n      if (features == NULL)\n        return FALSE;\n\n\n      for (i = 0; features[i] != NULL; i++)\n        {\n          FlatpakContextFeatures feature = flatpak_context_feature_from_string (parse_negated (features[i], &remove), NULL);\n          if (feature == 0)\n            g_info (\"Unknown feature type %s\", features[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_features (context, feature);\n              else\n                flatpak_context_add_features (context, feature);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FILESYSTEMS, NULL))\n    {\n      g_auto(GStrv) filesystems = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                              FLATPAK_METADATA_KEY_FILESYSTEMS, NULL, error);\n      if (filesystems == NULL)\n        return FALSE;\n\n      for (i = 0; filesystems[i] != NULL; i++)\n        {\n          const char *fs = parse_negated (filesystems[i], &remove);\n          g_autofree char *filesystem = NULL;\n          FlatpakFilesystemMode mode;\n\n          if (!flatpak_context_parse_filesystem (fs, remove,\n                                                 &filesystem, &mode, NULL))\n            g_info (\"Unknown filesystem type %s\", filesystems[i]);\n          else\n            {\n              g_assert (mode == FLATPAK_FILESYSTEM_MODE_NONE || !remove);\n              flatpak_context_take_filesystem (context, g_steal_pointer (&filesystem), mode);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_PERSISTENT, NULL))\n    {\n      g_auto(GStrv) persistent = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                             FLATPAK_METADATA_KEY_PERSISTENT, NULL, error);\n      if (persistent == NULL)\n        return FALSE;\n\n      for (i = 0; persistent[i] != NULL; i++)\n        flatpak_context_set_persistent (context, persistent[i]);\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, key, NULL);\n          FlatpakPolicy policy;\n\n          if (!flatpak_verify_dbus_name (key, error))\n            return FALSE;\n\n          policy = flatpak_policy_from_string (value, NULL);\n          if ((int) policy != -1)\n            flatpak_context_set_session_bus_policy (context, key, policy);\n        }\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, key, NULL);\n          FlatpakPolicy policy;\n\n          if (!flatpak_verify_dbus_name (key, error))\n            return FALSE;\n\n          policy = flatpak_policy_from_string (value, NULL);\n          if ((int) policy != -1)\n            flatpak_context_set_system_bus_policy (context, key, policy);\n        }\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, key, NULL);\n\n          flatpak_context_set_env_var (context, key, value);\n        }\n    }\n\n  /* unset-environment is higher precedence than Environment, so that\n   * we can put unset keys in both places. Old versions of Flatpak will\n   * interpret the empty string as unset; new versions will obey\n   * unset-environment. */\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT, NULL))\n    {\n      g_auto(GStrv) vars = NULL;\n      gsize vars_count;\n\n      vars = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                         FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT,\n                                         &vars_count, error);\n\n      if (vars == NULL)\n        return FALSE;\n\n      for (i = 0; i < vars_count; i++)\n        {\n          const char *var = vars[i];\n\n          flatpak_context_set_env_var (context, var, NULL);\n        }\n    }\n\n  groups = g_key_file_get_groups (metakey, NULL);\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      const char *group = groups[i];\n      const char *subsystem;\n      int j;\n\n      if (g_str_has_prefix (group, FLATPAK_METADATA_GROUP_PREFIX_POLICY))\n        {\n          g_auto(GStrv) keys = NULL;\n          subsystem = group + strlen (FLATPAK_METADATA_GROUP_PREFIX_POLICY);\n          keys = g_key_file_get_keys (metakey, group, NULL, NULL);\n          for (j = 0; keys != NULL && keys[j] != NULL; j++)\n            {\n              const char *key = keys[j];\n              g_autofree char *policy_key = g_strdup_printf (\"%s.%s\", subsystem, key);\n              g_auto(GStrv) values = NULL;\n              int k;\n\n              values = g_key_file_get_string_list (metakey, group, key, NULL, NULL);\n              for (k = 0; values != NULL && values[k] != NULL; k++)\n                flatpak_context_apply_generic_policy (context, policy_key,\n                                                      values[k]);\n            }\n        }\n    }\n\n  return TRUE;\n}",
        "func_after": "gboolean\nflatpak_context_load_metadata (FlatpakContext *context,\n                               GKeyFile       *metakey,\n                               GError        **error)\n{\n  gboolean remove;\n  g_auto(GStrv) groups = NULL;\n  gsize i;\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SHARED, NULL))\n    {\n      g_auto(GStrv) shares = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                         FLATPAK_METADATA_KEY_SHARED, NULL, error);\n      if (shares == NULL)\n        return FALSE;\n\n      for (i = 0; shares[i] != NULL; i++)\n        {\n          FlatpakContextShares share;\n\n          share = flatpak_context_share_from_string (parse_negated (shares[i], &remove), NULL);\n          if (share == 0)\n            g_info (\"Unknown share type %s\", shares[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_shares (context, share);\n              else\n                flatpak_context_add_shares (context, share);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SOCKETS, NULL))\n    {\n      g_auto(GStrv) sockets = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                          FLATPAK_METADATA_KEY_SOCKETS, NULL, error);\n      if (sockets == NULL)\n        return FALSE;\n\n      for (i = 0; sockets[i] != NULL; i++)\n        {\n          FlatpakContextSockets socket = flatpak_context_socket_from_string (parse_negated (sockets[i], &remove), NULL);\n          if (socket == 0)\n            g_info (\"Unknown socket type %s\", sockets[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_sockets (context, socket);\n              else\n                flatpak_context_add_sockets (context, socket);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_DEVICES, NULL))\n    {\n      g_auto(GStrv) devices = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                          FLATPAK_METADATA_KEY_DEVICES, NULL, error);\n      if (devices == NULL)\n        return FALSE;\n\n\n      for (i = 0; devices[i] != NULL; i++)\n        {\n          FlatpakContextDevices device = flatpak_context_device_from_string (parse_negated (devices[i], &remove), NULL);\n          if (device == 0)\n            g_info (\"Unknown device type %s\", devices[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_devices (context, device);\n              else\n                flatpak_context_add_devices (context, device);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FEATURES, NULL))\n    {\n      g_auto(GStrv) features = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                           FLATPAK_METADATA_KEY_FEATURES, NULL, error);\n      if (features == NULL)\n        return FALSE;\n\n\n      for (i = 0; features[i] != NULL; i++)\n        {\n          FlatpakContextFeatures feature = flatpak_context_feature_from_string (parse_negated (features[i], &remove), NULL);\n          if (feature == 0)\n            g_info (\"Unknown feature type %s\", features[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_features (context, feature);\n              else\n                flatpak_context_add_features (context, feature);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FILESYSTEMS, NULL))\n    {\n      g_auto(GStrv) filesystems = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                              FLATPAK_METADATA_KEY_FILESYSTEMS, NULL, error);\n      if (filesystems == NULL)\n        return FALSE;\n\n      for (i = 0; filesystems[i] != NULL; i++)\n        {\n          const char *fs = parse_negated (filesystems[i], &remove);\n          g_autofree char *filesystem = NULL;\n          g_autoptr(GError) local_error = NULL;\n          FlatpakFilesystemMode mode;\n\n          if (!flatpak_context_parse_filesystem (fs, remove,\n                                                 &filesystem, &mode, &local_error))\n            {\n              if (g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA))\n                {\n                  /* Invalid characters, so just hard-fail. */\n                  g_propagate_error (error, g_steal_pointer (&local_error));\n                  return FALSE;\n                }\n              else\n                {\n                  g_info (\"Unknown filesystem type %s\", filesystems[i]);\n                  g_clear_error (&local_error);\n                }\n            }\n          else\n            {\n              g_assert (mode == FLATPAK_FILESYSTEM_MODE_NONE || !remove);\n              flatpak_context_take_filesystem (context, g_steal_pointer (&filesystem), mode);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_PERSISTENT, NULL))\n    {\n      g_auto(GStrv) persistent = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                             FLATPAK_METADATA_KEY_PERSISTENT, NULL, error);\n      if (persistent == NULL)\n        return FALSE;\n\n      for (i = 0; persistent[i] != NULL; i++)\n        if (!flatpak_context_set_persistent (context, persistent[i], error))\n          return FALSE;\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, key, NULL);\n          FlatpakPolicy policy;\n\n          if (!flatpak_verify_dbus_name (key, error))\n            return FALSE;\n\n          policy = flatpak_policy_from_string (value, NULL);\n          if ((int) policy != -1)\n            flatpak_context_set_session_bus_policy (context, key, policy);\n        }\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, key, NULL);\n          FlatpakPolicy policy;\n\n          if (!flatpak_verify_dbus_name (key, error))\n            return FALSE;\n\n          policy = flatpak_policy_from_string (value, NULL);\n          if ((int) policy != -1)\n            flatpak_context_set_system_bus_policy (context, key, policy);\n        }\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, key, NULL);\n\n          flatpak_context_set_env_var (context, key, value);\n        }\n    }\n\n  /* unset-environment is higher precedence than Environment, so that\n   * we can put unset keys in both places. Old versions of Flatpak will\n   * interpret the empty string as unset; new versions will obey\n   * unset-environment. */\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT, NULL))\n    {\n      g_auto(GStrv) vars = NULL;\n      gsize vars_count;\n\n      vars = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                         FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT,\n                                         &vars_count, error);\n\n      if (vars == NULL)\n        return FALSE;\n\n      for (i = 0; i < vars_count; i++)\n        {\n          const char *var = vars[i];\n\n          flatpak_context_set_env_var (context, var, NULL);\n        }\n    }\n\n  groups = g_key_file_get_groups (metakey, NULL);\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      const char *group = groups[i];\n      const char *subsystem;\n      int j;\n\n      if (g_str_has_prefix (group, FLATPAK_METADATA_GROUP_PREFIX_POLICY))\n        {\n          g_auto(GStrv) keys = NULL;\n          subsystem = group + strlen (FLATPAK_METADATA_GROUP_PREFIX_POLICY);\n          keys = g_key_file_get_keys (metakey, group, NULL, NULL);\n          for (j = 0; keys != NULL && keys[j] != NULL; j++)\n            {\n              const char *key = keys[j];\n              g_autofree char *policy_key = g_strdup_printf (\"%s.%s\", subsystem, key);\n              g_auto(GStrv) values = NULL;\n              int k;\n\n              values = g_key_file_get_string_list (metakey, group, key, NULL, NULL);\n              for (k = 0; values != NULL && values[k] != NULL; k++)\n                flatpak_context_apply_generic_policy (context, policy_key,\n                                                      values[k]);\n            }\n        }\n    }\n\n  return TRUE;\n}",
        "description": "In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, Flatpak allowed attackers to publish applications with elevated permissions while hiding these permissions from users through the `flatpak(1)` command-line interface. This was achieved by setting other permissions to crafted values containing non-printable control characters such as `ESC`. A fix is available in the mentioned versions. As a workaround, users are advised to use a graphical user interface like GNOME Software instead of the command-line interface, or to only install applications from trusted maintainers.",
        "commit": "Rejecting paths containing special characters provided to --filesystem/--persist options to mitigate potential security risks associated with displaying such text."
    },
    {
        "cwe": "CWE-94",
        "func_name": "binutils-gdb/setup_group",
        "score": 0.7547373175621033,
        "func_before": "static bfd_boolean\nsetup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)\n{\n  unsigned int num_group = elf_tdata (abfd)->num_group;\n\n  /* If num_group is zero, read in all SHT_GROUP sections.  The count\n     is set to -1 if there are no SHT_GROUP sections.  */\n  if (num_group == 0)\n    {\n      unsigned int i, shnum;\n\n      /* First count the number of groups.  If we have a SHT_GROUP\n\t section with just a flag word (ie. sh_size is 4), ignore it.  */\n      shnum = elf_numsections (abfd);\n      num_group = 0;\n\n#define IS_VALID_GROUP_SECTION_HEADER(shdr, minsize)\t\\\n\t(   (shdr)->sh_type == SHT_GROUP\t\t\\\n\t && (shdr)->sh_size >= minsize\t\t\t\\\n\t && (shdr)->sh_entsize == GRP_ENTRY_SIZE\t\\\n\t && ((shdr)->sh_size % GRP_ENTRY_SIZE) == 0)\n\n      for (i = 0; i < shnum; i++)\n\t{\n\t  Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];\n\n\t  if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))\n\t    num_group += 1;\n\t}\n\n      if (num_group == 0)\n\t{\n\t  num_group = (unsigned) -1;\n\t  elf_tdata (abfd)->num_group = num_group;\n\t}\n      else\n\t{\n\t  /* We keep a list of elf section headers for group sections,\n\t     so we can find them quickly.  */\n\t  bfd_size_type amt;\n\n\t  elf_tdata (abfd)->num_group = num_group;\n\t  elf_tdata (abfd)->group_sect_ptr = (Elf_Internal_Shdr **)\n              bfd_alloc2 (abfd, num_group, sizeof (Elf_Internal_Shdr *));\n\t  if (elf_tdata (abfd)->group_sect_ptr == NULL)\n\t    return FALSE;\n\n\t  num_group = 0;\n\t  for (i = 0; i < shnum; i++)\n\t    {\n\t      Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];\n\n\t      if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))\n\t\t{\n\t\t  unsigned char *src;\n\t\t  Elf_Internal_Group *dest;\n\n\t\t  /* Add to list of sections.  */\n\t\t  elf_tdata (abfd)->group_sect_ptr[num_group] = shdr;\n\t\t  num_group += 1;\n\n\t\t  /* Read the raw contents.  */\n\t\t  BFD_ASSERT (sizeof (*dest) >= 4);\n\t\t  amt = shdr->sh_size * sizeof (*dest) / 4;\n\t\t  shdr->contents = (unsigned char *)\n                      bfd_alloc2 (abfd, shdr->sh_size, sizeof (*dest) / 4);\n\t\t  /* PR binutils/4110: Handle corrupt group headers.  */\n\t\t  if (shdr->contents == NULL)\n\t\t    {\n\t\t      _bfd_error_handler\n\t\t\t(_(\"%B: Corrupt size field in group section header: 0x%lx\"), abfd, shdr->sh_size);\n\t\t      bfd_set_error (bfd_error_bad_value);\n\t\t      return FALSE;\n\t\t    }\n\n\t\t  memset (shdr->contents, 0, amt);\n\n\t\t  if (bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0\n\t\t      || (bfd_bread (shdr->contents, shdr->sh_size, abfd)\n\t\t\t  != shdr->sh_size))\n\t\t    return FALSE;\n\n\t\t  /* Translate raw contents, a flag word followed by an\n\t\t     array of elf section indices all in target byte order,\n\t\t     to the flag word followed by an array of elf section\n\t\t     pointers.  */\n\t\t  src = shdr->contents + shdr->sh_size;\n\t\t  dest = (Elf_Internal_Group *) (shdr->contents + amt);\n\t\t  while (1)\n\t\t    {\n\t\t      unsigned int idx;\n\n\t\t      src -= 4;\n\t\t      --dest;\n\t\t      idx = H_GET_32 (abfd, src);\n\t\t      if (src == shdr->contents)\n\t\t\t{\n\t\t\t  dest->flags = idx;\n\t\t\t  if (shdr->bfd_section != NULL && (idx & GRP_COMDAT))\n\t\t\t    shdr->bfd_section->flags\n\t\t\t      |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;\n\t\t\t  break;\n\t\t\t}\n\t\t      if (idx >= shnum)\n\t\t\t{\n\t\t\t  ((*_bfd_error_handler)\n\t\t\t   (_(\"%B: invalid SHT_GROUP entry\"), abfd));\n\t\t\t  idx = 0;\n\t\t\t}\n\t\t      dest->shdr = elf_elfsections (abfd)[idx];\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n  if (num_group != (unsigned) -1)\n    {\n      unsigned int i;\n\n      for (i = 0; i < num_group; i++)\n\t{\n\t  Elf_Internal_Shdr *shdr = elf_tdata (abfd)->group_sect_ptr[i];\n\t  Elf_Internal_Group *idx = (Elf_Internal_Group *) shdr->contents;\n\t  unsigned int n_elt = shdr->sh_size / 4;\n\n\t  /* Look through this group's sections to see if current\n\t     section is a member.  */\n\t  while (--n_elt != 0)\n\t    if ((++idx)->shdr == hdr)\n\t      {\n\t\tasection *s = NULL;\n\n\t\t/* We are a member of this group.  Go looking through\n\t\t   other members to see if any others are linked via\n\t\t   next_in_group.  */\n\t\tidx = (Elf_Internal_Group *) shdr->contents;\n\t\tn_elt = shdr->sh_size / 4;\n\t\twhile (--n_elt != 0)\n\t\t  if ((s = (++idx)->shdr->bfd_section) != NULL\n\t\t      && elf_next_in_group (s) != NULL)\n\t\t    break;\n\t\tif (n_elt != 0)\n\t\t  {\n\t\t    /* Snarf the group name from other member, and\n\t\t       insert current section in circular list.  */\n\t\t    elf_group_name (newsect) = elf_group_name (s);\n\t\t    elf_next_in_group (newsect) = elf_next_in_group (s);\n\t\t    elf_next_in_group (s) = newsect;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    const char *gname;\n\n\t\t    gname = group_signature (abfd, shdr);\n\t\t    if (gname == NULL)\n\t\t      return FALSE;\n\t\t    elf_group_name (newsect) = gname;\n\n\t\t    /* Start a circular list with one element.  */\n\t\t    elf_next_in_group (newsect) = newsect;\n\t\t  }\n\n\t\t/* If the group section has been created, point to the\n\t\t   new member.  */\n\t\tif (shdr->bfd_section != NULL)\n\t\t  elf_next_in_group (shdr->bfd_section) = newsect;\n\n\t\ti = num_group - 1;\n\t\tbreak;\n\t      }\n\t}\n    }\n\n  if (elf_group_name (newsect) == NULL)\n    {\n      (*_bfd_error_handler) (_(\"%B: no group info for section %A\"),\n\t\t\t     abfd, newsect);\n    }\n  return TRUE;\n}",
        "func_after": "static bfd_boolean\nsetup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)\n{\n  unsigned int num_group = elf_tdata (abfd)->num_group;\n\n  /* If num_group is zero, read in all SHT_GROUP sections.  The count\n     is set to -1 if there are no SHT_GROUP sections.  */\n  if (num_group == 0)\n    {\n      unsigned int i, shnum;\n\n      /* First count the number of groups.  If we have a SHT_GROUP\n\t section with just a flag word (ie. sh_size is 4), ignore it.  */\n      shnum = elf_numsections (abfd);\n      num_group = 0;\n\n#define IS_VALID_GROUP_SECTION_HEADER(shdr, minsize)\t\\\n\t(   (shdr)->sh_type == SHT_GROUP\t\t\\\n\t && (shdr)->sh_size >= minsize\t\t\t\\\n\t && (shdr)->sh_entsize == GRP_ENTRY_SIZE\t\\\n\t && ((shdr)->sh_size % GRP_ENTRY_SIZE) == 0)\n\n      for (i = 0; i < shnum; i++)\n\t{\n\t  Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];\n\n\t  if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))\n\t    num_group += 1;\n\t}\n\n      if (num_group == 0)\n\t{\n\t  num_group = (unsigned) -1;\n\t  elf_tdata (abfd)->num_group = num_group;\n\t}\n      else\n\t{\n\t  /* We keep a list of elf section headers for group sections,\n\t     so we can find them quickly.  */\n\t  bfd_size_type amt;\n\n\t  elf_tdata (abfd)->num_group = num_group;\n\t  elf_tdata (abfd)->group_sect_ptr = (Elf_Internal_Shdr **)\n              bfd_alloc2 (abfd, num_group, sizeof (Elf_Internal_Shdr *));\n\t  if (elf_tdata (abfd)->group_sect_ptr == NULL)\n\t    return FALSE;\n\n\t  num_group = 0;\n\t  for (i = 0; i < shnum; i++)\n\t    {\n\t      Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];\n\n\t      if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))\n\t\t{\n\t\t  unsigned char *src;\n\t\t  Elf_Internal_Group *dest;\n\n\t\t  /* Add to list of sections.  */\n\t\t  elf_tdata (abfd)->group_sect_ptr[num_group] = shdr;\n\t\t  num_group += 1;\n\n\t\t  /* Read the raw contents.  */\n\t\t  BFD_ASSERT (sizeof (*dest) >= 4);\n\t\t  amt = shdr->sh_size * sizeof (*dest) / 4;\n\t\t  shdr->contents = (unsigned char *)\n                      bfd_alloc2 (abfd, shdr->sh_size, sizeof (*dest) / 4);\n\t\t  /* PR binutils/4110: Handle corrupt group headers.  */\n\t\t  if (shdr->contents == NULL)\n\t\t    {\n\t\t      _bfd_error_handler\n\t\t\t(_(\"%B: corrupt size field in group section header: 0x%lx\"), abfd, shdr->sh_size);\n\t\t      bfd_set_error (bfd_error_bad_value);\n\t\t      -- num_group;\n\t\t      continue;\n\t\t    }\n\n\t\t  memset (shdr->contents, 0, amt);\n\n\t\t  if (bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0\n\t\t      || (bfd_bread (shdr->contents, shdr->sh_size, abfd)\n\t\t\t  != shdr->sh_size))\n\t\t    {\n\t\t      _bfd_error_handler\n\t\t\t(_(\"%B: invalid size field in group section header: 0x%lx\"), abfd, shdr->sh_size);\n\t\t      bfd_set_error (bfd_error_bad_value);\n\t\t      -- num_group;\n\t\t      /* PR 17510: If the group contents are even partially\n\t\t\t corrupt, do not allow any of the contents to be used.  */\n\t\t      memset (shdr->contents, 0, amt);\n\t\t      continue;\n\t\t    }\n\t\t  \n\t\t  /* Translate raw contents, a flag word followed by an\n\t\t     array of elf section indices all in target byte order,\n\t\t     to the flag word followed by an array of elf section\n\t\t     pointers.  */\n\t\t  src = shdr->contents + shdr->sh_size;\n\t\t  dest = (Elf_Internal_Group *) (shdr->contents + amt);\n\t\t  while (1)\n\t\t    {\n\t\t      unsigned int idx;\n\n\t\t      src -= 4;\n\t\t      --dest;\n\t\t      idx = H_GET_32 (abfd, src);\n\t\t      if (src == shdr->contents)\n\t\t\t{\n\t\t\t  dest->flags = idx;\n\t\t\t  if (shdr->bfd_section != NULL && (idx & GRP_COMDAT))\n\t\t\t    shdr->bfd_section->flags\n\t\t\t      |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;\n\t\t\t  break;\n\t\t\t}\n\t\t      if (idx >= shnum)\n\t\t\t{\n\t\t\t  ((*_bfd_error_handler)\n\t\t\t   (_(\"%B: invalid SHT_GROUP entry\"), abfd));\n\t\t\t  idx = 0;\n\t\t\t}\n\t\t      dest->shdr = elf_elfsections (abfd)[idx];\n\t\t    }\n\t\t}\n\t    }\n\n\t  /* PR 17510: Corrupt binaries might contain invalid groups.  */\n\t  if (num_group != (unsigned) elf_tdata (abfd)->num_group)\n\t    {\n\t      elf_tdata (abfd)->num_group = num_group;\n\n\t      /* If all groups are invalid then fail.  */\n\t      if (num_group == 0)\n\t\t{\n\t\t  elf_tdata (abfd)->group_sect_ptr = NULL;\n\t\t  elf_tdata (abfd)->num_group = num_group = -1;\n\t\t  (*_bfd_error_handler) (_(\"%B: no valid group sections found\"), abfd);\n\t\t  bfd_set_error (bfd_error_bad_value);\n\t\t}\n\t    }\n\t}\n    }\n\n  if (num_group != (unsigned) -1)\n    {\n      unsigned int i;\n\n      for (i = 0; i < num_group; i++)\n\t{\n\t  Elf_Internal_Shdr *shdr = elf_tdata (abfd)->group_sect_ptr[i];\n\t  Elf_Internal_Group *idx = (Elf_Internal_Group *) shdr->contents;\n\t  unsigned int n_elt = shdr->sh_size / 4;\n\n\t  /* Look through this group's sections to see if current\n\t     section is a member.  */\n\t  while (--n_elt != 0)\n\t    if ((++idx)->shdr == hdr)\n\t      {\n\t\tasection *s = NULL;\n\n\t\t/* We are a member of this group.  Go looking through\n\t\t   other members to see if any others are linked via\n\t\t   next_in_group.  */\n\t\tidx = (Elf_Internal_Group *) shdr->contents;\n\t\tn_elt = shdr->sh_size / 4;\n\t\twhile (--n_elt != 0)\n\t\t  if ((s = (++idx)->shdr->bfd_section) != NULL\n\t\t      && elf_next_in_group (s) != NULL)\n\t\t    break;\n\t\tif (n_elt != 0)\n\t\t  {\n\t\t    /* Snarf the group name from other member, and\n\t\t       insert current section in circular list.  */\n\t\t    elf_group_name (newsect) = elf_group_name (s);\n\t\t    elf_next_in_group (newsect) = elf_next_in_group (s);\n\t\t    elf_next_in_group (s) = newsect;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    const char *gname;\n\n\t\t    gname = group_signature (abfd, shdr);\n\t\t    if (gname == NULL)\n\t\t      return FALSE;\n\t\t    elf_group_name (newsect) = gname;\n\n\t\t    /* Start a circular list with one element.  */\n\t\t    elf_next_in_group (newsect) = newsect;\n\t\t  }\n\n\t\t/* If the group section has been created, point to the\n\t\t   new member.  */\n\t\tif (shdr->bfd_section != NULL)\n\t\t  elf_next_in_group (shdr->bfd_section) = newsect;\n\n\t\ti = num_group - 1;\n\t\tbreak;\n\t      }\n\t}\n    }\n\n  if (elf_group_name (newsect) == NULL)\n    {\n      (*_bfd_error_handler) (_(\"%B: no group info for section %A\"),\n\t\t\t     abfd, newsect);\n      return FALSE;\n    }\n  return TRUE;\n}",
        "description": "The `setup_group` function in the `bfd/elf.c` file of the GNU binutils library, versions 2.24 and earlier, is vulnerable to a denial of service (crash) and potential arbitrary code execution by remote attackers. This vulnerability arises from the handling of crafted section group headers in an ELF file.",
        "commit": "This patch addresses a potential security vulnerability in applications that utilize the bfd library to parse binaries. Specifically, it enhances the handling of corrupt section group headers, which could be exploited by maliciously crafted binaries to cause issues such as buffer overflows or other security breaches."
    },
    {
        "cwe": "CWE-354",
        "func_name": "systemd/journal_file_offline_close",
        "score": 0.7451342940330505,
        "func_before": "JournalFile* journal_file_offline_close(JournalFile *f) {\n        if (!f)\n                return NULL;\n\n#if HAVE_GCRYPT\n        /* Write the final tag */\n        if (JOURNAL_HEADER_SEALED(f->header) && journal_file_writable(f)) {\n                int r;\n\n                r = journal_file_append_tag(f);\n                if (r < 0)\n                        log_error_errno(r, \"Failed to append tag when closing journal: %m\");\n        }\n#endif\n\n        if (sd_event_source_get_enabled(f->post_change_timer, NULL) > 0)\n                journal_file_post_change(f);\n        sd_event_source_disable_unref(f->post_change_timer);\n\n        journal_file_set_offline(f, true);\n\n        return journal_file_close(f);\n}",
        "func_after": "JournalFile* journal_file_offline_close(JournalFile *f) {\n        if (!f)\n                return NULL;\n\n        journal_file_write_final_tag(f);\n\n        if (sd_event_source_get_enabled(f->post_change_timer, NULL) > 0)\n                journal_file_post_change(f);\n        sd_event_source_disable_unref(f->post_change_timer);\n\n        journal_file_set_offline(f, true);\n\n        return journal_file_close(f);\n}",
        "description": "An issue was discovered in systemd where an attacker can manipulate a sealed log file by truncating it and then resuming the log sealing process. This manipulation allows the attacker to alter the log content without detection, as integrity checks do not reveal any errors.",
        "commit": "The vulnerability involves an issue in the `journalctl` tool where empty log epochs are not properly sealed, allowing attackers to manipulate sealed logs by truncating them and continuing without detection during verification. This defect partially addresses CVE-2023-31438. To fully resolve the issue, the system should enforce that there is exactly one seal per epoch and prevent sealing until an epoch has ended. Additionally, a new journal-file flag, `HEADER_COMPATIBLE_SEALED_CONTINUOUS`, has been introduced to indicate continuous sealing and determine whether missing cryptographic epochs should result in warnings or errors."
    }
]