[
    {
        "cwe": "CWE-444",
        "func_name": "haproxy/http_parse_cont_len_header",
        "score": 0.7887842655181885,
        "func_before": "int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\n\tword.ptr = value->ptr - 1; // -1 for next loop's pre-increment\n\te = value->ptr + value->len;\n\n\twhile (++word.ptr < e) {\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\t*body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}",
        "func_after": "int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\n\tword.ptr = value->ptr;\n\te = value->ptr + value->len;\n\n\twhile (1) {\n\t\tif (word.ptr >= e) {\n\t\t\t/* empty header or empty value */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr))) {\n\t\t\tword.ptr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\t*body_len = cl;\n\t\t*value = word;\n\n\t\t/* Now either n==e and we're done, or n points to the comma,\n\t\t * and we skip it and continue.\n\t\t */\n\t\tif (n++ == e)\n\t\t\tbreak;\n\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}",
        "description": "HAProxy versions up to 2.0.32, 2.1.x, 2.2.x through 2.2.30, 2.3.x, 2.4.x through 2.4.23, 2.5.x, and 2.6.x before 2.6.15, 2.7.x before 2.7.10, and 2.8.x before 2.8.2 forward empty Content-Length headers, which violates RFC 9110 section 8.6. In rare scenarios, an HTTP/1 server positioned behind HAProxy may misinterpret the payload as an additional request.",
        "commit": "A vulnerability was identified in the HTTP content-length header parsing mechanism, where an empty or trailing-comma value could be misinterpreted as an absent header. This oversight allowed such headers to pass through to the backend server without proper validation, potentially exposing vulnerable servers to attacks. The risk varies based on the backend server's handling of content-length headers, but users relying on HAProxy to protect known-vulnerable servers are particularly at risk. A configuration-based workaround involves explicitly rejecting requests with empty content-length headers in the frontend settings. The permanent fix requires modifying the parser to ensure that only valid values are accepted, rejecting any empty values encountered. This change needs to be applied across all supported versions of the software. The modifications were made to functions such as `h1_parse_cont_len_header()` and `http_parse_cont_len_header()`, with additional considerations for compatibility with Lua and future deprecation plans. Comprehensive testing was conducted to validate these changes."
    },
    {
        "cwe": "CWE-388",
        "func_name": "torvalds/handle_exception",
        "score": 0.8103637099266052,
        "func_before": "static int handle_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 intr_info, ex_no, error_code;\n\tunsigned long cr2, rip, dr6;\n\tu32 vect_info;\n\tenum emulation_result er;\n\n\tvect_info = vmx->idt_vectoring_info;\n\tintr_info = vmx->exit_intr_info;\n\n\tif (is_machine_check(intr_info))\n\t\treturn handle_machine_check(vcpu);\n\n\tif ((intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR)\n\t\treturn 1;  /* already handled by vmx_vcpu_run() */\n\n\tif (is_no_device(intr_info)) {\n\t\tvmx_fpu_activate(vcpu);\n\t\treturn 1;\n\t}\n\n\tif (is_invalid_opcode(intr_info)) {\n\t\tif (is_guest_mode(vcpu)) {\n\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\ter = emulate_instruction(vcpu, EMULTYPE_TRAP_UD);\n\t\tif (er != EMULATE_DONE)\n\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\terror_code = 0;\n\tif (intr_info & INTR_INFO_DELIVER_CODE_MASK)\n\t\terror_code = vmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\n\t/*\n\t * The #PF with PFEC.RSVD = 1 indicates the guest is accessing\n\t * MMIO, it is better to report an internal error.\n\t * See the comments in vmx_handle_exit.\n\t */\n\tif ((vect_info & VECTORING_INFO_VALID_MASK) &&\n\t    !(is_page_fault(intr_info) && !(error_code & PFERR_RSVD_MASK))) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_SIMUL_EX;\n\t\tvcpu->run->internal.ndata = 3;\n\t\tvcpu->run->internal.data[0] = vect_info;\n\t\tvcpu->run->internal.data[1] = intr_info;\n\t\tvcpu->run->internal.data[2] = error_code;\n\t\treturn 0;\n\t}\n\n\tif (is_page_fault(intr_info)) {\n\t\t/* EPT won't cause page fault directly */\n\t\tBUG_ON(enable_ept);\n\t\tcr2 = vmcs_readl(EXIT_QUALIFICATION);\n\t\ttrace_kvm_page_fault(cr2, error_code);\n\n\t\tif (kvm_event_needs_reinjection(vcpu))\n\t\t\tkvm_mmu_unprotect_page_virt(vcpu, cr2);\n\t\treturn kvm_mmu_page_fault(vcpu, cr2, error_code, NULL, 0);\n\t}\n\n\tex_no = intr_info & INTR_INFO_VECTOR_MASK;\n\n\tif (vmx->rmode.vm86_active && rmode_exception(vcpu, ex_no))\n\t\treturn handle_rmode_exception(vcpu, ex_no, error_code);\n\n\tswitch (ex_no) {\n\tcase AC_VECTOR:\n\t\tkvm_queue_exception_e(vcpu, AC_VECTOR, error_code);\n\t\treturn 1;\n\tcase DB_VECTOR:\n\t\tdr6 = vmcs_readl(EXIT_QUALIFICATION);\n\t\tif (!(vcpu->guest_debug &\n\t\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))) {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= dr6 | DR6_RTM;\n\t\t\tif (!(dr6 & ~DR6_RESERVED)) /* icebp */\n\t\t\t\tskip_emulated_instruction(vcpu);\n\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1;\n\t\tkvm_run->debug.arch.dr7 = vmcs_readl(GUEST_DR7);\n\t\t/* fall through */\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject #BP from\n\t\t * user space while in guest debugging mode. Reading it for\n\t\t * #DB as well causes no harm, it is not used in that case.\n\t\t */\n\t\tvmx->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\trip = kvm_rip_read(vcpu);\n\t\tkvm_run->debug.arch.pc = vmcs_readl(GUEST_CS_BASE) + rip;\n\t\tkvm_run->debug.arch.exception = ex_no;\n\t\tbreak;\n\tdefault:\n\t\tkvm_run->exit_reason = KVM_EXIT_EXCEPTION;\n\t\tkvm_run->ex.exception = ex_no;\n\t\tkvm_run->ex.error_code = error_code;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
        "func_after": "static int handle_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 intr_info, ex_no, error_code;\n\tunsigned long cr2, rip, dr6;\n\tu32 vect_info;\n\tenum emulation_result er;\n\n\tvect_info = vmx->idt_vectoring_info;\n\tintr_info = vmx->exit_intr_info;\n\n\tif (is_machine_check(intr_info))\n\t\treturn handle_machine_check(vcpu);\n\n\tif (is_nmi(intr_info))\n\t\treturn 1;  /* already handled by vmx_vcpu_run() */\n\n\tif (is_no_device(intr_info)) {\n\t\tvmx_fpu_activate(vcpu);\n\t\treturn 1;\n\t}\n\n\tif (is_invalid_opcode(intr_info)) {\n\t\tif (is_guest_mode(vcpu)) {\n\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\ter = emulate_instruction(vcpu, EMULTYPE_TRAP_UD);\n\t\tif (er != EMULATE_DONE)\n\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\terror_code = 0;\n\tif (intr_info & INTR_INFO_DELIVER_CODE_MASK)\n\t\terror_code = vmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\n\t/*\n\t * The #PF with PFEC.RSVD = 1 indicates the guest is accessing\n\t * MMIO, it is better to report an internal error.\n\t * See the comments in vmx_handle_exit.\n\t */\n\tif ((vect_info & VECTORING_INFO_VALID_MASK) &&\n\t    !(is_page_fault(intr_info) && !(error_code & PFERR_RSVD_MASK))) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_SIMUL_EX;\n\t\tvcpu->run->internal.ndata = 3;\n\t\tvcpu->run->internal.data[0] = vect_info;\n\t\tvcpu->run->internal.data[1] = intr_info;\n\t\tvcpu->run->internal.data[2] = error_code;\n\t\treturn 0;\n\t}\n\n\tif (is_page_fault(intr_info)) {\n\t\t/* EPT won't cause page fault directly */\n\t\tBUG_ON(enable_ept);\n\t\tcr2 = vmcs_readl(EXIT_QUALIFICATION);\n\t\ttrace_kvm_page_fault(cr2, error_code);\n\n\t\tif (kvm_event_needs_reinjection(vcpu))\n\t\t\tkvm_mmu_unprotect_page_virt(vcpu, cr2);\n\t\treturn kvm_mmu_page_fault(vcpu, cr2, error_code, NULL, 0);\n\t}\n\n\tex_no = intr_info & INTR_INFO_VECTOR_MASK;\n\n\tif (vmx->rmode.vm86_active && rmode_exception(vcpu, ex_no))\n\t\treturn handle_rmode_exception(vcpu, ex_no, error_code);\n\n\tswitch (ex_no) {\n\tcase AC_VECTOR:\n\t\tkvm_queue_exception_e(vcpu, AC_VECTOR, error_code);\n\t\treturn 1;\n\tcase DB_VECTOR:\n\t\tdr6 = vmcs_readl(EXIT_QUALIFICATION);\n\t\tif (!(vcpu->guest_debug &\n\t\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))) {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= dr6 | DR6_RTM;\n\t\t\tif (!(dr6 & ~DR6_RESERVED)) /* icebp */\n\t\t\t\tskip_emulated_instruction(vcpu);\n\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1;\n\t\tkvm_run->debug.arch.dr7 = vmcs_readl(GUEST_DR7);\n\t\t/* fall through */\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject #BP from\n\t\t * user space while in guest debugging mode. Reading it for\n\t\t * #DB as well causes no harm, it is not used in that case.\n\t\t */\n\t\tvmx->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\trip = kvm_rip_read(vcpu);\n\t\tkvm_run->debug.arch.pc = vmcs_readl(GUEST_CS_BASE) + rip;\n\t\tkvm_run->debug.arch.exception = ex_no;\n\t\tbreak;\n\tdefault:\n\t\tkvm_run->exit_reason = KVM_EXIT_EXCEPTION;\n\t\tkvm_run->ex.exception = ex_no;\n\t\tkvm_run->ex.error_code = error_code;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
        "description": "The Linux kernel through version 4.9 improperly manages the #BP (Breakpoint) and #OF (Overflow) exceptions in the arch/x86/kvm/vmx.c file. This mismanagement allows guest operating system users to trigger a denial of service (resulting in a guest OS crash) by refusing to handle an exception thrown by an L2 guest.",
        "commit": "In the KVM (Kernel-based Virtual Machine) subsystem, specifically within the nested virtualization (nVMX) feature, there is an enhancement that allows the Level 1 (L1) hypervisor to intercept software exceptions such as Breakpoint (#BP) and Overflow (#OF). Previously, only hardware exceptions were forwarded to L1; now, when Level 2 (L2) exits to Level 0 (L0) due to an \"exception or NMI,\" these software exceptions should be handled by L1 if L1 has requested interception."
    },
    {
        "cwe": "CWE-20",
        "func_name": "torvalds/cifs_lookup",
        "score": 0.8123470544815063,
        "func_before": "struct dentry *\ncifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,\n\t    struct nameidata *nd)\n{\n\tint xid;\n\tint rc = 0; /* to get around spurious gcc warning, set to zero here */\n\t__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;\n\t__u16 fileHandle = 0;\n\tbool posix_open = false;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct cifsFileInfo *cfile;\n\tstruct inode *newInode = NULL;\n\tchar *full_path = NULL;\n\tstruct file *filp;\n\n\txid = GetXid();\n\n\tcFYI(1, \"parent inode = 0x%p name is: %s and dentry = 0x%p\",\n\t      parent_dir_inode, direntry->d_name.name, direntry);\n\n\t/* check whether path exists */\n\n\tcifs_sb = CIFS_SB(parent_dir_inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tFreeXid(xid);\n\t\treturn (struct dentry *)tlink;\n\t}\n\tpTcon = tlink_tcon(tlink);\n\n\t/*\n\t * Don't allow the separator character in a path component.\n\t * The VFS will not allow \"/\", but \"\\\" is allowed by posix.\n\t */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {\n\t\tint i;\n\t\tfor (i = 0; i < direntry->d_name.len; i++)\n\t\t\tif (direntry->d_name.name[i] == '\\\\') {\n\t\t\t\tcFYI(1, \"Invalid file name\");\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t}\n\n\t/*\n\t * O_EXCL: optimize away the lookup, but don't hash the dentry. Let\n\t * the VFS handle the create.\n\t */\n\tif (nd && (nd->flags & LOOKUP_EXCL)) {\n\t\td_instantiate(direntry, NULL);\n\t\trc = 0;\n\t\tgoto lookup_out;\n\t}\n\n\t/* can not grab the rename sem here since it would\n\tdeadlock in the cases (beginning of sys_rename itself)\n\tin which we already have the sb rename sem */\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto lookup_out;\n\t}\n\n\tif (direntry->d_inode != NULL) {\n\t\tcFYI(1, \"non-NULL inode in lookup\");\n\t} else {\n\t\tcFYI(1, \"NULL inode in lookup\");\n\t}\n\tcFYI(1, \"Full path: %s inode = 0x%p\", full_path, direntry->d_inode);\n\n\t/* Posix open is only called (at lookup time) for file create now.\n\t * For opens (rather than creates), because we do not know if it\n\t * is a file or directory yet, and current Samba no longer allows\n\t * us to do posix open on dirs, we could end up wasting an open call\n\t * on what turns out to be a dir. For file opens, we wait to call posix\n\t * open till cifs_open.  It could be added here (lookup) in the future\n\t * but the performance tradeoff of the extra network request when EISDIR\n\t * or EACCES is returned would have to be weighed against the 50%\n\t * reduction in network traffic in the other paths.\n\t */\n\tif (pTcon->unix_ext) {\n\t\tif (nd && !(nd->flags & LOOKUP_DIRECTORY) &&\n\t\t     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&\n\t\t     (nd->intent.open.file->f_flags & O_CREAT)) {\n\t\t\trc = cifs_posix_open(full_path, &newInode,\n\t\t\t\t\tparent_dir_inode->i_sb,\n\t\t\t\t\tnd->intent.open.create_mode,\n\t\t\t\t\tnd->intent.open.file->f_flags, &oplock,\n\t\t\t\t\t&fileHandle, xid);\n\t\t\t/*\n\t\t\t * The check below works around a bug in POSIX\n\t\t\t * open in samba versions 3.3.1 and earlier where\n\t\t\t * open could incorrectly fail with invalid parameter.\n\t\t\t * If either that or op not supported returned, follow\n\t\t\t * the normal lookup.\n\t\t\t */\n\t\t\tif ((rc == 0) || (rc == -ENOENT))\n\t\t\t\tposix_open = true;\n\t\t\telse if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))\n\t\t\t\tpTcon->broken_posix_open = true;\n\t\t}\n\t\tif (!posix_open)\n\t\t\trc = cifs_get_inode_info_unix(&newInode, full_path,\n\t\t\t\t\t\tparent_dir_inode->i_sb, xid);\n\t} else\n\t\trc = cifs_get_inode_info(&newInode, full_path, NULL,\n\t\t\t\tparent_dir_inode->i_sb, xid, NULL);\n\n\tif ((rc == 0) && (newInode != NULL)) {\n\t\td_add(direntry, newInode);\n\t\tif (posix_open) {\n\t\t\tfilp = lookup_instantiate_filp(nd, direntry,\n\t\t\t\t\t\t       generic_file_open);\n\t\t\tif (IS_ERR(filp)) {\n\t\t\t\trc = PTR_ERR(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\n\t\t\tcfile = cifs_new_fileinfo(fileHandle, filp, tlink,\n\t\t\t\t\t\t  oplock);\n\t\t\tif (cfile == NULL) {\n\t\t\t\tfput(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t\t}\n\t\t/* since paths are not looked up by component - the parent\n\t\t   directories are presumed to be good here */\n\t\trenew_parental_timestamps(direntry);\n\n\t} else if (rc == -ENOENT) {\n\t\trc = 0;\n\t\tdirentry->d_time = jiffies;\n\t\td_add(direntry, NULL);\n\t/*\tif it was once a directory (but how can we tell?) we could do\n\t\tshrink_dcache_parent(direntry); */\n\t} else if (rc != -EACCES) {\n\t\tcERROR(1, \"Unexpected lookup error %d\", rc);\n\t\t/* We special case check for Access Denied - since that\n\t\tis a common return code */\n\t}\n\nlookup_out:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\tFreeXid(xid);\n\treturn ERR_PTR(rc);\n}",
        "func_after": "struct dentry *\ncifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,\n\t    struct nameidata *nd)\n{\n\tint xid;\n\tint rc = 0; /* to get around spurious gcc warning, set to zero here */\n\t__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;\n\t__u16 fileHandle = 0;\n\tbool posix_open = false;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct cifsFileInfo *cfile;\n\tstruct inode *newInode = NULL;\n\tchar *full_path = NULL;\n\tstruct file *filp;\n\n\txid = GetXid();\n\n\tcFYI(1, \"parent inode = 0x%p name is: %s and dentry = 0x%p\",\n\t      parent_dir_inode, direntry->d_name.name, direntry);\n\n\t/* check whether path exists */\n\n\tcifs_sb = CIFS_SB(parent_dir_inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tFreeXid(xid);\n\t\treturn (struct dentry *)tlink;\n\t}\n\tpTcon = tlink_tcon(tlink);\n\n\t/*\n\t * Don't allow the separator character in a path component.\n\t * The VFS will not allow \"/\", but \"\\\" is allowed by posix.\n\t */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {\n\t\tint i;\n\t\tfor (i = 0; i < direntry->d_name.len; i++)\n\t\t\tif (direntry->d_name.name[i] == '\\\\') {\n\t\t\t\tcFYI(1, \"Invalid file name\");\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t}\n\n\t/*\n\t * O_EXCL: optimize away the lookup, but don't hash the dentry. Let\n\t * the VFS handle the create.\n\t */\n\tif (nd && (nd->flags & LOOKUP_EXCL)) {\n\t\td_instantiate(direntry, NULL);\n\t\trc = 0;\n\t\tgoto lookup_out;\n\t}\n\n\t/* can not grab the rename sem here since it would\n\tdeadlock in the cases (beginning of sys_rename itself)\n\tin which we already have the sb rename sem */\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto lookup_out;\n\t}\n\n\tif (direntry->d_inode != NULL) {\n\t\tcFYI(1, \"non-NULL inode in lookup\");\n\t} else {\n\t\tcFYI(1, \"NULL inode in lookup\");\n\t}\n\tcFYI(1, \"Full path: %s inode = 0x%p\", full_path, direntry->d_inode);\n\n\t/* Posix open is only called (at lookup time) for file create now.\n\t * For opens (rather than creates), because we do not know if it\n\t * is a file or directory yet, and current Samba no longer allows\n\t * us to do posix open on dirs, we could end up wasting an open call\n\t * on what turns out to be a dir. For file opens, we wait to call posix\n\t * open till cifs_open.  It could be added here (lookup) in the future\n\t * but the performance tradeoff of the extra network request when EISDIR\n\t * or EACCES is returned would have to be weighed against the 50%\n\t * reduction in network traffic in the other paths.\n\t */\n\tif (pTcon->unix_ext) {\n\t\tif (nd && !(nd->flags & LOOKUP_DIRECTORY) &&\n\t\t     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&\n\t\t     (nd->intent.open.file->f_flags & O_CREAT)) {\n\t\t\trc = cifs_posix_open(full_path, &newInode,\n\t\t\t\t\tparent_dir_inode->i_sb,\n\t\t\t\t\tnd->intent.open.create_mode,\n\t\t\t\t\tnd->intent.open.file->f_flags, &oplock,\n\t\t\t\t\t&fileHandle, xid);\n\t\t\t/*\n\t\t\t * The check below works around a bug in POSIX\n\t\t\t * open in samba versions 3.3.1 and earlier where\n\t\t\t * open could incorrectly fail with invalid parameter.\n\t\t\t * If either that or op not supported returned, follow\n\t\t\t * the normal lookup.\n\t\t\t */\n\t\t\tswitch (rc) {\n\t\t\tcase 0:\n\t\t\t\t/*\n\t\t\t\t * The server may allow us to open things like\n\t\t\t\t * FIFOs, but the client isn't set up to deal\n\t\t\t\t * with that. If it's not a regular file, just\n\t\t\t\t * close it and proceed as if it were a normal\n\t\t\t\t * lookup.\n\t\t\t\t */\n\t\t\t\tif (newInode && !S_ISREG(newInode->i_mode)) {\n\t\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase -ENOENT:\n\t\t\t\tposix_open = true;\n\t\t\tcase -EOPNOTSUPP:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpTcon->broken_posix_open = true;\n\t\t\t}\n\t\t}\n\t\tif (!posix_open)\n\t\t\trc = cifs_get_inode_info_unix(&newInode, full_path,\n\t\t\t\t\t\tparent_dir_inode->i_sb, xid);\n\t} else\n\t\trc = cifs_get_inode_info(&newInode, full_path, NULL,\n\t\t\t\tparent_dir_inode->i_sb, xid, NULL);\n\n\tif ((rc == 0) && (newInode != NULL)) {\n\t\td_add(direntry, newInode);\n\t\tif (posix_open) {\n\t\t\tfilp = lookup_instantiate_filp(nd, direntry,\n\t\t\t\t\t\t       generic_file_open);\n\t\t\tif (IS_ERR(filp)) {\n\t\t\t\trc = PTR_ERR(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\n\t\t\tcfile = cifs_new_fileinfo(fileHandle, filp, tlink,\n\t\t\t\t\t\t  oplock);\n\t\t\tif (cfile == NULL) {\n\t\t\t\tfput(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t\t}\n\t\t/* since paths are not looked up by component - the parent\n\t\t   directories are presumed to be good here */\n\t\trenew_parental_timestamps(direntry);\n\n\t} else if (rc == -ENOENT) {\n\t\trc = 0;\n\t\tdirentry->d_time = jiffies;\n\t\td_add(direntry, NULL);\n\t/*\tif it was once a directory (but how can we tell?) we could do\n\t\tshrink_dcache_parent(direntry); */\n\t} else if (rc != -EACCES) {\n\t\tcERROR(1, \"Unexpected lookup error %d\", rc);\n\t\t/* We special case check for Access Denied - since that\n\t\tis a common return code */\n\t}\n\nlookup_out:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\tFreeXid(xid);\n\treturn ERR_PTR(rc);\n}",
        "description": "The `cifs_lookup` function in the CIFS directory handling module of the Linux kernel, prior to version 3.2.10, permits local users to trigger a denial of service (OOPS) condition by attempting to access a special file, such as a FIFO.",
        "commit": "The CIFS code attempts to open files during lookup under specific conditions. However, if the file turned out to be a FIFO or another special file type, the open file handle would be leaked, resulting in a dentry reference count mismatch and causing an oops error during unmount. This issue has been resolved by ensuring that the file handle on the server is closed if the file is not a regular file. Additionally, the code has been refactored to use a switch statement instead of a complex if-else structure."
    },
    {
        "cwe": "CWE-662",
        "func_name": "torvalds/do_fontx_ioctl",
        "score": 0.7898589372634888,
        "func_before": "static inline int do_fontx_ioctl(int cmd,\n\t\tstruct consolefontdesc __user *user_cfd,\n\t\tstruct console_font_op *op)\n{\n\tstruct consolefontdesc cfdarg;\n\tint i;\n\n\tif (copy_from_user(&cfdarg, user_cfd, sizeof(struct consolefontdesc)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase PIO_FONTX:\n\t\top->op = KD_FONT_OP_SET;\n\t\top->flags = KD_FONT_FLAG_OLD;\n\t\top->width = 8;\n\t\top->height = cfdarg.charheight;\n\t\top->charcount = cfdarg.charcount;\n\t\top->data = cfdarg.chardata;\n\t\treturn con_font_op(vc_cons[fg_console].d, op);\n\tcase GIO_FONTX: {\n\t\top->op = KD_FONT_OP_GET;\n\t\top->flags = KD_FONT_FLAG_OLD;\n\t\top->width = 8;\n\t\top->height = cfdarg.charheight;\n\t\top->charcount = cfdarg.charcount;\n\t\top->data = cfdarg.chardata;\n\t\ti = con_font_op(vc_cons[fg_console].d, op);\n\t\tif (i)\n\t\t\treturn i;\n\t\tcfdarg.charheight = op->height;\n\t\tcfdarg.charcount = op->charcount;\n\t\tif (copy_to_user(user_cfd, &cfdarg, sizeof(struct consolefontdesc)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}",
        "func_after": "static inline int do_fontx_ioctl(struct vc_data *vc, int cmd,\n\t\tstruct consolefontdesc __user *user_cfd,\n\t\tstruct console_font_op *op)\n{\n\tstruct consolefontdesc cfdarg;\n\tint i;\n\n\tif (copy_from_user(&cfdarg, user_cfd, sizeof(struct consolefontdesc)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase PIO_FONTX:\n\t\top->op = KD_FONT_OP_SET;\n\t\top->flags = KD_FONT_FLAG_OLD;\n\t\top->width = 8;\n\t\top->height = cfdarg.charheight;\n\t\top->charcount = cfdarg.charcount;\n\t\top->data = cfdarg.chardata;\n\t\treturn con_font_op(vc, op);\n\n\tcase GIO_FONTX:\n\t\top->op = KD_FONT_OP_GET;\n\t\top->flags = KD_FONT_FLAG_OLD;\n\t\top->width = 8;\n\t\top->height = cfdarg.charheight;\n\t\top->charcount = cfdarg.charcount;\n\t\top->data = cfdarg.chardata;\n\t\ti = con_font_op(vc, op);\n\t\tif (i)\n\t\t\treturn i;\n\t\tcfdarg.charheight = op->height;\n\t\tcfdarg.charcount = op->charcount;\n\t\tif (copy_to_user(user_cfd, &cfdarg, sizeof(struct consolefontdesc)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}",
        "description": "A flaw was identified in the Linux Kernel where access to a global variable used for managing the foreground console is not adequately synchronized, resulting in a use-after-free error within the function responsible for font operations.",
        "commit": "Some font-related terminal I/O control operations previously utilized the current foreground virtual console (VC) for their execution. This practice has been discontinued to address a data race condition involving the `fg_console` variable. Notably, both Michael Ellerman and Jiri Slaby have observed that these I/O control operations are deprecated and should have been removed earlier. They suggest that most systems now use the `KDFONTOP` ioctl instead. Additionally, Michael notes that BusyBox's `loadfont` program transitioned to using `KDFONTOP` precisely due to this bug, which was identified approximately 12 years ago."
    },
    {
        "cwe": "CWE-613",
        "func_name": "arangodb/RestAuthHandler::execute",
        "score": 0.7724074125289917,
        "func_before": "RestStatus RestAuthHandler__execute() {\n  auto const type = _request->requestType();\n  if (type != rest::RequestType::POST) {\n    generateError(rest::ResponseCode::METHOD_NOT_ALLOWED, TRI_ERROR_HTTP_METHOD_NOT_ALLOWED);\n    return RestStatus::DONE;\n  }\n\n  bool parseSuccess = false;\n  VPackSlice slice = this->parseVPackBody(parseSuccess);\n  if (!parseSuccess) { // error already set\n    return RestStatus::DONE;\n  }\n\n  if (!slice.isObject()) {\n    return badRequest();\n  }\n\n  VPackSlice usernameSlice = slice.get(\"username\");\n  VPackSlice passwordSlice = slice.get(\"password\");\n\n  if (!usernameSlice.isString() || !passwordSlice.isString()) {\n    return badRequest();\n  }\n\n  _username = usernameSlice.copyString();\n  std::string const password = passwordSlice.copyString();\n\n  auth::UserManager* um = AuthenticationFeature::instance()->userManager();\n  if (um == nullptr) {\n    std::string msg = \"This server does not support users\";\n    LOG_TOPIC(\"2e7d4\", ERR, Logger::AUTHENTICATION) << msg;\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED, msg);\n  } else if (um->checkPassword(_username, password)) {\n    VPackBuilder resultBuilder;\n    {\n      VPackObjectBuilder b(&resultBuilder);\n      std::string jwt = generateJwt(_username, password);\n      resultBuilder.add(\"jwt\", VPackValue(jwt));\n    }\n\n    _isValid = true;\n    generateDocument(resultBuilder.slice(), true, &VPackOptions::Defaults);\n  } else {\n    // mop: rfc 2616 10.4.2 (if credentials wrong 401)\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED,\n                  \"Wrong credentials\");\n  }\n  return RestStatus::DONE;\n}",
        "func_after": "RestStatus RestAuthHandler__execute() {\n  auto const type = _request->requestType();\n  if (type != rest::RequestType::POST) {\n    generateError(rest::ResponseCode::METHOD_NOT_ALLOWED, TRI_ERROR_HTTP_METHOD_NOT_ALLOWED);\n    return RestStatus::DONE;\n  }\n\n  bool parseSuccess = false;\n  VPackSlice slice = this->parseVPackBody(parseSuccess);\n  if (!parseSuccess) { // error already set\n    return RestStatus::DONE;\n  }\n\n  if (!slice.isObject()) {\n    return badRequest();\n  }\n\n  VPackSlice usernameSlice = slice.get(\"username\");\n  VPackSlice passwordSlice = slice.get(\"password\");\n\n  if (!usernameSlice.isString() || !passwordSlice.isString()) {\n    return badRequest();\n  }\n\n  std::string const username = usernameSlice.copyString();\n  std::string const password = passwordSlice.copyString();\n\n  bool isValid = false;\n\n  auto guard = scopeGuard([&]() {\n    try {\n      if (isValid) {\n        events::LoggedIn(*_request, username);\n      } else {\n        events::CredentialsBad(*_request, username);\n      }\n    } catch (...) {\n      // nothing we can do\n    }\n  });\n  \n  auth::UserManager* um = AuthenticationFeature::instance()->userManager();\n  if (um == nullptr) {\n    std::string msg = \"This server does not support users\";\n    LOG_TOPIC(\"2e7d4\", ERR, Logger::AUTHENTICATION) << msg;\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED, msg);\n  } else if (um->checkPassword(username, password)) {\n    VPackBuilder resultBuilder;\n    {\n      VPackObjectBuilder b(&resultBuilder);\n      resultBuilder.add(\"jwt\", VPackValue(generateJwt(username)));\n    }\n\n    isValid = true;\n    generateDocument(resultBuilder.slice(), true, &VPackOptions::Defaults);\n  } else {\n    // mop: rfc 2616 10.4.2 (if credentials wrong 401)\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED,\n                  \"Wrong credentials\");\n  }\n  return RestStatus::DONE;\n}",
        "description": "ArangoDB versions v3.7.6 through v3.8.3 are susceptible to an Insufficient Session Expiration issue. Specifically, when an administrator changes a user's password, the associated session is not invalidated. This failure allows a malicious user who is still logged in to continue performing arbitrary actions within the system.",
        "commit": "The startup parameter `--server.session-timeout` has been revived."
    }
]