[
    {
        "cwe": "CWE-863",
        "func_name": "torvalds/internal_get_user_pages_fast",
        "score": 0.7458010315895081,
        "func_before": "static int internal_get_user_pages_fast(unsigned long start, int nr_pages,\n\t\t\t\t\tunsigned int gup_flags,\n\t\t\t\t\tstruct page **pages)\n{\n\tunsigned long addr, len, end;\n\tint nr_pinned = 0, ret = 0;\n\n\tif (WARN_ON_ONCE(gup_flags & ~(FOLL_WRITE | FOLL_LONGTERM |\n\t\t\t\t       FOLL_FORCE | FOLL_PIN | FOLL_GET)))\n\t\treturn -EINVAL;\n\n\tstart = untagged_addr(start) & PAGE_MASK;\n\taddr = start;\n\tlen = (unsigned long) nr_pages << PAGE_SHIFT;\n\tend = start + len;\n\n\tif (end <= start)\n\t\treturn 0;\n\tif (unlikely(!access_ok((void __user *)start, len)))\n\t\treturn -EFAULT;\n\n\tif (IS_ENABLED(CONFIG_HAVE_FAST_GUP) &&\n\t    gup_fast_permitted(start, end)) {\n\t\tlocal_irq_disable();\n\t\tgup_pgd_range(addr, end, gup_flags, pages, &nr_pinned);\n\t\tlocal_irq_enable();\n\t\tret = nr_pinned;\n\t}\n\n\tif (nr_pinned < nr_pages) {\n\t\t/* Try to get the remaining pages with get_user_pages */\n\t\tstart += nr_pinned << PAGE_SHIFT;\n\t\tpages += nr_pinned;\n\n\t\tret = __gup_longterm_unlocked(start, nr_pages - nr_pinned,\n\t\t\t\t\t      gup_flags, pages);\n\n\t\t/* Have to be a bit careful with return values */\n\t\tif (nr_pinned > 0) {\n\t\t\tif (ret < 0)\n\t\t\t\tret = nr_pinned;\n\t\t\telse\n\t\t\t\tret += nr_pinned;\n\t\t}\n\t}\n\n\treturn ret;\n}",
        "func_after": "static int internal_get_user_pages_fast(unsigned long start, int nr_pages,\n\t\t\t\t\tunsigned int gup_flags,\n\t\t\t\t\tstruct page **pages)\n{\n\tunsigned long addr, len, end;\n\tint nr_pinned = 0, ret = 0;\n\n\tif (WARN_ON_ONCE(gup_flags & ~(FOLL_WRITE | FOLL_LONGTERM |\n\t\t\t\t       FOLL_FORCE | FOLL_PIN | FOLL_GET)))\n\t\treturn -EINVAL;\n\n\tstart = untagged_addr(start) & PAGE_MASK;\n\taddr = start;\n\tlen = (unsigned long) nr_pages << PAGE_SHIFT;\n\tend = start + len;\n\n\tif (end <= start)\n\t\treturn 0;\n\tif (unlikely(!access_ok((void __user *)start, len)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * The FAST_GUP case requires FOLL_WRITE even for pure reads,\n\t * because get_user_pages() may need to cause an early COW in\n\t * order to avoid confusing the normal COW routines. So only\n\t * targets that are already writable are safe to do by just\n\t * looking at the page tables.\n\t */\n\tif (IS_ENABLED(CONFIG_HAVE_FAST_GUP) &&\n\t    gup_fast_permitted(start, end)) {\n\t\tlocal_irq_disable();\n\t\tgup_pgd_range(addr, end, gup_flags | FOLL_WRITE, pages, &nr_pinned);\n\t\tlocal_irq_enable();\n\t\tret = nr_pinned;\n\t}\n\n\tif (nr_pinned < nr_pages) {\n\t\t/* Try to get the remaining pages with get_user_pages */\n\t\tstart += nr_pinned << PAGE_SHIFT;\n\t\tpages += nr_pinned;\n\n\t\tret = __gup_longterm_unlocked(start, nr_pages - nr_pinned,\n\t\t\t\t\t      gup_flags, pages);\n\n\t\t/* Have to be a bit careful with return values */\n\t\tif (nr_pinned > 0) {\n\t\t\tif (ret < 0)\n\t\t\t\tret = nr_pinned;\n\t\t\telse\n\t\t\t\tret += nr_pinned;\n\t\t}\n\t}\n\n\treturn ret;\n}",
        "description": "An issue was discovered in the Linux kernel prior to version 5.7.3, affecting the memory management components located in mm/gup.c and mm/huge_memory.c. The get_user_pages (gup) implementation, when utilized for copy-on-write pages, fails to correctly handle read operation semantics, potentially resulting in unintended write access.",
        "commit": "The vulnerability involves the `get_user_pages()` function in the Linux kernel, which can lead to ambiguous behavior when dealing with copy-on-write (COW) pages. Specifically, the function may return a page pointer that is no longer associated with the original virtual memory area (VM) due to potential COW events. This ambiguity arises because the direction and timing of COW events are undefined, and a page can be unmapped by the thread that performed the `get_user_pages()` call, especially under memory pressure.\n\nTo mitigate this issue, the kernel introduces a change to force a COW event by setting the `FOLL_WRITE` flag when `FOLL_GET` or `FOLL_PIN` is used on a COW mapping. This ensures that the page is properly isolated from other VMs, preventing unintended access or control. However, this change affects the behavior of `get_user_pages_fast()`, which now refuses to follow read-only pages due to the potential need for COW breaking, leading to slower processing in such cases.\n\nThe current semantics are as follows:\n- `__get_user_pages_fast()`: No changes; it does not break COW unless explicitly asked.\n- `get_user_pages_fast()`: Refuses to follow read-only pages, requiring the slow path for COW breaking.\n- `get_user_pages()`: Forces COW breaking for COW mappings when using `FOLL_GET` or `FOLL_PIN`.\n\nThis change aims to clarify the semantics of `get_user_pages()` and reduce the risk of subtle bugs related to COW behavior. While this addresses the ambiguity, it is noted that true shared mappings will still allow pages to change under the user, meaning `get_user_pages()` does not guarantee a \"stable\" page."
    },
    {
        "cwe": "CWE-200",
        "func_name": "torvalds/xfs_iget_cache_miss",
        "score": 0.7533514499664307,
        "func_before": "static int\nxfs_iget_cache_miss(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_trans_t\t\t*tp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_inode\t**ipp,\n\txfs_daddr_t\t\tbno,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\tunsigned long\t\tfirst_index, mask;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ino);\n\n\tip = xfs_inode_alloc(mp, ino);\n\tif (!ip)\n\t\treturn ENOMEM;\n\n\terror = xfs_iread(mp, tp, ip, bno, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\txfs_itrace_entry(ip);\n\n\tif ((ip->i_d.di_mode == 0) && !(flags & XFS_IGET_CREATE)) {\n\t\terror = ENOENT;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Preload the radix tree so we can insert safely under the\n\t * write spinlock. Note that we cannot sleep inside the preload\n\t * region.\n\t */\n\tif (radix_tree_preload(GFP_KERNEL)) {\n\t\terror = EAGAIN;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Because the inode hasn't been added to the radix-tree yet it can't\n\t * be found by another thread, so we can do the non-sleeping lock here.\n\t */\n\tif (lock_flags) {\n\t\tif (!xfs_ilock_nowait(ip, lock_flags))\n\t\t\tBUG();\n\t}\n\n\tmask = ~(((XFS_INODE_CLUSTER_SIZE(mp) >> mp->m_sb.sb_inodelog)) - 1);\n\tfirst_index = agino & mask;\n\twrite_lock(&pag->pag_ici_lock);\n\n\t/* insert the new inode */\n\terror = radix_tree_insert(&pag->pag_ici_root, agino, ip);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\t\tXFS_STATS_INC(xs_ig_dup);\n\t\terror = EAGAIN;\n\t\tgoto out_preload_end;\n\t}\n\n\t/* These values _must_ be set before releasing the radix tree lock! */\n\tip->i_udquot = ip->i_gdquot = NULL;\n\txfs_iflags_set(ip, XFS_INEW);\n\n\twrite_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\n\ttrace_xfs_iget_alloc(ip);\n\t*ipp = ip;\n\treturn 0;\n\nout_preload_end:\n\twrite_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\nout_destroy:\n\t__destroy_inode(VFS_I(ip));\n\txfs_inode_free(ip);\n\treturn error;\n}",
        "func_after": "static int\nxfs_iget_cache_miss(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_trans_t\t\t*tp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_inode\t**ipp,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\tunsigned long\t\tfirst_index, mask;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ino);\n\n\tip = xfs_inode_alloc(mp, ino);\n\tif (!ip)\n\t\treturn ENOMEM;\n\n\terror = xfs_iread(mp, tp, ip, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\txfs_itrace_entry(ip);\n\n\tif ((ip->i_d.di_mode == 0) && !(flags & XFS_IGET_CREATE)) {\n\t\terror = ENOENT;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Preload the radix tree so we can insert safely under the\n\t * write spinlock. Note that we cannot sleep inside the preload\n\t * region.\n\t */\n\tif (radix_tree_preload(GFP_KERNEL)) {\n\t\terror = EAGAIN;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Because the inode hasn't been added to the radix-tree yet it can't\n\t * be found by another thread, so we can do the non-sleeping lock here.\n\t */\n\tif (lock_flags) {\n\t\tif (!xfs_ilock_nowait(ip, lock_flags))\n\t\t\tBUG();\n\t}\n\n\tmask = ~(((XFS_INODE_CLUSTER_SIZE(mp) >> mp->m_sb.sb_inodelog)) - 1);\n\tfirst_index = agino & mask;\n\twrite_lock(&pag->pag_ici_lock);\n\n\t/* insert the new inode */\n\terror = radix_tree_insert(&pag->pag_ici_root, agino, ip);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\t\tXFS_STATS_INC(xs_ig_dup);\n\t\terror = EAGAIN;\n\t\tgoto out_preload_end;\n\t}\n\n\t/* These values _must_ be set before releasing the radix tree lock! */\n\tip->i_udquot = ip->i_gdquot = NULL;\n\txfs_iflags_set(ip, XFS_INEW);\n\n\twrite_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\n\ttrace_xfs_iget_alloc(ip);\n\t*ipp = ip;\n\treturn 0;\n\nout_preload_end:\n\twrite_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\nout_destroy:\n\t__destroy_inode(VFS_I(ip));\n\txfs_inode_free(ip);\n\treturn error;\n}",
        "description": "The XFS implementation in the Linux kernel prior to version 2.6.35 fails to check inode allocation btrees before reading inode buffers. This oversight enables remote authenticated users to access unlinked files or modify disk blocks that were previously associated with unlinked files but are now linked to active files through stale NFS filehandles.",
        "commit": "The vulnerability involves using block numbers obtained from bulkstat-based inode lookups to optimize mapping calculations. However, since bulkstat data cannot be trusted, the block numbers should be discarded to ensure accurate and reliable lookups and mappings."
    },
    {
        "cwe": "CWE-17",
        "func_name": "torvalds/udf_find_entry",
        "score": 0.7583593726158142,
        "func_before": "static struct fileIdentDesc *udf_find_entry(struct inode *dir,\n\t\t\t\t\t    const struct qstr *child,\n\t\t\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t\t\t    struct fileIdentDesc *cfi)\n{\n\tstruct fileIdentDesc *fi = NULL;\n\tloff_t f_pos;\n\tint block, flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tloff_t size;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint isdotdot = child->len == 2 &&\n\t\tchild->name[0] == '.' && child->name[1] == '.';\n\n\tsize = udf_ext0_offset(dir) + dir->i_size;\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tfibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\tgoto out_err;\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t}\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname)\n\t\tgoto out_err;\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out_err;\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif (fibh->sbh == fibh->ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh->soffset + sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi;\n\n\t\t\tif (poffset >= lfi)\n\t\t\t\tnameptr = (uint8_t *)(fibh->ebh->b_data +\n\t\t\t\t\t\t      poffset - lfi);\n\t\t\telse {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t\tlfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t\tfibh->ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn fi;\n}",
        "func_after": "static struct fileIdentDesc *udf_find_entry(struct inode *dir,\n\t\t\t\t\t    const struct qstr *child,\n\t\t\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t\t\t    struct fileIdentDesc *cfi)\n{\n\tstruct fileIdentDesc *fi = NULL;\n\tloff_t f_pos;\n\tint block, flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tloff_t size;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint isdotdot = child->len == 2 &&\n\t\tchild->name[0] == '.' && child->name[1] == '.';\n\n\tsize = udf_ext0_offset(dir) + dir->i_size;\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tfibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\tgoto out_err;\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t}\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname)\n\t\tgoto out_err;\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out_err;\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif (fibh->sbh == fibh->ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh->soffset + sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi;\n\n\t\t\tif (poffset >= lfi)\n\t\t\t\tnameptr = (uint8_t *)(fibh->ebh->b_data +\n\t\t\t\t\t\t      poffset - lfi);\n\t\t\telse {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t\tlfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t\tfibh->ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,\n\t\t\t\t\tUDF_NAME_LEN);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn fi;\n}",
        "description": "The UDF filesystem implementation in the Linux kernel prior to version 3.18.2 does not verify that sufficient space is allocated for storing a symlink target's name along with a trailing null character. This oversight enables local users to potentially access sensitive information through a specially crafted filesystem image.",
        "commit": "The vulnerability involves a failure to verify whether the resolved path from reading a symbolic link fits within the allocated buffer size. This oversight occurs during the process of reading symlinks, where the code does not account for potential encoding conversions that could increase the path length. Consequently, there is a risk that the path may exceed the buffer capacity, leading to buffer overflow issues."
    },
    {
        "cwe": "CWE-19",
        "func_name": "torvalds/xfs_attr_rmtval_set",
        "score": 0.7478412389755249,
        "func_before": "int\nxfs_attr_rmtval_set(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_bmbt_irec\tmap;\n\txfs_dablk_t\t\tlblkno;\n\txfs_fileoff_t\t\tlfileoff = 0;\n\t__uint8_t\t\t*src = args->value;\n\tint\t\t\tblkcnt;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_set(args);\n\n\t/*\n\t * Find a \"hole\" in the attribute address space large enough for\n\t * us to drop the new attribute's value into. Because CRC enable\n\t * attributes have headers, we can't just do a straight byte to FSB\n\t * conversion and have to take the header space into account.\n\t */\n\tblkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\terror = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,\n\t\t\t\t\t\t   XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\n\targs->rmtblkno = lblkno = (xfs_dablk_t)lfileoff;\n\targs->rmtblkcnt = blkcnt;\n\n\t/*\n\t * Roll through the \"value\", allocating blocks on disk as required.\n\t */\n\twhile (blkcnt > 0) {\n\t\tint\tcommitted;\n\n\t\t/*\n\t\t * Allocate a single extent, up to the size of the value.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_write(args->trans, dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t  blkcnt,\n\t\t\t\t  XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,\n\t\t\t\t  args->firstblock, args->total, &map, &nmap,\n\t\t\t\t  args->flist);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn(error);\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\n\t\t/*\n\t\t * Start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\treturn (error);\n\t}\n\n\t/*\n\t * Roll through the \"value\", copying the attribute value to the\n\t * already-allocated blocks.  Blocks are written synchronously\n\t * so that we can know they are all on disk before we turn off\n\t * the INCOMPLETE flag.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tvaluelen = args->valuelen;\n\twhile (valuelen > 0) {\n\t\tstruct xfs_buf\t*bp;\n\t\txfs_daddr_t\tdblkno;\n\t\tint\t\tdblkcnt;\n\n\t\tASSERT(blkcnt > 0);\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn(error);\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t\tdblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\tdblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\n\n\t\tbp = xfs_buf_get(mp->m_ddev_targp, dblkno, dblkcnt, 0);\n\t\tif (!bp)\n\t\t\treturn ENOMEM;\n\t\tbp->b_ops = &xfs_attr3_rmt_buf_ops;\n\n\t\txfs_attr_rmtval_copyin(mp, bp, args->dp->i_ino, &offset,\n\t\t\t\t       &valuelen, &src);\n\n\t\terror = xfs_bwrite(bp);\t/* GROT: NOTE: synchronous write */\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\n\t\t/* roll attribute extent map forwards */\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}",
        "func_after": "int\nxfs_attr_rmtval_set(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_bmbt_irec\tmap;\n\txfs_dablk_t\t\tlblkno;\n\txfs_fileoff_t\t\tlfileoff = 0;\n\t__uint8_t\t\t*src = args->value;\n\tint\t\t\tblkcnt;\n\tint\t\t\tvaluelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_set(args);\n\n\t/*\n\t * Find a \"hole\" in the attribute address space large enough for\n\t * us to drop the new attribute's value into. Because CRC enable\n\t * attributes have headers, we can't just do a straight byte to FSB\n\t * conversion and have to take the header space into account.\n\t */\n\tblkcnt = xfs_attr3_rmt_blocks(mp, args->rmtvaluelen);\n\terror = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,\n\t\t\t\t\t\t   XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\n\targs->rmtblkno = lblkno = (xfs_dablk_t)lfileoff;\n\targs->rmtblkcnt = blkcnt;\n\n\t/*\n\t * Roll through the \"value\", allocating blocks on disk as required.\n\t */\n\twhile (blkcnt > 0) {\n\t\tint\tcommitted;\n\n\t\t/*\n\t\t * Allocate a single extent, up to the size of the value.\n\t\t */\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_write(args->trans, dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t  blkcnt,\n\t\t\t\t  XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,\n\t\t\t\t  args->firstblock, args->total, &map, &nmap,\n\t\t\t\t  args->flist);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args->trans, args->flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs->trans = NULL;\n\t\t\txfs_bmap_cancel(args->flist);\n\t\t\treturn(error);\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args->trans, dp, 0);\n\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\n\t\t/*\n\t\t * Start the next trans in the chain.\n\t\t */\n\t\terror = xfs_trans_roll(&args->trans, dp);\n\t\tif (error)\n\t\t\treturn (error);\n\t}\n\n\t/*\n\t * Roll through the \"value\", copying the attribute value to the\n\t * already-allocated blocks.  Blocks are written synchronously\n\t * so that we can know they are all on disk before we turn off\n\t * the INCOMPLETE flag.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tstruct xfs_buf\t*bp;\n\t\txfs_daddr_t\tdblkno;\n\t\tint\t\tdblkcnt;\n\n\t\tASSERT(blkcnt > 0);\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, &map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn(error);\n\t\tASSERT(nmap == 1);\n\t\tASSERT((map.br_startblock != DELAYSTARTBLOCK) &&\n\t\t       (map.br_startblock != HOLESTARTBLOCK));\n\n\t\tdblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),\n\t\tdblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);\n\n\t\tbp = xfs_buf_get(mp->m_ddev_targp, dblkno, dblkcnt, 0);\n\t\tif (!bp)\n\t\t\treturn ENOMEM;\n\t\tbp->b_ops = &xfs_attr3_rmt_buf_ops;\n\n\t\txfs_attr_rmtval_copyin(mp, bp, args->dp->i_ino, &offset,\n\t\t\t\t       &valuelen, &src);\n\n\t\terror = xfs_bwrite(bp);\t/* GROT: NOTE: synchronous write */\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\n\t\t/* roll attribute extent map forwards */\n\t\tlblkno += map.br_blockcount;\n\t\tblkcnt -= map.br_blockcount;\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}",
        "description": "The XFS implementation in the Linux kernel prior to version 3.15 improperly utilizes an outdated size value during remote attribute replacement, enabling local users to trigger a denial of service through transaction overruns and data corruption, or potentially escalate their privileges by exploiting XFS filesystem access.",
        "commit": "A vulnerability in the XFS filesystem allows for a remote attribute overwrite, leading to a transaction overrun. During remote attribute lookups, the length of the attribute is passed in the `xfs_da_args` structure to ensure correct CRC calculations and validity checks. However, this inadvertently modifies the `args->valuelen` parameter when replacing a remote attribute. Specifically, the lookup operation overwrites `args->valuelen` with the length of the existing remote attribute, causing the new attribute to be created with the incorrect size. If the new attribute is significantly smaller than the old one, this results in a transaction overrun and an assertion failure in debug kernels. The fix involves maintaining separate lengths for the remote attribute value and the attribute value within the `xfs_da_args` structure. Additionally, ensuring that remote block contexts saved for later renames are properly reset to avoid confusing the state of the attribute to be removed with the new attribute's state."
    },
    {
        "cwe": "CWE-310",
        "func_name": "torvalds/asn1_ber_decoder",
        "score": 0.7530432343482971,
        "func_before": "int asn1_ber_decoder(const struct asn1_decoder *decoder,\n\t\t     void *context,\n\t\t     const unsigned char *data,\n\t\t     size_t datalen)\n{\n\tconst unsigned char *machine = decoder->machine;\n\tconst asn1_action_t *actions = decoder->actions;\n\tsize_t machlen = decoder->machlen;\n\tenum asn1_opcode op;\n\tunsigned char tag = 0, csp = 0, jsp = 0, optag = 0, hdr = 0;\n\tconst char *errmsg;\n\tsize_t pc = 0, dp = 0, tdp = 0, len = 0;\n\tint ret;\n\n\tunsigned char flags = 0;\n#define FLAG_INDEFINITE_LENGTH\t0x01\n#define FLAG_MATCHED\t\t0x02\n#define FLAG_LAST_MATCHED\t0x04 /* Last tag matched */\n#define FLAG_CONS\t\t0x20 /* Corresponds to CONS bit in the opcode tag\n\t\t\t\t      * - ie. whether or not we are going to parse\n\t\t\t\t      *   a compound type.\n\t\t\t\t      */\n\n#define NR_CONS_STACK 10\n\tunsigned short cons_dp_stack[NR_CONS_STACK];\n\tunsigned short cons_datalen_stack[NR_CONS_STACK];\n\tunsigned char cons_hdrlen_stack[NR_CONS_STACK];\n#define NR_JUMP_STACK 10\n\tunsigned char jump_stack[NR_JUMP_STACK];\n\n\tif (datalen > 65535)\n\t\treturn -EMSGSIZE;\n\nnext_op:\n\tpr_debug(\"next_op: pc=\\e[32m%zu\\e[m/%zu dp=\\e[33m%zu\\e[m/%zu C=%d J=%d\\n\",\n\t\t pc, machlen, dp, datalen, csp, jsp);\n\tif (unlikely(pc >= machlen))\n\t\tgoto machine_overrun_error;\n\top = machine[pc];\n\tif (unlikely(pc + asn1_op_lengths[op] > machlen))\n\t\tgoto machine_overrun_error;\n\n\t/* If this command is meant to match a tag, then do that before\n\t * evaluating the command.\n\t */\n\tif (op <= ASN1_OP__MATCHES_TAG) {\n\t\tunsigned char tmp;\n\n\t\t/* Skip conditional matches if possible */\n\t\tif ((op & ASN1_OP_MATCH__COND &&\n\t\t     flags & FLAG_MATCHED) ||\n\t\t    dp == datalen) {\n\t\t\tflags &= ~FLAG_LAST_MATCHED;\n\t\t\tpc += asn1_op_lengths[op];\n\t\t\tgoto next_op;\n\t\t}\n\n\t\tflags = 0;\n\t\thdr = 2;\n\n\t\t/* Extract a tag from the data */\n\t\tif (unlikely(dp >= datalen - 1))\n\t\t\tgoto data_overrun_error;\n\t\ttag = data[dp++];\n\t\tif (unlikely((tag & 0x1f) == ASN1_LONG_TAG))\n\t\t\tgoto long_tag_not_supported;\n\n\t\tif (op & ASN1_OP_MATCH__ANY) {\n\t\t\tpr_debug(\"- any %02x\\n\", tag);\n\t\t} else {\n\t\t\t/* Extract the tag from the machine\n\t\t\t * - Either CONS or PRIM are permitted in the data if\n\t\t\t *   CONS is not set in the op stream, otherwise CONS\n\t\t\t *   is mandatory.\n\t\t\t */\n\t\t\toptag = machine[pc + 1];\n\t\t\tflags |= optag & FLAG_CONS;\n\n\t\t\t/* Determine whether the tag matched */\n\t\t\ttmp = optag ^ tag;\n\t\t\ttmp &= ~(optag & ASN1_CONS_BIT);\n\t\t\tpr_debug(\"- match? %02x %02x %02x\\n\", tag, optag, tmp);\n\t\t\tif (tmp != 0) {\n\t\t\t\t/* All odd-numbered tags are MATCH_OR_SKIP. */\n\t\t\t\tif (op & ASN1_OP_MATCH__SKIP) {\n\t\t\t\t\tpc += asn1_op_lengths[op];\n\t\t\t\t\tdp--;\n\t\t\t\t\tgoto next_op;\n\t\t\t\t}\n\t\t\t\tgoto tag_mismatch;\n\t\t\t}\n\t\t}\n\t\tflags |= FLAG_MATCHED;\n\n\t\tlen = data[dp++];\n\t\tif (len > 0x7f) {\n\t\t\tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\t\t\t/* Indefinite length */\n\t\t\t\tif (unlikely(!(tag & ASN1_CONS_BIT)))\n\t\t\t\t\tgoto indefinite_len_primitive;\n\t\t\t\tflags |= FLAG_INDEFINITE_LENGTH;\n\t\t\t\tif (unlikely(2 > datalen - dp))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t} else {\n\t\t\t\tint n = len - 0x80;\n\t\t\t\tif (unlikely(n > 2))\n\t\t\t\t\tgoto length_too_long;\n\t\t\t\tif (unlikely(dp >= datalen - n))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t\thdr += n;\n\t\t\t\tfor (len = 0; n > 0; n--) {\n\t\t\t\t\tlen <<= 8;\n\t\t\t\t\tlen |= data[dp++];\n\t\t\t\t}\n\t\t\t\tif (unlikely(len > datalen - dp))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t}\n\t\t}\n\n\t\tif (flags & FLAG_CONS) {\n\t\t\t/* For expected compound forms, we stack the positions\n\t\t\t * of the start and end of the data.\n\t\t\t */\n\t\t\tif (unlikely(csp >= NR_CONS_STACK))\n\t\t\t\tgoto cons_stack_overflow;\n\t\t\tcons_dp_stack[csp] = dp;\n\t\t\tcons_hdrlen_stack[csp] = hdr;\n\t\t\tif (!(flags & FLAG_INDEFINITE_LENGTH)) {\n\t\t\t\tcons_datalen_stack[csp] = datalen;\n\t\t\t\tdatalen = dp + len;\n\t\t\t} else {\n\t\t\t\tcons_datalen_stack[csp] = 0;\n\t\t\t}\n\t\t\tcsp++;\n\t\t}\n\n\t\tpr_debug(\"- TAG: %02x %zu%s\\n\",\n\t\t\t tag, len, flags & FLAG_CONS ? \" CONS\" : \"\");\n\t\ttdp = dp;\n\t}\n\n\t/* Decide how to handle the operation */\n\tswitch (op) {\n\tcase ASN1_OP_MATCH_ANY_ACT:\n\tcase ASN1_OP_COND_MATCH_ANY_ACT:\n\t\tret = actions[machine[pc + 1]](context, hdr, tag, data + dp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto skip_data;\n\n\tcase ASN1_OP_MATCH_ACT:\n\tcase ASN1_OP_MATCH_ACT_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_ACT_OR_SKIP:\n\t\tret = actions[machine[pc + 2]](context, hdr, tag, data + dp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto skip_data;\n\n\tcase ASN1_OP_MATCH:\n\tcase ASN1_OP_MATCH_OR_SKIP:\n\tcase ASN1_OP_MATCH_ANY:\n\tcase ASN1_OP_COND_MATCH_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_ANY:\n\tskip_data:\n\t\tif (!(flags & FLAG_CONS)) {\n\t\t\tif (flags & FLAG_INDEFINITE_LENGTH) {\n\t\t\t\tret = asn1_find_indefinite_length(\n\t\t\t\t\tdata, datalen, &dp, &len, &errmsg);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tdp += len;\n\t\t\t}\n\t\t\tpr_debug(\"- LEAF: %zu\\n\", len);\n\t\t}\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_MATCH_JUMP:\n\tcase ASN1_OP_MATCH_JUMP_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_JUMP_OR_SKIP:\n\t\tpr_debug(\"- MATCH_JUMP\\n\");\n\t\tif (unlikely(jsp == NR_JUMP_STACK))\n\t\t\tgoto jump_stack_overflow;\n\t\tjump_stack[jsp++] = pc + asn1_op_lengths[op];\n\t\tpc = machine[pc + 2];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_COND_FAIL:\n\t\tif (unlikely(!(flags & FLAG_MATCHED)))\n\t\t\tgoto tag_mismatch;\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_COMPLETE:\n\t\tif (unlikely(jsp != 0 || csp != 0)) {\n\t\t\tpr_err(\"ASN.1 decoder error: Stacks not empty at completion (%u, %u)\\n\",\n\t\t\t       jsp, csp);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\treturn 0;\n\n\tcase ASN1_OP_END_SET:\n\tcase ASN1_OP_END_SET_ACT:\n\t\tif (unlikely(!(flags & FLAG_MATCHED)))\n\t\t\tgoto tag_mismatch;\n\tcase ASN1_OP_END_SEQ:\n\tcase ASN1_OP_END_SET_OF:\n\tcase ASN1_OP_END_SEQ_OF:\n\tcase ASN1_OP_END_SEQ_ACT:\n\tcase ASN1_OP_END_SET_OF_ACT:\n\tcase ASN1_OP_END_SEQ_OF_ACT:\n\t\tif (unlikely(csp <= 0))\n\t\t\tgoto cons_stack_underflow;\n\t\tcsp--;\n\t\ttdp = cons_dp_stack[csp];\n\t\thdr = cons_hdrlen_stack[csp];\n\t\tlen = datalen;\n\t\tdatalen = cons_datalen_stack[csp];\n\t\tpr_debug(\"- end cons t=%zu dp=%zu l=%zu/%zu\\n\",\n\t\t\t tdp, dp, len, datalen);\n\t\tif (datalen == 0) {\n\t\t\t/* Indefinite length - check for the EOC. */\n\t\t\tdatalen = len;\n\t\t\tif (unlikely(datalen - dp < 2))\n\t\t\t\tgoto data_overrun_error;\n\t\t\tif (data[dp++] != 0) {\n\t\t\t\tif (op & ASN1_OP_END__OF) {\n\t\t\t\t\tdp--;\n\t\t\t\t\tcsp++;\n\t\t\t\t\tpc = machine[pc + 1];\n\t\t\t\t\tpr_debug(\"- continue\\n\");\n\t\t\t\t\tgoto next_op;\n\t\t\t\t}\n\t\t\t\tgoto missing_eoc;\n\t\t\t}\n\t\t\tif (data[dp++] != 0)\n\t\t\t\tgoto invalid_eoc;\n\t\t\tlen = dp - tdp - 2;\n\t\t} else {\n\t\t\tif (dp < len && (op & ASN1_OP_END__OF)) {\n\t\t\t\tdatalen = len;\n\t\t\t\tcsp++;\n\t\t\t\tpc = machine[pc + 1];\n\t\t\t\tpr_debug(\"- continue\\n\");\n\t\t\t\tgoto next_op;\n\t\t\t}\n\t\t\tif (dp != len)\n\t\t\t\tgoto cons_length_error;\n\t\t\tlen -= tdp;\n\t\t\tpr_debug(\"- cons len l=%zu d=%zu\\n\", len, dp - tdp);\n\t\t}\n\n\t\tif (op & ASN1_OP_END__ACT) {\n\t\t\tunsigned char act;\n\t\t\tif (op & ASN1_OP_END__OF)\n\t\t\t\tact = machine[pc + 2];\n\t\t\telse\n\t\t\t\tact = machine[pc + 1];\n\t\t\tret = actions[act](context, hdr, 0, data + tdp, len);\n\t\t}\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_MAYBE_ACT:\n\t\tif (!(flags & FLAG_LAST_MATCHED)) {\n\t\t\tpc += asn1_op_lengths[op];\n\t\t\tgoto next_op;\n\t\t}\n\tcase ASN1_OP_ACT:\n\t\tret = actions[machine[pc + 1]](context, hdr, tag, data + tdp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_RETURN:\n\t\tif (unlikely(jsp <= 0))\n\t\t\tgoto jump_stack_underflow;\n\t\tpc = jump_stack[--jsp];\n\t\tflags |= FLAG_MATCHED | FLAG_LAST_MATCHED;\n\t\tgoto next_op;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* Shouldn't reach here */\n\tpr_err(\"ASN.1 decoder error: Found reserved opcode (%u) pc=%zu\\n\",\n\t       op, pc);\n\treturn -EBADMSG;\n\ndata_overrun_error:\n\terrmsg = \"Data overrun error\";\n\tgoto error;\nmachine_overrun_error:\n\terrmsg = \"Machine overrun error\";\n\tgoto error;\njump_stack_underflow:\n\terrmsg = \"Jump stack underflow\";\n\tgoto error;\njump_stack_overflow:\n\terrmsg = \"Jump stack overflow\";\n\tgoto error;\ncons_stack_underflow:\n\terrmsg = \"Cons stack underflow\";\n\tgoto error;\ncons_stack_overflow:\n\terrmsg = \"Cons stack overflow\";\n\tgoto error;\ncons_length_error:\n\terrmsg = \"Cons length error\";\n\tgoto error;\nmissing_eoc:\n\terrmsg = \"Missing EOC in indefinite len cons\";\n\tgoto error;\ninvalid_eoc:\n\terrmsg = \"Invalid length EOC\";\n\tgoto error;\nlength_too_long:\n\terrmsg = \"Unsupported length\";\n\tgoto error;\nindefinite_len_primitive:\n\terrmsg = \"Indefinite len primitive not permitted\";\n\tgoto error;\ntag_mismatch:\n\terrmsg = \"Unexpected tag\";\n\tgoto error;\nlong_tag_not_supported:\n\terrmsg = \"Long tag not supported\";\nerror:\n\tpr_debug(\"\\nASN1: %s [m=%zu d=%zu ot=%02x t=%02x l=%zu]\\n\",\n\t\t errmsg, pc, dp, optag, tag, len);\n\treturn -EBADMSG;\n}",
        "func_after": "int asn1_ber_decoder(const struct asn1_decoder *decoder,\n\t\t     void *context,\n\t\t     const unsigned char *data,\n\t\t     size_t datalen)\n{\n\tconst unsigned char *machine = decoder->machine;\n\tconst asn1_action_t *actions = decoder->actions;\n\tsize_t machlen = decoder->machlen;\n\tenum asn1_opcode op;\n\tunsigned char tag = 0, csp = 0, jsp = 0, optag = 0, hdr = 0;\n\tconst char *errmsg;\n\tsize_t pc = 0, dp = 0, tdp = 0, len = 0;\n\tint ret;\n\n\tunsigned char flags = 0;\n#define FLAG_INDEFINITE_LENGTH\t0x01\n#define FLAG_MATCHED\t\t0x02\n#define FLAG_LAST_MATCHED\t0x04 /* Last tag matched */\n#define FLAG_CONS\t\t0x20 /* Corresponds to CONS bit in the opcode tag\n\t\t\t\t      * - ie. whether or not we are going to parse\n\t\t\t\t      *   a compound type.\n\t\t\t\t      */\n\n#define NR_CONS_STACK 10\n\tunsigned short cons_dp_stack[NR_CONS_STACK];\n\tunsigned short cons_datalen_stack[NR_CONS_STACK];\n\tunsigned char cons_hdrlen_stack[NR_CONS_STACK];\n#define NR_JUMP_STACK 10\n\tunsigned char jump_stack[NR_JUMP_STACK];\n\n\tif (datalen > 65535)\n\t\treturn -EMSGSIZE;\n\nnext_op:\n\tpr_debug(\"next_op: pc=\\e[32m%zu\\e[m/%zu dp=\\e[33m%zu\\e[m/%zu C=%d J=%d\\n\",\n\t\t pc, machlen, dp, datalen, csp, jsp);\n\tif (unlikely(pc >= machlen))\n\t\tgoto machine_overrun_error;\n\top = machine[pc];\n\tif (unlikely(pc + asn1_op_lengths[op] > machlen))\n\t\tgoto machine_overrun_error;\n\n\t/* If this command is meant to match a tag, then do that before\n\t * evaluating the command.\n\t */\n\tif (op <= ASN1_OP__MATCHES_TAG) {\n\t\tunsigned char tmp;\n\n\t\t/* Skip conditional matches if possible */\n\t\tif ((op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED) ||\n\t\t    (op & ASN1_OP_MATCH__SKIP && dp == datalen)) {\n\t\t\tflags &= ~FLAG_LAST_MATCHED;\n\t\t\tpc += asn1_op_lengths[op];\n\t\t\tgoto next_op;\n\t\t}\n\n\t\tflags = 0;\n\t\thdr = 2;\n\n\t\t/* Extract a tag from the data */\n\t\tif (unlikely(dp >= datalen - 1))\n\t\t\tgoto data_overrun_error;\n\t\ttag = data[dp++];\n\t\tif (unlikely((tag & 0x1f) == ASN1_LONG_TAG))\n\t\t\tgoto long_tag_not_supported;\n\n\t\tif (op & ASN1_OP_MATCH__ANY) {\n\t\t\tpr_debug(\"- any %02x\\n\", tag);\n\t\t} else {\n\t\t\t/* Extract the tag from the machine\n\t\t\t * - Either CONS or PRIM are permitted in the data if\n\t\t\t *   CONS is not set in the op stream, otherwise CONS\n\t\t\t *   is mandatory.\n\t\t\t */\n\t\t\toptag = machine[pc + 1];\n\t\t\tflags |= optag & FLAG_CONS;\n\n\t\t\t/* Determine whether the tag matched */\n\t\t\ttmp = optag ^ tag;\n\t\t\ttmp &= ~(optag & ASN1_CONS_BIT);\n\t\t\tpr_debug(\"- match? %02x %02x %02x\\n\", tag, optag, tmp);\n\t\t\tif (tmp != 0) {\n\t\t\t\t/* All odd-numbered tags are MATCH_OR_SKIP. */\n\t\t\t\tif (op & ASN1_OP_MATCH__SKIP) {\n\t\t\t\t\tpc += asn1_op_lengths[op];\n\t\t\t\t\tdp--;\n\t\t\t\t\tgoto next_op;\n\t\t\t\t}\n\t\t\t\tgoto tag_mismatch;\n\t\t\t}\n\t\t}\n\t\tflags |= FLAG_MATCHED;\n\n\t\tlen = data[dp++];\n\t\tif (len > 0x7f) {\n\t\t\tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\t\t\t/* Indefinite length */\n\t\t\t\tif (unlikely(!(tag & ASN1_CONS_BIT)))\n\t\t\t\t\tgoto indefinite_len_primitive;\n\t\t\t\tflags |= FLAG_INDEFINITE_LENGTH;\n\t\t\t\tif (unlikely(2 > datalen - dp))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t} else {\n\t\t\t\tint n = len - 0x80;\n\t\t\t\tif (unlikely(n > 2))\n\t\t\t\t\tgoto length_too_long;\n\t\t\t\tif (unlikely(dp >= datalen - n))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t\thdr += n;\n\t\t\t\tfor (len = 0; n > 0; n--) {\n\t\t\t\t\tlen <<= 8;\n\t\t\t\t\tlen |= data[dp++];\n\t\t\t\t}\n\t\t\t\tif (unlikely(len > datalen - dp))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t}\n\t\t}\n\n\t\tif (flags & FLAG_CONS) {\n\t\t\t/* For expected compound forms, we stack the positions\n\t\t\t * of the start and end of the data.\n\t\t\t */\n\t\t\tif (unlikely(csp >= NR_CONS_STACK))\n\t\t\t\tgoto cons_stack_overflow;\n\t\t\tcons_dp_stack[csp] = dp;\n\t\t\tcons_hdrlen_stack[csp] = hdr;\n\t\t\tif (!(flags & FLAG_INDEFINITE_LENGTH)) {\n\t\t\t\tcons_datalen_stack[csp] = datalen;\n\t\t\t\tdatalen = dp + len;\n\t\t\t} else {\n\t\t\t\tcons_datalen_stack[csp] = 0;\n\t\t\t}\n\t\t\tcsp++;\n\t\t}\n\n\t\tpr_debug(\"- TAG: %02x %zu%s\\n\",\n\t\t\t tag, len, flags & FLAG_CONS ? \" CONS\" : \"\");\n\t\ttdp = dp;\n\t}\n\n\t/* Decide how to handle the operation */\n\tswitch (op) {\n\tcase ASN1_OP_MATCH_ANY_ACT:\n\tcase ASN1_OP_COND_MATCH_ANY_ACT:\n\t\tret = actions[machine[pc + 1]](context, hdr, tag, data + dp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto skip_data;\n\n\tcase ASN1_OP_MATCH_ACT:\n\tcase ASN1_OP_MATCH_ACT_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_ACT_OR_SKIP:\n\t\tret = actions[machine[pc + 2]](context, hdr, tag, data + dp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto skip_data;\n\n\tcase ASN1_OP_MATCH:\n\tcase ASN1_OP_MATCH_OR_SKIP:\n\tcase ASN1_OP_MATCH_ANY:\n\tcase ASN1_OP_COND_MATCH_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_ANY:\n\tskip_data:\n\t\tif (!(flags & FLAG_CONS)) {\n\t\t\tif (flags & FLAG_INDEFINITE_LENGTH) {\n\t\t\t\tret = asn1_find_indefinite_length(\n\t\t\t\t\tdata, datalen, &dp, &len, &errmsg);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tdp += len;\n\t\t\t}\n\t\t\tpr_debug(\"- LEAF: %zu\\n\", len);\n\t\t}\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_MATCH_JUMP:\n\tcase ASN1_OP_MATCH_JUMP_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_JUMP_OR_SKIP:\n\t\tpr_debug(\"- MATCH_JUMP\\n\");\n\t\tif (unlikely(jsp == NR_JUMP_STACK))\n\t\t\tgoto jump_stack_overflow;\n\t\tjump_stack[jsp++] = pc + asn1_op_lengths[op];\n\t\tpc = machine[pc + 2];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_COND_FAIL:\n\t\tif (unlikely(!(flags & FLAG_MATCHED)))\n\t\t\tgoto tag_mismatch;\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_COMPLETE:\n\t\tif (unlikely(jsp != 0 || csp != 0)) {\n\t\t\tpr_err(\"ASN.1 decoder error: Stacks not empty at completion (%u, %u)\\n\",\n\t\t\t       jsp, csp);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\treturn 0;\n\n\tcase ASN1_OP_END_SET:\n\tcase ASN1_OP_END_SET_ACT:\n\t\tif (unlikely(!(flags & FLAG_MATCHED)))\n\t\t\tgoto tag_mismatch;\n\tcase ASN1_OP_END_SEQ:\n\tcase ASN1_OP_END_SET_OF:\n\tcase ASN1_OP_END_SEQ_OF:\n\tcase ASN1_OP_END_SEQ_ACT:\n\tcase ASN1_OP_END_SET_OF_ACT:\n\tcase ASN1_OP_END_SEQ_OF_ACT:\n\t\tif (unlikely(csp <= 0))\n\t\t\tgoto cons_stack_underflow;\n\t\tcsp--;\n\t\ttdp = cons_dp_stack[csp];\n\t\thdr = cons_hdrlen_stack[csp];\n\t\tlen = datalen;\n\t\tdatalen = cons_datalen_stack[csp];\n\t\tpr_debug(\"- end cons t=%zu dp=%zu l=%zu/%zu\\n\",\n\t\t\t tdp, dp, len, datalen);\n\t\tif (datalen == 0) {\n\t\t\t/* Indefinite length - check for the EOC. */\n\t\t\tdatalen = len;\n\t\t\tif (unlikely(datalen - dp < 2))\n\t\t\t\tgoto data_overrun_error;\n\t\t\tif (data[dp++] != 0) {\n\t\t\t\tif (op & ASN1_OP_END__OF) {\n\t\t\t\t\tdp--;\n\t\t\t\t\tcsp++;\n\t\t\t\t\tpc = machine[pc + 1];\n\t\t\t\t\tpr_debug(\"- continue\\n\");\n\t\t\t\t\tgoto next_op;\n\t\t\t\t}\n\t\t\t\tgoto missing_eoc;\n\t\t\t}\n\t\t\tif (data[dp++] != 0)\n\t\t\t\tgoto invalid_eoc;\n\t\t\tlen = dp - tdp - 2;\n\t\t} else {\n\t\t\tif (dp < len && (op & ASN1_OP_END__OF)) {\n\t\t\t\tdatalen = len;\n\t\t\t\tcsp++;\n\t\t\t\tpc = machine[pc + 1];\n\t\t\t\tpr_debug(\"- continue\\n\");\n\t\t\t\tgoto next_op;\n\t\t\t}\n\t\t\tif (dp != len)\n\t\t\t\tgoto cons_length_error;\n\t\t\tlen -= tdp;\n\t\t\tpr_debug(\"- cons len l=%zu d=%zu\\n\", len, dp - tdp);\n\t\t}\n\n\t\tif (op & ASN1_OP_END__ACT) {\n\t\t\tunsigned char act;\n\t\t\tif (op & ASN1_OP_END__OF)\n\t\t\t\tact = machine[pc + 2];\n\t\t\telse\n\t\t\t\tact = machine[pc + 1];\n\t\t\tret = actions[act](context, hdr, 0, data + tdp, len);\n\t\t}\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_MAYBE_ACT:\n\t\tif (!(flags & FLAG_LAST_MATCHED)) {\n\t\t\tpc += asn1_op_lengths[op];\n\t\t\tgoto next_op;\n\t\t}\n\tcase ASN1_OP_ACT:\n\t\tret = actions[machine[pc + 1]](context, hdr, tag, data + tdp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_RETURN:\n\t\tif (unlikely(jsp <= 0))\n\t\t\tgoto jump_stack_underflow;\n\t\tpc = jump_stack[--jsp];\n\t\tflags |= FLAG_MATCHED | FLAG_LAST_MATCHED;\n\t\tgoto next_op;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* Shouldn't reach here */\n\tpr_err(\"ASN.1 decoder error: Found reserved opcode (%u) pc=%zu\\n\",\n\t       op, pc);\n\treturn -EBADMSG;\n\ndata_overrun_error:\n\terrmsg = \"Data overrun error\";\n\tgoto error;\nmachine_overrun_error:\n\terrmsg = \"Machine overrun error\";\n\tgoto error;\njump_stack_underflow:\n\terrmsg = \"Jump stack underflow\";\n\tgoto error;\njump_stack_overflow:\n\terrmsg = \"Jump stack overflow\";\n\tgoto error;\ncons_stack_underflow:\n\terrmsg = \"Cons stack underflow\";\n\tgoto error;\ncons_stack_overflow:\n\terrmsg = \"Cons stack overflow\";\n\tgoto error;\ncons_length_error:\n\terrmsg = \"Cons length error\";\n\tgoto error;\nmissing_eoc:\n\terrmsg = \"Missing EOC in indefinite len cons\";\n\tgoto error;\ninvalid_eoc:\n\terrmsg = \"Invalid length EOC\";\n\tgoto error;\nlength_too_long:\n\terrmsg = \"Unsupported length\";\n\tgoto error;\nindefinite_len_primitive:\n\terrmsg = \"Indefinite len primitive not permitted\";\n\tgoto error;\ntag_mismatch:\n\terrmsg = \"Unexpected tag\";\n\tgoto error;\nlong_tag_not_supported:\n\terrmsg = \"Long tag not supported\";\nerror:\n\tpr_debug(\"\\nASN1: %s [m=%zu d=%zu ot=%02x t=%02x l=%zu]\\n\",\n\t\t errmsg, pc, dp, optag, tag, len);\n\treturn -EBADMSG;\n}",
        "description": "The `asn1_ber_decoder` function in the Linux kernel, prior to version 4.3, is susceptible to a denial of service (panic) when processing an ASN.1 BER file that lacks a public key. This issue arises because the `public_key_verify_signature` function in the cryptographic module mishandles the absence of a public key, leading to system instability.",
        "commit": "The ASN.1 decoder in certain implementations fails to correctly handle data overruns, leading to non-matching detection failures. Specifically, when parsing sequences of objects, non-optional matches are skipped if there is no more data available, instead of reporting a data-overrun error. This issue arises because the code segment responsible for deciding whether to skip optional matches due to a lack of data also incorrectly skips non-optional elements when the data pointer reaches the end of the buffer. This behavior can be observed in the data decoder for the new RSA akcipher algorithm, where the last integer is skipped if there is insufficient data.\n\nWithout the fix, defining `DEBUG` in `asn1_decoder.c` reveals that the ASN.1 parser does not properly handle the end of the buffer, potentially leading to incorrect parsing outcomes. However, this vulnerability is mitigated in practical scenarios involving X.509 certificates and PKCS#7 messages due to several factors:\n\n1. **X.509 Certificates**: Relevant records are cleared before use, and the removal of critical components like the public key causes the ASN.1 parser to fail quickly due to a lack of data. Additionally, extracted signature data is handled robustly, and optional extensions like AKID and SKID are managed without risking NULL pointer issues.\n\n2. **PKCS#7 Messages**: Embedded X.509 certificates are survivable, and the message digest content and authattrs are handled appropriately if they show NULL pointers. Missing signatures result in NULL MPIs, which are managed by MPI routines. If data is NULL, it is expected that the message has detached content, and other fields are decoded to simple integers, with checks failing early if an algorithm ID field is omitted.\n\nDespite these mitigations, the underlying issue remains that mandatory tags should trigger an `EBADMSG` error when missing, but without the patch, errors like `ERANGE`, `ENOPKG`, or others might be produced, or the parse might appear to succeed with subsequent errors like `ENOKEY` or `EKEYREJECTED`. Testing this vulnerability involves removing mandatory tags from the ASN.1 stream, such as the final `BIT_STRING` or `OCTET_STRING`, which should trigger an `EBADMSG` error with the patch applied."
    }
]