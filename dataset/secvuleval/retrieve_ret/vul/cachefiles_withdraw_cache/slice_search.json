[
    {
        "cwe": "CWE-416",
        "func_name": "torvalds/ipt_do_table",
        "score": 0.7548743486404419,
        "func_before": "unsigned int\nipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
        "func_after": "unsigned int\nipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = rcu_access_pointer(table->private);\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
        "description": "An issue was discovered in the netfilter component of the Linux kernel prior to version 5.10. This vulnerability involves a use-after-free condition in the packet processing context due to improper handling of per-CPU sequence counts during concurrent iptables rule replacements. This flaw could be exploited by users with the CAP_NET_ADMIN capability in an unprivileged namespace.",
        "commit": "When performing concurrent iptables rules replacement, the system checks the per-CPU sequence count after assigning new information. This sequence count is intended to synchronize with the packet path without using explicit locking. If packets are currently using the old table information, the sequence count is incremented to an odd value and then to an even value after processing. After assigning the new table information, a write memory barrier is executed to ensure all CPUs see the latest value. If the packet path starts with the old table information, the sequence counter remains odd, and the iptables replacement waits until the sequence count is even before freeing the old table information. However, if the CPU delays executing the new table information assignment and memory barrier, another CPU's packet path may still use the old table information. This delay can lead to a use-after-free error in the packet processing context, resulting in a kernel NULL pointer dereference. To fix this issue, either enforce instruction ordering after the new table information assignment or switch to RCU for synchronization."
    },
    {
        "cwe": "CWE-415",
        "func_name": "libgd/gdImageWebpCtx",
        "score": 0.7389953136444092,
        "func_before": "BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\tuint8_t *argb;\n\tint x, y;\n\tuint8_t *p;\n\tuint8_t *out;\n\tsize_t out_size;\n\n\tif (im == NULL) {\n\t\treturn;\n\t}\n\n\tif (!gdImageTrueColor(im)) {\n\t\tgd_error(\"Paletter image not supported by webp\");\n\t\treturn;\n\t}\n\n\tif (quality == -1) {\n\t\tquality = 80;\n\t}\n\n\tif (overflow2(gdImageSX(im), 4)) {\n\t\treturn;\n\t}\n\n\tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n\t\treturn;\n\t}\n\n\targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n\tif (!argb) {\n\t\treturn;\n\t}\n\tp = argb;\n\tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n\tif (out_size == 0) {\n\t\tgd_error(\"gd-webp encoding failed\");\n\t\tgoto freeargb;\n\t}\n\tgdPutBuf(out, out_size, outfile);\n\tfree(out);\n\nfreeargb:\n\tgdFree(argb);\n}",
        "func_after": "BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\t_gdImageWebpCtx(im, outfile, quality);\n}",
        "description": "A double free vulnerability exists in the gdImageWebPtr function within the GD Graphics Library (libgd) prior to version 2.2.4. This flaw enables remote attackers to exploit the vulnerability by providing large width and height values, potentially leading to unspecified impacts.",
        "commit": "A vulnerability was identified in the gdImageWebPtr() function, where a double-free error could occur due to the lack of error checking in the gdImageWebpCtx() function, which performs the actual WebP image processing. Specifically, gdImageWebpCtx() does not indicate whether it succeeds or fails, leading gdImageWebpPtr() to assume successful execution even when it encounters issues, such as exceeding the WebP size limitations (width and height must be less than 16383). To address this, a new static helper function _gdImageWebpCtx() was introduced to return success or failure status, allowing gdImageWebpPtr() and related functions to properly check the outcome of the WebP processing. The underlying issue was reported by Ibrahim El-Sayed to security@libgd.org."
    },
    {
        "cwe": "CWE-459",
        "func_name": "torvalds/fuse_do_setattr",
        "score": 0.7411443591117859,
        "func_before": "int fuse_do_setattr(struct dentry *dentry, struct iattr *attr,\n\t\t    struct file *file)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tstruct fuse_conn *fc = fm->fc;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_setattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tbool is_truncate = false;\n\tbool is_wb = fc->writeback_cache;\n\tloff_t oldsize;\n\tint err;\n\tbool trust_local_cmtime = is_wb && S_ISREG(inode->i_mode);\n\tbool fault_blocked = false;\n\n\tif (!fc->default_permissions)\n\t\tattr->ia_valid |= ATTR_FORCE;\n\n\terr = setattr_prepare(dentry, attr);\n\tif (err)\n\t\treturn err;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tif (WARN_ON(!S_ISREG(inode->i_mode)))\n\t\t\treturn -EIO;\n\t\tis_truncate = true;\n\t}\n\n\tif (FUSE_IS_DAX(inode) && is_truncate) {\n\t\tdown_write(&fi->i_mmap_sem);\n\t\tfault_blocked = true;\n\t\terr = fuse_dax_break_layouts(inode, 0, 0);\n\t\tif (err) {\n\t\t\tup_write(&fi->i_mmap_sem);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (attr->ia_valid & ATTR_OPEN) {\n\t\t/* This is coming from open(..., ... | O_TRUNC); */\n\t\tWARN_ON(!(attr->ia_valid & ATTR_SIZE));\n\t\tWARN_ON(attr->ia_size != 0);\n\t\tif (fc->atomic_o_trunc) {\n\t\t\t/*\n\t\t\t * No need to send request to userspace, since actual\n\t\t\t * truncation has already been done by OPEN.  But still\n\t\t\t * need to truncate page cache.\n\t\t\t */\n\t\t\ti_size_write(inode, 0);\n\t\t\ttruncate_pagecache(inode, 0);\n\t\t\tgoto out;\n\t\t}\n\t\tfile = NULL;\n\t}\n\n\t/* Flush dirty data/metadata before non-truncate SETATTR */\n\tif (is_wb && S_ISREG(inode->i_mode) &&\n\t    attr->ia_valid &\n\t\t\t(ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_MTIME_SET |\n\t\t\t ATTR_TIMES_SET)) {\n\t\terr = write_inode_now(inode, true);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tfuse_set_nowrite(inode);\n\t\tfuse_release_nowrite(inode);\n\t}\n\n\tif (is_truncate) {\n\t\tfuse_set_nowrite(inode);\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\t\tif (trust_local_cmtime && attr->ia_size != inode->i_size)\n\t\t\tattr->ia_valid |= ATTR_MTIME | ATTR_CTIME;\n\t}\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\tiattr_to_fattr(fc, attr, &inarg, trust_local_cmtime);\n\tif (file) {\n\t\tstruct fuse_file *ff = file->private_data;\n\t\tinarg.valid |= FATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\n\t/* Kill suid/sgid for non-directory chown unconditionally */\n\tif (fc->handle_killpriv_v2 && !S_ISDIR(inode->i_mode) &&\n\t    attr->ia_valid & (ATTR_UID | ATTR_GID))\n\t\tinarg.valid |= FATTR_KILL_SUIDGID;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t/* For mandatory locking in truncate */\n\t\tinarg.valid |= FATTR_LOCKOWNER;\n\t\tinarg.lock_owner = fuse_lock_owner_id(fc, current->files);\n\n\t\t/* Kill suid/sgid for truncate only if no CAP_FSETID */\n\t\tif (fc->handle_killpriv_v2 && !capable(CAP_FSETID))\n\t\t\tinarg.valid |= FATTR_KILL_SUIDGID;\n\t}\n\tfuse_setattr_fill(fc, &args, inode, &inarg, &outarg);\n\terr = fuse_simple_request(fm, &args);\n\tif (err) {\n\t\tif (err == -EINTR)\n\t\t\tfuse_invalidate_attr(inode);\n\t\tgoto error;\n\t}\n\n\tif (fuse_invalid_attr(&outarg.attr) ||\n\t    (inode->i_mode ^ outarg.attr.mode) & S_IFMT) {\n\t\tmake_bad_inode(inode);\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\n\tspin_lock(&fi->lock);\n\t/* the kernel maintains i_mtime locally */\n\tif (trust_local_cmtime) {\n\t\tif (attr->ia_valid & ATTR_MTIME)\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\tif (attr->ia_valid & ATTR_CTIME)\n\t\t\tinode->i_ctime = attr->ia_ctime;\n\t\t/* FIXME: clear I_DIRTY_SYNC? */\n\t}\n\n\tfuse_change_attributes_common(inode, &outarg.attr,\n\t\t\t\t      attr_timeout(&outarg));\n\toldsize = inode->i_size;\n\t/* see the comment in fuse_change_attributes() */\n\tif (!is_wb || is_truncate || !S_ISREG(inode->i_mode))\n\t\ti_size_write(inode, outarg.attr.size);\n\n\tif (is_truncate) {\n\t\t/* NOTE: this may release/reacquire fi->lock */\n\t\t__fuse_release_nowrite(inode);\n\t}\n\tspin_unlock(&fi->lock);\n\n\t/*\n\t * Only call invalidate_inode_pages2() after removing\n\t * FUSE_NOWRITE, otherwise fuse_launder_page() would deadlock.\n\t */\n\tif ((is_truncate || !is_wb) &&\n\t    S_ISREG(inode->i_mode) && oldsize != outarg.attr.size) {\n\t\ttruncate_pagecache(inode, outarg.attr.size);\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\nout:\n\tif (fault_blocked)\n\t\tup_write(&fi->i_mmap_sem);\n\n\treturn 0;\n\nerror:\n\tif (is_truncate)\n\t\tfuse_release_nowrite(inode);\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\tif (fault_blocked)\n\t\tup_write(&fi->i_mmap_sem);\n\treturn err;\n}",
        "func_after": "int fuse_do_setattr(struct dentry *dentry, struct iattr *attr,\n\t\t    struct file *file)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tstruct fuse_conn *fc = fm->fc;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_setattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tbool is_truncate = false;\n\tbool is_wb = fc->writeback_cache;\n\tloff_t oldsize;\n\tint err;\n\tbool trust_local_cmtime = is_wb && S_ISREG(inode->i_mode);\n\tbool fault_blocked = false;\n\n\tif (!fc->default_permissions)\n\t\tattr->ia_valid |= ATTR_FORCE;\n\n\terr = setattr_prepare(dentry, attr);\n\tif (err)\n\t\treturn err;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tif (WARN_ON(!S_ISREG(inode->i_mode)))\n\t\t\treturn -EIO;\n\t\tis_truncate = true;\n\t}\n\n\tif (FUSE_IS_DAX(inode) && is_truncate) {\n\t\tdown_write(&fi->i_mmap_sem);\n\t\tfault_blocked = true;\n\t\terr = fuse_dax_break_layouts(inode, 0, 0);\n\t\tif (err) {\n\t\t\tup_write(&fi->i_mmap_sem);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (attr->ia_valid & ATTR_OPEN) {\n\t\t/* This is coming from open(..., ... | O_TRUNC); */\n\t\tWARN_ON(!(attr->ia_valid & ATTR_SIZE));\n\t\tWARN_ON(attr->ia_size != 0);\n\t\tif (fc->atomic_o_trunc) {\n\t\t\t/*\n\t\t\t * No need to send request to userspace, since actual\n\t\t\t * truncation has already been done by OPEN.  But still\n\t\t\t * need to truncate page cache.\n\t\t\t */\n\t\t\ti_size_write(inode, 0);\n\t\t\ttruncate_pagecache(inode, 0);\n\t\t\tgoto out;\n\t\t}\n\t\tfile = NULL;\n\t}\n\n\t/* Flush dirty data/metadata before non-truncate SETATTR */\n\tif (is_wb && S_ISREG(inode->i_mode) &&\n\t    attr->ia_valid &\n\t\t\t(ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_MTIME_SET |\n\t\t\t ATTR_TIMES_SET)) {\n\t\terr = write_inode_now(inode, true);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tfuse_set_nowrite(inode);\n\t\tfuse_release_nowrite(inode);\n\t}\n\n\tif (is_truncate) {\n\t\tfuse_set_nowrite(inode);\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\t\tif (trust_local_cmtime && attr->ia_size != inode->i_size)\n\t\t\tattr->ia_valid |= ATTR_MTIME | ATTR_CTIME;\n\t}\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\tiattr_to_fattr(fc, attr, &inarg, trust_local_cmtime);\n\tif (file) {\n\t\tstruct fuse_file *ff = file->private_data;\n\t\tinarg.valid |= FATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\n\t/* Kill suid/sgid for non-directory chown unconditionally */\n\tif (fc->handle_killpriv_v2 && !S_ISDIR(inode->i_mode) &&\n\t    attr->ia_valid & (ATTR_UID | ATTR_GID))\n\t\tinarg.valid |= FATTR_KILL_SUIDGID;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t/* For mandatory locking in truncate */\n\t\tinarg.valid |= FATTR_LOCKOWNER;\n\t\tinarg.lock_owner = fuse_lock_owner_id(fc, current->files);\n\n\t\t/* Kill suid/sgid for truncate only if no CAP_FSETID */\n\t\tif (fc->handle_killpriv_v2 && !capable(CAP_FSETID))\n\t\t\tinarg.valid |= FATTR_KILL_SUIDGID;\n\t}\n\tfuse_setattr_fill(fc, &args, inode, &inarg, &outarg);\n\terr = fuse_simple_request(fm, &args);\n\tif (err) {\n\t\tif (err == -EINTR)\n\t\t\tfuse_invalidate_attr(inode);\n\t\tgoto error;\n\t}\n\n\tif (fuse_invalid_attr(&outarg.attr) ||\n\t    (inode->i_mode ^ outarg.attr.mode) & S_IFMT) {\n\t\tfuse_make_bad(inode);\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\n\tspin_lock(&fi->lock);\n\t/* the kernel maintains i_mtime locally */\n\tif (trust_local_cmtime) {\n\t\tif (attr->ia_valid & ATTR_MTIME)\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\tif (attr->ia_valid & ATTR_CTIME)\n\t\t\tinode->i_ctime = attr->ia_ctime;\n\t\t/* FIXME: clear I_DIRTY_SYNC? */\n\t}\n\n\tfuse_change_attributes_common(inode, &outarg.attr,\n\t\t\t\t      attr_timeout(&outarg));\n\toldsize = inode->i_size;\n\t/* see the comment in fuse_change_attributes() */\n\tif (!is_wb || is_truncate || !S_ISREG(inode->i_mode))\n\t\ti_size_write(inode, outarg.attr.size);\n\n\tif (is_truncate) {\n\t\t/* NOTE: this may release/reacquire fi->lock */\n\t\t__fuse_release_nowrite(inode);\n\t}\n\tspin_unlock(&fi->lock);\n\n\t/*\n\t * Only call invalidate_inode_pages2() after removing\n\t * FUSE_NOWRITE, otherwise fuse_launder_page() would deadlock.\n\t */\n\tif ((is_truncate || !is_wb) &&\n\t    S_ISREG(inode->i_mode) && oldsize != outarg.attr.size) {\n\t\ttruncate_pagecache(inode, outarg.attr.size);\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\nout:\n\tif (fault_blocked)\n\t\tup_write(&fi->i_mmap_sem);\n\n\treturn 0;\n\nerror:\n\tif (is_truncate)\n\t\tfuse_release_nowrite(inode);\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\tif (fault_blocked)\n\t\tup_write(&fi->i_mmap_sem);\n\treturn err;\n}",
        "description": "An issue was discovered in the FUSE filesystem implementation within the Linux kernel prior to version 5.10.6, identified as CID-5d069dbe8aaf. The function fuse_do_getattr() incorrectly invokes make_bad_inode(), leading to system crashes. Note that the initial fix for this vulnerability was incomplete and is separately tracked as CVE-2021-28950.",
        "commit": "A vulnerability was identified in the FUSE filesystem implementation within the Linux kernel, where opening a directory and attaching a dnotify mark leads to inconsistencies in the attributes returned by the server. This inconsistency triggers a call to `make_bad_inode()`, which sets the inode mode to a regular file. As a result, dnotify fails to properly tear down its structures, ultimately causing a crash. To address this issue, the approach should involve avoiding the use of `make_bad_inode()` on a live inode by introducing a private flag on the FUSE inode instead. Additionally, incorporating the necessary checks from `bad_inode_ops` into the operations can help mitigate this problem. This bug has been present since the initial integration of FUSE into the Linux kernel in version 2.6.14."
    },
    {
        "cwe": "CWE-367",
        "func_name": "torvalds/enter_svm_guest_mode",
        "score": 0.7170032262802124,
        "func_before": "int enter_svm_guest_mode(struct vcpu_svm *svm, u64 vmcb12_gpa,\n\t\t\t struct vmcb *vmcb12)\n{\n\tint ret;\n\n\tsvm->nested.vmcb12_gpa = vmcb12_gpa;\n\tload_nested_vmcb_control(svm, &vmcb12->control);\n\tnested_prepare_vmcb_save(svm, vmcb12);\n\tnested_prepare_vmcb_control(svm);\n\n\tret = nested_svm_load_cr3(&svm->vcpu, vmcb12->save.cr3,\n\t\t\t\t  nested_npt_enabled(svm));\n\tif (ret)\n\t\treturn ret;\n\n\tsvm_set_gif(svm, true);\n\n\treturn 0;\n}",
        "func_after": "int enter_svm_guest_mode(struct vcpu_svm *svm, u64 vmcb12_gpa,\n\t\t\t struct vmcb *vmcb12)\n{\n\tint ret;\n\n\tsvm->nested.vmcb12_gpa = vmcb12_gpa;\n\tnested_prepare_vmcb_save(svm, vmcb12);\n\tnested_prepare_vmcb_control(svm);\n\n\tret = nested_svm_load_cr3(&svm->vcpu, vmcb12->save.cr3,\n\t\t\t\t  nested_npt_enabled(svm));\n\tif (ret)\n\t\treturn ret;\n\n\tsvm_set_gif(svm, true);\n\n\treturn 0;\n}",
        "description": "A use-after-free vulnerability exists in the Linux kernel prior to version 5.11.12 within the AMD KVM SVM nested virtualization module. This flaw allows an AMD KVM guest to potentially bypass access controls on host OS Model-Specific Registers (MSRs) when multiple nested guests are present. The issue arises due to a Time-of-Check to Time-of-Use (TOCTOU) race condition involving a VMCB12 double fetch in the `nested_svm_vmrun` function.",
        "commit": "To avoid race conditions between checking and using nested VMCB controls, ensuring that the VMRUN intercept is consistently reflected to the nested hypervisor rather than being processed by the host is crucial. Without this patch, there is a risk that `svm->nested.hsave` could point to the MSR permission bitmap for nested guests, leading to potential vulnerabilities such as CVE-2021-29657."
    },
    {
        "cwe": "CWE-399",
        "func_name": "torvalds/rtl8169_rx_interrupt",
        "score": 0.7528274059295654,
        "func_before": "static int rtl8169_rx_interrupt(struct net_device *dev,\n\t\t\t\tstruct rtl8169_private *tp,\n\t\t\t\tvoid __iomem *ioaddr, u32 budget)\n{\n\tunsigned int cur_rx, rx_left;\n\tunsigned int delta, count;\n\n\tcur_rx = tp->cur_rx;\n\trx_left = NUM_RX_DESC + tp->dirty_rx - cur_rx;\n\trx_left = min(rx_left, budget);\n\n\tfor (; rx_left > 0; rx_left--, cur_rx++) {\n\t\tunsigned int entry = cur_rx % NUM_RX_DESC;\n\t\tstruct RxDesc *desc = tp->RxDescArray + entry;\n\t\tu32 status;\n\n\t\trmb();\n\t\tstatus = le32_to_cpu(desc->opts1);\n\n\t\tif (status & DescOwn)\n\t\t\tbreak;\n\t\tif (unlikely(status & RxRES)) {\n\t\t\tif (netif_msg_rx_err(tp)) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"%s: Rx ERROR. status = %08x\\n\",\n\t\t\t\t       dev->name, status);\n\t\t\t}\n\t\t\tdev->stats.rx_errors++;\n\t\t\tif (status & (RxRWT | RxRUNT))\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\tif (status & RxCRC)\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\tif (status & RxFOVF) {\n\t\t\t\trtl8169_schedule_work(dev, rtl8169_reset_task);\n\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\t}\n\t\t\trtl8169_mark_to_asic(desc, tp->rx_buf_sz);\n\t\t} else {\n\t\t\tstruct sk_buff *skb = tp->Rx_skbuff[entry];\n\t\t\tdma_addr_t addr = le64_to_cpu(desc->addr);\n\t\t\tint pkt_size = (status & 0x00001FFF) - 4;\n\t\t\tstruct pci_dev *pdev = tp->pci_dev;\n\n\t\t\t/*\n\t\t\t * The driver does not support incoming fragmented\n\t\t\t * frames. They are seen as a symptom of over-mtu\n\t\t\t * sized frames.\n\t\t\t */\n\t\t\tif (unlikely(rtl8169_fragmented_frame(status))) {\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t\trtl8169_mark_to_asic(desc, tp->rx_buf_sz);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trtl8169_rx_csum(skb, desc);\n\n\t\t\tif (rtl8169_try_rx_copy(&skb, tp, pkt_size, addr)) {\n\t\t\t\tpci_dma_sync_single_for_device(pdev, addr,\n\t\t\t\t\tpkt_size, PCI_DMA_FROMDEVICE);\n\t\t\t\trtl8169_mark_to_asic(desc, tp->rx_buf_sz);\n\t\t\t} else {\n\t\t\t\tpci_unmap_single(pdev, addr, pkt_size,\n\t\t\t\t\t\t PCI_DMA_FROMDEVICE);\n\t\t\t\ttp->Rx_skbuff[entry] = NULL;\n\t\t\t}\n\n\t\t\tskb_put(skb, pkt_size);\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\n\t\t\tif (rtl8169_rx_vlan_skb(tp, desc, skb) < 0)\n\t\t\t\tnetif_receive_skb(skb);\n\n\t\t\tdev->last_rx = jiffies;\n\t\t\tdev->stats.rx_bytes += pkt_size;\n\t\t\tdev->stats.rx_packets++;\n\t\t}\n\n\t\t/* Work around for AMD plateform. */\n\t\tif ((desc->opts2 & cpu_to_le32(0xfffe000)) &&\n\t\t    (tp->mac_version == RTL_GIGA_MAC_VER_05)) {\n\t\t\tdesc->opts2 = 0;\n\t\t\tcur_rx++;\n\t\t}\n\t}\n\n\tcount = cur_rx - tp->cur_rx;\n\ttp->cur_rx = cur_rx;\n\n\tdelta = rtl8169_rx_fill(tp, dev, tp->dirty_rx, tp->cur_rx);\n\tif (!delta && count && netif_msg_intr(tp))\n\t\tprintk(KERN_INFO \"%s: no Rx buffer allocated\\n\", dev->name);\n\ttp->dirty_rx += delta;\n\n\t/*\n\t * FIXME: until there is periodic timer to try and refill the ring,\n\t * a temporary shortage may definitely kill the Rx process.\n\t * - disable the asic to try and avoid an overflow and kick it again\n\t *   after refill ?\n\t * - how do others driver handle this condition (Uh oh...).\n\t */\n\tif ((tp->dirty_rx + NUM_RX_DESC == tp->cur_rx) && netif_msg_intr(tp))\n\t\tprintk(KERN_EMERG \"%s: Rx buffers exhausted\\n\", dev->name);\n\n\treturn count;\n}",
        "func_after": "static int rtl8169_rx_interrupt(struct net_device *dev,\n\t\t\t\tstruct rtl8169_private *tp,\n\t\t\t\tvoid __iomem *ioaddr, u32 budget)\n{\n\tunsigned int cur_rx, rx_left;\n\tunsigned int delta, count;\n\n\tcur_rx = tp->cur_rx;\n\trx_left = NUM_RX_DESC + tp->dirty_rx - cur_rx;\n\trx_left = min(rx_left, budget);\n\n\tfor (; rx_left > 0; rx_left--, cur_rx++) {\n\t\tunsigned int entry = cur_rx % NUM_RX_DESC;\n\t\tstruct RxDesc *desc = tp->RxDescArray + entry;\n\t\tu32 status;\n\n\t\trmb();\n\t\tstatus = le32_to_cpu(desc->opts1);\n\n\t\tif (status & DescOwn)\n\t\t\tbreak;\n\t\tif (unlikely(status & RxRES)) {\n\t\t\tif (netif_msg_rx_err(tp)) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"%s: Rx ERROR. status = %08x\\n\",\n\t\t\t\t       dev->name, status);\n\t\t\t}\n\t\t\tdev->stats.rx_errors++;\n\t\t\tif (status & (RxRWT | RxRUNT))\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\tif (status & RxCRC)\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\tif (status & RxFOVF) {\n\t\t\t\trtl8169_schedule_work(dev, rtl8169_reset_task);\n\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\t}\n\t\t\trtl8169_mark_to_asic(desc, tp->rx_buf_sz);\n\t\t} else {\n\t\t\tstruct sk_buff *skb = tp->Rx_skbuff[entry];\n\t\t\tdma_addr_t addr = le64_to_cpu(desc->addr);\n\t\t\tint pkt_size = (status & 0x00001FFF) - 4;\n\t\t\tstruct pci_dev *pdev = tp->pci_dev;\n\n\t\t\t/*\n\t\t\t * The driver does not support incoming fragmented\n\t\t\t * frames. They are seen as a symptom of over-mtu\n\t\t\t * sized frames.\n\t\t\t */\n\t\t\tif (unlikely(rtl8169_fragmented_frame(status))) {\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t\trtl8169_mark_to_asic(desc, tp->rx_buf_sz);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trtl8169_rx_csum(skb, desc);\n\n\t\t\tif (rtl8169_try_rx_copy(&skb, tp, pkt_size, addr)) {\n\t\t\t\tpci_dma_sync_single_for_device(pdev, addr,\n\t\t\t\t\tpkt_size, PCI_DMA_FROMDEVICE);\n\t\t\t\trtl8169_mark_to_asic(desc, tp->rx_buf_sz);\n\t\t\t} else {\n\t\t\t\tpci_unmap_single(pdev, addr, tp->rx_buf_sz,\n\t\t\t\t\t\t PCI_DMA_FROMDEVICE);\n\t\t\t\ttp->Rx_skbuff[entry] = NULL;\n\t\t\t}\n\n\t\t\tskb_put(skb, pkt_size);\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\n\t\t\tif (rtl8169_rx_vlan_skb(tp, desc, skb) < 0)\n\t\t\t\tnetif_receive_skb(skb);\n\n\t\t\tdev->last_rx = jiffies;\n\t\t\tdev->stats.rx_bytes += pkt_size;\n\t\t\tdev->stats.rx_packets++;\n\t\t}\n\n\t\t/* Work around for AMD plateform. */\n\t\tif ((desc->opts2 & cpu_to_le32(0xfffe000)) &&\n\t\t    (tp->mac_version == RTL_GIGA_MAC_VER_05)) {\n\t\t\tdesc->opts2 = 0;\n\t\t\tcur_rx++;\n\t\t}\n\t}\n\n\tcount = cur_rx - tp->cur_rx;\n\ttp->cur_rx = cur_rx;\n\n\tdelta = rtl8169_rx_fill(tp, dev, tp->dirty_rx, tp->cur_rx);\n\tif (!delta && count && netif_msg_intr(tp))\n\t\tprintk(KERN_INFO \"%s: no Rx buffer allocated\\n\", dev->name);\n\ttp->dirty_rx += delta;\n\n\t/*\n\t * FIXME: until there is periodic timer to try and refill the ring,\n\t * a temporary shortage may definitely kill the Rx process.\n\t * - disable the asic to try and avoid an overflow and kick it again\n\t *   after refill ?\n\t * - how do others driver handle this condition (Uh oh...).\n\t */\n\tif ((tp->dirty_rx + NUM_RX_DESC == tp->cur_rx) && netif_msg_intr(tp))\n\t\tprintk(KERN_EMERG \"%s: Rx buffers exhausted\\n\", dev->name);\n\n\treturn count;\n}",
        "description": "The swiotlb functionality within the r8169 driver of the Linux kernel, prior to version 2.6.27.22, is susceptible to a denial of service attack. This vulnerability arises when remote attackers utilize jumbo frames for extensive network traffic, such as through a flood ping, leading to IOMMU space exhaustion and ultimately causing a system crash.",
        "commit": "A memory leak issue has been identified in conjunction with the use of swiotlb (Software IO TLB) and jumbo frames. This problem has been documented in Bugzilla under ID 9468. The leak was brought to attention by Ilpo J\u00e4rvinen, and it has also been communicated to Edward Hsu."
    }
]