[
    {
        "cwe": "CWE-121",
        "func_name": "libtiff/TIFFReadCustomDirectory",
        "score": 0.7657120823860168,
        "func_before": "int\nTIFFReadCustomDirectory(TIFF* tif, toff_t diroff,\n\t\t\tconst TIFFFieldArray* infoarray)\n{\n\tstatic const char module[] = \"TIFFReadCustomDirectory\";\n\tTIFFDirEntry* dir;\n\tuint16_t dircount;\n\tTIFFDirEntry* dp;\n\tuint16_t di;\n\tconst TIFFField* fip;\n\tuint32_t fii;\n        (*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */\n\t_TIFFSetupFields(tif, infoarray);\n\tdircount=TIFFFetchDirectory(tif,diroff,&dir,NULL);\n\tif (!dircount)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"Failed to read custom directory at offset %\" PRIu64,diroff);\n\t\treturn 0;\n\t}\n\tTIFFFreeDirectory(tif);\n\t_TIFFmemset(&tif->tif_dir, 0, sizeof(TIFFDirectory));\n\tTIFFReadDirectoryCheckOrder(tif,dir,dircount);\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\n\t{\n\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\tif (fii == FAILED_FII)\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Unknown field with tag %\"PRIu16\" (0x%\"PRIx16\") encountered\",\n\t\t\t    dp->tdir_tag, dp->tdir_tag);\n\t\t\tif (!_TIFFMergeFields(tif, _TIFFCreateAnonField(tif,\n\t\t\t\t\t\tdp->tdir_tag,\n\t\t\t\t\t\t(TIFFDataType) dp->tdir_type),\n\t\t\t\t\t     1)) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Registering anonymous field with tag %\"PRIu16\" (0x%\"PRIx16\") failed\",\n\t\t\t\t    dp->tdir_tag, dp->tdir_tag);\n\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t} else {\n\t\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\t\t\tassert( fii != FAILED_FII );\n\t\t\t}\n\t\t}\n\t\tif (!dp->tdir_ignore)\n\t\t{\n\t\t\tfip=tif->tif_fields[fii];\n\t\t\tif (fip->field_bit==FIELD_IGNORE)\n\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* check data type */\n\t\t\t\twhile ((fip->field_type!=TIFF_ANY)&&(fip->field_type!=dp->tdir_type))\n\t\t\t\t{\n\t\t\t\t\tfii++;\n\t\t\t\t\tif ((fii==tif->tif_nfields)||\n\t\t\t\t\t    (tif->tif_fields[fii]->field_tag!=(uint32_t)dp->tdir_tag))\n\t\t\t\t\t{\n\t\t\t\t\t\tfii=0xFFFF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfip=tif->tif_fields[fii];\n\t\t\t\t}\n\t\t\t\tif (fii==0xFFFF)\n\t\t\t\t{\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\t    \"Wrong data type %\"PRIu16\" for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t    dp->tdir_type,fip->field_name);\n\t\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* check count if known in advance */\n\t\t\t\t\tif ((fip->field_readcount!=TIFF_VARIABLE)&&\n\t\t\t\t\t    (fip->field_readcount!=TIFF_VARIABLE2))\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32_t expected;\n\t\t\t\t\t\tif (fip->field_readcount==TIFF_SPP)\n\t\t\t\t\t\t\texpected=(uint32_t)tif->tif_dir.td_samplesperpixel;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\texpected=(uint32_t)fip->field_readcount;\n\t\t\t\t\t\tif (!CheckDirCount(tif,dp,expected))\n\t\t\t\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!dp->tdir_ignore) {\n\t\t\t\tswitch (dp->tdir_tag) \n\t\t\t\t{\n\t\t\t\t\tcase EXIFTAG_SUBJECTDISTANCE:\n                        if(fip->field_name != NULL && strncmp(fip->field_name, \"Tag \", 4) != 0 ) {\n                            /* should only be called on a Exif directory */\n                            /* when exifFields[] is active */\n                            (void)TIFFFetchSubjectDistance(tif, dp);\n                        }\n                        else {\n                            (void)TIFFFetchNormalTag(tif, dp, TRUE);\n                        }\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t(void)TIFFFetchNormalTag(tif, dp, TRUE);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} /*-- if (!dp->tdir_ignore) */\n\t\t}\n\t}\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn 1;\n}",
        "func_after": "int\nTIFFReadCustomDirectory(TIFF* tif, toff_t diroff,\n\t\t\tconst TIFFFieldArray* infoarray)\n{\n\tstatic const char module[] = \"TIFFReadCustomDirectory\";\n\tTIFFDirEntry* dir;\n\tuint16_t dircount;\n\tTIFFDirEntry* dp;\n\tuint16_t di;\n\tconst TIFFField* fip;\n\tuint32_t fii;\n        (*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */\n\t_TIFFSetupFields(tif, infoarray);\n\tdircount=TIFFFetchDirectory(tif,diroff,&dir,NULL);\n\tif (!dircount)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"Failed to read custom directory at offset %\" PRIu64,diroff);\n\t\treturn 0;\n\t}\n\tTIFFFreeDirectory(tif);\n\t_TIFFmemset(&tif->tif_dir, 0, sizeof(TIFFDirectory));\n\tTIFFReadDirectoryCheckOrder(tif,dir,dircount);\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\n\t{\n\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\tif (fii == FAILED_FII)\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Unknown field with tag %\"PRIu16\" (0x%\"PRIx16\") encountered\",\n\t\t\t    dp->tdir_tag, dp->tdir_tag);\n\t\t\tif (!_TIFFMergeFields(tif, _TIFFCreateAnonField(tif,\n\t\t\t\t\t\tdp->tdir_tag,\n\t\t\t\t\t\t(TIFFDataType) dp->tdir_type),\n\t\t\t\t\t     1)) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Registering anonymous field with tag %\"PRIu16\" (0x%\"PRIx16\") failed\",\n\t\t\t\t    dp->tdir_tag, dp->tdir_tag);\n\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t} else {\n\t\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\t\t\tassert( fii != FAILED_FII );\n\t\t\t}\n\t\t}\n\t\tif (!dp->tdir_ignore)\n\t\t{\n\t\t\tfip=tif->tif_fields[fii];\n\t\t\tif (fip->field_bit==FIELD_IGNORE)\n\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* check data type */\n\t\t\t\twhile ((fip->field_type!=TIFF_ANY)&&(fip->field_type!=dp->tdir_type))\n\t\t\t\t{\n\t\t\t\t\tfii++;\n\t\t\t\t\tif ((fii==tif->tif_nfields)||\n\t\t\t\t\t    (tif->tif_fields[fii]->field_tag!=(uint32_t)dp->tdir_tag))\n\t\t\t\t\t{\n\t\t\t\t\t\tfii=0xFFFF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfip=tif->tif_fields[fii];\n\t\t\t\t}\n\t\t\t\tif (fii==0xFFFF)\n\t\t\t\t{\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\t    \"Wrong data type %\"PRIu16\" for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t    dp->tdir_type,fip->field_name);\n\t\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* check count if known in advance */\n\t\t\t\t\tif ((fip->field_readcount!=TIFF_VARIABLE)&&\n\t\t\t\t\t    (fip->field_readcount!=TIFF_VARIABLE2))\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32_t expected;\n\t\t\t\t\t\tif (fip->field_readcount==TIFF_SPP)\n\t\t\t\t\t\t\texpected=(uint32_t)tif->tif_dir.td_samplesperpixel;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\texpected=(uint32_t)fip->field_readcount;\n\t\t\t\t\t\tif (!CheckDirCount(tif,dp,expected))\n\t\t\t\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!dp->tdir_ignore) {\n\t\t\t\tswitch (dp->tdir_tag) \n\t\t\t\t{\n\t\t\t\t\tcase EXIFTAG_SUBJECTDISTANCE:\n                        if(!TIFFFieldIsAnonymous(fip)) {\n                            /* should only be called on a Exif directory */\n                            /* when exifFields[] is active */\n                            (void)TIFFFetchSubjectDistance(tif, dp);\n                        }\n                        else {\n                            (void)TIFFFetchNormalTag(tif, dp, TRUE);\n                        }\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t(void)TIFFFetchNormalTag(tif, dp, TRUE);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} /*-- if (!dp->tdir_ignore) */\n\t\t}\n\t}\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn 1;\n}",
        "description": "A stack buffer overflow vulnerability exists in the `main()` function of Libtiffs' `tiffcp.c`. This flaw enables an attacker to exploit it by providing a specially crafted TIFF file to the `tiffcp` tool, resulting in a stack buffer overflow. This can lead to memory corruption and ultimately cause a crash, leading to a denial of service.",
        "commit": "The addition of an extra flag for handling anonymous or unknown tags."
    },
    {
        "cwe": "CWE-613",
        "func_name": "arangodb/RestAuthHandler::execute",
        "score": 0.7209590673446655,
        "func_before": "RestStatus RestAuthHandler__execute() {\n  auto const type = _request->requestType();\n  if (type != rest::RequestType::POST) {\n    generateError(rest::ResponseCode::METHOD_NOT_ALLOWED, TRI_ERROR_HTTP_METHOD_NOT_ALLOWED);\n    return RestStatus::DONE;\n  }\n\n  bool parseSuccess = false;\n  VPackSlice slice = this->parseVPackBody(parseSuccess);\n  if (!parseSuccess) { // error already set\n    return RestStatus::DONE;\n  }\n\n  if (!slice.isObject()) {\n    return badRequest();\n  }\n\n  VPackSlice usernameSlice = slice.get(\"username\");\n  VPackSlice passwordSlice = slice.get(\"password\");\n\n  if (!usernameSlice.isString() || !passwordSlice.isString()) {\n    return badRequest();\n  }\n\n  _username = usernameSlice.copyString();\n  std::string const password = passwordSlice.copyString();\n\n  auth::UserManager* um = AuthenticationFeature::instance()->userManager();\n  if (um == nullptr) {\n    std::string msg = \"This server does not support users\";\n    LOG_TOPIC(\"2e7d4\", ERR, Logger::AUTHENTICATION) << msg;\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED, msg);\n  } else if (um->checkPassword(_username, password)) {\n    VPackBuilder resultBuilder;\n    {\n      VPackObjectBuilder b(&resultBuilder);\n      std::string jwt = generateJwt(_username, password);\n      resultBuilder.add(\"jwt\", VPackValue(jwt));\n    }\n\n    _isValid = true;\n    generateDocument(resultBuilder.slice(), true, &VPackOptions::Defaults);\n  } else {\n    // mop: rfc 2616 10.4.2 (if credentials wrong 401)\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED,\n                  \"Wrong credentials\");\n  }\n  return RestStatus::DONE;\n}",
        "func_after": "RestStatus RestAuthHandler__execute() {\n  auto const type = _request->requestType();\n  if (type != rest::RequestType::POST) {\n    generateError(rest::ResponseCode::METHOD_NOT_ALLOWED, TRI_ERROR_HTTP_METHOD_NOT_ALLOWED);\n    return RestStatus::DONE;\n  }\n\n  bool parseSuccess = false;\n  VPackSlice slice = this->parseVPackBody(parseSuccess);\n  if (!parseSuccess) { // error already set\n    return RestStatus::DONE;\n  }\n\n  if (!slice.isObject()) {\n    return badRequest();\n  }\n\n  VPackSlice usernameSlice = slice.get(\"username\");\n  VPackSlice passwordSlice = slice.get(\"password\");\n\n  if (!usernameSlice.isString() || !passwordSlice.isString()) {\n    return badRequest();\n  }\n\n  std::string const username = usernameSlice.copyString();\n  std::string const password = passwordSlice.copyString();\n\n  bool isValid = false;\n\n  auto guard = scopeGuard([&]() {\n    try {\n      if (isValid) {\n        events::LoggedIn(*_request, username);\n      } else {\n        events::CredentialsBad(*_request, username);\n      }\n    } catch (...) {\n      // nothing we can do\n    }\n  });\n  \n  auth::UserManager* um = AuthenticationFeature::instance()->userManager();\n  if (um == nullptr) {\n    std::string msg = \"This server does not support users\";\n    LOG_TOPIC(\"2e7d4\", ERR, Logger::AUTHENTICATION) << msg;\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED, msg);\n  } else if (um->checkPassword(username, password)) {\n    VPackBuilder resultBuilder;\n    {\n      VPackObjectBuilder b(&resultBuilder);\n      resultBuilder.add(\"jwt\", VPackValue(generateJwt(username)));\n    }\n\n    isValid = true;\n    generateDocument(resultBuilder.slice(), true, &VPackOptions::Defaults);\n  } else {\n    // mop: rfc 2616 10.4.2 (if credentials wrong 401)\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED,\n                  \"Wrong credentials\");\n  }\n  return RestStatus::DONE;\n}",
        "description": "ArangoDB versions v3.7.6 through v3.8.3 are susceptible to an Insufficient Session Expiration issue. Specifically, when an administrator changes a user's password, the associated session is not invalidated. This failure allows a malicious user who is still logged in to continue performing arbitrary actions within the system.",
        "commit": "The startup parameter `--server.session-timeout` has been revived."
    },
    {
        "cwe": "CWE-444",
        "func_name": "varnishcache/h2_vfp_body",
        "score": 0.7438428997993469,
        "func_before": "static enum vfp_status v_matchproto_(vfp_pull_f)\nh2_vfp_body(struct vfp_ctx *vc, struct vfp_entry *vfe, void *ptr, ssize_t *lp)\n{\n\tstruct h2_req *r2;\n\tstruct h2_sess *h2;\n\tunsigned l;\n\tenum vfp_status retval = VFP_OK;\n\n\tCHECK_OBJ_NOTNULL(vc, VFP_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(vfe, VFP_ENTRY_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, vfe->priv1, H2_REQ_MAGIC);\n\th2 = r2->h2sess;\n\n\tAN(ptr);\n\tAN(lp);\n\tl = *lp;\n\t*lp = 0;\n\n\tLck_Lock(&h2->sess->mtx);\n\tassert (r2->state == H2_S_OPEN);\n\tr2->cond = &vc->wrk->cond;\n\twhile (h2->mailcall != r2 && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(r2->cond, &h2->sess->mtx, 0));\n\tr2->cond = NULL;\n\tif (h2->error || r2->error) {\n\t\tretval = VFP_ERROR;\n\t} else {\n\t\tassert(h2->mailcall == r2);\n\t\tif (l > h2->rxf_len)\n\t\t\tl = h2->rxf_len;\n\t\tif (l > 0) {\n\t\t\tmemcpy(ptr, h2->rxf_data, l);\n\t\t\th2->rxf_data += l;\n\t\t\th2->rxf_len -= l;\n\t\t}\n\t\t*lp = l;\n\t\tif (h2->rxf_len > 0) {\n\t\t\t/* We ran out of storage: Have VFP call us\n\t\t\t * again with a fresh buffer */\n\t\t\tLck_Unlock(&h2->sess->mtx);\n\t\t\treturn (VFP_OK);\n\t\t}\n\t\tif (h2->rxf_len == 0) {\n\t\t\tif (h2->rxf_flags & H2FF_DATA_END_STREAM) {\n\t\t\t\tretval = VFP_END;\n\t\t\t\tr2->state = H2_S_CLOS_REM;\n\t\t\t}\n\t\t}\n\t\th2->mailcall = NULL;\n\t\tAZ(pthread_cond_signal(h2->cond));\n\t}\n\tLck_Unlock(&h2->sess->mtx);\n\treturn (retval);\n}",
        "func_after": "static enum vfp_status v_matchproto_(vfp_pull_f)\nh2_vfp_body(struct vfp_ctx *vc, struct vfp_entry *vfe, void *ptr, ssize_t *lp)\n{\n\tstruct h2_req *r2;\n\tstruct h2_sess *h2;\n\tunsigned l;\n\tenum vfp_status retval;\n\n\tCHECK_OBJ_NOTNULL(vc, VFP_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(vfe, VFP_ENTRY_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, vfe->priv1, H2_REQ_MAGIC);\n\th2 = r2->h2sess;\n\n\tAN(ptr);\n\tAN(lp);\n\tl = *lp;\n\t*lp = 0;\n\n\tLck_Lock(&h2->sess->mtx);\n\tr2->cond = &vc->wrk->cond;\n\twhile (h2->mailcall != r2 && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(r2->cond, &h2->sess->mtx, 0));\n\tr2->cond = NULL;\n\tif (h2->error || r2->error) {\n\t\tretval = VFP_ERROR;\n\t} else {\n\t\tassert(h2->mailcall == r2);\n\t\tif (l > h2->rxf_len)\n\t\t\tl = h2->rxf_len;\n\t\tif (l > 0) {\n\t\t\tmemcpy(ptr, h2->rxf_data, l);\n\t\t\th2->rxf_data += l;\n\t\t\th2->rxf_len -= l;\n\t\t}\n\t\t*lp = l;\n\t\tif (h2->rxf_len > 0) {\n\t\t\t/* We ran out of storage: Have VFP call us\n\t\t\t * again with a fresh buffer */\n\t\t\tLck_Unlock(&h2->sess->mtx);\n\t\t\treturn (VFP_OK);\n\t\t}\n\t\tif (h2->rxf_len == 0 && r2->state >= H2_S_CLOS_REM)\n\t\t\tretval = VFP_END;\n\t\telse\n\t\t\tretval = VFP_OK;\n\t\th2->mailcall = NULL;\n\t\tAZ(pthread_cond_signal(h2->cond));\n\t}\n\tLck_Unlock(&h2->sess->mtx);\n\treturn (retval);\n}",
        "description": "Varnish Cache, when HTTP/2 is enabled, is susceptible to request smuggling and VCL authorization bypass through the use of an excessively large Content-Length header in a POST request. This vulnerability impacts various versions of Varnish Enterprise and Varnish Cache, including specific releases prior to certain patch levels.",
        "commit": "When processing HTTP/2 (H/2) request bodies, ensure that the total size of received data frames aligns with the advertised content length. If the cumulative size of the data frames does not match the specified content length, the system should appropriately fail the request."
    },
    {
        "cwe": "CWE-385",
        "func_name": "openssl/ecdsa_sign_setup",
        "score": 0.7648937106132507,
        "func_before": "static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,\n\t\t\t\t\tBIGNUM **kinvp, BIGNUM **rp,\n\t\t\t\t\tconst unsigned char *dgst, int dlen)\n{\n\tBN_CTX   *ctx = NULL;\n\tBIGNUM\t *k = NULL, *r = NULL, *order = NULL, *X = NULL;\n\tEC_POINT *tmp_point=NULL;\n\tconst EC_GROUP *group;\n\tint \t ret = 0;\n\n\tif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\n\tif (ctx_in == NULL) \n\t{\n\t\tif ((ctx = BN_CTX_new()) == NULL)\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t\tctx = ctx_in;\n\n\tk     = BN_new();\t/* this value is later returned in *kinvp */\n\tr     = BN_new();\t/* this value is later returned in *rp    */\n\torder = BN_new();\n\tX     = BN_new();\n\tif (!k || !r || !order || !X)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t}\n\tif ((tmp_point = EC_POINT_new(group)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\tif (!EC_GROUP_get_order(group, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\n#ifdef OPENSSL_FIPS\n\tif (!fips_check_ec_prng(eckey))\n\t\tgoto err;\n#endif\n\t\n\tdo\n\t{\n\t\t/* get random k */\t\n\t\tdo\n#ifndef OPENSSL_NO_SHA512\n\t\t\tif (dgst != NULL)\n\t\t\t{\n\t\t\t\tif (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),\n\t\t\t\t\t\t\t   dgst, dlen, ctx))\n\t\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tif (!BN_rand_range(k, order))\n\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\twhile (BN_is_zero(k));\n\n\t\t/* We do not want timing information to leak the length of k,\n\t\t * so we compute G*k using an equivalent scalar of fixed\n\t\t * bit-length. */\n\n\t\tif (!BN_add(k, k, order)) goto err;\n\t\tif (BN_num_bits(k) <= BN_num_bits(order))\n\t\t\tif (!BN_add(k, k, order)) goto err;\n\n\t\t/* compute r the x-coordinate of generator * k */\n\t\tif (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t}\n\t\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#ifndef OPENSSL_NO_EC2M\n\t\telse /* NID_X9_62_characteristic_two_field */\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GF2m(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!BN_nnmod(r, X, order, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t}\n\t}\n\twhile (BN_is_zero(r));\n\n\t/* compute the inverse of k */\n\tif (!BN_mod_inverse(k, k, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\tgoto err;\t\n\t}\n\t/* clear old values if necessary */\n\tif (*rp != NULL)\n\t\tBN_clear_free(*rp);\n\tif (*kinvp != NULL) \n\t\tBN_clear_free(*kinvp);\n\t/* save the pre-computed values  */\n\t*rp    = r;\n\t*kinvp = k;\n\tret = 1;\nerr:\n\tif (!ret)\n\t{\n\t\tif (k != NULL) BN_clear_free(k);\n\t\tif (r != NULL) BN_clear_free(r);\n\t}\n\tif (ctx_in == NULL) \n\t\tBN_CTX_free(ctx);\n\tif (order != NULL)\n\t\tBN_free(order);\n\tif (tmp_point != NULL) \n\t\tEC_POINT_free(tmp_point);\n\tif (X)\n\t\tBN_clear_free(X);\n\treturn(ret);\n}",
        "func_after": "static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,\n\t\t\t\t\tBIGNUM **kinvp, BIGNUM **rp,\n\t\t\t\t\tconst unsigned char *dgst, int dlen)\n{\n\tBN_CTX   *ctx = NULL;\n\tBIGNUM\t *k = NULL, *r = NULL, *order = NULL, *X = NULL;\n\tEC_POINT *tmp_point=NULL;\n\tconst EC_GROUP *group;\n\tint \t ret = 0;\n\n\tif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\n\tif (ctx_in == NULL) \n\t{\n\t\tif ((ctx = BN_CTX_new()) == NULL)\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t\tctx = ctx_in;\n\n\tk     = BN_new();\t/* this value is later returned in *kinvp */\n\tr     = BN_new();\t/* this value is later returned in *rp    */\n\torder = BN_new();\n\tX     = BN_new();\n\tif (!k || !r || !order || !X)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t}\n\tif ((tmp_point = EC_POINT_new(group)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\tif (!EC_GROUP_get_order(group, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\n#ifdef OPENSSL_FIPS\n\tif (!fips_check_ec_prng(eckey))\n\t\tgoto err;\n#endif\n\t\n\tdo\n\t{\n\t\t/* get random k */\t\n\t\tdo\n#ifndef OPENSSL_NO_SHA512\n\t\t\tif (dgst != NULL)\n\t\t\t{\n\t\t\t\tif (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),\n\t\t\t\t\t\t\t   dgst, dlen, ctx))\n\t\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tif (!BN_rand_range(k, order))\n\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\twhile (BN_is_zero(k));\n\n\t\t/* We do not want timing information to leak the length of k,\n\t\t * so we compute G*k using an equivalent scalar of fixed\n\t\t * bit-length. */\n\n\t\tif (!BN_add(k, k, order)) goto err;\n\t\tif (BN_num_bits(k) <= BN_num_bits(order))\n\t\t\tif (!BN_add(k, k, order)) goto err;\n\n\t\t/* compute r the x-coordinate of generator * k */\n\t\tif (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t}\n\t\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#ifndef OPENSSL_NO_EC2M\n\t\telse /* NID_X9_62_characteristic_two_field */\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GF2m(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!BN_nnmod(r, X, order, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t}\n\t}\n\twhile (BN_is_zero(r));\n\n\t/* compute the inverse of k */\n\tif (EC_GROUP_get_mont_data(group) != NULL)\n\t\t{\n\t\t/* We want inverse in constant time, therefore we utilize the\n\t\t * fact order must be prime and use Fermats Little Theorem\n\t\t * instead. */\n\t\tif (!BN_set_word(X, 2) )\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (!BN_mod_sub(X, order, X, order, ctx))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tBN_set_flags(X, BN_FLG_CONSTTIME);\n\t\tif (!BN_mod_exp_mont_consttime(k, k, X, order, ctx, EC_GROUP_get_mont_data(group)))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tif (!BN_mod_inverse(k, k, order, ctx))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\t\n\t\t\t}\n\t\t}\n\n\t/* clear old values if necessary */\n\tif (*rp != NULL)\n\t\tBN_clear_free(*rp);\n\tif (*kinvp != NULL) \n\t\tBN_clear_free(*kinvp);\n\t/* save the pre-computed values  */\n\t*rp    = r;\n\t*kinvp = k;\n\tret = 1;\nerr:\n\tif (!ret)\n\t{\n\t\tif (k != NULL) BN_clear_free(k);\n\t\tif (r != NULL) BN_clear_free(r);\n\t}\n\tif (ctx_in == NULL) \n\t\tBN_CTX_free(ctx);\n\tif (order != NULL)\n\t\tBN_free(order);\n\tif (tmp_point != NULL) \n\t\tEC_POINT_free(tmp_point);\n\tif (X)\n\t\tBN_clear_free(X);\n\treturn(ret);\n}",
        "description": "A timing attack vulnerability was identified in OpenSSL versions prior to 1.0.1u, enabling a malicious user with local access to potentially recover ECDSA P-256 private keys through the exploitation of timing variations in cryptographic operations.",
        "commit": "The vulnerability knowledge has been abstracted and generalized as follows:\n\n\"The implementation of ECDSA includes an option to utilize BN_mod_exp_mont_consttime, a constant-time modular exponentiation function. This enhancement aims to improve the security of ECDSA operations.\""
    },
    {
        "cwe": "CWE-436",
        "func_name": "xen-project/sh_page_fault",
        "score": 0.7636818885803223,
        "func_before": "static int sh_page_fault(struct vcpu *v,\n                          unsigned long va,\n                          struct cpu_user_regs *regs)\n{\n    struct domain *d = v->domain;\n    walk_t gw;\n    gfn_t gfn = _gfn(0);\n    mfn_t gmfn, sl1mfn = _mfn(0);\n    shadow_l1e_t sl1e, *ptr_sl1e;\n    paddr_t gpa;\n    struct sh_emulate_ctxt emul_ctxt;\n    const struct x86_emulate_ops *emul_ops;\n    int r;\n    p2m_type_t p2mt;\n    uint32_t rc, error_code;\n    bool walk_ok;\n    int version;\n    unsigned int cpl;\n    const struct npfec access = {\n         .read_access = 1,\n         .write_access = !!(regs->error_code & PFEC_write_access),\n         .gla_valid = 1,\n         .kind = npfec_kind_with_gla\n    };\n    const fetch_type_t ft =\n        access.write_access ? ft_demand_write : ft_demand_read;\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n    int fast_emul = 0;\n#endif\n\n    SHADOW_PRINTK(\"%pv va=%#lx err=%#x, rip=%lx\\n\",\n                  v, va, regs->error_code, regs->rip);\n\n    perfc_incr(shadow_fault);\n\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n    /* If faulting frame is successfully emulated in last shadow fault\n     * it's highly likely to reach same emulation action for this frame.\n     * Then try to emulate early to avoid lock aquisition.\n     */\n    if ( v->arch.paging.last_write_emul_ok\n         && v->arch.paging.shadow.last_emulated_frame == (va >> PAGE_SHIFT) )\n    {\n        /* check whether error code is 3, or else fall back to normal path\n         * in case of some validation is required\n         */\n        if ( regs->error_code == (PFEC_write_access | PFEC_page_present) )\n        {\n            fast_emul = 1;\n            gmfn = _mfn(v->arch.paging.shadow.last_emulated_mfn);\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n            /* Fall back to the slow path if we're trying to emulate\n               writes to an out of sync page. */\n            if ( mfn_valid(gmfn) && mfn_is_out_of_sync(gmfn) )\n            {\n                fast_emul = 0;\n                v->arch.paging.last_write_emul_ok = 0;\n                goto page_fault_slow_path;\n            }\n#endif /* OOS */\n\n            perfc_incr(shadow_fault_fast_emulate);\n            goto early_emulation;\n        }\n        else\n            v->arch.paging.last_write_emul_ok = 0;\n    }\n#endif\n\n    //\n    // XXX: Need to think about eventually mapping superpages directly in the\n    //      shadow (when possible), as opposed to splintering them into a\n    //      bunch of 4K maps.\n    //\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_FAST_FAULT_PATH)\n    if ( (regs->error_code & PFEC_reserved_bit) )\n    {\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n        /* First, need to check that this isn't an out-of-sync\n         * shadow l1e.  If it is, we fall back to the slow path, which\n         * will sync it up again. */\n        {\n            shadow_l2e_t sl2e;\n            mfn_t gl1mfn;\n            if ( (__copy_from_user(&sl2e,\n                                   (sh_linear_l2_table(v)\n                                    + shadow_l2_linear_offset(va)),\n                                   sizeof(sl2e)) != 0)\n                 || !(shadow_l2e_get_flags(sl2e) & _PAGE_PRESENT)\n                 || !mfn_valid(gl1mfn = backpointer(mfn_to_page(\n                                  shadow_l2e_get_mfn(sl2e))))\n                 || unlikely(mfn_is_out_of_sync(gl1mfn)) )\n            {\n                /* Hit the slow path as if there had been no\n                 * shadow entry at all, and let it tidy up */\n                ASSERT(regs->error_code & PFEC_page_present);\n                regs->error_code ^= (PFEC_reserved_bit|PFEC_page_present);\n                goto page_fault_slow_path;\n            }\n        }\n#endif /* SHOPT_OUT_OF_SYNC */\n        /* The only reasons for reserved bits to be set in shadow entries\n         * are the two \"magic\" shadow_l1e entries. */\n        if ( likely((__copy_from_user(&sl1e,\n                                      (sh_linear_l1_table(v)\n                                       + shadow_l1_linear_offset(va)),\n                                      sizeof(sl1e)) == 0)\n                    && sh_l1e_is_magic(sl1e)) )\n        {\n\n            if ( sh_l1e_is_gnp(sl1e) )\n            {\n                /* Not-present in a guest PT: pass to the guest as\n                 * a not-present fault (by flipping two bits). */\n                ASSERT(regs->error_code & PFEC_page_present);\n                regs->error_code ^= (PFEC_reserved_bit|PFEC_page_present);\n                sh_reset_early_unshadow(v);\n                perfc_incr(shadow_fault_fast_gnp);\n                SHADOW_PRINTK(\"fast path not-present\\n\");\n                trace_shadow_gen(TRC_SHADOW_FAST_PROPAGATE, va);\n                return 0;\n            }\n#ifdef CONFIG_HVM\n            /* Magic MMIO marker: extract gfn for MMIO address */\n            ASSERT(sh_l1e_is_mmio(sl1e));\n            ASSERT(is_hvm_vcpu(v));\n            gpa = gfn_to_gaddr(sh_l1e_mmio_get_gfn(sl1e)) | (va & ~PAGE_MASK);\n            perfc_incr(shadow_fault_fast_mmio);\n            SHADOW_PRINTK(\"fast path mmio %#\"PRIpaddr\"\\n\", gpa);\n            sh_reset_early_unshadow(v);\n            trace_shadow_gen(TRC_SHADOW_FAST_MMIO, va);\n            return handle_mmio_with_translation(va, gpa >> PAGE_SHIFT, access)\n                   ? EXCRET_fault_fixed : 0;\n#else\n            /* When HVM is not enabled, there shouldn't be MMIO marker */\n            BUG();\n#endif\n        }\n        else\n        {\n            /* This should be exceptionally rare: another vcpu has fixed\n             * the tables between the fault and our reading the l1e.\n             * Retry and let the hardware give us the right fault next time. */\n            perfc_incr(shadow_fault_fast_fail);\n            SHADOW_PRINTK(\"fast path false alarm!\\n\");\n            trace_shadow_gen(TRC_SHADOW_FALSE_FAST_PATH, va);\n            return EXCRET_fault_fixed;\n        }\n    }\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n page_fault_slow_path:\n#endif\n#endif /* SHOPT_FAST_FAULT_PATH */\n\n    /* Detect if this page fault happened while we were already in Xen\n     * doing a shadow operation.  If that happens, the only thing we can\n     * do is let Xen's normal fault handlers try to fix it.  In any case,\n     * a diagnostic trace of the fault will be more useful than\n     * a BUG() when we try to take the lock again. */\n    if ( unlikely(paging_locked_by_me(d)) )\n    {\n        printk(XENLOG_G_ERR \"Recursive shadow fault: lock taken by %s\\n\",\n               d->arch.paging.lock.locker_function);\n        return 0;\n    }\n\n    cpl = is_pv_vcpu(v) ? (regs->ss & 3) : hvm_get_cpl(v);\n\n rewalk:\n\n    error_code = regs->error_code;\n\n    /*\n     * When CR4.SMAP is enabled, instructions which have a side effect of\n     * accessing the system data structures (e.g. mov to %ds accessing the\n     * LDT/GDT, or int $n accessing the IDT) are known as implicit supervisor\n     * accesses.\n     *\n     * The distinction between implicit and explicit accesses form part of the\n     * determination of access rights, controlling whether the access is\n     * successful, or raises a #PF.\n     *\n     * Unfortunately, the processor throws away the implicit/explicit\n     * distinction and does not provide it to the pagefault handler\n     * (i.e. here.) in the #PF error code.  Therefore, we must try to\n     * reconstruct the lost state so it can be fed back into our pagewalk\n     * through the guest tables.\n     *\n     * User mode accesses are easy to reconstruct:\n     *\n     *   If we observe a cpl3 data fetch which was a supervisor walk, this\n     *   must have been an implicit access to a system table.\n     *\n     * Supervisor mode accesses are not easy:\n     *\n     *   In principle, we could decode the instruction under %rip and have the\n     *   instruction emulator tell us if there is an implicit access.\n     *   However, this is racy with other vcpus updating the pagetable or\n     *   rewriting the instruction stream under our feet.\n     *\n     *   Therefore, we do nothing.  (If anyone has a sensible suggestion for\n     *   how to distinguish these cases, xen-devel@ is all ears...)\n     *\n     * As a result, one specific corner case will fail.  If a guest OS with\n     * SMAP enabled ends up mapping a system table with user mappings, sets\n     * EFLAGS.AC to allow explicit accesses to user mappings, and implicitly\n     * accesses the user mapping, hardware and the shadow code will disagree\n     * on whether a #PF should be raised.\n     *\n     * Hardware raises #PF because implicit supervisor accesses to user\n     * mappings are strictly disallowed.  As we can't reconstruct the correct\n     * input, the pagewalk is performed as if it were an explicit access,\n     * which concludes that the access should have succeeded and the shadow\n     * pagetables need modifying.  The shadow pagetables are modified (to the\n     * same value), and we re-enter the guest to re-execute the instruction,\n     * which causes another #PF, and the vcpu livelocks, unable to make\n     * forward progress.\n     *\n     * In practice, this is tolerable.  No production OS will deliberately\n     * construct this corner case (as doing so would mean that a system table\n     * is directly accessable to userspace, and the OS is trivially rootable.)\n     * If this corner case comes about accidentally, then a security-relevant\n     * bug has been tickled.\n     */\n    if ( !(error_code & (PFEC_insn_fetch|PFEC_user_mode)) && cpl == 3 )\n        error_code |= PFEC_implicit;\n\n    /* The walk is done in a lock-free style, with some sanity check\n     * postponed after grabbing paging lock later. Those delayed checks\n     * will make sure no inconsistent mapping being translated into\n     * shadow page table. */\n    version = atomic_read(&d->arch.paging.shadow.gtable_dirty_version);\n    smp_rmb();\n    walk_ok = sh_walk_guest_tables(v, va, &gw, error_code);\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n    regs->error_code &= ~PFEC_page_present;\n    if ( gw.pfec & PFEC_page_present )\n        regs->error_code |= PFEC_page_present;\n#endif\n\n    if ( !walk_ok )\n    {\n        perfc_incr(shadow_fault_bail_real_fault);\n        SHADOW_PRINTK(\"not a shadow fault\\n\");\n        sh_reset_early_unshadow(v);\n        regs->error_code = gw.pfec & PFEC_arch_mask;\n        goto propagate;\n    }\n\n    /* It's possible that the guest has put pagetables in memory that it has\n     * already used for some special purpose (ioreq pages, or granted pages).\n     * If that happens we'll have killed the guest already but it's still not\n     * safe to propagate entries out of the guest PT so get out now. */\n    if ( unlikely(d->is_shutting_down && d->shutdown_code == SHUTDOWN_crash) )\n    {\n        SHADOW_PRINTK(\"guest is shutting down\\n\");\n        goto propagate;\n    }\n\n    /* What mfn is the guest trying to access? */\n    gfn = guest_walk_to_gfn(&gw);\n    gmfn = get_gfn(d, gfn, &p2mt);\n\n    if ( shadow_mode_refcounts(d) &&\n         ((!p2m_is_valid(p2mt) && !p2m_is_grant(p2mt)) ||\n          (!p2m_is_mmio(p2mt) && !mfn_valid(gmfn))) )\n    {\n        perfc_incr(shadow_fault_bail_bad_gfn);\n        SHADOW_PRINTK(\"BAD gfn=%\"SH_PRI_gfn\" gmfn=%\"PRI_mfn\"\\n\",\n                      gfn_x(gfn), mfn_x(gmfn));\n        sh_reset_early_unshadow(v);\n        put_gfn(d, gfn_x(gfn));\n        goto propagate;\n    }\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_VIRTUAL_TLB)\n    /* Remember this successful VA->GFN translation for later. */\n    vtlb_insert(v, va >> PAGE_SHIFT, gfn_x(gfn),\n                regs->error_code | PFEC_page_present);\n#endif /* (SHADOW_OPTIMIZATIONS & SHOPT_VIRTUAL_TLB) */\n\n    paging_lock(d);\n\n    TRACE_CLEAR_PATH_FLAGS;\n\n    /* Make sure there is enough free shadow memory to build a chain of\n     * shadow tables. (We never allocate a top-level shadow on this path,\n     * only a 32b l1, pae l1, or 64b l3+2+1. Note that while\n     * SH_type_l1_shadow isn't correct in the latter case, all page\n     * tables are the same size there.)\n     *\n     * Preallocate shadow pages *before* removing writable accesses\n     * otherwhise an OOS L1 might be demoted and promoted again with\n     * writable mappings. */\n    shadow_prealloc(d,\n                    SH_type_l1_shadow,\n                    GUEST_PAGING_LEVELS < 4 ? 1 : GUEST_PAGING_LEVELS - 1);\n\n    rc = gw_remove_write_accesses(v, va, &gw);\n\n    /* First bit set: Removed write access to a page. */\n    if ( rc & GW_RMWR_FLUSHTLB )\n    {\n        /* Write permission removal is also a hint that other gwalks\n         * overlapping with this one may be inconsistent\n         */\n        perfc_incr(shadow_rm_write_flush_tlb);\n        smp_wmb();\n        atomic_inc(&d->arch.paging.shadow.gtable_dirty_version);\n        flush_tlb_mask(d->dirty_cpumask);\n    }\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n    /* Second bit set: Resynced a page. Re-walk needed. */\n    if ( rc & GW_RMWR_REWALK )\n    {\n        paging_unlock(d);\n        put_gfn(d, gfn_x(gfn));\n        goto rewalk;\n    }\n#endif /* OOS */\n\n    if ( !shadow_check_gwalk(v, va, &gw, version) )\n    {\n        perfc_incr(shadow_inconsistent_gwalk);\n        paging_unlock(d);\n        put_gfn(d, gfn_x(gfn));\n        goto rewalk;\n    }\n\n    shadow_audit_tables(v);\n    sh_audit_gw(v, &gw);\n\n    /* Acquire the shadow.  This must happen before we figure out the rights\n     * for the shadow entry, since we might promote a page here. */\n    ptr_sl1e = shadow_get_and_create_l1e(v, &gw, &sl1mfn, ft);\n    if ( unlikely(ptr_sl1e == NULL) )\n    {\n        /* Couldn't get the sl1e!  Since we know the guest entries\n         * are OK, this can only have been caused by a failed\n         * shadow_set_l*e(), which will have crashed the guest.\n         * Get out of the fault handler immediately. */\n        /* Windows 7 apparently relies on the hardware to do something\n         * it explicitly hasn't promised to do: load l3 values after\n         * the cr3 is loaded.\n         * In any case, in the PAE case, the ASSERT is not true; it can\n         * happen because of actions the guest is taking. */\n#if GUEST_PAGING_LEVELS == 3\n        v->arch.paging.mode->update_cr3(v, 0, false);\n#else\n        ASSERT(d->is_shutting_down);\n#endif\n        paging_unlock(d);\n        put_gfn(d, gfn_x(gfn));\n        trace_shadow_gen(TRC_SHADOW_DOMF_DYING, va);\n        return 0;\n    }\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n    /* Always unsync when writing to L1 page tables. */\n    if ( sh_mfn_is_a_page_table(gmfn)\n         && ft == ft_demand_write )\n        sh_unsync(v, gmfn);\n\n    if ( unlikely(d->is_shutting_down && d->shutdown_code == SHUTDOWN_crash) )\n    {\n        /* We might end up with a crashed domain here if\n         * sh_remove_shadows() in a previous sh_resync() call has\n         * failed. We cannot safely continue since some page is still\n         * OOS but not in the hash table anymore. */\n        paging_unlock(d);\n        put_gfn(d, gfn_x(gfn));\n        return 0;\n    }\n\n    /* Final check: if someone has synced a page, it's possible that\n     * our l1e is stale.  Compare the entries, and rewalk if necessary. */\n    if ( shadow_check_gl1e(v, &gw)  )\n    {\n        perfc_incr(shadow_inconsistent_gwalk);\n        paging_unlock(d);\n        put_gfn(d, gfn_x(gfn));\n        goto rewalk;\n    }\n#endif /* OOS */\n\n    /* Calculate the shadow entry and write it */\n    l1e_propagate_from_guest(v, gw.l1e, gmfn, &sl1e, ft, p2mt);\n    r = shadow_set_l1e(d, ptr_sl1e, sl1e, p2mt, sl1mfn);\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n    if ( mfn_valid(gw.l1mfn)\n         && mfn_is_out_of_sync(gw.l1mfn) )\n    {\n        /* Update the OOS snapshot. */\n        mfn_t snpmfn = oos_snapshot_lookup(d, gw.l1mfn);\n        guest_l1e_t *snp;\n\n        ASSERT(mfn_valid(snpmfn));\n\n        snp = map_domain_page(snpmfn);\n        snp[guest_l1_table_offset(va)] = gw.l1e;\n        unmap_domain_page(snp);\n    }\n#endif /* OOS */\n\n#if SHADOW_OPTIMIZATIONS & SHOPT_PREFETCH\n    /* Prefetch some more shadow entries */\n    sh_prefetch(v, &gw, ptr_sl1e, sl1mfn);\n#endif\n\n    /* Need to emulate accesses to page tables */\n    if ( sh_mfn_is_a_page_table(gmfn)\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n         /* Unless they've been allowed to go out of sync with their\n            shadows and we don't need to unshadow it. */\n         && !(mfn_is_out_of_sync(gmfn)\n              && !(regs->error_code & PFEC_user_mode))\n#endif\n         && (ft == ft_demand_write) )\n    {\n        perfc_incr(shadow_fault_emulate_write);\n        goto emulate;\n    }\n\n    /* Need to hand off device-model MMIO to the device model */\n    if ( p2mt == p2m_mmio_dm )\n    {\n        gpa = guest_walk_to_gpa(&gw);\n        goto mmio;\n    }\n\n    /* Ignore attempts to write to read-only memory. */\n    if ( p2m_is_readonly(p2mt) && (ft == ft_demand_write) )\n    {\n        static unsigned long lastpage;\n        if ( xchg(&lastpage, va & PAGE_MASK) != (va & PAGE_MASK) )\n            gdprintk(XENLOG_DEBUG, \"guest attempted write to read-only memory\"\n                     \" page. va page=%#lx, mfn=%#lx\\n\",\n                     va & PAGE_MASK, mfn_x(gmfn));\n        goto emulate_readonly; /* skip over the instruction */\n    }\n\n    /* In HVM guests, we force CR0.WP always to be set, so that the\n     * pagetables are always write-protected.  If the guest thinks\n     * CR0.WP is clear, we must emulate faulting supervisor writes to\n     * allow the guest to write through read-only PTEs.  Emulate if the\n     * fault was a non-user write to a present page.  */\n    if ( is_hvm_domain(d)\n         && unlikely(!hvm_wp_enabled(v))\n         && regs->error_code == (PFEC_write_access|PFEC_page_present)\n         && mfn_valid(gmfn) )\n    {\n        perfc_incr(shadow_fault_emulate_wp);\n        goto emulate;\n    }\n\n    perfc_incr(shadow_fault_fixed);\n    d->arch.paging.log_dirty.fault_count++;\n    sh_reset_early_unshadow(v);\n\n    trace_shadow_fixup(gw.l1e, va);\n done:\n    sh_audit_gw(v, &gw);\n    SHADOW_PRINTK(\"fixed\\n\");\n    shadow_audit_tables(v);\n    paging_unlock(d);\n    put_gfn(d, gfn_x(gfn));\n    return EXCRET_fault_fixed;\n\n emulate:\n    if ( !shadow_mode_refcounts(d) || !guest_mode(regs) )\n        goto not_a_shadow_fault;\n\n    /*\n     * We do not emulate user writes. Instead we use them as a hint that the\n     * page is no longer a page table. This behaviour differs from native, but\n     * it seems very unlikely that any OS grants user access to page tables.\n     */\n    if ( (regs->error_code & PFEC_user_mode) )\n    {\n        SHADOW_PRINTK(\"user-mode fault to PT, unshadowing mfn %#lx\\n\",\n                      mfn_x(gmfn));\n        perfc_incr(shadow_fault_emulate_failed);\n        sh_remove_shadows(d, gmfn, 0 /* thorough */, 1 /* must succeed */);\n        trace_shadow_emulate_other(TRC_SHADOW_EMULATE_UNSHADOW_USER,\n                                      va, gfn);\n        goto done;\n    }\n\n    /*\n     * Write from userspace to ro-mem needs to jump here to avoid getting\n     * caught by user-mode page-table check above.\n     */\n emulate_readonly:\n\n    /* Unshadow if we are writing to a toplevel pagetable that is\n     * flagged as a dying process, and that is not currently used. */\n    if ( sh_mfn_is_a_page_table(gmfn)\n         && (mfn_to_page(gmfn)->shadow_flags & SHF_pagetable_dying) )\n    {\n        int used = 0;\n        struct vcpu *tmp;\n        for_each_vcpu(d, tmp)\n        {\n#if GUEST_PAGING_LEVELS == 3\n            int i;\n            for ( i = 0; i < 4; i++ )\n            {\n                mfn_t smfn = pagetable_get_mfn(v->arch.shadow_table[i]);\n\n                if ( mfn_valid(smfn) && (mfn_x(smfn) != 0) )\n                {\n                    used |= (mfn_to_page(smfn)->v.sh.back == mfn_x(gmfn));\n\n                    if ( used )\n                        break;\n                }\n            }\n#else /* 32 or 64 */\n            used = mfn_eq(pagetable_get_mfn(tmp->arch.guest_table), gmfn);\n#endif\n            if ( used )\n                break;\n        }\n\n        if ( !used )\n            sh_remove_shadows(d, gmfn, 1 /* fast */, 0 /* can fail */);\n    }\n\n    /*\n     * We don't need to hold the lock for the whole emulation; we will\n     * take it again when we write to the pagetables.\n     */\n    sh_audit_gw(v, &gw);\n    shadow_audit_tables(v);\n    paging_unlock(d);\n    put_gfn(d, gfn_x(gfn));\n\n    this_cpu(trace_emulate_write_val) = 0;\n\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n early_emulation:\n#endif\n    if ( is_hvm_domain(d) )\n    {\n        /*\n         * If we are in the middle of injecting an exception or interrupt then\n         * we should not emulate: it is not the instruction at %eip that caused\n         * the fault. Furthermore it is almost certainly the case the handler\n         * stack is currently considered to be a page table, so we should\n         * unshadow the faulting page before exiting.\n         */\n        if ( unlikely(hvm_event_pending(v)) )\n        {\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n            if ( fast_emul )\n            {\n                perfc_incr(shadow_fault_fast_emulate_fail);\n                v->arch.paging.last_write_emul_ok = 0;\n            }\n#endif\n            gdprintk(XENLOG_DEBUG, \"write to pagetable during event \"\n                     \"injection: cr2=%#lx, mfn=%#lx\\n\",\n                     va, mfn_x(gmfn));\n            sh_remove_shadows(d, gmfn, 0 /* thorough */, 1 /* must succeed */);\n            trace_shadow_emulate_other(TRC_SHADOW_EMULATE_UNSHADOW_EVTINJ,\n                                       va, gfn);\n            return EXCRET_fault_fixed;\n        }\n    }\n\n    SHADOW_PRINTK(\"emulate: eip=%#lx esp=%#lx\\n\", regs->rip, regs->rsp);\n\n    emul_ops = shadow_init_emulation(&emul_ctxt, regs, GUEST_PTE_SIZE);\n\n    r = x86_emulate(&emul_ctxt.ctxt, emul_ops);\n\n#ifdef CONFIG_HVM\n    if ( r == X86EMUL_EXCEPTION )\n    {\n        ASSERT(is_hvm_domain(d));\n        /*\n         * This emulation covers writes to shadow pagetables.  We tolerate #PF\n         * (from accesses spanning pages, concurrent paging updated from\n         * vcpus, etc) and #GP[0]/#SS[0] (from segmentation errors).  Anything\n         * else is an emulation bug, or a guest playing with the instruction\n         * stream under Xen's feet.\n         */\n        if ( emul_ctxt.ctxt.event.type == X86_EVENTTYPE_HW_EXCEPTION &&\n             ((emul_ctxt.ctxt.event.vector == TRAP_page_fault) ||\n              (((emul_ctxt.ctxt.event.vector == TRAP_gp_fault) ||\n                (emul_ctxt.ctxt.event.vector == TRAP_stack_error)) &&\n               emul_ctxt.ctxt.event.error_code == 0)) )\n            hvm_inject_event(&emul_ctxt.ctxt.event);\n        else\n        {\n            SHADOW_PRINTK(\n                \"Unexpected event (type %u, vector %#x) from emulation\\n\",\n                emul_ctxt.ctxt.event.type, emul_ctxt.ctxt.event.vector);\n            r = X86EMUL_UNHANDLEABLE;\n        }\n    }\n#endif\n\n    /*\n     * NB. We do not unshadow on X86EMUL_EXCEPTION. It's not clear that it\n     * would be a good unshadow hint. If we *do* decide to unshadow-on-fault\n     * then it must be 'failable': we cannot require the unshadow to succeed.\n     */\n    if ( r == X86EMUL_UNHANDLEABLE || r == X86EMUL_UNIMPLEMENTED )\n    {\n        perfc_incr(shadow_fault_emulate_failed);\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n        if ( fast_emul )\n        {\n            perfc_incr(shadow_fault_fast_emulate_fail);\n            v->arch.paging.last_write_emul_ok = 0;\n        }\n#endif\n        SHADOW_PRINTK(\"emulator failure (rc=%d), unshadowing mfn %#lx\\n\",\n                       r, mfn_x(gmfn));\n        /* If this is actually a page table, then we have a bug, and need\n         * to support more operations in the emulator.  More likely,\n         * though, this is a hint that this page should not be shadowed. */\n        shadow_remove_all_shadows(d, gmfn);\n\n        trace_shadow_emulate_other(TRC_SHADOW_EMULATE_UNSHADOW_UNHANDLED,\n                                   va, gfn);\n        goto emulate_done;\n    }\n\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n    /* Record successfully emulated information as heuristics to next\n     * fault on same frame for acceleration. But be careful to verify\n     * its attribute still as page table, or else unshadow triggered\n     * in write emulation normally requires a re-sync with guest page\n     * table to recover r/w permission. Incorrect record for such case\n     * will cause unexpected more shadow faults due to propagation is\n     * skipped.\n     */\n    if ( (r == X86EMUL_OKAY) && sh_mfn_is_a_page_table(gmfn) )\n    {\n        if ( !fast_emul )\n        {\n            v->arch.paging.shadow.last_emulated_frame = va >> PAGE_SHIFT;\n            v->arch.paging.shadow.last_emulated_mfn = mfn_x(gmfn);\n            v->arch.paging.last_write_emul_ok = 1;\n        }\n    }\n    else if ( fast_emul )\n        v->arch.paging.last_write_emul_ok = 0;\n#endif\n\n    if ( emul_ctxt.ctxt.retire.singlestep )\n        hvm_inject_hw_exception(TRAP_debug, X86_EVENT_NO_EC);\n\n#if GUEST_PAGING_LEVELS == 3 /* PAE guest */\n    /*\n     * If there are no pending actions, emulate up to four extra instructions\n     * in the hope of catching the \"second half\" of a 64-bit pagetable write.\n     */\n    if ( r == X86EMUL_OKAY && !emul_ctxt.ctxt.retire.raw )\n    {\n        int i, emulation_count=0;\n        this_cpu(trace_emulate_initial_va) = va;\n\n        for ( i = 0 ; i < 4 ; i++ )\n        {\n            shadow_continue_emulation(&emul_ctxt, regs);\n            v->arch.paging.last_write_was_pt = 0;\n            r = x86_emulate(&emul_ctxt.ctxt, emul_ops);\n\n            /*\n             * Only continue the search for the second half if there are no\n             * exceptions or pending actions.  Otherwise, give up and re-enter\n             * the guest.\n             */\n            if ( r == X86EMUL_OKAY && !emul_ctxt.ctxt.retire.raw )\n            {\n                emulation_count++;\n                if ( v->arch.paging.last_write_was_pt )\n                {\n                    perfc_incr(shadow_em_ex_pt);\n                    TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_EMULATION_2ND_PT_WRITTEN);\n                    break; /* Don't emulate past the other half of the write */\n                }\n                else\n                    perfc_incr(shadow_em_ex_non_pt);\n            }\n            else\n            {\n                perfc_incr(shadow_em_ex_fail);\n                TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_EMULATION_LAST_FAILED);\n\n                if ( emul_ctxt.ctxt.retire.singlestep )\n                    hvm_inject_hw_exception(TRAP_debug, X86_EVENT_NO_EC);\n\n                break; /* Don't emulate again if we failed! */\n            }\n        }\n        this_cpu(trace_extra_emulation_count)=emulation_count;\n    }\n#endif /* PAE guest */\n\n    trace_shadow_emulate(gw.l1e, va);\n emulate_done:\n    SHADOW_PRINTK(\"emulated\\n\");\n    return EXCRET_fault_fixed;\n\n mmio:\n    if ( !guest_mode(regs) )\n        goto not_a_shadow_fault;\n#ifdef CONFIG_HVM\n    ASSERT(is_hvm_vcpu(v));\n    perfc_incr(shadow_fault_mmio);\n    sh_audit_gw(v, &gw);\n    SHADOW_PRINTK(\"mmio %#\"PRIpaddr\"\\n\", gpa);\n    shadow_audit_tables(v);\n    sh_reset_early_unshadow(v);\n    paging_unlock(d);\n    put_gfn(d, gfn_x(gfn));\n    trace_shadow_gen(TRC_SHADOW_MMIO, va);\n    return (handle_mmio_with_translation(va, gpa >> PAGE_SHIFT, access)\n            ? EXCRET_fault_fixed : 0);\n#else\n    BUG();\n#endif\n\n not_a_shadow_fault:\n    sh_audit_gw(v, &gw);\n    SHADOW_PRINTK(\"not a shadow fault\\n\");\n    shadow_audit_tables(v);\n    sh_reset_early_unshadow(v);\n    paging_unlock(d);\n    put_gfn(d, gfn_x(gfn));\n\npropagate:\n    trace_not_shadow_fault(gw.l1e, va);\n\n    return 0;\n}",
        "func_after": "static int sh_page_fault(struct vcpu *v,\n                          unsigned long va,\n                          struct cpu_user_regs *regs)\n{\n    struct domain *d = v->domain;\n    walk_t gw;\n    gfn_t gfn = _gfn(0);\n    mfn_t gmfn, sl1mfn = _mfn(0);\n    shadow_l1e_t sl1e, *ptr_sl1e;\n    paddr_t gpa;\n    struct sh_emulate_ctxt emul_ctxt;\n    const struct x86_emulate_ops *emul_ops;\n    int r;\n    p2m_type_t p2mt;\n    uint32_t rc, error_code;\n    bool walk_ok;\n    int version;\n    unsigned int cpl;\n    const struct npfec access = {\n         .read_access = 1,\n         .write_access = !!(regs->error_code & PFEC_write_access),\n         .gla_valid = 1,\n         .kind = npfec_kind_with_gla\n    };\n    const fetch_type_t ft =\n        access.write_access ? ft_demand_write : ft_demand_read;\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n    int fast_emul = 0;\n#endif\n\n    SHADOW_PRINTK(\"%pv va=%#lx err=%#x, rip=%lx\\n\",\n                  v, va, regs->error_code, regs->rip);\n\n    perfc_incr(shadow_fault);\n\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n    /* If faulting frame is successfully emulated in last shadow fault\n     * it's highly likely to reach same emulation action for this frame.\n     * Then try to emulate early to avoid lock aquisition.\n     */\n    if ( v->arch.paging.last_write_emul_ok\n         && v->arch.paging.shadow.last_emulated_frame == (va >> PAGE_SHIFT) )\n    {\n        /* check whether error code is 3, or else fall back to normal path\n         * in case of some validation is required\n         */\n        if ( regs->error_code == (PFEC_write_access | PFEC_page_present) )\n        {\n            fast_emul = 1;\n            gmfn = _mfn(v->arch.paging.shadow.last_emulated_mfn);\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n            /* Fall back to the slow path if we're trying to emulate\n               writes to an out of sync page. */\n            if ( mfn_valid(gmfn) && mfn_is_out_of_sync(gmfn) )\n            {\n                fast_emul = 0;\n                v->arch.paging.last_write_emul_ok = 0;\n                goto page_fault_slow_path;\n            }\n#endif /* OOS */\n\n            perfc_incr(shadow_fault_fast_emulate);\n            goto early_emulation;\n        }\n        else\n            v->arch.paging.last_write_emul_ok = 0;\n    }\n#endif\n\n    //\n    // XXX: Need to think about eventually mapping superpages directly in the\n    //      shadow (when possible), as opposed to splintering them into a\n    //      bunch of 4K maps.\n    //\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_FAST_FAULT_PATH)\n    if ( (regs->error_code & PFEC_reserved_bit) )\n    {\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n        /* First, need to check that this isn't an out-of-sync\n         * shadow l1e.  If it is, we fall back to the slow path, which\n         * will sync it up again. */\n        {\n            shadow_l2e_t sl2e;\n            mfn_t gl1mfn;\n            if ( (__copy_from_user(&sl2e,\n                                   (sh_linear_l2_table(v)\n                                    + shadow_l2_linear_offset(va)),\n                                   sizeof(sl2e)) != 0)\n                 || !(shadow_l2e_get_flags(sl2e) & _PAGE_PRESENT)\n                 || !mfn_valid(gl1mfn = backpointer(mfn_to_page(\n                                  shadow_l2e_get_mfn(sl2e))))\n                 || unlikely(mfn_is_out_of_sync(gl1mfn)) )\n            {\n                /* Hit the slow path as if there had been no\n                 * shadow entry at all, and let it tidy up */\n                ASSERT(regs->error_code & PFEC_page_present);\n                regs->error_code ^= (PFEC_reserved_bit|PFEC_page_present);\n                goto page_fault_slow_path;\n            }\n        }\n#endif /* SHOPT_OUT_OF_SYNC */\n        /* The only reasons for reserved bits to be set in shadow entries\n         * are the two \"magic\" shadow_l1e entries. */\n        if ( likely((__copy_from_user(&sl1e,\n                                      (sh_linear_l1_table(v)\n                                       + shadow_l1_linear_offset(va)),\n                                      sizeof(sl1e)) == 0)\n                    && sh_l1e_is_magic(sl1e)) )\n        {\n\n            if ( sh_l1e_is_gnp(sl1e) )\n            {\n                /* Not-present in a guest PT: pass to the guest as\n                 * a not-present fault (by flipping two bits). */\n                ASSERT(regs->error_code & PFEC_page_present);\n                regs->error_code ^= (PFEC_reserved_bit|PFEC_page_present);\n                sh_reset_early_unshadow(v);\n                perfc_incr(shadow_fault_fast_gnp);\n                SHADOW_PRINTK(\"fast path not-present\\n\");\n                trace_shadow_gen(TRC_SHADOW_FAST_PROPAGATE, va);\n                return 0;\n            }\n#ifdef CONFIG_HVM\n            /* Magic MMIO marker: extract gfn for MMIO address */\n            ASSERT(sh_l1e_is_mmio(sl1e));\n            ASSERT(is_hvm_vcpu(v));\n            gpa = gfn_to_gaddr(sh_l1e_mmio_get_gfn(sl1e)) | (va & ~PAGE_MASK);\n            perfc_incr(shadow_fault_fast_mmio);\n            SHADOW_PRINTK(\"fast path mmio %#\"PRIpaddr\"\\n\", gpa);\n            sh_reset_early_unshadow(v);\n            trace_shadow_gen(TRC_SHADOW_FAST_MMIO, va);\n            return handle_mmio_with_translation(va, gpa >> PAGE_SHIFT, access)\n                   ? EXCRET_fault_fixed : 0;\n#else\n            /* When HVM is not enabled, there shouldn't be MMIO marker */\n            BUG();\n#endif\n        }\n        else\n        {\n            /* This should be exceptionally rare: another vcpu has fixed\n             * the tables between the fault and our reading the l1e.\n             * Retry and let the hardware give us the right fault next time. */\n            perfc_incr(shadow_fault_fast_fail);\n            SHADOW_PRINTK(\"fast path false alarm!\\n\");\n            trace_shadow_gen(TRC_SHADOW_FALSE_FAST_PATH, va);\n            return EXCRET_fault_fixed;\n        }\n    }\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n page_fault_slow_path:\n#endif\n#endif /* SHOPT_FAST_FAULT_PATH */\n\n    /* Detect if this page fault happened while we were already in Xen\n     * doing a shadow operation.  If that happens, the only thing we can\n     * do is let Xen's normal fault handlers try to fix it.  In any case,\n     * a diagnostic trace of the fault will be more useful than\n     * a BUG() when we try to take the lock again. */\n    if ( unlikely(paging_locked_by_me(d)) )\n    {\n        printk(XENLOG_G_ERR \"Recursive shadow fault: lock taken by %s\\n\",\n               d->arch.paging.lock.locker_function);\n        return 0;\n    }\n\n    cpl = is_pv_vcpu(v) ? (regs->ss & 3) : hvm_get_cpl(v);\n\n rewalk:\n\n    error_code = regs->error_code;\n\n    /*\n     * When CR4.SMAP is enabled, instructions which have a side effect of\n     * accessing the system data structures (e.g. mov to %ds accessing the\n     * LDT/GDT, or int $n accessing the IDT) are known as implicit supervisor\n     * accesses.\n     *\n     * The distinction between implicit and explicit accesses form part of the\n     * determination of access rights, controlling whether the access is\n     * successful, or raises a #PF.\n     *\n     * Unfortunately, the processor throws away the implicit/explicit\n     * distinction and does not provide it to the pagefault handler\n     * (i.e. here.) in the #PF error code.  Therefore, we must try to\n     * reconstruct the lost state so it can be fed back into our pagewalk\n     * through the guest tables.\n     *\n     * User mode accesses are easy to reconstruct:\n     *\n     *   If we observe a cpl3 data fetch which was a supervisor walk, this\n     *   must have been an implicit access to a system table.\n     *\n     * Supervisor mode accesses are not easy:\n     *\n     *   In principle, we could decode the instruction under %rip and have the\n     *   instruction emulator tell us if there is an implicit access.\n     *   However, this is racy with other vcpus updating the pagetable or\n     *   rewriting the instruction stream under our feet.\n     *\n     *   Therefore, we do nothing.  (If anyone has a sensible suggestion for\n     *   how to distinguish these cases, xen-devel@ is all ears...)\n     *\n     * As a result, one specific corner case will fail.  If a guest OS with\n     * SMAP enabled ends up mapping a system table with user mappings, sets\n     * EFLAGS.AC to allow explicit accesses to user mappings, and implicitly\n     * accesses the user mapping, hardware and the shadow code will disagree\n     * on whether a #PF should be raised.\n     *\n     * Hardware raises #PF because implicit supervisor accesses to user\n     * mappings are strictly disallowed.  As we can't reconstruct the correct\n     * input, the pagewalk is performed as if it were an explicit access,\n     * which concludes that the access should have succeeded and the shadow\n     * pagetables need modifying.  The shadow pagetables are modified (to the\n     * same value), and we re-enter the guest to re-execute the instruction,\n     * which causes another #PF, and the vcpu livelocks, unable to make\n     * forward progress.\n     *\n     * In practice, this is tolerable.  No production OS will deliberately\n     * construct this corner case (as doing so would mean that a system table\n     * is directly accessable to userspace, and the OS is trivially rootable.)\n     * If this corner case comes about accidentally, then a security-relevant\n     * bug has been tickled.\n     */\n    if ( !(error_code & (PFEC_insn_fetch|PFEC_user_mode)) && cpl == 3 )\n        error_code |= PFEC_implicit;\n\n    /* The walk is done in a lock-free style, with some sanity check\n     * postponed after grabbing paging lock later. Those delayed checks\n     * will make sure no inconsistent mapping being translated into\n     * shadow page table. */\n    version = atomic_read(&d->arch.paging.shadow.gtable_dirty_version);\n    smp_rmb();\n    walk_ok = sh_walk_guest_tables(v, va, &gw, error_code);\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n    regs->error_code &= ~PFEC_page_present;\n    if ( gw.pfec & PFEC_page_present )\n        regs->error_code |= PFEC_page_present;\n#endif\n\n    if ( !walk_ok )\n    {\n        perfc_incr(shadow_fault_bail_real_fault);\n        SHADOW_PRINTK(\"not a shadow fault\\n\");\n        sh_reset_early_unshadow(v);\n        regs->error_code = gw.pfec & PFEC_arch_mask;\n        goto propagate;\n    }\n\n    /* It's possible that the guest has put pagetables in memory that it has\n     * already used for some special purpose (ioreq pages, or granted pages).\n     * If that happens we'll have killed the guest already but it's still not\n     * safe to propagate entries out of the guest PT so get out now. */\n    if ( unlikely(d->is_shutting_down && d->shutdown_code == SHUTDOWN_crash) )\n    {\n        SHADOW_PRINTK(\"guest is shutting down\\n\");\n        goto propagate;\n    }\n\n    /* What mfn is the guest trying to access? */\n    gfn = guest_walk_to_gfn(&gw);\n    gmfn = get_gfn(d, gfn, &p2mt);\n\n    if ( shadow_mode_refcounts(d) &&\n         ((!p2m_is_valid(p2mt) && !p2m_is_grant(p2mt)) ||\n          (!p2m_is_mmio(p2mt) && !mfn_valid(gmfn))) )\n    {\n        perfc_incr(shadow_fault_bail_bad_gfn);\n        SHADOW_PRINTK(\"BAD gfn=%\"SH_PRI_gfn\" gmfn=%\"PRI_mfn\"\\n\",\n                      gfn_x(gfn), mfn_x(gmfn));\n        sh_reset_early_unshadow(v);\n        put_gfn(d, gfn_x(gfn));\n        goto propagate;\n    }\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_VIRTUAL_TLB)\n    /* Remember this successful VA->GFN translation for later. */\n    vtlb_insert(v, va >> PAGE_SHIFT, gfn_x(gfn),\n                regs->error_code | PFEC_page_present);\n#endif /* (SHADOW_OPTIMIZATIONS & SHOPT_VIRTUAL_TLB) */\n\n    paging_lock(d);\n\n    TRACE_CLEAR_PATH_FLAGS;\n\n    /* Make sure there is enough free shadow memory to build a chain of\n     * shadow tables. (We never allocate a top-level shadow on this path,\n     * only a 32b l1, pae l1, or 64b l3+2+1. Note that while\n     * SH_type_l1_shadow isn't correct in the latter case, all page\n     * tables are the same size there.)\n     *\n     * Preallocate shadow pages *before* removing writable accesses\n     * otherwhise an OOS L1 might be demoted and promoted again with\n     * writable mappings. */\n    shadow_prealloc(d,\n                    SH_type_l1_shadow,\n                    GUEST_PAGING_LEVELS < 4 ? 1 : GUEST_PAGING_LEVELS - 1);\n\n    rc = gw_remove_write_accesses(v, va, &gw);\n\n    /* First bit set: Removed write access to a page. */\n    if ( rc & GW_RMWR_FLUSHTLB )\n    {\n        /* Write permission removal is also a hint that other gwalks\n         * overlapping with this one may be inconsistent\n         */\n        perfc_incr(shadow_rm_write_flush_tlb);\n        smp_wmb();\n        atomic_inc(&d->arch.paging.shadow.gtable_dirty_version);\n        flush_tlb_mask(d->dirty_cpumask);\n    }\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n    /* Second bit set: Resynced a page. Re-walk needed. */\n    if ( rc & GW_RMWR_REWALK )\n    {\n        paging_unlock(d);\n        put_gfn(d, gfn_x(gfn));\n        goto rewalk;\n    }\n#endif /* OOS */\n\n    if ( !shadow_check_gwalk(v, va, &gw, version) )\n    {\n        perfc_incr(shadow_inconsistent_gwalk);\n        paging_unlock(d);\n        put_gfn(d, gfn_x(gfn));\n        goto rewalk;\n    }\n\n    shadow_audit_tables(v);\n    sh_audit_gw(v, &gw);\n\n    /* Acquire the shadow.  This must happen before we figure out the rights\n     * for the shadow entry, since we might promote a page here. */\n    ptr_sl1e = shadow_get_and_create_l1e(v, &gw, &sl1mfn, ft);\n    if ( unlikely(ptr_sl1e == NULL) )\n    {\n        /* Couldn't get the sl1e!  Since we know the guest entries\n         * are OK, this can only have been caused by a failed\n         * shadow_set_l*e(), which will have crashed the guest.\n         * Get out of the fault handler immediately. */\n        /* Windows 7 apparently relies on the hardware to do something\n         * it explicitly hasn't promised to do: load l3 values after\n         * the cr3 is loaded.\n         * In any case, in the PAE case, the ASSERT is not true; it can\n         * happen because of actions the guest is taking. */\n#if GUEST_PAGING_LEVELS == 3\n        v->arch.paging.mode->update_cr3(v, 0, false);\n#else\n        ASSERT(d->is_shutting_down);\n#endif\n        paging_unlock(d);\n        put_gfn(d, gfn_x(gfn));\n        trace_shadow_gen(TRC_SHADOW_DOMF_DYING, va);\n        return 0;\n    }\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n    /* Always unsync when writing to L1 page tables. */\n    if ( sh_mfn_is_a_page_table(gmfn)\n         && ft == ft_demand_write )\n        sh_unsync(v, gmfn);\n\n    if ( unlikely(d->is_shutting_down && d->shutdown_code == SHUTDOWN_crash) )\n    {\n        /* We might end up with a crashed domain here if\n         * sh_remove_shadows() in a previous sh_resync() call has\n         * failed. We cannot safely continue since some page is still\n         * OOS but not in the hash table anymore. */\n        paging_unlock(d);\n        put_gfn(d, gfn_x(gfn));\n        return 0;\n    }\n\n    /* Final check: if someone has synced a page, it's possible that\n     * our l1e is stale.  Compare the entries, and rewalk if necessary. */\n    if ( shadow_check_gl1e(v, &gw)  )\n    {\n        perfc_incr(shadow_inconsistent_gwalk);\n        paging_unlock(d);\n        put_gfn(d, gfn_x(gfn));\n        goto rewalk;\n    }\n#endif /* OOS */\n\n    /* Calculate the shadow entry and write it */\n    l1e_propagate_from_guest(v, gw.l1e, gmfn, &sl1e, ft, p2mt);\n    r = shadow_set_l1e(d, ptr_sl1e, sl1e, p2mt, sl1mfn);\n\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n    if ( mfn_valid(gw.l1mfn)\n         && mfn_is_out_of_sync(gw.l1mfn) )\n    {\n        /* Update the OOS snapshot. */\n        mfn_t snpmfn = oos_snapshot_lookup(d, gw.l1mfn);\n        guest_l1e_t *snp;\n\n        ASSERT(mfn_valid(snpmfn));\n\n        snp = map_domain_page(snpmfn);\n        snp[guest_l1_table_offset(va)] = gw.l1e;\n        unmap_domain_page(snp);\n    }\n#endif /* OOS */\n\n#if SHADOW_OPTIMIZATIONS & SHOPT_PREFETCH\n    /* Prefetch some more shadow entries */\n    sh_prefetch(v, &gw, ptr_sl1e, sl1mfn);\n#endif\n\n    /* Need to emulate accesses to page tables */\n    if ( sh_mfn_is_a_page_table(gmfn)\n#if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC)\n         /* Unless they've been allowed to go out of sync with their\n            shadows and we don't need to unshadow it. */\n         && !(mfn_is_out_of_sync(gmfn)\n              && !(regs->error_code & PFEC_user_mode))\n#endif\n         && (ft == ft_demand_write) )\n    {\n        perfc_incr(shadow_fault_emulate_write);\n        goto emulate;\n    }\n\n    /* Need to hand off device-model MMIO to the device model */\n    if ( p2mt == p2m_mmio_dm )\n    {\n        gpa = guest_walk_to_gpa(&gw);\n        goto mmio;\n    }\n\n    /* Ignore attempts to write to read-only memory. */\n    if ( p2m_is_readonly(p2mt) && (ft == ft_demand_write) )\n    {\n        static unsigned long lastpage;\n        if ( xchg(&lastpage, va & PAGE_MASK) != (va & PAGE_MASK) )\n            gdprintk(XENLOG_DEBUG, \"guest attempted write to read-only memory\"\n                     \" page. va page=%#lx, mfn=%#lx\\n\",\n                     va & PAGE_MASK, mfn_x(gmfn));\n        goto emulate_readonly; /* skip over the instruction */\n    }\n\n    /* In HVM guests, we force CR0.WP always to be set, so that the\n     * pagetables are always write-protected.  If the guest thinks\n     * CR0.WP is clear, we must emulate faulting supervisor writes to\n     * allow the guest to write through read-only PTEs.  Emulate if the\n     * fault was a non-user write to a present page.  */\n    if ( is_hvm_domain(d)\n         && unlikely(!hvm_wp_enabled(v))\n         && regs->error_code == (PFEC_write_access|PFEC_page_present)\n         && mfn_valid(gmfn) )\n    {\n        perfc_incr(shadow_fault_emulate_wp);\n        goto emulate;\n    }\n\n    perfc_incr(shadow_fault_fixed);\n    d->arch.paging.log_dirty.fault_count++;\n    sh_reset_early_unshadow(v);\n\n    trace_shadow_fixup(gw.l1e, va);\n done:\n    sh_audit_gw(v, &gw);\n    SHADOW_PRINTK(\"fixed\\n\");\n    shadow_audit_tables(v);\n    paging_unlock(d);\n    put_gfn(d, gfn_x(gfn));\n    return EXCRET_fault_fixed;\n\n emulate:\n    if ( !shadow_mode_refcounts(d) || !guest_mode(regs) )\n        goto not_a_shadow_fault;\n\n    /*\n     * We do not emulate user writes. Instead we use them as a hint that the\n     * page is no longer a page table. This behaviour differs from native, but\n     * it seems very unlikely that any OS grants user access to page tables.\n     */\n    if ( (regs->error_code & PFEC_user_mode) )\n    {\n        SHADOW_PRINTK(\"user-mode fault to PT, unshadowing mfn %#lx\\n\",\n                      mfn_x(gmfn));\n        perfc_incr(shadow_fault_emulate_failed);\n        sh_remove_shadows(d, gmfn, 0 /* thorough */, 1 /* must succeed */);\n        trace_shadow_emulate_other(TRC_SHADOW_EMULATE_UNSHADOW_USER,\n                                      va, gfn);\n        goto done;\n    }\n\n    /*\n     * Write from userspace to ro-mem needs to jump here to avoid getting\n     * caught by user-mode page-table check above.\n     */\n emulate_readonly:\n\n    /* Unshadow if we are writing to a toplevel pagetable that is\n     * flagged as a dying process, and that is not currently used. */\n    if ( sh_mfn_is_a_page_table(gmfn) && is_hvm_domain(d) &&\n         mfn_to_page(gmfn)->pagetable_dying )\n    {\n        int used = 0;\n        struct vcpu *tmp;\n        for_each_vcpu(d, tmp)\n        {\n#if GUEST_PAGING_LEVELS == 3\n            int i;\n            for ( i = 0; i < 4; i++ )\n            {\n                mfn_t smfn = pagetable_get_mfn(v->arch.shadow_table[i]);\n\n                if ( mfn_valid(smfn) && (mfn_x(smfn) != 0) )\n                {\n                    used |= (mfn_to_page(smfn)->v.sh.back == mfn_x(gmfn));\n\n                    if ( used )\n                        break;\n                }\n            }\n#else /* 32 or 64 */\n            used = mfn_eq(pagetable_get_mfn(tmp->arch.guest_table), gmfn);\n#endif\n            if ( used )\n                break;\n        }\n\n        if ( !used )\n            sh_remove_shadows(d, gmfn, 1 /* fast */, 0 /* can fail */);\n    }\n\n    /*\n     * We don't need to hold the lock for the whole emulation; we will\n     * take it again when we write to the pagetables.\n     */\n    sh_audit_gw(v, &gw);\n    shadow_audit_tables(v);\n    paging_unlock(d);\n    put_gfn(d, gfn_x(gfn));\n\n    this_cpu(trace_emulate_write_val) = 0;\n\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n early_emulation:\n#endif\n    if ( is_hvm_domain(d) )\n    {\n        /*\n         * If we are in the middle of injecting an exception or interrupt then\n         * we should not emulate: it is not the instruction at %eip that caused\n         * the fault. Furthermore it is almost certainly the case the handler\n         * stack is currently considered to be a page table, so we should\n         * unshadow the faulting page before exiting.\n         */\n        if ( unlikely(hvm_event_pending(v)) )\n        {\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n            if ( fast_emul )\n            {\n                perfc_incr(shadow_fault_fast_emulate_fail);\n                v->arch.paging.last_write_emul_ok = 0;\n            }\n#endif\n            gdprintk(XENLOG_DEBUG, \"write to pagetable during event \"\n                     \"injection: cr2=%#lx, mfn=%#lx\\n\",\n                     va, mfn_x(gmfn));\n            sh_remove_shadows(d, gmfn, 0 /* thorough */, 1 /* must succeed */);\n            trace_shadow_emulate_other(TRC_SHADOW_EMULATE_UNSHADOW_EVTINJ,\n                                       va, gfn);\n            return EXCRET_fault_fixed;\n        }\n    }\n\n    SHADOW_PRINTK(\"emulate: eip=%#lx esp=%#lx\\n\", regs->rip, regs->rsp);\n\n    emul_ops = shadow_init_emulation(&emul_ctxt, regs, GUEST_PTE_SIZE);\n\n    r = x86_emulate(&emul_ctxt.ctxt, emul_ops);\n\n#ifdef CONFIG_HVM\n    if ( r == X86EMUL_EXCEPTION )\n    {\n        ASSERT(is_hvm_domain(d));\n        /*\n         * This emulation covers writes to shadow pagetables.  We tolerate #PF\n         * (from accesses spanning pages, concurrent paging updated from\n         * vcpus, etc) and #GP[0]/#SS[0] (from segmentation errors).  Anything\n         * else is an emulation bug, or a guest playing with the instruction\n         * stream under Xen's feet.\n         */\n        if ( emul_ctxt.ctxt.event.type == X86_EVENTTYPE_HW_EXCEPTION &&\n             ((emul_ctxt.ctxt.event.vector == TRAP_page_fault) ||\n              (((emul_ctxt.ctxt.event.vector == TRAP_gp_fault) ||\n                (emul_ctxt.ctxt.event.vector == TRAP_stack_error)) &&\n               emul_ctxt.ctxt.event.error_code == 0)) )\n            hvm_inject_event(&emul_ctxt.ctxt.event);\n        else\n        {\n            SHADOW_PRINTK(\n                \"Unexpected event (type %u, vector %#x) from emulation\\n\",\n                emul_ctxt.ctxt.event.type, emul_ctxt.ctxt.event.vector);\n            r = X86EMUL_UNHANDLEABLE;\n        }\n    }\n#endif\n\n    /*\n     * NB. We do not unshadow on X86EMUL_EXCEPTION. It's not clear that it\n     * would be a good unshadow hint. If we *do* decide to unshadow-on-fault\n     * then it must be 'failable': we cannot require the unshadow to succeed.\n     */\n    if ( r == X86EMUL_UNHANDLEABLE || r == X86EMUL_UNIMPLEMENTED )\n    {\n        perfc_incr(shadow_fault_emulate_failed);\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n        if ( fast_emul )\n        {\n            perfc_incr(shadow_fault_fast_emulate_fail);\n            v->arch.paging.last_write_emul_ok = 0;\n        }\n#endif\n        SHADOW_PRINTK(\"emulator failure (rc=%d), unshadowing mfn %#lx\\n\",\n                       r, mfn_x(gmfn));\n        /* If this is actually a page table, then we have a bug, and need\n         * to support more operations in the emulator.  More likely,\n         * though, this is a hint that this page should not be shadowed. */\n        shadow_remove_all_shadows(d, gmfn);\n\n        trace_shadow_emulate_other(TRC_SHADOW_EMULATE_UNSHADOW_UNHANDLED,\n                                   va, gfn);\n        goto emulate_done;\n    }\n\n#if SHADOW_OPTIMIZATIONS & SHOPT_FAST_EMULATION\n    /* Record successfully emulated information as heuristics to next\n     * fault on same frame for acceleration. But be careful to verify\n     * its attribute still as page table, or else unshadow triggered\n     * in write emulation normally requires a re-sync with guest page\n     * table to recover r/w permission. Incorrect record for such case\n     * will cause unexpected more shadow faults due to propagation is\n     * skipped.\n     */\n    if ( (r == X86EMUL_OKAY) && sh_mfn_is_a_page_table(gmfn) )\n    {\n        if ( !fast_emul )\n        {\n            v->arch.paging.shadow.last_emulated_frame = va >> PAGE_SHIFT;\n            v->arch.paging.shadow.last_emulated_mfn = mfn_x(gmfn);\n            v->arch.paging.last_write_emul_ok = 1;\n        }\n    }\n    else if ( fast_emul )\n        v->arch.paging.last_write_emul_ok = 0;\n#endif\n\n    if ( emul_ctxt.ctxt.retire.singlestep )\n        hvm_inject_hw_exception(TRAP_debug, X86_EVENT_NO_EC);\n\n#if GUEST_PAGING_LEVELS == 3 /* PAE guest */\n    /*\n     * If there are no pending actions, emulate up to four extra instructions\n     * in the hope of catching the \"second half\" of a 64-bit pagetable write.\n     */\n    if ( r == X86EMUL_OKAY && !emul_ctxt.ctxt.retire.raw )\n    {\n        int i, emulation_count=0;\n        this_cpu(trace_emulate_initial_va) = va;\n\n        for ( i = 0 ; i < 4 ; i++ )\n        {\n            shadow_continue_emulation(&emul_ctxt, regs);\n            v->arch.paging.last_write_was_pt = 0;\n            r = x86_emulate(&emul_ctxt.ctxt, emul_ops);\n\n            /*\n             * Only continue the search for the second half if there are no\n             * exceptions or pending actions.  Otherwise, give up and re-enter\n             * the guest.\n             */\n            if ( r == X86EMUL_OKAY && !emul_ctxt.ctxt.retire.raw )\n            {\n                emulation_count++;\n                if ( v->arch.paging.last_write_was_pt )\n                {\n                    perfc_incr(shadow_em_ex_pt);\n                    TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_EMULATION_2ND_PT_WRITTEN);\n                    break; /* Don't emulate past the other half of the write */\n                }\n                else\n                    perfc_incr(shadow_em_ex_non_pt);\n            }\n            else\n            {\n                perfc_incr(shadow_em_ex_fail);\n                TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_EMULATION_LAST_FAILED);\n\n                if ( emul_ctxt.ctxt.retire.singlestep )\n                    hvm_inject_hw_exception(TRAP_debug, X86_EVENT_NO_EC);\n\n                break; /* Don't emulate again if we failed! */\n            }\n        }\n        this_cpu(trace_extra_emulation_count)=emulation_count;\n    }\n#endif /* PAE guest */\n\n    trace_shadow_emulate(gw.l1e, va);\n emulate_done:\n    SHADOW_PRINTK(\"emulated\\n\");\n    return EXCRET_fault_fixed;\n\n mmio:\n    if ( !guest_mode(regs) )\n        goto not_a_shadow_fault;\n#ifdef CONFIG_HVM\n    ASSERT(is_hvm_vcpu(v));\n    perfc_incr(shadow_fault_mmio);\n    sh_audit_gw(v, &gw);\n    SHADOW_PRINTK(\"mmio %#\"PRIpaddr\"\\n\", gpa);\n    shadow_audit_tables(v);\n    sh_reset_early_unshadow(v);\n    paging_unlock(d);\n    put_gfn(d, gfn_x(gfn));\n    trace_shadow_gen(TRC_SHADOW_MMIO, va);\n    return (handle_mmio_with_translation(va, gpa >> PAGE_SHIFT, access)\n            ? EXCRET_fault_fixed : 0);\n#else\n    BUG();\n#endif\n\n not_a_shadow_fault:\n    sh_audit_gw(v, &gw);\n    SHADOW_PRINTK(\"not a shadow fault\\n\");\n    shadow_audit_tables(v);\n    sh_reset_early_unshadow(v);\n    paging_unlock(d);\n    put_gfn(d, gfn_x(gfn));\n\npropagate:\n    trace_not_shadow_fault(gw.l1e, va);\n\n    return 0;\n}",
        "description": "An issue was discovered in Xen versions up to 4.11.x, where x86 PV guest OS users could potentially cause a denial of service (host OS crash) or escalate their privileges to those of the host OS due to an interpretation conflict involving a union data structure related to shadow paging. This problem arose from an incorrect fix applied to address CVE-2017-15595.",
        "commit": "The vulnerability involves modifying the `struct page_info` in the x86/shadow module by reducing the size of the `shadow_flags` field to 16 bits to prevent overlap with the `linear_pt_count` field used in PV domains. To address this change, a new, HVM-only field named `pagetable_dying` was introduced to handle the functionality previously managed by the upper 16 bits of `shadow_flags`. The accesses to `shadow_flags` in functions like `shadow_{pro,de}mote()` were changed to non-atomic, non-bitops operations because atomic operations such as `{test,set,clear}_bit()` are not supported on `uint16_t` fields. This modification is justified by the fact that all updates to `shadow_flags` should occur while holding the paging lock, and other updates use bitwise operations (`|=`, `&=`), which inherently provide some level of atomicity. This change is part of the XSA-280 patch set."
    }
]