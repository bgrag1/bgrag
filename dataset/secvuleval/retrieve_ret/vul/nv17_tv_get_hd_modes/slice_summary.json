[
    {
        "cwe": "CWE-385",
        "func_name": "openssl/ecdsa_sign_setup",
        "score": 0.8015390038490295,
        "func_before": "static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,\n\t\t\t\t\tBIGNUM **kinvp, BIGNUM **rp,\n\t\t\t\t\tconst unsigned char *dgst, int dlen)\n{\n\tBN_CTX   *ctx = NULL;\n\tBIGNUM\t *k = NULL, *r = NULL, *order = NULL, *X = NULL;\n\tEC_POINT *tmp_point=NULL;\n\tconst EC_GROUP *group;\n\tint \t ret = 0;\n\n\tif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\n\tif (ctx_in == NULL) \n\t{\n\t\tif ((ctx = BN_CTX_new()) == NULL)\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t\tctx = ctx_in;\n\n\tk     = BN_new();\t/* this value is later returned in *kinvp */\n\tr     = BN_new();\t/* this value is later returned in *rp    */\n\torder = BN_new();\n\tX     = BN_new();\n\tif (!k || !r || !order || !X)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t}\n\tif ((tmp_point = EC_POINT_new(group)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\tif (!EC_GROUP_get_order(group, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\n#ifdef OPENSSL_FIPS\n\tif (!fips_check_ec_prng(eckey))\n\t\tgoto err;\n#endif\n\t\n\tdo\n\t{\n\t\t/* get random k */\t\n\t\tdo\n#ifndef OPENSSL_NO_SHA512\n\t\t\tif (dgst != NULL)\n\t\t\t{\n\t\t\t\tif (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),\n\t\t\t\t\t\t\t   dgst, dlen, ctx))\n\t\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tif (!BN_rand_range(k, order))\n\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\twhile (BN_is_zero(k));\n\n\t\t/* We do not want timing information to leak the length of k,\n\t\t * so we compute G*k using an equivalent scalar of fixed\n\t\t * bit-length. */\n\n\t\tif (!BN_add(k, k, order)) goto err;\n\t\tif (BN_num_bits(k) <= BN_num_bits(order))\n\t\t\tif (!BN_add(k, k, order)) goto err;\n\n\t\t/* compute r the x-coordinate of generator * k */\n\t\tif (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t}\n\t\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#ifndef OPENSSL_NO_EC2M\n\t\telse /* NID_X9_62_characteristic_two_field */\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GF2m(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!BN_nnmod(r, X, order, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t}\n\t}\n\twhile (BN_is_zero(r));\n\n\t/* compute the inverse of k */\n\tif (!BN_mod_inverse(k, k, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\tgoto err;\t\n\t}\n\t/* clear old values if necessary */\n\tif (*rp != NULL)\n\t\tBN_clear_free(*rp);\n\tif (*kinvp != NULL) \n\t\tBN_clear_free(*kinvp);\n\t/* save the pre-computed values  */\n\t*rp    = r;\n\t*kinvp = k;\n\tret = 1;\nerr:\n\tif (!ret)\n\t{\n\t\tif (k != NULL) BN_clear_free(k);\n\t\tif (r != NULL) BN_clear_free(r);\n\t}\n\tif (ctx_in == NULL) \n\t\tBN_CTX_free(ctx);\n\tif (order != NULL)\n\t\tBN_free(order);\n\tif (tmp_point != NULL) \n\t\tEC_POINT_free(tmp_point);\n\tif (X)\n\t\tBN_clear_free(X);\n\treturn(ret);\n}",
        "func_after": "static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,\n\t\t\t\t\tBIGNUM **kinvp, BIGNUM **rp,\n\t\t\t\t\tconst unsigned char *dgst, int dlen)\n{\n\tBN_CTX   *ctx = NULL;\n\tBIGNUM\t *k = NULL, *r = NULL, *order = NULL, *X = NULL;\n\tEC_POINT *tmp_point=NULL;\n\tconst EC_GROUP *group;\n\tint \t ret = 0;\n\n\tif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\n\tif (ctx_in == NULL) \n\t{\n\t\tif ((ctx = BN_CTX_new()) == NULL)\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t\tctx = ctx_in;\n\n\tk     = BN_new();\t/* this value is later returned in *kinvp */\n\tr     = BN_new();\t/* this value is later returned in *rp    */\n\torder = BN_new();\n\tX     = BN_new();\n\tif (!k || !r || !order || !X)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t}\n\tif ((tmp_point = EC_POINT_new(group)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\tif (!EC_GROUP_get_order(group, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\n#ifdef OPENSSL_FIPS\n\tif (!fips_check_ec_prng(eckey))\n\t\tgoto err;\n#endif\n\t\n\tdo\n\t{\n\t\t/* get random k */\t\n\t\tdo\n#ifndef OPENSSL_NO_SHA512\n\t\t\tif (dgst != NULL)\n\t\t\t{\n\t\t\t\tif (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),\n\t\t\t\t\t\t\t   dgst, dlen, ctx))\n\t\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tif (!BN_rand_range(k, order))\n\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\twhile (BN_is_zero(k));\n\n\t\t/* We do not want timing information to leak the length of k,\n\t\t * so we compute G*k using an equivalent scalar of fixed\n\t\t * bit-length. */\n\n\t\tif (!BN_add(k, k, order)) goto err;\n\t\tif (BN_num_bits(k) <= BN_num_bits(order))\n\t\t\tif (!BN_add(k, k, order)) goto err;\n\n\t\t/* compute r the x-coordinate of generator * k */\n\t\tif (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t}\n\t\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#ifndef OPENSSL_NO_EC2M\n\t\telse /* NID_X9_62_characteristic_two_field */\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GF2m(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!BN_nnmod(r, X, order, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t}\n\t}\n\twhile (BN_is_zero(r));\n\n\t/* compute the inverse of k */\n\tif (EC_GROUP_get_mont_data(group) != NULL)\n\t\t{\n\t\t/* We want inverse in constant time, therefore we utilize the\n\t\t * fact order must be prime and use Fermats Little Theorem\n\t\t * instead. */\n\t\tif (!BN_set_word(X, 2) )\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (!BN_mod_sub(X, order, X, order, ctx))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tBN_set_flags(X, BN_FLG_CONSTTIME);\n\t\tif (!BN_mod_exp_mont_consttime(k, k, X, order, ctx, EC_GROUP_get_mont_data(group)))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tif (!BN_mod_inverse(k, k, order, ctx))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\t\n\t\t\t}\n\t\t}\n\n\t/* clear old values if necessary */\n\tif (*rp != NULL)\n\t\tBN_clear_free(*rp);\n\tif (*kinvp != NULL) \n\t\tBN_clear_free(*kinvp);\n\t/* save the pre-computed values  */\n\t*rp    = r;\n\t*kinvp = k;\n\tret = 1;\nerr:\n\tif (!ret)\n\t{\n\t\tif (k != NULL) BN_clear_free(k);\n\t\tif (r != NULL) BN_clear_free(r);\n\t}\n\tif (ctx_in == NULL) \n\t\tBN_CTX_free(ctx);\n\tif (order != NULL)\n\t\tBN_free(order);\n\tif (tmp_point != NULL) \n\t\tEC_POINT_free(tmp_point);\n\tif (X)\n\t\tBN_clear_free(X);\n\treturn(ret);\n}",
        "description": "A timing attack vulnerability was identified in OpenSSL versions prior to 1.0.1u, enabling a malicious user with local access to potentially recover ECDSA P-256 private keys through the exploitation of timing variations in cryptographic operations.",
        "commit": "The vulnerability knowledge has been abstracted and generalized as follows:\n\n\"The implementation of ECDSA includes an option to utilize BN_mod_exp_mont_consttime, a constant-time modular exponentiation function. This enhancement aims to improve the security of ECDSA operations.\""
    },
    {
        "cwe": "CWE-601",
        "func_name": "OpenIDC/oidc_handle_logout",
        "score": 0.8024718165397644,
        "func_before": "static int oidc_handle_logout(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\toidc_provider_t *provider = NULL;\n\t/* pickup the command or URL where the user wants to go after logout */\n\tchar *url = NULL;\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_LOGOUT, &url);\n\n\toidc_debug(r, \"enter (url=%s)\", url);\n\n\tif (oidc_is_front_channel_logout(url)) {\n\t\treturn oidc_handle_logout_request(r, c, session, url);\n\t} else if (oidc_is_back_channel_logout(url)) {\n\t\treturn oidc_handle_logout_backchannel(r, c);\n\t}\n\n\tif ((url == NULL) || (apr_strnatcmp(url, \"\") == 0)) {\n\n\t\turl = c->default_slo_url;\n\n\t} else {\n\n\t\t/* do input validation on the logout parameter value */\n\n\t\tconst char *error_description = NULL;\n\t\tapr_uri_t uri;\n\n\t\tif (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {\n\t\t\tconst char *error_description = apr_psprintf(r->pool,\n\t\t\t\t\t\"Logout URL malformed: %s\", url);\n\t\t\toidc_error(r, \"%s\", error_description);\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Malformed URL\", error_description,\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\n\t\t}\n\n\t\tconst char *c_host = oidc_get_current_url_host(r);\n\t\tif ((uri.hostname != NULL)\n\t\t\t\t&& ((strstr(c_host, uri.hostname) == NULL)\n\t\t\t\t\t\t|| (strstr(uri.hostname, c_host) == NULL))) {\n\t\t\terror_description =\n\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n\t\t\toidc_error(r, \"%s\", error_description);\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\", error_description,\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t}\n\n\t\t/* validate the URL to prevent HTTP header splitting */\n\t\tif (((strstr(url, \"\\n\") != NULL) || strstr(url, \"\\r\") != NULL)) {\n\t\t\terror_description =\n\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\"logout value \\\"%s\\\" contains illegal \\\"\\n\\\" or \\\"\\r\\\" character(s)\",\n\t\t\t\t\t\t\turl);\n\t\t\toidc_error(r, \"%s\", error_description);\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\", error_description,\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t}\n\t}\n\n\toidc_get_provider_from_session(r, c, session, &provider);\n\n\tif ((provider != NULL) && (provider->end_session_endpoint != NULL)) {\n\n\t\tconst char *id_token_hint = oidc_session_get_idtoken(r, session);\n\n\t\tchar *logout_request = apr_pstrdup(r->pool,\n\t\t\t\tprovider->end_session_endpoint);\n\t\tif (id_token_hint != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool, \"%s%sid_token_hint=%s\",\n\t\t\t\t\tlogout_request, strchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, id_token_hint));\n\t\t}\n\n\t\tif (url != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool,\n\t\t\t\t\t\"%s%spost_logout_redirect_uri=%s\", logout_request,\n\t\t\t\t\tstrchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, url));\n\t\t}\n\t\turl = logout_request;\n\t}\n\n\treturn oidc_handle_logout_request(r, c, session, url);\n}",
        "func_after": "static int oidc_handle_logout(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\toidc_provider_t *provider = NULL;\n\t/* pickup the command or URL where the user wants to go after logout */\n\tchar *url = NULL;\n\tchar *error_str = NULL;\n\tchar *error_description = NULL;\n\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_LOGOUT, &url);\n\n\toidc_debug(r, \"enter (url=%s)\", url);\n\n\tif (oidc_is_front_channel_logout(url)) {\n\t\treturn oidc_handle_logout_request(r, c, session, url);\n\t} else if (oidc_is_back_channel_logout(url)) {\n\t\treturn oidc_handle_logout_backchannel(r, c);\n\t}\n\n\tif ((url == NULL) || (apr_strnatcmp(url, \"\") == 0)) {\n\n\t\turl = c->default_slo_url;\n\n\t} else {\n\n\t\t/* do input validation on the logout parameter value */\n\t\tif (oidc_validate_post_logout_url(r, url, &error_str,\n\t\t\t\t&error_description) == FALSE) {\n\t\t\treturn oidc_util_html_send_error(r, c->error_template, error_str,\n\t\t\t\t\terror_description,\n\t\t\t\t\tHTTP_BAD_REQUEST);\n\t\t}\n\t}\n\n\toidc_get_provider_from_session(r, c, session, &provider);\n\n\tif ((provider != NULL) && (provider->end_session_endpoint != NULL)) {\n\n\t\tconst char *id_token_hint = oidc_session_get_idtoken(r, session);\n\n\t\tchar *logout_request = apr_pstrdup(r->pool,\n\t\t\t\tprovider->end_session_endpoint);\n\t\tif (id_token_hint != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool, \"%s%sid_token_hint=%s\",\n\t\t\t\t\tlogout_request, strchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, id_token_hint));\n\t\t}\n\n\t\tif (url != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool,\n\t\t\t\t\t\"%s%spost_logout_redirect_uri=%s\", logout_request,\n\t\t\t\t\tstrchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, url));\n\t\t}\n\t\turl = logout_request;\n\t}\n\n\treturn oidc_handle_logout_request(r, c, session, url);\n}",
        "description": "A flaw was identified in mod_auth_openidc versions prior to 2.4.0.1, involving an open redirect vulnerability in URLs that include trailing slashes. This issue is analogous to CVE-2019-3877 found in mod_auth_mellon.",
        "commit": "Improving the validation of the post-logout URL to prevent open redirects."
    },
    {
        "cwe": "CWE-252",
        "func_name": "libtiff/createCroppedImage",
        "score": 0.7983119487762451,
        "func_before": "static int\ncreateCroppedImage(struct image_data *image, struct crop_mask *crop, \n                   unsigned char **read_buff_ptr, unsigned char **crop_buff_ptr)\n  {\n  tsize_t   cropsize;\n  unsigned  char *read_buff = NULL;\n  unsigned  char *crop_buff = NULL;\n  unsigned  char *new_buff  = NULL;\n  static    tsize_t  prev_cropsize = 0;\n\n  read_buff = *read_buff_ptr;\n\n  /* process full image, no crop buffer needed */\n  crop_buff = read_buff;\n  *crop_buff_ptr = read_buff;\n  crop->combined_width = image->width;\n  crop->combined_length = image->length;\n\n  cropsize = crop->bufftotal;\n  crop_buff = *crop_buff_ptr;\n  if (!crop_buff)\n    {\n    crop_buff = (unsigned char *)limitMalloc(cropsize);\n    *crop_buff_ptr = crop_buff;\n    _TIFFmemset(crop_buff, 0, cropsize);\n    prev_cropsize = cropsize;\n    }\n  else\n    {\n    if (prev_cropsize < cropsize)\n      {\n      new_buff = _TIFFrealloc(crop_buff, cropsize);\n      if (!new_buff)\n        {\n\tfree (crop_buff);\n        crop_buff = (unsigned char *)limitMalloc(cropsize);\n        }\n      else\n        crop_buff = new_buff;\n      _TIFFmemset(crop_buff, 0, cropsize);\n      }\n    }\n\n  if (!crop_buff)\n    {\n    TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");\n    return (-1);\n    }\n  *crop_buff_ptr = crop_buff;\n\n  if (crop->crop_mode & CROP_INVERT)\n    {\n    switch (crop->photometric)\n      {\n      /* Just change the interpretation */\n      case PHOTOMETRIC_MINISWHITE:\n      case PHOTOMETRIC_MINISBLACK:\n\t   image->photometric = crop->photometric;\n\t   break;\n      case INVERT_DATA_ONLY:\n      case INVERT_DATA_AND_TAG:\n           if (invertImage(image->photometric, image->spp, image->bps, \n                           crop->combined_width, crop->combined_length, crop_buff))\n             {\n             TIFFError(\"createCroppedImage\", \n                       \"Failed to invert colorspace for image or cropped selection\");\n             return (-1);\n             }\n           if (crop->photometric == INVERT_DATA_AND_TAG)\n             {\n             switch (image->photometric)\n               {\n               case PHOTOMETRIC_MINISWHITE:\n \t            image->photometric = PHOTOMETRIC_MINISBLACK;\n\t            break;\n               case PHOTOMETRIC_MINISBLACK:\n \t            image->photometric = PHOTOMETRIC_MINISWHITE;\n\t            break;\n               default:\n\t            break;\n\t       }\n\t     }\n           break;\n      default: break;\n      }\n    }\n\n  if (crop->crop_mode & CROP_MIRROR)\n    {\n    if (mirrorImage(image->spp, image->bps, crop->mirror, \n                    crop->combined_width, crop->combined_length, crop_buff))\n      {\n      TIFFError(\"createCroppedImage\", \"Failed to mirror image or cropped selection %s\", \n\t       (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");\n      return (-1);\n      }\n    }\n\n  if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n    {\n    if (rotateImage(crop->rotation, image, &crop->combined_width, \n                    &crop->combined_length, crop_buff_ptr))\n      {\n      TIFFError(\"createCroppedImage\", \n                \"Failed to rotate image or cropped selection by %\"PRIu16\" degrees\", crop->rotation);\n      return (-1);\n      }\n    }\n\n  if (crop_buff == read_buff) /* we used the read buffer for the crop buffer */\n    *read_buff_ptr = NULL;    /* so we don't try to free it later */\n\n  return (0);\n  }",
        "func_after": "static int\ncreateCroppedImage(struct image_data *image, struct crop_mask *crop, \n                   unsigned char **read_buff_ptr, unsigned char **crop_buff_ptr)\n  {\n  tsize_t   cropsize;\n  unsigned  char *read_buff = NULL;\n  unsigned  char *crop_buff = NULL;\n  unsigned  char *new_buff  = NULL;\n  static    tsize_t  prev_cropsize = 0;\n\n  read_buff = *read_buff_ptr;\n\n  /* process full image, no crop buffer needed */\n  crop_buff = read_buff;\n  *crop_buff_ptr = read_buff;\n  crop->combined_width = image->width;\n  crop->combined_length = image->length;\n\n  cropsize = crop->bufftotal;\n  crop_buff = *crop_buff_ptr;\n  if (!crop_buff)\n    {\n    crop_buff = (unsigned char *)limitMalloc(cropsize);\n    if (!crop_buff)\n    {\n        TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");\n        return (-1);\n    }\n    _TIFFmemset(crop_buff, 0, cropsize);\n    prev_cropsize = cropsize;\n    }\n  else\n    {\n    if (prev_cropsize < cropsize)\n      {\n      new_buff = _TIFFrealloc(crop_buff, cropsize);\n      if (!new_buff)\n        {\n\tfree (crop_buff);\n        crop_buff = (unsigned char *)limitMalloc(cropsize);\n        }\n      else\n        crop_buff = new_buff;\n      if (!crop_buff)\n      {\n          TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");\n          return (-1);\n      }\n      _TIFFmemset(crop_buff, 0, cropsize);\n      }\n    }\n\n  *crop_buff_ptr = crop_buff;\n\n  if (crop->crop_mode & CROP_INVERT)\n    {\n    switch (crop->photometric)\n      {\n      /* Just change the interpretation */\n      case PHOTOMETRIC_MINISWHITE:\n      case PHOTOMETRIC_MINISBLACK:\n\t   image->photometric = crop->photometric;\n\t   break;\n      case INVERT_DATA_ONLY:\n      case INVERT_DATA_AND_TAG:\n           if (invertImage(image->photometric, image->spp, image->bps, \n                           crop->combined_width, crop->combined_length, crop_buff))\n             {\n             TIFFError(\"createCroppedImage\", \n                       \"Failed to invert colorspace for image or cropped selection\");\n             return (-1);\n             }\n           if (crop->photometric == INVERT_DATA_AND_TAG)\n             {\n             switch (image->photometric)\n               {\n               case PHOTOMETRIC_MINISWHITE:\n \t            image->photometric = PHOTOMETRIC_MINISBLACK;\n\t            break;\n               case PHOTOMETRIC_MINISBLACK:\n \t            image->photometric = PHOTOMETRIC_MINISWHITE;\n\t            break;\n               default:\n\t            break;\n\t       }\n\t     }\n           break;\n      default: break;\n      }\n    }\n\n  if (crop->crop_mode & CROP_MIRROR)\n    {\n    if (mirrorImage(image->spp, image->bps, crop->mirror, \n                    crop->combined_width, crop->combined_length, crop_buff))\n      {\n      TIFFError(\"createCroppedImage\", \"Failed to mirror image or cropped selection %s\", \n\t       (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");\n      return (-1);\n      }\n    }\n\n  if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n    {\n    if (rotateImage(crop->rotation, image, &crop->combined_width, \n                    &crop->combined_length, crop_buff_ptr))\n      {\n      TIFFError(\"createCroppedImage\", \n                \"Failed to rotate image or cropped selection by %\"PRIu16\" degrees\", crop->rotation);\n      return (-1);\n      }\n    }\n\n  if (crop_buff == read_buff) /* we used the read buffer for the crop buffer */\n    *read_buff_ptr = NULL;    /* so we don't try to free it later */\n\n  return (0);\n  }",
        "description": "Unchecked return value leading to NULL pointer dereference in the tiffcrop utility of libtiff 4.3.0 enables attackers to trigger a denial-of-service condition through a specially crafted TIFF file. Users who compile libtiff from source can apply the fix available in commit f2b656e2.",
        "commit": "It was identified that checks for the return value of memory allocation functions like `malloc` were missing, which could lead to potential issues if the allocation fails."
    },
    {
        "cwe": "CWE-444",
        "func_name": "haproxy/http_parse_cont_len_header",
        "score": 0.7846143245697021,
        "func_before": "int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\n\tword.ptr = value->ptr - 1; // -1 for next loop's pre-increment\n\te = value->ptr + value->len;\n\n\twhile (++word.ptr < e) {\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\t*body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}",
        "func_after": "int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\n\tword.ptr = value->ptr;\n\te = value->ptr + value->len;\n\n\twhile (1) {\n\t\tif (word.ptr >= e) {\n\t\t\t/* empty header or empty value */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr))) {\n\t\t\tword.ptr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\t*body_len = cl;\n\t\t*value = word;\n\n\t\t/* Now either n==e and we're done, or n points to the comma,\n\t\t * and we skip it and continue.\n\t\t */\n\t\tif (n++ == e)\n\t\t\tbreak;\n\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}",
        "description": "HAProxy versions up to 2.0.32, 2.1.x, 2.2.x through 2.2.30, 2.3.x, 2.4.x through 2.4.23, 2.5.x, and 2.6.x before 2.6.15, 2.7.x before 2.7.10, and 2.8.x before 2.8.2 forward empty Content-Length headers, which violates RFC 9110 section 8.6. In rare scenarios, an HTTP/1 server positioned behind HAProxy may misinterpret the payload as an additional request.",
        "commit": "A vulnerability was identified in the HTTP content-length header parsing mechanism, where an empty or trailing-comma value could be misinterpreted as an absent header. This oversight allowed such headers to pass through to the backend server without proper validation, potentially exposing vulnerable servers to attacks. The risk varies based on the backend server's handling of content-length headers, but users relying on HAProxy to protect known-vulnerable servers are particularly at risk. A configuration-based workaround involves explicitly rejecting requests with empty content-length headers in the frontend settings. The permanent fix requires modifying the parser to ensure that only valid values are accepted, rejecting any empty values encountered. This change needs to be applied across all supported versions of the software. The modifications were made to functions such as `h1_parse_cont_len_header()` and `http_parse_cont_len_header()`, with additional considerations for compatibility with Lua and future deprecation plans. Comprehensive testing was conducted to validate these changes."
    },
    {
        "cwe": "CWE-78",
        "func_name": "emacs/main",
        "score": 0.7958383560180664,
        "func_before": "int\nmain (int argc, char **argv)\n{\n  int i;\n  int nincluded_files;\n  char **included_files;\n  argument *argbuffer;\n  int current_arg, file_count;\n  linebuffer filename_lb;\n  bool help_asked = false;\n  ptrdiff_t len;\n  char *optstring;\n  int opt;\n\n  progname = argv[0];\n  nincluded_files = 0;\n  included_files = xnew (argc, char *);\n  current_arg = 0;\n  file_count = 0;\n\n  /* Allocate enough no matter what happens.  Overkill, but each one\n     is small. */\n  argbuffer = xnew (argc, argument);\n\n  /*\n   * Always find typedefs and structure tags.\n   * Also default to find macro constants, enum constants, struct\n   * members and global variables.  Do it for both etags and ctags.\n   */\n  typedefs = typedefs_or_cplusplus = constantypedefs = true;\n  globals = members = true;\n\n  /* When the optstring begins with a '-' getopt_long does not rearrange the\n     non-options arguments to be at the end, but leaves them alone. */\n  optstring = concat (\"-ac:Cf:Il:o:Qr:RSVhH\",\n\t\t      (CTAGS) ? \"BxdtTuvw\" : \"Di:\",\n\t\t      \"\");\n\n  while ((opt = getopt_long (argc, argv, optstring, longopts, NULL)) != EOF)\n    switch (opt)\n      {\n      case 0:\n\t/* If getopt returns 0, then it has already processed a\n\t   long-named option.  We should do nothing.  */\n\tbreak;\n\n      case 1:\n\t/* This means that a file name has been seen.  Record it. */\n\targbuffer[current_arg].arg_type = at_filename;\n\targbuffer[current_arg].what     = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\t++file_count;\n\tbreak;\n\n      case STDIN:\n\t/* Parse standard input.  Idea by Vivek <vivek@etla.org>. */\n\targbuffer[current_arg].arg_type = at_stdin;\n\targbuffer[current_arg].what     = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\t++file_count;\n\tif (parsing_stdin)\n\t  fatal (\"cannot parse standard input more than once\");\n\tparsing_stdin = true;\n\tbreak;\n\n\t/* Common options. */\n      case 'a': append_to_tagfile = true;\tbreak;\n      case 'C': cplusplus = true;\t\tbreak;\n      case 'f':\t\t/* for compatibility with old makefiles */\n      case 'o':\n\tif (tagfile)\n\t  {\n\t    error (\"-o option may only be given once.\");\n\t    suggest_asking_for_help ();\n\t  }\n\ttagfile = optarg;\n\tbreak;\n      case 'I':\n      case 'S':\t\t/* for backward compatibility */\n\tignoreindent = true;\n\tbreak;\n      case 'l':\n\t{\n\t  language *lang = get_language_from_langname (optarg);\n\t  if (lang != NULL)\n\t    {\n\t      argbuffer[current_arg].lang = lang;\n\t      argbuffer[current_arg].arg_type = at_language;\n\t      ++current_arg;\n\t    }\n\t}\n\tbreak;\n      case 'c':\n\t/* Backward compatibility: support obsolete --ignore-case-regexp. */\n\toptarg = concat (optarg, \"i\", \"\"); /* memory leak here */\n\tFALLTHROUGH;\n      case 'r':\n\targbuffer[current_arg].arg_type = at_regexp;\n\targbuffer[current_arg].what = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\tbreak;\n      case 'R':\n\targbuffer[current_arg].arg_type = at_regexp;\n\targbuffer[current_arg].what = NULL;\n\t++current_arg;\n\tbreak;\n      case 'V':\n\tprint_version ();\n\tbreak;\n      case 'h':\n      case 'H':\n\thelp_asked = true;\n\tbreak;\n      case 'Q':\n\tclass_qualify = 1;\n\tbreak;\n\n\t/* Etags options */\n      case 'D': constantypedefs = false;\t\t\tbreak;\n      case 'i': included_files[nincluded_files++] = optarg;\tbreak;\n\n\t/* Ctags options. */\n      case 'B': searchar = '?';\t\t\t\t\tbreak;\n      case 'd': constantypedefs = true;\t\t\t\tbreak;\n      case 't': typedefs = true;\t\t\t\tbreak;\n      case 'T': typedefs = typedefs_or_cplusplus = true;\tbreak;\n      case 'u': update = true;\t\t\t\t\tbreak;\n      case 'v': vgrind_style = true;\t\t\t\tFALLTHROUGH;\n      case 'x': cxref_style = true;\t\t\t\tbreak;\n      case 'w': no_warnings = true;\t\t\t\tbreak;\n      default:\n\tsuggest_asking_for_help ();\n      }\n\n  /* No more options.  Store the rest of arguments. */\n  for (; optind < argc; optind++)\n    {\n      argbuffer[current_arg].arg_type = at_filename;\n      argbuffer[current_arg].what = argv[optind];\n      len = strlen (argv[optind]);\n      if (whatlen_max < len)\n\twhatlen_max = len;\n      ++current_arg;\n      ++file_count;\n    }\n\n  argbuffer[current_arg].arg_type = at_end;\n\n  if (help_asked)\n    print_help (argbuffer);\n\n  if (nincluded_files == 0 && file_count == 0)\n    {\n      error (\"no input files specified.\");\n      suggest_asking_for_help ();\n    }\n\n  if (tagfile == NULL)\n    tagfile = savestr (CTAGS ? \"tags\" : \"TAGS\");\n  cwd = etags_getcwd ();\t/* the current working directory */\n  if (cwd[strlen (cwd) - 1] != '/')\n    {\n      char *oldcwd = cwd;\n      cwd = concat (oldcwd, \"/\", \"\");\n      free (oldcwd);\n    }\n\n  /* Compute base directory for relative file names. */\n  if (streq (tagfile, \"-\")\n      || strneq (tagfile, \"/dev/\", 5))\n    tagfiledir = cwd;\t\t /* relative file names are relative to cwd */\n  else\n    {\n      canonicalize_filename (tagfile);\n      tagfiledir = absolute_dirname (tagfile, cwd);\n    }\n\n  linebuffer_init (&lb);\n  linebuffer_init (&filename_lb);\n  linebuffer_init (&filebuf);\n  linebuffer_init (&token_name);\n\n  if (!CTAGS)\n    {\n      if (streq (tagfile, \"-\"))\n\t{\n\t  tagf = stdout;\n\t  set_binary_mode (STDOUT_FILENO, O_BINARY);\n\t}\n      else\n\ttagf = fopen (tagfile, append_to_tagfile ? \"ab\" : \"wb\");\n      if (tagf == NULL)\n\tpfatal (tagfile);\n    }\n\n  /*\n   * Loop through files finding functions.\n   */\n  for (i = 0; i < current_arg; i++)\n    {\n      static language *lang;\t/* non-NULL if language is forced */\n      char *this_file;\n\n      switch (argbuffer[i].arg_type)\n\t{\n\tcase at_language:\n\t  lang = argbuffer[i].lang;\n\t  break;\n\tcase at_regexp:\n\t  analyze_regex (argbuffer[i].what);\n\t  break;\n\tcase at_filename:\n\t      this_file = argbuffer[i].what;\n\t      /* Input file named \"-\" means read file names from stdin\n\t\t (one per line) and use them. */\n\t      if (streq (this_file, \"-\"))\n\t\t{\n\t\t  if (parsing_stdin)\n\t\t    fatal (\"cannot parse standard input \"\n\t\t\t   \"AND read file names from it\");\n\t\t  while (readline_internal (&filename_lb, stdin, \"-\") > 0)\n\t\t    process_file_name (filename_lb.buffer, lang);\n\t\t}\n\t      else\n\t\tprocess_file_name (this_file, lang);\n\t  break;\n        case at_stdin:\n          this_file = argbuffer[i].what;\n          process_file (stdin, this_file, lang);\n          break;\n\tdefault:\n\t  error (\"internal error: arg_type\");\n\t}\n    }\n\n  free_regexps ();\n  free (lb.buffer);\n  free (filebuf.buffer);\n  free (token_name.buffer);\n\n  if (!CTAGS || cxref_style)\n    {\n      /* Write the remaining tags to tagf (ETAGS) or stdout (CXREF). */\n      put_entries (nodehead);\n      free_tree (nodehead);\n      nodehead = NULL;\n      if (!CTAGS)\n\t{\n\t  fdesc *fdp;\n\n\t  /* Output file entries that have no tags. */\n\t  for (fdp = fdhead; fdp != NULL; fdp = fdp->next)\n\t    if (!fdp->written)\n\t      fprintf (tagf, \"\\f\\n%s,0\\n\", fdp->taggedfname);\n\n\t  while (nincluded_files-- > 0)\n\t    fprintf (tagf, \"\\f\\n%s,include\\n\", *included_files++);\n\n\t  if (fclose (tagf) == EOF)\n\t    pfatal (tagfile);\n\t}\n\n      return EXIT_SUCCESS;\n    }\n\n  /* From here on, we are in (CTAGS && !cxref_style) */\n  if (update)\n    {\n      char *cmd =\n\txmalloc (strlen (tagfile) + whatlen_max +\n\t\t sizeof \"mv..OTAGS;grep -Fv '\\t\\t' OTAGS >;rm OTAGS\");\n      for (i = 0; i < current_arg; ++i)\n\t{\n\t  switch (argbuffer[i].arg_type)\n\t    {\n\t    case at_filename:\n\t    case at_stdin:\n\t      break;\n\t    default:\n\t      continue;\t\t/* the for loop */\n\t    }\n\t  char *z = stpcpy (cmd, \"mv \");\n\t  z = stpcpy (z, tagfile);\n\t  z = stpcpy (z, \" OTAGS;grep -Fv '\\t\");\n\t  z = stpcpy (z, argbuffer[i].what);\n\t  z = stpcpy (z, \"\\t' OTAGS >\");\n\t  z = stpcpy (z, tagfile);\n\t  strcpy (z, \";rm OTAGS\");\n\t  if (system (cmd) != EXIT_SUCCESS)\n\t    fatal (\"failed to execute shell command\");\n\t}\n      free (cmd);\n      append_to_tagfile = true;\n    }\n\n  tagf = fopen (tagfile, append_to_tagfile ? \"ab\" : \"wb\");\n  if (tagf == NULL)\n    pfatal (tagfile);\n  put_entries (nodehead);\t/* write all the tags (CTAGS) */\n  free_tree (nodehead);\n  nodehead = NULL;\n  if (fclose (tagf) == EOF)\n    pfatal (tagfile);\n\n  if (CTAGS)\n    if (append_to_tagfile || update)\n      {\n\t/* Maybe these should be used:\n\t   setenv (\"LC_COLLATE\", \"C\", 1);\n\t   setenv (\"LC_ALL\", \"C\", 1); */\n\tchar *cmd = xmalloc (8 * strlen (tagfile) + sizeof \"sort -u -o '' ''\");\n#if defined WINDOWSNT || defined MSDOS\n\t/* Quote \"like this\".  No need to escape the quotes in the file name,\n\t   since it is not allowed in file names on these systems.  */\n\tchar *z = stpcpy (cmd, \"sort -u -o \\\"\");\n\tz = stpcpy (z, tagfile);\n\tz = stpcpy (z, \"\\\" \\\"\");\n\tz = stpcpy (z, tagfile);\n\tstpcpy (z, \"\\\"\");\n#else\n\t/* Quote 'like this', and escape the apostrophe in the file name.  */\n\tchar *z = stpcpy (cmd, \"sort -u -o '\");\n\tchar *escaped_tagfile = z;\n\tfor (; *tagfile; *z++ = *tagfile++)\n\t  if (*tagfile == '\\'')\n\t    z = stpcpy (z, \"'\\\\'\");\n\tptrdiff_t escaped_tagfile_len = z - escaped_tagfile;\n\tz = stpcpy (z, \"' '\");\n\tz = mempcpy (z, escaped_tagfile, escaped_tagfile_len);\n\tstrcpy (z, \"'\");\n#endif\n\treturn system (cmd);\n      }\n  return EXIT_SUCCESS;\n}",
        "func_after": "int\nmain (int argc, char **argv)\n{\n  int i;\n  int nincluded_files;\n  char **included_files;\n  argument *argbuffer;\n  int current_arg, file_count;\n  linebuffer filename_lb;\n  bool help_asked = false;\n  ptrdiff_t len;\n  char *optstring;\n  int opt;\n\n  progname = argv[0];\n  nincluded_files = 0;\n  included_files = xnew (argc, char *);\n  current_arg = 0;\n  file_count = 0;\n\n  /* Allocate enough no matter what happens.  Overkill, but each one\n     is small. */\n  argbuffer = xnew (argc, argument);\n\n  /*\n   * Always find typedefs and structure tags.\n   * Also default to find macro constants, enum constants, struct\n   * members and global variables.  Do it for both etags and ctags.\n   */\n  typedefs = typedefs_or_cplusplus = constantypedefs = true;\n  globals = members = true;\n\n  /* When the optstring begins with a '-' getopt_long does not rearrange the\n     non-options arguments to be at the end, but leaves them alone. */\n  optstring = concat (\"-ac:Cf:Il:o:Qr:RSVhH\",\n\t\t      (CTAGS) ? \"BxdtTuvw\" : \"Di:\",\n\t\t      \"\");\n\n  while ((opt = getopt_long (argc, argv, optstring, longopts, NULL)) != EOF)\n    switch (opt)\n      {\n      case 0:\n\t/* If getopt returns 0, then it has already processed a\n\t   long-named option.  We should do nothing.  */\n\tbreak;\n\n      case 1:\n\t/* This means that a file name has been seen.  Record it. */\n\targbuffer[current_arg].arg_type = at_filename;\n\targbuffer[current_arg].what     = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\t++file_count;\n\tbreak;\n\n      case STDIN:\n\t/* Parse standard input.  Idea by Vivek <vivek@etla.org>. */\n\targbuffer[current_arg].arg_type = at_stdin;\n\targbuffer[current_arg].what     = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\t++file_count;\n\tif (parsing_stdin)\n\t  fatal (\"cannot parse standard input more than once\");\n\tparsing_stdin = true;\n\tbreak;\n\n\t/* Common options. */\n      case 'a': append_to_tagfile = true;\tbreak;\n      case 'C': cplusplus = true;\t\tbreak;\n      case 'f':\t\t/* for compatibility with old makefiles */\n      case 'o':\n\tif (tagfile)\n\t  {\n\t    error (\"-o option may only be given once.\");\n\t    suggest_asking_for_help ();\n\t  }\n\ttagfile = optarg;\n\tbreak;\n      case 'I':\n      case 'S':\t\t/* for backward compatibility */\n\tignoreindent = true;\n\tbreak;\n      case 'l':\n\t{\n\t  language *lang = get_language_from_langname (optarg);\n\t  if (lang != NULL)\n\t    {\n\t      argbuffer[current_arg].lang = lang;\n\t      argbuffer[current_arg].arg_type = at_language;\n\t      ++current_arg;\n\t    }\n\t}\n\tbreak;\n      case 'c':\n\t/* Backward compatibility: support obsolete --ignore-case-regexp. */\n\toptarg = concat (optarg, \"i\", \"\"); /* memory leak here */\n\tFALLTHROUGH;\n      case 'r':\n\targbuffer[current_arg].arg_type = at_regexp;\n\targbuffer[current_arg].what = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\tbreak;\n      case 'R':\n\targbuffer[current_arg].arg_type = at_regexp;\n\targbuffer[current_arg].what = NULL;\n\t++current_arg;\n\tbreak;\n      case 'V':\n\tprint_version ();\n\tbreak;\n      case 'h':\n      case 'H':\n\thelp_asked = true;\n\tbreak;\n      case 'Q':\n\tclass_qualify = 1;\n\tbreak;\n\n\t/* Etags options */\n      case 'D': constantypedefs = false;\t\t\tbreak;\n      case 'i': included_files[nincluded_files++] = optarg;\tbreak;\n\n\t/* Ctags options. */\n      case 'B': searchar = '?';\t\t\t\t\tbreak;\n      case 'd': constantypedefs = true;\t\t\t\tbreak;\n      case 't': typedefs = true;\t\t\t\tbreak;\n      case 'T': typedefs = typedefs_or_cplusplus = true;\tbreak;\n      case 'u': update = true;\t\t\t\t\tbreak;\n      case 'v': vgrind_style = true;\t\t\t\tFALLTHROUGH;\n      case 'x': cxref_style = true;\t\t\t\tbreak;\n      case 'w': no_warnings = true;\t\t\t\tbreak;\n      default:\n\tsuggest_asking_for_help ();\n      }\n\n  /* No more options.  Store the rest of arguments. */\n  for (; optind < argc; optind++)\n    {\n      argbuffer[current_arg].arg_type = at_filename;\n      argbuffer[current_arg].what = argv[optind];\n      len = strlen (argv[optind]);\n      if (whatlen_max < len)\n\twhatlen_max = len;\n      ++current_arg;\n      ++file_count;\n    }\n\n  argbuffer[current_arg].arg_type = at_end;\n\n  if (help_asked)\n    print_help (argbuffer);\n\n  if (nincluded_files == 0 && file_count == 0)\n    {\n      error (\"no input files specified.\");\n      suggest_asking_for_help ();\n    }\n\n  if (tagfile == NULL)\n    tagfile = savestr (CTAGS ? \"tags\" : \"TAGS\");\n  cwd = etags_getcwd ();\t/* the current working directory */\n  if (cwd[strlen (cwd) - 1] != '/')\n    {\n      char *oldcwd = cwd;\n      cwd = concat (oldcwd, \"/\", \"\");\n      free (oldcwd);\n    }\n\n  /* Compute base directory for relative file names. */\n  if (streq (tagfile, \"-\")\n      || strneq (tagfile, \"/dev/\", 5))\n    tagfiledir = cwd;\t\t /* relative file names are relative to cwd */\n  else\n    {\n      canonicalize_filename (tagfile);\n      tagfiledir = absolute_dirname (tagfile, cwd);\n    }\n\n  linebuffer_init (&lb);\n  linebuffer_init (&filename_lb);\n  linebuffer_init (&filebuf);\n  linebuffer_init (&token_name);\n\n  if (!CTAGS)\n    {\n      if (streq (tagfile, \"-\"))\n\t{\n\t  tagf = stdout;\n\t  set_binary_mode (STDOUT_FILENO, O_BINARY);\n\t}\n      else\n\ttagf = fopen (tagfile, append_to_tagfile ? \"ab\" : \"wb\");\n      if (tagf == NULL)\n\tpfatal (tagfile);\n    }\n\n  /*\n   * Loop through files finding functions.\n   */\n  for (i = 0; i < current_arg; i++)\n    {\n      static language *lang;\t/* non-NULL if language is forced */\n      char *this_file;\n\n      switch (argbuffer[i].arg_type)\n\t{\n\tcase at_language:\n\t  lang = argbuffer[i].lang;\n\t  break;\n\tcase at_regexp:\n\t  analyze_regex (argbuffer[i].what);\n\t  break;\n\tcase at_filename:\n\t      this_file = argbuffer[i].what;\n\t      /* Input file named \"-\" means read file names from stdin\n\t\t (one per line) and use them. */\n\t      if (streq (this_file, \"-\"))\n\t\t{\n\t\t  if (parsing_stdin)\n\t\t    fatal (\"cannot parse standard input \"\n\t\t\t   \"AND read file names from it\");\n\t\t  while (readline_internal (&filename_lb, stdin, \"-\", false) > 0)\n\t\t    process_file_name (filename_lb.buffer, lang);\n\t\t}\n\t      else\n\t\tprocess_file_name (this_file, lang);\n\t  break;\n        case at_stdin:\n          this_file = argbuffer[i].what;\n          process_file (stdin, this_file, lang);\n          break;\n\tdefault:\n\t  error (\"internal error: arg_type\");\n\t}\n    }\n\n  free_regexps ();\n  free (lb.buffer);\n  free (filebuf.buffer);\n  free (token_name.buffer);\n\n  if (!CTAGS || cxref_style)\n    {\n      /* Write the remaining tags to tagf (ETAGS) or stdout (CXREF). */\n      put_entries (nodehead);\n      free_tree (nodehead);\n      nodehead = NULL;\n      if (!CTAGS)\n\t{\n\t  fdesc *fdp;\n\n\t  /* Output file entries that have no tags. */\n\t  for (fdp = fdhead; fdp != NULL; fdp = fdp->next)\n\t    if (!fdp->written)\n\t      fprintf (tagf, \"\\f\\n%s,0\\n\", fdp->taggedfname);\n\n\t  while (nincluded_files-- > 0)\n\t    fprintf (tagf, \"\\f\\n%s,include\\n\", *included_files++);\n\n\t  if (fclose (tagf) == EOF)\n\t    pfatal (tagfile);\n\t}\n\n      return EXIT_SUCCESS;\n    }\n\n  /* From here on, we are in (CTAGS && !cxref_style) */\n  if (update)\n    {\n      for (i = 0; i < current_arg; ++i)\n\t{\n\t  switch (argbuffer[i].arg_type)\n\t    {\n\t    case at_filename:\n\t    case at_stdin:\n\t      break;\n\t    default:\n\t      continue;\t\t/* the for loop */\n\t    }\n          clean_matched_file_tag (tagfile, argbuffer[i].what);\n\t}\n      append_to_tagfile = true;\n    }\n\n  tagf = fopen (tagfile, append_to_tagfile ? \"ab\" : \"wb\");\n  if (tagf == NULL)\n    pfatal (tagfile);\n  put_entries (nodehead);\t/* write all the tags (CTAGS) */\n  free_tree (nodehead);\n  nodehead = NULL;\n  if (fclose (tagf) == EOF)\n    pfatal (tagfile);\n\n  if (CTAGS)\n    if (append_to_tagfile || update)\n      {\n\t/* Maybe these should be used:\n\t   setenv (\"LC_COLLATE\", \"C\", 1);\n\t   setenv (\"LC_ALL\", \"C\", 1); */\n\tchar *cmd = xmalloc (8 * strlen (tagfile) + sizeof \"sort -u -o '' ''\");\n#if defined WINDOWSNT || defined MSDOS\n\t/* Quote \"like this\".  No need to escape the quotes in the file name,\n\t   since it is not allowed in file names on these systems.  */\n\tchar *z = stpcpy (cmd, \"sort -u -o \\\"\");\n\tz = stpcpy (z, tagfile);\n\tz = stpcpy (z, \"\\\" \\\"\");\n\tz = stpcpy (z, tagfile);\n\tstpcpy (z, \"\\\"\");\n#else\n\t/* Quote 'like this', and escape the apostrophe in the file name.  */\n\tchar *z = stpcpy (cmd, \"sort -u -o '\");\n\tchar *escaped_tagfile = z;\n\tfor (; *tagfile; *z++ = *tagfile++)\n\t  if (*tagfile == '\\'')\n\t    z = stpcpy (z, \"'\\\\'\");\n\tptrdiff_t escaped_tagfile_len = z - escaped_tagfile;\n\tz = stpcpy (z, \"' '\");\n\tz = mempcpy (z, escaped_tagfile, escaped_tagfile_len);\n\tstrcpy (z, \"'\");\n#endif\n\treturn system (cmd);\n      }\n  return EXIT_SUCCESS;\n}",
        "description": "GNU Emacs versions up to 28.2 are vulnerable to command execution through shell metacharacters in source-code file names. This vulnerability arises due to the use of the system C library function within the implementation of the ctags program in lib-src/etags.c. An attacker can exploit this by using commands like \"ctags *\" in a directory containing files whose names are influenced by untrusted input, leading to unintended command execution.",
        "commit": "The vulnerability knowledge describes the addition of new functions and files within the `lib-src/etags.c` and `test/manual/etags/` directories of a software project. Specifically, the `clean_matched_file_tag` and `do_move_file` functions have been introduced, along with modifications to the `readline_internal` function to include a `leave_cr` parameter that controls whether the `\\r` character should be included. Additionally, new test files (`CTAGS.good_crlf`, `CTAGS.good_update`, and `crlf`) have been added to the `test/manual/etags/` directory, and test cases for `ctags -u` have been incorporated into the `Makefile`."
    }
]