[
    {
        "cwe": "CWE-200",
        "func_name": "torvalds/xfs_iget_cache_miss",
        "score": 0.8110642433166504,
        "func_before": "static int\nxfs_iget_cache_miss(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_trans_t\t\t*tp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_inode\t**ipp,\n\txfs_daddr_t\t\tbno,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\tunsigned long\t\tfirst_index, mask;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ino);\n\n\tip = xfs_inode_alloc(mp, ino);\n\tif (!ip)\n\t\treturn ENOMEM;\n\n\terror = xfs_iread(mp, tp, ip, bno, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\txfs_itrace_entry(ip);\n\n\tif ((ip->i_d.di_mode == 0) && !(flags & XFS_IGET_CREATE)) {\n\t\terror = ENOENT;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Preload the radix tree so we can insert safely under the\n\t * write spinlock. Note that we cannot sleep inside the preload\n\t * region.\n\t */\n\tif (radix_tree_preload(GFP_KERNEL)) {\n\t\terror = EAGAIN;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Because the inode hasn't been added to the radix-tree yet it can't\n\t * be found by another thread, so we can do the non-sleeping lock here.\n\t */\n\tif (lock_flags) {\n\t\tif (!xfs_ilock_nowait(ip, lock_flags))\n\t\t\tBUG();\n\t}\n\n\tmask = ~(((XFS_INODE_CLUSTER_SIZE(mp) >> mp->m_sb.sb_inodelog)) - 1);\n\tfirst_index = agino & mask;\n\twrite_lock(&pag->pag_ici_lock);\n\n\t/* insert the new inode */\n\terror = radix_tree_insert(&pag->pag_ici_root, agino, ip);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\t\tXFS_STATS_INC(xs_ig_dup);\n\t\terror = EAGAIN;\n\t\tgoto out_preload_end;\n\t}\n\n\t/* These values _must_ be set before releasing the radix tree lock! */\n\tip->i_udquot = ip->i_gdquot = NULL;\n\txfs_iflags_set(ip, XFS_INEW);\n\n\twrite_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\n\ttrace_xfs_iget_alloc(ip);\n\t*ipp = ip;\n\treturn 0;\n\nout_preload_end:\n\twrite_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\nout_destroy:\n\t__destroy_inode(VFS_I(ip));\n\txfs_inode_free(ip);\n\treturn error;\n}",
        "func_after": "static int\nxfs_iget_cache_miss(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\txfs_trans_t\t\t*tp,\n\txfs_ino_t\t\tino,\n\tstruct xfs_inode\t**ipp,\n\tint\t\t\tflags,\n\tint\t\t\tlock_flags)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\tunsigned long\t\tfirst_index, mask;\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ino);\n\n\tip = xfs_inode_alloc(mp, ino);\n\tif (!ip)\n\t\treturn ENOMEM;\n\n\terror = xfs_iread(mp, tp, ip, flags);\n\tif (error)\n\t\tgoto out_destroy;\n\n\txfs_itrace_entry(ip);\n\n\tif ((ip->i_d.di_mode == 0) && !(flags & XFS_IGET_CREATE)) {\n\t\terror = ENOENT;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Preload the radix tree so we can insert safely under the\n\t * write spinlock. Note that we cannot sleep inside the preload\n\t * region.\n\t */\n\tif (radix_tree_preload(GFP_KERNEL)) {\n\t\terror = EAGAIN;\n\t\tgoto out_destroy;\n\t}\n\n\t/*\n\t * Because the inode hasn't been added to the radix-tree yet it can't\n\t * be found by another thread, so we can do the non-sleeping lock here.\n\t */\n\tif (lock_flags) {\n\t\tif (!xfs_ilock_nowait(ip, lock_flags))\n\t\t\tBUG();\n\t}\n\n\tmask = ~(((XFS_INODE_CLUSTER_SIZE(mp) >> mp->m_sb.sb_inodelog)) - 1);\n\tfirst_index = agino & mask;\n\twrite_lock(&pag->pag_ici_lock);\n\n\t/* insert the new inode */\n\terror = radix_tree_insert(&pag->pag_ici_root, agino, ip);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\t\tXFS_STATS_INC(xs_ig_dup);\n\t\terror = EAGAIN;\n\t\tgoto out_preload_end;\n\t}\n\n\t/* These values _must_ be set before releasing the radix tree lock! */\n\tip->i_udquot = ip->i_gdquot = NULL;\n\txfs_iflags_set(ip, XFS_INEW);\n\n\twrite_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\n\ttrace_xfs_iget_alloc(ip);\n\t*ipp = ip;\n\treturn 0;\n\nout_preload_end:\n\twrite_unlock(&pag->pag_ici_lock);\n\tradix_tree_preload_end();\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\nout_destroy:\n\t__destroy_inode(VFS_I(ip));\n\txfs_inode_free(ip);\n\treturn error;\n}",
        "description": "The XFS implementation in the Linux kernel prior to version 2.6.35 fails to check inode allocation btrees before reading inode buffers. This oversight enables remote authenticated users to access unlinked files or modify disk blocks that were previously associated with unlinked files but are now linked to active files through stale NFS filehandles.",
        "commit": "The vulnerability involves using block numbers obtained from bulkstat-based inode lookups to optimize mapping calculations. However, since bulkstat data cannot be trusted, the block numbers should be discarded to ensure accurate and reliable lookups and mappings."
    },
    {
        "cwe": "CWE-532",
        "func_name": "torvalds/klsi_105_get_line_state",
        "score": 0.7910482883453369,
        "func_before": "static int klsi_105_get_line_state(struct usb_serial_port *port,\n\t\t\t\t   unsigned long *line_state_p)\n{\n\tint rc;\n\tu8 *status_buf;\n\t__u16 status;\n\n\tdev_info(&port->serial->dev->dev, \"sending SIO Poll request\\n\");\n\n\tstatus_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);\n\tif (!status_buf)\n\t\treturn -ENOMEM;\n\n\tstatus_buf[0] = 0xff;\n\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, /* value */\n\t\t\t     0, /* index */\n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc < 0)\n\t\tdev_err(&port->dev, \"Reading line status failed (error = %d)\\n\",\n\t\t\trc);\n\telse {\n\t\tstatus = get_unaligned_le16(status_buf);\n\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\n\tkfree(status_buf);\n\treturn rc;\n}",
        "func_after": "static int klsi_105_get_line_state(struct usb_serial_port *port,\n\t\t\t\t   unsigned long *line_state_p)\n{\n\tint rc;\n\tu8 *status_buf;\n\t__u16 status;\n\n\tdev_info(&port->serial->dev->dev, \"sending SIO Poll request\\n\");\n\n\tstatus_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);\n\tif (!status_buf)\n\t\treturn -ENOMEM;\n\n\tstatus_buf[0] = 0xff;\n\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, /* value */\n\t\t\t     0, /* index */\n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc != KLSI_STATUSBUF_LEN) {\n\t\tdev_err(&port->dev, \"reading line status failed: %d\\n\", rc);\n\t\tif (rc >= 0)\n\t\t\trc = -EIO;\n\t} else {\n\t\tstatus = get_unaligned_le16(status_buf);\n\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\n\tkfree(status_buf);\n\treturn rc;\n}",
        "description": "The `klsi_105_get_line_state` function in the Linux kernel's USB serial driver, prior to version 4.9.5, includes uninitialized heap memory content in a log entry when failing to read the line status. This flaw enables local users to extract sensitive information by accessing the log.",
        "commit": "The current implementation of the USB serial driver for the KL5KUSB105 device fails to properly detect short data transfers during attempts to read the line state. Additionally, it logs the contents of an uninitialized heap transfer buffer, which could lead to unintended information disclosure."
    },
    {
        "cwe": "CWE-134",
        "func_name": "wireapp/audio_level_json",
        "score": 0.7968961596488953,
        "func_before": "int audio_level_json(struct list *levell,\n\t\t     const char *userid_self, const char *clientid_self,\n\t\t     char **json_str, char **anon_str)\n{\n\tstruct json_object *jobj;\n\tstruct json_object *jarr;\n\tchar uid_anon[ANON_ID_LEN];\n\tchar cid_anon[ANON_CLIENT_LEN];\n\tstruct mbuf *pmb = NULL;\n\tint err = 0;\n\tstruct le *le;\n\n\tif (!levell || !json_str)\n\t\treturn EINVAL;\n\t\n\tjobj = jzon_alloc_object();\n\tif (!jobj)\n\t\treturn ENOMEM;\n\n\tjarr = jzon_alloc_array();\n\tif (!jarr) {\n\t\terr = ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (anon_str) {\n\t\tpmb = mbuf_alloc(512);\n\t\tmbuf_printf(pmb, \"%zu levels: \", list_count(levell));\n\t}\n\t\n\tLIST_FOREACH(levell, le) {\n\t\tstruct audio_level *a = le->data;\n\t\tstruct json_object *ja;\n\t\tconst char *userid = a->userid;\n\t\tconst char *clientid = a->clientid;\n\n\t\tif (a->is_self) {\n\t\t\tif (userid_self)\n\t\t\t\tuserid = userid_self;\n\t\t\tif (clientid_self)\n\t\t\t\tclientid = clientid_self;\n\t\t}\n\n\t\tja = jzon_alloc_object();\n\t\tif (ja) {\n\t\t\tjzon_add_str(ja, \"userid\", userid);\n\t\t\tjzon_add_str(ja, \"clientid\", clientid);\n\t\t\tjzon_add_int(ja, \"audio_level\",\n\t\t\t\t     (int32_t)a->aulevel_smooth);\n\t\t\tjzon_add_int(ja, \"audio_level_now\",\n\t\t\t\t     (int32_t)a->aulevel);\n\t\t}\n\t\tjson_object_array_add(jarr, ja);\n\n\t\t/* add to info string */\n\t\tif (pmb) {\n\t\t\tanon_id(uid_anon, userid);\n\t\t\tanon_client(cid_anon, clientid);\n\t\t\tmbuf_printf(pmb, \"{[%s.%s] audio_level: %d/%d}\",\n\t\t\t\t    uid_anon, cid_anon,\n\t\t\t\t    a->aulevel_smooth, a->aulevel);\n\t\t\tif (le != levell->tail)\n\t\t\t\tmbuf_printf(pmb, \",\");\n\t\t}\t\t\n\t}\n\tjson_object_object_add(jobj, \"audio_levels\", jarr);\n\n\tif (pmb) {\n\t\tpmb->pos = 0;\n\t\tmbuf_strdup(pmb, anon_str, pmb->end);\n\t\tmem_deref(pmb);\n\t}\n\n\tjzon_encode(json_str, jobj);\n out:\t\n\tmem_deref(jobj);\n\n\treturn err;\n}",
        "func_after": "int audio_level_json(struct list *levell,\n\t\t     const char *userid_self, const char *clientid_self,\n\t\t     char **json_str, char **anon_str)\n{\n\tstruct json_object *jobj;\n\tstruct json_object *jarr;\n\tchar uid_anon[ANON_ID_LEN];\n\tchar cid_anon[ANON_CLIENT_LEN];\n\tstruct mbuf *pmb = NULL;\n\tint err = 0;\n\tstruct le *le;\n\n\tif (!levell || !json_str)\n\t\treturn EINVAL;\n\t\n\tjobj = jzon_alloc_object();\n\tif (!jobj)\n\t\treturn ENOMEM;\n\n\tjarr = jzon_alloc_array();\n\tif (!jarr) {\n\t\terr = ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (anon_str) {\n\t\tpmb = mbuf_alloc(512);\n\t\tmbuf_printf(pmb, \"%zu levels: \", list_count(levell));\n\t}\n\t\n\tLIST_FOREACH(levell, le) {\n\t\tstruct audio_level *a = le->data;\n\t\tstruct json_object *ja;\n\t\tconst char *userid = a->userid;\n\t\tconst char *clientid = a->clientid;\n\n\t\tif (a->is_self) {\n\t\t\tif (userid_self)\n\t\t\t\tuserid = userid_self;\n\t\t\tif (clientid_self)\n\t\t\t\tclientid = clientid_self;\n\t\t}\n\n\t\tja = jzon_alloc_object();\n\t\tif (ja) {\n\t\t\tjzon_add_str(ja, \"userid\", \"%s\", userid);\n\t\t\tjzon_add_str(ja, \"clientid\", \"%s\", clientid);\n\t\t\tjzon_add_int(ja, \"audio_level\",\n\t\t\t\t     (int32_t)a->aulevel_smooth);\n\t\t\tjzon_add_int(ja, \"audio_level_now\",\n\t\t\t\t     (int32_t)a->aulevel);\n\t\t}\n\t\tjson_object_array_add(jarr, ja);\n\n\t\t/* add to info string */\n\t\tif (pmb) {\n\t\t\tanon_id(uid_anon, userid);\n\t\t\tanon_client(cid_anon, clientid);\n\t\t\tmbuf_printf(pmb, \"{[%s.%s] audio_level: %d/%d}\",\n\t\t\t\t    uid_anon, cid_anon,\n\t\t\t\t    a->aulevel_smooth, a->aulevel);\n\t\t\tif (le != levell->tail)\n\t\t\t\tmbuf_printf(pmb, \",\");\n\t\t}\t\t\n\t}\n\tjson_object_object_add(jobj, \"audio_levels\", jarr);\n\n\tif (pmb) {\n\t\tpmb->pos = 0;\n\t\tmbuf_strdup(pmb, anon_str, pmb->end);\n\t\tmem_deref(pmb);\n\t}\n\n\tjzon_encode(json_str, jobj);\n out:\t\n\tmem_deref(jobj);\n\n\treturn err;\n}",
        "description": "A remote format string vulnerability in the wire-avs component of Wire, an open-source messenger, affects versions prior to 7.1.12. This vulnerability could lead to a denial of service or the execution of arbitrary code by an attacker. The issue has been addressed in wire-avs version 7.1.12, and there are currently no known workarounds available.",
        "commit": "The process of importing the latest release-7.1 files from an old repository."
    },
    {
        "cwe": "CWE-20",
        "func_name": "torvalds/make_indexed_dir",
        "score": 0.8126417994499207,
        "func_before": "static int make_indexed_dir(handle_t *handle, struct dentry *dentry,\n\t\t\t    struct inode *inode, struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tstruct buffer_head *bh2;\n\tstruct dx_root\t*root;\n\tstruct dx_frame\tframes[2], *frame;\n\tstruct dx_entry *entries;\n\tstruct ext4_dir_entry_2\t*de, *de2;\n\tchar\t\t*data1, *top;\n\tunsigned\tlen;\n\tint\t\tretval;\n\tunsigned\tblocksize;\n\tstruct dx_hash_info hinfo;\n\text4_lblk_t  block;\n\tstruct fake_dirent *fde;\n\n\tblocksize =  dir->i_sb->s_blocksize;\n\tdxtrace(printk(KERN_DEBUG \"Creating index\\n\"));\n\tretval = ext4_journal_get_write_access(handle, bh);\n\tif (retval) {\n\t\text4_std_error(dir->i_sb, retval);\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\n\tbh2 = ext4_append(handle, dir, &block, &retval);\n\tif (!(bh2)) {\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\tEXT4_I(dir)->i_flags |= EXT4_INDEX_FL;\n\tdata1 = bh2->b_data;\n\n\t/* The 0th block becomes the root, move the dirents out */\n\tfde = &root->dotdot;\n\tde = (struct ext4_dir_entry_2 *)((char *)fde +\n\t\text4_rec_len_from_disk(fde->rec_len));\n\tlen = ((char *) root) + blocksize - (char *) de;\n\tmemcpy (data1, de, len);\n\tde = (struct ext4_dir_entry_2 *) data1;\n\ttop = data1 + len;\n\twhile ((char *)(de2 = ext4_next_entry(de)) < top)\n\t\tde = de2;\n\tde->rec_len = ext4_rec_len_to_disk(data1 + blocksize - (char *) de);\n\t/* Initialize the root; the dot dirents already exist */\n\tde = (struct ext4_dir_entry_2 *) (&root->dotdot);\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - EXT4_DIR_REC_LEN(2));\n\tmemset (&root->info, 0, sizeof(root->info));\n\troot->info.info_length = sizeof(root->info);\n\troot->info.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;\n\tentries = root->entries;\n\tdx_set_block(entries, 1);\n\tdx_set_count(entries, 1);\n\tdx_set_limit(entries, dx_root_limit(dir, sizeof(root->info)));\n\n\t/* Initialize as for dx_probe */\n\thinfo.hash_version = root->info.hash_version;\n\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\thinfo.hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo.seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\text4fs_dirhash(name, namelen, &hinfo);\n\tframe = frames;\n\tframe->entries = entries;\n\tframe->at = entries;\n\tframe->bh = bh;\n\tbh = bh2;\n\tde = do_split(handle,dir, &bh, frame, &hinfo, &retval);\n\tdx_release (frames);\n\tif (!(de))\n\t\treturn retval;\n\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}",
        "func_after": "static int make_indexed_dir(handle_t *handle, struct dentry *dentry,\n\t\t\t    struct inode *inode, struct buffer_head *bh)\n{\n\tstruct inode\t*dir = dentry->d_parent->d_inode;\n\tconst char\t*name = dentry->d_name.name;\n\tint\t\tnamelen = dentry->d_name.len;\n\tstruct buffer_head *bh2;\n\tstruct dx_root\t*root;\n\tstruct dx_frame\tframes[2], *frame;\n\tstruct dx_entry *entries;\n\tstruct ext4_dir_entry_2\t*de, *de2;\n\tchar\t\t*data1, *top;\n\tunsigned\tlen;\n\tint\t\tretval;\n\tunsigned\tblocksize;\n\tstruct dx_hash_info hinfo;\n\text4_lblk_t  block;\n\tstruct fake_dirent *fde;\n\n\tblocksize =  dir->i_sb->s_blocksize;\n\tdxtrace(printk(KERN_DEBUG \"Creating index: inode %lu\\n\", dir->i_ino));\n\tretval = ext4_journal_get_write_access(handle, bh);\n\tif (retval) {\n\t\text4_std_error(dir->i_sb, retval);\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\troot = (struct dx_root *) bh->b_data;\n\n\t/* The 0th block becomes the root, move the dirents out */\n\tfde = &root->dotdot;\n\tde = (struct ext4_dir_entry_2 *)((char *)fde +\n\t\text4_rec_len_from_disk(fde->rec_len));\n\tif ((char *) de >= (((char *) root) + blocksize)) {\n\t\text4_error(dir->i_sb, __func__,\n\t\t\t   \"invalid rec_len for '..' in inode %lu\",\n\t\t\t   dir->i_ino);\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\tlen = ((char *) root) + blocksize - (char *) de;\n\n\t/* Allocate new block for the 0th block's dirents */\n\tbh2 = ext4_append(handle, dir, &block, &retval);\n\tif (!(bh2)) {\n\t\tbrelse(bh);\n\t\treturn retval;\n\t}\n\tEXT4_I(dir)->i_flags |= EXT4_INDEX_FL;\n\tdata1 = bh2->b_data;\n\n\tmemcpy (data1, de, len);\n\tde = (struct ext4_dir_entry_2 *) data1;\n\ttop = data1 + len;\n\twhile ((char *)(de2 = ext4_next_entry(de)) < top)\n\t\tde = de2;\n\tde->rec_len = ext4_rec_len_to_disk(data1 + blocksize - (char *) de);\n\t/* Initialize the root; the dot dirents already exist */\n\tde = (struct ext4_dir_entry_2 *) (&root->dotdot);\n\tde->rec_len = ext4_rec_len_to_disk(blocksize - EXT4_DIR_REC_LEN(2));\n\tmemset (&root->info, 0, sizeof(root->info));\n\troot->info.info_length = sizeof(root->info);\n\troot->info.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;\n\tentries = root->entries;\n\tdx_set_block(entries, 1);\n\tdx_set_count(entries, 1);\n\tdx_set_limit(entries, dx_root_limit(dir, sizeof(root->info)));\n\n\t/* Initialize as for dx_probe */\n\thinfo.hash_version = root->info.hash_version;\n\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\thinfo.hash_version += EXT4_SB(dir->i_sb)->s_hash_unsigned;\n\thinfo.seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\text4fs_dirhash(name, namelen, &hinfo);\n\tframe = frames;\n\tframe->entries = entries;\n\tframe->at = entries;\n\tframe->bh = bh;\n\tbh = bh2;\n\tde = do_split(handle,dir, &bh, frame, &hinfo, &retval);\n\tdx_release (frames);\n\tif (!(de))\n\t\treturn retval;\n\n\treturn add_dirent_to_buf(handle, dentry, inode, de, bh);\n}",
        "description": "The `make_indexed_dir` function in the ext4 filesystem module of the Linux kernel, prior to versions 2.6.27.19 and 2.6.28.7, lacks validation for a specific `rec_len` field. This oversight enables local users to trigger a denial of service (OOPS) condition by mounting a specially crafted ext4 filesystem.",
        "commit": "It was discovered that a failure to validate the `rec_len` field in the '.' entry within a directory structure could lead to overrunning the directory block, resulting in a kernel panic on a deliberately corrupted filesystem."
    }
]