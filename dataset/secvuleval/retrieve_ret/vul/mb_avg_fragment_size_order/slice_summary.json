[
    {
        "cwe": "CWE-770",
        "func_name": "binutils-gdb/_bfd_elf_slurp_version_tables",
        "score": 0.7618343830108643,
        "func_before": "bfd_boolean\n_bfd_elf_slurp_version_tables (bfd *abfd, bfd_boolean default_imported_symver)\n{\n  bfd_byte *contents = NULL;\n  unsigned int freeidx = 0;\n\n  if (elf_dynverref (abfd) != 0)\n    {\n      Elf_Internal_Shdr *hdr;\n      Elf_External_Verneed *everneed;\n      Elf_Internal_Verneed *iverneed;\n      unsigned int i;\n      bfd_byte *contents_end;\n\n      hdr = &elf_tdata (abfd)->dynverref_hdr;\n\n      if (hdr->sh_info == 0 || hdr->sh_size < sizeof (Elf_External_Verneed))\n\t{\nerror_return_bad_verref:\n\t  _bfd_error_handler\n\t    (_(\"%B: .gnu.version_r invalid entry\"), abfd);\n\t  bfd_set_error (bfd_error_bad_value);\nerror_return_verref:\n\t  elf_tdata (abfd)->verref = NULL;\n\t  elf_tdata (abfd)->cverrefs = 0;\n\t  goto error_return;\n\t}\n\n      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);\n      if (contents == NULL)\n\tgoto error_return_verref;\n\n      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n\t  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)\n\tgoto error_return_verref;\n\n      elf_tdata (abfd)->verref = (Elf_Internal_Verneed *)\n\tbfd_zalloc2 (abfd, hdr->sh_info, sizeof (Elf_Internal_Verneed));\n\n      if (elf_tdata (abfd)->verref == NULL)\n\tgoto error_return_verref;\n\n      BFD_ASSERT (sizeof (Elf_External_Verneed)\n\t\t  == sizeof (Elf_External_Vernaux));\n      contents_end = contents + hdr->sh_size - sizeof (Elf_External_Verneed);\n      everneed = (Elf_External_Verneed *) contents;\n      iverneed = elf_tdata (abfd)->verref;\n      for (i = 0; i < hdr->sh_info; i++, iverneed++)\n\t{\n\t  Elf_External_Vernaux *evernaux;\n\t  Elf_Internal_Vernaux *ivernaux;\n\t  unsigned int j;\n\n\t  _bfd_elf_swap_verneed_in (abfd, everneed, iverneed);\n\n\t  iverneed->vn_bfd = abfd;\n\n\t  iverneed->vn_filename =\n\t    bfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t     iverneed->vn_file);\n\t  if (iverneed->vn_filename == NULL)\n\t    goto error_return_bad_verref;\n\n\t  if (iverneed->vn_cnt == 0)\n\t    iverneed->vn_auxptr = NULL;\n\t  else\n\t    {\n\t      iverneed->vn_auxptr = (struct elf_internal_vernaux *)\n                  bfd_alloc2 (abfd, iverneed->vn_cnt,\n                              sizeof (Elf_Internal_Vernaux));\n\t      if (iverneed->vn_auxptr == NULL)\n\t\tgoto error_return_verref;\n\t    }\n\n\t  if (iverneed->vn_aux\n\t      > (size_t) (contents_end - (bfd_byte *) everneed))\n\t    goto error_return_bad_verref;\n\n\t  evernaux = ((Elf_External_Vernaux *)\n\t\t      ((bfd_byte *) everneed + iverneed->vn_aux));\n\t  ivernaux = iverneed->vn_auxptr;\n\t  for (j = 0; j < iverneed->vn_cnt; j++, ivernaux++)\n\t    {\n\t      _bfd_elf_swap_vernaux_in (abfd, evernaux, ivernaux);\n\n\t      ivernaux->vna_nodename =\n\t\tbfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t\t ivernaux->vna_name);\n\t      if (ivernaux->vna_nodename == NULL)\n\t\tgoto error_return_bad_verref;\n\n\t      if (ivernaux->vna_other > freeidx)\n\t\tfreeidx = ivernaux->vna_other;\n\n\t      ivernaux->vna_nextptr = NULL;\n\t      if (ivernaux->vna_next == 0)\n\t\t{\n\t\t  iverneed->vn_cnt = j + 1;\n\t\t  break;\n\t\t}\n\t      if (j + 1 < iverneed->vn_cnt)\n\t\tivernaux->vna_nextptr = ivernaux + 1;\n\n\t      if (ivernaux->vna_next\n\t\t  > (size_t) (contents_end - (bfd_byte *) evernaux))\n\t\tgoto error_return_bad_verref;\n\n\t      evernaux = ((Elf_External_Vernaux *)\n\t\t\t  ((bfd_byte *) evernaux + ivernaux->vna_next));\n\t    }\n\n\t  iverneed->vn_nextref = NULL;\n\t  if (iverneed->vn_next == 0)\n\t    break;\n\t  if (i + 1 < hdr->sh_info)\n\t    iverneed->vn_nextref = iverneed + 1;\n\n\t  if (iverneed->vn_next\n\t      > (size_t) (contents_end - (bfd_byte *) everneed))\n\t    goto error_return_bad_verref;\n\n\t  everneed = ((Elf_External_Verneed *)\n\t\t      ((bfd_byte *) everneed + iverneed->vn_next));\n\t}\n      elf_tdata (abfd)->cverrefs = i;\n\n      free (contents);\n      contents = NULL;\n    }\n\n  if (elf_dynverdef (abfd) != 0)\n    {\n      Elf_Internal_Shdr *hdr;\n      Elf_External_Verdef *everdef;\n      Elf_Internal_Verdef *iverdef;\n      Elf_Internal_Verdef *iverdefarr;\n      Elf_Internal_Verdef iverdefmem;\n      unsigned int i;\n      unsigned int maxidx;\n      bfd_byte *contents_end_def, *contents_end_aux;\n\n      hdr = &elf_tdata (abfd)->dynverdef_hdr;\n\n      if (hdr->sh_info == 0 || hdr->sh_size < sizeof (Elf_External_Verdef))\n\t{\n\terror_return_bad_verdef:\n\t  _bfd_error_handler\n\t    (_(\"%B: .gnu.version_d invalid entry\"), abfd);\n\t  bfd_set_error (bfd_error_bad_value);\n\terror_return_verdef:\n\t  elf_tdata (abfd)->verdef = NULL;\n\t  elf_tdata (abfd)->cverdefs = 0;\n\t  goto error_return;\n\t}\n\n      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);\n      if (contents == NULL)\n\tgoto error_return_verdef;\n      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n\t  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)\n\tgoto error_return_verdef;\n\n      BFD_ASSERT (sizeof (Elf_External_Verdef)\n\t\t  >= sizeof (Elf_External_Verdaux));\n      contents_end_def = contents + hdr->sh_size\n\t\t\t - sizeof (Elf_External_Verdef);\n      contents_end_aux = contents + hdr->sh_size\n\t\t\t - sizeof (Elf_External_Verdaux);\n\n      /* We know the number of entries in the section but not the maximum\n\t index.  Therefore we have to run through all entries and find\n\t the maximum.  */\n      everdef = (Elf_External_Verdef *) contents;\n      maxidx = 0;\n      for (i = 0; i < hdr->sh_info; ++i)\n\t{\n\t  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);\n\n\t  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) == 0)\n\t    goto error_return_bad_verdef;\n\t  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) > maxidx)\n\t    maxidx = iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION);\n\n\t  if (iverdefmem.vd_next == 0)\n\t    break;\n\n\t  if (iverdefmem.vd_next\n\t      > (size_t) (contents_end_def - (bfd_byte *) everdef))\n\t    goto error_return_bad_verdef;\n\n\t  everdef = ((Elf_External_Verdef *)\n\t\t     ((bfd_byte *) everdef + iverdefmem.vd_next));\n\t}\n\n      if (default_imported_symver)\n\t{\n\t  if (freeidx > maxidx)\n\t    maxidx = ++freeidx;\n\t  else\n\t    freeidx = ++maxidx;\n\t}\n\n      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n\tbfd_zalloc2 (abfd, maxidx, sizeof (Elf_Internal_Verdef));\n      if (elf_tdata (abfd)->verdef == NULL)\n\tgoto error_return_verdef;\n\n      elf_tdata (abfd)->cverdefs = maxidx;\n\n      everdef = (Elf_External_Verdef *) contents;\n      iverdefarr = elf_tdata (abfd)->verdef;\n      for (i = 0; i < hdr->sh_info; i++)\n\t{\n\t  Elf_External_Verdaux *everdaux;\n\t  Elf_Internal_Verdaux *iverdaux;\n\t  unsigned int j;\n\n\t  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);\n\n\t  if ((iverdefmem.vd_ndx & VERSYM_VERSION) == 0)\n\t    goto error_return_bad_verdef;\n\n\t  iverdef = &iverdefarr[(iverdefmem.vd_ndx & VERSYM_VERSION) - 1];\n\t  memcpy (iverdef, &iverdefmem, offsetof (Elf_Internal_Verdef, vd_bfd));\n\n\t  iverdef->vd_bfd = abfd;\n\n\t  if (iverdef->vd_cnt == 0)\n\t    iverdef->vd_auxptr = NULL;\n\t  else\n\t    {\n\t      iverdef->vd_auxptr = (struct elf_internal_verdaux *)\n                  bfd_alloc2 (abfd, iverdef->vd_cnt,\n                              sizeof (Elf_Internal_Verdaux));\n\t      if (iverdef->vd_auxptr == NULL)\n\t\tgoto error_return_verdef;\n\t    }\n\n\t  if (iverdef->vd_aux\n\t      > (size_t) (contents_end_aux - (bfd_byte *) everdef))\n\t    goto error_return_bad_verdef;\n\n\t  everdaux = ((Elf_External_Verdaux *)\n\t\t      ((bfd_byte *) everdef + iverdef->vd_aux));\n\t  iverdaux = iverdef->vd_auxptr;\n\t  for (j = 0; j < iverdef->vd_cnt; j++, iverdaux++)\n\t    {\n\t      _bfd_elf_swap_verdaux_in (abfd, everdaux, iverdaux);\n\n\t      iverdaux->vda_nodename =\n\t\tbfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t\t iverdaux->vda_name);\n\t      if (iverdaux->vda_nodename == NULL)\n\t\tgoto error_return_bad_verdef;\n\n\t      iverdaux->vda_nextptr = NULL;\n\t      if (iverdaux->vda_next == 0)\n\t\t{\n\t\t  iverdef->vd_cnt = j + 1;\n\t\t  break;\n\t\t}\n\t      if (j + 1 < iverdef->vd_cnt)\n\t\tiverdaux->vda_nextptr = iverdaux + 1;\n\n\t      if (iverdaux->vda_next\n\t\t  > (size_t) (contents_end_aux - (bfd_byte *) everdaux))\n\t\tgoto error_return_bad_verdef;\n\n\t      everdaux = ((Elf_External_Verdaux *)\n\t\t\t  ((bfd_byte *) everdaux + iverdaux->vda_next));\n\t    }\n\n\t  iverdef->vd_nodename = NULL;\n\t  if (iverdef->vd_cnt)\n\t    iverdef->vd_nodename = iverdef->vd_auxptr->vda_nodename;\n\n\t  iverdef->vd_nextdef = NULL;\n\t  if (iverdef->vd_next == 0)\n\t    break;\n\t  if ((size_t) (iverdef - iverdefarr) + 1 < maxidx)\n\t    iverdef->vd_nextdef = iverdef + 1;\n\n\t  everdef = ((Elf_External_Verdef *)\n\t\t     ((bfd_byte *) everdef + iverdef->vd_next));\n\t}\n\n      free (contents);\n      contents = NULL;\n    }\n  else if (default_imported_symver)\n    {\n      if (freeidx < 3)\n\tfreeidx = 3;\n      else\n\tfreeidx++;\n\n      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n          bfd_zalloc2 (abfd, freeidx, sizeof (Elf_Internal_Verdef));\n      if (elf_tdata (abfd)->verdef == NULL)\n\tgoto error_return;\n\n      elf_tdata (abfd)->cverdefs = freeidx;\n    }\n\n  /* Create a default version based on the soname.  */\n  if (default_imported_symver)\n    {\n      Elf_Internal_Verdef *iverdef;\n      Elf_Internal_Verdaux *iverdaux;\n\n      iverdef = &elf_tdata (abfd)->verdef[freeidx - 1];\n\n      iverdef->vd_version = VER_DEF_CURRENT;\n      iverdef->vd_flags = 0;\n      iverdef->vd_ndx = freeidx;\n      iverdef->vd_cnt = 1;\n\n      iverdef->vd_bfd = abfd;\n\n      iverdef->vd_nodename = bfd_elf_get_dt_soname (abfd);\n      if (iverdef->vd_nodename == NULL)\n\tgoto error_return_verdef;\n      iverdef->vd_nextdef = NULL;\n      iverdef->vd_auxptr = ((struct elf_internal_verdaux *)\n\t\t\t    bfd_zalloc (abfd, sizeof (Elf_Internal_Verdaux)));\n      if (iverdef->vd_auxptr == NULL)\n\tgoto error_return_verdef;\n\n      iverdaux = iverdef->vd_auxptr;\n      iverdaux->vda_nodename = iverdef->vd_nodename;\n    }\n\n  return TRUE;\n\n error_return:\n  if (contents != NULL)\n    free (contents);\n  return FALSE;\n}",
        "func_after": "bfd_boolean\n_bfd_elf_slurp_version_tables (bfd *abfd, bfd_boolean default_imported_symver)\n{\n  bfd_byte *contents = NULL;\n  unsigned int freeidx = 0;\n\n  if (elf_dynverref (abfd) != 0)\n    {\n      Elf_Internal_Shdr *hdr;\n      Elf_External_Verneed *everneed;\n      Elf_Internal_Verneed *iverneed;\n      unsigned int i;\n      bfd_byte *contents_end;\n\n      hdr = &elf_tdata (abfd)->dynverref_hdr;\n\n      if (hdr->sh_info == 0\n\t  || hdr->sh_info > hdr->sh_size / sizeof (Elf_External_Verneed))\n\t{\nerror_return_bad_verref:\n\t  _bfd_error_handler\n\t    (_(\"%B: .gnu.version_r invalid entry\"), abfd);\n\t  bfd_set_error (bfd_error_bad_value);\nerror_return_verref:\n\t  elf_tdata (abfd)->verref = NULL;\n\t  elf_tdata (abfd)->cverrefs = 0;\n\t  goto error_return;\n\t}\n\n      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);\n      if (contents == NULL)\n\tgoto error_return_verref;\n\n      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n\t  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)\n\tgoto error_return_verref;\n\n      elf_tdata (abfd)->verref = (Elf_Internal_Verneed *)\n\tbfd_alloc2 (abfd, hdr->sh_info, sizeof (Elf_Internal_Verneed));\n\n      if (elf_tdata (abfd)->verref == NULL)\n\tgoto error_return_verref;\n\n      BFD_ASSERT (sizeof (Elf_External_Verneed)\n\t\t  == sizeof (Elf_External_Vernaux));\n      contents_end = contents + hdr->sh_size - sizeof (Elf_External_Verneed);\n      everneed = (Elf_External_Verneed *) contents;\n      iverneed = elf_tdata (abfd)->verref;\n      for (i = 0; i < hdr->sh_info; i++, iverneed++)\n\t{\n\t  Elf_External_Vernaux *evernaux;\n\t  Elf_Internal_Vernaux *ivernaux;\n\t  unsigned int j;\n\n\t  _bfd_elf_swap_verneed_in (abfd, everneed, iverneed);\n\n\t  iverneed->vn_bfd = abfd;\n\n\t  iverneed->vn_filename =\n\t    bfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t     iverneed->vn_file);\n\t  if (iverneed->vn_filename == NULL)\n\t    goto error_return_bad_verref;\n\n\t  if (iverneed->vn_cnt == 0)\n\t    iverneed->vn_auxptr = NULL;\n\t  else\n\t    {\n\t      iverneed->vn_auxptr = (struct elf_internal_vernaux *)\n                  bfd_alloc2 (abfd, iverneed->vn_cnt,\n                              sizeof (Elf_Internal_Vernaux));\n\t      if (iverneed->vn_auxptr == NULL)\n\t\tgoto error_return_verref;\n\t    }\n\n\t  if (iverneed->vn_aux\n\t      > (size_t) (contents_end - (bfd_byte *) everneed))\n\t    goto error_return_bad_verref;\n\n\t  evernaux = ((Elf_External_Vernaux *)\n\t\t      ((bfd_byte *) everneed + iverneed->vn_aux));\n\t  ivernaux = iverneed->vn_auxptr;\n\t  for (j = 0; j < iverneed->vn_cnt; j++, ivernaux++)\n\t    {\n\t      _bfd_elf_swap_vernaux_in (abfd, evernaux, ivernaux);\n\n\t      ivernaux->vna_nodename =\n\t\tbfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t\t ivernaux->vna_name);\n\t      if (ivernaux->vna_nodename == NULL)\n\t\tgoto error_return_bad_verref;\n\n\t      if (ivernaux->vna_other > freeidx)\n\t\tfreeidx = ivernaux->vna_other;\n\n\t      ivernaux->vna_nextptr = NULL;\n\t      if (ivernaux->vna_next == 0)\n\t\t{\n\t\t  iverneed->vn_cnt = j + 1;\n\t\t  break;\n\t\t}\n\t      if (j + 1 < iverneed->vn_cnt)\n\t\tivernaux->vna_nextptr = ivernaux + 1;\n\n\t      if (ivernaux->vna_next\n\t\t  > (size_t) (contents_end - (bfd_byte *) evernaux))\n\t\tgoto error_return_bad_verref;\n\n\t      evernaux = ((Elf_External_Vernaux *)\n\t\t\t  ((bfd_byte *) evernaux + ivernaux->vna_next));\n\t    }\n\n\t  iverneed->vn_nextref = NULL;\n\t  if (iverneed->vn_next == 0)\n\t    break;\n\t  if (i + 1 < hdr->sh_info)\n\t    iverneed->vn_nextref = iverneed + 1;\n\n\t  if (iverneed->vn_next\n\t      > (size_t) (contents_end - (bfd_byte *) everneed))\n\t    goto error_return_bad_verref;\n\n\t  everneed = ((Elf_External_Verneed *)\n\t\t      ((bfd_byte *) everneed + iverneed->vn_next));\n\t}\n      elf_tdata (abfd)->cverrefs = i;\n\n      free (contents);\n      contents = NULL;\n    }\n\n  if (elf_dynverdef (abfd) != 0)\n    {\n      Elf_Internal_Shdr *hdr;\n      Elf_External_Verdef *everdef;\n      Elf_Internal_Verdef *iverdef;\n      Elf_Internal_Verdef *iverdefarr;\n      Elf_Internal_Verdef iverdefmem;\n      unsigned int i;\n      unsigned int maxidx;\n      bfd_byte *contents_end_def, *contents_end_aux;\n\n      hdr = &elf_tdata (abfd)->dynverdef_hdr;\n\n      if (hdr->sh_info == 0 || hdr->sh_size < sizeof (Elf_External_Verdef))\n\t{\n\terror_return_bad_verdef:\n\t  _bfd_error_handler\n\t    (_(\"%B: .gnu.version_d invalid entry\"), abfd);\n\t  bfd_set_error (bfd_error_bad_value);\n\terror_return_verdef:\n\t  elf_tdata (abfd)->verdef = NULL;\n\t  elf_tdata (abfd)->cverdefs = 0;\n\t  goto error_return;\n\t}\n\n      contents = (bfd_byte *) bfd_malloc (hdr->sh_size);\n      if (contents == NULL)\n\tgoto error_return_verdef;\n      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n\t  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)\n\tgoto error_return_verdef;\n\n      BFD_ASSERT (sizeof (Elf_External_Verdef)\n\t\t  >= sizeof (Elf_External_Verdaux));\n      contents_end_def = contents + hdr->sh_size\n\t\t\t - sizeof (Elf_External_Verdef);\n      contents_end_aux = contents + hdr->sh_size\n\t\t\t - sizeof (Elf_External_Verdaux);\n\n      /* We know the number of entries in the section but not the maximum\n\t index.  Therefore we have to run through all entries and find\n\t the maximum.  */\n      everdef = (Elf_External_Verdef *) contents;\n      maxidx = 0;\n      for (i = 0; i < hdr->sh_info; ++i)\n\t{\n\t  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);\n\n\t  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) == 0)\n\t    goto error_return_bad_verdef;\n\t  if ((iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION)) > maxidx)\n\t    maxidx = iverdefmem.vd_ndx & ((unsigned) VERSYM_VERSION);\n\n\t  if (iverdefmem.vd_next == 0)\n\t    break;\n\n\t  if (iverdefmem.vd_next\n\t      > (size_t) (contents_end_def - (bfd_byte *) everdef))\n\t    goto error_return_bad_verdef;\n\n\t  everdef = ((Elf_External_Verdef *)\n\t\t     ((bfd_byte *) everdef + iverdefmem.vd_next));\n\t}\n\n      if (default_imported_symver)\n\t{\n\t  if (freeidx > maxidx)\n\t    maxidx = ++freeidx;\n\t  else\n\t    freeidx = ++maxidx;\n\t}\n\n      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n\tbfd_zalloc2 (abfd, maxidx, sizeof (Elf_Internal_Verdef));\n      if (elf_tdata (abfd)->verdef == NULL)\n\tgoto error_return_verdef;\n\n      elf_tdata (abfd)->cverdefs = maxidx;\n\n      everdef = (Elf_External_Verdef *) contents;\n      iverdefarr = elf_tdata (abfd)->verdef;\n      for (i = 0; i < hdr->sh_info; i++)\n\t{\n\t  Elf_External_Verdaux *everdaux;\n\t  Elf_Internal_Verdaux *iverdaux;\n\t  unsigned int j;\n\n\t  _bfd_elf_swap_verdef_in (abfd, everdef, &iverdefmem);\n\n\t  if ((iverdefmem.vd_ndx & VERSYM_VERSION) == 0)\n\t    goto error_return_bad_verdef;\n\n\t  iverdef = &iverdefarr[(iverdefmem.vd_ndx & VERSYM_VERSION) - 1];\n\t  memcpy (iverdef, &iverdefmem, offsetof (Elf_Internal_Verdef, vd_bfd));\n\n\t  iverdef->vd_bfd = abfd;\n\n\t  if (iverdef->vd_cnt == 0)\n\t    iverdef->vd_auxptr = NULL;\n\t  else\n\t    {\n\t      iverdef->vd_auxptr = (struct elf_internal_verdaux *)\n                  bfd_alloc2 (abfd, iverdef->vd_cnt,\n                              sizeof (Elf_Internal_Verdaux));\n\t      if (iverdef->vd_auxptr == NULL)\n\t\tgoto error_return_verdef;\n\t    }\n\n\t  if (iverdef->vd_aux\n\t      > (size_t) (contents_end_aux - (bfd_byte *) everdef))\n\t    goto error_return_bad_verdef;\n\n\t  everdaux = ((Elf_External_Verdaux *)\n\t\t      ((bfd_byte *) everdef + iverdef->vd_aux));\n\t  iverdaux = iverdef->vd_auxptr;\n\t  for (j = 0; j < iverdef->vd_cnt; j++, iverdaux++)\n\t    {\n\t      _bfd_elf_swap_verdaux_in (abfd, everdaux, iverdaux);\n\n\t      iverdaux->vda_nodename =\n\t\tbfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t\t iverdaux->vda_name);\n\t      if (iverdaux->vda_nodename == NULL)\n\t\tgoto error_return_bad_verdef;\n\n\t      iverdaux->vda_nextptr = NULL;\n\t      if (iverdaux->vda_next == 0)\n\t\t{\n\t\t  iverdef->vd_cnt = j + 1;\n\t\t  break;\n\t\t}\n\t      if (j + 1 < iverdef->vd_cnt)\n\t\tiverdaux->vda_nextptr = iverdaux + 1;\n\n\t      if (iverdaux->vda_next\n\t\t  > (size_t) (contents_end_aux - (bfd_byte *) everdaux))\n\t\tgoto error_return_bad_verdef;\n\n\t      everdaux = ((Elf_External_Verdaux *)\n\t\t\t  ((bfd_byte *) everdaux + iverdaux->vda_next));\n\t    }\n\n\t  iverdef->vd_nodename = NULL;\n\t  if (iverdef->vd_cnt)\n\t    iverdef->vd_nodename = iverdef->vd_auxptr->vda_nodename;\n\n\t  iverdef->vd_nextdef = NULL;\n\t  if (iverdef->vd_next == 0)\n\t    break;\n\t  if ((size_t) (iverdef - iverdefarr) + 1 < maxidx)\n\t    iverdef->vd_nextdef = iverdef + 1;\n\n\t  everdef = ((Elf_External_Verdef *)\n\t\t     ((bfd_byte *) everdef + iverdef->vd_next));\n\t}\n\n      free (contents);\n      contents = NULL;\n    }\n  else if (default_imported_symver)\n    {\n      if (freeidx < 3)\n\tfreeidx = 3;\n      else\n\tfreeidx++;\n\n      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n          bfd_zalloc2 (abfd, freeidx, sizeof (Elf_Internal_Verdef));\n      if (elf_tdata (abfd)->verdef == NULL)\n\tgoto error_return;\n\n      elf_tdata (abfd)->cverdefs = freeidx;\n    }\n\n  /* Create a default version based on the soname.  */\n  if (default_imported_symver)\n    {\n      Elf_Internal_Verdef *iverdef;\n      Elf_Internal_Verdaux *iverdaux;\n\n      iverdef = &elf_tdata (abfd)->verdef[freeidx - 1];\n\n      iverdef->vd_version = VER_DEF_CURRENT;\n      iverdef->vd_flags = 0;\n      iverdef->vd_ndx = freeidx;\n      iverdef->vd_cnt = 1;\n\n      iverdef->vd_bfd = abfd;\n\n      iverdef->vd_nodename = bfd_elf_get_dt_soname (abfd);\n      if (iverdef->vd_nodename == NULL)\n\tgoto error_return_verdef;\n      iverdef->vd_nextdef = NULL;\n      iverdef->vd_auxptr = ((struct elf_internal_verdaux *)\n\t\t\t    bfd_zalloc (abfd, sizeof (Elf_Internal_Verdaux)));\n      if (iverdef->vd_auxptr == NULL)\n\tgoto error_return_verdef;\n\n      iverdaux = iverdef->vd_auxptr;\n      iverdaux->vda_nodename = iverdef->vd_nodename;\n    }\n\n  return TRUE;\n\n error_return:\n  if (contents != NULL)\n    free (contents);\n  return FALSE;\n}",
        "description": "The _bfd_elf_slurp_version_tables function in the BFD library, part of GNU Binutils 2.29, is susceptible to a denial of service attack. This vulnerability arises from excessive memory allocation when processing a specially crafted ELF file, leading to potential application crashes.",
        "commit": "The vulnerability involves a memory allocation issue within the ELF (Executable and Linkable Format) handling module of a binary file format library. Specifically, the code performs a sanity check on the size of the `SHT_GNU_verneed` section, ensuring it meets certain minimum requirements related to the number of version entries (`sh_info`). Additionally, since the code either fully initializes all fields of the version entries or exits with an error, there is no need to zero-initialize the allocated memory for these entries. The fix includes modifying the `_bfd_elf_slurp_version_tables` function to test the `sh_info` field of the `SHT_GNU_verneed` section for validity and to avoid zero-initializing the memory allocated for version references."
    },
    {
        "cwe": "CWE-122",
        "func_name": "vim/find_help_tags",
        "score": 0.7600330114364624,
        "func_before": "int\nfind_help_tags(\n    char_u\t*arg,\n    int\t\t*num_matches,\n    char_u\t***matches,\n    int\t\tkeep_lang)\n{\n    char_u\t*s, *d;\n    int\t\ti;\n    // Specific tags that either have a specific replacement or won't go\n    // through the generic rules.\n    static char *(except_tbl[][2]) = {\n\t{\"*\",\t\t\"star\"},\n\t{\"g*\",\t\t\"gstar\"},\n\t{\"[*\",\t\t\"[star\"},\n\t{\"]*\",\t\t\"]star\"},\n\t{\":*\",\t\t\":star\"},\n\t{\"/*\",\t\t\"/star\"},\n\t{\"/\\\\*\",\t\"/\\\\\\\\star\"},\n\t{\"\\\"*\",\t\t\"quotestar\"},\n\t{\"**\",\t\t\"starstar\"},\n\t{\"cpo-*\",\t\"cpo-star\"},\n\t{\"/\\\\(\\\\)\",\t\"/\\\\\\\\(\\\\\\\\)\"},\n\t{\"/\\\\%(\\\\)\",\t\"/\\\\\\\\%(\\\\\\\\)\"},\n\t{\"?\",\t\t\"?\"},\n\t{\"??\",\t\t\"??\"},\n\t{\":?\",\t\t\":?\"},\n\t{\"?<CR>\",\t\"?<CR>\"},\n\t{\"g?\",\t\t\"g?\"},\n\t{\"g?g?\",\t\"g?g?\"},\n\t{\"g??\",\t\t\"g??\"},\n\t{\"-?\",\t\t\"-?\"},\n\t{\"q?\",\t\t\"q?\"},\n\t{\"v_g?\",\t\"v_g?\"},\n\t{\"/\\\\?\",\t\"/\\\\\\\\?\"},\n\t{\"/\\\\z(\\\\)\",\t\"/\\\\\\\\z(\\\\\\\\)\"},\n\t{\"\\\\=\",\t\t\"\\\\\\\\=\"},\n\t{\":s\\\\=\",\t\":s\\\\\\\\=\"},\n\t{\"[count]\",\t\"\\\\[count]\"},\n\t{\"[quotex]\",\t\"\\\\[quotex]\"},\n\t{\"[range]\",\t\"\\\\[range]\"},\n\t{\":[range]\",\t\":\\\\[range]\"},\n\t{\"[pattern]\",\t\"\\\\[pattern]\"},\n\t{\"\\\\|\",\t\t\"\\\\\\\\bar\"},\n\t{\"\\\\%$\",\t\"/\\\\\\\\%\\\\$\"},\n\t{\"s/\\\\~\",\t\"s/\\\\\\\\\\\\~\"},\n\t{\"s/\\\\U\",\t\"s/\\\\\\\\U\"},\n\t{\"s/\\\\L\",\t\"s/\\\\\\\\L\"},\n\t{\"s/\\\\1\",\t\"s/\\\\\\\\1\"},\n\t{\"s/\\\\2\",\t\"s/\\\\\\\\2\"},\n\t{\"s/\\\\3\",\t\"s/\\\\\\\\3\"},\n\t{\"s/\\\\9\",\t\"s/\\\\\\\\9\"},\n\t{NULL, NULL}\n    };\n    static char *(expr_table[]) = {\"!=?\", \"!~?\", \"<=?\", \"<?\", \"==?\", \"=~?\",\n\t\t\t\t   \">=?\", \">?\", \"is?\", \"isnot?\"};\n    int flags;\n\n    d = IObuff;\t\t    // assume IObuff is long enough!\n    d[0] = NUL;\n\n    if (STRNICMP(arg, \"expr-\", 5) == 0)\n    {\n\t// When the string starting with \"expr-\" and containing '?' and matches\n\t// the table, it is taken literally (but ~ is escaped).  Otherwise '?'\n\t// is recognized as a wildcard.\n\tfor (i = (int)ARRAY_LENGTH(expr_table); --i >= 0; )\n\t    if (STRCMP(arg + 5, expr_table[i]) == 0)\n\t    {\n\t\tint si = 0, di = 0;\n\n\t\tfor (;;)\n\t\t{\n\t\t    if (arg[si] == '~')\n\t\t\td[di++] = '\\\\';\n\t\t    d[di++] = arg[si];\n\t\t    if (arg[si] == NUL)\n\t\t\tbreak;\n\t\t    ++si;\n\t\t}\n\t\tbreak;\n\t    }\n    }\n    else\n    {\n\t// Recognize a few exceptions to the rule.  Some strings that contain\n\t// '*'are changed to \"star\", otherwise '*' is recognized as a wildcard.\n\tfor (i = 0; except_tbl[i][0] != NULL; ++i)\n\t    if (STRCMP(arg, except_tbl[i][0]) == 0)\n\t    {\n\t\tSTRCPY(d, except_tbl[i][1]);\n\t\tbreak;\n\t    }\n    }\n\n    if (d[0] == NUL)\t// no match in table\n    {\n\t// Replace \"\\S\" with \"/\\\\S\", etc.  Otherwise every tag is matched.\n\t// Also replace \"\\%^\" and \"\\%(\", they match every tag too.\n\t// Also \"\\zs\", \"\\z1\", etc.\n\t// Also \"\\@<\", \"\\@=\", \"\\@<=\", etc.\n\t// And also \"\\_$\" and \"\\_^\".\n\tif (arg[0] == '\\\\'\n\t\t&& ((arg[1] != NUL && arg[2] == NUL)\n\t\t    || (vim_strchr((char_u *)\"%_z@\", arg[1]) != NULL\n\t\t\t\t\t\t\t   && arg[2] != NUL)))\n\t{\n\t    STRCPY(d, \"/\\\\\\\\\");\n\t    STRCPY(d + 3, arg + 1);\n\t    // Check for \"/\\\\_$\", should be \"/\\\\_\\$\"\n\t    if (d[3] == '_' && d[4] == '$')\n\t\tSTRCPY(d + 4, \"\\\\$\");\n\t}\n\telse\n\t{\n\t  // Replace:\n\t  // \"[:...:]\" with \"\\[:...:]\"\n\t  // \"[++...]\" with \"\\[++...]\"\n\t  // \"\\{\" with \"\\\\{\"\t\t   -- matching \"} \\}\"\n\t    if ((arg[0] == '[' && (arg[1] == ':'\n\t\t\t || (arg[1] == '+' && arg[2] == '+')))\n\t\t    || (arg[0] == '\\\\' && arg[1] == '{'))\n\t      *d++ = '\\\\';\n\n\t  // If tag starts with \"('\", skip the \"(\". Fixes CTRL-] on ('option'.\n\t  if (*arg == '(' && arg[1] == '\\'')\n\t      arg++;\n\t  for (s = arg; *s; ++s)\n\t  {\n\t    // Replace \"|\" with \"bar\" and '\"' with \"quote\" to match the name of\n\t    // the tags for these commands.\n\t    // Replace \"*\" with \".*\" and \"?\" with \".\" to match command line\n\t    // completion.\n\t    // Insert a backslash before '~', '$' and '.' to avoid their\n\t    // special meaning.\n\t    if (d - IObuff > IOSIZE - 10)\t// getting too long!?\n\t\tbreak;\n\t    switch (*s)\n\t    {\n\t\tcase '|':   STRCPY(d, \"bar\");\n\t\t\t    d += 3;\n\t\t\t    continue;\n\t\tcase '\"':   STRCPY(d, \"quote\");\n\t\t\t    d += 5;\n\t\t\t    continue;\n\t\tcase '*':   *d++ = '.';\n\t\t\t    break;\n\t\tcase '?':   *d++ = '.';\n\t\t\t    continue;\n\t\tcase '$':\n\t\tcase '.':\n\t\tcase '~':   *d++ = '\\\\';\n\t\t\t    break;\n\t    }\n\n\t    // Replace \"^x\" by \"CTRL-X\". Don't do this for \"^_\" to make\n\t    // \":help i_^_CTRL-D\" work.\n\t    // Insert '-' before and after \"CTRL-X\" when applicable.\n\t    if (*s < ' ' || (*s == '^' && s[1] && (ASCII_ISALPHA(s[1])\n\t\t\t   || vim_strchr((char_u *)\"?@[\\\\]^\", s[1]) != NULL)))\n\t    {\n\t\tif (d > IObuff && d[-1] != '_' && d[-1] != '\\\\')\n\t\t    *d++ = '_';\t\t// prepend a '_' to make x_CTRL-x\n\t\tSTRCPY(d, \"CTRL-\");\n\t\td += 5;\n\t\tif (*s < ' ')\n\t\t{\n#ifdef EBCDIC\n\t\t    *d++ = CtrlChar(*s);\n#else\n\t\t    *d++ = *s + '@';\n#endif\n\t\t    if (d[-1] == '\\\\')\n\t\t\t*d++ = '\\\\';\t// double a backslash\n\t\t}\n\t\telse\n\t\t    *d++ = *++s;\n\t\tif (s[1] != NUL && s[1] != '_')\n\t\t    *d++ = '_';\t\t// append a '_'\n\t\tcontinue;\n\t    }\n\t    else if (*s == '^')\t\t// \"^\" or \"CTRL-^\" or \"^_\"\n\t\t*d++ = '\\\\';\n\n\t    // Insert a backslash before a backslash after a slash, for search\n\t    // pattern tags: \"/\\|\" --> \"/\\\\|\".\n\t    else if (s[0] == '\\\\' && s[1] != '\\\\'\n\t\t\t\t\t       && *arg == '/' && s == arg + 1)\n\t\t*d++ = '\\\\';\n\n\t    // \"CTRL-\\_\" -> \"CTRL-\\\\_\" to avoid the special meaning of \"\\_\" in\n\t    // \"CTRL-\\_CTRL-N\"\n\t    if (STRNICMP(s, \"CTRL-\\\\_\", 7) == 0)\n\t    {\n\t\tSTRCPY(d, \"CTRL-\\\\\\\\\");\n\t\td += 7;\n\t\ts += 6;\n\t    }\n\n\t    *d++ = *s;\n\n\t    // If tag contains \"({\" or \"([\", tag terminates at the \"(\".\n\t    // This is for help on functions, e.g.: abs({expr}).\n\t    if (*s == '(' && (s[1] == '{' || s[1] =='['))\n\t\tbreak;\n\n\t    // If tag starts with ', toss everything after a second '. Fixes\n\t    // CTRL-] on 'option'. (would include the trailing '.').\n\t    if (*s == '\\'' && s > arg && *arg == '\\'')\n\t\tbreak;\n\t    // Also '{' and '}'.\n\t    if (*s == '}' && s > arg && *arg == '{')\n\t\tbreak;\n\t  }\n\t  *d = NUL;\n\n\t  if (*IObuff == '`')\n\t  {\n\t      if (d > IObuff + 2 && d[-1] == '`')\n\t      {\n\t\t  // remove the backticks from `command`\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-2] = NUL;\n\t      }\n\t      else if (d > IObuff + 3 && d[-2] == '`' && d[-1] == ',')\n\t      {\n\t\t  // remove the backticks and comma from `command`,\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-3] = NUL;\n\t      }\n\t      else if (d > IObuff + 4 && d[-3] == '`'\n\t\t\t\t\t     && d[-2] == '\\\\' && d[-1] == '.')\n\t      {\n\t\t  // remove the backticks and dot from `command`\\.\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-4] = NUL;\n\t      }\n\t  }\n\t}\n    }\n\n    *matches = (char_u **)\"\";\n    *num_matches = 0;\n    flags = TAG_HELP | TAG_REGEXP | TAG_NAMES | TAG_VERBOSE | TAG_NO_TAGFUNC;\n    if (keep_lang)\n\tflags |= TAG_KEEP_LANG;\n    if (find_tags(IObuff, num_matches, matches, flags, (int)MAXCOL, NULL) == OK\n\t    && *num_matches > 0)\n    {\n\t// Sort the matches found on the heuristic number that is after the\n\t// tag name.\n\tqsort((void *)*matches, (size_t)*num_matches,\n\t\t\t\t\t      sizeof(char_u *), help_compare);\n\t// Delete more than TAG_MANY to reduce the size of the listing.\n\twhile (*num_matches > TAG_MANY)\n\t    vim_free((*matches)[--*num_matches]);\n    }\n    return OK;\n}",
        "func_after": "int\nfind_help_tags(\n    char_u\t*arg,\n    int\t\t*num_matches,\n    char_u\t***matches,\n    int\t\tkeep_lang)\n{\n    char_u\t*s, *d;\n    int\t\ti;\n    // Specific tags that either have a specific replacement or won't go\n    // through the generic rules.\n    static char *(except_tbl[][2]) = {\n\t{\"*\",\t\t\"star\"},\n\t{\"g*\",\t\t\"gstar\"},\n\t{\"[*\",\t\t\"[star\"},\n\t{\"]*\",\t\t\"]star\"},\n\t{\":*\",\t\t\":star\"},\n\t{\"/*\",\t\t\"/star\"},\n\t{\"/\\\\*\",\t\"/\\\\\\\\star\"},\n\t{\"\\\"*\",\t\t\"quotestar\"},\n\t{\"**\",\t\t\"starstar\"},\n\t{\"cpo-*\",\t\"cpo-star\"},\n\t{\"/\\\\(\\\\)\",\t\"/\\\\\\\\(\\\\\\\\)\"},\n\t{\"/\\\\%(\\\\)\",\t\"/\\\\\\\\%(\\\\\\\\)\"},\n\t{\"?\",\t\t\"?\"},\n\t{\"??\",\t\t\"??\"},\n\t{\":?\",\t\t\":?\"},\n\t{\"?<CR>\",\t\"?<CR>\"},\n\t{\"g?\",\t\t\"g?\"},\n\t{\"g?g?\",\t\"g?g?\"},\n\t{\"g??\",\t\t\"g??\"},\n\t{\"-?\",\t\t\"-?\"},\n\t{\"q?\",\t\t\"q?\"},\n\t{\"v_g?\",\t\"v_g?\"},\n\t{\"/\\\\?\",\t\"/\\\\\\\\?\"},\n\t{\"/\\\\z(\\\\)\",\t\"/\\\\\\\\z(\\\\\\\\)\"},\n\t{\"\\\\=\",\t\t\"\\\\\\\\=\"},\n\t{\":s\\\\=\",\t\":s\\\\\\\\=\"},\n\t{\"[count]\",\t\"\\\\[count]\"},\n\t{\"[quotex]\",\t\"\\\\[quotex]\"},\n\t{\"[range]\",\t\"\\\\[range]\"},\n\t{\":[range]\",\t\":\\\\[range]\"},\n\t{\"[pattern]\",\t\"\\\\[pattern]\"},\n\t{\"\\\\|\",\t\t\"\\\\\\\\bar\"},\n\t{\"\\\\%$\",\t\"/\\\\\\\\%\\\\$\"},\n\t{\"s/\\\\~\",\t\"s/\\\\\\\\\\\\~\"},\n\t{\"s/\\\\U\",\t\"s/\\\\\\\\U\"},\n\t{\"s/\\\\L\",\t\"s/\\\\\\\\L\"},\n\t{\"s/\\\\1\",\t\"s/\\\\\\\\1\"},\n\t{\"s/\\\\2\",\t\"s/\\\\\\\\2\"},\n\t{\"s/\\\\3\",\t\"s/\\\\\\\\3\"},\n\t{\"s/\\\\9\",\t\"s/\\\\\\\\9\"},\n\t{NULL, NULL}\n    };\n    static char *(expr_table[]) = {\"!=?\", \"!~?\", \"<=?\", \"<?\", \"==?\", \"=~?\",\n\t\t\t\t   \">=?\", \">?\", \"is?\", \"isnot?\"};\n    int flags;\n\n    d = IObuff;\t\t    // assume IObuff is long enough!\n    d[0] = NUL;\n\n    if (STRNICMP(arg, \"expr-\", 5) == 0)\n    {\n\t// When the string starting with \"expr-\" and containing '?' and matches\n\t// the table, it is taken literally (but ~ is escaped).  Otherwise '?'\n\t// is recognized as a wildcard.\n\tfor (i = (int)ARRAY_LENGTH(expr_table); --i >= 0; )\n\t    if (STRCMP(arg + 5, expr_table[i]) == 0)\n\t    {\n\t\tint si = 0, di = 0;\n\n\t\tfor (;;)\n\t\t{\n\t\t    if (arg[si] == '~')\n\t\t\td[di++] = '\\\\';\n\t\t    d[di++] = arg[si];\n\t\t    if (arg[si] == NUL)\n\t\t\tbreak;\n\t\t    ++si;\n\t\t}\n\t\tbreak;\n\t    }\n    }\n    else\n    {\n\t// Recognize a few exceptions to the rule.  Some strings that contain\n\t// '*'are changed to \"star\", otherwise '*' is recognized as a wildcard.\n\tfor (i = 0; except_tbl[i][0] != NULL; ++i)\n\t    if (STRCMP(arg, except_tbl[i][0]) == 0)\n\t    {\n\t\tSTRCPY(d, except_tbl[i][1]);\n\t\tbreak;\n\t    }\n    }\n\n    if (d[0] == NUL)\t// no match in table\n    {\n\t// Replace \"\\S\" with \"/\\\\S\", etc.  Otherwise every tag is matched.\n\t// Also replace \"\\%^\" and \"\\%(\", they match every tag too.\n\t// Also \"\\zs\", \"\\z1\", etc.\n\t// Also \"\\@<\", \"\\@=\", \"\\@<=\", etc.\n\t// And also \"\\_$\" and \"\\_^\".\n\tif (arg[0] == '\\\\'\n\t\t&& ((arg[1] != NUL && arg[2] == NUL)\n\t\t    || (vim_strchr((char_u *)\"%_z@\", arg[1]) != NULL\n\t\t\t\t\t\t\t   && arg[2] != NUL)))\n\t{\n\t    vim_snprintf((char *)d, IOSIZE, \"/\\\\\\\\%s\", arg + 1);\n\t    // Check for \"/\\\\_$\", should be \"/\\\\_\\$\"\n\t    if (d[3] == '_' && d[4] == '$')\n\t\tSTRCPY(d + 4, \"\\\\$\");\n\t}\n\telse\n\t{\n\t  // Replace:\n\t  // \"[:...:]\" with \"\\[:...:]\"\n\t  // \"[++...]\" with \"\\[++...]\"\n\t  // \"\\{\" with \"\\\\{\"\t\t   -- matching \"} \\}\"\n\t    if ((arg[0] == '[' && (arg[1] == ':'\n\t\t\t || (arg[1] == '+' && arg[2] == '+')))\n\t\t    || (arg[0] == '\\\\' && arg[1] == '{'))\n\t      *d++ = '\\\\';\n\n\t  // If tag starts with \"('\", skip the \"(\". Fixes CTRL-] on ('option'.\n\t  if (*arg == '(' && arg[1] == '\\'')\n\t      arg++;\n\t  for (s = arg; *s; ++s)\n\t  {\n\t    // Replace \"|\" with \"bar\" and '\"' with \"quote\" to match the name of\n\t    // the tags for these commands.\n\t    // Replace \"*\" with \".*\" and \"?\" with \".\" to match command line\n\t    // completion.\n\t    // Insert a backslash before '~', '$' and '.' to avoid their\n\t    // special meaning.\n\t    if (d - IObuff > IOSIZE - 10)\t// getting too long!?\n\t\tbreak;\n\t    switch (*s)\n\t    {\n\t\tcase '|':   STRCPY(d, \"bar\");\n\t\t\t    d += 3;\n\t\t\t    continue;\n\t\tcase '\"':   STRCPY(d, \"quote\");\n\t\t\t    d += 5;\n\t\t\t    continue;\n\t\tcase '*':   *d++ = '.';\n\t\t\t    break;\n\t\tcase '?':   *d++ = '.';\n\t\t\t    continue;\n\t\tcase '$':\n\t\tcase '.':\n\t\tcase '~':   *d++ = '\\\\';\n\t\t\t    break;\n\t    }\n\n\t    // Replace \"^x\" by \"CTRL-X\". Don't do this for \"^_\" to make\n\t    // \":help i_^_CTRL-D\" work.\n\t    // Insert '-' before and after \"CTRL-X\" when applicable.\n\t    if (*s < ' ' || (*s == '^' && s[1] && (ASCII_ISALPHA(s[1])\n\t\t\t   || vim_strchr((char_u *)\"?@[\\\\]^\", s[1]) != NULL)))\n\t    {\n\t\tif (d > IObuff && d[-1] != '_' && d[-1] != '\\\\')\n\t\t    *d++ = '_';\t\t// prepend a '_' to make x_CTRL-x\n\t\tSTRCPY(d, \"CTRL-\");\n\t\td += 5;\n\t\tif (*s < ' ')\n\t\t{\n#ifdef EBCDIC\n\t\t    *d++ = CtrlChar(*s);\n#else\n\t\t    *d++ = *s + '@';\n#endif\n\t\t    if (d[-1] == '\\\\')\n\t\t\t*d++ = '\\\\';\t// double a backslash\n\t\t}\n\t\telse\n\t\t    *d++ = *++s;\n\t\tif (s[1] != NUL && s[1] != '_')\n\t\t    *d++ = '_';\t\t// append a '_'\n\t\tcontinue;\n\t    }\n\t    else if (*s == '^')\t\t// \"^\" or \"CTRL-^\" or \"^_\"\n\t\t*d++ = '\\\\';\n\n\t    // Insert a backslash before a backslash after a slash, for search\n\t    // pattern tags: \"/\\|\" --> \"/\\\\|\".\n\t    else if (s[0] == '\\\\' && s[1] != '\\\\'\n\t\t\t\t\t       && *arg == '/' && s == arg + 1)\n\t\t*d++ = '\\\\';\n\n\t    // \"CTRL-\\_\" -> \"CTRL-\\\\_\" to avoid the special meaning of \"\\_\" in\n\t    // \"CTRL-\\_CTRL-N\"\n\t    if (STRNICMP(s, \"CTRL-\\\\_\", 7) == 0)\n\t    {\n\t\tSTRCPY(d, \"CTRL-\\\\\\\\\");\n\t\td += 7;\n\t\ts += 6;\n\t    }\n\n\t    *d++ = *s;\n\n\t    // If tag contains \"({\" or \"([\", tag terminates at the \"(\".\n\t    // This is for help on functions, e.g.: abs({expr}).\n\t    if (*s == '(' && (s[1] == '{' || s[1] =='['))\n\t\tbreak;\n\n\t    // If tag starts with ', toss everything after a second '. Fixes\n\t    // CTRL-] on 'option'. (would include the trailing '.').\n\t    if (*s == '\\'' && s > arg && *arg == '\\'')\n\t\tbreak;\n\t    // Also '{' and '}'.\n\t    if (*s == '}' && s > arg && *arg == '{')\n\t\tbreak;\n\t  }\n\t  *d = NUL;\n\n\t  if (*IObuff == '`')\n\t  {\n\t      if (d > IObuff + 2 && d[-1] == '`')\n\t      {\n\t\t  // remove the backticks from `command`\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-2] = NUL;\n\t      }\n\t      else if (d > IObuff + 3 && d[-2] == '`' && d[-1] == ',')\n\t      {\n\t\t  // remove the backticks and comma from `command`,\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-3] = NUL;\n\t      }\n\t      else if (d > IObuff + 4 && d[-3] == '`'\n\t\t\t\t\t     && d[-2] == '\\\\' && d[-1] == '.')\n\t      {\n\t\t  // remove the backticks and dot from `command`\\.\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-4] = NUL;\n\t      }\n\t  }\n\t}\n    }\n\n    *matches = (char_u **)\"\";\n    *num_matches = 0;\n    flags = TAG_HELP | TAG_REGEXP | TAG_NAMES | TAG_VERBOSE | TAG_NO_TAGFUNC;\n    if (keep_lang)\n\tflags |= TAG_KEEP_LANG;\n    if (find_tags(IObuff, num_matches, matches, flags, (int)MAXCOL, NULL) == OK\n\t    && *num_matches > 0)\n    {\n\t// Sort the matches found on the heuristic number that is after the\n\t// tag name.\n\tqsort((void *)*matches, (size_t)*num_matches,\n\t\t\t\t\t      sizeof(char_u *), help_compare);\n\t// Delete more than TAG_MANY to reduce the size of the listing.\n\twhile (*num_matches > TAG_MANY)\n\t    vim_free((*matches)[--*num_matches]);\n    }\n    return OK;\n}",
        "description": "vim is susceptible to a Heap-based Buffer Overflow vulnerability.",
        "commit": "output: \"A buffer overflow vulnerability was identified in the handling of long help arguments. The solution implemented involves using snprintf() to prevent such overflows.\""
    },
    {
        "cwe": "CWE-121",
        "func_name": "kernel/chap_server_compute_md5",
        "score": 0.7659298777580261,
        "func_before": "static int chap_server_compute_md5(\n\tstruct iscsi_conn *conn,\n\tstruct iscsi_node_auth *auth,\n\tchar *nr_in_ptr,\n\tchar *nr_out_ptr,\n\tunsigned int *nr_out_len)\n{\n\tunsigned long id;\n\tunsigned char id_as_uchar;\n\tunsigned char digest[MD5_SIGNATURE_SIZE];\n\tunsigned char type, response[MD5_SIGNATURE_SIZE * 2 + 2];\n\tunsigned char identifier[10], *challenge = NULL;\n\tunsigned char *challenge_binhex = NULL;\n\tunsigned char client_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char server_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char chap_n[MAX_CHAP_N_SIZE], chap_r[MAX_RESPONSE_LENGTH];\n\tsize_t compare_len;\n\tstruct iscsi_chap *chap = conn->auth_protocol;\n\tstruct crypto_shash *tfm = NULL;\n\tstruct shash_desc *desc = NULL;\n\tint auth_ret = -1, ret, challenge_len;\n\n\tmemset(identifier, 0, 10);\n\tmemset(chap_n, 0, MAX_CHAP_N_SIZE);\n\tmemset(chap_r, 0, MAX_RESPONSE_LENGTH);\n\tmemset(digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(response, 0, MD5_SIGNATURE_SIZE * 2 + 2);\n\tmemset(client_digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(server_digest, 0, MD5_SIGNATURE_SIZE);\n\n\tchallenge = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge) {\n\t\tpr_err(\"Unable to allocate challenge buffer\\n\");\n\t\tgoto out;\n\t}\n\n\tchallenge_binhex = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge_binhex) {\n\t\tpr_err(\"Unable to allocate challenge_binhex buffer\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Extract CHAP_N.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_N\", MAX_CHAP_N_SIZE, chap_n,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\tif (type == HEX) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Include the terminating NULL in the compare */\n\tcompare_len = strlen(auth->userid) + 1;\n\tif (strncmp(chap_n, auth->userid, compare_len) != 0) {\n\t\tpr_err(\"CHAP_N values do not match!\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_N=%s\\n\", chap_n);\n\t/*\n\t * Extract CHAP_R.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_R\", MAX_RESPONSE_LENGTH, chap_r,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"[server] Got CHAP_R=%s\\n\", chap_r);\n\tchap_string_to_hex(client_digest, chap_r, strlen(chap_r));\n\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\ttfm = NULL;\n\t\tpr_err(\"Unable to allocate struct crypto_shash\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);\n\tif (!desc) {\n\t\tpr_err(\"Unable to allocate struct shash_desc\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, &chap->id, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, (char *)&auth->password,\n\t\t\t\t  strlen(auth->password));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for password\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_finup(desc, chap->challenge,\n\t\t\t\t CHAP_CHALLENGE_LENGTH, server_digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for challenge\\n\");\n\t\tgoto out;\n\t}\n\n\tchap_binaryhex_to_asciihex(response, server_digest, MD5_SIGNATURE_SIZE);\n\tpr_debug(\"[server] MD5 Server Digest: %s\\n\", response);\n\n\tif (memcmp(server_digest, client_digest, MD5_SIGNATURE_SIZE) != 0) {\n\t\tpr_debug(\"[server] MD5 Digests do not match!\\n\\n\");\n\t\tgoto out;\n\t} else\n\t\tpr_debug(\"[server] MD5 Digests match, CHAP connection\"\n\t\t\t\t\" successful.\\n\\n\");\n\t/*\n\t * One way authentication has succeeded, return now if mutual\n\t * authentication is not enabled.\n\t */\n\tif (!auth->authenticate_target) {\n\t\tauth_ret = 0;\n\t\tgoto out;\n\t}\n\t/*\n\t * Get CHAP_I.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_I\", 10, identifier, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_I.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type == HEX)\n\t\tret = kstrtoul(&identifier[2], 0, &id);\n\telse\n\t\tret = kstrtoul(identifier, 0, &id);\n\n\tif (ret < 0) {\n\t\tpr_err(\"kstrtoul() failed for CHAP identifier: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (id > 255) {\n\t\tpr_err(\"chap identifier: %lu greater than 255\\n\", id);\n\t\tgoto out;\n\t}\n\t/*\n\t * RFC 1994 says Identifier is no more than octet (8 bits).\n\t */\n\tpr_debug(\"[server] Got CHAP_I=%lu\\n\", id);\n\t/*\n\t * Get CHAP_C.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_C\", CHAP_CHALLENGE_STR_LEN,\n\t\t\tchallenge, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_C=%s\\n\", challenge);\n\tchallenge_len = chap_string_to_hex(challenge_binhex, challenge,\n\t\t\t\tstrlen(challenge));\n\tif (!challenge_len) {\n\t\tpr_err(\"Unable to convert incoming challenge\\n\");\n\t\tgoto out;\n\t}\n\tif (challenge_len > 1024) {\n\t\tpr_err(\"CHAP_C exceeds maximum binary size of 1024 bytes\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * During mutual authentication, the CHAP_C generated by the\n\t * initiator must not match the original CHAP_C generated by\n\t * the target.\n\t */\n\tif (!memcmp(challenge_binhex, chap->challenge, CHAP_CHALLENGE_LENGTH)) {\n\t\tpr_err(\"initiator CHAP_C matches target CHAP_C, failing\"\n\t\t       \" login attempt\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Generate CHAP_N and CHAP_R for mutual authentication.\n\t */\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* To handle both endiannesses */\n\tid_as_uchar = id;\n\tret = crypto_shash_update(desc, &id_as_uchar, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, auth->password_mutual,\n\t\t\t\t  strlen(auth->password_mutual));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for\"\n\t\t\t\t\" password_mutual\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Convert received challenge to binary hex.\n\t */\n\tret = crypto_shash_finup(desc, challenge_binhex, challenge_len,\n\t\t\t\t digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for ma challenge\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Generate CHAP_N and CHAP_R.\n\t */\n\t*nr_out_len = sprintf(nr_out_ptr, \"CHAP_N=%s\", auth->userid_mutual);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_N=%s\\n\", auth->userid_mutual);\n\t/*\n\t * Convert response from binary hex to ascii hext.\n\t */\n\tchap_binaryhex_to_asciihex(response, digest, MD5_SIGNATURE_SIZE);\n\t*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, \"CHAP_R=0x%s\",\n\t\t\tresponse);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_R=0x%s\\n\", response);\n\tauth_ret = 0;\nout:\n\tkzfree(desc);\n\tif (tfm)\n\t\tcrypto_free_shash(tfm);\n\tkfree(challenge);\n\tkfree(challenge_binhex);\n\treturn auth_ret;\n}",
        "func_after": "static int chap_server_compute_md5(\n\tstruct iscsi_conn *conn,\n\tstruct iscsi_node_auth *auth,\n\tchar *nr_in_ptr,\n\tchar *nr_out_ptr,\n\tunsigned int *nr_out_len)\n{\n\tunsigned long id;\n\tunsigned char id_as_uchar;\n\tunsigned char digest[MD5_SIGNATURE_SIZE];\n\tunsigned char type, response[MD5_SIGNATURE_SIZE * 2 + 2];\n\tunsigned char identifier[10], *challenge = NULL;\n\tunsigned char *challenge_binhex = NULL;\n\tunsigned char client_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char server_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char chap_n[MAX_CHAP_N_SIZE], chap_r[MAX_RESPONSE_LENGTH];\n\tsize_t compare_len;\n\tstruct iscsi_chap *chap = conn->auth_protocol;\n\tstruct crypto_shash *tfm = NULL;\n\tstruct shash_desc *desc = NULL;\n\tint auth_ret = -1, ret, challenge_len;\n\n\tmemset(identifier, 0, 10);\n\tmemset(chap_n, 0, MAX_CHAP_N_SIZE);\n\tmemset(chap_r, 0, MAX_RESPONSE_LENGTH);\n\tmemset(digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(response, 0, MD5_SIGNATURE_SIZE * 2 + 2);\n\tmemset(client_digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(server_digest, 0, MD5_SIGNATURE_SIZE);\n\n\tchallenge = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge) {\n\t\tpr_err(\"Unable to allocate challenge buffer\\n\");\n\t\tgoto out;\n\t}\n\n\tchallenge_binhex = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge_binhex) {\n\t\tpr_err(\"Unable to allocate challenge_binhex buffer\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Extract CHAP_N.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_N\", MAX_CHAP_N_SIZE, chap_n,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\tif (type == HEX) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Include the terminating NULL in the compare */\n\tcompare_len = strlen(auth->userid) + 1;\n\tif (strncmp(chap_n, auth->userid, compare_len) != 0) {\n\t\tpr_err(\"CHAP_N values do not match!\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_N=%s\\n\", chap_n);\n\t/*\n\t * Extract CHAP_R.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_R\", MAX_RESPONSE_LENGTH, chap_r,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (strlen(chap_r) != MD5_SIGNATURE_SIZE * 2) {\n\t\tpr_err(\"Malformed CHAP_R\\n\");\n\t\tgoto out;\n\t}\n\tif (hex2bin(client_digest, chap_r, MD5_SIGNATURE_SIZE) < 0) {\n\t\tpr_err(\"Malformed CHAP_R\\n\");\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"[server] Got CHAP_R=%s\\n\", chap_r);\n\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\ttfm = NULL;\n\t\tpr_err(\"Unable to allocate struct crypto_shash\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);\n\tif (!desc) {\n\t\tpr_err(\"Unable to allocate struct shash_desc\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, &chap->id, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, (char *)&auth->password,\n\t\t\t\t  strlen(auth->password));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for password\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_finup(desc, chap->challenge,\n\t\t\t\t CHAP_CHALLENGE_LENGTH, server_digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for challenge\\n\");\n\t\tgoto out;\n\t}\n\n\tchap_binaryhex_to_asciihex(response, server_digest, MD5_SIGNATURE_SIZE);\n\tpr_debug(\"[server] MD5 Server Digest: %s\\n\", response);\n\n\tif (memcmp(server_digest, client_digest, MD5_SIGNATURE_SIZE) != 0) {\n\t\tpr_debug(\"[server] MD5 Digests do not match!\\n\\n\");\n\t\tgoto out;\n\t} else\n\t\tpr_debug(\"[server] MD5 Digests match, CHAP connection\"\n\t\t\t\t\" successful.\\n\\n\");\n\t/*\n\t * One way authentication has succeeded, return now if mutual\n\t * authentication is not enabled.\n\t */\n\tif (!auth->authenticate_target) {\n\t\tauth_ret = 0;\n\t\tgoto out;\n\t}\n\t/*\n\t * Get CHAP_I.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_I\", 10, identifier, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_I.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type == HEX)\n\t\tret = kstrtoul(&identifier[2], 0, &id);\n\telse\n\t\tret = kstrtoul(identifier, 0, &id);\n\n\tif (ret < 0) {\n\t\tpr_err(\"kstrtoul() failed for CHAP identifier: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (id > 255) {\n\t\tpr_err(\"chap identifier: %lu greater than 255\\n\", id);\n\t\tgoto out;\n\t}\n\t/*\n\t * RFC 1994 says Identifier is no more than octet (8 bits).\n\t */\n\tpr_debug(\"[server] Got CHAP_I=%lu\\n\", id);\n\t/*\n\t * Get CHAP_C.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_C\", CHAP_CHALLENGE_STR_LEN,\n\t\t\tchallenge, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\tchallenge_len = DIV_ROUND_UP(strlen(challenge), 2);\n\tif (!challenge_len) {\n\t\tpr_err(\"Unable to convert incoming challenge\\n\");\n\t\tgoto out;\n\t}\n\tif (challenge_len > 1024) {\n\t\tpr_err(\"CHAP_C exceeds maximum binary size of 1024 bytes\\n\");\n\t\tgoto out;\n\t}\n\tif (hex2bin(challenge_binhex, challenge, challenge_len) < 0) {\n\t\tpr_err(\"Malformed CHAP_C\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_C=%s\\n\", challenge);\n\t/*\n\t * During mutual authentication, the CHAP_C generated by the\n\t * initiator must not match the original CHAP_C generated by\n\t * the target.\n\t */\n\tif (!memcmp(challenge_binhex, chap->challenge, CHAP_CHALLENGE_LENGTH)) {\n\t\tpr_err(\"initiator CHAP_C matches target CHAP_C, failing\"\n\t\t       \" login attempt\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Generate CHAP_N and CHAP_R for mutual authentication.\n\t */\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* To handle both endiannesses */\n\tid_as_uchar = id;\n\tret = crypto_shash_update(desc, &id_as_uchar, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, auth->password_mutual,\n\t\t\t\t  strlen(auth->password_mutual));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for\"\n\t\t\t\t\" password_mutual\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Convert received challenge to binary hex.\n\t */\n\tret = crypto_shash_finup(desc, challenge_binhex, challenge_len,\n\t\t\t\t digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for ma challenge\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Generate CHAP_N and CHAP_R.\n\t */\n\t*nr_out_len = sprintf(nr_out_ptr, \"CHAP_N=%s\", auth->userid_mutual);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_N=%s\\n\", auth->userid_mutual);\n\t/*\n\t * Convert response from binary hex to ascii hext.\n\t */\n\tchap_binaryhex_to_asciihex(response, digest, MD5_SIGNATURE_SIZE);\n\t*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, \"CHAP_R=0x%s\",\n\t\t\tresponse);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_R=0x%s\\n\", response);\n\tauth_ret = 0;\nout:\n\tkzfree(desc);\n\tif (tfm)\n\t\tcrypto_free_shash(tfm);\n\tkfree(challenge);\n\tkfree(challenge_binhex);\n\treturn auth_ret;\n}",
        "description": "A security flaw exists in the chap_server_compute_md5() function within the ISCSI target code of the Linux kernel, where an unauthenticated remote attacker can exploit a stack buffer overflow to overwrite up to 17 bytes of the stack. This vulnerability arises during the processing of an authentication request from an ISCSI initiator. For an attack to be successful, the iSCSI target must be enabled on the victim host. The impact of the overflow varies based on the target's build environment, including the compiler, compile flags, and hardware architecture, potentially leading to a system crash, denial-of-service, or unauthorized access to data exported by the iSCSI target. Although privilege escalation is not conclusively proven, it remains a concern. This vulnerability affects kernel versions 4.18.x, 4.14.x, and 3.10.x.",
        "commit": "Please provide the specific vulnerability knowledge you would like me to abstract and generalize."
    },
    {
        "cwe": "CWE-834",
        "func_name": "ImageMagick/ReadPDBImage",
        "score": 0.7604069113731384,
        "func_before": "static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  unsigned char\n    attributes,\n    tag[3];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  PDBImage\n    pdb_image;\n\n  PDBInfo\n    pdb_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    num_pad_bytes,\n    one,\n    packets;\n\n  ssize_t\n    count,\n    img_offset,\n    comment_offset = 0,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PDB image file.\n  */\n  count=ReadBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n  if (count != sizeof(pdb_info.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_info.attributes=(short) ReadBlobMSBShort(image);\n  pdb_info.version=(short) ReadBlobMSBShort(image);\n  pdb_info.create_time=ReadBlobMSBLong(image);\n  pdb_info.modify_time=ReadBlobMSBLong(image);\n  pdb_info.archive_time=ReadBlobMSBLong(image);\n  pdb_info.modify_number=ReadBlobMSBLong(image);\n  pdb_info.application_info=ReadBlobMSBLong(image);\n  pdb_info.sort_info=ReadBlobMSBLong(image);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.type);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.id);\n  pdb_info.seed=ReadBlobMSBLong(image);\n  pdb_info.next_record=ReadBlobMSBLong(image);\n  pdb_info.number_records=(short) ReadBlobMSBShort(image);\n  if ((memcmp(pdb_info.type,\"vIMG\",4) != 0) ||\n      (memcmp(pdb_info.id,\"View\",4) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (pdb_info.next_record != 0)\n    ThrowReaderException(CoderError,\"MultipleRecordListNotSupported\");\n  /*\n    Read record header.\n  */\n  img_offset=(ssize_t) ReadBlobMSBSignedLong(image);\n  attributes=(unsigned char) ReadBlobByte(image);\n  (void) attributes;\n  count=ReadBlob(image,3,(unsigned char *) tag);\n  if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x00\",3) != 0)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  if (pdb_info.number_records > 1)\n    {\n      comment_offset=(ssize_t) ReadBlobMSBSignedLong(image);\n      attributes=(unsigned char) ReadBlobByte(image);\n      count=ReadBlob(image,3,(unsigned char *) tag);\n      if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x01\",3) != 0)\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  num_pad_bytes = (size_t) (img_offset - TellBlob( image ));\n  while (num_pad_bytes-- != 0)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  /*\n    Read image header.\n  */\n  count=ReadBlob(image,sizeof(pdb_image.name),(unsigned char *) pdb_image.name);\n  if (count != sizeof(pdb_image.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_image.version=ReadBlobByte(image);\n  pdb_image.type=(unsigned char) (ReadBlobByte(image));\n  pdb_image.reserved_1=ReadBlobMSBLong(image);\n  pdb_image.note=ReadBlobMSBLong(image);\n  pdb_image.x_last=(short) ReadBlobMSBShort(image);\n  pdb_image.y_last=(short) ReadBlobMSBShort(image);\n  pdb_image.reserved_2=ReadBlobMSBLong(image);\n  pdb_image.x_anchor=ReadBlobMSBShort(image);\n  pdb_image.y_anchor=ReadBlobMSBShort(image);\n  pdb_image.width=(short) ReadBlobMSBShort(image);\n  pdb_image.height=(short) ReadBlobMSBShort(image);\n  /*\n    Initialize image structure.\n  */\n  image->columns=(size_t) pdb_image.width;\n  image->rows=(size_t) pdb_image.height;\n  image->depth=8;\n  image->storage_class=PseudoClass;\n  bits_per_pixel=pdb_image.type == 0 ? 2UL : pdb_image.type == 2 ? 4UL : 1UL;\n  one=1;\n  if (AcquireImageColormap(image,one << bits_per_pixel,exception) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  packets=(bits_per_pixel*image->columns+7)/8;\n  pixels=(unsigned char *) AcquireQuantumMemory(packets+257UL,image->rows*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  switch (pdb_image.version & 0x07) \n  {\n    case 0:\n    {\n      image->compression=NoCompression;\n      count=(ssize_t) ReadBlob(image,packets*image->rows,pixels);\n      break;\n    }\n    case 1:\n    {\n      image->compression=RLECompression;\n      if (!DecodeImage(image,pixels,packets*image->rows))\n        {\n          pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n          ThrowReaderException(CorruptImageError,\"RLEDecoderError\");\n        }\n      break;\n    }\n    default:\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowReaderException(CorruptImageError,\n        \"UnrecognizedImageCompressionType\");\n    }\n  }\n  p=pixels;\n  switch (bits_per_pixel)\n  {\n    case 1:\n    {\n      int\n        bit;\n\n      /*\n        Read 1-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=(Quantum) (*p & (0x80 >> bit) ? 0x00 : 0x01);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    case 2:\n    {\n      /*\n        Read 2-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns-3; x+=4)\n        {\n          index=ConstrainColormapIndex(image,3UL-((*p >> 6) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 4) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 2) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    case 4:\n    {\n      /*\n        Read 4-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns-1; x+=2)\n        {\n          index=ConstrainColormapIndex(image,15UL-((*p >> 4) & 0x0f),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,15UL-((*p) & 0x0f),exception);\n          SetPixelIndex(image,index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    default:\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (pdb_info.number_records > 1)\n    {\n      char\n        *comment;\n\n      int\n        c;\n\n      register char\n        *p;\n\n      size_t\n        length;\n\n      num_pad_bytes = (size_t) (comment_offset - TellBlob( image ));\n      while (num_pad_bytes--) ReadBlobByte( image );\n\n      /*\n        Read comment.\n      */\n      c=ReadBlobByte(image);\n      length=MagickPathExtent;\n      comment=AcquireString((char *) NULL);\n      for (p=comment; c != EOF; p++)\n      {\n        if ((size_t) (p-comment+MagickPathExtent) >= length)\n          {\n            *p='\\0';\n            length<<=1;\n            length+=MagickPathExtent;\n            comment=(char *) ResizeQuantumMemory(comment,length+MagickPathExtent,\n              sizeof(*comment));\n            if (comment == (char *) NULL)\n              break;\n            p=comment+strlen(comment);\n          }\n        *p=c;\n        c=ReadBlobByte(image);\n      }\n      *p='\\0';\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      (void) SetImageProperty(image,\"comment\",comment,exception);\n      comment=DestroyString(comment);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func_after": "static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  unsigned char\n    attributes,\n    tag[3];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  PDBImage\n    pdb_image;\n\n  PDBInfo\n    pdb_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    num_pad_bytes,\n    one,\n    packets;\n\n  ssize_t\n    count,\n    img_offset,\n    comment_offset = 0,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PDB image file.\n  */\n  count=ReadBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n  if (count != sizeof(pdb_info.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_info.attributes=(short) ReadBlobMSBShort(image);\n  pdb_info.version=(short) ReadBlobMSBShort(image);\n  pdb_info.create_time=ReadBlobMSBLong(image);\n  pdb_info.modify_time=ReadBlobMSBLong(image);\n  pdb_info.archive_time=ReadBlobMSBLong(image);\n  pdb_info.modify_number=ReadBlobMSBLong(image);\n  pdb_info.application_info=ReadBlobMSBLong(image);\n  pdb_info.sort_info=ReadBlobMSBLong(image);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.type);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.id);\n  pdb_info.seed=ReadBlobMSBLong(image);\n  pdb_info.next_record=ReadBlobMSBLong(image);\n  pdb_info.number_records=(short) ReadBlobMSBShort(image);\n  if ((memcmp(pdb_info.type,\"vIMG\",4) != 0) ||\n      (memcmp(pdb_info.id,\"View\",4) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (pdb_info.next_record != 0)\n    ThrowReaderException(CoderError,\"MultipleRecordListNotSupported\");\n  /*\n    Read record header.\n  */\n  img_offset=(ssize_t) ReadBlobMSBSignedLong(image);\n  attributes=(unsigned char) ReadBlobByte(image);\n  (void) attributes;\n  count=ReadBlob(image,3,(unsigned char *) tag);\n  if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x00\",3) != 0)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  if (pdb_info.number_records > 1)\n    {\n      comment_offset=(ssize_t) ReadBlobMSBSignedLong(image);\n      attributes=(unsigned char) ReadBlobByte(image);\n      count=ReadBlob(image,3,(unsigned char *) tag);\n      if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x01\",3) != 0)\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  num_pad_bytes = (size_t) (img_offset - TellBlob( image ));\n  while (num_pad_bytes-- != 0)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  /*\n    Read image header.\n  */\n  count=ReadBlob(image,sizeof(pdb_image.name),(unsigned char *) pdb_image.name);\n  if (count != sizeof(pdb_image.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_image.version=ReadBlobByte(image);\n  pdb_image.type=(unsigned char) (ReadBlobByte(image));\n  pdb_image.reserved_1=ReadBlobMSBLong(image);\n  pdb_image.note=ReadBlobMSBLong(image);\n  pdb_image.x_last=(short) ReadBlobMSBShort(image);\n  pdb_image.y_last=(short) ReadBlobMSBShort(image);\n  pdb_image.reserved_2=ReadBlobMSBLong(image);\n  pdb_image.x_anchor=ReadBlobMSBShort(image);\n  pdb_image.y_anchor=ReadBlobMSBShort(image);\n  pdb_image.width=(short) ReadBlobMSBShort(image);\n  pdb_image.height=(short) ReadBlobMSBShort(image);\n  /*\n    Initialize image structure.\n  */\n  image->columns=(size_t) pdb_image.width;\n  image->rows=(size_t) pdb_image.height;\n  image->depth=8;\n  image->storage_class=PseudoClass;\n  bits_per_pixel=pdb_image.type == 0 ? 2UL : pdb_image.type == 2 ? 4UL : 1UL;\n  one=1;\n  if (AcquireImageColormap(image,one << bits_per_pixel,exception) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  packets=(bits_per_pixel*image->columns+7)/8;\n  pixels=(unsigned char *) AcquireQuantumMemory(packets+257UL,image->rows*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  switch (pdb_image.version & 0x07) \n  {\n    case 0:\n    {\n      image->compression=NoCompression;\n      count=(ssize_t) ReadBlob(image,packets*image->rows,pixels);\n      break;\n    }\n    case 1:\n    {\n      image->compression=RLECompression;\n      if (!DecodeImage(image,pixels,packets*image->rows))\n        {\n          pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n          ThrowReaderException(CorruptImageError,\"RLEDecoderError\");\n        }\n      break;\n    }\n    default:\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowReaderException(CorruptImageError,\n        \"UnrecognizedImageCompressionType\");\n    }\n  }\n  p=pixels;\n  switch (bits_per_pixel)\n  {\n    case 1:\n    {\n      int\n        bit;\n\n      /*\n        Read 1-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=(Quantum) (*p & (0x80 >> bit) ? 0x00 : 0x01);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    case 2:\n    {\n      /*\n        Read 2-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns-3; x+=4)\n        {\n          index=ConstrainColormapIndex(image,3UL-((*p >> 6) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 4) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 2) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    case 4:\n    {\n      /*\n        Read 4-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns-1; x+=2)\n        {\n          index=ConstrainColormapIndex(image,15UL-((*p >> 4) & 0x0f),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,15UL-((*p) & 0x0f),exception);\n          SetPixelIndex(image,index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    default:\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (pdb_info.number_records > 1)\n    {\n      char\n        *comment;\n\n      int\n        c;\n\n      register char\n        *p;\n\n      size_t\n        length;\n\n      num_pad_bytes = (size_t) (comment_offset - TellBlob( image ));\n      while (num_pad_bytes-- != 0)\n      {\n        int\n          c;\n\n        c=ReadBlobByte(image);\n        if (c == EOF)\n          break;\n      }\n\n      /*\n        Read comment.\n      */\n      c=ReadBlobByte(image);\n      length=MagickPathExtent;\n      comment=AcquireString((char *) NULL);\n      for (p=comment; c != EOF; p++)\n      {\n        if ((size_t) (p-comment+MagickPathExtent) >= length)\n          {\n            *p='\\0';\n            length<<=1;\n            length+=MagickPathExtent;\n            comment=(char *) ResizeQuantumMemory(comment,length+MagickPathExtent,\n              sizeof(*comment));\n            if (comment == (char *) NULL)\n              break;\n            p=comment+strlen(comment);\n          }\n        *p=c;\n        c=ReadBlobByte(image);\n      }\n      *p='\\0';\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      (void) SetImageProperty(image,\"comment\",comment,exception);\n      comment=DestroyString(comment);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "description": "In ImageMagick versions prior to 7.0.6-2, a CPU exhaustion vulnerability exists within the function responsible for reading PDB images. This flaw enables attackers to exploit it, leading to a denial of service condition.",
        "commit": "It was discovered that ImageMagick, a popular image processing library, contains a vulnerability related to improper handling of certain image formats, potentially leading to buffer overflows or other memory corruption issues."
    },
    {
        "cwe": "CWE-662",
        "func_name": "torvalds/do_fontx_ioctl",
        "score": 0.7474355101585388,
        "func_before": "static inline int do_fontx_ioctl(int cmd,\n\t\tstruct consolefontdesc __user *user_cfd,\n\t\tstruct console_font_op *op)\n{\n\tstruct consolefontdesc cfdarg;\n\tint i;\n\n\tif (copy_from_user(&cfdarg, user_cfd, sizeof(struct consolefontdesc)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase PIO_FONTX:\n\t\top->op = KD_FONT_OP_SET;\n\t\top->flags = KD_FONT_FLAG_OLD;\n\t\top->width = 8;\n\t\top->height = cfdarg.charheight;\n\t\top->charcount = cfdarg.charcount;\n\t\top->data = cfdarg.chardata;\n\t\treturn con_font_op(vc_cons[fg_console].d, op);\n\tcase GIO_FONTX: {\n\t\top->op = KD_FONT_OP_GET;\n\t\top->flags = KD_FONT_FLAG_OLD;\n\t\top->width = 8;\n\t\top->height = cfdarg.charheight;\n\t\top->charcount = cfdarg.charcount;\n\t\top->data = cfdarg.chardata;\n\t\ti = con_font_op(vc_cons[fg_console].d, op);\n\t\tif (i)\n\t\t\treturn i;\n\t\tcfdarg.charheight = op->height;\n\t\tcfdarg.charcount = op->charcount;\n\t\tif (copy_to_user(user_cfd, &cfdarg, sizeof(struct consolefontdesc)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}",
        "func_after": "static inline int do_fontx_ioctl(struct vc_data *vc, int cmd,\n\t\tstruct consolefontdesc __user *user_cfd,\n\t\tstruct console_font_op *op)\n{\n\tstruct consolefontdesc cfdarg;\n\tint i;\n\n\tif (copy_from_user(&cfdarg, user_cfd, sizeof(struct consolefontdesc)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase PIO_FONTX:\n\t\top->op = KD_FONT_OP_SET;\n\t\top->flags = KD_FONT_FLAG_OLD;\n\t\top->width = 8;\n\t\top->height = cfdarg.charheight;\n\t\top->charcount = cfdarg.charcount;\n\t\top->data = cfdarg.chardata;\n\t\treturn con_font_op(vc, op);\n\n\tcase GIO_FONTX:\n\t\top->op = KD_FONT_OP_GET;\n\t\top->flags = KD_FONT_FLAG_OLD;\n\t\top->width = 8;\n\t\top->height = cfdarg.charheight;\n\t\top->charcount = cfdarg.charcount;\n\t\top->data = cfdarg.chardata;\n\t\ti = con_font_op(vc, op);\n\t\tif (i)\n\t\t\treturn i;\n\t\tcfdarg.charheight = op->height;\n\t\tcfdarg.charcount = op->charcount;\n\t\tif (copy_to_user(user_cfd, &cfdarg, sizeof(struct consolefontdesc)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}",
        "description": "A flaw was identified in the Linux Kernel where access to a global variable used for managing the foreground console is not adequately synchronized, resulting in a use-after-free error within the function responsible for font operations.",
        "commit": "Some font-related terminal I/O control operations previously utilized the current foreground virtual console (VC) for their execution. This practice has been discontinued to address a data race condition involving the `fg_console` variable. Notably, both Michael Ellerman and Jiri Slaby have observed that these I/O control operations are deprecated and should have been removed earlier. They suggest that most systems now use the `KDFONTOP` ioctl instead. Additionally, Michael notes that BusyBox's `loadfont` program transitioned to using `KDFONTOP` precisely due to this bug, which was identified approximately 12 years ago."
    }
]