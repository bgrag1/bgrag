[
    {
        "cwe": "CWE-22",
        "func_name": "GNOME/extract_archive_thread",
        "score": 0.7985194325447083,
        "func_before": "static void\nextract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tGHashTable           *created_files;\n\tGHashTable           *folders_created_during_extraction;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\n\tr = create_read_object (load_data, &a);\n\tif (r != ARCHIVE_OK) {\n\t\tarchive_read_free(a);\n\t\treturn;\n\t}\n\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tcreated_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, g_object_unref);\n\tfolders_created_during_extraction = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        target_offset, actual_offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\n\t\t/* honor the skip_older and overwrite options */\n\n\t\tif ((g_hash_table_lookup (folders_created_during_extraction, file) == NULL)\n\t\t    && (extract_data->skip_older || ! extract_data->overwrite))\n\t\t{\n\t\t\tGFileInfo *info;\n\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\n\t\t\t\tg_object_unref (info);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\t\t}\n\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\n\t\t/* create the file parents */\n\n\t\tparent = g_file_get_parent (file);\n\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (! _g_file_make_directory_with_parents (parent,\n\t\t\t\t\t\t\t\t   folders_created_during_extraction,\n\t\t\t\t\t\t\t\t   cancellable,\n\t\t\t\t\t\t\t\t   &local_error))\n\t\t\t{\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\telse\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\n\t\t\tif (load_data->error == NULL) {\n\t\t\t\tGFile *grandparent;\n\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\n\t\t/* create the file */\n\n\t\tfiletype = archive_entry_filetype (entry);\n\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; /* treat as a regular file to save the data */\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tif (load_data->error == NULL)\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tactual_offset = 0;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &target_offset)) == ARCHIVE_OK) {\n\t\t\t\t\tgsize bytes_written;\n\n\t\t\t\t\tif (target_offset > actual_offset) {\n\t\t\t\t\t\tif (! _g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, target_offset - actual_offset);\n\t\t\t\t\t\tactual_offset = target_offset;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! g_output_stream_write_all (ostream, buffer, buffer_size, &bytes_written, cancellable, &load_data->error))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tactual_offset += bytes_written;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, bytes_written);\n\t\t\t\t}\n\n\t\t\t\tif ((r == ARCHIVE_EOF) && (target_offset > actual_offset))\n\t\t\t\t\t_g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error);\n\n\t\t\t\t_g_object_unref (ostream);\n\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (load_data->error == NULL)\n\t\trestore_original_file_attributes (created_files, cancellable);\n\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\n\tg_hash_table_unref (folders_created_during_extraction);\n\tg_hash_table_unref (created_files);\n\tg_hash_table_unref (checked_folders);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "func_after": "static void\nextract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tGHashTable           *created_files;\n\tGHashTable           *folders_created_during_extraction;\n\tGHashTable           *external_links;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\n\tr = create_read_object (load_data, &a);\n\tif (r != ARCHIVE_OK) {\n\t\tarchive_read_free(a);\n\t\treturn;\n\t}\n\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tcreated_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, g_object_unref);\n\tfolders_created_during_extraction = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\texternal_links = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        target_offset, actual_offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (_g_path_is_external_to_destination (relative_path, extract_data->destination, external_links)) {\n\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\n\t\t/* honor the skip_older and overwrite options */\n\n\t\tif ((g_hash_table_lookup (folders_created_during_extraction, file) == NULL)\n\t\t    && (extract_data->skip_older || ! extract_data->overwrite))\n\t\t{\n\t\t\tGFileInfo *info;\n\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\n\t\t\t\tg_object_unref (info);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\t\t}\n\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\n\t\t/* create the file parents */\n\n\t\tparent = g_file_get_parent (file);\n\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (! _g_file_make_directory_with_parents (parent,\n\t\t\t\t\t\t\t\t   folders_created_during_extraction,\n\t\t\t\t\t\t\t\t   cancellable,\n\t\t\t\t\t\t\t\t   &local_error))\n\t\t\t{\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\telse\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\n\t\t\tif (load_data->error == NULL) {\n\t\t\t\tGFile *grandparent;\n\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\n\t\t/* create the file */\n\n\t\tfiletype = archive_entry_filetype (entry);\n\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; /* treat as a regular file to save the data */\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tif (load_data->error == NULL)\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tactual_offset = 0;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &target_offset)) == ARCHIVE_OK) {\n\t\t\t\t\tgsize bytes_written;\n\n\t\t\t\t\tif (target_offset > actual_offset) {\n\t\t\t\t\t\tif (! _g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, target_offset - actual_offset);\n\t\t\t\t\t\tactual_offset = target_offset;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! g_output_stream_write_all (ostream, buffer, buffer_size, &bytes_written, cancellable, &load_data->error))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tactual_offset += bytes_written;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, bytes_written);\n\t\t\t\t}\n\n\t\t\t\tif ((r == ARCHIVE_EOF) && (target_offset > actual_offset))\n\t\t\t\t\t_g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error);\n\n\t\t\t\t_g_object_unref (ostream);\n\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\telse if (_symlink_is_external_to_destination (file, archive_entry_symlink (entry), extract_data->destination, external_links))\n\t\t\t\t\tg_hash_table_insert (external_links, g_object_ref (file), GINT_TO_POINTER (1));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (load_data->error == NULL)\n\t\trestore_original_file_attributes (created_files, cancellable);\n\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\n\tg_hash_table_unref (folders_created_during_extraction);\n\tg_hash_table_unref (created_files);\n\tg_hash_table_unref (checked_folders);\n\tg_hash_table_unref (external_links);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "description": "A directory traversal vulnerability exists in File Roller versions 3.6.x before 3.6.4, 3.8.x before 3.8.3, and 3.9.x before 3.9.3 when using libarchive. This flaw allows remote attackers to create arbitrary files by exploiting improper handling of archives during a \"Keep directory structure\" action.",
        "commit": "It was discovered that filenames should be sanitized before extraction to prevent potential security vulnerabilities."
    },
    {
        "cwe": "CWE-843",
        "func_name": "torvalds/__fib6_rule_action",
        "score": 0.7864611148834229,
        "func_before": "static int __fib6_rule_action(struct fib_rule *rule, struct flowi *flp,\n\t\t\t      int flags, struct fib_lookup_arg *arg)\n{\n\tstruct flowi6 *flp6 = &flp->u.ip6;\n\tstruct rt6_info *rt = NULL;\n\tstruct fib6_table *table;\n\tstruct net *net = rule->fr_net;\n\tpol_lookup_t lookup = arg->lookup_ptr;\n\tint err = 0;\n\tu32 tb_id;\n\n\tswitch (rule->action) {\n\tcase FR_ACT_TO_TBL:\n\t\tbreak;\n\tcase FR_ACT_UNREACHABLE:\n\t\terr = -ENETUNREACH;\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tgoto discard_pkt;\n\tdefault:\n\tcase FR_ACT_BLACKHOLE:\n\t\terr = -EINVAL;\n\t\trt = net->ipv6.ip6_blk_hole_entry;\n\t\tgoto discard_pkt;\n\tcase FR_ACT_PROHIBIT:\n\t\terr = -EACCES;\n\t\trt = net->ipv6.ip6_prohibit_entry;\n\t\tgoto discard_pkt;\n\t}\n\n\ttb_id = fib_rule_get_table(rule, arg);\n\ttable = fib6_get_table(net, tb_id);\n\tif (!table) {\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trt = lookup(net, table, flp6, arg->lookup_data, flags);\n\tif (rt != net->ipv6.ip6_null_entry) {\n\t\terr = fib6_rule_saddr(net, rule, flags, flp6,\n\t\t\t\t      ip6_dst_idev(&rt->dst)->dev);\n\n\t\tif (err == -EAGAIN)\n\t\t\tgoto again;\n\n\t\terr = rt->dst.error;\n\t\tif (err != -EAGAIN)\n\t\t\tgoto out;\n\t}\nagain:\n\tip6_rt_put(rt);\n\terr = -EAGAIN;\n\trt = NULL;\n\tgoto out;\n\ndiscard_pkt:\n\tdst_hold(&rt->dst);\nout:\n\targ->result = rt;\n\treturn err;\n}",
        "func_after": "static int __fib6_rule_action(struct fib_rule *rule, struct flowi *flp,\n\t\t\t      int flags, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct flowi6 *flp6 = &flp->u.ip6;\n\tstruct rt6_info *rt = NULL;\n\tstruct fib6_table *table;\n\tstruct net *net = rule->fr_net;\n\tpol_lookup_t lookup = arg->lookup_ptr;\n\tint err = 0;\n\tu32 tb_id;\n\n\tswitch (rule->action) {\n\tcase FR_ACT_TO_TBL:\n\t\tbreak;\n\tcase FR_ACT_UNREACHABLE:\n\t\terr = -ENETUNREACH;\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tgoto discard_pkt;\n\tdefault:\n\tcase FR_ACT_BLACKHOLE:\n\t\terr = -EINVAL;\n\t\trt = net->ipv6.ip6_blk_hole_entry;\n\t\tgoto discard_pkt;\n\tcase FR_ACT_PROHIBIT:\n\t\terr = -EACCES;\n\t\trt = net->ipv6.ip6_prohibit_entry;\n\t\tgoto discard_pkt;\n\t}\n\n\ttb_id = fib_rule_get_table(rule, arg);\n\ttable = fib6_get_table(net, tb_id);\n\tif (!table) {\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trt = lookup(net, table, flp6, arg->lookup_data, flags);\n\tif (rt != net->ipv6.ip6_null_entry) {\n\t\terr = fib6_rule_saddr(net, rule, flags, flp6,\n\t\t\t\t      ip6_dst_idev(&rt->dst)->dev);\n\n\t\tif (err == -EAGAIN)\n\t\t\tgoto again;\n\n\t\terr = rt->dst.error;\n\t\tif (err != -EAGAIN)\n\t\t\tgoto out;\n\t}\nagain:\n\tip6_rt_put(rt);\n\terr = -EAGAIN;\n\trt = NULL;\n\tgoto out;\n\ndiscard_pkt:\n\tdst_hold(&rt->dst);\nout:\n\tres->rt6 = rt;\n\treturn err;\n}",
        "description": "A flaw was identified in the IPv6 module of the Linux kernel, where the variable `arg.result` was inconsistently utilized within the function `fib6_rule_lookup`. At times, it held a value of type `rt6_info`, while at other times it held a value of type `fib6_info`. This inconsistency was not properly managed in other parts of the code that anticipated `rt6_info` unconditionally, potentially resulting in a kernel panic during the execution of `fib6_rule_suppress`.",
        "commit": "The use of the `result` argument in `fib_lookup_arg` is inconsistent within IPv6 routing mechanisms. Specifically, `arg.result` is sometimes utilized as a `fib6_result` and other times as a container for `rt6_info`. To address this inconsistency, `rt6_info` should be incorporated into `fib6_result`, ensuring uniform usage of `arg.result` throughout IPv6 routing rules. Additionally, the `rt6` entry is populated during lookups that return a `dst_entry`, but not for direct `fib_lookups` that merely require a `fib6_info`."
    },
    {
        "cwe": "CWE-59",
        "func_name": "acassen/vrrp_print_json",
        "score": 0.7985778450965881,
        "func_before": "void\nvrrp_print_json(void)\n{\n\tFILE *file;\n\telement e;\n\tstruct json_object *array;\n\n\tif (LIST_ISEMPTY(vrrp_data->vrrp))\n\t\treturn;\n\n\tfile = fopen (\"/tmp/keepalived.json\",\"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open /tmp/keepalived.json (%d: %s)\",\n\t\t\terrno, strerror(errno));\n\t\treturn;\n\t}\n\n\tarray = json_object_new_array();\n\n\tfor (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {\n\t\tstruct json_object *instance_json, *json_stats, *json_data,\n\t\t\t*vips, *evips, *track_ifp, *track_script;\n#ifdef _HAVE_FIB_ROUTING_\n\t\tstruct json_object *vroutes, *vrules;\n#endif\n\t\telement f;\n\n\t\tvrrp_t *vrrp = ELEMENT_DATA(e);\n\t\tinstance_json = json_object_new_object();\n\t\tjson_stats = json_object_new_object();\n\t\tjson_data = json_object_new_object();\n\t\tvips = json_object_new_array();\n\t\tevips = json_object_new_array();\n\t\ttrack_ifp = json_object_new_array();\n\t\ttrack_script = json_object_new_array();\n#ifdef _HAVE_FIB_ROUTING_\n\t\tvroutes = json_object_new_array();\n\t\tvrules = json_object_new_array();\n#endif\n\n\t\t// Dump data to json\n\t\tjson_object_object_add(json_data, \"iname\",\n\t\t\tjson_object_new_string(vrrp->iname));\n\t\tjson_object_object_add(json_data, \"dont_track_primary\",\n\t\t\tjson_object_new_int(vrrp->dont_track_primary));\n\t\tjson_object_object_add(json_data, \"skip_check_adv_addr\",\n\t\t\tjson_object_new_int(vrrp->skip_check_adv_addr));\n\t\tjson_object_object_add(json_data, \"strict_mode\",\n\t\t\tjson_object_new_int((int)vrrp->strict_mode));\n#ifdef _HAVE_VRRP_VMAC_\n\t\tjson_object_object_add(json_data, \"vmac_ifname\",\n\t\t\tjson_object_new_string(vrrp->vmac_ifname));\n#endif\n\t\t// Tracked interfaces are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->track_ifp)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_ifp); f; ELEMENT_NEXT(f)) {\n\t\t\t\tinterface_t *ifp = ELEMENT_DATA(f);\n\t\t\t\tjson_object_array_add(track_ifp,\n\t\t\t\t\tjson_object_new_string(ifp->ifname));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_ifp\", track_ifp);\n\n\t\t// Tracked scripts also\n\t\tif (!LIST_ISEMPTY(vrrp->track_script)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_script); f; ELEMENT_NEXT(f)) {\n\t\t\t\ttracked_sc_t *tsc = ELEMENT_DATA(f);\n\t\t\t\tvrrp_script_t *vscript = tsc->scr;\n\t\t\t\tjson_object_array_add(track_script,\n\t\t\t\t\tjson_object_new_string(cmd_str(&vscript->script)));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_script\", track_script);\n\n\t\tjson_object_object_add(json_data, \"ifp_ifname\",\n\t\t\tjson_object_new_string(vrrp->ifp->ifname));\n\t\tjson_object_object_add(json_data, \"master_priority\",\n\t\t\tjson_object_new_int(vrrp->master_priority));\n\t\tjson_object_object_add(json_data, \"last_transition\",\n\t\t\tjson_object_new_double(timeval_to_double(&vrrp->last_transition)));\n\t\tjson_object_object_add(json_data, \"garp_delay\",\n\t\t\tjson_object_new_double(vrrp->garp_delay / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"garp_refresh\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh.tv_sec));\n\t\tjson_object_object_add(json_data, \"garp_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_rep));\n\t\tjson_object_object_add(json_data, \"garp_refresh_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh_rep));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->garp_lower_prio_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_lower_prio_rep));\n\t\tjson_object_object_add(json_data, \"lower_prio_no_advert\",\n\t\t\tjson_object_new_int((int)vrrp->lower_prio_no_advert));\n\t\tjson_object_object_add(json_data, \"higher_prio_send_advert\",\n\t\t\tjson_object_new_int((int)vrrp->higher_prio_send_advert));\n\t\tjson_object_object_add(json_data, \"vrid\",\n\t\t\tjson_object_new_int(vrrp->vrid));\n\t\tjson_object_object_add(json_data, \"base_priority\",\n\t\t\tjson_object_new_int(vrrp->base_priority));\n\t\tjson_object_object_add(json_data, \"effective_priority\",\n\t\t\tjson_object_new_int(vrrp->effective_priority));\n\t\tjson_object_object_add(json_data, \"vipset\",\n\t\t\tjson_object_new_boolean(vrrp->vipset));\n\n\t\t//Virtual IPs are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->vip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *vip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(vip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(vips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vips\", vips);\n\n\t\t//External VIPs are also stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->evip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->evip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *evip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(evip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(evips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"evips\", evips);\n\n\t\tjson_object_object_add(json_data, \"promote_secondaries\",\n\t\t\tjson_object_new_boolean(vrrp->promote_secondaries));\n\n#ifdef _HAVE_FIB_ROUTING_\n\t\t// Dump vroutes\n\t\tif (!LIST_ISEMPTY(vrrp->vroutes)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vroutes); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_route_t *route = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(ROUTE_BUF_SIZE);\n\t\t\t\tformat_iproute(route, buf, ROUTE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vroutes,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vroutes\", vroutes);\n\n\t\t// Dump vrules\n\t\tif (!LIST_ISEMPTY(vrrp->vrules)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vrules); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_rule_t *rule = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(RULE_BUF_SIZE);\n\t\t\t\tformat_iprule(rule, buf, RULE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vrules,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vrules\", vrules);\n#endif\n\n\t\tjson_object_object_add(json_data, \"adver_int\",\n\t\t\tjson_object_new_double(vrrp->adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"master_adver_int\",\n\t\t\tjson_object_new_double(vrrp->master_adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"accept\",\n\t\t\tjson_object_new_int((int)vrrp->accept));\n\t\tjson_object_object_add(json_data, \"nopreempt\",\n\t\t\tjson_object_new_boolean(vrrp->nopreempt));\n\t\tjson_object_object_add(json_data, \"preempt_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->preempt_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"state\",\n\t\t\tjson_object_new_int(vrrp->state));\n\t\tjson_object_object_add(json_data, \"wantstate\",\n\t\t\tjson_object_new_int(vrrp->wantstate));\n\t\tjson_object_object_add(json_data, \"version\",\n\t\t\tjson_object_new_int(vrrp->version));\n\t\tif (vrrp->script_backup)\n\t\t\tjson_object_object_add(json_data, \"script_backup\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_backup)));\n\t\tif (vrrp->script_master)\n\t\t\tjson_object_object_add(json_data, \"script_master\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master)));\n\t\tif (vrrp->script_fault)\n\t\t\tjson_object_object_add(json_data, \"script_fault\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_fault)));\n\t\tif (vrrp->script_stop)\n\t\t\tjson_object_object_add(json_data, \"script_stop\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_stop)));\n\t\tif (vrrp->script)\n\t\t\tjson_object_object_add(json_data, \"script\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script)));\n\t\tif (vrrp->script_master_rx_lower_pri)\n\t\t\tjson_object_object_add(json_data, \"script_master_rx_lower_pri\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master_rx_lower_pri)));\n\t\tjson_object_object_add(json_data, \"smtp_alert\",\n\t\t\tjson_object_new_boolean(vrrp->smtp_alert));\n#ifdef _WITH_VRRP_AUTH_\n\t\tif (vrrp->auth_type) {\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(vrrp->auth_type));\n\n\t\t\tif (vrrp->auth_type != VRRP_AUTH_AH) {\n\t\t\t\tchar auth_data[sizeof(vrrp->auth_data) + 1];\n\t\t\t\tmemcpy(auth_data, vrrp->auth_data, sizeof(vrrp->auth_data));\n\t\t\t\tauth_data[sizeof(vrrp->auth_data)] = '\\0';\n\t\t\t\tjson_object_object_add(json_data, \"auth_data\",\n\t\t\t\t\tjson_object_new_string(auth_data));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(0));\n#endif\n\n\t\t// Dump stats to json\n\t\tjson_object_object_add(json_stats, \"advert_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_rcvd));\n\t\tjson_object_object_add(json_stats, \"advert_sent\",\n\t\t\tjson_object_new_int64(vrrp->stats->advert_sent));\n\t\tjson_object_object_add(json_stats, \"become_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->become_master));\n\t\tjson_object_object_add(json_stats, \"release_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->release_master));\n\t\tjson_object_object_add(json_stats, \"packet_len_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->packet_len_err));\n\t\tjson_object_object_add(json_stats, \"advert_interval_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_interval_err));\n\t\tjson_object_object_add(json_stats, \"ip_ttl_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->ip_ttl_err));\n\t\tjson_object_object_add(json_stats, \"invalid_type_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->invalid_type_rcvd));\n\t\tjson_object_object_add(json_stats, \"addr_list_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->addr_list_err));\n\t\tjson_object_object_add(json_stats, \"invalid_authtype\",\n\t\t\tjson_object_new_int64(vrrp->stats->invalid_authtype));\n#ifdef _WITH_VRRP_AUTH_\n\t\tjson_object_object_add(json_stats, \"authtype_mismatch\",\n\t\t\tjson_object_new_int64(vrrp->stats->authtype_mismatch));\n\t\tjson_object_object_add(json_stats, \"auth_failure\",\n\t\t\tjson_object_new_int64(vrrp->stats->auth_failure));\n#endif\n\t\tjson_object_object_add(json_stats, \"pri_zero_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_rcvd));\n\t\tjson_object_object_add(json_stats, \"pri_zero_sent\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_sent));\n\n\t\t// Add both json_data and json_stats to main instance_json\n\t\tjson_object_object_add(instance_json, \"data\", json_data);\n\t\tjson_object_object_add(instance_json, \"stats\", json_stats);\n\n\t\t// Add instance_json to main array\n\t\tjson_object_array_add(array, instance_json);\n\n\t}\n\tfprintf(file, \"%s\", json_object_to_json_string(array));\n\tfclose(file);\n}",
        "func_after": "void\nvrrp_print_json(void)\n{\n\tFILE *file;\n\telement e;\n\tstruct json_object *array;\n\n\tif (LIST_ISEMPTY(vrrp_data->vrrp))\n\t\treturn;\n\n\tfile = fopen_safe(\"/tmp/keepalived.json\", \"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open /tmp/keepalived.json (%d: %s)\",\n\t\t\terrno, strerror(errno));\n\t\treturn;\n\t}\n\n\tarray = json_object_new_array();\n\n\tfor (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {\n\t\tstruct json_object *instance_json, *json_stats, *json_data,\n\t\t\t*vips, *evips, *track_ifp, *track_script;\n#ifdef _HAVE_FIB_ROUTING_\n\t\tstruct json_object *vroutes, *vrules;\n#endif\n\t\telement f;\n\n\t\tvrrp_t *vrrp = ELEMENT_DATA(e);\n\t\tinstance_json = json_object_new_object();\n\t\tjson_stats = json_object_new_object();\n\t\tjson_data = json_object_new_object();\n\t\tvips = json_object_new_array();\n\t\tevips = json_object_new_array();\n\t\ttrack_ifp = json_object_new_array();\n\t\ttrack_script = json_object_new_array();\n#ifdef _HAVE_FIB_ROUTING_\n\t\tvroutes = json_object_new_array();\n\t\tvrules = json_object_new_array();\n#endif\n\n\t\t// Dump data to json\n\t\tjson_object_object_add(json_data, \"iname\",\n\t\t\tjson_object_new_string(vrrp->iname));\n\t\tjson_object_object_add(json_data, \"dont_track_primary\",\n\t\t\tjson_object_new_int(vrrp->dont_track_primary));\n\t\tjson_object_object_add(json_data, \"skip_check_adv_addr\",\n\t\t\tjson_object_new_int(vrrp->skip_check_adv_addr));\n\t\tjson_object_object_add(json_data, \"strict_mode\",\n\t\t\tjson_object_new_int((int)vrrp->strict_mode));\n#ifdef _HAVE_VRRP_VMAC_\n\t\tjson_object_object_add(json_data, \"vmac_ifname\",\n\t\t\tjson_object_new_string(vrrp->vmac_ifname));\n#endif\n\t\t// Tracked interfaces are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->track_ifp)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_ifp); f; ELEMENT_NEXT(f)) {\n\t\t\t\tinterface_t *ifp = ELEMENT_DATA(f);\n\t\t\t\tjson_object_array_add(track_ifp,\n\t\t\t\t\tjson_object_new_string(ifp->ifname));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_ifp\", track_ifp);\n\n\t\t// Tracked scripts also\n\t\tif (!LIST_ISEMPTY(vrrp->track_script)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_script); f; ELEMENT_NEXT(f)) {\n\t\t\t\ttracked_sc_t *tsc = ELEMENT_DATA(f);\n\t\t\t\tvrrp_script_t *vscript = tsc->scr;\n\t\t\t\tjson_object_array_add(track_script,\n\t\t\t\t\tjson_object_new_string(cmd_str(&vscript->script)));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_script\", track_script);\n\n\t\tjson_object_object_add(json_data, \"ifp_ifname\",\n\t\t\tjson_object_new_string(vrrp->ifp->ifname));\n\t\tjson_object_object_add(json_data, \"master_priority\",\n\t\t\tjson_object_new_int(vrrp->master_priority));\n\t\tjson_object_object_add(json_data, \"last_transition\",\n\t\t\tjson_object_new_double(timeval_to_double(&vrrp->last_transition)));\n\t\tjson_object_object_add(json_data, \"garp_delay\",\n\t\t\tjson_object_new_double(vrrp->garp_delay / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"garp_refresh\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh.tv_sec));\n\t\tjson_object_object_add(json_data, \"garp_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_rep));\n\t\tjson_object_object_add(json_data, \"garp_refresh_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh_rep));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->garp_lower_prio_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_lower_prio_rep));\n\t\tjson_object_object_add(json_data, \"lower_prio_no_advert\",\n\t\t\tjson_object_new_int((int)vrrp->lower_prio_no_advert));\n\t\tjson_object_object_add(json_data, \"higher_prio_send_advert\",\n\t\t\tjson_object_new_int((int)vrrp->higher_prio_send_advert));\n\t\tjson_object_object_add(json_data, \"vrid\",\n\t\t\tjson_object_new_int(vrrp->vrid));\n\t\tjson_object_object_add(json_data, \"base_priority\",\n\t\t\tjson_object_new_int(vrrp->base_priority));\n\t\tjson_object_object_add(json_data, \"effective_priority\",\n\t\t\tjson_object_new_int(vrrp->effective_priority));\n\t\tjson_object_object_add(json_data, \"vipset\",\n\t\t\tjson_object_new_boolean(vrrp->vipset));\n\n\t\t//Virtual IPs are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->vip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *vip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(vip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(vips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vips\", vips);\n\n\t\t//External VIPs are also stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->evip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->evip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *evip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(evip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(evips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"evips\", evips);\n\n\t\tjson_object_object_add(json_data, \"promote_secondaries\",\n\t\t\tjson_object_new_boolean(vrrp->promote_secondaries));\n\n#ifdef _HAVE_FIB_ROUTING_\n\t\t// Dump vroutes\n\t\tif (!LIST_ISEMPTY(vrrp->vroutes)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vroutes); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_route_t *route = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(ROUTE_BUF_SIZE);\n\t\t\t\tformat_iproute(route, buf, ROUTE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vroutes,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vroutes\", vroutes);\n\n\t\t// Dump vrules\n\t\tif (!LIST_ISEMPTY(vrrp->vrules)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vrules); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_rule_t *rule = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(RULE_BUF_SIZE);\n\t\t\t\tformat_iprule(rule, buf, RULE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vrules,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vrules\", vrules);\n#endif\n\n\t\tjson_object_object_add(json_data, \"adver_int\",\n\t\t\tjson_object_new_double(vrrp->adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"master_adver_int\",\n\t\t\tjson_object_new_double(vrrp->master_adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"accept\",\n\t\t\tjson_object_new_int((int)vrrp->accept));\n\t\tjson_object_object_add(json_data, \"nopreempt\",\n\t\t\tjson_object_new_boolean(vrrp->nopreempt));\n\t\tjson_object_object_add(json_data, \"preempt_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->preempt_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"state\",\n\t\t\tjson_object_new_int(vrrp->state));\n\t\tjson_object_object_add(json_data, \"wantstate\",\n\t\t\tjson_object_new_int(vrrp->wantstate));\n\t\tjson_object_object_add(json_data, \"version\",\n\t\t\tjson_object_new_int(vrrp->version));\n\t\tif (vrrp->script_backup)\n\t\t\tjson_object_object_add(json_data, \"script_backup\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_backup)));\n\t\tif (vrrp->script_master)\n\t\t\tjson_object_object_add(json_data, \"script_master\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master)));\n\t\tif (vrrp->script_fault)\n\t\t\tjson_object_object_add(json_data, \"script_fault\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_fault)));\n\t\tif (vrrp->script_stop)\n\t\t\tjson_object_object_add(json_data, \"script_stop\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_stop)));\n\t\tif (vrrp->script)\n\t\t\tjson_object_object_add(json_data, \"script\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script)));\n\t\tif (vrrp->script_master_rx_lower_pri)\n\t\t\tjson_object_object_add(json_data, \"script_master_rx_lower_pri\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master_rx_lower_pri)));\n\t\tjson_object_object_add(json_data, \"smtp_alert\",\n\t\t\tjson_object_new_boolean(vrrp->smtp_alert));\n#ifdef _WITH_VRRP_AUTH_\n\t\tif (vrrp->auth_type) {\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(vrrp->auth_type));\n\n\t\t\tif (vrrp->auth_type != VRRP_AUTH_AH) {\n\t\t\t\tchar auth_data[sizeof(vrrp->auth_data) + 1];\n\t\t\t\tmemcpy(auth_data, vrrp->auth_data, sizeof(vrrp->auth_data));\n\t\t\t\tauth_data[sizeof(vrrp->auth_data)] = '\\0';\n\t\t\t\tjson_object_object_add(json_data, \"auth_data\",\n\t\t\t\t\tjson_object_new_string(auth_data));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(0));\n#endif\n\n\t\t// Dump stats to json\n\t\tjson_object_object_add(json_stats, \"advert_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_rcvd));\n\t\tjson_object_object_add(json_stats, \"advert_sent\",\n\t\t\tjson_object_new_int64(vrrp->stats->advert_sent));\n\t\tjson_object_object_add(json_stats, \"become_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->become_master));\n\t\tjson_object_object_add(json_stats, \"release_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->release_master));\n\t\tjson_object_object_add(json_stats, \"packet_len_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->packet_len_err));\n\t\tjson_object_object_add(json_stats, \"advert_interval_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_interval_err));\n\t\tjson_object_object_add(json_stats, \"ip_ttl_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->ip_ttl_err));\n\t\tjson_object_object_add(json_stats, \"invalid_type_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->invalid_type_rcvd));\n\t\tjson_object_object_add(json_stats, \"addr_list_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->addr_list_err));\n\t\tjson_object_object_add(json_stats, \"invalid_authtype\",\n\t\t\tjson_object_new_int64(vrrp->stats->invalid_authtype));\n#ifdef _WITH_VRRP_AUTH_\n\t\tjson_object_object_add(json_stats, \"authtype_mismatch\",\n\t\t\tjson_object_new_int64(vrrp->stats->authtype_mismatch));\n\t\tjson_object_object_add(json_stats, \"auth_failure\",\n\t\t\tjson_object_new_int64(vrrp->stats->auth_failure));\n#endif\n\t\tjson_object_object_add(json_stats, \"pri_zero_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_rcvd));\n\t\tjson_object_object_add(json_stats, \"pri_zero_sent\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_sent));\n\n\t\t// Add both json_data and json_stats to main instance_json\n\t\tjson_object_object_add(instance_json, \"data\", json_data);\n\t\tjson_object_object_add(instance_json, \"stats\", json_stats);\n\n\t\t// Add instance_json to main array\n\t\tjson_object_array_add(array, instance_json);\n\n\t}\n\tfprintf(file, \"%s\", json_object_to_json_string(array));\n\tfclose(file);\n}",
        "description": "keepalived 2.0.8 failed to verify the presence of symbolic links in file paths when writing data to temporary files during calls to PrintData or PrintStats. This oversight permitted local users to overwrite arbitrary files when the system setting fs.protected_symlinks is disabled, as illustrated by creating a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",
        "commit": "When opening files for write operations, it is crucial to verify that the target path is not a symbolic link. This vulnerability highlights a scenario where a non-privileged user could exploit a symbolic link to overwrite critical system files, such as `/etc/passwd`, by creating a symlink from `/etc/keepalvied.data` to `/etc/passwd`. To mitigate this risk, the solution involves setting the `O_NOFOLLOW` flag whenever a file is opened for writing. However, this change may introduce backward incompatibility in certain setups where the target file is accessed via a symbolic link. In such cases, administrators should adjust their configurations, for instance, by redirecting the actual data file to a temporary location and maintaining the symbolic link to this new location. Despite these adjustments, there is no straightforward way to prevent race conditions when checking if a path is a symbolic link before opening it for writing."
    },
    {
        "cwe": "CWE-1284",
        "func_name": "Samsung/crypto_bignum_allocate",
        "score": 0.7730267643928528,
        "func_before": "struct bignum *crypto_bignum_allocate(size_t size_bits)\n{\n\tsize_t sz = mpa_StaticVarSizeInU32(size_bits) *\tsizeof(uint32_t);\n\tstruct mpa_numbase_struct *bn = calloc(1, sz);\n\n\tif (!bn)\n\t\treturn NULL;\n\tbn->alloc = sz - MPA_NUMBASE_METADATA_SIZE_IN_U32 * sizeof(uint32_t);\n\treturn (struct bignum *)bn;\n}",
        "func_after": "struct bignum *crypto_bignum_allocate(size_t size_bits)\n{\n\tsize_t sz = mpa_StaticVarSizeInU32(size_bits) *\tsizeof(uint32_t);\n\t// struct mpa_numbase_struct *bn = calloc(1, sz);\n\tstruct mpa_numbase_struct *bn= TEE_Malloc(sz, TEE_MALLOC_FILL_ZERO);\n\tif (!bn)\n\t\treturn NULL;\n\tbn->alloc = sz - MPA_NUMBASE_METADATA_SIZE_IN_U32 * sizeof(uint32_t);\n\treturn (struct bignum *)bn;\n}",
        "description": "The function `tee_obj_free` in Samsung mTower through version 0.3.0 enables a trusted application to cause a Denial of Service (DoS) by calling the function `TEE_AllocateOperation` with a disrupted heap layout, which is associated with `utee_cryp_obj_alloc`.",
        "commit": "A vulnerability has been addressed in a software system, specifically identified by CVE-2022-40761."
    },
    {
        "cwe": "CWE-776",
        "func_name": "libexpat/externalParEntProcessor",
        "score": 0.747310996055603,
        "func_before": "static enum XML_Error PTRCALL\nexternalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: /* start == end */\n    default:\n      break;\n    }\n  }\n  /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.\n     However, when parsing an external subset, doProlog will not accept a BOM\n     as valid, and report a syntax error, so we have to skip the BOM\n  */\n  else if (tok == XML_TOK_BOM) {\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}",
        "func_after": "static enum XML_Error PTRCALL\nexternalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: /* start == end */\n    default:\n      break;\n    }\n  }\n  /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.\n     However, when parsing an external subset, doProlog will not accept a BOM\n     as valid, and report a syntax error, so we have to skip the BOM\n  */\n  else if (tok == XML_TOK_BOM) {\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);\n}",
        "description": "In versions of libexpat prior to 2.2.8, maliciously crafted XML input could cause the parser to prematurely transition from DTD parsing to document parsing. Subsequently, invoking functions such as XML_GetCurrentLineNumber or XML_GetCurrentColumnNumber led to a heap-based buffer over-read.",
        "commit": "output: \"Denial of service vulnerability due to improper handling of internal entities within the XML parsing process.\""
    }
]