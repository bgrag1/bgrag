[
    {
        "cwe": "CWE-254",
        "func_name": "android/impeg2d_dec_d_slice",
        "score": 0.7303292155265808,
        "func_before": "IMPEG2D_ERROR_CODES_T impeg2d_dec_d_slice(dec_state_t *ps_dec)\n{\n    UWORD32 i;\n    yuv_buf_t *ps_cur_frm_buf  = &ps_dec->s_cur_frm_buf;\n\n    stream_t   *ps_stream       = &ps_dec->s_bit_stream;\n    UWORD8   *pu1_vld_buf;\n\n    WORD16 i2_dc_diff;\n    UWORD32 u4_frame_width = ps_dec->u2_frame_width;\n    UWORD32 u4_frm_offset = 0;\n    if(ps_dec->u2_picture_structure != FRAME_PICTURE)\n    {\n        u4_frame_width <<= 1;\n        if(ps_dec->u2_picture_structure == BOTTOM_FIELD)\n        {\n            u4_frm_offset = ps_dec->u2_frame_width;\n        }\n    }\n\n    do\n    {\n\n        UWORD32 u4_x_offset, u4_y_offset;\n        UWORD32 u4_blk_pos;\n        WORD16 i2_dc_val;\n\n        UWORD32 u4_dst_x_offset     = u4_frm_offset + (ps_dec->u2_mb_x << 4);\n        UWORD32 u4_dst_y_offset     = (ps_dec->u2_mb_y << 4) * u4_frame_width;\n        UWORD8 *pu1_vld_buf8        = ps_cur_frm_buf->pu1_y + u4_dst_x_offset + u4_dst_y_offset;\n        UWORD32 u4_dst_wd           = u4_frame_width;\n        /*------------------------------------------------------------------*/\n        /* Discard the Macroblock stuffing in case of MPEG-1 stream         */\n        /*------------------------------------------------------------------*/\n        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)\n            impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n\n        /*------------------------------------------------------------------*/\n        /* Flush 2 bits from bitstream [MB_Type and MacroBlockAddrIncrement]*/\n        /*------------------------------------------------------------------*/\n        impeg2d_bit_stream_flush(ps_stream,1);\n\n        if(impeg2d_bit_stream_get(ps_stream, 1) != 0x01)\n        {\n            /* Ignore and continue decoding. */\n        }\n\n        /* Process LUMA blocks of the MB */\n        for(i = 0; i < NUM_LUMA_BLKS; ++i)\n        {\n\n            u4_x_offset    = gai2_impeg2_blk_x_off[i];\n            u4_y_offset    = gai2_impeg2_blk_y_off_frm[i] ;\n            u4_blk_pos     = (u4_y_offset * u4_dst_wd) + u4_x_offset;\n            pu1_vld_buf     = pu1_vld_buf8 + u4_blk_pos;\n\n            i2_dc_diff = impeg2d_get_luma_dc_diff(ps_stream);\n            i2_dc_val = ps_dec->u2_def_dc_pred[Y_LUMA] + i2_dc_diff;\n            ps_dec->u2_def_dc_pred[Y_LUMA] = i2_dc_val;\n            i2_dc_val = CLIP_U8(i2_dc_val);\n\n            ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n        }\n\n\n\n        /* Process U block of the MB */\n\n        u4_dst_x_offset                >>= 1;\n        u4_dst_y_offset                >>= 2;\n        u4_dst_wd                      >>= 1;\n        pu1_vld_buf                     = ps_cur_frm_buf->pu1_u + u4_dst_x_offset + u4_dst_y_offset;\n        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);\n        i2_dc_val                      = ps_dec->u2_def_dc_pred[U_CHROMA] + i2_dc_diff;\n        ps_dec->u2_def_dc_pred[U_CHROMA]    = i2_dc_val;\n        i2_dc_val = CLIP_U8(i2_dc_val);\n        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n\n\n        /* Process V block of the MB */\n\n        pu1_vld_buf                     = ps_cur_frm_buf->pu1_v + u4_dst_x_offset + u4_dst_y_offset;\n        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);\n        i2_dc_val                      = ps_dec->u2_def_dc_pred[V_CHROMA] + i2_dc_diff;\n        ps_dec->u2_def_dc_pred[V_CHROMA]    = i2_dc_val;\n        i2_dc_val = CLIP_U8(i2_dc_val);\n        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n\n        /* Common MB processing Steps */\n\n\n        ps_dec->u2_num_mbs_left--;\n        ps_dec->u2_mb_x++;\n\n        if(ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset)\n        {\n            return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;\n        }\n        else if (ps_dec->u2_mb_x == ps_dec->u2_num_horiz_mb)\n        {\n            ps_dec->u2_mb_x = 0;\n            ps_dec->u2_mb_y++;\n\n        }\n\n        /* Flush end of macro block */\n        impeg2d_bit_stream_flush(ps_stream,1);\n    }\n    while(ps_dec->u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,23) != 0x0);\n    return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}",
        "func_after": "IMPEG2D_ERROR_CODES_T impeg2d_dec_d_slice(dec_state_t *ps_dec)\n{\n    UWORD32 i;\n    yuv_buf_t *ps_cur_frm_buf  = &ps_dec->s_cur_frm_buf;\n\n    stream_t   *ps_stream       = &ps_dec->s_bit_stream;\n    UWORD8   *pu1_vld_buf;\n\n    WORD16 i2_dc_diff;\n    UWORD32 u4_frame_width = ps_dec->u2_frame_width;\n    UWORD32 u4_frm_offset = 0;\n    if(ps_dec->u2_picture_structure != FRAME_PICTURE)\n    {\n        u4_frame_width <<= 1;\n        if(ps_dec->u2_picture_structure == BOTTOM_FIELD)\n        {\n            u4_frm_offset = ps_dec->u2_frame_width;\n        }\n    }\n\n    do\n    {\n\n        UWORD32 u4_x_offset, u4_y_offset;\n        UWORD32 u4_blk_pos;\n        WORD16 i2_dc_val;\n\n        UWORD32 u4_dst_x_offset     = u4_frm_offset + (ps_dec->u2_mb_x << 4);\n        UWORD32 u4_dst_y_offset     = (ps_dec->u2_mb_y << 4) * u4_frame_width;\n        UWORD8 *pu1_vld_buf8        = ps_cur_frm_buf->pu1_y + u4_dst_x_offset + u4_dst_y_offset;\n        UWORD32 u4_dst_wd           = u4_frame_width;\n        /*------------------------------------------------------------------*/\n        /* Discard the Macroblock stuffing in case of MPEG-1 stream         */\n        /*------------------------------------------------------------------*/\n        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&\n                ps_stream->u4_offset < ps_stream->u4_max_offset)\n            impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n\n        /*------------------------------------------------------------------*/\n        /* Flush 2 bits from bitstream [MB_Type and MacroBlockAddrIncrement]*/\n        /*------------------------------------------------------------------*/\n        impeg2d_bit_stream_flush(ps_stream,1);\n\n        if(impeg2d_bit_stream_get(ps_stream, 1) != 0x01)\n        {\n            /* Ignore and continue decoding. */\n        }\n\n        /* Process LUMA blocks of the MB */\n        for(i = 0; i < NUM_LUMA_BLKS; ++i)\n        {\n\n            u4_x_offset    = gai2_impeg2_blk_x_off[i];\n            u4_y_offset    = gai2_impeg2_blk_y_off_frm[i] ;\n            u4_blk_pos     = (u4_y_offset * u4_dst_wd) + u4_x_offset;\n            pu1_vld_buf     = pu1_vld_buf8 + u4_blk_pos;\n\n            i2_dc_diff = impeg2d_get_luma_dc_diff(ps_stream);\n            i2_dc_val = ps_dec->u2_def_dc_pred[Y_LUMA] + i2_dc_diff;\n            ps_dec->u2_def_dc_pred[Y_LUMA] = i2_dc_val;\n            i2_dc_val = CLIP_U8(i2_dc_val);\n\n            ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n        }\n\n\n\n        /* Process U block of the MB */\n\n        u4_dst_x_offset                >>= 1;\n        u4_dst_y_offset                >>= 2;\n        u4_dst_wd                      >>= 1;\n        pu1_vld_buf                     = ps_cur_frm_buf->pu1_u + u4_dst_x_offset + u4_dst_y_offset;\n        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);\n        i2_dc_val                      = ps_dec->u2_def_dc_pred[U_CHROMA] + i2_dc_diff;\n        ps_dec->u2_def_dc_pred[U_CHROMA]    = i2_dc_val;\n        i2_dc_val = CLIP_U8(i2_dc_val);\n        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n\n\n        /* Process V block of the MB */\n\n        pu1_vld_buf                     = ps_cur_frm_buf->pu1_v + u4_dst_x_offset + u4_dst_y_offset;\n        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);\n        i2_dc_val                      = ps_dec->u2_def_dc_pred[V_CHROMA] + i2_dc_diff;\n        ps_dec->u2_def_dc_pred[V_CHROMA]    = i2_dc_val;\n        i2_dc_val = CLIP_U8(i2_dc_val);\n        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n\n        /* Common MB processing Steps */\n\n\n        ps_dec->u2_num_mbs_left--;\n        ps_dec->u2_mb_x++;\n\n        if(ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset)\n        {\n            return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;\n        }\n        else if (ps_dec->u2_mb_x == ps_dec->u2_num_horiz_mb)\n        {\n            ps_dec->u2_mb_x = 0;\n            ps_dec->u2_mb_y++;\n\n        }\n\n        /* Flush end of macro block */\n        impeg2d_bit_stream_flush(ps_stream,1);\n    }\n    while(ps_dec->u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,23) != 0x0);\n    return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}",
        "description": "libstagefright in Android versions prior to March 1, 2016, contains a vulnerability that allows attackers to gain unauthorized access to sensitive information by manipulating Bitstream data. This flaw enables attackers to potentially bypass an unspecified security mechanism, such as Signature or SignatureOrSystem access, through crafted input.",
        "commit": "Fixed bit stream access to ensure that reads do not exceed the allocated size."
    },
    {
        "cwe": "CWE-444",
        "func_name": "varnishcache/h2_vfp_body",
        "score": 0.7145032286643982,
        "func_before": "static enum vfp_status v_matchproto_(vfp_pull_f)\nh2_vfp_body(struct vfp_ctx *vc, struct vfp_entry *vfe, void *ptr, ssize_t *lp)\n{\n\tstruct h2_req *r2;\n\tstruct h2_sess *h2;\n\tunsigned l;\n\tenum vfp_status retval = VFP_OK;\n\n\tCHECK_OBJ_NOTNULL(vc, VFP_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(vfe, VFP_ENTRY_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, vfe->priv1, H2_REQ_MAGIC);\n\th2 = r2->h2sess;\n\n\tAN(ptr);\n\tAN(lp);\n\tl = *lp;\n\t*lp = 0;\n\n\tLck_Lock(&h2->sess->mtx);\n\tassert (r2->state == H2_S_OPEN);\n\tr2->cond = &vc->wrk->cond;\n\twhile (h2->mailcall != r2 && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(r2->cond, &h2->sess->mtx, 0));\n\tr2->cond = NULL;\n\tif (h2->error || r2->error) {\n\t\tretval = VFP_ERROR;\n\t} else {\n\t\tassert(h2->mailcall == r2);\n\t\tif (l > h2->rxf_len)\n\t\t\tl = h2->rxf_len;\n\t\tif (l > 0) {\n\t\t\tmemcpy(ptr, h2->rxf_data, l);\n\t\t\th2->rxf_data += l;\n\t\t\th2->rxf_len -= l;\n\t\t}\n\t\t*lp = l;\n\t\tif (h2->rxf_len > 0) {\n\t\t\t/* We ran out of storage: Have VFP call us\n\t\t\t * again with a fresh buffer */\n\t\t\tLck_Unlock(&h2->sess->mtx);\n\t\t\treturn (VFP_OK);\n\t\t}\n\t\tif (h2->rxf_len == 0) {\n\t\t\tif (h2->rxf_flags & H2FF_DATA_END_STREAM) {\n\t\t\t\tretval = VFP_END;\n\t\t\t\tr2->state = H2_S_CLOS_REM;\n\t\t\t}\n\t\t}\n\t\th2->mailcall = NULL;\n\t\tAZ(pthread_cond_signal(h2->cond));\n\t}\n\tLck_Unlock(&h2->sess->mtx);\n\treturn (retval);\n}",
        "func_after": "static enum vfp_status v_matchproto_(vfp_pull_f)\nh2_vfp_body(struct vfp_ctx *vc, struct vfp_entry *vfe, void *ptr, ssize_t *lp)\n{\n\tstruct h2_req *r2;\n\tstruct h2_sess *h2;\n\tunsigned l;\n\tenum vfp_status retval;\n\n\tCHECK_OBJ_NOTNULL(vc, VFP_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(vfe, VFP_ENTRY_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, vfe->priv1, H2_REQ_MAGIC);\n\th2 = r2->h2sess;\n\n\tAN(ptr);\n\tAN(lp);\n\tl = *lp;\n\t*lp = 0;\n\n\tLck_Lock(&h2->sess->mtx);\n\tr2->cond = &vc->wrk->cond;\n\twhile (h2->mailcall != r2 && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(r2->cond, &h2->sess->mtx, 0));\n\tr2->cond = NULL;\n\tif (h2->error || r2->error) {\n\t\tretval = VFP_ERROR;\n\t} else {\n\t\tassert(h2->mailcall == r2);\n\t\tif (l > h2->rxf_len)\n\t\t\tl = h2->rxf_len;\n\t\tif (l > 0) {\n\t\t\tmemcpy(ptr, h2->rxf_data, l);\n\t\t\th2->rxf_data += l;\n\t\t\th2->rxf_len -= l;\n\t\t}\n\t\t*lp = l;\n\t\tif (h2->rxf_len > 0) {\n\t\t\t/* We ran out of storage: Have VFP call us\n\t\t\t * again with a fresh buffer */\n\t\t\tLck_Unlock(&h2->sess->mtx);\n\t\t\treturn (VFP_OK);\n\t\t}\n\t\tif (h2->rxf_len == 0 && r2->state >= H2_S_CLOS_REM)\n\t\t\tretval = VFP_END;\n\t\telse\n\t\t\tretval = VFP_OK;\n\t\th2->mailcall = NULL;\n\t\tAZ(pthread_cond_signal(h2->cond));\n\t}\n\tLck_Unlock(&h2->sess->mtx);\n\treturn (retval);\n}",
        "description": "Varnish Cache, when HTTP/2 is enabled, is susceptible to request smuggling and VCL authorization bypass through the use of an excessively large Content-Length header in a POST request. This vulnerability impacts various versions of Varnish Enterprise and Varnish Cache, including specific releases prior to certain patch levels.",
        "commit": "When processing HTTP/2 (H/2) request bodies, ensure that the total size of received data frames aligns with the advertised content length. If the cumulative size of the data frames does not match the specified content length, the system should appropriately fail the request."
    },
    {
        "cwe": "CWE-125",
        "func_name": "perl5-dbi/dbd_st_prepare",
        "score": 0.7472902536392212,
        "func_before": "int\ndbd_st_prepare(\n  SV *sth,\n  imp_sth_t *imp_sth,\n  char *statement,\n  SV *attribs)\n{\n  int i;\n  SV **svp;\n  dTHX;\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n#if MYSQL_VERSION_ID < CALL_PLACEHOLDER_VERSION\n  char *str_ptr, *str_last_ptr;\n#if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION\n  int limit_flag=0;\n#endif\n#endif\n  int col_type, prepare_retval;\n  MYSQL_BIND *bind, *bind_end;\n  imp_sth_phb_t *fbind;\n#endif\n  D_imp_xxh(sth);\n  D_imp_dbh_from_sth;\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                 \"\\t-> dbd_st_prepare MYSQL_VERSION_ID %d, SQL statement: %s\\n\",\n                  MYSQL_VERSION_ID, statement);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n /* Set default value of 'mysql_server_prepare' attribute for sth from dbh */\n  imp_sth->use_server_side_prepare= imp_dbh->use_server_side_prepare;\n  if (attribs)\n  {\n    svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_server_prepare\", 20);\n    imp_sth->use_server_side_prepare = (svp) ?\n      SvTRUE(*svp) : imp_dbh->use_server_side_prepare;\n\n    svp = DBD_ATTRIB_GET_SVP(attribs, \"async\", 5);\n\n    if(svp && SvTRUE(*svp)) {\n#if MYSQL_ASYNC\n        imp_sth->is_async = TRUE;\n        imp_sth->use_server_side_prepare = FALSE;\n#else\n        do_error(sth, 2000,\n                 \"Async support was not built into this version of DBD::mysql\", \"HY000\");\n        return 0;\n#endif\n    }\n  }\n\n  imp_sth->fetch_done= 0;\n#endif\n\n  imp_sth->done_desc= 0;\n  imp_sth->result= NULL;\n  imp_sth->currow= 0;\n\n  /* Set default value of 'mysql_use_result' attribute for sth from dbh */\n  svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_use_result\", 16);\n  imp_sth->use_mysql_use_result= svp ?\n    SvTRUE(*svp) : imp_dbh->use_mysql_use_result;\n\n  for (i= 0; i < AV_ATTRIB_LAST; i++)\n    imp_sth->av_attr[i]= Nullav;\n\n  /*\n     Clean-up previous result set(s) for sth to prevent\n     'Commands out of sync' error \n  */\n  mysql_st_free_result_sets(sth, imp_sth);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION && MYSQL_VERSION_ID < CALL_PLACEHOLDER_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tuse_server_side_prepare set, check restrictions\\n\");\n    /*\n      This code is here because placeholder support is not implemented for\n      statements with :-\n      1. LIMIT < 5.0.7\n      2. CALL < 5.5.3 (Added support for out & inout parameters)\n      In these cases we have to disable server side prepared statements\n      NOTE: These checks could cause a false positive on statements which\n      include columns / table names that match \"call \" or \" limit \"\n    */ \n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n#if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION\n                    \"\\t\\tneed to test for LIMIT & CALL\\n\");\n#else\n                    \"\\t\\tneed to test for restrictions\\n\");\n#endif\n    str_last_ptr = statement + strlen(statement);\n    for (str_ptr= statement; str_ptr < str_last_ptr; str_ptr++)\n    {\n#if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION\n      /*\n        Place holders not supported in LIMIT's\n      */\n      if (limit_flag)\n      {\n        if (*str_ptr == '?')\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tLIMIT and ? found, set to use_server_side_prepare=0\\n\");\n          /* ... then we do not want to try server side prepare (use emulation) */\n          imp_sth->use_server_side_prepare= 0;\n          break;\n        }\n      }\n      else if (str_ptr < str_last_ptr - 6 &&\n          isspace(*(str_ptr + 0)) &&\n          tolower(*(str_ptr + 1)) == 'l' &&\n          tolower(*(str_ptr + 2)) == 'i' &&\n          tolower(*(str_ptr + 3)) == 'm' &&\n          tolower(*(str_ptr + 4)) == 'i' &&\n          tolower(*(str_ptr + 5)) == 't' &&\n          isspace(*(str_ptr + 6)))\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"LIMIT set limit flag to 1\\n\");\n        limit_flag= 1;\n      }\n#endif\n      /*\n        Place holders not supported in CALL's\n      */\n      if (str_ptr < str_last_ptr - 4 &&\n           tolower(*(str_ptr + 0)) == 'c' &&\n           tolower(*(str_ptr + 1)) == 'a' &&\n           tolower(*(str_ptr + 2)) == 'l' &&\n           tolower(*(str_ptr + 3)) == 'l' &&\n           isspace(*(str_ptr + 4)))\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Disable PS mode for CALL()\\n\");\n        imp_sth->use_server_side_prepare= 0;\n        break;\n      }\n    }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tuse_server_side_prepare set\\n\");\n    /* do we really need this? If we do, we should return, not just continue */\n    if (imp_sth->stmt)\n      fprintf(stderr,\n              \"ERROR: Trying to prepare new stmt while we have \\\n              already not closed one \\n\");\n\n    imp_sth->stmt= mysql_stmt_init(imp_dbh->pmysql);\n\n    if (! imp_sth->stmt)\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tERROR: Unable to return MYSQL_STMT structure \\\n                      from mysql_stmt_init(): ERROR NO: %d ERROR MSG:%s\\n\",\n                      mysql_errno(imp_dbh->pmysql),\n                      mysql_error(imp_dbh->pmysql));\n    }\n\n    prepare_retval= mysql_stmt_prepare(imp_sth->stmt,\n                                       statement,\n                                       strlen(statement));\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tmysql_stmt_prepare returned %d\\n\",\n                      prepare_retval);\n\n    if (prepare_retval)\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tmysql_stmt_prepare %d %s\\n\",\n                      mysql_stmt_errno(imp_sth->stmt),\n                      mysql_stmt_error(imp_sth->stmt));\n\n      /* For commands that are not supported by server side prepared statement\n         mechanism lets try to pass them through regular API */\n      if (mysql_stmt_errno(imp_sth->stmt) == ER_UNSUPPORTED_PS)\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tSETTING imp_sth->use_server_side_prepare to 0\\n\");\n        imp_sth->use_server_side_prepare= 0;\n      }\n      else\n      {\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                 mysql_stmt_error(imp_sth->stmt),\n                mysql_sqlstate(imp_dbh->pmysql));\n        mysql_stmt_close(imp_sth->stmt);\n        imp_sth->stmt= NULL;\n        return FALSE;\n      }\n    }\n    else\n    {\n      DBIc_NUM_PARAMS(imp_sth)= mysql_stmt_param_count(imp_sth->stmt);\n      /* mysql_stmt_param_count */\n\n      if (DBIc_NUM_PARAMS(imp_sth) > 0)\n      {\n        int has_statement_fields= imp_sth->stmt->fields != 0;\n        /* Allocate memory for bind variables */\n        imp_sth->bind=            alloc_bind(DBIc_NUM_PARAMS(imp_sth));\n        imp_sth->fbind=           alloc_fbind(DBIc_NUM_PARAMS(imp_sth));\n        imp_sth->has_been_bound=  0;\n\n        /* Initialize ph variables with  NULL values */\n        for (i= 0,\n             bind=      imp_sth->bind,\n             fbind=     imp_sth->fbind,\n             bind_end=  bind+DBIc_NUM_PARAMS(imp_sth);\n             bind < bind_end ;\n             bind++, fbind++, i++ )\n        {\n          /*\n            if this statement has a result set, field types will be\n            correctly identified. If there is no result set, such as\n            with an INSERT, fields will not be defined, and all buffer_type\n            will default to MYSQL_TYPE_VAR_STRING\n          */\n          col_type= (has_statement_fields ?\n                     imp_sth->stmt->fields[i].type : MYSQL_TYPE_STRING);\n\n          bind->buffer_type=  mysql_to_perl_type(col_type);\n\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tmysql_to_perl_type returned %d\\n\", col_type);\n\n          bind->buffer=       NULL;\n          bind->length=       &(fbind->length);\n          bind->is_null=      (char*) &(fbind->is_null);\n          fbind->is_null=     1;\n          fbind->length=      0;\n        }\n      }\n    }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  /* Count the number of parameters (driver, vs server-side) */\n  if (imp_sth->use_server_side_prepare == 0)\n    DBIc_NUM_PARAMS(imp_sth) = count_params((imp_xxh_t *)imp_dbh, aTHX_ statement,\n                                            imp_dbh->bind_comment_placeholders);\n#else\n  DBIc_NUM_PARAMS(imp_sth) = count_params((imp_xxh_t *)imp_dbh, aTHX_ statement,\n                                          imp_dbh->bind_comment_placeholders);\n#endif\n\n  /* Allocate memory for parameters */\n  imp_sth->params= alloc_param(DBIc_NUM_PARAMS(imp_sth));\n  DBIc_IMPSET_on(imp_sth);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_prepare\\n\");\n  return 1;\n}",
        "func_after": "int\ndbd_st_prepare(\n  SV *sth,\n  imp_sth_t *imp_sth,\n  char *statement,\n  SV *attribs)\n{\n  int i;\n  SV **svp;\n  dTHX;\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n#if MYSQL_VERSION_ID < CALL_PLACEHOLDER_VERSION\n  char *str_ptr, *str_last_ptr;\n#if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION\n  int limit_flag=0;\n#endif\n#endif\n  int prepare_retval;\n  MYSQL_BIND *bind, *bind_end;\n  imp_sth_phb_t *fbind;\n#endif\n  D_imp_xxh(sth);\n  D_imp_dbh_from_sth;\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                 \"\\t-> dbd_st_prepare MYSQL_VERSION_ID %d, SQL statement: %s\\n\",\n                  MYSQL_VERSION_ID, statement);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n /* Set default value of 'mysql_server_prepare' attribute for sth from dbh */\n  imp_sth->use_server_side_prepare= imp_dbh->use_server_side_prepare;\n  if (attribs)\n  {\n    svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_server_prepare\", 20);\n    imp_sth->use_server_side_prepare = (svp) ?\n      SvTRUE(*svp) : imp_dbh->use_server_side_prepare;\n\n    svp = DBD_ATTRIB_GET_SVP(attribs, \"async\", 5);\n\n    if(svp && SvTRUE(*svp)) {\n#if MYSQL_ASYNC\n        imp_sth->is_async = TRUE;\n        imp_sth->use_server_side_prepare = FALSE;\n#else\n        do_error(sth, 2000,\n                 \"Async support was not built into this version of DBD::mysql\", \"HY000\");\n        return 0;\n#endif\n    }\n  }\n\n  imp_sth->fetch_done= 0;\n#endif\n\n  imp_sth->done_desc= 0;\n  imp_sth->result= NULL;\n  imp_sth->currow= 0;\n\n  /* Set default value of 'mysql_use_result' attribute for sth from dbh */\n  svp= DBD_ATTRIB_GET_SVP(attribs, \"mysql_use_result\", 16);\n  imp_sth->use_mysql_use_result= svp ?\n    SvTRUE(*svp) : imp_dbh->use_mysql_use_result;\n\n  for (i= 0; i < AV_ATTRIB_LAST; i++)\n    imp_sth->av_attr[i]= Nullav;\n\n  /*\n     Clean-up previous result set(s) for sth to prevent\n     'Commands out of sync' error \n  */\n  mysql_st_free_result_sets(sth, imp_sth);\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION && MYSQL_VERSION_ID < CALL_PLACEHOLDER_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tuse_server_side_prepare set, check restrictions\\n\");\n    /*\n      This code is here because placeholder support is not implemented for\n      statements with :-\n      1. LIMIT < 5.0.7\n      2. CALL < 5.5.3 (Added support for out & inout parameters)\n      In these cases we have to disable server side prepared statements\n      NOTE: These checks could cause a false positive on statements which\n      include columns / table names that match \"call \" or \" limit \"\n    */ \n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n#if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION\n                    \"\\t\\tneed to test for LIMIT & CALL\\n\");\n#else\n                    \"\\t\\tneed to test for restrictions\\n\");\n#endif\n    str_last_ptr = statement + strlen(statement);\n    for (str_ptr= statement; str_ptr < str_last_ptr; str_ptr++)\n    {\n#if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION\n      /*\n        Place holders not supported in LIMIT's\n      */\n      if (limit_flag)\n      {\n        if (*str_ptr == '?')\n        {\n          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n            PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tLIMIT and ? found, set to use_server_side_prepare=0\\n\");\n          /* ... then we do not want to try server side prepare (use emulation) */\n          imp_sth->use_server_side_prepare= 0;\n          break;\n        }\n      }\n      else if (str_ptr < str_last_ptr - 6 &&\n          isspace(*(str_ptr + 0)) &&\n          tolower(*(str_ptr + 1)) == 'l' &&\n          tolower(*(str_ptr + 2)) == 'i' &&\n          tolower(*(str_ptr + 3)) == 'm' &&\n          tolower(*(str_ptr + 4)) == 'i' &&\n          tolower(*(str_ptr + 5)) == 't' &&\n          isspace(*(str_ptr + 6)))\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"LIMIT set limit flag to 1\\n\");\n        limit_flag= 1;\n      }\n#endif\n      /*\n        Place holders not supported in CALL's\n      */\n      if (str_ptr < str_last_ptr - 4 &&\n           tolower(*(str_ptr + 0)) == 'c' &&\n           tolower(*(str_ptr + 1)) == 'a' &&\n           tolower(*(str_ptr + 2)) == 'l' &&\n           tolower(*(str_ptr + 3)) == 'l' &&\n           isspace(*(str_ptr + 4)))\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"Disable PS mode for CALL()\\n\");\n        imp_sth->use_server_side_prepare= 0;\n        break;\n      }\n    }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  if (imp_sth->use_server_side_prepare)\n  {\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n      PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tuse_server_side_prepare set\\n\");\n    /* do we really need this? If we do, we should return, not just continue */\n    if (imp_sth->stmt)\n      fprintf(stderr,\n              \"ERROR: Trying to prepare new stmt while we have \\\n              already not closed one \\n\");\n\n    imp_sth->stmt= mysql_stmt_init(imp_dbh->pmysql);\n\n    if (! imp_sth->stmt)\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tERROR: Unable to return MYSQL_STMT structure \\\n                      from mysql_stmt_init(): ERROR NO: %d ERROR MSG:%s\\n\",\n                      mysql_errno(imp_dbh->pmysql),\n                      mysql_error(imp_dbh->pmysql));\n    }\n\n    prepare_retval= mysql_stmt_prepare(imp_sth->stmt,\n                                       statement,\n                                       strlen(statement));\n    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tmysql_stmt_prepare returned %d\\n\",\n                      prepare_retval);\n\n    if (prepare_retval)\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n        PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                      \"\\t\\tmysql_stmt_prepare %d %s\\n\",\n                      mysql_stmt_errno(imp_sth->stmt),\n                      mysql_stmt_error(imp_sth->stmt));\n\n      /* For commands that are not supported by server side prepared statement\n         mechanism lets try to pass them through regular API */\n      if (mysql_stmt_errno(imp_sth->stmt) == ER_UNSUPPORTED_PS)\n      {\n        if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n          PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n                    \"\\t\\tSETTING imp_sth->use_server_side_prepare to 0\\n\");\n        imp_sth->use_server_side_prepare= 0;\n      }\n      else\n      {\n        do_error(sth, mysql_stmt_errno(imp_sth->stmt),\n                 mysql_stmt_error(imp_sth->stmt),\n                mysql_sqlstate(imp_dbh->pmysql));\n        mysql_stmt_close(imp_sth->stmt);\n        imp_sth->stmt= NULL;\n        return FALSE;\n      }\n    }\n    else\n    {\n      DBIc_NUM_PARAMS(imp_sth)= mysql_stmt_param_count(imp_sth->stmt);\n      /* mysql_stmt_param_count */\n\n      if (DBIc_NUM_PARAMS(imp_sth) > 0)\n      {\n        /* Allocate memory for bind variables */\n        imp_sth->bind=            alloc_bind(DBIc_NUM_PARAMS(imp_sth));\n        imp_sth->fbind=           alloc_fbind(DBIc_NUM_PARAMS(imp_sth));\n        imp_sth->has_been_bound=  0;\n\n        /* Initialize ph variables with  NULL values */\n        for (i= 0,\n             bind=      imp_sth->bind,\n             fbind=     imp_sth->fbind,\n             bind_end=  bind+DBIc_NUM_PARAMS(imp_sth);\n             bind < bind_end ;\n             bind++, fbind++, i++ )\n        {\n          bind->buffer_type=  MYSQL_TYPE_STRING;\n          bind->buffer=       NULL;\n          bind->length=       &(fbind->length);\n          bind->is_null=      (char*) &(fbind->is_null);\n          fbind->is_null=     1;\n          fbind->length=      0;\n        }\n      }\n    }\n  }\n#endif\n\n#if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION\n  /* Count the number of parameters (driver, vs server-side) */\n  if (imp_sth->use_server_side_prepare == 0)\n    DBIc_NUM_PARAMS(imp_sth) = count_params((imp_xxh_t *)imp_dbh, aTHX_ statement,\n                                            imp_dbh->bind_comment_placeholders);\n#else\n  DBIc_NUM_PARAMS(imp_sth) = count_params((imp_xxh_t *)imp_dbh, aTHX_ statement,\n                                          imp_dbh->bind_comment_placeholders);\n#endif\n\n  /* Allocate memory for parameters */\n  imp_sth->params= alloc_param(DBIc_NUM_PARAMS(imp_sth));\n  DBIc_IMPSET_on(imp_sth);\n\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t<- dbd_st_prepare\\n\");\n  return 1;\n}",
        "description": "The DBD::mysql module for Perl, when utilizing server-side prepared statement support, permits attackers to induce a denial of service (out-of-bounds read) through vectors that include an unaligned number of placeholders in WHERE conditions and output fields in SELECT expressions.",
        "commit": "A fix was implemented for a previously identified vulnerability, CVE-2016-1249."
    },
    {
        "cwe": "CWE-416",
        "func_name": "torvalds/ipt_do_table",
        "score": 0.7521959543228149,
        "func_before": "unsigned int\nipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
        "func_after": "unsigned int\nipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = rcu_access_pointer(table->private);\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
        "description": "An issue was discovered in the netfilter component of the Linux kernel prior to version 5.10. This vulnerability involves a use-after-free condition in the packet processing context due to improper handling of per-CPU sequence counts during concurrent iptables rule replacements. This flaw could be exploited by users with the CAP_NET_ADMIN capability in an unprivileged namespace.",
        "commit": "When performing concurrent iptables rules replacement, the system checks the per-CPU sequence count after assigning new information. This sequence count is intended to synchronize with the packet path without using explicit locking. If packets are currently using the old table information, the sequence count is incremented to an odd value and then to an even value after processing. After assigning the new table information, a write memory barrier is executed to ensure all CPUs see the latest value. If the packet path starts with the old table information, the sequence counter remains odd, and the iptables replacement waits until the sequence count is even before freeing the old table information. However, if the CPU delays executing the new table information assignment and memory barrier, another CPU's packet path may still use the old table information. This delay can lead to a use-after-free error in the packet processing context, resulting in a kernel NULL pointer dereference. To fix this issue, either enforce instruction ordering after the new table information assignment or switch to RCU for synchronization."
    }
]