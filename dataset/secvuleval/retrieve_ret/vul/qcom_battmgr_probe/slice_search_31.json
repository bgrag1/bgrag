[
    {
        "cwe": "CWE-908",
        "func_name": "php/gdImageCreateFromXbm",
        "score": 0.7910262942314148,
        "func_before": "gdImagePtr gdImageCreateFromXbm(FILE * fd)\n{\n\tchar fline[MAX_XBM_LINE_SIZE];\n\tchar iname[MAX_XBM_LINE_SIZE];\n\tchar *type;\n\tint value;\n\tunsigned int width = 0, height = 0;\n\tint fail = 0;\n\tint max_bit = 0;\n\n\tgdImagePtr im;\n\tint bytes = 0, i;\n\tint bit, x = 0, y = 0;\n\tint ch;\n\tchar h[8];\n\tunsigned int b;\n\n\trewind(fd);\n\twhile (fgets(fline, MAX_XBM_LINE_SIZE, fd)) {\n\t\tfline[MAX_XBM_LINE_SIZE-1] = '\\0';\n\t\tif (strlen(fline) == MAX_XBM_LINE_SIZE-1) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (sscanf(fline, \"#define %s %d\", iname, &value) == 2) {\n\t\t\tif (!(type = strrchr(iname, '_'))) {\n\t\t\t\ttype = iname;\n\t\t\t} else {\n\t\t\t\ttype++;\n\t\t\t}\n\n\t\t\tif (!strcmp(\"width\", type)) {\n\t\t\t\twidth = (unsigned int) value;\n\t\t\t}\n\t\t\tif (!strcmp(\"height\", type)) {\n\t\t\t\theight = (unsigned int) value;\n\t\t\t}\n\t\t} else {\n\t\t\tif ( sscanf(fline, \"static unsigned char %s = {\", iname) == 1\n\t\t\t  || sscanf(fline, \"static char %s = {\", iname) == 1)\n\t\t\t{\n\t\t\t\tmax_bit = 128;\n\t\t\t} else if (sscanf(fline, \"static unsigned short %s = {\", iname) == 1\n\t\t\t\t\t|| sscanf(fline, \"static short %s = {\", iname) == 1)\n\t\t\t{\n\t\t\t\tmax_bit = 32768;\n\t\t\t}\n\t\t\tif (max_bit) {\n\t\t\t\tbytes = (width + 7) / 8 * height;\n\t\t\t\tif (!bytes) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (!(type = strrchr(iname, '_'))) {\n\t\t\t\t\ttype = iname;\n\t\t\t\t} else {\n\t\t\t\t\ttype++;\n\t\t\t\t}\n\t\t\t\tif (!strcmp(\"bits[]\", type)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n \t\t}\n\t}\n\tif (!bytes || !max_bit) {\n\t\treturn 0;\n\t}\n\n\tif(!(im = gdImageCreate(width, height))) {\n\t\treturn 0;\n\t}\n\tgdImageColorAllocate(im, 255, 255, 255);\n\tgdImageColorAllocate(im, 0, 0, 0);\n\th[2] = '\\0';\n\th[4] = '\\0';\n\tfor (i = 0; i < bytes; i++) {\n\t\twhile (1) {\n\t\t\tif ((ch=getc(fd)) == EOF) {\n\t\t\t\tfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ch == 'x') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (fail) {\n\t\t\tbreak;\n\t\t}\n\t\t/* Get hex value */\n\t\tif ((ch=getc(fd)) == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\th[0] = ch;\n\t\tif ((ch=getc(fd)) == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\th[1] = ch;\n\t\tif (max_bit == 32768) {\n\t\t\tif ((ch=getc(fd)) == EOF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\th[2] = ch;\n\t\t\tif ((ch=getc(fd)) == EOF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\th[3] = ch;\n\t\t}\n\t\tsscanf(h, \"%x\", &b);\n\t\tfor (bit = 1; bit <= max_bit; bit = bit << 1) {\n\t\t\tgdImageSetPixel(im, x++, y, (b & bit) ? 1 : 0);\n\t\t\tif (x == im->sx) {\n\t\t\t\tx = 0;\n\t\t\t\ty++;\n\t\t\t\tif (y == im->sy) {\n\t\t\t\t\treturn im;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tphp_gd_error(\"EOF before image was complete\");\n\tgdImageDestroy(im);\n\treturn 0;\n}",
        "func_after": "gdImagePtr gdImageCreateFromXbm(FILE * fd)\n{\n\tchar fline[MAX_XBM_LINE_SIZE];\n\tchar iname[MAX_XBM_LINE_SIZE];\n\tchar *type;\n\tint value;\n\tunsigned int width = 0, height = 0;\n\tint fail = 0;\n\tint max_bit = 0;\n\n\tgdImagePtr im;\n\tint bytes = 0, i;\n\tint bit, x = 0, y = 0;\n\tint ch;\n\tchar h[8];\n\tunsigned int b;\n\n\trewind(fd);\n\twhile (fgets(fline, MAX_XBM_LINE_SIZE, fd)) {\n\t\tfline[MAX_XBM_LINE_SIZE-1] = '\\0';\n\t\tif (strlen(fline) == MAX_XBM_LINE_SIZE-1) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (sscanf(fline, \"#define %s %d\", iname, &value) == 2) {\n\t\t\tif (!(type = strrchr(iname, '_'))) {\n\t\t\t\ttype = iname;\n\t\t\t} else {\n\t\t\t\ttype++;\n\t\t\t}\n\n\t\t\tif (!strcmp(\"width\", type)) {\n\t\t\t\twidth = (unsigned int) value;\n\t\t\t}\n\t\t\tif (!strcmp(\"height\", type)) {\n\t\t\t\theight = (unsigned int) value;\n\t\t\t}\n\t\t} else {\n\t\t\tif ( sscanf(fline, \"static unsigned char %s = {\", iname) == 1\n\t\t\t  || sscanf(fline, \"static char %s = {\", iname) == 1)\n\t\t\t{\n\t\t\t\tmax_bit = 128;\n\t\t\t} else if (sscanf(fline, \"static unsigned short %s = {\", iname) == 1\n\t\t\t\t\t|| sscanf(fline, \"static short %s = {\", iname) == 1)\n\t\t\t{\n\t\t\t\tmax_bit = 32768;\n\t\t\t}\n\t\t\tif (max_bit) {\n\t\t\t\tbytes = (width + 7) / 8 * height;\n\t\t\t\tif (!bytes) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (!(type = strrchr(iname, '_'))) {\n\t\t\t\t\ttype = iname;\n\t\t\t\t} else {\n\t\t\t\t\ttype++;\n\t\t\t\t}\n\t\t\t\tif (!strcmp(\"bits[]\", type)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n \t\t}\n\t}\n\tif (!bytes || !max_bit) {\n\t\treturn 0;\n\t}\n\n\tif(!(im = gdImageCreate(width, height))) {\n\t\treturn 0;\n\t}\n\tgdImageColorAllocate(im, 255, 255, 255);\n\tgdImageColorAllocate(im, 0, 0, 0);\n\th[2] = '\\0';\n\th[4] = '\\0';\n\tfor (i = 0; i < bytes; i++) {\n\t\twhile (1) {\n\t\t\tif ((ch=getc(fd)) == EOF) {\n\t\t\t\tfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ch == 'x') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (fail) {\n\t\t\tbreak;\n\t\t}\n\t\t/* Get hex value */\n\t\tif ((ch=getc(fd)) == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\th[0] = ch;\n\t\tif ((ch=getc(fd)) == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\th[1] = ch;\n\t\tif (max_bit == 32768) {\n\t\t\tif ((ch=getc(fd)) == EOF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\th[2] = ch;\n\t\t\tif ((ch=getc(fd)) == EOF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\th[3] = ch;\n\t\t}\n\t\tif (sscanf(h, \"%x\", &b) != 1) {\n\t\t\tphp_gd_error(\"invalid XBM\");\n\t\t\tgdImageDestroy(im);\n\t\t\treturn 0;\n\t\t}\n\t\tfor (bit = 1; bit <= max_bit; bit = bit << 1) {\n\t\t\tgdImageSetPixel(im, x++, y, (b & bit) ? 1 : 0);\n\t\t\tif (x == im->sx) {\n\t\t\t\tx = 0;\n\t\t\t\ty++;\n\t\t\t\tif (y == im->sy) {\n\t\t\t\t\treturn im;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tphp_gd_error(\"EOF before image was complete\");\n\tgdImageDestroy(im);\n\treturn 0;\n}",
        "description": "When utilizing the gdImageCreateFromXbm() function within the GD Graphics Library (LibGD) version 2.2.5, as employed in the PHP GD extension across various PHP versions, it is feasible to provide data that results in the function accessing an uninitialized variable. This scenario can potentially expose stack contents that were previously left by other code, leading to information disclosure vulnerabilities.",
        "commit": "It was discovered that the `gdImageCreateFromXbm` function contains an uninitialized read issue. To address this, it is essential to verify that the `sscanf()` function successfully reads a hexadecimal value and to terminate the process otherwise."
    },
    {
        "cwe": "CWE-824",
        "func_name": "gerbv/gerbv_open_image",
        "score": 0.8002496361732483,
        "func_before": "int\ngerbv_open_image(gerbv_project_t *gerbvProject, gchar const* filename, int idx, int reload,\n\t\tgerbv_HID_Attribute *fattr, int n_fattr, gboolean forceLoadFile)\n{\n    gerb_file_t *fd;\n    gerbv_image_t *parsed_image = NULL, *parsed_image2 = NULL;\n    gint retv = -1;\n    gboolean isPnpFile = FALSE, foundBinary;\n    gerbv_HID_Attribute *attr_list = NULL;\n    int n_attr = 0;\n    /* If we're reloading, we'll pass in our file format attribute list\n     * since this is our hook for letting the user override the fileformat.\n     */\n    if (reload)\n\t{\n\t    /* We're reloading so use the attribute list in memory */\n\t    attr_list =  gerbvProject->file[idx]->image->info->attr_list;\n\t    n_attr =  gerbvProject->file[idx]->image->info->n_attr;\n\t}\n    else\n\t{\n\t    /* We're not reloading so use the attribute list read from the \n\t     * project file if given or NULL otherwise.\n\t     */\n\t    attr_list = fattr;\n\t    n_attr = n_fattr;\n\t}\n    /* if we don't have enough spots, then grow the file list by 2 to account for the possible \n       loading of two images for PNP files */\n    if ((idx+1) >= gerbvProject->max_files) {\n\tgerbvProject->file = g_renew (gerbv_fileinfo_t *,\n\t\t\tgerbvProject->file, gerbvProject->max_files + 2);\n\n\tgerbvProject->file[gerbvProject->max_files] = NULL;\n\tgerbvProject->file[gerbvProject->max_files+1] = NULL;\n\tgerbvProject->max_files += 2;\n    }\n    \n    dprintf(\"In open_image, about to try opening filename = %s\\n\", filename);\n    \n    fd = gerb_fopen(filename);\n    if (fd == NULL) {\n\tGERB_COMPILE_ERROR(_(\"Trying to open \\\"%s\\\": %s\"),\n\t\t\tfilename, strerror(errno));\n\treturn -1;\n    }\n\n    /* Store filename info fd for further use */\n    fd->filename = g_strdup(filename);\n    \n    dprintf(\"In open_image, successfully opened file.  Now check its type....\\n\");\n    /* Here's where we decide what file type we have */\n    /* Note: if the file has some invalid characters in it but still appears to\n       be a valid file, we check with the user if he wants to continue (only\n       if user opens the layer from the menu...if from the command line, we go\n       ahead and try to load it anyways) */\n\n    if (gerber_is_rs274x_p(fd, &foundBinary)) {\n\tdprintf(\"Found RS-274X file\\n\");\n\tif (!foundBinary || forceLoadFile) {\n\t\t/* figure out the directory path in case parse_gerb needs to\n\t\t * load any include files */\n\t\tgchar *currentLoadDirectory = g_path_get_dirname (filename);\n\t\tparsed_image = parse_gerb(fd, currentLoadDirectory);\n\t\tg_free (currentLoadDirectory);\n\t}\n    } else if(drill_file_p(fd, &foundBinary)) {\n\tdprintf(\"Found drill file\\n\");\n\tif (!foundBinary || forceLoadFile)\n\t    parsed_image = parse_drillfile(fd, attr_list, n_attr, reload);\n\t\n    } else if (pick_and_place_check_file_type(fd, &foundBinary)) {\n\tdprintf(\"Found pick-n-place file\\n\");\n\tif (!foundBinary || forceLoadFile) {\n\t\tif (!reload) {\n\t\t\tpick_and_place_parse_file_to_images(fd, &parsed_image, &parsed_image2);\n\t\t} else {\n\t\t\tswitch (gerbvProject->file[idx]->image->layertype) {\n\t\t\tcase GERBV_LAYERTYPE_PICKANDPLACE_TOP:\n\t\t\t\t/* Non NULL pointer is used as \"not to reload\" mark */\n\t\t\t\tparsed_image2 = (void *)!NULL;\n\t\t\t\tpick_and_place_parse_file_to_images(fd, &parsed_image, &parsed_image2);\n\t\t\t\tparsed_image2 = NULL;\n\t\t\t\tbreak;\n\t\t\tcase GERBV_LAYERTYPE_PICKANDPLACE_BOT:\n\t\t\t\t/* Non NULL pointer is used as \"not to reload\" mark */\n\t\t\t\tparsed_image2 = (void *)!NULL;\n\t\t\t\tpick_and_place_parse_file_to_images(fd, &parsed_image2, &parsed_image);\n\t\t\t\tparsed_image2 = NULL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tGERB_COMPILE_ERROR(_(\"%s: unknown pick-and-place board side to reload\"), filename);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tisPnpFile = TRUE;\n\t}\n    } else if (gerber_is_rs274d_p(fd)) {\n\tgchar *str = g_strdup_printf(_(\"Most likely found a RS-274D file \"\n\t\t\t\"\\\"%s\\\" ... trying to open anyways\\n\"), filename);\n\tdprintf(\"%s\", str);\n\tg_warning(\"%s\", str);\n\tg_free (str);\n\n\tif (!foundBinary || forceLoadFile) {\n\t\t/* figure out the directory path in case parse_gerb needs to\n\t\t * load any include files */\n\t\tgchar *currentLoadDirectory = g_path_get_dirname (filename);\n\t\tparsed_image = parse_gerb(fd, currentLoadDirectory);\n\t\tg_free (currentLoadDirectory);\n\t}\n    } else {\n\t/* This is not a known file */\n\tdprintf(\"Unknown filetype\");\n\tGERB_COMPILE_ERROR(_(\"%s: Unknown file type.\"), filename);\n\tparsed_image = NULL;\n    }\n    \n    g_free(fd->filename);\n    gerb_fclose(fd);\n    if (parsed_image == NULL) {\n\treturn -1;\n    }\n    \n    if (parsed_image) {\n\t/* strip the filename to the base */\n\tgchar *baseName = g_path_get_basename (filename);\n\tgchar *displayedName;\n\tif (isPnpFile)\n\t\tdisplayedName = g_strconcat (baseName, _(\" (top)\"), NULL);\n\telse\n\t\tdisplayedName = g_strdup (baseName);\n    \tretv = gerbv_add_parsed_image_to_project (gerbvProject, parsed_image, filename, displayedName, idx, reload);\n    \tg_free (baseName);\n    \tg_free (displayedName);\n    }\n\n    /* Set layer_dirty flag to FALSE */\n    gerbvProject->file[idx]->layer_dirty = FALSE;\n\n    /* for PNP place files, we may need to add a second image for the other\n       board side */\n    if (parsed_image2) {\n      /* strip the filename to the base */\n\tgchar *baseName = g_path_get_basename (filename);\n\tgchar *displayedName;\n\tdisplayedName = g_strconcat (baseName, _(\" (bottom)\"), NULL);\n    \tretv = gerbv_add_parsed_image_to_project (gerbvProject, parsed_image2, filename, displayedName, idx + 1, reload);\n    \tg_free (baseName);\n    \tg_free (displayedName);\n    }\n\n    return retv;\n}",
        "func_after": "int\ngerbv_open_image(gerbv_project_t *gerbvProject, gchar const* filename, int idx, int reload,\n\t\tgerbv_HID_Attribute *fattr, int n_fattr, gboolean forceLoadFile)\n{\n    gerb_file_t *fd;\n    gerbv_image_t *parsed_image = NULL, *parsed_image2 = NULL;\n    gint retv = -1;\n    gboolean isPnpFile = FALSE, foundBinary;\n    gerbv_HID_Attribute *attr_list = NULL;\n    int n_attr = 0;\n    /* If we're reloading, we'll pass in our file format attribute list\n     * since this is our hook for letting the user override the fileformat.\n     */\n    if (reload)\n\t{\n\t    /* We're reloading so use the attribute list in memory */\n\t    attr_list =  gerbvProject->file[idx]->image->info->attr_list;\n\t    n_attr =  gerbvProject->file[idx]->image->info->n_attr;\n\t}\n    else\n\t{\n\t    /* We're not reloading so use the attribute list read from the \n\t     * project file if given or NULL otherwise.\n\t     */\n\t    attr_list = fattr;\n\t    n_attr = n_fattr;\n\t}\n    /* if we don't have enough spots, then grow the file list by 2 to account for the possible \n       loading of two images for PNP files */\n    if ((idx+1) >= gerbvProject->max_files) {\n\tgerbvProject->file = g_renew (gerbv_fileinfo_t *,\n\t\t\tgerbvProject->file, gerbvProject->max_files + 2);\n\n\tgerbvProject->file[gerbvProject->max_files] = NULL;\n\tgerbvProject->file[gerbvProject->max_files+1] = NULL;\n\tgerbvProject->max_files += 2;\n    }\n    \n    dprintf(\"In open_image, about to try opening filename = %s\\n\", filename);\n    \n    fd = gerb_fopen(filename);\n    if (fd == NULL) {\n\tGERB_COMPILE_ERROR(_(\"Trying to open \\\"%s\\\": %s\"),\n\t\t\tfilename, strerror(errno));\n\treturn -1;\n    }\n\n    dprintf(\"In open_image, successfully opened file.  Now check its type....\\n\");\n    /* Here's where we decide what file type we have */\n    /* Note: if the file has some invalid characters in it but still appears to\n       be a valid file, we check with the user if he wants to continue (only\n       if user opens the layer from the menu...if from the command line, we go\n       ahead and try to load it anyways) */\n\n    if (gerber_is_rs274x_p(fd, &foundBinary)) {\n\tdprintf(\"Found RS-274X file\\n\");\n\tif (!foundBinary || forceLoadFile) {\n\t\t/* figure out the directory path in case parse_gerb needs to\n\t\t * load any include files */\n\t\tgchar *currentLoadDirectory = g_path_get_dirname (filename);\n\t\tparsed_image = parse_gerb(fd, currentLoadDirectory);\n\t\tg_free (currentLoadDirectory);\n\t}\n    } else if(drill_file_p(fd, &foundBinary)) {\n\tdprintf(\"Found drill file\\n\");\n\tif (!foundBinary || forceLoadFile)\n\t    parsed_image = parse_drillfile(fd, attr_list, n_attr, reload);\n\t\n    } else if (pick_and_place_check_file_type(fd, &foundBinary)) {\n\tdprintf(\"Found pick-n-place file\\n\");\n\tif (!foundBinary || forceLoadFile) {\n\t\tif (!reload) {\n\t\t\tpick_and_place_parse_file_to_images(fd, &parsed_image, &parsed_image2);\n\t\t} else {\n\t\t\tswitch (gerbvProject->file[idx]->image->layertype) {\n\t\t\tcase GERBV_LAYERTYPE_PICKANDPLACE_TOP:\n\t\t\t\t/* Non NULL pointer is used as \"not to reload\" mark */\n\t\t\t\tparsed_image2 = (void *)!NULL;\n\t\t\t\tpick_and_place_parse_file_to_images(fd, &parsed_image, &parsed_image2);\n\t\t\t\tparsed_image2 = NULL;\n\t\t\t\tbreak;\n\t\t\tcase GERBV_LAYERTYPE_PICKANDPLACE_BOT:\n\t\t\t\t/* Non NULL pointer is used as \"not to reload\" mark */\n\t\t\t\tparsed_image2 = (void *)!NULL;\n\t\t\t\tpick_and_place_parse_file_to_images(fd, &parsed_image2, &parsed_image);\n\t\t\t\tparsed_image2 = NULL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tGERB_COMPILE_ERROR(_(\"%s: unknown pick-and-place board side to reload\"), filename);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tisPnpFile = TRUE;\n\t}\n    } else if (gerber_is_rs274d_p(fd)) {\n\tgchar *str = g_strdup_printf(_(\"Most likely found a RS-274D file \"\n\t\t\t\"\\\"%s\\\" ... trying to open anyways\\n\"), filename);\n\tdprintf(\"%s\", str);\n\tg_warning(\"%s\", str);\n\tg_free (str);\n\n\tif (!foundBinary || forceLoadFile) {\n\t\t/* figure out the directory path in case parse_gerb needs to\n\t\t * load any include files */\n\t\tgchar *currentLoadDirectory = g_path_get_dirname (filename);\n\t\tparsed_image = parse_gerb(fd, currentLoadDirectory);\n\t\tg_free (currentLoadDirectory);\n\t}\n    } else {\n\t/* This is not a known file */\n\tdprintf(\"Unknown filetype\");\n\tGERB_COMPILE_ERROR(_(\"%s: Unknown file type.\"), filename);\n\tparsed_image = NULL;\n    }\n    \n    gerb_fclose(fd);\n    if (parsed_image == NULL) {\n\treturn -1;\n    }\n    \n    if (parsed_image) {\n\t/* strip the filename to the base */\n\tgchar *baseName = g_path_get_basename (filename);\n\tgchar *displayedName;\n\tif (isPnpFile)\n\t\tdisplayedName = g_strconcat (baseName, _(\" (top)\"), NULL);\n\telse\n\t\tdisplayedName = g_strdup (baseName);\n    \tretv = gerbv_add_parsed_image_to_project (gerbvProject, parsed_image, filename, displayedName, idx, reload);\n    \tg_free (baseName);\n    \tg_free (displayedName);\n    }\n\n    /* Set layer_dirty flag to FALSE */\n    gerbvProject->file[idx]->layer_dirty = FALSE;\n\n    /* for PNP place files, we may need to add a second image for the other\n       board side */\n    if (parsed_image2) {\n      /* strip the filename to the base */\n\tgchar *baseName = g_path_get_basename (filename);\n\tgchar *displayedName;\n\tdisplayedName = g_strconcat (baseName, _(\" (bottom)\"), NULL);\n    \tretv = gerbv_add_parsed_image_to_project (gerbvProject, parsed_image2, filename, displayedName, idx + 1, reload);\n    \tg_free (baseName);\n    \tg_free (displayedName);\n    }\n\n    return retv;\n}",
        "description": "A user with control over file input to Gerbv, between versions 2.4.0 and 2.10.0, can trigger a crash and achieve a denial-of-service condition by providing a specially crafted Gerber RS-274X file.",
        "commit": "An out-of-bounds memory access vulnerability related to filename handling was identified. To address this, all filename allocation and deallocation have been centralized within the `gerb_fopen` and `gerb_fclose` functions, eliminating the need for the caller to manage these operations. Additionally, a previously allocated `includeFilename` was not being properly freed, which has now been corrected. Unit tests have been added to ensure proper memory management using Valgrind."
    },
    {
        "cwe": "CWE-476",
        "func_name": "ImageMagick/LoadOpenCLDevices",
        "score": 0.8008522987365723,
        "func_before": "static void LoadOpenCLDevices(MagickCLEnv clEnv)\n{\n  cl_context_properties\n    properties[3];\n\n  cl_device_id\n    *devices;\n\n  cl_int\n    status;\n\n  cl_platform_id\n    *platforms;\n\n  cl_uint\n    i,\n    j,\n    next,\n    number_devices,\n    number_platforms;\n\n  size_t\n    length;\n\n  number_platforms=0;\n  if (openCL_library->clGetPlatformIDs(0,NULL,&number_platforms) != CL_SUCCESS)\n    return;\n  if (number_platforms == 0)\n    return;\n  platforms=(cl_platform_id *) AcquireMagickMemory(number_platforms*\n    sizeof(cl_platform_id));\n  if (platforms == (cl_platform_id *) NULL)\n    return;\n  if (openCL_library->clGetPlatformIDs(number_platforms,platforms,NULL) != CL_SUCCESS)\n    {\n       platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n       return;\n    }\n  for (i = 0; i < number_platforms; i++)\n  {\n    number_devices=GetOpenCLDeviceCount(clEnv,platforms[i]);\n    if (number_devices == 0)\n      platforms[i]=(cl_platform_id) NULL;\n    else\n      clEnv->number_devices+=number_devices;\n  }\n  if (clEnv->number_devices == 0)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  clEnv->devices=(MagickCLDevice *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(MagickCLDevice));\n  if (clEnv->devices == (MagickCLDevice *) NULL)\n    {\n      RelinquishMagickCLDevices(clEnv);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  (void) ResetMagickMemory(clEnv->devices,0,clEnv->number_devices*\n    sizeof(MagickCLDevice));\n  devices=(cl_device_id *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(cl_device_id));\n  if (devices == (cl_device_id *) NULL)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  clEnv->number_contexts=(size_t) number_platforms;\n  clEnv->contexts=(cl_context *) AcquireQuantumMemory(clEnv->number_contexts,\n    sizeof(cl_context));\n  if (clEnv->contexts == (cl_context *) NULL)\n    {\n      devices=(cl_device_id *) RelinquishMagickMemory(devices);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  next=0;\n  for (i = 0; i < number_platforms; i++)\n  {\n    if (platforms[i] == (cl_platform_id) NULL)\n      continue;\n\n    status=clEnv->library->clGetDeviceIDs(platforms[i],CL_DEVICE_TYPE_CPU | \n      CL_DEVICE_TYPE_GPU,(cl_uint) clEnv->number_devices,devices,&number_devices);\n    if (status != CL_SUCCESS)\n      continue;\n\n    properties[0]=CL_CONTEXT_PLATFORM;\n    properties[1]=(cl_context_properties) platforms[i];\n    properties[2]=0;\n    clEnv->contexts[i]=openCL_library->clCreateContext(properties,number_devices,\n      devices,NULL,NULL,&status);\n    if (status != CL_SUCCESS)\n      continue;\n\n    for (j = 0; j < number_devices; j++,next++)\n    {\n      MagickCLDevice\n        device;\n\n      device=AcquireMagickCLDevice();\n      if (device == (MagickCLDevice) NULL)\n        break;\n\n      device->context=clEnv->contexts[i];\n      device->deviceID=devices[j];\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,0,NULL,\n        &length);\n      device->platform_name=AcquireQuantumMemory(length,\n        sizeof(*device->platform_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,length,\n        device->platform_name,NULL);\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,0,NULL,\n        &length);\n      device->vendor_name=AcquireQuantumMemory(length,\n        sizeof(*device->vendor_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,length,\n        device->vendor_name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,0,NULL,\n        &length);\n      device->name=AcquireQuantumMemory(length,sizeof(*device->name));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,length,\n        device->name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,0,NULL,\n        &length);\n      device->version=AcquireQuantumMemory(length,sizeof(*device->version));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,length,\n        device->version,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_CLOCK_FREQUENCY,\n        sizeof(cl_uint),&device->max_clock_frequency,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_COMPUTE_UNITS,\n        sizeof(cl_uint),&device->max_compute_units,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_TYPE,\n        sizeof(cl_device_type),&device->type,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_LOCAL_MEM_SIZE,\n        sizeof(cl_ulong),&device->local_memory_size,NULL);\n\n      clEnv->devices[next]=device;\n    }\n  }\n  if (next != clEnv->number_devices)\n    RelinquishMagickCLDevices(clEnv);\n  platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n  devices=(cl_device_id *) RelinquishMagickMemory(devices);\n}",
        "func_after": "static void LoadOpenCLDevices(MagickCLEnv clEnv)\n{\n  cl_context_properties\n    properties[3];\n\n  cl_device_id\n    *devices;\n\n  cl_int\n    status;\n\n  cl_platform_id\n    *platforms;\n\n  cl_uint\n    i,\n    j,\n    next,\n    number_devices,\n    number_platforms;\n\n  size_t\n    length;\n\n  number_platforms=0;\n  if (openCL_library->clGetPlatformIDs(0,NULL,&number_platforms) != CL_SUCCESS)\n    return;\n  if (number_platforms == 0)\n    return;\n  platforms=(cl_platform_id *) AcquireMagickMemory(number_platforms*\n    sizeof(cl_platform_id));\n  if (platforms == (cl_platform_id *) NULL)\n    return;\n  if (openCL_library->clGetPlatformIDs(number_platforms,platforms,NULL) != CL_SUCCESS)\n    {\n       platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n       return;\n    }\n  for (i = 0; i < number_platforms; i++)\n  {\n    number_devices=GetOpenCLDeviceCount(clEnv,platforms[i]);\n    if (number_devices == 0)\n      platforms[i]=(cl_platform_id) NULL;\n    else\n      clEnv->number_devices+=number_devices;\n  }\n  if (clEnv->number_devices == 0)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  clEnv->devices=(MagickCLDevice *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(MagickCLDevice));\n  if (clEnv->devices == (MagickCLDevice *) NULL)\n    {\n      RelinquishMagickCLDevices(clEnv);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  (void) ResetMagickMemory(clEnv->devices,0,clEnv->number_devices*\n    sizeof(MagickCLDevice));\n  devices=(cl_device_id *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(cl_device_id));\n  if (devices == (cl_device_id *) NULL)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  clEnv->number_contexts=(size_t) number_platforms;\n  clEnv->contexts=(cl_context *) AcquireQuantumMemory(clEnv->number_contexts,\n    sizeof(cl_context));\n  if (clEnv->contexts == (cl_context *) NULL)\n    {\n      devices=(cl_device_id *) RelinquishMagickMemory(devices);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  next=0;\n  for (i = 0; i < number_platforms; i++)\n  {\n    if (platforms[i] == (cl_platform_id) NULL)\n      continue;\n\n    status=clEnv->library->clGetDeviceIDs(platforms[i],CL_DEVICE_TYPE_CPU | \n      CL_DEVICE_TYPE_GPU,(cl_uint) clEnv->number_devices,devices,&number_devices);\n    if (status != CL_SUCCESS)\n      continue;\n\n    properties[0]=CL_CONTEXT_PLATFORM;\n    properties[1]=(cl_context_properties) platforms[i];\n    properties[2]=0;\n    clEnv->contexts[i]=openCL_library->clCreateContext(properties,number_devices,\n      devices,NULL,NULL,&status);\n    if (status != CL_SUCCESS)\n      continue;\n\n    for (j = 0; j < number_devices; j++,next++)\n    {\n      MagickCLDevice\n        device;\n\n      device=AcquireMagickCLDevice();\n      if (device == (MagickCLDevice) NULL)\n        break;\n\n      device->context=clEnv->contexts[i];\n      device->deviceID=devices[j];\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,0,NULL,\n        &length);\n      device->platform_name=AcquireCriticalMemory(length*\n        sizeof(*device->platform_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,length,\n        device->platform_name,NULL);\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,0,NULL,\n        &length);\n      device->vendor_name=AcquireQuantumMemory(length,\n        sizeof(*device->vendor_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,length,\n        device->vendor_name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,0,NULL,\n        &length);\n      device->name=AcquireQuantumMemory(length,sizeof(*device->name));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,length,\n        device->name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,0,NULL,\n        &length);\n      device->version=AcquireQuantumMemory(length,sizeof(*device->version));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,length,\n        device->version,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_CLOCK_FREQUENCY,\n        sizeof(cl_uint),&device->max_clock_frequency,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_COMPUTE_UNITS,\n        sizeof(cl_uint),&device->max_compute_units,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_TYPE,\n        sizeof(cl_device_type),&device->type,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_LOCAL_MEM_SIZE,\n        sizeof(cl_ulong),&device->local_memory_size,NULL);\n\n      clEnv->devices[next]=device;\n    }\n  }\n  if (next != clEnv->number_devices)\n    RelinquishMagickCLDevices(clEnv);\n  platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n  devices=(cl_device_id *) RelinquishMagickMemory(devices);\n}",
        "description": "An issue was discovered in ImageMagick where a NULL pointer dereference vulnerability exists in the function responsible for loading OpenCL devices. This flaw allows attackers to trigger a denial of service through the use of a specially crafted file.",
        "commit": "It was discovered that ImageMagick, a popular image processing library, contains a vulnerability related to improper handling of certain image formats, potentially leading to buffer overflows or other memory corruption issues."
    },
    {
        "cwe": "CWE-119",
        "func_name": "torvalds/hugetlb_mcopy_atomic_pte",
        "score": 0.8033402562141418,
        "func_before": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tstruct address_space *mapping = dst_vma->vm_file->f_mapping;\n\t\tpgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
        "func_after": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\tunsigned long size;\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\tmapping = dst_vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\t\tret = -EFAULT;\n\t\tif (idx >= size)\n\t\t\tgoto out_release_nounlock;\n\n\t\t/*\n\t\t * Serialization between remove_inode_hugepages() and\n\t\t * huge_add_to_page_cache() below happens through the\n\t\t * hugetlb_fault_mutex_table that here must be hold by\n\t\t * the caller.\n\t\t */\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\t/*\n\t * Recheck the i_size after holding PT lock to make sure not\n\t * to leave any page mapped (as page_mapped()) beyond the end\n\t * of the i_size (remove_inode_hugepages() is strict about\n\t * enforcing that). If we bail out here, we'll also leave a\n\t * page in the radix tree in the vm_shared case beyond the end\n\t * of the i_size, but remove_inode_hugepages() will take care\n\t * of it as soon as we drop the hugetlb_fault_mutex_table.\n\t */\n\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\tret = -EFAULT;\n\tif (idx >= size)\n\t\tgoto out_release_unlock;\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
        "description": "A flaw was identified in the hugetlb_mcopy_atomic_pte function within the Linux kernel's memory management module, affecting versions prior to 4.13.12. The absence of a proper size check in this function could lead to a denial of service condition, indicated by a BUG.",
        "commit": "A vulnerability was identified in the userfaultfd functionality related to hugetlbfs, where the UFFDIO_COPY operation could inadvertently extend beyond the intended size of the file (i_size). This issue led to a kernel panic (oops) at fs/hugetlbfs/inode.c:484, triggered by the absence of an i_size check in the hugetlb_mcopy_atomic_pte function. Although mmap() operations could succeed beyond the end of the i_size after vmtruncate had removed virtual memory areas (vmas) in those ranges, subsequent faults, including UFFDIO_COPY, should not be allowed to succeed. The proposed solution involves modifying the return value to userland to indicate a SIGBUS-like condition, similar to what a page fault would produce, but this approach was deemed less useful due to the difficulty in distinguishing between SIGSEGV and SIGBUS through meaningful syscall return values."
    },
    {
        "cwe": "CWE-617",
        "func_name": "jerryscript-project/ecma_op_object_get_property_names",
        "score": 0.8033515214920044,
        "func_before": "ecma_collection_t *\necma_op_object_get_property_names (ecma_object_t *obj_p, /**< object */\n                                   uint32_t opts) /**< any combination of ecma_list_properties_options_t values  */\n{\n  JERRY_ASSERT (obj_p != NULL\n                && !ecma_is_lexical_environment (obj_p));\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_IS_PROXY (obj_p))\n  {\n    return ecma_proxy_object_own_property_keys (obj_p);\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  if (ecma_op_object_is_fast_array (obj_p))\n  {\n    return ecma_fast_array_get_property_names (obj_p, opts);\n  }\n\n  ecma_collection_t *ret_p = ecma_new_collection ();\n  ecma_collection_t *skipped_non_enumerable_p = ecma_new_collection ();\n\n  const bool is_enumerable_only = (opts & ECMA_LIST_ENUMERABLE) != 0;\n  const bool is_array_indices_only = (opts & ECMA_LIST_ARRAY_INDICES) != 0;\n  const bool is_with_prototype_chain = (opts & ECMA_LIST_PROTOTYPE) != 0;\n#if ENABLED (JERRY_ES2015)\n  const bool is_symbols = (opts & ECMA_LIST_SYMBOLS) != 0;\n  const bool is_symbols_only = (opts & ECMA_LIST_SYMBOLS_ONLY) != 0;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  const size_t bitmap_row_size = sizeof (uint32_t) * JERRY_BITSINBYTE;\n  const size_t names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size;\n  JERRY_VLA (uint32_t, names_hashes_bitmap, names_hashes_bitmap_size);\n\n  memset (names_hashes_bitmap, 0, names_hashes_bitmap_size * sizeof (names_hashes_bitmap[0]));\n\n  while (true)\n  {\n    const ecma_object_type_t type = ecma_get_object_type (obj_p);\n    const bool obj_is_builtin = ecma_get_object_is_builtin (obj_p);\n    ecma_length_t string_named_properties_count = 0;\n    ecma_length_t array_index_named_properties_count = 0;\n#if ENABLED (JERRY_ES2015)\n    ecma_length_t symbol_named_properties_count = 0;\n#endif /* ENABLED (JERRY_ES2015) */\n    ecma_collection_t *prop_names_p = ecma_new_collection ();\n\n#if ENABLED (JERRY_ES2015)\n    if (JERRY_LIKELY (!is_symbols_only))\n    {\n#endif /* ENABLED (JERRY_ES2015) */\n\n      if (obj_is_builtin)\n      {\n        if (type == ECMA_OBJECT_TYPE_FUNCTION && ecma_builtin_function_is_routine (obj_p))\n        {\n          ecma_builtin_routine_list_lazy_property_names (obj_p,\n                                                          opts,\n                                                          prop_names_p,\n                                                          skipped_non_enumerable_p);\n        }\n        else\n        {\n          ecma_builtin_list_lazy_property_names (obj_p,\n                                                 opts,\n                                                 prop_names_p,\n                                                 skipped_non_enumerable_p);\n        }\n      }\n      else\n      {\n        switch (type)\n        {\n          case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:\n          {\n  #if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n            if (ecma_object_is_typedarray (obj_p))\n            {\n              ecma_op_typedarray_list_lazy_property_names (obj_p, prop_names_p);\n            }\n  #endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n            break;\n          }\n          case ECMA_OBJECT_TYPE_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_function_list_lazy_property_names (obj_p,\n                                                         opts,\n                                                         prop_names_p,\n                                                         skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_external_function_list_lazy_property_names (obj_p,\n                                                                  opts,\n                                                                  prop_names_p,\n                                                                  skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_bound_function_list_lazy_property_names (obj_p,\n                                                               opts,\n                                                               prop_names_p,\n                                                               skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_CLASS:\n          {\n            ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n            if (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_STRING_UL)\n            {\n              ecma_op_string_list_lazy_property_names (obj_p,\n                                                       opts,\n                                                       prop_names_p,\n                                                       skipped_non_enumerable_p);\n            }\n\n            break;\n          }\n          case ECMA_OBJECT_TYPE_ARRAY:\n          {\n            ecma_op_array_list_lazy_property_names (obj_p,\n                                                    opts,\n                                                    prop_names_p,\n                                                    skipped_non_enumerable_p);\n            break;\n          }\n          default:\n          {\n            JERRY_ASSERT (type == ECMA_OBJECT_TYPE_GENERAL);\n\n            break;\n          }\n        }\n      }\n#if ENABLED (JERRY_ES2015)\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    ecma_value_t *buffer_p = prop_names_p->buffer_p;\n    uint32_t lazy_prop_name_count = prop_names_p->item_count;\n\n    const size_t own_names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size;\n    JERRY_VLA (uint32_t, own_names_hashes_bitmap, own_names_hashes_bitmap_size);\n    memset (own_names_hashes_bitmap, 0, own_names_hashes_bitmap_size * sizeof (own_names_hashes_bitmap[0]));\n\n    for (uint32_t i = 0; i < prop_names_p->item_count; i++)\n    {\n      ecma_string_t *name_p = ecma_get_string_from_value (buffer_p[i]);\n\n      if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)\n      {\n        array_index_named_properties_count++;\n      }\n#if ENABLED (JERRY_ES2015)\n      else if (ecma_prop_name_is_symbol (name_p))\n      {\n        symbol_named_properties_count++;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      else\n      {\n        string_named_properties_count++;\n      }\n\n#if ENABLED (JERRY_ES2015)\n      /* Symbols are never lazy listed */\n      JERRY_ASSERT (!ecma_prop_name_is_symbol (name_p));\n#endif /* ENABLED (JERRY_ES2015) */\n\n      uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n      uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n      uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n      if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0)\n      {\n        own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n      }\n    }\n\n    jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp;\n\n    if (ecma_op_object_is_fast_array (obj_p) && prop_iter_cp != JMEM_CP_NULL)\n    {\n      ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;\n\n      uint32_t length = ext_obj_p->u.array.length;\n      array_index_named_properties_count = length - ecma_fast_array_get_hole_count (obj_p);\n\n      ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, prop_iter_cp);\n\n      for (uint32_t i = 0; i < length; i++)\n      {\n        if (ecma_is_value_array_hole (values_p[i]))\n        {\n          continue;\n        }\n\n        ecma_string_t *index_str_p = ecma_new_ecma_string_from_uint32 (i);\n\n        uint8_t hash = (uint8_t) ecma_string_hash (index_str_p);\n        uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n        uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n        bool is_add = true;\n\n        if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0)\n        {\n          buffer_p = prop_names_p->buffer_p;\n\n          for (uint32_t j = 0; j < prop_names_p->item_count; j++)\n          {\n            ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n            if (ecma_compare_ecma_strings (index_str_p, current_name_p))\n            {\n              is_add = false;\n              break;\n            }\n          }\n        }\n\n        if (is_add)\n        {\n          own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n\n          ecma_collection_push_back (prop_names_p, ecma_make_string_value (index_str_p));\n        }\n      }\n    }\n    else\n    {\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n      if (prop_iter_cp != JMEM_CP_NULL)\n      {\n        ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n        if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n        {\n          prop_iter_cp = prop_iter_p->next_property_cp;\n        }\n      }\n  #endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n      while (prop_iter_cp != JMEM_CP_NULL)\n      {\n        ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n        JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n        for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)\n        {\n          ecma_property_t *property_p = prop_iter_p->types + i;\n\n          if (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA\n              || ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR)\n          {\n            ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n            if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_MAGIC\n                && prop_pair_p->names_cp[i] >= LIT_NON_INTERNAL_MAGIC_STRING__COUNT\n                && prop_pair_p->names_cp[i] < LIT_MAGIC_STRING__COUNT)\n            {\n              /* Internal properties are never enumerated. */\n              continue;\n            }\n\n            ecma_string_t *name_p = ecma_string_from_property_name (*property_p,\n                                                                    prop_pair_p->names_cp[i]);\n\n            if (!(is_enumerable_only && !ecma_is_property_enumerable (*property_p)))\n            {\n  #if ENABLED (JERRY_ES2015)\n              /* We skip the current property in the following cases:\n                 1. We don't want to list symbols (is_symbols and is_symbols_only are false)\n                    and the current property is a symbol.\n                 2. We only want to list symbols (is_symbols_only is true) and the current\n                    property is NOT a symbol. */\n              bool is_symbol = ecma_prop_name_is_symbol (name_p);\n              if ((!(is_symbols || is_symbols_only) && is_symbol) || (is_symbols_only && !is_symbol))\n              {\n                ecma_deref_ecma_string (name_p);\n                continue;\n              }\n  #endif /* ENABLED (JERRY_ES2015) */\n\n              uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n              uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n              uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n              bool is_add = true;\n\n              if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0)\n              {\n                buffer_p = prop_names_p->buffer_p;\n\n                for (uint32_t j = 0; j < prop_names_p->item_count; j++)\n                {\n                  ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n                  if (ecma_compare_ecma_strings (name_p, current_name_p))\n                  {\n                    is_add = false;\n                    break;\n                  }\n                }\n              }\n\n              if (is_add)\n              {\n                if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)\n                {\n                  /* The name is a valid array index. */\n                  array_index_named_properties_count++;\n                }\n                else if (!is_array_indices_only)\n                {\n  #if ENABLED (JERRY_ES2015)\n                  if (ecma_prop_name_is_symbol (name_p))\n                  {\n                    symbol_named_properties_count++;\n                  }\n                  else\n                  {\n  #endif /* ENABLED (JERRY_ES2015) */\n                    string_named_properties_count++;\n  #if ENABLED (JERRY_ES2015)\n                  }\n  #endif /* ENABLED (JERRY_ES2015) */\n                }\n                else\n                {\n                  ecma_deref_ecma_string (name_p);\n                  continue;\n                }\n\n                own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n\n                ecma_collection_push_back (prop_names_p, ecma_make_prop_name_value (name_p));\n              }\n              else\n              {\n                ecma_deref_ecma_string (name_p);\n              }\n            }\n            else\n            {\n              JERRY_ASSERT (is_enumerable_only && !ecma_is_property_enumerable (*property_p));\n\n              ecma_collection_push_back (skipped_non_enumerable_p, ecma_make_prop_name_value (name_p));\n            }\n          }\n        }\n\n        prop_iter_cp = prop_iter_p->next_property_cp;\n      }\n    }\n\n    ecma_length_t all_properties_count = array_index_named_properties_count + string_named_properties_count;\n\n#if ENABLED (JERRY_ES2015)\n    all_properties_count += symbol_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    /* Second pass: collecting property names into an array. */\n    JMEM_DEFINE_LOCAL_ARRAY (names_p, all_properties_count, ecma_string_t *);\n\n    ecma_string_t **string_names_p = names_p + array_index_named_properties_count;\n#if ENABLED (JERRY_ES2015)\n    ecma_string_t **symbol_names_p = string_names_p + string_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    uint32_t array_index_name_pos = 0;\n    uint32_t string_name_pos = string_named_properties_count;\n    uint32_t lazy_string_name_pos = 0;\n#if ENABLED (JERRY_ES2015)\n    uint32_t symbol_name_pos = symbol_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    buffer_p = prop_names_p->buffer_p;\n\n    for (uint32_t i = 0; i < prop_names_p->item_count; i++)\n    {\n      ecma_string_t *name_p = ecma_get_prop_name_from_value (buffer_p[i]);\n      ecma_ref_ecma_string (name_p);\n\n      uint32_t index = ecma_string_get_array_index (name_p);\n\n      if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n      {\n        JERRY_ASSERT (array_index_name_pos < array_index_named_properties_count);\n\n        uint32_t insertion_pos = 0;\n        while (insertion_pos < array_index_name_pos\n               && index > ecma_string_get_array_index (names_p[insertion_pos]))\n        {\n          insertion_pos++;\n        }\n\n        if (insertion_pos == array_index_name_pos)\n        {\n          names_p[array_index_name_pos++] = name_p;\n        }\n        else\n        {\n          JERRY_ASSERT (insertion_pos < array_index_name_pos);\n          JERRY_ASSERT (index <= ecma_string_get_array_index (names_p[insertion_pos]));\n\n          uint32_t move_pos = array_index_name_pos++;\n\n          while (move_pos > insertion_pos)\n          {\n            names_p[move_pos] = names_p[move_pos - 1u];\n\n            move_pos--;\n          }\n\n          names_p[insertion_pos] = name_p;\n        }\n      }\n#if ENABLED (JERRY_ES2015)\n      else if (ecma_prop_name_is_symbol (name_p))\n      {\n        // Put in the symbols in reverse order.\n        JERRY_ASSERT (symbol_name_pos > 0);\n        JERRY_ASSERT (symbol_name_pos <= symbol_named_properties_count);\n\n        symbol_names_p[--symbol_name_pos] = name_p;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      else\n      {\n        // Put in the strings in reverse order.\n        JERRY_ASSERT (string_name_pos > 0);\n        JERRY_ASSERT (string_name_pos <= string_named_properties_count);\n\n        if (i < lazy_prop_name_count)\n        {\n          string_names_p[lazy_string_name_pos++] = name_p;\n        }\n        else\n        {\n          string_names_p[--string_name_pos] = name_p;\n        }\n      }\n    }\n\n    JERRY_ASSERT (array_index_name_pos == array_index_named_properties_count);\n    JERRY_ASSERT (string_name_pos - lazy_string_name_pos == 0);\n#if ENABLED (JERRY_ES2015)\n    JERRY_ASSERT (symbol_name_pos == 0);\n#endif /* ENABLED (JERRY_ES2015) */\n\n    ecma_collection_free (prop_names_p);\n\n    /* Third pass:\n     *   embedding own property names of current object of prototype chain to aggregate property names collection */\n    for (uint32_t i = 0; i < all_properties_count; i++)\n    {\n      bool is_append = true;\n\n      ecma_string_t *name_p = names_p[i];\n\n      uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n      uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n      uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n      if ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0)\n      {\n        /* This hash has not been used before (for non-skipped). */\n        names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n      }\n      else\n      {\n        /* Name with same hash has already occured. */\n        buffer_p = ret_p->buffer_p;\n\n        for (uint32_t j = 0; j < ret_p->item_count; j++)\n        {\n          ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n          if (ecma_compare_ecma_strings (name_p, current_name_p))\n          {\n            is_append = false;\n            break;\n          }\n        }\n      }\n\n      if (is_append)\n      {\n        buffer_p = skipped_non_enumerable_p->buffer_p;\n\n        for (uint32_t j = 0; j < skipped_non_enumerable_p->item_count; j++)\n        {\n          ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n          if (ecma_compare_ecma_strings (name_p, current_name_p))\n          {\n            is_append = false;\n            break;\n          }\n        }\n      }\n\n      if (is_append)\n      {\n        JERRY_ASSERT ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0);\n\n        ecma_collection_push_back (ret_p, ecma_make_prop_name_value (name_p));\n      }\n      else\n      {\n        ecma_deref_ecma_string (name_p);\n      }\n\n    }\n\n    JMEM_FINALIZE_LOCAL_ARRAY (names_p);\n\n    if (!is_with_prototype_chain || obj_p->u2.prototype_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_p->u2.prototype_cp);\n  }\n\n  ecma_collection_free (skipped_non_enumerable_p);\n\n  return ret_p;\n}",
        "func_after": "ecma_collection_t *\necma_op_object_get_property_names (ecma_object_t *obj_p, /**< object */\n                                   uint32_t opts) /**< any combination of ecma_list_properties_options_t values  */\n{\n  JERRY_ASSERT (obj_p != NULL\n                && !ecma_is_lexical_environment (obj_p));\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_IS_PROXY (obj_p))\n  {\n    /* Integrated a part of ECMA 262 v6 7.3.21 EnumerableOwnNames operation. */\n    ecma_collection_t *proxy_keys = ecma_proxy_object_own_property_keys (obj_p);\n    if (JERRY_UNLIKELY (proxy_keys == NULL))\n    {\n      return proxy_keys;\n    }\n    ecma_collection_t *return_keys = ecma_new_collection ();\n\n    /* Move valid elements to the output collection */\n    for (uint32_t i = 0; i < proxy_keys->item_count; i++)\n    {\n      ecma_value_t entry = proxy_keys->buffer_p[i];\n      ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (entry);\n      bool prop_is_symbol = ecma_prop_name_is_symbol (prop_name_p);\n\n      if (prop_is_symbol && ((opts & (ECMA_LIST_SYMBOLS | ECMA_LIST_SYMBOLS_ONLY)) != 0))\n      {\n        ecma_collection_push_back (return_keys, entry);\n      }\n      else if (!prop_is_symbol && (opts & ECMA_LIST_SYMBOLS_ONLY) == 0)\n      {\n        ecma_collection_push_back (return_keys, entry);\n      }\n      else\n      {\n        ecma_free_value (entry);\n      }\n    }\n\n    ecma_collection_destroy (proxy_keys);\n    return return_keys;\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  if (ecma_op_object_is_fast_array (obj_p))\n  {\n    return ecma_fast_array_get_property_names (obj_p, opts);\n  }\n\n  ecma_collection_t *ret_p = ecma_new_collection ();\n  ecma_collection_t *skipped_non_enumerable_p = ecma_new_collection ();\n\n  const bool is_enumerable_only = (opts & ECMA_LIST_ENUMERABLE) != 0;\n  const bool is_array_indices_only = (opts & ECMA_LIST_ARRAY_INDICES) != 0;\n  const bool is_with_prototype_chain = (opts & ECMA_LIST_PROTOTYPE) != 0;\n#if ENABLED (JERRY_ES2015)\n  const bool is_symbols = (opts & ECMA_LIST_SYMBOLS) != 0;\n  const bool is_symbols_only = (opts & ECMA_LIST_SYMBOLS_ONLY) != 0;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  const size_t bitmap_row_size = sizeof (uint32_t) * JERRY_BITSINBYTE;\n  const size_t names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size;\n  JERRY_VLA (uint32_t, names_hashes_bitmap, names_hashes_bitmap_size);\n\n  memset (names_hashes_bitmap, 0, names_hashes_bitmap_size * sizeof (names_hashes_bitmap[0]));\n\n  while (true)\n  {\n    const ecma_object_type_t type = ecma_get_object_type (obj_p);\n    const bool obj_is_builtin = ecma_get_object_is_builtin (obj_p);\n    ecma_length_t string_named_properties_count = 0;\n    ecma_length_t array_index_named_properties_count = 0;\n#if ENABLED (JERRY_ES2015)\n    ecma_length_t symbol_named_properties_count = 0;\n#endif /* ENABLED (JERRY_ES2015) */\n    ecma_collection_t *prop_names_p = ecma_new_collection ();\n\n#if ENABLED (JERRY_ES2015)\n    if (JERRY_LIKELY (!is_symbols_only))\n    {\n#endif /* ENABLED (JERRY_ES2015) */\n\n      if (obj_is_builtin)\n      {\n        if (type == ECMA_OBJECT_TYPE_FUNCTION && ecma_builtin_function_is_routine (obj_p))\n        {\n          ecma_builtin_routine_list_lazy_property_names (obj_p,\n                                                          opts,\n                                                          prop_names_p,\n                                                          skipped_non_enumerable_p);\n        }\n        else\n        {\n          ecma_builtin_list_lazy_property_names (obj_p,\n                                                 opts,\n                                                 prop_names_p,\n                                                 skipped_non_enumerable_p);\n        }\n      }\n      else\n      {\n        switch (type)\n        {\n          case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:\n          {\n  #if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n            if (ecma_object_is_typedarray (obj_p))\n            {\n              ecma_op_typedarray_list_lazy_property_names (obj_p, prop_names_p);\n            }\n  #endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n            break;\n          }\n          case ECMA_OBJECT_TYPE_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_function_list_lazy_property_names (obj_p,\n                                                         opts,\n                                                         prop_names_p,\n                                                         skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_external_function_list_lazy_property_names (obj_p,\n                                                                  opts,\n                                                                  prop_names_p,\n                                                                  skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_bound_function_list_lazy_property_names (obj_p,\n                                                               opts,\n                                                               prop_names_p,\n                                                               skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_CLASS:\n          {\n            ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n            if (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_STRING_UL)\n            {\n              ecma_op_string_list_lazy_property_names (obj_p,\n                                                       opts,\n                                                       prop_names_p,\n                                                       skipped_non_enumerable_p);\n            }\n\n            break;\n          }\n          case ECMA_OBJECT_TYPE_ARRAY:\n          {\n            ecma_op_array_list_lazy_property_names (obj_p,\n                                                    opts,\n                                                    prop_names_p,\n                                                    skipped_non_enumerable_p);\n            break;\n          }\n          default:\n          {\n            JERRY_ASSERT (type == ECMA_OBJECT_TYPE_GENERAL);\n\n            break;\n          }\n        }\n      }\n#if ENABLED (JERRY_ES2015)\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    ecma_value_t *buffer_p = prop_names_p->buffer_p;\n    uint32_t lazy_prop_name_count = prop_names_p->item_count;\n\n    const size_t own_names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size;\n    JERRY_VLA (uint32_t, own_names_hashes_bitmap, own_names_hashes_bitmap_size);\n    memset (own_names_hashes_bitmap, 0, own_names_hashes_bitmap_size * sizeof (own_names_hashes_bitmap[0]));\n\n    for (uint32_t i = 0; i < prop_names_p->item_count; i++)\n    {\n      ecma_string_t *name_p = ecma_get_string_from_value (buffer_p[i]);\n\n      if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)\n      {\n        array_index_named_properties_count++;\n      }\n#if ENABLED (JERRY_ES2015)\n      else if (ecma_prop_name_is_symbol (name_p))\n      {\n        symbol_named_properties_count++;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      else\n      {\n        string_named_properties_count++;\n      }\n\n#if ENABLED (JERRY_ES2015)\n      /* Symbols are never lazy listed */\n      JERRY_ASSERT (!ecma_prop_name_is_symbol (name_p));\n#endif /* ENABLED (JERRY_ES2015) */\n\n      uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n      uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n      uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n      if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0)\n      {\n        own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n      }\n    }\n\n    jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp;\n\n    if (ecma_op_object_is_fast_array (obj_p) && prop_iter_cp != JMEM_CP_NULL)\n    {\n      ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;\n\n      uint32_t length = ext_obj_p->u.array.length;\n      array_index_named_properties_count = length - ecma_fast_array_get_hole_count (obj_p);\n\n      ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, prop_iter_cp);\n\n      for (uint32_t i = 0; i < length; i++)\n      {\n        if (ecma_is_value_array_hole (values_p[i]))\n        {\n          continue;\n        }\n\n        ecma_string_t *index_str_p = ecma_new_ecma_string_from_uint32 (i);\n\n        uint8_t hash = (uint8_t) ecma_string_hash (index_str_p);\n        uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n        uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n        bool is_add = true;\n\n        if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0)\n        {\n          buffer_p = prop_names_p->buffer_p;\n\n          for (uint32_t j = 0; j < prop_names_p->item_count; j++)\n          {\n            ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n            if (ecma_compare_ecma_strings (index_str_p, current_name_p))\n            {\n              is_add = false;\n              break;\n            }\n          }\n        }\n\n        if (is_add)\n        {\n          own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n\n          ecma_collection_push_back (prop_names_p, ecma_make_string_value (index_str_p));\n        }\n      }\n    }\n    else\n    {\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n      if (prop_iter_cp != JMEM_CP_NULL)\n      {\n        ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n        if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n        {\n          prop_iter_cp = prop_iter_p->next_property_cp;\n        }\n      }\n  #endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n      while (prop_iter_cp != JMEM_CP_NULL)\n      {\n        ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n        JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n        for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)\n        {\n          ecma_property_t *property_p = prop_iter_p->types + i;\n\n          if (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA\n              || ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR)\n          {\n            ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n            if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_MAGIC\n                && prop_pair_p->names_cp[i] >= LIT_NON_INTERNAL_MAGIC_STRING__COUNT\n                && prop_pair_p->names_cp[i] < LIT_MAGIC_STRING__COUNT)\n            {\n              /* Internal properties are never enumerated. */\n              continue;\n            }\n\n            ecma_string_t *name_p = ecma_string_from_property_name (*property_p,\n                                                                    prop_pair_p->names_cp[i]);\n\n            if (!(is_enumerable_only && !ecma_is_property_enumerable (*property_p)))\n            {\n  #if ENABLED (JERRY_ES2015)\n              /* We skip the current property in the following cases:\n                 1. We don't want to list symbols (is_symbols and is_symbols_only are false)\n                    and the current property is a symbol.\n                 2. We only want to list symbols (is_symbols_only is true) and the current\n                    property is NOT a symbol. */\n              bool is_symbol = ecma_prop_name_is_symbol (name_p);\n              if ((!(is_symbols || is_symbols_only) && is_symbol) || (is_symbols_only && !is_symbol))\n              {\n                ecma_deref_ecma_string (name_p);\n                continue;\n              }\n  #endif /* ENABLED (JERRY_ES2015) */\n\n              uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n              uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n              uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n              bool is_add = true;\n\n              if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0)\n              {\n                buffer_p = prop_names_p->buffer_p;\n\n                for (uint32_t j = 0; j < prop_names_p->item_count; j++)\n                {\n                  ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n                  if (ecma_compare_ecma_strings (name_p, current_name_p))\n                  {\n                    is_add = false;\n                    break;\n                  }\n                }\n              }\n\n              if (is_add)\n              {\n                if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)\n                {\n                  /* The name is a valid array index. */\n                  array_index_named_properties_count++;\n                }\n                else if (!is_array_indices_only)\n                {\n  #if ENABLED (JERRY_ES2015)\n                  if (ecma_prop_name_is_symbol (name_p))\n                  {\n                    symbol_named_properties_count++;\n                  }\n                  else\n                  {\n  #endif /* ENABLED (JERRY_ES2015) */\n                    string_named_properties_count++;\n  #if ENABLED (JERRY_ES2015)\n                  }\n  #endif /* ENABLED (JERRY_ES2015) */\n                }\n                else\n                {\n                  ecma_deref_ecma_string (name_p);\n                  continue;\n                }\n\n                own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n\n                ecma_collection_push_back (prop_names_p, ecma_make_prop_name_value (name_p));\n              }\n              else\n              {\n                ecma_deref_ecma_string (name_p);\n              }\n            }\n            else\n            {\n              JERRY_ASSERT (is_enumerable_only && !ecma_is_property_enumerable (*property_p));\n\n              ecma_collection_push_back (skipped_non_enumerable_p, ecma_make_prop_name_value (name_p));\n            }\n          }\n        }\n\n        prop_iter_cp = prop_iter_p->next_property_cp;\n      }\n    }\n\n    ecma_length_t all_properties_count = array_index_named_properties_count + string_named_properties_count;\n\n#if ENABLED (JERRY_ES2015)\n    all_properties_count += symbol_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    /* Second pass: collecting property names into an array. */\n    JMEM_DEFINE_LOCAL_ARRAY (names_p, all_properties_count, ecma_string_t *);\n\n    ecma_string_t **string_names_p = names_p + array_index_named_properties_count;\n#if ENABLED (JERRY_ES2015)\n    ecma_string_t **symbol_names_p = string_names_p + string_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    uint32_t array_index_name_pos = 0;\n    uint32_t string_name_pos = string_named_properties_count;\n    uint32_t lazy_string_name_pos = 0;\n#if ENABLED (JERRY_ES2015)\n    uint32_t symbol_name_pos = symbol_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    buffer_p = prop_names_p->buffer_p;\n\n    for (uint32_t i = 0; i < prop_names_p->item_count; i++)\n    {\n      ecma_string_t *name_p = ecma_get_prop_name_from_value (buffer_p[i]);\n      ecma_ref_ecma_string (name_p);\n\n      uint32_t index = ecma_string_get_array_index (name_p);\n\n      if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n      {\n        JERRY_ASSERT (array_index_name_pos < array_index_named_properties_count);\n\n        uint32_t insertion_pos = 0;\n        while (insertion_pos < array_index_name_pos\n               && index > ecma_string_get_array_index (names_p[insertion_pos]))\n        {\n          insertion_pos++;\n        }\n\n        if (insertion_pos == array_index_name_pos)\n        {\n          names_p[array_index_name_pos++] = name_p;\n        }\n        else\n        {\n          JERRY_ASSERT (insertion_pos < array_index_name_pos);\n          JERRY_ASSERT (index <= ecma_string_get_array_index (names_p[insertion_pos]));\n\n          uint32_t move_pos = array_index_name_pos++;\n\n          while (move_pos > insertion_pos)\n          {\n            names_p[move_pos] = names_p[move_pos - 1u];\n\n            move_pos--;\n          }\n\n          names_p[insertion_pos] = name_p;\n        }\n      }\n#if ENABLED (JERRY_ES2015)\n      else if (ecma_prop_name_is_symbol (name_p))\n      {\n        // Put in the symbols in reverse order.\n        JERRY_ASSERT (symbol_name_pos > 0);\n        JERRY_ASSERT (symbol_name_pos <= symbol_named_properties_count);\n\n        symbol_names_p[--symbol_name_pos] = name_p;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      else\n      {\n        // Put in the strings in reverse order.\n        JERRY_ASSERT (string_name_pos > 0);\n        JERRY_ASSERT (string_name_pos <= string_named_properties_count);\n\n        if (i < lazy_prop_name_count)\n        {\n          string_names_p[lazy_string_name_pos++] = name_p;\n        }\n        else\n        {\n          string_names_p[--string_name_pos] = name_p;\n        }\n      }\n    }\n\n    JERRY_ASSERT (array_index_name_pos == array_index_named_properties_count);\n    JERRY_ASSERT (string_name_pos - lazy_string_name_pos == 0);\n#if ENABLED (JERRY_ES2015)\n    JERRY_ASSERT (symbol_name_pos == 0);\n#endif /* ENABLED (JERRY_ES2015) */\n\n    ecma_collection_free (prop_names_p);\n\n    /* Third pass:\n     *   embedding own property names of current object of prototype chain to aggregate property names collection */\n    for (uint32_t i = 0; i < all_properties_count; i++)\n    {\n      bool is_append = true;\n\n      ecma_string_t *name_p = names_p[i];\n\n      uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n      uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n      uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n      if ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0)\n      {\n        /* This hash has not been used before (for non-skipped). */\n        names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n      }\n      else\n      {\n        /* Name with same hash has already occured. */\n        buffer_p = ret_p->buffer_p;\n\n        for (uint32_t j = 0; j < ret_p->item_count; j++)\n        {\n          ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n          if (ecma_compare_ecma_strings (name_p, current_name_p))\n          {\n            is_append = false;\n            break;\n          }\n        }\n      }\n\n      if (is_append)\n      {\n        buffer_p = skipped_non_enumerable_p->buffer_p;\n\n        for (uint32_t j = 0; j < skipped_non_enumerable_p->item_count; j++)\n        {\n          ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n          if (ecma_compare_ecma_strings (name_p, current_name_p))\n          {\n            is_append = false;\n            break;\n          }\n        }\n      }\n\n      if (is_append)\n      {\n        JERRY_ASSERT ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0);\n\n        ecma_collection_push_back (ret_p, ecma_make_prop_name_value (name_p));\n      }\n      else\n      {\n        ecma_deref_ecma_string (name_p);\n      }\n\n    }\n\n    JMEM_FINALIZE_LOCAL_ARRAY (names_p);\n\n    if (!is_with_prototype_chain || obj_p->u2.prototype_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_p->u2.prototype_cp);\n  }\n\n  ecma_collection_free (skipped_non_enumerable_p);\n\n  return ret_p;\n}",
        "description": "JerryScript 2.2.0 allows attackers to trigger a denial of service (assertion failure) due to an unintended property key query result when interacting with a Proxy object.",
        "commit": "The property key query for Proxy objects in JerryScript always returned all keys, regardless of whether any symbols were requested or present in the resulting array."
    }
]