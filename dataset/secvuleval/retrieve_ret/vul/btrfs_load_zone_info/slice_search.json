[
    {
        "cwe": "CWE-476",
        "func_name": "ImageMagick/LoadOpenCLDevices",
        "score": 0.8126571774482727,
        "func_before": "static void LoadOpenCLDevices(MagickCLEnv clEnv)\n{\n  cl_context_properties\n    properties[3];\n\n  cl_device_id\n    *devices;\n\n  cl_int\n    status;\n\n  cl_platform_id\n    *platforms;\n\n  cl_uint\n    i,\n    j,\n    next,\n    number_devices,\n    number_platforms;\n\n  size_t\n    length;\n\n  number_platforms=0;\n  if (openCL_library->clGetPlatformIDs(0,NULL,&number_platforms) != CL_SUCCESS)\n    return;\n  if (number_platforms == 0)\n    return;\n  platforms=(cl_platform_id *) AcquireMagickMemory(number_platforms*\n    sizeof(cl_platform_id));\n  if (platforms == (cl_platform_id *) NULL)\n    return;\n  if (openCL_library->clGetPlatformIDs(number_platforms,platforms,NULL) != CL_SUCCESS)\n    {\n       platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n       return;\n    }\n  for (i = 0; i < number_platforms; i++)\n  {\n    number_devices=GetOpenCLDeviceCount(clEnv,platforms[i]);\n    if (number_devices == 0)\n      platforms[i]=(cl_platform_id) NULL;\n    else\n      clEnv->number_devices+=number_devices;\n  }\n  if (clEnv->number_devices == 0)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  clEnv->devices=(MagickCLDevice *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(MagickCLDevice));\n  if (clEnv->devices == (MagickCLDevice *) NULL)\n    {\n      RelinquishMagickCLDevices(clEnv);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  (void) ResetMagickMemory(clEnv->devices,0,clEnv->number_devices*\n    sizeof(MagickCLDevice));\n  devices=(cl_device_id *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(cl_device_id));\n  if (devices == (cl_device_id *) NULL)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  clEnv->number_contexts=(size_t) number_platforms;\n  clEnv->contexts=(cl_context *) AcquireQuantumMemory(clEnv->number_contexts,\n    sizeof(cl_context));\n  if (clEnv->contexts == (cl_context *) NULL)\n    {\n      devices=(cl_device_id *) RelinquishMagickMemory(devices);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  next=0;\n  for (i = 0; i < number_platforms; i++)\n  {\n    if (platforms[i] == (cl_platform_id) NULL)\n      continue;\n\n    status=clEnv->library->clGetDeviceIDs(platforms[i],CL_DEVICE_TYPE_CPU | \n      CL_DEVICE_TYPE_GPU,(cl_uint) clEnv->number_devices,devices,&number_devices);\n    if (status != CL_SUCCESS)\n      continue;\n\n    properties[0]=CL_CONTEXT_PLATFORM;\n    properties[1]=(cl_context_properties) platforms[i];\n    properties[2]=0;\n    clEnv->contexts[i]=openCL_library->clCreateContext(properties,number_devices,\n      devices,NULL,NULL,&status);\n    if (status != CL_SUCCESS)\n      continue;\n\n    for (j = 0; j < number_devices; j++,next++)\n    {\n      MagickCLDevice\n        device;\n\n      device=AcquireMagickCLDevice();\n      if (device == (MagickCLDevice) NULL)\n        break;\n\n      device->context=clEnv->contexts[i];\n      device->deviceID=devices[j];\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,0,NULL,\n        &length);\n      device->platform_name=AcquireQuantumMemory(length,\n        sizeof(*device->platform_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,length,\n        device->platform_name,NULL);\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,0,NULL,\n        &length);\n      device->vendor_name=AcquireQuantumMemory(length,\n        sizeof(*device->vendor_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,length,\n        device->vendor_name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,0,NULL,\n        &length);\n      device->name=AcquireQuantumMemory(length,sizeof(*device->name));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,length,\n        device->name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,0,NULL,\n        &length);\n      device->version=AcquireQuantumMemory(length,sizeof(*device->version));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,length,\n        device->version,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_CLOCK_FREQUENCY,\n        sizeof(cl_uint),&device->max_clock_frequency,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_COMPUTE_UNITS,\n        sizeof(cl_uint),&device->max_compute_units,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_TYPE,\n        sizeof(cl_device_type),&device->type,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_LOCAL_MEM_SIZE,\n        sizeof(cl_ulong),&device->local_memory_size,NULL);\n\n      clEnv->devices[next]=device;\n    }\n  }\n  if (next != clEnv->number_devices)\n    RelinquishMagickCLDevices(clEnv);\n  platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n  devices=(cl_device_id *) RelinquishMagickMemory(devices);\n}",
        "func_after": "static void LoadOpenCLDevices(MagickCLEnv clEnv)\n{\n  cl_context_properties\n    properties[3];\n\n  cl_device_id\n    *devices;\n\n  cl_int\n    status;\n\n  cl_platform_id\n    *platforms;\n\n  cl_uint\n    i,\n    j,\n    next,\n    number_devices,\n    number_platforms;\n\n  size_t\n    length;\n\n  number_platforms=0;\n  if (openCL_library->clGetPlatformIDs(0,NULL,&number_platforms) != CL_SUCCESS)\n    return;\n  if (number_platforms == 0)\n    return;\n  platforms=(cl_platform_id *) AcquireMagickMemory(number_platforms*\n    sizeof(cl_platform_id));\n  if (platforms == (cl_platform_id *) NULL)\n    return;\n  if (openCL_library->clGetPlatformIDs(number_platforms,platforms,NULL) != CL_SUCCESS)\n    {\n       platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n       return;\n    }\n  for (i = 0; i < number_platforms; i++)\n  {\n    number_devices=GetOpenCLDeviceCount(clEnv,platforms[i]);\n    if (number_devices == 0)\n      platforms[i]=(cl_platform_id) NULL;\n    else\n      clEnv->number_devices+=number_devices;\n  }\n  if (clEnv->number_devices == 0)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  clEnv->devices=(MagickCLDevice *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(MagickCLDevice));\n  if (clEnv->devices == (MagickCLDevice *) NULL)\n    {\n      RelinquishMagickCLDevices(clEnv);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  (void) ResetMagickMemory(clEnv->devices,0,clEnv->number_devices*\n    sizeof(MagickCLDevice));\n  devices=(cl_device_id *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(cl_device_id));\n  if (devices == (cl_device_id *) NULL)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  clEnv->number_contexts=(size_t) number_platforms;\n  clEnv->contexts=(cl_context *) AcquireQuantumMemory(clEnv->number_contexts,\n    sizeof(cl_context));\n  if (clEnv->contexts == (cl_context *) NULL)\n    {\n      devices=(cl_device_id *) RelinquishMagickMemory(devices);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  next=0;\n  for (i = 0; i < number_platforms; i++)\n  {\n    if (platforms[i] == (cl_platform_id) NULL)\n      continue;\n\n    status=clEnv->library->clGetDeviceIDs(platforms[i],CL_DEVICE_TYPE_CPU | \n      CL_DEVICE_TYPE_GPU,(cl_uint) clEnv->number_devices,devices,&number_devices);\n    if (status != CL_SUCCESS)\n      continue;\n\n    properties[0]=CL_CONTEXT_PLATFORM;\n    properties[1]=(cl_context_properties) platforms[i];\n    properties[2]=0;\n    clEnv->contexts[i]=openCL_library->clCreateContext(properties,number_devices,\n      devices,NULL,NULL,&status);\n    if (status != CL_SUCCESS)\n      continue;\n\n    for (j = 0; j < number_devices; j++,next++)\n    {\n      MagickCLDevice\n        device;\n\n      device=AcquireMagickCLDevice();\n      if (device == (MagickCLDevice) NULL)\n        break;\n\n      device->context=clEnv->contexts[i];\n      device->deviceID=devices[j];\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,0,NULL,\n        &length);\n      device->platform_name=AcquireCriticalMemory(length*\n        sizeof(*device->platform_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,length,\n        device->platform_name,NULL);\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,0,NULL,\n        &length);\n      device->vendor_name=AcquireQuantumMemory(length,\n        sizeof(*device->vendor_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,length,\n        device->vendor_name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,0,NULL,\n        &length);\n      device->name=AcquireQuantumMemory(length,sizeof(*device->name));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,length,\n        device->name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,0,NULL,\n        &length);\n      device->version=AcquireQuantumMemory(length,sizeof(*device->version));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,length,\n        device->version,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_CLOCK_FREQUENCY,\n        sizeof(cl_uint),&device->max_clock_frequency,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_COMPUTE_UNITS,\n        sizeof(cl_uint),&device->max_compute_units,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_TYPE,\n        sizeof(cl_device_type),&device->type,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_LOCAL_MEM_SIZE,\n        sizeof(cl_ulong),&device->local_memory_size,NULL);\n\n      clEnv->devices[next]=device;\n    }\n  }\n  if (next != clEnv->number_devices)\n    RelinquishMagickCLDevices(clEnv);\n  platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n  devices=(cl_device_id *) RelinquishMagickMemory(devices);\n}",
        "description": "An issue was discovered in ImageMagick where a NULL pointer dereference vulnerability exists in the function responsible for loading OpenCL devices. This flaw allows attackers to trigger a denial of service through the use of a specially crafted file.",
        "commit": "It was discovered that ImageMagick, a popular image processing library, contains a vulnerability related to improper handling of certain image formats, potentially leading to buffer overflows or other memory corruption issues."
    },
    {
        "cwe": "CWE-269",
        "func_name": "xen-project/msix_capability_init",
        "score": 0.8102109432220459,
        "func_before": "static int msix_capability_init(struct pci_dev *dev,\n                                struct msi_info *msi,\n                                struct msi_desc **desc)\n{\n    struct arch_msix *msix = dev->msix;\n    struct msi_desc *entry = NULL;\n    int vf;\n    u16 control;\n    u64 table_paddr;\n    u32 table_offset;\n    u8 bir, pbus, pslot, pfunc;\n    u16 seg = dev->seg;\n    u8 bus = dev->bus;\n    u8 slot = PCI_SLOT(dev->devfn);\n    u8 func = PCI_FUNC(dev->devfn);\n    bool maskall = msix->host_maskall;\n    unsigned int pos = pci_find_cap_offset(seg, bus, slot, func,\n                                           PCI_CAP_ID_MSIX);\n\n    if ( !pos )\n        return -ENODEV;\n\n    ASSERT(pcidevs_locked());\n\n    control = pci_conf_read16(dev->sbdf, msix_control_reg(pos));\n    /*\n     * Ensure MSI-X interrupts are masked during setup. Some devices require\n     * MSI-X to be enabled before we can touch the MSI-X registers. We need\n     * to mask all the vectors to prevent interrupts coming in before they're\n     * fully set up.\n     */\n    msix->host_maskall = 1;\n    pci_conf_write16(dev->sbdf, msix_control_reg(pos),\n                     control | (PCI_MSIX_FLAGS_ENABLE |\n                                PCI_MSIX_FLAGS_MASKALL));\n\n    if ( unlikely(!memory_decoded(dev)) )\n    {\n        pci_conf_write16(dev->sbdf, msix_control_reg(pos),\n                         control & ~PCI_MSIX_FLAGS_ENABLE);\n        return -ENXIO;\n    }\n\n    if ( desc )\n    {\n        entry = alloc_msi_entry(1);\n        if ( !entry )\n        {\n            pci_conf_write16(dev->sbdf, msix_control_reg(pos),\n                             control & ~PCI_MSIX_FLAGS_ENABLE);\n            return -ENOMEM;\n        }\n        ASSERT(msi);\n    }\n\n    /* Locate MSI-X table region */\n    table_offset = pci_conf_read32(dev->sbdf, msix_table_offset_reg(pos));\n    bir = (u8)(table_offset & PCI_MSIX_BIRMASK);\n    table_offset &= ~PCI_MSIX_BIRMASK;\n\n    if ( !dev->info.is_virtfn )\n    {\n        pbus = bus;\n        pslot = slot;\n        pfunc = func;\n        vf = -1;\n    }\n    else\n    {\n        pbus = dev->info.physfn.bus;\n        pslot = PCI_SLOT(dev->info.physfn.devfn);\n        pfunc = PCI_FUNC(dev->info.physfn.devfn);\n        vf = PCI_BDF2(dev->bus, dev->devfn);\n    }\n\n    table_paddr = read_pci_mem_bar(seg, pbus, pslot, pfunc, bir, vf);\n    WARN_ON(msi && msi->table_base != table_paddr);\n    if ( !table_paddr )\n    {\n        if ( !msi || !msi->table_base )\n        {\n            pci_conf_write16(dev->sbdf, msix_control_reg(pos),\n                             control & ~PCI_MSIX_FLAGS_ENABLE);\n            xfree(entry);\n            return -ENXIO;\n        }\n        table_paddr = msi->table_base;\n    }\n    table_paddr += table_offset;\n\n    if ( !msix->used_entries )\n    {\n        u64 pba_paddr;\n        u32 pba_offset;\n\n        msix->table.first = PFN_DOWN(table_paddr);\n        msix->table.last = PFN_DOWN(table_paddr +\n                                    msix->nr_entries * PCI_MSIX_ENTRY_SIZE - 1);\n        WARN_ON(rangeset_overlaps_range(mmio_ro_ranges, msix->table.first,\n                                        msix->table.last));\n\n        pba_offset = pci_conf_read32(dev->sbdf, msix_pba_offset_reg(pos));\n        bir = (u8)(pba_offset & PCI_MSIX_BIRMASK);\n        pba_paddr = read_pci_mem_bar(seg, pbus, pslot, pfunc, bir, vf);\n        WARN_ON(!pba_paddr);\n        pba_paddr += pba_offset & ~PCI_MSIX_BIRMASK;\n\n        msix->pba.first = PFN_DOWN(pba_paddr);\n        msix->pba.last = PFN_DOWN(pba_paddr +\n                                  BITS_TO_LONGS(msix->nr_entries) - 1);\n        WARN_ON(rangeset_overlaps_range(mmio_ro_ranges, msix->pba.first,\n                                        msix->pba.last));\n    }\n\n    if ( entry )\n    {\n        /* Map MSI-X table region */\n        u64 entry_paddr = table_paddr + msi->entry_nr * PCI_MSIX_ENTRY_SIZE;\n        int idx = msix_get_fixmap(msix, table_paddr, entry_paddr);\n        void __iomem *base;\n\n        if ( idx < 0 )\n        {\n            pci_conf_write16(dev->sbdf, msix_control_reg(pos),\n                             control & ~PCI_MSIX_FLAGS_ENABLE);\n            xfree(entry);\n            return idx;\n        }\n        base = fix_to_virt(idx) + (entry_paddr & (PAGE_SIZE - 1));\n\n        /* Mask interrupt here */\n        writel(1, base + PCI_MSIX_ENTRY_VECTOR_CTRL_OFFSET);\n\n        entry->msi_attrib.type = PCI_CAP_ID_MSIX;\n        entry->msi_attrib.is_64 = 1;\n        entry->msi_attrib.entry_nr = msi->entry_nr;\n        entry->msi_attrib.maskbit = 1;\n        entry->msi_attrib.host_masked = 1;\n        entry->msi_attrib.guest_masked = 1;\n        entry->msi_attrib.pos = pos;\n        entry->irq = msi->irq;\n        entry->dev = dev;\n        entry->mask_base = base;\n\n        list_add_tail(&entry->list, &dev->msi_list);\n        *desc = entry;\n    }\n\n    if ( !msix->used_entries )\n    {\n        maskall = false;\n        if ( !msix->guest_maskall )\n            control &= ~PCI_MSIX_FLAGS_MASKALL;\n        else\n            control |= PCI_MSIX_FLAGS_MASKALL;\n\n        if ( rangeset_add_range(mmio_ro_ranges, msix->table.first,\n                                msix->table.last) )\n            WARN();\n        if ( rangeset_add_range(mmio_ro_ranges, msix->pba.first,\n                                msix->pba.last) )\n            WARN();\n\n        if ( desc )\n        {\n            struct domain *currd = current->domain;\n            struct domain *d = dev->domain ?: currd;\n\n            if ( !is_hardware_domain(currd) || d != currd )\n                printk(\"%s use of MSI-X on %pp by %pd\\n\",\n                       is_hardware_domain(currd)\n                       ? XENLOG_WARNING \"Potentially insecure\"\n                       : XENLOG_ERR \"Insecure\",\n                       &dev->sbdf, d);\n            if ( !is_hardware_domain(d) &&\n                 /* Assume a domain without memory has no mappings yet. */\n                 (!is_hardware_domain(currd) || domain_tot_pages(d)) )\n                domain_crash(d);\n            /* XXX How to deal with existing mappings? */\n        }\n    }\n    WARN_ON(msix->table.first != (table_paddr >> PAGE_SHIFT));\n    ++msix->used_entries;\n\n    /* Restore MSI-X enabled bits */\n    if ( !hardware_domain )\n    {\n        /*\n         * ..., except for internal requests (before Dom0 starts), in which\n         * case we rather need to behave \"normally\", i.e. not follow the split\n         * brain model where Dom0 actually enables MSI (and disables INTx).\n         */\n        pci_intx(dev, false);\n        control |= PCI_MSIX_FLAGS_ENABLE;\n        control &= ~PCI_MSIX_FLAGS_MASKALL;\n        maskall = 0;\n    }\n    msix->host_maskall = maskall;\n    pci_conf_write16(dev->sbdf, msix_control_reg(pos), control);\n\n    return 0;\n}",
        "func_after": "static int msix_capability_init(struct pci_dev *dev,\n                                struct msi_info *msi,\n                                struct msi_desc **desc)\n{\n    struct arch_msix *msix = dev->msix;\n    struct msi_desc *entry = NULL;\n    u16 control;\n    u64 table_paddr;\n    u32 table_offset;\n    u16 seg = dev->seg;\n    u8 bus = dev->bus;\n    u8 slot = PCI_SLOT(dev->devfn);\n    u8 func = PCI_FUNC(dev->devfn);\n    bool maskall = msix->host_maskall, zap_on_error = false;\n    unsigned int pos = pci_find_cap_offset(seg, bus, slot, func,\n                                           PCI_CAP_ID_MSIX);\n\n    if ( !pos )\n        return -ENODEV;\n\n    ASSERT(pcidevs_locked());\n\n    control = pci_conf_read16(dev->sbdf, msix_control_reg(pos));\n    /*\n     * Ensure MSI-X interrupts are masked during setup. Some devices require\n     * MSI-X to be enabled before we can touch the MSI-X registers. We need\n     * to mask all the vectors to prevent interrupts coming in before they're\n     * fully set up.\n     */\n    msix->host_maskall = 1;\n    pci_conf_write16(dev->sbdf, msix_control_reg(pos),\n                     control | (PCI_MSIX_FLAGS_ENABLE |\n                                PCI_MSIX_FLAGS_MASKALL));\n\n    if ( unlikely(!memory_decoded(dev)) )\n    {\n        pci_conf_write16(dev->sbdf, msix_control_reg(pos),\n                         control & ~PCI_MSIX_FLAGS_ENABLE);\n        return -ENXIO;\n    }\n\n    if ( desc )\n    {\n        entry = alloc_msi_entry(1);\n        if ( !entry )\n        {\n            pci_conf_write16(dev->sbdf, msix_control_reg(pos),\n                             control & ~PCI_MSIX_FLAGS_ENABLE);\n            return -ENOMEM;\n        }\n        ASSERT(msi);\n    }\n\n    /* Locate MSI-X table region */\n    table_offset = pci_conf_read32(dev->sbdf, msix_table_offset_reg(pos));\n    if ( !msix->used_entries &&\n         (!msi ||\n          (is_hardware_domain(current->domain) &&\n           (dev->domain == current->domain || dev->domain == dom_io))) )\n    {\n        unsigned int bir = table_offset & PCI_MSIX_BIRMASK, pbus, pslot, pfunc;\n        int vf;\n        paddr_t pba_paddr;\n        unsigned int pba_offset;\n\n        if ( !dev->info.is_virtfn )\n        {\n            pbus = bus;\n            pslot = slot;\n            pfunc = func;\n            vf = -1;\n        }\n        else\n        {\n            pbus = dev->info.physfn.bus;\n            pslot = PCI_SLOT(dev->info.physfn.devfn);\n            pfunc = PCI_FUNC(dev->info.physfn.devfn);\n            vf = PCI_BDF2(dev->bus, dev->devfn);\n        }\n\n        table_paddr = read_pci_mem_bar(seg, pbus, pslot, pfunc, bir, vf);\n        WARN_ON(msi && msi->table_base != table_paddr);\n        if ( !table_paddr )\n        {\n            if ( !msi || !msi->table_base )\n            {\n                pci_conf_write16(dev->sbdf, msix_control_reg(pos),\n                                 control & ~PCI_MSIX_FLAGS_ENABLE);\n                xfree(entry);\n                return -ENXIO;\n            }\n            table_paddr = msi->table_base;\n        }\n        table_paddr += table_offset & ~PCI_MSIX_BIRMASK;\n\n        msix->table.first = PFN_DOWN(table_paddr);\n        msix->table.last = PFN_DOWN(table_paddr +\n                                    msix->nr_entries * PCI_MSIX_ENTRY_SIZE - 1);\n        WARN_ON(rangeset_overlaps_range(mmio_ro_ranges, msix->table.first,\n                                        msix->table.last));\n\n        pba_offset = pci_conf_read32(dev->sbdf, msix_pba_offset_reg(pos));\n        bir = (u8)(pba_offset & PCI_MSIX_BIRMASK);\n        pba_paddr = read_pci_mem_bar(seg, pbus, pslot, pfunc, bir, vf);\n        WARN_ON(!pba_paddr);\n        pba_paddr += pba_offset & ~PCI_MSIX_BIRMASK;\n\n        msix->pba.first = PFN_DOWN(pba_paddr);\n        msix->pba.last = PFN_DOWN(pba_paddr +\n                                  BITS_TO_LONGS(msix->nr_entries) - 1);\n        WARN_ON(rangeset_overlaps_range(mmio_ro_ranges, msix->pba.first,\n                                        msix->pba.last));\n\n        zap_on_error = true;\n    }\n    else if ( !msix->table.first )\n    {\n        pci_conf_write16(dev->sbdf, msix_control_reg(pos), control);\n        xfree(entry);\n        return -ENODATA;\n    }\n    else\n        table_paddr = (msix->table.first << PAGE_SHIFT) +\n                      PAGE_OFFSET(table_offset & ~PCI_MSIX_BIRMASK);\n\n    if ( entry )\n    {\n        /* Map MSI-X table region */\n        u64 entry_paddr = table_paddr + msi->entry_nr * PCI_MSIX_ENTRY_SIZE;\n        int idx = msix_get_fixmap(msix, table_paddr, entry_paddr);\n        void __iomem *base;\n\n        if ( idx < 0 )\n        {\n            if ( zap_on_error )\n            {\n                msix->table.first = 0;\n                msix->pba.first = 0;\n\n                control &= ~PCI_MSIX_FLAGS_ENABLE;\n            }\n\n            pci_conf_write16(dev->sbdf, msix_control_reg(pos), control);\n            xfree(entry);\n            return idx;\n        }\n        base = fix_to_virt(idx) + (entry_paddr & (PAGE_SIZE - 1));\n\n        /* Mask interrupt here */\n        writel(1, base + PCI_MSIX_ENTRY_VECTOR_CTRL_OFFSET);\n\n        entry->msi_attrib.type = PCI_CAP_ID_MSIX;\n        entry->msi_attrib.is_64 = 1;\n        entry->msi_attrib.entry_nr = msi->entry_nr;\n        entry->msi_attrib.maskbit = 1;\n        entry->msi_attrib.host_masked = 1;\n        entry->msi_attrib.guest_masked = 1;\n        entry->msi_attrib.pos = pos;\n        entry->irq = msi->irq;\n        entry->dev = dev;\n        entry->mask_base = base;\n\n        list_add_tail(&entry->list, &dev->msi_list);\n        *desc = entry;\n    }\n\n    if ( !msix->used_entries )\n    {\n        maskall = false;\n        if ( !msix->guest_maskall )\n            control &= ~PCI_MSIX_FLAGS_MASKALL;\n        else\n            control |= PCI_MSIX_FLAGS_MASKALL;\n\n        if ( rangeset_add_range(mmio_ro_ranges, msix->table.first,\n                                msix->table.last) )\n            WARN();\n        if ( rangeset_add_range(mmio_ro_ranges, msix->pba.first,\n                                msix->pba.last) )\n            WARN();\n\n        if ( desc )\n        {\n            struct domain *currd = current->domain;\n            struct domain *d = dev->domain ?: currd;\n\n            if ( !is_hardware_domain(currd) || d != currd )\n                printk(\"%s use of MSI-X on %pp by %pd\\n\",\n                       is_hardware_domain(currd)\n                       ? XENLOG_WARNING \"Potentially insecure\"\n                       : XENLOG_ERR \"Insecure\",\n                       &dev->sbdf, d);\n            if ( !is_hardware_domain(d) &&\n                 /* Assume a domain without memory has no mappings yet. */\n                 (!is_hardware_domain(currd) || domain_tot_pages(d)) )\n                domain_crash(d);\n            /* XXX How to deal with existing mappings? */\n        }\n    }\n    WARN_ON(msix->table.first != (table_paddr >> PAGE_SHIFT));\n    ++msix->used_entries;\n\n    /* Restore MSI-X enabled bits */\n    if ( !hardware_domain )\n    {\n        /*\n         * ..., except for internal requests (before Dom0 starts), in which\n         * case we rather need to behave \"normally\", i.e. not follow the split\n         * brain model where Dom0 actually enables MSI (and disables INTx).\n         */\n        pci_intx(dev, false);\n        control |= PCI_MSIX_FLAGS_ENABLE;\n        control &= ~PCI_MSIX_FLAGS_MASKALL;\n        maskall = 0;\n    }\n    msix->host_maskall = maskall;\n    pci_conf_write16(dev->sbdf, msix_control_reg(pos), control);\n\n    return 0;\n}",
        "description": "An issue was discovered in Xen through version 4.14.x where the PCI passthrough code improperly utilizes register data. Specifically, certain code paths in Xen's MSI handling act on unsanitized values read from device hardware registers. Although devices compliant with PCI specifications should not be able to affect these registers, many devices possess out-of-spec \"backdoor\" operations that can influence the results of these reads. A not fully trusted guest may exploit this vulnerability to crash Xen, resulting in a Denial of Service (DoS) for the entire system. Privilege escalation and information leaks are also potential risks. All versions of Xen supporting PCI passthrough are affected, but only x86 systems are vulnerable; Arm systems are not affected. Only guests with passed-through PCI devices may be able to leverage this vulnerability, and only systems passing through devices with out-of-spec (\"backdoor\") functionality can be impacted. Given that such out-of-spec functionality is common, it is advisable to assume that devices have this capability unless there is evidence to the contrary.",
        "commit": "When devices are assigned to less trusted or untrusted guests, they may alter their state unexpectedly, such as getting reset through unknown means. To prevent unauthorized access, reading Base Address Registers (BARs) from hardware should be restricted once a device is no longer owned by the Domain 0 (Dom0). Additionally, if a BAR cannot be read or returns zero, the caller-provided address should not be used unless the caller is trusted. The logic in `msix_capability_init()` has been restructured to ensure that only Dom0 (and only if the device isn't owned by a Domain User (DomU) yet) or calls through `PHYSDEVOP_prepare_msix` will result in reading the respective BAR registers. This reading should occur only as long as in-use table entries are known, with `PHYSDEVOP_prepare_msix` counting as a \"pseudo\" entry. In all other cases, previously recorded values should be used instead. The recorded values are cleared in `_pci_cleanup_msix()` and on the affected error path, which has also been adjusted to avoid blindly disabling Message Signaled Interrupts (MSI-X) when it was enabled upon entering the function. Variable declarations have been moved and adjusted to reduce their scopes and types, as part of XSA-337."
    },
    {
        "cwe": "CWE-385",
        "func_name": "openssl/ecdsa_sign_setup",
        "score": 0.8109728693962097,
        "func_before": "static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,\n\t\t\t\t\tBIGNUM **kinvp, BIGNUM **rp,\n\t\t\t\t\tconst unsigned char *dgst, int dlen)\n{\n\tBN_CTX   *ctx = NULL;\n\tBIGNUM\t *k = NULL, *r = NULL, *order = NULL, *X = NULL;\n\tEC_POINT *tmp_point=NULL;\n\tconst EC_GROUP *group;\n\tint \t ret = 0;\n\n\tif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\n\tif (ctx_in == NULL) \n\t{\n\t\tif ((ctx = BN_CTX_new()) == NULL)\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t\tctx = ctx_in;\n\n\tk     = BN_new();\t/* this value is later returned in *kinvp */\n\tr     = BN_new();\t/* this value is later returned in *rp    */\n\torder = BN_new();\n\tX     = BN_new();\n\tif (!k || !r || !order || !X)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t}\n\tif ((tmp_point = EC_POINT_new(group)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\tif (!EC_GROUP_get_order(group, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\n#ifdef OPENSSL_FIPS\n\tif (!fips_check_ec_prng(eckey))\n\t\tgoto err;\n#endif\n\t\n\tdo\n\t{\n\t\t/* get random k */\t\n\t\tdo\n#ifndef OPENSSL_NO_SHA512\n\t\t\tif (dgst != NULL)\n\t\t\t{\n\t\t\t\tif (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),\n\t\t\t\t\t\t\t   dgst, dlen, ctx))\n\t\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tif (!BN_rand_range(k, order))\n\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\twhile (BN_is_zero(k));\n\n\t\t/* We do not want timing information to leak the length of k,\n\t\t * so we compute G*k using an equivalent scalar of fixed\n\t\t * bit-length. */\n\n\t\tif (!BN_add(k, k, order)) goto err;\n\t\tif (BN_num_bits(k) <= BN_num_bits(order))\n\t\t\tif (!BN_add(k, k, order)) goto err;\n\n\t\t/* compute r the x-coordinate of generator * k */\n\t\tif (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t}\n\t\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#ifndef OPENSSL_NO_EC2M\n\t\telse /* NID_X9_62_characteristic_two_field */\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GF2m(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!BN_nnmod(r, X, order, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t}\n\t}\n\twhile (BN_is_zero(r));\n\n\t/* compute the inverse of k */\n\tif (!BN_mod_inverse(k, k, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\tgoto err;\t\n\t}\n\t/* clear old values if necessary */\n\tif (*rp != NULL)\n\t\tBN_clear_free(*rp);\n\tif (*kinvp != NULL) \n\t\tBN_clear_free(*kinvp);\n\t/* save the pre-computed values  */\n\t*rp    = r;\n\t*kinvp = k;\n\tret = 1;\nerr:\n\tif (!ret)\n\t{\n\t\tif (k != NULL) BN_clear_free(k);\n\t\tif (r != NULL) BN_clear_free(r);\n\t}\n\tif (ctx_in == NULL) \n\t\tBN_CTX_free(ctx);\n\tif (order != NULL)\n\t\tBN_free(order);\n\tif (tmp_point != NULL) \n\t\tEC_POINT_free(tmp_point);\n\tif (X)\n\t\tBN_clear_free(X);\n\treturn(ret);\n}",
        "func_after": "static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,\n\t\t\t\t\tBIGNUM **kinvp, BIGNUM **rp,\n\t\t\t\t\tconst unsigned char *dgst, int dlen)\n{\n\tBN_CTX   *ctx = NULL;\n\tBIGNUM\t *k = NULL, *r = NULL, *order = NULL, *X = NULL;\n\tEC_POINT *tmp_point=NULL;\n\tconst EC_GROUP *group;\n\tint \t ret = 0;\n\n\tif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\n\tif (ctx_in == NULL) \n\t{\n\t\tif ((ctx = BN_CTX_new()) == NULL)\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t\tctx = ctx_in;\n\n\tk     = BN_new();\t/* this value is later returned in *kinvp */\n\tr     = BN_new();\t/* this value is later returned in *rp    */\n\torder = BN_new();\n\tX     = BN_new();\n\tif (!k || !r || !order || !X)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t}\n\tif ((tmp_point = EC_POINT_new(group)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\tif (!EC_GROUP_get_order(group, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\n#ifdef OPENSSL_FIPS\n\tif (!fips_check_ec_prng(eckey))\n\t\tgoto err;\n#endif\n\t\n\tdo\n\t{\n\t\t/* get random k */\t\n\t\tdo\n#ifndef OPENSSL_NO_SHA512\n\t\t\tif (dgst != NULL)\n\t\t\t{\n\t\t\t\tif (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),\n\t\t\t\t\t\t\t   dgst, dlen, ctx))\n\t\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tif (!BN_rand_range(k, order))\n\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\twhile (BN_is_zero(k));\n\n\t\t/* We do not want timing information to leak the length of k,\n\t\t * so we compute G*k using an equivalent scalar of fixed\n\t\t * bit-length. */\n\n\t\tif (!BN_add(k, k, order)) goto err;\n\t\tif (BN_num_bits(k) <= BN_num_bits(order))\n\t\t\tif (!BN_add(k, k, order)) goto err;\n\n\t\t/* compute r the x-coordinate of generator * k */\n\t\tif (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t}\n\t\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#ifndef OPENSSL_NO_EC2M\n\t\telse /* NID_X9_62_characteristic_two_field */\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GF2m(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!BN_nnmod(r, X, order, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t}\n\t}\n\twhile (BN_is_zero(r));\n\n\t/* compute the inverse of k */\n\tif (EC_GROUP_get_mont_data(group) != NULL)\n\t\t{\n\t\t/* We want inverse in constant time, therefore we utilize the\n\t\t * fact order must be prime and use Fermats Little Theorem\n\t\t * instead. */\n\t\tif (!BN_set_word(X, 2) )\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (!BN_mod_sub(X, order, X, order, ctx))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tBN_set_flags(X, BN_FLG_CONSTTIME);\n\t\tif (!BN_mod_exp_mont_consttime(k, k, X, order, ctx, EC_GROUP_get_mont_data(group)))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tif (!BN_mod_inverse(k, k, order, ctx))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\t\n\t\t\t}\n\t\t}\n\n\t/* clear old values if necessary */\n\tif (*rp != NULL)\n\t\tBN_clear_free(*rp);\n\tif (*kinvp != NULL) \n\t\tBN_clear_free(*kinvp);\n\t/* save the pre-computed values  */\n\t*rp    = r;\n\t*kinvp = k;\n\tret = 1;\nerr:\n\tif (!ret)\n\t{\n\t\tif (k != NULL) BN_clear_free(k);\n\t\tif (r != NULL) BN_clear_free(r);\n\t}\n\tif (ctx_in == NULL) \n\t\tBN_CTX_free(ctx);\n\tif (order != NULL)\n\t\tBN_free(order);\n\tif (tmp_point != NULL) \n\t\tEC_POINT_free(tmp_point);\n\tif (X)\n\t\tBN_clear_free(X);\n\treturn(ret);\n}",
        "description": "A timing attack vulnerability was identified in OpenSSL versions prior to 1.0.1u, enabling a malicious user with local access to potentially recover ECDSA P-256 private keys through the exploitation of timing variations in cryptographic operations.",
        "commit": "The vulnerability knowledge has been abstracted and generalized as follows:\n\n\"The implementation of ECDSA includes an option to utilize BN_mod_exp_mont_consttime, a constant-time modular exponentiation function. This enhancement aims to improve the security of ECDSA operations.\""
    },
    {
        "cwe": "CWE-276",
        "func_name": "minetest/Server::handleCommand_InventoryAction",
        "score": 0.7876826524734497,
        "func_before": "void Server__handleCommand_InventoryAction(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\t// Strip command and create a stream\n\tstd::string datastring(pkt->getString(0), pkt->getSize());\n\tverbosestream << \"TOSERVER_INVENTORY_ACTION: data=\" << datastring\n\t\t<< std::endl;\n\tstd::istringstream is(datastring, std::ios_base::binary);\n\t// Create an action\n\tInventoryAction *a = InventoryAction::deSerialize(is);\n\tif (!a) {\n\t\tinfostream << \"TOSERVER_INVENTORY_ACTION: \"\n\t\t\t\t<< \"InventoryAction::deSerialize() returned NULL\"\n\t\t\t\t<< std::endl;\n\t\treturn;\n\t}\n\n\t// If something goes wrong, this player is to blame\n\tRollbackScopeActor rollback_scope(m_rollback,\n\t\t\tstd::string(\"player:\")+player->getName());\n\n\t/*\n\t\tNote: Always set inventory not sent, to repair cases\n\t\twhere the client made a bad prediction.\n\t*/\n\n\t/*\n\t\tHandle restrictions and special cases of the move action\n\t*/\n\tif (a->getType() == IAction::Move) {\n\t\tIMoveAction *ma = (IMoveAction*)a;\n\n\t\tma->from_inv.applyCurrentPlayer(player->getName());\n\t\tma->to_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ma->from_inv);\n\t\tif (ma->from_inv != ma->to_inv)\n\t\t\tm_inventory_mgr->setInventoryModified(ma->to_inv);\n\n\t\tbool from_inv_is_current_player =\n\t\t\t(ma->from_inv.type == InventoryLocation::PLAYER) &&\n\t\t\t(ma->from_inv.name == player->getName());\n\n\t\tbool to_inv_is_current_player =\n\t\t\t(ma->to_inv.type == InventoryLocation::PLAYER) &&\n\t\t\t(ma->to_inv.name == player->getName());\n\n\t\tInventoryLocation *remote = from_inv_is_current_player ?\n\t\t\t&ma->to_inv : &ma->from_inv;\n\n\t\t// Check for out-of-range interaction\n\t\tif (remote->type == InventoryLocation::NODEMETA) {\n\t\t\tv3f node_pos   = intToFloat(remote->p, BS);\n\t\t\tv3f player_pos = player->getPlayerSAO()->getEyePosition();\n\t\t\tf32 d = player_pos.getDistanceFrom(node_pos);\n\t\t\tif (!checkInteractDistance(player, d, \"inventory\"))\n\t\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items out of craftpreview\n\t\t*/\n\t\tif (ma->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because src is \" << ma->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items into craftresult and craftpreview\n\t\t*/\n\t\tif (ma->to_list == \"craftpreview\" || ma->to_list == \"craftresult\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because dst is \" << ma->to_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow moving items in elsewhere than player's inventory\n\t\t// if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\") &&\n\t\t\t\t(!from_inv_is_current_player ||\n\t\t\t\t!to_inv_is_current_player)) {\n\t\t\tinfostream << \"Cannot move outside of player's inventory: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the drop action\n\t*/\n\telse if (a->getType() == IAction::Drop) {\n\t\tIDropAction *da = (IDropAction*)a;\n\n\t\tda->from_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(da->from_inv);\n\n\t\t/*\n\t\t\tDisable dropping items out of craftpreview\n\t\t*/\n\t\tif (da->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because src is \" << da->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if dead\n\t\tif (playersao->isDead()) {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because player is dead.\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the craft action\n\t*/\n\telse if (a->getType() == IAction::Craft) {\n\t\tICraftAction *ca = (ICraftAction*)a;\n\n\t\tca->craft_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ca->craft_inv);\n\n\t\t//bool craft_inv_is_current_player =\n\t\t//\t(ca->craft_inv.type == InventoryLocation::PLAYER) &&\n\t\t//\t(ca->craft_inv.name == player->getName());\n\n\t\t// Disallow crafting if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tinfostream << \"Cannot craft: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Do the action\n\ta->apply(m_inventory_mgr.get(), playersao, this);\n\t// Eat the action\n\tdelete a;\n}",
        "func_after": "void Server__handleCommand_InventoryAction(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\t// Strip command and create a stream\n\tstd::string datastring(pkt->getString(0), pkt->getSize());\n\tverbosestream << \"TOSERVER_INVENTORY_ACTION: data=\" << datastring\n\t\t<< std::endl;\n\tstd::istringstream is(datastring, std::ios_base::binary);\n\t// Create an action\n\tInventoryAction *a = InventoryAction::deSerialize(is);\n\tif (!a) {\n\t\tinfostream << \"TOSERVER_INVENTORY_ACTION: \"\n\t\t\t\t<< \"InventoryAction::deSerialize() returned NULL\"\n\t\t\t\t<< std::endl;\n\t\treturn;\n\t}\n\n\t// If something goes wrong, this player is to blame\n\tRollbackScopeActor rollback_scope(m_rollback,\n\t\t\tstd::string(\"player:\")+player->getName());\n\n\t/*\n\t\tNote: Always set inventory not sent, to repair cases\n\t\twhere the client made a bad prediction.\n\t*/\n\n\t/*\n\t\tHandle restrictions and special cases of the move action\n\t*/\n\tif (a->getType() == IAction::Move) {\n\t\tIMoveAction *ma = (IMoveAction*)a;\n\n\t\tma->from_inv.applyCurrentPlayer(player->getName());\n\t\tma->to_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ma->from_inv);\n\t\tif (ma->from_inv != ma->to_inv)\n\t\t\tm_inventory_mgr->setInventoryModified(ma->to_inv);\n\n\t\tbool from_inv_is_current_player = false;\n\t\tif (ma->from_inv.type == InventoryLocation::PLAYER) {\n\t\t\tif (ma->from_inv.name != player->getName())\n\t\t\t\treturn;\n\t\t\tfrom_inv_is_current_player = true;\n\t\t}\n\t\t\n\t\tbool to_inv_is_current_player = false;\n\t\tif (ma->to_inv.type == InventoryLocation::PLAYER) {\n\t\t\tif (ma->to_inv.name != player->getName())\n\t\t\t\treturn;\n\t\t\tto_inv_is_current_player = true;\n\t\t}\n\n\t\tInventoryLocation *remote = from_inv_is_current_player ?\n\t\t\t&ma->to_inv : &ma->from_inv;\n\n\t\t// Check for out-of-range interaction\n\t\tif (remote->type == InventoryLocation::NODEMETA) {\n\t\t\tv3f node_pos   = intToFloat(remote->p, BS);\n\t\t\tv3f player_pos = player->getPlayerSAO()->getEyePosition();\n\t\t\tf32 d = player_pos.getDistanceFrom(node_pos);\n\t\t\tif (!checkInteractDistance(player, d, \"inventory\"))\n\t\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items out of craftpreview\n\t\t*/\n\t\tif (ma->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because src is \" << ma->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items into craftresult and craftpreview\n\t\t*/\n\t\tif (ma->to_list == \"craftpreview\" || ma->to_list == \"craftresult\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because dst is \" << ma->to_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow moving items in elsewhere than player's inventory\n\t\t// if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\") &&\n\t\t\t\t(!from_inv_is_current_player ||\n\t\t\t\t!to_inv_is_current_player)) {\n\t\t\tinfostream << \"Cannot move outside of player's inventory: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the drop action\n\t*/\n\telse if (a->getType() == IAction::Drop) {\n\t\tIDropAction *da = (IDropAction*)a;\n\n\t\tda->from_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(da->from_inv);\n\n\t\t/*\n\t\t\tDisable dropping items out of craftpreview\n\t\t*/\n\t\tif (da->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because src is \" << da->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if dead\n\t\tif (playersao->isDead()) {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because player is dead.\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the craft action\n\t*/\n\telse if (a->getType() == IAction::Craft) {\n\t\tICraftAction *ca = (ICraftAction*)a;\n\n\t\tca->craft_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ca->craft_inv);\n\n\t\t//bool craft_inv_is_current_player =\n\t\t//\t(ca->craft_inv.type == InventoryLocation::PLAYER) &&\n\t\t//\t(ca->craft_inv.name == player->getName());\n\n\t\t// Disallow crafting if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tinfostream << \"Cannot craft: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Do the action\n\ta->apply(m_inventory_mgr.get(), playersao, this);\n\t// Eat the action\n\tdelete a;\n}",
        "description": "In versions of Minetest prior to 5.4.0, players have the capability to modify the inventory contents of other players, either by adding or removing items.",
        "commit": "output: \"A vulnerability that allows players to access the inventories of other players.\""
    },
    {
        "cwe": "CWE-326",
        "func_name": "torvalds/__ipv6_select_ident",
        "score": 0.7846665382385254,
        "func_before": "static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tu32 hash, id;\n\n\thash = __ipv6_addr_jhash(dst, hashrnd);\n\thash = __ipv6_addr_jhash(src, hash);\n\thash ^= net_hash_mix(net);\n\n\t/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,\n\t * set the hight order instead thus minimizing possible future\n\t * collisions.\n\t */\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\n\treturn id;\n}",
        "func_after": "static u32 __ipv6_select_ident(struct net *net,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tconst struct {\n\t\tstruct in6_addr dst;\n\t\tstruct in6_addr src;\n\t} __aligned(SIPHASH_ALIGNMENT) combined = {\n\t\t.dst = *dst,\n\t\t.src = *src,\n\t};\n\tu32 hash, id;\n\n\t/* Note the following code is not safe, but this is okay. */\n\tif (unlikely(siphash_key_is_zero(&net->ipv4.ip_id_key)))\n\t\tget_random_bytes(&net->ipv4.ip_id_key,\n\t\t\t\t sizeof(net->ipv4.ip_id_key));\n\n\thash = siphash(&combined, sizeof(combined), &net->ipv4.ip_id_key);\n\n\t/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,\n\t * set the hight order instead thus minimizing possible future\n\t * collisions.\n\t */\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\n\treturn id;\n}",
        "description": "In versions of the Linux kernel prior to 5.1.7, an attacker can track devices by analyzing the IP ID values generated by the kernel for connectionless protocols such as UDP and ICMP. By sending traffic to multiple destination IP addresses, it is possible to induce hash collisions within the counter array, potentially revealing the hashing key through enumeration. This vulnerability can be exploited by hosting a specially crafted web page that leverages technologies like WebRTC or gQUIC to direct UDP traffic to IP addresses controlled by the attacker.",
        "commit": "The IP ID generation mechanism in the networking stack is deemed insufficiently secure due to potential vulnerabilities that could be exploited by attackers. Despite recent improvements such as the introduction of a 64-bit key and the Jenkins hash function, these measures are still considered risky. Therefore, it is recommended to transition to using siphash with its 128-bit keys to enhance the security of IP ID generation."
    }
]