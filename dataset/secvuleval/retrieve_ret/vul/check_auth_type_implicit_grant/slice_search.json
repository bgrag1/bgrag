[
    {
        "cwe": "CWE-601",
        "func_name": "OpenIDC/oidc_handle_logout",
        "score": 0.7618118524551392,
        "func_before": "static int oidc_handle_logout(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\toidc_provider_t *provider = NULL;\n\t/* pickup the command or URL where the user wants to go after logout */\n\tchar *url = NULL;\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_LOGOUT, &url);\n\n\toidc_debug(r, \"enter (url=%s)\", url);\n\n\tif (oidc_is_front_channel_logout(url)) {\n\t\treturn oidc_handle_logout_request(r, c, session, url);\n\t} else if (oidc_is_back_channel_logout(url)) {\n\t\treturn oidc_handle_logout_backchannel(r, c);\n\t}\n\n\tif ((url == NULL) || (apr_strnatcmp(url, \"\") == 0)) {\n\n\t\turl = c->default_slo_url;\n\n\t} else {\n\n\t\t/* do input validation on the logout parameter value */\n\n\t\tconst char *error_description = NULL;\n\t\tapr_uri_t uri;\n\n\t\tif (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {\n\t\t\tconst char *error_description = apr_psprintf(r->pool,\n\t\t\t\t\t\"Logout URL malformed: %s\", url);\n\t\t\toidc_error(r, \"%s\", error_description);\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Malformed URL\", error_description,\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\n\t\t}\n\n\t\tconst char *c_host = oidc_get_current_url_host(r);\n\t\tif ((uri.hostname != NULL)\n\t\t\t\t&& ((strstr(c_host, uri.hostname) == NULL)\n\t\t\t\t\t\t|| (strstr(uri.hostname, c_host) == NULL))) {\n\t\t\terror_description =\n\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n\t\t\toidc_error(r, \"%s\", error_description);\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\", error_description,\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t}\n\n\t\t/* validate the URL to prevent HTTP header splitting */\n\t\tif (((strstr(url, \"\\n\") != NULL) || strstr(url, \"\\r\") != NULL)) {\n\t\t\terror_description =\n\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\"logout value \\\"%s\\\" contains illegal \\\"\\n\\\" or \\\"\\r\\\" character(s)\",\n\t\t\t\t\t\t\turl);\n\t\t\toidc_error(r, \"%s\", error_description);\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\", error_description,\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t}\n\t}\n\n\toidc_get_provider_from_session(r, c, session, &provider);\n\n\tif ((provider != NULL) && (provider->end_session_endpoint != NULL)) {\n\n\t\tconst char *id_token_hint = oidc_session_get_idtoken(r, session);\n\n\t\tchar *logout_request = apr_pstrdup(r->pool,\n\t\t\t\tprovider->end_session_endpoint);\n\t\tif (id_token_hint != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool, \"%s%sid_token_hint=%s\",\n\t\t\t\t\tlogout_request, strchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, id_token_hint));\n\t\t}\n\n\t\tif (url != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool,\n\t\t\t\t\t\"%s%spost_logout_redirect_uri=%s\", logout_request,\n\t\t\t\t\tstrchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, url));\n\t\t}\n\t\turl = logout_request;\n\t}\n\n\treturn oidc_handle_logout_request(r, c, session, url);\n}",
        "func_after": "static int oidc_handle_logout(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\toidc_provider_t *provider = NULL;\n\t/* pickup the command or URL where the user wants to go after logout */\n\tchar *url = NULL;\n\tchar *error_str = NULL;\n\tchar *error_description = NULL;\n\n\toidc_util_get_request_parameter(r, OIDC_REDIRECT_URI_REQUEST_LOGOUT, &url);\n\n\toidc_debug(r, \"enter (url=%s)\", url);\n\n\tif (oidc_is_front_channel_logout(url)) {\n\t\treturn oidc_handle_logout_request(r, c, session, url);\n\t} else if (oidc_is_back_channel_logout(url)) {\n\t\treturn oidc_handle_logout_backchannel(r, c);\n\t}\n\n\tif ((url == NULL) || (apr_strnatcmp(url, \"\") == 0)) {\n\n\t\turl = c->default_slo_url;\n\n\t} else {\n\n\t\t/* do input validation on the logout parameter value */\n\t\tif (oidc_validate_post_logout_url(r, url, &error_str,\n\t\t\t\t&error_description) == FALSE) {\n\t\t\treturn oidc_util_html_send_error(r, c->error_template, error_str,\n\t\t\t\t\terror_description,\n\t\t\t\t\tHTTP_BAD_REQUEST);\n\t\t}\n\t}\n\n\toidc_get_provider_from_session(r, c, session, &provider);\n\n\tif ((provider != NULL) && (provider->end_session_endpoint != NULL)) {\n\n\t\tconst char *id_token_hint = oidc_session_get_idtoken(r, session);\n\n\t\tchar *logout_request = apr_pstrdup(r->pool,\n\t\t\t\tprovider->end_session_endpoint);\n\t\tif (id_token_hint != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool, \"%s%sid_token_hint=%s\",\n\t\t\t\t\tlogout_request, strchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, id_token_hint));\n\t\t}\n\n\t\tif (url != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool,\n\t\t\t\t\t\"%s%spost_logout_redirect_uri=%s\", logout_request,\n\t\t\t\t\tstrchr(logout_request ? logout_request : \"\",\n\t\t\t\t\t\t\tOIDC_CHAR_QUERY) != NULL ?\n\t\t\t\t\t\t\t\t\tOIDC_STR_AMP :\n\t\t\t\t\t\t\t\t\tOIDC_STR_QUERY,\n\t\t\t\t\t\t\t\t\toidc_util_escape_string(r, url));\n\t\t}\n\t\turl = logout_request;\n\t}\n\n\treturn oidc_handle_logout_request(r, c, session, url);\n}",
        "description": "A flaw was identified in mod_auth_openidc versions prior to 2.4.0.1, involving an open redirect vulnerability in URLs that include trailing slashes. This issue is analogous to CVE-2019-3877 found in mod_auth_mellon.",
        "commit": "Improving the validation of the post-logout URL to prevent open redirects."
    },
    {
        "cwe": "CWE-613",
        "func_name": "arangodb/RestAuthHandler::execute",
        "score": 0.7070044875144958,
        "func_before": "RestStatus RestAuthHandler__execute() {\n  auto const type = _request->requestType();\n  if (type != rest::RequestType::POST) {\n    generateError(rest::ResponseCode::METHOD_NOT_ALLOWED, TRI_ERROR_HTTP_METHOD_NOT_ALLOWED);\n    return RestStatus::DONE;\n  }\n\n  bool parseSuccess = false;\n  VPackSlice slice = this->parseVPackBody(parseSuccess);\n  if (!parseSuccess) { // error already set\n    return RestStatus::DONE;\n  }\n\n  if (!slice.isObject()) {\n    return badRequest();\n  }\n\n  VPackSlice usernameSlice = slice.get(\"username\");\n  VPackSlice passwordSlice = slice.get(\"password\");\n\n  if (!usernameSlice.isString() || !passwordSlice.isString()) {\n    return badRequest();\n  }\n\n  _username = usernameSlice.copyString();\n  std::string const password = passwordSlice.copyString();\n\n  auth::UserManager* um = AuthenticationFeature::instance()->userManager();\n  if (um == nullptr) {\n    std::string msg = \"This server does not support users\";\n    LOG_TOPIC(\"2e7d4\", ERR, Logger::AUTHENTICATION) << msg;\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED, msg);\n  } else if (um->checkPassword(_username, password)) {\n    VPackBuilder resultBuilder;\n    {\n      VPackObjectBuilder b(&resultBuilder);\n      std::string jwt = generateJwt(_username, password);\n      resultBuilder.add(\"jwt\", VPackValue(jwt));\n    }\n\n    _isValid = true;\n    generateDocument(resultBuilder.slice(), true, &VPackOptions::Defaults);\n  } else {\n    // mop: rfc 2616 10.4.2 (if credentials wrong 401)\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED,\n                  \"Wrong credentials\");\n  }\n  return RestStatus::DONE;\n}",
        "func_after": "RestStatus RestAuthHandler__execute() {\n  auto const type = _request->requestType();\n  if (type != rest::RequestType::POST) {\n    generateError(rest::ResponseCode::METHOD_NOT_ALLOWED, TRI_ERROR_HTTP_METHOD_NOT_ALLOWED);\n    return RestStatus::DONE;\n  }\n\n  bool parseSuccess = false;\n  VPackSlice slice = this->parseVPackBody(parseSuccess);\n  if (!parseSuccess) { // error already set\n    return RestStatus::DONE;\n  }\n\n  if (!slice.isObject()) {\n    return badRequest();\n  }\n\n  VPackSlice usernameSlice = slice.get(\"username\");\n  VPackSlice passwordSlice = slice.get(\"password\");\n\n  if (!usernameSlice.isString() || !passwordSlice.isString()) {\n    return badRequest();\n  }\n\n  std::string const username = usernameSlice.copyString();\n  std::string const password = passwordSlice.copyString();\n\n  bool isValid = false;\n\n  auto guard = scopeGuard([&]() {\n    try {\n      if (isValid) {\n        events::LoggedIn(*_request, username);\n      } else {\n        events::CredentialsBad(*_request, username);\n      }\n    } catch (...) {\n      // nothing we can do\n    }\n  });\n  \n  auth::UserManager* um = AuthenticationFeature::instance()->userManager();\n  if (um == nullptr) {\n    std::string msg = \"This server does not support users\";\n    LOG_TOPIC(\"2e7d4\", ERR, Logger::AUTHENTICATION) << msg;\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED, msg);\n  } else if (um->checkPassword(username, password)) {\n    VPackBuilder resultBuilder;\n    {\n      VPackObjectBuilder b(&resultBuilder);\n      resultBuilder.add(\"jwt\", VPackValue(generateJwt(username)));\n    }\n\n    isValid = true;\n    generateDocument(resultBuilder.slice(), true, &VPackOptions::Defaults);\n  } else {\n    // mop: rfc 2616 10.4.2 (if credentials wrong 401)\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED,\n                  \"Wrong credentials\");\n  }\n  return RestStatus::DONE;\n}",
        "description": "ArangoDB versions v3.7.6 through v3.8.3 are susceptible to an Insufficient Session Expiration issue. Specifically, when an administrator changes a user's password, the associated session is not invalidated. This failure allows a malicious user who is still logged in to continue performing arbitrary actions within the system.",
        "commit": "The startup parameter `--server.session-timeout` has been revived."
    },
    {
        "cwe": "CWE-287",
        "func_name": "torvalds/ieee80211_change_station",
        "score": 0.7619398236274719,
        "func_before": "static int ieee80211_change_station(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *dev, const u8 *mac,\n\t\t\t\t    struct station_parameters *params)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct sta_info *sta;\n\tstruct ieee80211_sub_if_data *vlansdata;\n\tenum cfg80211_station_type statype;\n\tint err;\n\n\tmutex_lock(&local->sta_mtx);\n\n\tsta = sta_info_get_bss(sdata, mac);\n\tif (!sta) {\n\t\terr = -ENOENT;\n\t\tgoto out_err;\n\t}\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (sdata->u.mesh.user_mpm)\n\t\t\tstatype = CFG80211_STA_MESH_PEER_USER;\n\t\telse\n\t\t\tstatype = CFG80211_STA_MESH_PEER_KERNEL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tstatype = CFG80211_STA_IBSS;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (!test_sta_flag(sta, WLAN_STA_TDLS_PEER)) {\n\t\t\tstatype = CFG80211_STA_AP_STA;\n\t\t\tbreak;\n\t\t}\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tstatype = CFG80211_STA_TDLS_PEER_ACTIVE;\n\t\telse\n\t\t\tstatype = CFG80211_STA_TDLS_PEER_SETUP;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (test_sta_flag(sta, WLAN_STA_ASSOC))\n\t\t\tstatype = CFG80211_STA_AP_CLIENT;\n\t\telse\n\t\t\tstatype = CFG80211_STA_AP_CLIENT_UNASSOC;\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\terr = cfg80211_check_station_change(wiphy, params, statype);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (params->vlan && params->vlan != sta->sdata->dev) {\n\t\tvlansdata = IEEE80211_DEV_TO_SUB_IF(params->vlan);\n\n\t\tif (params->vlan->ieee80211_ptr->use_4addr) {\n\t\t\tif (vlansdata->u.vlan.sta) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\trcu_assign_pointer(vlansdata->u.vlan.sta, sta);\n\t\t\t__ieee80211_check_fast_rx_iface(vlansdata);\n\t\t}\n\n\t\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t\t    sta->sdata->u.vlan.sta)\n\t\t\tRCU_INIT_POINTER(sta->sdata->u.vlan.sta, NULL);\n\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tieee80211_vif_dec_num_mcast(sta->sdata);\n\n\t\tsta->sdata = vlansdata;\n\t\tieee80211_check_fast_xmit(sta);\n\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tieee80211_vif_inc_num_mcast(sta->sdata);\n\n\t\tcfg80211_send_layer2_update(sta->sdata->dev, sta->sta.addr);\n\t}\n\n\terr = sta_apply_parameters(local, sta, params);\n\tif (err)\n\t\tgoto out_err;\n\n\tmutex_unlock(&local->sta_mtx);\n\n\tif ((sdata->vif.type == NL80211_IFTYPE_AP ||\n\t     sdata->vif.type == NL80211_IFTYPE_AP_VLAN) &&\n\t    sta->known_smps_mode != sta->sdata->bss->req_smps &&\n\t    test_sta_flag(sta, WLAN_STA_AUTHORIZED) &&\n\t    sta_info_tx_streams(sta) != 1) {\n\t\tht_dbg(sta->sdata,\n\t\t       \"%pM just authorized and MIMO capable - update SMPS\\n\",\n\t\t       sta->sta.addr);\n\t\tieee80211_send_smps_action(sta->sdata,\n\t\t\tsta->sdata->bss->req_smps,\n\t\t\tsta->sta.addr,\n\t\t\tsta->sdata->vif.bss_conf.bssid);\n\t}\n\n\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t    params->sta_flags_mask & BIT(NL80211_STA_FLAG_AUTHORIZED)) {\n\t\tieee80211_recalc_ps(local);\n\t\tieee80211_recalc_ps_vif(sdata);\n\t}\n\n\treturn 0;\nout_err:\n\tmutex_unlock(&local->sta_mtx);\n\treturn err;\n}",
        "func_after": "static int ieee80211_change_station(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *dev, const u8 *mac,\n\t\t\t\t    struct station_parameters *params)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct sta_info *sta;\n\tstruct ieee80211_sub_if_data *vlansdata;\n\tenum cfg80211_station_type statype;\n\tint err;\n\n\tmutex_lock(&local->sta_mtx);\n\n\tsta = sta_info_get_bss(sdata, mac);\n\tif (!sta) {\n\t\terr = -ENOENT;\n\t\tgoto out_err;\n\t}\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (sdata->u.mesh.user_mpm)\n\t\t\tstatype = CFG80211_STA_MESH_PEER_USER;\n\t\telse\n\t\t\tstatype = CFG80211_STA_MESH_PEER_KERNEL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tstatype = CFG80211_STA_IBSS;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (!test_sta_flag(sta, WLAN_STA_TDLS_PEER)) {\n\t\t\tstatype = CFG80211_STA_AP_STA;\n\t\t\tbreak;\n\t\t}\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tstatype = CFG80211_STA_TDLS_PEER_ACTIVE;\n\t\telse\n\t\t\tstatype = CFG80211_STA_TDLS_PEER_SETUP;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (test_sta_flag(sta, WLAN_STA_ASSOC))\n\t\t\tstatype = CFG80211_STA_AP_CLIENT;\n\t\telse\n\t\t\tstatype = CFG80211_STA_AP_CLIENT_UNASSOC;\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\terr = cfg80211_check_station_change(wiphy, params, statype);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (params->vlan && params->vlan != sta->sdata->dev) {\n\t\tvlansdata = IEEE80211_DEV_TO_SUB_IF(params->vlan);\n\n\t\tif (params->vlan->ieee80211_ptr->use_4addr) {\n\t\t\tif (vlansdata->u.vlan.sta) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\trcu_assign_pointer(vlansdata->u.vlan.sta, sta);\n\t\t\t__ieee80211_check_fast_rx_iface(vlansdata);\n\t\t}\n\n\t\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t\t    sta->sdata->u.vlan.sta)\n\t\t\tRCU_INIT_POINTER(sta->sdata->u.vlan.sta, NULL);\n\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tieee80211_vif_dec_num_mcast(sta->sdata);\n\n\t\tsta->sdata = vlansdata;\n\t\tieee80211_check_fast_xmit(sta);\n\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED)) {\n\t\t\tieee80211_vif_inc_num_mcast(sta->sdata);\n\t\t\tcfg80211_send_layer2_update(sta->sdata->dev,\n\t\t\t\t\t\t    sta->sta.addr);\n\t\t}\n\t}\n\n\terr = sta_apply_parameters(local, sta, params);\n\tif (err)\n\t\tgoto out_err;\n\n\tmutex_unlock(&local->sta_mtx);\n\n\tif ((sdata->vif.type == NL80211_IFTYPE_AP ||\n\t     sdata->vif.type == NL80211_IFTYPE_AP_VLAN) &&\n\t    sta->known_smps_mode != sta->sdata->bss->req_smps &&\n\t    test_sta_flag(sta, WLAN_STA_AUTHORIZED) &&\n\t    sta_info_tx_streams(sta) != 1) {\n\t\tht_dbg(sta->sdata,\n\t\t       \"%pM just authorized and MIMO capable - update SMPS\\n\",\n\t\t       sta->sta.addr);\n\t\tieee80211_send_smps_action(sta->sdata,\n\t\t\tsta->sdata->bss->req_smps,\n\t\t\tsta->sta.addr,\n\t\t\tsta->sdata->vif.bss_conf.bssid);\n\t}\n\n\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t    params->sta_flags_mask & BIT(NL80211_STA_FLAG_AUTHORIZED)) {\n\t\tieee80211_recalc_ps(local);\n\t\tieee80211_recalc_ps_vif(sdata);\n\t}\n\n\treturn 0;\nout_err:\n\tmutex_unlock(&local->sta_mtx);\n\treturn err;\n}",
        "description": "An exploitable denial-of-service vulnerability exists in the Linux kernel prior to version 5.3. An attacker can exploit this vulnerability by inducing Access Points (APs) to send Inter-Access Point Protocol (IAPP) location updates for stations before the necessary authentication process is complete. This could result in various denial-of-service scenarios, including CAM table attacks or traffic flapping if the attacker impersonates existing clients in neighboring APs within the same wireless infrastructure. The attacker can achieve this by forging Authentication and Association Request packets.",
        "commit": "The Layer 2 Update frame is utilized to notify bridges of a station's movement to a new Access Point (AP), even if the station does not transmit any frames afterward. According to IEEE Std 802.11F-2003, this update should occur based on the MLME-ASSOCIATE.indication, which happens before the completion of the 4-way handshake. However, this standard predates the introduction of Robust Security Network (RSN) protocols (IEEE Std 802.11i-2004) and thus does not account for RSN use cases. Additionally, the IEEE Std 802.11F-2003 was withdrawn in 2006 and should no longer be used.\n\nTransmitting the Layer 2 Update frame immediately after association is acceptable for open networks and certain authentication methods like SAE, FT protocol, or FILS, where the station is authenticated by the time association completes. However, it is inappropriate for RSN with PSK or EAP authentication, as full authentication occurs only after the 4-way handshake. Attackers could exploit the premature transmission of the Layer 2 Update frame to disrupt bridge behavior.\n\nTo address this issue, the transmission of the Layer 2 Update frame should be postponed until the station entry is marked as authorized. Similarly, VLAN binding updates should only be sent if the station entry has been authorized."
    },
    {
        "cwe": "CWE-532",
        "func_name": "torvalds/klsi_105_get_line_state",
        "score": 0.7365542650222778,
        "func_before": "static int klsi_105_get_line_state(struct usb_serial_port *port,\n\t\t\t\t   unsigned long *line_state_p)\n{\n\tint rc;\n\tu8 *status_buf;\n\t__u16 status;\n\n\tdev_info(&port->serial->dev->dev, \"sending SIO Poll request\\n\");\n\n\tstatus_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);\n\tif (!status_buf)\n\t\treturn -ENOMEM;\n\n\tstatus_buf[0] = 0xff;\n\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, /* value */\n\t\t\t     0, /* index */\n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc < 0)\n\t\tdev_err(&port->dev, \"Reading line status failed (error = %d)\\n\",\n\t\t\trc);\n\telse {\n\t\tstatus = get_unaligned_le16(status_buf);\n\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\n\tkfree(status_buf);\n\treturn rc;\n}",
        "func_after": "static int klsi_105_get_line_state(struct usb_serial_port *port,\n\t\t\t\t   unsigned long *line_state_p)\n{\n\tint rc;\n\tu8 *status_buf;\n\t__u16 status;\n\n\tdev_info(&port->serial->dev->dev, \"sending SIO Poll request\\n\");\n\n\tstatus_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);\n\tif (!status_buf)\n\t\treturn -ENOMEM;\n\n\tstatus_buf[0] = 0xff;\n\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, /* value */\n\t\t\t     0, /* index */\n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc != KLSI_STATUSBUF_LEN) {\n\t\tdev_err(&port->dev, \"reading line status failed: %d\\n\", rc);\n\t\tif (rc >= 0)\n\t\t\trc = -EIO;\n\t} else {\n\t\tstatus = get_unaligned_le16(status_buf);\n\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\n\tkfree(status_buf);\n\treturn rc;\n}",
        "description": "The `klsi_105_get_line_state` function in the Linux kernel's USB serial driver, prior to version 4.9.5, includes uninitialized heap memory content in a log entry when failing to read the line status. This flaw enables local users to extract sensitive information by accessing the log.",
        "commit": "The current implementation of the USB serial driver for the KL5KUSB105 device fails to properly detect short data transfers during attempts to read the line state. Additionally, it logs the contents of an uninitialized heap transfer buffer, which could lead to unintended information disclosure."
    }
]