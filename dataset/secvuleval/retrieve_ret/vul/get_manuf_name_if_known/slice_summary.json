[
    {
        "cwe": "CWE-22",
        "func_name": "asterisk/action_getconfig",
        "score": 0.7871339917182922,
        "func_before": "static int action_getconfig(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tconst char *category = astman_get_header(m, \"Category\");\n\tconst char *filter = astman_get_header(m, \"Filter\");\n\tconst char *category_name;\n\tint catcount = 0;\n\tint lineno = 0;\n\tstruct ast_category *cur_category = NULL;\n\tstruct ast_variable *v;\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\n\tif (ast_strlen_zero(fn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\n\tif (restrictedFile(fn)) {\n\t\tastman_send_error(s, m, \"File requires escalated priveledges\");\n\t\treturn 0;\n\t}\n\n\tcfg = ast_config_load2(fn, \"manager\", config_flags);\n\tif (cfg == CONFIG_STATUS_FILEMISSING) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\n\tastman_start_ack(s, m);\n\twhile ((cur_category = ast_category_browse_filtered(cfg, category, cur_category, filter))) {\n\t\tstruct ast_str *templates;\n\n\t\tcategory_name = ast_category_get_name(cur_category);\n\t\tlineno = 0;\n\t\tastman_append(s, \"Category-%06d: %s\\r\\n\", catcount, category_name);\n\n\t\tif (ast_category_is_template(cur_category)) {\n\t\t\tastman_append(s, \"IsTemplate-%06d: %d\\r\\n\", catcount, 1);\n\t\t}\n\n\t\tif ((templates = ast_category_get_templates(cur_category))\n\t\t\t&& ast_str_strlen(templates) > 0) {\n\t\t\tastman_append(s, \"Templates-%06d: %s\\r\\n\", catcount, ast_str_buffer(templates));\n\t\t\tast_free(templates);\n\t\t}\n\n\t\tfor (v = ast_category_first(cur_category); v; v = v->next) {\n\t\t\tastman_append(s, \"Line-%06d-%06d: %s=%s\\r\\n\", catcount, lineno++, v->name, v->value);\n\t\t}\n\n\t\tcatcount++;\n\t}\n\n\tif (!ast_strlen_zero(category) && catcount == 0) { /* TODO: actually, a config with no categories doesn't even get loaded */\n\t\tastman_append(s, \"No categories found\\r\\n\");\n\t}\n\n\tast_config_destroy(cfg);\n\tastman_append(s, \"\\r\\n\");\n\n\treturn 0;\n}",
        "func_after": "static int action_getconfig(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tconst char *category = astman_get_header(m, \"Category\");\n\tconst char *filter = astman_get_header(m, \"Filter\");\n\tconst char *category_name;\n\tint catcount = 0;\n\tint lineno = 0;\n\tint ret = 0;\n\tstruct ast_category *cur_category = NULL;\n\tstruct ast_variable *v;\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\n\tif (ast_strlen_zero(fn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\n\tret = restrictedFile(fn);\n\tif (ret == 1) {\n\t\tastman_send_error(s, m, \"File requires escalated priveledges\");\n\t\treturn 0;\n\t} else if (ret == -1) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t}\n\n\tcfg = ast_config_load2(fn, \"manager\", config_flags);\n\tif (cfg == CONFIG_STATUS_FILEMISSING) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\n\tastman_start_ack(s, m);\n\twhile ((cur_category = ast_category_browse_filtered(cfg, category, cur_category, filter))) {\n\t\tstruct ast_str *templates;\n\n\t\tcategory_name = ast_category_get_name(cur_category);\n\t\tlineno = 0;\n\t\tastman_append(s, \"Category-%06d: %s\\r\\n\", catcount, category_name);\n\n\t\tif (ast_category_is_template(cur_category)) {\n\t\t\tastman_append(s, \"IsTemplate-%06d: %d\\r\\n\", catcount, 1);\n\t\t}\n\n\t\tif ((templates = ast_category_get_templates(cur_category))\n\t\t\t&& ast_str_strlen(templates) > 0) {\n\t\t\tastman_append(s, \"Templates-%06d: %s\\r\\n\", catcount, ast_str_buffer(templates));\n\t\t\tast_free(templates);\n\t\t}\n\n\t\tfor (v = ast_category_first(cur_category); v; v = v->next) {\n\t\t\tastman_append(s, \"Line-%06d-%06d: %s=%s\\r\\n\", catcount, lineno++, v->name, v->value);\n\t\t}\n\n\t\tcatcount++;\n\t}\n\n\tif (!ast_strlen_zero(category) && catcount == 0) { /* TODO: actually, a config with no categories doesn't even get loaded */\n\t\tastman_append(s, \"No categories found\\r\\n\");\n\t}\n\n\tast_config_destroy(cfg);\n\tastman_append(s, \"\\r\\n\");\n\n\treturn 0;\n}",
        "description": "Asterisk, an open-source private branch exchange and telephony toolkit, is vulnerable to an arbitrary file reading issue in versions prior to 18.20.1, 20.5.1, and 21.0.1, as well as certified-asterisk prior to 18.9-cert6. This vulnerability allows unauthorized access to read any arbitrary file, regardless of whether the `live_dangerously` option is enabled. Versions 18.20.1, 20.5.1, and 21.0.1, as well as certified-asterisk prior to 18.9-cert6, have implemented a fix for this issue.",
        "commit": "It was discovered that the GetConfig function in the manager module allowed unauthorized access to files outside of the Asterisk configuration directory by manipulating filenames with \".\" and \"./\", even when the live_dangerously feature was not enabled. This vulnerability has been addressed by implementing a measure to resolve the full path and verify that the file remains within the configuration directory before attempting to access it."
    },
    {
        "cwe": "CWE-416",
        "func_name": "torvalds/__ext4_new_inode",
        "score": 0.7954866290092468,
        "func_before": "struct inode *__ext4_new_inode(handle_t *handle, struct inode *dir,\n\t\t\t       umode_t mode, const struct qstr *qstr,\n\t\t\t       __u32 goal, uid_t *owner, __u32 i_flags,\n\t\t\t       int handle_type, unsigned int line_no,\n\t\t\t       int nblocks)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *inode_bitmap_bh = NULL;\n\tstruct buffer_head *group_desc_bh;\n\text4_group_t ngroups, group = 0;\n\tunsigned long ino = 0;\n\tstruct inode *inode;\n\tstruct ext4_group_desc *gdp = NULL;\n\tstruct ext4_inode_info *ei;\n\tstruct ext4_sb_info *sbi;\n\tint ret2, err;\n\tstruct inode *ret;\n\text4_group_t i;\n\text4_group_t flex_group;\n\tstruct ext4_group_info *grp;\n\tint encrypt = 0;\n\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\n\tsb = dir->i_sb;\n\tsbi = EXT4_SB(sb);\n\n\tif (unlikely(ext4_forced_shutdown(sbi)))\n\t\treturn ERR_PTR(-EIO);\n\n\tif ((ext4_encrypted_inode(dir) || DUMMY_ENCRYPTION_ENABLED(sbi)) &&\n\t    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)) &&\n\t    !(i_flags & EXT4_EA_INODE_FL)) {\n\t\terr = fscrypt_get_encryption_info(dir);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tif (!fscrypt_has_encryption_key(dir))\n\t\t\treturn ERR_PTR(-ENOKEY);\n\t\tencrypt = 1;\n\t}\n\n\tif (!handle && sbi->s_journal && !(i_flags & EXT4_EA_INODE_FL)) {\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t\tstruct posix_acl *p = get_acl(dir, ACL_TYPE_DEFAULT);\n\n\t\tif (IS_ERR(p))\n\t\t\treturn ERR_CAST(p);\n\t\tif (p) {\n\t\t\tint acl_size = p->a_count * sizeof(ext4_acl_entry);\n\n\t\t\tnblocks += (S_ISDIR(mode) ? 2 : 1) *\n\t\t\t\t__ext4_xattr_set_credits(sb, NULL /* inode */,\n\t\t\t\t\tNULL /* block_bh */, acl_size,\n\t\t\t\t\ttrue /* is_create */);\n\t\t\tposix_acl_release(p);\n\t\t}\n#endif\n\n#ifdef CONFIG_SECURITY\n\t\t{\n\t\t\tint num_security_xattrs = 1;\n\n#ifdef CONFIG_INTEGRITY\n\t\t\tnum_security_xattrs++;\n#endif\n\t\t\t/*\n\t\t\t * We assume that security xattrs are never\n\t\t\t * more than 1k.  In practice they are under\n\t\t\t * 128 bytes.\n\t\t\t */\n\t\t\tnblocks += num_security_xattrs *\n\t\t\t\t__ext4_xattr_set_credits(sb, NULL /* inode */,\n\t\t\t\t\tNULL /* block_bh */, 1024,\n\t\t\t\t\ttrue /* is_create */);\n\t\t}\n#endif\n\t\tif (encrypt)\n\t\t\tnblocks += __ext4_xattr_set_credits(sb,\n\t\t\t\t\tNULL /* inode */, NULL /* block_bh */,\n\t\t\t\t\tFSCRYPT_SET_CONTEXT_MAX_SIZE,\n\t\t\t\t\ttrue /* is_create */);\n\t}\n\n\tngroups = ext4_get_groups_count(sb);\n\ttrace_ext4_request_inode(dir, mode);\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tei = EXT4_I(inode);\n\n\t/*\n\t * Initialize owners and quota early so that we don't have to account\n\t * for quota initialization worst case in standard inode creating\n\t * transaction\n\t */\n\tif (owner) {\n\t\tinode->i_mode = mode;\n\t\ti_uid_write(inode, owner[0]);\n\t\ti_gid_write(inode, owner[1]);\n\t} else if (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tif (ext4_has_feature_project(sb) &&\n\t    ext4_test_inode_flag(dir, EXT4_INODE_PROJINHERIT))\n\t\tei->i_projid = EXT4_I(dir)->i_projid;\n\telse\n\t\tei->i_projid = make_kprojid(&init_user_ns, EXT4_DEF_PROJID);\n\n\terr = dquot_initialize(inode);\n\tif (err)\n\t\tgoto out;\n\n\tif (!goal)\n\t\tgoal = sbi->s_inode_goal;\n\n\tif (goal && goal <= le32_to_cpu(sbi->s_es->s_inodes_count)) {\n\t\tgroup = (goal - 1) / EXT4_INODES_PER_GROUP(sb);\n\t\tino = (goal - 1) % EXT4_INODES_PER_GROUP(sb);\n\t\tret2 = 0;\n\t\tgoto got_group;\n\t}\n\n\tif (S_ISDIR(mode))\n\t\tret2 = find_group_orlov(sb, dir, &group, mode, qstr);\n\telse\n\t\tret2 = find_group_other(sb, dir, &group, mode);\n\ngot_group:\n\tEXT4_I(dir)->i_last_alloc_group = group;\n\terr = -ENOSPC;\n\tif (ret2 == -1)\n\t\tgoto out;\n\n\t/*\n\t * Normally we will only go through one pass of this loop,\n\t * unless we get unlucky and it turns out the group we selected\n\t * had its last inode grabbed by someone else.\n\t */\n\tfor (i = 0; i < ngroups; i++, ino = 0) {\n\t\terr = -EIO;\n\n\t\tgdp = ext4_get_group_desc(sb, group, &group_desc_bh);\n\t\tif (!gdp)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Check free inodes count before loading bitmap.\n\t\t */\n\t\tif (ext4_free_inodes_count(sb, gdp) == 0)\n\t\t\tgoto next_group;\n\n\t\tgrp = ext4_get_group_info(sb, group);\n\t\t/* Skip groups with already-known suspicious inode tables */\n\t\tif (EXT4_MB_GRP_IBITMAP_CORRUPT(grp))\n\t\t\tgoto next_group;\n\n\t\tbrelse(inode_bitmap_bh);\n\t\tinode_bitmap_bh = ext4_read_inode_bitmap(sb, group);\n\t\t/* Skip groups with suspicious inode tables */\n\t\tif (EXT4_MB_GRP_IBITMAP_CORRUPT(grp) ||\n\t\t    IS_ERR(inode_bitmap_bh)) {\n\t\t\tinode_bitmap_bh = NULL;\n\t\t\tgoto next_group;\n\t\t}\n\nrepeat_in_this_group:\n\t\tret2 = find_inode_bit(sb, group, inode_bitmap_bh, &ino);\n\t\tif (!ret2)\n\t\t\tgoto next_group;\n\n\t\tif (group == 0 && (ino + 1) < EXT4_FIRST_INO(sb)) {\n\t\t\text4_error(sb, \"reserved inode found cleared - \"\n\t\t\t\t   \"inode=%lu\", ino + 1);\n\t\t\text4_mark_group_bitmap_corrupted(sb, group,\n\t\t\t\t\tEXT4_GROUP_INFO_IBITMAP_CORRUPT);\n\t\t\tgoto next_group;\n\t\t}\n\n\t\tif (!handle) {\n\t\t\tBUG_ON(nblocks <= 0);\n\t\t\thandle = __ext4_journal_start_sb(dir->i_sb, line_no,\n\t\t\t\t\t\t\t handle_type, nblocks,\n\t\t\t\t\t\t\t 0);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\terr = PTR_ERR(handle);\n\t\t\t\text4_std_error(sb, err);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tBUFFER_TRACE(inode_bitmap_bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, inode_bitmap_bh);\n\t\tif (err) {\n\t\t\text4_std_error(sb, err);\n\t\t\tgoto out;\n\t\t}\n\t\text4_lock_group(sb, group);\n\t\tret2 = ext4_test_and_set_bit(ino, inode_bitmap_bh->b_data);\n\t\tif (ret2) {\n\t\t\t/* Someone already took the bit. Repeat the search\n\t\t\t * with lock held.\n\t\t\t */\n\t\t\tret2 = find_inode_bit(sb, group, inode_bitmap_bh, &ino);\n\t\t\tif (ret2) {\n\t\t\t\text4_set_bit(ino, inode_bitmap_bh->b_data);\n\t\t\t\tret2 = 0;\n\t\t\t} else {\n\t\t\t\tret2 = 1; /* we didn't grab the inode */\n\t\t\t}\n\t\t}\n\t\text4_unlock_group(sb, group);\n\t\tino++;\t\t/* the inode bitmap is zero-based */\n\t\tif (!ret2)\n\t\t\tgoto got; /* we grabbed the inode! */\n\n\t\tif (ino < EXT4_INODES_PER_GROUP(sb))\n\t\t\tgoto repeat_in_this_group;\nnext_group:\n\t\tif (++group == ngroups)\n\t\t\tgroup = 0;\n\t}\n\terr = -ENOSPC;\n\tgoto out;\n\ngot:\n\tBUFFER_TRACE(inode_bitmap_bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, inode_bitmap_bh);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto out;\n\t}\n\n\tBUFFER_TRACE(group_desc_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, group_desc_bh);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto out;\n\t}\n\n\t/* We may have to initialize the block bitmap if it isn't already */\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tstruct buffer_head *block_bitmap_bh;\n\n\t\tblock_bitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (IS_ERR(block_bitmap_bh)) {\n\t\t\terr = PTR_ERR(block_bitmap_bh);\n\t\t\tgoto out;\n\t\t}\n\t\tBUFFER_TRACE(block_bitmap_bh, \"get block bitmap access\");\n\t\terr = ext4_journal_get_write_access(handle, block_bitmap_bh);\n\t\tif (err) {\n\t\t\tbrelse(block_bitmap_bh);\n\t\t\text4_std_error(sb, err);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUFFER_TRACE(block_bitmap_bh, \"dirty block bitmap\");\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, block_bitmap_bh);\n\n\t\t/* recheck and clear flag under lock if we still need to */\n\t\text4_lock_group(sb, group);\n\t\tif (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\t\tgdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);\n\t\t\text4_free_group_clusters_set(sb, gdp,\n\t\t\t\text4_free_clusters_after_init(sb, group, gdp));\n\t\t\text4_block_bitmap_csum_set(sb, group, gdp,\n\t\t\t\t\t\t   block_bitmap_bh);\n\t\t\text4_group_desc_csum_set(sb, group, gdp);\n\t\t}\n\t\text4_unlock_group(sb, group);\n\t\tbrelse(block_bitmap_bh);\n\n\t\tif (err) {\n\t\t\text4_std_error(sb, err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Update the relevant bg descriptor fields */\n\tif (ext4_has_group_desc_csum(sb)) {\n\t\tint free;\n\t\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\n\t\tdown_read(&grp->alloc_sem); /* protect vs itable lazyinit */\n\t\text4_lock_group(sb, group); /* while we modify the bg desc */\n\t\tfree = EXT4_INODES_PER_GROUP(sb) -\n\t\t\text4_itable_unused_count(sb, gdp);\n\t\tif (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)) {\n\t\t\tgdp->bg_flags &= cpu_to_le16(~EXT4_BG_INODE_UNINIT);\n\t\t\tfree = 0;\n\t\t}\n\t\t/*\n\t\t * Check the relative inode number against the last used\n\t\t * relative inode number in this group. if it is greater\n\t\t * we need to update the bg_itable_unused count\n\t\t */\n\t\tif (ino > free)\n\t\t\text4_itable_unused_set(sb, gdp,\n\t\t\t\t\t(EXT4_INODES_PER_GROUP(sb) - ino));\n\t\tup_read(&grp->alloc_sem);\n\t} else {\n\t\text4_lock_group(sb, group);\n\t}\n\n\text4_free_inodes_set(sb, gdp, ext4_free_inodes_count(sb, gdp) - 1);\n\tif (S_ISDIR(mode)) {\n\t\text4_used_dirs_set(sb, gdp, ext4_used_dirs_count(sb, gdp) + 1);\n\t\tif (sbi->s_log_groups_per_flex) {\n\t\t\text4_group_t f = ext4_flex_group(sbi, group);\n\n\t\t\tatomic_inc(&sbi->s_flex_groups[f].used_dirs);\n\t\t}\n\t}\n\tif (ext4_has_group_desc_csum(sb)) {\n\t\text4_inode_bitmap_csum_set(sb, group, gdp, inode_bitmap_bh,\n\t\t\t\t\t   EXT4_INODES_PER_GROUP(sb) / 8);\n\t\text4_group_desc_csum_set(sb, group, gdp);\n\t}\n\text4_unlock_group(sb, group);\n\n\tBUFFER_TRACE(group_desc_bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, group_desc_bh);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto out;\n\t}\n\n\tpercpu_counter_dec(&sbi->s_freeinodes_counter);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\tflex_group = ext4_flex_group(sbi, group);\n\t\tatomic_dec(&sbi->s_flex_groups[flex_group].free_inodes);\n\t}\n\n\tinode->i_ino = ino + group * EXT4_INODES_PER_GROUP(sb);\n\t/* This is the optimal IO size (for stat), not the fs block size */\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = ei->i_crtime =\n\t\t\t\t\t\t       current_time(inode);\n\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_dir_start_lookup = 0;\n\tei->i_disksize = 0;\n\n\t/* Don't inherit extent flag from directory, amongst others. */\n\tei->i_flags =\n\t\text4_mask_flags(mode, EXT4_I(dir)->i_flags & EXT4_FL_INHERITED);\n\tei->i_flags |= i_flags;\n\tei->i_file_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_group = group;\n\tei->i_last_alloc_group = ~0;\n\n\text4_set_inode_flags(inode);\n\tif (IS_DIRSYNC(inode))\n\t\text4_handle_sync(handle);\n\tif (insert_inode_locked(inode) < 0) {\n\t\t/*\n\t\t * Likely a bitmap corruption causing inode to be allocated\n\t\t * twice.\n\t\t */\n\t\terr = -EIO;\n\t\text4_error(sb, \"failed to insert inode %lu: doubly allocated?\",\n\t\t\t   inode->i_ino);\n\t\text4_mark_group_bitmap_corrupted(sb, group,\n\t\t\t\t\tEXT4_GROUP_INFO_IBITMAP_CORRUPT);\n\t\tgoto out;\n\t}\n\tinode->i_generation = prandom_u32();\n\n\t/* Precompute checksum seed for inode metadata */\n\tif (ext4_has_metadata_csum(sb)) {\n\t\t__u32 csum;\n\t\t__le32 inum = cpu_to_le32(inode->i_ino);\n\t\t__le32 gen = cpu_to_le32(inode->i_generation);\n\t\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&inum,\n\t\t\t\t   sizeof(inum));\n\t\tei->i_csum_seed = ext4_chksum(sbi, csum, (__u8 *)&gen,\n\t\t\t\t\t      sizeof(gen));\n\t}\n\n\text4_clear_state_flags(ei); /* Only relevant on 32-bit archs */\n\text4_set_inode_state(inode, EXT4_STATE_NEW);\n\n\tei->i_extra_isize = sbi->s_want_extra_isize;\n\tei->i_inline_off = 0;\n\tif (ext4_has_feature_inline_data(sb))\n\t\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\tret = inode;\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\t/*\n\t * Since the encryption xattr will always be unique, create it first so\n\t * that it's less likely to end up in an external xattr block and\n\t * prevent its deduplication.\n\t */\n\tif (encrypt) {\n\t\terr = fscrypt_inherit_context(dir, inode, handle, true);\n\t\tif (err)\n\t\t\tgoto fail_free_drop;\n\t}\n\n\tif (!(ei->i_flags & EXT4_EA_INODE_FL)) {\n\t\terr = ext4_init_acl(handle, inode, dir);\n\t\tif (err)\n\t\t\tgoto fail_free_drop;\n\n\t\terr = ext4_init_security(handle, inode, dir, qstr);\n\t\tif (err)\n\t\t\tgoto fail_free_drop;\n\t}\n\n\tif (ext4_has_feature_extents(sb)) {\n\t\t/* set extent flag only for directory, file and normal symlink*/\n\t\tif (S_ISDIR(mode) || S_ISREG(mode) || S_ISLNK(mode)) {\n\t\t\text4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode);\n\t\t}\n\t}\n\n\tif (ext4_handle_valid(handle)) {\n\t\tei->i_sync_tid = handle->h_transaction->t_tid;\n\t\tei->i_datasync_tid = handle->h_transaction->t_tid;\n\t}\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto fail_free_drop;\n\t}\n\n\text4_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_allocate_inode(inode, dir, mode);\n\tbrelse(inode_bitmap_bh);\n\treturn ret;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\nfail_drop:\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nout:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\tbrelse(inode_bitmap_bh);\n\treturn ERR_PTR(err);\n}",
        "func_after": "struct inode *__ext4_new_inode(handle_t *handle, struct inode *dir,\n\t\t\t       umode_t mode, const struct qstr *qstr,\n\t\t\t       __u32 goal, uid_t *owner, __u32 i_flags,\n\t\t\t       int handle_type, unsigned int line_no,\n\t\t\t       int nblocks)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *inode_bitmap_bh = NULL;\n\tstruct buffer_head *group_desc_bh;\n\text4_group_t ngroups, group = 0;\n\tunsigned long ino = 0;\n\tstruct inode *inode;\n\tstruct ext4_group_desc *gdp = NULL;\n\tstruct ext4_inode_info *ei;\n\tstruct ext4_sb_info *sbi;\n\tint ret2, err;\n\tstruct inode *ret;\n\text4_group_t i;\n\text4_group_t flex_group;\n\tstruct ext4_group_info *grp;\n\tint encrypt = 0;\n\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\n\tsb = dir->i_sb;\n\tsbi = EXT4_SB(sb);\n\n\tif (unlikely(ext4_forced_shutdown(sbi)))\n\t\treturn ERR_PTR(-EIO);\n\n\tif ((ext4_encrypted_inode(dir) || DUMMY_ENCRYPTION_ENABLED(sbi)) &&\n\t    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)) &&\n\t    !(i_flags & EXT4_EA_INODE_FL)) {\n\t\terr = fscrypt_get_encryption_info(dir);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tif (!fscrypt_has_encryption_key(dir))\n\t\t\treturn ERR_PTR(-ENOKEY);\n\t\tencrypt = 1;\n\t}\n\n\tif (!handle && sbi->s_journal && !(i_flags & EXT4_EA_INODE_FL)) {\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t\tstruct posix_acl *p = get_acl(dir, ACL_TYPE_DEFAULT);\n\n\t\tif (IS_ERR(p))\n\t\t\treturn ERR_CAST(p);\n\t\tif (p) {\n\t\t\tint acl_size = p->a_count * sizeof(ext4_acl_entry);\n\n\t\t\tnblocks += (S_ISDIR(mode) ? 2 : 1) *\n\t\t\t\t__ext4_xattr_set_credits(sb, NULL /* inode */,\n\t\t\t\t\tNULL /* block_bh */, acl_size,\n\t\t\t\t\ttrue /* is_create */);\n\t\t\tposix_acl_release(p);\n\t\t}\n#endif\n\n#ifdef CONFIG_SECURITY\n\t\t{\n\t\t\tint num_security_xattrs = 1;\n\n#ifdef CONFIG_INTEGRITY\n\t\t\tnum_security_xattrs++;\n#endif\n\t\t\t/*\n\t\t\t * We assume that security xattrs are never\n\t\t\t * more than 1k.  In practice they are under\n\t\t\t * 128 bytes.\n\t\t\t */\n\t\t\tnblocks += num_security_xattrs *\n\t\t\t\t__ext4_xattr_set_credits(sb, NULL /* inode */,\n\t\t\t\t\tNULL /* block_bh */, 1024,\n\t\t\t\t\ttrue /* is_create */);\n\t\t}\n#endif\n\t\tif (encrypt)\n\t\t\tnblocks += __ext4_xattr_set_credits(sb,\n\t\t\t\t\tNULL /* inode */, NULL /* block_bh */,\n\t\t\t\t\tFSCRYPT_SET_CONTEXT_MAX_SIZE,\n\t\t\t\t\ttrue /* is_create */);\n\t}\n\n\tngroups = ext4_get_groups_count(sb);\n\ttrace_ext4_request_inode(dir, mode);\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tei = EXT4_I(inode);\n\n\t/*\n\t * Initialize owners and quota early so that we don't have to account\n\t * for quota initialization worst case in standard inode creating\n\t * transaction\n\t */\n\tif (owner) {\n\t\tinode->i_mode = mode;\n\t\ti_uid_write(inode, owner[0]);\n\t\ti_gid_write(inode, owner[1]);\n\t} else if (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tif (ext4_has_feature_project(sb) &&\n\t    ext4_test_inode_flag(dir, EXT4_INODE_PROJINHERIT))\n\t\tei->i_projid = EXT4_I(dir)->i_projid;\n\telse\n\t\tei->i_projid = make_kprojid(&init_user_ns, EXT4_DEF_PROJID);\n\n\terr = dquot_initialize(inode);\n\tif (err)\n\t\tgoto out;\n\n\tif (!goal)\n\t\tgoal = sbi->s_inode_goal;\n\n\tif (goal && goal <= le32_to_cpu(sbi->s_es->s_inodes_count)) {\n\t\tgroup = (goal - 1) / EXT4_INODES_PER_GROUP(sb);\n\t\tino = (goal - 1) % EXT4_INODES_PER_GROUP(sb);\n\t\tret2 = 0;\n\t\tgoto got_group;\n\t}\n\n\tif (S_ISDIR(mode))\n\t\tret2 = find_group_orlov(sb, dir, &group, mode, qstr);\n\telse\n\t\tret2 = find_group_other(sb, dir, &group, mode);\n\ngot_group:\n\tEXT4_I(dir)->i_last_alloc_group = group;\n\terr = -ENOSPC;\n\tif (ret2 == -1)\n\t\tgoto out;\n\n\t/*\n\t * Normally we will only go through one pass of this loop,\n\t * unless we get unlucky and it turns out the group we selected\n\t * had its last inode grabbed by someone else.\n\t */\n\tfor (i = 0; i < ngroups; i++, ino = 0) {\n\t\terr = -EIO;\n\n\t\tgdp = ext4_get_group_desc(sb, group, &group_desc_bh);\n\t\tif (!gdp)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Check free inodes count before loading bitmap.\n\t\t */\n\t\tif (ext4_free_inodes_count(sb, gdp) == 0)\n\t\t\tgoto next_group;\n\n\t\tgrp = ext4_get_group_info(sb, group);\n\t\t/* Skip groups with already-known suspicious inode tables */\n\t\tif (EXT4_MB_GRP_IBITMAP_CORRUPT(grp))\n\t\t\tgoto next_group;\n\n\t\tbrelse(inode_bitmap_bh);\n\t\tinode_bitmap_bh = ext4_read_inode_bitmap(sb, group);\n\t\t/* Skip groups with suspicious inode tables */\n\t\tif (EXT4_MB_GRP_IBITMAP_CORRUPT(grp) ||\n\t\t    IS_ERR(inode_bitmap_bh)) {\n\t\t\tinode_bitmap_bh = NULL;\n\t\t\tgoto next_group;\n\t\t}\n\nrepeat_in_this_group:\n\t\tret2 = find_inode_bit(sb, group, inode_bitmap_bh, &ino);\n\t\tif (!ret2)\n\t\t\tgoto next_group;\n\n\t\tif (group == 0 && (ino + 1) < EXT4_FIRST_INO(sb)) {\n\t\t\text4_error(sb, \"reserved inode found cleared - \"\n\t\t\t\t   \"inode=%lu\", ino + 1);\n\t\t\text4_mark_group_bitmap_corrupted(sb, group,\n\t\t\t\t\tEXT4_GROUP_INFO_IBITMAP_CORRUPT);\n\t\t\tgoto next_group;\n\t\t}\n\n\t\tif (!handle) {\n\t\t\tBUG_ON(nblocks <= 0);\n\t\t\thandle = __ext4_journal_start_sb(dir->i_sb, line_no,\n\t\t\t\t\t\t\t handle_type, nblocks,\n\t\t\t\t\t\t\t 0);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\terr = PTR_ERR(handle);\n\t\t\t\text4_std_error(sb, err);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tBUFFER_TRACE(inode_bitmap_bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, inode_bitmap_bh);\n\t\tif (err) {\n\t\t\text4_std_error(sb, err);\n\t\t\tgoto out;\n\t\t}\n\t\text4_lock_group(sb, group);\n\t\tret2 = ext4_test_and_set_bit(ino, inode_bitmap_bh->b_data);\n\t\tif (ret2) {\n\t\t\t/* Someone already took the bit. Repeat the search\n\t\t\t * with lock held.\n\t\t\t */\n\t\t\tret2 = find_inode_bit(sb, group, inode_bitmap_bh, &ino);\n\t\t\tif (ret2) {\n\t\t\t\text4_set_bit(ino, inode_bitmap_bh->b_data);\n\t\t\t\tret2 = 0;\n\t\t\t} else {\n\t\t\t\tret2 = 1; /* we didn't grab the inode */\n\t\t\t}\n\t\t}\n\t\text4_unlock_group(sb, group);\n\t\tino++;\t\t/* the inode bitmap is zero-based */\n\t\tif (!ret2)\n\t\t\tgoto got; /* we grabbed the inode! */\n\n\t\tif (ino < EXT4_INODES_PER_GROUP(sb))\n\t\t\tgoto repeat_in_this_group;\nnext_group:\n\t\tif (++group == ngroups)\n\t\t\tgroup = 0;\n\t}\n\terr = -ENOSPC;\n\tgoto out;\n\ngot:\n\tBUFFER_TRACE(inode_bitmap_bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, inode_bitmap_bh);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto out;\n\t}\n\n\tBUFFER_TRACE(group_desc_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, group_desc_bh);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto out;\n\t}\n\n\t/* We may have to initialize the block bitmap if it isn't already */\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tstruct buffer_head *block_bitmap_bh;\n\n\t\tblock_bitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (IS_ERR(block_bitmap_bh)) {\n\t\t\terr = PTR_ERR(block_bitmap_bh);\n\t\t\tgoto out;\n\t\t}\n\t\tBUFFER_TRACE(block_bitmap_bh, \"get block bitmap access\");\n\t\terr = ext4_journal_get_write_access(handle, block_bitmap_bh);\n\t\tif (err) {\n\t\t\tbrelse(block_bitmap_bh);\n\t\t\text4_std_error(sb, err);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUFFER_TRACE(block_bitmap_bh, \"dirty block bitmap\");\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, block_bitmap_bh);\n\n\t\t/* recheck and clear flag under lock if we still need to */\n\t\text4_lock_group(sb, group);\n\t\tif (ext4_has_group_desc_csum(sb) &&\n\t\t    (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {\n\t\t\tgdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);\n\t\t\text4_free_group_clusters_set(sb, gdp,\n\t\t\t\text4_free_clusters_after_init(sb, group, gdp));\n\t\t\text4_block_bitmap_csum_set(sb, group, gdp,\n\t\t\t\t\t\t   block_bitmap_bh);\n\t\t\text4_group_desc_csum_set(sb, group, gdp);\n\t\t}\n\t\text4_unlock_group(sb, group);\n\t\tbrelse(block_bitmap_bh);\n\n\t\tif (err) {\n\t\t\text4_std_error(sb, err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Update the relevant bg descriptor fields */\n\tif (ext4_has_group_desc_csum(sb)) {\n\t\tint free;\n\t\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\n\t\tdown_read(&grp->alloc_sem); /* protect vs itable lazyinit */\n\t\text4_lock_group(sb, group); /* while we modify the bg desc */\n\t\tfree = EXT4_INODES_PER_GROUP(sb) -\n\t\t\text4_itable_unused_count(sb, gdp);\n\t\tif (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)) {\n\t\t\tgdp->bg_flags &= cpu_to_le16(~EXT4_BG_INODE_UNINIT);\n\t\t\tfree = 0;\n\t\t}\n\t\t/*\n\t\t * Check the relative inode number against the last used\n\t\t * relative inode number in this group. if it is greater\n\t\t * we need to update the bg_itable_unused count\n\t\t */\n\t\tif (ino > free)\n\t\t\text4_itable_unused_set(sb, gdp,\n\t\t\t\t\t(EXT4_INODES_PER_GROUP(sb) - ino));\n\t\tup_read(&grp->alloc_sem);\n\t} else {\n\t\text4_lock_group(sb, group);\n\t}\n\n\text4_free_inodes_set(sb, gdp, ext4_free_inodes_count(sb, gdp) - 1);\n\tif (S_ISDIR(mode)) {\n\t\text4_used_dirs_set(sb, gdp, ext4_used_dirs_count(sb, gdp) + 1);\n\t\tif (sbi->s_log_groups_per_flex) {\n\t\t\text4_group_t f = ext4_flex_group(sbi, group);\n\n\t\t\tatomic_inc(&sbi->s_flex_groups[f].used_dirs);\n\t\t}\n\t}\n\tif (ext4_has_group_desc_csum(sb)) {\n\t\text4_inode_bitmap_csum_set(sb, group, gdp, inode_bitmap_bh,\n\t\t\t\t\t   EXT4_INODES_PER_GROUP(sb) / 8);\n\t\text4_group_desc_csum_set(sb, group, gdp);\n\t}\n\text4_unlock_group(sb, group);\n\n\tBUFFER_TRACE(group_desc_bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, group_desc_bh);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto out;\n\t}\n\n\tpercpu_counter_dec(&sbi->s_freeinodes_counter);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\tflex_group = ext4_flex_group(sbi, group);\n\t\tatomic_dec(&sbi->s_flex_groups[flex_group].free_inodes);\n\t}\n\n\tinode->i_ino = ino + group * EXT4_INODES_PER_GROUP(sb);\n\t/* This is the optimal IO size (for stat), not the fs block size */\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = ei->i_crtime =\n\t\t\t\t\t\t       current_time(inode);\n\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_dir_start_lookup = 0;\n\tei->i_disksize = 0;\n\n\t/* Don't inherit extent flag from directory, amongst others. */\n\tei->i_flags =\n\t\text4_mask_flags(mode, EXT4_I(dir)->i_flags & EXT4_FL_INHERITED);\n\tei->i_flags |= i_flags;\n\tei->i_file_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_group = group;\n\tei->i_last_alloc_group = ~0;\n\n\text4_set_inode_flags(inode);\n\tif (IS_DIRSYNC(inode))\n\t\text4_handle_sync(handle);\n\tif (insert_inode_locked(inode) < 0) {\n\t\t/*\n\t\t * Likely a bitmap corruption causing inode to be allocated\n\t\t * twice.\n\t\t */\n\t\terr = -EIO;\n\t\text4_error(sb, \"failed to insert inode %lu: doubly allocated?\",\n\t\t\t   inode->i_ino);\n\t\text4_mark_group_bitmap_corrupted(sb, group,\n\t\t\t\t\tEXT4_GROUP_INFO_IBITMAP_CORRUPT);\n\t\tgoto out;\n\t}\n\tinode->i_generation = prandom_u32();\n\n\t/* Precompute checksum seed for inode metadata */\n\tif (ext4_has_metadata_csum(sb)) {\n\t\t__u32 csum;\n\t\t__le32 inum = cpu_to_le32(inode->i_ino);\n\t\t__le32 gen = cpu_to_le32(inode->i_generation);\n\t\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&inum,\n\t\t\t\t   sizeof(inum));\n\t\tei->i_csum_seed = ext4_chksum(sbi, csum, (__u8 *)&gen,\n\t\t\t\t\t      sizeof(gen));\n\t}\n\n\text4_clear_state_flags(ei); /* Only relevant on 32-bit archs */\n\text4_set_inode_state(inode, EXT4_STATE_NEW);\n\n\tei->i_extra_isize = sbi->s_want_extra_isize;\n\tei->i_inline_off = 0;\n\tif (ext4_has_feature_inline_data(sb))\n\t\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\tret = inode;\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\t/*\n\t * Since the encryption xattr will always be unique, create it first so\n\t * that it's less likely to end up in an external xattr block and\n\t * prevent its deduplication.\n\t */\n\tif (encrypt) {\n\t\terr = fscrypt_inherit_context(dir, inode, handle, true);\n\t\tif (err)\n\t\t\tgoto fail_free_drop;\n\t}\n\n\tif (!(ei->i_flags & EXT4_EA_INODE_FL)) {\n\t\terr = ext4_init_acl(handle, inode, dir);\n\t\tif (err)\n\t\t\tgoto fail_free_drop;\n\n\t\terr = ext4_init_security(handle, inode, dir, qstr);\n\t\tif (err)\n\t\t\tgoto fail_free_drop;\n\t}\n\n\tif (ext4_has_feature_extents(sb)) {\n\t\t/* set extent flag only for directory, file and normal symlink*/\n\t\tif (S_ISDIR(mode) || S_ISREG(mode) || S_ISLNK(mode)) {\n\t\t\text4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode);\n\t\t}\n\t}\n\n\tif (ext4_handle_valid(handle)) {\n\t\tei->i_sync_tid = handle->h_transaction->t_tid;\n\t\tei->i_datasync_tid = handle->h_transaction->t_tid;\n\t}\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto fail_free_drop;\n\t}\n\n\text4_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_allocate_inode(inode, dir, mode);\n\tbrelse(inode_bitmap_bh);\n\treturn ret;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\nfail_drop:\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nout:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\tbrelse(inode_bitmap_bh);\n\treturn ERR_PTR(err);\n}",
        "description": "A flaw was identified in the Linux kernel's ext4 filesystem code, where a use-after-free condition can occur in the `ext4_ext_remove_space()` function during the mounting and operation of a specially crafted ext4 image.",
        "commit": "The vulnerability involves the `bg_flags` field in block group descriptors within a file system, which should only be considered valid if either the `uninit_bg` or `metadata_csum` feature is enabled. Previously, there was inconsistent checking of this field. Additionally, block group #0 must never have uninitialized allocation bitmaps or require zeroing, as it contains essential inodes such as the root inode. The fix includes checking these conditions and marking the file system as corrupted if any of these issues are detected. This addresses CVE-2018-10876."
    },
    {
        "cwe": "CWE-59",
        "func_name": "acassen/vrrp_print_json",
        "score": 0.7870728969573975,
        "func_before": "void\nvrrp_print_json(void)\n{\n\tFILE *file;\n\telement e;\n\tstruct json_object *array;\n\n\tif (LIST_ISEMPTY(vrrp_data->vrrp))\n\t\treturn;\n\n\tfile = fopen (\"/tmp/keepalived.json\",\"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open /tmp/keepalived.json (%d: %s)\",\n\t\t\terrno, strerror(errno));\n\t\treturn;\n\t}\n\n\tarray = json_object_new_array();\n\n\tfor (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {\n\t\tstruct json_object *instance_json, *json_stats, *json_data,\n\t\t\t*vips, *evips, *track_ifp, *track_script;\n#ifdef _HAVE_FIB_ROUTING_\n\t\tstruct json_object *vroutes, *vrules;\n#endif\n\t\telement f;\n\n\t\tvrrp_t *vrrp = ELEMENT_DATA(e);\n\t\tinstance_json = json_object_new_object();\n\t\tjson_stats = json_object_new_object();\n\t\tjson_data = json_object_new_object();\n\t\tvips = json_object_new_array();\n\t\tevips = json_object_new_array();\n\t\ttrack_ifp = json_object_new_array();\n\t\ttrack_script = json_object_new_array();\n#ifdef _HAVE_FIB_ROUTING_\n\t\tvroutes = json_object_new_array();\n\t\tvrules = json_object_new_array();\n#endif\n\n\t\t// Dump data to json\n\t\tjson_object_object_add(json_data, \"iname\",\n\t\t\tjson_object_new_string(vrrp->iname));\n\t\tjson_object_object_add(json_data, \"dont_track_primary\",\n\t\t\tjson_object_new_int(vrrp->dont_track_primary));\n\t\tjson_object_object_add(json_data, \"skip_check_adv_addr\",\n\t\t\tjson_object_new_int(vrrp->skip_check_adv_addr));\n\t\tjson_object_object_add(json_data, \"strict_mode\",\n\t\t\tjson_object_new_int((int)vrrp->strict_mode));\n#ifdef _HAVE_VRRP_VMAC_\n\t\tjson_object_object_add(json_data, \"vmac_ifname\",\n\t\t\tjson_object_new_string(vrrp->vmac_ifname));\n#endif\n\t\t// Tracked interfaces are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->track_ifp)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_ifp); f; ELEMENT_NEXT(f)) {\n\t\t\t\tinterface_t *ifp = ELEMENT_DATA(f);\n\t\t\t\tjson_object_array_add(track_ifp,\n\t\t\t\t\tjson_object_new_string(ifp->ifname));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_ifp\", track_ifp);\n\n\t\t// Tracked scripts also\n\t\tif (!LIST_ISEMPTY(vrrp->track_script)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_script); f; ELEMENT_NEXT(f)) {\n\t\t\t\ttracked_sc_t *tsc = ELEMENT_DATA(f);\n\t\t\t\tvrrp_script_t *vscript = tsc->scr;\n\t\t\t\tjson_object_array_add(track_script,\n\t\t\t\t\tjson_object_new_string(cmd_str(&vscript->script)));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_script\", track_script);\n\n\t\tjson_object_object_add(json_data, \"ifp_ifname\",\n\t\t\tjson_object_new_string(vrrp->ifp->ifname));\n\t\tjson_object_object_add(json_data, \"master_priority\",\n\t\t\tjson_object_new_int(vrrp->master_priority));\n\t\tjson_object_object_add(json_data, \"last_transition\",\n\t\t\tjson_object_new_double(timeval_to_double(&vrrp->last_transition)));\n\t\tjson_object_object_add(json_data, \"garp_delay\",\n\t\t\tjson_object_new_double(vrrp->garp_delay / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"garp_refresh\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh.tv_sec));\n\t\tjson_object_object_add(json_data, \"garp_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_rep));\n\t\tjson_object_object_add(json_data, \"garp_refresh_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh_rep));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->garp_lower_prio_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_lower_prio_rep));\n\t\tjson_object_object_add(json_data, \"lower_prio_no_advert\",\n\t\t\tjson_object_new_int((int)vrrp->lower_prio_no_advert));\n\t\tjson_object_object_add(json_data, \"higher_prio_send_advert\",\n\t\t\tjson_object_new_int((int)vrrp->higher_prio_send_advert));\n\t\tjson_object_object_add(json_data, \"vrid\",\n\t\t\tjson_object_new_int(vrrp->vrid));\n\t\tjson_object_object_add(json_data, \"base_priority\",\n\t\t\tjson_object_new_int(vrrp->base_priority));\n\t\tjson_object_object_add(json_data, \"effective_priority\",\n\t\t\tjson_object_new_int(vrrp->effective_priority));\n\t\tjson_object_object_add(json_data, \"vipset\",\n\t\t\tjson_object_new_boolean(vrrp->vipset));\n\n\t\t//Virtual IPs are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->vip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *vip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(vip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(vips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vips\", vips);\n\n\t\t//External VIPs are also stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->evip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->evip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *evip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(evip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(evips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"evips\", evips);\n\n\t\tjson_object_object_add(json_data, \"promote_secondaries\",\n\t\t\tjson_object_new_boolean(vrrp->promote_secondaries));\n\n#ifdef _HAVE_FIB_ROUTING_\n\t\t// Dump vroutes\n\t\tif (!LIST_ISEMPTY(vrrp->vroutes)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vroutes); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_route_t *route = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(ROUTE_BUF_SIZE);\n\t\t\t\tformat_iproute(route, buf, ROUTE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vroutes,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vroutes\", vroutes);\n\n\t\t// Dump vrules\n\t\tif (!LIST_ISEMPTY(vrrp->vrules)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vrules); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_rule_t *rule = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(RULE_BUF_SIZE);\n\t\t\t\tformat_iprule(rule, buf, RULE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vrules,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vrules\", vrules);\n#endif\n\n\t\tjson_object_object_add(json_data, \"adver_int\",\n\t\t\tjson_object_new_double(vrrp->adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"master_adver_int\",\n\t\t\tjson_object_new_double(vrrp->master_adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"accept\",\n\t\t\tjson_object_new_int((int)vrrp->accept));\n\t\tjson_object_object_add(json_data, \"nopreempt\",\n\t\t\tjson_object_new_boolean(vrrp->nopreempt));\n\t\tjson_object_object_add(json_data, \"preempt_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->preempt_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"state\",\n\t\t\tjson_object_new_int(vrrp->state));\n\t\tjson_object_object_add(json_data, \"wantstate\",\n\t\t\tjson_object_new_int(vrrp->wantstate));\n\t\tjson_object_object_add(json_data, \"version\",\n\t\t\tjson_object_new_int(vrrp->version));\n\t\tif (vrrp->script_backup)\n\t\t\tjson_object_object_add(json_data, \"script_backup\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_backup)));\n\t\tif (vrrp->script_master)\n\t\t\tjson_object_object_add(json_data, \"script_master\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master)));\n\t\tif (vrrp->script_fault)\n\t\t\tjson_object_object_add(json_data, \"script_fault\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_fault)));\n\t\tif (vrrp->script_stop)\n\t\t\tjson_object_object_add(json_data, \"script_stop\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_stop)));\n\t\tif (vrrp->script)\n\t\t\tjson_object_object_add(json_data, \"script\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script)));\n\t\tif (vrrp->script_master_rx_lower_pri)\n\t\t\tjson_object_object_add(json_data, \"script_master_rx_lower_pri\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master_rx_lower_pri)));\n\t\tjson_object_object_add(json_data, \"smtp_alert\",\n\t\t\tjson_object_new_boolean(vrrp->smtp_alert));\n#ifdef _WITH_VRRP_AUTH_\n\t\tif (vrrp->auth_type) {\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(vrrp->auth_type));\n\n\t\t\tif (vrrp->auth_type != VRRP_AUTH_AH) {\n\t\t\t\tchar auth_data[sizeof(vrrp->auth_data) + 1];\n\t\t\t\tmemcpy(auth_data, vrrp->auth_data, sizeof(vrrp->auth_data));\n\t\t\t\tauth_data[sizeof(vrrp->auth_data)] = '\\0';\n\t\t\t\tjson_object_object_add(json_data, \"auth_data\",\n\t\t\t\t\tjson_object_new_string(auth_data));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(0));\n#endif\n\n\t\t// Dump stats to json\n\t\tjson_object_object_add(json_stats, \"advert_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_rcvd));\n\t\tjson_object_object_add(json_stats, \"advert_sent\",\n\t\t\tjson_object_new_int64(vrrp->stats->advert_sent));\n\t\tjson_object_object_add(json_stats, \"become_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->become_master));\n\t\tjson_object_object_add(json_stats, \"release_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->release_master));\n\t\tjson_object_object_add(json_stats, \"packet_len_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->packet_len_err));\n\t\tjson_object_object_add(json_stats, \"advert_interval_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_interval_err));\n\t\tjson_object_object_add(json_stats, \"ip_ttl_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->ip_ttl_err));\n\t\tjson_object_object_add(json_stats, \"invalid_type_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->invalid_type_rcvd));\n\t\tjson_object_object_add(json_stats, \"addr_list_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->addr_list_err));\n\t\tjson_object_object_add(json_stats, \"invalid_authtype\",\n\t\t\tjson_object_new_int64(vrrp->stats->invalid_authtype));\n#ifdef _WITH_VRRP_AUTH_\n\t\tjson_object_object_add(json_stats, \"authtype_mismatch\",\n\t\t\tjson_object_new_int64(vrrp->stats->authtype_mismatch));\n\t\tjson_object_object_add(json_stats, \"auth_failure\",\n\t\t\tjson_object_new_int64(vrrp->stats->auth_failure));\n#endif\n\t\tjson_object_object_add(json_stats, \"pri_zero_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_rcvd));\n\t\tjson_object_object_add(json_stats, \"pri_zero_sent\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_sent));\n\n\t\t// Add both json_data and json_stats to main instance_json\n\t\tjson_object_object_add(instance_json, \"data\", json_data);\n\t\tjson_object_object_add(instance_json, \"stats\", json_stats);\n\n\t\t// Add instance_json to main array\n\t\tjson_object_array_add(array, instance_json);\n\n\t}\n\tfprintf(file, \"%s\", json_object_to_json_string(array));\n\tfclose(file);\n}",
        "func_after": "void\nvrrp_print_json(void)\n{\n\tFILE *file;\n\telement e;\n\tstruct json_object *array;\n\n\tif (LIST_ISEMPTY(vrrp_data->vrrp))\n\t\treturn;\n\n\tfile = fopen_safe(\"/tmp/keepalived.json\", \"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open /tmp/keepalived.json (%d: %s)\",\n\t\t\terrno, strerror(errno));\n\t\treturn;\n\t}\n\n\tarray = json_object_new_array();\n\n\tfor (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {\n\t\tstruct json_object *instance_json, *json_stats, *json_data,\n\t\t\t*vips, *evips, *track_ifp, *track_script;\n#ifdef _HAVE_FIB_ROUTING_\n\t\tstruct json_object *vroutes, *vrules;\n#endif\n\t\telement f;\n\n\t\tvrrp_t *vrrp = ELEMENT_DATA(e);\n\t\tinstance_json = json_object_new_object();\n\t\tjson_stats = json_object_new_object();\n\t\tjson_data = json_object_new_object();\n\t\tvips = json_object_new_array();\n\t\tevips = json_object_new_array();\n\t\ttrack_ifp = json_object_new_array();\n\t\ttrack_script = json_object_new_array();\n#ifdef _HAVE_FIB_ROUTING_\n\t\tvroutes = json_object_new_array();\n\t\tvrules = json_object_new_array();\n#endif\n\n\t\t// Dump data to json\n\t\tjson_object_object_add(json_data, \"iname\",\n\t\t\tjson_object_new_string(vrrp->iname));\n\t\tjson_object_object_add(json_data, \"dont_track_primary\",\n\t\t\tjson_object_new_int(vrrp->dont_track_primary));\n\t\tjson_object_object_add(json_data, \"skip_check_adv_addr\",\n\t\t\tjson_object_new_int(vrrp->skip_check_adv_addr));\n\t\tjson_object_object_add(json_data, \"strict_mode\",\n\t\t\tjson_object_new_int((int)vrrp->strict_mode));\n#ifdef _HAVE_VRRP_VMAC_\n\t\tjson_object_object_add(json_data, \"vmac_ifname\",\n\t\t\tjson_object_new_string(vrrp->vmac_ifname));\n#endif\n\t\t// Tracked interfaces are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->track_ifp)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_ifp); f; ELEMENT_NEXT(f)) {\n\t\t\t\tinterface_t *ifp = ELEMENT_DATA(f);\n\t\t\t\tjson_object_array_add(track_ifp,\n\t\t\t\t\tjson_object_new_string(ifp->ifname));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_ifp\", track_ifp);\n\n\t\t// Tracked scripts also\n\t\tif (!LIST_ISEMPTY(vrrp->track_script)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_script); f; ELEMENT_NEXT(f)) {\n\t\t\t\ttracked_sc_t *tsc = ELEMENT_DATA(f);\n\t\t\t\tvrrp_script_t *vscript = tsc->scr;\n\t\t\t\tjson_object_array_add(track_script,\n\t\t\t\t\tjson_object_new_string(cmd_str(&vscript->script)));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_script\", track_script);\n\n\t\tjson_object_object_add(json_data, \"ifp_ifname\",\n\t\t\tjson_object_new_string(vrrp->ifp->ifname));\n\t\tjson_object_object_add(json_data, \"master_priority\",\n\t\t\tjson_object_new_int(vrrp->master_priority));\n\t\tjson_object_object_add(json_data, \"last_transition\",\n\t\t\tjson_object_new_double(timeval_to_double(&vrrp->last_transition)));\n\t\tjson_object_object_add(json_data, \"garp_delay\",\n\t\t\tjson_object_new_double(vrrp->garp_delay / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"garp_refresh\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh.tv_sec));\n\t\tjson_object_object_add(json_data, \"garp_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_rep));\n\t\tjson_object_object_add(json_data, \"garp_refresh_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh_rep));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->garp_lower_prio_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_lower_prio_rep));\n\t\tjson_object_object_add(json_data, \"lower_prio_no_advert\",\n\t\t\tjson_object_new_int((int)vrrp->lower_prio_no_advert));\n\t\tjson_object_object_add(json_data, \"higher_prio_send_advert\",\n\t\t\tjson_object_new_int((int)vrrp->higher_prio_send_advert));\n\t\tjson_object_object_add(json_data, \"vrid\",\n\t\t\tjson_object_new_int(vrrp->vrid));\n\t\tjson_object_object_add(json_data, \"base_priority\",\n\t\t\tjson_object_new_int(vrrp->base_priority));\n\t\tjson_object_object_add(json_data, \"effective_priority\",\n\t\t\tjson_object_new_int(vrrp->effective_priority));\n\t\tjson_object_object_add(json_data, \"vipset\",\n\t\t\tjson_object_new_boolean(vrrp->vipset));\n\n\t\t//Virtual IPs are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->vip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *vip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(vip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(vips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vips\", vips);\n\n\t\t//External VIPs are also stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->evip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->evip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *evip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(evip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(evips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"evips\", evips);\n\n\t\tjson_object_object_add(json_data, \"promote_secondaries\",\n\t\t\tjson_object_new_boolean(vrrp->promote_secondaries));\n\n#ifdef _HAVE_FIB_ROUTING_\n\t\t// Dump vroutes\n\t\tif (!LIST_ISEMPTY(vrrp->vroutes)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vroutes); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_route_t *route = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(ROUTE_BUF_SIZE);\n\t\t\t\tformat_iproute(route, buf, ROUTE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vroutes,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vroutes\", vroutes);\n\n\t\t// Dump vrules\n\t\tif (!LIST_ISEMPTY(vrrp->vrules)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vrules); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_rule_t *rule = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(RULE_BUF_SIZE);\n\t\t\t\tformat_iprule(rule, buf, RULE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vrules,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vrules\", vrules);\n#endif\n\n\t\tjson_object_object_add(json_data, \"adver_int\",\n\t\t\tjson_object_new_double(vrrp->adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"master_adver_int\",\n\t\t\tjson_object_new_double(vrrp->master_adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"accept\",\n\t\t\tjson_object_new_int((int)vrrp->accept));\n\t\tjson_object_object_add(json_data, \"nopreempt\",\n\t\t\tjson_object_new_boolean(vrrp->nopreempt));\n\t\tjson_object_object_add(json_data, \"preempt_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->preempt_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"state\",\n\t\t\tjson_object_new_int(vrrp->state));\n\t\tjson_object_object_add(json_data, \"wantstate\",\n\t\t\tjson_object_new_int(vrrp->wantstate));\n\t\tjson_object_object_add(json_data, \"version\",\n\t\t\tjson_object_new_int(vrrp->version));\n\t\tif (vrrp->script_backup)\n\t\t\tjson_object_object_add(json_data, \"script_backup\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_backup)));\n\t\tif (vrrp->script_master)\n\t\t\tjson_object_object_add(json_data, \"script_master\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master)));\n\t\tif (vrrp->script_fault)\n\t\t\tjson_object_object_add(json_data, \"script_fault\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_fault)));\n\t\tif (vrrp->script_stop)\n\t\t\tjson_object_object_add(json_data, \"script_stop\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_stop)));\n\t\tif (vrrp->script)\n\t\t\tjson_object_object_add(json_data, \"script\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script)));\n\t\tif (vrrp->script_master_rx_lower_pri)\n\t\t\tjson_object_object_add(json_data, \"script_master_rx_lower_pri\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master_rx_lower_pri)));\n\t\tjson_object_object_add(json_data, \"smtp_alert\",\n\t\t\tjson_object_new_boolean(vrrp->smtp_alert));\n#ifdef _WITH_VRRP_AUTH_\n\t\tif (vrrp->auth_type) {\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(vrrp->auth_type));\n\n\t\t\tif (vrrp->auth_type != VRRP_AUTH_AH) {\n\t\t\t\tchar auth_data[sizeof(vrrp->auth_data) + 1];\n\t\t\t\tmemcpy(auth_data, vrrp->auth_data, sizeof(vrrp->auth_data));\n\t\t\t\tauth_data[sizeof(vrrp->auth_data)] = '\\0';\n\t\t\t\tjson_object_object_add(json_data, \"auth_data\",\n\t\t\t\t\tjson_object_new_string(auth_data));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(0));\n#endif\n\n\t\t// Dump stats to json\n\t\tjson_object_object_add(json_stats, \"advert_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_rcvd));\n\t\tjson_object_object_add(json_stats, \"advert_sent\",\n\t\t\tjson_object_new_int64(vrrp->stats->advert_sent));\n\t\tjson_object_object_add(json_stats, \"become_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->become_master));\n\t\tjson_object_object_add(json_stats, \"release_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->release_master));\n\t\tjson_object_object_add(json_stats, \"packet_len_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->packet_len_err));\n\t\tjson_object_object_add(json_stats, \"advert_interval_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_interval_err));\n\t\tjson_object_object_add(json_stats, \"ip_ttl_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->ip_ttl_err));\n\t\tjson_object_object_add(json_stats, \"invalid_type_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->invalid_type_rcvd));\n\t\tjson_object_object_add(json_stats, \"addr_list_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->addr_list_err));\n\t\tjson_object_object_add(json_stats, \"invalid_authtype\",\n\t\t\tjson_object_new_int64(vrrp->stats->invalid_authtype));\n#ifdef _WITH_VRRP_AUTH_\n\t\tjson_object_object_add(json_stats, \"authtype_mismatch\",\n\t\t\tjson_object_new_int64(vrrp->stats->authtype_mismatch));\n\t\tjson_object_object_add(json_stats, \"auth_failure\",\n\t\t\tjson_object_new_int64(vrrp->stats->auth_failure));\n#endif\n\t\tjson_object_object_add(json_stats, \"pri_zero_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_rcvd));\n\t\tjson_object_object_add(json_stats, \"pri_zero_sent\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_sent));\n\n\t\t// Add both json_data and json_stats to main instance_json\n\t\tjson_object_object_add(instance_json, \"data\", json_data);\n\t\tjson_object_object_add(instance_json, \"stats\", json_stats);\n\n\t\t// Add instance_json to main array\n\t\tjson_object_array_add(array, instance_json);\n\n\t}\n\tfprintf(file, \"%s\", json_object_to_json_string(array));\n\tfclose(file);\n}",
        "description": "keepalived 2.0.8 failed to verify the presence of symbolic links in file paths when writing data to temporary files during calls to PrintData or PrintStats. This oversight permitted local users to overwrite arbitrary files when the system setting fs.protected_symlinks is disabled, as illustrated by creating a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",
        "commit": "When opening files for write operations, it is crucial to verify that the target path is not a symbolic link. This vulnerability highlights a scenario where a non-privileged user could exploit a symbolic link to overwrite critical system files, such as `/etc/passwd`, by creating a symlink from `/etc/keepalvied.data` to `/etc/passwd`. To mitigate this risk, the solution involves setting the `O_NOFOLLOW` flag whenever a file is opened for writing. However, this change may introduce backward incompatibility in certain setups where the target file is accessed via a symbolic link. In such cases, administrators should adjust their configurations, for instance, by redirecting the actual data file to a temporary location and maintaining the symbolic link to this new location. Despite these adjustments, there is no straightforward way to prevent race conditions when checking if a path is a symbolic link before opening it for writing."
    },
    {
        "cwe": "CWE-763",
        "func_name": "facebook/write",
        "score": 0.7782578468322754,
        "func_before": "size_t\nwrite(Protocol_* iprot, const StructInfo& structInfo, const void* object) {\n  DCHECK(object);\n  size_t written = iprot->writeStructBegin(structInfo.name);\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    const FieldInfo* end = structInfo.fieldInfos + structInfo.numFields;\n    const auto& unionId =\n        activeUnionMemberId(object, structInfo.unionExt->unionTypeOffset);\n    const FieldInfo* found = std::lower_bound(\n        structInfo.fieldInfos,\n        end,\n        unionId,\n        [](const FieldInfo& lhs, FieldID rhs) { return lhs.id < rhs; });\n    if (found < end && found->id == unionId) {\n      const OptionalThriftValue value = getValue(*found->typeInfo, object);\n      if (value.hasValue()) {\n        written += writeField(iprot, *found, value.value());\n      } else if (found->typeInfo->type == protocol::TType::T_STRUCT) {\n        written += iprot->writeFieldBegin(\n            found->name, found->typeInfo->type, found->id);\n        written += iprot->writeStructBegin(found->name);\n        written += iprot->writeStructEnd();\n        written += iprot->writeFieldStop();\n        written += iprot->writeFieldEnd();\n      }\n    }\n  } else {\n    for (std::int16_t index = 0; index < structInfo.numFields; index++) {\n      const auto& fieldInfo = structInfo.fieldInfos[index];\n      if (fieldInfo.isUnqualified || fieldInfo.issetOffset == 0 ||\n          fieldIsSet(object, fieldInfo.issetOffset)) {\n        const OptionalThriftValue value =\n            getValue(*fieldInfo.typeInfo, getMember(fieldInfo, object));\n        if (value.hasValue()) {\n          written += writeField(iprot, fieldInfo, value.value());\n        }\n      }\n    }\n  }\n\n  written += iprot->writeFieldStop();\n  written += iprot->writeStructEnd();\n  return written;\n}",
        "func_after": "size_t\nwrite(Protocol_* iprot, const StructInfo& structInfo, const void* object) {\n  DCHECK(object);\n  size_t written = iprot->writeStructBegin(structInfo.name);\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    const FieldInfo* end = structInfo.fieldInfos + structInfo.numFields;\n    const auto& activeId = getActiveId(object, structInfo);\n    const FieldInfo* found = std::lower_bound(\n        structInfo.fieldInfos,\n        end,\n        activeId,\n        [](const FieldInfo& lhs, FieldID rhs) { return lhs.id < rhs; });\n    if (found < end && found->id == activeId) {\n      const OptionalThriftValue value = getValue(*found->typeInfo, object);\n      if (value.hasValue()) {\n        written += writeField(iprot, *found, value.value());\n      } else if (found->typeInfo->type == protocol::TType::T_STRUCT) {\n        written += iprot->writeFieldBegin(\n            found->name, found->typeInfo->type, found->id);\n        written += iprot->writeStructBegin(found->name);\n        written += iprot->writeStructEnd();\n        written += iprot->writeFieldStop();\n        written += iprot->writeFieldEnd();\n      }\n    }\n  } else {\n    for (std::int16_t index = 0; index < structInfo.numFields; index++) {\n      const auto& fieldInfo = structInfo.fieldInfos[index];\n      if (fieldInfo.isUnqualified || fieldInfo.issetOffset == 0 ||\n          fieldIsSet(object, fieldInfo.issetOffset)) {\n        const OptionalThriftValue value =\n            getValue(*fieldInfo.typeInfo, getMember(fieldInfo, object));\n        if (value.hasValue()) {\n          written += writeField(iprot, fieldInfo, value.value());\n        }\n      }\n    }\n  }\n\n  written += iprot->writeFieldStop();\n  written += iprot->writeStructEnd();\n  return written;\n}",
        "description": "An invalid free operation within Thrift's table-based serialization can lead to application crashes or enable code execution and other unintended consequences. This vulnerability impacts Facebook Thrift versions prior to v2021.02.22.00.",
        "commit": "It was discovered that the table-based serializer improperly handled invalid union data, leading to potential memory leaks and other undesirable effects. Specifically, when duplicate union data was encountered, the previous active member of the union was overwritten without invoking the destructor of the old object. Additionally, if the second piece of data was incomplete, the incorrect destructor was called during stack unwinding, resulting in segmentation faults, data corruption, or other issues. The fix involves clearing the union if there is an active member and correcting the type of the data member that holds the active field ID."
    },
    {
        "cwe": "CWE-90",
        "func_name": "krb5/krb5_ldap_put_principal",
        "score": 0.7821240425109863,
        "func_before": "krb5_error_code\nkrb5_ldap_put_principal(krb5_context context, krb5_db_entry *entry,\n                        char **db_args)\n{\n    int                         l=0, kerberos_principal_object_type=0;\n    unsigned int                ntrees=0, tre=0;\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL, *ent=NULL;\n    char                        **subtreelist = NULL;\n    char                        *user=NULL, *subtree=NULL, *principal_dn=NULL;\n    char                        **values=NULL, *strval[10]={NULL}, errbuf[1024];\n    char                        *filtuser=NULL;\n    struct berval               **bersecretkey=NULL;\n    LDAPMod                     **mods=NULL;\n    krb5_boolean                create_standalone=FALSE;\n    krb5_boolean                krb_identity_exists=FALSE, establish_links=FALSE;\n    char                        *standalone_principal_dn=NULL;\n    krb5_tl_data                *tl_data=NULL;\n    krb5_key_data               **keys=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    osa_princ_ent_rec           princ_ent = {0};\n    xargs_t                     xargs = {0};\n    char                        *polname = NULL;\n    OPERATION optype;\n    krb5_boolean                found_entry = FALSE;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    SETUP_CONTEXT();\n    if (ldap_context->lrparams == NULL || ldap_context->container_dn == NULL)\n        return EINVAL;\n\n    /* get ldap handle */\n    GET_HANDLE();\n\n    if (!is_principal_in_realm(ldap_context, entry->princ)) {\n        st = EINVAL;\n        k5_setmsg(context, st,\n                  _(\"Principal does not belong to the default realm\"));\n        goto cleanup;\n    }\n\n    /* get the principal information to act on */\n    if (((st=krb5_unparse_name(context, entry->princ, &user)) != 0) ||\n        ((st=krb5_ldap_unparse_principal_name(user)) != 0))\n        goto cleanup;\n    filtuser = ldap_filter_correct(user);\n    if (filtuser == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Identity the type of operation, it can be\n     * add principal or modify principal.\n     * hack if the entry->mask has KRB_PRINCIPAL flag set\n     * then it is a add operation\n     */\n    if (entry->mask & KADM5_PRINCIPAL)\n        optype = ADD_PRINCIPAL;\n    else\n        optype = MODIFY_PRINCIPAL;\n\n    if (((st=krb5_get_princ_type(context, entry, &kerberos_principal_object_type)) != 0) ||\n        ((st=krb5_get_userdn(context, entry, &principal_dn)) != 0))\n        goto cleanup;\n\n    if ((st=process_db_args(context, db_args, &xargs, optype)) != 0)\n        goto cleanup;\n\n    if (entry->mask & KADM5_LOAD) {\n        unsigned int     tree = 0;\n        int              numlentries = 0;\n        char             *filter = NULL;\n\n        /*  A load operation is special, will do a mix-in (add krbprinc\n         *  attrs to a non-krb object entry) if an object exists with a\n         *  matching krbprincipalname attribute so try to find existing\n         *  object and set principal_dn.  This assumes that the\n         *  krbprincipalname attribute is unique (only one object entry has\n         *  a particular krbprincipalname attribute).\n         */\n        if (asprintf(&filter, FILTER\"%s))\", filtuser) < 0) {\n            filter = NULL;\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        /* get the current subtree list */\n        if ((st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees)) != 0)\n            goto cleanup;\n\n        found_entry = FALSE;\n        /* search for entry with matching krbprincipalname attribute */\n        for (tree = 0; found_entry == FALSE && tree < ntrees; ++tree) {\n            if (principal_dn == NULL) {\n                LDAP_SEARCH_1(subtreelist[tree], ldap_context->lrparams->search_scope, filter, principal_attributes, IGNORE_STATUS);\n            } else {\n                /* just look for entry with principal_dn */\n                LDAP_SEARCH_1(principal_dn, LDAP_SCOPE_BASE, filter, principal_attributes, IGNORE_STATUS);\n            }\n            if (st == LDAP_SUCCESS) {\n                numlentries = ldap_count_entries(ld, result);\n                if (numlentries > 1) {\n                    free(filter);\n                    st = EINVAL;\n                    k5_setmsg(context, st,\n                              _(\"operation can not continue, more than one \"\n                                \"entry with principal name \\\"%s\\\" found\"),\n                              user);\n                    goto cleanup;\n                } else if (numlentries == 1) {\n                    found_entry = TRUE;\n                    if (principal_dn == NULL) {\n                        ent = ldap_first_entry(ld, result);\n                        if (ent != NULL) {\n                            /* setting principal_dn will cause that entry to be modified further down */\n                            if ((principal_dn = ldap_get_dn(ld, ent)) == NULL) {\n                                ldap_get_option (ld, LDAP_OPT_RESULT_CODE, &st);\n                                st = set_ldap_error (context, st, 0);\n                                free(filter);\n                                goto cleanup;\n                            }\n                        }\n                    }\n                }\n            } else if (st != LDAP_NO_SUCH_OBJECT) {\n                /* could not perform search, return with failure */\n                st = set_ldap_error (context, st, 0);\n                free(filter);\n                goto cleanup;\n            }\n            ldap_msgfree(result);\n            result = NULL;\n            /*\n             * If it isn't found then assume a standalone princ entry is to\n             * be created.\n             */\n        } /* end for (tree = 0; principal_dn == ... */\n\n        free(filter);\n\n        if (found_entry == FALSE && principal_dn != NULL) {\n            /*\n             * if principal_dn is null then there is code further down to\n             * deal with setting standalone_principal_dn.  Also note that\n             * this will set create_standalone true for\n             * non-mix-in entries which is okay if loading from a dump.\n             */\n            create_standalone = TRUE;\n            standalone_principal_dn = strdup(principal_dn);\n            CHECK_NULL(standalone_principal_dn);\n        }\n    } /* end if (entry->mask & KADM5_LOAD */\n\n    /* time to generate the DN information with the help of\n     * containerdn, principalcontainerreference or\n     * realmcontainerdn information\n     */\n    if (principal_dn == NULL && xargs.dn == NULL) { /* creation of standalone principal */\n        /* get the subtree information */\n        if (entry->princ->length == 2 && entry->princ->data[0].length == strlen(\"krbtgt\") &&\n            strncmp(entry->princ->data[0].data, \"krbtgt\", entry->princ->data[0].length) == 0) {\n            /* if the principal is a inter-realm principal, always created in the realm container */\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        } else if (xargs.containerdn) {\n            if ((st=checkattributevalue(ld, xargs.containerdn, NULL, NULL, NULL)) != 0) {\n                if (st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION) {\n                    int ost = st;\n                    st = EINVAL;\n                    k5_wrapmsg(context, ost, st, _(\"'%s' not found\"),\n                               xargs.containerdn);\n                }\n                goto cleanup;\n            }\n            subtree = strdup(xargs.containerdn);\n        } else if (ldap_context->lrparams->containerref && strlen(ldap_context->lrparams->containerref) != 0) {\n            /*\n             * Here the subtree should be changed with\n             * principalcontainerreference attribute value\n             */\n            subtree = strdup(ldap_context->lrparams->containerref);\n        } else {\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        }\n        CHECK_NULL(subtree);\n\n        if (asprintf(&standalone_principal_dn, \"krbprincipalname=%s,%s\",\n                     filtuser, subtree) < 0)\n            standalone_principal_dn = NULL;\n        CHECK_NULL(standalone_principal_dn);\n        /*\n         * free subtree when you are done using the subtree\n         * set the boolean create_standalone to TRUE\n         */\n        create_standalone = TRUE;\n        free(subtree);\n        subtree = NULL;\n    }\n\n    /*\n     * If the DN information is presented by the user, time to\n     * validate the input to ensure that the DN falls under\n     * any of the subtrees\n     */\n    if (xargs.dn_from_kbd == TRUE) {\n        /* make sure the DN falls in the subtree */\n        int              dnlen=0, subtreelen=0;\n        char             *dn=NULL;\n        krb5_boolean     outofsubtree=TRUE;\n\n        if (xargs.dn != NULL) {\n            dn = xargs.dn;\n        } else if (xargs.linkdn != NULL) {\n            dn = xargs.linkdn;\n        } else if (standalone_principal_dn != NULL) {\n            /*\n             * Even though the standalone_principal_dn is constructed\n             * within this function, there is the containerdn input\n             * from the user that can become part of the it.\n             */\n            dn = standalone_principal_dn;\n        }\n\n        /* Get the current subtree list if we haven't already done so. */\n        if (subtreelist == NULL) {\n            st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees);\n            if (st)\n                goto cleanup;\n        }\n\n        for (tre=0; tre<ntrees; ++tre) {\n            if (subtreelist[tre] == NULL || strlen(subtreelist[tre]) == 0) {\n                outofsubtree = FALSE;\n                break;\n            } else {\n                dnlen = strlen (dn);\n                subtreelen = strlen(subtreelist[tre]);\n                if ((dnlen >= subtreelen) && (strcasecmp((dn + dnlen - subtreelen), subtreelist[tre]) == 0)) {\n                    outofsubtree = FALSE;\n                    break;\n                }\n            }\n        }\n\n        if (outofsubtree == TRUE) {\n            st = EINVAL;\n            k5_setmsg(context, st, _(\"DN is out of the realm subtree\"));\n            goto cleanup;\n        }\n\n        /*\n         * dn value will be set either by dn, linkdn or the standalone_principal_dn\n         * In the first 2 cases, the dn should be existing and in the last case we\n         * are supposed to create the ldap object. so the below should not be\n         * executed for the last case.\n         */\n\n        if (standalone_principal_dn == NULL) {\n            /*\n             * If the ldap object is missing, this results in an error.\n             */\n\n            /*\n             * Search for krbprincipalname attribute here.\n             * This is to find if a kerberos identity is already present\n             * on the ldap object, in which case adding a kerberos identity\n             * on the ldap object should result in an error.\n             */\n            char  *attributes[]={\"krbticketpolicyreference\", \"krbprincipalname\", NULL};\n\n            ldap_msgfree(result);\n            result = NULL;\n            LDAP_SEARCH_1(dn, LDAP_SCOPE_BASE, 0, attributes, IGNORE_STATUS);\n            if (st == LDAP_SUCCESS) {\n                ent = ldap_first_entry(ld, result);\n                if (ent != NULL) {\n                    if ((values=ldap_get_values(ld, ent, \"krbticketpolicyreference\")) != NULL) {\n                        ldap_value_free(values);\n                    }\n\n                    if ((values=ldap_get_values(ld, ent, \"krbprincipalname\")) != NULL) {\n                        krb_identity_exists = TRUE;\n                        ldap_value_free(values);\n                    }\n                }\n            } else {\n                st = set_ldap_error(context, st, OP_SEARCH);\n                goto cleanup;\n            }\n        }\n    }\n\n    /*\n     * If xargs.dn is set then the request is to add a\n     * kerberos principal on a ldap object, but if\n     * there is one already on the ldap object this\n     * should result in an error.\n     */\n\n    if (xargs.dn != NULL && krb_identity_exists == TRUE) {\n        st = EINVAL;\n        snprintf(errbuf, sizeof(errbuf),\n                 _(\"ldap object is already kerberized\"));\n        k5_setmsg(context, st, \"%s\", errbuf);\n        goto cleanup;\n    }\n\n    if (xargs.linkdn != NULL) {\n        /*\n         * link information can be changed using modprinc.\n         * However, link information can be changed only on the\n         * standalone kerberos principal objects. A standalone\n         * kerberos principal object is of type krbprincipal\n         * structural objectclass.\n         *\n         * NOTE: kerberos principals on an ldap object can't be\n         * linked to other ldap objects.\n         */\n        if (optype == MODIFY_PRINCIPAL &&\n            kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT) {\n            st = EINVAL;\n            snprintf(errbuf, sizeof(errbuf),\n                     _(\"link information can not be set/updated as the \"\n                       \"kerberos principal belongs to an ldap object\"));\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n        /*\n         * Check the link information. If there is already a link\n         * existing then this operation is not allowed.\n         */\n        {\n            char **linkdns=NULL;\n            int  j=0;\n\n            if ((st=krb5_get_linkdn(context, entry, &linkdns)) != 0) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Failed getting object references\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            }\n            if (linkdns != NULL) {\n                st = EINVAL;\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"kerberos principal is already linked to a ldap \"\n                           \"object\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                for (j=0; linkdns[j] != NULL; ++j)\n                    free (linkdns[j]);\n                free (linkdns);\n                goto cleanup;\n            }\n        }\n\n        establish_links = TRUE;\n    }\n\n    if (entry->mask & KADM5_LAST_SUCCESS) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_success)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastSuccessfulAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_LAST_FAILED) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_failed)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastFailedAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free(strval[0]);\n    }\n\n    if (entry->mask & KADM5_FAIL_AUTH_COUNT) {\n        krb5_kvno fail_auth_count;\n\n        fail_auth_count = entry->fail_auth_count;\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            fail_auth_count++;\n\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_REPLACE,\n                                       fail_auth_count);\n        if (st != 0)\n            goto cleanup;\n    } else if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT) {\n        int attr_mask = 0;\n        krb5_boolean has_fail_count;\n\n        /* Check if the krbLoginFailedCount attribute exists.  (Through\n         * krb5 1.8.1, it wasn't set in new entries.) */\n        st = krb5_get_attributes_mask(context, entry, &attr_mask);\n        if (st != 0)\n            goto cleanup;\n        has_fail_count = ((attr_mask & KDB_FAIL_AUTH_COUNT_ATTR) != 0);\n\n        /*\n         * If the client library and server supports RFC 4525,\n         * then use it to increment by one the value of the\n         * krbLoginFailedCount attribute. Otherwise, assert the\n         * (provided) old value by deleting it before adding.\n         */\n#ifdef LDAP_MOD_INCREMENT\n        if (ldap_server_handle->server_info->modify_increment &&\n            has_fail_count) {\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_INCREMENT, 1);\n            if (st != 0)\n                goto cleanup;\n        } else {\n#endif /* LDAP_MOD_INCREMENT */\n            if (has_fail_count) {\n                st = krb5_add_int_mem_ldap_mod(&mods,\n                                               \"krbLoginFailedCount\",\n                                               LDAP_MOD_DELETE,\n                                               entry->fail_auth_count);\n                if (st != 0)\n                    goto cleanup;\n            }\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_ADD,\n                                           entry->fail_auth_count + 1);\n            if (st != 0)\n                goto cleanup;\n#ifdef LDAP_MOD_INCREMENT\n        }\n#endif\n    } else if (optype == ADD_PRINCIPAL) {\n        /* Initialize krbLoginFailedCount in new entries to help avoid a\n         * race during the first failed login. */\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_ADD, 0);\n    }\n\n    if (entry->mask & KADM5_MAX_LIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxticketlife\", LDAP_MOD_REPLACE, entry->max_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_MAX_RLIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxrenewableage\", LDAP_MOD_REPLACE,\n                                          entry->max_renewable_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_ATTRIBUTES) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbticketflags\", LDAP_MOD_REPLACE,\n                                          entry->attributes)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINCIPAL) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = user;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalname\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINC_EXPIRE_TIME) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalexpiration\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_PW_EXPIRATION) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpasswordexpiration\",\n                                          LDAP_MOD_REPLACE,\n                                          strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_POLICY || entry->mask & KADM5_KEY_HIST) {\n        memset(&princ_ent, 0, sizeof(princ_ent));\n        for (tl_data=entry->tl_data; tl_data; tl_data=tl_data->tl_data_next) {\n            if (tl_data->tl_data_type == KRB5_TL_KADM_DATA) {\n                if ((st = krb5_lookup_tl_kadm_data(tl_data, &princ_ent)) != 0) {\n                    goto cleanup;\n                }\n                break;\n            }\n        }\n    }\n\n    if (entry->mask & KADM5_POLICY) {\n        if (princ_ent.aux_attributes & KADM5_POLICY) {\n            memset(strval, 0, sizeof(strval));\n            if ((st = krb5_ldap_name_to_policydn (context, princ_ent.policy, &polname)) != 0)\n                goto cleanup;\n            strval[0] = polname;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n        } else {\n            st = EINVAL;\n            k5_setmsg(context, st, \"Password policy value null\");\n            goto cleanup;\n        }\n    } else if (entry->mask & KADM5_LOAD && found_entry == TRUE) {\n        /*\n         * a load is special in that existing entries must have attrs that\n         * removed.\n         */\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_POLICY_CLR) {\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_KEY_HIST) {\n        bersecretkey = krb5_encode_histkey(&princ_ent);\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        st = krb5_add_ber_mem_ldap_mod(&mods, \"krbpwdhistory\",\n                                       LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                       bersecretkey);\n        if (st != 0)\n            goto cleanup;\n        free_berdata(bersecretkey);\n        bersecretkey = NULL;\n    }\n\n    if (entry->mask & KADM5_KEY_DATA || entry->mask & KADM5_KVNO) {\n        krb5_kvno mkvno;\n\n        if ((st=krb5_dbe_lookup_mkvno(context, entry, &mkvno)) != 0)\n            goto cleanup;\n        bersecretkey = krb5_encode_krbsecretkey (entry->key_data,\n                                                 entry->n_key_data, mkvno);\n\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n        /* An empty list of bervals is only accepted for modify operations,\n         * not add operations. */\n        if (bersecretkey[0] != NULL || !create_standalone) {\n            st = krb5_add_ber_mem_ldap_mod(&mods, \"krbprincipalkey\",\n                                           LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                           bersecretkey);\n            if (st != 0)\n                goto cleanup;\n        }\n\n        if (!(entry->mask & KADM5_PRINCIPAL)) {\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n                goto cleanup;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods,\n                                              \"krbpasswordexpiration\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n        /* Update last password change whenever a new key is set */\n        {\n            krb5_timestamp last_pw_changed;\n            if ((st=krb5_dbe_lookup_last_pwd_change(context, entry,\n                                                    &last_pw_changed)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(last_pw_changed)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastPwdChange\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n    } /* Modify Key data ends here */\n\n    /* Auth indicators will also be stored in krbExtraData when processing\n     * tl_data. */\n    st = update_ldap_mod_auth_ind(context, entry, &mods);\n    if (st != 0)\n        goto cleanup;\n\n    /* Set tl_data */\n    if (entry->tl_data != NULL) {\n        int count = 0;\n        struct berval **ber_tl_data = NULL;\n        krb5_tl_data *ptr;\n        krb5_timestamp unlock_time;\n        for (ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n            if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                || ptr->tl_data_type == KDB_TL_USER_INFO\n                || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                continue;\n            count++;\n        }\n        if (count != 0) {\n            int j;\n            ber_tl_data = (struct berval **) calloc (count + 1,\n                                                     sizeof (struct berval*));\n            if (ber_tl_data == NULL) {\n                st = ENOMEM;\n                goto cleanup;\n            }\n            for (j = 0, ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n                /* Ignore tl_data that are stored in separate directory\n                 * attributes */\n                if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                    || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                    || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                    || ptr->tl_data_type == KDB_TL_USER_INFO\n                    || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                    || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                    continue;\n                if ((st = tl_data2berval (ptr, &ber_tl_data[j])) != 0)\n                    break;\n                j++;\n            }\n            if (st == 0) {\n                ber_tl_data[count] = NULL;\n                st=krb5_add_ber_mem_ldap_mod(&mods, \"krbExtraData\",\n                                             LDAP_MOD_REPLACE |\n                                             LDAP_MOD_BVALUES, ber_tl_data);\n            }\n            free_berdata(ber_tl_data);\n            if (st != 0)\n                goto cleanup;\n        }\n        if ((st=krb5_dbe_lookup_last_admin_unlock(context, entry,\n                                                  &unlock_time)) != 0)\n            goto cleanup;\n        if (unlock_time != 0) {\n            /* Update last admin unlock */\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(unlock_time)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastAdminUnlock\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n    }\n\n    /* Directory specific attribute */\n    if (xargs.tktpolicydn != NULL) {\n        int tmask=0;\n\n        if (strlen(xargs.tktpolicydn) != 0) {\n            st = checkattributevalue(ld, xargs.tktpolicydn, \"objectclass\", policyclass, &tmask);\n            CHECK_CLASS_VALIDITY(st, tmask, _(\"ticket policy object value: \"));\n\n            strval[0] = xargs.tktpolicydn;\n            strval[1] = NULL;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n\n        } else {\n            /* if xargs.tktpolicydn is a empty string, then delete\n             * already existing krbticketpolicyreference attr */\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n                goto cleanup;\n        }\n\n    }\n\n    if (establish_links == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = xargs.linkdn;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbObjectReferences\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    /*\n     * in case mods is NULL then return\n     * not sure but can happen in a modprinc\n     * so no need to return an error\n     * addprinc will at least have the principal name\n     * and the keys passed in\n     */\n    if (mods == NULL)\n        goto cleanup;\n\n    if (create_standalone == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = \"krbprincipal\";\n        strval[1] = \"krbprincipalaux\";\n        strval[2] = \"krbTicketPolicyAux\";\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n            goto cleanup;\n\n        st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n        if (st == LDAP_ALREADY_EXISTS && entry->mask & KADM5_LOAD) {\n            /* a load operation must replace an existing entry */\n            st = ldap_delete_ext_s(ld, standalone_principal_dn, NULL, NULL);\n            if (st != LDAP_SUCCESS) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Principal delete failed (trying to replace \"\n                           \"entry): %s\"), ldap_err2string(st));\n                st = translate_ldap_error (st, OP_ADD);\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            } else {\n                st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n            }\n        }\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"Principal add failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_ADD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n    } else {\n        /*\n         * Here existing ldap object is modified and can be related\n         * to any attribute, so always ensure that the ldap\n         * object is extended with all the kerberos related\n         * objectclasses so that there are no constraint\n         * violations.\n         */\n        {\n            char *attrvalues[] = {\"krbprincipalaux\", \"krbTicketPolicyAux\", NULL};\n            int p, q, r=0, amask=0;\n\n            if ((st=checkattributevalue(ld, (xargs.dn) ? xargs.dn : principal_dn,\n                                        \"objectclass\", attrvalues, &amask)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            for (p=1, q=0; p<=2; p<<=1, ++q) {\n                if ((p & amask) == 0)\n                    strval[r++] = attrvalues[q];\n            }\n            if (r != 0) {\n                if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n                    goto cleanup;\n            }\n        }\n        if (xargs.dn != NULL)\n            st=ldap_modify_ext_s(ld, xargs.dn, mods, NULL, NULL);\n        else\n            st = ldap_modify_ext_s(ld, principal_dn, mods, NULL, NULL);\n\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"User modification failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_MOD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            entry->fail_auth_count++;\n    }\n\ncleanup:\n    if (user)\n        free(user);\n\n    if (filtuser)\n        free(filtuser);\n\n    free_xargs(xargs);\n\n    if (standalone_principal_dn)\n        free(standalone_principal_dn);\n\n    if (principal_dn)\n        free (principal_dn);\n\n    if (polname != NULL)\n        free(polname);\n\n    for (tre = 0; tre < ntrees; tre++)\n        free(subtreelist[tre]);\n    free(subtreelist);\n\n    if (subtree)\n        free (subtree);\n\n    if (bersecretkey) {\n        for (l=0; bersecretkey[l]; ++l) {\n            if (bersecretkey[l]->bv_val)\n                free (bersecretkey[l]->bv_val);\n            free (bersecretkey[l]);\n        }\n        free (bersecretkey);\n    }\n\n    if (keys)\n        free (keys);\n\n    ldap_mods_free(mods, 1);\n    ldap_osa_free_princ_ent(&princ_ent);\n    ldap_msgfree(result);\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return(st);\n}",
        "func_after": "krb5_error_code\nkrb5_ldap_put_principal(krb5_context context, krb5_db_entry *entry,\n                        char **db_args)\n{\n    int                         l=0, kerberos_principal_object_type=0;\n    unsigned int                ntrees=0, tre=0;\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL, *ent=NULL;\n    char                        **subtreelist = NULL;\n    char                        *user=NULL, *subtree=NULL, *principal_dn=NULL;\n    char                        *strval[10]={NULL}, errbuf[1024];\n    char                        *filtuser=NULL;\n    struct berval               **bersecretkey=NULL;\n    LDAPMod                     **mods=NULL;\n    krb5_boolean                create_standalone=FALSE;\n    krb5_boolean                establish_links=FALSE;\n    char                        *standalone_principal_dn=NULL;\n    krb5_tl_data                *tl_data=NULL;\n    krb5_key_data               **keys=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    osa_princ_ent_rec           princ_ent = {0};\n    xargs_t                     xargs = {0};\n    char                        *polname = NULL;\n    OPERATION optype;\n    krb5_boolean                found_entry = FALSE;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    SETUP_CONTEXT();\n    if (ldap_context->lrparams == NULL || ldap_context->container_dn == NULL)\n        return EINVAL;\n\n    /* get ldap handle */\n    GET_HANDLE();\n\n    if (!is_principal_in_realm(ldap_context, entry->princ)) {\n        st = EINVAL;\n        k5_setmsg(context, st,\n                  _(\"Principal does not belong to the default realm\"));\n        goto cleanup;\n    }\n\n    /* get the principal information to act on */\n    if (((st=krb5_unparse_name(context, entry->princ, &user)) != 0) ||\n        ((st=krb5_ldap_unparse_principal_name(user)) != 0))\n        goto cleanup;\n    filtuser = ldap_filter_correct(user);\n    if (filtuser == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Identity the type of operation, it can be\n     * add principal or modify principal.\n     * hack if the entry->mask has KRB_PRINCIPAL flag set\n     * then it is a add operation\n     */\n    if (entry->mask & KADM5_PRINCIPAL)\n        optype = ADD_PRINCIPAL;\n    else\n        optype = MODIFY_PRINCIPAL;\n\n    if (((st=krb5_get_princ_type(context, entry, &kerberos_principal_object_type)) != 0) ||\n        ((st=krb5_get_userdn(context, entry, &principal_dn)) != 0))\n        goto cleanup;\n\n    if ((st=process_db_args(context, db_args, &xargs, optype)) != 0)\n        goto cleanup;\n\n    if (entry->mask & KADM5_LOAD) {\n        unsigned int     tree = 0;\n        int              numlentries = 0;\n        char             *filter = NULL;\n\n        /*  A load operation is special, will do a mix-in (add krbprinc\n         *  attrs to a non-krb object entry) if an object exists with a\n         *  matching krbprincipalname attribute so try to find existing\n         *  object and set principal_dn.  This assumes that the\n         *  krbprincipalname attribute is unique (only one object entry has\n         *  a particular krbprincipalname attribute).\n         */\n        if (asprintf(&filter, FILTER\"%s))\", filtuser) < 0) {\n            filter = NULL;\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        /* get the current subtree list */\n        if ((st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees)) != 0)\n            goto cleanup;\n\n        found_entry = FALSE;\n        /* search for entry with matching krbprincipalname attribute */\n        for (tree = 0; found_entry == FALSE && tree < ntrees; ++tree) {\n            if (principal_dn == NULL) {\n                LDAP_SEARCH_1(subtreelist[tree], ldap_context->lrparams->search_scope, filter, principal_attributes, IGNORE_STATUS);\n            } else {\n                /* just look for entry with principal_dn */\n                LDAP_SEARCH_1(principal_dn, LDAP_SCOPE_BASE, filter, principal_attributes, IGNORE_STATUS);\n            }\n            if (st == LDAP_SUCCESS) {\n                numlentries = ldap_count_entries(ld, result);\n                if (numlentries > 1) {\n                    free(filter);\n                    st = EINVAL;\n                    k5_setmsg(context, st,\n                              _(\"operation can not continue, more than one \"\n                                \"entry with principal name \\\"%s\\\" found\"),\n                              user);\n                    goto cleanup;\n                } else if (numlentries == 1) {\n                    found_entry = TRUE;\n                    if (principal_dn == NULL) {\n                        ent = ldap_first_entry(ld, result);\n                        if (ent != NULL) {\n                            /* setting principal_dn will cause that entry to be modified further down */\n                            if ((principal_dn = ldap_get_dn(ld, ent)) == NULL) {\n                                ldap_get_option (ld, LDAP_OPT_RESULT_CODE, &st);\n                                st = set_ldap_error (context, st, 0);\n                                free(filter);\n                                goto cleanup;\n                            }\n                        }\n                    }\n                }\n            } else if (st != LDAP_NO_SUCH_OBJECT) {\n                /* could not perform search, return with failure */\n                st = set_ldap_error (context, st, 0);\n                free(filter);\n                goto cleanup;\n            }\n            ldap_msgfree(result);\n            result = NULL;\n            /*\n             * If it isn't found then assume a standalone princ entry is to\n             * be created.\n             */\n        } /* end for (tree = 0; principal_dn == ... */\n\n        free(filter);\n\n        if (found_entry == FALSE && principal_dn != NULL) {\n            /*\n             * if principal_dn is null then there is code further down to\n             * deal with setting standalone_principal_dn.  Also note that\n             * this will set create_standalone true for\n             * non-mix-in entries which is okay if loading from a dump.\n             */\n            create_standalone = TRUE;\n            standalone_principal_dn = strdup(principal_dn);\n            CHECK_NULL(standalone_principal_dn);\n        }\n    } /* end if (entry->mask & KADM5_LOAD */\n\n    /* time to generate the DN information with the help of\n     * containerdn, principalcontainerreference or\n     * realmcontainerdn information\n     */\n    if (principal_dn == NULL && xargs.dn == NULL) { /* creation of standalone principal */\n        /* get the subtree information */\n        if (entry->princ->length == 2 && entry->princ->data[0].length == strlen(\"krbtgt\") &&\n            strncmp(entry->princ->data[0].data, \"krbtgt\", entry->princ->data[0].length) == 0) {\n            /* if the principal is a inter-realm principal, always created in the realm container */\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        } else if (xargs.containerdn) {\n            if ((st=checkattributevalue(ld, xargs.containerdn, NULL, NULL, NULL)) != 0) {\n                if (st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION) {\n                    int ost = st;\n                    st = EINVAL;\n                    k5_wrapmsg(context, ost, st, _(\"'%s' not found\"),\n                               xargs.containerdn);\n                }\n                goto cleanup;\n            }\n            subtree = strdup(xargs.containerdn);\n        } else if (ldap_context->lrparams->containerref && strlen(ldap_context->lrparams->containerref) != 0) {\n            /*\n             * Here the subtree should be changed with\n             * principalcontainerreference attribute value\n             */\n            subtree = strdup(ldap_context->lrparams->containerref);\n        } else {\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        }\n        CHECK_NULL(subtree);\n\n        if (asprintf(&standalone_principal_dn, \"krbprincipalname=%s,%s\",\n                     filtuser, subtree) < 0)\n            standalone_principal_dn = NULL;\n        CHECK_NULL(standalone_principal_dn);\n        /*\n         * free subtree when you are done using the subtree\n         * set the boolean create_standalone to TRUE\n         */\n        create_standalone = TRUE;\n        free(subtree);\n        subtree = NULL;\n    }\n\n    /*\n     * If the DN information is presented by the user, time to\n     * validate the input to ensure that the DN falls under\n     * any of the subtrees\n     */\n    if (xargs.dn_from_kbd == TRUE) {\n        /* Get the current subtree list if we haven't already done so. */\n        if (subtreelist == NULL) {\n            st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees);\n            if (st)\n                goto cleanup;\n        }\n\n        st = validate_xargs(context, ldap_server_handle, &xargs,\n                            standalone_principal_dn, subtreelist, ntrees);\n        if (st)\n            goto cleanup;\n    }\n\n    if (xargs.linkdn != NULL) {\n        /*\n         * link information can be changed using modprinc.\n         * However, link information can be changed only on the\n         * standalone kerberos principal objects. A standalone\n         * kerberos principal object is of type krbprincipal\n         * structural objectclass.\n         *\n         * NOTE: kerberos principals on an ldap object can't be\n         * linked to other ldap objects.\n         */\n        if (optype == MODIFY_PRINCIPAL &&\n            kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT) {\n            st = EINVAL;\n            snprintf(errbuf, sizeof(errbuf),\n                     _(\"link information can not be set/updated as the \"\n                       \"kerberos principal belongs to an ldap object\"));\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n        /*\n         * Check the link information. If there is already a link\n         * existing then this operation is not allowed.\n         */\n        {\n            char **linkdns=NULL;\n            int  j=0;\n\n            if ((st=krb5_get_linkdn(context, entry, &linkdns)) != 0) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Failed getting object references\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            }\n            if (linkdns != NULL) {\n                st = EINVAL;\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"kerberos principal is already linked to a ldap \"\n                           \"object\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                for (j=0; linkdns[j] != NULL; ++j)\n                    free (linkdns[j]);\n                free (linkdns);\n                goto cleanup;\n            }\n        }\n\n        establish_links = TRUE;\n    }\n\n    if (entry->mask & KADM5_LAST_SUCCESS) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_success)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastSuccessfulAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_LAST_FAILED) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_failed)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastFailedAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free(strval[0]);\n    }\n\n    if (entry->mask & KADM5_FAIL_AUTH_COUNT) {\n        krb5_kvno fail_auth_count;\n\n        fail_auth_count = entry->fail_auth_count;\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            fail_auth_count++;\n\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_REPLACE,\n                                       fail_auth_count);\n        if (st != 0)\n            goto cleanup;\n    } else if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT) {\n        int attr_mask = 0;\n        krb5_boolean has_fail_count;\n\n        /* Check if the krbLoginFailedCount attribute exists.  (Through\n         * krb5 1.8.1, it wasn't set in new entries.) */\n        st = krb5_get_attributes_mask(context, entry, &attr_mask);\n        if (st != 0)\n            goto cleanup;\n        has_fail_count = ((attr_mask & KDB_FAIL_AUTH_COUNT_ATTR) != 0);\n\n        /*\n         * If the client library and server supports RFC 4525,\n         * then use it to increment by one the value of the\n         * krbLoginFailedCount attribute. Otherwise, assert the\n         * (provided) old value by deleting it before adding.\n         */\n#ifdef LDAP_MOD_INCREMENT\n        if (ldap_server_handle->server_info->modify_increment &&\n            has_fail_count) {\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_INCREMENT, 1);\n            if (st != 0)\n                goto cleanup;\n        } else {\n#endif /* LDAP_MOD_INCREMENT */\n            if (has_fail_count) {\n                st = krb5_add_int_mem_ldap_mod(&mods,\n                                               \"krbLoginFailedCount\",\n                                               LDAP_MOD_DELETE,\n                                               entry->fail_auth_count);\n                if (st != 0)\n                    goto cleanup;\n            }\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_ADD,\n                                           entry->fail_auth_count + 1);\n            if (st != 0)\n                goto cleanup;\n#ifdef LDAP_MOD_INCREMENT\n        }\n#endif\n    } else if (optype == ADD_PRINCIPAL) {\n        /* Initialize krbLoginFailedCount in new entries to help avoid a\n         * race during the first failed login. */\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_ADD, 0);\n    }\n\n    if (entry->mask & KADM5_MAX_LIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxticketlife\", LDAP_MOD_REPLACE, entry->max_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_MAX_RLIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxrenewableage\", LDAP_MOD_REPLACE,\n                                          entry->max_renewable_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_ATTRIBUTES) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbticketflags\", LDAP_MOD_REPLACE,\n                                          entry->attributes)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINCIPAL) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = user;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalname\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINC_EXPIRE_TIME) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalexpiration\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_PW_EXPIRATION) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpasswordexpiration\",\n                                          LDAP_MOD_REPLACE,\n                                          strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_POLICY || entry->mask & KADM5_KEY_HIST) {\n        memset(&princ_ent, 0, sizeof(princ_ent));\n        for (tl_data=entry->tl_data; tl_data; tl_data=tl_data->tl_data_next) {\n            if (tl_data->tl_data_type == KRB5_TL_KADM_DATA) {\n                if ((st = krb5_lookup_tl_kadm_data(tl_data, &princ_ent)) != 0) {\n                    goto cleanup;\n                }\n                break;\n            }\n        }\n    }\n\n    if (entry->mask & KADM5_POLICY) {\n        if (princ_ent.aux_attributes & KADM5_POLICY) {\n            memset(strval, 0, sizeof(strval));\n            if ((st = krb5_ldap_name_to_policydn (context, princ_ent.policy, &polname)) != 0)\n                goto cleanup;\n            strval[0] = polname;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n        } else {\n            st = EINVAL;\n            k5_setmsg(context, st, \"Password policy value null\");\n            goto cleanup;\n        }\n    } else if (entry->mask & KADM5_LOAD && found_entry == TRUE) {\n        /*\n         * a load is special in that existing entries must have attrs that\n         * removed.\n         */\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_POLICY_CLR) {\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_KEY_HIST) {\n        bersecretkey = krb5_encode_histkey(&princ_ent);\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        st = krb5_add_ber_mem_ldap_mod(&mods, \"krbpwdhistory\",\n                                       LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                       bersecretkey);\n        if (st != 0)\n            goto cleanup;\n        free_berdata(bersecretkey);\n        bersecretkey = NULL;\n    }\n\n    if (entry->mask & KADM5_KEY_DATA || entry->mask & KADM5_KVNO) {\n        krb5_kvno mkvno;\n\n        if ((st=krb5_dbe_lookup_mkvno(context, entry, &mkvno)) != 0)\n            goto cleanup;\n        bersecretkey = krb5_encode_krbsecretkey (entry->key_data,\n                                                 entry->n_key_data, mkvno);\n\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n        /* An empty list of bervals is only accepted for modify operations,\n         * not add operations. */\n        if (bersecretkey[0] != NULL || !create_standalone) {\n            st = krb5_add_ber_mem_ldap_mod(&mods, \"krbprincipalkey\",\n                                           LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                           bersecretkey);\n            if (st != 0)\n                goto cleanup;\n        }\n\n        if (!(entry->mask & KADM5_PRINCIPAL)) {\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n                goto cleanup;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods,\n                                              \"krbpasswordexpiration\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n        /* Update last password change whenever a new key is set */\n        {\n            krb5_timestamp last_pw_changed;\n            if ((st=krb5_dbe_lookup_last_pwd_change(context, entry,\n                                                    &last_pw_changed)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(last_pw_changed)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastPwdChange\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n    } /* Modify Key data ends here */\n\n    /* Auth indicators will also be stored in krbExtraData when processing\n     * tl_data. */\n    st = update_ldap_mod_auth_ind(context, entry, &mods);\n    if (st != 0)\n        goto cleanup;\n\n    /* Set tl_data */\n    if (entry->tl_data != NULL) {\n        int count = 0;\n        struct berval **ber_tl_data = NULL;\n        krb5_tl_data *ptr;\n        krb5_timestamp unlock_time;\n        for (ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n            if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                || ptr->tl_data_type == KDB_TL_USER_INFO\n                || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                continue;\n            count++;\n        }\n        if (count != 0) {\n            int j;\n            ber_tl_data = (struct berval **) calloc (count + 1,\n                                                     sizeof (struct berval*));\n            if (ber_tl_data == NULL) {\n                st = ENOMEM;\n                goto cleanup;\n            }\n            for (j = 0, ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n                /* Ignore tl_data that are stored in separate directory\n                 * attributes */\n                if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                    || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                    || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                    || ptr->tl_data_type == KDB_TL_USER_INFO\n                    || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                    || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                    continue;\n                if ((st = tl_data2berval (ptr, &ber_tl_data[j])) != 0)\n                    break;\n                j++;\n            }\n            if (st == 0) {\n                ber_tl_data[count] = NULL;\n                st=krb5_add_ber_mem_ldap_mod(&mods, \"krbExtraData\",\n                                             LDAP_MOD_REPLACE |\n                                             LDAP_MOD_BVALUES, ber_tl_data);\n            }\n            free_berdata(ber_tl_data);\n            if (st != 0)\n                goto cleanup;\n        }\n        if ((st=krb5_dbe_lookup_last_admin_unlock(context, entry,\n                                                  &unlock_time)) != 0)\n            goto cleanup;\n        if (unlock_time != 0) {\n            /* Update last admin unlock */\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(unlock_time)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastAdminUnlock\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n    }\n\n    /* Directory specific attribute */\n    if (xargs.tktpolicydn != NULL) {\n        int tmask=0;\n\n        if (strlen(xargs.tktpolicydn) != 0) {\n            st = checkattributevalue(ld, xargs.tktpolicydn, \"objectclass\", policyclass, &tmask);\n            CHECK_CLASS_VALIDITY(st, tmask, _(\"ticket policy object value: \"));\n\n            strval[0] = xargs.tktpolicydn;\n            strval[1] = NULL;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n\n        } else {\n            /* if xargs.tktpolicydn is a empty string, then delete\n             * already existing krbticketpolicyreference attr */\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n                goto cleanup;\n        }\n\n    }\n\n    if (establish_links == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = xargs.linkdn;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbObjectReferences\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    /*\n     * in case mods is NULL then return\n     * not sure but can happen in a modprinc\n     * so no need to return an error\n     * addprinc will at least have the principal name\n     * and the keys passed in\n     */\n    if (mods == NULL)\n        goto cleanup;\n\n    if (create_standalone == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = \"krbprincipal\";\n        strval[1] = \"krbprincipalaux\";\n        strval[2] = \"krbTicketPolicyAux\";\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n            goto cleanup;\n\n        st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n        if (st == LDAP_ALREADY_EXISTS && entry->mask & KADM5_LOAD) {\n            /* a load operation must replace an existing entry */\n            st = ldap_delete_ext_s(ld, standalone_principal_dn, NULL, NULL);\n            if (st != LDAP_SUCCESS) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Principal delete failed (trying to replace \"\n                           \"entry): %s\"), ldap_err2string(st));\n                st = translate_ldap_error (st, OP_ADD);\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            } else {\n                st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n            }\n        }\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"Principal add failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_ADD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n    } else {\n        /*\n         * Here existing ldap object is modified and can be related\n         * to any attribute, so always ensure that the ldap\n         * object is extended with all the kerberos related\n         * objectclasses so that there are no constraint\n         * violations.\n         */\n        {\n            char *attrvalues[] = {\"krbprincipalaux\", \"krbTicketPolicyAux\", NULL};\n            int p, q, r=0, amask=0;\n\n            if ((st=checkattributevalue(ld, (xargs.dn) ? xargs.dn : principal_dn,\n                                        \"objectclass\", attrvalues, &amask)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            for (p=1, q=0; p<=2; p<<=1, ++q) {\n                if ((p & amask) == 0)\n                    strval[r++] = attrvalues[q];\n            }\n            if (r != 0) {\n                if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n                    goto cleanup;\n            }\n        }\n        if (xargs.dn != NULL)\n            st=ldap_modify_ext_s(ld, xargs.dn, mods, NULL, NULL);\n        else\n            st = ldap_modify_ext_s(ld, principal_dn, mods, NULL, NULL);\n\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"User modification failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_MOD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            entry->fail_auth_count++;\n    }\n\ncleanup:\n    if (user)\n        free(user);\n\n    if (filtuser)\n        free(filtuser);\n\n    free_xargs(xargs);\n\n    if (standalone_principal_dn)\n        free(standalone_principal_dn);\n\n    if (principal_dn)\n        free (principal_dn);\n\n    if (polname != NULL)\n        free(polname);\n\n    for (tre = 0; tre < ntrees; tre++)\n        free(subtreelist[tre]);\n    free(subtreelist);\n\n    if (subtree)\n        free (subtree);\n\n    if (bersecretkey) {\n        for (l=0; bersecretkey[l]; ++l) {\n            if (bersecretkey[l]->bv_val)\n                free (bersecretkey[l]->bv_val);\n            free (bersecretkey[l]);\n        }\n        free (bersecretkey);\n    }\n\n    if (keys)\n        free (keys);\n\n    ldap_mods_free(mods, 1);\n    ldap_osa_free_princ_ent(&princ_ent);\n    ldap_msgfree(result);\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return(st);\n}",
        "description": "An authenticated kadmin user with permissions to add principals to an LDAP Kerberos database can trigger a denial of service through a NULL pointer dereference or bypass a DN container check by providing tagged data that is internal to the database module.",
        "commit": "It was discovered that the LDAP DN checking mechanism in the MIT krb5 library had several vulnerabilities. Specifically, the `KDB_TL_USER_INFO` tl-data, which is intended to be internal to the LDAP KDB module, could be inadvertently sent by kadmin clients due to insufficient type number validation. This allowed authenticated kadmin users with permission to add principals to an LDAP Kerberos database to either cause a null dereference in kadmind or bypass intended DN container checks by manipulating tagged data.\n\nTo address these issues, the type number for `KDB_TL_USER_INFO` was set to less than 256, and filtering was implemented in `kadm5_create_principal_3()` to exclude such low type numbers. Additionally, in the LDAP KDB module, checks for container membership were enhanced by factoring out the checks into helper functions and applying them to all relevant client-influenced DNs during `put_principal` operations. These changes aimed to prevent unauthorized access and ensure proper DN validation."
    }
]