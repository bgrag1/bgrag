[
    {
        "cwe": "CWE-667",
        "func_name": "torvalds/pipe_to_file",
        "score": 0.7850326895713806,
        "func_before": "static int pipe_to_file(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\n\t\t\tstruct splice_desc *sd)\n{\n\tstruct file *file = sd->u.file;\n\tstruct address_space *mapping = file->f_mapping;\n\tunsigned int offset, this_len;\n\tstruct page *page;\n\tpgoff_t index;\n\tint ret;\n\n\t/*\n\t * make sure the data in this buffer is uptodate\n\t */\n\tret = buf->ops->confirm(pipe, buf);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tindex = sd->pos >> PAGE_CACHE_SHIFT;\n\toffset = sd->pos & ~PAGE_CACHE_MASK;\n\n\tthis_len = sd->len;\n\tif (this_len + offset > PAGE_CACHE_SIZE)\n\t\tthis_len = PAGE_CACHE_SIZE - offset;\n\nfind_page:\n\tpage = find_lock_page(mapping, index);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tpage = page_cache_alloc_cold(mapping);\n\t\tif (unlikely(!page))\n\t\t\tgoto out_ret;\n\n\t\t/*\n\t\t * This will also lock the page\n\t\t */\n\t\tret = add_to_page_cache_lru(page, mapping, index,\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (unlikely(ret))\n\t\t\tgoto out;\n\t}\n\n\tret = mapping->a_ops->prepare_write(file, page, offset, offset+this_len);\n\tif (unlikely(ret)) {\n\t\tloff_t isize = i_size_read(mapping->host);\n\n\t\tif (ret != AOP_TRUNCATED_PAGE)\n\t\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (ret == AOP_TRUNCATED_PAGE)\n\t\t\tgoto find_page;\n\n\t\t/*\n\t\t * prepare_write() may have instantiated a few blocks\n\t\t * outside i_size.  Trim these off again.\n\t\t */\n\t\tif (sd->pos + this_len > isize)\n\t\t\tvmtruncate(mapping->host, isize);\n\n\t\tgoto out_ret;\n\t}\n\n\tif (buf->page != page) {\n\t\t/*\n\t\t * Careful, ->map() uses KM_USER0!\n\t\t */\n\t\tchar *src = buf->ops->map(pipe, buf, 1);\n\t\tchar *dst = kmap_atomic(page, KM_USER1);\n\n\t\tmemcpy(dst + offset, src + buf->offset, this_len);\n\t\tflush_dcache_page(page);\n\t\tkunmap_atomic(dst, KM_USER1);\n\t\tbuf->ops->unmap(pipe, buf, src);\n\t}\n\n\tret = mapping->a_ops->commit_write(file, page, offset, offset+this_len);\n\tif (ret) {\n\t\tif (ret == AOP_TRUNCATED_PAGE) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto find_page;\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Partial write has happened, so 'ret' already initialized by\n\t\t * number of bytes written, Where is nothing we have to do here.\n\t\t */\n\t} else\n\t\tret = this_len;\n\t/*\n\t * Return the number of bytes written and mark page as\n\t * accessed, we are now done!\n\t */\n\tmark_page_accessed(page);\nout:\n\tpage_cache_release(page);\n\tunlock_page(page);\nout_ret:\n\treturn ret;\n}",
        "func_after": "static int pipe_to_file(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\n\t\t\tstruct splice_desc *sd)\n{\n\tstruct file *file = sd->u.file;\n\tstruct address_space *mapping = file->f_mapping;\n\tunsigned int offset, this_len;\n\tstruct page *page;\n\tpgoff_t index;\n\tint ret;\n\n\t/*\n\t * make sure the data in this buffer is uptodate\n\t */\n\tret = buf->ops->confirm(pipe, buf);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tindex = sd->pos >> PAGE_CACHE_SHIFT;\n\toffset = sd->pos & ~PAGE_CACHE_MASK;\n\n\tthis_len = sd->len;\n\tif (this_len + offset > PAGE_CACHE_SIZE)\n\t\tthis_len = PAGE_CACHE_SIZE - offset;\n\nfind_page:\n\tpage = find_lock_page(mapping, index);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tpage = page_cache_alloc_cold(mapping);\n\t\tif (unlikely(!page))\n\t\t\tgoto out_ret;\n\n\t\t/*\n\t\t * This will also lock the page\n\t\t */\n\t\tret = add_to_page_cache_lru(page, mapping, index,\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (unlikely(ret))\n\t\t\tgoto out_release;\n\t}\n\n\tret = mapping->a_ops->prepare_write(file, page, offset, offset+this_len);\n\tif (unlikely(ret)) {\n\t\tloff_t isize = i_size_read(mapping->host);\n\n\t\tif (ret != AOP_TRUNCATED_PAGE)\n\t\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (ret == AOP_TRUNCATED_PAGE)\n\t\t\tgoto find_page;\n\n\t\t/*\n\t\t * prepare_write() may have instantiated a few blocks\n\t\t * outside i_size.  Trim these off again.\n\t\t */\n\t\tif (sd->pos + this_len > isize)\n\t\t\tvmtruncate(mapping->host, isize);\n\n\t\tgoto out_ret;\n\t}\n\n\tif (buf->page != page) {\n\t\t/*\n\t\t * Careful, ->map() uses KM_USER0!\n\t\t */\n\t\tchar *src = buf->ops->map(pipe, buf, 1);\n\t\tchar *dst = kmap_atomic(page, KM_USER1);\n\n\t\tmemcpy(dst + offset, src + buf->offset, this_len);\n\t\tflush_dcache_page(page);\n\t\tkunmap_atomic(dst, KM_USER1);\n\t\tbuf->ops->unmap(pipe, buf, src);\n\t}\n\n\tret = mapping->a_ops->commit_write(file, page, offset, offset+this_len);\n\tif (ret) {\n\t\tif (ret == AOP_TRUNCATED_PAGE) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto find_page;\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * Partial write has happened, so 'ret' already initialized by\n\t\t * number of bytes written, Where is nothing we have to do here.\n\t\t */\n\t} else\n\t\tret = this_len;\n\t/*\n\t * Return the number of bytes written and mark page as\n\t * accessed, we are now done!\n\t */\n\tmark_page_accessed(page);\nout:\n\tunlock_page(page);\nout_release:\n\tpage_cache_release(page);\nout_ret:\n\treturn ret;\n}",
        "description": "In the splice subsystem of the Linux kernel prior to version 2.6.22.2, there is an issue where the `add_to_page_cache_lru` function's failure is not adequately managed. As a result, the system attempts to unlock a page that was not previously locked, leading to a denial of service condition characterized by a kernel BUG and potential system crash. This vulnerability can be exploited by local users using tools such as fio for I/O operations.",
        "commit": "If the `add_to_page_cache_lru()` function fails, the page remains unlocked. However, the subsequent code in `splice` jumps to an error path that attempts to release and unlock the page, leading to a `BUG()` in `unlock_page()`. This issue can be resolved by introducing an additional label that solely handles the page release without attempting to unlock it. This bug was triggered on EL5 by Gurudas Pai using the fio tool."
    },
    {
        "cwe": "CWE-362",
        "func_name": "torvalds/fib6_add_rt2node",
        "score": 0.7908588647842407,
        "func_before": "static int fib6_add_rt2node(struct fib6_node *fn, struct fib6_info *rt,\n\t\t\t    struct nl_info *info,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct fib6_info *leaf = rcu_dereference_protected(fn->leaf,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\tstruct fib6_info *iter = NULL;\n\tstruct fib6_info __rcu **ins;\n\tstruct fib6_info __rcu **fallback_ins = NULL;\n\tint replace = (info->nlh &&\n\t\t       (info->nlh->nlmsg_flags & NLM_F_REPLACE));\n\tint add = (!info->nlh ||\n\t\t   (info->nlh->nlmsg_flags & NLM_F_CREATE));\n\tint found = 0;\n\tbool rt_can_ecmp = rt6_qualify_for_ecmp(rt);\n\tbool notify_sibling_rt = false;\n\tu16 nlflags = NLM_F_EXCL;\n\tint err;\n\n\tif (info->nlh && (info->nlh->nlmsg_flags & NLM_F_APPEND))\n\t\tnlflags |= NLM_F_APPEND;\n\n\tins = &fn->leaf;\n\n\tfor (iter = leaf; iter;\n\t     iter = rcu_dereference_protected(iter->fib6_next,\n\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock))) {\n\t\t/*\n\t\t *\tSearch for duplicates\n\t\t */\n\n\t\tif (iter->fib6_metric == rt->fib6_metric) {\n\t\t\t/*\n\t\t\t *\tSame priority level\n\t\t\t */\n\t\t\tif (info->nlh &&\n\t\t\t    (info->nlh->nlmsg_flags & NLM_F_EXCL))\n\t\t\t\treturn -EEXIST;\n\n\t\t\tnlflags &= ~NLM_F_EXCL;\n\t\t\tif (replace) {\n\t\t\t\tif (rt_can_ecmp == rt6_qualify_for_ecmp(iter)) {\n\t\t\t\t\tfound++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallback_ins = fallback_ins ?: ins;\n\t\t\t\tgoto next_iter;\n\t\t\t}\n\n\t\t\tif (rt6_duplicate_nexthop(iter, rt)) {\n\t\t\t\tif (rt->fib6_nsiblings)\n\t\t\t\t\trt->fib6_nsiblings = 0;\n\t\t\t\tif (!(iter->fib6_flags & RTF_EXPIRES))\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\tif (!(rt->fib6_flags & RTF_EXPIRES))\n\t\t\t\t\tfib6_clean_expires_locked(iter);\n\t\t\t\telse\n\t\t\t\t\tfib6_set_expires_locked(iter,\n\t\t\t\t\t\t\t\trt->expires);\n\n\t\t\t\tif (rt->fib6_pmtu)\n\t\t\t\t\tfib6_metric_set(iter, RTAX_MTU,\n\t\t\t\t\t\t\trt->fib6_pmtu);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\t/* If we have the same destination and the same metric,\n\t\t\t * but not the same gateway, then the route we try to\n\t\t\t * add is sibling to this route, increment our counter\n\t\t\t * of siblings, and later we will add our route to the\n\t\t\t * list.\n\t\t\t * Only static routes (which don't have flag\n\t\t\t * RTF_EXPIRES) are used for ECMPv6.\n\t\t\t *\n\t\t\t * To avoid long list, we only had siblings if the\n\t\t\t * route have a gateway.\n\t\t\t */\n\t\t\tif (rt_can_ecmp &&\n\t\t\t    rt6_qualify_for_ecmp(iter))\n\t\t\t\trt->fib6_nsiblings++;\n\t\t}\n\n\t\tif (iter->fib6_metric > rt->fib6_metric)\n\t\t\tbreak;\n\nnext_iter:\n\t\tins = &iter->fib6_next;\n\t}\n\n\tif (fallback_ins && !found) {\n\t\t/* No matching route with same ecmp-able-ness found, replace\n\t\t * first matching route\n\t\t */\n\t\tins = fallback_ins;\n\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\tfound++;\n\t}\n\n\t/* Reset round-robin state, if necessary */\n\tif (ins == &fn->leaf)\n\t\tfn->rr_ptr = NULL;\n\n\t/* Link this route to others same route. */\n\tif (rt->fib6_nsiblings) {\n\t\tunsigned int fib6_nsiblings;\n\t\tstruct fib6_info *sibling, *temp_sibling;\n\n\t\t/* Find the first route that have the same metric */\n\t\tsibling = leaf;\n\t\tnotify_sibling_rt = true;\n\t\twhile (sibling) {\n\t\t\tif (sibling->fib6_metric == rt->fib6_metric &&\n\t\t\t    rt6_qualify_for_ecmp(sibling)) {\n\t\t\t\tlist_add_tail(&rt->fib6_siblings,\n\t\t\t\t\t      &sibling->fib6_siblings);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsibling = rcu_dereference_protected(sibling->fib6_next,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\tnotify_sibling_rt = false;\n\t\t}\n\t\t/* For each sibling in the list, increment the counter of\n\t\t * siblings. BUG() if counters does not match, list of siblings\n\t\t * is broken!\n\t\t */\n\t\tfib6_nsiblings = 0;\n\t\tlist_for_each_entry_safe(sibling, temp_sibling,\n\t\t\t\t\t &rt->fib6_siblings, fib6_siblings) {\n\t\t\tsibling->fib6_nsiblings++;\n\t\t\tBUG_ON(sibling->fib6_nsiblings != rt->fib6_nsiblings);\n\t\t\tfib6_nsiblings++;\n\t\t}\n\t\tBUG_ON(fib6_nsiblings != rt->fib6_nsiblings);\n\t\trt6_multipath_rebalance(temp_sibling);\n\t}\n\n\t/*\n\t *\tinsert node\n\t */\n\tif (!replace) {\n\t\tif (!add)\n\t\t\tpr_warn(\"NLM_F_CREATE should be set when creating new route\\n\");\n\nadd:\n\t\tnlflags |= NLM_F_CREATE;\n\n\t\t/* The route should only be notified if it is the first\n\t\t * route in the node or if it is added as a sibling\n\t\t * route to the first route in the node.\n\t\t */\n\t\tif (!info->skip_notify_kernel &&\n\t\t    (notify_sibling_rt || ins == &fn->leaf)) {\n\t\t\tenum fib_event_type fib_event;\n\n\t\t\tif (notify_sibling_rt)\n\t\t\t\tfib_event = FIB_EVENT_ENTRY_APPEND;\n\t\t\telse\n\t\t\t\tfib_event = FIB_EVENT_ENTRY_REPLACE;\n\t\t\terr = call_fib6_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\tfib_event, rt,\n\t\t\t\t\t\t\textack);\n\t\t\tif (err) {\n\t\t\t\tstruct fib6_info *sibling, *next_sibling;\n\n\t\t\t\t/* If the route has siblings, then it first\n\t\t\t\t * needs to be unlinked from them.\n\t\t\t\t */\n\t\t\t\tif (!rt->fib6_nsiblings)\n\t\t\t\t\treturn err;\n\n\t\t\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t\t\t\t &rt->fib6_siblings,\n\t\t\t\t\t\t\t fib6_siblings)\n\t\t\t\t\tsibling->fib6_nsiblings--;\n\t\t\t\trt->fib6_nsiblings = 0;\n\t\t\t\tlist_del_init(&rt->fib6_siblings);\n\t\t\t\trt6_multipath_rebalance(next_sibling);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\trcu_assign_pointer(rt->fib6_next, iter);\n\t\tfib6_info_hold(rt);\n\t\trcu_assign_pointer(rt->fib6_node, fn);\n\t\trcu_assign_pointer(*ins, rt);\n\t\tif (!info->skip_notify)\n\t\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, nlflags);\n\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries++;\n\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\n\t} else {\n\t\tint nsiblings;\n\n\t\tif (!found) {\n\t\t\tif (add)\n\t\t\t\tgoto add;\n\t\t\tpr_warn(\"NLM_F_REPLACE set, but no existing node found!\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (!info->skip_notify_kernel && ins == &fn->leaf) {\n\t\t\terr = call_fib6_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\tFIB_EVENT_ENTRY_REPLACE,\n\t\t\t\t\t\t\trt, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tfib6_info_hold(rt);\n\t\trcu_assign_pointer(rt->fib6_node, fn);\n\t\trt->fib6_next = iter->fib6_next;\n\t\trcu_assign_pointer(*ins, rt);\n\t\tif (!info->skip_notify)\n\t\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, NLM_F_REPLACE);\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\t\tnsiblings = iter->fib6_nsiblings;\n\t\titer->fib6_node = NULL;\n\t\tfib6_purge_rt(iter, fn, info->nl_net);\n\t\tif (rcu_access_pointer(fn->rr_ptr) == iter)\n\t\t\tfn->rr_ptr = NULL;\n\t\tfib6_info_release(iter);\n\n\t\tif (nsiblings) {\n\t\t\t/* Replacing an ECMP route, remove all siblings */\n\t\t\tins = &rt->fib6_next;\n\t\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\twhile (iter) {\n\t\t\t\tif (iter->fib6_metric > rt->fib6_metric)\n\t\t\t\t\tbreak;\n\t\t\t\tif (rt6_qualify_for_ecmp(iter)) {\n\t\t\t\t\t*ins = iter->fib6_next;\n\t\t\t\t\titer->fib6_node = NULL;\n\t\t\t\t\tfib6_purge_rt(iter, fn, info->nl_net);\n\t\t\t\t\tif (rcu_access_pointer(fn->rr_ptr) == iter)\n\t\t\t\t\t\tfn->rr_ptr = NULL;\n\t\t\t\t\tfib6_info_release(iter);\n\t\t\t\t\tnsiblings--;\n\t\t\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries--;\n\t\t\t\t} else {\n\t\t\t\t\tins = &iter->fib6_next;\n\t\t\t\t}\n\t\t\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\t}\n\t\t\tWARN_ON(nsiblings != 0);\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "func_after": "static int fib6_add_rt2node(struct fib6_node *fn, struct fib6_info *rt,\n\t\t\t    struct nl_info *info,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct fib6_info *leaf = rcu_dereference_protected(fn->leaf,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\tstruct fib6_info *iter = NULL;\n\tstruct fib6_info __rcu **ins;\n\tstruct fib6_info __rcu **fallback_ins = NULL;\n\tint replace = (info->nlh &&\n\t\t       (info->nlh->nlmsg_flags & NLM_F_REPLACE));\n\tint add = (!info->nlh ||\n\t\t   (info->nlh->nlmsg_flags & NLM_F_CREATE));\n\tint found = 0;\n\tbool rt_can_ecmp = rt6_qualify_for_ecmp(rt);\n\tbool notify_sibling_rt = false;\n\tu16 nlflags = NLM_F_EXCL;\n\tint err;\n\n\tif (info->nlh && (info->nlh->nlmsg_flags & NLM_F_APPEND))\n\t\tnlflags |= NLM_F_APPEND;\n\n\tins = &fn->leaf;\n\n\tfor (iter = leaf; iter;\n\t     iter = rcu_dereference_protected(iter->fib6_next,\n\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock))) {\n\t\t/*\n\t\t *\tSearch for duplicates\n\t\t */\n\n\t\tif (iter->fib6_metric == rt->fib6_metric) {\n\t\t\t/*\n\t\t\t *\tSame priority level\n\t\t\t */\n\t\t\tif (info->nlh &&\n\t\t\t    (info->nlh->nlmsg_flags & NLM_F_EXCL))\n\t\t\t\treturn -EEXIST;\n\n\t\t\tnlflags &= ~NLM_F_EXCL;\n\t\t\tif (replace) {\n\t\t\t\tif (rt_can_ecmp == rt6_qualify_for_ecmp(iter)) {\n\t\t\t\t\tfound++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallback_ins = fallback_ins ?: ins;\n\t\t\t\tgoto next_iter;\n\t\t\t}\n\n\t\t\tif (rt6_duplicate_nexthop(iter, rt)) {\n\t\t\t\tif (rt->fib6_nsiblings)\n\t\t\t\t\trt->fib6_nsiblings = 0;\n\t\t\t\tif (!(iter->fib6_flags & RTF_EXPIRES))\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\tif (!(rt->fib6_flags & RTF_EXPIRES))\n\t\t\t\t\tfib6_clean_expires(iter);\n\t\t\t\telse\n\t\t\t\t\tfib6_set_expires(iter, rt->expires);\n\n\t\t\t\tif (rt->fib6_pmtu)\n\t\t\t\t\tfib6_metric_set(iter, RTAX_MTU,\n\t\t\t\t\t\t\trt->fib6_pmtu);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\t/* If we have the same destination and the same metric,\n\t\t\t * but not the same gateway, then the route we try to\n\t\t\t * add is sibling to this route, increment our counter\n\t\t\t * of siblings, and later we will add our route to the\n\t\t\t * list.\n\t\t\t * Only static routes (which don't have flag\n\t\t\t * RTF_EXPIRES) are used for ECMPv6.\n\t\t\t *\n\t\t\t * To avoid long list, we only had siblings if the\n\t\t\t * route have a gateway.\n\t\t\t */\n\t\t\tif (rt_can_ecmp &&\n\t\t\t    rt6_qualify_for_ecmp(iter))\n\t\t\t\trt->fib6_nsiblings++;\n\t\t}\n\n\t\tif (iter->fib6_metric > rt->fib6_metric)\n\t\t\tbreak;\n\nnext_iter:\n\t\tins = &iter->fib6_next;\n\t}\n\n\tif (fallback_ins && !found) {\n\t\t/* No matching route with same ecmp-able-ness found, replace\n\t\t * first matching route\n\t\t */\n\t\tins = fallback_ins;\n\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\tfound++;\n\t}\n\n\t/* Reset round-robin state, if necessary */\n\tif (ins == &fn->leaf)\n\t\tfn->rr_ptr = NULL;\n\n\t/* Link this route to others same route. */\n\tif (rt->fib6_nsiblings) {\n\t\tunsigned int fib6_nsiblings;\n\t\tstruct fib6_info *sibling, *temp_sibling;\n\n\t\t/* Find the first route that have the same metric */\n\t\tsibling = leaf;\n\t\tnotify_sibling_rt = true;\n\t\twhile (sibling) {\n\t\t\tif (sibling->fib6_metric == rt->fib6_metric &&\n\t\t\t    rt6_qualify_for_ecmp(sibling)) {\n\t\t\t\tlist_add_tail(&rt->fib6_siblings,\n\t\t\t\t\t      &sibling->fib6_siblings);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsibling = rcu_dereference_protected(sibling->fib6_next,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\tnotify_sibling_rt = false;\n\t\t}\n\t\t/* For each sibling in the list, increment the counter of\n\t\t * siblings. BUG() if counters does not match, list of siblings\n\t\t * is broken!\n\t\t */\n\t\tfib6_nsiblings = 0;\n\t\tlist_for_each_entry_safe(sibling, temp_sibling,\n\t\t\t\t\t &rt->fib6_siblings, fib6_siblings) {\n\t\t\tsibling->fib6_nsiblings++;\n\t\t\tBUG_ON(sibling->fib6_nsiblings != rt->fib6_nsiblings);\n\t\t\tfib6_nsiblings++;\n\t\t}\n\t\tBUG_ON(fib6_nsiblings != rt->fib6_nsiblings);\n\t\trt6_multipath_rebalance(temp_sibling);\n\t}\n\n\t/*\n\t *\tinsert node\n\t */\n\tif (!replace) {\n\t\tif (!add)\n\t\t\tpr_warn(\"NLM_F_CREATE should be set when creating new route\\n\");\n\nadd:\n\t\tnlflags |= NLM_F_CREATE;\n\n\t\t/* The route should only be notified if it is the first\n\t\t * route in the node or if it is added as a sibling\n\t\t * route to the first route in the node.\n\t\t */\n\t\tif (!info->skip_notify_kernel &&\n\t\t    (notify_sibling_rt || ins == &fn->leaf)) {\n\t\t\tenum fib_event_type fib_event;\n\n\t\t\tif (notify_sibling_rt)\n\t\t\t\tfib_event = FIB_EVENT_ENTRY_APPEND;\n\t\t\telse\n\t\t\t\tfib_event = FIB_EVENT_ENTRY_REPLACE;\n\t\t\terr = call_fib6_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\tfib_event, rt,\n\t\t\t\t\t\t\textack);\n\t\t\tif (err) {\n\t\t\t\tstruct fib6_info *sibling, *next_sibling;\n\n\t\t\t\t/* If the route has siblings, then it first\n\t\t\t\t * needs to be unlinked from them.\n\t\t\t\t */\n\t\t\t\tif (!rt->fib6_nsiblings)\n\t\t\t\t\treturn err;\n\n\t\t\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t\t\t\t &rt->fib6_siblings,\n\t\t\t\t\t\t\t fib6_siblings)\n\t\t\t\t\tsibling->fib6_nsiblings--;\n\t\t\t\trt->fib6_nsiblings = 0;\n\t\t\t\tlist_del_init(&rt->fib6_siblings);\n\t\t\t\trt6_multipath_rebalance(next_sibling);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\trcu_assign_pointer(rt->fib6_next, iter);\n\t\tfib6_info_hold(rt);\n\t\trcu_assign_pointer(rt->fib6_node, fn);\n\t\trcu_assign_pointer(*ins, rt);\n\t\tif (!info->skip_notify)\n\t\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, nlflags);\n\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries++;\n\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\n\t} else {\n\t\tint nsiblings;\n\n\t\tif (!found) {\n\t\t\tif (add)\n\t\t\t\tgoto add;\n\t\t\tpr_warn(\"NLM_F_REPLACE set, but no existing node found!\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (!info->skip_notify_kernel && ins == &fn->leaf) {\n\t\t\terr = call_fib6_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\tFIB_EVENT_ENTRY_REPLACE,\n\t\t\t\t\t\t\trt, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tfib6_info_hold(rt);\n\t\trcu_assign_pointer(rt->fib6_node, fn);\n\t\trt->fib6_next = iter->fib6_next;\n\t\trcu_assign_pointer(*ins, rt);\n\t\tif (!info->skip_notify)\n\t\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, NLM_F_REPLACE);\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\t\tnsiblings = iter->fib6_nsiblings;\n\t\titer->fib6_node = NULL;\n\t\tfib6_purge_rt(iter, fn, info->nl_net);\n\t\tif (rcu_access_pointer(fn->rr_ptr) == iter)\n\t\t\tfn->rr_ptr = NULL;\n\t\tfib6_info_release(iter);\n\n\t\tif (nsiblings) {\n\t\t\t/* Replacing an ECMP route, remove all siblings */\n\t\t\tins = &rt->fib6_next;\n\t\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\twhile (iter) {\n\t\t\t\tif (iter->fib6_metric > rt->fib6_metric)\n\t\t\t\t\tbreak;\n\t\t\t\tif (rt6_qualify_for_ecmp(iter)) {\n\t\t\t\t\t*ins = iter->fib6_next;\n\t\t\t\t\titer->fib6_node = NULL;\n\t\t\t\t\tfib6_purge_rt(iter, fn, info->nl_net);\n\t\t\t\t\tif (rcu_access_pointer(fn->rr_ptr) == iter)\n\t\t\t\t\t\tfn->rr_ptr = NULL;\n\t\t\t\t\tfib6_info_release(iter);\n\t\t\t\t\tnsiblings--;\n\t\t\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries--;\n\t\t\t\t} else {\n\t\t\t\t\tins = &iter->fib6_next;\n\t\t\t\t}\n\t\t\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\t}\n\t\t\tWARN_ON(nsiblings != 0);\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "description": "A race condition exists in the Linux Kernel where an unauthenticated attacker from an adjacent network could exploit it by sending an ICMPv6 router advertisement packet, potentially leading to arbitrary code execution.",
        "commit": "This vulnerability involves a revert of a specific commit due to race conditions related to the management of the `expires` field in a `fib6_info` structure. The original commit introduced issues where the garbage collection (gc) process could start before the entry was added to the gc list and the timer value was set, potentially leading to a use-after-free (UAF) condition. The recommended approach is to revert the commit and address the problem in a future release."
    },
    {
        "cwe": "CWE-416",
        "func_name": "torvalds/ipt_do_table",
        "score": 0.788750171661377,
        "func_before": "unsigned int\nipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
        "func_after": "unsigned int\nipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = rcu_access_pointer(table->private);\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
        "description": "An issue was discovered in the netfilter component of the Linux kernel prior to version 5.10. This vulnerability involves a use-after-free condition in the packet processing context due to improper handling of per-CPU sequence counts during concurrent iptables rule replacements. This flaw could be exploited by users with the CAP_NET_ADMIN capability in an unprivileged namespace.",
        "commit": "When performing concurrent iptables rules replacement, the system checks the per-CPU sequence count after assigning new information. This sequence count is intended to synchronize with the packet path without using explicit locking. If packets are currently using the old table information, the sequence count is incremented to an odd value and then to an even value after processing. After assigning the new table information, a write memory barrier is executed to ensure all CPUs see the latest value. If the packet path starts with the old table information, the sequence counter remains odd, and the iptables replacement waits until the sequence count is even before freeing the old table information. However, if the CPU delays executing the new table information assignment and memory barrier, another CPU's packet path may still use the old table information. This delay can lead to a use-after-free error in the packet processing context, resulting in a kernel NULL pointer dereference. To fix this issue, either enforce instruction ordering after the new table information assignment or switch to RCU for synchronization."
    },
    {
        "cwe": "CWE-404",
        "func_name": "wireshark/dissect_iscsi",
        "score": 0.775359570980072,
        "func_before": "static int\ndissect_iscsi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean check_port) {\n    /* Set up structures needed to add the protocol subtree and manage it */\n    guint offset = 0;\n    guint32 available_bytes = tvb_captured_length(tvb);\n    int digestsActive = 1;\n    conversation_t *conversation = NULL;\n    iscsi_session_t *iscsi_session=NULL;\n    guint8 opcode, tmpbyte;\n\n    if (available_bytes < 48) {\n        /* heuristic already rejected the packet if size < 48,\n           assume it's an iscsi packet with a segmented header */\n        pinfo->desegment_offset = offset;\n        pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\n        return -1;\n    }\n\n    opcode = tvb_get_guint8(tvb, offset + 0);\n    opcode &= OPCODE_MASK;\n\n    /* heuristics to verify that the packet looks sane.   the heuristics\n     * are based on the RFC version of iscsi.\n     * (we should retire support for older iscsi versions in wireshark)\n     *      -- ronnie s\n     */\n    /* opcode must be any of the ones from the standard\n     * also check the header that it looks \"sane\"\n     * all reserved or undefined bits in iscsi must be set to zero.\n     */\n    switch(opcode){\n    case ISCSI_OPCODE_NOP_IN:\n        /* top two bits of byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2 and 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_NOP_OUT:\n        /* top bit of byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2 and 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        /* assume ITT and TTT must always be non NULL (ok they can be NULL\n         * from time to time but it usually means we are in the middle\n         * of a zeroed datablock).\n         */\n        if(!tvb_get_letohl(tvb,offset+16) || !tvb_get_letohl(tvb,offset+20)){\n            return 0;\n        }\n        /* all reserved bytes between 32 - 47 must be null */\n        if(tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGIN_COMMAND:\n        /* top two bits in byte 0 must be 0x40 */\n        if((tvb_get_guint8(tvb, offset+0)&0xc0)!=0x40){\n\n            return 0;\n        }\n        /* both the T and C bits can not be set\n         * and the two reserved bits in byte 1 must be 0\n         */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        switch(tmpbyte&0xf0){\n        case 0x80:\n        case 0x40:\n        case 0x00:\n            break;\n        default:\n            return 0;\n        }\n        /* CSG and NSG must not be 2 */\n        if(((tmpbyte & 0x03) == 0x02)\n           || ((tmpbyte & 0x0c) == 0x08)) {\n            return 0;\n        }\n        /* if T bit is set NSG must not be 0 */\n        if(tmpbyte&0x80){\n            if(!(tmpbyte&0x03)){\n                return 0;\n            }\n        }\n        /* should we test that datasegmentlen is non zero? */\n        break;\n    case ISCSI_OPCODE_LOGIN_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n\n            return 0;\n        }\n        /* both the T and C bits can not be set\n         * and the two reserved bits in byte 1 must be 0\n         */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        switch(tmpbyte&0xf0){\n        case 0x80:\n        case 0x40:\n        case 0x00:\n            break;\n        default:\n            return 0;\n        }\n        /* CSG and NSG must not be 2 */\n        if(((tmpbyte & 0x03) == 0x02)\n           || ((tmpbyte & 0x0c) == 0x08)) {\n            return 0;\n        }\n        /* if T bit is set NSG must not be 0 */\n        if(tmpbyte&0x80){\n            if(!(tmpbyte&0x03)){\n                return 0;\n            }\n        }\n        /* the 32bit words at offsets 20, 40, 44 must be zero */\n        if(tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the two bytes at offset 38 must be zero */\n        if(tvb_get_letohs(tvb,offset+38)){\n            return 0;\n        }\n        /* should we test that datasegmentlen is non zero unless we just\n         * entered full featured phase?\n         */\n        break;\n    case ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* top bit in byte 1 must be set */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* Function must be known */\n        if(!try_val_to_str(tmpbyte&0x7f, iscsi_task_management_functions)){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl must be null */\n        if(tvb_get_letohl(tvb,offset+4)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* response must be 0-6 or 255 */\n        tmpbyte=tvb_get_guint8(tvb,offset+2);\n        if(tmpbyte>6 && tmpbyte<255){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb,offset+3)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 20, 36\n         * 40, 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGOUT_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* top bit in byte 1 must be set */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* Reason code must be known */\n        if(!try_val_to_str(tmpbyte&0x7f, iscsi_logout_reasons)){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 32, 36\n         * 40, 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SNACK_REQUEST:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* top 4 bits in byte 1 must be 0x80 */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if((tmpbyte&0xf0)!=0x80){\n            return 0;\n        }\n        /* type must be known */\n        if(!try_val_to_str(tmpbyte&0x0f, iscsi_snack_types)){\n            return 0;\n        }\n        /* for status/snack and datack itt must be 0xffffffff\n         * for rdata/snack ttt must not be 0 or 0xffffffff\n         */\n        switch(tmpbyte&0x0f){\n        case 1:\n        case 2:\n            if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n                return 0;\n            }\n            break;\n        case 3:\n            if(tvb_get_letohl(tvb,offset+20)==0xffffffff){\n                return 0;\n            }\n            if(tvb_get_letohl(tvb,offset+20)==0){\n                return 0;\n            }\n            break;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 24, 32, 36\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+24)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)){\n            return 0;\n        }\n\n        break;\n    case ISCSI_OPCODE_R2T:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl must be null */\n        if(tvb_get_letohl(tvb,offset+4)){\n            return 0;\n        }\n        /* desired data transfer length must not be null */\n        if(!tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_REJECT:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* reason must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_reject_reasons)){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        /* the 32bit words at offsets 8, 12, 20, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the 32bit word at 16 must be 0xffffffff */\n        if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TEXT_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* one of the F and C bits must be set but not both\n         * low 6 bits in byte 1 must be 0\n         */\n        switch(tvb_get_guint8(tvb,offset+1)){\n        case 0x80:\n        case 0x40:\n            break;\n        default:\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 32, 36, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TEXT_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* one of the F and C bits must be set but not both\n         * low 6 bits in byte 1 must be 0\n         */\n        switch(tvb_get_guint8(tvb,offset+1)){\n        case 0x80:\n        case 0x40:\n            break;\n        default:\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 36, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* reserved bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb, offset+1)&0x18){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* if expected data transfer length is set, W and/or R have to be set */\n        if(tvb_get_ntohl(tvb,offset+20)){\n            if(!(tvb_get_guint8(tvb, offset+1)&0x60)){\n                return 0;\n            }\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* top bit in byte 1 must be 1 */\n        tmpbyte=tvb_get_guint8(tvb,offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* the reserved bits in byte 1 must be 0 */\n        if(tmpbyte&0x61){\n            return 0;\n        }\n        /* status must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+3), scsi_status_val)){\n            return 0;\n        }\n        /* the 32bit words at offsets 8, 12\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_ASYNC_MESSAGE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 20, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the 32bit word at 16 must be 0xffffffff */\n        if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGOUT_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* response must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_logout_response)){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb,offset+3)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 20, 36\n         * 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_DATA_OUT:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* low 7 bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb,offset+1)&0x7f){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 24, 32, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+24)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_DATA_IN:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* reserved bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb,offset+1)&0x38){\n            return 0;\n        }\n        /* byte 2 must be reserved */\n        if(tvb_get_guint8(tvb,offset+2)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I0:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I1:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I2:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T0:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T1:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T2:\n        break;\n    default:\n        return 0;\n    } /* end of heuristics check */\n\n\n    /* process multiple iSCSI PDUs per packet */\n    while(available_bytes >= 48 || (iscsi_desegment && available_bytes >= 8)) {\n        const char *opcode_str = NULL;\n        guint32 data_segment_len;\n        guint32 pduLen = 48;\n        guint8 secondPduByte = tvb_get_guint8(tvb, offset + 1);\n        int badPdu = FALSE;\n        guint8 ahsLen=0;\n        guint32 data_segment_offset, data_segment_len_padded;\n\n        /* mask out any extra bits in the opcode byte */\n        opcode = tvb_get_guint8(tvb, offset + 0);\n        opcode &= OPCODE_MASK;\n\n        opcode_str = try_val_to_str(opcode, iscsi_opcodes);\n        if(opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION ||\n           opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\n           opcode == ISCSI_OPCODE_R2T ||\n           opcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\n           opcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\n           opcode == ISCSI_OPCODE_SNACK_REQUEST)\n            data_segment_len = 0;\n        else\n            data_segment_len = tvb_get_ntohl(tvb, offset + 4) & 0x00ffffff;\n\n        if(opcode_str == NULL) {\n            badPdu = TRUE;\n        }\n\n\n        if(!badPdu && check_port) {\n            badPdu = TRUE;\n            if ((opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->srcport)) {\n                badPdu = FALSE;\n            }\n            if (!(opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->destport)) {\n                badPdu = FALSE;\n            }\n            if ((opcode & TARGET_OPCODE_BIT) && pinfo->srcport == iscsi_system_port) {\n                badPdu = FALSE;\n            }\n            if (!(opcode & TARGET_OPCODE_BIT) && pinfo->destport == iscsi_system_port) {\n                badPdu = FALSE;\n            }\n        }\n\n        if(!badPdu && enable_bogosity_filter) {\n            /* try and distinguish between data and real headers */\n            if(data_segment_len > bogus_pdu_data_length_threshold) {\n                badPdu = TRUE;\n            }\n            else if(demand_good_f_bit &&\n                    !(secondPduByte & 0x80) &&\n                    (opcode == ISCSI_OPCODE_NOP_OUT ||\n                     opcode == ISCSI_OPCODE_NOP_IN ||\n                     opcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\n                     opcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\n                     opcode == ISCSI_OPCODE_SCSI_RESPONSE ||\n                     opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\n                     opcode == ISCSI_OPCODE_R2T ||\n                     opcode == ISCSI_OPCODE_ASYNC_MESSAGE ||\n                     opcode == ISCSI_OPCODE_SNACK_REQUEST ||\n                     opcode == ISCSI_OPCODE_REJECT)) {\n                badPdu = TRUE;\n            } else if(opcode==ISCSI_OPCODE_NOP_OUT) {\n                /* TransferTag for NOP-Out should either be -1 or\n                   the tag value we want for a response.\n                   Assume 0 means we are just inside a big all zero\n                   datablock.\n                */\n                if(tvb_get_ntohl(tvb, offset+20)==0){\n                    badPdu = TRUE;\n                }\n            }\n        }\n\n        if(badPdu) {\n            return offset;\n        }\n\n        if(opcode == ISCSI_OPCODE_LOGIN_COMMAND ||\n           opcode == ISCSI_OPCODE_LOGIN_RESPONSE) {\n            if(iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT08) {\n                if((secondPduByte & CSG_MASK) < ISCSI_CSG_OPERATIONAL_NEGOTIATION) {\n                    /* digests are not yet turned on */\n                    digestsActive = 0;\n                }\n            } else {\n                digestsActive = 0;\n            }\n        }\n\n        if(opcode == ISCSI_OPCODE_SCSI_COMMAND) {\n            /* ahsLen */\n            ahsLen = tvb_get_guint8(tvb, offset + 4);\n            pduLen += ahsLen * 4;\n        }\n\n        data_segment_offset = pduLen;\n        data_segment_len_padded = data_segment_len;\n        if((data_segment_len_padded & 3) != 0)\n            data_segment_len_padded += 4 - (data_segment_len_padded & 3);\n        pduLen += data_segment_len_padded;\n\n\n        /* make sure we have a conversation for this session */\n        conversation = find_or_create_conversation(pinfo);\n\n        iscsi_session=(iscsi_session_t *)conversation_get_proto_data(conversation, proto_iscsi);\n        if(!iscsi_session){\n            iscsi_session = wmem_new(wmem_file_scope(), iscsi_session_t);\n            iscsi_session->header_digest = ISCSI_DIGEST_AUTO;\n            iscsi_session->data_digest = ISCSI_DIGEST_AUTO;\n            iscsi_session->itlq = wmem_tree_new(wmem_file_scope());\n            iscsi_session->itl  = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);\n            conversation_add_proto_data(conversation, proto_iscsi, iscsi_session);\n\n            /* DataOut PDUs are often mistaken by DCERPC heuristics to be\n             * that protocol. Now that we know this is iscsi, set a\n             * dissector for this conversation to block other heuristic\n             * dissectors.\n             */\n            conversation_set_dissector(conversation, iscsi_handle);\n        }\n        /* try to autodetect if header digest is used or not */\n        if (digestsActive && (available_bytes >= (guint32) (48+4+ahsLen*4)) &&\n            (iscsi_session->header_digest == ISCSI_DIGEST_AUTO)) {\n            guint32 crc;\n            /* we have enough data to test if HeaderDigest is enabled */\n            crc= ~crc32c_tvb_offset_calculate(tvb, offset, 48+ahsLen*4, CRC32C_PRELOAD);\n            if(crc==tvb_get_ntohl(tvb,48+ahsLen*4)){\n                iscsi_session->header_digest = ISCSI_DIGEST_CRC32;\n            } else {\n                iscsi_session->header_digest = ISCSI_DIGEST_NONE;\n            }\n        }\n\n\n        /* Add header digest length to pdulen */\n        if(digestsActive){\n            switch(iscsi_session->header_digest){\n            case ISCSI_DIGEST_CRC32:\n                pduLen += 4;\n                data_segment_offset += 4;\n                break;\n            case ISCSI_DIGEST_NONE:\n                break;\n            case ISCSI_DIGEST_AUTO:\n                /* oops we don't yet know what digest is used */\n                /* here we should use some default */\n                break;\n            default:\n                DISSECTOR_ASSERT_NOT_REACHED();\n            }\n        }\n\n        /* try to autodetect whether data digest is used */\n        if (digestsActive &&\n            (available_bytes >= data_segment_offset + data_segment_len_padded + 4) &&\n            (iscsi_session->data_digest == ISCSI_DIGEST_AUTO)) {\n            guint32 crc;\n            /* we have enough data to test if DataDigest is enabled */\n            crc = ~crc32c_tvb_offset_calculate(tvb, data_segment_offset, data_segment_len_padded, CRC32C_PRELOAD);\n            if (crc == tvb_get_ntohl(tvb, data_segment_offset + data_segment_len_padded)) {\n                iscsi_session->data_digest = ISCSI_DIGEST_CRC32;\n            } else {\n                iscsi_session->data_digest = ISCSI_DIGEST_NONE;\n            }\n        }\n\n        /* Add data digest length to pdulen */\n        if (digestsActive && data_segment_len > 0) {\n            switch (iscsi_session->data_digest) {\n            case ISCSI_DIGEST_CRC32:\n                pduLen += 4;\n                break;\n            case ISCSI_DIGEST_NONE:\n                break;\n            case ISCSI_DIGEST_AUTO:\n                /* unknown digest, perhaps a new field was introduced? */\n                break;\n            default:\n                DISSECTOR_ASSERT_NOT_REACHED();\n            }\n        }\n\n        /*\n         * Desegmentation check.\n         */\n        if(iscsi_desegment && pinfo->can_desegment) {\n            if(pduLen > available_bytes) {\n                /*\n                 * This frame doesn't have all of the data for\n                 * this message, but we can do reassembly on it.\n                 *\n                 * Tell the TCP dissector where the data for this\n                 * message starts in the data it handed us, and\n                 * how many more bytes we need, and return.\n                 */\n                pinfo->desegment_offset = offset;\n                pinfo->desegment_len = pduLen - available_bytes;\n                return -1;\n            }\n        }\n\n        /* This is to help TCP keep track of PDU boundaries\n           and allows it to find PDUs that are not aligned to\n           the start of a TCP segments.\n           Since it also allows TCP to know what is in the middle\n           of a large PDU, it reduces the probability of a segment\n           in the middle of a large PDU transfer being misdissected as\n           a PDU.\n        */\n        if(!pinfo->fd->visited){\n            if(pduLen>(guint32)tvb_reported_length_remaining(tvb, offset)){\n                pinfo->want_pdu_tracking=2;\n                pinfo->bytes_until_next_pdu=pduLen-tvb_reported_length_remaining(tvb, offset);\n            }\n        }\n\n        if (offset == 0)\n            col_set_str(pinfo->cinfo, COL_INFO, \"\");\n        else\n            col_append_str(pinfo->cinfo, COL_INFO, \", \");\n\n        dissect_iscsi_pdu(tvb, pinfo, tree, offset, opcode, opcode_str, data_segment_len, iscsi_session, conversation);\n        if(pduLen > available_bytes)\n            pduLen = available_bytes;\n        offset += pduLen;\n        available_bytes -= pduLen;\n    }\n\n    return offset;\n}",
        "func_after": "static int\ndissect_iscsi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean check_port) {\n    /* Set up structures needed to add the protocol subtree and manage it */\n    guint offset = 0;\n    guint32 available_bytes = tvb_captured_length(tvb);\n    int digestsActive = 1;\n    conversation_t *conversation = NULL;\n    iscsi_session_t *iscsi_session=NULL;\n    guint8 opcode, tmpbyte;\n\n    if (available_bytes < 48) {\n        /* heuristic already rejected the packet if size < 48,\n           assume it's an iscsi packet with a segmented header */\n        pinfo->desegment_offset = offset;\n        pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\n        return -1;\n    }\n\n    opcode = tvb_get_guint8(tvb, offset + 0);\n    opcode &= OPCODE_MASK;\n\n    /* heuristics to verify that the packet looks sane.   the heuristics\n     * are based on the RFC version of iscsi.\n     * (we should retire support for older iscsi versions in wireshark)\n     *      -- ronnie s\n     */\n    /* opcode must be any of the ones from the standard\n     * also check the header that it looks \"sane\"\n     * all reserved or undefined bits in iscsi must be set to zero.\n     */\n    switch(opcode){\n    case ISCSI_OPCODE_NOP_IN:\n        /* top two bits of byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2 and 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_NOP_OUT:\n        /* top bit of byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2 and 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        /* assume ITT and TTT must always be non NULL (ok they can be NULL\n         * from time to time but it usually means we are in the middle\n         * of a zeroed datablock).\n         */\n        if(!tvb_get_letohl(tvb,offset+16) || !tvb_get_letohl(tvb,offset+20)){\n            return 0;\n        }\n        /* all reserved bytes between 32 - 47 must be null */\n        if(tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGIN_COMMAND:\n        /* top two bits in byte 0 must be 0x40 */\n        if((tvb_get_guint8(tvb, offset+0)&0xc0)!=0x40){\n\n            return 0;\n        }\n        /* both the T and C bits can not be set\n         * and the two reserved bits in byte 1 must be 0\n         */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        switch(tmpbyte&0xf0){\n        case 0x80:\n        case 0x40:\n        case 0x00:\n            break;\n        default:\n            return 0;\n        }\n        /* CSG and NSG must not be 2 */\n        if(((tmpbyte & 0x03) == 0x02)\n           || ((tmpbyte & 0x0c) == 0x08)) {\n            return 0;\n        }\n        /* if T bit is set NSG must not be 0 */\n        if(tmpbyte&0x80){\n            if(!(tmpbyte&0x03)){\n                return 0;\n            }\n        }\n        /* should we test that datasegmentlen is non zero? */\n        break;\n    case ISCSI_OPCODE_LOGIN_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n\n            return 0;\n        }\n        /* both the T and C bits can not be set\n         * and the two reserved bits in byte 1 must be 0\n         */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        switch(tmpbyte&0xf0){\n        case 0x80:\n        case 0x40:\n        case 0x00:\n            break;\n        default:\n            return 0;\n        }\n        /* CSG and NSG must not be 2 */\n        if(((tmpbyte & 0x03) == 0x02)\n           || ((tmpbyte & 0x0c) == 0x08)) {\n            return 0;\n        }\n        /* if T bit is set NSG must not be 0 */\n        if(tmpbyte&0x80){\n            if(!(tmpbyte&0x03)){\n                return 0;\n            }\n        }\n        /* the 32bit words at offsets 20, 40, 44 must be zero */\n        if(tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the two bytes at offset 38 must be zero */\n        if(tvb_get_letohs(tvb,offset+38)){\n            return 0;\n        }\n        /* should we test that datasegmentlen is non zero unless we just\n         * entered full featured phase?\n         */\n        break;\n    case ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* top bit in byte 1 must be set */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* Function must be known */\n        if(!try_val_to_str(tmpbyte&0x7f, iscsi_task_management_functions)){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl must be null */\n        if(tvb_get_letohl(tvb,offset+4)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* response must be 0-6 or 255 */\n        tmpbyte=tvb_get_guint8(tvb,offset+2);\n        if(tmpbyte>6 && tmpbyte<255){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb,offset+3)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 20, 36\n         * 40, 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGOUT_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* top bit in byte 1 must be set */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* Reason code must be known */\n        if(!try_val_to_str(tmpbyte&0x7f, iscsi_logout_reasons)){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 32, 36\n         * 40, 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SNACK_REQUEST:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* top 4 bits in byte 1 must be 0x80 */\n        tmpbyte=tvb_get_guint8(tvb, offset+1);\n        if((tmpbyte&0xf0)!=0x80){\n            return 0;\n        }\n        /* type must be known */\n        if(!try_val_to_str(tmpbyte&0x0f, iscsi_snack_types)){\n            return 0;\n        }\n        /* for status/snack and datack itt must be 0xffffffff\n         * for rdata/snack ttt must not be 0 or 0xffffffff\n         */\n        switch(tmpbyte&0x0f){\n        case 1:\n        case 2:\n            if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n                return 0;\n            }\n            break;\n        case 3:\n            if(tvb_get_letohl(tvb,offset+20)==0xffffffff){\n                return 0;\n            }\n            if(tvb_get_letohl(tvb,offset+20)==0){\n                return 0;\n            }\n            break;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 24, 32, 36\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+24)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)){\n            return 0;\n        }\n\n        break;\n    case ISCSI_OPCODE_R2T:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* ahs and dsl must be null */\n        if(tvb_get_letohl(tvb,offset+4)){\n            return 0;\n        }\n        /* desired data transfer length must not be null */\n        if(!tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_REJECT:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* reason must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_reject_reasons)){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb, offset+3)){\n            return 0;\n        }\n        /* the 32bit words at offsets 8, 12, 20, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the 32bit word at 16 must be 0xffffffff */\n        if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TEXT_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* one of the F and C bits must be set but not both\n         * low 6 bits in byte 1 must be 0\n         */\n        switch(tvb_get_guint8(tvb,offset+1)){\n        case 0x80:\n        case 0x40:\n            break;\n        default:\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 32, 36, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_TEXT_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* one of the F and C bits must be set but not both\n         * low 6 bits in byte 1 must be 0\n         */\n        switch(tvb_get_guint8(tvb,offset+1)){\n        case 0x80:\n        case 0x40:\n            break;\n        default:\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 36, 40, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+40)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_COMMAND:\n        /* top bit in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0x80){\n            return 0;\n        }\n        /* reserved bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb, offset+1)&0x18){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* if expected data transfer length is set, W and/or R have to be set */\n        if(tvb_get_ntohl(tvb,offset+20)){\n            if(!(tvb_get_guint8(tvb, offset+1)&0x60)){\n                return 0;\n            }\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* top bit in byte 1 must be 1 */\n        tmpbyte=tvb_get_guint8(tvb,offset+1);\n        if(!(tmpbyte&0x80)){\n            return 0;\n        }\n        /* the reserved bits in byte 1 must be 0 */\n        if(tmpbyte&0x61){\n            return 0;\n        }\n        /* status must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+3), scsi_status_val)){\n            return 0;\n        }\n        /* the 32bit words at offsets 8, 12\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_ASYNC_MESSAGE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 20, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        /* the 32bit word at 16 must be 0xffffffff */\n        if(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_LOGOUT_RESPONSE:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* byte 1 must be 0x80 */\n        if(tvb_get_guint8(tvb, offset+1)!=0x80){\n            return 0;\n        }\n        /* response must be known */\n        if(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_logout_response)){\n            return 0;\n        }\n        /* byte 3 must be 0 */\n        if(tvb_get_guint8(tvb,offset+3)){\n            return 0;\n        }\n        /* ahs and dsl  as well as the 32bit words at offsets 8, 12, 20, 36\n         * 44 must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+4)\n           || tvb_get_letohl(tvb,offset+8)\n           || tvb_get_letohl(tvb,offset+12)\n           || tvb_get_letohl(tvb,offset+20)\n           || tvb_get_letohl(tvb,offset+36)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_DATA_OUT:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* low 7 bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb,offset+1)&0x7f){\n            return 0;\n        }\n        /* bytes 2,3 must be null */\n        if(tvb_get_letohs(tvb,offset+2)){\n            return 0;\n        }\n        /* the 32bit words at offsets 24, 32, 44\n         * must all be 0\n         */\n        if(tvb_get_letohl(tvb,offset+24)\n           || tvb_get_letohl(tvb,offset+32)\n           || tvb_get_letohl(tvb,offset+44)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_SCSI_DATA_IN:\n        /* top two bits in byte 0 must be 0 */\n        if(tvb_get_guint8(tvb, offset+0)&0xc0){\n            return 0;\n        }\n        /* reserved bits in byte 1 must be 0 */\n        if(tvb_get_guint8(tvb,offset+1)&0x38){\n            return 0;\n        }\n        /* byte 2 must be reserved */\n        if(tvb_get_guint8(tvb,offset+2)){\n            return 0;\n        }\n        break;\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I0:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I1:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_I2:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T0:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T1:\n    case ISCSI_OPCODE_VENDOR_SPECIFIC_T2:\n        break;\n    default:\n        return 0;\n    } /* end of heuristics check */\n\n\n    /* process multiple iSCSI PDUs per packet */\n    while(available_bytes >= 48 || (iscsi_desegment && available_bytes >= 8)) {\n        guint32 data_segment_len;\n        guint32 pduLen = 48;\n        guint8 secondPduByte = tvb_get_guint8(tvb, offset + 1);\n        int badPdu = FALSE;\n        guint8 ahsLen=0;\n        guint32 data_segment_offset, data_segment_len_padded;\n\n        /* mask out any extra bits in the opcode byte */\n        opcode = tvb_get_guint8(tvb, offset + 0);\n        opcode &= OPCODE_MASK;\n\n        if(opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION ||\n           opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\n           opcode == ISCSI_OPCODE_R2T ||\n           opcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\n           opcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\n           opcode == ISCSI_OPCODE_SNACK_REQUEST)\n            data_segment_len = 0;\n        else\n            data_segment_len = tvb_get_ntohl(tvb, offset + 4) & 0x00ffffff;\n\n        if (!try_val_to_str(opcode, iscsi_opcodes)) {\n            badPdu = TRUE;\n        }\n\n\n        if(!badPdu && check_port) {\n            badPdu = TRUE;\n            if ((opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->srcport)) {\n                badPdu = FALSE;\n            }\n            if (!(opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->destport)) {\n                badPdu = FALSE;\n            }\n            if ((opcode & TARGET_OPCODE_BIT) && pinfo->srcport == iscsi_system_port) {\n                badPdu = FALSE;\n            }\n            if (!(opcode & TARGET_OPCODE_BIT) && pinfo->destport == iscsi_system_port) {\n                badPdu = FALSE;\n            }\n        }\n\n        if(!badPdu && enable_bogosity_filter) {\n            /* try and distinguish between data and real headers */\n            if(data_segment_len > bogus_pdu_data_length_threshold) {\n                badPdu = TRUE;\n            }\n            else if(demand_good_f_bit &&\n                    !(secondPduByte & 0x80) &&\n                    (opcode == ISCSI_OPCODE_NOP_OUT ||\n                     opcode == ISCSI_OPCODE_NOP_IN ||\n                     opcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\n                     opcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\n                     opcode == ISCSI_OPCODE_SCSI_RESPONSE ||\n                     opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\n                     opcode == ISCSI_OPCODE_R2T ||\n                     opcode == ISCSI_OPCODE_ASYNC_MESSAGE ||\n                     opcode == ISCSI_OPCODE_SNACK_REQUEST ||\n                     opcode == ISCSI_OPCODE_REJECT)) {\n                badPdu = TRUE;\n            } else if(opcode==ISCSI_OPCODE_NOP_OUT) {\n                /* TransferTag for NOP-Out should either be -1 or\n                   the tag value we want for a response.\n                   Assume 0 means we are just inside a big all zero\n                   datablock.\n                */\n                if(tvb_get_ntohl(tvb, offset+20)==0){\n                    badPdu = TRUE;\n                }\n            }\n        }\n\n        if(badPdu) {\n            return offset;\n        }\n\n        if(opcode == ISCSI_OPCODE_LOGIN_COMMAND ||\n           opcode == ISCSI_OPCODE_LOGIN_RESPONSE) {\n            if(iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT08) {\n                if((secondPduByte & CSG_MASK) < ISCSI_CSG_OPERATIONAL_NEGOTIATION) {\n                    /* digests are not yet turned on */\n                    digestsActive = 0;\n                }\n            } else {\n                digestsActive = 0;\n            }\n        }\n\n        if(opcode == ISCSI_OPCODE_SCSI_COMMAND) {\n            /* ahsLen */\n            ahsLen = tvb_get_guint8(tvb, offset + 4);\n            pduLen += ahsLen * 4;\n        }\n\n        data_segment_offset = pduLen;\n        data_segment_len_padded = data_segment_len;\n        if((data_segment_len_padded & 3) != 0)\n            data_segment_len_padded += 4 - (data_segment_len_padded & 3);\n        pduLen += data_segment_len_padded;\n\n\n        /* make sure we have a conversation for this session */\n        conversation = find_or_create_conversation(pinfo);\n\n        iscsi_session=(iscsi_session_t *)conversation_get_proto_data(conversation, proto_iscsi);\n        if(!iscsi_session){\n            iscsi_session = wmem_new(wmem_file_scope(), iscsi_session_t);\n            iscsi_session->header_digest = ISCSI_DIGEST_AUTO;\n            iscsi_session->data_digest = ISCSI_DIGEST_AUTO;\n            iscsi_session->itlq = wmem_tree_new(wmem_file_scope());\n            iscsi_session->itl  = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);\n            conversation_add_proto_data(conversation, proto_iscsi, iscsi_session);\n\n            /* DataOut PDUs are often mistaken by DCERPC heuristics to be\n             * that protocol. Now that we know this is iscsi, set a\n             * dissector for this conversation to block other heuristic\n             * dissectors.\n             */\n            conversation_set_dissector(conversation, iscsi_handle);\n        }\n        /* try to autodetect if header digest is used or not */\n        if (digestsActive && (available_bytes >= (guint32) (48+4+ahsLen*4)) &&\n            (iscsi_session->header_digest == ISCSI_DIGEST_AUTO)) {\n            guint32 crc;\n            /* we have enough data to test if HeaderDigest is enabled */\n            crc= ~crc32c_tvb_offset_calculate(tvb, offset, 48+ahsLen*4, CRC32C_PRELOAD);\n            if(crc==tvb_get_ntohl(tvb,48+ahsLen*4)){\n                iscsi_session->header_digest = ISCSI_DIGEST_CRC32;\n            } else {\n                iscsi_session->header_digest = ISCSI_DIGEST_NONE;\n            }\n        }\n\n\n        /* Add header digest length to pdulen */\n        if(digestsActive){\n            switch(iscsi_session->header_digest){\n            case ISCSI_DIGEST_CRC32:\n                pduLen += 4;\n                data_segment_offset += 4;\n                break;\n            case ISCSI_DIGEST_NONE:\n                break;\n            case ISCSI_DIGEST_AUTO:\n                /* oops we don't yet know what digest is used */\n                /* here we should use some default */\n                break;\n            default:\n                DISSECTOR_ASSERT_NOT_REACHED();\n            }\n        }\n\n        /* try to autodetect whether data digest is used */\n        if (digestsActive &&\n            (available_bytes >= data_segment_offset + data_segment_len_padded + 4) &&\n            (iscsi_session->data_digest == ISCSI_DIGEST_AUTO)) {\n            guint32 crc;\n            /* we have enough data to test if DataDigest is enabled */\n            crc = ~crc32c_tvb_offset_calculate(tvb, data_segment_offset, data_segment_len_padded, CRC32C_PRELOAD);\n            if (crc == tvb_get_ntohl(tvb, data_segment_offset + data_segment_len_padded)) {\n                iscsi_session->data_digest = ISCSI_DIGEST_CRC32;\n            } else {\n                iscsi_session->data_digest = ISCSI_DIGEST_NONE;\n            }\n        }\n\n        /* Add data digest length to pdulen */\n        if (digestsActive && data_segment_len > 0) {\n            switch (iscsi_session->data_digest) {\n            case ISCSI_DIGEST_CRC32:\n                pduLen += 4;\n                break;\n            case ISCSI_DIGEST_NONE:\n                break;\n            case ISCSI_DIGEST_AUTO:\n                /* unknown digest, perhaps a new field was introduced? */\n                break;\n            default:\n                DISSECTOR_ASSERT_NOT_REACHED();\n            }\n        }\n\n        /*\n         * Desegmentation check.\n         */\n        if(iscsi_desegment && pinfo->can_desegment) {\n            if(pduLen > available_bytes) {\n                /*\n                 * This frame doesn't have all of the data for\n                 * this message, but we can do reassembly on it.\n                 *\n                 * Tell the TCP dissector where the data for this\n                 * message starts in the data it handed us, and\n                 * how many more bytes we need, and return.\n                 */\n                pinfo->desegment_offset = offset;\n                pinfo->desegment_len = pduLen - available_bytes;\n                return -1;\n            }\n        }\n\n        /* This is to help TCP keep track of PDU boundaries\n           and allows it to find PDUs that are not aligned to\n           the start of a TCP segments.\n           Since it also allows TCP to know what is in the middle\n           of a large PDU, it reduces the probability of a segment\n           in the middle of a large PDU transfer being misdissected as\n           a PDU.\n        */\n        if(!pinfo->fd->visited){\n            if(pduLen>(guint32)tvb_reported_length_remaining(tvb, offset)){\n                pinfo->want_pdu_tracking=2;\n                pinfo->bytes_until_next_pdu=pduLen-tvb_reported_length_remaining(tvb, offset);\n            }\n        }\n\n        if (offset == 0)\n            col_set_str(pinfo->cinfo, COL_INFO, \"\");\n        else\n            col_append_str(pinfo->cinfo, COL_INFO, \", \");\n\n        dissect_iscsi_pdu(tvb, pinfo, tree, offset, opcode, data_segment_len, iscsi_session, conversation);\n        if(pduLen > available_bytes)\n            pduLen = available_bytes;\n        offset += pduLen;\n        available_bytes -= pduLen;\n    }\n\n    return offset;\n}",
        "description": "A vulnerability in Wireshark versions 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 causes a crash in the iSCSI dissector when processing certain packets or crafted capture files. This issue can be exploited to achieve a denial of service.",
        "commit": "It was discovered that the iSCSI protocol implementation lacked proper handling of invalid opcodes within Reject messages. Specifically, the function responsible for dissecting iSCSI PDUs did not account for such cases, leading to potential crashes when encountering invalid opcodes in Reject messages. This issue has been addressed to ensure robustness against malformed inputs."
    },
    {
        "cwe": "CWE-330",
        "func_name": "torvalds/sfb_enqueue",
        "score": 0.7833160161972046,
        "func_before": "static int sfb_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t       struct sk_buff **to_free)\n{\n\n\tstruct sfb_sched_data *q = qdisc_priv(sch);\n\tstruct Qdisc *child = q->qdisc;\n\tstruct tcf_proto *fl;\n\tint i;\n\tu32 p_min = ~0;\n\tu32 minqlen = ~0;\n\tu32 r, sfbhash;\n\tu32 slot = q->slot;\n\tint ret = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n\n\tif (unlikely(sch->q.qlen >= q->limit)) {\n\t\tqdisc_qstats_overlimit(sch);\n\t\tq->stats.queuedrop++;\n\t\tgoto drop;\n\t}\n\n\tif (q->rehash_interval > 0) {\n\t\tunsigned long limit = q->rehash_time + q->rehash_interval;\n\n\t\tif (unlikely(time_after(jiffies, limit))) {\n\t\t\tsfb_swap_slot(q);\n\t\t\tq->rehash_time = jiffies;\n\t\t} else if (unlikely(!q->double_buffering && q->warmup_time > 0 &&\n\t\t\t\t    time_after(jiffies, limit - q->warmup_time))) {\n\t\t\tq->double_buffering = true;\n\t\t}\n\t}\n\n\tfl = rcu_dereference_bh(q->filter_list);\n\tif (fl) {\n\t\tu32 salt;\n\n\t\t/* If using external classifiers, get result and record it. */\n\t\tif (!sfb_classify(skb, fl, &ret, &salt))\n\t\t\tgoto other_drop;\n\t\tsfbhash = jhash_1word(salt, q->bins[slot].perturbation);\n\t} else {\n\t\tsfbhash = skb_get_hash_perturb(skb, q->bins[slot].perturbation);\n\t}\n\n\n\tif (!sfbhash)\n\t\tsfbhash = 1;\n\tsfb_skb_cb(skb)->hashes[slot] = sfbhash;\n\n\tfor (i = 0; i < SFB_LEVELS; i++) {\n\t\tu32 hash = sfbhash & SFB_BUCKET_MASK;\n\t\tstruct sfb_bucket *b = &q->bins[slot].bins[i][hash];\n\n\t\tsfbhash >>= SFB_BUCKET_SHIFT;\n\t\tif (b->qlen == 0)\n\t\t\tdecrement_prob(b, q);\n\t\telse if (b->qlen >= q->bin_size)\n\t\t\tincrement_prob(b, q);\n\t\tif (minqlen > b->qlen)\n\t\t\tminqlen = b->qlen;\n\t\tif (p_min > b->p_mark)\n\t\t\tp_min = b->p_mark;\n\t}\n\n\tslot ^= 1;\n\tsfb_skb_cb(skb)->hashes[slot] = 0;\n\n\tif (unlikely(minqlen >= q->max)) {\n\t\tqdisc_qstats_overlimit(sch);\n\t\tq->stats.bucketdrop++;\n\t\tgoto drop;\n\t}\n\n\tif (unlikely(p_min >= SFB_MAX_PROB)) {\n\t\t/* Inelastic flow */\n\t\tif (q->double_buffering) {\n\t\t\tsfbhash = skb_get_hash_perturb(skb,\n\t\t\t    q->bins[slot].perturbation);\n\t\t\tif (!sfbhash)\n\t\t\t\tsfbhash = 1;\n\t\t\tsfb_skb_cb(skb)->hashes[slot] = sfbhash;\n\n\t\t\tfor (i = 0; i < SFB_LEVELS; i++) {\n\t\t\t\tu32 hash = sfbhash & SFB_BUCKET_MASK;\n\t\t\t\tstruct sfb_bucket *b = &q->bins[slot].bins[i][hash];\n\n\t\t\t\tsfbhash >>= SFB_BUCKET_SHIFT;\n\t\t\t\tif (b->qlen == 0)\n\t\t\t\t\tdecrement_prob(b, q);\n\t\t\t\telse if (b->qlen >= q->bin_size)\n\t\t\t\t\tincrement_prob(b, q);\n\t\t\t}\n\t\t}\n\t\tif (sfb_rate_limit(skb, q)) {\n\t\t\tqdisc_qstats_overlimit(sch);\n\t\t\tq->stats.penaltydrop++;\n\t\t\tgoto drop;\n\t\t}\n\t\tgoto enqueue;\n\t}\n\n\tr = prandom_u32() & SFB_MAX_PROB;\n\n\tif (unlikely(r < p_min)) {\n\t\tif (unlikely(p_min > SFB_MAX_PROB / 2)) {\n\t\t\t/* If we're marking that many packets, then either\n\t\t\t * this flow is unresponsive, or we're badly congested.\n\t\t\t * In either case, we want to start dropping packets.\n\t\t\t */\n\t\t\tif (r < (p_min - SFB_MAX_PROB / 2) * 2) {\n\t\t\t\tq->stats.earlydrop++;\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\t\tif (INET_ECN_set_ce(skb)) {\n\t\t\tq->stats.marked++;\n\t\t} else {\n\t\t\tq->stats.earlydrop++;\n\t\t\tgoto drop;\n\t\t}\n\t}\n\nenqueue:\n\tret = qdisc_enqueue(skb, child, to_free);\n\tif (likely(ret == NET_XMIT_SUCCESS)) {\n\t\tqdisc_qstats_backlog_inc(sch, skb);\n\t\tsch->q.qlen++;\n\t\tincrement_qlen(skb, q);\n\t} else if (net_xmit_drop_count(ret)) {\n\t\tq->stats.childdrop++;\n\t\tqdisc_qstats_drop(sch);\n\t}\n\treturn ret;\n\ndrop:\n\tqdisc_drop(skb, sch, to_free);\n\treturn NET_XMIT_CN;\nother_drop:\n\tif (ret & __NET_XMIT_BYPASS)\n\t\tqdisc_qstats_drop(sch);\n\tkfree_skb(skb);\n\treturn ret;\n}",
        "func_after": "static int sfb_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t       struct sk_buff **to_free)\n{\n\n\tstruct sfb_sched_data *q = qdisc_priv(sch);\n\tstruct Qdisc *child = q->qdisc;\n\tstruct tcf_proto *fl;\n\tint i;\n\tu32 p_min = ~0;\n\tu32 minqlen = ~0;\n\tu32 r, sfbhash;\n\tu32 slot = q->slot;\n\tint ret = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n\n\tif (unlikely(sch->q.qlen >= q->limit)) {\n\t\tqdisc_qstats_overlimit(sch);\n\t\tq->stats.queuedrop++;\n\t\tgoto drop;\n\t}\n\n\tif (q->rehash_interval > 0) {\n\t\tunsigned long limit = q->rehash_time + q->rehash_interval;\n\n\t\tif (unlikely(time_after(jiffies, limit))) {\n\t\t\tsfb_swap_slot(q);\n\t\t\tq->rehash_time = jiffies;\n\t\t} else if (unlikely(!q->double_buffering && q->warmup_time > 0 &&\n\t\t\t\t    time_after(jiffies, limit - q->warmup_time))) {\n\t\t\tq->double_buffering = true;\n\t\t}\n\t}\n\n\tfl = rcu_dereference_bh(q->filter_list);\n\tif (fl) {\n\t\tu32 salt;\n\n\t\t/* If using external classifiers, get result and record it. */\n\t\tif (!sfb_classify(skb, fl, &ret, &salt))\n\t\t\tgoto other_drop;\n\t\tsfbhash = siphash_1u32(salt, &q->bins[slot].perturbation);\n\t} else {\n\t\tsfbhash = skb_get_hash_perturb(skb, &q->bins[slot].perturbation);\n\t}\n\n\n\tif (!sfbhash)\n\t\tsfbhash = 1;\n\tsfb_skb_cb(skb)->hashes[slot] = sfbhash;\n\n\tfor (i = 0; i < SFB_LEVELS; i++) {\n\t\tu32 hash = sfbhash & SFB_BUCKET_MASK;\n\t\tstruct sfb_bucket *b = &q->bins[slot].bins[i][hash];\n\n\t\tsfbhash >>= SFB_BUCKET_SHIFT;\n\t\tif (b->qlen == 0)\n\t\t\tdecrement_prob(b, q);\n\t\telse if (b->qlen >= q->bin_size)\n\t\t\tincrement_prob(b, q);\n\t\tif (minqlen > b->qlen)\n\t\t\tminqlen = b->qlen;\n\t\tif (p_min > b->p_mark)\n\t\t\tp_min = b->p_mark;\n\t}\n\n\tslot ^= 1;\n\tsfb_skb_cb(skb)->hashes[slot] = 0;\n\n\tif (unlikely(minqlen >= q->max)) {\n\t\tqdisc_qstats_overlimit(sch);\n\t\tq->stats.bucketdrop++;\n\t\tgoto drop;\n\t}\n\n\tif (unlikely(p_min >= SFB_MAX_PROB)) {\n\t\t/* Inelastic flow */\n\t\tif (q->double_buffering) {\n\t\t\tsfbhash = skb_get_hash_perturb(skb,\n\t\t\t    &q->bins[slot].perturbation);\n\t\t\tif (!sfbhash)\n\t\t\t\tsfbhash = 1;\n\t\t\tsfb_skb_cb(skb)->hashes[slot] = sfbhash;\n\n\t\t\tfor (i = 0; i < SFB_LEVELS; i++) {\n\t\t\t\tu32 hash = sfbhash & SFB_BUCKET_MASK;\n\t\t\t\tstruct sfb_bucket *b = &q->bins[slot].bins[i][hash];\n\n\t\t\t\tsfbhash >>= SFB_BUCKET_SHIFT;\n\t\t\t\tif (b->qlen == 0)\n\t\t\t\t\tdecrement_prob(b, q);\n\t\t\t\telse if (b->qlen >= q->bin_size)\n\t\t\t\t\tincrement_prob(b, q);\n\t\t\t}\n\t\t}\n\t\tif (sfb_rate_limit(skb, q)) {\n\t\t\tqdisc_qstats_overlimit(sch);\n\t\t\tq->stats.penaltydrop++;\n\t\t\tgoto drop;\n\t\t}\n\t\tgoto enqueue;\n\t}\n\n\tr = prandom_u32() & SFB_MAX_PROB;\n\n\tif (unlikely(r < p_min)) {\n\t\tif (unlikely(p_min > SFB_MAX_PROB / 2)) {\n\t\t\t/* If we're marking that many packets, then either\n\t\t\t * this flow is unresponsive, or we're badly congested.\n\t\t\t * In either case, we want to start dropping packets.\n\t\t\t */\n\t\t\tif (r < (p_min - SFB_MAX_PROB / 2) * 2) {\n\t\t\t\tq->stats.earlydrop++;\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\t\tif (INET_ECN_set_ce(skb)) {\n\t\t\tq->stats.marked++;\n\t\t} else {\n\t\t\tq->stats.earlydrop++;\n\t\t\tgoto drop;\n\t\t}\n\t}\n\nenqueue:\n\tret = qdisc_enqueue(skb, child, to_free);\n\tif (likely(ret == NET_XMIT_SUCCESS)) {\n\t\tqdisc_qstats_backlog_inc(sch, skb);\n\t\tsch->q.qlen++;\n\t\tincrement_qlen(skb, q);\n\t} else if (net_xmit_drop_count(ret)) {\n\t\tq->stats.childdrop++;\n\t\tqdisc_qstats_drop(sch);\n\t}\n\treturn ret;\n\ndrop:\n\tqdisc_drop(skb, sch, to_free);\n\treturn NET_XMIT_CN;\nother_drop:\n\tif (ret & __NET_XMIT_BYPASS)\n\t\tqdisc_qstats_drop(sch);\n\tkfree_skb(skb);\n\treturn ret;\n}",
        "description": "The flow_dissector feature in the Linux kernel from version 4.3 up to but not including 5.3.10 suffers from a device tracking vulnerability, identified as CID-55667441c84f. This vulnerability arises due to the reliance on a 32-bit hashrnd value as a secret for the auto flowlabel of a UDP IPv6 packet. Additionally, the use of jhash instead of siphash exacerbates the issue. Since the hashrnd value remains constant from the time of system boot, it can be deduced by an attacker, thereby compromising the intended security measures. This problem is present in the net/core/flow_dissector.c file and related components.",
        "commit": "The vulnerability involves the use of a 32-bit secret in generating auto flowlabels for UDP IPv6 packets, which can be inferred by attackers to identify devices or users. The secret is initialized only at boot time and is used in conjunction with the jhash function to create flow labels that are predictable. This predictability poses a significant privacy risk. The proposed solution is to switch from using jhash to a cryptographically strong pseudo-random function like siphash, similar to changes made in the IP ID generator. This switch aims to enhance security by making the flow label generation process less predictable and thereby reducing the risk of device/user identification."
    }
]