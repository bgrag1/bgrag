[
    {
        "cwe": "CWE-911",
        "func_name": "torvalds/u32_destroy_key",
        "score": 0.7441087365150452,
        "func_before": "static int u32_destroy_key(struct tc_u_knode *n, bool free_pf)\n{\n\tstruct tc_u_hnode *ht = rtnl_dereference(n->ht_down);\n\n\ttcf_exts_destroy(&n->exts);\n\ttcf_exts_put_net(&n->exts);\n\tif (ht && --ht->refcnt == 0)\n\t\tkfree(ht);\n#ifdef CONFIG_CLS_U32_PERF\n\tif (free_pf)\n\t\tfree_percpu(n->pf);\n#endif\n#ifdef CONFIG_CLS_U32_MARK\n\tif (free_pf)\n\t\tfree_percpu(n->pcpu_success);\n#endif\n\tkfree(n);\n\treturn 0;\n}",
        "func_after": "static void u32_destroy_key(struct tc_u_knode *n, bool free_pf)\n{\n\ttcf_exts_put_net(&n->exts);\n#ifdef CONFIG_CLS_U32_PERF\n\tif (free_pf)\n\t\tfree_percpu(n->pf);\n#endif\n#ifdef CONFIG_CLS_U32_MARK\n\tif (free_pf)\n\t\tfree_percpu(n->pcpu_success);\n#endif\n\t__u32_destroy_key(n);\n}",
        "description": "An Improper Update of Reference Count vulnerability in the networking scheduler component of the Linux Kernel enables a local attacker to achieve privilege escalation to root. This issue impacts Linux Kernel versions prior to 5.18 and versions 4.14 and later.",
        "commit": "A vulnerability was identified in the Linux kernel where an extra `put_net()` operation is detected prematurely. Specifically, functions such as `u32_init_knode()` and `tcf_exts_init()` populate the `->exts.net` pointer without elevating the reference count on the network namespace (`netns`). The reference count is incremented only when `tcf_exts_get_net()` is called. Consequently, two calls to `u32_destroy_key()` from `u32_change()` attempt to release an invalid reference on the `netns`, leading to a refcount decrement hitting zero and potential memory leaks. This issue occurs in the Linux kernel prior to a specific version, affecting the handling of network traffic classification and filtering mechanisms."
    },
    {
        "cwe": "CWE-681",
        "func_name": "FreeRDP/update_recv_secondary_order",
        "score": 0.7915294170379639,
        "func_before": "static BOOL update_recv_secondary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBOOL rc = FALSE;\n\tsize_t start, end, diff;\n\tBYTE orderType;\n\tUINT16 extraFlags;\n\tUINT16 orderLength;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpSecondaryUpdate* secondary = update->secondary;\n\tconst char* name;\n\n\tif (Stream_GetRemainingLength(s) < 5)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 5\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Read_UINT16(s, extraFlags);  /* extraFlags (2 bytes) */\n\tStream_Read_UINT8(s, orderType);    /* orderType (1 byte) */\n\tif (Stream_GetRemainingLength(s) < orderLength + 7U)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) %\" PRIuz \" < %\" PRIu16,\n\t\t           Stream_GetRemainingLength(s), orderLength + 7);\n\t\treturn FALSE;\n\t}\n\n\tstart = Stream_GetPosition(s);\n\tname = secondary_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Secondary Drawing Order %s\", name);\n\n\tif (!check_secondary_order_supported(update->log, settings, orderType, name))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_CACHE_BITMAP_COMPRESSED);\n\t\t\tCACHE_BITMAP_ORDER* order =\n\t\t\t    update_read_cache_bitmap_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmap, context, order);\n\t\t\t\tfree_cache_bitmap_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_BITMAP_COMPRESSED_V2);\n\t\t\tCACHE_BITMAP_V2_ORDER* order =\n\t\t\t    update_read_cache_bitmap_v2_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV2, context, order);\n\t\t\t\tfree_cache_bitmap_v2_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t{\n\t\t\tCACHE_BITMAP_V3_ORDER* order = update_read_cache_bitmap_v3_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV3, context, order);\n\t\t\t\tfree_cache_bitmap_v3_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t{\n\t\t\tCACHE_COLOR_TABLE_ORDER* order =\n\t\t\t    update_read_cache_color_table_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheColorTable, context, order);\n\t\t\t\tfree_cache_color_table_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_ORDER* order = update_read_cache_glyph_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyph, context, order);\n\t\t\t\t\t\tfree_cache_glyph_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_V2_ORDER* order =\n\t\t\t\t\t    update_read_cache_glyph_v2_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyphV2, context, order);\n\t\t\t\t\t\tfree_cache_glyph_v2_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\t/* [MS-RDPEGDI] 2.2.2.2.1.2.7 Cache Brush (CACHE_BRUSH_ORDER) */\n\t\t\t{\n\t\t\t\tCACHE_BRUSH_ORDER* order = update_read_cache_brush_order(update, s, extraFlags);\n\n\t\t\t\tif (order)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBrush, context, order);\n\t\t\t\t\tfree_cache_brush_order(context, order);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", name);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"SECONDARY ORDER %s failed\", name);\n\t}\n\n\tstart += orderLength + 7;\n\tend = Stream_GetPosition(s);\n\tif (start > end)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes too much\",\n\t\t           name, end - start);\n\t\treturn FALSE;\n\t}\n\tdiff = start - end;\n\tif (diff > 0)\n\t{\n\t\tWLog_Print(update->log, WLOG_DEBUG,\n\t\t           \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes short, skipping\", name, diff);\n\t\tStream_Seek(s, diff);\n\t}\n\treturn rc;\n}",
        "func_after": "static BOOL update_recv_secondary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBOOL rc = FALSE;\n\tsize_t start, end, diff;\n\tBYTE orderType;\n\tUINT16 extraFlags;\n\tUINT16 orderLength;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpSecondaryUpdate* secondary = update->secondary;\n\tconst char* name;\n\n\tif (Stream_GetRemainingLength(s) < 5)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 5\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Read_UINT16(s, extraFlags);  /* extraFlags (2 bytes) */\n\tStream_Read_UINT8(s, orderType);    /* orderType (1 byte) */\n\tif (Stream_GetRemainingLength(s) < orderLength + 7U)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) %\" PRIuz \" < %\" PRIu16,\n\t\t           Stream_GetRemainingLength(s), orderLength + 7);\n\t\treturn FALSE;\n\t}\n\n\tstart = Stream_GetPosition(s);\n\tname = secondary_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Secondary Drawing Order %s\", name);\n\n\tif (!check_secondary_order_supported(update->log, settings, orderType, name))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_CACHE_BITMAP_COMPRESSED);\n\t\t\tCACHE_BITMAP_ORDER* order =\n\t\t\t    update_read_cache_bitmap_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmap, context, order);\n\t\t\t\tfree_cache_bitmap_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_BITMAP_COMPRESSED_V2);\n\t\t\tCACHE_BITMAP_V2_ORDER* order =\n\t\t\t    update_read_cache_bitmap_v2_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV2, context, order);\n\t\t\t\tfree_cache_bitmap_v2_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t{\n\t\t\tCACHE_BITMAP_V3_ORDER* order = update_read_cache_bitmap_v3_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV3, context, order);\n\t\t\t\tfree_cache_bitmap_v3_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t{\n\t\t\tCACHE_COLOR_TABLE_ORDER* order =\n\t\t\t    update_read_cache_color_table_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheColorTable, context, order);\n\t\t\t\tfree_cache_color_table_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_ORDER* order = update_read_cache_glyph_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyph, context, order);\n\t\t\t\t\t\tfree_cache_glyph_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_V2_ORDER* order =\n\t\t\t\t\t    update_read_cache_glyph_v2_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyphV2, context, order);\n\t\t\t\t\t\tfree_cache_glyph_v2_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\t/* [MS-RDPEGDI] 2.2.2.2.1.2.7 Cache Brush (CACHE_BRUSH_ORDER) */\n\t\t\t{\n\t\t\t\tCACHE_BRUSH_ORDER* order = update_read_cache_brush_order(update, s, extraFlags);\n\n\t\t\t\tif (order)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBrush, context, order);\n\t\t\t\t\tfree_cache_brush_order(context, order);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", name);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"SECONDARY ORDER %s failed\", name);\n\t}\n\n\tstart += orderLength + 7;\n\tend = Stream_GetPosition(s);\n\tif (start > end)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes too much\",\n\t\t           name, end - start);\n\t\treturn FALSE;\n\t}\n\tdiff = end - start;\n\tif (diff > 0)\n\t{\n\t\tWLog_Print(update->log, WLOG_DEBUG,\n\t\t           \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes short, skipping\", name, diff);\n\t\tif (!Stream_SafeSeek(s, diff))\n\t\t\treturn FALSE;\n\t}\n\treturn rc;\n}",
        "description": "In FreeRDP versions prior to 2.1.2, there exists an integer casting vulnerability within the `update_recv_secondary_order` function. This vulnerability affects all clients configured with both `+glyph-cache` and `relax-order-checks` options. This issue has been addressed in version 2.1.2.",
        "commit": "An out-of-bounds (OOB) read vulnerability was addressed in the `update_recv_secondary_order` function. This issue was identified and reported by @antonio-morales."
    },
    {
        "cwe": "CWE-682",
        "func_name": "torvalds/sctp_make_init",
        "score": 0.7963236570358276,
        "func_before": "struct sctp_chunk *sctp_make_init(const struct sctp_association *asoc,\n\t\t\t     const struct sctp_bind_addr *bp,\n\t\t\t     gfp_t gfp, int vparam_len)\n{\n\tsctp_inithdr_t init;\n\tunion sctp_params addrs;\n\tsize_t chunksize;\n\tstruct sctp_chunk *retval = NULL;\n\tint num_types, addrs_len = 0;\n\tstruct sctp_sock *sp;\n\tsctp_supported_addrs_param_t sat;\n\t__be16 types[2];\n\tsctp_adaptation_ind_param_t aiparam;\n\tsctp_supported_ext_param_t ext_param;\n\tint num_ext = 0;\n\t__u8 extensions[3];\n\tsctp_paramhdr_t *auth_chunks = NULL,\n\t\t\t*auth_hmacs = NULL;\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 1: The INIT chunks can contain multiple addresses that\n\t * can be IPv4 and/or IPv6 in any combination.\n\t */\n\tretval = NULL;\n\n\t/* Convert the provided bind address list to raw format. */\n\taddrs = sctp_bind_addrs_to_raw(bp, &addrs_len, gfp);\n\n\tinit.init_tag\t\t   = htonl(asoc->c.my_vtag);\n\tinit.a_rwnd\t\t   = htonl(asoc->rwnd);\n\tinit.num_outbound_streams  = htons(asoc->c.sinit_num_ostreams);\n\tinit.num_inbound_streams   = htons(asoc->c.sinit_max_instreams);\n\tinit.initial_tsn\t   = htonl(asoc->c.initial_tsn);\n\n\t/* How many address types are needed? */\n\tsp = sctp_sk(asoc->base.sk);\n\tnum_types = sp->pf->supported_addrs(sp, types);\n\n\tchunksize = sizeof(init) + addrs_len + SCTP_SAT_LEN(num_types);\n\tchunksize += sizeof(ecap_param);\n\n\tif (sctp_prsctp_enable)\n\t\tchunksize += sizeof(prsctp_param);\n\n\t/* ADDIP: Section 4.2.7:\n\t *  An implementation supporting this extension [ADDIP] MUST list\n\t *  the ASCONF,the ASCONF-ACK, and the AUTH  chunks in its INIT and\n\t *  INIT-ACK parameters.\n\t */\n\tif (sctp_addip_enable) {\n\t\textensions[num_ext] = SCTP_CID_ASCONF;\n\t\textensions[num_ext+1] = SCTP_CID_ASCONF_ACK;\n\t\tnum_ext += 2;\n\t}\n\n\tif (sp->adaptation_ind)\n\t\tchunksize += sizeof(aiparam);\n\n\tchunksize += vparam_len;\n\n\t/* Account for AUTH related parameters */\n\tif (sctp_auth_enable) {\n\t\t/* Add random parameter length*/\n\t\tchunksize += sizeof(asoc->c.auth_random);\n\n\t\t/* Add HMACS parameter length if any were defined */\n\t\tauth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;\n\t\tif (auth_hmacs->length)\n\t\t\tchunksize += ntohs(auth_hmacs->length);\n\t\telse\n\t\t\tauth_hmacs = NULL;\n\n\t\t/* Add CHUNKS parameter length */\n\t\tauth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;\n\t\tif (auth_chunks->length)\n\t\t\tchunksize += ntohs(auth_chunks->length);\n\t\telse\n\t\t\tauth_chunks = NULL;\n\n\t\textensions[num_ext] = SCTP_CID_AUTH;\n\t\tnum_ext += 1;\n\t}\n\n\t/* If we have any extensions to report, account for that */\n\tif (num_ext)\n\t\tchunksize += sizeof(sctp_supported_ext_param_t) + num_ext;\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 3: An INIT chunk MUST NOT contain more than one Host\n\t * Name address parameter. Moreover, the sender of the INIT\n\t * MUST NOT combine any other address types with the Host Name\n\t * address in the INIT. The receiver of INIT MUST ignore any\n\t * other address types if the Host Name address parameter is\n\t * present in the received INIT chunk.\n\t *\n\t * PLEASE DO NOT FIXME [This version does not support Host Name.]\n\t */\n\n\tretval = sctp_make_chunk(asoc, SCTP_CID_INIT, 0, chunksize);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.init_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(init), &init);\n\tretval->param_hdr.v =\n\t\tsctp_addto_chunk(retval, addrs_len, addrs.v);\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 4: This parameter, when present, specifies all the\n\t * address types the sending endpoint can support. The absence\n\t * of this parameter indicates that the sending endpoint can\n\t * support any address type.\n\t */\n\tsat.param_hdr.type = SCTP_PARAM_SUPPORTED_ADDRESS_TYPES;\n\tsat.param_hdr.length = htons(SCTP_SAT_LEN(num_types));\n\tsctp_addto_chunk(retval, sizeof(sat), &sat);\n\tsctp_addto_chunk(retval, num_types * sizeof(__u16), &types);\n\n\tsctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);\n\n\t/* Add the supported extensions parameter.  Be nice and add this\n\t * fist before addiding the parameters for the extensions themselves\n\t */\n\tif (num_ext) {\n\t\text_param.param_hdr.type = SCTP_PARAM_SUPPORTED_EXT;\n\t\text_param.param_hdr.length =\n\t\t\t    htons(sizeof(sctp_supported_ext_param_t) + num_ext);\n\t\tsctp_addto_chunk(retval, sizeof(sctp_supported_ext_param_t),\n\t\t\t\t&ext_param);\n\t\tsctp_addto_param(retval, num_ext, extensions);\n\t}\n\n\tif (sctp_prsctp_enable)\n\t\tsctp_addto_chunk(retval, sizeof(prsctp_param), &prsctp_param);\n\n\tif (sp->adaptation_ind) {\n\t\taiparam.param_hdr.type = SCTP_PARAM_ADAPTATION_LAYER_IND;\n\t\taiparam.param_hdr.length = htons(sizeof(aiparam));\n\t\taiparam.adaptation_ind = htonl(sp->adaptation_ind);\n\t\tsctp_addto_chunk(retval, sizeof(aiparam), &aiparam);\n\t}\n\n\t/* Add SCTP-AUTH chunks to the parameter list */\n\tif (sctp_auth_enable) {\n\t\tsctp_addto_chunk(retval, sizeof(asoc->c.auth_random),\n\t\t\t\t asoc->c.auth_random);\n\t\tif (auth_hmacs)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_hmacs->length),\n\t\t\t\t\tauth_hmacs);\n\t\tif (auth_chunks)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_chunks->length),\n\t\t\t\t\tauth_chunks);\n\t}\nnodata:\n\tkfree(addrs.v);\n\treturn retval;\n}",
        "func_after": "struct sctp_chunk *sctp_make_init(const struct sctp_association *asoc,\n\t\t\t     const struct sctp_bind_addr *bp,\n\t\t\t     gfp_t gfp, int vparam_len)\n{\n\tsctp_inithdr_t init;\n\tunion sctp_params addrs;\n\tsize_t chunksize;\n\tstruct sctp_chunk *retval = NULL;\n\tint num_types, addrs_len = 0;\n\tstruct sctp_sock *sp;\n\tsctp_supported_addrs_param_t sat;\n\t__be16 types[2];\n\tsctp_adaptation_ind_param_t aiparam;\n\tsctp_supported_ext_param_t ext_param;\n\tint num_ext = 0;\n\t__u8 extensions[3];\n\tsctp_paramhdr_t *auth_chunks = NULL,\n\t\t\t*auth_hmacs = NULL;\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 1: The INIT chunks can contain multiple addresses that\n\t * can be IPv4 and/or IPv6 in any combination.\n\t */\n\tretval = NULL;\n\n\t/* Convert the provided bind address list to raw format. */\n\taddrs = sctp_bind_addrs_to_raw(bp, &addrs_len, gfp);\n\n\tinit.init_tag\t\t   = htonl(asoc->c.my_vtag);\n\tinit.a_rwnd\t\t   = htonl(asoc->rwnd);\n\tinit.num_outbound_streams  = htons(asoc->c.sinit_num_ostreams);\n\tinit.num_inbound_streams   = htons(asoc->c.sinit_max_instreams);\n\tinit.initial_tsn\t   = htonl(asoc->c.initial_tsn);\n\n\t/* How many address types are needed? */\n\tsp = sctp_sk(asoc->base.sk);\n\tnum_types = sp->pf->supported_addrs(sp, types);\n\n\tchunksize = sizeof(init) + addrs_len;\n\tchunksize += WORD_ROUND(SCTP_SAT_LEN(num_types));\n\tchunksize += sizeof(ecap_param);\n\n\tif (sctp_prsctp_enable)\n\t\tchunksize += sizeof(prsctp_param);\n\n\t/* ADDIP: Section 4.2.7:\n\t *  An implementation supporting this extension [ADDIP] MUST list\n\t *  the ASCONF,the ASCONF-ACK, and the AUTH  chunks in its INIT and\n\t *  INIT-ACK parameters.\n\t */\n\tif (sctp_addip_enable) {\n\t\textensions[num_ext] = SCTP_CID_ASCONF;\n\t\textensions[num_ext+1] = SCTP_CID_ASCONF_ACK;\n\t\tnum_ext += 2;\n\t}\n\n\tif (sp->adaptation_ind)\n\t\tchunksize += sizeof(aiparam);\n\n\tchunksize += vparam_len;\n\n\t/* Account for AUTH related parameters */\n\tif (sctp_auth_enable) {\n\t\t/* Add random parameter length*/\n\t\tchunksize += sizeof(asoc->c.auth_random);\n\n\t\t/* Add HMACS parameter length if any were defined */\n\t\tauth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;\n\t\tif (auth_hmacs->length)\n\t\t\tchunksize += WORD_ROUND(ntohs(auth_hmacs->length));\n\t\telse\n\t\t\tauth_hmacs = NULL;\n\n\t\t/* Add CHUNKS parameter length */\n\t\tauth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;\n\t\tif (auth_chunks->length)\n\t\t\tchunksize += WORD_ROUND(ntohs(auth_chunks->length));\n\t\telse\n\t\t\tauth_chunks = NULL;\n\n\t\textensions[num_ext] = SCTP_CID_AUTH;\n\t\tnum_ext += 1;\n\t}\n\n\t/* If we have any extensions to report, account for that */\n\tif (num_ext)\n\t\tchunksize += WORD_ROUND(sizeof(sctp_supported_ext_param_t) +\n\t\t\t\t\tnum_ext);\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 3: An INIT chunk MUST NOT contain more than one Host\n\t * Name address parameter. Moreover, the sender of the INIT\n\t * MUST NOT combine any other address types with the Host Name\n\t * address in the INIT. The receiver of INIT MUST ignore any\n\t * other address types if the Host Name address parameter is\n\t * present in the received INIT chunk.\n\t *\n\t * PLEASE DO NOT FIXME [This version does not support Host Name.]\n\t */\n\n\tretval = sctp_make_chunk(asoc, SCTP_CID_INIT, 0, chunksize);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.init_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(init), &init);\n\tretval->param_hdr.v =\n\t\tsctp_addto_chunk(retval, addrs_len, addrs.v);\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 4: This parameter, when present, specifies all the\n\t * address types the sending endpoint can support. The absence\n\t * of this parameter indicates that the sending endpoint can\n\t * support any address type.\n\t */\n\tsat.param_hdr.type = SCTP_PARAM_SUPPORTED_ADDRESS_TYPES;\n\tsat.param_hdr.length = htons(SCTP_SAT_LEN(num_types));\n\tsctp_addto_chunk(retval, sizeof(sat), &sat);\n\tsctp_addto_chunk(retval, num_types * sizeof(__u16), &types);\n\n\tsctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);\n\n\t/* Add the supported extensions parameter.  Be nice and add this\n\t * fist before addiding the parameters for the extensions themselves\n\t */\n\tif (num_ext) {\n\t\text_param.param_hdr.type = SCTP_PARAM_SUPPORTED_EXT;\n\t\text_param.param_hdr.length =\n\t\t\t    htons(sizeof(sctp_supported_ext_param_t) + num_ext);\n\t\tsctp_addto_chunk(retval, sizeof(sctp_supported_ext_param_t),\n\t\t\t\t&ext_param);\n\t\tsctp_addto_param(retval, num_ext, extensions);\n\t}\n\n\tif (sctp_prsctp_enable)\n\t\tsctp_addto_chunk(retval, sizeof(prsctp_param), &prsctp_param);\n\n\tif (sp->adaptation_ind) {\n\t\taiparam.param_hdr.type = SCTP_PARAM_ADAPTATION_LAYER_IND;\n\t\taiparam.param_hdr.length = htons(sizeof(aiparam));\n\t\taiparam.adaptation_ind = htonl(sp->adaptation_ind);\n\t\tsctp_addto_chunk(retval, sizeof(aiparam), &aiparam);\n\t}\n\n\t/* Add SCTP-AUTH chunks to the parameter list */\n\tif (sctp_auth_enable) {\n\t\tsctp_addto_chunk(retval, sizeof(asoc->c.auth_random),\n\t\t\t\t asoc->c.auth_random);\n\t\tif (auth_hmacs)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_hmacs->length),\n\t\t\t\t\tauth_hmacs);\n\t\tif (auth_chunks)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_chunks->length),\n\t\t\t\t\tauth_chunks);\n\t}\nnodata:\n\tkfree(addrs.v);\n\treturn retval;\n}",
        "description": "In the Linux kernel prior to version 2.6.34, when both addip_enable and auth_enable are enabled, the function responsible for creating SCTP chunks does not account for the amount of zero padding during the calculation of chunk lengths for INIT and INIT ACK chunks. This oversight allows remote attackers to exploit this vulnerability by sending specially crafted packets, resulting in a denial of service (OOPS).",
        "commit": "When calculating the INIT/INIT-ACK chunk length, it is essential to consider not only the length of the parameters but also the zero padding length of these parameters, such as the AUTH HMACS parameter and CHUNKS parameter. Failing to account for the zero padding length can lead to a kernel panic, specifically an `skb_over_panic` error, which occurs when attempting to write beyond the buffer's allocated space. This issue arises within the SCTP protocol implementation in the Linux kernel, potentially affecting network communication stability and security."
    },
    {
        "cwe": "CWE-668",
        "func_name": "xen-project/sh_guess_wrmap",
        "score": 0.7613227367401123,
        "func_before": "static int sh_guess_wrmap(struct vcpu *v, unsigned long vaddr, mfn_t gmfn)\n/* Look up this vaddr in the current shadow and see if it's a writeable\n * mapping of this gmfn.  If so, remove it.  Returns 1 if it worked. */\n{\n    struct domain *d = v->domain;\n    shadow_l1e_t sl1e, *sl1p;\n    shadow_l2e_t *sl2p;\n    shadow_l3e_t *sl3p;\n#if SHADOW_PAGING_LEVELS >= 4\n    shadow_l4e_t *sl4p;\n#endif\n    mfn_t sl1mfn;\n    int r;\n\n    /* Carefully look in the shadow linear map for the l1e we expect */\n#if SHADOW_PAGING_LEVELS >= 4\n    sl4p = sh_linear_l4_table(v) + shadow_l4_linear_offset(vaddr);\n    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )\n        return 0;\n    sl3p = sh_linear_l3_table(v) + shadow_l3_linear_offset(vaddr);\n    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )\n        return 0;\n#else /* SHADOW_PAGING_LEVELS == 3 */\n    sl3p = ((shadow_l3e_t *) v->arch.paging.shadow.l3table)\n        + shadow_l3_linear_offset(vaddr);\n    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )\n        return 0;\n#endif\n    sl2p = sh_linear_l2_table(v) + shadow_l2_linear_offset(vaddr);\n    if ( !(shadow_l2e_get_flags(*sl2p) & _PAGE_PRESENT) )\n        return 0;\n    sl1p = sh_linear_l1_table(v) + shadow_l1_linear_offset(vaddr);\n    sl1e = *sl1p;\n    if ( ((shadow_l1e_get_flags(sl1e) & (_PAGE_PRESENT|_PAGE_RW))\n          != (_PAGE_PRESENT|_PAGE_RW))\n         || (mfn_x(shadow_l1e_get_mfn(sl1e)) != mfn_x(gmfn)) )\n        return 0;\n\n    /* Found it!  Need to remove its write permissions. */\n    sl1mfn = shadow_l2e_get_mfn(*sl2p);\n    sl1e = shadow_l1e_remove_flags(sl1e, _PAGE_RW);\n    r = shadow_set_l1e(d, sl1p, sl1e, p2m_ram_rw, sl1mfn);\n    if ( r & SHADOW_SET_ERROR ) {\n        /* Can only currently happen if we found a grant-mapped\n         * page.  Just make the guess fail. */\n        return 0;\n    }\n    TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_WRMAP_GUESS_FOUND);\n    return 1;\n}",
        "func_after": "static int sh_guess_wrmap(struct vcpu *v, unsigned long vaddr, mfn_t gmfn)\n/* Look up this vaddr in the current shadow and see if it's a writeable\n * mapping of this gmfn.  If so, remove it.  Returns 1 if it worked. */\n{\n    struct domain *d = v->domain;\n    shadow_l1e_t sl1e, *sl1p;\n    shadow_l2e_t *sl2p;\n    shadow_l3e_t *sl3p;\n#if SHADOW_PAGING_LEVELS >= 4\n    shadow_l4e_t *sl4p;\n#endif\n    mfn_t sl1mfn;\n    int r;\n\n    /* Carefully look in the shadow linear map for the l1e we expect */\n#if SHADOW_PAGING_LEVELS >= 4\n    /* Is a shadow linear map is installed in the first place? */\n    sl4p  = v->arch.paging.shadow.guest_vtable;\n    sl4p += shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START);\n    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )\n        return 0;\n    sl4p = sh_linear_l4_table(v) + shadow_l4_linear_offset(vaddr);\n    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )\n        return 0;\n    sl3p = sh_linear_l3_table(v) + shadow_l3_linear_offset(vaddr);\n    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )\n        return 0;\n#else /* SHADOW_PAGING_LEVELS == 3 */\n    sl3p = ((shadow_l3e_t *) v->arch.paging.shadow.l3table)\n        + shadow_l3_linear_offset(vaddr);\n    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )\n        return 0;\n#endif\n    sl2p = sh_linear_l2_table(v) + shadow_l2_linear_offset(vaddr);\n    if ( !(shadow_l2e_get_flags(*sl2p) & _PAGE_PRESENT) )\n        return 0;\n    sl1p = sh_linear_l1_table(v) + shadow_l1_linear_offset(vaddr);\n    sl1e = *sl1p;\n    if ( ((shadow_l1e_get_flags(sl1e) & (_PAGE_PRESENT|_PAGE_RW))\n          != (_PAGE_PRESENT|_PAGE_RW))\n         || (mfn_x(shadow_l1e_get_mfn(sl1e)) != mfn_x(gmfn)) )\n        return 0;\n\n    /* Found it!  Need to remove its write permissions. */\n    sl1mfn = shadow_l2e_get_mfn(*sl2p);\n    sl1e = shadow_l1e_remove_flags(sl1e, _PAGE_RW);\n    r = shadow_set_l1e(d, sl1p, sl1e, p2m_ram_rw, sl1mfn);\n    if ( r & SHADOW_SET_ERROR ) {\n        /* Can only currently happen if we found a grant-mapped\n         * page.  Just make the guess fail. */\n        return 0;\n    }\n    TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_WRMAP_GUESS_FOUND);\n    return 1;\n}",
        "description": "An issue was discovered in Xen versions up to 4.9.x, where x86 HVM guest OS users could potentially cause a denial of service (hypervisor crash) or escalate privileges due to improper handling of self-linear shadow mappings in translated guests.",
        "commit": "A vulnerability was identified in the x86/shadow component of the Xen hypervisor, specifically within the `sh_guess_wrmap()` function. The fix for XSA-243/CVE-2017-15592 introduced a change in behavior for `sh_guest_wrmap()`, which now needs to handle cases where no shadow linear mapping is present. The issue arises because `guest_vtable` maps the guest's page table rather than Xen's page table, leading to incorrect checks for the presence of a shadow linear slot. As a result, a shadow HVM vCPU switching to 4-level paging mode with an L4 page table containing a mapping that aliases Xen's `SH_LINEAR_PT_VIRT_START` can pass the safety check when it should fail. Consequently, Xen encounters a page fault due to the missing mapping. This problem is part of XSA-243."
    },
    {
        "cwe": "CWE-863",
        "func_name": "torvalds/internal_get_user_pages_fast",
        "score": 0.794119119644165,
        "func_before": "static int internal_get_user_pages_fast(unsigned long start, int nr_pages,\n\t\t\t\t\tunsigned int gup_flags,\n\t\t\t\t\tstruct page **pages)\n{\n\tunsigned long addr, len, end;\n\tint nr_pinned = 0, ret = 0;\n\n\tif (WARN_ON_ONCE(gup_flags & ~(FOLL_WRITE | FOLL_LONGTERM |\n\t\t\t\t       FOLL_FORCE | FOLL_PIN | FOLL_GET)))\n\t\treturn -EINVAL;\n\n\tstart = untagged_addr(start) & PAGE_MASK;\n\taddr = start;\n\tlen = (unsigned long) nr_pages << PAGE_SHIFT;\n\tend = start + len;\n\n\tif (end <= start)\n\t\treturn 0;\n\tif (unlikely(!access_ok((void __user *)start, len)))\n\t\treturn -EFAULT;\n\n\tif (IS_ENABLED(CONFIG_HAVE_FAST_GUP) &&\n\t    gup_fast_permitted(start, end)) {\n\t\tlocal_irq_disable();\n\t\tgup_pgd_range(addr, end, gup_flags, pages, &nr_pinned);\n\t\tlocal_irq_enable();\n\t\tret = nr_pinned;\n\t}\n\n\tif (nr_pinned < nr_pages) {\n\t\t/* Try to get the remaining pages with get_user_pages */\n\t\tstart += nr_pinned << PAGE_SHIFT;\n\t\tpages += nr_pinned;\n\n\t\tret = __gup_longterm_unlocked(start, nr_pages - nr_pinned,\n\t\t\t\t\t      gup_flags, pages);\n\n\t\t/* Have to be a bit careful with return values */\n\t\tif (nr_pinned > 0) {\n\t\t\tif (ret < 0)\n\t\t\t\tret = nr_pinned;\n\t\t\telse\n\t\t\t\tret += nr_pinned;\n\t\t}\n\t}\n\n\treturn ret;\n}",
        "func_after": "static int internal_get_user_pages_fast(unsigned long start, int nr_pages,\n\t\t\t\t\tunsigned int gup_flags,\n\t\t\t\t\tstruct page **pages)\n{\n\tunsigned long addr, len, end;\n\tint nr_pinned = 0, ret = 0;\n\n\tif (WARN_ON_ONCE(gup_flags & ~(FOLL_WRITE | FOLL_LONGTERM |\n\t\t\t\t       FOLL_FORCE | FOLL_PIN | FOLL_GET)))\n\t\treturn -EINVAL;\n\n\tstart = untagged_addr(start) & PAGE_MASK;\n\taddr = start;\n\tlen = (unsigned long) nr_pages << PAGE_SHIFT;\n\tend = start + len;\n\n\tif (end <= start)\n\t\treturn 0;\n\tif (unlikely(!access_ok((void __user *)start, len)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * The FAST_GUP case requires FOLL_WRITE even for pure reads,\n\t * because get_user_pages() may need to cause an early COW in\n\t * order to avoid confusing the normal COW routines. So only\n\t * targets that are already writable are safe to do by just\n\t * looking at the page tables.\n\t */\n\tif (IS_ENABLED(CONFIG_HAVE_FAST_GUP) &&\n\t    gup_fast_permitted(start, end)) {\n\t\tlocal_irq_disable();\n\t\tgup_pgd_range(addr, end, gup_flags | FOLL_WRITE, pages, &nr_pinned);\n\t\tlocal_irq_enable();\n\t\tret = nr_pinned;\n\t}\n\n\tif (nr_pinned < nr_pages) {\n\t\t/* Try to get the remaining pages with get_user_pages */\n\t\tstart += nr_pinned << PAGE_SHIFT;\n\t\tpages += nr_pinned;\n\n\t\tret = __gup_longterm_unlocked(start, nr_pages - nr_pinned,\n\t\t\t\t\t      gup_flags, pages);\n\n\t\t/* Have to be a bit careful with return values */\n\t\tif (nr_pinned > 0) {\n\t\t\tif (ret < 0)\n\t\t\t\tret = nr_pinned;\n\t\t\telse\n\t\t\t\tret += nr_pinned;\n\t\t}\n\t}\n\n\treturn ret;\n}",
        "description": "An issue was discovered in the Linux kernel prior to version 5.7.3, affecting the memory management components located in mm/gup.c and mm/huge_memory.c. The get_user_pages (gup) implementation, when utilized for copy-on-write pages, fails to correctly handle read operation semantics, potentially resulting in unintended write access.",
        "commit": "The vulnerability involves the `get_user_pages()` function in the Linux kernel, which can lead to ambiguous behavior when dealing with copy-on-write (COW) pages. Specifically, the function may return a page pointer that is no longer associated with the original virtual memory area (VM) due to potential COW events. This ambiguity arises because the direction and timing of COW events are undefined, and a page can be unmapped by the thread that performed the `get_user_pages()` call, especially under memory pressure.\n\nTo mitigate this issue, the kernel introduces a change to force a COW event by setting the `FOLL_WRITE` flag when `FOLL_GET` or `FOLL_PIN` is used on a COW mapping. This ensures that the page is properly isolated from other VMs, preventing unintended access or control. However, this change affects the behavior of `get_user_pages_fast()`, which now refuses to follow read-only pages due to the potential need for COW breaking, leading to slower processing in such cases.\n\nThe current semantics are as follows:\n- `__get_user_pages_fast()`: No changes; it does not break COW unless explicitly asked.\n- `get_user_pages_fast()`: Refuses to follow read-only pages, requiring the slow path for COW breaking.\n- `get_user_pages()`: Forces COW breaking for COW mappings when using `FOLL_GET` or `FOLL_PIN`.\n\nThis change aims to clarify the semantics of `get_user_pages()` and reduce the risk of subtle bugs related to COW behavior. While this addresses the ambiguity, it is noted that true shared mappings will still allow pages to change under the user, meaning `get_user_pages()` does not guarantee a \"stable\" page."
    }
]