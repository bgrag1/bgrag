[
    {
        "cwe": "CWE-119",
        "func_name": "torvalds/hugetlb_mcopy_atomic_pte",
        "score": 0.7749755382537842,
        "func_before": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tstruct address_space *mapping = dst_vma->vm_file->f_mapping;\n\t\tpgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
        "func_after": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\tunsigned long size;\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\tmapping = dst_vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\t\tret = -EFAULT;\n\t\tif (idx >= size)\n\t\t\tgoto out_release_nounlock;\n\n\t\t/*\n\t\t * Serialization between remove_inode_hugepages() and\n\t\t * huge_add_to_page_cache() below happens through the\n\t\t * hugetlb_fault_mutex_table that here must be hold by\n\t\t * the caller.\n\t\t */\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\t/*\n\t * Recheck the i_size after holding PT lock to make sure not\n\t * to leave any page mapped (as page_mapped()) beyond the end\n\t * of the i_size (remove_inode_hugepages() is strict about\n\t * enforcing that). If we bail out here, we'll also leave a\n\t * page in the radix tree in the vm_shared case beyond the end\n\t * of the i_size, but remove_inode_hugepages() will take care\n\t * of it as soon as we drop the hugetlb_fault_mutex_table.\n\t */\n\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\tret = -EFAULT;\n\tif (idx >= size)\n\t\tgoto out_release_unlock;\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
        "description": "A flaw was identified in the hugetlb_mcopy_atomic_pte function within the Linux kernel's memory management module, affecting versions prior to 4.13.12. The absence of a proper size check in this function could lead to a denial of service condition, indicated by a BUG.",
        "commit": "A vulnerability was identified in the userfaultfd functionality related to hugetlbfs, where the UFFDIO_COPY operation could inadvertently extend beyond the intended size of the file (i_size). This issue led to a kernel panic (oops) at fs/hugetlbfs/inode.c:484, triggered by the absence of an i_size check in the hugetlb_mcopy_atomic_pte function. Although mmap() operations could succeed beyond the end of the i_size after vmtruncate had removed virtual memory areas (vmas) in those ranges, subsequent faults, including UFFDIO_COPY, should not be allowed to succeed. The proposed solution involves modifying the return value to userland to indicate a SIGBUS-like condition, similar to what a page fault would produce, but this approach was deemed less useful due to the difficulty in distinguishing between SIGSEGV and SIGBUS through meaningful syscall return values."
    },
    {
        "cwe": "CWE-444",
        "func_name": "haproxy/http_parse_cont_len_header",
        "score": 0.7511903643608093,
        "func_before": "int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\n\tword.ptr = value->ptr - 1; // -1 for next loop's pre-increment\n\te = value->ptr + value->len;\n\n\twhile (++word.ptr < e) {\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\t*body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}",
        "func_after": "int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\n\tword.ptr = value->ptr;\n\te = value->ptr + value->len;\n\n\twhile (1) {\n\t\tif (word.ptr >= e) {\n\t\t\t/* empty header or empty value */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr))) {\n\t\t\tword.ptr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\t*body_len = cl;\n\t\t*value = word;\n\n\t\t/* Now either n==e and we're done, or n points to the comma,\n\t\t * and we skip it and continue.\n\t\t */\n\t\tif (n++ == e)\n\t\t\tbreak;\n\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}",
        "description": "HAProxy versions up to 2.0.32, 2.1.x, 2.2.x through 2.2.30, 2.3.x, 2.4.x through 2.4.23, 2.5.x, and 2.6.x before 2.6.15, 2.7.x before 2.7.10, and 2.8.x before 2.8.2 forward empty Content-Length headers, which violates RFC 9110 section 8.6. In rare scenarios, an HTTP/1 server positioned behind HAProxy may misinterpret the payload as an additional request.",
        "commit": "A vulnerability was identified in the HTTP content-length header parsing mechanism, where an empty or trailing-comma value could be misinterpreted as an absent header. This oversight allowed such headers to pass through to the backend server without proper validation, potentially exposing vulnerable servers to attacks. The risk varies based on the backend server's handling of content-length headers, but users relying on HAProxy to protect known-vulnerable servers are particularly at risk. A configuration-based workaround involves explicitly rejecting requests with empty content-length headers in the frontend settings. The permanent fix requires modifying the parser to ensure that only valid values are accepted, rejecting any empty values encountered. This change needs to be applied across all supported versions of the software. The modifications were made to functions such as `h1_parse_cont_len_header()` and `http_parse_cont_len_header()`, with additional considerations for compatibility with Lua and future deprecation plans. Comprehensive testing was conducted to validate these changes."
    },
    {
        "cwe": "CWE-121",
        "func_name": "libtiff/TIFFReadCustomDirectory",
        "score": 0.7700785994529724,
        "func_before": "int\nTIFFReadCustomDirectory(TIFF* tif, toff_t diroff,\n\t\t\tconst TIFFFieldArray* infoarray)\n{\n\tstatic const char module[] = \"TIFFReadCustomDirectory\";\n\tTIFFDirEntry* dir;\n\tuint16_t dircount;\n\tTIFFDirEntry* dp;\n\tuint16_t di;\n\tconst TIFFField* fip;\n\tuint32_t fii;\n        (*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */\n\t_TIFFSetupFields(tif, infoarray);\n\tdircount=TIFFFetchDirectory(tif,diroff,&dir,NULL);\n\tif (!dircount)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"Failed to read custom directory at offset %\" PRIu64,diroff);\n\t\treturn 0;\n\t}\n\tTIFFFreeDirectory(tif);\n\t_TIFFmemset(&tif->tif_dir, 0, sizeof(TIFFDirectory));\n\tTIFFReadDirectoryCheckOrder(tif,dir,dircount);\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\n\t{\n\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\tif (fii == FAILED_FII)\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Unknown field with tag %\"PRIu16\" (0x%\"PRIx16\") encountered\",\n\t\t\t    dp->tdir_tag, dp->tdir_tag);\n\t\t\tif (!_TIFFMergeFields(tif, _TIFFCreateAnonField(tif,\n\t\t\t\t\t\tdp->tdir_tag,\n\t\t\t\t\t\t(TIFFDataType) dp->tdir_type),\n\t\t\t\t\t     1)) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Registering anonymous field with tag %\"PRIu16\" (0x%\"PRIx16\") failed\",\n\t\t\t\t    dp->tdir_tag, dp->tdir_tag);\n\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t} else {\n\t\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\t\t\tassert( fii != FAILED_FII );\n\t\t\t}\n\t\t}\n\t\tif (!dp->tdir_ignore)\n\t\t{\n\t\t\tfip=tif->tif_fields[fii];\n\t\t\tif (fip->field_bit==FIELD_IGNORE)\n\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* check data type */\n\t\t\t\twhile ((fip->field_type!=TIFF_ANY)&&(fip->field_type!=dp->tdir_type))\n\t\t\t\t{\n\t\t\t\t\tfii++;\n\t\t\t\t\tif ((fii==tif->tif_nfields)||\n\t\t\t\t\t    (tif->tif_fields[fii]->field_tag!=(uint32_t)dp->tdir_tag))\n\t\t\t\t\t{\n\t\t\t\t\t\tfii=0xFFFF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfip=tif->tif_fields[fii];\n\t\t\t\t}\n\t\t\t\tif (fii==0xFFFF)\n\t\t\t\t{\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\t    \"Wrong data type %\"PRIu16\" for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t    dp->tdir_type,fip->field_name);\n\t\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* check count if known in advance */\n\t\t\t\t\tif ((fip->field_readcount!=TIFF_VARIABLE)&&\n\t\t\t\t\t    (fip->field_readcount!=TIFF_VARIABLE2))\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32_t expected;\n\t\t\t\t\t\tif (fip->field_readcount==TIFF_SPP)\n\t\t\t\t\t\t\texpected=(uint32_t)tif->tif_dir.td_samplesperpixel;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\texpected=(uint32_t)fip->field_readcount;\n\t\t\t\t\t\tif (!CheckDirCount(tif,dp,expected))\n\t\t\t\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!dp->tdir_ignore) {\n\t\t\t\tswitch (dp->tdir_tag) \n\t\t\t\t{\n\t\t\t\t\tcase EXIFTAG_SUBJECTDISTANCE:\n                        if(fip->field_name != NULL && strncmp(fip->field_name, \"Tag \", 4) != 0 ) {\n                            /* should only be called on a Exif directory */\n                            /* when exifFields[] is active */\n                            (void)TIFFFetchSubjectDistance(tif, dp);\n                        }\n                        else {\n                            (void)TIFFFetchNormalTag(tif, dp, TRUE);\n                        }\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t(void)TIFFFetchNormalTag(tif, dp, TRUE);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} /*-- if (!dp->tdir_ignore) */\n\t\t}\n\t}\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn 1;\n}",
        "func_after": "int\nTIFFReadCustomDirectory(TIFF* tif, toff_t diroff,\n\t\t\tconst TIFFFieldArray* infoarray)\n{\n\tstatic const char module[] = \"TIFFReadCustomDirectory\";\n\tTIFFDirEntry* dir;\n\tuint16_t dircount;\n\tTIFFDirEntry* dp;\n\tuint16_t di;\n\tconst TIFFField* fip;\n\tuint32_t fii;\n        (*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */\n\t_TIFFSetupFields(tif, infoarray);\n\tdircount=TIFFFetchDirectory(tif,diroff,&dir,NULL);\n\tif (!dircount)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"Failed to read custom directory at offset %\" PRIu64,diroff);\n\t\treturn 0;\n\t}\n\tTIFFFreeDirectory(tif);\n\t_TIFFmemset(&tif->tif_dir, 0, sizeof(TIFFDirectory));\n\tTIFFReadDirectoryCheckOrder(tif,dir,dircount);\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\n\t{\n\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\tif (fii == FAILED_FII)\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Unknown field with tag %\"PRIu16\" (0x%\"PRIx16\") encountered\",\n\t\t\t    dp->tdir_tag, dp->tdir_tag);\n\t\t\tif (!_TIFFMergeFields(tif, _TIFFCreateAnonField(tif,\n\t\t\t\t\t\tdp->tdir_tag,\n\t\t\t\t\t\t(TIFFDataType) dp->tdir_type),\n\t\t\t\t\t     1)) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Registering anonymous field with tag %\"PRIu16\" (0x%\"PRIx16\") failed\",\n\t\t\t\t    dp->tdir_tag, dp->tdir_tag);\n\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t} else {\n\t\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\t\t\tassert( fii != FAILED_FII );\n\t\t\t}\n\t\t}\n\t\tif (!dp->tdir_ignore)\n\t\t{\n\t\t\tfip=tif->tif_fields[fii];\n\t\t\tif (fip->field_bit==FIELD_IGNORE)\n\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* check data type */\n\t\t\t\twhile ((fip->field_type!=TIFF_ANY)&&(fip->field_type!=dp->tdir_type))\n\t\t\t\t{\n\t\t\t\t\tfii++;\n\t\t\t\t\tif ((fii==tif->tif_nfields)||\n\t\t\t\t\t    (tif->tif_fields[fii]->field_tag!=(uint32_t)dp->tdir_tag))\n\t\t\t\t\t{\n\t\t\t\t\t\tfii=0xFFFF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfip=tif->tif_fields[fii];\n\t\t\t\t}\n\t\t\t\tif (fii==0xFFFF)\n\t\t\t\t{\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\t    \"Wrong data type %\"PRIu16\" for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t    dp->tdir_type,fip->field_name);\n\t\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* check count if known in advance */\n\t\t\t\t\tif ((fip->field_readcount!=TIFF_VARIABLE)&&\n\t\t\t\t\t    (fip->field_readcount!=TIFF_VARIABLE2))\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32_t expected;\n\t\t\t\t\t\tif (fip->field_readcount==TIFF_SPP)\n\t\t\t\t\t\t\texpected=(uint32_t)tif->tif_dir.td_samplesperpixel;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\texpected=(uint32_t)fip->field_readcount;\n\t\t\t\t\t\tif (!CheckDirCount(tif,dp,expected))\n\t\t\t\t\t\t\tdp->tdir_ignore = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!dp->tdir_ignore) {\n\t\t\t\tswitch (dp->tdir_tag) \n\t\t\t\t{\n\t\t\t\t\tcase EXIFTAG_SUBJECTDISTANCE:\n                        if(!TIFFFieldIsAnonymous(fip)) {\n                            /* should only be called on a Exif directory */\n                            /* when exifFields[] is active */\n                            (void)TIFFFetchSubjectDistance(tif, dp);\n                        }\n                        else {\n                            (void)TIFFFetchNormalTag(tif, dp, TRUE);\n                        }\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t(void)TIFFFetchNormalTag(tif, dp, TRUE);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} /*-- if (!dp->tdir_ignore) */\n\t\t}\n\t}\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn 1;\n}",
        "description": "A stack buffer overflow vulnerability exists in the `main()` function of Libtiffs' `tiffcp.c`. This flaw enables an attacker to exploit it by providing a specially crafted TIFF file to the `tiffcp` tool, resulting in a stack buffer overflow. This can lead to memory corruption and ultimately cause a crash, leading to a denial of service.",
        "commit": "The addition of an extra flag for handling anonymous or unknown tags."
    },
    {
        "cwe": "CWE-122",
        "func_name": "vim/ins_compl_infercase_gettext",
        "score": 0.7646842002868652,
        "func_before": "static char_u *\nins_compl_infercase_gettext(\n\tchar_u\t*str,\n\tint\tchar_len,\n\tint\tcompl_char_len,\n\tint\tmin_len,\n\tchar_u  **tofree)\n{\n    int\t\t*wca;\t\t\t// Wide character array.\n    char_u\t*p;\n    int\t\ti, c;\n    int\t\thas_lower = FALSE;\n    int\t\twas_letter = FALSE;\n    garray_T\tgap;\n\n    IObuff[0] = NUL;\n\n    // Allocate wide character array for the completion and fill it.\n    wca = ALLOC_MULT(int, char_len);\n    if (wca == NULL)\n\treturn IObuff;\n\n    p = str;\n    for (i = 0; i < char_len; ++i)\n\tif (has_mbyte)\n\t    wca[i] = mb_ptr2char_adv(&p);\n\telse\n\t    wca[i] = *(p++);\n\n    // Rule 1: Were any chars converted to lower?\n    p = compl_orig_text;\n    for (i = 0; i < min_len; ++i)\n    {\n\tif (has_mbyte)\n\t    c = mb_ptr2char_adv(&p);\n\telse\n\t    c = *(p++);\n\tif (MB_ISLOWER(c))\n\t{\n\t    has_lower = TRUE;\n\t    if (MB_ISUPPER(wca[i]))\n\t    {\n\t\t// Rule 1 is satisfied.\n\t\tfor (i = compl_char_len; i < char_len; ++i)\n\t\t    wca[i] = MB_TOLOWER(wca[i]);\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    // Rule 2: No lower case, 2nd consecutive letter converted to\n    // upper case.\n    if (!has_lower)\n    {\n\tp = compl_orig_text;\n\tfor (i = 0; i < min_len; ++i)\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char_adv(&p);\n\t    else\n\t\tc = *(p++);\n\t    if (was_letter && MB_ISUPPER(c) && MB_ISLOWER(wca[i]))\n\t    {\n\t\t// Rule 2 is satisfied.\n\t\tfor (i = compl_char_len; i < char_len; ++i)\n\t\t    wca[i] = MB_TOUPPER(wca[i]);\n\t\tbreak;\n\t    }\n\t    was_letter = MB_ISLOWER(c) || MB_ISUPPER(c);\n\t}\n    }\n\n    // Copy the original case of the part we typed.\n    p = compl_orig_text;\n    for (i = 0; i < min_len; ++i)\n    {\n\tif (has_mbyte)\n\t    c = mb_ptr2char_adv(&p);\n\telse\n\t    c = *(p++);\n\tif (MB_ISLOWER(c))\n\t    wca[i] = MB_TOLOWER(wca[i]);\n\telse if (MB_ISUPPER(c))\n\t    wca[i] = MB_TOUPPER(wca[i]);\n    }\n\n    // Generate encoding specific output from wide character array.\n    p = IObuff;\n    i = 0;\n    ga_init2(&gap, 1, 500);\n    while (i < char_len)\n    {\n\tif (gap.ga_data != NULL)\n\t{\n\t    if (ga_grow(&gap, 10) == FAIL)\n\t    {\n\t\tga_clear(&gap);\n\t\treturn (char_u *)\"[failed]\";\n\t    }\n\t    p = (char_u *)gap.ga_data + gap.ga_len;\n\t    if (has_mbyte)\n\t\tgap.ga_len += (*mb_char2bytes)(wca[i++], p);\n\t    else\n\t    {\n\t\t*p = wca[i++];\n\t\t++gap.ga_len;\n\t    }\n\t}\n\telse if ((p - IObuff) + 6 >= IOSIZE)\n\t{\n\t    // Multi-byte characters can occupy up to five bytes more than\n\t    // ASCII characters, and we also need one byte for NUL, so when\n\t    // getting to six bytes from the edge of IObuff switch to using a\n\t    // growarray.  Add the character in the next round.\n\t    if (ga_grow(&gap, IOSIZE) == FAIL)\n\t\treturn (char_u *)\"[failed]\";\n\t    STRCPY(gap.ga_data, IObuff);\n\t    gap.ga_len = (int)STRLEN(IObuff);\n\t}\n\telse if (has_mbyte)\n\t    p += (*mb_char2bytes)(wca[i++], p);\n\telse\n\t    *(p++) = wca[i++];\n    }\n    vim_free(wca);\n\n    if (gap.ga_data != NULL)\n    {\n\t*tofree = gap.ga_data;\n\treturn gap.ga_data;\n    }\n\n    *p = NUL;\n    return IObuff;\n}",
        "func_after": "static char_u *\nins_compl_infercase_gettext(\n\tchar_u\t*str,\n\tint\tchar_len,\n\tint\tcompl_char_len,\n\tint\tmin_len,\n\tchar_u  **tofree)\n{\n    int\t\t*wca;\t\t\t// Wide character array.\n    char_u\t*p;\n    int\t\ti, c;\n    int\t\thas_lower = FALSE;\n    int\t\twas_letter = FALSE;\n    garray_T\tgap;\n\n    IObuff[0] = NUL;\n\n    // Allocate wide character array for the completion and fill it.\n    wca = ALLOC_MULT(int, char_len);\n    if (wca == NULL)\n\treturn IObuff;\n\n    p = str;\n    for (i = 0; i < char_len; ++i)\n\tif (has_mbyte)\n\t    wca[i] = mb_ptr2char_adv(&p);\n\telse\n\t    wca[i] = *(p++);\n\n    // Rule 1: Were any chars converted to lower?\n    p = compl_orig_text;\n    for (i = 0; i < min_len; ++i)\n    {\n\tif (has_mbyte)\n\t    c = mb_ptr2char_adv(&p);\n\telse\n\t    c = *(p++);\n\tif (MB_ISLOWER(c))\n\t{\n\t    has_lower = TRUE;\n\t    if (MB_ISUPPER(wca[i]))\n\t    {\n\t\t// Rule 1 is satisfied.\n\t\tfor (i = compl_char_len; i < char_len; ++i)\n\t\t    wca[i] = MB_TOLOWER(wca[i]);\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    // Rule 2: No lower case, 2nd consecutive letter converted to\n    // upper case.\n    if (!has_lower)\n    {\n\tp = compl_orig_text;\n\tfor (i = 0; i < min_len; ++i)\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char_adv(&p);\n\t    else\n\t\tc = *(p++);\n\t    if (was_letter && MB_ISUPPER(c) && MB_ISLOWER(wca[i]))\n\t    {\n\t\t// Rule 2 is satisfied.\n\t\tfor (i = compl_char_len; i < char_len; ++i)\n\t\t    wca[i] = MB_TOUPPER(wca[i]);\n\t\tbreak;\n\t    }\n\t    was_letter = MB_ISLOWER(c) || MB_ISUPPER(c);\n\t}\n    }\n\n    // Copy the original case of the part we typed.\n    p = compl_orig_text;\n    for (i = 0; i < min_len; ++i)\n    {\n\tif (has_mbyte)\n\t    c = mb_ptr2char_adv(&p);\n\telse\n\t    c = *(p++);\n\tif (MB_ISLOWER(c))\n\t    wca[i] = MB_TOLOWER(wca[i]);\n\telse if (MB_ISUPPER(c))\n\t    wca[i] = MB_TOUPPER(wca[i]);\n    }\n\n    // Generate encoding specific output from wide character array.\n    p = IObuff;\n    i = 0;\n    ga_init2(&gap, 1, 500);\n    while (i < char_len)\n    {\n\tif (gap.ga_data != NULL)\n\t{\n\t    if (ga_grow(&gap, 10) == FAIL)\n\t    {\n\t\tga_clear(&gap);\n\t\treturn (char_u *)\"[failed]\";\n\t    }\n\t    p = (char_u *)gap.ga_data + gap.ga_len;\n\t    if (has_mbyte)\n\t\tgap.ga_len += (*mb_char2bytes)(wca[i++], p);\n\t    else\n\t    {\n\t\t*p = wca[i++];\n\t\t++gap.ga_len;\n\t    }\n\t}\n\telse if ((p - IObuff) + 6 >= IOSIZE)\n\t{\n\t    // Multi-byte characters can occupy up to five bytes more than\n\t    // ASCII characters, and we also need one byte for NUL, so when\n\t    // getting to six bytes from the edge of IObuff switch to using a\n\t    // growarray.  Add the character in the next round.\n\t    if (ga_grow(&gap, IOSIZE) == FAIL)\n\t\treturn (char_u *)\"[failed]\";\n\t    *p = NUL;\n\t    STRCPY(gap.ga_data, IObuff);\n\t    gap.ga_len = (int)STRLEN(IObuff);\n\t}\n\telse if (has_mbyte)\n\t    p += (*mb_char2bytes)(wca[i++], p);\n\telse\n\t    *(p++) = wca[i++];\n    }\n    vim_free(wca);\n\n    if (gap.ga_data != NULL)\n    {\n\t*tofree = gap.ga_data;\n\treturn gap.ga_data;\n    }\n\n    *p = NUL;\n    return IObuff;\n}",
        "description": "Heap-based Buffer Overflow in the Vim text editor prior to version 9.0.0044.",
        "commit": "Reading past the end of a buffer when processing a long line with the 'infercase' option enabled. Solution involves dynamically allocating the string if necessary."
    },
    {
        "cwe": "CWE-763",
        "func_name": "facebook/write",
        "score": 0.7566884160041809,
        "func_before": "size_t\nwrite(Protocol_* iprot, const StructInfo& structInfo, const void* object) {\n  DCHECK(object);\n  size_t written = iprot->writeStructBegin(structInfo.name);\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    const FieldInfo* end = structInfo.fieldInfos + structInfo.numFields;\n    const auto& unionId =\n        activeUnionMemberId(object, structInfo.unionExt->unionTypeOffset);\n    const FieldInfo* found = std::lower_bound(\n        structInfo.fieldInfos,\n        end,\n        unionId,\n        [](const FieldInfo& lhs, FieldID rhs) { return lhs.id < rhs; });\n    if (found < end && found->id == unionId) {\n      const OptionalThriftValue value = getValue(*found->typeInfo, object);\n      if (value.hasValue()) {\n        written += writeField(iprot, *found, value.value());\n      } else if (found->typeInfo->type == protocol::TType::T_STRUCT) {\n        written += iprot->writeFieldBegin(\n            found->name, found->typeInfo->type, found->id);\n        written += iprot->writeStructBegin(found->name);\n        written += iprot->writeStructEnd();\n        written += iprot->writeFieldStop();\n        written += iprot->writeFieldEnd();\n      }\n    }\n  } else {\n    for (std::int16_t index = 0; index < structInfo.numFields; index++) {\n      const auto& fieldInfo = structInfo.fieldInfos[index];\n      if (fieldInfo.isUnqualified || fieldInfo.issetOffset == 0 ||\n          fieldIsSet(object, fieldInfo.issetOffset)) {\n        const OptionalThriftValue value =\n            getValue(*fieldInfo.typeInfo, getMember(fieldInfo, object));\n        if (value.hasValue()) {\n          written += writeField(iprot, fieldInfo, value.value());\n        }\n      }\n    }\n  }\n\n  written += iprot->writeFieldStop();\n  written += iprot->writeStructEnd();\n  return written;\n}",
        "func_after": "size_t\nwrite(Protocol_* iprot, const StructInfo& structInfo, const void* object) {\n  DCHECK(object);\n  size_t written = iprot->writeStructBegin(structInfo.name);\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    const FieldInfo* end = structInfo.fieldInfos + structInfo.numFields;\n    const auto& activeId = getActiveId(object, structInfo);\n    const FieldInfo* found = std::lower_bound(\n        structInfo.fieldInfos,\n        end,\n        activeId,\n        [](const FieldInfo& lhs, FieldID rhs) { return lhs.id < rhs; });\n    if (found < end && found->id == activeId) {\n      const OptionalThriftValue value = getValue(*found->typeInfo, object);\n      if (value.hasValue()) {\n        written += writeField(iprot, *found, value.value());\n      } else if (found->typeInfo->type == protocol::TType::T_STRUCT) {\n        written += iprot->writeFieldBegin(\n            found->name, found->typeInfo->type, found->id);\n        written += iprot->writeStructBegin(found->name);\n        written += iprot->writeStructEnd();\n        written += iprot->writeFieldStop();\n        written += iprot->writeFieldEnd();\n      }\n    }\n  } else {\n    for (std::int16_t index = 0; index < structInfo.numFields; index++) {\n      const auto& fieldInfo = structInfo.fieldInfos[index];\n      if (fieldInfo.isUnqualified || fieldInfo.issetOffset == 0 ||\n          fieldIsSet(object, fieldInfo.issetOffset)) {\n        const OptionalThriftValue value =\n            getValue(*fieldInfo.typeInfo, getMember(fieldInfo, object));\n        if (value.hasValue()) {\n          written += writeField(iprot, fieldInfo, value.value());\n        }\n      }\n    }\n  }\n\n  written += iprot->writeFieldStop();\n  written += iprot->writeStructEnd();\n  return written;\n}",
        "description": "An invalid free operation within Thrift's table-based serialization can lead to application crashes or enable code execution and other unintended consequences. This vulnerability impacts Facebook Thrift versions prior to v2021.02.22.00.",
        "commit": "It was discovered that the table-based serializer improperly handled invalid union data, leading to potential memory leaks and other undesirable effects. Specifically, when duplicate union data was encountered, the previous active member of the union was overwritten without invoking the destructor of the old object. Additionally, if the second piece of data was incomplete, the incorrect destructor was called during stack unwinding, resulting in segmentation faults, data corruption, or other issues. The fix involves clearing the union if there is an active member and correcting the type of the data member that holds the active field ID."
    }
]