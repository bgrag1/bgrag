[
    {
        "cwe": "CWE-362",
        "func_name": "torvalds/fib6_add_rt2node",
        "score": 0.8223333358764648,
        "func_before": "static int fib6_add_rt2node(struct fib6_node *fn, struct fib6_info *rt,\n\t\t\t    struct nl_info *info,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct fib6_info *leaf = rcu_dereference_protected(fn->leaf,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\tstruct fib6_info *iter = NULL;\n\tstruct fib6_info __rcu **ins;\n\tstruct fib6_info __rcu **fallback_ins = NULL;\n\tint replace = (info->nlh &&\n\t\t       (info->nlh->nlmsg_flags & NLM_F_REPLACE));\n\tint add = (!info->nlh ||\n\t\t   (info->nlh->nlmsg_flags & NLM_F_CREATE));\n\tint found = 0;\n\tbool rt_can_ecmp = rt6_qualify_for_ecmp(rt);\n\tbool notify_sibling_rt = false;\n\tu16 nlflags = NLM_F_EXCL;\n\tint err;\n\n\tif (info->nlh && (info->nlh->nlmsg_flags & NLM_F_APPEND))\n\t\tnlflags |= NLM_F_APPEND;\n\n\tins = &fn->leaf;\n\n\tfor (iter = leaf; iter;\n\t     iter = rcu_dereference_protected(iter->fib6_next,\n\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock))) {\n\t\t/*\n\t\t *\tSearch for duplicates\n\t\t */\n\n\t\tif (iter->fib6_metric == rt->fib6_metric) {\n\t\t\t/*\n\t\t\t *\tSame priority level\n\t\t\t */\n\t\t\tif (info->nlh &&\n\t\t\t    (info->nlh->nlmsg_flags & NLM_F_EXCL))\n\t\t\t\treturn -EEXIST;\n\n\t\t\tnlflags &= ~NLM_F_EXCL;\n\t\t\tif (replace) {\n\t\t\t\tif (rt_can_ecmp == rt6_qualify_for_ecmp(iter)) {\n\t\t\t\t\tfound++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallback_ins = fallback_ins ?: ins;\n\t\t\t\tgoto next_iter;\n\t\t\t}\n\n\t\t\tif (rt6_duplicate_nexthop(iter, rt)) {\n\t\t\t\tif (rt->fib6_nsiblings)\n\t\t\t\t\trt->fib6_nsiblings = 0;\n\t\t\t\tif (!(iter->fib6_flags & RTF_EXPIRES))\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\tif (!(rt->fib6_flags & RTF_EXPIRES))\n\t\t\t\t\tfib6_clean_expires_locked(iter);\n\t\t\t\telse\n\t\t\t\t\tfib6_set_expires_locked(iter,\n\t\t\t\t\t\t\t\trt->expires);\n\n\t\t\t\tif (rt->fib6_pmtu)\n\t\t\t\t\tfib6_metric_set(iter, RTAX_MTU,\n\t\t\t\t\t\t\trt->fib6_pmtu);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\t/* If we have the same destination and the same metric,\n\t\t\t * but not the same gateway, then the route we try to\n\t\t\t * add is sibling to this route, increment our counter\n\t\t\t * of siblings, and later we will add our route to the\n\t\t\t * list.\n\t\t\t * Only static routes (which don't have flag\n\t\t\t * RTF_EXPIRES) are used for ECMPv6.\n\t\t\t *\n\t\t\t * To avoid long list, we only had siblings if the\n\t\t\t * route have a gateway.\n\t\t\t */\n\t\t\tif (rt_can_ecmp &&\n\t\t\t    rt6_qualify_for_ecmp(iter))\n\t\t\t\trt->fib6_nsiblings++;\n\t\t}\n\n\t\tif (iter->fib6_metric > rt->fib6_metric)\n\t\t\tbreak;\n\nnext_iter:\n\t\tins = &iter->fib6_next;\n\t}\n\n\tif (fallback_ins && !found) {\n\t\t/* No matching route with same ecmp-able-ness found, replace\n\t\t * first matching route\n\t\t */\n\t\tins = fallback_ins;\n\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\tfound++;\n\t}\n\n\t/* Reset round-robin state, if necessary */\n\tif (ins == &fn->leaf)\n\t\tfn->rr_ptr = NULL;\n\n\t/* Link this route to others same route. */\n\tif (rt->fib6_nsiblings) {\n\t\tunsigned int fib6_nsiblings;\n\t\tstruct fib6_info *sibling, *temp_sibling;\n\n\t\t/* Find the first route that have the same metric */\n\t\tsibling = leaf;\n\t\tnotify_sibling_rt = true;\n\t\twhile (sibling) {\n\t\t\tif (sibling->fib6_metric == rt->fib6_metric &&\n\t\t\t    rt6_qualify_for_ecmp(sibling)) {\n\t\t\t\tlist_add_tail(&rt->fib6_siblings,\n\t\t\t\t\t      &sibling->fib6_siblings);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsibling = rcu_dereference_protected(sibling->fib6_next,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\tnotify_sibling_rt = false;\n\t\t}\n\t\t/* For each sibling in the list, increment the counter of\n\t\t * siblings. BUG() if counters does not match, list of siblings\n\t\t * is broken!\n\t\t */\n\t\tfib6_nsiblings = 0;\n\t\tlist_for_each_entry_safe(sibling, temp_sibling,\n\t\t\t\t\t &rt->fib6_siblings, fib6_siblings) {\n\t\t\tsibling->fib6_nsiblings++;\n\t\t\tBUG_ON(sibling->fib6_nsiblings != rt->fib6_nsiblings);\n\t\t\tfib6_nsiblings++;\n\t\t}\n\t\tBUG_ON(fib6_nsiblings != rt->fib6_nsiblings);\n\t\trt6_multipath_rebalance(temp_sibling);\n\t}\n\n\t/*\n\t *\tinsert node\n\t */\n\tif (!replace) {\n\t\tif (!add)\n\t\t\tpr_warn(\"NLM_F_CREATE should be set when creating new route\\n\");\n\nadd:\n\t\tnlflags |= NLM_F_CREATE;\n\n\t\t/* The route should only be notified if it is the first\n\t\t * route in the node or if it is added as a sibling\n\t\t * route to the first route in the node.\n\t\t */\n\t\tif (!info->skip_notify_kernel &&\n\t\t    (notify_sibling_rt || ins == &fn->leaf)) {\n\t\t\tenum fib_event_type fib_event;\n\n\t\t\tif (notify_sibling_rt)\n\t\t\t\tfib_event = FIB_EVENT_ENTRY_APPEND;\n\t\t\telse\n\t\t\t\tfib_event = FIB_EVENT_ENTRY_REPLACE;\n\t\t\terr = call_fib6_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\tfib_event, rt,\n\t\t\t\t\t\t\textack);\n\t\t\tif (err) {\n\t\t\t\tstruct fib6_info *sibling, *next_sibling;\n\n\t\t\t\t/* If the route has siblings, then it first\n\t\t\t\t * needs to be unlinked from them.\n\t\t\t\t */\n\t\t\t\tif (!rt->fib6_nsiblings)\n\t\t\t\t\treturn err;\n\n\t\t\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t\t\t\t &rt->fib6_siblings,\n\t\t\t\t\t\t\t fib6_siblings)\n\t\t\t\t\tsibling->fib6_nsiblings--;\n\t\t\t\trt->fib6_nsiblings = 0;\n\t\t\t\tlist_del_init(&rt->fib6_siblings);\n\t\t\t\trt6_multipath_rebalance(next_sibling);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\trcu_assign_pointer(rt->fib6_next, iter);\n\t\tfib6_info_hold(rt);\n\t\trcu_assign_pointer(rt->fib6_node, fn);\n\t\trcu_assign_pointer(*ins, rt);\n\t\tif (!info->skip_notify)\n\t\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, nlflags);\n\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries++;\n\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\n\t} else {\n\t\tint nsiblings;\n\n\t\tif (!found) {\n\t\t\tif (add)\n\t\t\t\tgoto add;\n\t\t\tpr_warn(\"NLM_F_REPLACE set, but no existing node found!\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (!info->skip_notify_kernel && ins == &fn->leaf) {\n\t\t\terr = call_fib6_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\tFIB_EVENT_ENTRY_REPLACE,\n\t\t\t\t\t\t\trt, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tfib6_info_hold(rt);\n\t\trcu_assign_pointer(rt->fib6_node, fn);\n\t\trt->fib6_next = iter->fib6_next;\n\t\trcu_assign_pointer(*ins, rt);\n\t\tif (!info->skip_notify)\n\t\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, NLM_F_REPLACE);\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\t\tnsiblings = iter->fib6_nsiblings;\n\t\titer->fib6_node = NULL;\n\t\tfib6_purge_rt(iter, fn, info->nl_net);\n\t\tif (rcu_access_pointer(fn->rr_ptr) == iter)\n\t\t\tfn->rr_ptr = NULL;\n\t\tfib6_info_release(iter);\n\n\t\tif (nsiblings) {\n\t\t\t/* Replacing an ECMP route, remove all siblings */\n\t\t\tins = &rt->fib6_next;\n\t\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\twhile (iter) {\n\t\t\t\tif (iter->fib6_metric > rt->fib6_metric)\n\t\t\t\t\tbreak;\n\t\t\t\tif (rt6_qualify_for_ecmp(iter)) {\n\t\t\t\t\t*ins = iter->fib6_next;\n\t\t\t\t\titer->fib6_node = NULL;\n\t\t\t\t\tfib6_purge_rt(iter, fn, info->nl_net);\n\t\t\t\t\tif (rcu_access_pointer(fn->rr_ptr) == iter)\n\t\t\t\t\t\tfn->rr_ptr = NULL;\n\t\t\t\t\tfib6_info_release(iter);\n\t\t\t\t\tnsiblings--;\n\t\t\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries--;\n\t\t\t\t} else {\n\t\t\t\t\tins = &iter->fib6_next;\n\t\t\t\t}\n\t\t\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\t}\n\t\t\tWARN_ON(nsiblings != 0);\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "func_after": "static int fib6_add_rt2node(struct fib6_node *fn, struct fib6_info *rt,\n\t\t\t    struct nl_info *info,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct fib6_info *leaf = rcu_dereference_protected(fn->leaf,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\tstruct fib6_info *iter = NULL;\n\tstruct fib6_info __rcu **ins;\n\tstruct fib6_info __rcu **fallback_ins = NULL;\n\tint replace = (info->nlh &&\n\t\t       (info->nlh->nlmsg_flags & NLM_F_REPLACE));\n\tint add = (!info->nlh ||\n\t\t   (info->nlh->nlmsg_flags & NLM_F_CREATE));\n\tint found = 0;\n\tbool rt_can_ecmp = rt6_qualify_for_ecmp(rt);\n\tbool notify_sibling_rt = false;\n\tu16 nlflags = NLM_F_EXCL;\n\tint err;\n\n\tif (info->nlh && (info->nlh->nlmsg_flags & NLM_F_APPEND))\n\t\tnlflags |= NLM_F_APPEND;\n\n\tins = &fn->leaf;\n\n\tfor (iter = leaf; iter;\n\t     iter = rcu_dereference_protected(iter->fib6_next,\n\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock))) {\n\t\t/*\n\t\t *\tSearch for duplicates\n\t\t */\n\n\t\tif (iter->fib6_metric == rt->fib6_metric) {\n\t\t\t/*\n\t\t\t *\tSame priority level\n\t\t\t */\n\t\t\tif (info->nlh &&\n\t\t\t    (info->nlh->nlmsg_flags & NLM_F_EXCL))\n\t\t\t\treturn -EEXIST;\n\n\t\t\tnlflags &= ~NLM_F_EXCL;\n\t\t\tif (replace) {\n\t\t\t\tif (rt_can_ecmp == rt6_qualify_for_ecmp(iter)) {\n\t\t\t\t\tfound++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallback_ins = fallback_ins ?: ins;\n\t\t\t\tgoto next_iter;\n\t\t\t}\n\n\t\t\tif (rt6_duplicate_nexthop(iter, rt)) {\n\t\t\t\tif (rt->fib6_nsiblings)\n\t\t\t\t\trt->fib6_nsiblings = 0;\n\t\t\t\tif (!(iter->fib6_flags & RTF_EXPIRES))\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\tif (!(rt->fib6_flags & RTF_EXPIRES))\n\t\t\t\t\tfib6_clean_expires(iter);\n\t\t\t\telse\n\t\t\t\t\tfib6_set_expires(iter, rt->expires);\n\n\t\t\t\tif (rt->fib6_pmtu)\n\t\t\t\t\tfib6_metric_set(iter, RTAX_MTU,\n\t\t\t\t\t\t\trt->fib6_pmtu);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\t/* If we have the same destination and the same metric,\n\t\t\t * but not the same gateway, then the route we try to\n\t\t\t * add is sibling to this route, increment our counter\n\t\t\t * of siblings, and later we will add our route to the\n\t\t\t * list.\n\t\t\t * Only static routes (which don't have flag\n\t\t\t * RTF_EXPIRES) are used for ECMPv6.\n\t\t\t *\n\t\t\t * To avoid long list, we only had siblings if the\n\t\t\t * route have a gateway.\n\t\t\t */\n\t\t\tif (rt_can_ecmp &&\n\t\t\t    rt6_qualify_for_ecmp(iter))\n\t\t\t\trt->fib6_nsiblings++;\n\t\t}\n\n\t\tif (iter->fib6_metric > rt->fib6_metric)\n\t\t\tbreak;\n\nnext_iter:\n\t\tins = &iter->fib6_next;\n\t}\n\n\tif (fallback_ins && !found) {\n\t\t/* No matching route with same ecmp-able-ness found, replace\n\t\t * first matching route\n\t\t */\n\t\tins = fallback_ins;\n\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\tfound++;\n\t}\n\n\t/* Reset round-robin state, if necessary */\n\tif (ins == &fn->leaf)\n\t\tfn->rr_ptr = NULL;\n\n\t/* Link this route to others same route. */\n\tif (rt->fib6_nsiblings) {\n\t\tunsigned int fib6_nsiblings;\n\t\tstruct fib6_info *sibling, *temp_sibling;\n\n\t\t/* Find the first route that have the same metric */\n\t\tsibling = leaf;\n\t\tnotify_sibling_rt = true;\n\t\twhile (sibling) {\n\t\t\tif (sibling->fib6_metric == rt->fib6_metric &&\n\t\t\t    rt6_qualify_for_ecmp(sibling)) {\n\t\t\t\tlist_add_tail(&rt->fib6_siblings,\n\t\t\t\t\t      &sibling->fib6_siblings);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsibling = rcu_dereference_protected(sibling->fib6_next,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\tnotify_sibling_rt = false;\n\t\t}\n\t\t/* For each sibling in the list, increment the counter of\n\t\t * siblings. BUG() if counters does not match, list of siblings\n\t\t * is broken!\n\t\t */\n\t\tfib6_nsiblings = 0;\n\t\tlist_for_each_entry_safe(sibling, temp_sibling,\n\t\t\t\t\t &rt->fib6_siblings, fib6_siblings) {\n\t\t\tsibling->fib6_nsiblings++;\n\t\t\tBUG_ON(sibling->fib6_nsiblings != rt->fib6_nsiblings);\n\t\t\tfib6_nsiblings++;\n\t\t}\n\t\tBUG_ON(fib6_nsiblings != rt->fib6_nsiblings);\n\t\trt6_multipath_rebalance(temp_sibling);\n\t}\n\n\t/*\n\t *\tinsert node\n\t */\n\tif (!replace) {\n\t\tif (!add)\n\t\t\tpr_warn(\"NLM_F_CREATE should be set when creating new route\\n\");\n\nadd:\n\t\tnlflags |= NLM_F_CREATE;\n\n\t\t/* The route should only be notified if it is the first\n\t\t * route in the node or if it is added as a sibling\n\t\t * route to the first route in the node.\n\t\t */\n\t\tif (!info->skip_notify_kernel &&\n\t\t    (notify_sibling_rt || ins == &fn->leaf)) {\n\t\t\tenum fib_event_type fib_event;\n\n\t\t\tif (notify_sibling_rt)\n\t\t\t\tfib_event = FIB_EVENT_ENTRY_APPEND;\n\t\t\telse\n\t\t\t\tfib_event = FIB_EVENT_ENTRY_REPLACE;\n\t\t\terr = call_fib6_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\tfib_event, rt,\n\t\t\t\t\t\t\textack);\n\t\t\tif (err) {\n\t\t\t\tstruct fib6_info *sibling, *next_sibling;\n\n\t\t\t\t/* If the route has siblings, then it first\n\t\t\t\t * needs to be unlinked from them.\n\t\t\t\t */\n\t\t\t\tif (!rt->fib6_nsiblings)\n\t\t\t\t\treturn err;\n\n\t\t\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t\t\t\t &rt->fib6_siblings,\n\t\t\t\t\t\t\t fib6_siblings)\n\t\t\t\t\tsibling->fib6_nsiblings--;\n\t\t\t\trt->fib6_nsiblings = 0;\n\t\t\t\tlist_del_init(&rt->fib6_siblings);\n\t\t\t\trt6_multipath_rebalance(next_sibling);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\trcu_assign_pointer(rt->fib6_next, iter);\n\t\tfib6_info_hold(rt);\n\t\trcu_assign_pointer(rt->fib6_node, fn);\n\t\trcu_assign_pointer(*ins, rt);\n\t\tif (!info->skip_notify)\n\t\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, nlflags);\n\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries++;\n\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\n\t} else {\n\t\tint nsiblings;\n\n\t\tif (!found) {\n\t\t\tif (add)\n\t\t\t\tgoto add;\n\t\t\tpr_warn(\"NLM_F_REPLACE set, but no existing node found!\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (!info->skip_notify_kernel && ins == &fn->leaf) {\n\t\t\terr = call_fib6_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\tFIB_EVENT_ENTRY_REPLACE,\n\t\t\t\t\t\t\trt, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tfib6_info_hold(rt);\n\t\trcu_assign_pointer(rt->fib6_node, fn);\n\t\trt->fib6_next = iter->fib6_next;\n\t\trcu_assign_pointer(*ins, rt);\n\t\tif (!info->skip_notify)\n\t\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, NLM_F_REPLACE);\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\t\tnsiblings = iter->fib6_nsiblings;\n\t\titer->fib6_node = NULL;\n\t\tfib6_purge_rt(iter, fn, info->nl_net);\n\t\tif (rcu_access_pointer(fn->rr_ptr) == iter)\n\t\t\tfn->rr_ptr = NULL;\n\t\tfib6_info_release(iter);\n\n\t\tif (nsiblings) {\n\t\t\t/* Replacing an ECMP route, remove all siblings */\n\t\t\tins = &rt->fib6_next;\n\t\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\twhile (iter) {\n\t\t\t\tif (iter->fib6_metric > rt->fib6_metric)\n\t\t\t\t\tbreak;\n\t\t\t\tif (rt6_qualify_for_ecmp(iter)) {\n\t\t\t\t\t*ins = iter->fib6_next;\n\t\t\t\t\titer->fib6_node = NULL;\n\t\t\t\t\tfib6_purge_rt(iter, fn, info->nl_net);\n\t\t\t\t\tif (rcu_access_pointer(fn->rr_ptr) == iter)\n\t\t\t\t\t\tfn->rr_ptr = NULL;\n\t\t\t\t\tfib6_info_release(iter);\n\t\t\t\t\tnsiblings--;\n\t\t\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries--;\n\t\t\t\t} else {\n\t\t\t\t\tins = &iter->fib6_next;\n\t\t\t\t}\n\t\t\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\t}\n\t\t\tWARN_ON(nsiblings != 0);\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "description": "A race condition exists in the Linux Kernel where an unauthenticated attacker from an adjacent network could exploit it by sending an ICMPv6 router advertisement packet, potentially leading to arbitrary code execution.",
        "commit": "This vulnerability involves a revert of a specific commit due to race conditions related to the management of the `expires` field in a `fib6_info` structure. The original commit introduced issues where the garbage collection (gc) process could start before the entry was added to the gc list and the timer value was set, potentially leading to a use-after-free (UAF) condition. The recommended approach is to revert the commit and address the problem in a future release."
    },
    {
        "cwe": "CWE-310",
        "func_name": "torvalds/asn1_ber_decoder",
        "score": 0.8183780908584595,
        "func_before": "int asn1_ber_decoder(const struct asn1_decoder *decoder,\n\t\t     void *context,\n\t\t     const unsigned char *data,\n\t\t     size_t datalen)\n{\n\tconst unsigned char *machine = decoder->machine;\n\tconst asn1_action_t *actions = decoder->actions;\n\tsize_t machlen = decoder->machlen;\n\tenum asn1_opcode op;\n\tunsigned char tag = 0, csp = 0, jsp = 0, optag = 0, hdr = 0;\n\tconst char *errmsg;\n\tsize_t pc = 0, dp = 0, tdp = 0, len = 0;\n\tint ret;\n\n\tunsigned char flags = 0;\n#define FLAG_INDEFINITE_LENGTH\t0x01\n#define FLAG_MATCHED\t\t0x02\n#define FLAG_LAST_MATCHED\t0x04 /* Last tag matched */\n#define FLAG_CONS\t\t0x20 /* Corresponds to CONS bit in the opcode tag\n\t\t\t\t      * - ie. whether or not we are going to parse\n\t\t\t\t      *   a compound type.\n\t\t\t\t      */\n\n#define NR_CONS_STACK 10\n\tunsigned short cons_dp_stack[NR_CONS_STACK];\n\tunsigned short cons_datalen_stack[NR_CONS_STACK];\n\tunsigned char cons_hdrlen_stack[NR_CONS_STACK];\n#define NR_JUMP_STACK 10\n\tunsigned char jump_stack[NR_JUMP_STACK];\n\n\tif (datalen > 65535)\n\t\treturn -EMSGSIZE;\n\nnext_op:\n\tpr_debug(\"next_op: pc=\\e[32m%zu\\e[m/%zu dp=\\e[33m%zu\\e[m/%zu C=%d J=%d\\n\",\n\t\t pc, machlen, dp, datalen, csp, jsp);\n\tif (unlikely(pc >= machlen))\n\t\tgoto machine_overrun_error;\n\top = machine[pc];\n\tif (unlikely(pc + asn1_op_lengths[op] > machlen))\n\t\tgoto machine_overrun_error;\n\n\t/* If this command is meant to match a tag, then do that before\n\t * evaluating the command.\n\t */\n\tif (op <= ASN1_OP__MATCHES_TAG) {\n\t\tunsigned char tmp;\n\n\t\t/* Skip conditional matches if possible */\n\t\tif ((op & ASN1_OP_MATCH__COND &&\n\t\t     flags & FLAG_MATCHED) ||\n\t\t    dp == datalen) {\n\t\t\tflags &= ~FLAG_LAST_MATCHED;\n\t\t\tpc += asn1_op_lengths[op];\n\t\t\tgoto next_op;\n\t\t}\n\n\t\tflags = 0;\n\t\thdr = 2;\n\n\t\t/* Extract a tag from the data */\n\t\tif (unlikely(dp >= datalen - 1))\n\t\t\tgoto data_overrun_error;\n\t\ttag = data[dp++];\n\t\tif (unlikely((tag & 0x1f) == ASN1_LONG_TAG))\n\t\t\tgoto long_tag_not_supported;\n\n\t\tif (op & ASN1_OP_MATCH__ANY) {\n\t\t\tpr_debug(\"- any %02x\\n\", tag);\n\t\t} else {\n\t\t\t/* Extract the tag from the machine\n\t\t\t * - Either CONS or PRIM are permitted in the data if\n\t\t\t *   CONS is not set in the op stream, otherwise CONS\n\t\t\t *   is mandatory.\n\t\t\t */\n\t\t\toptag = machine[pc + 1];\n\t\t\tflags |= optag & FLAG_CONS;\n\n\t\t\t/* Determine whether the tag matched */\n\t\t\ttmp = optag ^ tag;\n\t\t\ttmp &= ~(optag & ASN1_CONS_BIT);\n\t\t\tpr_debug(\"- match? %02x %02x %02x\\n\", tag, optag, tmp);\n\t\t\tif (tmp != 0) {\n\t\t\t\t/* All odd-numbered tags are MATCH_OR_SKIP. */\n\t\t\t\tif (op & ASN1_OP_MATCH__SKIP) {\n\t\t\t\t\tpc += asn1_op_lengths[op];\n\t\t\t\t\tdp--;\n\t\t\t\t\tgoto next_op;\n\t\t\t\t}\n\t\t\t\tgoto tag_mismatch;\n\t\t\t}\n\t\t}\n\t\tflags |= FLAG_MATCHED;\n\n\t\tlen = data[dp++];\n\t\tif (len > 0x7f) {\n\t\t\tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\t\t\t/* Indefinite length */\n\t\t\t\tif (unlikely(!(tag & ASN1_CONS_BIT)))\n\t\t\t\t\tgoto indefinite_len_primitive;\n\t\t\t\tflags |= FLAG_INDEFINITE_LENGTH;\n\t\t\t\tif (unlikely(2 > datalen - dp))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t} else {\n\t\t\t\tint n = len - 0x80;\n\t\t\t\tif (unlikely(n > 2))\n\t\t\t\t\tgoto length_too_long;\n\t\t\t\tif (unlikely(dp >= datalen - n))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t\thdr += n;\n\t\t\t\tfor (len = 0; n > 0; n--) {\n\t\t\t\t\tlen <<= 8;\n\t\t\t\t\tlen |= data[dp++];\n\t\t\t\t}\n\t\t\t\tif (unlikely(len > datalen - dp))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t}\n\t\t}\n\n\t\tif (flags & FLAG_CONS) {\n\t\t\t/* For expected compound forms, we stack the positions\n\t\t\t * of the start and end of the data.\n\t\t\t */\n\t\t\tif (unlikely(csp >= NR_CONS_STACK))\n\t\t\t\tgoto cons_stack_overflow;\n\t\t\tcons_dp_stack[csp] = dp;\n\t\t\tcons_hdrlen_stack[csp] = hdr;\n\t\t\tif (!(flags & FLAG_INDEFINITE_LENGTH)) {\n\t\t\t\tcons_datalen_stack[csp] = datalen;\n\t\t\t\tdatalen = dp + len;\n\t\t\t} else {\n\t\t\t\tcons_datalen_stack[csp] = 0;\n\t\t\t}\n\t\t\tcsp++;\n\t\t}\n\n\t\tpr_debug(\"- TAG: %02x %zu%s\\n\",\n\t\t\t tag, len, flags & FLAG_CONS ? \" CONS\" : \"\");\n\t\ttdp = dp;\n\t}\n\n\t/* Decide how to handle the operation */\n\tswitch (op) {\n\tcase ASN1_OP_MATCH_ANY_ACT:\n\tcase ASN1_OP_COND_MATCH_ANY_ACT:\n\t\tret = actions[machine[pc + 1]](context, hdr, tag, data + dp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto skip_data;\n\n\tcase ASN1_OP_MATCH_ACT:\n\tcase ASN1_OP_MATCH_ACT_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_ACT_OR_SKIP:\n\t\tret = actions[machine[pc + 2]](context, hdr, tag, data + dp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto skip_data;\n\n\tcase ASN1_OP_MATCH:\n\tcase ASN1_OP_MATCH_OR_SKIP:\n\tcase ASN1_OP_MATCH_ANY:\n\tcase ASN1_OP_COND_MATCH_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_ANY:\n\tskip_data:\n\t\tif (!(flags & FLAG_CONS)) {\n\t\t\tif (flags & FLAG_INDEFINITE_LENGTH) {\n\t\t\t\tret = asn1_find_indefinite_length(\n\t\t\t\t\tdata, datalen, &dp, &len, &errmsg);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tdp += len;\n\t\t\t}\n\t\t\tpr_debug(\"- LEAF: %zu\\n\", len);\n\t\t}\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_MATCH_JUMP:\n\tcase ASN1_OP_MATCH_JUMP_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_JUMP_OR_SKIP:\n\t\tpr_debug(\"- MATCH_JUMP\\n\");\n\t\tif (unlikely(jsp == NR_JUMP_STACK))\n\t\t\tgoto jump_stack_overflow;\n\t\tjump_stack[jsp++] = pc + asn1_op_lengths[op];\n\t\tpc = machine[pc + 2];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_COND_FAIL:\n\t\tif (unlikely(!(flags & FLAG_MATCHED)))\n\t\t\tgoto tag_mismatch;\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_COMPLETE:\n\t\tif (unlikely(jsp != 0 || csp != 0)) {\n\t\t\tpr_err(\"ASN.1 decoder error: Stacks not empty at completion (%u, %u)\\n\",\n\t\t\t       jsp, csp);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\treturn 0;\n\n\tcase ASN1_OP_END_SET:\n\tcase ASN1_OP_END_SET_ACT:\n\t\tif (unlikely(!(flags & FLAG_MATCHED)))\n\t\t\tgoto tag_mismatch;\n\tcase ASN1_OP_END_SEQ:\n\tcase ASN1_OP_END_SET_OF:\n\tcase ASN1_OP_END_SEQ_OF:\n\tcase ASN1_OP_END_SEQ_ACT:\n\tcase ASN1_OP_END_SET_OF_ACT:\n\tcase ASN1_OP_END_SEQ_OF_ACT:\n\t\tif (unlikely(csp <= 0))\n\t\t\tgoto cons_stack_underflow;\n\t\tcsp--;\n\t\ttdp = cons_dp_stack[csp];\n\t\thdr = cons_hdrlen_stack[csp];\n\t\tlen = datalen;\n\t\tdatalen = cons_datalen_stack[csp];\n\t\tpr_debug(\"- end cons t=%zu dp=%zu l=%zu/%zu\\n\",\n\t\t\t tdp, dp, len, datalen);\n\t\tif (datalen == 0) {\n\t\t\t/* Indefinite length - check for the EOC. */\n\t\t\tdatalen = len;\n\t\t\tif (unlikely(datalen - dp < 2))\n\t\t\t\tgoto data_overrun_error;\n\t\t\tif (data[dp++] != 0) {\n\t\t\t\tif (op & ASN1_OP_END__OF) {\n\t\t\t\t\tdp--;\n\t\t\t\t\tcsp++;\n\t\t\t\t\tpc = machine[pc + 1];\n\t\t\t\t\tpr_debug(\"- continue\\n\");\n\t\t\t\t\tgoto next_op;\n\t\t\t\t}\n\t\t\t\tgoto missing_eoc;\n\t\t\t}\n\t\t\tif (data[dp++] != 0)\n\t\t\t\tgoto invalid_eoc;\n\t\t\tlen = dp - tdp - 2;\n\t\t} else {\n\t\t\tif (dp < len && (op & ASN1_OP_END__OF)) {\n\t\t\t\tdatalen = len;\n\t\t\t\tcsp++;\n\t\t\t\tpc = machine[pc + 1];\n\t\t\t\tpr_debug(\"- continue\\n\");\n\t\t\t\tgoto next_op;\n\t\t\t}\n\t\t\tif (dp != len)\n\t\t\t\tgoto cons_length_error;\n\t\t\tlen -= tdp;\n\t\t\tpr_debug(\"- cons len l=%zu d=%zu\\n\", len, dp - tdp);\n\t\t}\n\n\t\tif (op & ASN1_OP_END__ACT) {\n\t\t\tunsigned char act;\n\t\t\tif (op & ASN1_OP_END__OF)\n\t\t\t\tact = machine[pc + 2];\n\t\t\telse\n\t\t\t\tact = machine[pc + 1];\n\t\t\tret = actions[act](context, hdr, 0, data + tdp, len);\n\t\t}\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_MAYBE_ACT:\n\t\tif (!(flags & FLAG_LAST_MATCHED)) {\n\t\t\tpc += asn1_op_lengths[op];\n\t\t\tgoto next_op;\n\t\t}\n\tcase ASN1_OP_ACT:\n\t\tret = actions[machine[pc + 1]](context, hdr, tag, data + tdp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_RETURN:\n\t\tif (unlikely(jsp <= 0))\n\t\t\tgoto jump_stack_underflow;\n\t\tpc = jump_stack[--jsp];\n\t\tflags |= FLAG_MATCHED | FLAG_LAST_MATCHED;\n\t\tgoto next_op;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* Shouldn't reach here */\n\tpr_err(\"ASN.1 decoder error: Found reserved opcode (%u) pc=%zu\\n\",\n\t       op, pc);\n\treturn -EBADMSG;\n\ndata_overrun_error:\n\terrmsg = \"Data overrun error\";\n\tgoto error;\nmachine_overrun_error:\n\terrmsg = \"Machine overrun error\";\n\tgoto error;\njump_stack_underflow:\n\terrmsg = \"Jump stack underflow\";\n\tgoto error;\njump_stack_overflow:\n\terrmsg = \"Jump stack overflow\";\n\tgoto error;\ncons_stack_underflow:\n\terrmsg = \"Cons stack underflow\";\n\tgoto error;\ncons_stack_overflow:\n\terrmsg = \"Cons stack overflow\";\n\tgoto error;\ncons_length_error:\n\terrmsg = \"Cons length error\";\n\tgoto error;\nmissing_eoc:\n\terrmsg = \"Missing EOC in indefinite len cons\";\n\tgoto error;\ninvalid_eoc:\n\terrmsg = \"Invalid length EOC\";\n\tgoto error;\nlength_too_long:\n\terrmsg = \"Unsupported length\";\n\tgoto error;\nindefinite_len_primitive:\n\terrmsg = \"Indefinite len primitive not permitted\";\n\tgoto error;\ntag_mismatch:\n\terrmsg = \"Unexpected tag\";\n\tgoto error;\nlong_tag_not_supported:\n\terrmsg = \"Long tag not supported\";\nerror:\n\tpr_debug(\"\\nASN1: %s [m=%zu d=%zu ot=%02x t=%02x l=%zu]\\n\",\n\t\t errmsg, pc, dp, optag, tag, len);\n\treturn -EBADMSG;\n}",
        "func_after": "int asn1_ber_decoder(const struct asn1_decoder *decoder,\n\t\t     void *context,\n\t\t     const unsigned char *data,\n\t\t     size_t datalen)\n{\n\tconst unsigned char *machine = decoder->machine;\n\tconst asn1_action_t *actions = decoder->actions;\n\tsize_t machlen = decoder->machlen;\n\tenum asn1_opcode op;\n\tunsigned char tag = 0, csp = 0, jsp = 0, optag = 0, hdr = 0;\n\tconst char *errmsg;\n\tsize_t pc = 0, dp = 0, tdp = 0, len = 0;\n\tint ret;\n\n\tunsigned char flags = 0;\n#define FLAG_INDEFINITE_LENGTH\t0x01\n#define FLAG_MATCHED\t\t0x02\n#define FLAG_LAST_MATCHED\t0x04 /* Last tag matched */\n#define FLAG_CONS\t\t0x20 /* Corresponds to CONS bit in the opcode tag\n\t\t\t\t      * - ie. whether or not we are going to parse\n\t\t\t\t      *   a compound type.\n\t\t\t\t      */\n\n#define NR_CONS_STACK 10\n\tunsigned short cons_dp_stack[NR_CONS_STACK];\n\tunsigned short cons_datalen_stack[NR_CONS_STACK];\n\tunsigned char cons_hdrlen_stack[NR_CONS_STACK];\n#define NR_JUMP_STACK 10\n\tunsigned char jump_stack[NR_JUMP_STACK];\n\n\tif (datalen > 65535)\n\t\treturn -EMSGSIZE;\n\nnext_op:\n\tpr_debug(\"next_op: pc=\\e[32m%zu\\e[m/%zu dp=\\e[33m%zu\\e[m/%zu C=%d J=%d\\n\",\n\t\t pc, machlen, dp, datalen, csp, jsp);\n\tif (unlikely(pc >= machlen))\n\t\tgoto machine_overrun_error;\n\top = machine[pc];\n\tif (unlikely(pc + asn1_op_lengths[op] > machlen))\n\t\tgoto machine_overrun_error;\n\n\t/* If this command is meant to match a tag, then do that before\n\t * evaluating the command.\n\t */\n\tif (op <= ASN1_OP__MATCHES_TAG) {\n\t\tunsigned char tmp;\n\n\t\t/* Skip conditional matches if possible */\n\t\tif ((op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED) ||\n\t\t    (op & ASN1_OP_MATCH__SKIP && dp == datalen)) {\n\t\t\tflags &= ~FLAG_LAST_MATCHED;\n\t\t\tpc += asn1_op_lengths[op];\n\t\t\tgoto next_op;\n\t\t}\n\n\t\tflags = 0;\n\t\thdr = 2;\n\n\t\t/* Extract a tag from the data */\n\t\tif (unlikely(dp >= datalen - 1))\n\t\t\tgoto data_overrun_error;\n\t\ttag = data[dp++];\n\t\tif (unlikely((tag & 0x1f) == ASN1_LONG_TAG))\n\t\t\tgoto long_tag_not_supported;\n\n\t\tif (op & ASN1_OP_MATCH__ANY) {\n\t\t\tpr_debug(\"- any %02x\\n\", tag);\n\t\t} else {\n\t\t\t/* Extract the tag from the machine\n\t\t\t * - Either CONS or PRIM are permitted in the data if\n\t\t\t *   CONS is not set in the op stream, otherwise CONS\n\t\t\t *   is mandatory.\n\t\t\t */\n\t\t\toptag = machine[pc + 1];\n\t\t\tflags |= optag & FLAG_CONS;\n\n\t\t\t/* Determine whether the tag matched */\n\t\t\ttmp = optag ^ tag;\n\t\t\ttmp &= ~(optag & ASN1_CONS_BIT);\n\t\t\tpr_debug(\"- match? %02x %02x %02x\\n\", tag, optag, tmp);\n\t\t\tif (tmp != 0) {\n\t\t\t\t/* All odd-numbered tags are MATCH_OR_SKIP. */\n\t\t\t\tif (op & ASN1_OP_MATCH__SKIP) {\n\t\t\t\t\tpc += asn1_op_lengths[op];\n\t\t\t\t\tdp--;\n\t\t\t\t\tgoto next_op;\n\t\t\t\t}\n\t\t\t\tgoto tag_mismatch;\n\t\t\t}\n\t\t}\n\t\tflags |= FLAG_MATCHED;\n\n\t\tlen = data[dp++];\n\t\tif (len > 0x7f) {\n\t\t\tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\t\t\t/* Indefinite length */\n\t\t\t\tif (unlikely(!(tag & ASN1_CONS_BIT)))\n\t\t\t\t\tgoto indefinite_len_primitive;\n\t\t\t\tflags |= FLAG_INDEFINITE_LENGTH;\n\t\t\t\tif (unlikely(2 > datalen - dp))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t} else {\n\t\t\t\tint n = len - 0x80;\n\t\t\t\tif (unlikely(n > 2))\n\t\t\t\t\tgoto length_too_long;\n\t\t\t\tif (unlikely(dp >= datalen - n))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t\thdr += n;\n\t\t\t\tfor (len = 0; n > 0; n--) {\n\t\t\t\t\tlen <<= 8;\n\t\t\t\t\tlen |= data[dp++];\n\t\t\t\t}\n\t\t\t\tif (unlikely(len > datalen - dp))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t}\n\t\t}\n\n\t\tif (flags & FLAG_CONS) {\n\t\t\t/* For expected compound forms, we stack the positions\n\t\t\t * of the start and end of the data.\n\t\t\t */\n\t\t\tif (unlikely(csp >= NR_CONS_STACK))\n\t\t\t\tgoto cons_stack_overflow;\n\t\t\tcons_dp_stack[csp] = dp;\n\t\t\tcons_hdrlen_stack[csp] = hdr;\n\t\t\tif (!(flags & FLAG_INDEFINITE_LENGTH)) {\n\t\t\t\tcons_datalen_stack[csp] = datalen;\n\t\t\t\tdatalen = dp + len;\n\t\t\t} else {\n\t\t\t\tcons_datalen_stack[csp] = 0;\n\t\t\t}\n\t\t\tcsp++;\n\t\t}\n\n\t\tpr_debug(\"- TAG: %02x %zu%s\\n\",\n\t\t\t tag, len, flags & FLAG_CONS ? \" CONS\" : \"\");\n\t\ttdp = dp;\n\t}\n\n\t/* Decide how to handle the operation */\n\tswitch (op) {\n\tcase ASN1_OP_MATCH_ANY_ACT:\n\tcase ASN1_OP_COND_MATCH_ANY_ACT:\n\t\tret = actions[machine[pc + 1]](context, hdr, tag, data + dp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto skip_data;\n\n\tcase ASN1_OP_MATCH_ACT:\n\tcase ASN1_OP_MATCH_ACT_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_ACT_OR_SKIP:\n\t\tret = actions[machine[pc + 2]](context, hdr, tag, data + dp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tgoto skip_data;\n\n\tcase ASN1_OP_MATCH:\n\tcase ASN1_OP_MATCH_OR_SKIP:\n\tcase ASN1_OP_MATCH_ANY:\n\tcase ASN1_OP_COND_MATCH_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_ANY:\n\tskip_data:\n\t\tif (!(flags & FLAG_CONS)) {\n\t\t\tif (flags & FLAG_INDEFINITE_LENGTH) {\n\t\t\t\tret = asn1_find_indefinite_length(\n\t\t\t\t\tdata, datalen, &dp, &len, &errmsg);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tdp += len;\n\t\t\t}\n\t\t\tpr_debug(\"- LEAF: %zu\\n\", len);\n\t\t}\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_MATCH_JUMP:\n\tcase ASN1_OP_MATCH_JUMP_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_JUMP_OR_SKIP:\n\t\tpr_debug(\"- MATCH_JUMP\\n\");\n\t\tif (unlikely(jsp == NR_JUMP_STACK))\n\t\t\tgoto jump_stack_overflow;\n\t\tjump_stack[jsp++] = pc + asn1_op_lengths[op];\n\t\tpc = machine[pc + 2];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_COND_FAIL:\n\t\tif (unlikely(!(flags & FLAG_MATCHED)))\n\t\t\tgoto tag_mismatch;\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_COMPLETE:\n\t\tif (unlikely(jsp != 0 || csp != 0)) {\n\t\t\tpr_err(\"ASN.1 decoder error: Stacks not empty at completion (%u, %u)\\n\",\n\t\t\t       jsp, csp);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\treturn 0;\n\n\tcase ASN1_OP_END_SET:\n\tcase ASN1_OP_END_SET_ACT:\n\t\tif (unlikely(!(flags & FLAG_MATCHED)))\n\t\t\tgoto tag_mismatch;\n\tcase ASN1_OP_END_SEQ:\n\tcase ASN1_OP_END_SET_OF:\n\tcase ASN1_OP_END_SEQ_OF:\n\tcase ASN1_OP_END_SEQ_ACT:\n\tcase ASN1_OP_END_SET_OF_ACT:\n\tcase ASN1_OP_END_SEQ_OF_ACT:\n\t\tif (unlikely(csp <= 0))\n\t\t\tgoto cons_stack_underflow;\n\t\tcsp--;\n\t\ttdp = cons_dp_stack[csp];\n\t\thdr = cons_hdrlen_stack[csp];\n\t\tlen = datalen;\n\t\tdatalen = cons_datalen_stack[csp];\n\t\tpr_debug(\"- end cons t=%zu dp=%zu l=%zu/%zu\\n\",\n\t\t\t tdp, dp, len, datalen);\n\t\tif (datalen == 0) {\n\t\t\t/* Indefinite length - check for the EOC. */\n\t\t\tdatalen = len;\n\t\t\tif (unlikely(datalen - dp < 2))\n\t\t\t\tgoto data_overrun_error;\n\t\t\tif (data[dp++] != 0) {\n\t\t\t\tif (op & ASN1_OP_END__OF) {\n\t\t\t\t\tdp--;\n\t\t\t\t\tcsp++;\n\t\t\t\t\tpc = machine[pc + 1];\n\t\t\t\t\tpr_debug(\"- continue\\n\");\n\t\t\t\t\tgoto next_op;\n\t\t\t\t}\n\t\t\t\tgoto missing_eoc;\n\t\t\t}\n\t\t\tif (data[dp++] != 0)\n\t\t\t\tgoto invalid_eoc;\n\t\t\tlen = dp - tdp - 2;\n\t\t} else {\n\t\t\tif (dp < len && (op & ASN1_OP_END__OF)) {\n\t\t\t\tdatalen = len;\n\t\t\t\tcsp++;\n\t\t\t\tpc = machine[pc + 1];\n\t\t\t\tpr_debug(\"- continue\\n\");\n\t\t\t\tgoto next_op;\n\t\t\t}\n\t\t\tif (dp != len)\n\t\t\t\tgoto cons_length_error;\n\t\t\tlen -= tdp;\n\t\t\tpr_debug(\"- cons len l=%zu d=%zu\\n\", len, dp - tdp);\n\t\t}\n\n\t\tif (op & ASN1_OP_END__ACT) {\n\t\t\tunsigned char act;\n\t\t\tif (op & ASN1_OP_END__OF)\n\t\t\t\tact = machine[pc + 2];\n\t\t\telse\n\t\t\t\tact = machine[pc + 1];\n\t\t\tret = actions[act](context, hdr, 0, data + tdp, len);\n\t\t}\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_MAYBE_ACT:\n\t\tif (!(flags & FLAG_LAST_MATCHED)) {\n\t\t\tpc += asn1_op_lengths[op];\n\t\t\tgoto next_op;\n\t\t}\n\tcase ASN1_OP_ACT:\n\t\tret = actions[machine[pc + 1]](context, hdr, tag, data + tdp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_RETURN:\n\t\tif (unlikely(jsp <= 0))\n\t\t\tgoto jump_stack_underflow;\n\t\tpc = jump_stack[--jsp];\n\t\tflags |= FLAG_MATCHED | FLAG_LAST_MATCHED;\n\t\tgoto next_op;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* Shouldn't reach here */\n\tpr_err(\"ASN.1 decoder error: Found reserved opcode (%u) pc=%zu\\n\",\n\t       op, pc);\n\treturn -EBADMSG;\n\ndata_overrun_error:\n\terrmsg = \"Data overrun error\";\n\tgoto error;\nmachine_overrun_error:\n\terrmsg = \"Machine overrun error\";\n\tgoto error;\njump_stack_underflow:\n\terrmsg = \"Jump stack underflow\";\n\tgoto error;\njump_stack_overflow:\n\terrmsg = \"Jump stack overflow\";\n\tgoto error;\ncons_stack_underflow:\n\terrmsg = \"Cons stack underflow\";\n\tgoto error;\ncons_stack_overflow:\n\terrmsg = \"Cons stack overflow\";\n\tgoto error;\ncons_length_error:\n\terrmsg = \"Cons length error\";\n\tgoto error;\nmissing_eoc:\n\terrmsg = \"Missing EOC in indefinite len cons\";\n\tgoto error;\ninvalid_eoc:\n\terrmsg = \"Invalid length EOC\";\n\tgoto error;\nlength_too_long:\n\terrmsg = \"Unsupported length\";\n\tgoto error;\nindefinite_len_primitive:\n\terrmsg = \"Indefinite len primitive not permitted\";\n\tgoto error;\ntag_mismatch:\n\terrmsg = \"Unexpected tag\";\n\tgoto error;\nlong_tag_not_supported:\n\terrmsg = \"Long tag not supported\";\nerror:\n\tpr_debug(\"\\nASN1: %s [m=%zu d=%zu ot=%02x t=%02x l=%zu]\\n\",\n\t\t errmsg, pc, dp, optag, tag, len);\n\treturn -EBADMSG;\n}",
        "description": "The `asn1_ber_decoder` function in the Linux kernel, prior to version 4.3, is susceptible to a denial of service (panic) when processing an ASN.1 BER file that lacks a public key. This issue arises because the `public_key_verify_signature` function in the cryptographic module mishandles the absence of a public key, leading to system instability.",
        "commit": "The ASN.1 decoder in certain implementations fails to correctly handle data overruns, leading to non-matching detection failures. Specifically, when parsing sequences of objects, non-optional matches are skipped if there is no more data available, instead of reporting a data-overrun error. This issue arises because the code segment responsible for deciding whether to skip optional matches due to a lack of data also incorrectly skips non-optional elements when the data pointer reaches the end of the buffer. This behavior can be observed in the data decoder for the new RSA akcipher algorithm, where the last integer is skipped if there is insufficient data.\n\nWithout the fix, defining `DEBUG` in `asn1_decoder.c` reveals that the ASN.1 parser does not properly handle the end of the buffer, potentially leading to incorrect parsing outcomes. However, this vulnerability is mitigated in practical scenarios involving X.509 certificates and PKCS#7 messages due to several factors:\n\n1. **X.509 Certificates**: Relevant records are cleared before use, and the removal of critical components like the public key causes the ASN.1 parser to fail quickly due to a lack of data. Additionally, extracted signature data is handled robustly, and optional extensions like AKID and SKID are managed without risking NULL pointer issues.\n\n2. **PKCS#7 Messages**: Embedded X.509 certificates are survivable, and the message digest content and authattrs are handled appropriately if they show NULL pointers. Missing signatures result in NULL MPIs, which are managed by MPI routines. If data is NULL, it is expected that the message has detached content, and other fields are decoded to simple integers, with checks failing early if an algorithm ID field is omitted.\n\nDespite these mitigations, the underlying issue remains that mandatory tags should trigger an `EBADMSG` error when missing, but without the patch, errors like `ERANGE`, `ENOPKG`, or others might be produced, or the parse might appear to succeed with subsequent errors like `ENOKEY` or `EKEYREJECTED`. Testing this vulnerability involves removing mandatory tags from the ASN.1 stream, such as the final `BIT_STRING` or `OCTET_STRING`, which should trigger an `EBADMSG` error with the patch applied."
    },
    {
        "cwe": "CWE-122",
        "func_name": "vim/find_help_tags",
        "score": 0.8091922402381897,
        "func_before": "int\nfind_help_tags(\n    char_u\t*arg,\n    int\t\t*num_matches,\n    char_u\t***matches,\n    int\t\tkeep_lang)\n{\n    char_u\t*s, *d;\n    int\t\ti;\n    // Specific tags that either have a specific replacement or won't go\n    // through the generic rules.\n    static char *(except_tbl[][2]) = {\n\t{\"*\",\t\t\"star\"},\n\t{\"g*\",\t\t\"gstar\"},\n\t{\"[*\",\t\t\"[star\"},\n\t{\"]*\",\t\t\"]star\"},\n\t{\":*\",\t\t\":star\"},\n\t{\"/*\",\t\t\"/star\"},\n\t{\"/\\\\*\",\t\"/\\\\\\\\star\"},\n\t{\"\\\"*\",\t\t\"quotestar\"},\n\t{\"**\",\t\t\"starstar\"},\n\t{\"cpo-*\",\t\"cpo-star\"},\n\t{\"/\\\\(\\\\)\",\t\"/\\\\\\\\(\\\\\\\\)\"},\n\t{\"/\\\\%(\\\\)\",\t\"/\\\\\\\\%(\\\\\\\\)\"},\n\t{\"?\",\t\t\"?\"},\n\t{\"??\",\t\t\"??\"},\n\t{\":?\",\t\t\":?\"},\n\t{\"?<CR>\",\t\"?<CR>\"},\n\t{\"g?\",\t\t\"g?\"},\n\t{\"g?g?\",\t\"g?g?\"},\n\t{\"g??\",\t\t\"g??\"},\n\t{\"-?\",\t\t\"-?\"},\n\t{\"q?\",\t\t\"q?\"},\n\t{\"v_g?\",\t\"v_g?\"},\n\t{\"/\\\\?\",\t\"/\\\\\\\\?\"},\n\t{\"/\\\\z(\\\\)\",\t\"/\\\\\\\\z(\\\\\\\\)\"},\n\t{\"\\\\=\",\t\t\"\\\\\\\\=\"},\n\t{\":s\\\\=\",\t\":s\\\\\\\\=\"},\n\t{\"[count]\",\t\"\\\\[count]\"},\n\t{\"[quotex]\",\t\"\\\\[quotex]\"},\n\t{\"[range]\",\t\"\\\\[range]\"},\n\t{\":[range]\",\t\":\\\\[range]\"},\n\t{\"[pattern]\",\t\"\\\\[pattern]\"},\n\t{\"\\\\|\",\t\t\"\\\\\\\\bar\"},\n\t{\"\\\\%$\",\t\"/\\\\\\\\%\\\\$\"},\n\t{\"s/\\\\~\",\t\"s/\\\\\\\\\\\\~\"},\n\t{\"s/\\\\U\",\t\"s/\\\\\\\\U\"},\n\t{\"s/\\\\L\",\t\"s/\\\\\\\\L\"},\n\t{\"s/\\\\1\",\t\"s/\\\\\\\\1\"},\n\t{\"s/\\\\2\",\t\"s/\\\\\\\\2\"},\n\t{\"s/\\\\3\",\t\"s/\\\\\\\\3\"},\n\t{\"s/\\\\9\",\t\"s/\\\\\\\\9\"},\n\t{NULL, NULL}\n    };\n    static char *(expr_table[]) = {\"!=?\", \"!~?\", \"<=?\", \"<?\", \"==?\", \"=~?\",\n\t\t\t\t   \">=?\", \">?\", \"is?\", \"isnot?\"};\n    int flags;\n\n    d = IObuff;\t\t    // assume IObuff is long enough!\n    d[0] = NUL;\n\n    if (STRNICMP(arg, \"expr-\", 5) == 0)\n    {\n\t// When the string starting with \"expr-\" and containing '?' and matches\n\t// the table, it is taken literally (but ~ is escaped).  Otherwise '?'\n\t// is recognized as a wildcard.\n\tfor (i = (int)ARRAY_LENGTH(expr_table); --i >= 0; )\n\t    if (STRCMP(arg + 5, expr_table[i]) == 0)\n\t    {\n\t\tint si = 0, di = 0;\n\n\t\tfor (;;)\n\t\t{\n\t\t    if (arg[si] == '~')\n\t\t\td[di++] = '\\\\';\n\t\t    d[di++] = arg[si];\n\t\t    if (arg[si] == NUL)\n\t\t\tbreak;\n\t\t    ++si;\n\t\t}\n\t\tbreak;\n\t    }\n    }\n    else\n    {\n\t// Recognize a few exceptions to the rule.  Some strings that contain\n\t// '*'are changed to \"star\", otherwise '*' is recognized as a wildcard.\n\tfor (i = 0; except_tbl[i][0] != NULL; ++i)\n\t    if (STRCMP(arg, except_tbl[i][0]) == 0)\n\t    {\n\t\tSTRCPY(d, except_tbl[i][1]);\n\t\tbreak;\n\t    }\n    }\n\n    if (d[0] == NUL)\t// no match in table\n    {\n\t// Replace \"\\S\" with \"/\\\\S\", etc.  Otherwise every tag is matched.\n\t// Also replace \"\\%^\" and \"\\%(\", they match every tag too.\n\t// Also \"\\zs\", \"\\z1\", etc.\n\t// Also \"\\@<\", \"\\@=\", \"\\@<=\", etc.\n\t// And also \"\\_$\" and \"\\_^\".\n\tif (arg[0] == '\\\\'\n\t\t&& ((arg[1] != NUL && arg[2] == NUL)\n\t\t    || (vim_strchr((char_u *)\"%_z@\", arg[1]) != NULL\n\t\t\t\t\t\t\t   && arg[2] != NUL)))\n\t{\n\t    STRCPY(d, \"/\\\\\\\\\");\n\t    STRCPY(d + 3, arg + 1);\n\t    // Check for \"/\\\\_$\", should be \"/\\\\_\\$\"\n\t    if (d[3] == '_' && d[4] == '$')\n\t\tSTRCPY(d + 4, \"\\\\$\");\n\t}\n\telse\n\t{\n\t  // Replace:\n\t  // \"[:...:]\" with \"\\[:...:]\"\n\t  // \"[++...]\" with \"\\[++...]\"\n\t  // \"\\{\" with \"\\\\{\"\t\t   -- matching \"} \\}\"\n\t    if ((arg[0] == '[' && (arg[1] == ':'\n\t\t\t || (arg[1] == '+' && arg[2] == '+')))\n\t\t    || (arg[0] == '\\\\' && arg[1] == '{'))\n\t      *d++ = '\\\\';\n\n\t  // If tag starts with \"('\", skip the \"(\". Fixes CTRL-] on ('option'.\n\t  if (*arg == '(' && arg[1] == '\\'')\n\t      arg++;\n\t  for (s = arg; *s; ++s)\n\t  {\n\t    // Replace \"|\" with \"bar\" and '\"' with \"quote\" to match the name of\n\t    // the tags for these commands.\n\t    // Replace \"*\" with \".*\" and \"?\" with \".\" to match command line\n\t    // completion.\n\t    // Insert a backslash before '~', '$' and '.' to avoid their\n\t    // special meaning.\n\t    if (d - IObuff > IOSIZE - 10)\t// getting too long!?\n\t\tbreak;\n\t    switch (*s)\n\t    {\n\t\tcase '|':   STRCPY(d, \"bar\");\n\t\t\t    d += 3;\n\t\t\t    continue;\n\t\tcase '\"':   STRCPY(d, \"quote\");\n\t\t\t    d += 5;\n\t\t\t    continue;\n\t\tcase '*':   *d++ = '.';\n\t\t\t    break;\n\t\tcase '?':   *d++ = '.';\n\t\t\t    continue;\n\t\tcase '$':\n\t\tcase '.':\n\t\tcase '~':   *d++ = '\\\\';\n\t\t\t    break;\n\t    }\n\n\t    // Replace \"^x\" by \"CTRL-X\". Don't do this for \"^_\" to make\n\t    // \":help i_^_CTRL-D\" work.\n\t    // Insert '-' before and after \"CTRL-X\" when applicable.\n\t    if (*s < ' ' || (*s == '^' && s[1] && (ASCII_ISALPHA(s[1])\n\t\t\t   || vim_strchr((char_u *)\"?@[\\\\]^\", s[1]) != NULL)))\n\t    {\n\t\tif (d > IObuff && d[-1] != '_' && d[-1] != '\\\\')\n\t\t    *d++ = '_';\t\t// prepend a '_' to make x_CTRL-x\n\t\tSTRCPY(d, \"CTRL-\");\n\t\td += 5;\n\t\tif (*s < ' ')\n\t\t{\n#ifdef EBCDIC\n\t\t    *d++ = CtrlChar(*s);\n#else\n\t\t    *d++ = *s + '@';\n#endif\n\t\t    if (d[-1] == '\\\\')\n\t\t\t*d++ = '\\\\';\t// double a backslash\n\t\t}\n\t\telse\n\t\t    *d++ = *++s;\n\t\tif (s[1] != NUL && s[1] != '_')\n\t\t    *d++ = '_';\t\t// append a '_'\n\t\tcontinue;\n\t    }\n\t    else if (*s == '^')\t\t// \"^\" or \"CTRL-^\" or \"^_\"\n\t\t*d++ = '\\\\';\n\n\t    // Insert a backslash before a backslash after a slash, for search\n\t    // pattern tags: \"/\\|\" --> \"/\\\\|\".\n\t    else if (s[0] == '\\\\' && s[1] != '\\\\'\n\t\t\t\t\t       && *arg == '/' && s == arg + 1)\n\t\t*d++ = '\\\\';\n\n\t    // \"CTRL-\\_\" -> \"CTRL-\\\\_\" to avoid the special meaning of \"\\_\" in\n\t    // \"CTRL-\\_CTRL-N\"\n\t    if (STRNICMP(s, \"CTRL-\\\\_\", 7) == 0)\n\t    {\n\t\tSTRCPY(d, \"CTRL-\\\\\\\\\");\n\t\td += 7;\n\t\ts += 6;\n\t    }\n\n\t    *d++ = *s;\n\n\t    // If tag contains \"({\" or \"([\", tag terminates at the \"(\".\n\t    // This is for help on functions, e.g.: abs({expr}).\n\t    if (*s == '(' && (s[1] == '{' || s[1] =='['))\n\t\tbreak;\n\n\t    // If tag starts with ', toss everything after a second '. Fixes\n\t    // CTRL-] on 'option'. (would include the trailing '.').\n\t    if (*s == '\\'' && s > arg && *arg == '\\'')\n\t\tbreak;\n\t    // Also '{' and '}'.\n\t    if (*s == '}' && s > arg && *arg == '{')\n\t\tbreak;\n\t  }\n\t  *d = NUL;\n\n\t  if (*IObuff == '`')\n\t  {\n\t      if (d > IObuff + 2 && d[-1] == '`')\n\t      {\n\t\t  // remove the backticks from `command`\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-2] = NUL;\n\t      }\n\t      else if (d > IObuff + 3 && d[-2] == '`' && d[-1] == ',')\n\t      {\n\t\t  // remove the backticks and comma from `command`,\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-3] = NUL;\n\t      }\n\t      else if (d > IObuff + 4 && d[-3] == '`'\n\t\t\t\t\t     && d[-2] == '\\\\' && d[-1] == '.')\n\t      {\n\t\t  // remove the backticks and dot from `command`\\.\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-4] = NUL;\n\t      }\n\t  }\n\t}\n    }\n\n    *matches = (char_u **)\"\";\n    *num_matches = 0;\n    flags = TAG_HELP | TAG_REGEXP | TAG_NAMES | TAG_VERBOSE | TAG_NO_TAGFUNC;\n    if (keep_lang)\n\tflags |= TAG_KEEP_LANG;\n    if (find_tags(IObuff, num_matches, matches, flags, (int)MAXCOL, NULL) == OK\n\t    && *num_matches > 0)\n    {\n\t// Sort the matches found on the heuristic number that is after the\n\t// tag name.\n\tqsort((void *)*matches, (size_t)*num_matches,\n\t\t\t\t\t      sizeof(char_u *), help_compare);\n\t// Delete more than TAG_MANY to reduce the size of the listing.\n\twhile (*num_matches > TAG_MANY)\n\t    vim_free((*matches)[--*num_matches]);\n    }\n    return OK;\n}",
        "func_after": "int\nfind_help_tags(\n    char_u\t*arg,\n    int\t\t*num_matches,\n    char_u\t***matches,\n    int\t\tkeep_lang)\n{\n    char_u\t*s, *d;\n    int\t\ti;\n    // Specific tags that either have a specific replacement or won't go\n    // through the generic rules.\n    static char *(except_tbl[][2]) = {\n\t{\"*\",\t\t\"star\"},\n\t{\"g*\",\t\t\"gstar\"},\n\t{\"[*\",\t\t\"[star\"},\n\t{\"]*\",\t\t\"]star\"},\n\t{\":*\",\t\t\":star\"},\n\t{\"/*\",\t\t\"/star\"},\n\t{\"/\\\\*\",\t\"/\\\\\\\\star\"},\n\t{\"\\\"*\",\t\t\"quotestar\"},\n\t{\"**\",\t\t\"starstar\"},\n\t{\"cpo-*\",\t\"cpo-star\"},\n\t{\"/\\\\(\\\\)\",\t\"/\\\\\\\\(\\\\\\\\)\"},\n\t{\"/\\\\%(\\\\)\",\t\"/\\\\\\\\%(\\\\\\\\)\"},\n\t{\"?\",\t\t\"?\"},\n\t{\"??\",\t\t\"??\"},\n\t{\":?\",\t\t\":?\"},\n\t{\"?<CR>\",\t\"?<CR>\"},\n\t{\"g?\",\t\t\"g?\"},\n\t{\"g?g?\",\t\"g?g?\"},\n\t{\"g??\",\t\t\"g??\"},\n\t{\"-?\",\t\t\"-?\"},\n\t{\"q?\",\t\t\"q?\"},\n\t{\"v_g?\",\t\"v_g?\"},\n\t{\"/\\\\?\",\t\"/\\\\\\\\?\"},\n\t{\"/\\\\z(\\\\)\",\t\"/\\\\\\\\z(\\\\\\\\)\"},\n\t{\"\\\\=\",\t\t\"\\\\\\\\=\"},\n\t{\":s\\\\=\",\t\":s\\\\\\\\=\"},\n\t{\"[count]\",\t\"\\\\[count]\"},\n\t{\"[quotex]\",\t\"\\\\[quotex]\"},\n\t{\"[range]\",\t\"\\\\[range]\"},\n\t{\":[range]\",\t\":\\\\[range]\"},\n\t{\"[pattern]\",\t\"\\\\[pattern]\"},\n\t{\"\\\\|\",\t\t\"\\\\\\\\bar\"},\n\t{\"\\\\%$\",\t\"/\\\\\\\\%\\\\$\"},\n\t{\"s/\\\\~\",\t\"s/\\\\\\\\\\\\~\"},\n\t{\"s/\\\\U\",\t\"s/\\\\\\\\U\"},\n\t{\"s/\\\\L\",\t\"s/\\\\\\\\L\"},\n\t{\"s/\\\\1\",\t\"s/\\\\\\\\1\"},\n\t{\"s/\\\\2\",\t\"s/\\\\\\\\2\"},\n\t{\"s/\\\\3\",\t\"s/\\\\\\\\3\"},\n\t{\"s/\\\\9\",\t\"s/\\\\\\\\9\"},\n\t{NULL, NULL}\n    };\n    static char *(expr_table[]) = {\"!=?\", \"!~?\", \"<=?\", \"<?\", \"==?\", \"=~?\",\n\t\t\t\t   \">=?\", \">?\", \"is?\", \"isnot?\"};\n    int flags;\n\n    d = IObuff;\t\t    // assume IObuff is long enough!\n    d[0] = NUL;\n\n    if (STRNICMP(arg, \"expr-\", 5) == 0)\n    {\n\t// When the string starting with \"expr-\" and containing '?' and matches\n\t// the table, it is taken literally (but ~ is escaped).  Otherwise '?'\n\t// is recognized as a wildcard.\n\tfor (i = (int)ARRAY_LENGTH(expr_table); --i >= 0; )\n\t    if (STRCMP(arg + 5, expr_table[i]) == 0)\n\t    {\n\t\tint si = 0, di = 0;\n\n\t\tfor (;;)\n\t\t{\n\t\t    if (arg[si] == '~')\n\t\t\td[di++] = '\\\\';\n\t\t    d[di++] = arg[si];\n\t\t    if (arg[si] == NUL)\n\t\t\tbreak;\n\t\t    ++si;\n\t\t}\n\t\tbreak;\n\t    }\n    }\n    else\n    {\n\t// Recognize a few exceptions to the rule.  Some strings that contain\n\t// '*'are changed to \"star\", otherwise '*' is recognized as a wildcard.\n\tfor (i = 0; except_tbl[i][0] != NULL; ++i)\n\t    if (STRCMP(arg, except_tbl[i][0]) == 0)\n\t    {\n\t\tSTRCPY(d, except_tbl[i][1]);\n\t\tbreak;\n\t    }\n    }\n\n    if (d[0] == NUL)\t// no match in table\n    {\n\t// Replace \"\\S\" with \"/\\\\S\", etc.  Otherwise every tag is matched.\n\t// Also replace \"\\%^\" and \"\\%(\", they match every tag too.\n\t// Also \"\\zs\", \"\\z1\", etc.\n\t// Also \"\\@<\", \"\\@=\", \"\\@<=\", etc.\n\t// And also \"\\_$\" and \"\\_^\".\n\tif (arg[0] == '\\\\'\n\t\t&& ((arg[1] != NUL && arg[2] == NUL)\n\t\t    || (vim_strchr((char_u *)\"%_z@\", arg[1]) != NULL\n\t\t\t\t\t\t\t   && arg[2] != NUL)))\n\t{\n\t    vim_snprintf((char *)d, IOSIZE, \"/\\\\\\\\%s\", arg + 1);\n\t    // Check for \"/\\\\_$\", should be \"/\\\\_\\$\"\n\t    if (d[3] == '_' && d[4] == '$')\n\t\tSTRCPY(d + 4, \"\\\\$\");\n\t}\n\telse\n\t{\n\t  // Replace:\n\t  // \"[:...:]\" with \"\\[:...:]\"\n\t  // \"[++...]\" with \"\\[++...]\"\n\t  // \"\\{\" with \"\\\\{\"\t\t   -- matching \"} \\}\"\n\t    if ((arg[0] == '[' && (arg[1] == ':'\n\t\t\t || (arg[1] == '+' && arg[2] == '+')))\n\t\t    || (arg[0] == '\\\\' && arg[1] == '{'))\n\t      *d++ = '\\\\';\n\n\t  // If tag starts with \"('\", skip the \"(\". Fixes CTRL-] on ('option'.\n\t  if (*arg == '(' && arg[1] == '\\'')\n\t      arg++;\n\t  for (s = arg; *s; ++s)\n\t  {\n\t    // Replace \"|\" with \"bar\" and '\"' with \"quote\" to match the name of\n\t    // the tags for these commands.\n\t    // Replace \"*\" with \".*\" and \"?\" with \".\" to match command line\n\t    // completion.\n\t    // Insert a backslash before '~', '$' and '.' to avoid their\n\t    // special meaning.\n\t    if (d - IObuff > IOSIZE - 10)\t// getting too long!?\n\t\tbreak;\n\t    switch (*s)\n\t    {\n\t\tcase '|':   STRCPY(d, \"bar\");\n\t\t\t    d += 3;\n\t\t\t    continue;\n\t\tcase '\"':   STRCPY(d, \"quote\");\n\t\t\t    d += 5;\n\t\t\t    continue;\n\t\tcase '*':   *d++ = '.';\n\t\t\t    break;\n\t\tcase '?':   *d++ = '.';\n\t\t\t    continue;\n\t\tcase '$':\n\t\tcase '.':\n\t\tcase '~':   *d++ = '\\\\';\n\t\t\t    break;\n\t    }\n\n\t    // Replace \"^x\" by \"CTRL-X\". Don't do this for \"^_\" to make\n\t    // \":help i_^_CTRL-D\" work.\n\t    // Insert '-' before and after \"CTRL-X\" when applicable.\n\t    if (*s < ' ' || (*s == '^' && s[1] && (ASCII_ISALPHA(s[1])\n\t\t\t   || vim_strchr((char_u *)\"?@[\\\\]^\", s[1]) != NULL)))\n\t    {\n\t\tif (d > IObuff && d[-1] != '_' && d[-1] != '\\\\')\n\t\t    *d++ = '_';\t\t// prepend a '_' to make x_CTRL-x\n\t\tSTRCPY(d, \"CTRL-\");\n\t\td += 5;\n\t\tif (*s < ' ')\n\t\t{\n#ifdef EBCDIC\n\t\t    *d++ = CtrlChar(*s);\n#else\n\t\t    *d++ = *s + '@';\n#endif\n\t\t    if (d[-1] == '\\\\')\n\t\t\t*d++ = '\\\\';\t// double a backslash\n\t\t}\n\t\telse\n\t\t    *d++ = *++s;\n\t\tif (s[1] != NUL && s[1] != '_')\n\t\t    *d++ = '_';\t\t// append a '_'\n\t\tcontinue;\n\t    }\n\t    else if (*s == '^')\t\t// \"^\" or \"CTRL-^\" or \"^_\"\n\t\t*d++ = '\\\\';\n\n\t    // Insert a backslash before a backslash after a slash, for search\n\t    // pattern tags: \"/\\|\" --> \"/\\\\|\".\n\t    else if (s[0] == '\\\\' && s[1] != '\\\\'\n\t\t\t\t\t       && *arg == '/' && s == arg + 1)\n\t\t*d++ = '\\\\';\n\n\t    // \"CTRL-\\_\" -> \"CTRL-\\\\_\" to avoid the special meaning of \"\\_\" in\n\t    // \"CTRL-\\_CTRL-N\"\n\t    if (STRNICMP(s, \"CTRL-\\\\_\", 7) == 0)\n\t    {\n\t\tSTRCPY(d, \"CTRL-\\\\\\\\\");\n\t\td += 7;\n\t\ts += 6;\n\t    }\n\n\t    *d++ = *s;\n\n\t    // If tag contains \"({\" or \"([\", tag terminates at the \"(\".\n\t    // This is for help on functions, e.g.: abs({expr}).\n\t    if (*s == '(' && (s[1] == '{' || s[1] =='['))\n\t\tbreak;\n\n\t    // If tag starts with ', toss everything after a second '. Fixes\n\t    // CTRL-] on 'option'. (would include the trailing '.').\n\t    if (*s == '\\'' && s > arg && *arg == '\\'')\n\t\tbreak;\n\t    // Also '{' and '}'.\n\t    if (*s == '}' && s > arg && *arg == '{')\n\t\tbreak;\n\t  }\n\t  *d = NUL;\n\n\t  if (*IObuff == '`')\n\t  {\n\t      if (d > IObuff + 2 && d[-1] == '`')\n\t      {\n\t\t  // remove the backticks from `command`\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-2] = NUL;\n\t      }\n\t      else if (d > IObuff + 3 && d[-2] == '`' && d[-1] == ',')\n\t      {\n\t\t  // remove the backticks and comma from `command`,\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-3] = NUL;\n\t      }\n\t      else if (d > IObuff + 4 && d[-3] == '`'\n\t\t\t\t\t     && d[-2] == '\\\\' && d[-1] == '.')\n\t      {\n\t\t  // remove the backticks and dot from `command`\\.\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-4] = NUL;\n\t      }\n\t  }\n\t}\n    }\n\n    *matches = (char_u **)\"\";\n    *num_matches = 0;\n    flags = TAG_HELP | TAG_REGEXP | TAG_NAMES | TAG_VERBOSE | TAG_NO_TAGFUNC;\n    if (keep_lang)\n\tflags |= TAG_KEEP_LANG;\n    if (find_tags(IObuff, num_matches, matches, flags, (int)MAXCOL, NULL) == OK\n\t    && *num_matches > 0)\n    {\n\t// Sort the matches found on the heuristic number that is after the\n\t// tag name.\n\tqsort((void *)*matches, (size_t)*num_matches,\n\t\t\t\t\t      sizeof(char_u *), help_compare);\n\t// Delete more than TAG_MANY to reduce the size of the listing.\n\twhile (*num_matches > TAG_MANY)\n\t    vim_free((*matches)[--*num_matches]);\n    }\n    return OK;\n}",
        "description": "vim is susceptible to a Heap-based Buffer Overflow vulnerability.",
        "commit": "output: \"A buffer overflow vulnerability was identified in the handling of long help arguments. The solution implemented involves using snprintf() to prevent such overflows.\""
    },
    {
        "cwe": "CWE-776",
        "func_name": "libexpat/externalParEntProcessor",
        "score": 0.7746165990829468,
        "func_before": "static enum XML_Error PTRCALL\nexternalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: /* start == end */\n    default:\n      break;\n    }\n  }\n  /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.\n     However, when parsing an external subset, doProlog will not accept a BOM\n     as valid, and report a syntax error, so we have to skip the BOM\n  */\n  else if (tok == XML_TOK_BOM) {\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}",
        "func_after": "static enum XML_Error PTRCALL\nexternalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: /* start == end */\n    default:\n      break;\n    }\n  }\n  /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.\n     However, when parsing an external subset, doProlog will not accept a BOM\n     as valid, and report a syntax error, so we have to skip the BOM\n  */\n  else if (tok == XML_TOK_BOM) {\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);\n}",
        "description": "In versions of libexpat prior to 2.2.8, maliciously crafted XML input could cause the parser to prematurely transition from DTD parsing to document parsing. Subsequently, invoking functions such as XML_GetCurrentLineNumber or XML_GetCurrentColumnNumber led to a heap-based buffer over-read.",
        "commit": "output: \"Denial of service vulnerability due to improper handling of internal entities within the XML parsing process.\""
    },
    {
        "cwe": "CWE-611",
        "func_name": "UIKit0/plist_from_xml",
        "score": 0.7676980495452881,
        "func_before": "PLIST_API void plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)\n{\n    xmlDocPtr plist_doc = xmlParseMemory(plist_xml, length);\n    xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n\n    xml_to_node(root_node, plist);\n    xmlFreeDoc(plist_doc);\n}",
        "func_after": "PLIST_API void plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)\n{\n    /* CVE-2013-0339: disable external entity loading to prevent XXE vulnerability */\n    xmlSetExternalEntityLoader(plist_xml_external_entity_loader);\n\n    /* read XML from memory and disable network access for security reasons */\n    xmlDocPtr plist_doc = xmlReadMemory(plist_xml, length, \"plist_from_xml:memory\", NULL, XML_PARSE_NONET);\n    if (plist_doc) {\n        xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n\n        xml_to_node(root_node, plist);\n        xmlFreeDoc(plist_doc);\n    }\n}",
        "description": "A vulnerability has been identified in the UIKit0 libplist library version 1.12, affecting the plist_from_xml function within the XML Handler component. This issue involves improper handling of XML external entity references, which could lead to potential security risks. To address this, a patch with the identifier c086cb139af7c82845f6d565e636073ff4b37440 has been developed. It is advised to apply this patch to mitigate the vulnerability.",
        "commit": "A security vulnerability related to XML property lists (plists) has been identified, where an attacker could potentially exploit a limited but possible XML External Entity (XXE) flaw. This vulnerability arises from the use of a specially crafted XML file that leverages a custom Document Type Definition (DTD) with an external entity reference. Such a file, when processed by the plistutil tool, could facilitate unauthorized GET requests to arbitrary URLs or disclose local files. Although practical exploitation is constrained, the issue has been addressed to enhance security. This vulnerability is analogous to CVE-2013-0339 observed in libxml2 and aligns with CWE-827. The vulnerability was reported by Lo\u00efc B\u00e9nis from calypt.com."
    }
]