[
    {
        "cwe": "CWE-20",
        "func_name": "torvalds/cifs_lookup",
        "score": 0.7936105728149414,
        "func_before": "struct dentry *\ncifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,\n\t    struct nameidata *nd)\n{\n\tint xid;\n\tint rc = 0; /* to get around spurious gcc warning, set to zero here */\n\t__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;\n\t__u16 fileHandle = 0;\n\tbool posix_open = false;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct cifsFileInfo *cfile;\n\tstruct inode *newInode = NULL;\n\tchar *full_path = NULL;\n\tstruct file *filp;\n\n\txid = GetXid();\n\n\tcFYI(1, \"parent inode = 0x%p name is: %s and dentry = 0x%p\",\n\t      parent_dir_inode, direntry->d_name.name, direntry);\n\n\t/* check whether path exists */\n\n\tcifs_sb = CIFS_SB(parent_dir_inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tFreeXid(xid);\n\t\treturn (struct dentry *)tlink;\n\t}\n\tpTcon = tlink_tcon(tlink);\n\n\t/*\n\t * Don't allow the separator character in a path component.\n\t * The VFS will not allow \"/\", but \"\\\" is allowed by posix.\n\t */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {\n\t\tint i;\n\t\tfor (i = 0; i < direntry->d_name.len; i++)\n\t\t\tif (direntry->d_name.name[i] == '\\\\') {\n\t\t\t\tcFYI(1, \"Invalid file name\");\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t}\n\n\t/*\n\t * O_EXCL: optimize away the lookup, but don't hash the dentry. Let\n\t * the VFS handle the create.\n\t */\n\tif (nd && (nd->flags & LOOKUP_EXCL)) {\n\t\td_instantiate(direntry, NULL);\n\t\trc = 0;\n\t\tgoto lookup_out;\n\t}\n\n\t/* can not grab the rename sem here since it would\n\tdeadlock in the cases (beginning of sys_rename itself)\n\tin which we already have the sb rename sem */\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto lookup_out;\n\t}\n\n\tif (direntry->d_inode != NULL) {\n\t\tcFYI(1, \"non-NULL inode in lookup\");\n\t} else {\n\t\tcFYI(1, \"NULL inode in lookup\");\n\t}\n\tcFYI(1, \"Full path: %s inode = 0x%p\", full_path, direntry->d_inode);\n\n\t/* Posix open is only called (at lookup time) for file create now.\n\t * For opens (rather than creates), because we do not know if it\n\t * is a file or directory yet, and current Samba no longer allows\n\t * us to do posix open on dirs, we could end up wasting an open call\n\t * on what turns out to be a dir. For file opens, we wait to call posix\n\t * open till cifs_open.  It could be added here (lookup) in the future\n\t * but the performance tradeoff of the extra network request when EISDIR\n\t * or EACCES is returned would have to be weighed against the 50%\n\t * reduction in network traffic in the other paths.\n\t */\n\tif (pTcon->unix_ext) {\n\t\tif (nd && !(nd->flags & LOOKUP_DIRECTORY) &&\n\t\t     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&\n\t\t     (nd->intent.open.file->f_flags & O_CREAT)) {\n\t\t\trc = cifs_posix_open(full_path, &newInode,\n\t\t\t\t\tparent_dir_inode->i_sb,\n\t\t\t\t\tnd->intent.open.create_mode,\n\t\t\t\t\tnd->intent.open.file->f_flags, &oplock,\n\t\t\t\t\t&fileHandle, xid);\n\t\t\t/*\n\t\t\t * The check below works around a bug in POSIX\n\t\t\t * open in samba versions 3.3.1 and earlier where\n\t\t\t * open could incorrectly fail with invalid parameter.\n\t\t\t * If either that or op not supported returned, follow\n\t\t\t * the normal lookup.\n\t\t\t */\n\t\t\tif ((rc == 0) || (rc == -ENOENT))\n\t\t\t\tposix_open = true;\n\t\t\telse if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))\n\t\t\t\tpTcon->broken_posix_open = true;\n\t\t}\n\t\tif (!posix_open)\n\t\t\trc = cifs_get_inode_info_unix(&newInode, full_path,\n\t\t\t\t\t\tparent_dir_inode->i_sb, xid);\n\t} else\n\t\trc = cifs_get_inode_info(&newInode, full_path, NULL,\n\t\t\t\tparent_dir_inode->i_sb, xid, NULL);\n\n\tif ((rc == 0) && (newInode != NULL)) {\n\t\td_add(direntry, newInode);\n\t\tif (posix_open) {\n\t\t\tfilp = lookup_instantiate_filp(nd, direntry,\n\t\t\t\t\t\t       generic_file_open);\n\t\t\tif (IS_ERR(filp)) {\n\t\t\t\trc = PTR_ERR(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\n\t\t\tcfile = cifs_new_fileinfo(fileHandle, filp, tlink,\n\t\t\t\t\t\t  oplock);\n\t\t\tif (cfile == NULL) {\n\t\t\t\tfput(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t\t}\n\t\t/* since paths are not looked up by component - the parent\n\t\t   directories are presumed to be good here */\n\t\trenew_parental_timestamps(direntry);\n\n\t} else if (rc == -ENOENT) {\n\t\trc = 0;\n\t\tdirentry->d_time = jiffies;\n\t\td_add(direntry, NULL);\n\t/*\tif it was once a directory (but how can we tell?) we could do\n\t\tshrink_dcache_parent(direntry); */\n\t} else if (rc != -EACCES) {\n\t\tcERROR(1, \"Unexpected lookup error %d\", rc);\n\t\t/* We special case check for Access Denied - since that\n\t\tis a common return code */\n\t}\n\nlookup_out:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\tFreeXid(xid);\n\treturn ERR_PTR(rc);\n}",
        "func_after": "struct dentry *\ncifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,\n\t    struct nameidata *nd)\n{\n\tint xid;\n\tint rc = 0; /* to get around spurious gcc warning, set to zero here */\n\t__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;\n\t__u16 fileHandle = 0;\n\tbool posix_open = false;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct cifsFileInfo *cfile;\n\tstruct inode *newInode = NULL;\n\tchar *full_path = NULL;\n\tstruct file *filp;\n\n\txid = GetXid();\n\n\tcFYI(1, \"parent inode = 0x%p name is: %s and dentry = 0x%p\",\n\t      parent_dir_inode, direntry->d_name.name, direntry);\n\n\t/* check whether path exists */\n\n\tcifs_sb = CIFS_SB(parent_dir_inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tFreeXid(xid);\n\t\treturn (struct dentry *)tlink;\n\t}\n\tpTcon = tlink_tcon(tlink);\n\n\t/*\n\t * Don't allow the separator character in a path component.\n\t * The VFS will not allow \"/\", but \"\\\" is allowed by posix.\n\t */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {\n\t\tint i;\n\t\tfor (i = 0; i < direntry->d_name.len; i++)\n\t\t\tif (direntry->d_name.name[i] == '\\\\') {\n\t\t\t\tcFYI(1, \"Invalid file name\");\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t}\n\n\t/*\n\t * O_EXCL: optimize away the lookup, but don't hash the dentry. Let\n\t * the VFS handle the create.\n\t */\n\tif (nd && (nd->flags & LOOKUP_EXCL)) {\n\t\td_instantiate(direntry, NULL);\n\t\trc = 0;\n\t\tgoto lookup_out;\n\t}\n\n\t/* can not grab the rename sem here since it would\n\tdeadlock in the cases (beginning of sys_rename itself)\n\tin which we already have the sb rename sem */\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto lookup_out;\n\t}\n\n\tif (direntry->d_inode != NULL) {\n\t\tcFYI(1, \"non-NULL inode in lookup\");\n\t} else {\n\t\tcFYI(1, \"NULL inode in lookup\");\n\t}\n\tcFYI(1, \"Full path: %s inode = 0x%p\", full_path, direntry->d_inode);\n\n\t/* Posix open is only called (at lookup time) for file create now.\n\t * For opens (rather than creates), because we do not know if it\n\t * is a file or directory yet, and current Samba no longer allows\n\t * us to do posix open on dirs, we could end up wasting an open call\n\t * on what turns out to be a dir. For file opens, we wait to call posix\n\t * open till cifs_open.  It could be added here (lookup) in the future\n\t * but the performance tradeoff of the extra network request when EISDIR\n\t * or EACCES is returned would have to be weighed against the 50%\n\t * reduction in network traffic in the other paths.\n\t */\n\tif (pTcon->unix_ext) {\n\t\tif (nd && !(nd->flags & LOOKUP_DIRECTORY) &&\n\t\t     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&\n\t\t     (nd->intent.open.file->f_flags & O_CREAT)) {\n\t\t\trc = cifs_posix_open(full_path, &newInode,\n\t\t\t\t\tparent_dir_inode->i_sb,\n\t\t\t\t\tnd->intent.open.create_mode,\n\t\t\t\t\tnd->intent.open.file->f_flags, &oplock,\n\t\t\t\t\t&fileHandle, xid);\n\t\t\t/*\n\t\t\t * The check below works around a bug in POSIX\n\t\t\t * open in samba versions 3.3.1 and earlier where\n\t\t\t * open could incorrectly fail with invalid parameter.\n\t\t\t * If either that or op not supported returned, follow\n\t\t\t * the normal lookup.\n\t\t\t */\n\t\t\tswitch (rc) {\n\t\t\tcase 0:\n\t\t\t\t/*\n\t\t\t\t * The server may allow us to open things like\n\t\t\t\t * FIFOs, but the client isn't set up to deal\n\t\t\t\t * with that. If it's not a regular file, just\n\t\t\t\t * close it and proceed as if it were a normal\n\t\t\t\t * lookup.\n\t\t\t\t */\n\t\t\t\tif (newInode && !S_ISREG(newInode->i_mode)) {\n\t\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase -ENOENT:\n\t\t\t\tposix_open = true;\n\t\t\tcase -EOPNOTSUPP:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpTcon->broken_posix_open = true;\n\t\t\t}\n\t\t}\n\t\tif (!posix_open)\n\t\t\trc = cifs_get_inode_info_unix(&newInode, full_path,\n\t\t\t\t\t\tparent_dir_inode->i_sb, xid);\n\t} else\n\t\trc = cifs_get_inode_info(&newInode, full_path, NULL,\n\t\t\t\tparent_dir_inode->i_sb, xid, NULL);\n\n\tif ((rc == 0) && (newInode != NULL)) {\n\t\td_add(direntry, newInode);\n\t\tif (posix_open) {\n\t\t\tfilp = lookup_instantiate_filp(nd, direntry,\n\t\t\t\t\t\t       generic_file_open);\n\t\t\tif (IS_ERR(filp)) {\n\t\t\t\trc = PTR_ERR(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\n\t\t\tcfile = cifs_new_fileinfo(fileHandle, filp, tlink,\n\t\t\t\t\t\t  oplock);\n\t\t\tif (cfile == NULL) {\n\t\t\t\tfput(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t\t}\n\t\t/* since paths are not looked up by component - the parent\n\t\t   directories are presumed to be good here */\n\t\trenew_parental_timestamps(direntry);\n\n\t} else if (rc == -ENOENT) {\n\t\trc = 0;\n\t\tdirentry->d_time = jiffies;\n\t\td_add(direntry, NULL);\n\t/*\tif it was once a directory (but how can we tell?) we could do\n\t\tshrink_dcache_parent(direntry); */\n\t} else if (rc != -EACCES) {\n\t\tcERROR(1, \"Unexpected lookup error %d\", rc);\n\t\t/* We special case check for Access Denied - since that\n\t\tis a common return code */\n\t}\n\nlookup_out:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\tFreeXid(xid);\n\treturn ERR_PTR(rc);\n}",
        "description": "The `cifs_lookup` function in the CIFS directory handling module of the Linux kernel, prior to version 3.2.10, permits local users to trigger a denial of service (OOPS) condition by attempting to access a special file, such as a FIFO.",
        "commit": "The CIFS code attempts to open files during lookup under specific conditions. However, if the file turned out to be a FIFO or another special file type, the open file handle would be leaked, resulting in a dentry reference count mismatch and causing an oops error during unmount. This issue has been resolved by ensuring that the file handle on the server is closed if the file is not a regular file. Additionally, the code has been refactored to use a switch statement instead of a complex if-else structure."
    },
    {
        "cwe": "CWE-834",
        "func_name": "ImageMagick/ReadPDBImage",
        "score": 0.7808892726898193,
        "func_before": "static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  unsigned char\n    attributes,\n    tag[3];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  PDBImage\n    pdb_image;\n\n  PDBInfo\n    pdb_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    num_pad_bytes,\n    one,\n    packets;\n\n  ssize_t\n    count,\n    img_offset,\n    comment_offset = 0,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PDB image file.\n  */\n  count=ReadBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n  if (count != sizeof(pdb_info.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_info.attributes=(short) ReadBlobMSBShort(image);\n  pdb_info.version=(short) ReadBlobMSBShort(image);\n  pdb_info.create_time=ReadBlobMSBLong(image);\n  pdb_info.modify_time=ReadBlobMSBLong(image);\n  pdb_info.archive_time=ReadBlobMSBLong(image);\n  pdb_info.modify_number=ReadBlobMSBLong(image);\n  pdb_info.application_info=ReadBlobMSBLong(image);\n  pdb_info.sort_info=ReadBlobMSBLong(image);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.type);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.id);\n  pdb_info.seed=ReadBlobMSBLong(image);\n  pdb_info.next_record=ReadBlobMSBLong(image);\n  pdb_info.number_records=(short) ReadBlobMSBShort(image);\n  if ((memcmp(pdb_info.type,\"vIMG\",4) != 0) ||\n      (memcmp(pdb_info.id,\"View\",4) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (pdb_info.next_record != 0)\n    ThrowReaderException(CoderError,\"MultipleRecordListNotSupported\");\n  /*\n    Read record header.\n  */\n  img_offset=(ssize_t) ReadBlobMSBSignedLong(image);\n  attributes=(unsigned char) ReadBlobByte(image);\n  (void) attributes;\n  count=ReadBlob(image,3,(unsigned char *) tag);\n  if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x00\",3) != 0)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  if (pdb_info.number_records > 1)\n    {\n      comment_offset=(ssize_t) ReadBlobMSBSignedLong(image);\n      attributes=(unsigned char) ReadBlobByte(image);\n      count=ReadBlob(image,3,(unsigned char *) tag);\n      if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x01\",3) != 0)\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  num_pad_bytes = (size_t) (img_offset - TellBlob( image ));\n  while (num_pad_bytes-- != 0)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  /*\n    Read image header.\n  */\n  count=ReadBlob(image,sizeof(pdb_image.name),(unsigned char *) pdb_image.name);\n  if (count != sizeof(pdb_image.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_image.version=ReadBlobByte(image);\n  pdb_image.type=(unsigned char) (ReadBlobByte(image));\n  pdb_image.reserved_1=ReadBlobMSBLong(image);\n  pdb_image.note=ReadBlobMSBLong(image);\n  pdb_image.x_last=(short) ReadBlobMSBShort(image);\n  pdb_image.y_last=(short) ReadBlobMSBShort(image);\n  pdb_image.reserved_2=ReadBlobMSBLong(image);\n  pdb_image.x_anchor=ReadBlobMSBShort(image);\n  pdb_image.y_anchor=ReadBlobMSBShort(image);\n  pdb_image.width=(short) ReadBlobMSBShort(image);\n  pdb_image.height=(short) ReadBlobMSBShort(image);\n  /*\n    Initialize image structure.\n  */\n  image->columns=(size_t) pdb_image.width;\n  image->rows=(size_t) pdb_image.height;\n  image->depth=8;\n  image->storage_class=PseudoClass;\n  bits_per_pixel=pdb_image.type == 0 ? 2UL : pdb_image.type == 2 ? 4UL : 1UL;\n  one=1;\n  if (AcquireImageColormap(image,one << bits_per_pixel,exception) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  packets=(bits_per_pixel*image->columns+7)/8;\n  pixels=(unsigned char *) AcquireQuantumMemory(packets+257UL,image->rows*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  switch (pdb_image.version & 0x07) \n  {\n    case 0:\n    {\n      image->compression=NoCompression;\n      count=(ssize_t) ReadBlob(image,packets*image->rows,pixels);\n      break;\n    }\n    case 1:\n    {\n      image->compression=RLECompression;\n      if (!DecodeImage(image,pixels,packets*image->rows))\n        {\n          pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n          ThrowReaderException(CorruptImageError,\"RLEDecoderError\");\n        }\n      break;\n    }\n    default:\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowReaderException(CorruptImageError,\n        \"UnrecognizedImageCompressionType\");\n    }\n  }\n  p=pixels;\n  switch (bits_per_pixel)\n  {\n    case 1:\n    {\n      int\n        bit;\n\n      /*\n        Read 1-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=(Quantum) (*p & (0x80 >> bit) ? 0x00 : 0x01);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    case 2:\n    {\n      /*\n        Read 2-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns-3; x+=4)\n        {\n          index=ConstrainColormapIndex(image,3UL-((*p >> 6) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 4) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 2) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    case 4:\n    {\n      /*\n        Read 4-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns-1; x+=2)\n        {\n          index=ConstrainColormapIndex(image,15UL-((*p >> 4) & 0x0f),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,15UL-((*p) & 0x0f),exception);\n          SetPixelIndex(image,index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    default:\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (pdb_info.number_records > 1)\n    {\n      char\n        *comment;\n\n      int\n        c;\n\n      register char\n        *p;\n\n      size_t\n        length;\n\n      num_pad_bytes = (size_t) (comment_offset - TellBlob( image ));\n      while (num_pad_bytes--) ReadBlobByte( image );\n\n      /*\n        Read comment.\n      */\n      c=ReadBlobByte(image);\n      length=MagickPathExtent;\n      comment=AcquireString((char *) NULL);\n      for (p=comment; c != EOF; p++)\n      {\n        if ((size_t) (p-comment+MagickPathExtent) >= length)\n          {\n            *p='\\0';\n            length<<=1;\n            length+=MagickPathExtent;\n            comment=(char *) ResizeQuantumMemory(comment,length+MagickPathExtent,\n              sizeof(*comment));\n            if (comment == (char *) NULL)\n              break;\n            p=comment+strlen(comment);\n          }\n        *p=c;\n        c=ReadBlobByte(image);\n      }\n      *p='\\0';\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      (void) SetImageProperty(image,\"comment\",comment,exception);\n      comment=DestroyString(comment);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func_after": "static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  unsigned char\n    attributes,\n    tag[3];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  PDBImage\n    pdb_image;\n\n  PDBInfo\n    pdb_info;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    num_pad_bytes,\n    one,\n    packets;\n\n  ssize_t\n    count,\n    img_offset,\n    comment_offset = 0,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PDB image file.\n  */\n  count=ReadBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n  if (count != sizeof(pdb_info.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_info.attributes=(short) ReadBlobMSBShort(image);\n  pdb_info.version=(short) ReadBlobMSBShort(image);\n  pdb_info.create_time=ReadBlobMSBLong(image);\n  pdb_info.modify_time=ReadBlobMSBLong(image);\n  pdb_info.archive_time=ReadBlobMSBLong(image);\n  pdb_info.modify_number=ReadBlobMSBLong(image);\n  pdb_info.application_info=ReadBlobMSBLong(image);\n  pdb_info.sort_info=ReadBlobMSBLong(image);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.type);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.id);\n  pdb_info.seed=ReadBlobMSBLong(image);\n  pdb_info.next_record=ReadBlobMSBLong(image);\n  pdb_info.number_records=(short) ReadBlobMSBShort(image);\n  if ((memcmp(pdb_info.type,\"vIMG\",4) != 0) ||\n      (memcmp(pdb_info.id,\"View\",4) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (pdb_info.next_record != 0)\n    ThrowReaderException(CoderError,\"MultipleRecordListNotSupported\");\n  /*\n    Read record header.\n  */\n  img_offset=(ssize_t) ReadBlobMSBSignedLong(image);\n  attributes=(unsigned char) ReadBlobByte(image);\n  (void) attributes;\n  count=ReadBlob(image,3,(unsigned char *) tag);\n  if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x00\",3) != 0)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  if (pdb_info.number_records > 1)\n    {\n      comment_offset=(ssize_t) ReadBlobMSBSignedLong(image);\n      attributes=(unsigned char) ReadBlobByte(image);\n      count=ReadBlob(image,3,(unsigned char *) tag);\n      if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x01\",3) != 0)\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  num_pad_bytes = (size_t) (img_offset - TellBlob( image ));\n  while (num_pad_bytes-- != 0)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  /*\n    Read image header.\n  */\n  count=ReadBlob(image,sizeof(pdb_image.name),(unsigned char *) pdb_image.name);\n  if (count != sizeof(pdb_image.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_image.version=ReadBlobByte(image);\n  pdb_image.type=(unsigned char) (ReadBlobByte(image));\n  pdb_image.reserved_1=ReadBlobMSBLong(image);\n  pdb_image.note=ReadBlobMSBLong(image);\n  pdb_image.x_last=(short) ReadBlobMSBShort(image);\n  pdb_image.y_last=(short) ReadBlobMSBShort(image);\n  pdb_image.reserved_2=ReadBlobMSBLong(image);\n  pdb_image.x_anchor=ReadBlobMSBShort(image);\n  pdb_image.y_anchor=ReadBlobMSBShort(image);\n  pdb_image.width=(short) ReadBlobMSBShort(image);\n  pdb_image.height=(short) ReadBlobMSBShort(image);\n  /*\n    Initialize image structure.\n  */\n  image->columns=(size_t) pdb_image.width;\n  image->rows=(size_t) pdb_image.height;\n  image->depth=8;\n  image->storage_class=PseudoClass;\n  bits_per_pixel=pdb_image.type == 0 ? 2UL : pdb_image.type == 2 ? 4UL : 1UL;\n  one=1;\n  if (AcquireImageColormap(image,one << bits_per_pixel,exception) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  packets=(bits_per_pixel*image->columns+7)/8;\n  pixels=(unsigned char *) AcquireQuantumMemory(packets+257UL,image->rows*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  switch (pdb_image.version & 0x07) \n  {\n    case 0:\n    {\n      image->compression=NoCompression;\n      count=(ssize_t) ReadBlob(image,packets*image->rows,pixels);\n      break;\n    }\n    case 1:\n    {\n      image->compression=RLECompression;\n      if (!DecodeImage(image,pixels,packets*image->rows))\n        {\n          pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n          ThrowReaderException(CorruptImageError,\"RLEDecoderError\");\n        }\n      break;\n    }\n    default:\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowReaderException(CorruptImageError,\n        \"UnrecognizedImageCompressionType\");\n    }\n  }\n  p=pixels;\n  switch (bits_per_pixel)\n  {\n    case 1:\n    {\n      int\n        bit;\n\n      /*\n        Read 1-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=(Quantum) (*p & (0x80 >> bit) ? 0x00 : 0x01);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    case 2:\n    {\n      /*\n        Read 2-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns-3; x+=4)\n        {\n          index=ConstrainColormapIndex(image,3UL-((*p >> 6) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 4) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 2) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,3UL-((*p) & 0x03),exception);\n          SetPixelIndex(image,index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    case 4:\n    {\n      /*\n        Read 4-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns-1; x+=2)\n        {\n          index=ConstrainColormapIndex(image,15UL-((*p >> 4) & 0x0f),exception);\n          SetPixelIndex(image,index,q);\n          q+=GetPixelChannels(image);\n          index=ConstrainColormapIndex(image,15UL-((*p) & 0x0f),exception);\n          SetPixelIndex(image,index,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image,exception);\n      break;\n    }\n    default:\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (pdb_info.number_records > 1)\n    {\n      char\n        *comment;\n\n      int\n        c;\n\n      register char\n        *p;\n\n      size_t\n        length;\n\n      num_pad_bytes = (size_t) (comment_offset - TellBlob( image ));\n      while (num_pad_bytes-- != 0)\n      {\n        int\n          c;\n\n        c=ReadBlobByte(image);\n        if (c == EOF)\n          break;\n      }\n\n      /*\n        Read comment.\n      */\n      c=ReadBlobByte(image);\n      length=MagickPathExtent;\n      comment=AcquireString((char *) NULL);\n      for (p=comment; c != EOF; p++)\n      {\n        if ((size_t) (p-comment+MagickPathExtent) >= length)\n          {\n            *p='\\0';\n            length<<=1;\n            length+=MagickPathExtent;\n            comment=(char *) ResizeQuantumMemory(comment,length+MagickPathExtent,\n              sizeof(*comment));\n            if (comment == (char *) NULL)\n              break;\n            p=comment+strlen(comment);\n          }\n        *p=c;\n        c=ReadBlobByte(image);\n      }\n      *p='\\0';\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      (void) SetImageProperty(image,\"comment\",comment,exception);\n      comment=DestroyString(comment);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "description": "In ImageMagick versions prior to 7.0.6-2, a CPU exhaustion vulnerability exists within the function responsible for reading PDB images. This flaw enables attackers to exploit it, leading to a denial of service condition.",
        "commit": "It was discovered that ImageMagick, a popular image processing library, contains a vulnerability related to improper handling of certain image formats, potentially leading to buffer overflows or other memory corruption issues."
    },
    {
        "cwe": "CWE-754",
        "func_name": "torvalds/copy_params",
        "score": 0.7897304892539978,
        "func_before": "static int copy_params(struct dm_ioctl __user *user, struct dm_ioctl *param_kernel,\n\t\t       int ioctl_flags, struct dm_ioctl **param, int *param_flags)\n{\n\tstruct dm_ioctl *dmi;\n\tint secure_data;\n\tconst size_t minimum_data_size = offsetof(struct dm_ioctl, data);\n\n\t/* check_version() already copied version from userspace, avoid TOCTOU */\n\tif (copy_from_user((char *)param_kernel + sizeof(param_kernel->version),\n\t\t\t   (char __user *)user + sizeof(param_kernel->version),\n\t\t\t   minimum_data_size - sizeof(param_kernel->version)))\n\t\treturn -EFAULT;\n\n\tif (param_kernel->data_size < minimum_data_size) {\n\t\tDMERR(\"Invalid data size in the ioctl structure: %u\",\n\t\t      param_kernel->data_size);\n\t\treturn -EINVAL;\n\t}\n\n\tsecure_data = param_kernel->flags & DM_SECURE_DATA_FLAG;\n\n\t*param_flags = secure_data ? DM_WIPE_BUFFER : 0;\n\n\tif (ioctl_flags & IOCTL_FLAGS_NO_PARAMS) {\n\t\tdmi = param_kernel;\n\t\tdmi->data_size = minimum_data_size;\n\t\tgoto data_copied;\n\t}\n\n\t/*\n\t * Use __GFP_HIGH to avoid low memory issues when a device is\n\t * suspended and the ioctl is needed to resume it.\n\t * Use kmalloc() rather than vmalloc() when we can.\n\t */\n\tdmi = NULL;\n\tdmi = kvmalloc(param_kernel->data_size, GFP_NOIO | __GFP_HIGH);\n\n\tif (!dmi) {\n\t\tif (secure_data && clear_user(user, param_kernel->data_size))\n\t\t\treturn -EFAULT;\n\t\treturn -ENOMEM;\n\t}\n\n\t*param_flags |= DM_PARAMS_MALLOC;\n\n\t/* Copy from param_kernel (which was already copied from user) */\n\tmemcpy(dmi, param_kernel, minimum_data_size);\n\n\tif (copy_from_user(&dmi->data, (char __user *)user + minimum_data_size,\n\t\t\t   param_kernel->data_size - minimum_data_size))\n\t\tgoto bad;\ndata_copied:\n\t/* Wipe the user buffer so we do not return it to userspace */\n\tif (secure_data && clear_user(user, param_kernel->data_size))\n\t\tgoto bad;\n\n\t*param = dmi;\n\treturn 0;\n\nbad:\n\tfree_params(dmi, param_kernel->data_size, *param_flags);\n\n\treturn -EFAULT;\n}",
        "func_after": "static int copy_params(struct dm_ioctl __user *user, struct dm_ioctl *param_kernel,\n\t\t       int ioctl_flags, struct dm_ioctl **param, int *param_flags)\n{\n\tstruct dm_ioctl *dmi;\n\tint secure_data;\n\tconst size_t minimum_data_size = offsetof(struct dm_ioctl, data);\n\n\t/* check_version() already copied version from userspace, avoid TOCTOU */\n\tif (copy_from_user((char *)param_kernel + sizeof(param_kernel->version),\n\t\t\t   (char __user *)user + sizeof(param_kernel->version),\n\t\t\t   minimum_data_size - sizeof(param_kernel->version)))\n\t\treturn -EFAULT;\n\n\tif (unlikely(param_kernel->data_size < minimum_data_size) ||\n\t    unlikely(param_kernel->data_size > DM_MAX_TARGETS * DM_MAX_TARGET_PARAMS)) {\n\t\tDMERR(\"Invalid data size in the ioctl structure: %u\",\n\t\t      param_kernel->data_size);\n\t\treturn -EINVAL;\n\t}\n\n\tsecure_data = param_kernel->flags & DM_SECURE_DATA_FLAG;\n\n\t*param_flags = secure_data ? DM_WIPE_BUFFER : 0;\n\n\tif (ioctl_flags & IOCTL_FLAGS_NO_PARAMS) {\n\t\tdmi = param_kernel;\n\t\tdmi->data_size = minimum_data_size;\n\t\tgoto data_copied;\n\t}\n\n\t/*\n\t * Use __GFP_HIGH to avoid low memory issues when a device is\n\t * suspended and the ioctl is needed to resume it.\n\t * Use kmalloc() rather than vmalloc() when we can.\n\t */\n\tdmi = NULL;\n\tdmi = kvmalloc(param_kernel->data_size, GFP_NOIO | __GFP_HIGH);\n\n\tif (!dmi) {\n\t\tif (secure_data && clear_user(user, param_kernel->data_size))\n\t\t\treturn -EFAULT;\n\t\treturn -ENOMEM;\n\t}\n\n\t*param_flags |= DM_PARAMS_MALLOC;\n\n\t/* Copy from param_kernel (which was already copied from user) */\n\tmemcpy(dmi, param_kernel, minimum_data_size);\n\n\tif (copy_from_user(&dmi->data, (char __user *)user + minimum_data_size,\n\t\t\t   param_kernel->data_size - minimum_data_size))\n\t\tgoto bad;\ndata_copied:\n\t/* Wipe the user buffer so we do not return it to userspace */\n\tif (secure_data && clear_user(user, param_kernel->data_size))\n\t\tgoto bad;\n\n\t*param = dmi;\n\treturn 0;\n\nbad:\n\tfree_params(dmi, param_kernel->data_size, *param_flags);\n\n\treturn -EFAULT;\n}",
        "description": "The `dm_table_create` function in the device mapper module of the Linux kernel, up to version 6.7.4, may allocate more than `INT_MAX` bytes during the `alloc_targets` process due to a lack of validation for the `struct dm_ioctl.target_count`. This oversight can lead to a system crash.",
        "commit": "The `kvmalloc` function generates a warning when the requested size exceeds `INT_MAX`. This issue was identified during automated syscall testing. To prevent such warnings, the commit imposes a limit of 1,048,576 targets and restricts the parameter area size to 1,073,741,824 bytes."
    },
    {
        "cwe": "CWE-665",
        "func_name": "torvalds/__skb_flow_dissect",
        "score": 0.7901017665863037,
        "func_before": "bool __skb_flow_dissect(const struct sk_buff *skb,\n\t\t\tstruct flow_dissector *flow_dissector,\n\t\t\tvoid *target_container,\n\t\t\tvoid *data, __be16 proto, int nhoff, int hlen)\n{\n\tstruct flow_dissector_key_control *key_control;\n\tstruct flow_dissector_key_basic *key_basic;\n\tstruct flow_dissector_key_addrs *key_addrs;\n\tstruct flow_dissector_key_ports *key_ports;\n\tstruct flow_dissector_key_tags *key_tags;\n\tstruct flow_dissector_key_keyid *key_keyid;\n\tu8 ip_proto = 0;\n\n\tif (!data) {\n\t\tdata = skb->data;\n\t\tproto = skb->protocol;\n\t\tnhoff = skb_network_offset(skb);\n\t\thlen = skb_headlen(skb);\n\t}\n\n\t/* It is ensured by skb_flow_dissector_init() that control key will\n\t * be always present.\n\t */\n\tkey_control = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_CONTROL,\n\t\t\t\t\t\ttarget_container);\n\n\t/* It is ensured by skb_flow_dissector_init() that basic key will\n\t * be always present.\n\t */\n\tkey_basic = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t      FLOW_DISSECTOR_KEY_BASIC,\n\t\t\t\t\t      target_container);\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct ethhdr *eth = eth_hdr(skb);\n\t\tstruct flow_dissector_key_eth_addrs *key_eth_addrs;\n\n\t\tkey_eth_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t  FLOW_DISSECTOR_KEY_ETH_ADDRS,\n\t\t\t\t\t\t\t  target_container);\n\t\tmemcpy(key_eth_addrs, &eth->h_dest, sizeof(*key_eth_addrs));\n\t}\n\nagain:\n\tswitch (proto) {\n\tcase htons(ETH_P_IP): {\n\t\tconst struct iphdr *iph;\n\t\tstruct iphdr _iph;\nip:\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph || iph->ihl < 5)\n\t\t\treturn false;\n\t\tnhoff += iph->ihl * 4;\n\n\t\tip_proto = iph->protocol;\n\t\tif (ip_is_fragment(iph))\n\t\t\tip_proto = 0;\n\n\t\tif (!skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t FLOW_DISSECTOR_KEY_IPV4_ADDRS))\n\t\t\tbreak;\n\n\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t      FLOW_DISSECTOR_KEY_IPV4_ADDRS, target_container);\n\t\tmemcpy(&key_addrs->v4addrs, &iph->saddr,\n\t\t       sizeof(key_addrs->v4addrs));\n\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_IPV6): {\n\t\tconst struct ipv6hdr *iph;\n\t\tstruct ipv6hdr _iph;\n\t\t__be32 flow_label;\n\nipv6:\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph)\n\t\t\treturn false;\n\n\t\tip_proto = iph->nexthdr;\n\t\tnhoff += sizeof(struct ipv6hdr);\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_IPV6_ADDRS)) {\n\t\t\tstruct flow_dissector_key_ipv6_addrs *key_ipv6_addrs;\n\n\t\t\tkey_ipv6_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t   FLOW_DISSECTOR_KEY_IPV6_ADDRS,\n\t\t\t\t\t\t\t\t   target_container);\n\n\t\t\tmemcpy(key_ipv6_addrs, &iph->saddr, sizeof(*key_ipv6_addrs));\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t}\n\n\t\tflow_label = ip6_flowlabel(iph);\n\t\tif (flow_label) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\tFLOW_DISSECTOR_KEY_FLOW_LABEL)) {\n\t\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_FLOW_LABEL,\n\t\t\t\t\t\t\t\t     target_container);\n\t\t\t\tkey_tags->flow_label = ntohl(flow_label);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_8021AD):\n\tcase htons(ETH_P_8021Q): {\n\t\tconst struct vlan_hdr *vlan;\n\t\tstruct vlan_hdr _vlan;\n\n\t\tvlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);\n\t\tif (!vlan)\n\t\t\treturn false;\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_VLANID)) {\n\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_VLANID,\n\t\t\t\t\t\t\t     target_container);\n\n\t\t\tkey_tags->vlan_id = skb_vlan_tag_get_id(skb);\n\t\t}\n\n\t\tproto = vlan->h_vlan_encapsulated_proto;\n\t\tnhoff += sizeof(*vlan);\n\t\tgoto again;\n\t}\n\tcase htons(ETH_P_PPP_SES): {\n\t\tstruct {\n\t\t\tstruct pppoe_hdr hdr;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\t\tproto = hdr->proto;\n\t\tnhoff += PPPOE_SES_HLEN;\n\t\tswitch (proto) {\n\t\tcase htons(PPP_IP):\n\t\t\tgoto ip;\n\t\tcase htons(PPP_IPV6):\n\t\t\tgoto ipv6;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\tcase htons(ETH_P_TIPC): {\n\t\tstruct {\n\t\t\t__be32 pre[3];\n\t\t\t__be32 srcnode;\n\t\t} *hdr, _hdr;\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\t\tkey_basic->n_proto = proto;\n\t\tkey_control->thoff = (u16)nhoff;\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_TIPC_ADDRS)) {\n\t\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_TIPC_ADDRS,\n\t\t\t\t\t\t\t      target_container);\n\t\t\tkey_addrs->tipcaddrs.srcnode = hdr->srcnode;\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;\n\t\t}\n\t\treturn true;\n\t}\n\n\tcase htons(ETH_P_MPLS_UC):\n\tcase htons(ETH_P_MPLS_MC): {\n\t\tstruct mpls_label *hdr, _hdr[2];\nmpls:\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,\n\t\t\t\t\t   hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\n\t\tif ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>\n\t\t     MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_MPLS_ENTROPY)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_MPLS_ENTROPY,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = hdr[1].entry &\n\t\t\t\t\thtonl(MPLS_LS_LABEL_MASK);\n\t\t\t}\n\n\t\t\tkey_basic->n_proto = proto;\n\t\t\tkey_basic->ip_proto = ip_proto;\n\t\t\tkey_control->thoff = (u16)nhoff;\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tcase htons(ETH_P_FCOE):\n\t\tkey_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);\n\t\t/* fall through */\n\tdefault:\n\t\treturn false;\n\t}\n\nip_proto_again:\n\tswitch (ip_proto) {\n\tcase IPPROTO_GRE: {\n\t\tstruct gre_hdr {\n\t\t\t__be16 flags;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\t\t/*\n\t\t * Only look inside GRE if version zero and no\n\t\t * routing\n\t\t */\n\t\tif (hdr->flags & (GRE_VERSION | GRE_ROUTING))\n\t\t\tbreak;\n\n\t\tproto = hdr->proto;\n\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_CSUM)\n\t\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_KEY) {\n\t\t\tconst __be32 *keyid;\n\t\t\t__be32 _keyid;\n\n\t\t\tkeyid = __skb_header_pointer(skb, nhoff, sizeof(_keyid),\n\t\t\t\t\t\t     data, hlen, &_keyid);\n\n\t\t\tif (!keyid)\n\t\t\t\treturn false;\n\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_GRE_KEYID)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_GRE_KEYID,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = *keyid;\n\t\t\t}\n\t\t\tnhoff += 4;\n\t\t}\n\t\tif (hdr->flags & GRE_SEQ)\n\t\t\tnhoff += 4;\n\t\tif (proto == htons(ETH_P_TEB)) {\n\t\t\tconst struct ethhdr *eth;\n\t\t\tstruct ethhdr _eth;\n\n\t\t\teth = __skb_header_pointer(skb, nhoff,\n\t\t\t\t\t\t   sizeof(_eth),\n\t\t\t\t\t\t   data, hlen, &_eth);\n\t\t\tif (!eth)\n\t\t\t\treturn false;\n\t\t\tproto = eth->h_proto;\n\t\t\tnhoff += sizeof(*eth);\n\t\t}\n\t\tgoto again;\n\t}\n\tcase NEXTHDR_HOP:\n\tcase NEXTHDR_ROUTING:\n\tcase NEXTHDR_DEST: {\n\t\tu8 _opthdr[2], *opthdr;\n\n\t\tif (proto != htons(ETH_P_IPV6))\n\t\t\tbreak;\n\n\t\topthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),\n\t\t\t\t\t      data, hlen, &_opthdr);\n\t\tif (!opthdr)\n\t\t\treturn false;\n\n\t\tip_proto = opthdr[0];\n\t\tnhoff += (opthdr[1] + 1) << 3;\n\n\t\tgoto ip_proto_again;\n\t}\n\tcase IPPROTO_IPIP:\n\t\tproto = htons(ETH_P_IP);\n\t\tgoto ip;\n\tcase IPPROTO_IPV6:\n\t\tproto = htons(ETH_P_IPV6);\n\t\tgoto ipv6;\n\tcase IPPROTO_MPLS:\n\t\tproto = htons(ETH_P_MPLS_UC);\n\t\tgoto mpls;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkey_basic->n_proto = proto;\n\tkey_basic->ip_proto = ip_proto;\n\tkey_control->thoff = (u16)nhoff;\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_PORTS)) {\n\t\tkey_ports = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_PORTS,\n\t\t\t\t\t\t      target_container);\n\t\tkey_ports->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,\n\t\t\t\t\t\t\tdata, hlen);\n\t}\n\n\treturn true;\n}",
        "func_after": "bool __skb_flow_dissect(const struct sk_buff *skb,\n\t\t\tstruct flow_dissector *flow_dissector,\n\t\t\tvoid *target_container,\n\t\t\tvoid *data, __be16 proto, int nhoff, int hlen)\n{\n\tstruct flow_dissector_key_control *key_control;\n\tstruct flow_dissector_key_basic *key_basic;\n\tstruct flow_dissector_key_addrs *key_addrs;\n\tstruct flow_dissector_key_ports *key_ports;\n\tstruct flow_dissector_key_tags *key_tags;\n\tstruct flow_dissector_key_keyid *key_keyid;\n\tu8 ip_proto = 0;\n\tbool ret = false;\n\n\tif (!data) {\n\t\tdata = skb->data;\n\t\tproto = skb->protocol;\n\t\tnhoff = skb_network_offset(skb);\n\t\thlen = skb_headlen(skb);\n\t}\n\n\t/* It is ensured by skb_flow_dissector_init() that control key will\n\t * be always present.\n\t */\n\tkey_control = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_CONTROL,\n\t\t\t\t\t\ttarget_container);\n\n\t/* It is ensured by skb_flow_dissector_init() that basic key will\n\t * be always present.\n\t */\n\tkey_basic = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t      FLOW_DISSECTOR_KEY_BASIC,\n\t\t\t\t\t      target_container);\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct ethhdr *eth = eth_hdr(skb);\n\t\tstruct flow_dissector_key_eth_addrs *key_eth_addrs;\n\n\t\tkey_eth_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t  FLOW_DISSECTOR_KEY_ETH_ADDRS,\n\t\t\t\t\t\t\t  target_container);\n\t\tmemcpy(key_eth_addrs, &eth->h_dest, sizeof(*key_eth_addrs));\n\t}\n\nagain:\n\tswitch (proto) {\n\tcase htons(ETH_P_IP): {\n\t\tconst struct iphdr *iph;\n\t\tstruct iphdr _iph;\nip:\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph || iph->ihl < 5)\n\t\t\tgoto out_bad;\n\t\tnhoff += iph->ihl * 4;\n\n\t\tip_proto = iph->protocol;\n\t\tif (ip_is_fragment(iph))\n\t\t\tip_proto = 0;\n\n\t\tif (!skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t FLOW_DISSECTOR_KEY_IPV4_ADDRS))\n\t\t\tbreak;\n\n\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t      FLOW_DISSECTOR_KEY_IPV4_ADDRS, target_container);\n\t\tmemcpy(&key_addrs->v4addrs, &iph->saddr,\n\t\t       sizeof(key_addrs->v4addrs));\n\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_IPV6): {\n\t\tconst struct ipv6hdr *iph;\n\t\tstruct ipv6hdr _iph;\n\t\t__be32 flow_label;\n\nipv6:\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph)\n\t\t\tgoto out_bad;\n\n\t\tip_proto = iph->nexthdr;\n\t\tnhoff += sizeof(struct ipv6hdr);\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_IPV6_ADDRS)) {\n\t\t\tstruct flow_dissector_key_ipv6_addrs *key_ipv6_addrs;\n\n\t\t\tkey_ipv6_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t   FLOW_DISSECTOR_KEY_IPV6_ADDRS,\n\t\t\t\t\t\t\t\t   target_container);\n\n\t\t\tmemcpy(key_ipv6_addrs, &iph->saddr, sizeof(*key_ipv6_addrs));\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t}\n\n\t\tflow_label = ip6_flowlabel(iph);\n\t\tif (flow_label) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\tFLOW_DISSECTOR_KEY_FLOW_LABEL)) {\n\t\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_FLOW_LABEL,\n\t\t\t\t\t\t\t\t     target_container);\n\t\t\t\tkey_tags->flow_label = ntohl(flow_label);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_8021AD):\n\tcase htons(ETH_P_8021Q): {\n\t\tconst struct vlan_hdr *vlan;\n\t\tstruct vlan_hdr _vlan;\n\n\t\tvlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);\n\t\tif (!vlan)\n\t\t\tgoto out_bad;\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_VLANID)) {\n\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_VLANID,\n\t\t\t\t\t\t\t     target_container);\n\n\t\t\tkey_tags->vlan_id = skb_vlan_tag_get_id(skb);\n\t\t}\n\n\t\tproto = vlan->h_vlan_encapsulated_proto;\n\t\tnhoff += sizeof(*vlan);\n\t\tgoto again;\n\t}\n\tcase htons(ETH_P_PPP_SES): {\n\t\tstruct {\n\t\t\tstruct pppoe_hdr hdr;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\tgoto out_bad;\n\t\tproto = hdr->proto;\n\t\tnhoff += PPPOE_SES_HLEN;\n\t\tswitch (proto) {\n\t\tcase htons(PPP_IP):\n\t\t\tgoto ip;\n\t\tcase htons(PPP_IPV6):\n\t\t\tgoto ipv6;\n\t\tdefault:\n\t\t\tgoto out_bad;\n\t\t}\n\t}\n\tcase htons(ETH_P_TIPC): {\n\t\tstruct {\n\t\t\t__be32 pre[3];\n\t\t\t__be32 srcnode;\n\t\t} *hdr, _hdr;\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\tgoto out_bad;\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_TIPC_ADDRS)) {\n\t\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_TIPC_ADDRS,\n\t\t\t\t\t\t\t      target_container);\n\t\t\tkey_addrs->tipcaddrs.srcnode = hdr->srcnode;\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;\n\t\t}\n\t\tgoto out_good;\n\t}\n\n\tcase htons(ETH_P_MPLS_UC):\n\tcase htons(ETH_P_MPLS_MC): {\n\t\tstruct mpls_label *hdr, _hdr[2];\nmpls:\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,\n\t\t\t\t\t   hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\tgoto out_bad;\n\n\t\tif ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>\n\t\t     MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_MPLS_ENTROPY)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_MPLS_ENTROPY,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = hdr[1].entry &\n\t\t\t\t\thtonl(MPLS_LS_LABEL_MASK);\n\t\t\t}\n\n\t\t\tgoto out_good;\n\t\t}\n\n\t\tgoto out_good;\n\t}\n\n\tcase htons(ETH_P_FCOE):\n\t\tkey_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);\n\t\t/* fall through */\n\tdefault:\n\t\tgoto out_bad;\n\t}\n\nip_proto_again:\n\tswitch (ip_proto) {\n\tcase IPPROTO_GRE: {\n\t\tstruct gre_hdr {\n\t\t\t__be16 flags;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\tgoto out_bad;\n\t\t/*\n\t\t * Only look inside GRE if version zero and no\n\t\t * routing\n\t\t */\n\t\tif (hdr->flags & (GRE_VERSION | GRE_ROUTING))\n\t\t\tbreak;\n\n\t\tproto = hdr->proto;\n\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_CSUM)\n\t\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_KEY) {\n\t\t\tconst __be32 *keyid;\n\t\t\t__be32 _keyid;\n\n\t\t\tkeyid = __skb_header_pointer(skb, nhoff, sizeof(_keyid),\n\t\t\t\t\t\t     data, hlen, &_keyid);\n\n\t\t\tif (!keyid)\n\t\t\t\tgoto out_bad;\n\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_GRE_KEYID)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_GRE_KEYID,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = *keyid;\n\t\t\t}\n\t\t\tnhoff += 4;\n\t\t}\n\t\tif (hdr->flags & GRE_SEQ)\n\t\t\tnhoff += 4;\n\t\tif (proto == htons(ETH_P_TEB)) {\n\t\t\tconst struct ethhdr *eth;\n\t\t\tstruct ethhdr _eth;\n\n\t\t\teth = __skb_header_pointer(skb, nhoff,\n\t\t\t\t\t\t   sizeof(_eth),\n\t\t\t\t\t\t   data, hlen, &_eth);\n\t\t\tif (!eth)\n\t\t\t\tgoto out_bad;\n\t\t\tproto = eth->h_proto;\n\t\t\tnhoff += sizeof(*eth);\n\t\t}\n\t\tgoto again;\n\t}\n\tcase NEXTHDR_HOP:\n\tcase NEXTHDR_ROUTING:\n\tcase NEXTHDR_DEST: {\n\t\tu8 _opthdr[2], *opthdr;\n\n\t\tif (proto != htons(ETH_P_IPV6))\n\t\t\tbreak;\n\n\t\topthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),\n\t\t\t\t\t      data, hlen, &_opthdr);\n\t\tif (!opthdr)\n\t\t\tgoto out_bad;\n\n\t\tip_proto = opthdr[0];\n\t\tnhoff += (opthdr[1] + 1) << 3;\n\n\t\tgoto ip_proto_again;\n\t}\n\tcase IPPROTO_IPIP:\n\t\tproto = htons(ETH_P_IP);\n\t\tgoto ip;\n\tcase IPPROTO_IPV6:\n\t\tproto = htons(ETH_P_IPV6);\n\t\tgoto ipv6;\n\tcase IPPROTO_MPLS:\n\t\tproto = htons(ETH_P_MPLS_UC);\n\t\tgoto mpls;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_PORTS)) {\n\t\tkey_ports = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_PORTS,\n\t\t\t\t\t\t      target_container);\n\t\tkey_ports->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,\n\t\t\t\t\t\t\tdata, hlen);\n\t}\n\nout_good:\n\tret = true;\n\nout_bad:\n\tkey_basic->n_proto = proto;\n\tkey_basic->ip_proto = ip_proto;\n\tkey_control->thoff = (u16)nhoff;\n\n\treturn ret;\n}",
        "description": "The `__skb_flow_dissect` function in the Linux kernel, prior to version 4.3, does not guarantee the initialization of certain protocol fields (`n_proto`, `ip_proto`, and `thoff`). This oversight enables remote attackers to exploit a single crafted MPLS packet to trigger a denial of service (system crash) or potentially execute arbitrary code.",
        "commit": "The vulnerability involves a function responsible for dissecting network flows, where instead of returning immediately upon encountering a parsing failure, it jumps to cleanup code. This approach ensures that even in the event of a failure, some protocol values are set in the key_control structure, although there may still be valid information in the key_tags that was established before the error occurred."
    },
    {
        "cwe": "CWE-400",
        "func_name": "kernel/tcp_prune_ofo_queue",
        "score": 0.7773391604423523,
        "func_before": "static bool tcp_prune_ofo_queue(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct rb_node *node, *prev;\n\n\tif (RB_EMPTY_ROOT(&tp->out_of_order_queue))\n\t\treturn false;\n\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_OFOPRUNED);\n\tnode = &tp->ooo_last_skb->rbnode;\n\tdo {\n\t\tprev = rb_prev(node);\n\t\trb_erase(node, &tp->out_of_order_queue);\n\t\ttcp_drop(sk, rb_to_skb(node));\n\t\tsk_mem_reclaim(sk);\n\t\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf &&\n\t\t    !tcp_under_memory_pressure(sk))\n\t\t\tbreak;\n\t\tnode = prev;\n\t} while (node);\n\ttp->ooo_last_skb = rb_to_skb(prev);\n\n\t/* Reset SACK state.  A conforming SACK implementation will\n\t * do the same at a timeout based retransmit.  When a connection\n\t * is in a sad state like this, we care only about integrity\n\t * of the connection not performance.\n\t */\n\tif (tp->rx_opt.sack_ok)\n\t\ttcp_sack_reset(&tp->rx_opt);\n\treturn true;\n}",
        "func_after": "static bool tcp_prune_ofo_queue(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct rb_node *node, *prev;\n\tint goal;\n\n\tif (RB_EMPTY_ROOT(&tp->out_of_order_queue))\n\t\treturn false;\n\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_OFOPRUNED);\n\tgoal = sk->sk_rcvbuf >> 3;\n\tnode = &tp->ooo_last_skb->rbnode;\n\tdo {\n\t\tprev = rb_prev(node);\n\t\trb_erase(node, &tp->out_of_order_queue);\n\t\tgoal -= rb_to_skb(node)->truesize;\n\t\ttcp_drop(sk, rb_to_skb(node));\n\t\tif (!prev || goal <= 0) {\n\t\t\tsk_mem_reclaim(sk);\n\t\t\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf &&\n\t\t\t    !tcp_under_memory_pressure(sk))\n\t\t\t\tbreak;\n\t\t\tgoal = sk->sk_rcvbuf >> 3;\n\t\t}\n\t\tnode = prev;\n\t} while (node);\n\ttp->ooo_last_skb = rb_to_skb(prev);\n\n\t/* Reset SACK state.  A conforming SACK implementation will\n\t * do the same at a timeout based retransmit.  When a connection\n\t * is in a sad state like this, we care only about integrity\n\t * of the connection not performance.\n\t */\n\tif (tp->rx_opt.sack_ok)\n\t\ttcp_sack_reset(&tp->rx_opt);\n\treturn true;\n}",
        "description": "Linux kernel versions 4.9 and later can be coerced into making highly resource-intensive calls to functions responsible for collapsing and pruning out-of-order queues for every incoming packet, potentially leading to a denial of service.",
        "commit": "Malicious peers can exploit a vulnerability by injecting small packets into the out-of-order queue, leading to repeated and costly calls to functions such as `tcp_collapse_ofo_queue()` and `tcp_prune_ofo_queue()` for each incoming packet. When the out-of-order queue's default memory limit is set to 6MB, it can hold approximately 7000 nodes. This patch series aims to reduce CPU usage sufficiently to mitigate the severity of the attack. Future enhancements may include disconnecting or blackholing confirmed malicious flows."
    }
]