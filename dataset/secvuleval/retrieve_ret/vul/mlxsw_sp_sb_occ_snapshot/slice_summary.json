[
    {
        "cwe": "CWE-122",
        "func_name": "vim/find_help_tags",
        "score": 0.7283862233161926,
        "func_before": "int\nfind_help_tags(\n    char_u\t*arg,\n    int\t\t*num_matches,\n    char_u\t***matches,\n    int\t\tkeep_lang)\n{\n    char_u\t*s, *d;\n    int\t\ti;\n    // Specific tags that either have a specific replacement or won't go\n    // through the generic rules.\n    static char *(except_tbl[][2]) = {\n\t{\"*\",\t\t\"star\"},\n\t{\"g*\",\t\t\"gstar\"},\n\t{\"[*\",\t\t\"[star\"},\n\t{\"]*\",\t\t\"]star\"},\n\t{\":*\",\t\t\":star\"},\n\t{\"/*\",\t\t\"/star\"},\n\t{\"/\\\\*\",\t\"/\\\\\\\\star\"},\n\t{\"\\\"*\",\t\t\"quotestar\"},\n\t{\"**\",\t\t\"starstar\"},\n\t{\"cpo-*\",\t\"cpo-star\"},\n\t{\"/\\\\(\\\\)\",\t\"/\\\\\\\\(\\\\\\\\)\"},\n\t{\"/\\\\%(\\\\)\",\t\"/\\\\\\\\%(\\\\\\\\)\"},\n\t{\"?\",\t\t\"?\"},\n\t{\"??\",\t\t\"??\"},\n\t{\":?\",\t\t\":?\"},\n\t{\"?<CR>\",\t\"?<CR>\"},\n\t{\"g?\",\t\t\"g?\"},\n\t{\"g?g?\",\t\"g?g?\"},\n\t{\"g??\",\t\t\"g??\"},\n\t{\"-?\",\t\t\"-?\"},\n\t{\"q?\",\t\t\"q?\"},\n\t{\"v_g?\",\t\"v_g?\"},\n\t{\"/\\\\?\",\t\"/\\\\\\\\?\"},\n\t{\"/\\\\z(\\\\)\",\t\"/\\\\\\\\z(\\\\\\\\)\"},\n\t{\"\\\\=\",\t\t\"\\\\\\\\=\"},\n\t{\":s\\\\=\",\t\":s\\\\\\\\=\"},\n\t{\"[count]\",\t\"\\\\[count]\"},\n\t{\"[quotex]\",\t\"\\\\[quotex]\"},\n\t{\"[range]\",\t\"\\\\[range]\"},\n\t{\":[range]\",\t\":\\\\[range]\"},\n\t{\"[pattern]\",\t\"\\\\[pattern]\"},\n\t{\"\\\\|\",\t\t\"\\\\\\\\bar\"},\n\t{\"\\\\%$\",\t\"/\\\\\\\\%\\\\$\"},\n\t{\"s/\\\\~\",\t\"s/\\\\\\\\\\\\~\"},\n\t{\"s/\\\\U\",\t\"s/\\\\\\\\U\"},\n\t{\"s/\\\\L\",\t\"s/\\\\\\\\L\"},\n\t{\"s/\\\\1\",\t\"s/\\\\\\\\1\"},\n\t{\"s/\\\\2\",\t\"s/\\\\\\\\2\"},\n\t{\"s/\\\\3\",\t\"s/\\\\\\\\3\"},\n\t{\"s/\\\\9\",\t\"s/\\\\\\\\9\"},\n\t{NULL, NULL}\n    };\n    static char *(expr_table[]) = {\"!=?\", \"!~?\", \"<=?\", \"<?\", \"==?\", \"=~?\",\n\t\t\t\t   \">=?\", \">?\", \"is?\", \"isnot?\"};\n    int flags;\n\n    d = IObuff;\t\t    // assume IObuff is long enough!\n    d[0] = NUL;\n\n    if (STRNICMP(arg, \"expr-\", 5) == 0)\n    {\n\t// When the string starting with \"expr-\" and containing '?' and matches\n\t// the table, it is taken literally (but ~ is escaped).  Otherwise '?'\n\t// is recognized as a wildcard.\n\tfor (i = (int)ARRAY_LENGTH(expr_table); --i >= 0; )\n\t    if (STRCMP(arg + 5, expr_table[i]) == 0)\n\t    {\n\t\tint si = 0, di = 0;\n\n\t\tfor (;;)\n\t\t{\n\t\t    if (arg[si] == '~')\n\t\t\td[di++] = '\\\\';\n\t\t    d[di++] = arg[si];\n\t\t    if (arg[si] == NUL)\n\t\t\tbreak;\n\t\t    ++si;\n\t\t}\n\t\tbreak;\n\t    }\n    }\n    else\n    {\n\t// Recognize a few exceptions to the rule.  Some strings that contain\n\t// '*'are changed to \"star\", otherwise '*' is recognized as a wildcard.\n\tfor (i = 0; except_tbl[i][0] != NULL; ++i)\n\t    if (STRCMP(arg, except_tbl[i][0]) == 0)\n\t    {\n\t\tSTRCPY(d, except_tbl[i][1]);\n\t\tbreak;\n\t    }\n    }\n\n    if (d[0] == NUL)\t// no match in table\n    {\n\t// Replace \"\\S\" with \"/\\\\S\", etc.  Otherwise every tag is matched.\n\t// Also replace \"\\%^\" and \"\\%(\", they match every tag too.\n\t// Also \"\\zs\", \"\\z1\", etc.\n\t// Also \"\\@<\", \"\\@=\", \"\\@<=\", etc.\n\t// And also \"\\_$\" and \"\\_^\".\n\tif (arg[0] == '\\\\'\n\t\t&& ((arg[1] != NUL && arg[2] == NUL)\n\t\t    || (vim_strchr((char_u *)\"%_z@\", arg[1]) != NULL\n\t\t\t\t\t\t\t   && arg[2] != NUL)))\n\t{\n\t    STRCPY(d, \"/\\\\\\\\\");\n\t    STRCPY(d + 3, arg + 1);\n\t    // Check for \"/\\\\_$\", should be \"/\\\\_\\$\"\n\t    if (d[3] == '_' && d[4] == '$')\n\t\tSTRCPY(d + 4, \"\\\\$\");\n\t}\n\telse\n\t{\n\t  // Replace:\n\t  // \"[:...:]\" with \"\\[:...:]\"\n\t  // \"[++...]\" with \"\\[++...]\"\n\t  // \"\\{\" with \"\\\\{\"\t\t   -- matching \"} \\}\"\n\t    if ((arg[0] == '[' && (arg[1] == ':'\n\t\t\t || (arg[1] == '+' && arg[2] == '+')))\n\t\t    || (arg[0] == '\\\\' && arg[1] == '{'))\n\t      *d++ = '\\\\';\n\n\t  // If tag starts with \"('\", skip the \"(\". Fixes CTRL-] on ('option'.\n\t  if (*arg == '(' && arg[1] == '\\'')\n\t      arg++;\n\t  for (s = arg; *s; ++s)\n\t  {\n\t    // Replace \"|\" with \"bar\" and '\"' with \"quote\" to match the name of\n\t    // the tags for these commands.\n\t    // Replace \"*\" with \".*\" and \"?\" with \".\" to match command line\n\t    // completion.\n\t    // Insert a backslash before '~', '$' and '.' to avoid their\n\t    // special meaning.\n\t    if (d - IObuff > IOSIZE - 10)\t// getting too long!?\n\t\tbreak;\n\t    switch (*s)\n\t    {\n\t\tcase '|':   STRCPY(d, \"bar\");\n\t\t\t    d += 3;\n\t\t\t    continue;\n\t\tcase '\"':   STRCPY(d, \"quote\");\n\t\t\t    d += 5;\n\t\t\t    continue;\n\t\tcase '*':   *d++ = '.';\n\t\t\t    break;\n\t\tcase '?':   *d++ = '.';\n\t\t\t    continue;\n\t\tcase '$':\n\t\tcase '.':\n\t\tcase '~':   *d++ = '\\\\';\n\t\t\t    break;\n\t    }\n\n\t    // Replace \"^x\" by \"CTRL-X\". Don't do this for \"^_\" to make\n\t    // \":help i_^_CTRL-D\" work.\n\t    // Insert '-' before and after \"CTRL-X\" when applicable.\n\t    if (*s < ' ' || (*s == '^' && s[1] && (ASCII_ISALPHA(s[1])\n\t\t\t   || vim_strchr((char_u *)\"?@[\\\\]^\", s[1]) != NULL)))\n\t    {\n\t\tif (d > IObuff && d[-1] != '_' && d[-1] != '\\\\')\n\t\t    *d++ = '_';\t\t// prepend a '_' to make x_CTRL-x\n\t\tSTRCPY(d, \"CTRL-\");\n\t\td += 5;\n\t\tif (*s < ' ')\n\t\t{\n#ifdef EBCDIC\n\t\t    *d++ = CtrlChar(*s);\n#else\n\t\t    *d++ = *s + '@';\n#endif\n\t\t    if (d[-1] == '\\\\')\n\t\t\t*d++ = '\\\\';\t// double a backslash\n\t\t}\n\t\telse\n\t\t    *d++ = *++s;\n\t\tif (s[1] != NUL && s[1] != '_')\n\t\t    *d++ = '_';\t\t// append a '_'\n\t\tcontinue;\n\t    }\n\t    else if (*s == '^')\t\t// \"^\" or \"CTRL-^\" or \"^_\"\n\t\t*d++ = '\\\\';\n\n\t    // Insert a backslash before a backslash after a slash, for search\n\t    // pattern tags: \"/\\|\" --> \"/\\\\|\".\n\t    else if (s[0] == '\\\\' && s[1] != '\\\\'\n\t\t\t\t\t       && *arg == '/' && s == arg + 1)\n\t\t*d++ = '\\\\';\n\n\t    // \"CTRL-\\_\" -> \"CTRL-\\\\_\" to avoid the special meaning of \"\\_\" in\n\t    // \"CTRL-\\_CTRL-N\"\n\t    if (STRNICMP(s, \"CTRL-\\\\_\", 7) == 0)\n\t    {\n\t\tSTRCPY(d, \"CTRL-\\\\\\\\\");\n\t\td += 7;\n\t\ts += 6;\n\t    }\n\n\t    *d++ = *s;\n\n\t    // If tag contains \"({\" or \"([\", tag terminates at the \"(\".\n\t    // This is for help on functions, e.g.: abs({expr}).\n\t    if (*s == '(' && (s[1] == '{' || s[1] =='['))\n\t\tbreak;\n\n\t    // If tag starts with ', toss everything after a second '. Fixes\n\t    // CTRL-] on 'option'. (would include the trailing '.').\n\t    if (*s == '\\'' && s > arg && *arg == '\\'')\n\t\tbreak;\n\t    // Also '{' and '}'.\n\t    if (*s == '}' && s > arg && *arg == '{')\n\t\tbreak;\n\t  }\n\t  *d = NUL;\n\n\t  if (*IObuff == '`')\n\t  {\n\t      if (d > IObuff + 2 && d[-1] == '`')\n\t      {\n\t\t  // remove the backticks from `command`\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-2] = NUL;\n\t      }\n\t      else if (d > IObuff + 3 && d[-2] == '`' && d[-1] == ',')\n\t      {\n\t\t  // remove the backticks and comma from `command`,\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-3] = NUL;\n\t      }\n\t      else if (d > IObuff + 4 && d[-3] == '`'\n\t\t\t\t\t     && d[-2] == '\\\\' && d[-1] == '.')\n\t      {\n\t\t  // remove the backticks and dot from `command`\\.\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-4] = NUL;\n\t      }\n\t  }\n\t}\n    }\n\n    *matches = (char_u **)\"\";\n    *num_matches = 0;\n    flags = TAG_HELP | TAG_REGEXP | TAG_NAMES | TAG_VERBOSE | TAG_NO_TAGFUNC;\n    if (keep_lang)\n\tflags |= TAG_KEEP_LANG;\n    if (find_tags(IObuff, num_matches, matches, flags, (int)MAXCOL, NULL) == OK\n\t    && *num_matches > 0)\n    {\n\t// Sort the matches found on the heuristic number that is after the\n\t// tag name.\n\tqsort((void *)*matches, (size_t)*num_matches,\n\t\t\t\t\t      sizeof(char_u *), help_compare);\n\t// Delete more than TAG_MANY to reduce the size of the listing.\n\twhile (*num_matches > TAG_MANY)\n\t    vim_free((*matches)[--*num_matches]);\n    }\n    return OK;\n}",
        "func_after": "int\nfind_help_tags(\n    char_u\t*arg,\n    int\t\t*num_matches,\n    char_u\t***matches,\n    int\t\tkeep_lang)\n{\n    char_u\t*s, *d;\n    int\t\ti;\n    // Specific tags that either have a specific replacement or won't go\n    // through the generic rules.\n    static char *(except_tbl[][2]) = {\n\t{\"*\",\t\t\"star\"},\n\t{\"g*\",\t\t\"gstar\"},\n\t{\"[*\",\t\t\"[star\"},\n\t{\"]*\",\t\t\"]star\"},\n\t{\":*\",\t\t\":star\"},\n\t{\"/*\",\t\t\"/star\"},\n\t{\"/\\\\*\",\t\"/\\\\\\\\star\"},\n\t{\"\\\"*\",\t\t\"quotestar\"},\n\t{\"**\",\t\t\"starstar\"},\n\t{\"cpo-*\",\t\"cpo-star\"},\n\t{\"/\\\\(\\\\)\",\t\"/\\\\\\\\(\\\\\\\\)\"},\n\t{\"/\\\\%(\\\\)\",\t\"/\\\\\\\\%(\\\\\\\\)\"},\n\t{\"?\",\t\t\"?\"},\n\t{\"??\",\t\t\"??\"},\n\t{\":?\",\t\t\":?\"},\n\t{\"?<CR>\",\t\"?<CR>\"},\n\t{\"g?\",\t\t\"g?\"},\n\t{\"g?g?\",\t\"g?g?\"},\n\t{\"g??\",\t\t\"g??\"},\n\t{\"-?\",\t\t\"-?\"},\n\t{\"q?\",\t\t\"q?\"},\n\t{\"v_g?\",\t\"v_g?\"},\n\t{\"/\\\\?\",\t\"/\\\\\\\\?\"},\n\t{\"/\\\\z(\\\\)\",\t\"/\\\\\\\\z(\\\\\\\\)\"},\n\t{\"\\\\=\",\t\t\"\\\\\\\\=\"},\n\t{\":s\\\\=\",\t\":s\\\\\\\\=\"},\n\t{\"[count]\",\t\"\\\\[count]\"},\n\t{\"[quotex]\",\t\"\\\\[quotex]\"},\n\t{\"[range]\",\t\"\\\\[range]\"},\n\t{\":[range]\",\t\":\\\\[range]\"},\n\t{\"[pattern]\",\t\"\\\\[pattern]\"},\n\t{\"\\\\|\",\t\t\"\\\\\\\\bar\"},\n\t{\"\\\\%$\",\t\"/\\\\\\\\%\\\\$\"},\n\t{\"s/\\\\~\",\t\"s/\\\\\\\\\\\\~\"},\n\t{\"s/\\\\U\",\t\"s/\\\\\\\\U\"},\n\t{\"s/\\\\L\",\t\"s/\\\\\\\\L\"},\n\t{\"s/\\\\1\",\t\"s/\\\\\\\\1\"},\n\t{\"s/\\\\2\",\t\"s/\\\\\\\\2\"},\n\t{\"s/\\\\3\",\t\"s/\\\\\\\\3\"},\n\t{\"s/\\\\9\",\t\"s/\\\\\\\\9\"},\n\t{NULL, NULL}\n    };\n    static char *(expr_table[]) = {\"!=?\", \"!~?\", \"<=?\", \"<?\", \"==?\", \"=~?\",\n\t\t\t\t   \">=?\", \">?\", \"is?\", \"isnot?\"};\n    int flags;\n\n    d = IObuff;\t\t    // assume IObuff is long enough!\n    d[0] = NUL;\n\n    if (STRNICMP(arg, \"expr-\", 5) == 0)\n    {\n\t// When the string starting with \"expr-\" and containing '?' and matches\n\t// the table, it is taken literally (but ~ is escaped).  Otherwise '?'\n\t// is recognized as a wildcard.\n\tfor (i = (int)ARRAY_LENGTH(expr_table); --i >= 0; )\n\t    if (STRCMP(arg + 5, expr_table[i]) == 0)\n\t    {\n\t\tint si = 0, di = 0;\n\n\t\tfor (;;)\n\t\t{\n\t\t    if (arg[si] == '~')\n\t\t\td[di++] = '\\\\';\n\t\t    d[di++] = arg[si];\n\t\t    if (arg[si] == NUL)\n\t\t\tbreak;\n\t\t    ++si;\n\t\t}\n\t\tbreak;\n\t    }\n    }\n    else\n    {\n\t// Recognize a few exceptions to the rule.  Some strings that contain\n\t// '*'are changed to \"star\", otherwise '*' is recognized as a wildcard.\n\tfor (i = 0; except_tbl[i][0] != NULL; ++i)\n\t    if (STRCMP(arg, except_tbl[i][0]) == 0)\n\t    {\n\t\tSTRCPY(d, except_tbl[i][1]);\n\t\tbreak;\n\t    }\n    }\n\n    if (d[0] == NUL)\t// no match in table\n    {\n\t// Replace \"\\S\" with \"/\\\\S\", etc.  Otherwise every tag is matched.\n\t// Also replace \"\\%^\" and \"\\%(\", they match every tag too.\n\t// Also \"\\zs\", \"\\z1\", etc.\n\t// Also \"\\@<\", \"\\@=\", \"\\@<=\", etc.\n\t// And also \"\\_$\" and \"\\_^\".\n\tif (arg[0] == '\\\\'\n\t\t&& ((arg[1] != NUL && arg[2] == NUL)\n\t\t    || (vim_strchr((char_u *)\"%_z@\", arg[1]) != NULL\n\t\t\t\t\t\t\t   && arg[2] != NUL)))\n\t{\n\t    vim_snprintf((char *)d, IOSIZE, \"/\\\\\\\\%s\", arg + 1);\n\t    // Check for \"/\\\\_$\", should be \"/\\\\_\\$\"\n\t    if (d[3] == '_' && d[4] == '$')\n\t\tSTRCPY(d + 4, \"\\\\$\");\n\t}\n\telse\n\t{\n\t  // Replace:\n\t  // \"[:...:]\" with \"\\[:...:]\"\n\t  // \"[++...]\" with \"\\[++...]\"\n\t  // \"\\{\" with \"\\\\{\"\t\t   -- matching \"} \\}\"\n\t    if ((arg[0] == '[' && (arg[1] == ':'\n\t\t\t || (arg[1] == '+' && arg[2] == '+')))\n\t\t    || (arg[0] == '\\\\' && arg[1] == '{'))\n\t      *d++ = '\\\\';\n\n\t  // If tag starts with \"('\", skip the \"(\". Fixes CTRL-] on ('option'.\n\t  if (*arg == '(' && arg[1] == '\\'')\n\t      arg++;\n\t  for (s = arg; *s; ++s)\n\t  {\n\t    // Replace \"|\" with \"bar\" and '\"' with \"quote\" to match the name of\n\t    // the tags for these commands.\n\t    // Replace \"*\" with \".*\" and \"?\" with \".\" to match command line\n\t    // completion.\n\t    // Insert a backslash before '~', '$' and '.' to avoid their\n\t    // special meaning.\n\t    if (d - IObuff > IOSIZE - 10)\t// getting too long!?\n\t\tbreak;\n\t    switch (*s)\n\t    {\n\t\tcase '|':   STRCPY(d, \"bar\");\n\t\t\t    d += 3;\n\t\t\t    continue;\n\t\tcase '\"':   STRCPY(d, \"quote\");\n\t\t\t    d += 5;\n\t\t\t    continue;\n\t\tcase '*':   *d++ = '.';\n\t\t\t    break;\n\t\tcase '?':   *d++ = '.';\n\t\t\t    continue;\n\t\tcase '$':\n\t\tcase '.':\n\t\tcase '~':   *d++ = '\\\\';\n\t\t\t    break;\n\t    }\n\n\t    // Replace \"^x\" by \"CTRL-X\". Don't do this for \"^_\" to make\n\t    // \":help i_^_CTRL-D\" work.\n\t    // Insert '-' before and after \"CTRL-X\" when applicable.\n\t    if (*s < ' ' || (*s == '^' && s[1] && (ASCII_ISALPHA(s[1])\n\t\t\t   || vim_strchr((char_u *)\"?@[\\\\]^\", s[1]) != NULL)))\n\t    {\n\t\tif (d > IObuff && d[-1] != '_' && d[-1] != '\\\\')\n\t\t    *d++ = '_';\t\t// prepend a '_' to make x_CTRL-x\n\t\tSTRCPY(d, \"CTRL-\");\n\t\td += 5;\n\t\tif (*s < ' ')\n\t\t{\n#ifdef EBCDIC\n\t\t    *d++ = CtrlChar(*s);\n#else\n\t\t    *d++ = *s + '@';\n#endif\n\t\t    if (d[-1] == '\\\\')\n\t\t\t*d++ = '\\\\';\t// double a backslash\n\t\t}\n\t\telse\n\t\t    *d++ = *++s;\n\t\tif (s[1] != NUL && s[1] != '_')\n\t\t    *d++ = '_';\t\t// append a '_'\n\t\tcontinue;\n\t    }\n\t    else if (*s == '^')\t\t// \"^\" or \"CTRL-^\" or \"^_\"\n\t\t*d++ = '\\\\';\n\n\t    // Insert a backslash before a backslash after a slash, for search\n\t    // pattern tags: \"/\\|\" --> \"/\\\\|\".\n\t    else if (s[0] == '\\\\' && s[1] != '\\\\'\n\t\t\t\t\t       && *arg == '/' && s == arg + 1)\n\t\t*d++ = '\\\\';\n\n\t    // \"CTRL-\\_\" -> \"CTRL-\\\\_\" to avoid the special meaning of \"\\_\" in\n\t    // \"CTRL-\\_CTRL-N\"\n\t    if (STRNICMP(s, \"CTRL-\\\\_\", 7) == 0)\n\t    {\n\t\tSTRCPY(d, \"CTRL-\\\\\\\\\");\n\t\td += 7;\n\t\ts += 6;\n\t    }\n\n\t    *d++ = *s;\n\n\t    // If tag contains \"({\" or \"([\", tag terminates at the \"(\".\n\t    // This is for help on functions, e.g.: abs({expr}).\n\t    if (*s == '(' && (s[1] == '{' || s[1] =='['))\n\t\tbreak;\n\n\t    // If tag starts with ', toss everything after a second '. Fixes\n\t    // CTRL-] on 'option'. (would include the trailing '.').\n\t    if (*s == '\\'' && s > arg && *arg == '\\'')\n\t\tbreak;\n\t    // Also '{' and '}'.\n\t    if (*s == '}' && s > arg && *arg == '{')\n\t\tbreak;\n\t  }\n\t  *d = NUL;\n\n\t  if (*IObuff == '`')\n\t  {\n\t      if (d > IObuff + 2 && d[-1] == '`')\n\t      {\n\t\t  // remove the backticks from `command`\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-2] = NUL;\n\t      }\n\t      else if (d > IObuff + 3 && d[-2] == '`' && d[-1] == ',')\n\t      {\n\t\t  // remove the backticks and comma from `command`,\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-3] = NUL;\n\t      }\n\t      else if (d > IObuff + 4 && d[-3] == '`'\n\t\t\t\t\t     && d[-2] == '\\\\' && d[-1] == '.')\n\t      {\n\t\t  // remove the backticks and dot from `command`\\.\n\t\t  mch_memmove(IObuff, IObuff + 1, STRLEN(IObuff));\n\t\t  d[-4] = NUL;\n\t      }\n\t  }\n\t}\n    }\n\n    *matches = (char_u **)\"\";\n    *num_matches = 0;\n    flags = TAG_HELP | TAG_REGEXP | TAG_NAMES | TAG_VERBOSE | TAG_NO_TAGFUNC;\n    if (keep_lang)\n\tflags |= TAG_KEEP_LANG;\n    if (find_tags(IObuff, num_matches, matches, flags, (int)MAXCOL, NULL) == OK\n\t    && *num_matches > 0)\n    {\n\t// Sort the matches found on the heuristic number that is after the\n\t// tag name.\n\tqsort((void *)*matches, (size_t)*num_matches,\n\t\t\t\t\t      sizeof(char_u *), help_compare);\n\t// Delete more than TAG_MANY to reduce the size of the listing.\n\twhile (*num_matches > TAG_MANY)\n\t    vim_free((*matches)[--*num_matches]);\n    }\n    return OK;\n}",
        "description": "vim is susceptible to a Heap-based Buffer Overflow vulnerability.",
        "commit": "output: \"A buffer overflow vulnerability was identified in the handling of long help arguments. The solution implemented involves using snprintf() to prevent such overflows.\""
    },
    {
        "cwe": "CWE-121",
        "func_name": "kernel/chap_server_compute_md5",
        "score": 0.7373350858688354,
        "func_before": "static int chap_server_compute_md5(\n\tstruct iscsi_conn *conn,\n\tstruct iscsi_node_auth *auth,\n\tchar *nr_in_ptr,\n\tchar *nr_out_ptr,\n\tunsigned int *nr_out_len)\n{\n\tunsigned long id;\n\tunsigned char id_as_uchar;\n\tunsigned char digest[MD5_SIGNATURE_SIZE];\n\tunsigned char type, response[MD5_SIGNATURE_SIZE * 2 + 2];\n\tunsigned char identifier[10], *challenge = NULL;\n\tunsigned char *challenge_binhex = NULL;\n\tunsigned char client_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char server_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char chap_n[MAX_CHAP_N_SIZE], chap_r[MAX_RESPONSE_LENGTH];\n\tsize_t compare_len;\n\tstruct iscsi_chap *chap = conn->auth_protocol;\n\tstruct crypto_shash *tfm = NULL;\n\tstruct shash_desc *desc = NULL;\n\tint auth_ret = -1, ret, challenge_len;\n\n\tmemset(identifier, 0, 10);\n\tmemset(chap_n, 0, MAX_CHAP_N_SIZE);\n\tmemset(chap_r, 0, MAX_RESPONSE_LENGTH);\n\tmemset(digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(response, 0, MD5_SIGNATURE_SIZE * 2 + 2);\n\tmemset(client_digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(server_digest, 0, MD5_SIGNATURE_SIZE);\n\n\tchallenge = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge) {\n\t\tpr_err(\"Unable to allocate challenge buffer\\n\");\n\t\tgoto out;\n\t}\n\n\tchallenge_binhex = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge_binhex) {\n\t\tpr_err(\"Unable to allocate challenge_binhex buffer\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Extract CHAP_N.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_N\", MAX_CHAP_N_SIZE, chap_n,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\tif (type == HEX) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Include the terminating NULL in the compare */\n\tcompare_len = strlen(auth->userid) + 1;\n\tif (strncmp(chap_n, auth->userid, compare_len) != 0) {\n\t\tpr_err(\"CHAP_N values do not match!\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_N=%s\\n\", chap_n);\n\t/*\n\t * Extract CHAP_R.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_R\", MAX_RESPONSE_LENGTH, chap_r,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"[server] Got CHAP_R=%s\\n\", chap_r);\n\tchap_string_to_hex(client_digest, chap_r, strlen(chap_r));\n\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\ttfm = NULL;\n\t\tpr_err(\"Unable to allocate struct crypto_shash\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);\n\tif (!desc) {\n\t\tpr_err(\"Unable to allocate struct shash_desc\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, &chap->id, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, (char *)&auth->password,\n\t\t\t\t  strlen(auth->password));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for password\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_finup(desc, chap->challenge,\n\t\t\t\t CHAP_CHALLENGE_LENGTH, server_digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for challenge\\n\");\n\t\tgoto out;\n\t}\n\n\tchap_binaryhex_to_asciihex(response, server_digest, MD5_SIGNATURE_SIZE);\n\tpr_debug(\"[server] MD5 Server Digest: %s\\n\", response);\n\n\tif (memcmp(server_digest, client_digest, MD5_SIGNATURE_SIZE) != 0) {\n\t\tpr_debug(\"[server] MD5 Digests do not match!\\n\\n\");\n\t\tgoto out;\n\t} else\n\t\tpr_debug(\"[server] MD5 Digests match, CHAP connection\"\n\t\t\t\t\" successful.\\n\\n\");\n\t/*\n\t * One way authentication has succeeded, return now if mutual\n\t * authentication is not enabled.\n\t */\n\tif (!auth->authenticate_target) {\n\t\tauth_ret = 0;\n\t\tgoto out;\n\t}\n\t/*\n\t * Get CHAP_I.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_I\", 10, identifier, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_I.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type == HEX)\n\t\tret = kstrtoul(&identifier[2], 0, &id);\n\telse\n\t\tret = kstrtoul(identifier, 0, &id);\n\n\tif (ret < 0) {\n\t\tpr_err(\"kstrtoul() failed for CHAP identifier: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (id > 255) {\n\t\tpr_err(\"chap identifier: %lu greater than 255\\n\", id);\n\t\tgoto out;\n\t}\n\t/*\n\t * RFC 1994 says Identifier is no more than octet (8 bits).\n\t */\n\tpr_debug(\"[server] Got CHAP_I=%lu\\n\", id);\n\t/*\n\t * Get CHAP_C.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_C\", CHAP_CHALLENGE_STR_LEN,\n\t\t\tchallenge, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_C=%s\\n\", challenge);\n\tchallenge_len = chap_string_to_hex(challenge_binhex, challenge,\n\t\t\t\tstrlen(challenge));\n\tif (!challenge_len) {\n\t\tpr_err(\"Unable to convert incoming challenge\\n\");\n\t\tgoto out;\n\t}\n\tif (challenge_len > 1024) {\n\t\tpr_err(\"CHAP_C exceeds maximum binary size of 1024 bytes\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * During mutual authentication, the CHAP_C generated by the\n\t * initiator must not match the original CHAP_C generated by\n\t * the target.\n\t */\n\tif (!memcmp(challenge_binhex, chap->challenge, CHAP_CHALLENGE_LENGTH)) {\n\t\tpr_err(\"initiator CHAP_C matches target CHAP_C, failing\"\n\t\t       \" login attempt\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Generate CHAP_N and CHAP_R for mutual authentication.\n\t */\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* To handle both endiannesses */\n\tid_as_uchar = id;\n\tret = crypto_shash_update(desc, &id_as_uchar, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, auth->password_mutual,\n\t\t\t\t  strlen(auth->password_mutual));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for\"\n\t\t\t\t\" password_mutual\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Convert received challenge to binary hex.\n\t */\n\tret = crypto_shash_finup(desc, challenge_binhex, challenge_len,\n\t\t\t\t digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for ma challenge\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Generate CHAP_N and CHAP_R.\n\t */\n\t*nr_out_len = sprintf(nr_out_ptr, \"CHAP_N=%s\", auth->userid_mutual);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_N=%s\\n\", auth->userid_mutual);\n\t/*\n\t * Convert response from binary hex to ascii hext.\n\t */\n\tchap_binaryhex_to_asciihex(response, digest, MD5_SIGNATURE_SIZE);\n\t*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, \"CHAP_R=0x%s\",\n\t\t\tresponse);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_R=0x%s\\n\", response);\n\tauth_ret = 0;\nout:\n\tkzfree(desc);\n\tif (tfm)\n\t\tcrypto_free_shash(tfm);\n\tkfree(challenge);\n\tkfree(challenge_binhex);\n\treturn auth_ret;\n}",
        "func_after": "static int chap_server_compute_md5(\n\tstruct iscsi_conn *conn,\n\tstruct iscsi_node_auth *auth,\n\tchar *nr_in_ptr,\n\tchar *nr_out_ptr,\n\tunsigned int *nr_out_len)\n{\n\tunsigned long id;\n\tunsigned char id_as_uchar;\n\tunsigned char digest[MD5_SIGNATURE_SIZE];\n\tunsigned char type, response[MD5_SIGNATURE_SIZE * 2 + 2];\n\tunsigned char identifier[10], *challenge = NULL;\n\tunsigned char *challenge_binhex = NULL;\n\tunsigned char client_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char server_digest[MD5_SIGNATURE_SIZE];\n\tunsigned char chap_n[MAX_CHAP_N_SIZE], chap_r[MAX_RESPONSE_LENGTH];\n\tsize_t compare_len;\n\tstruct iscsi_chap *chap = conn->auth_protocol;\n\tstruct crypto_shash *tfm = NULL;\n\tstruct shash_desc *desc = NULL;\n\tint auth_ret = -1, ret, challenge_len;\n\n\tmemset(identifier, 0, 10);\n\tmemset(chap_n, 0, MAX_CHAP_N_SIZE);\n\tmemset(chap_r, 0, MAX_RESPONSE_LENGTH);\n\tmemset(digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(response, 0, MD5_SIGNATURE_SIZE * 2 + 2);\n\tmemset(client_digest, 0, MD5_SIGNATURE_SIZE);\n\tmemset(server_digest, 0, MD5_SIGNATURE_SIZE);\n\n\tchallenge = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge) {\n\t\tpr_err(\"Unable to allocate challenge buffer\\n\");\n\t\tgoto out;\n\t}\n\n\tchallenge_binhex = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\n\tif (!challenge_binhex) {\n\t\tpr_err(\"Unable to allocate challenge_binhex buffer\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Extract CHAP_N.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_N\", MAX_CHAP_N_SIZE, chap_n,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\tif (type == HEX) {\n\t\tpr_err(\"Could not find CHAP_N.\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Include the terminating NULL in the compare */\n\tcompare_len = strlen(auth->userid) + 1;\n\tif (strncmp(chap_n, auth->userid, compare_len) != 0) {\n\t\tpr_err(\"CHAP_N values do not match!\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_N=%s\\n\", chap_n);\n\t/*\n\t * Extract CHAP_R.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_R\", MAX_RESPONSE_LENGTH, chap_r,\n\t\t\t\t&type) < 0) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_R.\\n\");\n\t\tgoto out;\n\t}\n\tif (strlen(chap_r) != MD5_SIGNATURE_SIZE * 2) {\n\t\tpr_err(\"Malformed CHAP_R\\n\");\n\t\tgoto out;\n\t}\n\tif (hex2bin(client_digest, chap_r, MD5_SIGNATURE_SIZE) < 0) {\n\t\tpr_err(\"Malformed CHAP_R\\n\");\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"[server] Got CHAP_R=%s\\n\", chap_r);\n\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\ttfm = NULL;\n\t\tpr_err(\"Unable to allocate struct crypto_shash\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);\n\tif (!desc) {\n\t\tpr_err(\"Unable to allocate struct shash_desc\\n\");\n\t\tgoto out;\n\t}\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, &chap->id, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, (char *)&auth->password,\n\t\t\t\t  strlen(auth->password));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for password\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_finup(desc, chap->challenge,\n\t\t\t\t CHAP_CHALLENGE_LENGTH, server_digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for challenge\\n\");\n\t\tgoto out;\n\t}\n\n\tchap_binaryhex_to_asciihex(response, server_digest, MD5_SIGNATURE_SIZE);\n\tpr_debug(\"[server] MD5 Server Digest: %s\\n\", response);\n\n\tif (memcmp(server_digest, client_digest, MD5_SIGNATURE_SIZE) != 0) {\n\t\tpr_debug(\"[server] MD5 Digests do not match!\\n\\n\");\n\t\tgoto out;\n\t} else\n\t\tpr_debug(\"[server] MD5 Digests match, CHAP connection\"\n\t\t\t\t\" successful.\\n\\n\");\n\t/*\n\t * One way authentication has succeeded, return now if mutual\n\t * authentication is not enabled.\n\t */\n\tif (!auth->authenticate_target) {\n\t\tauth_ret = 0;\n\t\tgoto out;\n\t}\n\t/*\n\t * Get CHAP_I.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_I\", 10, identifier, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_I.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type == HEX)\n\t\tret = kstrtoul(&identifier[2], 0, &id);\n\telse\n\t\tret = kstrtoul(identifier, 0, &id);\n\n\tif (ret < 0) {\n\t\tpr_err(\"kstrtoul() failed for CHAP identifier: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\tif (id > 255) {\n\t\tpr_err(\"chap identifier: %lu greater than 255\\n\", id);\n\t\tgoto out;\n\t}\n\t/*\n\t * RFC 1994 says Identifier is no more than octet (8 bits).\n\t */\n\tpr_debug(\"[server] Got CHAP_I=%lu\\n\", id);\n\t/*\n\t * Get CHAP_C.\n\t */\n\tif (extract_param(nr_in_ptr, \"CHAP_C\", CHAP_CHALLENGE_STR_LEN,\n\t\t\tchallenge, &type) < 0) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (type != HEX) {\n\t\tpr_err(\"Could not find CHAP_C.\\n\");\n\t\tgoto out;\n\t}\n\tchallenge_len = DIV_ROUND_UP(strlen(challenge), 2);\n\tif (!challenge_len) {\n\t\tpr_err(\"Unable to convert incoming challenge\\n\");\n\t\tgoto out;\n\t}\n\tif (challenge_len > 1024) {\n\t\tpr_err(\"CHAP_C exceeds maximum binary size of 1024 bytes\\n\");\n\t\tgoto out;\n\t}\n\tif (hex2bin(challenge_binhex, challenge, challenge_len) < 0) {\n\t\tpr_err(\"Malformed CHAP_C\\n\");\n\t\tgoto out;\n\t}\n\tpr_debug(\"[server] Got CHAP_C=%s\\n\", challenge);\n\t/*\n\t * During mutual authentication, the CHAP_C generated by the\n\t * initiator must not match the original CHAP_C generated by\n\t * the target.\n\t */\n\tif (!memcmp(challenge_binhex, chap->challenge, CHAP_CHALLENGE_LENGTH)) {\n\t\tpr_err(\"initiator CHAP_C matches target CHAP_C, failing\"\n\t\t       \" login attempt\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Generate CHAP_N and CHAP_R for mutual authentication.\n\t */\n\tret = crypto_shash_init(desc);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_init() failed\\n\");\n\t\tgoto out;\n\t}\n\n\t/* To handle both endiannesses */\n\tid_as_uchar = id;\n\tret = crypto_shash_update(desc, &id_as_uchar, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for id\\n\");\n\t\tgoto out;\n\t}\n\n\tret = crypto_shash_update(desc, auth->password_mutual,\n\t\t\t\t  strlen(auth->password_mutual));\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_update() failed for\"\n\t\t\t\t\" password_mutual\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * Convert received challenge to binary hex.\n\t */\n\tret = crypto_shash_finup(desc, challenge_binhex, challenge_len,\n\t\t\t\t digest);\n\tif (ret < 0) {\n\t\tpr_err(\"crypto_shash_finup() failed for ma challenge\\n\");\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Generate CHAP_N and CHAP_R.\n\t */\n\t*nr_out_len = sprintf(nr_out_ptr, \"CHAP_N=%s\", auth->userid_mutual);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_N=%s\\n\", auth->userid_mutual);\n\t/*\n\t * Convert response from binary hex to ascii hext.\n\t */\n\tchap_binaryhex_to_asciihex(response, digest, MD5_SIGNATURE_SIZE);\n\t*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, \"CHAP_R=0x%s\",\n\t\t\tresponse);\n\t*nr_out_len += 1;\n\tpr_debug(\"[server] Sending CHAP_R=0x%s\\n\", response);\n\tauth_ret = 0;\nout:\n\tkzfree(desc);\n\tif (tfm)\n\t\tcrypto_free_shash(tfm);\n\tkfree(challenge);\n\tkfree(challenge_binhex);\n\treturn auth_ret;\n}",
        "description": "A security flaw exists in the chap_server_compute_md5() function within the ISCSI target code of the Linux kernel, where an unauthenticated remote attacker can exploit a stack buffer overflow to overwrite up to 17 bytes of the stack. This vulnerability arises during the processing of an authentication request from an ISCSI initiator. For an attack to be successful, the iSCSI target must be enabled on the victim host. The impact of the overflow varies based on the target's build environment, including the compiler, compile flags, and hardware architecture, potentially leading to a system crash, denial-of-service, or unauthorized access to data exported by the iSCSI target. Although privilege escalation is not conclusively proven, it remains a concern. This vulnerability affects kernel versions 4.18.x, 4.14.x, and 3.10.x.",
        "commit": "Please provide the specific vulnerability knowledge you would like me to abstract and generalize."
    },
    {
        "cwe": "CWE-19",
        "func_name": "torvalds/do_page_fault",
        "score": 0.7383803725242615,
        "func_before": "static int __kprobes do_page_fault(unsigned long addr, unsigned int esr,\n\t\t\t\t   struct pt_regs *regs)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *mm;\n\tint fault, sig, code;\n\tunsigned long vm_flags = VM_READ | VM_WRITE;\n\tunsigned int mm_flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;\n\n\ttsk = current;\n\tmm  = tsk->mm;\n\n\t/* Enable interrupts if they were enabled in the parent context. */\n\tif (interrupts_enabled(regs))\n\t\tlocal_irq_enable();\n\n\t/*\n\t * If we're in an interrupt or have no user context, we must not take\n\t * the fault.\n\t */\n\tif (in_atomic() || !mm)\n\t\tgoto no_context;\n\n\tif (user_mode(regs))\n\t\tmm_flags |= FAULT_FLAG_USER;\n\n\tif (esr & ESR_LNX_EXEC) {\n\t\tvm_flags = VM_EXEC;\n\t} else if ((esr & ESR_EL1_WRITE) && !(esr & ESR_EL1_CM)) {\n\t\tvm_flags = VM_WRITE;\n\t\tmm_flags |= FAULT_FLAG_WRITE;\n\t}\n\n\t/*\n\t * As per x86, we may deadlock here. However, since the kernel only\n\t * validly references user space from well defined areas of the code,\n\t * we can bug out early if this is from code which shouldn't.\n\t */\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tif (!user_mode(regs) && !search_exception_tables(regs->pc))\n\t\t\tgoto no_context;\nretry:\n\t\tdown_read(&mm->mmap_sem);\n\t} else {\n\t\t/*\n\t\t * The above down_read_trylock() might have succeeded in which\n\t\t * case, we'll have missed the might_sleep() from down_read().\n\t\t */\n\t\tmight_sleep();\n#ifdef CONFIG_DEBUG_VM\n\t\tif (!user_mode(regs) && !search_exception_tables(regs->pc))\n\t\t\tgoto no_context;\n#endif\n\t}\n\n\tfault = __do_page_fault(mm, addr, mm_flags, vm_flags, tsk);\n\n\t/*\n\t * If we need to retry but a fatal signal is pending, handle the\n\t * signal first. We do not need to release the mmap_sem because it\n\t * would already be released in __lock_page_or_retry in mm/filemap.c.\n\t */\n\tif ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))\n\t\treturn 0;\n\n\t/*\n\t * Major/minor page fault accounting is only done on the initial\n\t * attempt. If we go through a retry, it is extremely likely that the\n\t * page will be found in page cache at that point.\n\t */\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, addr);\n\tif (mm_flags & FAULT_FLAG_ALLOW_RETRY) {\n\t\tif (fault & VM_FAULT_MAJOR) {\n\t\t\ttsk->maj_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs,\n\t\t\t\t      addr);\n\t\t} else {\n\t\t\ttsk->min_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs,\n\t\t\t\t      addr);\n\t\t}\n\t\tif (fault & VM_FAULT_RETRY) {\n\t\t\t/*\n\t\t\t * Clear FAULT_FLAG_ALLOW_RETRY to avoid any risk of\n\t\t\t * starvation.\n\t\t\t */\n\t\t\tmm_flags &= ~FAULT_FLAG_ALLOW_RETRY;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tup_read(&mm->mmap_sem);\n\n\t/*\n\t * Handle the \"normal\" case first - VM_FAULT_MAJOR / VM_FAULT_MINOR\n\t */\n\tif (likely(!(fault & (VM_FAULT_ERROR | VM_FAULT_BADMAP |\n\t\t\t      VM_FAULT_BADACCESS))))\n\t\treturn 0;\n\n\t/*\n\t * If we are in kernel mode at this point, we have no context to\n\t * handle this fault with.\n\t */\n\tif (!user_mode(regs))\n\t\tgoto no_context;\n\n\tif (fault & VM_FAULT_OOM) {\n\t\t/*\n\t\t * We ran out of memory, call the OOM killer, and return to\n\t\t * userspace (which will retry the fault, or kill us if we got\n\t\t * oom-killed).\n\t\t */\n\t\tpagefault_out_of_memory();\n\t\treturn 0;\n\t}\n\n\tif (fault & VM_FAULT_SIGBUS) {\n\t\t/*\n\t\t * We had some memory, but were unable to successfully fix up\n\t\t * this page fault.\n\t\t */\n\t\tsig = SIGBUS;\n\t\tcode = BUS_ADRERR;\n\t} else {\n\t\t/*\n\t\t * Something tried to access memory that isn't in our memory\n\t\t * map.\n\t\t */\n\t\tsig = SIGSEGV;\n\t\tcode = fault == VM_FAULT_BADACCESS ?\n\t\t\tSEGV_ACCERR : SEGV_MAPERR;\n\t}\n\n\t__do_user_fault(tsk, addr, esr, sig, code, regs);\n\treturn 0;\n\nno_context:\n\t__do_kernel_fault(mm, addr, esr, regs);\n\treturn 0;\n}",
        "func_after": "static int __kprobes do_page_fault(unsigned long addr, unsigned int esr,\n\t\t\t\t   struct pt_regs *regs)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *mm;\n\tint fault, sig, code;\n\tunsigned long vm_flags = VM_READ | VM_WRITE | VM_EXEC;\n\tunsigned int mm_flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;\n\n\ttsk = current;\n\tmm  = tsk->mm;\n\n\t/* Enable interrupts if they were enabled in the parent context. */\n\tif (interrupts_enabled(regs))\n\t\tlocal_irq_enable();\n\n\t/*\n\t * If we're in an interrupt or have no user context, we must not take\n\t * the fault.\n\t */\n\tif (in_atomic() || !mm)\n\t\tgoto no_context;\n\n\tif (user_mode(regs))\n\t\tmm_flags |= FAULT_FLAG_USER;\n\n\tif (esr & ESR_LNX_EXEC) {\n\t\tvm_flags = VM_EXEC;\n\t} else if ((esr & ESR_EL1_WRITE) && !(esr & ESR_EL1_CM)) {\n\t\tvm_flags = VM_WRITE;\n\t\tmm_flags |= FAULT_FLAG_WRITE;\n\t}\n\n\t/*\n\t * As per x86, we may deadlock here. However, since the kernel only\n\t * validly references user space from well defined areas of the code,\n\t * we can bug out early if this is from code which shouldn't.\n\t */\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tif (!user_mode(regs) && !search_exception_tables(regs->pc))\n\t\t\tgoto no_context;\nretry:\n\t\tdown_read(&mm->mmap_sem);\n\t} else {\n\t\t/*\n\t\t * The above down_read_trylock() might have succeeded in which\n\t\t * case, we'll have missed the might_sleep() from down_read().\n\t\t */\n\t\tmight_sleep();\n#ifdef CONFIG_DEBUG_VM\n\t\tif (!user_mode(regs) && !search_exception_tables(regs->pc))\n\t\t\tgoto no_context;\n#endif\n\t}\n\n\tfault = __do_page_fault(mm, addr, mm_flags, vm_flags, tsk);\n\n\t/*\n\t * If we need to retry but a fatal signal is pending, handle the\n\t * signal first. We do not need to release the mmap_sem because it\n\t * would already be released in __lock_page_or_retry in mm/filemap.c.\n\t */\n\tif ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))\n\t\treturn 0;\n\n\t/*\n\t * Major/minor page fault accounting is only done on the initial\n\t * attempt. If we go through a retry, it is extremely likely that the\n\t * page will be found in page cache at that point.\n\t */\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, addr);\n\tif (mm_flags & FAULT_FLAG_ALLOW_RETRY) {\n\t\tif (fault & VM_FAULT_MAJOR) {\n\t\t\ttsk->maj_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs,\n\t\t\t\t      addr);\n\t\t} else {\n\t\t\ttsk->min_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs,\n\t\t\t\t      addr);\n\t\t}\n\t\tif (fault & VM_FAULT_RETRY) {\n\t\t\t/*\n\t\t\t * Clear FAULT_FLAG_ALLOW_RETRY to avoid any risk of\n\t\t\t * starvation.\n\t\t\t */\n\t\t\tmm_flags &= ~FAULT_FLAG_ALLOW_RETRY;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tup_read(&mm->mmap_sem);\n\n\t/*\n\t * Handle the \"normal\" case first - VM_FAULT_MAJOR / VM_FAULT_MINOR\n\t */\n\tif (likely(!(fault & (VM_FAULT_ERROR | VM_FAULT_BADMAP |\n\t\t\t      VM_FAULT_BADACCESS))))\n\t\treturn 0;\n\n\t/*\n\t * If we are in kernel mode at this point, we have no context to\n\t * handle this fault with.\n\t */\n\tif (!user_mode(regs))\n\t\tgoto no_context;\n\n\tif (fault & VM_FAULT_OOM) {\n\t\t/*\n\t\t * We ran out of memory, call the OOM killer, and return to\n\t\t * userspace (which will retry the fault, or kill us if we got\n\t\t * oom-killed).\n\t\t */\n\t\tpagefault_out_of_memory();\n\t\treturn 0;\n\t}\n\n\tif (fault & VM_FAULT_SIGBUS) {\n\t\t/*\n\t\t * We had some memory, but were unable to successfully fix up\n\t\t * this page fault.\n\t\t */\n\t\tsig = SIGBUS;\n\t\tcode = BUS_ADRERR;\n\t} else {\n\t\t/*\n\t\t * Something tried to access memory that isn't in our memory\n\t\t * map.\n\t\t */\n\t\tsig = SIGSEGV;\n\t\tcode = fault == VM_FAULT_BADACCESS ?\n\t\t\tSEGV_ACCERR : SEGV_MAPERR;\n\t}\n\n\t__do_user_fault(tsk, addr, esr, sig, code, regs);\n\treturn 0;\n\nno_context:\n\t__do_kernel_fault(mm, addr, esr, regs);\n\treturn 0;\n}",
        "description": "In the Linux kernel prior to version 3.15-rc5-next-20140519, as utilized in Android versions before 2016-07-05 on Nexus 5X and 6P devices, there exists a flaw in the handling of execute-only pages within the architecture-specific page table header file. This mishandling enables attackers to escalate their privileges through the deployment of a specially crafted application.",
        "commit": "This reverts a change that introduced execute-only page access permissions for ARM64 architectures. Although the intention was to enhance security for memory maps with execute-only permissions, it fails to prevent kernel-level reads. Given that SECCOMP (secure computing mode) has not yet been implemented for ARM64, reverting this patch is necessary to avoid misleading users about the effectiveness of execute-only mappings."
    },
    {
        "cwe": "CWE-119",
        "func_name": "torvalds/do_page_fault",
        "score": 0.7411362528800964,
        "func_before": "asmlinkage\n#endif\nvoid __kprobes do_page_fault(struct pt_regs *regs, unsigned long error_code)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long address;\n\tint write, si_code;\n\tint fault;\n#ifdef CONFIG_X86_64\n\tunsigned long flags;\n\tint sig;\n#endif\n\n\ttsk = current;\n\tmm = tsk->mm;\n\tprefetchw(&mm->mmap_sem);\n\n\t/* get the address */\n\taddress = read_cr2();\n\n\tsi_code = SEGV_MAPERR;\n\n\tif (notify_page_fault(regs))\n\t\treturn;\n\tif (unlikely(kmmio_fault(regs, address)))\n\t\treturn;\n\n\t/*\n\t * We fault-in kernel-space virtual memory on-demand. The\n\t * 'reference' page table is init_mm.pgd.\n\t *\n\t * NOTE! We MUST NOT take any locks for this case. We may\n\t * be in an interrupt or a critical region, and should\n\t * only copy the information from the master page table,\n\t * nothing more.\n\t *\n\t * This verifies that the fault happens in kernel space\n\t * (error_code & 4) == 0, and that the fault was not a\n\t * protection error (error_code & 9) == 0.\n\t */\n#ifdef CONFIG_X86_32\n\tif (unlikely(address >= TASK_SIZE)) {\n#else\n\tif (unlikely(address >= TASK_SIZE64)) {\n#endif\n\t\tif (!(error_code & (PF_RSVD|PF_USER|PF_PROT)) &&\n\t\t    vmalloc_fault(address) >= 0)\n\t\t\treturn;\n\n\t\t/* Can handle a stale RO->RW TLB */\n\t\tif (spurious_fault(address, error_code))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Don't take the mm semaphore here. If we fixup a prefetch\n\t\t * fault we could otherwise deadlock.\n\t\t */\n\t\tgoto bad_area_nosemaphore;\n\t}\n\n\n\t/*\n\t * It's safe to allow irq's after cr2 has been saved and the\n\t * vmalloc fault has been handled.\n\t *\n\t * User-mode registers count as a user access even for any\n\t * potential system fault or CPU buglet.\n\t */\n\tif (user_mode_vm(regs)) {\n\t\tlocal_irq_enable();\n\t\terror_code |= PF_USER;\n\t} else if (regs->flags & X86_EFLAGS_IF)\n\t\tlocal_irq_enable();\n\n#ifdef CONFIG_X86_64\n\tif (unlikely(error_code & PF_RSVD))\n\t\tpgtable_bad(address, regs, error_code);\n#endif\n\n\t/*\n\t * If we're in an interrupt, have no user context or are running in an\n\t * atomic region then we must not take the fault.\n\t */\n\tif (unlikely(in_atomic() || !mm))\n\t\tgoto bad_area_nosemaphore;\n\n\t/*\n\t * When running in the kernel we expect faults to occur only to\n\t * addresses in user space.  All other faults represent errors in the\n\t * kernel and should generate an OOPS.  Unfortunately, in the case of an\n\t * erroneous fault occurring in a code path which already holds mmap_sem\n\t * we will deadlock attempting to validate the fault against the\n\t * address space.  Luckily the kernel only validly references user\n\t * space from well defined areas of code, which are listed in the\n\t * exceptions table.\n\t *\n\t * As the vast majority of faults will be valid we will only perform\n\t * the source reference check when there is a possibility of a deadlock.\n\t * Attempt to lock the address space, if we cannot we then validate the\n\t * source.  If this is invalid we can skip the address space check,\n\t * thus avoiding the deadlock.\n\t */\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tif ((error_code & PF_USER) == 0 &&\n\t\t    !search_exception_tables(regs->ip))\n\t\t\tgoto bad_area_nosemaphore;\n\t\tdown_read(&mm->mmap_sem);\n\t}\n\n\tvma = find_vma(mm, address);\n\tif (!vma)\n\t\tgoto bad_area;\n\tif (vma->vm_start <= address)\n\t\tgoto good_area;\n\tif (!(vma->vm_flags & VM_GROWSDOWN))\n\t\tgoto bad_area;\n\tif (error_code & PF_USER) {\n\t\t/*\n\t\t * Accessing the stack below %sp is always a bug.\n\t\t * The large cushion allows instructions like enter\n\t\t * and pusha to work.  (\"enter $65535,$31\" pushes\n\t\t * 32 pointers and then decrements %sp by 65535.)\n\t\t */\n\t\tif (address + 65536 + 32 * sizeof(unsigned long) < regs->sp)\n\t\t\tgoto bad_area;\n\t}\n\tif (expand_stack(vma, address))\n\t\tgoto bad_area;\n/*\n * Ok, we have a good vm_area for this memory access, so\n * we can handle it..\n */\ngood_area:\n\tsi_code = SEGV_ACCERR;\n\twrite = 0;\n\tswitch (error_code & (PF_PROT|PF_WRITE)) {\n\tdefault:\t/* 3: write, present */\n\t\t/* fall through */\n\tcase PF_WRITE:\t\t/* write, not present */\n\t\tif (!(vma->vm_flags & VM_WRITE))\n\t\t\tgoto bad_area;\n\t\twrite++;\n\t\tbreak;\n\tcase PF_PROT:\t\t/* read, present */\n\t\tgoto bad_area;\n\tcase 0:\t\t\t/* read, not present */\n\t\tif (!(vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE)))\n\t\t\tgoto bad_area;\n\t}\n\n\t/*\n\t * If for any reason at all we couldn't handle the fault,\n\t * make sure we exit gracefully rather than endlessly redo\n\t * the fault.\n\t */\n\tfault = handle_mm_fault(mm, vma, address, write);\n\tif (unlikely(fault & VM_FAULT_ERROR)) {\n\t\tif (fault & VM_FAULT_OOM)\n\t\t\tgoto out_of_memory;\n\t\telse if (fault & VM_FAULT_SIGBUS)\n\t\t\tgoto do_sigbus;\n\t\tBUG();\n\t}\n\tif (fault & VM_FAULT_MAJOR)\n\t\ttsk->maj_flt++;\n\telse\n\t\ttsk->min_flt++;\n\n#ifdef CONFIG_X86_32\n\t/*\n\t * Did it hit the DOS screen memory VA from vm86 mode?\n\t */\n\tif (v8086_mode(regs)) {\n\t\tunsigned long bit = (address - 0xA0000) >> PAGE_SHIFT;\n\t\tif (bit < 32)\n\t\t\ttsk->thread.screen_bitmap |= 1 << bit;\n\t}\n#endif\n\tup_read(&mm->mmap_sem);\n\treturn;\n\n/*\n * Something tried to access memory that isn't in our memory map..\n * Fix it, but check if it's kernel or user first..\n */\nbad_area:\n\tup_read(&mm->mmap_sem);\n\nbad_area_nosemaphore:\n\t/* User mode accesses just cause a SIGSEGV */\n\tif (error_code & PF_USER) {\n\t\t/*\n\t\t * It's possible to have interrupts off here.\n\t\t */\n\t\tlocal_irq_enable();\n\n\t\t/*\n\t\t * Valid to do another page fault here because this one came\n\t\t * from user space.\n\t\t */\n\t\tif (is_prefetch(regs, address, error_code))\n\t\t\treturn;\n\n\t\tif (is_errata100(regs, address))\n\t\t\treturn;\n\n\t\tif (show_unhandled_signals && unhandled_signal(tsk, SIGSEGV) &&\n\t\t    printk_ratelimit()) {\n\t\t\tprintk(\n\t\t\t\"%s%s[%d]: segfault at %lx ip %p sp %p error %lx\",\n\t\t\ttask_pid_nr(tsk) > 1 ? KERN_INFO : KERN_EMERG,\n\t\t\ttsk->comm, task_pid_nr(tsk), address,\n\t\t\t(void *) regs->ip, (void *) regs->sp, error_code);\n\t\t\tprint_vma_addr(\" in \", regs->ip);\n\t\t\tprintk(\"\\n\");\n\t\t}\n\n\t\ttsk->thread.cr2 = address;\n\t\t/* Kernel addresses are always protection faults */\n\t\ttsk->thread.error_code = error_code | (address >= TASK_SIZE);\n\t\ttsk->thread.trap_no = 14;\n\t\tforce_sig_info_fault(SIGSEGV, si_code, address, tsk);\n\t\treturn;\n\t}\n\n\tif (is_f00f_bug(regs, address))\n\t\treturn;\n\nno_context:\n\t/* Are we prepared to handle this kernel fault?  */\n\tif (fixup_exception(regs))\n\t\treturn;\n\n\t/*\n\t * X86_32\n\t * Valid to do another page fault here, because if this fault\n\t * had been triggered by is_prefetch fixup_exception would have\n\t * handled it.\n\t *\n\t * X86_64\n\t * Hall of shame of CPU/BIOS bugs.\n\t */\n\tif (is_prefetch(regs, address, error_code))\n\t\treturn;\n\n\tif (is_errata93(regs, address))\n\t\treturn;\n\n/*\n * Oops. The kernel tried to access some bad page. We'll have to\n * terminate things with extreme prejudice.\n */\n#ifdef CONFIG_X86_32\n\tbust_spinlocks(1);\n#else\n\tflags = oops_begin();\n#endif\n\n\tshow_fault_oops(regs, error_code, address);\n\n\ttsk->thread.cr2 = address;\n\ttsk->thread.trap_no = 14;\n\ttsk->thread.error_code = error_code;\n\n#ifdef CONFIG_X86_32\n\tdie(\"Oops\", regs, error_code);\n\tbust_spinlocks(0);\n\tdo_exit(SIGKILL);\n#else\n\tsig = SIGKILL;\n\tif (__die(\"Oops\", regs, error_code))\n\t\tsig = 0;\n\t/* Executive summary in case the body of the oops scrolled away */\n\tprintk(KERN_EMERG \"CR2: %016lx\\n\", address);\n\toops_end(flags, regs, sig);\n#endif\n\nout_of_memory:\n\t/*\n\t * We ran out of memory, call the OOM killer, and return the userspace\n\t * (which will retry the fault, or kill us if we got oom-killed).\n\t */\n\tup_read(&mm->mmap_sem);\n\tpagefault_out_of_memory();\n\treturn;\n\ndo_sigbus:\n\tup_read(&mm->mmap_sem);\n\n\t/* Kernel mode? Handle exceptions or die */\n\tif (!(error_code & PF_USER))\n\t\tgoto no_context;\n#ifdef CONFIG_X86_32\n\t/* User space => ok to do another page fault */\n\tif (is_prefetch(regs, address, error_code))\n\t\treturn;\n#endif\n\ttsk->thread.cr2 = address;\n\ttsk->thread.error_code = error_code;\n\ttsk->thread.trap_no = 14;\n\tforce_sig_info_fault(SIGBUS, BUS_ADRERR, address, tsk);\n}",
        "func_after": "asmlinkage\n#endif\nvoid __kprobes do_page_fault(struct pt_regs *regs, unsigned long error_code)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long address;\n\tint write, si_code;\n\tint fault;\n#ifdef CONFIG_X86_64\n\tunsigned long flags;\n\tint sig;\n#endif\n\n\ttsk = current;\n\tmm = tsk->mm;\n\tprefetchw(&mm->mmap_sem);\n\n\t/* get the address */\n\taddress = read_cr2();\n\n\tsi_code = SEGV_MAPERR;\n\n\tif (unlikely(kmmio_fault(regs, address)))\n\t\treturn;\n\n\t/*\n\t * We fault-in kernel-space virtual memory on-demand. The\n\t * 'reference' page table is init_mm.pgd.\n\t *\n\t * NOTE! We MUST NOT take any locks for this case. We may\n\t * be in an interrupt or a critical region, and should\n\t * only copy the information from the master page table,\n\t * nothing more.\n\t *\n\t * This verifies that the fault happens in kernel space\n\t * (error_code & 4) == 0, and that the fault was not a\n\t * protection error (error_code & 9) == 0.\n\t */\n#ifdef CONFIG_X86_32\n\tif (unlikely(address >= TASK_SIZE)) {\n#else\n\tif (unlikely(address >= TASK_SIZE64)) {\n#endif\n\t\tif (!(error_code & (PF_RSVD|PF_USER|PF_PROT)) &&\n\t\t    vmalloc_fault(address) >= 0)\n\t\t\treturn;\n\n\t\t/* Can handle a stale RO->RW TLB */\n\t\tif (spurious_fault(address, error_code))\n\t\t\treturn;\n\n\t\t/* kprobes don't want to hook the spurious faults. */\n\t\tif (notify_page_fault(regs))\n\t\t\treturn;\n\t\t/*\n\t\t * Don't take the mm semaphore here. If we fixup a prefetch\n\t\t * fault we could otherwise deadlock.\n\t\t */\n\t\tgoto bad_area_nosemaphore;\n\t}\n\n\t/* kprobes don't want to hook the spurious faults. */\n\tif (notify_page_fault(regs))\n\t\treturn;\n\n\t/*\n\t * It's safe to allow irq's after cr2 has been saved and the\n\t * vmalloc fault has been handled.\n\t *\n\t * User-mode registers count as a user access even for any\n\t * potential system fault or CPU buglet.\n\t */\n\tif (user_mode_vm(regs)) {\n\t\tlocal_irq_enable();\n\t\terror_code |= PF_USER;\n\t} else if (regs->flags & X86_EFLAGS_IF)\n\t\tlocal_irq_enable();\n\n#ifdef CONFIG_X86_64\n\tif (unlikely(error_code & PF_RSVD))\n\t\tpgtable_bad(address, regs, error_code);\n#endif\n\n\t/*\n\t * If we're in an interrupt, have no user context or are running in an\n\t * atomic region then we must not take the fault.\n\t */\n\tif (unlikely(in_atomic() || !mm))\n\t\tgoto bad_area_nosemaphore;\n\n\t/*\n\t * When running in the kernel we expect faults to occur only to\n\t * addresses in user space.  All other faults represent errors in the\n\t * kernel and should generate an OOPS.  Unfortunately, in the case of an\n\t * erroneous fault occurring in a code path which already holds mmap_sem\n\t * we will deadlock attempting to validate the fault against the\n\t * address space.  Luckily the kernel only validly references user\n\t * space from well defined areas of code, which are listed in the\n\t * exceptions table.\n\t *\n\t * As the vast majority of faults will be valid we will only perform\n\t * the source reference check when there is a possibility of a deadlock.\n\t * Attempt to lock the address space, if we cannot we then validate the\n\t * source.  If this is invalid we can skip the address space check,\n\t * thus avoiding the deadlock.\n\t */\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tif ((error_code & PF_USER) == 0 &&\n\t\t    !search_exception_tables(regs->ip))\n\t\t\tgoto bad_area_nosemaphore;\n\t\tdown_read(&mm->mmap_sem);\n\t}\n\n\tvma = find_vma(mm, address);\n\tif (!vma)\n\t\tgoto bad_area;\n\tif (vma->vm_start <= address)\n\t\tgoto good_area;\n\tif (!(vma->vm_flags & VM_GROWSDOWN))\n\t\tgoto bad_area;\n\tif (error_code & PF_USER) {\n\t\t/*\n\t\t * Accessing the stack below %sp is always a bug.\n\t\t * The large cushion allows instructions like enter\n\t\t * and pusha to work.  (\"enter $65535,$31\" pushes\n\t\t * 32 pointers and then decrements %sp by 65535.)\n\t\t */\n\t\tif (address + 65536 + 32 * sizeof(unsigned long) < regs->sp)\n\t\t\tgoto bad_area;\n\t}\n\tif (expand_stack(vma, address))\n\t\tgoto bad_area;\n/*\n * Ok, we have a good vm_area for this memory access, so\n * we can handle it..\n */\ngood_area:\n\tsi_code = SEGV_ACCERR;\n\twrite = 0;\n\tswitch (error_code & (PF_PROT|PF_WRITE)) {\n\tdefault:\t/* 3: write, present */\n\t\t/* fall through */\n\tcase PF_WRITE:\t\t/* write, not present */\n\t\tif (!(vma->vm_flags & VM_WRITE))\n\t\t\tgoto bad_area;\n\t\twrite++;\n\t\tbreak;\n\tcase PF_PROT:\t\t/* read, present */\n\t\tgoto bad_area;\n\tcase 0:\t\t\t/* read, not present */\n\t\tif (!(vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE)))\n\t\t\tgoto bad_area;\n\t}\n\n\t/*\n\t * If for any reason at all we couldn't handle the fault,\n\t * make sure we exit gracefully rather than endlessly redo\n\t * the fault.\n\t */\n\tfault = handle_mm_fault(mm, vma, address, write);\n\tif (unlikely(fault & VM_FAULT_ERROR)) {\n\t\tif (fault & VM_FAULT_OOM)\n\t\t\tgoto out_of_memory;\n\t\telse if (fault & VM_FAULT_SIGBUS)\n\t\t\tgoto do_sigbus;\n\t\tBUG();\n\t}\n\tif (fault & VM_FAULT_MAJOR)\n\t\ttsk->maj_flt++;\n\telse\n\t\ttsk->min_flt++;\n\n#ifdef CONFIG_X86_32\n\t/*\n\t * Did it hit the DOS screen memory VA from vm86 mode?\n\t */\n\tif (v8086_mode(regs)) {\n\t\tunsigned long bit = (address - 0xA0000) >> PAGE_SHIFT;\n\t\tif (bit < 32)\n\t\t\ttsk->thread.screen_bitmap |= 1 << bit;\n\t}\n#endif\n\tup_read(&mm->mmap_sem);\n\treturn;\n\n/*\n * Something tried to access memory that isn't in our memory map..\n * Fix it, but check if it's kernel or user first..\n */\nbad_area:\n\tup_read(&mm->mmap_sem);\n\nbad_area_nosemaphore:\n\t/* User mode accesses just cause a SIGSEGV */\n\tif (error_code & PF_USER) {\n\t\t/*\n\t\t * It's possible to have interrupts off here.\n\t\t */\n\t\tlocal_irq_enable();\n\n\t\t/*\n\t\t * Valid to do another page fault here because this one came\n\t\t * from user space.\n\t\t */\n\t\tif (is_prefetch(regs, address, error_code))\n\t\t\treturn;\n\n\t\tif (is_errata100(regs, address))\n\t\t\treturn;\n\n\t\tif (show_unhandled_signals && unhandled_signal(tsk, SIGSEGV) &&\n\t\t    printk_ratelimit()) {\n\t\t\tprintk(\n\t\t\t\"%s%s[%d]: segfault at %lx ip %p sp %p error %lx\",\n\t\t\ttask_pid_nr(tsk) > 1 ? KERN_INFO : KERN_EMERG,\n\t\t\ttsk->comm, task_pid_nr(tsk), address,\n\t\t\t(void *) regs->ip, (void *) regs->sp, error_code);\n\t\t\tprint_vma_addr(\" in \", regs->ip);\n\t\t\tprintk(\"\\n\");\n\t\t}\n\n\t\ttsk->thread.cr2 = address;\n\t\t/* Kernel addresses are always protection faults */\n\t\ttsk->thread.error_code = error_code | (address >= TASK_SIZE);\n\t\ttsk->thread.trap_no = 14;\n\t\tforce_sig_info_fault(SIGSEGV, si_code, address, tsk);\n\t\treturn;\n\t}\n\n\tif (is_f00f_bug(regs, address))\n\t\treturn;\n\nno_context:\n\t/* Are we prepared to handle this kernel fault?  */\n\tif (fixup_exception(regs))\n\t\treturn;\n\n\t/*\n\t * X86_32\n\t * Valid to do another page fault here, because if this fault\n\t * had been triggered by is_prefetch fixup_exception would have\n\t * handled it.\n\t *\n\t * X86_64\n\t * Hall of shame of CPU/BIOS bugs.\n\t */\n\tif (is_prefetch(regs, address, error_code))\n\t\treturn;\n\n\tif (is_errata93(regs, address))\n\t\treturn;\n\n/*\n * Oops. The kernel tried to access some bad page. We'll have to\n * terminate things with extreme prejudice.\n */\n#ifdef CONFIG_X86_32\n\tbust_spinlocks(1);\n#else\n\tflags = oops_begin();\n#endif\n\n\tshow_fault_oops(regs, error_code, address);\n\n\ttsk->thread.cr2 = address;\n\ttsk->thread.trap_no = 14;\n\ttsk->thread.error_code = error_code;\n\n#ifdef CONFIG_X86_32\n\tdie(\"Oops\", regs, error_code);\n\tbust_spinlocks(0);\n\tdo_exit(SIGKILL);\n#else\n\tsig = SIGKILL;\n\tif (__die(\"Oops\", regs, error_code))\n\t\tsig = 0;\n\t/* Executive summary in case the body of the oops scrolled away */\n\tprintk(KERN_EMERG \"CR2: %016lx\\n\", address);\n\toops_end(flags, regs, sig);\n#endif\n\nout_of_memory:\n\t/*\n\t * We ran out of memory, call the OOM killer, and return the userspace\n\t * (which will retry the fault, or kill us if we got oom-killed).\n\t */\n\tup_read(&mm->mmap_sem);\n\tpagefault_out_of_memory();\n\treturn;\n\ndo_sigbus:\n\tup_read(&mm->mmap_sem);\n\n\t/* Kernel mode? Handle exceptions or die */\n\tif (!(error_code & PF_USER))\n\t\tgoto no_context;\n#ifdef CONFIG_X86_32\n\t/* User space => ok to do another page fault */\n\tif (is_prefetch(regs, address, error_code))\n\t\treturn;\n#endif\n\ttsk->thread.cr2 = address;\n\ttsk->thread.error_code = error_code;\n\ttsk->thread.trap_no = 14;\n\tforce_sig_info_fault(SIGBUS, BUS_ADRERR, address, tsk);\n}",
        "description": "A stack consumption vulnerability exists in the `do_page_fault` function within the Linux kernel prior to version 2.6.28.5. This flaw allows local users to induce a denial of service through memory corruption or potentially escalate privileges by exploiting undefined vectors that trigger page faults on systems with registered Kprobes probes.",
        "commit": "To prevent kprobes from catching spurious faults that lead to infinite recursive page faults and memory corruption due to stack overflow."
    },
    {
        "cwe": "CWE-385",
        "func_name": "openssl/ecdsa_sign_setup",
        "score": 0.736199140548706,
        "func_before": "static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,\n\t\t\t\t\tBIGNUM **kinvp, BIGNUM **rp,\n\t\t\t\t\tconst unsigned char *dgst, int dlen)\n{\n\tBN_CTX   *ctx = NULL;\n\tBIGNUM\t *k = NULL, *r = NULL, *order = NULL, *X = NULL;\n\tEC_POINT *tmp_point=NULL;\n\tconst EC_GROUP *group;\n\tint \t ret = 0;\n\n\tif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\n\tif (ctx_in == NULL) \n\t{\n\t\tif ((ctx = BN_CTX_new()) == NULL)\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t\tctx = ctx_in;\n\n\tk     = BN_new();\t/* this value is later returned in *kinvp */\n\tr     = BN_new();\t/* this value is later returned in *rp    */\n\torder = BN_new();\n\tX     = BN_new();\n\tif (!k || !r || !order || !X)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t}\n\tif ((tmp_point = EC_POINT_new(group)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\tif (!EC_GROUP_get_order(group, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\n#ifdef OPENSSL_FIPS\n\tif (!fips_check_ec_prng(eckey))\n\t\tgoto err;\n#endif\n\t\n\tdo\n\t{\n\t\t/* get random k */\t\n\t\tdo\n#ifndef OPENSSL_NO_SHA512\n\t\t\tif (dgst != NULL)\n\t\t\t{\n\t\t\t\tif (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),\n\t\t\t\t\t\t\t   dgst, dlen, ctx))\n\t\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tif (!BN_rand_range(k, order))\n\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\twhile (BN_is_zero(k));\n\n\t\t/* We do not want timing information to leak the length of k,\n\t\t * so we compute G*k using an equivalent scalar of fixed\n\t\t * bit-length. */\n\n\t\tif (!BN_add(k, k, order)) goto err;\n\t\tif (BN_num_bits(k) <= BN_num_bits(order))\n\t\t\tif (!BN_add(k, k, order)) goto err;\n\n\t\t/* compute r the x-coordinate of generator * k */\n\t\tif (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t}\n\t\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#ifndef OPENSSL_NO_EC2M\n\t\telse /* NID_X9_62_characteristic_two_field */\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GF2m(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!BN_nnmod(r, X, order, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t}\n\t}\n\twhile (BN_is_zero(r));\n\n\t/* compute the inverse of k */\n\tif (!BN_mod_inverse(k, k, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\tgoto err;\t\n\t}\n\t/* clear old values if necessary */\n\tif (*rp != NULL)\n\t\tBN_clear_free(*rp);\n\tif (*kinvp != NULL) \n\t\tBN_clear_free(*kinvp);\n\t/* save the pre-computed values  */\n\t*rp    = r;\n\t*kinvp = k;\n\tret = 1;\nerr:\n\tif (!ret)\n\t{\n\t\tif (k != NULL) BN_clear_free(k);\n\t\tif (r != NULL) BN_clear_free(r);\n\t}\n\tif (ctx_in == NULL) \n\t\tBN_CTX_free(ctx);\n\tif (order != NULL)\n\t\tBN_free(order);\n\tif (tmp_point != NULL) \n\t\tEC_POINT_free(tmp_point);\n\tif (X)\n\t\tBN_clear_free(X);\n\treturn(ret);\n}",
        "func_after": "static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,\n\t\t\t\t\tBIGNUM **kinvp, BIGNUM **rp,\n\t\t\t\t\tconst unsigned char *dgst, int dlen)\n{\n\tBN_CTX   *ctx = NULL;\n\tBIGNUM\t *k = NULL, *r = NULL, *order = NULL, *X = NULL;\n\tEC_POINT *tmp_point=NULL;\n\tconst EC_GROUP *group;\n\tint \t ret = 0;\n\n\tif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\n\tif (ctx_in == NULL) \n\t{\n\t\tif ((ctx = BN_CTX_new()) == NULL)\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t\tctx = ctx_in;\n\n\tk     = BN_new();\t/* this value is later returned in *kinvp */\n\tr     = BN_new();\t/* this value is later returned in *rp    */\n\torder = BN_new();\n\tX     = BN_new();\n\tif (!k || !r || !order || !X)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t}\n\tif ((tmp_point = EC_POINT_new(group)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\tif (!EC_GROUP_get_order(group, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\n#ifdef OPENSSL_FIPS\n\tif (!fips_check_ec_prng(eckey))\n\t\tgoto err;\n#endif\n\t\n\tdo\n\t{\n\t\t/* get random k */\t\n\t\tdo\n#ifndef OPENSSL_NO_SHA512\n\t\t\tif (dgst != NULL)\n\t\t\t{\n\t\t\t\tif (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),\n\t\t\t\t\t\t\t   dgst, dlen, ctx))\n\t\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tif (!BN_rand_range(k, order))\n\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\twhile (BN_is_zero(k));\n\n\t\t/* We do not want timing information to leak the length of k,\n\t\t * so we compute G*k using an equivalent scalar of fixed\n\t\t * bit-length. */\n\n\t\tif (!BN_add(k, k, order)) goto err;\n\t\tif (BN_num_bits(k) <= BN_num_bits(order))\n\t\t\tif (!BN_add(k, k, order)) goto err;\n\n\t\t/* compute r the x-coordinate of generator * k */\n\t\tif (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t}\n\t\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#ifndef OPENSSL_NO_EC2M\n\t\telse /* NID_X9_62_characteristic_two_field */\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GF2m(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!BN_nnmod(r, X, order, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t}\n\t}\n\twhile (BN_is_zero(r));\n\n\t/* compute the inverse of k */\n\tif (EC_GROUP_get_mont_data(group) != NULL)\n\t\t{\n\t\t/* We want inverse in constant time, therefore we utilize the\n\t\t * fact order must be prime and use Fermats Little Theorem\n\t\t * instead. */\n\t\tif (!BN_set_word(X, 2) )\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (!BN_mod_sub(X, order, X, order, ctx))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tBN_set_flags(X, BN_FLG_CONSTTIME);\n\t\tif (!BN_mod_exp_mont_consttime(k, k, X, order, ctx, EC_GROUP_get_mont_data(group)))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tif (!BN_mod_inverse(k, k, order, ctx))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\t\n\t\t\t}\n\t\t}\n\n\t/* clear old values if necessary */\n\tif (*rp != NULL)\n\t\tBN_clear_free(*rp);\n\tif (*kinvp != NULL) \n\t\tBN_clear_free(*kinvp);\n\t/* save the pre-computed values  */\n\t*rp    = r;\n\t*kinvp = k;\n\tret = 1;\nerr:\n\tif (!ret)\n\t{\n\t\tif (k != NULL) BN_clear_free(k);\n\t\tif (r != NULL) BN_clear_free(r);\n\t}\n\tif (ctx_in == NULL) \n\t\tBN_CTX_free(ctx);\n\tif (order != NULL)\n\t\tBN_free(order);\n\tif (tmp_point != NULL) \n\t\tEC_POINT_free(tmp_point);\n\tif (X)\n\t\tBN_clear_free(X);\n\treturn(ret);\n}",
        "description": "A timing attack vulnerability was identified in OpenSSL versions prior to 1.0.1u, enabling a malicious user with local access to potentially recover ECDSA P-256 private keys through the exploitation of timing variations in cryptographic operations.",
        "commit": "The vulnerability knowledge has been abstracted and generalized as follows:\n\n\"The implementation of ECDSA includes an option to utilize BN_mod_exp_mont_consttime, a constant-time modular exponentiation function. This enhancement aims to improve the security of ECDSA operations.\""
    }
]