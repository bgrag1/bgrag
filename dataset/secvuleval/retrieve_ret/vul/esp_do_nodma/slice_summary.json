[
    {
        "cwe": "CWE-78",
        "func_name": "shadowsocks/construct_command_line",
        "score": 0.7742152214050293,
        "func_before": "static char *\nconstruct_command_line(struct manager_ctx *manager, struct server *server)\n{\n    static char cmd[BUF_SIZE];\n    char *method = manager->method;\n    int i;\n\n    build_config(working_dir, server);\n\n    if (server->method) method = server->method;\n    memset(cmd, 0, BUF_SIZE);\n    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n\n    if (manager->acl != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n    }\n    if (manager->timeout != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n    }\n#ifdef HAVE_SETRLIMIT\n    if (manager->nofile) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n    }\n#endif\n    if (manager->user != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n    }\n    if (manager->verbose) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n    }\n    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n    }\n    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n    }\n    if (server->fast_open[0] == 0 && manager->fast_open) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n    }\n    if (manager->ipv6first) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n    }\n    if (manager->mtu) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n    }\n    if (server->plugin == NULL && manager->plugin) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n    }\n    if (server->plugin_opts == NULL && manager->plugin_opts) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n    }\n    for (i = 0; i < manager->nameserver_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n    }\n    for (i = 0; i < manager->host_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n    }\n    // Always enable reuse port\n    {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n    }\n\n    if (verbose) {\n        LOGI(\"cmd: %s\", cmd);\n    }\n\n    return cmd;\n}",
        "func_after": "static char *\nconstruct_command_line(struct manager_ctx *manager, struct server *server)\n{\n    static char cmd[BUF_SIZE];\n    int i;\n    int port;\n\n    port = atoi(server->port);\n\n    build_config(working_dir, manager, server);\n\n    memset(cmd, 0, BUF_SIZE);\n    snprintf(cmd, BUF_SIZE,\n             \"%s --manager-address %s -f %s/.shadowsocks_%d.pid -c %s/.shadowsocks_%d.conf\",\n             executable, manager->manager_address, working_dir, port, working_dir, port);\n\n    if (manager->acl != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n    }\n    if (manager->timeout != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n    }\n#ifdef HAVE_SETRLIMIT\n    if (manager->nofile) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n    }\n#endif\n    if (manager->user != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n    }\n    if (manager->verbose) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n    }\n    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n    }\n    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n    }\n    if (server->fast_open[0] == 0 && manager->fast_open) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n    }\n    if (manager->ipv6first) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n    }\n    if (manager->mtu) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n    }\n    if (server->plugin == NULL && manager->plugin) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n    }\n    if (server->plugin_opts == NULL && manager->plugin_opts) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n    }\n    for (i = 0; i < manager->nameserver_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n    }\n    for (i = 0; i < manager->host_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n    }\n    // Always enable reuse port\n    {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n    }\n\n    if (verbose) {\n        LOGI(\"cmd: %s\", cmd);\n    }\n\n    return cmd;\n}",
        "description": "In the `ss-manager` component of the Shadowsocks-libev library version 3.1.0, there exists a vulnerability due to improper parsing of JSON configuration requests received via UDP traffic on `127.0.0.1`. This issue facilitates command injection through the use of shell metacharacters. The vulnerability is associated with functions such as `add_server`, `build_config`, and `construct_command_line`.",
        "commit": "<Abstracted Description begin>\nA fix has been implemented to address an unspecified issue identified by ticket number 1734.\n<Abstracted Description end>"
    },
    {
        "cwe": "CWE-444",
        "func_name": "haproxy/http_parse_cont_len_header",
        "score": 0.7591419219970703,
        "func_before": "int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\n\tword.ptr = value->ptr - 1; // -1 for next loop's pre-increment\n\te = value->ptr + value->len;\n\n\twhile (++word.ptr < e) {\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\t*body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}",
        "func_after": "int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\n\tword.ptr = value->ptr;\n\te = value->ptr + value->len;\n\n\twhile (1) {\n\t\tif (word.ptr >= e) {\n\t\t\t/* empty header or empty value */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr))) {\n\t\t\tword.ptr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\t*body_len = cl;\n\t\t*value = word;\n\n\t\t/* Now either n==e and we're done, or n points to the comma,\n\t\t * and we skip it and continue.\n\t\t */\n\t\tif (n++ == e)\n\t\t\tbreak;\n\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}",
        "description": "HAProxy versions up to 2.0.32, 2.1.x, 2.2.x through 2.2.30, 2.3.x, 2.4.x through 2.4.23, 2.5.x, and 2.6.x before 2.6.15, 2.7.x before 2.7.10, and 2.8.x before 2.8.2 forward empty Content-Length headers, which violates RFC 9110 section 8.6. In rare scenarios, an HTTP/1 server positioned behind HAProxy may misinterpret the payload as an additional request.",
        "commit": "A vulnerability was identified in the HTTP content-length header parsing mechanism, where an empty or trailing-comma value could be misinterpreted as an absent header. This oversight allowed such headers to pass through to the backend server without proper validation, potentially exposing vulnerable servers to attacks. The risk varies based on the backend server's handling of content-length headers, but users relying on HAProxy to protect known-vulnerable servers are particularly at risk. A configuration-based workaround involves explicitly rejecting requests with empty content-length headers in the frontend settings. The permanent fix requires modifying the parser to ensure that only valid values are accepted, rejecting any empty values encountered. This change needs to be applied across all supported versions of the software. The modifications were made to functions such as `h1_parse_cont_len_header()` and `http_parse_cont_len_header()`, with additional considerations for compatibility with Lua and future deprecation plans. Comprehensive testing was conducted to validate these changes."
    },
    {
        "cwe": "CWE-119",
        "func_name": "torvalds/hugetlb_mcopy_atomic_pte",
        "score": 0.7820311188697815,
        "func_before": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tstruct address_space *mapping = dst_vma->vm_file->f_mapping;\n\t\tpgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
        "func_after": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\tunsigned long size;\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\tmapping = dst_vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\t\tret = -EFAULT;\n\t\tif (idx >= size)\n\t\t\tgoto out_release_nounlock;\n\n\t\t/*\n\t\t * Serialization between remove_inode_hugepages() and\n\t\t * huge_add_to_page_cache() below happens through the\n\t\t * hugetlb_fault_mutex_table that here must be hold by\n\t\t * the caller.\n\t\t */\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\t/*\n\t * Recheck the i_size after holding PT lock to make sure not\n\t * to leave any page mapped (as page_mapped()) beyond the end\n\t * of the i_size (remove_inode_hugepages() is strict about\n\t * enforcing that). If we bail out here, we'll also leave a\n\t * page in the radix tree in the vm_shared case beyond the end\n\t * of the i_size, but remove_inode_hugepages() will take care\n\t * of it as soon as we drop the hugetlb_fault_mutex_table.\n\t */\n\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\tret = -EFAULT;\n\tif (idx >= size)\n\t\tgoto out_release_unlock;\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
        "description": "A flaw was identified in the hugetlb_mcopy_atomic_pte function within the Linux kernel's memory management module, affecting versions prior to 4.13.12. The absence of a proper size check in this function could lead to a denial of service condition, indicated by a BUG.",
        "commit": "A vulnerability was identified in the userfaultfd functionality related to hugetlbfs, where the UFFDIO_COPY operation could inadvertently extend beyond the intended size of the file (i_size). This issue led to a kernel panic (oops) at fs/hugetlbfs/inode.c:484, triggered by the absence of an i_size check in the hugetlb_mcopy_atomic_pte function. Although mmap() operations could succeed beyond the end of the i_size after vmtruncate had removed virtual memory areas (vmas) in those ranges, subsequent faults, including UFFDIO_COPY, should not be allowed to succeed. The proposed solution involves modifying the return value to userland to indicate a SIGBUS-like condition, similar to what a page fault would produce, but this approach was deemed less useful due to the difficulty in distinguishing between SIGSEGV and SIGBUS through meaningful syscall return values."
    },
    {
        "cwe": "CWE-611",
        "func_name": "UIKit0/plist_from_xml",
        "score": 0.7300332188606262,
        "func_before": "PLIST_API void plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)\n{\n    xmlDocPtr plist_doc = xmlParseMemory(plist_xml, length);\n    xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n\n    xml_to_node(root_node, plist);\n    xmlFreeDoc(plist_doc);\n}",
        "func_after": "PLIST_API void plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)\n{\n    /* CVE-2013-0339: disable external entity loading to prevent XXE vulnerability */\n    xmlSetExternalEntityLoader(plist_xml_external_entity_loader);\n\n    /* read XML from memory and disable network access for security reasons */\n    xmlDocPtr plist_doc = xmlReadMemory(plist_xml, length, \"plist_from_xml:memory\", NULL, XML_PARSE_NONET);\n    if (plist_doc) {\n        xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n\n        xml_to_node(root_node, plist);\n        xmlFreeDoc(plist_doc);\n    }\n}",
        "description": "A vulnerability has been identified in the UIKit0 libplist library version 1.12, affecting the plist_from_xml function within the XML Handler component. This issue involves improper handling of XML external entity references, which could lead to potential security risks. To address this, a patch with the identifier c086cb139af7c82845f6d565e636073ff4b37440 has been developed. It is advised to apply this patch to mitigate the vulnerability.",
        "commit": "A security vulnerability related to XML property lists (plists) has been identified, where an attacker could potentially exploit a limited but possible XML External Entity (XXE) flaw. This vulnerability arises from the use of a specially crafted XML file that leverages a custom Document Type Definition (DTD) with an external entity reference. Such a file, when processed by the plistutil tool, could facilitate unauthorized GET requests to arbitrary URLs or disclose local files. Although practical exploitation is constrained, the issue has been addressed to enhance security. This vulnerability is analogous to CVE-2013-0339 observed in libxml2 and aligns with CWE-827. The vulnerability was reported by Lo\u00efc B\u00e9nis from calypt.com."
    },
    {
        "cwe": "CWE-776",
        "func_name": "libexpat/externalParEntProcessor",
        "score": 0.7358987331390381,
        "func_before": "static enum XML_Error PTRCALL\nexternalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: /* start == end */\n    default:\n      break;\n    }\n  }\n  /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.\n     However, when parsing an external subset, doProlog will not accept a BOM\n     as valid, and report a syntax error, so we have to skip the BOM\n  */\n  else if (tok == XML_TOK_BOM) {\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}",
        "func_after": "static enum XML_Error PTRCALL\nexternalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: /* start == end */\n    default:\n      break;\n    }\n  }\n  /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.\n     However, when parsing an external subset, doProlog will not accept a BOM\n     as valid, and report a syntax error, so we have to skip the BOM\n  */\n  else if (tok == XML_TOK_BOM) {\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);\n}",
        "description": "In versions of libexpat prior to 2.2.8, maliciously crafted XML input could cause the parser to prematurely transition from DTD parsing to document parsing. Subsequently, invoking functions such as XML_GetCurrentLineNumber or XML_GetCurrentColumnNumber led to a heap-based buffer over-read.",
        "commit": "output: \"Denial of service vulnerability due to improper handling of internal entities within the XML parsing process.\""
    }
]