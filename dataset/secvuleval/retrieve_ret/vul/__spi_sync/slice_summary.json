[
    {
        "cwe": "CWE-662",
        "func_name": "torvalds/do_fontx_ioctl",
        "score": 0.7519624829292297,
        "func_before": "static inline int do_fontx_ioctl(int cmd,\n\t\tstruct consolefontdesc __user *user_cfd,\n\t\tstruct console_font_op *op)\n{\n\tstruct consolefontdesc cfdarg;\n\tint i;\n\n\tif (copy_from_user(&cfdarg, user_cfd, sizeof(struct consolefontdesc)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase PIO_FONTX:\n\t\top->op = KD_FONT_OP_SET;\n\t\top->flags = KD_FONT_FLAG_OLD;\n\t\top->width = 8;\n\t\top->height = cfdarg.charheight;\n\t\top->charcount = cfdarg.charcount;\n\t\top->data = cfdarg.chardata;\n\t\treturn con_font_op(vc_cons[fg_console].d, op);\n\tcase GIO_FONTX: {\n\t\top->op = KD_FONT_OP_GET;\n\t\top->flags = KD_FONT_FLAG_OLD;\n\t\top->width = 8;\n\t\top->height = cfdarg.charheight;\n\t\top->charcount = cfdarg.charcount;\n\t\top->data = cfdarg.chardata;\n\t\ti = con_font_op(vc_cons[fg_console].d, op);\n\t\tif (i)\n\t\t\treturn i;\n\t\tcfdarg.charheight = op->height;\n\t\tcfdarg.charcount = op->charcount;\n\t\tif (copy_to_user(user_cfd, &cfdarg, sizeof(struct consolefontdesc)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}",
        "func_after": "static inline int do_fontx_ioctl(struct vc_data *vc, int cmd,\n\t\tstruct consolefontdesc __user *user_cfd,\n\t\tstruct console_font_op *op)\n{\n\tstruct consolefontdesc cfdarg;\n\tint i;\n\n\tif (copy_from_user(&cfdarg, user_cfd, sizeof(struct consolefontdesc)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase PIO_FONTX:\n\t\top->op = KD_FONT_OP_SET;\n\t\top->flags = KD_FONT_FLAG_OLD;\n\t\top->width = 8;\n\t\top->height = cfdarg.charheight;\n\t\top->charcount = cfdarg.charcount;\n\t\top->data = cfdarg.chardata;\n\t\treturn con_font_op(vc, op);\n\n\tcase GIO_FONTX:\n\t\top->op = KD_FONT_OP_GET;\n\t\top->flags = KD_FONT_FLAG_OLD;\n\t\top->width = 8;\n\t\top->height = cfdarg.charheight;\n\t\top->charcount = cfdarg.charcount;\n\t\top->data = cfdarg.chardata;\n\t\ti = con_font_op(vc, op);\n\t\tif (i)\n\t\t\treturn i;\n\t\tcfdarg.charheight = op->height;\n\t\tcfdarg.charcount = op->charcount;\n\t\tif (copy_to_user(user_cfd, &cfdarg, sizeof(struct consolefontdesc)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}",
        "description": "A flaw was identified in the Linux Kernel where access to a global variable used for managing the foreground console is not adequately synchronized, resulting in a use-after-free error within the function responsible for font operations.",
        "commit": "Some font-related terminal I/O control operations previously utilized the current foreground virtual console (VC) for their execution. This practice has been discontinued to address a data race condition involving the `fg_console` variable. Notably, both Michael Ellerman and Jiri Slaby have observed that these I/O control operations are deprecated and should have been removed earlier. They suggest that most systems now use the `KDFONTOP` ioctl instead. Additionally, Michael notes that BusyBox's `loadfont` program transitioned to using `KDFONTOP` precisely due to this bug, which was identified approximately 12 years ago."
    },
    {
        "cwe": "CWE-116",
        "func_name": "flatpak/flatpak_builtin_info",
        "score": 0.7535513043403625,
        "func_before": "gboolean\nflatpak_builtin_info (int argc, char **argv, GCancellable *cancellable, GError **error)\n{\n  g_autoptr(GOptionContext) context = NULL;\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n  g_autoptr(FlatpakDir) dir = NULL;\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autoptr(FlatpakDeploy) deploy = NULL;\n  g_autoptr(GFile) deploy_dir = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  const char *commit = NULL;\n  const char *alt_id = NULL;\n  const char *eol;\n  const char *eol_rebase;\n  const char *name;\n  const char *summary;\n  const char *version;\n  const char *license;\n  const char *pref = NULL;\n  const char *default_branch = NULL;\n  const char *origin = NULL;\n  guint64 size;\n  gboolean search_all = FALSE;\n  gboolean first = TRUE;\n  FlatpakKinds kinds;\n  const char *path;\n  g_autofree char *formatted_size = NULL;\n  gboolean friendly = TRUE;\n  g_autofree const char **subpaths = NULL;\n  int len = 0;\n  int rows, cols;\n  int width;\n\n  context = g_option_context_new (_(\"NAME [BRANCH] - Get info about an installed app or runtime\"));\n  g_option_context_set_translation_domain (context, GETTEXT_PACKAGE);\n\n  if (!flatpak_option_context_parse (context, options, &argc, &argv, FLATPAK_BUILTIN_FLAG_NO_DIR, NULL, cancellable, error))\n    return FALSE;\n\n  if (argc < 2)\n    return usage_error (context, _(\"NAME must be specified\"), error);\n  pref = argv[1];\n\n  if (argc >= 3)\n    default_branch = argv[2];\n\n  if (argc > 3)\n    return usage_error (context, _(\"Too many arguments\"), error);\n\n  kinds = FLATPAK_KINDS_APP | FLATPAK_KINDS_RUNTIME;\n\n  if (!opt_user && !opt_system && opt_installations == NULL)\n    search_all = TRUE;\n\n  dir = flatpak_find_installed_pref (pref, kinds, opt_arch, default_branch,\n                                     search_all, opt_user, opt_system, opt_installations,\n                                     &ref, cancellable, error);\n  if (dir == NULL)\n    return FALSE;\n\n  deploy_data = flatpak_dir_get_deploy_data (dir, ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);\n  if (deploy_data == NULL)\n    return FALSE;\n\n  deploy = flatpak_dir_load_deployed (dir, ref, NULL, cancellable, error);\n  if (deploy == NULL)\n    return FALSE;\n\n  commit = flatpak_deploy_data_get_commit (deploy_data);\n  alt_id = flatpak_deploy_data_get_alt_id (deploy_data);\n  origin = flatpak_deploy_data_get_origin (deploy_data);\n  size = flatpak_deploy_data_get_installed_size (deploy_data);\n  formatted_size = g_format_size (size);\n  deploy_dir = flatpak_deploy_get_dir (deploy);\n  path = flatpak_file_get_path_cached (deploy_dir);\n  subpaths = flatpak_deploy_data_get_subpaths (deploy_data);\n  eol = flatpak_deploy_data_get_eol (deploy_data);\n  eol_rebase = flatpak_deploy_data_get_eol_rebase (deploy_data);\n  name = flatpak_deploy_data_get_appdata_name (deploy_data);\n  summary = flatpak_deploy_data_get_appdata_summary (deploy_data);\n  version = flatpak_deploy_data_get_appdata_version (deploy_data);\n  license = flatpak_deploy_data_get_appdata_license (deploy_data);\n\n  metakey = flatpak_deploy_get_metadata (deploy);\n\n  if (opt_show_ref || opt_show_origin || opt_show_commit || opt_show_size || opt_show_metadata || opt_show_permissions ||\n      opt_file_access || opt_show_location || opt_show_runtime || opt_show_sdk)\n    friendly = FALSE;\n\n  if (friendly)\n    {\n      g_autoptr(GVariant) commit_v = NULL;\n      VarMetadataRef commit_metadata;\n      guint64 timestamp;\n      g_autofree char *formatted_timestamp = NULL;\n      const gchar *subject = NULL;\n      g_autofree char *parent = NULL;\n      g_autofree char *latest = NULL;\n      const char *xa_metadata = NULL;\n      const char *collection_id = NULL;\n\n      flatpak_get_window_size (&rows, &cols);\n\n      if (name)\n        {\n          if (summary)\n            print_wrapped (MIN (cols, 80), \"\\n%s - %s\\n\", name, summary);\n          else\n            print_wrapped (MIN (cols, 80), \"\\n%s\\n\", name);\n        }\n\n      latest = flatpak_dir_read_latest (dir, origin, flatpak_decomposed_get_ref (ref), NULL, NULL, NULL);\n      if (latest == NULL)\n        latest = g_strdup (_(\"ref not present in origin\"));\n\n      if (ostree_repo_load_commit (flatpak_dir_get_repo (dir), commit, &commit_v, NULL, NULL))\n        {\n          VarCommitRef var_commit = var_commit_from_gvariant (commit_v);\n\n          subject = var_commit_get_subject (var_commit);\n          parent = ostree_commit_get_parent (commit_v);\n          timestamp = ostree_commit_get_timestamp (commit_v);\n\n          formatted_timestamp = format_timestamp (timestamp);\n\n          commit_metadata = var_commit_get_metadata (var_commit);\n          xa_metadata = var_metadata_lookup_string (commit_metadata, \"xa.metadata\", NULL);\n          if (xa_metadata == NULL)\n            g_printerr (_(\"Warning: Commit has no flatpak metadata\\n\"));\n\n          collection_id = var_metadata_lookup_string (commit_metadata, \"ostree.collection-binding\", NULL);\n        }\n\n      len = 0;\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Ref:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Arch:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Branch:\"), -1));\n      if (version)\n        len = MAX (len, g_utf8_strlen (_(\"Version:\"), -1));\n      if (license)\n        len = MAX (len, g_utf8_strlen (_(\"License:\"), -1));\n      if (collection_id != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Collection:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installation:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      if (flatpak_decomposed_is_app (ref))\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Runtime:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Sdk:\"), -1));\n        }\n      if (formatted_timestamp)\n        len = MAX (len, g_utf8_strlen (_(\"Date:\"), -1));\n      if (subject)\n        len = MAX (len, g_utf8_strlen (_(\"Subject:\"), -1));\n      if (strcmp (commit, latest) != 0)\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Active commit:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Latest commit:\"), -1));\n        }\n      else\n        len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      if (parent)\n        len = MAX (len, g_utf8_strlen (_(\"Parent:\"), -1));\n      if (alt_id)\n        len = MAX (len, g_utf8_strlen (_(\"Alt-id:\"), -1));\n      if (eol)\n        len = MAX (len, g_utf8_strlen (_(\"End-of-life:\"), -1));\n      if (eol_rebase)\n        len = MAX (len, g_utf8_strlen (_(\"End-of-life-rebase:\"), -1));\n      if (subpaths[0] != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Subdirectories:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Extension:\"), -1));\n\n      width = cols - (len + 1);\n\n      print_aligned_take (len, _(\"ID:\"), flatpak_decomposed_dup_id (ref));\n      print_aligned (len, _(\"Ref:\"), flatpak_decomposed_get_ref (ref));\n      print_aligned_take (len, _(\"Arch:\"), flatpak_decomposed_dup_arch (ref));\n      print_aligned_take (len, _(\"Branch:\"), flatpak_decomposed_dup_branch (ref));\n      if (version)\n        print_aligned (len, _(\"Version:\"), version);\n      if (license)\n        print_aligned (len, _(\"License:\"), license);\n      print_aligned (len, _(\"Origin:\"), origin ? origin : \"-\");\n      if (collection_id)\n        print_aligned (len, _(\"Collection:\"), collection_id);\n      print_aligned (len, _(\"Installation:\"), flatpak_dir_get_name_cached (dir));\n      print_aligned (len, _(\"Installed:\"), formatted_size);\n      if (flatpak_decomposed_is_app (ref))\n        {\n          g_autofree char *runtime = NULL;\n          runtime = g_key_file_get_string (metakey,\n                                           FLATPAK_METADATA_GROUP_APPLICATION,\n                                           FLATPAK_METADATA_KEY_RUNTIME,\n                                           error);\n          print_aligned (len, _(\"Runtime:\"), runtime ? runtime : \"-\");\n        }\n      if (flatpak_decomposed_is_app (ref))\n        {\n          g_autofree char *sdk = NULL;\n          sdk = g_key_file_get_string (metakey,\n                                       FLATPAK_METADATA_GROUP_APPLICATION,\n                                       FLATPAK_METADATA_KEY_SDK,\n                                       error);\n          print_aligned (len, _(\"Sdk:\"), sdk ? sdk : \"-\");\n        }\n      g_print (\"\\n\");\n\n      if (strcmp (commit, latest) != 0)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (commit, width);\n          print_aligned (len, _(\"Active commit:\"), formatted_commit);\n          g_free (formatted_commit);\n          formatted_commit = ellipsize_string (latest, width);\n          print_aligned (len, _(\"Latest commit:\"), formatted_commit);\n        }\n      else\n        {\n          g_autofree char *formatted_commit = ellipsize_string (commit, width);\n          print_aligned (len, _(\"Commit:\"), formatted_commit);\n        }\n      if (parent)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (parent, width);\n          print_aligned (len, _(\"Parent:\"), formatted_commit);\n        }\n      if (subject)\n        print_aligned (len, _(\"Subject:\"), subject);\n      if (formatted_timestamp)\n        print_aligned (len, _(\"Date:\"), formatted_timestamp);\n      if (subpaths[0] != NULL)\n        {\n          g_autofree char *s = g_strjoinv (\",\", (char **) subpaths);\n          print_aligned (len, _(\"Subdirectories:\"), s);\n        }\n\n      if (alt_id)\n        print_aligned (len, _(\"Alt-id:\"), alt_id);\n      if (eol)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol, width);\n          print_aligned (len, _(\"End-of-life:\"), formatted_eol);\n        }\n      if (eol_rebase)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol_rebase, width);\n          print_aligned (len, _(\"End-of-life-rebase:\"), formatted_eol);\n        }\n    }\n  else\n    {\n      if (opt_show_ref)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", flatpak_decomposed_get_ref (ref));\n        }\n\n      if (opt_show_origin)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", origin ? origin : \"-\");\n        }\n\n      if (opt_show_commit)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", commit);\n        }\n\n      if (opt_show_size)\n        {\n          maybe_print_space (&first);\n          g_print (\"%\" G_GUINT64_FORMAT, size);\n        }\n\n      if (opt_show_location)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", path);\n        }\n\n      if (opt_show_runtime)\n        {\n          g_autofree char *runtime = NULL;\n          maybe_print_space (&first);\n\n          runtime = g_key_file_get_string (metakey,\n                                           flatpak_decomposed_get_kind_metadata_group (ref),\n                                           FLATPAK_METADATA_KEY_RUNTIME,\n                                           NULL);\n          g_print (\"%s\", runtime ? runtime : \"-\");\n        }\n\n      if (opt_show_sdk)\n        {\n          g_autofree char *sdk = NULL;\n          maybe_print_space (&first);\n\n          sdk = g_key_file_get_string (metakey,\n                                       flatpak_decomposed_get_kind_metadata_group (ref),\n                                       FLATPAK_METADATA_KEY_SDK,\n                                       NULL);\n          g_print (\"%s\", sdk ? sdk : \"-\");\n        }\n\n      if (!first)\n        g_print (\"\\n\");\n\n      if (opt_show_metadata)\n        {\n          g_autoptr(GFile) file = NULL;\n          g_autofree char *data = NULL;\n          gsize data_size;\n\n          file = g_file_get_child (deploy_dir, \"metadata\");\n\n          if (!g_file_load_contents (file, cancellable, &data, &data_size, NULL, error))\n            return FALSE;\n\n          g_print (\"%s\", data);\n        }\n\n      if (opt_show_permissions || opt_file_access)\n        {\n          g_autoptr(FlatpakContext) app_context = NULL;\n          g_autoptr(GKeyFile) keyfile = NULL;\n          g_autofree gchar *contents = NULL;\n\n          app_context = flatpak_context_load_for_deploy (deploy, error);\n          if (app_context == NULL)\n            return FALSE;\n\n          if (opt_show_permissions)\n            {\n              keyfile = g_key_file_new ();\n              flatpak_context_save_metadata (app_context, TRUE, keyfile);\n              contents = g_key_file_to_data (keyfile, NULL, error);\n              if (contents == NULL)\n                return FALSE;\n\n              g_print (\"%s\", contents);\n            }\n\n          if (opt_file_access)\n            {\n              g_autofree char *id = flatpak_decomposed_dup_id (ref);\n              g_autoptr(FlatpakExports) exports = flatpak_context_get_exports (app_context, id);\n              FlatpakFilesystemMode mode;\n\n              mode = flatpak_exports_path_get_mode (exports, opt_file_access);\n              if (mode == 0)\n                g_print (\"hidden\\n\");\n              else if (mode == FLATPAK_FILESYSTEM_MODE_READ_ONLY)\n                g_print (\"read-only\\n\");\n              else\n                g_print (\"read-write\\n\");\n            }\n        }\n    }\n\n  if (opt_show_extensions)\n    {\n      GList *extensions, *l;\n      g_autofree char *ref_arch = flatpak_decomposed_dup_arch (ref);\n      g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);\n\n      len = MAX (len, g_utf8_strlen (_(\"Extension:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Origin:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Subpaths:\"), -1));\n\n      flatpak_get_window_size (&rows, &cols);\n      width = cols - (len + 1);\n\n      extensions = flatpak_list_extensions (metakey, ref_arch, ref_branch);\n      for (l = extensions; l; l = l->next)\n        {\n          FlatpakExtension *ext = l->data;\n          g_autofree const char **ext_subpaths = NULL;\n          g_autoptr(GBytes) ext_deploy_data = NULL;\n          g_autofree char *formatted = NULL;\n          g_autofree char *ext_formatted_size = NULL;\n          g_autofree char *formatted_commit = NULL;\n\n          if (ext->is_unmaintained)\n            {\n              formatted_commit = g_strdup (_(\"unmaintained\"));\n              origin = NULL;\n              size = 0;\n              ext_formatted_size = g_strdup (_(\"unknown\"));\n              ext_subpaths = NULL;\n            }\n          else\n            {\n              ext_deploy_data = flatpak_dir_get_deploy_data (dir, ext->ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);\n              if (ext_deploy_data == NULL)\n                return FALSE;\n\n              commit = flatpak_deploy_data_get_commit (ext_deploy_data);\n              formatted_commit = ellipsize_string (commit, width);\n              origin = flatpak_deploy_data_get_origin (ext_deploy_data);\n              size = flatpak_deploy_data_get_installed_size (ext_deploy_data);\n              formatted = g_format_size (size);\n              ext_subpaths = flatpak_deploy_data_get_subpaths (ext_deploy_data);\n              if (ext_subpaths && ext_subpaths[0] && size > 0)\n                ext_formatted_size = g_strconcat (\"<\", formatted, NULL);\n              else\n                ext_formatted_size = g_steal_pointer (&formatted);\n            }\n\n          g_print (\"\\n\");\n          print_aligned (len, _(\"Extension:\"), flatpak_decomposed_get_ref (ext->ref));\n          print_aligned (len, _(\"ID:\"), ext->id);\n          print_aligned (len, _(\"Origin:\"), origin ? origin : \"-\");\n          print_aligned (len, _(\"Commit:\"), formatted_commit);\n          print_aligned (len, _(\"Installed:\"), ext_formatted_size);\n\n          if (ext_subpaths && ext_subpaths[0])\n            {\n              g_autofree char *s = g_strjoinv (\",\", (char **) ext_subpaths);\n              print_aligned (len, _(\"Subpaths:\"), s);\n            }\n        }\n\n      g_list_free_full (extensions, (GDestroyNotify) flatpak_extension_free);\n    }\n\n  return TRUE;\n}",
        "func_after": "gboolean\nflatpak_builtin_info (int argc, char **argv, GCancellable *cancellable, GError **error)\n{\n  g_autoptr(GOptionContext) context = NULL;\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n  g_autoptr(FlatpakDir) dir = NULL;\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autoptr(FlatpakDeploy) deploy = NULL;\n  g_autoptr(GFile) deploy_dir = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  const char *commit = NULL;\n  const char *alt_id = NULL;\n  const char *eol;\n  const char *eol_rebase;\n  const char *name;\n  const char *summary;\n  const char *version;\n  const char *license;\n  const char *pref = NULL;\n  const char *default_branch = NULL;\n  const char *origin = NULL;\n  guint64 size;\n  gboolean search_all = FALSE;\n  gboolean first = TRUE;\n  FlatpakKinds kinds;\n  const char *path;\n  g_autofree char *formatted_size = NULL;\n  gboolean friendly = TRUE;\n  g_autofree const char **subpaths = NULL;\n  int len = 0;\n  int rows, cols;\n  int width;\n\n  context = g_option_context_new (_(\"NAME [BRANCH] - Get info about an installed app or runtime\"));\n  g_option_context_set_translation_domain (context, GETTEXT_PACKAGE);\n\n  if (!flatpak_option_context_parse (context, options, &argc, &argv, FLATPAK_BUILTIN_FLAG_NO_DIR, NULL, cancellable, error))\n    return FALSE;\n\n  if (argc < 2)\n    return usage_error (context, _(\"NAME must be specified\"), error);\n  pref = argv[1];\n\n  if (argc >= 3)\n    default_branch = argv[2];\n\n  if (argc > 3)\n    return usage_error (context, _(\"Too many arguments\"), error);\n\n  kinds = FLATPAK_KINDS_APP | FLATPAK_KINDS_RUNTIME;\n\n  if (!opt_user && !opt_system && opt_installations == NULL)\n    search_all = TRUE;\n\n  dir = flatpak_find_installed_pref (pref, kinds, opt_arch, default_branch,\n                                     search_all, opt_user, opt_system, opt_installations,\n                                     &ref, cancellable, error);\n  if (dir == NULL)\n    return FALSE;\n\n  deploy_data = flatpak_dir_get_deploy_data (dir, ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);\n  if (deploy_data == NULL)\n    return FALSE;\n\n  deploy = flatpak_dir_load_deployed (dir, ref, NULL, cancellable, error);\n  if (deploy == NULL)\n    return FALSE;\n\n  commit = flatpak_deploy_data_get_commit (deploy_data);\n  alt_id = flatpak_deploy_data_get_alt_id (deploy_data);\n  origin = flatpak_deploy_data_get_origin (deploy_data);\n  size = flatpak_deploy_data_get_installed_size (deploy_data);\n  formatted_size = g_format_size (size);\n  deploy_dir = flatpak_deploy_get_dir (deploy);\n  path = flatpak_file_get_path_cached (deploy_dir);\n  subpaths = flatpak_deploy_data_get_subpaths (deploy_data);\n  eol = flatpak_deploy_data_get_eol (deploy_data);\n  eol_rebase = flatpak_deploy_data_get_eol_rebase (deploy_data);\n  name = flatpak_deploy_data_get_appdata_name (deploy_data);\n  summary = flatpak_deploy_data_get_appdata_summary (deploy_data);\n  version = flatpak_deploy_data_get_appdata_version (deploy_data);\n  license = flatpak_deploy_data_get_appdata_license (deploy_data);\n\n  metakey = flatpak_deploy_get_metadata (deploy);\n\n  if (opt_show_ref || opt_show_origin || opt_show_commit || opt_show_size || opt_show_metadata || opt_show_permissions ||\n      opt_file_access || opt_show_location || opt_show_runtime || opt_show_sdk)\n    friendly = FALSE;\n\n  if (friendly)\n    {\n      g_autoptr(GVariant) commit_v = NULL;\n      VarMetadataRef commit_metadata;\n      guint64 timestamp;\n      g_autofree char *formatted_timestamp = NULL;\n      const gchar *subject = NULL;\n      g_autofree char *parent = NULL;\n      g_autofree char *latest = NULL;\n      const char *xa_metadata = NULL;\n      const char *collection_id = NULL;\n\n      flatpak_get_window_size (&rows, &cols);\n\n      if (name)\n        {\n          if (summary)\n            print_wrapped (MIN (cols, 80), \"\\n%s - %s\\n\", name, summary);\n          else\n            print_wrapped (MIN (cols, 80), \"\\n%s\\n\", name);\n        }\n\n      latest = flatpak_dir_read_latest (dir, origin, flatpak_decomposed_get_ref (ref), NULL, NULL, NULL);\n      if (latest == NULL)\n        latest = g_strdup (_(\"ref not present in origin\"));\n\n      if (ostree_repo_load_commit (flatpak_dir_get_repo (dir), commit, &commit_v, NULL, NULL))\n        {\n          VarCommitRef var_commit = var_commit_from_gvariant (commit_v);\n\n          subject = var_commit_get_subject (var_commit);\n          parent = ostree_commit_get_parent (commit_v);\n          timestamp = ostree_commit_get_timestamp (commit_v);\n\n          formatted_timestamp = format_timestamp (timestamp);\n\n          commit_metadata = var_commit_get_metadata (var_commit);\n          xa_metadata = var_metadata_lookup_string (commit_metadata, \"xa.metadata\", NULL);\n          if (xa_metadata == NULL)\n            g_printerr (_(\"Warning: Commit has no flatpak metadata\\n\"));\n\n          collection_id = var_metadata_lookup_string (commit_metadata, \"ostree.collection-binding\", NULL);\n        }\n\n      len = 0;\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Ref:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Arch:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Branch:\"), -1));\n      if (version)\n        len = MAX (len, g_utf8_strlen (_(\"Version:\"), -1));\n      if (license)\n        len = MAX (len, g_utf8_strlen (_(\"License:\"), -1));\n      if (collection_id != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Collection:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installation:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      if (flatpak_decomposed_is_app (ref))\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Runtime:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Sdk:\"), -1));\n        }\n      if (formatted_timestamp)\n        len = MAX (len, g_utf8_strlen (_(\"Date:\"), -1));\n      if (subject)\n        len = MAX (len, g_utf8_strlen (_(\"Subject:\"), -1));\n      if (strcmp (commit, latest) != 0)\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Active commit:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Latest commit:\"), -1));\n        }\n      else\n        len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      if (parent)\n        len = MAX (len, g_utf8_strlen (_(\"Parent:\"), -1));\n      if (alt_id)\n        len = MAX (len, g_utf8_strlen (_(\"Alt-id:\"), -1));\n      if (eol)\n        len = MAX (len, g_utf8_strlen (_(\"End-of-life:\"), -1));\n      if (eol_rebase)\n        len = MAX (len, g_utf8_strlen (_(\"End-of-life-rebase:\"), -1));\n      if (subpaths[0] != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Subdirectories:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Extension:\"), -1));\n\n      width = cols - (len + 1);\n\n      print_aligned_take (len, _(\"ID:\"), flatpak_decomposed_dup_id (ref));\n      print_aligned (len, _(\"Ref:\"), flatpak_decomposed_get_ref (ref));\n      print_aligned_take (len, _(\"Arch:\"), flatpak_decomposed_dup_arch (ref));\n      print_aligned_take (len, _(\"Branch:\"), flatpak_decomposed_dup_branch (ref));\n      if (version)\n        print_aligned (len, _(\"Version:\"), version);\n      if (license)\n        print_aligned (len, _(\"License:\"), license);\n      print_aligned (len, _(\"Origin:\"), origin ? origin : \"-\");\n      if (collection_id)\n        print_aligned (len, _(\"Collection:\"), collection_id);\n      print_aligned (len, _(\"Installation:\"), flatpak_dir_get_name_cached (dir));\n      print_aligned (len, _(\"Installed:\"), formatted_size);\n      if (flatpak_decomposed_is_app (ref))\n        {\n          g_autofree char *runtime = NULL;\n          runtime = g_key_file_get_string (metakey,\n                                           FLATPAK_METADATA_GROUP_APPLICATION,\n                                           FLATPAK_METADATA_KEY_RUNTIME,\n                                           error);\n          print_aligned (len, _(\"Runtime:\"), runtime ? runtime : \"-\");\n        }\n      if (flatpak_decomposed_is_app (ref))\n        {\n          g_autofree char *sdk = NULL;\n          sdk = g_key_file_get_string (metakey,\n                                       FLATPAK_METADATA_GROUP_APPLICATION,\n                                       FLATPAK_METADATA_KEY_SDK,\n                                       error);\n          print_aligned (len, _(\"Sdk:\"), sdk ? sdk : \"-\");\n        }\n      g_print (\"\\n\");\n\n      if (strcmp (commit, latest) != 0)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (commit, width);\n          print_aligned (len, _(\"Active commit:\"), formatted_commit);\n          g_free (formatted_commit);\n          formatted_commit = ellipsize_string (latest, width);\n          print_aligned (len, _(\"Latest commit:\"), formatted_commit);\n        }\n      else\n        {\n          g_autofree char *formatted_commit = ellipsize_string (commit, width);\n          print_aligned (len, _(\"Commit:\"), formatted_commit);\n        }\n      if (parent)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (parent, width);\n          print_aligned (len, _(\"Parent:\"), formatted_commit);\n        }\n      if (subject)\n        print_aligned (len, _(\"Subject:\"), subject);\n      if (formatted_timestamp)\n        print_aligned (len, _(\"Date:\"), formatted_timestamp);\n      if (subpaths[0] != NULL)\n        {\n          g_autofree char *s = g_strjoinv (\",\", (char **) subpaths);\n          print_aligned (len, _(\"Subdirectories:\"), s);\n        }\n\n      if (alt_id)\n        print_aligned (len, _(\"Alt-id:\"), alt_id);\n      if (eol)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol, width);\n          print_aligned (len, _(\"End-of-life:\"), formatted_eol);\n        }\n      if (eol_rebase)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol_rebase, width);\n          print_aligned (len, _(\"End-of-life-rebase:\"), formatted_eol);\n        }\n    }\n  else\n    {\n      if (opt_show_ref)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", flatpak_decomposed_get_ref (ref));\n        }\n\n      if (opt_show_origin)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", origin ? origin : \"-\");\n        }\n\n      if (opt_show_commit)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", commit);\n        }\n\n      if (opt_show_size)\n        {\n          maybe_print_space (&first);\n          g_print (\"%\" G_GUINT64_FORMAT, size);\n        }\n\n      if (opt_show_location)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", path);\n        }\n\n      if (opt_show_runtime)\n        {\n          g_autofree char *runtime = NULL;\n          maybe_print_space (&first);\n\n          runtime = g_key_file_get_string (metakey,\n                                           flatpak_decomposed_get_kind_metadata_group (ref),\n                                           FLATPAK_METADATA_KEY_RUNTIME,\n                                           NULL);\n          g_print (\"%s\", runtime ? runtime : \"-\");\n        }\n\n      if (opt_show_sdk)\n        {\n          g_autofree char *sdk = NULL;\n          maybe_print_space (&first);\n\n          sdk = g_key_file_get_string (metakey,\n                                       flatpak_decomposed_get_kind_metadata_group (ref),\n                                       FLATPAK_METADATA_KEY_SDK,\n                                       NULL);\n          g_print (\"%s\", sdk ? sdk : \"-\");\n        }\n\n      if (!first)\n        g_print (\"\\n\");\n\n      if (opt_show_metadata)\n        {\n          g_autoptr(GFile) file = NULL;\n          g_autofree char *data = NULL;\n          gsize data_size;\n\n          file = g_file_get_child (deploy_dir, \"metadata\");\n\n          if (!g_file_load_contents (file, cancellable, &data, &data_size, NULL, error))\n            return FALSE;\n\n          flatpak_print_escaped_string (data,\n                                        FLATPAK_ESCAPE_ALLOW_NEWLINES\n                                        | FLATPAK_ESCAPE_DO_NOT_QUOTE);\n        }\n\n      if (opt_show_permissions || opt_file_access)\n        {\n          g_autoptr(FlatpakContext) app_context = NULL;\n          g_autoptr(GKeyFile) keyfile = NULL;\n          g_autofree gchar *contents = NULL;\n\n          app_context = flatpak_context_load_for_deploy (deploy, error);\n          if (app_context == NULL)\n            return FALSE;\n\n          if (opt_show_permissions)\n            {\n              keyfile = g_key_file_new ();\n              flatpak_context_save_metadata (app_context, TRUE, keyfile);\n              contents = g_key_file_to_data (keyfile, NULL, error);\n              if (contents == NULL)\n                return FALSE;\n\n              flatpak_print_escaped_string (contents,\n                                            FLATPAK_ESCAPE_ALLOW_NEWLINES\n                                            | FLATPAK_ESCAPE_DO_NOT_QUOTE);\n            }\n\n          if (opt_file_access)\n            {\n              g_autofree char *id = flatpak_decomposed_dup_id (ref);\n              g_autoptr(FlatpakExports) exports = flatpak_context_get_exports (app_context, id);\n              FlatpakFilesystemMode mode;\n\n              mode = flatpak_exports_path_get_mode (exports, opt_file_access);\n              if (mode == 0)\n                g_print (\"hidden\\n\");\n              else if (mode == FLATPAK_FILESYSTEM_MODE_READ_ONLY)\n                g_print (\"read-only\\n\");\n              else\n                g_print (\"read-write\\n\");\n            }\n        }\n    }\n\n  if (opt_show_extensions)\n    {\n      GList *extensions, *l;\n      g_autofree char *ref_arch = flatpak_decomposed_dup_arch (ref);\n      g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);\n\n      len = MAX (len, g_utf8_strlen (_(\"Extension:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Origin:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Subpaths:\"), -1));\n\n      flatpak_get_window_size (&rows, &cols);\n      width = cols - (len + 1);\n\n      extensions = flatpak_list_extensions (metakey, ref_arch, ref_branch);\n      for (l = extensions; l; l = l->next)\n        {\n          FlatpakExtension *ext = l->data;\n          g_autofree const char **ext_subpaths = NULL;\n          g_autoptr(GBytes) ext_deploy_data = NULL;\n          g_autofree char *formatted = NULL;\n          g_autofree char *ext_formatted_size = NULL;\n          g_autofree char *formatted_commit = NULL;\n\n          if (ext->is_unmaintained)\n            {\n              formatted_commit = g_strdup (_(\"unmaintained\"));\n              origin = NULL;\n              size = 0;\n              ext_formatted_size = g_strdup (_(\"unknown\"));\n              ext_subpaths = NULL;\n            }\n          else\n            {\n              ext_deploy_data = flatpak_dir_get_deploy_data (dir, ext->ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);\n              if (ext_deploy_data == NULL)\n                return FALSE;\n\n              commit = flatpak_deploy_data_get_commit (ext_deploy_data);\n              formatted_commit = ellipsize_string (commit, width);\n              origin = flatpak_deploy_data_get_origin (ext_deploy_data);\n              size = flatpak_deploy_data_get_installed_size (ext_deploy_data);\n              formatted = g_format_size (size);\n              ext_subpaths = flatpak_deploy_data_get_subpaths (ext_deploy_data);\n              if (ext_subpaths && ext_subpaths[0] && size > 0)\n                ext_formatted_size = g_strconcat (\"<\", formatted, NULL);\n              else\n                ext_formatted_size = g_steal_pointer (&formatted);\n            }\n\n          g_print (\"\\n\");\n          print_aligned (len, _(\"Extension:\"), flatpak_decomposed_get_ref (ext->ref));\n          print_aligned (len, _(\"ID:\"), ext->id);\n          print_aligned (len, _(\"Origin:\"), origin ? origin : \"-\");\n          print_aligned (len, _(\"Commit:\"), formatted_commit);\n          print_aligned (len, _(\"Installed:\"), ext_formatted_size);\n\n          if (ext_subpaths && ext_subpaths[0])\n            {\n              g_autofree char *s = g_strjoinv (\",\", (char **) ext_subpaths);\n              print_aligned (len, _(\"Subpaths:\"), s);\n            }\n        }\n\n      g_list_free_full (extensions, (GDestroyNotify) flatpak_extension_free);\n    }\n\n  return TRUE;\n}",
        "description": "In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, Flatpak allowed attackers to publish applications with elevated permissions while hiding these permissions from users through the `flatpak(1)` command-line interface. This was achieved by setting other permissions to crafted values containing non-printable control characters such as `ESC`. A fix is available in the mentioned versions. As a workaround, users are advised to use a graphical user interface like GNOME Software instead of the command-line interface, or to only install applications from trusted maintainers.",
        "commit": "It is important to escape special characters in permissions and metadata to prevent manipulation of the permissions list's appearance."
    },
    {
        "cwe": "CWE-354",
        "func_name": "systemd/journal_file_offline_close",
        "score": 0.7442134022712708,
        "func_before": "JournalFile* journal_file_offline_close(JournalFile *f) {\n        if (!f)\n                return NULL;\n\n#if HAVE_GCRYPT\n        /* Write the final tag */\n        if (JOURNAL_HEADER_SEALED(f->header) && journal_file_writable(f)) {\n                int r;\n\n                r = journal_file_append_tag(f);\n                if (r < 0)\n                        log_error_errno(r, \"Failed to append tag when closing journal: %m\");\n        }\n#endif\n\n        if (sd_event_source_get_enabled(f->post_change_timer, NULL) > 0)\n                journal_file_post_change(f);\n        sd_event_source_disable_unref(f->post_change_timer);\n\n        journal_file_set_offline(f, true);\n\n        return journal_file_close(f);\n}",
        "func_after": "JournalFile* journal_file_offline_close(JournalFile *f) {\n        if (!f)\n                return NULL;\n\n        journal_file_write_final_tag(f);\n\n        if (sd_event_source_get_enabled(f->post_change_timer, NULL) > 0)\n                journal_file_post_change(f);\n        sd_event_source_disable_unref(f->post_change_timer);\n\n        journal_file_set_offline(f, true);\n\n        return journal_file_close(f);\n}",
        "description": "An issue was discovered in systemd where an attacker can manipulate a sealed log file by truncating it and then resuming the log sealing process. This manipulation allows the attacker to alter the log content without detection, as integrity checks do not reveal any errors.",
        "commit": "The vulnerability involves an issue in the `journalctl` tool where empty log epochs are not properly sealed, allowing attackers to manipulate sealed logs by truncating them and continuing without detection during verification. This defect partially addresses CVE-2023-31438. To fully resolve the issue, the system should enforce that there is exactly one seal per epoch and prevent sealing until an epoch has ended. Additionally, a new journal-file flag, `HEADER_COMPATIBLE_SEALED_CONTINUOUS`, has been introduced to indicate continuous sealing and determine whether missing cryptographic epochs should result in warnings or errors."
    },
    {
        "cwe": "CWE-119",
        "func_name": "torvalds/hugetlb_mcopy_atomic_pte",
        "score": 0.7711454033851624,
        "func_before": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tstruct address_space *mapping = dst_vma->vm_file->f_mapping;\n\t\tpgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
        "func_after": "int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,\n\t\t\t    pte_t *dst_pte,\n\t\t\t    struct vm_area_struct *dst_vma,\n\t\t\t    unsigned long dst_addr,\n\t\t\t    unsigned long src_addr,\n\t\t\t    struct page **pagep)\n{\n\tstruct address_space *mapping;\n\tpgoff_t idx;\n\tunsigned long size;\n\tint vm_shared = dst_vma->vm_flags & VM_SHARED;\n\tstruct hstate *h = hstate_vma(dst_vma);\n\tpte_t _dst_pte;\n\tspinlock_t *ptl;\n\tint ret;\n\tstruct page *page;\n\n\tif (!*pagep) {\n\t\tret = -ENOMEM;\n\t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\n\t\tret = copy_huge_page_from_user(page,\n\t\t\t\t\t\t(const void __user *) src_addr,\n\t\t\t\t\t\tpages_per_huge_page(h), false);\n\n\t\t/* fallback to copy_from_user outside mmap_sem */\n\t\tif (unlikely(ret)) {\n\t\t\tret = -EFAULT;\n\t\t\t*pagep = page;\n\t\t\t/* don't free the page */\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tpage = *pagep;\n\t\t*pagep = NULL;\n\t}\n\n\t/*\n\t * The memory barrier inside __SetPageUptodate makes sure that\n\t * preceding stores to the page contents become visible before\n\t * the set_pte_at() write.\n\t */\n\t__SetPageUptodate(page);\n\tset_page_huge_active(page);\n\n\tmapping = dst_vma->vm_file->f_mapping;\n\tidx = vma_hugecache_offset(h, dst_vma, dst_addr);\n\n\t/*\n\t * If shared, add to page cache\n\t */\n\tif (vm_shared) {\n\t\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\t\tret = -EFAULT;\n\t\tif (idx >= size)\n\t\t\tgoto out_release_nounlock;\n\n\t\t/*\n\t\t * Serialization between remove_inode_hugepages() and\n\t\t * huge_add_to_page_cache() below happens through the\n\t\t * hugetlb_fault_mutex_table that here must be hold by\n\t\t * the caller.\n\t\t */\n\t\tret = huge_add_to_page_cache(page, mapping, idx);\n\t\tif (ret)\n\t\t\tgoto out_release_nounlock;\n\t}\n\n\tptl = huge_pte_lockptr(h, dst_mm, dst_pte);\n\tspin_lock(ptl);\n\n\t/*\n\t * Recheck the i_size after holding PT lock to make sure not\n\t * to leave any page mapped (as page_mapped()) beyond the end\n\t * of the i_size (remove_inode_hugepages() is strict about\n\t * enforcing that). If we bail out here, we'll also leave a\n\t * page in the radix tree in the vm_shared case beyond the end\n\t * of the i_size, but remove_inode_hugepages() will take care\n\t * of it as soon as we drop the hugetlb_fault_mutex_table.\n\t */\n\tsize = i_size_read(mapping->host) >> huge_page_shift(h);\n\tret = -EFAULT;\n\tif (idx >= size)\n\t\tgoto out_release_unlock;\n\n\tret = -EEXIST;\n\tif (!huge_pte_none(huge_ptep_get(dst_pte)))\n\t\tgoto out_release_unlock;\n\n\tif (vm_shared) {\n\t\tpage_dup_rmap(page, true);\n\t} else {\n\t\tClearPagePrivate(page);\n\t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);\n\t}\n\n\t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);\n\tif (dst_vma->vm_flags & VM_WRITE)\n\t\t_dst_pte = huge_pte_mkdirty(_dst_pte);\n\t_dst_pte = pte_mkyoung(_dst_pte);\n\n\tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);\n\n\t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,\n\t\t\t\t\tdst_vma->vm_flags & VM_WRITE);\n\thugetlb_count_add(pages_per_huge_page(h), dst_mm);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);\n\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\n\tret = 0;\nout:\n\treturn ret;\nout_release_unlock:\n\tspin_unlock(ptl);\n\tif (vm_shared)\n\t\tunlock_page(page);\nout_release_nounlock:\n\tput_page(page);\n\tgoto out;\n}",
        "description": "A flaw was identified in the hugetlb_mcopy_atomic_pte function within the Linux kernel's memory management module, affecting versions prior to 4.13.12. The absence of a proper size check in this function could lead to a denial of service condition, indicated by a BUG.",
        "commit": "A vulnerability was identified in the userfaultfd functionality related to hugetlbfs, where the UFFDIO_COPY operation could inadvertently extend beyond the intended size of the file (i_size). This issue led to a kernel panic (oops) at fs/hugetlbfs/inode.c:484, triggered by the absence of an i_size check in the hugetlb_mcopy_atomic_pte function. Although mmap() operations could succeed beyond the end of the i_size after vmtruncate had removed virtual memory areas (vmas) in those ranges, subsequent faults, including UFFDIO_COPY, should not be allowed to succeed. The proposed solution involves modifying the return value to userland to indicate a SIGBUS-like condition, similar to what a page fault would produce, but this approach was deemed less useful due to the difficulty in distinguishing between SIGSEGV and SIGBUS through meaningful syscall return values."
    },
    {
        "cwe": "CWE-362",
        "func_name": "torvalds/fib6_add_rt2node",
        "score": 0.7768052816390991,
        "func_before": "static int fib6_add_rt2node(struct fib6_node *fn, struct fib6_info *rt,\n\t\t\t    struct nl_info *info,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct fib6_info *leaf = rcu_dereference_protected(fn->leaf,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\tstruct fib6_info *iter = NULL;\n\tstruct fib6_info __rcu **ins;\n\tstruct fib6_info __rcu **fallback_ins = NULL;\n\tint replace = (info->nlh &&\n\t\t       (info->nlh->nlmsg_flags & NLM_F_REPLACE));\n\tint add = (!info->nlh ||\n\t\t   (info->nlh->nlmsg_flags & NLM_F_CREATE));\n\tint found = 0;\n\tbool rt_can_ecmp = rt6_qualify_for_ecmp(rt);\n\tbool notify_sibling_rt = false;\n\tu16 nlflags = NLM_F_EXCL;\n\tint err;\n\n\tif (info->nlh && (info->nlh->nlmsg_flags & NLM_F_APPEND))\n\t\tnlflags |= NLM_F_APPEND;\n\n\tins = &fn->leaf;\n\n\tfor (iter = leaf; iter;\n\t     iter = rcu_dereference_protected(iter->fib6_next,\n\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock))) {\n\t\t/*\n\t\t *\tSearch for duplicates\n\t\t */\n\n\t\tif (iter->fib6_metric == rt->fib6_metric) {\n\t\t\t/*\n\t\t\t *\tSame priority level\n\t\t\t */\n\t\t\tif (info->nlh &&\n\t\t\t    (info->nlh->nlmsg_flags & NLM_F_EXCL))\n\t\t\t\treturn -EEXIST;\n\n\t\t\tnlflags &= ~NLM_F_EXCL;\n\t\t\tif (replace) {\n\t\t\t\tif (rt_can_ecmp == rt6_qualify_for_ecmp(iter)) {\n\t\t\t\t\tfound++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallback_ins = fallback_ins ?: ins;\n\t\t\t\tgoto next_iter;\n\t\t\t}\n\n\t\t\tif (rt6_duplicate_nexthop(iter, rt)) {\n\t\t\t\tif (rt->fib6_nsiblings)\n\t\t\t\t\trt->fib6_nsiblings = 0;\n\t\t\t\tif (!(iter->fib6_flags & RTF_EXPIRES))\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\tif (!(rt->fib6_flags & RTF_EXPIRES))\n\t\t\t\t\tfib6_clean_expires_locked(iter);\n\t\t\t\telse\n\t\t\t\t\tfib6_set_expires_locked(iter,\n\t\t\t\t\t\t\t\trt->expires);\n\n\t\t\t\tif (rt->fib6_pmtu)\n\t\t\t\t\tfib6_metric_set(iter, RTAX_MTU,\n\t\t\t\t\t\t\trt->fib6_pmtu);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\t/* If we have the same destination and the same metric,\n\t\t\t * but not the same gateway, then the route we try to\n\t\t\t * add is sibling to this route, increment our counter\n\t\t\t * of siblings, and later we will add our route to the\n\t\t\t * list.\n\t\t\t * Only static routes (which don't have flag\n\t\t\t * RTF_EXPIRES) are used for ECMPv6.\n\t\t\t *\n\t\t\t * To avoid long list, we only had siblings if the\n\t\t\t * route have a gateway.\n\t\t\t */\n\t\t\tif (rt_can_ecmp &&\n\t\t\t    rt6_qualify_for_ecmp(iter))\n\t\t\t\trt->fib6_nsiblings++;\n\t\t}\n\n\t\tif (iter->fib6_metric > rt->fib6_metric)\n\t\t\tbreak;\n\nnext_iter:\n\t\tins = &iter->fib6_next;\n\t}\n\n\tif (fallback_ins && !found) {\n\t\t/* No matching route with same ecmp-able-ness found, replace\n\t\t * first matching route\n\t\t */\n\t\tins = fallback_ins;\n\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\tfound++;\n\t}\n\n\t/* Reset round-robin state, if necessary */\n\tif (ins == &fn->leaf)\n\t\tfn->rr_ptr = NULL;\n\n\t/* Link this route to others same route. */\n\tif (rt->fib6_nsiblings) {\n\t\tunsigned int fib6_nsiblings;\n\t\tstruct fib6_info *sibling, *temp_sibling;\n\n\t\t/* Find the first route that have the same metric */\n\t\tsibling = leaf;\n\t\tnotify_sibling_rt = true;\n\t\twhile (sibling) {\n\t\t\tif (sibling->fib6_metric == rt->fib6_metric &&\n\t\t\t    rt6_qualify_for_ecmp(sibling)) {\n\t\t\t\tlist_add_tail(&rt->fib6_siblings,\n\t\t\t\t\t      &sibling->fib6_siblings);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsibling = rcu_dereference_protected(sibling->fib6_next,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\tnotify_sibling_rt = false;\n\t\t}\n\t\t/* For each sibling in the list, increment the counter of\n\t\t * siblings. BUG() if counters does not match, list of siblings\n\t\t * is broken!\n\t\t */\n\t\tfib6_nsiblings = 0;\n\t\tlist_for_each_entry_safe(sibling, temp_sibling,\n\t\t\t\t\t &rt->fib6_siblings, fib6_siblings) {\n\t\t\tsibling->fib6_nsiblings++;\n\t\t\tBUG_ON(sibling->fib6_nsiblings != rt->fib6_nsiblings);\n\t\t\tfib6_nsiblings++;\n\t\t}\n\t\tBUG_ON(fib6_nsiblings != rt->fib6_nsiblings);\n\t\trt6_multipath_rebalance(temp_sibling);\n\t}\n\n\t/*\n\t *\tinsert node\n\t */\n\tif (!replace) {\n\t\tif (!add)\n\t\t\tpr_warn(\"NLM_F_CREATE should be set when creating new route\\n\");\n\nadd:\n\t\tnlflags |= NLM_F_CREATE;\n\n\t\t/* The route should only be notified if it is the first\n\t\t * route in the node or if it is added as a sibling\n\t\t * route to the first route in the node.\n\t\t */\n\t\tif (!info->skip_notify_kernel &&\n\t\t    (notify_sibling_rt || ins == &fn->leaf)) {\n\t\t\tenum fib_event_type fib_event;\n\n\t\t\tif (notify_sibling_rt)\n\t\t\t\tfib_event = FIB_EVENT_ENTRY_APPEND;\n\t\t\telse\n\t\t\t\tfib_event = FIB_EVENT_ENTRY_REPLACE;\n\t\t\terr = call_fib6_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\tfib_event, rt,\n\t\t\t\t\t\t\textack);\n\t\t\tif (err) {\n\t\t\t\tstruct fib6_info *sibling, *next_sibling;\n\n\t\t\t\t/* If the route has siblings, then it first\n\t\t\t\t * needs to be unlinked from them.\n\t\t\t\t */\n\t\t\t\tif (!rt->fib6_nsiblings)\n\t\t\t\t\treturn err;\n\n\t\t\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t\t\t\t &rt->fib6_siblings,\n\t\t\t\t\t\t\t fib6_siblings)\n\t\t\t\t\tsibling->fib6_nsiblings--;\n\t\t\t\trt->fib6_nsiblings = 0;\n\t\t\t\tlist_del_init(&rt->fib6_siblings);\n\t\t\t\trt6_multipath_rebalance(next_sibling);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\trcu_assign_pointer(rt->fib6_next, iter);\n\t\tfib6_info_hold(rt);\n\t\trcu_assign_pointer(rt->fib6_node, fn);\n\t\trcu_assign_pointer(*ins, rt);\n\t\tif (!info->skip_notify)\n\t\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, nlflags);\n\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries++;\n\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\n\t} else {\n\t\tint nsiblings;\n\n\t\tif (!found) {\n\t\t\tif (add)\n\t\t\t\tgoto add;\n\t\t\tpr_warn(\"NLM_F_REPLACE set, but no existing node found!\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (!info->skip_notify_kernel && ins == &fn->leaf) {\n\t\t\terr = call_fib6_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\tFIB_EVENT_ENTRY_REPLACE,\n\t\t\t\t\t\t\trt, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tfib6_info_hold(rt);\n\t\trcu_assign_pointer(rt->fib6_node, fn);\n\t\trt->fib6_next = iter->fib6_next;\n\t\trcu_assign_pointer(*ins, rt);\n\t\tif (!info->skip_notify)\n\t\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, NLM_F_REPLACE);\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\t\tnsiblings = iter->fib6_nsiblings;\n\t\titer->fib6_node = NULL;\n\t\tfib6_purge_rt(iter, fn, info->nl_net);\n\t\tif (rcu_access_pointer(fn->rr_ptr) == iter)\n\t\t\tfn->rr_ptr = NULL;\n\t\tfib6_info_release(iter);\n\n\t\tif (nsiblings) {\n\t\t\t/* Replacing an ECMP route, remove all siblings */\n\t\t\tins = &rt->fib6_next;\n\t\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\twhile (iter) {\n\t\t\t\tif (iter->fib6_metric > rt->fib6_metric)\n\t\t\t\t\tbreak;\n\t\t\t\tif (rt6_qualify_for_ecmp(iter)) {\n\t\t\t\t\t*ins = iter->fib6_next;\n\t\t\t\t\titer->fib6_node = NULL;\n\t\t\t\t\tfib6_purge_rt(iter, fn, info->nl_net);\n\t\t\t\t\tif (rcu_access_pointer(fn->rr_ptr) == iter)\n\t\t\t\t\t\tfn->rr_ptr = NULL;\n\t\t\t\t\tfib6_info_release(iter);\n\t\t\t\t\tnsiblings--;\n\t\t\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries--;\n\t\t\t\t} else {\n\t\t\t\t\tins = &iter->fib6_next;\n\t\t\t\t}\n\t\t\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\t}\n\t\t\tWARN_ON(nsiblings != 0);\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "func_after": "static int fib6_add_rt2node(struct fib6_node *fn, struct fib6_info *rt,\n\t\t\t    struct nl_info *info,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct fib6_info *leaf = rcu_dereference_protected(fn->leaf,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\tstruct fib6_info *iter = NULL;\n\tstruct fib6_info __rcu **ins;\n\tstruct fib6_info __rcu **fallback_ins = NULL;\n\tint replace = (info->nlh &&\n\t\t       (info->nlh->nlmsg_flags & NLM_F_REPLACE));\n\tint add = (!info->nlh ||\n\t\t   (info->nlh->nlmsg_flags & NLM_F_CREATE));\n\tint found = 0;\n\tbool rt_can_ecmp = rt6_qualify_for_ecmp(rt);\n\tbool notify_sibling_rt = false;\n\tu16 nlflags = NLM_F_EXCL;\n\tint err;\n\n\tif (info->nlh && (info->nlh->nlmsg_flags & NLM_F_APPEND))\n\t\tnlflags |= NLM_F_APPEND;\n\n\tins = &fn->leaf;\n\n\tfor (iter = leaf; iter;\n\t     iter = rcu_dereference_protected(iter->fib6_next,\n\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock))) {\n\t\t/*\n\t\t *\tSearch for duplicates\n\t\t */\n\n\t\tif (iter->fib6_metric == rt->fib6_metric) {\n\t\t\t/*\n\t\t\t *\tSame priority level\n\t\t\t */\n\t\t\tif (info->nlh &&\n\t\t\t    (info->nlh->nlmsg_flags & NLM_F_EXCL))\n\t\t\t\treturn -EEXIST;\n\n\t\t\tnlflags &= ~NLM_F_EXCL;\n\t\t\tif (replace) {\n\t\t\t\tif (rt_can_ecmp == rt6_qualify_for_ecmp(iter)) {\n\t\t\t\t\tfound++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallback_ins = fallback_ins ?: ins;\n\t\t\t\tgoto next_iter;\n\t\t\t}\n\n\t\t\tif (rt6_duplicate_nexthop(iter, rt)) {\n\t\t\t\tif (rt->fib6_nsiblings)\n\t\t\t\t\trt->fib6_nsiblings = 0;\n\t\t\t\tif (!(iter->fib6_flags & RTF_EXPIRES))\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\tif (!(rt->fib6_flags & RTF_EXPIRES))\n\t\t\t\t\tfib6_clean_expires(iter);\n\t\t\t\telse\n\t\t\t\t\tfib6_set_expires(iter, rt->expires);\n\n\t\t\t\tif (rt->fib6_pmtu)\n\t\t\t\t\tfib6_metric_set(iter, RTAX_MTU,\n\t\t\t\t\t\t\trt->fib6_pmtu);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\t/* If we have the same destination and the same metric,\n\t\t\t * but not the same gateway, then the route we try to\n\t\t\t * add is sibling to this route, increment our counter\n\t\t\t * of siblings, and later we will add our route to the\n\t\t\t * list.\n\t\t\t * Only static routes (which don't have flag\n\t\t\t * RTF_EXPIRES) are used for ECMPv6.\n\t\t\t *\n\t\t\t * To avoid long list, we only had siblings if the\n\t\t\t * route have a gateway.\n\t\t\t */\n\t\t\tif (rt_can_ecmp &&\n\t\t\t    rt6_qualify_for_ecmp(iter))\n\t\t\t\trt->fib6_nsiblings++;\n\t\t}\n\n\t\tif (iter->fib6_metric > rt->fib6_metric)\n\t\t\tbreak;\n\nnext_iter:\n\t\tins = &iter->fib6_next;\n\t}\n\n\tif (fallback_ins && !found) {\n\t\t/* No matching route with same ecmp-able-ness found, replace\n\t\t * first matching route\n\t\t */\n\t\tins = fallback_ins;\n\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\tfound++;\n\t}\n\n\t/* Reset round-robin state, if necessary */\n\tif (ins == &fn->leaf)\n\t\tfn->rr_ptr = NULL;\n\n\t/* Link this route to others same route. */\n\tif (rt->fib6_nsiblings) {\n\t\tunsigned int fib6_nsiblings;\n\t\tstruct fib6_info *sibling, *temp_sibling;\n\n\t\t/* Find the first route that have the same metric */\n\t\tsibling = leaf;\n\t\tnotify_sibling_rt = true;\n\t\twhile (sibling) {\n\t\t\tif (sibling->fib6_metric == rt->fib6_metric &&\n\t\t\t    rt6_qualify_for_ecmp(sibling)) {\n\t\t\t\tlist_add_tail(&rt->fib6_siblings,\n\t\t\t\t\t      &sibling->fib6_siblings);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsibling = rcu_dereference_protected(sibling->fib6_next,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\tnotify_sibling_rt = false;\n\t\t}\n\t\t/* For each sibling in the list, increment the counter of\n\t\t * siblings. BUG() if counters does not match, list of siblings\n\t\t * is broken!\n\t\t */\n\t\tfib6_nsiblings = 0;\n\t\tlist_for_each_entry_safe(sibling, temp_sibling,\n\t\t\t\t\t &rt->fib6_siblings, fib6_siblings) {\n\t\t\tsibling->fib6_nsiblings++;\n\t\t\tBUG_ON(sibling->fib6_nsiblings != rt->fib6_nsiblings);\n\t\t\tfib6_nsiblings++;\n\t\t}\n\t\tBUG_ON(fib6_nsiblings != rt->fib6_nsiblings);\n\t\trt6_multipath_rebalance(temp_sibling);\n\t}\n\n\t/*\n\t *\tinsert node\n\t */\n\tif (!replace) {\n\t\tif (!add)\n\t\t\tpr_warn(\"NLM_F_CREATE should be set when creating new route\\n\");\n\nadd:\n\t\tnlflags |= NLM_F_CREATE;\n\n\t\t/* The route should only be notified if it is the first\n\t\t * route in the node or if it is added as a sibling\n\t\t * route to the first route in the node.\n\t\t */\n\t\tif (!info->skip_notify_kernel &&\n\t\t    (notify_sibling_rt || ins == &fn->leaf)) {\n\t\t\tenum fib_event_type fib_event;\n\n\t\t\tif (notify_sibling_rt)\n\t\t\t\tfib_event = FIB_EVENT_ENTRY_APPEND;\n\t\t\telse\n\t\t\t\tfib_event = FIB_EVENT_ENTRY_REPLACE;\n\t\t\terr = call_fib6_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\tfib_event, rt,\n\t\t\t\t\t\t\textack);\n\t\t\tif (err) {\n\t\t\t\tstruct fib6_info *sibling, *next_sibling;\n\n\t\t\t\t/* If the route has siblings, then it first\n\t\t\t\t * needs to be unlinked from them.\n\t\t\t\t */\n\t\t\t\tif (!rt->fib6_nsiblings)\n\t\t\t\t\treturn err;\n\n\t\t\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t\t\t\t &rt->fib6_siblings,\n\t\t\t\t\t\t\t fib6_siblings)\n\t\t\t\t\tsibling->fib6_nsiblings--;\n\t\t\t\trt->fib6_nsiblings = 0;\n\t\t\t\tlist_del_init(&rt->fib6_siblings);\n\t\t\t\trt6_multipath_rebalance(next_sibling);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\trcu_assign_pointer(rt->fib6_next, iter);\n\t\tfib6_info_hold(rt);\n\t\trcu_assign_pointer(rt->fib6_node, fn);\n\t\trcu_assign_pointer(*ins, rt);\n\t\tif (!info->skip_notify)\n\t\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, nlflags);\n\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries++;\n\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\n\t} else {\n\t\tint nsiblings;\n\n\t\tif (!found) {\n\t\t\tif (add)\n\t\t\t\tgoto add;\n\t\t\tpr_warn(\"NLM_F_REPLACE set, but no existing node found!\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (!info->skip_notify_kernel && ins == &fn->leaf) {\n\t\t\terr = call_fib6_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\tFIB_EVENT_ENTRY_REPLACE,\n\t\t\t\t\t\t\trt, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tfib6_info_hold(rt);\n\t\trcu_assign_pointer(rt->fib6_node, fn);\n\t\trt->fib6_next = iter->fib6_next;\n\t\trcu_assign_pointer(*ins, rt);\n\t\tif (!info->skip_notify)\n\t\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, NLM_F_REPLACE);\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\t\tnsiblings = iter->fib6_nsiblings;\n\t\titer->fib6_node = NULL;\n\t\tfib6_purge_rt(iter, fn, info->nl_net);\n\t\tif (rcu_access_pointer(fn->rr_ptr) == iter)\n\t\t\tfn->rr_ptr = NULL;\n\t\tfib6_info_release(iter);\n\n\t\tif (nsiblings) {\n\t\t\t/* Replacing an ECMP route, remove all siblings */\n\t\t\tins = &rt->fib6_next;\n\t\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\twhile (iter) {\n\t\t\t\tif (iter->fib6_metric > rt->fib6_metric)\n\t\t\t\t\tbreak;\n\t\t\t\tif (rt6_qualify_for_ecmp(iter)) {\n\t\t\t\t\t*ins = iter->fib6_next;\n\t\t\t\t\titer->fib6_node = NULL;\n\t\t\t\t\tfib6_purge_rt(iter, fn, info->nl_net);\n\t\t\t\t\tif (rcu_access_pointer(fn->rr_ptr) == iter)\n\t\t\t\t\t\tfn->rr_ptr = NULL;\n\t\t\t\t\tfib6_info_release(iter);\n\t\t\t\t\tnsiblings--;\n\t\t\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries--;\n\t\t\t\t} else {\n\t\t\t\t\tins = &iter->fib6_next;\n\t\t\t\t}\n\t\t\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\t}\n\t\t\tWARN_ON(nsiblings != 0);\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "description": "A race condition exists in the Linux Kernel where an unauthenticated attacker from an adjacent network could exploit it by sending an ICMPv6 router advertisement packet, potentially leading to arbitrary code execution.",
        "commit": "This vulnerability involves a revert of a specific commit due to race conditions related to the management of the `expires` field in a `fib6_info` structure. The original commit introduced issues where the garbage collection (gc) process could start before the entry was added to the gc list and the timer value was set, potentially leading to a use-after-free (UAF) condition. The recommended approach is to revert the commit and address the problem in a future release."
    }
]