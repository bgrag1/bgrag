[
    {
        "cwe": "CWE-401",
        "func_name": "eclipse/handle__publish",
        "score": 0.7760974168777466,
        "func_before": "int handle__publish(struct mosquitto *context)\n{\n\tuint8_t dup;\n\tint rc = 0;\n\tint rc2;\n\tuint8_t header = context->in_packet.command;\n\tint res = 0;\n\tstruct mosquitto_msg_store *msg, *stored = NULL;\n\tsize_t len;\n\tuint16_t slen;\n\tchar *topic_mount;\n\tmosquitto_property *properties = NULL;\n\tmosquitto_property *p, *p_prev;\n\tmosquitto_property *msg_properties_last;\n\tuint32_t message_expiry_interval = 0;\n\tint topic_alias = -1;\n\tuint8_t reason_code = 0;\n\tuint16_t mid = 0;\n\n\tif(context->state != mosq_cs_active){\n\t\treturn MOSQ_ERR_PROTOCOL;\n\t}\n\n\tmsg = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n\tif(msg == NULL){\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\n\tdup = (header & 0x08)>>3;\n\tmsg->qos = (header & 0x06)>>1;\n\tif(dup == 1 && msg->qos == 0){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n\t\t\t\t\"Invalid PUBLISH (QoS=0 and DUP=1) from %s, disconnecting.\", context->id);\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\tif(msg->qos == 3){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n\t\t\t\t\"Invalid QoS in PUBLISH from %s, disconnecting.\", context->id);\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\tif(msg->qos > context->max_qos){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n\t\t\t\t\"Too high QoS in PUBLISH from %s, disconnecting.\", context->id);\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_QOS_NOT_SUPPORTED;\n\t}\n\tmsg->retain = (header & 0x01);\n\n\tif(msg->retain && db.config->retain_available == false){\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_RETAIN_NOT_SUPPORTED;\n\t}\n\n\tif(packet__read_string(&context->in_packet, &msg->topic, &slen)){\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\tif(!slen && context->protocol != mosq_p_mqtt5){\n\t\t/* Invalid publish topic, disconnect client. */\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\n\tif(msg->qos > 0){\n\t\tif(packet__read_uint16(&context->in_packet, &mid)){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t\t}\n\t\tif(mid == 0){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t}\n\t\t/* It is important to have a separate copy of mid, because msg may be\n\t\t * freed before we want to send a PUBACK/PUBREC. */\n\t\tmsg->source_mid = mid;\n\t}\n\n\t/* Handle properties */\n\tif(context->protocol == mosq_p_mqtt5){\n\t\trc = property__read_all(CMD_PUBLISH, &context->in_packet, &properties);\n\t\tif(rc){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn rc;\n\t\t}\n\n\t\tp = properties;\n\t\tp_prev = NULL;\n\t\tmsg->properties = NULL;\n\t\tmsg_properties_last = NULL;\n\t\twhile(p){\n\t\t\tswitch(p->identifier){\n\t\t\t\tcase MQTT_PROP_CONTENT_TYPE:\n\t\t\t\tcase MQTT_PROP_CORRELATION_DATA:\n\t\t\t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n\t\t\t\tcase MQTT_PROP_RESPONSE_TOPIC:\n\t\t\t\tcase MQTT_PROP_USER_PROPERTY:\n\t\t\t\t\tif(msg->properties){\n\t\t\t\t\t\tmsg_properties_last->next = p;\n\t\t\t\t\t\tmsg_properties_last = p;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmsg->properties = p;\n\t\t\t\t\t\tmsg_properties_last = p;\n\t\t\t\t\t}\n\t\t\t\t\tif(p_prev){\n\t\t\t\t\t\tp_prev->next = p->next;\n\t\t\t\t\t\tp = p_prev->next;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tproperties = p->next;\n\t\t\t\t\t\tp = properties;\n\t\t\t\t\t}\n\t\t\t\t\tmsg_properties_last->next = NULL;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MQTT_PROP_TOPIC_ALIAS:\n\t\t\t\t\ttopic_alias = p->value.i16;\n\t\t\t\t\tp_prev = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n\t\t\t\t\tmessage_expiry_interval = p->value.i32;\n\t\t\t\t\tp_prev = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n\t\t\t\t\tp_prev = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmosquitto_property_free_all(&properties);\n\n\tif(topic_alias == 0 || (context->listener && topic_alias > context->listener->max_topic_alias)){\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_TOPIC_ALIAS_INVALID;\n\t}else if(topic_alias > 0){\n\t\tif(msg->topic){\n\t\t\trc = alias__add(context, msg->topic, (uint16_t)topic_alias);\n\t\t\tif(rc){\n\t\t\t\tdb__msg_store_free(msg);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}else{\n\t\t\trc = alias__find(context, &msg->topic, (uint16_t)topic_alias);\n\t\t\tif(rc){\n\t\t\t\tdb__msg_store_free(msg);\n\t\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef WITH_BRIDGE\n\trc = bridge__remap_topic_in(context, &msg->topic);\n\tif(rc){\n\t\tdb__msg_store_free(msg);\n\t\treturn rc;\n\t}\n\n#endif\n\tif(mosquitto_pub_topic_check(msg->topic) != MOSQ_ERR_SUCCESS){\n\t\t/* Invalid publish topic, just swallow it. */\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\n\tmsg->payloadlen = context->in_packet.remaining_length - context->in_packet.pos;\n\tG_PUB_BYTES_RECEIVED_INC(msg->payloadlen);\n\tif(context->listener && context->listener->mount_point){\n\t\tlen = strlen(context->listener->mount_point) + strlen(msg->topic) + 1;\n\t\ttopic_mount = mosquitto__malloc(len+1);\n\t\tif(!topic_mount){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t\tsnprintf(topic_mount, len, \"%s%s\", context->listener->mount_point, msg->topic);\n\t\ttopic_mount[len] = '\\0';\n\n\t\tmosquitto__free(msg->topic);\n\t\tmsg->topic = topic_mount;\n\t}\n\n\tif(msg->payloadlen){\n\t\tif(db.config->message_size_limit && msg->payloadlen > db.config->message_size_limit){\n\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Dropped too large PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);\n\t\t\treason_code = MQTT_RC_PACKET_TOO_LARGE;\n\t\t\tgoto process_bad_message;\n\t\t}\n\t\tmsg->payload = mosquitto__malloc(msg->payloadlen+1);\n\t\tif(msg->payload == NULL){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t\t/* Ensure payload is always zero terminated, this is the reason for the extra byte above */\n\t\t((uint8_t *)msg->payload)[msg->payloadlen] = 0;\n\n\t\tif(packet__read_bytes(&context->in_packet, msg->payload, msg->payloadlen)){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t\t}\n\t}\n\n\t/* Check for topic access */\n\trc = mosquitto_acl_check(context, msg->topic, msg->payloadlen, msg->payload, msg->qos, msg->retain, MOSQ_ACL_WRITE);\n\tif(rc == MOSQ_ERR_ACL_DENIED){\n\t\tlog__printf(NULL, MOSQ_LOG_DEBUG,\n\t\t\t\t\"Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\",\n\t\t\t\tcontext->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,\n\t\t\t\t(long)msg->payloadlen);\n\t\treason_code = MQTT_RC_NOT_AUTHORIZED;\n\t\tgoto process_bad_message;\n\t}else if(rc != MOSQ_ERR_SUCCESS){\n\t\tdb__msg_store_free(msg);\n\t\treturn rc;\n\t}\n\n\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Received PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);\n\n\tif(!strncmp(msg->topic, \"$CONTROL/\", 9)){\n#ifdef WITH_CONTROL\n\t\trc = control__process(context, msg);\n\t\tdb__msg_store_free(msg);\n\t\treturn rc;\n#else\n\t\treason_code = MQTT_RC_IMPLEMENTATION_SPECIFIC;\n\t\tgoto process_bad_message;\n#endif\n\t}\n\n\t{\n\t\trc = plugin__handle_message(context, msg);\n\t\tif(rc == MOSQ_ERR_ACL_DENIED){\n\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG,\n\t\t\t\t\t\"Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\",\n\t\t\t\t\tcontext->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,\n\t\t\t\t\t(long)msg->payloadlen);\n\n\t\t\treason_code = MQTT_RC_NOT_AUTHORIZED;\n\t\t\tgoto process_bad_message;\n\t\t}else if(rc != MOSQ_ERR_SUCCESS){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif(msg->qos > 0){\n\t\tdb__message_store_find(context, msg->source_mid, &stored);\n\t}\n\n\tif(stored && msg->source_mid != 0 &&\n\t\t\t(stored->qos != msg->qos\n\t\t\t || stored->payloadlen != msg->payloadlen\n\t\t\t || strcmp(stored->topic, msg->topic)\n\t\t\t || memcmp(stored->payload, msg->payload, msg->payloadlen) )){\n\n\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Reused message ID %u from %s detected. Clearing from storage.\", msg->source_mid, context->id);\n\t\tdb__message_remove_incoming(context, msg->source_mid);\n\t\tstored = NULL;\n\t}\n\n\tif(!stored){\n\t\tif(msg->qos == 0\n\t\t\t\t|| db__ready_for_flight(context, mosq_md_in, msg->qos)\n\t\t\t\t|| db__ready_for_queue(context, msg->qos, &context->msgs_in)){\n\n\t\t\tdup = 0;\n\t\t\trc = db__message_store(context, msg, message_expiry_interval, 0, mosq_mo_client);\n\t\t\tif(rc) return rc;\n\t\t}else{\n\t\t\t/* Client isn't allowed any more incoming messages, so fail early */\n\t\t\treason_code = MQTT_RC_QUOTA_EXCEEDED;\n\t\t\tgoto process_bad_message;\n\t\t}\n\t\tstored = msg;\n\t\tmsg = NULL;\n\t}else{\n\t\tdb__msg_store_free(msg);\n\t\tmsg = NULL;\n\t\tdup = 1;\n\t}\n\n\tswitch(stored->qos){\n\t\tcase 0:\n\t\t\trc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);\n\t\t\tif(rc2 > 0) rc = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tutil__decrement_receive_quota(context);\n\t\t\trc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);\n\t\t\t/* stored may now be free, so don't refer to it */\n\t\t\tif(rc2 == MOSQ_ERR_SUCCESS || context->protocol != mosq_p_mqtt5){\n\t\t\t\tif(send__puback(context, mid, 0, NULL)) rc = 1;\n\t\t\t}else if(rc2 == MOSQ_ERR_NO_SUBSCRIBERS){\n\t\t\t\tif(send__puback(context, mid, MQTT_RC_NO_MATCHING_SUBSCRIBERS, NULL)) rc = 1;\n\t\t\t}else{\n\t\t\t\trc = rc2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif(dup == 0){\n\t\t\t\tres = db__message_insert(context, stored->source_mid, mosq_md_in, stored->qos, stored->retain, stored, NULL, false);\n\t\t\t}else{\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t\t/* db__message_insert() returns 2 to indicate dropped message\n\t\t\t * due to queue. This isn't an error so don't disconnect them. */\n\t\t\t/* FIXME - this is no longer necessary due to failing early above */\n\t\t\tif(!res){\n\t\t\t\tif(send__pubrec(context, stored->source_mid, 0, NULL)) rc = 1;\n\t\t\t}else if(res == 1){\n\t\t\t\trc = 1;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tdb__message_write_queued_in(context);\n\treturn rc;\nprocess_bad_message:\n\trc = 1;\n\tif(msg){\n\t\tswitch(msg->qos){\n\t\t\tcase 0:\n\t\t\t\trc = MOSQ_ERR_SUCCESS;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\trc = send__puback(context, msg->source_mid, reason_code, NULL);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\trc = send__pubrec(context, msg->source_mid, reason_code, NULL);\n\t\t\t\tbreak;\n\t\t}\n\t\tdb__msg_store_free(msg);\n\t}\n\treturn rc;\n}",
        "func_after": "int handle__publish(struct mosquitto *context)\n{\n\tuint8_t dup;\n\tint rc = 0;\n\tint rc2;\n\tuint8_t header = context->in_packet.command;\n\tint res = 0;\n\tstruct mosquitto_msg_store *msg, *stored = NULL;\n\tstruct mosquitto_client_msg *cmsg_stored = NULL;\n\tsize_t len;\n\tuint16_t slen;\n\tchar *topic_mount;\n\tmosquitto_property *properties = NULL;\n\tmosquitto_property *p, *p_prev;\n\tmosquitto_property *msg_properties_last;\n\tuint32_t message_expiry_interval = 0;\n\tint topic_alias = -1;\n\tuint8_t reason_code = 0;\n\tuint16_t mid = 0;\n\n\tif(context->state != mosq_cs_active){\n\t\treturn MOSQ_ERR_PROTOCOL;\n\t}\n\n\tmsg = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n\tif(msg == NULL){\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\n\tdup = (header & 0x08)>>3;\n\tmsg->qos = (header & 0x06)>>1;\n\tif(dup == 1 && msg->qos == 0){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n\t\t\t\t\"Invalid PUBLISH (QoS=0 and DUP=1) from %s, disconnecting.\", context->id);\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\tif(msg->qos == 3){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n\t\t\t\t\"Invalid QoS in PUBLISH from %s, disconnecting.\", context->id);\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\tif(msg->qos > context->max_qos){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n\t\t\t\t\"Too high QoS in PUBLISH from %s, disconnecting.\", context->id);\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_QOS_NOT_SUPPORTED;\n\t}\n\tmsg->retain = (header & 0x01);\n\n\tif(msg->retain && db.config->retain_available == false){\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_RETAIN_NOT_SUPPORTED;\n\t}\n\n\tif(packet__read_string(&context->in_packet, &msg->topic, &slen)){\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\tif(!slen && context->protocol != mosq_p_mqtt5){\n\t\t/* Invalid publish topic, disconnect client. */\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\n\tif(msg->qos > 0){\n\t\tif(packet__read_uint16(&context->in_packet, &mid)){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t\t}\n\t\tif(mid == 0){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t}\n\t\t/* It is important to have a separate copy of mid, because msg may be\n\t\t * freed before we want to send a PUBACK/PUBREC. */\n\t\tmsg->source_mid = mid;\n\t}\n\n\t/* Handle properties */\n\tif(context->protocol == mosq_p_mqtt5){\n\t\trc = property__read_all(CMD_PUBLISH, &context->in_packet, &properties);\n\t\tif(rc){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn rc;\n\t\t}\n\n\t\tp = properties;\n\t\tp_prev = NULL;\n\t\tmsg->properties = NULL;\n\t\tmsg_properties_last = NULL;\n\t\twhile(p){\n\t\t\tswitch(p->identifier){\n\t\t\t\tcase MQTT_PROP_CONTENT_TYPE:\n\t\t\t\tcase MQTT_PROP_CORRELATION_DATA:\n\t\t\t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n\t\t\t\tcase MQTT_PROP_RESPONSE_TOPIC:\n\t\t\t\tcase MQTT_PROP_USER_PROPERTY:\n\t\t\t\t\tif(msg->properties){\n\t\t\t\t\t\tmsg_properties_last->next = p;\n\t\t\t\t\t\tmsg_properties_last = p;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmsg->properties = p;\n\t\t\t\t\t\tmsg_properties_last = p;\n\t\t\t\t\t}\n\t\t\t\t\tif(p_prev){\n\t\t\t\t\t\tp_prev->next = p->next;\n\t\t\t\t\t\tp = p_prev->next;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tproperties = p->next;\n\t\t\t\t\t\tp = properties;\n\t\t\t\t\t}\n\t\t\t\t\tmsg_properties_last->next = NULL;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MQTT_PROP_TOPIC_ALIAS:\n\t\t\t\t\ttopic_alias = p->value.i16;\n\t\t\t\t\tp_prev = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n\t\t\t\t\tmessage_expiry_interval = p->value.i32;\n\t\t\t\t\tp_prev = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n\t\t\t\t\tp_prev = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmosquitto_property_free_all(&properties);\n\n\tif(topic_alias == 0 || (context->listener && topic_alias > context->listener->max_topic_alias)){\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_TOPIC_ALIAS_INVALID;\n\t}else if(topic_alias > 0){\n\t\tif(msg->topic){\n\t\t\trc = alias__add(context, msg->topic, (uint16_t)topic_alias);\n\t\t\tif(rc){\n\t\t\t\tdb__msg_store_free(msg);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}else{\n\t\t\trc = alias__find(context, &msg->topic, (uint16_t)topic_alias);\n\t\t\tif(rc){\n\t\t\t\tdb__msg_store_free(msg);\n\t\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef WITH_BRIDGE\n\trc = bridge__remap_topic_in(context, &msg->topic);\n\tif(rc){\n\t\tdb__msg_store_free(msg);\n\t\treturn rc;\n\t}\n\n#endif\n\tif(mosquitto_pub_topic_check(msg->topic) != MOSQ_ERR_SUCCESS){\n\t\t/* Invalid publish topic, just swallow it. */\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\n\tmsg->payloadlen = context->in_packet.remaining_length - context->in_packet.pos;\n\tG_PUB_BYTES_RECEIVED_INC(msg->payloadlen);\n\tif(context->listener && context->listener->mount_point){\n\t\tlen = strlen(context->listener->mount_point) + strlen(msg->topic) + 1;\n\t\ttopic_mount = mosquitto__malloc(len+1);\n\t\tif(!topic_mount){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t\tsnprintf(topic_mount, len, \"%s%s\", context->listener->mount_point, msg->topic);\n\t\ttopic_mount[len] = '\\0';\n\n\t\tmosquitto__free(msg->topic);\n\t\tmsg->topic = topic_mount;\n\t}\n\n\tif(msg->payloadlen){\n\t\tif(db.config->message_size_limit && msg->payloadlen > db.config->message_size_limit){\n\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Dropped too large PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);\n\t\t\treason_code = MQTT_RC_PACKET_TOO_LARGE;\n\t\t\tgoto process_bad_message;\n\t\t}\n\t\tmsg->payload = mosquitto__malloc(msg->payloadlen+1);\n\t\tif(msg->payload == NULL){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t\t/* Ensure payload is always zero terminated, this is the reason for the extra byte above */\n\t\t((uint8_t *)msg->payload)[msg->payloadlen] = 0;\n\n\t\tif(packet__read_bytes(&context->in_packet, msg->payload, msg->payloadlen)){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t\t}\n\t}\n\n\t/* Check for topic access */\n\trc = mosquitto_acl_check(context, msg->topic, msg->payloadlen, msg->payload, msg->qos, msg->retain, MOSQ_ACL_WRITE);\n\tif(rc == MOSQ_ERR_ACL_DENIED){\n\t\tlog__printf(NULL, MOSQ_LOG_DEBUG,\n\t\t\t\t\"Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\",\n\t\t\t\tcontext->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,\n\t\t\t\t(long)msg->payloadlen);\n\t\treason_code = MQTT_RC_NOT_AUTHORIZED;\n\t\tgoto process_bad_message;\n\t}else if(rc != MOSQ_ERR_SUCCESS){\n\t\tdb__msg_store_free(msg);\n\t\treturn rc;\n\t}\n\n\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Received PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);\n\n\tif(!strncmp(msg->topic, \"$CONTROL/\", 9)){\n#ifdef WITH_CONTROL\n\t\trc = control__process(context, msg);\n\t\tdb__msg_store_free(msg);\n\t\treturn rc;\n#else\n\t\treason_code = MQTT_RC_IMPLEMENTATION_SPECIFIC;\n\t\tgoto process_bad_message;\n#endif\n\t}\n\n\t{\n\t\trc = plugin__handle_message(context, msg);\n\t\tif(rc == MOSQ_ERR_ACL_DENIED){\n\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG,\n\t\t\t\t\t\"Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\",\n\t\t\t\t\tcontext->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,\n\t\t\t\t\t(long)msg->payloadlen);\n\n\t\t\treason_code = MQTT_RC_NOT_AUTHORIZED;\n\t\t\tgoto process_bad_message;\n\t\t}else if(rc != MOSQ_ERR_SUCCESS){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif(msg->qos > 0){\n\t\tdb__message_store_find(context, msg->source_mid, &cmsg_stored);\n\t}\n\n\tif(cmsg_stored && cmsg_stored->store && msg->source_mid != 0 &&\n\t\t\t(cmsg_stored->store->qos != msg->qos\n\t\t\t || cmsg_stored->store->payloadlen != msg->payloadlen\n\t\t\t || strcmp(cmsg_stored->store->topic, msg->topic)\n\t\t\t || memcmp(cmsg_stored->store->payload, msg->payload, msg->payloadlen) )){\n\n\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Reused message ID %u from %s detected. Clearing from storage.\", msg->source_mid, context->id);\n\t\tdb__message_remove_incoming(context, msg->source_mid);\n\t\tcmsg_stored = NULL;\n\t}\n\n\tif(!cmsg_stored){\n\t\tif(msg->qos == 0\n\t\t\t\t|| db__ready_for_flight(context, mosq_md_in, msg->qos)\n\t\t\t\t){\n\n\t\t\tdup = 0;\n\t\t\trc = db__message_store(context, msg, message_expiry_interval, 0, mosq_mo_client);\n\t\t\tif(rc) return rc;\n\t\t}else{\n\t\t\t/* Client isn't allowed any more incoming messages, so fail early */\n\t\t\treason_code = MQTT_RC_QUOTA_EXCEEDED;\n\t\t\tgoto process_bad_message;\n\t\t}\n\t\tstored = msg;\n\t\tmsg = NULL;\n\t\tdup = 0;\n\t}else{\n\t\tdb__msg_store_free(msg);\n\t\tmsg = NULL;\n\t\tstored = cmsg_stored->store;\n\t\tcmsg_stored->dup++;\n\t\tdup = cmsg_stored->dup;\n\t}\n\n\tswitch(stored->qos){\n\t\tcase 0:\n\t\t\trc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);\n\t\t\tif(rc2 > 0) rc = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tutil__decrement_receive_quota(context);\n\t\t\trc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);\n\t\t\t/* stored may now be free, so don't refer to it */\n\t\t\tif(rc2 == MOSQ_ERR_SUCCESS || context->protocol != mosq_p_mqtt5){\n\t\t\t\tif(send__puback(context, mid, 0, NULL)) rc = 1;\n\t\t\t}else if(rc2 == MOSQ_ERR_NO_SUBSCRIBERS){\n\t\t\t\tif(send__puback(context, mid, MQTT_RC_NO_MATCHING_SUBSCRIBERS, NULL)) rc = 1;\n\t\t\t}else{\n\t\t\t\trc = rc2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif(dup == 0){\n\t\t\t\tres = db__message_insert(context, stored->source_mid, mosq_md_in, stored->qos, stored->retain, stored, NULL, false);\n\t\t\t}else{\n\t\t\t\tres = 0;\n\t\t\t}\n\n\t\t\t/* db__message_insert() returns 2 to indicate dropped message\n\t\t\t * due to queue. This isn't an error so don't disconnect them. */\n\t\t\t/* FIXME - this is no longer necessary due to failing early above */\n\t\t\tif(!res){\n\t\t\t\tif(dup == 0 || dup == 1){\n\t\t\t\t\trc2 = send__pubrec(context, stored->source_mid, 0, NULL);\n\t\t\t\t\tif(rc2) rc = rc2;\n\t\t\t\t}else{\n\t\t\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t\t\t}\n\t\t\t}else if(res == 1){\n\t\t\t\trc = 1;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tdb__message_write_queued_in(context);\n\treturn rc;\nprocess_bad_message:\n\trc = 1;\n\tif(msg){\n\t\tswitch(msg->qos){\n\t\t\tcase 0:\n\t\t\t\trc = MOSQ_ERR_SUCCESS;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\trc = send__puback(context, msg->source_mid, reason_code, NULL);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\trc = send__pubrec(context, msg->source_mid, reason_code, NULL);\n\t\t\t\tbreak;\n\t\t}\n\t\tdb__msg_store_free(msg);\n\t}\n\tif(context->out_packet_count >= db.config->max_queued_messages){\n\t\trc = MQTT_RC_QUOTA_EXCEEDED;\n\t}\n\treturn rc;\n}",
        "description": "The broker in Eclipse Mosquitto versions 1.3.2 through 2.x, prior to 2.0.16, suffers from a memory leak that can be exploited remotely. This vulnerability arises when a client sends numerous QoS 2 messages with duplicate message IDs and fails to respond to PUBREC commands. The issue stems from improper handling of the EAGAIN error returned by the libc send function.",
        "commit": "<Abstracted Description begin>\nA fix has been implemented for a vulnerability identified as CVE-2023-28366.\n<Abstracted Description end>"
    },
    {
        "cwe": "CWE-252",
        "func_name": "libtiff/createCroppedImage",
        "score": 0.7722901105880737,
        "func_before": "static int\ncreateCroppedImage(struct image_data *image, struct crop_mask *crop, \n                   unsigned char **read_buff_ptr, unsigned char **crop_buff_ptr)\n  {\n  tsize_t   cropsize;\n  unsigned  char *read_buff = NULL;\n  unsigned  char *crop_buff = NULL;\n  unsigned  char *new_buff  = NULL;\n  static    tsize_t  prev_cropsize = 0;\n\n  read_buff = *read_buff_ptr;\n\n  /* process full image, no crop buffer needed */\n  crop_buff = read_buff;\n  *crop_buff_ptr = read_buff;\n  crop->combined_width = image->width;\n  crop->combined_length = image->length;\n\n  cropsize = crop->bufftotal;\n  crop_buff = *crop_buff_ptr;\n  if (!crop_buff)\n    {\n    crop_buff = (unsigned char *)limitMalloc(cropsize);\n    *crop_buff_ptr = crop_buff;\n    _TIFFmemset(crop_buff, 0, cropsize);\n    prev_cropsize = cropsize;\n    }\n  else\n    {\n    if (prev_cropsize < cropsize)\n      {\n      new_buff = _TIFFrealloc(crop_buff, cropsize);\n      if (!new_buff)\n        {\n\tfree (crop_buff);\n        crop_buff = (unsigned char *)limitMalloc(cropsize);\n        }\n      else\n        crop_buff = new_buff;\n      _TIFFmemset(crop_buff, 0, cropsize);\n      }\n    }\n\n  if (!crop_buff)\n    {\n    TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");\n    return (-1);\n    }\n  *crop_buff_ptr = crop_buff;\n\n  if (crop->crop_mode & CROP_INVERT)\n    {\n    switch (crop->photometric)\n      {\n      /* Just change the interpretation */\n      case PHOTOMETRIC_MINISWHITE:\n      case PHOTOMETRIC_MINISBLACK:\n\t   image->photometric = crop->photometric;\n\t   break;\n      case INVERT_DATA_ONLY:\n      case INVERT_DATA_AND_TAG:\n           if (invertImage(image->photometric, image->spp, image->bps, \n                           crop->combined_width, crop->combined_length, crop_buff))\n             {\n             TIFFError(\"createCroppedImage\", \n                       \"Failed to invert colorspace for image or cropped selection\");\n             return (-1);\n             }\n           if (crop->photometric == INVERT_DATA_AND_TAG)\n             {\n             switch (image->photometric)\n               {\n               case PHOTOMETRIC_MINISWHITE:\n \t            image->photometric = PHOTOMETRIC_MINISBLACK;\n\t            break;\n               case PHOTOMETRIC_MINISBLACK:\n \t            image->photometric = PHOTOMETRIC_MINISWHITE;\n\t            break;\n               default:\n\t            break;\n\t       }\n\t     }\n           break;\n      default: break;\n      }\n    }\n\n  if (crop->crop_mode & CROP_MIRROR)\n    {\n    if (mirrorImage(image->spp, image->bps, crop->mirror, \n                    crop->combined_width, crop->combined_length, crop_buff))\n      {\n      TIFFError(\"createCroppedImage\", \"Failed to mirror image or cropped selection %s\", \n\t       (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");\n      return (-1);\n      }\n    }\n\n  if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n    {\n    if (rotateImage(crop->rotation, image, &crop->combined_width, \n                    &crop->combined_length, crop_buff_ptr))\n      {\n      TIFFError(\"createCroppedImage\", \n                \"Failed to rotate image or cropped selection by %\"PRIu16\" degrees\", crop->rotation);\n      return (-1);\n      }\n    }\n\n  if (crop_buff == read_buff) /* we used the read buffer for the crop buffer */\n    *read_buff_ptr = NULL;    /* so we don't try to free it later */\n\n  return (0);\n  }",
        "func_after": "static int\ncreateCroppedImage(struct image_data *image, struct crop_mask *crop, \n                   unsigned char **read_buff_ptr, unsigned char **crop_buff_ptr)\n  {\n  tsize_t   cropsize;\n  unsigned  char *read_buff = NULL;\n  unsigned  char *crop_buff = NULL;\n  unsigned  char *new_buff  = NULL;\n  static    tsize_t  prev_cropsize = 0;\n\n  read_buff = *read_buff_ptr;\n\n  /* process full image, no crop buffer needed */\n  crop_buff = read_buff;\n  *crop_buff_ptr = read_buff;\n  crop->combined_width = image->width;\n  crop->combined_length = image->length;\n\n  cropsize = crop->bufftotal;\n  crop_buff = *crop_buff_ptr;\n  if (!crop_buff)\n    {\n    crop_buff = (unsigned char *)limitMalloc(cropsize);\n    if (!crop_buff)\n    {\n        TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");\n        return (-1);\n    }\n    _TIFFmemset(crop_buff, 0, cropsize);\n    prev_cropsize = cropsize;\n    }\n  else\n    {\n    if (prev_cropsize < cropsize)\n      {\n      new_buff = _TIFFrealloc(crop_buff, cropsize);\n      if (!new_buff)\n        {\n\tfree (crop_buff);\n        crop_buff = (unsigned char *)limitMalloc(cropsize);\n        }\n      else\n        crop_buff = new_buff;\n      if (!crop_buff)\n      {\n          TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");\n          return (-1);\n      }\n      _TIFFmemset(crop_buff, 0, cropsize);\n      }\n    }\n\n  *crop_buff_ptr = crop_buff;\n\n  if (crop->crop_mode & CROP_INVERT)\n    {\n    switch (crop->photometric)\n      {\n      /* Just change the interpretation */\n      case PHOTOMETRIC_MINISWHITE:\n      case PHOTOMETRIC_MINISBLACK:\n\t   image->photometric = crop->photometric;\n\t   break;\n      case INVERT_DATA_ONLY:\n      case INVERT_DATA_AND_TAG:\n           if (invertImage(image->photometric, image->spp, image->bps, \n                           crop->combined_width, crop->combined_length, crop_buff))\n             {\n             TIFFError(\"createCroppedImage\", \n                       \"Failed to invert colorspace for image or cropped selection\");\n             return (-1);\n             }\n           if (crop->photometric == INVERT_DATA_AND_TAG)\n             {\n             switch (image->photometric)\n               {\n               case PHOTOMETRIC_MINISWHITE:\n \t            image->photometric = PHOTOMETRIC_MINISBLACK;\n\t            break;\n               case PHOTOMETRIC_MINISBLACK:\n \t            image->photometric = PHOTOMETRIC_MINISWHITE;\n\t            break;\n               default:\n\t            break;\n\t       }\n\t     }\n           break;\n      default: break;\n      }\n    }\n\n  if (crop->crop_mode & CROP_MIRROR)\n    {\n    if (mirrorImage(image->spp, image->bps, crop->mirror, \n                    crop->combined_width, crop->combined_length, crop_buff))\n      {\n      TIFFError(\"createCroppedImage\", \"Failed to mirror image or cropped selection %s\", \n\t       (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");\n      return (-1);\n      }\n    }\n\n  if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n    {\n    if (rotateImage(crop->rotation, image, &crop->combined_width, \n                    &crop->combined_length, crop_buff_ptr))\n      {\n      TIFFError(\"createCroppedImage\", \n                \"Failed to rotate image or cropped selection by %\"PRIu16\" degrees\", crop->rotation);\n      return (-1);\n      }\n    }\n\n  if (crop_buff == read_buff) /* we used the read buffer for the crop buffer */\n    *read_buff_ptr = NULL;    /* so we don't try to free it later */\n\n  return (0);\n  }",
        "description": "Unchecked return value leading to NULL pointer dereference in the tiffcrop utility of libtiff 4.3.0 enables attackers to trigger a denial-of-service condition through a specially crafted TIFF file. Users who compile libtiff from source can apply the fix available in commit f2b656e2.",
        "commit": "It was identified that checks for the return value of memory allocation functions like `malloc` were missing, which could lead to potential issues if the allocation fails."
    },
    {
        "cwe": "CWE-120",
        "func_name": "ClusterLabs/_blackbox_vlogger",
        "score": 0.7776357531547546,
        "func_before": "static void\n_blackbox_vlogger(int32_t target,\n\t\t  struct qb_log_callsite *cs, struct timespec *timestamp, va_list ap)\n{\n\tsize_t max_size;\n\tsize_t actual_size;\n\tuint32_t fn_size;\n\tchar *chunk;\n\tchar *msg_len_pt;\n\tuint32_t msg_len;\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\n\tif (t->instance == NULL) {\n\t\treturn;\n\t}\n\n\tfn_size = strlen(cs->function) + 1;\n\n\tactual_size = 4 * sizeof(uint32_t) + sizeof(uint8_t) + fn_size + sizeof(struct timespec);\n\tmax_size = actual_size + t->max_line_length;\n\n\tchunk = qb_rb_chunk_alloc(t->instance, max_size);\n\n\tif (chunk == NULL) {\n\t\t/* something bad has happened. abort blackbox logging */\n\t\tqb_util_perror(LOG_ERR, \"Blackbox allocation error, aborting blackbox log %s\", t->filename);\n\t\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t\t(struct qb_ringbuffer_s **) &t->instance\n\t\t));\n\t\treturn;\n\t}\n\n\t/* line number */\n\tmemcpy(chunk, &cs->lineno, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* tags */\n\tmemcpy(chunk, &cs->tags, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* log level/priority */\n\tmemcpy(chunk, &cs->priority, sizeof(uint8_t));\n\tchunk += sizeof(uint8_t);\n\n\t/* function name */\n\tmemcpy(chunk, &fn_size, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, cs->function, fn_size);\n\tchunk += fn_size;\n\n\t/* timestamp */\n\tmemcpy(chunk, timestamp, sizeof(struct timespec));\n\tchunk += sizeof(struct timespec);\n\n\t/* log message length */\n\tmsg_len_pt = chunk;\n\tchunk += sizeof(uint32_t);\n\n\t/* log message */\n\tmsg_len = qb_vsnprintf_serialize(chunk, max_size, cs->format, ap);\n\tif (msg_len >= max_size) {\n\t    chunk = msg_len_pt + sizeof(uint32_t); /* Reset */\n\n\t    /* Leave this at QB_LOG_MAX_LEN so as not to overflow the blackbox */\n\t    msg_len = qb_vsnprintf_serialize(chunk, QB_LOG_MAX_LEN,\n\t\t\"Log message too long to be stored in the blackbox.  \"\\\n\t\t\"Maximum is QB_LOG_MAX_LEN\" , ap);\n\t}\n\n\tactual_size += msg_len;\n\n\t/* now that we know the length, write it\n\t */\n\tmemcpy(msg_len_pt, &msg_len, sizeof(uint32_t));\n\n\t(void)qb_rb_chunk_commit(t->instance, actual_size);\n}",
        "func_after": "static void\n_blackbox_vlogger(int32_t target,\n\t\t  struct qb_log_callsite *cs, struct timespec *timestamp, va_list ap)\n{\n\tsize_t max_size;\n\tsize_t actual_size;\n\tuint32_t fn_size;\n\tchar *chunk;\n\tchar *msg_len_pt;\n\tuint32_t msg_len;\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\n\tif (t->instance == NULL) {\n\t\treturn;\n\t}\n\n\tfn_size = strlen(cs->function) + 1;\n\n\tactual_size = 4 * sizeof(uint32_t) + sizeof(uint8_t) + fn_size + sizeof(struct timespec);\n\tmax_size = actual_size + t->max_line_length;\n\n\tchunk = qb_rb_chunk_alloc(t->instance, max_size);\n\n\tif (chunk == NULL) {\n\t\t/* something bad has happened. abort blackbox logging */\n\t\tqb_util_perror(LOG_ERR, \"Blackbox allocation error, aborting blackbox log %s\", t->filename);\n\t\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t\t(struct qb_ringbuffer_s **) &t->instance\n\t\t));\n\t\treturn;\n\t}\n\n\t/* line number */\n\tmemcpy(chunk, &cs->lineno, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* tags */\n\tmemcpy(chunk, &cs->tags, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* log level/priority */\n\tmemcpy(chunk, &cs->priority, sizeof(uint8_t));\n\tchunk += sizeof(uint8_t);\n\n\t/* function name */\n\tmemcpy(chunk, &fn_size, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, cs->function, fn_size);\n\tchunk += fn_size;\n\n\t/* timestamp */\n\tmemcpy(chunk, timestamp, sizeof(struct timespec));\n\tchunk += sizeof(struct timespec);\n\n\t/* log message length */\n\tmsg_len_pt = chunk;\n\tchunk += sizeof(uint32_t);\n\n\t/* log message */\n\tmsg_len = qb_vsnprintf_serialize(chunk, t->max_line_length, cs->format, ap);\n\tif (msg_len >= t->max_line_length) {\n\t    chunk = msg_len_pt + sizeof(uint32_t); /* Reset */\n\n\t    /* Leave this at QB_LOG_MAX_LEN so as not to overflow the blackbox */\n\t    msg_len = qb_vsnprintf_serialize(chunk, QB_LOG_MAX_LEN,\n\t\t\"Log message too long to be stored in the blackbox.  \"\\\n\t\t\"Maximum is QB_LOG_MAX_LEN\" , ap);\n\t}\n\n\tactual_size += msg_len;\n\n\t/* now that we know the length, write it\n\t */\n\tmemcpy(msg_len_pt, &msg_len, sizeof(uint32_t));\n\n\t(void)qb_rb_chunk_commit(t->instance, actual_size);\n}",
        "description": "log_blackbox.c in libqb prior to version 2.0.8 is susceptible to a buffer overflow due to the neglect of considering the header size when processing long log messages.",
        "commit": "The vulnerability knowledge has been abstracted and generalized as follows:\n\n\"A function responsible for serializing log messages potentially suffers from an overflow issue due to improper buffer size calculation. The original implementation used 'max_size' to limit the length of the formatted log message, but failed to account for the additional space required for the log header ('actual_size'). This oversight has been corrected by adjusting the maximum length parameter to 't->max_line_length', ensuring it accurately reflects the remaining buffer space. Additionally, error checks have been introduced to the blackbox calls at the end of the test to ensure proper functionality and to prevent masking of failures.\""
    },
    {
        "cwe": "CWE-89",
        "func_name": "openlink/sqlo_add_table_ref",
        "score": 0.7735381722450256,
        "func_before": "void\nsqlo_add_table_ref (sqlo_t * so, ST ** tree_ret, dk_set_t *res)\n{\n  char tmp[10];\n  ST * tree = *tree_ret;\n  switch (tree->type)\n    {\n    case TABLE_REF:\n      {\n\tST * prev = tree->_.table_ref.table;\n\tif (ST_P (prev, SELECT_STMT))\n\t  {\n\t    tree->type = DERIVED_TABLE;\n\t    sqlp_view_def (NULL, tree->_.table_ref.table, 0);\n\t    sqlo_add_table_ref (so, tree_ret, res);\n\t    return;\n\t  }\n\tsqlo_add_table_ref (so, &tree->_.table_ref.table, res);\n\tif (prev != tree->_.table_ref.table)\n\t  *tree_ret = tree->_.table_ref.table;\n\tbreak;\n      }\n    case TABLE_DOTTED:\n      {\n\tST * with_view = sqlo_with_decl (so, tree);\n\tdbe_table_t *tb = with_view ? NULL : sch_name_to_table (wi_inst.wi_schema, tree->_.table.name);\n\tST * view;\n\tif (!tb && !with_view)\n\t  sqlc_error (so->so_sc->sc_cc, \"S0002\", \"No table %s\", tree->_.table.name);\n\tif (inside_view)\n\t  tree->_.table.name = t_box_copy (tb->tb_name);\n\tif (!with_view)\n\t  {\n\t    sqlc_table_used (so->so_sc, tb);\n\t    view = (ST*) sch_view_def (wi_inst.wi_schema, tb->tb_name);\n\t  }\n\telse\n\t  view = with_view;\n\tif (!view || inside_view)\n\t  {\n\t    remote_table_t * rt = find_remote_table (tb->tb_name, 0);\n\t    t_NEW_VARZ (op_table_t, ot);\n\t    ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts);\n\t    ot->ot_prefix = tree->_.table.prefix;\n\t    snprintf (tmp, sizeof (tmp), \"t%d\", so->so_name_ctr++);\n\t    ot->ot_new_prefix = t_box_string (tmp);\n\t    tree->_.table.prefix = ot->ot_new_prefix;\n\t    ot->ot_table = tb;\n\t    ot->ot_rds = rt ? rt->rt_rds : NULL;\n\t    ot->ot_u_id = (oid_t) unbox (tree->_.table.u_id);\n\t    ot->ot_g_id = (oid_t) unbox (tree->_.table.g_id);\n\t    if (ST_P (view, PROC_TABLE))\n\t      {\n\t\tot->ot_dt = view;\n\t\tsqlo_proc_table_cols (so, ot);\n\t\tot->ot_dt = NULL;\n\t\tot->ot_is_proc_view = 1;\n\t      }\n\t    sqlo_rls_add_condition (so, ot, res, tb);\n\t    t_set_push (&so->so_tables, (void*) ot);\n\t    sco_add_table (so->so_scope, ot);\n\t  }\n\telse\n\t  {\n\t    op_table_t * ot = NULL;\n\t    if (!with_view && !sec_tb_check (tb, (oid_t) unbox (tree->_.table.g_id), (oid_t) unbox (tree->_.table.u_id), GR_SELECT))\n\t      sqlc_new_error (so->so_sc->sc_cc, \"42000\", \"SQ070:SECURITY\", \"Must have select privileges on view %s\", tb->tb_name);\n\t    view = (ST*) t_box_copy_tree ((caddr_t) view);\n\t    if (ST_P (view, UNION_ST) ||\n\t\tST_P (view, UNION_ALL_ST) ||\n\t\tST_P (view, EXCEPT_ST) ||\n\t\tST_P (view, EXCEPT_ALL_ST) ||\n\t\tST_P (view, INTERSECT_ST) ||\n\t\tST_P (view, INTERSECT_ALL_ST))\n\t      {\n\t\tview = sqlp_view_def (NULL, view, 1);\n\t\tview = sqlc_union_dt_wrap (view);\n\t      }\n\t    sqlo_scope (so, &view);\n\t    if (ST_P (view, SELECT_STMT))\n\t      {\n\t\tot = (op_table_t *) so->so_tables->data;\n\t\tot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name;\n\t\tsco_add_table (so->so_scope, ot);\n\t      }\n\t    else\n\t      {\n\t\tt_NEW_VARZ (op_table_t, ot2);\n\t\tmemset (ot2, 0, sizeof (op_table_t));\n\t\tot = ot2;\n\t\tot->ot_dt = view;\n\t\tot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name;\n\t\tot->ot_new_prefix = sqlo_new_prefix (so);\n\t\tot->ot_left_sel = sqlp_union_tree_select (view);\n\t\tif (ST_P (view, PROC_TABLE))\n\t\t  {\n\t\t    sqlo_proc_table_cols (so, ot);\n\t\t    ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts);\n\t\t    ot->ot_is_proc_view = 1;\n\t\t  }\n\t\tsco_add_table (so->so_scope, ot);\n\t\tt_set_push (&so->so_tables, (void*) ot);\n\n\t      }\n\t    sqlo_rls_add_condition (so, ot, res, tb);\n\t    *tree_ret = (ST*) t_list (3, DERIVED_TABLE, ot->ot_dt, ot->ot_new_prefix);\n\t  }\n\tbreak;\n      }\n    case JOINED_TABLE:\n      {\n\tsql_scope_t *old_sco = so->so_scope;\n\tTNEW (sql_scope_t, sco);\n\top_table_t *right_ot, *left_ot;\n\ts_node_t *ptr;\n\tST *j_right;\n\tdk_set_t res_jt = NULL;\n\tint is_jtc, is_natural = (tree->_.join.is_natural &&\n\t    (!tree->_.join.cond || tree->_.join.cond == (ST *) STAR));\n\n\n\tmemset (sco, 0, sizeof (sql_scope_t));\n\tsco->sco_so = so;\n\tsco->sco_fun_refs_allowed = old_sco->sco_fun_refs_allowed;\n\tsco->sco_super = so->so_scope->sco_super;\n\tso->so_scope = sco;\n\n\tif (OJ_RIGHT == tree->_.join.type)\n\t  {\n\t    ST * tmp = tree->_.join.left;\n\t    tree->_.join.left = tree->_.join.right;\n\t    tree->_.join.right = tmp;\n\t    tree->_.join.type = OJ_LEFT;\n\t  }\n\tj_right = tree->_.join.left;\n\twhile (ST_P (j_right, TABLE_REF))\n\t  j_right = j_right->_.table_ref.table;\n\tis_jtc = ST_P (j_right, JOINED_TABLE);\n\tif (tree->_.join.type == OJ_FULL)\n\t  sco->sco_has_jt = 1;\n\tif (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)))\n\t  sco->sco_has_jt = 1;\n\tj_right = tree->_.join.right;\n\twhile (ST_P (j_right, TABLE_REF))\n\t  j_right = j_right->_.table_ref.table;\n\tis_jtc = ST_P (j_right, JOINED_TABLE);\n\tif (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)))\n\t  sco->sco_has_jt = 1;\n\tsqlo_add_table_ref (so, &tree->_.join.left, res);\n\tleft_ot = (op_table_t *) so->so_tables->data;\n\tsqlo_add_table_ref (so, &tree->_.join.right, is_jtc ? &res_jt : res);\n\tright_ot = (op_table_t *) so->so_tables->data;\n\tsqlo_natural_join_cond (so, left_ot, right_ot, tree);\n\tsqlo_scope (so, &(tree->_.join.cond));\n\t/* can be that the right subtree in a ij ends with oj in which case the right ot will be flagged outer. The cond in this case goes to to the top where, i.e. res, not to the join cond of the outer (optional) ot */\nif (J_INNER == tree->_.join.type && right_ot->ot_is_outer)\n  \t  t_st_and (&right_ot->ot_enclosing_where_cond, tree->_.join.cond); /*always ste, even if some joins may be made into dts later*/\n\n\telse\n\t  t_st_and (&right_ot->ot_join_cond, tree->_.join.cond); /*always ste, even if some joins may be made into dts later*/\n\tsco_merge (old_sco, sco);\n\tso->so_scope = old_sco;\n\tif (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)\n\t  right_ot->ot_is_outer = 1;\n\telse if (!sco->sco_has_jt && tree->_.join.type == J_INNER &&\n\t    !ST_P (left_ot->ot_dt, PROC_TABLE) &&\n\t    !ST_P (right_ot->ot_dt, PROC_TABLE))\n\t  {\n\t    t_set_push (res, tree);\n\t    break;\n\t  }\n\tbreak;\n      }\n    case DERIVED_TABLE:\n      {\n\top_table_t * ot;\n\tsqlo_scope (so, &(tree->_.table_ref.table));\n\tif (ST_P (tree->_.table_ref.table, SELECT_STMT))\n\t  {\n\t    ot = (op_table_t *) so->so_tables->data;\n\t    ot->ot_prefix = tree->_.table_ref.range;\n\t    tree->_.table_ref.range = ot->ot_new_prefix;\n/*\t    t_set_push (res, (void *) ot);*/\n\t    sco_add_table (so->so_scope, ot);\n\t    if (ot->ot_trans)\n\t      sqlo_trans_cols (so, ot);\n\t  }\n\telse\n\t  {\n\t    op_table_t *old_ot = so->so_tables ? (op_table_t *) so->so_tables->data : NULL;\n\t    t_NEW_VARZ (op_table_t, ot);\n\t    ot->ot_prefix = tree->_.table_ref.range;\n\t    ot->ot_dt = tree->_.table_ref.table;\n\t    ot->ot_new_prefix = sqlo_new_prefix (so);\n\t    tree->_.table_ref.range = ot->ot_new_prefix;\n\t    if (old_ot)\n\t      ot->ot_left_sel = old_ot->ot_left_sel;\n\t    else\n\t      ot->ot_left_sel = sqlp_union_tree_select (tree->_.table_ref.table);\n\t    if (ST_P (tree->_.table_ref.table, PROC_TABLE))\n\t      sqlo_proc_table_cols (so, ot);\n/*\t    t_set_push (res, (void *) ot);*/\n\t    sco_add_table (so->so_scope, ot);\n\t    t_set_push (&so->so_tables, (void*) ot);\n\t  }\n\tbreak;\n      }\n    }\n}",
        "func_after": "void\nsqlo_add_table_ref (sqlo_t * so, ST ** tree_ret, dk_set_t *res)\n{\n  char tmp[10];\n  ST * tree = *tree_ret;\n  switch (tree->type)\n    {\n    case TABLE_REF:\n      {\n\tST * prev = tree->_.table_ref.table;\n\tif (ST_P (prev, SELECT_STMT))\n\t  {\n\t    tree->type = DERIVED_TABLE;\n\t    sqlp_view_def (NULL, tree->_.table_ref.table, 0);\n\t    sqlo_add_table_ref (so, tree_ret, res);\n\t    return;\n\t  }\n\tsqlo_add_table_ref (so, &tree->_.table_ref.table, res);\n\tif (prev != tree->_.table_ref.table)\n\t  *tree_ret = tree->_.table_ref.table;\n\tbreak;\n      }\n    case TABLE_DOTTED:\n      {\n\tST * with_view = sqlo_with_decl (so, tree);\n\tdbe_table_t *tb = with_view ? NULL : sch_name_to_table (wi_inst.wi_schema, tree->_.table.name);\n\tST * view;\n\tif (!tb && !with_view)\n\t  sqlc_error (so->so_sc->sc_cc, \"S0002\", \"No table %s\", tree->_.table.name);\n\tif (inside_view)\n\t  tree->_.table.name = t_box_copy (tb->tb_name);\n\tif (!with_view)\n\t  {\n\t    sqlc_table_used (so->so_sc, tb);\n\t    view = (ST*) sch_view_def (wi_inst.wi_schema, tb->tb_name);\n\t  }\n\telse\n\t  view = with_view;\n\tif (!view || inside_view)\n\t  {\n\t    remote_table_t * rt = find_remote_table (tb->tb_name, 0);\n\t    t_NEW_VARZ (op_table_t, ot);\n\t    ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts);\n\t    ot->ot_prefix = tree->_.table.prefix;\n\t    snprintf (tmp, sizeof (tmp), \"t%d\", so->so_name_ctr++);\n\t    ot->ot_new_prefix = t_box_string (tmp);\n\t    tree->_.table.prefix = ot->ot_new_prefix;\n\t    ot->ot_table = tb;\n\t    ot->ot_rds = rt ? rt->rt_rds : NULL;\n\t    ot->ot_u_id = (oid_t) unbox (tree->_.table.u_id);\n\t    ot->ot_g_id = (oid_t) unbox (tree->_.table.g_id);\n\t    if (ST_P (view, PROC_TABLE))\n\t      {\n\t\tot->ot_dt = view;\n\t\tsqlo_proc_table_cols (so, ot);\n\t\tot->ot_dt = NULL;\n\t\tot->ot_is_proc_view = 1;\n\t      }\n\t    sqlo_rls_add_condition (so, ot, res, tb);\n\t    t_set_push (&so->so_tables, (void*) ot);\n\t    sco_add_table (so->so_scope, ot);\n\t  }\n\telse\n\t  {\n\t    op_table_t * ot = NULL;\n\t    if (!with_view && !sec_tb_check (tb, (oid_t) unbox (tree->_.table.g_id), (oid_t) unbox (tree->_.table.u_id), GR_SELECT))\n\t      sqlc_new_error (so->so_sc->sc_cc, \"42000\", \"SQ070:SECURITY\", \"Must have select privileges on view %s\", tb->tb_name);\n\t    view = (ST*) t_box_copy_tree ((caddr_t) view);\n\t    if (ST_P (view, UNION_ST) ||\n\t\tST_P (view, UNION_ALL_ST) ||\n\t\tST_P (view, EXCEPT_ST) ||\n\t\tST_P (view, EXCEPT_ALL_ST) ||\n\t\tST_P (view, INTERSECT_ST) ||\n\t\tST_P (view, INTERSECT_ALL_ST))\n\t      {\n\t\tview = sqlp_view_def (NULL, view, 1);\n\t\tview = sqlc_union_dt_wrap (so->so_sc, view);\n\t      }\n\t    sqlo_scope (so, &view);\n\t    if (ST_P (view, SELECT_STMT))\n\t      {\n\t\tot = (op_table_t *) so->so_tables->data;\n\t\tot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name;\n\t\tsco_add_table (so->so_scope, ot);\n\t      }\n\t    else\n\t      {\n\t\tt_NEW_VARZ (op_table_t, ot2);\n\t\tmemset (ot2, 0, sizeof (op_table_t));\n\t\tot = ot2;\n\t\tot->ot_dt = view;\n\t\tot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name;\n\t\tot->ot_new_prefix = sqlo_new_prefix (so);\n\t\tot->ot_left_sel = sqlp_union_tree_select (view);\n\t\tif (ST_P (view, PROC_TABLE))\n\t\t  {\n\t\t    sqlo_proc_table_cols (so, ot);\n\t\t    ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts);\n\t\t    ot->ot_is_proc_view = 1;\n\t\t  }\n\t\tsco_add_table (so->so_scope, ot);\n\t\tt_set_push (&so->so_tables, (void*) ot);\n\n\t      }\n\t    sqlo_rls_add_condition (so, ot, res, tb);\n\t    *tree_ret = (ST*) t_list (3, DERIVED_TABLE, ot->ot_dt, ot->ot_new_prefix);\n\t  }\n\tbreak;\n      }\n    case JOINED_TABLE:\n      {\n\tsql_scope_t *old_sco = so->so_scope;\n\tTNEW (sql_scope_t, sco);\n\top_table_t *right_ot, *left_ot;\n\ts_node_t *ptr;\n\tST *j_right;\n\tdk_set_t res_jt = NULL;\n\tint is_jtc, is_natural = (tree->_.join.is_natural &&\n\t    (!tree->_.join.cond || tree->_.join.cond == (ST *) STAR));\n\n\n\tmemset (sco, 0, sizeof (sql_scope_t));\n\tsco->sco_so = so;\n\tsco->sco_fun_refs_allowed = old_sco->sco_fun_refs_allowed;\n\tsco->sco_super = so->so_scope->sco_super;\n\tso->so_scope = sco;\n\n\tif (OJ_RIGHT == tree->_.join.type)\n\t  {\n\t    ST * tmp = tree->_.join.left;\n\t    tree->_.join.left = tree->_.join.right;\n\t    tree->_.join.right = tmp;\n\t    tree->_.join.type = OJ_LEFT;\n\t  }\n\tj_right = tree->_.join.left;\n\twhile (ST_P (j_right, TABLE_REF))\n\t  j_right = j_right->_.table_ref.table;\n\tis_jtc = ST_P (j_right, JOINED_TABLE);\n\tif (tree->_.join.type == OJ_FULL)\n\t  sco->sco_has_jt = 1;\n\tif (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)))\n\t  sco->sco_has_jt = 1;\n\tj_right = tree->_.join.right;\n\twhile (ST_P (j_right, TABLE_REF))\n\t  j_right = j_right->_.table_ref.table;\n\tis_jtc = ST_P (j_right, JOINED_TABLE);\n\tif (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)))\n\t  sco->sco_has_jt = 1;\n\tsqlo_add_table_ref (so, &tree->_.join.left, res);\n\tleft_ot = (op_table_t *) so->so_tables->data;\n\tsqlo_add_table_ref (so, &tree->_.join.right, is_jtc ? &res_jt : res);\n\tright_ot = (op_table_t *) so->so_tables->data;\n\tsqlo_natural_join_cond (so, left_ot, right_ot, tree);\n\tsqlo_scope (so, &(tree->_.join.cond));\n\t/* can be that the right subtree in a ij ends with oj in which case the right ot will be flagged outer. The cond in this case goes to to the top where, i.e. res, not to the join cond of the outer (optional) ot */\nif (J_INNER == tree->_.join.type && right_ot->ot_is_outer)\n  \t  t_st_and (&right_ot->ot_enclosing_where_cond, tree->_.join.cond); /*always ste, even if some joins may be made into dts later*/\n\n\telse\n\t  t_st_and (&right_ot->ot_join_cond, tree->_.join.cond); /*always ste, even if some joins may be made into dts later*/\n\tsco_merge (old_sco, sco);\n\tso->so_scope = old_sco;\n\tif (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)\n\t  right_ot->ot_is_outer = 1;\n\telse if (!sco->sco_has_jt && tree->_.join.type == J_INNER &&\n\t    !ST_P (left_ot->ot_dt, PROC_TABLE) &&\n\t    !ST_P (right_ot->ot_dt, PROC_TABLE))\n\t  {\n\t    t_set_push (res, tree);\n\t    break;\n\t  }\n\tbreak;\n      }\n    case DERIVED_TABLE:\n      {\n\top_table_t * ot;\n\tsqlo_scope (so, &(tree->_.table_ref.table));\n\tif (ST_P (tree->_.table_ref.table, SELECT_STMT))\n\t  {\n\t    ot = (op_table_t *) so->so_tables->data;\n\t    ot->ot_prefix = tree->_.table_ref.range;\n\t    tree->_.table_ref.range = ot->ot_new_prefix;\n/*\t    t_set_push (res, (void *) ot);*/\n\t    sco_add_table (so->so_scope, ot);\n\t    if (ot->ot_trans)\n\t      sqlo_trans_cols (so, ot);\n\t  }\n\telse\n\t  {\n\t    op_table_t *old_ot = so->so_tables ? (op_table_t *) so->so_tables->data : NULL;\n\t    t_NEW_VARZ (op_table_t, ot);\n\t    ot->ot_prefix = tree->_.table_ref.range;\n\t    ot->ot_dt = tree->_.table_ref.table;\n\t    ot->ot_new_prefix = sqlo_new_prefix (so);\n\t    tree->_.table_ref.range = ot->ot_new_prefix;\n\t    if (old_ot)\n\t      ot->ot_left_sel = old_ot->ot_left_sel;\n\t    else\n\t      ot->ot_left_sel = sqlp_union_tree_select (tree->_.table_ref.table);\n\t    if (ST_P (tree->_.table_ref.table, PROC_TABLE))\n\t      sqlo_proc_table_cols (so, ot);\n/*\t    t_set_push (res, (void *) ot);*/\n\t    sco_add_table (so->so_scope, ot);\n\t    t_set_push (&so->so_tables, (void*) ot);\n\t  }\n\tbreak;\n      }\n    }\n}",
        "description": "An issue in the sqlc_union_dt_wrap component of OpenLink Virtuoso Open Source allows attackers to trigger a Denial of Service (DoS) condition through the use of specially crafted SQL statements.",
        "commit": "The support for fixed non-terminals in union branches is not implemented, which may lead to issues or unexpected behavior in certain scenarios."
    },
    {
        "cwe": "CWE-909",
        "func_name": "eclipse-openj9/resolveStaticMethodRefInto",
        "score": 0.7759565711021423,
        "func_before": "J9Method *   \nresolveStaticMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMStaticMethodRef *ramCPEntry)\n{\n\tJ9ROMMethodRef *romMethodRef;\n\tJ9Class *resolvedClass;\n\tJ9Method *method = NULL;\n\tJ9Class *cpClass;\n\tJ9Class *methodClass = NULL;\n\tBOOLEAN isResolvedClassAnInterface = FALSE;\n\tJ9ROMNameAndSignature *nameAndSig = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveStaticMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\ntryAgain:\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\tnameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\t/* Stack allocate a J9NameAndSignature structure for polymorphic signature methods */\n\tJ9NameAndSignature onStackNAS = {NULL, NULL};\n\tJ9UTF8 nullSignature = {0};\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\tif (resolvedClass == NULL) {\n\t\tgoto done;\n\t}\n\tisResolvedClassAnInterface = (J9AccInterface == (resolvedClass->romClass->modifiers & J9AccInterface));\n\n\t/* Find the method. */\n\tlookupOptions |= J9_LOOK_STATIC;\n\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) == J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\tcpClass = NULL;\n\t} else {\n\t\tcpClass = J9_CLASS_FROM_CP(ramCP);\n\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\n\t\tif (J2SE_VERSION(vmStruct->javaVM) >= J2SE_V11) {\n\t\t\t/* This check is only required in Java9 and there have been applications that\n\t\t\t * fail when this check is enabled on Java8.\n\t\t\t */\n\t\t\tif ((cpClass != NULL) && (cpClass->romClass != NULL)) {\n\t\t\t\tUDATA cpType = J9_CP_TYPE(J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass), cpIndex);\n\t\t\t\tif (isResolvedClassAnInterface) {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_STATIC_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_INSTANCE_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_METHOD != cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_STATIC_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_INSTANCE_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_METHOD == cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (isResolvedClassAnInterface) {\n\t\tlookupOptions |= J9_LOOK_INTERFACE;\n\t}\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vmStruct->javaVM)) {\n\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t/**\n\t\t * Check for MH intrinsic methods\n\t\t *\n\t\t * Modify the signature to avoid signature mismatch due to varargs\n\t\t * These methods have special INL send targets\n\t\t */\n\t\tU_8* methodName = J9UTF8_DATA(nameUTF);\n\t\tU_16 methodNameLength = J9UTF8_LENGTH(nameUTF);\n\n\t\tif (isMethodHandleINL(methodName, methodNameLength)) {\n\t\t\t/* Create new J9NameAndSignature */\n\t\t\tonStackNAS.name = nameUTF;\n\t\t\tonStackNAS.signature = &nullSignature;\n\t\t\tnameAndSig = (J9ROMNameAndSignature *)(&onStackNAS);\n\n\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n\t\t\tlookupOptions |= (J9_LOOK_DIRECT_NAS | J9_LOOK_PARTIAL_SIGNATURE);\n\t\t}\n\t}\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, nameAndSig, cpClass, lookupOptions);\n\n\tTrc_VM_resolveStaticMethodRef_lookupMethod(vmStruct, method);\n\n\tif (method == NULL) {\n\t\tgoto done;\n\t}\n\n\tmethodClass = J9_CLASS_FROM_METHOD(method);\n\tif (methodClass != resolvedClass) {\n\t\tif (isResolvedClassAnInterface) {\nincompat:\n\t\t\tif (throwException) {\n\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, NULL);\n\t\t\t}\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Initialize the defining class of the method. */\n\t\n\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CLASS_INIT)) {\n\t\tJ9Class *methodClass = J9_CLASS_FROM_METHOD(method);\n\t\tUDATA initStatus = methodClass->initializeStatus;\n\t\tif (jitCompileTimeResolve && (J9ClassInitSucceeded != initStatus)) {\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t\tif (initStatus != J9ClassInitSucceeded && initStatus != (UDATA)vmStruct) {\n\t\t\t/* Initialize the class if java code is allowed */\n\t\t\tif (canRunJavaCode) {\n\t\t\t\tUDATA preCount = vmStruct->javaVM->hotSwapCount;\n\n\t\t\t\tinitializeClass(vmStruct, methodClass);\n\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\tmethod = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (preCount != vmStruct->javaVM->hotSwapCount) {\n\t\t\t\t\tgoto tryAgain;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Can't initialize the class, so fail the resolve */\n\t\t\t\tmethod = NULL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tif (NULL != ramCPEntry)\n\t{\n\t\tramCPEntry->method = method;\n\t}\n\ndone:\n\tTrc_VM_resolveStaticMethodRef_Exit(vmStruct, method);\n\treturn method;\n}",
        "func_after": "J9Method *   \nresolveStaticMethodRefInto(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags, J9RAMStaticMethodRef *ramCPEntry)\n{\n\tJ9ROMMethodRef *romMethodRef;\n\tJ9Class *resolvedClass;\n\tJ9Method *method = NULL;\n\tJ9Class *cpClass;\n\tJ9Class *methodClass = NULL;\n\tBOOLEAN isResolvedClassAnInterface = FALSE;\n\tJ9ROMNameAndSignature *nameAndSig = NULL;\n\tbool jitCompileTimeResolve = J9_ARE_ANY_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_JIT_COMPILE_TIME);\n\tbool canRunJavaCode = !jitCompileTimeResolve && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_REDEFINE_CLASS);\n\tbool throwException = canRunJavaCode && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_THROW_ON_FAIL);\n\tUDATA lookupOptions = 0;\n\tif (canRunJavaCode) {\n\t\tif (!throwException) {\n\t\t\tlookupOptions = J9_LOOK_NO_THROW;\t\t\t\n\t\t}\n\t} else {\n\t\tlookupOptions = J9_LOOK_NO_JAVA;\n\t}\n\n\tTrc_VM_resolveStaticMethodRef_Entry(vmStruct, ramCP, cpIndex, resolveFlags);\n\ntryAgain:\n\tromMethodRef = (J9ROMMethodRef *)&ramCP->romConstantPool[cpIndex];\n\tnameAndSig = J9ROMMETHODREF_NAMEANDSIGNATURE(romMethodRef);\n\n\tcheckForDecompile(vmStruct, romMethodRef, jitCompileTimeResolve);\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\t/* Stack allocate a J9NameAndSignature structure for polymorphic signature methods */\n\tJ9NameAndSignature onStackNAS = {NULL, NULL};\n\tJ9UTF8 nullSignature = {0};\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\n\t/* Resolve the class. */\n\tresolvedClass = resolveClassRef(vmStruct, ramCP, romMethodRef->classRefCPIndex, resolveFlags);\n\tif (resolvedClass == NULL) {\n\t\tgoto done;\n\t}\n\tisResolvedClassAnInterface = (J9AccInterface == (resolvedClass->romClass->modifiers & J9AccInterface));\n\n\t/* Find the method. */\n\tlookupOptions |= J9_LOOK_STATIC;\n\tif ((resolveFlags & J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) == J9_RESOLVE_FLAG_JCL_CONSTANT_POOL) {\n\t\tcpClass = NULL;\n\t} else {\n\t\tcpClass = J9_CLASS_FROM_CP(ramCP);\n\t\tlookupOptions |= J9_LOOK_CLCONSTRAINTS;\n\n\t\tif (J2SE_VERSION(vmStruct->javaVM) >= J2SE_V11) {\n\t\t\t/* This check is only required in Java9 and there have been applications that\n\t\t\t * fail when this check is enabled on Java8.\n\t\t\t */\n\t\t\tif ((cpClass != NULL) && (cpClass->romClass != NULL)) {\n\t\t\t\tUDATA cpType = J9_CP_TYPE(J9ROMCLASS_CPSHAPEDESCRIPTION(cpClass->romClass), cpIndex);\n\t\t\t\tif (isResolvedClassAnInterface) {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_STATIC_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_INSTANCE_METHOD != cpType)\n\t\t\t\t\t&& (J9CPTYPE_INTERFACE_METHOD != cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((J9CPTYPE_INTERFACE_STATIC_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_INSTANCE_METHOD == cpType)\n\t\t\t\t\t|| (J9CPTYPE_INTERFACE_METHOD == cpType)\n\t\t\t\t\t) {\n\t\t\t\t\t\tgoto incompat;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (isResolvedClassAnInterface) {\n\t\tlookupOptions |= J9_LOOK_INTERFACE;\n\t}\n\n#if defined(J9VM_OPT_OPENJDK_METHODHANDLE)\n\tif (resolvedClass == J9VMJAVALANGINVOKEMETHODHANDLE(vmStruct->javaVM)) {\n\t\tJ9UTF8 *nameUTF = J9ROMNAMEANDSIGNATURE_NAME(nameAndSig);\n\t\t/**\n\t\t * Check for MH intrinsic methods\n\t\t *\n\t\t * Modify the signature to avoid signature mismatch due to varargs\n\t\t * These methods have special INL send targets\n\t\t */\n\t\tU_8* methodName = J9UTF8_DATA(nameUTF);\n\t\tU_16 methodNameLength = J9UTF8_LENGTH(nameUTF);\n\n\t\tif (isMethodHandleINL(methodName, methodNameLength)) {\n\t\t\t/* Create new J9NameAndSignature */\n\t\t\tonStackNAS.name = nameUTF;\n\t\t\tonStackNAS.signature = &nullSignature;\n\t\t\tnameAndSig = (J9ROMNameAndSignature *)(&onStackNAS);\n\n\t\t\t/* Set flag for partial signature lookup. Signature length is already initialized to 0. */\n\t\t\tlookupOptions |= (J9_LOOK_DIRECT_NAS | J9_LOOK_PARTIAL_SIGNATURE);\n\t\t}\n\t}\n#endif /* defined(J9VM_OPT_OPENJDK_METHODHANDLE) */\n\tmethod = (J9Method *)javaLookupMethod(vmStruct, resolvedClass, nameAndSig, cpClass, lookupOptions);\n\n\tTrc_VM_resolveStaticMethodRef_lookupMethod(vmStruct, method);\n\n\tif (method == NULL) {\n\t\tgoto done;\n\t}\n\n\tmethodClass = J9_CLASS_FROM_METHOD(method);\n\tif (methodClass != resolvedClass) {\n\t\tif (isResolvedClassAnInterface) {\nincompat:\n\t\t\tif (throwException) {\n\t\t\t\tsetCurrentException(vmStruct, J9VMCONSTANTPOOL_JAVALANGINCOMPATIBLECLASSCHANGEERROR, NULL);\n\t\t\t}\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Initialize the defining class of the method. */\n\t\n\tif (J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CLASS_INIT)) {\n\t\tJ9Class *methodClass = J9_CLASS_FROM_METHOD(method);\n\t\tUDATA initStatus = methodClass->initializeStatus;\n\t\tif (jitCompileTimeResolve && (J9ClassInitSucceeded != initStatus)) {\n\t\t\tmethod = NULL;\n\t\t\tgoto done;\n\t\t}\n\t\tif (initStatus != J9ClassInitSucceeded && initStatus != (UDATA)vmStruct) {\n\t\t\t/* Initialize the class if java code is allowed */\n\t\t\tif (canRunJavaCode) {\n\t\t\t\tUDATA preCount = vmStruct->javaVM->hotSwapCount;\n\n\t\t\t\tinitializeClass(vmStruct, methodClass);\n\t\t\t\tif (threadEventsPending(vmStruct)) {\n\t\t\t\t\tmethod = NULL;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (preCount != vmStruct->javaVM->hotSwapCount) {\n\t\t\t\t\tgoto tryAgain;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Can't initialize the class, so fail the resolve */\n\t\t\t\tmethod = NULL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\tif ((NULL != ramCPEntry) && J9_ARE_NO_BITS_SET(resolveFlags, J9_RESOLVE_FLAG_NO_CP_UPDATE)) {\n\t\tramCPEntry->method = method;\n\t}\n\ndone:\n\tTrc_VM_resolveStaticMethodRef_Exit(vmStruct, method);\n\treturn method;\n}",
        "description": "In Eclipse OpenJ9 up to version 0.25.0, the use of the `jdk.internal.reflect.ConstantPool` API leads to the JVM pre-resolving certain constant pool entries in some cases. This behavior enables users to invoke static methods or access static members without executing the class initialization method, potentially allowing them to observe uninitialized values.",
        "commit": "When utilizing ConstantPool, ensure that classes are correctly loaded and initialized. Avoid loading classes during \"ifLoaded\" calls, refrain from initializing classes in native methods, and do not update the constant pool when querying from native methods."
    }
]