[
    {
        "cwe": "CWE-347",
        "func_name": "rpm-software-management/pgpPrtParams",
        "score": 0.685455858707428,
        "func_before": "int pgpPrtParams(const uint8_t * pkts, size_t pktlen, unsigned int pkttype,\n\t\t pgpDigParams * ret)\n{\n    const uint8_t *p = pkts;\n    const uint8_t *pend = pkts + pktlen;\n    pgpDigParams digp = NULL;\n    struct pgpPkt pkt;\n    int rc = -1; /* assume failure */\n\n    while (p < pend) {\n\tif (decodePkt(p, (pend - p), &pkt))\n\t    break;\n\n\tif (digp == NULL) {\n\t    if (pkttype && pkt.tag != pkttype) {\n\t\tbreak;\n\t    } else {\n\t\tdigp = pgpDigParamsNew(pkt.tag);\n\t    }\n\t}\n\n\tif (pgpPrtPkt(&pkt, digp))\n\t    break;\n\n\tp += (pkt.body - pkt.head) + pkt.blen;\n\tif (pkttype == PGPTAG_SIGNATURE)\n\t    break;\n    }\n\n    rc = (digp && (p == pend)) ? 0 : -1;\n\n    if (ret && rc == 0) {\n\t*ret = digp;\n    } else {\n\tpgpDigParamsFree(digp);\n    }\n    return rc;\n}",
        "func_after": "int pgpPrtParams(const uint8_t * pkts, size_t pktlen, unsigned int pkttype,\n\t\t pgpDigParams * ret)\n{\n    const uint8_t *p = pkts;\n    const uint8_t *pend = pkts + pktlen;\n    pgpDigParams digp = NULL;\n    pgpDigParams selfsig = NULL;\n    int i = 0;\n    int alloced = 16; /* plenty for normal cases */\n    struct pgpPkt *all = xmalloc(alloced * sizeof(*all));\n    int rc = -1; /* assume failure */\n    int expect = 0;\n    int prevtag = 0;\n\n    while (p < pend) {\n\tstruct pgpPkt *pkt = &all[i];\n\tif (decodePkt(p, (pend - p), pkt))\n\t    break;\n\n\tif (digp == NULL) {\n\t    if (pkttype && pkt->tag != pkttype) {\n\t\tbreak;\n\t    } else {\n\t\tdigp = pgpDigParamsNew(pkt->tag);\n\t    }\n\t}\n\n\tif (expect) {\n\t    if (pkt->tag != expect)\n\t\tbreak;\n\t    selfsig = pgpDigParamsNew(pkt->tag);\n\t}\n\n\tif (pgpPrtPkt(pkt, selfsig ? selfsig : digp))\n\t    break;\n\n\tif (selfsig) {\n\t    /* subkeys must be followed by binding signature */\n\t    if (prevtag == PGPTAG_PUBLIC_SUBKEY) {\n\t\tif (selfsig->sigtype != PGPSIGTYPE_SUBKEY_BINDING)\n\t\t    break;\n\t    }\n\n\t    int xx = pgpVerifySelf(digp, selfsig, all, i);\n\n\t    selfsig = pgpDigParamsFree(selfsig);\n\t    if (xx)\n\t\tbreak;\n\t    expect = 0;\n\t}\n\n\tif (pkt->tag == PGPTAG_PUBLIC_SUBKEY)\n\t    expect = PGPTAG_SIGNATURE;\n\tprevtag = pkt->tag;\n\n\ti++;\n\tp += (pkt->body - pkt->head) + pkt->blen;\n\tif (pkttype == PGPTAG_SIGNATURE)\n\t    break;\n\n\tif (alloced <= i) {\n\t    alloced *= 2;\n\t    all = xrealloc(all, alloced * sizeof(*all));\n\t}\n    }\n\n    rc = (digp && (p == pend) && expect == 0) ? 0 : -1;\n\n    free(all);\n    if (ret && rc == 0) {\n\t*ret = digp;\n    } else {\n\tpgpDigParamsFree(digp);\n    }\n    return rc;\n}",
        "description": "There is a flaw in RPM's signature functionality where it does not verify the binding signature of subkeys before importing them. This can allow an attacker to add or trick another party into adding a malicious subkey to a legitimate public key, potentially causing RPM to trust a malicious signature. The primary impact of this flaw is on data integrity. Exploitation requires compromising an RPM repository or convincing an administrator to install an untrusted RPM or public key. It is recommended to only use RPMs and public keys from trusted sources.",
        "commit": "To enhance the applicability of the given vulnerability knowledge across different scenarios, we can abstract and generalize it as follows:\n\n**Abstracted and Generalized Description:**\n\n\"A vulnerability was identified in the parsing mechanism of PGP public keys, where the implementation lacked enforcement of subkey binding signatures as mandated by the OpenPGP RFC. To address this, a workaround was introduced to ensure that all subkeys are validated by a binding signature from the primary key. This solution involves storing raw packets internally during decoding to facilitate access to previous elements for validating ordering and data integrity. Additionally, test cases were added to handle manipulated keys that previously could be imported successfully. This fix aims to improve the robustness of the parser without altering the API to maximize compatibility with older versions.\""
    },
    {
        "cwe": "CWE-295",
        "func_name": "gobby/inf_gtk_certificate_manager_certificate_func",
        "score": 0.7055973410606384,
        "func_before": "static void\ninf_gtk_certificate_manager_certificate_func(InfXmppConnection* connection,\n                                             gnutls_session_t session,\n                                             InfCertificateChain* chain,\n                                             gpointer user_data)\n{\n  InfGtkCertificateManager* manager;\n  InfGtkCertificateManagerPrivate* priv;\n\n  InfGtkCertificateDialogFlags flags;\n  gnutls_x509_crt_t presented_cert;\n  gnutls_x509_crt_t known_cert;\n  gchar* hostname;\n\n  gboolean match_hostname;\n  gboolean issuer_known;\n  gnutls_x509_crt_t root_cert;\n\n  int ret;\n  unsigned int verify;\n  GHashTable* table;\n  gboolean cert_equal;\n  time_t expiration_time;\n\n  InfGtkCertificateManagerQuery* query;\n  gchar* text;\n  GtkWidget* vbox;\n  GtkWidget* label;\n\n  GError* error;\n\n  manager = INF_GTK_CERTIFICATE_MANAGER(user_data);\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  g_object_get(G_OBJECT(connection), \"remote-hostname\", &hostname, NULL);\n  presented_cert = inf_certificate_chain_get_own_certificate(chain);\n\n  match_hostname = gnutls_x509_crt_check_hostname(presented_cert, hostname);\n\n  /* First, validate the certificate */\n  ret = gnutls_certificate_verify_peers2(session, &verify);\n  error = NULL;\n\n  if(ret != GNUTLS_E_SUCCESS)\n    inf_gnutls_set_error(&error, ret);\n\n  /* Remove the GNUTLS_CERT_ISSUER_NOT_KNOWN flag from the verification\n   * result, and if the certificate is still invalid, then set an error. */\n  if(error == NULL)\n  {\n    issuer_known = TRUE;\n    if(verify & GNUTLS_CERT_SIGNER_NOT_FOUND)\n    {\n      issuer_known = FALSE;\n\n      /* Re-validate the certificate for other failure reasons --\n       * unfortunately the gnutls_certificate_verify_peers2() call\n       * does not tell us whether the certificate is otherwise invalid\n       * if a signer is not found already. */\n      /* TODO: Here it would be good to use the verify flags from the\n       * certificate credentials, but GnuTLS does not have API to\n       * retrieve them. */\n      root_cert = inf_certificate_chain_get_root_certificate(chain);\n\n      ret = gnutls_x509_crt_list_verify(\n        inf_certificate_chain_get_raw(chain),\n        inf_certificate_chain_get_n_certificates(chain),\n        &root_cert,\n        1,\n        NULL,\n        0,\n        GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT,\n        &verify\n      );\n\n      if(ret != GNUTLS_E_SUCCESS)\n        inf_gnutls_set_error(&error, ret);\n      else if(verify & GNUTLS_CERT_INVALID)\n        inf_gnutls_certificate_verification_set_error(&error, verify);\n    }\n  }\n\n  /* Look up the host in our database of pinned certificates if we could not\n   * fully verify the certificate, i.e. if either the issuer is not known or\n   * the hostname of the connection does not match the certificate. */\n  table = NULL;\n  if(error == NULL)\n  {\n    known_cert = NULL;\n    if(!match_hostname || !issuer_known)\n    {\n      /* If we cannot load the known host file, then cancel the connection.\n       * Otherwise it might happen that someone shows us a certificate that we\n       * tell the user we don't know, if though actually for that host we expect\n       * a different certificate. */\n      table = inf_gtk_certificate_manager_ref_known_hosts(manager, &error);\n      if(table != NULL)\n        known_cert = g_hash_table_lookup(table, hostname);\n    }\n  }\n\n  /* Next, configure the flags for the dialog to be shown based on the\n   * verification result, and on whether the pinned certificate matches\n   * the one presented by the host or not. */\n  flags = 0;\n  if(error == NULL)\n  {\n    if(known_cert != NULL)\n    {\n      cert_equal = inf_gtk_certificate_manager_compare_fingerprint(\n        known_cert,\n        presented_cert,\n        &error\n      );\n\n      if(error == NULL && cert_equal == FALSE)\n      {\n        if(!match_hostname)\n          flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;\n        if(!issuer_known)\n          flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;\n\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_UNEXPECTED;\n        expiration_time = gnutls_x509_crt_get_expiration_time(known_cert);\n        if(expiration_time != (time_t)(-1))\n        {\n          expiration_time -= INF_GTK_CERTIFICATE_MANAGER_EXPIRATION_TOLERANCE;\n          if(time(NULL) > expiration_time)\n          {\n            flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_OLD_EXPIRED;\n          }\n        }\n      }\n    }\n    else\n    {\n      if(!match_hostname)\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;\n      if(!issuer_known)\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;\n    }\n  }\n\n  /* Now proceed either by accepting the connection, rejecting it, or\n   * bothering the user with an annoying dialog. */\n  if(error == NULL)\n  {\n    if(flags == 0)\n    {\n      if(match_hostname && issuer_known)\n      {\n        /* Remove the pinned entry if we now have a valid certificate for\n         * this host. */\n        if(table != NULL && g_hash_table_remove(table, hostname) == TRUE)\n        {\n          inf_gtk_certificate_manager_write_known_hosts_with_warning(\n            manager,\n            table\n          );\n        }\n      }\n\n      inf_xmpp_connection_certificate_verify_continue(connection);\n    }\n    else\n    {\n      query = g_slice_new(InfGtkCertificateManagerQuery);\n      query->manager = manager;\n      query->known_hosts = table;\n      query->connection = connection;\n      query->dialog = inf_gtk_certificate_dialog_new(\n        priv->parent_window,\n        0,\n        flags,\n        hostname,\n        chain\n      );\n      query->certificate_chain = chain;\n\n      table = NULL;\n\n      g_object_ref(query->connection);\n      inf_certificate_chain_ref(chain);\n\n      g_signal_connect(\n        G_OBJECT(connection),\n        \"notify::status\",\n        G_CALLBACK(inf_gtk_certificate_manager_notify_status_cb),\n        query\n      );\n\n      g_signal_connect(\n        G_OBJECT(query->dialog),\n        \"response\",\n        G_CALLBACK(inf_gtk_certificate_manager_response_cb),\n        query\n      );\n\n      gtk_dialog_add_button(\n        GTK_DIALOG(query->dialog),\n        _(\"_Cancel connection\"),\n        GTK_RESPONSE_REJECT\n      );\n\n      gtk_dialog_add_button(\n        GTK_DIALOG(query->dialog),\n        _(\"C_ontinue connection\"),\n        GTK_RESPONSE_ACCEPT\n      );\n\n      text = g_strdup_printf(\n        _(\"Do you want to continue the connection to host \\\"%s\\\"? If you \"\n          \"choose to continue, this certificate will be trusted in the \"\n          \"future when connecting to this host.\"),\n        hostname\n      );\n\n      label = gtk_label_new(text);\n      gtk_label_set_line_wrap(GTK_LABEL(label), TRUE);\n      gtk_label_set_line_wrap_mode(GTK_LABEL(label), PANGO_WRAP_WORD_CHAR);\n      gtk_label_set_max_width_chars(GTK_LABEL(label), 60);\n      gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.0);\n      gtk_widget_show(label);\n      g_free(text);\n\n      vbox = gtk_dialog_get_content_area(GTK_DIALOG(query->dialog));\n      gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 0);\n\n      priv->queries = g_slist_prepend(priv->queries, query);\n      gtk_window_present(GTK_WINDOW(query->dialog));\n    }\n  }\n  else\n  {\n    inf_xmpp_connection_certificate_verify_cancel(connection, error);\n    g_error_free(error);\n  }\n\n  if(table != NULL) g_hash_table_unref(table);\n  g_free(hostname);\n}",
        "func_after": "static void\ninf_gtk_certificate_manager_certificate_func(InfXmppConnection* connection,\n                                             gnutls_session_t session,\n                                             InfCertificateChain* chain,\n                                             gpointer user_data)\n{\n  InfGtkCertificateManager* manager;\n  InfGtkCertificateManagerPrivate* priv;\n\n  InfGtkCertificateDialogFlags flags;\n  gnutls_x509_crt_t presented_cert;\n  gnutls_x509_crt_t known_cert;\n  gchar* hostname;\n\n  gboolean match_hostname;\n  gboolean issuer_known;\n  gnutls_x509_crt_t root_cert;\n\n  int ret;\n  unsigned int verify;\n  GHashTable* table;\n  gboolean cert_equal;\n  time_t expiration_time;\n\n  InfGtkCertificateManagerQuery* query;\n  gchar* text;\n  GtkWidget* vbox;\n  GtkWidget* label;\n\n  GError* error;\n\n  manager = INF_GTK_CERTIFICATE_MANAGER(user_data);\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  g_object_get(G_OBJECT(connection), \"remote-hostname\", &hostname, NULL);\n  presented_cert = inf_certificate_chain_get_own_certificate(chain);\n\n  match_hostname = gnutls_x509_crt_check_hostname(presented_cert, hostname);\n\n  /* First, validate the certificate */\n  ret = gnutls_certificate_verify_peers2(session, &verify);\n  error = NULL;\n\n  if(ret != GNUTLS_E_SUCCESS)\n    inf_gnutls_set_error(&error, ret);\n\n  /* Remove the GNUTLS_CERT_ISSUER_NOT_KNOWN flag from the verification\n   * result, and if the certificate is still invalid, then set an error. */\n  if(error == NULL)\n  {\n    issuer_known = TRUE;\n    if(verify & GNUTLS_CERT_SIGNER_NOT_FOUND)\n    {\n      issuer_known = FALSE;\n\n      /* Re-validate the certificate for other failure reasons --\n       * unfortunately the gnutls_certificate_verify_peers2() call\n       * does not tell us whether the certificate is otherwise invalid\n       * if a signer is not found already. */\n      /* TODO: Here it would be good to use the verify flags from the\n       * certificate credentials, but GnuTLS does not have API to\n       * retrieve them. */\n      root_cert = inf_certificate_chain_get_root_certificate(chain);\n\n      ret = gnutls_x509_crt_list_verify(\n        inf_certificate_chain_get_raw(chain),\n        inf_certificate_chain_get_n_certificates(chain),\n        &root_cert,\n        1,\n        NULL,\n        0,\n        GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT,\n        &verify\n      );\n\n      if(ret != GNUTLS_E_SUCCESS)\n        inf_gnutls_set_error(&error, ret);\n    }\n\n    if(error == NULL)\n      if(verify & GNUTLS_CERT_INVALID)\n        inf_gnutls_certificate_verification_set_error(&error, verify);\n  }\n\n  /* Look up the host in our database of pinned certificates if we could not\n   * fully verify the certificate, i.e. if either the issuer is not known or\n   * the hostname of the connection does not match the certificate. */\n  table = NULL;\n  if(error == NULL)\n  {\n    known_cert = NULL;\n    if(!match_hostname || !issuer_known)\n    {\n      /* If we cannot load the known host file, then cancel the connection.\n       * Otherwise it might happen that someone shows us a certificate that we\n       * tell the user we don't know, if though actually for that host we expect\n       * a different certificate. */\n      table = inf_gtk_certificate_manager_ref_known_hosts(manager, &error);\n      if(table != NULL)\n        known_cert = g_hash_table_lookup(table, hostname);\n    }\n  }\n\n  /* Next, configure the flags for the dialog to be shown based on the\n   * verification result, and on whether the pinned certificate matches\n   * the one presented by the host or not. */\n  flags = 0;\n  if(error == NULL)\n  {\n    if(known_cert != NULL)\n    {\n      cert_equal = inf_gtk_certificate_manager_compare_fingerprint(\n        known_cert,\n        presented_cert,\n        &error\n      );\n\n      if(error == NULL && cert_equal == FALSE)\n      {\n        if(!match_hostname)\n          flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;\n        if(!issuer_known)\n          flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;\n\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_UNEXPECTED;\n        expiration_time = gnutls_x509_crt_get_expiration_time(known_cert);\n        if(expiration_time != (time_t)(-1))\n        {\n          expiration_time -= INF_GTK_CERTIFICATE_MANAGER_EXPIRATION_TOLERANCE;\n          if(time(NULL) > expiration_time)\n          {\n            flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_OLD_EXPIRED;\n          }\n        }\n      }\n    }\n    else\n    {\n      if(!match_hostname)\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;\n      if(!issuer_known)\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;\n    }\n  }\n\n  /* Now proceed either by accepting the connection, rejecting it, or\n   * bothering the user with an annoying dialog. */\n  if(error == NULL)\n  {\n    if(flags == 0)\n    {\n      if(match_hostname && issuer_known)\n      {\n        /* Remove the pinned entry if we now have a valid certificate for\n         * this host. */\n        if(table != NULL && g_hash_table_remove(table, hostname) == TRUE)\n        {\n          inf_gtk_certificate_manager_write_known_hosts_with_warning(\n            manager,\n            table\n          );\n        }\n      }\n\n      inf_xmpp_connection_certificate_verify_continue(connection);\n    }\n    else\n    {\n      query = g_slice_new(InfGtkCertificateManagerQuery);\n      query->manager = manager;\n      query->known_hosts = table;\n      query->connection = connection;\n      query->dialog = inf_gtk_certificate_dialog_new(\n        priv->parent_window,\n        0,\n        flags,\n        hostname,\n        chain\n      );\n      query->certificate_chain = chain;\n\n      table = NULL;\n\n      g_object_ref(query->connection);\n      inf_certificate_chain_ref(chain);\n\n      g_signal_connect(\n        G_OBJECT(connection),\n        \"notify::status\",\n        G_CALLBACK(inf_gtk_certificate_manager_notify_status_cb),\n        query\n      );\n\n      g_signal_connect(\n        G_OBJECT(query->dialog),\n        \"response\",\n        G_CALLBACK(inf_gtk_certificate_manager_response_cb),\n        query\n      );\n\n      gtk_dialog_add_button(\n        GTK_DIALOG(query->dialog),\n        _(\"_Cancel connection\"),\n        GTK_RESPONSE_REJECT\n      );\n\n      gtk_dialog_add_button(\n        GTK_DIALOG(query->dialog),\n        _(\"C_ontinue connection\"),\n        GTK_RESPONSE_ACCEPT\n      );\n\n      text = g_strdup_printf(\n        _(\"Do you want to continue the connection to host \\\"%s\\\"? If you \"\n          \"choose to continue, this certificate will be trusted in the \"\n          \"future when connecting to this host.\"),\n        hostname\n      );\n\n      label = gtk_label_new(text);\n      gtk_label_set_line_wrap(GTK_LABEL(label), TRUE);\n      gtk_label_set_line_wrap_mode(GTK_LABEL(label), PANGO_WRAP_WORD_CHAR);\n      gtk_label_set_max_width_chars(GTK_LABEL(label), 60);\n      gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.0);\n      gtk_widget_show(label);\n      g_free(text);\n\n      vbox = gtk_dialog_get_content_area(GTK_DIALOG(query->dialog));\n      gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 0);\n\n      priv->queries = g_slist_prepend(priv->queries, query);\n      gtk_window_present(GTK_WINDOW(query->dialog));\n    }\n  }\n  else\n  {\n    inf_xmpp_connection_certificate_verify_cancel(connection, error);\n    g_error_free(error);\n  }\n\n  if(table != NULL) g_hash_table_unref(table);\n  g_free(hostname);\n}",
        "description": "Libinfinity versions prior to 0.6.6-1 do not properly validate expired SSL certificates, enabling remote attackers to exploit this vulnerability through unknown vectors to achieve unspecified impacts.",
        "commit": "Expired certificate validation was addressed in Gobby."
    },
    {
        "cwe": "CWE-20",
        "func_name": "torvalds/cifs_lookup",
        "score": 0.7143376469612122,
        "func_before": "struct dentry *\ncifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,\n\t    struct nameidata *nd)\n{\n\tint xid;\n\tint rc = 0; /* to get around spurious gcc warning, set to zero here */\n\t__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;\n\t__u16 fileHandle = 0;\n\tbool posix_open = false;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct cifsFileInfo *cfile;\n\tstruct inode *newInode = NULL;\n\tchar *full_path = NULL;\n\tstruct file *filp;\n\n\txid = GetXid();\n\n\tcFYI(1, \"parent inode = 0x%p name is: %s and dentry = 0x%p\",\n\t      parent_dir_inode, direntry->d_name.name, direntry);\n\n\t/* check whether path exists */\n\n\tcifs_sb = CIFS_SB(parent_dir_inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tFreeXid(xid);\n\t\treturn (struct dentry *)tlink;\n\t}\n\tpTcon = tlink_tcon(tlink);\n\n\t/*\n\t * Don't allow the separator character in a path component.\n\t * The VFS will not allow \"/\", but \"\\\" is allowed by posix.\n\t */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {\n\t\tint i;\n\t\tfor (i = 0; i < direntry->d_name.len; i++)\n\t\t\tif (direntry->d_name.name[i] == '\\\\') {\n\t\t\t\tcFYI(1, \"Invalid file name\");\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t}\n\n\t/*\n\t * O_EXCL: optimize away the lookup, but don't hash the dentry. Let\n\t * the VFS handle the create.\n\t */\n\tif (nd && (nd->flags & LOOKUP_EXCL)) {\n\t\td_instantiate(direntry, NULL);\n\t\trc = 0;\n\t\tgoto lookup_out;\n\t}\n\n\t/* can not grab the rename sem here since it would\n\tdeadlock in the cases (beginning of sys_rename itself)\n\tin which we already have the sb rename sem */\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto lookup_out;\n\t}\n\n\tif (direntry->d_inode != NULL) {\n\t\tcFYI(1, \"non-NULL inode in lookup\");\n\t} else {\n\t\tcFYI(1, \"NULL inode in lookup\");\n\t}\n\tcFYI(1, \"Full path: %s inode = 0x%p\", full_path, direntry->d_inode);\n\n\t/* Posix open is only called (at lookup time) for file create now.\n\t * For opens (rather than creates), because we do not know if it\n\t * is a file or directory yet, and current Samba no longer allows\n\t * us to do posix open on dirs, we could end up wasting an open call\n\t * on what turns out to be a dir. For file opens, we wait to call posix\n\t * open till cifs_open.  It could be added here (lookup) in the future\n\t * but the performance tradeoff of the extra network request when EISDIR\n\t * or EACCES is returned would have to be weighed against the 50%\n\t * reduction in network traffic in the other paths.\n\t */\n\tif (pTcon->unix_ext) {\n\t\tif (nd && !(nd->flags & LOOKUP_DIRECTORY) &&\n\t\t     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&\n\t\t     (nd->intent.open.file->f_flags & O_CREAT)) {\n\t\t\trc = cifs_posix_open(full_path, &newInode,\n\t\t\t\t\tparent_dir_inode->i_sb,\n\t\t\t\t\tnd->intent.open.create_mode,\n\t\t\t\t\tnd->intent.open.file->f_flags, &oplock,\n\t\t\t\t\t&fileHandle, xid);\n\t\t\t/*\n\t\t\t * The check below works around a bug in POSIX\n\t\t\t * open in samba versions 3.3.1 and earlier where\n\t\t\t * open could incorrectly fail with invalid parameter.\n\t\t\t * If either that or op not supported returned, follow\n\t\t\t * the normal lookup.\n\t\t\t */\n\t\t\tif ((rc == 0) || (rc == -ENOENT))\n\t\t\t\tposix_open = true;\n\t\t\telse if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))\n\t\t\t\tpTcon->broken_posix_open = true;\n\t\t}\n\t\tif (!posix_open)\n\t\t\trc = cifs_get_inode_info_unix(&newInode, full_path,\n\t\t\t\t\t\tparent_dir_inode->i_sb, xid);\n\t} else\n\t\trc = cifs_get_inode_info(&newInode, full_path, NULL,\n\t\t\t\tparent_dir_inode->i_sb, xid, NULL);\n\n\tif ((rc == 0) && (newInode != NULL)) {\n\t\td_add(direntry, newInode);\n\t\tif (posix_open) {\n\t\t\tfilp = lookup_instantiate_filp(nd, direntry,\n\t\t\t\t\t\t       generic_file_open);\n\t\t\tif (IS_ERR(filp)) {\n\t\t\t\trc = PTR_ERR(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\n\t\t\tcfile = cifs_new_fileinfo(fileHandle, filp, tlink,\n\t\t\t\t\t\t  oplock);\n\t\t\tif (cfile == NULL) {\n\t\t\t\tfput(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t\t}\n\t\t/* since paths are not looked up by component - the parent\n\t\t   directories are presumed to be good here */\n\t\trenew_parental_timestamps(direntry);\n\n\t} else if (rc == -ENOENT) {\n\t\trc = 0;\n\t\tdirentry->d_time = jiffies;\n\t\td_add(direntry, NULL);\n\t/*\tif it was once a directory (but how can we tell?) we could do\n\t\tshrink_dcache_parent(direntry); */\n\t} else if (rc != -EACCES) {\n\t\tcERROR(1, \"Unexpected lookup error %d\", rc);\n\t\t/* We special case check for Access Denied - since that\n\t\tis a common return code */\n\t}\n\nlookup_out:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\tFreeXid(xid);\n\treturn ERR_PTR(rc);\n}",
        "func_after": "struct dentry *\ncifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,\n\t    struct nameidata *nd)\n{\n\tint xid;\n\tint rc = 0; /* to get around spurious gcc warning, set to zero here */\n\t__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;\n\t__u16 fileHandle = 0;\n\tbool posix_open = false;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct cifsFileInfo *cfile;\n\tstruct inode *newInode = NULL;\n\tchar *full_path = NULL;\n\tstruct file *filp;\n\n\txid = GetXid();\n\n\tcFYI(1, \"parent inode = 0x%p name is: %s and dentry = 0x%p\",\n\t      parent_dir_inode, direntry->d_name.name, direntry);\n\n\t/* check whether path exists */\n\n\tcifs_sb = CIFS_SB(parent_dir_inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tFreeXid(xid);\n\t\treturn (struct dentry *)tlink;\n\t}\n\tpTcon = tlink_tcon(tlink);\n\n\t/*\n\t * Don't allow the separator character in a path component.\n\t * The VFS will not allow \"/\", but \"\\\" is allowed by posix.\n\t */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {\n\t\tint i;\n\t\tfor (i = 0; i < direntry->d_name.len; i++)\n\t\t\tif (direntry->d_name.name[i] == '\\\\') {\n\t\t\t\tcFYI(1, \"Invalid file name\");\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t}\n\n\t/*\n\t * O_EXCL: optimize away the lookup, but don't hash the dentry. Let\n\t * the VFS handle the create.\n\t */\n\tif (nd && (nd->flags & LOOKUP_EXCL)) {\n\t\td_instantiate(direntry, NULL);\n\t\trc = 0;\n\t\tgoto lookup_out;\n\t}\n\n\t/* can not grab the rename sem here since it would\n\tdeadlock in the cases (beginning of sys_rename itself)\n\tin which we already have the sb rename sem */\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto lookup_out;\n\t}\n\n\tif (direntry->d_inode != NULL) {\n\t\tcFYI(1, \"non-NULL inode in lookup\");\n\t} else {\n\t\tcFYI(1, \"NULL inode in lookup\");\n\t}\n\tcFYI(1, \"Full path: %s inode = 0x%p\", full_path, direntry->d_inode);\n\n\t/* Posix open is only called (at lookup time) for file create now.\n\t * For opens (rather than creates), because we do not know if it\n\t * is a file or directory yet, and current Samba no longer allows\n\t * us to do posix open on dirs, we could end up wasting an open call\n\t * on what turns out to be a dir. For file opens, we wait to call posix\n\t * open till cifs_open.  It could be added here (lookup) in the future\n\t * but the performance tradeoff of the extra network request when EISDIR\n\t * or EACCES is returned would have to be weighed against the 50%\n\t * reduction in network traffic in the other paths.\n\t */\n\tif (pTcon->unix_ext) {\n\t\tif (nd && !(nd->flags & LOOKUP_DIRECTORY) &&\n\t\t     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&\n\t\t     (nd->intent.open.file->f_flags & O_CREAT)) {\n\t\t\trc = cifs_posix_open(full_path, &newInode,\n\t\t\t\t\tparent_dir_inode->i_sb,\n\t\t\t\t\tnd->intent.open.create_mode,\n\t\t\t\t\tnd->intent.open.file->f_flags, &oplock,\n\t\t\t\t\t&fileHandle, xid);\n\t\t\t/*\n\t\t\t * The check below works around a bug in POSIX\n\t\t\t * open in samba versions 3.3.1 and earlier where\n\t\t\t * open could incorrectly fail with invalid parameter.\n\t\t\t * If either that or op not supported returned, follow\n\t\t\t * the normal lookup.\n\t\t\t */\n\t\t\tswitch (rc) {\n\t\t\tcase 0:\n\t\t\t\t/*\n\t\t\t\t * The server may allow us to open things like\n\t\t\t\t * FIFOs, but the client isn't set up to deal\n\t\t\t\t * with that. If it's not a regular file, just\n\t\t\t\t * close it and proceed as if it were a normal\n\t\t\t\t * lookup.\n\t\t\t\t */\n\t\t\t\tif (newInode && !S_ISREG(newInode->i_mode)) {\n\t\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase -ENOENT:\n\t\t\t\tposix_open = true;\n\t\t\tcase -EOPNOTSUPP:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpTcon->broken_posix_open = true;\n\t\t\t}\n\t\t}\n\t\tif (!posix_open)\n\t\t\trc = cifs_get_inode_info_unix(&newInode, full_path,\n\t\t\t\t\t\tparent_dir_inode->i_sb, xid);\n\t} else\n\t\trc = cifs_get_inode_info(&newInode, full_path, NULL,\n\t\t\t\tparent_dir_inode->i_sb, xid, NULL);\n\n\tif ((rc == 0) && (newInode != NULL)) {\n\t\td_add(direntry, newInode);\n\t\tif (posix_open) {\n\t\t\tfilp = lookup_instantiate_filp(nd, direntry,\n\t\t\t\t\t\t       generic_file_open);\n\t\t\tif (IS_ERR(filp)) {\n\t\t\t\trc = PTR_ERR(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\n\t\t\tcfile = cifs_new_fileinfo(fileHandle, filp, tlink,\n\t\t\t\t\t\t  oplock);\n\t\t\tif (cfile == NULL) {\n\t\t\t\tfput(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t\t}\n\t\t/* since paths are not looked up by component - the parent\n\t\t   directories are presumed to be good here */\n\t\trenew_parental_timestamps(direntry);\n\n\t} else if (rc == -ENOENT) {\n\t\trc = 0;\n\t\tdirentry->d_time = jiffies;\n\t\td_add(direntry, NULL);\n\t/*\tif it was once a directory (but how can we tell?) we could do\n\t\tshrink_dcache_parent(direntry); */\n\t} else if (rc != -EACCES) {\n\t\tcERROR(1, \"Unexpected lookup error %d\", rc);\n\t\t/* We special case check for Access Denied - since that\n\t\tis a common return code */\n\t}\n\nlookup_out:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\tFreeXid(xid);\n\treturn ERR_PTR(rc);\n}",
        "description": "The `cifs_lookup` function in the CIFS directory handling module of the Linux kernel, prior to version 3.2.10, permits local users to trigger a denial of service (OOPS) condition by attempting to access a special file, such as a FIFO.",
        "commit": "The CIFS code attempts to open files during lookup under specific conditions. However, if the file turned out to be a FIFO or another special file type, the open file handle would be leaked, resulting in a dentry reference count mismatch and causing an oops error during unmount. This issue has been resolved by ensuring that the file handle on the server is closed if the file is not a regular file. Additionally, the code has been refactored to use a switch statement instead of a complex if-else structure."
    },
    {
        "cwe": "CWE-254",
        "func_name": "android/impeg2d_dec_d_slice",
        "score": 0.6948277354240417,
        "func_before": "IMPEG2D_ERROR_CODES_T impeg2d_dec_d_slice(dec_state_t *ps_dec)\n{\n    UWORD32 i;\n    yuv_buf_t *ps_cur_frm_buf  = &ps_dec->s_cur_frm_buf;\n\n    stream_t   *ps_stream       = &ps_dec->s_bit_stream;\n    UWORD8   *pu1_vld_buf;\n\n    WORD16 i2_dc_diff;\n    UWORD32 u4_frame_width = ps_dec->u2_frame_width;\n    UWORD32 u4_frm_offset = 0;\n    if(ps_dec->u2_picture_structure != FRAME_PICTURE)\n    {\n        u4_frame_width <<= 1;\n        if(ps_dec->u2_picture_structure == BOTTOM_FIELD)\n        {\n            u4_frm_offset = ps_dec->u2_frame_width;\n        }\n    }\n\n    do\n    {\n\n        UWORD32 u4_x_offset, u4_y_offset;\n        UWORD32 u4_blk_pos;\n        WORD16 i2_dc_val;\n\n        UWORD32 u4_dst_x_offset     = u4_frm_offset + (ps_dec->u2_mb_x << 4);\n        UWORD32 u4_dst_y_offset     = (ps_dec->u2_mb_y << 4) * u4_frame_width;\n        UWORD8 *pu1_vld_buf8        = ps_cur_frm_buf->pu1_y + u4_dst_x_offset + u4_dst_y_offset;\n        UWORD32 u4_dst_wd           = u4_frame_width;\n        /*------------------------------------------------------------------*/\n        /* Discard the Macroblock stuffing in case of MPEG-1 stream         */\n        /*------------------------------------------------------------------*/\n        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)\n            impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n\n        /*------------------------------------------------------------------*/\n        /* Flush 2 bits from bitstream [MB_Type and MacroBlockAddrIncrement]*/\n        /*------------------------------------------------------------------*/\n        impeg2d_bit_stream_flush(ps_stream,1);\n\n        if(impeg2d_bit_stream_get(ps_stream, 1) != 0x01)\n        {\n            /* Ignore and continue decoding. */\n        }\n\n        /* Process LUMA blocks of the MB */\n        for(i = 0; i < NUM_LUMA_BLKS; ++i)\n        {\n\n            u4_x_offset    = gai2_impeg2_blk_x_off[i];\n            u4_y_offset    = gai2_impeg2_blk_y_off_frm[i] ;\n            u4_blk_pos     = (u4_y_offset * u4_dst_wd) + u4_x_offset;\n            pu1_vld_buf     = pu1_vld_buf8 + u4_blk_pos;\n\n            i2_dc_diff = impeg2d_get_luma_dc_diff(ps_stream);\n            i2_dc_val = ps_dec->u2_def_dc_pred[Y_LUMA] + i2_dc_diff;\n            ps_dec->u2_def_dc_pred[Y_LUMA] = i2_dc_val;\n            i2_dc_val = CLIP_U8(i2_dc_val);\n\n            ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n        }\n\n\n\n        /* Process U block of the MB */\n\n        u4_dst_x_offset                >>= 1;\n        u4_dst_y_offset                >>= 2;\n        u4_dst_wd                      >>= 1;\n        pu1_vld_buf                     = ps_cur_frm_buf->pu1_u + u4_dst_x_offset + u4_dst_y_offset;\n        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);\n        i2_dc_val                      = ps_dec->u2_def_dc_pred[U_CHROMA] + i2_dc_diff;\n        ps_dec->u2_def_dc_pred[U_CHROMA]    = i2_dc_val;\n        i2_dc_val = CLIP_U8(i2_dc_val);\n        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n\n\n        /* Process V block of the MB */\n\n        pu1_vld_buf                     = ps_cur_frm_buf->pu1_v + u4_dst_x_offset + u4_dst_y_offset;\n        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);\n        i2_dc_val                      = ps_dec->u2_def_dc_pred[V_CHROMA] + i2_dc_diff;\n        ps_dec->u2_def_dc_pred[V_CHROMA]    = i2_dc_val;\n        i2_dc_val = CLIP_U8(i2_dc_val);\n        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n\n        /* Common MB processing Steps */\n\n\n        ps_dec->u2_num_mbs_left--;\n        ps_dec->u2_mb_x++;\n\n        if(ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset)\n        {\n            return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;\n        }\n        else if (ps_dec->u2_mb_x == ps_dec->u2_num_horiz_mb)\n        {\n            ps_dec->u2_mb_x = 0;\n            ps_dec->u2_mb_y++;\n\n        }\n\n        /* Flush end of macro block */\n        impeg2d_bit_stream_flush(ps_stream,1);\n    }\n    while(ps_dec->u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,23) != 0x0);\n    return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}",
        "func_after": "IMPEG2D_ERROR_CODES_T impeg2d_dec_d_slice(dec_state_t *ps_dec)\n{\n    UWORD32 i;\n    yuv_buf_t *ps_cur_frm_buf  = &ps_dec->s_cur_frm_buf;\n\n    stream_t   *ps_stream       = &ps_dec->s_bit_stream;\n    UWORD8   *pu1_vld_buf;\n\n    WORD16 i2_dc_diff;\n    UWORD32 u4_frame_width = ps_dec->u2_frame_width;\n    UWORD32 u4_frm_offset = 0;\n    if(ps_dec->u2_picture_structure != FRAME_PICTURE)\n    {\n        u4_frame_width <<= 1;\n        if(ps_dec->u2_picture_structure == BOTTOM_FIELD)\n        {\n            u4_frm_offset = ps_dec->u2_frame_width;\n        }\n    }\n\n    do\n    {\n\n        UWORD32 u4_x_offset, u4_y_offset;\n        UWORD32 u4_blk_pos;\n        WORD16 i2_dc_val;\n\n        UWORD32 u4_dst_x_offset     = u4_frm_offset + (ps_dec->u2_mb_x << 4);\n        UWORD32 u4_dst_y_offset     = (ps_dec->u2_mb_y << 4) * u4_frame_width;\n        UWORD8 *pu1_vld_buf8        = ps_cur_frm_buf->pu1_y + u4_dst_x_offset + u4_dst_y_offset;\n        UWORD32 u4_dst_wd           = u4_frame_width;\n        /*------------------------------------------------------------------*/\n        /* Discard the Macroblock stuffing in case of MPEG-1 stream         */\n        /*------------------------------------------------------------------*/\n        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&\n                ps_stream->u4_offset < ps_stream->u4_max_offset)\n            impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n\n        /*------------------------------------------------------------------*/\n        /* Flush 2 bits from bitstream [MB_Type and MacroBlockAddrIncrement]*/\n        /*------------------------------------------------------------------*/\n        impeg2d_bit_stream_flush(ps_stream,1);\n\n        if(impeg2d_bit_stream_get(ps_stream, 1) != 0x01)\n        {\n            /* Ignore and continue decoding. */\n        }\n\n        /* Process LUMA blocks of the MB */\n        for(i = 0; i < NUM_LUMA_BLKS; ++i)\n        {\n\n            u4_x_offset    = gai2_impeg2_blk_x_off[i];\n            u4_y_offset    = gai2_impeg2_blk_y_off_frm[i] ;\n            u4_blk_pos     = (u4_y_offset * u4_dst_wd) + u4_x_offset;\n            pu1_vld_buf     = pu1_vld_buf8 + u4_blk_pos;\n\n            i2_dc_diff = impeg2d_get_luma_dc_diff(ps_stream);\n            i2_dc_val = ps_dec->u2_def_dc_pred[Y_LUMA] + i2_dc_diff;\n            ps_dec->u2_def_dc_pred[Y_LUMA] = i2_dc_val;\n            i2_dc_val = CLIP_U8(i2_dc_val);\n\n            ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n        }\n\n\n\n        /* Process U block of the MB */\n\n        u4_dst_x_offset                >>= 1;\n        u4_dst_y_offset                >>= 2;\n        u4_dst_wd                      >>= 1;\n        pu1_vld_buf                     = ps_cur_frm_buf->pu1_u + u4_dst_x_offset + u4_dst_y_offset;\n        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);\n        i2_dc_val                      = ps_dec->u2_def_dc_pred[U_CHROMA] + i2_dc_diff;\n        ps_dec->u2_def_dc_pred[U_CHROMA]    = i2_dc_val;\n        i2_dc_val = CLIP_U8(i2_dc_val);\n        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n\n\n        /* Process V block of the MB */\n\n        pu1_vld_buf                     = ps_cur_frm_buf->pu1_v + u4_dst_x_offset + u4_dst_y_offset;\n        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);\n        i2_dc_val                      = ps_dec->u2_def_dc_pred[V_CHROMA] + i2_dc_diff;\n        ps_dec->u2_def_dc_pred[V_CHROMA]    = i2_dc_val;\n        i2_dc_val = CLIP_U8(i2_dc_val);\n        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n\n        /* Common MB processing Steps */\n\n\n        ps_dec->u2_num_mbs_left--;\n        ps_dec->u2_mb_x++;\n\n        if(ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset)\n        {\n            return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;\n        }\n        else if (ps_dec->u2_mb_x == ps_dec->u2_num_horiz_mb)\n        {\n            ps_dec->u2_mb_x = 0;\n            ps_dec->u2_mb_y++;\n\n        }\n\n        /* Flush end of macro block */\n        impeg2d_bit_stream_flush(ps_stream,1);\n    }\n    while(ps_dec->u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,23) != 0x0);\n    return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}",
        "description": "libstagefright in Android versions prior to March 1, 2016, contains a vulnerability that allows attackers to gain unauthorized access to sensitive information by manipulating Bitstream data. This flaw enables attackers to potentially bypass an unspecified security mechanism, such as Signature or SignatureOrSystem access, through crafted input.",
        "commit": "Fixed bit stream access to ensure that reads do not exceed the allocated size."
    },
    {
        "cwe": "CWE-843",
        "func_name": "nginx/njs_promise_resolve",
        "score": 0.6937730312347412,
        "func_before": "njs_promise_t *\nnjs_promise_resolve(njs_vm_t *vm, njs_value_t *constructor, njs_value_t *x)\n{\n    njs_int_t                 ret;\n    njs_value_t               value;\n    njs_object_t              *object;\n    njs_promise_capability_t  *capability;\n\n    static const njs_value_t  string_constructor = njs_string(\"constructor\");\n\n    if (njs_is_object(x)) {\n        object = njs_object_proto_lookup(njs_object(x), NJS_PROMISE,\n                                         njs_object_t);\n\n        if (object != NULL) {\n            ret = njs_value_property(vm, x, njs_value_arg(&string_constructor),\n                                     &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NULL;\n            }\n\n            if (njs_values_same(&value, constructor)) {\n                return njs_promise(x);\n            }\n        }\n    }\n\n    capability = njs_promise_new_capability(vm, constructor);\n    if (njs_slow_path(capability == NULL)) {\n        return NULL;\n    }\n\n    ret = njs_function_call(vm, njs_function(&capability->resolve),\n                            &njs_value_undefined, x, 1, &value);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return NULL;\n    }\n\n    return njs_promise(&capability->promise);\n}",
        "func_after": "njs_promise_t *\nnjs_promise_resolve(njs_vm_t *vm, njs_value_t *constructor, njs_value_t *x)\n{\n    njs_int_t                 ret;\n    njs_value_t               value;\n    njs_promise_capability_t  *capability;\n\n    static const njs_value_t  string_constructor = njs_string(\"constructor\");\n\n    if (njs_is_promise(x)) {\n        ret = njs_value_property(vm, x, njs_value_arg(&string_constructor),\n                                 &value);\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return NULL;\n        }\n\n        if (njs_values_same(&value, constructor)) {\n            return njs_promise(x);\n        }\n    }\n\n    capability = njs_promise_new_capability(vm, constructor);\n    if (njs_slow_path(capability == NULL)) {\n        return NULL;\n    }\n\n    ret = njs_function_call(vm, njs_function(&capability->resolve),\n                            &njs_value_undefined, x, 1, &value);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return NULL;\n    }\n\n    return njs_promise(&capability->promise);\n}",
        "description": "njs versions up to 0.7.1, utilized in NGINX, were found to be susceptible to a control flow hijack due to a Type Confusion vulnerability within the njs_promise_perform_then() function.",
        "commit": "A type confusion bug was fixed while resolving promises. Previously, the internal function `njs_promise_perform_then()` expected its first argument to always be a promise instance. However, the functions corresponding to `Promise.prototype.then()` and `Promise.resolve()` incorrectly verified their arguments, treating any object with a Promise in its prototype chain as a valid promise. This was incorrect because internal slots are not inherited according to the specification. This issue has been addressed and closed in GitHub issue #447."
    }
]