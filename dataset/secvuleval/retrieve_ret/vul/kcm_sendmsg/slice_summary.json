[
    {
        "cwe": "CWE-354",
        "func_name": "systemd/journal_file_offline_close",
        "score": 0.7458316683769226,
        "func_before": "JournalFile* journal_file_offline_close(JournalFile *f) {\n        if (!f)\n                return NULL;\n\n#if HAVE_GCRYPT\n        /* Write the final tag */\n        if (JOURNAL_HEADER_SEALED(f->header) && journal_file_writable(f)) {\n                int r;\n\n                r = journal_file_append_tag(f);\n                if (r < 0)\n                        log_error_errno(r, \"Failed to append tag when closing journal: %m\");\n        }\n#endif\n\n        if (sd_event_source_get_enabled(f->post_change_timer, NULL) > 0)\n                journal_file_post_change(f);\n        sd_event_source_disable_unref(f->post_change_timer);\n\n        journal_file_set_offline(f, true);\n\n        return journal_file_close(f);\n}",
        "func_after": "JournalFile* journal_file_offline_close(JournalFile *f) {\n        if (!f)\n                return NULL;\n\n        journal_file_write_final_tag(f);\n\n        if (sd_event_source_get_enabled(f->post_change_timer, NULL) > 0)\n                journal_file_post_change(f);\n        sd_event_source_disable_unref(f->post_change_timer);\n\n        journal_file_set_offline(f, true);\n\n        return journal_file_close(f);\n}",
        "description": "An issue was discovered in systemd where an attacker can manipulate a sealed log file by truncating it and then resuming the log sealing process. This manipulation allows the attacker to alter the log content without detection, as integrity checks do not reveal any errors.",
        "commit": "The vulnerability involves an issue in the `journalctl` tool where empty log epochs are not properly sealed, allowing attackers to manipulate sealed logs by truncating them and continuing without detection during verification. This defect partially addresses CVE-2023-31438. To fully resolve the issue, the system should enforce that there is exactly one seal per epoch and prevent sealing until an epoch has ended. Additionally, a new journal-file flag, `HEADER_COMPATIBLE_SEALED_CONTINUOUS`, has been introduced to indicate continuous sealing and determine whether missing cryptographic epochs should result in warnings or errors."
    },
    {
        "cwe": "CWE-385",
        "func_name": "openssl/ecdsa_sign_setup",
        "score": 0.7685656547546387,
        "func_before": "static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,\n\t\t\t\t\tBIGNUM **kinvp, BIGNUM **rp,\n\t\t\t\t\tconst unsigned char *dgst, int dlen)\n{\n\tBN_CTX   *ctx = NULL;\n\tBIGNUM\t *k = NULL, *r = NULL, *order = NULL, *X = NULL;\n\tEC_POINT *tmp_point=NULL;\n\tconst EC_GROUP *group;\n\tint \t ret = 0;\n\n\tif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\n\tif (ctx_in == NULL) \n\t{\n\t\tif ((ctx = BN_CTX_new()) == NULL)\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t\tctx = ctx_in;\n\n\tk     = BN_new();\t/* this value is later returned in *kinvp */\n\tr     = BN_new();\t/* this value is later returned in *rp    */\n\torder = BN_new();\n\tX     = BN_new();\n\tif (!k || !r || !order || !X)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t}\n\tif ((tmp_point = EC_POINT_new(group)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\tif (!EC_GROUP_get_order(group, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\n#ifdef OPENSSL_FIPS\n\tif (!fips_check_ec_prng(eckey))\n\t\tgoto err;\n#endif\n\t\n\tdo\n\t{\n\t\t/* get random k */\t\n\t\tdo\n#ifndef OPENSSL_NO_SHA512\n\t\t\tif (dgst != NULL)\n\t\t\t{\n\t\t\t\tif (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),\n\t\t\t\t\t\t\t   dgst, dlen, ctx))\n\t\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tif (!BN_rand_range(k, order))\n\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\twhile (BN_is_zero(k));\n\n\t\t/* We do not want timing information to leak the length of k,\n\t\t * so we compute G*k using an equivalent scalar of fixed\n\t\t * bit-length. */\n\n\t\tif (!BN_add(k, k, order)) goto err;\n\t\tif (BN_num_bits(k) <= BN_num_bits(order))\n\t\t\tif (!BN_add(k, k, order)) goto err;\n\n\t\t/* compute r the x-coordinate of generator * k */\n\t\tif (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t}\n\t\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#ifndef OPENSSL_NO_EC2M\n\t\telse /* NID_X9_62_characteristic_two_field */\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GF2m(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!BN_nnmod(r, X, order, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t}\n\t}\n\twhile (BN_is_zero(r));\n\n\t/* compute the inverse of k */\n\tif (!BN_mod_inverse(k, k, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\tgoto err;\t\n\t}\n\t/* clear old values if necessary */\n\tif (*rp != NULL)\n\t\tBN_clear_free(*rp);\n\tif (*kinvp != NULL) \n\t\tBN_clear_free(*kinvp);\n\t/* save the pre-computed values  */\n\t*rp    = r;\n\t*kinvp = k;\n\tret = 1;\nerr:\n\tif (!ret)\n\t{\n\t\tif (k != NULL) BN_clear_free(k);\n\t\tif (r != NULL) BN_clear_free(r);\n\t}\n\tif (ctx_in == NULL) \n\t\tBN_CTX_free(ctx);\n\tif (order != NULL)\n\t\tBN_free(order);\n\tif (tmp_point != NULL) \n\t\tEC_POINT_free(tmp_point);\n\tif (X)\n\t\tBN_clear_free(X);\n\treturn(ret);\n}",
        "func_after": "static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,\n\t\t\t\t\tBIGNUM **kinvp, BIGNUM **rp,\n\t\t\t\t\tconst unsigned char *dgst, int dlen)\n{\n\tBN_CTX   *ctx = NULL;\n\tBIGNUM\t *k = NULL, *r = NULL, *order = NULL, *X = NULL;\n\tEC_POINT *tmp_point=NULL;\n\tconst EC_GROUP *group;\n\tint \t ret = 0;\n\n\tif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\n\tif (ctx_in == NULL) \n\t{\n\t\tif ((ctx = BN_CTX_new()) == NULL)\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t\tctx = ctx_in;\n\n\tk     = BN_new();\t/* this value is later returned in *kinvp */\n\tr     = BN_new();\t/* this value is later returned in *rp    */\n\torder = BN_new();\n\tX     = BN_new();\n\tif (!k || !r || !order || !X)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t}\n\tif ((tmp_point = EC_POINT_new(group)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\tif (!EC_GROUP_get_order(group, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\n#ifdef OPENSSL_FIPS\n\tif (!fips_check_ec_prng(eckey))\n\t\tgoto err;\n#endif\n\t\n\tdo\n\t{\n\t\t/* get random k */\t\n\t\tdo\n#ifndef OPENSSL_NO_SHA512\n\t\t\tif (dgst != NULL)\n\t\t\t{\n\t\t\t\tif (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),\n\t\t\t\t\t\t\t   dgst, dlen, ctx))\n\t\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tif (!BN_rand_range(k, order))\n\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\twhile (BN_is_zero(k));\n\n\t\t/* We do not want timing information to leak the length of k,\n\t\t * so we compute G*k using an equivalent scalar of fixed\n\t\t * bit-length. */\n\n\t\tif (!BN_add(k, k, order)) goto err;\n\t\tif (BN_num_bits(k) <= BN_num_bits(order))\n\t\t\tif (!BN_add(k, k, order)) goto err;\n\n\t\t/* compute r the x-coordinate of generator * k */\n\t\tif (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t}\n\t\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#ifndef OPENSSL_NO_EC2M\n\t\telse /* NID_X9_62_characteristic_two_field */\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GF2m(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!BN_nnmod(r, X, order, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t}\n\t}\n\twhile (BN_is_zero(r));\n\n\t/* compute the inverse of k */\n\tif (EC_GROUP_get_mont_data(group) != NULL)\n\t\t{\n\t\t/* We want inverse in constant time, therefore we utilize the\n\t\t * fact order must be prime and use Fermats Little Theorem\n\t\t * instead. */\n\t\tif (!BN_set_word(X, 2) )\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (!BN_mod_sub(X, order, X, order, ctx))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tBN_set_flags(X, BN_FLG_CONSTTIME);\n\t\tif (!BN_mod_exp_mont_consttime(k, k, X, order, ctx, EC_GROUP_get_mont_data(group)))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tif (!BN_mod_inverse(k, k, order, ctx))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\t\n\t\t\t}\n\t\t}\n\n\t/* clear old values if necessary */\n\tif (*rp != NULL)\n\t\tBN_clear_free(*rp);\n\tif (*kinvp != NULL) \n\t\tBN_clear_free(*kinvp);\n\t/* save the pre-computed values  */\n\t*rp    = r;\n\t*kinvp = k;\n\tret = 1;\nerr:\n\tif (!ret)\n\t{\n\t\tif (k != NULL) BN_clear_free(k);\n\t\tif (r != NULL) BN_clear_free(r);\n\t}\n\tif (ctx_in == NULL) \n\t\tBN_CTX_free(ctx);\n\tif (order != NULL)\n\t\tBN_free(order);\n\tif (tmp_point != NULL) \n\t\tEC_POINT_free(tmp_point);\n\tif (X)\n\t\tBN_clear_free(X);\n\treturn(ret);\n}",
        "description": "A timing attack vulnerability was identified in OpenSSL versions prior to 1.0.1u, enabling a malicious user with local access to potentially recover ECDSA P-256 private keys through the exploitation of timing variations in cryptographic operations.",
        "commit": "The vulnerability knowledge has been abstracted and generalized as follows:\n\n\"The implementation of ECDSA includes an option to utilize BN_mod_exp_mont_consttime, a constant-time modular exponentiation function. This enhancement aims to improve the security of ECDSA operations.\""
    },
    {
        "cwe": "CWE-89",
        "func_name": "openlink/sqlo_add_table_ref",
        "score": 0.7667961120605469,
        "func_before": "void\nsqlo_add_table_ref (sqlo_t * so, ST ** tree_ret, dk_set_t *res)\n{\n  char tmp[10];\n  ST * tree = *tree_ret;\n  switch (tree->type)\n    {\n    case TABLE_REF:\n      {\n\tST * prev = tree->_.table_ref.table;\n\tif (ST_P (prev, SELECT_STMT))\n\t  {\n\t    tree->type = DERIVED_TABLE;\n\t    sqlp_view_def (NULL, tree->_.table_ref.table, 0);\n\t    sqlo_add_table_ref (so, tree_ret, res);\n\t    return;\n\t  }\n\tsqlo_add_table_ref (so, &tree->_.table_ref.table, res);\n\tif (prev != tree->_.table_ref.table)\n\t  *tree_ret = tree->_.table_ref.table;\n\tbreak;\n      }\n    case TABLE_DOTTED:\n      {\n\tST * with_view = sqlo_with_decl (so, tree);\n\tdbe_table_t *tb = with_view ? NULL : sch_name_to_table (wi_inst.wi_schema, tree->_.table.name);\n\tST * view;\n\tif (!tb && !with_view)\n\t  sqlc_error (so->so_sc->sc_cc, \"S0002\", \"No table %s\", tree->_.table.name);\n\tif (inside_view)\n\t  tree->_.table.name = t_box_copy (tb->tb_name);\n\tif (!with_view)\n\t  {\n\t    sqlc_table_used (so->so_sc, tb);\n\t    view = (ST*) sch_view_def (wi_inst.wi_schema, tb->tb_name);\n\t  }\n\telse\n\t  view = with_view;\n\tif (!view || inside_view)\n\t  {\n\t    remote_table_t * rt = find_remote_table (tb->tb_name, 0);\n\t    t_NEW_VARZ (op_table_t, ot);\n\t    ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts);\n\t    ot->ot_prefix = tree->_.table.prefix;\n\t    snprintf (tmp, sizeof (tmp), \"t%d\", so->so_name_ctr++);\n\t    ot->ot_new_prefix = t_box_string (tmp);\n\t    tree->_.table.prefix = ot->ot_new_prefix;\n\t    ot->ot_table = tb;\n\t    ot->ot_rds = rt ? rt->rt_rds : NULL;\n\t    ot->ot_u_id = (oid_t) unbox (tree->_.table.u_id);\n\t    ot->ot_g_id = (oid_t) unbox (tree->_.table.g_id);\n\t    if (ST_P (view, PROC_TABLE))\n\t      {\n\t\tot->ot_dt = view;\n\t\tsqlo_proc_table_cols (so, ot);\n\t\tot->ot_dt = NULL;\n\t\tot->ot_is_proc_view = 1;\n\t      }\n\t    sqlo_rls_add_condition (so, ot, res, tb);\n\t    t_set_push (&so->so_tables, (void*) ot);\n\t    sco_add_table (so->so_scope, ot);\n\t  }\n\telse\n\t  {\n\t    op_table_t * ot = NULL;\n\t    if (!with_view && !sec_tb_check (tb, (oid_t) unbox (tree->_.table.g_id), (oid_t) unbox (tree->_.table.u_id), GR_SELECT))\n\t      sqlc_new_error (so->so_sc->sc_cc, \"42000\", \"SQ070:SECURITY\", \"Must have select privileges on view %s\", tb->tb_name);\n\t    view = (ST*) t_box_copy_tree ((caddr_t) view);\n\t    if (ST_P (view, UNION_ST) ||\n\t\tST_P (view, UNION_ALL_ST) ||\n\t\tST_P (view, EXCEPT_ST) ||\n\t\tST_P (view, EXCEPT_ALL_ST) ||\n\t\tST_P (view, INTERSECT_ST) ||\n\t\tST_P (view, INTERSECT_ALL_ST))\n\t      {\n\t\tview = sqlp_view_def (NULL, view, 1);\n\t\tview = sqlc_union_dt_wrap (view);\n\t      }\n\t    sqlo_scope (so, &view);\n\t    if (ST_P (view, SELECT_STMT))\n\t      {\n\t\tot = (op_table_t *) so->so_tables->data;\n\t\tot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name;\n\t\tsco_add_table (so->so_scope, ot);\n\t      }\n\t    else\n\t      {\n\t\tt_NEW_VARZ (op_table_t, ot2);\n\t\tmemset (ot2, 0, sizeof (op_table_t));\n\t\tot = ot2;\n\t\tot->ot_dt = view;\n\t\tot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name;\n\t\tot->ot_new_prefix = sqlo_new_prefix (so);\n\t\tot->ot_left_sel = sqlp_union_tree_select (view);\n\t\tif (ST_P (view, PROC_TABLE))\n\t\t  {\n\t\t    sqlo_proc_table_cols (so, ot);\n\t\t    ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts);\n\t\t    ot->ot_is_proc_view = 1;\n\t\t  }\n\t\tsco_add_table (so->so_scope, ot);\n\t\tt_set_push (&so->so_tables, (void*) ot);\n\n\t      }\n\t    sqlo_rls_add_condition (so, ot, res, tb);\n\t    *tree_ret = (ST*) t_list (3, DERIVED_TABLE, ot->ot_dt, ot->ot_new_prefix);\n\t  }\n\tbreak;\n      }\n    case JOINED_TABLE:\n      {\n\tsql_scope_t *old_sco = so->so_scope;\n\tTNEW (sql_scope_t, sco);\n\top_table_t *right_ot, *left_ot;\n\ts_node_t *ptr;\n\tST *j_right;\n\tdk_set_t res_jt = NULL;\n\tint is_jtc, is_natural = (tree->_.join.is_natural &&\n\t    (!tree->_.join.cond || tree->_.join.cond == (ST *) STAR));\n\n\n\tmemset (sco, 0, sizeof (sql_scope_t));\n\tsco->sco_so = so;\n\tsco->sco_fun_refs_allowed = old_sco->sco_fun_refs_allowed;\n\tsco->sco_super = so->so_scope->sco_super;\n\tso->so_scope = sco;\n\n\tif (OJ_RIGHT == tree->_.join.type)\n\t  {\n\t    ST * tmp = tree->_.join.left;\n\t    tree->_.join.left = tree->_.join.right;\n\t    tree->_.join.right = tmp;\n\t    tree->_.join.type = OJ_LEFT;\n\t  }\n\tj_right = tree->_.join.left;\n\twhile (ST_P (j_right, TABLE_REF))\n\t  j_right = j_right->_.table_ref.table;\n\tis_jtc = ST_P (j_right, JOINED_TABLE);\n\tif (tree->_.join.type == OJ_FULL)\n\t  sco->sco_has_jt = 1;\n\tif (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)))\n\t  sco->sco_has_jt = 1;\n\tj_right = tree->_.join.right;\n\twhile (ST_P (j_right, TABLE_REF))\n\t  j_right = j_right->_.table_ref.table;\n\tis_jtc = ST_P (j_right, JOINED_TABLE);\n\tif (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)))\n\t  sco->sco_has_jt = 1;\n\tsqlo_add_table_ref (so, &tree->_.join.left, res);\n\tleft_ot = (op_table_t *) so->so_tables->data;\n\tsqlo_add_table_ref (so, &tree->_.join.right, is_jtc ? &res_jt : res);\n\tright_ot = (op_table_t *) so->so_tables->data;\n\tsqlo_natural_join_cond (so, left_ot, right_ot, tree);\n\tsqlo_scope (so, &(tree->_.join.cond));\n\t/* can be that the right subtree in a ij ends with oj in which case the right ot will be flagged outer. The cond in this case goes to to the top where, i.e. res, not to the join cond of the outer (optional) ot */\nif (J_INNER == tree->_.join.type && right_ot->ot_is_outer)\n  \t  t_st_and (&right_ot->ot_enclosing_where_cond, tree->_.join.cond); /*always ste, even if some joins may be made into dts later*/\n\n\telse\n\t  t_st_and (&right_ot->ot_join_cond, tree->_.join.cond); /*always ste, even if some joins may be made into dts later*/\n\tsco_merge (old_sco, sco);\n\tso->so_scope = old_sco;\n\tif (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)\n\t  right_ot->ot_is_outer = 1;\n\telse if (!sco->sco_has_jt && tree->_.join.type == J_INNER &&\n\t    !ST_P (left_ot->ot_dt, PROC_TABLE) &&\n\t    !ST_P (right_ot->ot_dt, PROC_TABLE))\n\t  {\n\t    t_set_push (res, tree);\n\t    break;\n\t  }\n\tbreak;\n      }\n    case DERIVED_TABLE:\n      {\n\top_table_t * ot;\n\tsqlo_scope (so, &(tree->_.table_ref.table));\n\tif (ST_P (tree->_.table_ref.table, SELECT_STMT))\n\t  {\n\t    ot = (op_table_t *) so->so_tables->data;\n\t    ot->ot_prefix = tree->_.table_ref.range;\n\t    tree->_.table_ref.range = ot->ot_new_prefix;\n/*\t    t_set_push (res, (void *) ot);*/\n\t    sco_add_table (so->so_scope, ot);\n\t    if (ot->ot_trans)\n\t      sqlo_trans_cols (so, ot);\n\t  }\n\telse\n\t  {\n\t    op_table_t *old_ot = so->so_tables ? (op_table_t *) so->so_tables->data : NULL;\n\t    t_NEW_VARZ (op_table_t, ot);\n\t    ot->ot_prefix = tree->_.table_ref.range;\n\t    ot->ot_dt = tree->_.table_ref.table;\n\t    ot->ot_new_prefix = sqlo_new_prefix (so);\n\t    tree->_.table_ref.range = ot->ot_new_prefix;\n\t    if (old_ot)\n\t      ot->ot_left_sel = old_ot->ot_left_sel;\n\t    else\n\t      ot->ot_left_sel = sqlp_union_tree_select (tree->_.table_ref.table);\n\t    if (ST_P (tree->_.table_ref.table, PROC_TABLE))\n\t      sqlo_proc_table_cols (so, ot);\n/*\t    t_set_push (res, (void *) ot);*/\n\t    sco_add_table (so->so_scope, ot);\n\t    t_set_push (&so->so_tables, (void*) ot);\n\t  }\n\tbreak;\n      }\n    }\n}",
        "func_after": "void\nsqlo_add_table_ref (sqlo_t * so, ST ** tree_ret, dk_set_t *res)\n{\n  char tmp[10];\n  ST * tree = *tree_ret;\n  switch (tree->type)\n    {\n    case TABLE_REF:\n      {\n\tST * prev = tree->_.table_ref.table;\n\tif (ST_P (prev, SELECT_STMT))\n\t  {\n\t    tree->type = DERIVED_TABLE;\n\t    sqlp_view_def (NULL, tree->_.table_ref.table, 0);\n\t    sqlo_add_table_ref (so, tree_ret, res);\n\t    return;\n\t  }\n\tsqlo_add_table_ref (so, &tree->_.table_ref.table, res);\n\tif (prev != tree->_.table_ref.table)\n\t  *tree_ret = tree->_.table_ref.table;\n\tbreak;\n      }\n    case TABLE_DOTTED:\n      {\n\tST * with_view = sqlo_with_decl (so, tree);\n\tdbe_table_t *tb = with_view ? NULL : sch_name_to_table (wi_inst.wi_schema, tree->_.table.name);\n\tST * view;\n\tif (!tb && !with_view)\n\t  sqlc_error (so->so_sc->sc_cc, \"S0002\", \"No table %s\", tree->_.table.name);\n\tif (inside_view)\n\t  tree->_.table.name = t_box_copy (tb->tb_name);\n\tif (!with_view)\n\t  {\n\t    sqlc_table_used (so->so_sc, tb);\n\t    view = (ST*) sch_view_def (wi_inst.wi_schema, tb->tb_name);\n\t  }\n\telse\n\t  view = with_view;\n\tif (!view || inside_view)\n\t  {\n\t    remote_table_t * rt = find_remote_table (tb->tb_name, 0);\n\t    t_NEW_VARZ (op_table_t, ot);\n\t    ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts);\n\t    ot->ot_prefix = tree->_.table.prefix;\n\t    snprintf (tmp, sizeof (tmp), \"t%d\", so->so_name_ctr++);\n\t    ot->ot_new_prefix = t_box_string (tmp);\n\t    tree->_.table.prefix = ot->ot_new_prefix;\n\t    ot->ot_table = tb;\n\t    ot->ot_rds = rt ? rt->rt_rds : NULL;\n\t    ot->ot_u_id = (oid_t) unbox (tree->_.table.u_id);\n\t    ot->ot_g_id = (oid_t) unbox (tree->_.table.g_id);\n\t    if (ST_P (view, PROC_TABLE))\n\t      {\n\t\tot->ot_dt = view;\n\t\tsqlo_proc_table_cols (so, ot);\n\t\tot->ot_dt = NULL;\n\t\tot->ot_is_proc_view = 1;\n\t      }\n\t    sqlo_rls_add_condition (so, ot, res, tb);\n\t    t_set_push (&so->so_tables, (void*) ot);\n\t    sco_add_table (so->so_scope, ot);\n\t  }\n\telse\n\t  {\n\t    op_table_t * ot = NULL;\n\t    if (!with_view && !sec_tb_check (tb, (oid_t) unbox (tree->_.table.g_id), (oid_t) unbox (tree->_.table.u_id), GR_SELECT))\n\t      sqlc_new_error (so->so_sc->sc_cc, \"42000\", \"SQ070:SECURITY\", \"Must have select privileges on view %s\", tb->tb_name);\n\t    view = (ST*) t_box_copy_tree ((caddr_t) view);\n\t    if (ST_P (view, UNION_ST) ||\n\t\tST_P (view, UNION_ALL_ST) ||\n\t\tST_P (view, EXCEPT_ST) ||\n\t\tST_P (view, EXCEPT_ALL_ST) ||\n\t\tST_P (view, INTERSECT_ST) ||\n\t\tST_P (view, INTERSECT_ALL_ST))\n\t      {\n\t\tview = sqlp_view_def (NULL, view, 1);\n\t\tview = sqlc_union_dt_wrap (so->so_sc, view);\n\t      }\n\t    sqlo_scope (so, &view);\n\t    if (ST_P (view, SELECT_STMT))\n\t      {\n\t\tot = (op_table_t *) so->so_tables->data;\n\t\tot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name;\n\t\tsco_add_table (so->so_scope, ot);\n\t      }\n\t    else\n\t      {\n\t\tt_NEW_VARZ (op_table_t, ot2);\n\t\tmemset (ot2, 0, sizeof (op_table_t));\n\t\tot = ot2;\n\t\tot->ot_dt = view;\n\t\tot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name;\n\t\tot->ot_new_prefix = sqlo_new_prefix (so);\n\t\tot->ot_left_sel = sqlp_union_tree_select (view);\n\t\tif (ST_P (view, PROC_TABLE))\n\t\t  {\n\t\t    sqlo_proc_table_cols (so, ot);\n\t\t    ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts);\n\t\t    ot->ot_is_proc_view = 1;\n\t\t  }\n\t\tsco_add_table (so->so_scope, ot);\n\t\tt_set_push (&so->so_tables, (void*) ot);\n\n\t      }\n\t    sqlo_rls_add_condition (so, ot, res, tb);\n\t    *tree_ret = (ST*) t_list (3, DERIVED_TABLE, ot->ot_dt, ot->ot_new_prefix);\n\t  }\n\tbreak;\n      }\n    case JOINED_TABLE:\n      {\n\tsql_scope_t *old_sco = so->so_scope;\n\tTNEW (sql_scope_t, sco);\n\top_table_t *right_ot, *left_ot;\n\ts_node_t *ptr;\n\tST *j_right;\n\tdk_set_t res_jt = NULL;\n\tint is_jtc, is_natural = (tree->_.join.is_natural &&\n\t    (!tree->_.join.cond || tree->_.join.cond == (ST *) STAR));\n\n\n\tmemset (sco, 0, sizeof (sql_scope_t));\n\tsco->sco_so = so;\n\tsco->sco_fun_refs_allowed = old_sco->sco_fun_refs_allowed;\n\tsco->sco_super = so->so_scope->sco_super;\n\tso->so_scope = sco;\n\n\tif (OJ_RIGHT == tree->_.join.type)\n\t  {\n\t    ST * tmp = tree->_.join.left;\n\t    tree->_.join.left = tree->_.join.right;\n\t    tree->_.join.right = tmp;\n\t    tree->_.join.type = OJ_LEFT;\n\t  }\n\tj_right = tree->_.join.left;\n\twhile (ST_P (j_right, TABLE_REF))\n\t  j_right = j_right->_.table_ref.table;\n\tis_jtc = ST_P (j_right, JOINED_TABLE);\n\tif (tree->_.join.type == OJ_FULL)\n\t  sco->sco_has_jt = 1;\n\tif (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)))\n\t  sco->sco_has_jt = 1;\n\tj_right = tree->_.join.right;\n\twhile (ST_P (j_right, TABLE_REF))\n\t  j_right = j_right->_.table_ref.table;\n\tis_jtc = ST_P (j_right, JOINED_TABLE);\n\tif (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)))\n\t  sco->sco_has_jt = 1;\n\tsqlo_add_table_ref (so, &tree->_.join.left, res);\n\tleft_ot = (op_table_t *) so->so_tables->data;\n\tsqlo_add_table_ref (so, &tree->_.join.right, is_jtc ? &res_jt : res);\n\tright_ot = (op_table_t *) so->so_tables->data;\n\tsqlo_natural_join_cond (so, left_ot, right_ot, tree);\n\tsqlo_scope (so, &(tree->_.join.cond));\n\t/* can be that the right subtree in a ij ends with oj in which case the right ot will be flagged outer. The cond in this case goes to to the top where, i.e. res, not to the join cond of the outer (optional) ot */\nif (J_INNER == tree->_.join.type && right_ot->ot_is_outer)\n  \t  t_st_and (&right_ot->ot_enclosing_where_cond, tree->_.join.cond); /*always ste, even if some joins may be made into dts later*/\n\n\telse\n\t  t_st_and (&right_ot->ot_join_cond, tree->_.join.cond); /*always ste, even if some joins may be made into dts later*/\n\tsco_merge (old_sco, sco);\n\tso->so_scope = old_sco;\n\tif (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL)\n\t  right_ot->ot_is_outer = 1;\n\telse if (!sco->sco_has_jt && tree->_.join.type == J_INNER &&\n\t    !ST_P (left_ot->ot_dt, PROC_TABLE) &&\n\t    !ST_P (right_ot->ot_dt, PROC_TABLE))\n\t  {\n\t    t_set_push (res, tree);\n\t    break;\n\t  }\n\tbreak;\n      }\n    case DERIVED_TABLE:\n      {\n\top_table_t * ot;\n\tsqlo_scope (so, &(tree->_.table_ref.table));\n\tif (ST_P (tree->_.table_ref.table, SELECT_STMT))\n\t  {\n\t    ot = (op_table_t *) so->so_tables->data;\n\t    ot->ot_prefix = tree->_.table_ref.range;\n\t    tree->_.table_ref.range = ot->ot_new_prefix;\n/*\t    t_set_push (res, (void *) ot);*/\n\t    sco_add_table (so->so_scope, ot);\n\t    if (ot->ot_trans)\n\t      sqlo_trans_cols (so, ot);\n\t  }\n\telse\n\t  {\n\t    op_table_t *old_ot = so->so_tables ? (op_table_t *) so->so_tables->data : NULL;\n\t    t_NEW_VARZ (op_table_t, ot);\n\t    ot->ot_prefix = tree->_.table_ref.range;\n\t    ot->ot_dt = tree->_.table_ref.table;\n\t    ot->ot_new_prefix = sqlo_new_prefix (so);\n\t    tree->_.table_ref.range = ot->ot_new_prefix;\n\t    if (old_ot)\n\t      ot->ot_left_sel = old_ot->ot_left_sel;\n\t    else\n\t      ot->ot_left_sel = sqlp_union_tree_select (tree->_.table_ref.table);\n\t    if (ST_P (tree->_.table_ref.table, PROC_TABLE))\n\t      sqlo_proc_table_cols (so, ot);\n/*\t    t_set_push (res, (void *) ot);*/\n\t    sco_add_table (so->so_scope, ot);\n\t    t_set_push (&so->so_tables, (void*) ot);\n\t  }\n\tbreak;\n      }\n    }\n}",
        "description": "An issue in the sqlc_union_dt_wrap component of OpenLink Virtuoso Open Source allows attackers to trigger a Denial of Service (DoS) condition through the use of specially crafted SQL statements.",
        "commit": "The support for fixed non-terminals in union branches is not implemented, which may lead to issues or unexpected behavior in certain scenarios."
    },
    {
        "cwe": "CWE-444",
        "func_name": "varnishcache/h2_vfp_body",
        "score": 0.7487758994102478,
        "func_before": "static enum vfp_status v_matchproto_(vfp_pull_f)\nh2_vfp_body(struct vfp_ctx *vc, struct vfp_entry *vfe, void *ptr, ssize_t *lp)\n{\n\tstruct h2_req *r2;\n\tstruct h2_sess *h2;\n\tunsigned l;\n\tenum vfp_status retval = VFP_OK;\n\n\tCHECK_OBJ_NOTNULL(vc, VFP_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(vfe, VFP_ENTRY_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, vfe->priv1, H2_REQ_MAGIC);\n\th2 = r2->h2sess;\n\n\tAN(ptr);\n\tAN(lp);\n\tl = *lp;\n\t*lp = 0;\n\n\tLck_Lock(&h2->sess->mtx);\n\tassert (r2->state == H2_S_OPEN);\n\tr2->cond = &vc->wrk->cond;\n\twhile (h2->mailcall != r2 && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(r2->cond, &h2->sess->mtx, 0));\n\tr2->cond = NULL;\n\tif (h2->error || r2->error) {\n\t\tretval = VFP_ERROR;\n\t} else {\n\t\tassert(h2->mailcall == r2);\n\t\tif (l > h2->rxf_len)\n\t\t\tl = h2->rxf_len;\n\t\tif (l > 0) {\n\t\t\tmemcpy(ptr, h2->rxf_data, l);\n\t\t\th2->rxf_data += l;\n\t\t\th2->rxf_len -= l;\n\t\t}\n\t\t*lp = l;\n\t\tif (h2->rxf_len > 0) {\n\t\t\t/* We ran out of storage: Have VFP call us\n\t\t\t * again with a fresh buffer */\n\t\t\tLck_Unlock(&h2->sess->mtx);\n\t\t\treturn (VFP_OK);\n\t\t}\n\t\tif (h2->rxf_len == 0) {\n\t\t\tif (h2->rxf_flags & H2FF_DATA_END_STREAM) {\n\t\t\t\tretval = VFP_END;\n\t\t\t\tr2->state = H2_S_CLOS_REM;\n\t\t\t}\n\t\t}\n\t\th2->mailcall = NULL;\n\t\tAZ(pthread_cond_signal(h2->cond));\n\t}\n\tLck_Unlock(&h2->sess->mtx);\n\treturn (retval);\n}",
        "func_after": "static enum vfp_status v_matchproto_(vfp_pull_f)\nh2_vfp_body(struct vfp_ctx *vc, struct vfp_entry *vfe, void *ptr, ssize_t *lp)\n{\n\tstruct h2_req *r2;\n\tstruct h2_sess *h2;\n\tunsigned l;\n\tenum vfp_status retval;\n\n\tCHECK_OBJ_NOTNULL(vc, VFP_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(vfe, VFP_ENTRY_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, vfe->priv1, H2_REQ_MAGIC);\n\th2 = r2->h2sess;\n\n\tAN(ptr);\n\tAN(lp);\n\tl = *lp;\n\t*lp = 0;\n\n\tLck_Lock(&h2->sess->mtx);\n\tr2->cond = &vc->wrk->cond;\n\twhile (h2->mailcall != r2 && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(r2->cond, &h2->sess->mtx, 0));\n\tr2->cond = NULL;\n\tif (h2->error || r2->error) {\n\t\tretval = VFP_ERROR;\n\t} else {\n\t\tassert(h2->mailcall == r2);\n\t\tif (l > h2->rxf_len)\n\t\t\tl = h2->rxf_len;\n\t\tif (l > 0) {\n\t\t\tmemcpy(ptr, h2->rxf_data, l);\n\t\t\th2->rxf_data += l;\n\t\t\th2->rxf_len -= l;\n\t\t}\n\t\t*lp = l;\n\t\tif (h2->rxf_len > 0) {\n\t\t\t/* We ran out of storage: Have VFP call us\n\t\t\t * again with a fresh buffer */\n\t\t\tLck_Unlock(&h2->sess->mtx);\n\t\t\treturn (VFP_OK);\n\t\t}\n\t\tif (h2->rxf_len == 0 && r2->state >= H2_S_CLOS_REM)\n\t\t\tretval = VFP_END;\n\t\telse\n\t\t\tretval = VFP_OK;\n\t\th2->mailcall = NULL;\n\t\tAZ(pthread_cond_signal(h2->cond));\n\t}\n\tLck_Unlock(&h2->sess->mtx);\n\treturn (retval);\n}",
        "description": "Varnish Cache, when HTTP/2 is enabled, is susceptible to request smuggling and VCL authorization bypass through the use of an excessively large Content-Length header in a POST request. This vulnerability impacts various versions of Varnish Enterprise and Varnish Cache, including specific releases prior to certain patch levels.",
        "commit": "When processing HTTP/2 (H/2) request bodies, ensure that the total size of received data frames aligns with the advertised content length. If the cumulative size of the data frames does not match the specified content length, the system should appropriately fail the request."
    },
    {
        "cwe": "CWE-116",
        "func_name": "flatpak/flatpak_builtin_info",
        "score": 0.7562915682792664,
        "func_before": "gboolean\nflatpak_builtin_info (int argc, char **argv, GCancellable *cancellable, GError **error)\n{\n  g_autoptr(GOptionContext) context = NULL;\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n  g_autoptr(FlatpakDir) dir = NULL;\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autoptr(FlatpakDeploy) deploy = NULL;\n  g_autoptr(GFile) deploy_dir = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  const char *commit = NULL;\n  const char *alt_id = NULL;\n  const char *eol;\n  const char *eol_rebase;\n  const char *name;\n  const char *summary;\n  const char *version;\n  const char *license;\n  const char *pref = NULL;\n  const char *default_branch = NULL;\n  const char *origin = NULL;\n  guint64 size;\n  gboolean search_all = FALSE;\n  gboolean first = TRUE;\n  FlatpakKinds kinds;\n  const char *path;\n  g_autofree char *formatted_size = NULL;\n  gboolean friendly = TRUE;\n  g_autofree const char **subpaths = NULL;\n  int len = 0;\n  int rows, cols;\n  int width;\n\n  context = g_option_context_new (_(\"NAME [BRANCH] - Get info about an installed app or runtime\"));\n  g_option_context_set_translation_domain (context, GETTEXT_PACKAGE);\n\n  if (!flatpak_option_context_parse (context, options, &argc, &argv, FLATPAK_BUILTIN_FLAG_NO_DIR, NULL, cancellable, error))\n    return FALSE;\n\n  if (argc < 2)\n    return usage_error (context, _(\"NAME must be specified\"), error);\n  pref = argv[1];\n\n  if (argc >= 3)\n    default_branch = argv[2];\n\n  if (argc > 3)\n    return usage_error (context, _(\"Too many arguments\"), error);\n\n  kinds = FLATPAK_KINDS_APP | FLATPAK_KINDS_RUNTIME;\n\n  if (!opt_user && !opt_system && opt_installations == NULL)\n    search_all = TRUE;\n\n  dir = flatpak_find_installed_pref (pref, kinds, opt_arch, default_branch,\n                                     search_all, opt_user, opt_system, opt_installations,\n                                     &ref, cancellable, error);\n  if (dir == NULL)\n    return FALSE;\n\n  deploy_data = flatpak_dir_get_deploy_data (dir, ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);\n  if (deploy_data == NULL)\n    return FALSE;\n\n  deploy = flatpak_dir_load_deployed (dir, ref, NULL, cancellable, error);\n  if (deploy == NULL)\n    return FALSE;\n\n  commit = flatpak_deploy_data_get_commit (deploy_data);\n  alt_id = flatpak_deploy_data_get_alt_id (deploy_data);\n  origin = flatpak_deploy_data_get_origin (deploy_data);\n  size = flatpak_deploy_data_get_installed_size (deploy_data);\n  formatted_size = g_format_size (size);\n  deploy_dir = flatpak_deploy_get_dir (deploy);\n  path = flatpak_file_get_path_cached (deploy_dir);\n  subpaths = flatpak_deploy_data_get_subpaths (deploy_data);\n  eol = flatpak_deploy_data_get_eol (deploy_data);\n  eol_rebase = flatpak_deploy_data_get_eol_rebase (deploy_data);\n  name = flatpak_deploy_data_get_appdata_name (deploy_data);\n  summary = flatpak_deploy_data_get_appdata_summary (deploy_data);\n  version = flatpak_deploy_data_get_appdata_version (deploy_data);\n  license = flatpak_deploy_data_get_appdata_license (deploy_data);\n\n  metakey = flatpak_deploy_get_metadata (deploy);\n\n  if (opt_show_ref || opt_show_origin || opt_show_commit || opt_show_size || opt_show_metadata || opt_show_permissions ||\n      opt_file_access || opt_show_location || opt_show_runtime || opt_show_sdk)\n    friendly = FALSE;\n\n  if (friendly)\n    {\n      g_autoptr(GVariant) commit_v = NULL;\n      VarMetadataRef commit_metadata;\n      guint64 timestamp;\n      g_autofree char *formatted_timestamp = NULL;\n      const gchar *subject = NULL;\n      g_autofree char *parent = NULL;\n      g_autofree char *latest = NULL;\n      const char *xa_metadata = NULL;\n      const char *collection_id = NULL;\n\n      flatpak_get_window_size (&rows, &cols);\n\n      if (name)\n        {\n          if (summary)\n            print_wrapped (MIN (cols, 80), \"\\n%s - %s\\n\", name, summary);\n          else\n            print_wrapped (MIN (cols, 80), \"\\n%s\\n\", name);\n        }\n\n      latest = flatpak_dir_read_latest (dir, origin, flatpak_decomposed_get_ref (ref), NULL, NULL, NULL);\n      if (latest == NULL)\n        latest = g_strdup (_(\"ref not present in origin\"));\n\n      if (ostree_repo_load_commit (flatpak_dir_get_repo (dir), commit, &commit_v, NULL, NULL))\n        {\n          VarCommitRef var_commit = var_commit_from_gvariant (commit_v);\n\n          subject = var_commit_get_subject (var_commit);\n          parent = ostree_commit_get_parent (commit_v);\n          timestamp = ostree_commit_get_timestamp (commit_v);\n\n          formatted_timestamp = format_timestamp (timestamp);\n\n          commit_metadata = var_commit_get_metadata (var_commit);\n          xa_metadata = var_metadata_lookup_string (commit_metadata, \"xa.metadata\", NULL);\n          if (xa_metadata == NULL)\n            g_printerr (_(\"Warning: Commit has no flatpak metadata\\n\"));\n\n          collection_id = var_metadata_lookup_string (commit_metadata, \"ostree.collection-binding\", NULL);\n        }\n\n      len = 0;\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Ref:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Arch:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Branch:\"), -1));\n      if (version)\n        len = MAX (len, g_utf8_strlen (_(\"Version:\"), -1));\n      if (license)\n        len = MAX (len, g_utf8_strlen (_(\"License:\"), -1));\n      if (collection_id != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Collection:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installation:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      if (flatpak_decomposed_is_app (ref))\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Runtime:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Sdk:\"), -1));\n        }\n      if (formatted_timestamp)\n        len = MAX (len, g_utf8_strlen (_(\"Date:\"), -1));\n      if (subject)\n        len = MAX (len, g_utf8_strlen (_(\"Subject:\"), -1));\n      if (strcmp (commit, latest) != 0)\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Active commit:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Latest commit:\"), -1));\n        }\n      else\n        len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      if (parent)\n        len = MAX (len, g_utf8_strlen (_(\"Parent:\"), -1));\n      if (alt_id)\n        len = MAX (len, g_utf8_strlen (_(\"Alt-id:\"), -1));\n      if (eol)\n        len = MAX (len, g_utf8_strlen (_(\"End-of-life:\"), -1));\n      if (eol_rebase)\n        len = MAX (len, g_utf8_strlen (_(\"End-of-life-rebase:\"), -1));\n      if (subpaths[0] != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Subdirectories:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Extension:\"), -1));\n\n      width = cols - (len + 1);\n\n      print_aligned_take (len, _(\"ID:\"), flatpak_decomposed_dup_id (ref));\n      print_aligned (len, _(\"Ref:\"), flatpak_decomposed_get_ref (ref));\n      print_aligned_take (len, _(\"Arch:\"), flatpak_decomposed_dup_arch (ref));\n      print_aligned_take (len, _(\"Branch:\"), flatpak_decomposed_dup_branch (ref));\n      if (version)\n        print_aligned (len, _(\"Version:\"), version);\n      if (license)\n        print_aligned (len, _(\"License:\"), license);\n      print_aligned (len, _(\"Origin:\"), origin ? origin : \"-\");\n      if (collection_id)\n        print_aligned (len, _(\"Collection:\"), collection_id);\n      print_aligned (len, _(\"Installation:\"), flatpak_dir_get_name_cached (dir));\n      print_aligned (len, _(\"Installed:\"), formatted_size);\n      if (flatpak_decomposed_is_app (ref))\n        {\n          g_autofree char *runtime = NULL;\n          runtime = g_key_file_get_string (metakey,\n                                           FLATPAK_METADATA_GROUP_APPLICATION,\n                                           FLATPAK_METADATA_KEY_RUNTIME,\n                                           error);\n          print_aligned (len, _(\"Runtime:\"), runtime ? runtime : \"-\");\n        }\n      if (flatpak_decomposed_is_app (ref))\n        {\n          g_autofree char *sdk = NULL;\n          sdk = g_key_file_get_string (metakey,\n                                       FLATPAK_METADATA_GROUP_APPLICATION,\n                                       FLATPAK_METADATA_KEY_SDK,\n                                       error);\n          print_aligned (len, _(\"Sdk:\"), sdk ? sdk : \"-\");\n        }\n      g_print (\"\\n\");\n\n      if (strcmp (commit, latest) != 0)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (commit, width);\n          print_aligned (len, _(\"Active commit:\"), formatted_commit);\n          g_free (formatted_commit);\n          formatted_commit = ellipsize_string (latest, width);\n          print_aligned (len, _(\"Latest commit:\"), formatted_commit);\n        }\n      else\n        {\n          g_autofree char *formatted_commit = ellipsize_string (commit, width);\n          print_aligned (len, _(\"Commit:\"), formatted_commit);\n        }\n      if (parent)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (parent, width);\n          print_aligned (len, _(\"Parent:\"), formatted_commit);\n        }\n      if (subject)\n        print_aligned (len, _(\"Subject:\"), subject);\n      if (formatted_timestamp)\n        print_aligned (len, _(\"Date:\"), formatted_timestamp);\n      if (subpaths[0] != NULL)\n        {\n          g_autofree char *s = g_strjoinv (\",\", (char **) subpaths);\n          print_aligned (len, _(\"Subdirectories:\"), s);\n        }\n\n      if (alt_id)\n        print_aligned (len, _(\"Alt-id:\"), alt_id);\n      if (eol)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol, width);\n          print_aligned (len, _(\"End-of-life:\"), formatted_eol);\n        }\n      if (eol_rebase)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol_rebase, width);\n          print_aligned (len, _(\"End-of-life-rebase:\"), formatted_eol);\n        }\n    }\n  else\n    {\n      if (opt_show_ref)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", flatpak_decomposed_get_ref (ref));\n        }\n\n      if (opt_show_origin)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", origin ? origin : \"-\");\n        }\n\n      if (opt_show_commit)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", commit);\n        }\n\n      if (opt_show_size)\n        {\n          maybe_print_space (&first);\n          g_print (\"%\" G_GUINT64_FORMAT, size);\n        }\n\n      if (opt_show_location)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", path);\n        }\n\n      if (opt_show_runtime)\n        {\n          g_autofree char *runtime = NULL;\n          maybe_print_space (&first);\n\n          runtime = g_key_file_get_string (metakey,\n                                           flatpak_decomposed_get_kind_metadata_group (ref),\n                                           FLATPAK_METADATA_KEY_RUNTIME,\n                                           NULL);\n          g_print (\"%s\", runtime ? runtime : \"-\");\n        }\n\n      if (opt_show_sdk)\n        {\n          g_autofree char *sdk = NULL;\n          maybe_print_space (&first);\n\n          sdk = g_key_file_get_string (metakey,\n                                       flatpak_decomposed_get_kind_metadata_group (ref),\n                                       FLATPAK_METADATA_KEY_SDK,\n                                       NULL);\n          g_print (\"%s\", sdk ? sdk : \"-\");\n        }\n\n      if (!first)\n        g_print (\"\\n\");\n\n      if (opt_show_metadata)\n        {\n          g_autoptr(GFile) file = NULL;\n          g_autofree char *data = NULL;\n          gsize data_size;\n\n          file = g_file_get_child (deploy_dir, \"metadata\");\n\n          if (!g_file_load_contents (file, cancellable, &data, &data_size, NULL, error))\n            return FALSE;\n\n          g_print (\"%s\", data);\n        }\n\n      if (opt_show_permissions || opt_file_access)\n        {\n          g_autoptr(FlatpakContext) app_context = NULL;\n          g_autoptr(GKeyFile) keyfile = NULL;\n          g_autofree gchar *contents = NULL;\n\n          app_context = flatpak_context_load_for_deploy (deploy, error);\n          if (app_context == NULL)\n            return FALSE;\n\n          if (opt_show_permissions)\n            {\n              keyfile = g_key_file_new ();\n              flatpak_context_save_metadata (app_context, TRUE, keyfile);\n              contents = g_key_file_to_data (keyfile, NULL, error);\n              if (contents == NULL)\n                return FALSE;\n\n              g_print (\"%s\", contents);\n            }\n\n          if (opt_file_access)\n            {\n              g_autofree char *id = flatpak_decomposed_dup_id (ref);\n              g_autoptr(FlatpakExports) exports = flatpak_context_get_exports (app_context, id);\n              FlatpakFilesystemMode mode;\n\n              mode = flatpak_exports_path_get_mode (exports, opt_file_access);\n              if (mode == 0)\n                g_print (\"hidden\\n\");\n              else if (mode == FLATPAK_FILESYSTEM_MODE_READ_ONLY)\n                g_print (\"read-only\\n\");\n              else\n                g_print (\"read-write\\n\");\n            }\n        }\n    }\n\n  if (opt_show_extensions)\n    {\n      GList *extensions, *l;\n      g_autofree char *ref_arch = flatpak_decomposed_dup_arch (ref);\n      g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);\n\n      len = MAX (len, g_utf8_strlen (_(\"Extension:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Origin:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Subpaths:\"), -1));\n\n      flatpak_get_window_size (&rows, &cols);\n      width = cols - (len + 1);\n\n      extensions = flatpak_list_extensions (metakey, ref_arch, ref_branch);\n      for (l = extensions; l; l = l->next)\n        {\n          FlatpakExtension *ext = l->data;\n          g_autofree const char **ext_subpaths = NULL;\n          g_autoptr(GBytes) ext_deploy_data = NULL;\n          g_autofree char *formatted = NULL;\n          g_autofree char *ext_formatted_size = NULL;\n          g_autofree char *formatted_commit = NULL;\n\n          if (ext->is_unmaintained)\n            {\n              formatted_commit = g_strdup (_(\"unmaintained\"));\n              origin = NULL;\n              size = 0;\n              ext_formatted_size = g_strdup (_(\"unknown\"));\n              ext_subpaths = NULL;\n            }\n          else\n            {\n              ext_deploy_data = flatpak_dir_get_deploy_data (dir, ext->ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);\n              if (ext_deploy_data == NULL)\n                return FALSE;\n\n              commit = flatpak_deploy_data_get_commit (ext_deploy_data);\n              formatted_commit = ellipsize_string (commit, width);\n              origin = flatpak_deploy_data_get_origin (ext_deploy_data);\n              size = flatpak_deploy_data_get_installed_size (ext_deploy_data);\n              formatted = g_format_size (size);\n              ext_subpaths = flatpak_deploy_data_get_subpaths (ext_deploy_data);\n              if (ext_subpaths && ext_subpaths[0] && size > 0)\n                ext_formatted_size = g_strconcat (\"<\", formatted, NULL);\n              else\n                ext_formatted_size = g_steal_pointer (&formatted);\n            }\n\n          g_print (\"\\n\");\n          print_aligned (len, _(\"Extension:\"), flatpak_decomposed_get_ref (ext->ref));\n          print_aligned (len, _(\"ID:\"), ext->id);\n          print_aligned (len, _(\"Origin:\"), origin ? origin : \"-\");\n          print_aligned (len, _(\"Commit:\"), formatted_commit);\n          print_aligned (len, _(\"Installed:\"), ext_formatted_size);\n\n          if (ext_subpaths && ext_subpaths[0])\n            {\n              g_autofree char *s = g_strjoinv (\",\", (char **) ext_subpaths);\n              print_aligned (len, _(\"Subpaths:\"), s);\n            }\n        }\n\n      g_list_free_full (extensions, (GDestroyNotify) flatpak_extension_free);\n    }\n\n  return TRUE;\n}",
        "func_after": "gboolean\nflatpak_builtin_info (int argc, char **argv, GCancellable *cancellable, GError **error)\n{\n  g_autoptr(GOptionContext) context = NULL;\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n  g_autoptr(FlatpakDir) dir = NULL;\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autoptr(FlatpakDeploy) deploy = NULL;\n  g_autoptr(GFile) deploy_dir = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  const char *commit = NULL;\n  const char *alt_id = NULL;\n  const char *eol;\n  const char *eol_rebase;\n  const char *name;\n  const char *summary;\n  const char *version;\n  const char *license;\n  const char *pref = NULL;\n  const char *default_branch = NULL;\n  const char *origin = NULL;\n  guint64 size;\n  gboolean search_all = FALSE;\n  gboolean first = TRUE;\n  FlatpakKinds kinds;\n  const char *path;\n  g_autofree char *formatted_size = NULL;\n  gboolean friendly = TRUE;\n  g_autofree const char **subpaths = NULL;\n  int len = 0;\n  int rows, cols;\n  int width;\n\n  context = g_option_context_new (_(\"NAME [BRANCH] - Get info about an installed app or runtime\"));\n  g_option_context_set_translation_domain (context, GETTEXT_PACKAGE);\n\n  if (!flatpak_option_context_parse (context, options, &argc, &argv, FLATPAK_BUILTIN_FLAG_NO_DIR, NULL, cancellable, error))\n    return FALSE;\n\n  if (argc < 2)\n    return usage_error (context, _(\"NAME must be specified\"), error);\n  pref = argv[1];\n\n  if (argc >= 3)\n    default_branch = argv[2];\n\n  if (argc > 3)\n    return usage_error (context, _(\"Too many arguments\"), error);\n\n  kinds = FLATPAK_KINDS_APP | FLATPAK_KINDS_RUNTIME;\n\n  if (!opt_user && !opt_system && opt_installations == NULL)\n    search_all = TRUE;\n\n  dir = flatpak_find_installed_pref (pref, kinds, opt_arch, default_branch,\n                                     search_all, opt_user, opt_system, opt_installations,\n                                     &ref, cancellable, error);\n  if (dir == NULL)\n    return FALSE;\n\n  deploy_data = flatpak_dir_get_deploy_data (dir, ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);\n  if (deploy_data == NULL)\n    return FALSE;\n\n  deploy = flatpak_dir_load_deployed (dir, ref, NULL, cancellable, error);\n  if (deploy == NULL)\n    return FALSE;\n\n  commit = flatpak_deploy_data_get_commit (deploy_data);\n  alt_id = flatpak_deploy_data_get_alt_id (deploy_data);\n  origin = flatpak_deploy_data_get_origin (deploy_data);\n  size = flatpak_deploy_data_get_installed_size (deploy_data);\n  formatted_size = g_format_size (size);\n  deploy_dir = flatpak_deploy_get_dir (deploy);\n  path = flatpak_file_get_path_cached (deploy_dir);\n  subpaths = flatpak_deploy_data_get_subpaths (deploy_data);\n  eol = flatpak_deploy_data_get_eol (deploy_data);\n  eol_rebase = flatpak_deploy_data_get_eol_rebase (deploy_data);\n  name = flatpak_deploy_data_get_appdata_name (deploy_data);\n  summary = flatpak_deploy_data_get_appdata_summary (deploy_data);\n  version = flatpak_deploy_data_get_appdata_version (deploy_data);\n  license = flatpak_deploy_data_get_appdata_license (deploy_data);\n\n  metakey = flatpak_deploy_get_metadata (deploy);\n\n  if (opt_show_ref || opt_show_origin || opt_show_commit || opt_show_size || opt_show_metadata || opt_show_permissions ||\n      opt_file_access || opt_show_location || opt_show_runtime || opt_show_sdk)\n    friendly = FALSE;\n\n  if (friendly)\n    {\n      g_autoptr(GVariant) commit_v = NULL;\n      VarMetadataRef commit_metadata;\n      guint64 timestamp;\n      g_autofree char *formatted_timestamp = NULL;\n      const gchar *subject = NULL;\n      g_autofree char *parent = NULL;\n      g_autofree char *latest = NULL;\n      const char *xa_metadata = NULL;\n      const char *collection_id = NULL;\n\n      flatpak_get_window_size (&rows, &cols);\n\n      if (name)\n        {\n          if (summary)\n            print_wrapped (MIN (cols, 80), \"\\n%s - %s\\n\", name, summary);\n          else\n            print_wrapped (MIN (cols, 80), \"\\n%s\\n\", name);\n        }\n\n      latest = flatpak_dir_read_latest (dir, origin, flatpak_decomposed_get_ref (ref), NULL, NULL, NULL);\n      if (latest == NULL)\n        latest = g_strdup (_(\"ref not present in origin\"));\n\n      if (ostree_repo_load_commit (flatpak_dir_get_repo (dir), commit, &commit_v, NULL, NULL))\n        {\n          VarCommitRef var_commit = var_commit_from_gvariant (commit_v);\n\n          subject = var_commit_get_subject (var_commit);\n          parent = ostree_commit_get_parent (commit_v);\n          timestamp = ostree_commit_get_timestamp (commit_v);\n\n          formatted_timestamp = format_timestamp (timestamp);\n\n          commit_metadata = var_commit_get_metadata (var_commit);\n          xa_metadata = var_metadata_lookup_string (commit_metadata, \"xa.metadata\", NULL);\n          if (xa_metadata == NULL)\n            g_printerr (_(\"Warning: Commit has no flatpak metadata\\n\"));\n\n          collection_id = var_metadata_lookup_string (commit_metadata, \"ostree.collection-binding\", NULL);\n        }\n\n      len = 0;\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Ref:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Arch:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Branch:\"), -1));\n      if (version)\n        len = MAX (len, g_utf8_strlen (_(\"Version:\"), -1));\n      if (license)\n        len = MAX (len, g_utf8_strlen (_(\"License:\"), -1));\n      if (collection_id != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Collection:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installation:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      if (flatpak_decomposed_is_app (ref))\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Runtime:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Sdk:\"), -1));\n        }\n      if (formatted_timestamp)\n        len = MAX (len, g_utf8_strlen (_(\"Date:\"), -1));\n      if (subject)\n        len = MAX (len, g_utf8_strlen (_(\"Subject:\"), -1));\n      if (strcmp (commit, latest) != 0)\n        {\n          len = MAX (len, g_utf8_strlen (_(\"Active commit:\"), -1));\n          len = MAX (len, g_utf8_strlen (_(\"Latest commit:\"), -1));\n        }\n      else\n        len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      if (parent)\n        len = MAX (len, g_utf8_strlen (_(\"Parent:\"), -1));\n      if (alt_id)\n        len = MAX (len, g_utf8_strlen (_(\"Alt-id:\"), -1));\n      if (eol)\n        len = MAX (len, g_utf8_strlen (_(\"End-of-life:\"), -1));\n      if (eol_rebase)\n        len = MAX (len, g_utf8_strlen (_(\"End-of-life-rebase:\"), -1));\n      if (subpaths[0] != NULL)\n        len = MAX (len, g_utf8_strlen (_(\"Subdirectories:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Extension:\"), -1));\n\n      width = cols - (len + 1);\n\n      print_aligned_take (len, _(\"ID:\"), flatpak_decomposed_dup_id (ref));\n      print_aligned (len, _(\"Ref:\"), flatpak_decomposed_get_ref (ref));\n      print_aligned_take (len, _(\"Arch:\"), flatpak_decomposed_dup_arch (ref));\n      print_aligned_take (len, _(\"Branch:\"), flatpak_decomposed_dup_branch (ref));\n      if (version)\n        print_aligned (len, _(\"Version:\"), version);\n      if (license)\n        print_aligned (len, _(\"License:\"), license);\n      print_aligned (len, _(\"Origin:\"), origin ? origin : \"-\");\n      if (collection_id)\n        print_aligned (len, _(\"Collection:\"), collection_id);\n      print_aligned (len, _(\"Installation:\"), flatpak_dir_get_name_cached (dir));\n      print_aligned (len, _(\"Installed:\"), formatted_size);\n      if (flatpak_decomposed_is_app (ref))\n        {\n          g_autofree char *runtime = NULL;\n          runtime = g_key_file_get_string (metakey,\n                                           FLATPAK_METADATA_GROUP_APPLICATION,\n                                           FLATPAK_METADATA_KEY_RUNTIME,\n                                           error);\n          print_aligned (len, _(\"Runtime:\"), runtime ? runtime : \"-\");\n        }\n      if (flatpak_decomposed_is_app (ref))\n        {\n          g_autofree char *sdk = NULL;\n          sdk = g_key_file_get_string (metakey,\n                                       FLATPAK_METADATA_GROUP_APPLICATION,\n                                       FLATPAK_METADATA_KEY_SDK,\n                                       error);\n          print_aligned (len, _(\"Sdk:\"), sdk ? sdk : \"-\");\n        }\n      g_print (\"\\n\");\n\n      if (strcmp (commit, latest) != 0)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (commit, width);\n          print_aligned (len, _(\"Active commit:\"), formatted_commit);\n          g_free (formatted_commit);\n          formatted_commit = ellipsize_string (latest, width);\n          print_aligned (len, _(\"Latest commit:\"), formatted_commit);\n        }\n      else\n        {\n          g_autofree char *formatted_commit = ellipsize_string (commit, width);\n          print_aligned (len, _(\"Commit:\"), formatted_commit);\n        }\n      if (parent)\n        {\n          g_autofree char *formatted_commit = ellipsize_string (parent, width);\n          print_aligned (len, _(\"Parent:\"), formatted_commit);\n        }\n      if (subject)\n        print_aligned (len, _(\"Subject:\"), subject);\n      if (formatted_timestamp)\n        print_aligned (len, _(\"Date:\"), formatted_timestamp);\n      if (subpaths[0] != NULL)\n        {\n          g_autofree char *s = g_strjoinv (\",\", (char **) subpaths);\n          print_aligned (len, _(\"Subdirectories:\"), s);\n        }\n\n      if (alt_id)\n        print_aligned (len, _(\"Alt-id:\"), alt_id);\n      if (eol)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol, width);\n          print_aligned (len, _(\"End-of-life:\"), formatted_eol);\n        }\n      if (eol_rebase)\n        {\n          g_autofree char *formatted_eol = ellipsize_string (eol_rebase, width);\n          print_aligned (len, _(\"End-of-life-rebase:\"), formatted_eol);\n        }\n    }\n  else\n    {\n      if (opt_show_ref)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", flatpak_decomposed_get_ref (ref));\n        }\n\n      if (opt_show_origin)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", origin ? origin : \"-\");\n        }\n\n      if (opt_show_commit)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", commit);\n        }\n\n      if (opt_show_size)\n        {\n          maybe_print_space (&first);\n          g_print (\"%\" G_GUINT64_FORMAT, size);\n        }\n\n      if (opt_show_location)\n        {\n          maybe_print_space (&first);\n          g_print (\"%s\", path);\n        }\n\n      if (opt_show_runtime)\n        {\n          g_autofree char *runtime = NULL;\n          maybe_print_space (&first);\n\n          runtime = g_key_file_get_string (metakey,\n                                           flatpak_decomposed_get_kind_metadata_group (ref),\n                                           FLATPAK_METADATA_KEY_RUNTIME,\n                                           NULL);\n          g_print (\"%s\", runtime ? runtime : \"-\");\n        }\n\n      if (opt_show_sdk)\n        {\n          g_autofree char *sdk = NULL;\n          maybe_print_space (&first);\n\n          sdk = g_key_file_get_string (metakey,\n                                       flatpak_decomposed_get_kind_metadata_group (ref),\n                                       FLATPAK_METADATA_KEY_SDK,\n                                       NULL);\n          g_print (\"%s\", sdk ? sdk : \"-\");\n        }\n\n      if (!first)\n        g_print (\"\\n\");\n\n      if (opt_show_metadata)\n        {\n          g_autoptr(GFile) file = NULL;\n          g_autofree char *data = NULL;\n          gsize data_size;\n\n          file = g_file_get_child (deploy_dir, \"metadata\");\n\n          if (!g_file_load_contents (file, cancellable, &data, &data_size, NULL, error))\n            return FALSE;\n\n          flatpak_print_escaped_string (data,\n                                        FLATPAK_ESCAPE_ALLOW_NEWLINES\n                                        | FLATPAK_ESCAPE_DO_NOT_QUOTE);\n        }\n\n      if (opt_show_permissions || opt_file_access)\n        {\n          g_autoptr(FlatpakContext) app_context = NULL;\n          g_autoptr(GKeyFile) keyfile = NULL;\n          g_autofree gchar *contents = NULL;\n\n          app_context = flatpak_context_load_for_deploy (deploy, error);\n          if (app_context == NULL)\n            return FALSE;\n\n          if (opt_show_permissions)\n            {\n              keyfile = g_key_file_new ();\n              flatpak_context_save_metadata (app_context, TRUE, keyfile);\n              contents = g_key_file_to_data (keyfile, NULL, error);\n              if (contents == NULL)\n                return FALSE;\n\n              flatpak_print_escaped_string (contents,\n                                            FLATPAK_ESCAPE_ALLOW_NEWLINES\n                                            | FLATPAK_ESCAPE_DO_NOT_QUOTE);\n            }\n\n          if (opt_file_access)\n            {\n              g_autofree char *id = flatpak_decomposed_dup_id (ref);\n              g_autoptr(FlatpakExports) exports = flatpak_context_get_exports (app_context, id);\n              FlatpakFilesystemMode mode;\n\n              mode = flatpak_exports_path_get_mode (exports, opt_file_access);\n              if (mode == 0)\n                g_print (\"hidden\\n\");\n              else if (mode == FLATPAK_FILESYSTEM_MODE_READ_ONLY)\n                g_print (\"read-only\\n\");\n              else\n                g_print (\"read-write\\n\");\n            }\n        }\n    }\n\n  if (opt_show_extensions)\n    {\n      GList *extensions, *l;\n      g_autofree char *ref_arch = flatpak_decomposed_dup_arch (ref);\n      g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);\n\n      len = MAX (len, g_utf8_strlen (_(\"Extension:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"ID:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Origin:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Commit:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Installed:\"), -1));\n      len = MAX (len, g_utf8_strlen (_(\"Subpaths:\"), -1));\n\n      flatpak_get_window_size (&rows, &cols);\n      width = cols - (len + 1);\n\n      extensions = flatpak_list_extensions (metakey, ref_arch, ref_branch);\n      for (l = extensions; l; l = l->next)\n        {\n          FlatpakExtension *ext = l->data;\n          g_autofree const char **ext_subpaths = NULL;\n          g_autoptr(GBytes) ext_deploy_data = NULL;\n          g_autofree char *formatted = NULL;\n          g_autofree char *ext_formatted_size = NULL;\n          g_autofree char *formatted_commit = NULL;\n\n          if (ext->is_unmaintained)\n            {\n              formatted_commit = g_strdup (_(\"unmaintained\"));\n              origin = NULL;\n              size = 0;\n              ext_formatted_size = g_strdup (_(\"unknown\"));\n              ext_subpaths = NULL;\n            }\n          else\n            {\n              ext_deploy_data = flatpak_dir_get_deploy_data (dir, ext->ref, FLATPAK_DEPLOY_VERSION_CURRENT, cancellable, error);\n              if (ext_deploy_data == NULL)\n                return FALSE;\n\n              commit = flatpak_deploy_data_get_commit (ext_deploy_data);\n              formatted_commit = ellipsize_string (commit, width);\n              origin = flatpak_deploy_data_get_origin (ext_deploy_data);\n              size = flatpak_deploy_data_get_installed_size (ext_deploy_data);\n              formatted = g_format_size (size);\n              ext_subpaths = flatpak_deploy_data_get_subpaths (ext_deploy_data);\n              if (ext_subpaths && ext_subpaths[0] && size > 0)\n                ext_formatted_size = g_strconcat (\"<\", formatted, NULL);\n              else\n                ext_formatted_size = g_steal_pointer (&formatted);\n            }\n\n          g_print (\"\\n\");\n          print_aligned (len, _(\"Extension:\"), flatpak_decomposed_get_ref (ext->ref));\n          print_aligned (len, _(\"ID:\"), ext->id);\n          print_aligned (len, _(\"Origin:\"), origin ? origin : \"-\");\n          print_aligned (len, _(\"Commit:\"), formatted_commit);\n          print_aligned (len, _(\"Installed:\"), ext_formatted_size);\n\n          if (ext_subpaths && ext_subpaths[0])\n            {\n              g_autofree char *s = g_strjoinv (\",\", (char **) ext_subpaths);\n              print_aligned (len, _(\"Subpaths:\"), s);\n            }\n        }\n\n      g_list_free_full (extensions, (GDestroyNotify) flatpak_extension_free);\n    }\n\n  return TRUE;\n}",
        "description": "In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, Flatpak allowed attackers to publish applications with elevated permissions while hiding these permissions from users through the `flatpak(1)` command-line interface. This was achieved by setting other permissions to crafted values containing non-printable control characters such as `ESC`. A fix is available in the mentioned versions. As a workaround, users are advised to use a graphical user interface like GNOME Software instead of the command-line interface, or to only install applications from trusted maintainers.",
        "commit": "It is important to escape special characters in permissions and metadata to prevent manipulation of the permissions list's appearance."
    }
]