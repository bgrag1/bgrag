[
    {
        "cwe": "CWE-1284",
        "func_name": "Samsung/crypto_bignum_allocate",
        "score": 0.7582201361656189,
        "func_before": "struct bignum *crypto_bignum_allocate(size_t size_bits)\n{\n\tsize_t sz = mpa_StaticVarSizeInU32(size_bits) *\tsizeof(uint32_t);\n\tstruct mpa_numbase_struct *bn = calloc(1, sz);\n\n\tif (!bn)\n\t\treturn NULL;\n\tbn->alloc = sz - MPA_NUMBASE_METADATA_SIZE_IN_U32 * sizeof(uint32_t);\n\treturn (struct bignum *)bn;\n}",
        "func_after": "struct bignum *crypto_bignum_allocate(size_t size_bits)\n{\n\tsize_t sz = mpa_StaticVarSizeInU32(size_bits) *\tsizeof(uint32_t);\n\t// struct mpa_numbase_struct *bn = calloc(1, sz);\n\tstruct mpa_numbase_struct *bn= TEE_Malloc(sz, TEE_MALLOC_FILL_ZERO);\n\tif (!bn)\n\t\treturn NULL;\n\tbn->alloc = sz - MPA_NUMBASE_METADATA_SIZE_IN_U32 * sizeof(uint32_t);\n\treturn (struct bignum *)bn;\n}",
        "description": "The function `tee_obj_free` in Samsung mTower through version 0.3.0 enables a trusted application to cause a Denial of Service (DoS) by calling the function `TEE_AllocateOperation` with a disrupted heap layout, which is associated with `utee_cryp_obj_alloc`.",
        "commit": "A vulnerability has been addressed in a software system, specifically identified by CVE-2022-40761."
    },
    {
        "cwe": "CWE-347",
        "func_name": "rpm-software-management/pgpPrtParams",
        "score": 0.7677093148231506,
        "func_before": "int pgpPrtParams(const uint8_t * pkts, size_t pktlen, unsigned int pkttype,\n\t\t pgpDigParams * ret)\n{\n    const uint8_t *p = pkts;\n    const uint8_t *pend = pkts + pktlen;\n    pgpDigParams digp = NULL;\n    struct pgpPkt pkt;\n    int rc = -1; /* assume failure */\n\n    while (p < pend) {\n\tif (decodePkt(p, (pend - p), &pkt))\n\t    break;\n\n\tif (digp == NULL) {\n\t    if (pkttype && pkt.tag != pkttype) {\n\t\tbreak;\n\t    } else {\n\t\tdigp = pgpDigParamsNew(pkt.tag);\n\t    }\n\t}\n\n\tif (pgpPrtPkt(&pkt, digp))\n\t    break;\n\n\tp += (pkt.body - pkt.head) + pkt.blen;\n\tif (pkttype == PGPTAG_SIGNATURE)\n\t    break;\n    }\n\n    rc = (digp && (p == pend)) ? 0 : -1;\n\n    if (ret && rc == 0) {\n\t*ret = digp;\n    } else {\n\tpgpDigParamsFree(digp);\n    }\n    return rc;\n}",
        "func_after": "int pgpPrtParams(const uint8_t * pkts, size_t pktlen, unsigned int pkttype,\n\t\t pgpDigParams * ret)\n{\n    const uint8_t *p = pkts;\n    const uint8_t *pend = pkts + pktlen;\n    pgpDigParams digp = NULL;\n    pgpDigParams selfsig = NULL;\n    int i = 0;\n    int alloced = 16; /* plenty for normal cases */\n    struct pgpPkt *all = xmalloc(alloced * sizeof(*all));\n    int rc = -1; /* assume failure */\n    int expect = 0;\n    int prevtag = 0;\n\n    while (p < pend) {\n\tstruct pgpPkt *pkt = &all[i];\n\tif (decodePkt(p, (pend - p), pkt))\n\t    break;\n\n\tif (digp == NULL) {\n\t    if (pkttype && pkt->tag != pkttype) {\n\t\tbreak;\n\t    } else {\n\t\tdigp = pgpDigParamsNew(pkt->tag);\n\t    }\n\t}\n\n\tif (expect) {\n\t    if (pkt->tag != expect)\n\t\tbreak;\n\t    selfsig = pgpDigParamsNew(pkt->tag);\n\t}\n\n\tif (pgpPrtPkt(pkt, selfsig ? selfsig : digp))\n\t    break;\n\n\tif (selfsig) {\n\t    /* subkeys must be followed by binding signature */\n\t    if (prevtag == PGPTAG_PUBLIC_SUBKEY) {\n\t\tif (selfsig->sigtype != PGPSIGTYPE_SUBKEY_BINDING)\n\t\t    break;\n\t    }\n\n\t    int xx = pgpVerifySelf(digp, selfsig, all, i);\n\n\t    selfsig = pgpDigParamsFree(selfsig);\n\t    if (xx)\n\t\tbreak;\n\t    expect = 0;\n\t}\n\n\tif (pkt->tag == PGPTAG_PUBLIC_SUBKEY)\n\t    expect = PGPTAG_SIGNATURE;\n\tprevtag = pkt->tag;\n\n\ti++;\n\tp += (pkt->body - pkt->head) + pkt->blen;\n\tif (pkttype == PGPTAG_SIGNATURE)\n\t    break;\n\n\tif (alloced <= i) {\n\t    alloced *= 2;\n\t    all = xrealloc(all, alloced * sizeof(*all));\n\t}\n    }\n\n    rc = (digp && (p == pend) && expect == 0) ? 0 : -1;\n\n    free(all);\n    if (ret && rc == 0) {\n\t*ret = digp;\n    } else {\n\tpgpDigParamsFree(digp);\n    }\n    return rc;\n}",
        "description": "There is a flaw in RPM's signature functionality where it does not verify the binding signature of subkeys before importing them. This can allow an attacker to add or trick another party into adding a malicious subkey to a legitimate public key, potentially causing RPM to trust a malicious signature. The primary impact of this flaw is on data integrity. Exploitation requires compromising an RPM repository or convincing an administrator to install an untrusted RPM or public key. It is recommended to only use RPMs and public keys from trusted sources.",
        "commit": "To enhance the applicability of the given vulnerability knowledge across different scenarios, we can abstract and generalize it as follows:\n\n**Abstracted and Generalized Description:**\n\n\"A vulnerability was identified in the parsing mechanism of PGP public keys, where the implementation lacked enforcement of subkey binding signatures as mandated by the OpenPGP RFC. To address this, a workaround was introduced to ensure that all subkeys are validated by a binding signature from the primary key. This solution involves storing raw packets internally during decoding to facilitate access to previous elements for validating ordering and data integrity. Additionally, test cases were added to handle manipulated keys that previously could be imported successfully. This fix aims to improve the robustness of the parser without altering the API to maximize compatibility with older versions.\""
    },
    {
        "cwe": "CWE-681",
        "func_name": "FreeRDP/update_recv_secondary_order",
        "score": 0.7818727493286133,
        "func_before": "static BOOL update_recv_secondary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBOOL rc = FALSE;\n\tsize_t start, end, diff;\n\tBYTE orderType;\n\tUINT16 extraFlags;\n\tUINT16 orderLength;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpSecondaryUpdate* secondary = update->secondary;\n\tconst char* name;\n\n\tif (Stream_GetRemainingLength(s) < 5)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 5\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Read_UINT16(s, extraFlags);  /* extraFlags (2 bytes) */\n\tStream_Read_UINT8(s, orderType);    /* orderType (1 byte) */\n\tif (Stream_GetRemainingLength(s) < orderLength + 7U)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) %\" PRIuz \" < %\" PRIu16,\n\t\t           Stream_GetRemainingLength(s), orderLength + 7);\n\t\treturn FALSE;\n\t}\n\n\tstart = Stream_GetPosition(s);\n\tname = secondary_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Secondary Drawing Order %s\", name);\n\n\tif (!check_secondary_order_supported(update->log, settings, orderType, name))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_CACHE_BITMAP_COMPRESSED);\n\t\t\tCACHE_BITMAP_ORDER* order =\n\t\t\t    update_read_cache_bitmap_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmap, context, order);\n\t\t\t\tfree_cache_bitmap_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_BITMAP_COMPRESSED_V2);\n\t\t\tCACHE_BITMAP_V2_ORDER* order =\n\t\t\t    update_read_cache_bitmap_v2_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV2, context, order);\n\t\t\t\tfree_cache_bitmap_v2_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t{\n\t\t\tCACHE_BITMAP_V3_ORDER* order = update_read_cache_bitmap_v3_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV3, context, order);\n\t\t\t\tfree_cache_bitmap_v3_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t{\n\t\t\tCACHE_COLOR_TABLE_ORDER* order =\n\t\t\t    update_read_cache_color_table_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheColorTable, context, order);\n\t\t\t\tfree_cache_color_table_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_ORDER* order = update_read_cache_glyph_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyph, context, order);\n\t\t\t\t\t\tfree_cache_glyph_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_V2_ORDER* order =\n\t\t\t\t\t    update_read_cache_glyph_v2_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyphV2, context, order);\n\t\t\t\t\t\tfree_cache_glyph_v2_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\t/* [MS-RDPEGDI] 2.2.2.2.1.2.7 Cache Brush (CACHE_BRUSH_ORDER) */\n\t\t\t{\n\t\t\t\tCACHE_BRUSH_ORDER* order = update_read_cache_brush_order(update, s, extraFlags);\n\n\t\t\t\tif (order)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBrush, context, order);\n\t\t\t\t\tfree_cache_brush_order(context, order);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", name);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"SECONDARY ORDER %s failed\", name);\n\t}\n\n\tstart += orderLength + 7;\n\tend = Stream_GetPosition(s);\n\tif (start > end)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes too much\",\n\t\t           name, end - start);\n\t\treturn FALSE;\n\t}\n\tdiff = start - end;\n\tif (diff > 0)\n\t{\n\t\tWLog_Print(update->log, WLOG_DEBUG,\n\t\t           \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes short, skipping\", name, diff);\n\t\tStream_Seek(s, diff);\n\t}\n\treturn rc;\n}",
        "func_after": "static BOOL update_recv_secondary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBOOL rc = FALSE;\n\tsize_t start, end, diff;\n\tBYTE orderType;\n\tUINT16 extraFlags;\n\tUINT16 orderLength;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpSecondaryUpdate* secondary = update->secondary;\n\tconst char* name;\n\n\tif (Stream_GetRemainingLength(s) < 5)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 5\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Read_UINT16(s, extraFlags);  /* extraFlags (2 bytes) */\n\tStream_Read_UINT8(s, orderType);    /* orderType (1 byte) */\n\tif (Stream_GetRemainingLength(s) < orderLength + 7U)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) %\" PRIuz \" < %\" PRIu16,\n\t\t           Stream_GetRemainingLength(s), orderLength + 7);\n\t\treturn FALSE;\n\t}\n\n\tstart = Stream_GetPosition(s);\n\tname = secondary_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Secondary Drawing Order %s\", name);\n\n\tif (!check_secondary_order_supported(update->log, settings, orderType, name))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_CACHE_BITMAP_COMPRESSED);\n\t\t\tCACHE_BITMAP_ORDER* order =\n\t\t\t    update_read_cache_bitmap_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmap, context, order);\n\t\t\t\tfree_cache_bitmap_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_BITMAP_COMPRESSED_V2);\n\t\t\tCACHE_BITMAP_V2_ORDER* order =\n\t\t\t    update_read_cache_bitmap_v2_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV2, context, order);\n\t\t\t\tfree_cache_bitmap_v2_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t{\n\t\t\tCACHE_BITMAP_V3_ORDER* order = update_read_cache_bitmap_v3_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV3, context, order);\n\t\t\t\tfree_cache_bitmap_v3_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t{\n\t\t\tCACHE_COLOR_TABLE_ORDER* order =\n\t\t\t    update_read_cache_color_table_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheColorTable, context, order);\n\t\t\t\tfree_cache_color_table_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_ORDER* order = update_read_cache_glyph_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyph, context, order);\n\t\t\t\t\t\tfree_cache_glyph_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_V2_ORDER* order =\n\t\t\t\t\t    update_read_cache_glyph_v2_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyphV2, context, order);\n\t\t\t\t\t\tfree_cache_glyph_v2_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\t/* [MS-RDPEGDI] 2.2.2.2.1.2.7 Cache Brush (CACHE_BRUSH_ORDER) */\n\t\t\t{\n\t\t\t\tCACHE_BRUSH_ORDER* order = update_read_cache_brush_order(update, s, extraFlags);\n\n\t\t\t\tif (order)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBrush, context, order);\n\t\t\t\t\tfree_cache_brush_order(context, order);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", name);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"SECONDARY ORDER %s failed\", name);\n\t}\n\n\tstart += orderLength + 7;\n\tend = Stream_GetPosition(s);\n\tif (start > end)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes too much\",\n\t\t           name, end - start);\n\t\treturn FALSE;\n\t}\n\tdiff = end - start;\n\tif (diff > 0)\n\t{\n\t\tWLog_Print(update->log, WLOG_DEBUG,\n\t\t           \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes short, skipping\", name, diff);\n\t\tif (!Stream_SafeSeek(s, diff))\n\t\t\treturn FALSE;\n\t}\n\treturn rc;\n}",
        "description": "In FreeRDP versions prior to 2.1.2, there exists an integer casting vulnerability within the `update_recv_secondary_order` function. This vulnerability affects all clients configured with both `+glyph-cache` and `relax-order-checks` options. This issue has been addressed in version 2.1.2.",
        "commit": "An out-of-bounds (OOB) read vulnerability was addressed in the `update_recv_secondary_order` function. This issue was identified and reported by @antonio-morales."
    },
    {
        "cwe": "CWE-346",
        "func_name": "hotplug/udev_monitor_receive_device",
        "score": 0.7798311710357666,
        "func_before": "struct udev_device *udev_monitor_receive_device(struct udev_monitor *udev_monitor)\n{\n\tstruct udev_device *udev_device;\n\tstruct msghdr smsg;\n\tstruct iovec iov;\n\tchar cred_msg[CMSG_SPACE(sizeof(struct ucred))];\n\tchar buf[4096];\n\tsize_t bufpos;\n\tint devpath_set = 0;\n\tint subsystem_set = 0;\n\tint action_set = 0;\n\tint maj = 0;\n\tint min = 0;\n\n\tif (udev_monitor == NULL)\n\t\treturn NULL;\n\tmemset(buf, 0x00, sizeof(buf));\n\tiov.iov_base = &buf;\n\tiov.iov_len = sizeof(buf);\n\tmemset (&smsg, 0x00, sizeof(struct msghdr));\n\tsmsg.msg_iov = &iov;\n\tsmsg.msg_iovlen = 1;\n\tsmsg.msg_control = cred_msg;\n\tsmsg.msg_controllen = sizeof(cred_msg);\n\n\tif (recvmsg(udev_monitor->sock, &smsg, 0) < 0) {\n\t\tif (errno != EINTR)\n\t\t\tinfo(udev_monitor->udev, \"unable to receive message\");\n\t\treturn NULL;\n\t}\n\n\tif (udev_monitor->sun.sun_family != 0) {\n\t\tstruct cmsghdr *cmsg = CMSG_FIRSTHDR(&smsg);\n\t\tstruct ucred *cred = (struct ucred *)CMSG_DATA (cmsg);\n\n\t\tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {\n\t\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (cred->uid != 0) {\n\t\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* skip header */\n\tbufpos = strlen(buf) + 1;\n\tif (bufpos < sizeof(\"a@/d\") || bufpos >= sizeof(buf)) {\n\t\tinfo(udev_monitor->udev, \"invalid message length\");\n\t\treturn NULL;\n\t}\n\n\t/* check message header */\n\tif (strstr(buf, \"@/\") == NULL) {\n\t\tinfo(udev_monitor->udev, \"unrecognized message header\");\n\t\treturn NULL;\n\t}\n\n\tudev_device = device_new(udev_monitor->udev);\n\tif (udev_device == NULL) {\n\t\treturn NULL;\n\t}\n\n\twhile (bufpos < sizeof(buf)) {\n\t\tchar *key;\n\t\tsize_t keylen;\n\n\t\tkey = &buf[bufpos];\n\t\tkeylen = strlen(key);\n\t\tif (keylen == 0)\n\t\t\tbreak;\n\t\tbufpos += keylen + 1;\n\n\t\tif (strncmp(key, \"DEVPATH=\", 8) == 0) {\n\t\t\tchar path[UTIL_PATH_SIZE];\n\n\t\t\tutil_strlcpy(path, udev_get_sys_path(udev_monitor->udev), sizeof(path));\n\t\t\tutil_strlcat(path, &key[8], sizeof(path));\n\t\t\tudev_device_set_syspath(udev_device, path);\n\t\t\tdevpath_set = 1;\n\t\t} else if (strncmp(key, \"SUBSYSTEM=\", 10) == 0) {\n\t\t\tudev_device_set_subsystem(udev_device, &key[10]);\n\t\t\tsubsystem_set = 1;\n\t\t} else if (strncmp(key, \"DEVTYPE=\", 8) == 0) {\n\t\t\tudev_device_set_devtype(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVNAME=\", 8) == 0) {\n\t\t\tudev_device_set_devnode(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVLINKS=\", 9) == 0) {\n\t\t\tchar devlinks[UTIL_PATH_SIZE];\n\t\t\tchar *slink;\n\t\t\tchar *next;\n\n\t\t\tutil_strlcpy(devlinks, &key[9], sizeof(devlinks));\n\t\t\tslink = devlinks;\n\t\t\tnext = strchr(slink, ' ');\n\t\t\twhile (next != NULL) {\n\t\t\t\tnext[0] = '\\0';\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t\t\tslink = &next[1];\n\t\t\t\tnext = strchr(slink, ' ');\n\t\t\t}\n\t\t\tif (slink[0] != '\\0')\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t} else if (strncmp(key, \"DRIVER=\", 7) == 0) {\n\t\t\tudev_device_set_driver(udev_device, &key[7]);\n\t\t} else if (strncmp(key, \"ACTION=\", 7) == 0) {\n\t\t\tudev_device_set_action(udev_device, &key[7]);\n\t\t\taction_set = 1;\n\t\t} else if (strncmp(key, \"MAJOR=\", 6) == 0) {\n\t\t\tmaj = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"MINOR=\", 6) == 0) {\n\t\t\tmin = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"DEVPATH_OLD=\", 12) == 0) {\n\t\t\tudev_device_set_devpath_old(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"PHYSDEVPATH=\", 12) == 0) {\n\t\t\tudev_device_set_physdevpath(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"SEQNUM=\", 7) == 0) {\n\t\t\tudev_device_set_seqnum(udev_device, strtoull(&key[7], NULL, 10));\n\t\t} else if (strncmp(key, \"TIMEOUT=\", 8) == 0) {\n\t\t\tudev_device_set_timeout(udev_device, strtoull(&key[8], NULL, 10));\n\t\t} else if (strncmp(key, \"PHYSDEV\", 7) == 0) {\n\t\t\t/* skip deprecated values */\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tudev_device_add_property_from_string(udev_device, key);\n\t\t}\n\t}\n\tif (!devpath_set || !subsystem_set || !action_set) {\n\t\tinfo(udev_monitor->udev, \"missing values, skip\\n\");\n\t\tudev_device_unref(udev_device);\n\t\treturn NULL;\n\t}\n\tif (maj > 0)\n\t\tudev_device_set_devnum(udev_device, makedev(maj, min));\n\tudev_device_set_info_loaded(udev_device);\n\treturn udev_device;\n}",
        "func_after": "struct udev_device *udev_monitor_receive_device(struct udev_monitor *udev_monitor)\n{\n\tstruct udev_device *udev_device;\n\tstruct msghdr smsg;\n\tstruct iovec iov;\n\tchar cred_msg[CMSG_SPACE(sizeof(struct ucred))];\n\tstruct cmsghdr *cmsg;\n\tstruct ucred *cred;\n\tchar buf[4096];\n\tsize_t bufpos;\n\tint devpath_set = 0;\n\tint subsystem_set = 0;\n\tint action_set = 0;\n\tint maj = 0;\n\tint min = 0;\n\n\tif (udev_monitor == NULL)\n\t\treturn NULL;\n\tmemset(buf, 0x00, sizeof(buf));\n\tiov.iov_base = &buf;\n\tiov.iov_len = sizeof(buf);\n\tmemset (&smsg, 0x00, sizeof(struct msghdr));\n\tsmsg.msg_iov = &iov;\n\tsmsg.msg_iovlen = 1;\n\tsmsg.msg_control = cred_msg;\n\tsmsg.msg_controllen = sizeof(cred_msg);\n\n\tif (recvmsg(udev_monitor->sock, &smsg, 0) < 0) {\n\t\tif (errno != EINTR)\n\t\t\tinfo(udev_monitor->udev, \"unable to receive message\");\n\t\treturn NULL;\n\t}\n\n\tcmsg = CMSG_FIRSTHDR(&smsg);\n\tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {\n\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");\n\t\treturn NULL;\n\t}\n\n\tcred = (struct ucred *)CMSG_DATA(cmsg);\n\tif (cred->uid != 0) {\n\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);\n\t\treturn NULL;\n\t}\n\n\t/* skip header */\n\tbufpos = strlen(buf) + 1;\n\tif (bufpos < sizeof(\"a@/d\") || bufpos >= sizeof(buf)) {\n\t\tinfo(udev_monitor->udev, \"invalid message length\");\n\t\treturn NULL;\n\t}\n\n\t/* check message header */\n\tif (strstr(buf, \"@/\") == NULL) {\n\t\tinfo(udev_monitor->udev, \"unrecognized message header\");\n\t\treturn NULL;\n\t}\n\n\tudev_device = device_new(udev_monitor->udev);\n\tif (udev_device == NULL) {\n\t\treturn NULL;\n\t}\n\n\twhile (bufpos < sizeof(buf)) {\n\t\tchar *key;\n\t\tsize_t keylen;\n\n\t\tkey = &buf[bufpos];\n\t\tkeylen = strlen(key);\n\t\tif (keylen == 0)\n\t\t\tbreak;\n\t\tbufpos += keylen + 1;\n\n\t\tif (strncmp(key, \"DEVPATH=\", 8) == 0) {\n\t\t\tchar path[UTIL_PATH_SIZE];\n\n\t\t\tutil_strlcpy(path, udev_get_sys_path(udev_monitor->udev), sizeof(path));\n\t\t\tutil_strlcat(path, &key[8], sizeof(path));\n\t\t\tudev_device_set_syspath(udev_device, path);\n\t\t\tdevpath_set = 1;\n\t\t} else if (strncmp(key, \"SUBSYSTEM=\", 10) == 0) {\n\t\t\tudev_device_set_subsystem(udev_device, &key[10]);\n\t\t\tsubsystem_set = 1;\n\t\t} else if (strncmp(key, \"DEVTYPE=\", 8) == 0) {\n\t\t\tudev_device_set_devtype(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVNAME=\", 8) == 0) {\n\t\t\tudev_device_set_devnode(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVLINKS=\", 9) == 0) {\n\t\t\tchar devlinks[UTIL_PATH_SIZE];\n\t\t\tchar *slink;\n\t\t\tchar *next;\n\n\t\t\tutil_strlcpy(devlinks, &key[9], sizeof(devlinks));\n\t\t\tslink = devlinks;\n\t\t\tnext = strchr(slink, ' ');\n\t\t\twhile (next != NULL) {\n\t\t\t\tnext[0] = '\\0';\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t\t\tslink = &next[1];\n\t\t\t\tnext = strchr(slink, ' ');\n\t\t\t}\n\t\t\tif (slink[0] != '\\0')\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t} else if (strncmp(key, \"DRIVER=\", 7) == 0) {\n\t\t\tudev_device_set_driver(udev_device, &key[7]);\n\t\t} else if (strncmp(key, \"ACTION=\", 7) == 0) {\n\t\t\tudev_device_set_action(udev_device, &key[7]);\n\t\t\taction_set = 1;\n\t\t} else if (strncmp(key, \"MAJOR=\", 6) == 0) {\n\t\t\tmaj = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"MINOR=\", 6) == 0) {\n\t\t\tmin = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"DEVPATH_OLD=\", 12) == 0) {\n\t\t\tudev_device_set_devpath_old(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"PHYSDEVPATH=\", 12) == 0) {\n\t\t\tudev_device_set_physdevpath(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"SEQNUM=\", 7) == 0) {\n\t\t\tudev_device_set_seqnum(udev_device, strtoull(&key[7], NULL, 10));\n\t\t} else if (strncmp(key, \"TIMEOUT=\", 8) == 0) {\n\t\t\tudev_device_set_timeout(udev_device, strtoull(&key[8], NULL, 10));\n\t\t} else if (strncmp(key, \"PHYSDEV\", 7) == 0) {\n\t\t\t/* skip deprecated values */\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tudev_device_add_property_from_string(udev_device, key);\n\t\t}\n\t}\n\tif (!devpath_set || !subsystem_set || !action_set) {\n\t\tinfo(udev_monitor->udev, \"missing values, skip\\n\");\n\t\tudev_device_unref(udev_device);\n\t\treturn NULL;\n\t}\n\tif (maj > 0)\n\t\tudev_device_set_devnum(udev_device, makedev(maj, min));\n\tudev_device_set_info_loaded(udev_device);\n\treturn udev_device;\n}",
        "description": "udev versions prior to 1.4.1 do not validate whether a NETLINK message originates from kernel space, enabling local users to escalate privileges by transmitting a NETLINK message from user space.",
        "commit": "To enhance protection, the system should disregard any unicast messages received on the netlink socket and any multicast messages on the kernel group that do not originate from the kernel."
    },
    {
        "cwe": "CWE-129",
        "func_name": "admesh/stl_fix_normal_directions",
        "score": 0.7653366923332214,
        "func_before": "void\nstl_fix_normal_directions(stl_file *stl) {\n  char *norm_sw;\n  /*  int edge_num;*/\n  /*  int vnot;*/\n  int checked = 0;\n  int facet_num;\n  /*  int next_facet;*/\n  int i;\n  int j;\n  struct stl_normal {\n    int               facet_num;\n    struct stl_normal *next;\n  };\n  struct stl_normal *head;\n  struct stl_normal *tail;\n  struct stl_normal *newn;\n  struct stl_normal *temp;\n\n  if (stl->error) return;\n\n  /* Initialize linked list. */\n  head = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n  if(head == NULL) perror(\"stl_fix_normal_directions\");\n  tail = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n  if(tail == NULL) perror(\"stl_fix_normal_directions\");\n  head->next = tail;\n  tail->next = tail;\n\n  /* Initialize list that keeps track of already fixed facets. */\n  norm_sw = (char*)calloc(stl->stats.number_of_facets, sizeof(char));\n  if(norm_sw == NULL) perror(\"stl_fix_normal_directions\");\n\n\n  facet_num = 0;\n  /* If normal vector is not within tolerance and backwards:\n     Arbitrarily starts at face 0.  If this one is wrong, we're screwed.  Thankfully, the chances\n     of it being wrong randomly are low if most of the triangles are right: */\n  if(stl_check_normal_vector(stl, 0, 0) == 2)\n    stl_reverse_facet(stl, 0);\n\n  /* Say that we've fixed this facet: */\n  norm_sw[facet_num] = 1;\n  checked++;\n\n  for(;;) {\n    /* Add neighbors_to_list.\n       Add unconnected neighbors to the list:a  */\n    for(j = 0; j < 3; j++) {\n      /* Reverse the neighboring facets if necessary. */\n      if(stl->neighbors_start[facet_num].which_vertex_not[j] > 2) {\n        /* If the facet has a neighbor that is -1, it means that edge isn't shared by another facet */\n        if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n          stl_reverse_facet\n          (stl, stl->neighbors_start[facet_num].neighbor[j]);\n        }\n      }\n      /* If this edge of the facet is connected: */\n      if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n        /* If we haven't fixed this facet yet, add it to the list: */\n        if(norm_sw[stl->neighbors_start[facet_num].neighbor[j]] != 1) {\n          /* Add node to beginning of list. */\n          newn = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n          if(newn == NULL) perror(\"stl_fix_normal_directions\");\n          newn->facet_num = stl->neighbors_start[facet_num].neighbor[j];\n          newn->next = head->next;\n          head->next = newn;\n        }\n      }\n    }\n    /* Get next facet to fix from top of list. */\n    if(head->next != tail) {\n      facet_num = head->next->facet_num;\n      if(norm_sw[facet_num] != 1) { /* If facet is in list mutiple times */\n        norm_sw[facet_num] = 1; /* Record this one as being fixed. */\n        checked++;\n      }\n      temp = head->next;\t/* Delete this facet from the list. */\n      head->next = head->next->next;\n      free(temp);\n    } else { /* if we ran out of facets to fix: */\n      /* All of the facets in this part have been fixed. */\n      stl->stats.number_of_parts += 1;\n      if(checked >= stl->stats.number_of_facets) {\n        /* All of the facets have been checked.  Bail out. */\n        break;\n      } else {\n        /* There is another part here.  Find it and continue. */\n        for(i = 0; i < stl->stats.number_of_facets; i++) {\n          if(norm_sw[i] == 0) {\n            /* This is the first facet of the next part. */\n            facet_num = i;\n            if(stl_check_normal_vector(stl, i, 0) == 2) {\n              stl_reverse_facet(stl, i);\n            }\n\n            norm_sw[facet_num] = 1;\n            checked++;\n            break;\n          }\n        }\n      }\n    }\n  }\n  free(head);\n  free(tail);\n  free(norm_sw);\n}",
        "func_after": "void\nstl_fix_normal_directions(stl_file *stl) {\n  char *norm_sw;\n  /*  int edge_num;*/\n  /*  int vnot;*/\n  int checked = 0;\n  int facet_num;\n  /*  int next_facet;*/\n  int i;\n  int j;\n  struct stl_normal {\n    int               facet_num;\n    struct stl_normal *next;\n  };\n  struct stl_normal *head;\n  struct stl_normal *tail;\n  struct stl_normal *newn;\n  struct stl_normal *temp;\n\n  if (stl->error) return;\n\n  /* Initialize linked list. */\n  head = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n  if(head == NULL) perror(\"stl_fix_normal_directions\");\n  tail = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n  if(tail == NULL) perror(\"stl_fix_normal_directions\");\n  head->next = tail;\n  tail->next = tail;\n\n  /* Initialize list that keeps track of already fixed facets. */\n  norm_sw = (char*)calloc(stl->stats.number_of_facets, sizeof(char));\n  if(norm_sw == NULL) perror(\"stl_fix_normal_directions\");\n\n\n  facet_num = 0;\n  /* If normal vector is not within tolerance and backwards:\n     Arbitrarily starts at face 0.  If this one is wrong, we're screwed.  Thankfully, the chances\n     of it being wrong randomly are low if most of the triangles are right: */\n  if(stl_check_normal_vector(stl, 0, 0) == 2)\n    stl_reverse_facet(stl, 0);\n\n  /* Say that we've fixed this facet: */\n  norm_sw[facet_num] = 1;\n  checked++;\n\n  for(;;) {\n    /* Add neighbors_to_list.\n       Add unconnected neighbors to the list:a  */\n    for(j = 0; j < 3; j++) {\n      /* Reverse the neighboring facets if necessary. */\n      if(stl->neighbors_start[facet_num].which_vertex_not[j] > 2) {\n        /* If the facet has a neighbor that is -1, it means that edge isn't shared by another facet */\n        if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n          stl_reverse_facet\n          (stl, stl->neighbors_start[facet_num].neighbor[j]);\n        }\n      }\n      /* If this edge of the facet is connected: */\n      if(stl->neighbors_start[facet_num].neighbor[j] != -1 &&\n         stl->neighbors_start[facet_num].neighbor[j] < stl->stats.number_of_facets*sizeof(char)) {\n        /* If we haven't fixed this facet yet, add it to the list: */\n        if(norm_sw[stl->neighbors_start[facet_num].neighbor[j]] != 1) {\n          /* Add node to beginning of list. */\n          newn = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n          if(newn == NULL) perror(\"stl_fix_normal_directions\");\n          newn->facet_num = stl->neighbors_start[facet_num].neighbor[j];\n          newn->next = head->next;\n          head->next = newn;\n        }\n      }\n    }\n    /* Get next facet to fix from top of list. */\n    if(head->next != tail) {\n      facet_num = head->next->facet_num;\n      if(norm_sw[facet_num] != 1) { /* If facet is in list mutiple times */\n        norm_sw[facet_num] = 1; /* Record this one as being fixed. */\n        checked++;\n      }\n      temp = head->next;\t/* Delete this facet from the list. */\n      head->next = head->next->next;\n      free(temp);\n    } else { /* if we ran out of facets to fix: */\n      /* All of the facets in this part have been fixed. */\n      stl->stats.number_of_parts += 1;\n      if(checked >= stl->stats.number_of_facets) {\n        /* All of the facets have been checked.  Bail out. */\n        break;\n      } else {\n        /* There is another part here.  Find it and continue. */\n        for(i = 0; i < stl->stats.number_of_facets; i++) {\n          if(norm_sw[i] == 0) {\n            /* This is the first facet of the next part. */\n            facet_num = i;\n            if(stl_check_normal_vector(stl, i, 0) == 2) {\n              stl_reverse_facet(stl, i);\n            }\n\n            norm_sw[facet_num] = 1;\n            checked++;\n            break;\n          }\n        }\n      }\n    }\n  }\n  free(head);\n  free(tail);\n  free(norm_sw);\n}",
        "description": "An improper array index validation vulnerability exists in the stl_fix_normal_directions functionality of ADMesh. A specially-crafted STL file can lead to a heap buffer overflow. An attacker can exploit this by providing a malicious file.",
        "commit": "The vulnerability involves a check for the `neighbor_index` within the `stl_check_normal_vector` function. This fix addresses an issue identified in ticket #60."
    }
]