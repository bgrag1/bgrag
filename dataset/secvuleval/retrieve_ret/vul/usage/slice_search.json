[
    {
        "cwe": "CWE-22",
        "func_name": "asterisk/action_getconfig",
        "score": 0.7494950890541077,
        "func_before": "static int action_getconfig(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tconst char *category = astman_get_header(m, \"Category\");\n\tconst char *filter = astman_get_header(m, \"Filter\");\n\tconst char *category_name;\n\tint catcount = 0;\n\tint lineno = 0;\n\tstruct ast_category *cur_category = NULL;\n\tstruct ast_variable *v;\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\n\tif (ast_strlen_zero(fn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\n\tif (restrictedFile(fn)) {\n\t\tastman_send_error(s, m, \"File requires escalated priveledges\");\n\t\treturn 0;\n\t}\n\n\tcfg = ast_config_load2(fn, \"manager\", config_flags);\n\tif (cfg == CONFIG_STATUS_FILEMISSING) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\n\tastman_start_ack(s, m);\n\twhile ((cur_category = ast_category_browse_filtered(cfg, category, cur_category, filter))) {\n\t\tstruct ast_str *templates;\n\n\t\tcategory_name = ast_category_get_name(cur_category);\n\t\tlineno = 0;\n\t\tastman_append(s, \"Category-%06d: %s\\r\\n\", catcount, category_name);\n\n\t\tif (ast_category_is_template(cur_category)) {\n\t\t\tastman_append(s, \"IsTemplate-%06d: %d\\r\\n\", catcount, 1);\n\t\t}\n\n\t\tif ((templates = ast_category_get_templates(cur_category))\n\t\t\t&& ast_str_strlen(templates) > 0) {\n\t\t\tastman_append(s, \"Templates-%06d: %s\\r\\n\", catcount, ast_str_buffer(templates));\n\t\t\tast_free(templates);\n\t\t}\n\n\t\tfor (v = ast_category_first(cur_category); v; v = v->next) {\n\t\t\tastman_append(s, \"Line-%06d-%06d: %s=%s\\r\\n\", catcount, lineno++, v->name, v->value);\n\t\t}\n\n\t\tcatcount++;\n\t}\n\n\tif (!ast_strlen_zero(category) && catcount == 0) { /* TODO: actually, a config with no categories doesn't even get loaded */\n\t\tastman_append(s, \"No categories found\\r\\n\");\n\t}\n\n\tast_config_destroy(cfg);\n\tastman_append(s, \"\\r\\n\");\n\n\treturn 0;\n}",
        "func_after": "static int action_getconfig(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tconst char *category = astman_get_header(m, \"Category\");\n\tconst char *filter = astman_get_header(m, \"Filter\");\n\tconst char *category_name;\n\tint catcount = 0;\n\tint lineno = 0;\n\tint ret = 0;\n\tstruct ast_category *cur_category = NULL;\n\tstruct ast_variable *v;\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\n\tif (ast_strlen_zero(fn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\n\tret = restrictedFile(fn);\n\tif (ret == 1) {\n\t\tastman_send_error(s, m, \"File requires escalated priveledges\");\n\t\treturn 0;\n\t} else if (ret == -1) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t}\n\n\tcfg = ast_config_load2(fn, \"manager\", config_flags);\n\tif (cfg == CONFIG_STATUS_FILEMISSING) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\n\tastman_start_ack(s, m);\n\twhile ((cur_category = ast_category_browse_filtered(cfg, category, cur_category, filter))) {\n\t\tstruct ast_str *templates;\n\n\t\tcategory_name = ast_category_get_name(cur_category);\n\t\tlineno = 0;\n\t\tastman_append(s, \"Category-%06d: %s\\r\\n\", catcount, category_name);\n\n\t\tif (ast_category_is_template(cur_category)) {\n\t\t\tastman_append(s, \"IsTemplate-%06d: %d\\r\\n\", catcount, 1);\n\t\t}\n\n\t\tif ((templates = ast_category_get_templates(cur_category))\n\t\t\t&& ast_str_strlen(templates) > 0) {\n\t\t\tastman_append(s, \"Templates-%06d: %s\\r\\n\", catcount, ast_str_buffer(templates));\n\t\t\tast_free(templates);\n\t\t}\n\n\t\tfor (v = ast_category_first(cur_category); v; v = v->next) {\n\t\t\tastman_append(s, \"Line-%06d-%06d: %s=%s\\r\\n\", catcount, lineno++, v->name, v->value);\n\t\t}\n\n\t\tcatcount++;\n\t}\n\n\tif (!ast_strlen_zero(category) && catcount == 0) { /* TODO: actually, a config with no categories doesn't even get loaded */\n\t\tastman_append(s, \"No categories found\\r\\n\");\n\t}\n\n\tast_config_destroy(cfg);\n\tastman_append(s, \"\\r\\n\");\n\n\treturn 0;\n}",
        "description": "Asterisk, an open-source private branch exchange and telephony toolkit, is vulnerable to an arbitrary file reading issue in versions prior to 18.20.1, 20.5.1, and 21.0.1, as well as certified-asterisk prior to 18.9-cert6. This vulnerability allows unauthorized access to read any arbitrary file, regardless of whether the `live_dangerously` option is enabled. Versions 18.20.1, 20.5.1, and 21.0.1, as well as certified-asterisk prior to 18.9-cert6, have implemented a fix for this issue.",
        "commit": "It was discovered that the GetConfig function in the manager module allowed unauthorized access to files outside of the Asterisk configuration directory by manipulating filenames with \".\" and \"./\", even when the live_dangerously feature was not enabled. This vulnerability has been addressed by implementing a measure to resolve the full path and verify that the file remains within the configuration directory before attempting to access it."
    },
    {
        "cwe": "CWE-78",
        "func_name": "shadowsocks/construct_command_line",
        "score": 0.7534323334693909,
        "func_before": "static char *\nconstruct_command_line(struct manager_ctx *manager, struct server *server)\n{\n    static char cmd[BUF_SIZE];\n    char *method = manager->method;\n    int i;\n\n    build_config(working_dir, server);\n\n    if (server->method) method = server->method;\n    memset(cmd, 0, BUF_SIZE);\n    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n\n    if (manager->acl != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n    }\n    if (manager->timeout != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n    }\n#ifdef HAVE_SETRLIMIT\n    if (manager->nofile) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n    }\n#endif\n    if (manager->user != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n    }\n    if (manager->verbose) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n    }\n    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n    }\n    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n    }\n    if (server->fast_open[0] == 0 && manager->fast_open) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n    }\n    if (manager->ipv6first) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n    }\n    if (manager->mtu) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n    }\n    if (server->plugin == NULL && manager->plugin) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n    }\n    if (server->plugin_opts == NULL && manager->plugin_opts) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n    }\n    for (i = 0; i < manager->nameserver_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n    }\n    for (i = 0; i < manager->host_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n    }\n    // Always enable reuse port\n    {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n    }\n\n    if (verbose) {\n        LOGI(\"cmd: %s\", cmd);\n    }\n\n    return cmd;\n}",
        "func_after": "static char *\nconstruct_command_line(struct manager_ctx *manager, struct server *server)\n{\n    static char cmd[BUF_SIZE];\n    int i;\n    int port;\n\n    port = atoi(server->port);\n\n    build_config(working_dir, manager, server);\n\n    memset(cmd, 0, BUF_SIZE);\n    snprintf(cmd, BUF_SIZE,\n             \"%s --manager-address %s -f %s/.shadowsocks_%d.pid -c %s/.shadowsocks_%d.conf\",\n             executable, manager->manager_address, working_dir, port, working_dir, port);\n\n    if (manager->acl != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n    }\n    if (manager->timeout != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n    }\n#ifdef HAVE_SETRLIMIT\n    if (manager->nofile) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n    }\n#endif\n    if (manager->user != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n    }\n    if (manager->verbose) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n    }\n    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n    }\n    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n    }\n    if (server->fast_open[0] == 0 && manager->fast_open) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n    }\n    if (manager->ipv6first) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n    }\n    if (manager->mtu) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n    }\n    if (server->plugin == NULL && manager->plugin) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n    }\n    if (server->plugin_opts == NULL && manager->plugin_opts) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n    }\n    for (i = 0; i < manager->nameserver_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n    }\n    for (i = 0; i < manager->host_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n    }\n    // Always enable reuse port\n    {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n    }\n\n    if (verbose) {\n        LOGI(\"cmd: %s\", cmd);\n    }\n\n    return cmd;\n}",
        "description": "In the `ss-manager` component of the Shadowsocks-libev library version 3.1.0, there exists a vulnerability due to improper parsing of JSON configuration requests received via UDP traffic on `127.0.0.1`. This issue facilitates command injection through the use of shell metacharacters. The vulnerability is associated with functions such as `add_server`, `build_config`, and `construct_command_line`.",
        "commit": "<Abstracted Description begin>\nA fix has been implemented to address an unspecified issue identified by ticket number 1734.\n<Abstracted Description end>"
    },
    {
        "cwe": "CWE-77",
        "func_name": "ImageMagick/ReadVIDEOImage",
        "score": 0.7442007660865784,
        "func_before": "static Image *ReadVIDEOImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const DelegateInfo\n    *delegate_info;\n\n  Image\n    *image,\n    *images,\n    *next;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CloseBlob(image);\n  (void) DestroyImageList(image);\n  /*\n    Convert VIDEO to PAM with delegate.\n  */\n  images=(Image *) NULL;\n  read_info=CloneImageInfo(image_info);\n  delegate_info=GetDelegateInfo(\"video:decode\",(char *) NULL,exception);\n  if (delegate_info != (const DelegateInfo *) NULL)\n    {\n      char\n        command[MagickPathExtent],\n        message[MagickPathExtent];\n\n      char\n        *options,\n        *sanitized_option;\n\n      const char\n        *intermediate_format,\n        *option;\n\n      int\n        exit_code;\n\n      options=AcquireString(\"\");\n      if (image_info->number_scenes > 0)\n        (void) FormatLocaleString(options,MagickPathExtent,\"-vframes %i\",\n          (int) image_info->number_scenes);\n      option=GetImageOption(image_info,\"video:vsync\");\n      if (option != (const char *) NULL)\n        {\n          sanitized_option=SanitizeDelegateString(option);\n          (void) FormatLocaleString(command,MagickPathExtent,\" -vsync %s\",\n            sanitized_option);\n          DestroyString(sanitized_option);\n          (void) ConcatenateMagickString(options,command,MagickPathExtent);\n        }\n      option=GetImageOption(image_info,\"video:pixel-format\");\n      if (option != (const char *) NULL)\n        {\n          sanitized_option=SanitizeDelegateString(option);\n          (void) FormatLocaleString(command,MagickPathExtent,\" -pix_fmt %s\",\n            sanitized_option);\n          DestroyString(sanitized_option);\n          (void) ConcatenateMagickString(options,command,MagickPathExtent);\n        }\n      else\n        if (LocaleNCompare(image_info->magick,\"APNG\",MagickPathExtent) == 0)\n          (void) ConcatenateMagickString(options,\" -pix_fmt rgba\",\n            MagickPathExtent);\n      intermediate_format=GetIntermediateFormat(image_info);\n      (void) FormatLocaleString(command,MagickPathExtent,\" -vcodec %s\",\n        intermediate_format);\n      (void) ConcatenateMagickString(options,command,MagickPathExtent);\n      AcquireUniqueFilename(read_info->unique);\n      (void) AcquireUniqueSymbolicLink(image_info->filename,\n        read_info->filename);\n      (void) FormatLocaleString(command,MagickPathExtent,\n        GetDelegateCommands(delegate_info),read_info->filename,options,\n        read_info->unique);\n      options=DestroyString(options);\n      (void) CopyMagickString(read_info->magick,intermediate_format,\n        MagickPathExtent);\n      (void) CopyMagickString(read_info->filename,read_info->unique,\n        MagickPathExtent);\n      exit_code=ExternalDelegateCommand(MagickFalse,image_info->verbose,\n        command,message,exception);\n      if (exit_code == 0)\n        images=ReadImage(read_info,exception);\n      else\n        if (*message != '\\0')\n          (void) ThrowMagickException(exception,GetMagickModule(),DelegateError,\n            \"VideoDelegateFailed\",\"`%s'\",message);\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      (void) RelinquishUniqueFileResource(read_info->unique);\n      if (images != (Image *) NULL)\n        for (next=images; next != (Image *) NULL; next=next->next)\n        {\n          (void) CopyMagickString(next->filename,image_info->filename,\n            MagickPathExtent);\n          (void) CopyMagickString(next->magick,image_info->magick,\n            MagickPathExtent);\n        }\n    }\n  read_info=DestroyImageInfo(read_info);\n  return(images);\n}",
        "func_after": "static Image *ReadVIDEOImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const DelegateInfo\n    *delegate_info;\n\n  Image\n    *image,\n    *images,\n    *next;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CloseBlob(image);\n  (void) DestroyImageList(image);\n  /*\n    Convert VIDEO to PAM with delegate.\n  */\n  images=(Image *) NULL;\n  read_info=CloneImageInfo(image_info);\n  delegate_info=GetDelegateInfo(\"video:decode\",(char *) NULL,exception);\n  if (delegate_info != (const DelegateInfo *) NULL)\n    {\n      char\n        command[MagickPathExtent],\n        message[MagickPathExtent];\n\n      char\n        *options;\n\n      const char\n        *intermediate_format,\n        *option;\n\n      int\n        exit_code;\n\n      options=AcquireString(\"\");\n      if (image_info->number_scenes > 0)\n        (void) FormatLocaleString(options,MagickPathExtent,\"-vframes %i\",\n          (int) image_info->number_scenes);\n      option=GetImageOption(image_info,\"video:vsync\");\n      if (option != (const char *) NULL)\n        {\n          FormatSanitizedDelegateOption(command,MagickPathExtent,\n            \" -vsync \\\"%s\\\"\",\" -vsync '%s'\",option);\n          (void) ConcatenateMagickString(options,command,MagickPathExtent);\n        }\n      option=GetImageOption(image_info,\"video:pixel-format\");\n      if (option != (const char *) NULL)\n        {\n          FormatSanitizedDelegateOption(command,MagickPathExtent,\n            \" -pix_fmt \\\"%s\\\"\",\" -pix_fmt '%s'\",option);\n          (void) ConcatenateMagickString(options,command,MagickPathExtent);\n        }\n      else\n        if (LocaleNCompare(image_info->magick,\"APNG\",MagickPathExtent) == 0)\n          (void) ConcatenateMagickString(options,\" -pix_fmt rgba\",\n            MagickPathExtent);\n      intermediate_format=GetIntermediateFormat(image_info);\n      (void) FormatLocaleString(command,MagickPathExtent,\" -vcodec %s\",\n        intermediate_format);\n      (void) ConcatenateMagickString(options,command,MagickPathExtent);\n      AcquireUniqueFilename(read_info->unique);\n      (void) AcquireUniqueSymbolicLink(image_info->filename,\n        read_info->filename);\n      (void) FormatLocaleString(command,MagickPathExtent,\n        GetDelegateCommands(delegate_info),read_info->filename,options,\n        read_info->unique);\n      options=DestroyString(options);\n      (void) CopyMagickString(read_info->magick,intermediate_format,\n        MagickPathExtent);\n      (void) CopyMagickString(read_info->filename,read_info->unique,\n        MagickPathExtent);\n      exit_code=ExternalDelegateCommand(MagickFalse,image_info->verbose,\n        command,message,exception);\n      if (exit_code == 0)\n        images=ReadImage(read_info,exception);\n      else\n        if (*message != '\\0')\n          (void) ThrowMagickException(exception,GetMagickModule(),DelegateError,\n            \"VideoDelegateFailed\",\"`%s'\",message);\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      (void) RelinquishUniqueFileResource(read_info->unique);\n      if (images != (Image *) NULL)\n        for (next=images; next != (Image *) NULL; next=next->next)\n        {\n          (void) CopyMagickString(next->filename,image_info->filename,\n            MagickPathExtent);\n          (void) CopyMagickString(next->magick,image_info->magick,\n            MagickPathExtent);\n        }\n    }\n  read_info=DestroyImageInfo(read_info);\n  return(images);\n}",
        "description": "A vulnerability was identified in ImageMagick that leads to a shell command injection through the use of specific options in video encoding/decoding processes.",
        "commit": "Ensure that options are correctly quoted to address the issue identified in ticket #6338."
    },
    {
        "cwe": "CWE-79",
        "func_name": "GNOME/history_service_query_urls_cb",
        "score": 0.7472819089889526,
        "func_before": "static void\nhistory_service_query_urls_cb (EphyHistoryService     *history,\n                               gboolean                success,\n                               GList                  *urls,\n                               WebKitURISchemeRequest *request)\n{\n  EphySnapshotService *snapshot_service;\n  EphyEmbedShell *shell;\n  GString *data_str;\n  gsize data_length;\n  char *lang;\n  GList *l;\n  guint list_length;\n\n  snapshot_service = ephy_snapshot_service_get_default ();\n  shell = ephy_embed_shell_get_default ();\n\n  data_str = g_string_new (NULL);\n\n  lang = g_strdup (pango_language_to_string (gtk_get_default_language ()));\n  g_strdelimit (lang, \"_-@\", '\\0');\n\n  g_string_append_printf (data_str,\n                          \"<html xml:lang=\\\"%s\\\" lang=\\\"%s\\\" dir=\\\"%s\\\">\\n\"\n                          \"<head>\\n\"\n                          \"  <title>%s</title>\\n\"\n                          \"  <meta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=utf-8\\\" />\\n\"\n                          \"  <meta name=\\\"viewport\\\" content=\\\"width=device-width\\\">\"\n                          \"  <link href=\\\"\"EPHY_PAGE_TEMPLATE_ABOUT_CSS \"\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\">\\n\"\n                          \"  <script> </script>\\n\"\n                          \"</head>\\n\"\n                          \"<body>\\n\",\n                          lang, lang,\n                          ((gtk_widget_get_default_direction () == GTK_TEXT_DIR_RTL) ? \"rtl\" : \"ltr\"),\n                          _(NEW_TAB_PAGE_TITLE));\n  g_free (lang);\n\n  list_length = g_list_length (urls);\n\n  if (list_length == 0 || !success) {\n    GtkIconInfo *icon_info;\n    g_autofree gchar *icon = g_strconcat (APPLICATION_ID, \"-symbolic\", NULL);\n\n    icon_info = gtk_icon_theme_lookup_icon (gtk_icon_theme_get_default (),\n                                            icon,\n                                            128,\n                                            0);\n    g_string_append_printf (data_str,\n                            \"  <div id=\\\"overview\\\" class=\\\"overview-empty\\\">\\n\"\n                            \"    <img src=\\\"file://%s\\\"/>\\n\"\n                            \"    <div><h1>%s</h1></div>\\n\"\n                            \"    <div><p>%s</p></div>\\n\"\n                            \"  </div>\\n\"\n                            \"</body></html>\\n\",\n                            icon_info ? gtk_icon_info_get_filename (icon_info) : \"\",\n                            /* Displayed when opening the browser for the first time. */\n                            _(\"Welcome to Web\"), _(\"Start browsing and your most-visited sites will appear here.\"));\n    if (icon_info)\n      g_object_unref (icon_info);\n    goto out;\n  }\n\n  g_string_append (data_str,\n                   \"<div id=\\\"overview\\\">\\n\");\n\n  g_string_append (data_str,\n                   \"<div id=\\\"most-visited-grid\\\">\\n\");\n\n  for (l = urls; l; l = g_list_next (l)) {\n    EphyHistoryURL *url = (EphyHistoryURL *)l->data;\n    const char *snapshot;\n    g_autofree char *thumbnail_style = NULL;\n    g_autofree char *markup = NULL;\n\n    snapshot = ephy_snapshot_service_lookup_cached_snapshot_path (snapshot_service, url->url);\n    if (snapshot)\n      thumbnail_style = g_strdup_printf (\" style=\\\"background: url(file://%s) no-repeat; background-size: 100%%;\\\"\", snapshot);\n    else\n      ephy_embed_shell_schedule_thumbnail_update (shell, url);\n\n    markup = g_markup_escape_text (url->title, -1);\n    g_string_append_printf (data_str,\n                            \"<a class=\\\"overview-item\\\" title=\\\"%s\\\" href=\\\"%s\\\">\"\n                            \"  <div class=\\\"overview-close-button\\\" title=\\\"%s\\\"></div>\"\n                            \"  <span class=\\\"overview-thumbnail\\\"%s></span>\"\n                            \"  <span class=\\\"overview-title\\\">%s</span>\"\n                            \"</a>\",\n                            markup, url->url, _(\"Remove from overview\"),\n                            thumbnail_style ? thumbnail_style : \"\", url->title);\n  }\n\n  data_str = g_string_append (data_str,\n                              \"  </div>\\n\"\n                              \"  </div>\\n\"\n                              \"</body></html>\\n\");\n\nout:\n  data_length = data_str->len;\n  ephy_about_handler_finish_request (request, g_string_free (data_str, FALSE), data_length);\n  g_object_unref (request);\n}",
        "func_after": "static void\nhistory_service_query_urls_cb (EphyHistoryService     *history,\n                               gboolean                success,\n                               GList                  *urls,\n                               WebKitURISchemeRequest *request)\n{\n  EphySnapshotService *snapshot_service;\n  EphyEmbedShell *shell;\n  GString *data_str;\n  gsize data_length;\n  char *lang;\n  GList *l;\n  guint list_length;\n\n  snapshot_service = ephy_snapshot_service_get_default ();\n  shell = ephy_embed_shell_get_default ();\n\n  data_str = g_string_new (NULL);\n\n  lang = g_strdup (pango_language_to_string (gtk_get_default_language ()));\n  g_strdelimit (lang, \"_-@\", '\\0');\n\n  g_string_append_printf (data_str,\n                          \"<html xml:lang=\\\"%s\\\" lang=\\\"%s\\\" dir=\\\"%s\\\">\\n\"\n                          \"<head>\\n\"\n                          \"  <title>%s</title>\\n\"\n                          \"  <meta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=utf-8\\\" />\\n\"\n                          \"  <meta name=\\\"viewport\\\" content=\\\"width=device-width\\\">\"\n                          \"  <link href=\\\"\"EPHY_PAGE_TEMPLATE_ABOUT_CSS \"\\\" rel=\\\"stylesheet\\\" type=\\\"text/css\\\">\\n\"\n                          \"  <script> </script>\\n\"\n                          \"</head>\\n\"\n                          \"<body>\\n\",\n                          lang, lang,\n                          ((gtk_widget_get_default_direction () == GTK_TEXT_DIR_RTL) ? \"rtl\" : \"ltr\"),\n                          _(NEW_TAB_PAGE_TITLE));\n  g_free (lang);\n\n  list_length = g_list_length (urls);\n\n  if (list_length == 0 || !success) {\n    GtkIconInfo *icon_info;\n    g_autofree gchar *icon = g_strconcat (APPLICATION_ID, \"-symbolic\", NULL);\n\n    icon_info = gtk_icon_theme_lookup_icon (gtk_icon_theme_get_default (),\n                                            icon,\n                                            128,\n                                            0);\n    g_string_append_printf (data_str,\n                            \"  <div id=\\\"overview\\\" class=\\\"overview-empty\\\">\\n\"\n                            \"    <img src=\\\"file://%s\\\"/>\\n\"\n                            \"    <div><h1>%s</h1></div>\\n\"\n                            \"    <div><p>%s</p></div>\\n\"\n                            \"  </div>\\n\"\n                            \"</body></html>\\n\",\n                            icon_info ? gtk_icon_info_get_filename (icon_info) : \"\",\n                            /* Displayed when opening the browser for the first time. */\n                            _(\"Welcome to Web\"), _(\"Start browsing and your most-visited sites will appear here.\"));\n    if (icon_info)\n      g_object_unref (icon_info);\n    goto out;\n  }\n\n  g_string_append (data_str,\n                   \"<div id=\\\"overview\\\">\\n\");\n\n  g_string_append (data_str,\n                   \"<div id=\\\"most-visited-grid\\\">\\n\");\n\n  for (l = urls; l; l = g_list_next (l)) {\n    EphyHistoryURL *url = (EphyHistoryURL *)l->data;\n    const char *snapshot;\n    g_autofree char *thumbnail_style = NULL;\n    g_autofree char *encoded_title = NULL;\n    g_autofree char *encoded_url = NULL;\n\n    snapshot = ephy_snapshot_service_lookup_cached_snapshot_path (snapshot_service, url->url);\n    if (snapshot)\n      thumbnail_style = g_strdup_printf (\" style=\\\"background: url(file://%s) no-repeat; background-size: 100%%;\\\"\", snapshot);\n    else\n      ephy_embed_shell_schedule_thumbnail_update (shell, url);\n\n    /* Title and URL are controlled by web content and could be malicious. */\n    encoded_title = ephy_encode_for_html_attribute (url->title);\n    encoded_url = ephy_encode_for_html_attribute (url->url);\n    g_string_append_printf (data_str,\n                            \"<a class=\\\"overview-item\\\" title=\\\"%s\\\" href=\\\"%s\\\">\"\n                            \"  <div class=\\\"overview-close-button\\\" title=\\\"%s\\\"></div>\"\n                            \"  <span class=\\\"overview-thumbnail\\\"%s></span>\"\n                            \"  <span class=\\\"overview-title\\\">%s</span>\"\n                            \"</a>\",\n                            encoded_title, encoded_url, _(\"Remove from overview\"),\n                            thumbnail_style ? thumbnail_style : \"\", encoded_title);\n  }\n\n  data_str = g_string_append (data_str,\n                              \"  </div>\\n\"\n                              \"  </div>\\n\"\n                              \"</body></html>\\n\");\n\nout:\n  data_length = data_str->len;\n  ephy_about_handler_finish_request (request, g_string_free (data_str, FALSE), data_length);\n  g_object_unref (request);\n}",
        "description": "Cross-site scripting (XSS) vulnerabilities can exist in GNOME Web (also known as Epiphany) versions prior to 40.4 and 41.1. These vulnerabilities arise when a user frequently visits a webpage containing an XSS payload, causing that page to be added to the Most Visited list through an about: page, such as ephy-about:overview.",
        "commit": "It was discovered that the about:overview handler does not properly encode page titles and URLs, potentially allowing web pages to execute arbitrary code through a malicious page title. To mitigate this risk, encoding should also be applied to URLs."
    },
    {
        "cwe": "CWE-74",
        "func_name": "radareorg/parse_attr_value",
        "score": 0.745317816734314,
        "func_before": "static const ut8 *parse_attr_value(const ut8 *obuf, int obuf_len,\n\t\tRBinDwarfAttrDef *def, RBinDwarfAttrValue *value,\n\t\tconst RBinDwarfCompUnitHdr *hdr,\n\t\tconst ut8 *debug_str, size_t debug_str_len) {\n\tr_return_val_if_fail (def && value && hdr && obuf, NULL);\n\n\tvalue->attr_form = def->attr_form;\n\tvalue->attr_name = def->attr_name;\n\tvalue->block.data = NULL;\n\tvalue->string.content = NULL;\n\tvalue->string.offset = 0;\n\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + obuf_len;\n\tsize_t j;\n\n\tif (obuf_len < 1) {\n\t\treturn NULL;\n\t}\n\n\t// http://www.dwarfstd.org/doc/DWARF4.pdf#page=161&zoom=100,0,560\n\tswitch (def->attr_form) {\n\tcase DW_FORM_addr:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tswitch (hdr->address_size) {\n\t\tcase 1:\n\t\t\tvalue->address = READ8 (buf);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvalue->address = READ16 (buf);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvalue->address = READ32 (buf);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalue->address = READ64 (buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tR_LOG_WARN (\"DWARF: Unexpected pointer size: %u\", (unsigned)hdr->address_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_data1:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_data2:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_data4:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_data8:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_data16: // TODO Fix this, right now I just read the data, but I need to make storage for it\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64 (buf);\n\t\tvalue->uconstant = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = r_leb128 (buf, buf_end - buf, &value->sconstant);\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->uconstant, NULL);\n\t\tbreak;\n\tcase DW_FORM_string:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.content = *buf ? r_str_ndup ((const char *)buf, buf_end - buf) : NULL;\n\t\tif (value->string.content) {\n\t\t\tbuf += strlen (value->string.content) + 1;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block1:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ8 (buf);\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block2:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ16 (buf);\n\t\tif (value->block.length > 0) {\n\t\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length);\n\t\t\tif (!value->block.data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block4:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ32 (buf);\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block: // variable length ULEB128\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = READ (buf, ut8);\n\t\tbreak;\n\t// offset in .debug_str\n\tcase DW_FORM_strp:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tif (debug_str && value->string.offset < debug_str_len) {\n\t\t\tconst char *ds = (const char *)(debug_str + value->string.offset);\n\t\t\tvalue->string.content = strdup (ds); // r_str_ndup (ds, debug_str_len - value->string.offset);\n\t\t} else {\n\t\t\tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t}\n\t\tbreak;\n\t// offset in .debug_info\n\tcase DW_FORM_ref_addr:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t// This type of reference is an offset from the first byte of the compilation\n\t// header for the compilation unit containing the reference\n\tcase DW_FORM_ref1:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref2:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_udata:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\t// uleb128 is enough to fit into ut64?\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->reference, NULL);\n\t\tvalue->reference += hdr->unit_offset;\n\t\tbreak;\n\t// offset in a section other than .debug_info or .debug_str\n\tcase DW_FORM_sec_offset:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset(hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\tcase DW_FORM_exprloc:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\t// this means that the flag is present, nothing is read\n\tcase DW_FORM_flag_present:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = true;\n\t\tbreak;\n\tcase DW_FORM_ref_sig8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// offset into .debug_line_str section, can't parse the section now, so we just skip\n\tcase DW_FORM_strx:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\t// value->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdup ((const char *)(debug_str + value->string.offset));\n\t\t// } else {\n\t\t// \tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t// }\n\t\tbreak;\n\tcase DW_FORM_strx1:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx2:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx3: // TODO Add 3 byte int read\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_strx4:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_implicit_const:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = def->special;\n\t\tbreak;\n\t/*  addrx* forms : The index is relative to the value of the\n\t\tDW_AT_addr_base attribute of the associated compilation unit.\n\t    index into an array of addresses in the .debug_addr section.*/\n\tcase DW_FORM_addrx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tcase DW_FORM_addrx1:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx2:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx3:\n\t\t// I need to add 3byte endianess free read here TODO\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_addrx4:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_line_ptr: // offset in a section .debug_line_str\n\tcase DW_FORM_strp_sup: // offset in a section .debug_line_str\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdupsts\n\t\tbreak;\n\t// offset in the supplementary object file\n\tcase DW_FORM_ref_sup4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_sup8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// An index into the .debug_loc\n\tcase DW_FORM_loclistx:\n\t\tvalue->kind = DW_AT_KIND_LOCLISTPTR;\n\t\tvalue->reference = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t // An index into the .debug_rnglists\n\tcase DW_FORM_rnglistx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tcase 0:\n\t\tvalue->uconstant = 0;\n\t\treturn NULL;\n\tdefault:\n\t\tR_LOG_WARN (\"Unknown DW_FORM 0x%02\" PFMT64x, def->attr_form);\n\t\tvalue->uconstant = 0;\n\t\treturn NULL;\n\t}\n\treturn buf;\n}",
        "func_after": "static const ut8 *parse_attr_value(const ut8 *obuf, int obuf_len,\n\t\tRBinDwarfAttrDef *def, RBinDwarfAttrValue *value,\n\t\tconst RBinDwarfCompUnitHdr *hdr,\n\t\tconst ut8 *debug_str, size_t debug_str_len) {\n\tr_return_val_if_fail (def && value && hdr && obuf, NULL);\n\n\tvalue->attr_form = def->attr_form;\n\tvalue->attr_name = def->attr_name;\n\tvalue->block.data = NULL;\n\tvalue->string.content = NULL;\n\tvalue->string.offset = 0;\n\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + obuf_len;\n\tsize_t j;\n\n\tif (obuf_len < 1) {\n\t\treturn NULL;\n\t}\n\n\t// http://www.dwarfstd.org/doc/DWARF4.pdf#page=161&zoom=100,0,560\n\tswitch (def->attr_form) {\n\tcase DW_FORM_addr:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tswitch (hdr->address_size) {\n\t\tcase 1:\n\t\t\tvalue->address = READ8 (buf);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvalue->address = READ16 (buf);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvalue->address = READ32 (buf);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalue->address = READ64 (buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tR_LOG_WARN (\"DWARF: Unexpected pointer size: %u\", (unsigned)hdr->address_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_data1:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_data2:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_data4:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_data8:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_data16: // TODO Fix this, right now I just read the data, but I need to make storage for it\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64 (buf);\n\t\tvalue->uconstant = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = r_leb128 (buf, buf_end - buf, &value->sconstant);\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->uconstant, NULL);\n\t\tbreak;\n\tcase DW_FORM_string:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tif (*buf) {\n\t\t\tchar *name = r_str_ndup ((const char *)buf, buf_end - buf);\n\t\t\tr_str_ansi_strip (name);\n\t\t\tr_str_replace_ch (name, '\\n', 0, true);\n\t\t\tr_str_replace_ch (name, '\\t', 0, true);\n\t\t\tvalue->string.content = name;\n\t\t} else {\n\t\t\tvalue->string.content = NULL;\n\t\t}\n\t\tif (value->string.content) {\n\t\t\tbuf += strlen (value->string.content) + 1;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block1:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ8 (buf);\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block2:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ16 (buf);\n\t\tif (value->block.length > 0) {\n\t\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length);\n\t\t\tif (!value->block.data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block4:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ32 (buf);\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block: // variable length ULEB128\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = READ (buf, ut8);\n\t\tbreak;\n\t// offset in .debug_str\n\tcase DW_FORM_strp:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tif (debug_str && value->string.offset < debug_str_len) {\n\t\t\tchar *ds = r_str_ndup ((const char *)(debug_str + value->string.offset), debug_str_len);\n\t\t\tif (ds) {\n\t\t\t\tr_str_ansi_strip (ds);\n\t\t\t\tr_str_replace_ch (ds, '\\n', 0, true);\n\t\t\t\tr_str_replace_ch (ds, '\\t', 0, true);\n\t\t\t\tvalue->string.content = ds;\n\t\t\t} else {\n\t\t\t\tvalue->string.content = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t}\n\t\tbreak;\n\t// offset in .debug_info\n\tcase DW_FORM_ref_addr:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t// This type of reference is an offset from the first byte of the compilation\n\t// header for the compilation unit containing the reference\n\tcase DW_FORM_ref1:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref2:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_udata:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\t// uleb128 is enough to fit into ut64?\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->reference, NULL);\n\t\tvalue->reference += hdr->unit_offset;\n\t\tbreak;\n\t// offset in a section other than .debug_info or .debug_str\n\tcase DW_FORM_sec_offset:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset(hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\tcase DW_FORM_exprloc:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\t// this means that the flag is present, nothing is read\n\tcase DW_FORM_flag_present:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = true;\n\t\tbreak;\n\tcase DW_FORM_ref_sig8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// offset into .debug_line_str section, can't parse the section now, so we just skip\n\tcase DW_FORM_strx:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\t// value->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdup ((const char *)(debug_str + value->string.offset));\n\t\t// } else {\n\t\t// \tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t// }\n\t\tbreak;\n\tcase DW_FORM_strx1:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx2:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx3: // TODO Add 3 byte int read\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_strx4:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_implicit_const:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = def->special;\n\t\tbreak;\n\t/*  addrx* forms : The index is relative to the value of the\n\t\tDW_AT_addr_base attribute of the associated compilation unit.\n\t    index into an array of addresses in the .debug_addr section.*/\n\tcase DW_FORM_addrx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tcase DW_FORM_addrx1:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx2:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx3:\n\t\t// I need to add 3byte endianess free read here TODO\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_addrx4:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_line_ptr: // offset in a section .debug_line_str\n\tcase DW_FORM_strp_sup: // offset in a section .debug_line_str\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdupsts\n\t\tbreak;\n\t// offset in the supplementary object file\n\tcase DW_FORM_ref_sup4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_sup8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// An index into the .debug_loc\n\tcase DW_FORM_loclistx:\n\t\tvalue->kind = DW_AT_KIND_LOCLISTPTR;\n\t\tvalue->reference = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t // An index into the .debug_rnglists\n\tcase DW_FORM_rnglistx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tcase 0:\n\t\tvalue->uconstant = 0;\n\t\treturn NULL;\n\tdefault:\n\t\tR_LOG_WARN (\"Unknown DW_FORM 0x%02\" PFMT64x, def->attr_form);\n\t\tvalue->uconstant = 0;\n\t\treturn NULL;\n\t}\n\treturn buf;\n}",
        "description": "Failure to sanitize special elements into a different plane (Special Element Injection) in the radare2 project prior to version 5.8.2.",
        "commit": "ANSI escape sequence injection vulnerabilities were addressed in the DWARF library. These vulnerabilities were reported via the huntrdev platform by @solid-snail. A reproducer function named `dwarf_test_func_patched` was provided to demonstrate the issue."
    }
]