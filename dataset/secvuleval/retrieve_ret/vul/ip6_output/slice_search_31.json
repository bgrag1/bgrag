[
    {
        "cwe": "CWE-17",
        "func_name": "torvalds/udf_find_entry",
        "score": 0.7585098147392273,
        "func_before": "static struct fileIdentDesc *udf_find_entry(struct inode *dir,\n\t\t\t\t\t    const struct qstr *child,\n\t\t\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t\t\t    struct fileIdentDesc *cfi)\n{\n\tstruct fileIdentDesc *fi = NULL;\n\tloff_t f_pos;\n\tint block, flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tloff_t size;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint isdotdot = child->len == 2 &&\n\t\tchild->name[0] == '.' && child->name[1] == '.';\n\n\tsize = udf_ext0_offset(dir) + dir->i_size;\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tfibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\tgoto out_err;\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t}\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname)\n\t\tgoto out_err;\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out_err;\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif (fibh->sbh == fibh->ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh->soffset + sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi;\n\n\t\t\tif (poffset >= lfi)\n\t\t\t\tnameptr = (uint8_t *)(fibh->ebh->b_data +\n\t\t\t\t\t\t      poffset - lfi);\n\t\t\telse {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t\tlfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t\tfibh->ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn fi;\n}",
        "func_after": "static struct fileIdentDesc *udf_find_entry(struct inode *dir,\n\t\t\t\t\t    const struct qstr *child,\n\t\t\t\t\t    struct udf_fileident_bh *fibh,\n\t\t\t\t\t    struct fileIdentDesc *cfi)\n{\n\tstruct fileIdentDesc *fi = NULL;\n\tloff_t f_pos;\n\tint block, flen;\n\tunsigned char *fname = NULL;\n\tunsigned char *nameptr;\n\tuint8_t lfi;\n\tuint16_t liu;\n\tloff_t size;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tstruct udf_inode_info *dinfo = UDF_I(dir);\n\tint isdotdot = child->len == 2 &&\n\t\tchild->name[0] == '.' && child->name[1] == '.';\n\n\tsize = udf_ext0_offset(dir) + dir->i_size;\n\tf_pos = udf_ext0_offset(dir);\n\n\tfibh->sbh = fibh->ebh = NULL;\n\tfibh->soffset = fibh->eoffset = f_pos & (dir->i_sb->s_blocksize - 1);\n\tif (dinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n\t\tif (inode_bmap(dir, f_pos >> dir->i_sb->s_blocksize_bits, &epos,\n\t\t    &eloc, &elen, &offset) != (EXT_RECORDED_ALLOCATED >> 30))\n\t\t\tgoto out_err;\n\t\tblock = udf_get_lb_pblock(dir->i_sb, &eloc, offset);\n\t\tif ((++offset << dir->i_sb->s_blocksize_bits) < elen) {\n\t\t\tif (dinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)\n\t\t\t\tepos.offset -= sizeof(struct short_ad);\n\t\t\telse if (dinfo->i_alloc_type == ICBTAG_FLAG_AD_LONG)\n\t\t\t\tepos.offset -= sizeof(struct long_ad);\n\t\t} else\n\t\t\toffset = 0;\n\n\t\tfibh->sbh = fibh->ebh = udf_tread(dir->i_sb, block);\n\t\tif (!fibh->sbh)\n\t\t\tgoto out_err;\n\t}\n\n\tfname = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n\tif (!fname)\n\t\tgoto out_err;\n\n\twhile (f_pos < size) {\n\t\tfi = udf_fileident_read(dir, &f_pos, fibh, cfi, &epos, &eloc,\n\t\t\t\t\t&elen, &offset);\n\t\tif (!fi)\n\t\t\tgoto out_err;\n\n\t\tliu = le16_to_cpu(cfi->lengthOfImpUse);\n\t\tlfi = cfi->lengthFileIdent;\n\n\t\tif (fibh->sbh == fibh->ebh) {\n\t\t\tnameptr = fi->fileIdent + liu;\n\t\t} else {\n\t\t\tint poffset;\t/* Unpaded ending offset */\n\n\t\t\tpoffset = fibh->soffset + sizeof(struct fileIdentDesc) +\n\t\t\t\t\tliu + lfi;\n\n\t\t\tif (poffset >= lfi)\n\t\t\t\tnameptr = (uint8_t *)(fibh->ebh->b_data +\n\t\t\t\t\t\t      poffset - lfi);\n\t\t\telse {\n\t\t\t\tnameptr = fname;\n\t\t\t\tmemcpy(nameptr, fi->fileIdent + liu,\n\t\t\t\t\tlfi - poffset);\n\t\t\t\tmemcpy(nameptr + lfi - poffset,\n\t\t\t\t\tfibh->ebh->b_data, poffset);\n\t\t\t}\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNDELETE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {\n\t\t\tif (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNHIDE))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,\n\t\t\t\t\tUDF_NAME_LEN);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:\n\tbrelse(epos.bh);\n\tkfree(fname);\n\n\treturn fi;\n}",
        "description": "The UDF filesystem implementation in the Linux kernel prior to version 3.18.2 does not verify that sufficient space is allocated for storing a symlink target's name along with a trailing null character. This oversight enables local users to potentially access sensitive information through a specially crafted filesystem image.",
        "commit": "The vulnerability involves a failure to verify whether the resolved path from reading a symbolic link fits within the allocated buffer size. This oversight occurs during the process of reading symlinks, where the code does not account for potential encoding conversions that could increase the path length. Consequently, there is a risk that the path may exceed the buffer capacity, leading to buffer overflow issues."
    },
    {
        "cwe": "CWE-665",
        "func_name": "torvalds/__skb_flow_dissect",
        "score": 0.752995491027832,
        "func_before": "bool __skb_flow_dissect(const struct sk_buff *skb,\n\t\t\tstruct flow_dissector *flow_dissector,\n\t\t\tvoid *target_container,\n\t\t\tvoid *data, __be16 proto, int nhoff, int hlen)\n{\n\tstruct flow_dissector_key_control *key_control;\n\tstruct flow_dissector_key_basic *key_basic;\n\tstruct flow_dissector_key_addrs *key_addrs;\n\tstruct flow_dissector_key_ports *key_ports;\n\tstruct flow_dissector_key_tags *key_tags;\n\tstruct flow_dissector_key_keyid *key_keyid;\n\tu8 ip_proto = 0;\n\n\tif (!data) {\n\t\tdata = skb->data;\n\t\tproto = skb->protocol;\n\t\tnhoff = skb_network_offset(skb);\n\t\thlen = skb_headlen(skb);\n\t}\n\n\t/* It is ensured by skb_flow_dissector_init() that control key will\n\t * be always present.\n\t */\n\tkey_control = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_CONTROL,\n\t\t\t\t\t\ttarget_container);\n\n\t/* It is ensured by skb_flow_dissector_init() that basic key will\n\t * be always present.\n\t */\n\tkey_basic = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t      FLOW_DISSECTOR_KEY_BASIC,\n\t\t\t\t\t      target_container);\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct ethhdr *eth = eth_hdr(skb);\n\t\tstruct flow_dissector_key_eth_addrs *key_eth_addrs;\n\n\t\tkey_eth_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t  FLOW_DISSECTOR_KEY_ETH_ADDRS,\n\t\t\t\t\t\t\t  target_container);\n\t\tmemcpy(key_eth_addrs, &eth->h_dest, sizeof(*key_eth_addrs));\n\t}\n\nagain:\n\tswitch (proto) {\n\tcase htons(ETH_P_IP): {\n\t\tconst struct iphdr *iph;\n\t\tstruct iphdr _iph;\nip:\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph || iph->ihl < 5)\n\t\t\treturn false;\n\t\tnhoff += iph->ihl * 4;\n\n\t\tip_proto = iph->protocol;\n\t\tif (ip_is_fragment(iph))\n\t\t\tip_proto = 0;\n\n\t\tif (!skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t FLOW_DISSECTOR_KEY_IPV4_ADDRS))\n\t\t\tbreak;\n\n\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t      FLOW_DISSECTOR_KEY_IPV4_ADDRS, target_container);\n\t\tmemcpy(&key_addrs->v4addrs, &iph->saddr,\n\t\t       sizeof(key_addrs->v4addrs));\n\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_IPV6): {\n\t\tconst struct ipv6hdr *iph;\n\t\tstruct ipv6hdr _iph;\n\t\t__be32 flow_label;\n\nipv6:\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph)\n\t\t\treturn false;\n\n\t\tip_proto = iph->nexthdr;\n\t\tnhoff += sizeof(struct ipv6hdr);\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_IPV6_ADDRS)) {\n\t\t\tstruct flow_dissector_key_ipv6_addrs *key_ipv6_addrs;\n\n\t\t\tkey_ipv6_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t   FLOW_DISSECTOR_KEY_IPV6_ADDRS,\n\t\t\t\t\t\t\t\t   target_container);\n\n\t\t\tmemcpy(key_ipv6_addrs, &iph->saddr, sizeof(*key_ipv6_addrs));\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t}\n\n\t\tflow_label = ip6_flowlabel(iph);\n\t\tif (flow_label) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\tFLOW_DISSECTOR_KEY_FLOW_LABEL)) {\n\t\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_FLOW_LABEL,\n\t\t\t\t\t\t\t\t     target_container);\n\t\t\t\tkey_tags->flow_label = ntohl(flow_label);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_8021AD):\n\tcase htons(ETH_P_8021Q): {\n\t\tconst struct vlan_hdr *vlan;\n\t\tstruct vlan_hdr _vlan;\n\n\t\tvlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);\n\t\tif (!vlan)\n\t\t\treturn false;\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_VLANID)) {\n\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_VLANID,\n\t\t\t\t\t\t\t     target_container);\n\n\t\t\tkey_tags->vlan_id = skb_vlan_tag_get_id(skb);\n\t\t}\n\n\t\tproto = vlan->h_vlan_encapsulated_proto;\n\t\tnhoff += sizeof(*vlan);\n\t\tgoto again;\n\t}\n\tcase htons(ETH_P_PPP_SES): {\n\t\tstruct {\n\t\t\tstruct pppoe_hdr hdr;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\t\tproto = hdr->proto;\n\t\tnhoff += PPPOE_SES_HLEN;\n\t\tswitch (proto) {\n\t\tcase htons(PPP_IP):\n\t\t\tgoto ip;\n\t\tcase htons(PPP_IPV6):\n\t\t\tgoto ipv6;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\tcase htons(ETH_P_TIPC): {\n\t\tstruct {\n\t\t\t__be32 pre[3];\n\t\t\t__be32 srcnode;\n\t\t} *hdr, _hdr;\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\t\tkey_basic->n_proto = proto;\n\t\tkey_control->thoff = (u16)nhoff;\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_TIPC_ADDRS)) {\n\t\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_TIPC_ADDRS,\n\t\t\t\t\t\t\t      target_container);\n\t\t\tkey_addrs->tipcaddrs.srcnode = hdr->srcnode;\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;\n\t\t}\n\t\treturn true;\n\t}\n\n\tcase htons(ETH_P_MPLS_UC):\n\tcase htons(ETH_P_MPLS_MC): {\n\t\tstruct mpls_label *hdr, _hdr[2];\nmpls:\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,\n\t\t\t\t\t   hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\n\t\tif ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>\n\t\t     MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_MPLS_ENTROPY)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_MPLS_ENTROPY,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = hdr[1].entry &\n\t\t\t\t\thtonl(MPLS_LS_LABEL_MASK);\n\t\t\t}\n\n\t\t\tkey_basic->n_proto = proto;\n\t\t\tkey_basic->ip_proto = ip_proto;\n\t\t\tkey_control->thoff = (u16)nhoff;\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tcase htons(ETH_P_FCOE):\n\t\tkey_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);\n\t\t/* fall through */\n\tdefault:\n\t\treturn false;\n\t}\n\nip_proto_again:\n\tswitch (ip_proto) {\n\tcase IPPROTO_GRE: {\n\t\tstruct gre_hdr {\n\t\t\t__be16 flags;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\t\t/*\n\t\t * Only look inside GRE if version zero and no\n\t\t * routing\n\t\t */\n\t\tif (hdr->flags & (GRE_VERSION | GRE_ROUTING))\n\t\t\tbreak;\n\n\t\tproto = hdr->proto;\n\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_CSUM)\n\t\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_KEY) {\n\t\t\tconst __be32 *keyid;\n\t\t\t__be32 _keyid;\n\n\t\t\tkeyid = __skb_header_pointer(skb, nhoff, sizeof(_keyid),\n\t\t\t\t\t\t     data, hlen, &_keyid);\n\n\t\t\tif (!keyid)\n\t\t\t\treturn false;\n\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_GRE_KEYID)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_GRE_KEYID,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = *keyid;\n\t\t\t}\n\t\t\tnhoff += 4;\n\t\t}\n\t\tif (hdr->flags & GRE_SEQ)\n\t\t\tnhoff += 4;\n\t\tif (proto == htons(ETH_P_TEB)) {\n\t\t\tconst struct ethhdr *eth;\n\t\t\tstruct ethhdr _eth;\n\n\t\t\teth = __skb_header_pointer(skb, nhoff,\n\t\t\t\t\t\t   sizeof(_eth),\n\t\t\t\t\t\t   data, hlen, &_eth);\n\t\t\tif (!eth)\n\t\t\t\treturn false;\n\t\t\tproto = eth->h_proto;\n\t\t\tnhoff += sizeof(*eth);\n\t\t}\n\t\tgoto again;\n\t}\n\tcase NEXTHDR_HOP:\n\tcase NEXTHDR_ROUTING:\n\tcase NEXTHDR_DEST: {\n\t\tu8 _opthdr[2], *opthdr;\n\n\t\tif (proto != htons(ETH_P_IPV6))\n\t\t\tbreak;\n\n\t\topthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),\n\t\t\t\t\t      data, hlen, &_opthdr);\n\t\tif (!opthdr)\n\t\t\treturn false;\n\n\t\tip_proto = opthdr[0];\n\t\tnhoff += (opthdr[1] + 1) << 3;\n\n\t\tgoto ip_proto_again;\n\t}\n\tcase IPPROTO_IPIP:\n\t\tproto = htons(ETH_P_IP);\n\t\tgoto ip;\n\tcase IPPROTO_IPV6:\n\t\tproto = htons(ETH_P_IPV6);\n\t\tgoto ipv6;\n\tcase IPPROTO_MPLS:\n\t\tproto = htons(ETH_P_MPLS_UC);\n\t\tgoto mpls;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkey_basic->n_proto = proto;\n\tkey_basic->ip_proto = ip_proto;\n\tkey_control->thoff = (u16)nhoff;\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_PORTS)) {\n\t\tkey_ports = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_PORTS,\n\t\t\t\t\t\t      target_container);\n\t\tkey_ports->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,\n\t\t\t\t\t\t\tdata, hlen);\n\t}\n\n\treturn true;\n}",
        "func_after": "bool __skb_flow_dissect(const struct sk_buff *skb,\n\t\t\tstruct flow_dissector *flow_dissector,\n\t\t\tvoid *target_container,\n\t\t\tvoid *data, __be16 proto, int nhoff, int hlen)\n{\n\tstruct flow_dissector_key_control *key_control;\n\tstruct flow_dissector_key_basic *key_basic;\n\tstruct flow_dissector_key_addrs *key_addrs;\n\tstruct flow_dissector_key_ports *key_ports;\n\tstruct flow_dissector_key_tags *key_tags;\n\tstruct flow_dissector_key_keyid *key_keyid;\n\tu8 ip_proto = 0;\n\tbool ret = false;\n\n\tif (!data) {\n\t\tdata = skb->data;\n\t\tproto = skb->protocol;\n\t\tnhoff = skb_network_offset(skb);\n\t\thlen = skb_headlen(skb);\n\t}\n\n\t/* It is ensured by skb_flow_dissector_init() that control key will\n\t * be always present.\n\t */\n\tkey_control = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_CONTROL,\n\t\t\t\t\t\ttarget_container);\n\n\t/* It is ensured by skb_flow_dissector_init() that basic key will\n\t * be always present.\n\t */\n\tkey_basic = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t      FLOW_DISSECTOR_KEY_BASIC,\n\t\t\t\t\t      target_container);\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct ethhdr *eth = eth_hdr(skb);\n\t\tstruct flow_dissector_key_eth_addrs *key_eth_addrs;\n\n\t\tkey_eth_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t  FLOW_DISSECTOR_KEY_ETH_ADDRS,\n\t\t\t\t\t\t\t  target_container);\n\t\tmemcpy(key_eth_addrs, &eth->h_dest, sizeof(*key_eth_addrs));\n\t}\n\nagain:\n\tswitch (proto) {\n\tcase htons(ETH_P_IP): {\n\t\tconst struct iphdr *iph;\n\t\tstruct iphdr _iph;\nip:\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph || iph->ihl < 5)\n\t\t\tgoto out_bad;\n\t\tnhoff += iph->ihl * 4;\n\n\t\tip_proto = iph->protocol;\n\t\tif (ip_is_fragment(iph))\n\t\t\tip_proto = 0;\n\n\t\tif (!skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t FLOW_DISSECTOR_KEY_IPV4_ADDRS))\n\t\t\tbreak;\n\n\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t      FLOW_DISSECTOR_KEY_IPV4_ADDRS, target_container);\n\t\tmemcpy(&key_addrs->v4addrs, &iph->saddr,\n\t\t       sizeof(key_addrs->v4addrs));\n\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_IPV6): {\n\t\tconst struct ipv6hdr *iph;\n\t\tstruct ipv6hdr _iph;\n\t\t__be32 flow_label;\n\nipv6:\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph)\n\t\t\tgoto out_bad;\n\n\t\tip_proto = iph->nexthdr;\n\t\tnhoff += sizeof(struct ipv6hdr);\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_IPV6_ADDRS)) {\n\t\t\tstruct flow_dissector_key_ipv6_addrs *key_ipv6_addrs;\n\n\t\t\tkey_ipv6_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t   FLOW_DISSECTOR_KEY_IPV6_ADDRS,\n\t\t\t\t\t\t\t\t   target_container);\n\n\t\t\tmemcpy(key_ipv6_addrs, &iph->saddr, sizeof(*key_ipv6_addrs));\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t}\n\n\t\tflow_label = ip6_flowlabel(iph);\n\t\tif (flow_label) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\tFLOW_DISSECTOR_KEY_FLOW_LABEL)) {\n\t\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_FLOW_LABEL,\n\t\t\t\t\t\t\t\t     target_container);\n\t\t\t\tkey_tags->flow_label = ntohl(flow_label);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_8021AD):\n\tcase htons(ETH_P_8021Q): {\n\t\tconst struct vlan_hdr *vlan;\n\t\tstruct vlan_hdr _vlan;\n\n\t\tvlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);\n\t\tif (!vlan)\n\t\t\tgoto out_bad;\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_VLANID)) {\n\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_VLANID,\n\t\t\t\t\t\t\t     target_container);\n\n\t\t\tkey_tags->vlan_id = skb_vlan_tag_get_id(skb);\n\t\t}\n\n\t\tproto = vlan->h_vlan_encapsulated_proto;\n\t\tnhoff += sizeof(*vlan);\n\t\tgoto again;\n\t}\n\tcase htons(ETH_P_PPP_SES): {\n\t\tstruct {\n\t\t\tstruct pppoe_hdr hdr;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\tgoto out_bad;\n\t\tproto = hdr->proto;\n\t\tnhoff += PPPOE_SES_HLEN;\n\t\tswitch (proto) {\n\t\tcase htons(PPP_IP):\n\t\t\tgoto ip;\n\t\tcase htons(PPP_IPV6):\n\t\t\tgoto ipv6;\n\t\tdefault:\n\t\t\tgoto out_bad;\n\t\t}\n\t}\n\tcase htons(ETH_P_TIPC): {\n\t\tstruct {\n\t\t\t__be32 pre[3];\n\t\t\t__be32 srcnode;\n\t\t} *hdr, _hdr;\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\tgoto out_bad;\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_TIPC_ADDRS)) {\n\t\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_TIPC_ADDRS,\n\t\t\t\t\t\t\t      target_container);\n\t\t\tkey_addrs->tipcaddrs.srcnode = hdr->srcnode;\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;\n\t\t}\n\t\tgoto out_good;\n\t}\n\n\tcase htons(ETH_P_MPLS_UC):\n\tcase htons(ETH_P_MPLS_MC): {\n\t\tstruct mpls_label *hdr, _hdr[2];\nmpls:\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,\n\t\t\t\t\t   hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\tgoto out_bad;\n\n\t\tif ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>\n\t\t     MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_MPLS_ENTROPY)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_MPLS_ENTROPY,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = hdr[1].entry &\n\t\t\t\t\thtonl(MPLS_LS_LABEL_MASK);\n\t\t\t}\n\n\t\t\tgoto out_good;\n\t\t}\n\n\t\tgoto out_good;\n\t}\n\n\tcase htons(ETH_P_FCOE):\n\t\tkey_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);\n\t\t/* fall through */\n\tdefault:\n\t\tgoto out_bad;\n\t}\n\nip_proto_again:\n\tswitch (ip_proto) {\n\tcase IPPROTO_GRE: {\n\t\tstruct gre_hdr {\n\t\t\t__be16 flags;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\tgoto out_bad;\n\t\t/*\n\t\t * Only look inside GRE if version zero and no\n\t\t * routing\n\t\t */\n\t\tif (hdr->flags & (GRE_VERSION | GRE_ROUTING))\n\t\t\tbreak;\n\n\t\tproto = hdr->proto;\n\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_CSUM)\n\t\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_KEY) {\n\t\t\tconst __be32 *keyid;\n\t\t\t__be32 _keyid;\n\n\t\t\tkeyid = __skb_header_pointer(skb, nhoff, sizeof(_keyid),\n\t\t\t\t\t\t     data, hlen, &_keyid);\n\n\t\t\tif (!keyid)\n\t\t\t\tgoto out_bad;\n\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_GRE_KEYID)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_GRE_KEYID,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = *keyid;\n\t\t\t}\n\t\t\tnhoff += 4;\n\t\t}\n\t\tif (hdr->flags & GRE_SEQ)\n\t\t\tnhoff += 4;\n\t\tif (proto == htons(ETH_P_TEB)) {\n\t\t\tconst struct ethhdr *eth;\n\t\t\tstruct ethhdr _eth;\n\n\t\t\teth = __skb_header_pointer(skb, nhoff,\n\t\t\t\t\t\t   sizeof(_eth),\n\t\t\t\t\t\t   data, hlen, &_eth);\n\t\t\tif (!eth)\n\t\t\t\tgoto out_bad;\n\t\t\tproto = eth->h_proto;\n\t\t\tnhoff += sizeof(*eth);\n\t\t}\n\t\tgoto again;\n\t}\n\tcase NEXTHDR_HOP:\n\tcase NEXTHDR_ROUTING:\n\tcase NEXTHDR_DEST: {\n\t\tu8 _opthdr[2], *opthdr;\n\n\t\tif (proto != htons(ETH_P_IPV6))\n\t\t\tbreak;\n\n\t\topthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),\n\t\t\t\t\t      data, hlen, &_opthdr);\n\t\tif (!opthdr)\n\t\t\tgoto out_bad;\n\n\t\tip_proto = opthdr[0];\n\t\tnhoff += (opthdr[1] + 1) << 3;\n\n\t\tgoto ip_proto_again;\n\t}\n\tcase IPPROTO_IPIP:\n\t\tproto = htons(ETH_P_IP);\n\t\tgoto ip;\n\tcase IPPROTO_IPV6:\n\t\tproto = htons(ETH_P_IPV6);\n\t\tgoto ipv6;\n\tcase IPPROTO_MPLS:\n\t\tproto = htons(ETH_P_MPLS_UC);\n\t\tgoto mpls;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_PORTS)) {\n\t\tkey_ports = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_PORTS,\n\t\t\t\t\t\t      target_container);\n\t\tkey_ports->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,\n\t\t\t\t\t\t\tdata, hlen);\n\t}\n\nout_good:\n\tret = true;\n\nout_bad:\n\tkey_basic->n_proto = proto;\n\tkey_basic->ip_proto = ip_proto;\n\tkey_control->thoff = (u16)nhoff;\n\n\treturn ret;\n}",
        "description": "The `__skb_flow_dissect` function in the Linux kernel, prior to version 4.3, does not guarantee the initialization of certain protocol fields (`n_proto`, `ip_proto`, and `thoff`). This oversight enables remote attackers to exploit a single crafted MPLS packet to trigger a denial of service (system crash) or potentially execute arbitrary code.",
        "commit": "The vulnerability involves a function responsible for dissecting network flows, where instead of returning immediately upon encountering a parsing failure, it jumps to cleanup code. This approach ensures that even in the event of a failure, some protocol values are set in the key_control structure, although there may still be valid information in the key_tags that was established before the error occurred."
    },
    {
        "cwe": "CWE-416",
        "func_name": "torvalds/ipt_do_table",
        "score": 0.7554500102996826,
        "func_before": "unsigned int\nipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
        "func_after": "unsigned int\nipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = rcu_access_pointer(table->private);\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
        "description": "An issue was discovered in the netfilter component of the Linux kernel prior to version 5.10. This vulnerability involves a use-after-free condition in the packet processing context due to improper handling of per-CPU sequence counts during concurrent iptables rule replacements. This flaw could be exploited by users with the CAP_NET_ADMIN capability in an unprivileged namespace.",
        "commit": "When performing concurrent iptables rules replacement, the system checks the per-CPU sequence count after assigning new information. This sequence count is intended to synchronize with the packet path without using explicit locking. If packets are currently using the old table information, the sequence count is incremented to an odd value and then to an even value after processing. After assigning the new table information, a write memory barrier is executed to ensure all CPUs see the latest value. If the packet path starts with the old table information, the sequence counter remains odd, and the iptables replacement waits until the sequence count is even before freeing the old table information. However, if the CPU delays executing the new table information assignment and memory barrier, another CPU's packet path may still use the old table information. This delay can lead to a use-after-free error in the packet processing context, resulting in a kernel NULL pointer dereference. To fix this issue, either enforce instruction ordering after the new table information assignment or switch to RCU for synchronization."
    },
    {
        "cwe": "CWE-269",
        "func_name": "xen-project/msix_capability_init",
        "score": 0.7450435757637024,
        "func_before": "static int msix_capability_init(struct pci_dev *dev,\n                                struct msi_info *msi,\n                                struct msi_desc **desc)\n{\n    struct arch_msix *msix = dev->msix;\n    struct msi_desc *entry = NULL;\n    int vf;\n    u16 control;\n    u64 table_paddr;\n    u32 table_offset;\n    u8 bir, pbus, pslot, pfunc;\n    u16 seg = dev->seg;\n    u8 bus = dev->bus;\n    u8 slot = PCI_SLOT(dev->devfn);\n    u8 func = PCI_FUNC(dev->devfn);\n    bool maskall = msix->host_maskall;\n    unsigned int pos = pci_find_cap_offset(seg, bus, slot, func,\n                                           PCI_CAP_ID_MSIX);\n\n    if ( !pos )\n        return -ENODEV;\n\n    ASSERT(pcidevs_locked());\n\n    control = pci_conf_read16(dev->sbdf, msix_control_reg(pos));\n    /*\n     * Ensure MSI-X interrupts are masked during setup. Some devices require\n     * MSI-X to be enabled before we can touch the MSI-X registers. We need\n     * to mask all the vectors to prevent interrupts coming in before they're\n     * fully set up.\n     */\n    msix->host_maskall = 1;\n    pci_conf_write16(dev->sbdf, msix_control_reg(pos),\n                     control | (PCI_MSIX_FLAGS_ENABLE |\n                                PCI_MSIX_FLAGS_MASKALL));\n\n    if ( unlikely(!memory_decoded(dev)) )\n    {\n        pci_conf_write16(dev->sbdf, msix_control_reg(pos),\n                         control & ~PCI_MSIX_FLAGS_ENABLE);\n        return -ENXIO;\n    }\n\n    if ( desc )\n    {\n        entry = alloc_msi_entry(1);\n        if ( !entry )\n        {\n            pci_conf_write16(dev->sbdf, msix_control_reg(pos),\n                             control & ~PCI_MSIX_FLAGS_ENABLE);\n            return -ENOMEM;\n        }\n        ASSERT(msi);\n    }\n\n    /* Locate MSI-X table region */\n    table_offset = pci_conf_read32(dev->sbdf, msix_table_offset_reg(pos));\n    bir = (u8)(table_offset & PCI_MSIX_BIRMASK);\n    table_offset &= ~PCI_MSIX_BIRMASK;\n\n    if ( !dev->info.is_virtfn )\n    {\n        pbus = bus;\n        pslot = slot;\n        pfunc = func;\n        vf = -1;\n    }\n    else\n    {\n        pbus = dev->info.physfn.bus;\n        pslot = PCI_SLOT(dev->info.physfn.devfn);\n        pfunc = PCI_FUNC(dev->info.physfn.devfn);\n        vf = PCI_BDF2(dev->bus, dev->devfn);\n    }\n\n    table_paddr = read_pci_mem_bar(seg, pbus, pslot, pfunc, bir, vf);\n    WARN_ON(msi && msi->table_base != table_paddr);\n    if ( !table_paddr )\n    {\n        if ( !msi || !msi->table_base )\n        {\n            pci_conf_write16(dev->sbdf, msix_control_reg(pos),\n                             control & ~PCI_MSIX_FLAGS_ENABLE);\n            xfree(entry);\n            return -ENXIO;\n        }\n        table_paddr = msi->table_base;\n    }\n    table_paddr += table_offset;\n\n    if ( !msix->used_entries )\n    {\n        u64 pba_paddr;\n        u32 pba_offset;\n\n        msix->table.first = PFN_DOWN(table_paddr);\n        msix->table.last = PFN_DOWN(table_paddr +\n                                    msix->nr_entries * PCI_MSIX_ENTRY_SIZE - 1);\n        WARN_ON(rangeset_overlaps_range(mmio_ro_ranges, msix->table.first,\n                                        msix->table.last));\n\n        pba_offset = pci_conf_read32(dev->sbdf, msix_pba_offset_reg(pos));\n        bir = (u8)(pba_offset & PCI_MSIX_BIRMASK);\n        pba_paddr = read_pci_mem_bar(seg, pbus, pslot, pfunc, bir, vf);\n        WARN_ON(!pba_paddr);\n        pba_paddr += pba_offset & ~PCI_MSIX_BIRMASK;\n\n        msix->pba.first = PFN_DOWN(pba_paddr);\n        msix->pba.last = PFN_DOWN(pba_paddr +\n                                  BITS_TO_LONGS(msix->nr_entries) - 1);\n        WARN_ON(rangeset_overlaps_range(mmio_ro_ranges, msix->pba.first,\n                                        msix->pba.last));\n    }\n\n    if ( entry )\n    {\n        /* Map MSI-X table region */\n        u64 entry_paddr = table_paddr + msi->entry_nr * PCI_MSIX_ENTRY_SIZE;\n        int idx = msix_get_fixmap(msix, table_paddr, entry_paddr);\n        void __iomem *base;\n\n        if ( idx < 0 )\n        {\n            pci_conf_write16(dev->sbdf, msix_control_reg(pos),\n                             control & ~PCI_MSIX_FLAGS_ENABLE);\n            xfree(entry);\n            return idx;\n        }\n        base = fix_to_virt(idx) + (entry_paddr & (PAGE_SIZE - 1));\n\n        /* Mask interrupt here */\n        writel(1, base + PCI_MSIX_ENTRY_VECTOR_CTRL_OFFSET);\n\n        entry->msi_attrib.type = PCI_CAP_ID_MSIX;\n        entry->msi_attrib.is_64 = 1;\n        entry->msi_attrib.entry_nr = msi->entry_nr;\n        entry->msi_attrib.maskbit = 1;\n        entry->msi_attrib.host_masked = 1;\n        entry->msi_attrib.guest_masked = 1;\n        entry->msi_attrib.pos = pos;\n        entry->irq = msi->irq;\n        entry->dev = dev;\n        entry->mask_base = base;\n\n        list_add_tail(&entry->list, &dev->msi_list);\n        *desc = entry;\n    }\n\n    if ( !msix->used_entries )\n    {\n        maskall = false;\n        if ( !msix->guest_maskall )\n            control &= ~PCI_MSIX_FLAGS_MASKALL;\n        else\n            control |= PCI_MSIX_FLAGS_MASKALL;\n\n        if ( rangeset_add_range(mmio_ro_ranges, msix->table.first,\n                                msix->table.last) )\n            WARN();\n        if ( rangeset_add_range(mmio_ro_ranges, msix->pba.first,\n                                msix->pba.last) )\n            WARN();\n\n        if ( desc )\n        {\n            struct domain *currd = current->domain;\n            struct domain *d = dev->domain ?: currd;\n\n            if ( !is_hardware_domain(currd) || d != currd )\n                printk(\"%s use of MSI-X on %pp by %pd\\n\",\n                       is_hardware_domain(currd)\n                       ? XENLOG_WARNING \"Potentially insecure\"\n                       : XENLOG_ERR \"Insecure\",\n                       &dev->sbdf, d);\n            if ( !is_hardware_domain(d) &&\n                 /* Assume a domain without memory has no mappings yet. */\n                 (!is_hardware_domain(currd) || domain_tot_pages(d)) )\n                domain_crash(d);\n            /* XXX How to deal with existing mappings? */\n        }\n    }\n    WARN_ON(msix->table.first != (table_paddr >> PAGE_SHIFT));\n    ++msix->used_entries;\n\n    /* Restore MSI-X enabled bits */\n    if ( !hardware_domain )\n    {\n        /*\n         * ..., except for internal requests (before Dom0 starts), in which\n         * case we rather need to behave \"normally\", i.e. not follow the split\n         * brain model where Dom0 actually enables MSI (and disables INTx).\n         */\n        pci_intx(dev, false);\n        control |= PCI_MSIX_FLAGS_ENABLE;\n        control &= ~PCI_MSIX_FLAGS_MASKALL;\n        maskall = 0;\n    }\n    msix->host_maskall = maskall;\n    pci_conf_write16(dev->sbdf, msix_control_reg(pos), control);\n\n    return 0;\n}",
        "func_after": "static int msix_capability_init(struct pci_dev *dev,\n                                struct msi_info *msi,\n                                struct msi_desc **desc)\n{\n    struct arch_msix *msix = dev->msix;\n    struct msi_desc *entry = NULL;\n    u16 control;\n    u64 table_paddr;\n    u32 table_offset;\n    u16 seg = dev->seg;\n    u8 bus = dev->bus;\n    u8 slot = PCI_SLOT(dev->devfn);\n    u8 func = PCI_FUNC(dev->devfn);\n    bool maskall = msix->host_maskall, zap_on_error = false;\n    unsigned int pos = pci_find_cap_offset(seg, bus, slot, func,\n                                           PCI_CAP_ID_MSIX);\n\n    if ( !pos )\n        return -ENODEV;\n\n    ASSERT(pcidevs_locked());\n\n    control = pci_conf_read16(dev->sbdf, msix_control_reg(pos));\n    /*\n     * Ensure MSI-X interrupts are masked during setup. Some devices require\n     * MSI-X to be enabled before we can touch the MSI-X registers. We need\n     * to mask all the vectors to prevent interrupts coming in before they're\n     * fully set up.\n     */\n    msix->host_maskall = 1;\n    pci_conf_write16(dev->sbdf, msix_control_reg(pos),\n                     control | (PCI_MSIX_FLAGS_ENABLE |\n                                PCI_MSIX_FLAGS_MASKALL));\n\n    if ( unlikely(!memory_decoded(dev)) )\n    {\n        pci_conf_write16(dev->sbdf, msix_control_reg(pos),\n                         control & ~PCI_MSIX_FLAGS_ENABLE);\n        return -ENXIO;\n    }\n\n    if ( desc )\n    {\n        entry = alloc_msi_entry(1);\n        if ( !entry )\n        {\n            pci_conf_write16(dev->sbdf, msix_control_reg(pos),\n                             control & ~PCI_MSIX_FLAGS_ENABLE);\n            return -ENOMEM;\n        }\n        ASSERT(msi);\n    }\n\n    /* Locate MSI-X table region */\n    table_offset = pci_conf_read32(dev->sbdf, msix_table_offset_reg(pos));\n    if ( !msix->used_entries &&\n         (!msi ||\n          (is_hardware_domain(current->domain) &&\n           (dev->domain == current->domain || dev->domain == dom_io))) )\n    {\n        unsigned int bir = table_offset & PCI_MSIX_BIRMASK, pbus, pslot, pfunc;\n        int vf;\n        paddr_t pba_paddr;\n        unsigned int pba_offset;\n\n        if ( !dev->info.is_virtfn )\n        {\n            pbus = bus;\n            pslot = slot;\n            pfunc = func;\n            vf = -1;\n        }\n        else\n        {\n            pbus = dev->info.physfn.bus;\n            pslot = PCI_SLOT(dev->info.physfn.devfn);\n            pfunc = PCI_FUNC(dev->info.physfn.devfn);\n            vf = PCI_BDF2(dev->bus, dev->devfn);\n        }\n\n        table_paddr = read_pci_mem_bar(seg, pbus, pslot, pfunc, bir, vf);\n        WARN_ON(msi && msi->table_base != table_paddr);\n        if ( !table_paddr )\n        {\n            if ( !msi || !msi->table_base )\n            {\n                pci_conf_write16(dev->sbdf, msix_control_reg(pos),\n                                 control & ~PCI_MSIX_FLAGS_ENABLE);\n                xfree(entry);\n                return -ENXIO;\n            }\n            table_paddr = msi->table_base;\n        }\n        table_paddr += table_offset & ~PCI_MSIX_BIRMASK;\n\n        msix->table.first = PFN_DOWN(table_paddr);\n        msix->table.last = PFN_DOWN(table_paddr +\n                                    msix->nr_entries * PCI_MSIX_ENTRY_SIZE - 1);\n        WARN_ON(rangeset_overlaps_range(mmio_ro_ranges, msix->table.first,\n                                        msix->table.last));\n\n        pba_offset = pci_conf_read32(dev->sbdf, msix_pba_offset_reg(pos));\n        bir = (u8)(pba_offset & PCI_MSIX_BIRMASK);\n        pba_paddr = read_pci_mem_bar(seg, pbus, pslot, pfunc, bir, vf);\n        WARN_ON(!pba_paddr);\n        pba_paddr += pba_offset & ~PCI_MSIX_BIRMASK;\n\n        msix->pba.first = PFN_DOWN(pba_paddr);\n        msix->pba.last = PFN_DOWN(pba_paddr +\n                                  BITS_TO_LONGS(msix->nr_entries) - 1);\n        WARN_ON(rangeset_overlaps_range(mmio_ro_ranges, msix->pba.first,\n                                        msix->pba.last));\n\n        zap_on_error = true;\n    }\n    else if ( !msix->table.first )\n    {\n        pci_conf_write16(dev->sbdf, msix_control_reg(pos), control);\n        xfree(entry);\n        return -ENODATA;\n    }\n    else\n        table_paddr = (msix->table.first << PAGE_SHIFT) +\n                      PAGE_OFFSET(table_offset & ~PCI_MSIX_BIRMASK);\n\n    if ( entry )\n    {\n        /* Map MSI-X table region */\n        u64 entry_paddr = table_paddr + msi->entry_nr * PCI_MSIX_ENTRY_SIZE;\n        int idx = msix_get_fixmap(msix, table_paddr, entry_paddr);\n        void __iomem *base;\n\n        if ( idx < 0 )\n        {\n            if ( zap_on_error )\n            {\n                msix->table.first = 0;\n                msix->pba.first = 0;\n\n                control &= ~PCI_MSIX_FLAGS_ENABLE;\n            }\n\n            pci_conf_write16(dev->sbdf, msix_control_reg(pos), control);\n            xfree(entry);\n            return idx;\n        }\n        base = fix_to_virt(idx) + (entry_paddr & (PAGE_SIZE - 1));\n\n        /* Mask interrupt here */\n        writel(1, base + PCI_MSIX_ENTRY_VECTOR_CTRL_OFFSET);\n\n        entry->msi_attrib.type = PCI_CAP_ID_MSIX;\n        entry->msi_attrib.is_64 = 1;\n        entry->msi_attrib.entry_nr = msi->entry_nr;\n        entry->msi_attrib.maskbit = 1;\n        entry->msi_attrib.host_masked = 1;\n        entry->msi_attrib.guest_masked = 1;\n        entry->msi_attrib.pos = pos;\n        entry->irq = msi->irq;\n        entry->dev = dev;\n        entry->mask_base = base;\n\n        list_add_tail(&entry->list, &dev->msi_list);\n        *desc = entry;\n    }\n\n    if ( !msix->used_entries )\n    {\n        maskall = false;\n        if ( !msix->guest_maskall )\n            control &= ~PCI_MSIX_FLAGS_MASKALL;\n        else\n            control |= PCI_MSIX_FLAGS_MASKALL;\n\n        if ( rangeset_add_range(mmio_ro_ranges, msix->table.first,\n                                msix->table.last) )\n            WARN();\n        if ( rangeset_add_range(mmio_ro_ranges, msix->pba.first,\n                                msix->pba.last) )\n            WARN();\n\n        if ( desc )\n        {\n            struct domain *currd = current->domain;\n            struct domain *d = dev->domain ?: currd;\n\n            if ( !is_hardware_domain(currd) || d != currd )\n                printk(\"%s use of MSI-X on %pp by %pd\\n\",\n                       is_hardware_domain(currd)\n                       ? XENLOG_WARNING \"Potentially insecure\"\n                       : XENLOG_ERR \"Insecure\",\n                       &dev->sbdf, d);\n            if ( !is_hardware_domain(d) &&\n                 /* Assume a domain without memory has no mappings yet. */\n                 (!is_hardware_domain(currd) || domain_tot_pages(d)) )\n                domain_crash(d);\n            /* XXX How to deal with existing mappings? */\n        }\n    }\n    WARN_ON(msix->table.first != (table_paddr >> PAGE_SHIFT));\n    ++msix->used_entries;\n\n    /* Restore MSI-X enabled bits */\n    if ( !hardware_domain )\n    {\n        /*\n         * ..., except for internal requests (before Dom0 starts), in which\n         * case we rather need to behave \"normally\", i.e. not follow the split\n         * brain model where Dom0 actually enables MSI (and disables INTx).\n         */\n        pci_intx(dev, false);\n        control |= PCI_MSIX_FLAGS_ENABLE;\n        control &= ~PCI_MSIX_FLAGS_MASKALL;\n        maskall = 0;\n    }\n    msix->host_maskall = maskall;\n    pci_conf_write16(dev->sbdf, msix_control_reg(pos), control);\n\n    return 0;\n}",
        "description": "An issue was discovered in Xen through version 4.14.x where the PCI passthrough code improperly utilizes register data. Specifically, certain code paths in Xen's MSI handling act on unsanitized values read from device hardware registers. Although devices compliant with PCI specifications should not be able to affect these registers, many devices possess out-of-spec \"backdoor\" operations that can influence the results of these reads. A not fully trusted guest may exploit this vulnerability to crash Xen, resulting in a Denial of Service (DoS) for the entire system. Privilege escalation and information leaks are also potential risks. All versions of Xen supporting PCI passthrough are affected, but only x86 systems are vulnerable; Arm systems are not affected. Only guests with passed-through PCI devices may be able to leverage this vulnerability, and only systems passing through devices with out-of-spec (\"backdoor\") functionality can be impacted. Given that such out-of-spec functionality is common, it is advisable to assume that devices have this capability unless there is evidence to the contrary.",
        "commit": "When devices are assigned to less trusted or untrusted guests, they may alter their state unexpectedly, such as getting reset through unknown means. To prevent unauthorized access, reading Base Address Registers (BARs) from hardware should be restricted once a device is no longer owned by the Domain 0 (Dom0). Additionally, if a BAR cannot be read or returns zero, the caller-provided address should not be used unless the caller is trusted. The logic in `msix_capability_init()` has been restructured to ensure that only Dom0 (and only if the device isn't owned by a Domain User (DomU) yet) or calls through `PHYSDEVOP_prepare_msix` will result in reading the respective BAR registers. This reading should occur only as long as in-use table entries are known, with `PHYSDEVOP_prepare_msix` counting as a \"pseudo\" entry. In all other cases, previously recorded values should be used instead. The recorded values are cleared in `_pci_cleanup_msix()` and on the affected error path, which has also been adjusted to avoid blindly disabling Message Signaled Interrupts (MSI-X) when it was enabled upon entering the function. Variable declarations have been moved and adjusted to reduce their scopes and types, as part of XSA-337."
    }
]