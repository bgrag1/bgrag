[
    {
        "cwe": "CWE-416",
        "func_name": "torvalds/ipt_do_table",
        "score": 0.720097005367279,
        "func_before": "unsigned int\nipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
        "func_after": "unsigned int\nipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = rcu_access_pointer(table->private);\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
        "description": "An issue was discovered in the netfilter component of the Linux kernel prior to version 5.10. This vulnerability involves a use-after-free condition in the packet processing context due to improper handling of per-CPU sequence counts during concurrent iptables rule replacements. This flaw could be exploited by users with the CAP_NET_ADMIN capability in an unprivileged namespace.",
        "commit": "When performing concurrent iptables rules replacement, the system checks the per-CPU sequence count after assigning new information. This sequence count is intended to synchronize with the packet path without using explicit locking. If packets are currently using the old table information, the sequence count is incremented to an odd value and then to an even value after processing. After assigning the new table information, a write memory barrier is executed to ensure all CPUs see the latest value. If the packet path starts with the old table information, the sequence counter remains odd, and the iptables replacement waits until the sequence count is even before freeing the old table information. However, if the CPU delays executing the new table information assignment and memory barrier, another CPU's packet path may still use the old table information. This delay can lead to a use-after-free error in the packet processing context, resulting in a kernel NULL pointer dereference. To fix this issue, either enforce instruction ordering after the new table information assignment or switch to RCU for synchronization."
    },
    {
        "cwe": "CWE-385",
        "func_name": "openssl/ecdsa_sign_setup",
        "score": 0.7099379897117615,
        "func_before": "static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,\n\t\t\t\t\tBIGNUM **kinvp, BIGNUM **rp,\n\t\t\t\t\tconst unsigned char *dgst, int dlen)\n{\n\tBN_CTX   *ctx = NULL;\n\tBIGNUM\t *k = NULL, *r = NULL, *order = NULL, *X = NULL;\n\tEC_POINT *tmp_point=NULL;\n\tconst EC_GROUP *group;\n\tint \t ret = 0;\n\n\tif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\n\tif (ctx_in == NULL) \n\t{\n\t\tif ((ctx = BN_CTX_new()) == NULL)\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t\tctx = ctx_in;\n\n\tk     = BN_new();\t/* this value is later returned in *kinvp */\n\tr     = BN_new();\t/* this value is later returned in *rp    */\n\torder = BN_new();\n\tX     = BN_new();\n\tif (!k || !r || !order || !X)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t}\n\tif ((tmp_point = EC_POINT_new(group)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\tif (!EC_GROUP_get_order(group, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\n#ifdef OPENSSL_FIPS\n\tif (!fips_check_ec_prng(eckey))\n\t\tgoto err;\n#endif\n\t\n\tdo\n\t{\n\t\t/* get random k */\t\n\t\tdo\n#ifndef OPENSSL_NO_SHA512\n\t\t\tif (dgst != NULL)\n\t\t\t{\n\t\t\t\tif (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),\n\t\t\t\t\t\t\t   dgst, dlen, ctx))\n\t\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tif (!BN_rand_range(k, order))\n\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\twhile (BN_is_zero(k));\n\n\t\t/* We do not want timing information to leak the length of k,\n\t\t * so we compute G*k using an equivalent scalar of fixed\n\t\t * bit-length. */\n\n\t\tif (!BN_add(k, k, order)) goto err;\n\t\tif (BN_num_bits(k) <= BN_num_bits(order))\n\t\t\tif (!BN_add(k, k, order)) goto err;\n\n\t\t/* compute r the x-coordinate of generator * k */\n\t\tif (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t}\n\t\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#ifndef OPENSSL_NO_EC2M\n\t\telse /* NID_X9_62_characteristic_two_field */\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GF2m(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!BN_nnmod(r, X, order, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t}\n\t}\n\twhile (BN_is_zero(r));\n\n\t/* compute the inverse of k */\n\tif (!BN_mod_inverse(k, k, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\tgoto err;\t\n\t}\n\t/* clear old values if necessary */\n\tif (*rp != NULL)\n\t\tBN_clear_free(*rp);\n\tif (*kinvp != NULL) \n\t\tBN_clear_free(*kinvp);\n\t/* save the pre-computed values  */\n\t*rp    = r;\n\t*kinvp = k;\n\tret = 1;\nerr:\n\tif (!ret)\n\t{\n\t\tif (k != NULL) BN_clear_free(k);\n\t\tif (r != NULL) BN_clear_free(r);\n\t}\n\tif (ctx_in == NULL) \n\t\tBN_CTX_free(ctx);\n\tif (order != NULL)\n\t\tBN_free(order);\n\tif (tmp_point != NULL) \n\t\tEC_POINT_free(tmp_point);\n\tif (X)\n\t\tBN_clear_free(X);\n\treturn(ret);\n}",
        "func_after": "static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,\n\t\t\t\t\tBIGNUM **kinvp, BIGNUM **rp,\n\t\t\t\t\tconst unsigned char *dgst, int dlen)\n{\n\tBN_CTX   *ctx = NULL;\n\tBIGNUM\t *k = NULL, *r = NULL, *order = NULL, *X = NULL;\n\tEC_POINT *tmp_point=NULL;\n\tconst EC_GROUP *group;\n\tint \t ret = 0;\n\n\tif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\n\tif (ctx_in == NULL) \n\t{\n\t\tif ((ctx = BN_CTX_new()) == NULL)\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t\tctx = ctx_in;\n\n\tk     = BN_new();\t/* this value is later returned in *kinvp */\n\tr     = BN_new();\t/* this value is later returned in *rp    */\n\torder = BN_new();\n\tX     = BN_new();\n\tif (!k || !r || !order || !X)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t}\n\tif ((tmp_point = EC_POINT_new(group)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\tif (!EC_GROUP_get_order(group, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\n#ifdef OPENSSL_FIPS\n\tif (!fips_check_ec_prng(eckey))\n\t\tgoto err;\n#endif\n\t\n\tdo\n\t{\n\t\t/* get random k */\t\n\t\tdo\n#ifndef OPENSSL_NO_SHA512\n\t\t\tif (dgst != NULL)\n\t\t\t{\n\t\t\t\tif (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),\n\t\t\t\t\t\t\t   dgst, dlen, ctx))\n\t\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tif (!BN_rand_range(k, order))\n\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\twhile (BN_is_zero(k));\n\n\t\t/* We do not want timing information to leak the length of k,\n\t\t * so we compute G*k using an equivalent scalar of fixed\n\t\t * bit-length. */\n\n\t\tif (!BN_add(k, k, order)) goto err;\n\t\tif (BN_num_bits(k) <= BN_num_bits(order))\n\t\t\tif (!BN_add(k, k, order)) goto err;\n\n\t\t/* compute r the x-coordinate of generator * k */\n\t\tif (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t}\n\t\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#ifndef OPENSSL_NO_EC2M\n\t\telse /* NID_X9_62_characteristic_two_field */\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GF2m(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!BN_nnmod(r, X, order, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t}\n\t}\n\twhile (BN_is_zero(r));\n\n\t/* compute the inverse of k */\n\tif (EC_GROUP_get_mont_data(group) != NULL)\n\t\t{\n\t\t/* We want inverse in constant time, therefore we utilize the\n\t\t * fact order must be prime and use Fermats Little Theorem\n\t\t * instead. */\n\t\tif (!BN_set_word(X, 2) )\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (!BN_mod_sub(X, order, X, order, ctx))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tBN_set_flags(X, BN_FLG_CONSTTIME);\n\t\tif (!BN_mod_exp_mont_consttime(k, k, X, order, ctx, EC_GROUP_get_mont_data(group)))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tif (!BN_mod_inverse(k, k, order, ctx))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\t\n\t\t\t}\n\t\t}\n\n\t/* clear old values if necessary */\n\tif (*rp != NULL)\n\t\tBN_clear_free(*rp);\n\tif (*kinvp != NULL) \n\t\tBN_clear_free(*kinvp);\n\t/* save the pre-computed values  */\n\t*rp    = r;\n\t*kinvp = k;\n\tret = 1;\nerr:\n\tif (!ret)\n\t{\n\t\tif (k != NULL) BN_clear_free(k);\n\t\tif (r != NULL) BN_clear_free(r);\n\t}\n\tif (ctx_in == NULL) \n\t\tBN_CTX_free(ctx);\n\tif (order != NULL)\n\t\tBN_free(order);\n\tif (tmp_point != NULL) \n\t\tEC_POINT_free(tmp_point);\n\tif (X)\n\t\tBN_clear_free(X);\n\treturn(ret);\n}",
        "description": "A timing attack vulnerability was identified in OpenSSL versions prior to 1.0.1u, enabling a malicious user with local access to potentially recover ECDSA P-256 private keys through the exploitation of timing variations in cryptographic operations.",
        "commit": "The vulnerability knowledge has been abstracted and generalized as follows:\n\n\"The implementation of ECDSA includes an option to utilize BN_mod_exp_mont_consttime, a constant-time modular exponentiation function. This enhancement aims to improve the security of ECDSA operations.\""
    },
    {
        "cwe": "CWE-384",
        "func_name": "debauchee/MainWindow::checkFingerprint",
        "score": 0.6731796264648438,
        "func_before": "void MainWindow__checkFingerprint(const QString& line)\n{\n    QRegExp fingerprintRegex(\".*server fingerprint \\\\(SHA1\\\\): ([A-F0-9:]+) \\\\(SHA256\\\\): ([A-F0-9:]+)\");\n    if (!fingerprintRegex.exactMatch(line)) {\n        return;\n    }\n\n    barrier::FingerprintData fingerprint_sha1 = {\n        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA1),\n        barrier::string::from_hex(fingerprintRegex.cap(1).toStdString())\n    };\n\n    barrier::FingerprintData fingerprint_sha256 = {\n        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA256),\n        barrier::string::from_hex(fingerprintRegex.cap(2).toStdString())\n    };\n\n    auto db_path = barrier::DataDirectories::trusted_servers_ssl_fingerprints_path();\n\n    auto db_dir = db_path.parent_path();\n    if (!barrier::fs::exists(db_dir)) {\n        barrier::fs::create_directories(db_dir);\n    }\n\n    // We compare only SHA256 fingerprints, but show both SHA1 and SHA256 so that the users can\n    // still verify fingerprints on old Barrier servers. This way the only time when we are exposed\n    // to SHA1 vulnerabilities is when the user is reconnecting again.\n    barrier::FingerprintDatabase db;\n    db.read(db_path);\n    if (db.is_trusted(fingerprint_sha256)) {\n        return;\n    }\n\n    static bool messageBoxAlreadyShown = false;\n\n    if (!messageBoxAlreadyShown) {\n        stopBarrier();\n\n        messageBoxAlreadyShown = true;\n        QMessageBox::StandardButton fingerprintReply =\n            QMessageBox::information(\n            this, tr(\"Security question\"),\n            tr(\"Do you trust this fingerprint?\\n\\n\"\n               \"SHA256:\\n\"\n               \"%1\\n\"\n               \"%2\\n\\n\"\n               \"SHA1 (obsolete, when using old Barrier server):\\n\"\n               \"%3\\n\\n\"\n               \"This is a server fingerprint. You should compare this \"\n               \"fingerprint to the one on your server's screen. If the \"\n               \"two don't match exactly, then it's probably not the server \"\n               \"you're expecting (it could be a malicious user).\\n\\n\"\n               \"To automatically trust this fingerprint for future \"\n               \"connections, click Yes. To reject this fingerprint and \"\n               \"disconnect from the server, click No.\")\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))\n            .arg(QString::fromStdString(\n                     barrier::create_fingerprint_randomart(fingerprint_sha256.data)))\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data))),\n            QMessageBox::Yes | QMessageBox::No);\n\n        if (fingerprintReply == QMessageBox::Yes) {\n            // restart core process after trusting fingerprint.\n            db.add_trusted(fingerprint_sha256);\n            db.write(db_path);\n            startBarrier();\n        }\n\n        messageBoxAlreadyShown = false;\n    }\n}",
        "func_after": "void MainWindow__checkFingerprint(const QString& line)\n{\n    QRegExp fingerprintRegex(\".*peer fingerprint \\\\(SHA1\\\\): ([A-F0-9:]+) \\\\(SHA256\\\\): ([A-F0-9:]+)\");\n    if (!fingerprintRegex.exactMatch(line)) {\n        return;\n    }\n\n    barrier::FingerprintData fingerprint_sha1 = {\n        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA1),\n        barrier::string::from_hex(fingerprintRegex.cap(1).toStdString())\n    };\n\n    barrier::FingerprintData fingerprint_sha256 = {\n        barrier::fingerprint_type_to_string(barrier::FingerprintType::SHA256),\n        barrier::string::from_hex(fingerprintRegex.cap(2).toStdString())\n    };\n\n    bool is_client = barrierType() == barrierClient;\n\n    auto db_path = is_client\n            ? barrier::DataDirectories::trusted_servers_ssl_fingerprints_path()\n            : barrier::DataDirectories::trusted_clients_ssl_fingerprints_path();\n\n    auto db_dir = db_path.parent_path();\n    if (!barrier::fs::exists(db_dir)) {\n        barrier::fs::create_directories(db_dir);\n    }\n\n    // We compare only SHA256 fingerprints, but show both SHA1 and SHA256 so that the users can\n    // still verify fingerprints on old Barrier servers. This way the only time when we are exposed\n    // to SHA1 vulnerabilities is when the user is reconnecting again.\n    barrier::FingerprintDatabase db;\n    db.read(db_path);\n    if (db.is_trusted(fingerprint_sha256)) {\n        return;\n    }\n\n    static bool messageBoxAlreadyShown = false;\n\n    if (!messageBoxAlreadyShown) {\n        if (is_client) {\n            stopBarrier();\n        }\n\n        QString message;\n        if (is_client) {\n            message = tr(\"Do you trust this fingerprint?\\n\\n\"\n               \"SHA256:\\n\"\n               \"%1\\n\"\n               \"%2\\n\\n\"\n               \"SHA1 (obsolete, when using old Barrier client):\\n\"\n               \"%3\\n\\n\"\n               \"This is a server fingerprint. You should compare this \"\n               \"fingerprint to the one on your server's screen. If the \"\n               \"two don't match exactly, then it's probably not the server \"\n               \"you're expecting (it could be a malicious user).\\n\\n\"\n               \"To automatically trust this fingerprint for future \"\n               \"connections, click Yes. To reject this fingerprint and \"\n               \"disconnect from the server, click No.\")\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))\n            .arg(QString::fromStdString(\n                     barrier::create_fingerprint_randomart(fingerprint_sha256.data)))\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha1.data)));\n        } else {\n            message = tr(\"Do you trust this fingerprint?\\n\\n\"\n               \"SHA256:\\n\"\n               \"%1\\n\"\n               \"%2\\n\\n\"\n               \"This is a client fingerprint. You should compare this \"\n               \"fingerprint to the one on your client's screen. If the \"\n               \"two don't match exactly, then it's probably not the client \"\n               \"you're expecting (it could be a malicious user).\\n\\n\"\n               \"To automatically trust this fingerprint for future \"\n               \"connections, click Yes. To reject this fingerprint and \"\n               \"disconnect the client, click No.\")\n            .arg(QString::fromStdString(barrier::format_ssl_fingerprint(fingerprint_sha256.data)))\n            .arg(QString::fromStdString(\n                     barrier::create_fingerprint_randomart(fingerprint_sha256.data)));\n        }\n\n        messageBoxAlreadyShown = true;\n        QMessageBox::StandardButton fingerprintReply =\n            QMessageBox::information(\n            this, tr(\"Security question\"),\n            message,\n            QMessageBox::Yes | QMessageBox::No);\n\n        if (fingerprintReply == QMessageBox::Yes) {\n            // restart core process after trusting fingerprint.\n            db.add_trusted(fingerprint_sha256);\n            db.write(db_path);\n            if (is_client) {\n                startBarrier();\n            }\n        }\n\n        messageBoxAlreadyShown = false;\n    }\n}",
        "description": "An issue was discovered in Barrier prior to version 2.4.0. An attacker can gain access to an active session state by providing a client label that corresponds to a valid client configuration. This label defaults to \"Unnamed\" but can potentially be deduced from hostnames or other publicly available information. Once in the active session state, an attacker can intercept input device events from the server and alter the clipboard content on the server.",
        "commit": "This commit addresses two security vulnerabilities, CVE-2021-42072 and CVE-2021-42073, which were reported by Matthias Gerstner. The primary focus of the fix is to implement client identity verification to enhance the security posture of the system."
    },
    {
        "cwe": "CWE-193",
        "func_name": "torvalds/ext4_ext_insert_extent",
        "score": 0.7198252081871033,
        "func_before": "int ext4_ext_insert_extent(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_ext_path *path,\n\t\t\t\tstruct ext4_extent *newext, int flag)\n{\n\tstruct ext4_extent_header *eh;\n\tstruct ext4_extent *ex, *fex;\n\tstruct ext4_extent *nearex; /* nearest extent */\n\tstruct ext4_ext_path *npath = NULL;\n\tint depth, len, err;\n\text4_lblk_t next;\n\tunsigned uninitialized = 0;\n\tint flags = 0;\n\n\tif (unlikely(ext4_ext_get_actual_len(newext) == 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"ext4_ext_get_actual_len(newext) == 0\");\n\t\treturn -EIO;\n\t}\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tif (unlikely(path[depth].p_hdr == NULL)) {\n\t\tEXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);\n\t\treturn -EIO;\n\t}\n\n\t/* try to insert block into found extent and return */\n\tif (ex && !(flag & EXT4_GET_BLOCKS_PRE_IO)\n\t\t&& ext4_can_extents_be_merged(inode, ex, newext)) {\n\t\text_debug(\"append [%d]%d block to %d:[%d]%d (from %llu)\\n\",\n\t\t\t  ext4_ext_is_uninitialized(newext),\n\t\t\t  ext4_ext_get_actual_len(newext),\n\t\t\t  le32_to_cpu(ex->ee_block),\n\t\t\t  ext4_ext_is_uninitialized(ex),\n\t\t\t  ext4_ext_get_actual_len(ex),\n\t\t\t  ext4_ext_pblock(ex));\n\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t/*\n\t\t * ext4_can_extents_be_merged should have checked that either\n\t\t * both extents are uninitialized, or both aren't. Thus we\n\t\t * need to check only one of them here.\n\t\t */\n\t\tif (ext4_ext_is_uninitialized(ex))\n\t\t\tuninitialized = 1;\n\t\tex->ee_len = cpu_to_le16(ext4_ext_get_actual_len(ex)\n\t\t\t\t\t+ ext4_ext_get_actual_len(newext));\n\t\tif (uninitialized)\n\t\t\text4_ext_mark_uninitialized(ex);\n\t\teh = path[depth].p_hdr;\n\t\tnearex = ex;\n\t\tgoto merge;\n\t}\n\nrepeat:\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max))\n\t\tgoto has_space;\n\n\t/* probably next leaf has space for us? */\n\tfex = EXT_LAST_EXTENT(eh);\n\tnext = ext4_ext_next_leaf_block(inode, path);\n\tif (le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block)\n\t    && next != EXT_MAX_BLOCK) {\n\t\text_debug(\"next leaf block - %d\\n\", next);\n\t\tBUG_ON(npath != NULL);\n\t\tnpath = ext4_ext_find_extent(inode, next, NULL);\n\t\tif (IS_ERR(npath))\n\t\t\treturn PTR_ERR(npath);\n\t\tBUG_ON(npath->p_depth != path->p_depth);\n\t\teh = npath[depth].p_hdr;\n\t\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)) {\n\t\t\text_debug(\"next leaf isn't full(%d)\\n\",\n\t\t\t\t  le16_to_cpu(eh->eh_entries));\n\t\t\tpath = npath;\n\t\t\tgoto repeat;\n\t\t}\n\t\text_debug(\"next leaf has no free space(%d,%d)\\n\",\n\t\t\t  le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\n\t}\n\n\t/*\n\t * There is no free space in the found leaf.\n\t * We're gonna add a new leaf in the tree.\n\t */\n\tif (flag & EXT4_GET_BLOCKS_PUNCH_OUT_EXT)\n\t\tflags = EXT4_MB_USE_ROOT_BLOCKS;\n\terr = ext4_ext_create_new_leaf(handle, inode, flags, path, newext);\n\tif (err)\n\t\tgoto cleanup;\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\nhas_space:\n\tnearex = path[depth].p_ext;\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (!nearex) {\n\t\t/* there is no extent in this leaf, create first one */\n\t\text_debug(\"first extent in the leaf: %d:%llu:[%d]%d\\n\",\n\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\text4_ext_pblock(newext),\n\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\text4_ext_get_actual_len(newext));\n\t\tpath[depth].p_ext = EXT_FIRST_EXTENT(eh);\n\t} else if (le32_to_cpu(newext->ee_block)\n\t\t\t   > le32_to_cpu(nearex->ee_block)) {\n/*\t\tBUG_ON(newext->ee_block == nearex->ee_block); */\n\t\tif (nearex != EXT_LAST_EXTENT(eh)) {\n\t\t\tlen = EXT_MAX_EXTENT(eh) - nearex;\n\t\t\tlen = (len - 1) * sizeof(struct ext4_extent);\n\t\t\tlen = len < 0 ? 0 : len;\n\t\t\text_debug(\"insert %d:%llu:[%d]%d after: nearest 0x%p, \"\n\t\t\t\t\t\"move %d from 0x%p to 0x%p\\n\",\n\t\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\t\text4_ext_pblock(newext),\n\t\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\t\tnearex, len, nearex + 1, nearex + 2);\n\t\t\tmemmove(nearex + 2, nearex + 1, len);\n\t\t}\n\t\tpath[depth].p_ext = nearex + 1;\n\t} else {\n\t\tBUG_ON(newext->ee_block == nearex->ee_block);\n\t\tlen = (EXT_MAX_EXTENT(eh) - nearex) * sizeof(struct ext4_extent);\n\t\tlen = len < 0 ? 0 : len;\n\t\text_debug(\"insert %d:%llu:[%d]%d before: nearest 0x%p, \"\n\t\t\t\t\"move %d from 0x%p to 0x%p\\n\",\n\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\text4_ext_pblock(newext),\n\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\tnearex, len, nearex + 1, nearex + 2);\n\t\tmemmove(nearex + 1, nearex, len);\n\t\tpath[depth].p_ext = nearex;\n\t}\n\n\tle16_add_cpu(&eh->eh_entries, 1);\n\tnearex = path[depth].p_ext;\n\tnearex->ee_block = newext->ee_block;\n\text4_ext_store_pblock(nearex, ext4_ext_pblock(newext));\n\tnearex->ee_len = newext->ee_len;\n\nmerge:\n\t/* try to merge extents to the right */\n\tif (!(flag & EXT4_GET_BLOCKS_PRE_IO))\n\t\text4_ext_try_to_merge(inode, path, nearex);\n\n\t/* try to merge extents to the left */\n\n\t/* time to correct all indexes above */\n\terr = ext4_ext_correct_indexes(handle, inode, path);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = ext4_ext_dirty(handle, inode, path + depth);\n\ncleanup:\n\tif (npath) {\n\t\text4_ext_drop_refs(npath);\n\t\tkfree(npath);\n\t}\n\text4_ext_invalidate_cache(inode);\n\treturn err;\n}",
        "func_after": "int ext4_ext_insert_extent(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_ext_path *path,\n\t\t\t\tstruct ext4_extent *newext, int flag)\n{\n\tstruct ext4_extent_header *eh;\n\tstruct ext4_extent *ex, *fex;\n\tstruct ext4_extent *nearex; /* nearest extent */\n\tstruct ext4_ext_path *npath = NULL;\n\tint depth, len, err;\n\text4_lblk_t next;\n\tunsigned uninitialized = 0;\n\tint flags = 0;\n\n\tif (unlikely(ext4_ext_get_actual_len(newext) == 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"ext4_ext_get_actual_len(newext) == 0\");\n\t\treturn -EIO;\n\t}\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tif (unlikely(path[depth].p_hdr == NULL)) {\n\t\tEXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);\n\t\treturn -EIO;\n\t}\n\n\t/* try to insert block into found extent and return */\n\tif (ex && !(flag & EXT4_GET_BLOCKS_PRE_IO)\n\t\t&& ext4_can_extents_be_merged(inode, ex, newext)) {\n\t\text_debug(\"append [%d]%d block to %d:[%d]%d (from %llu)\\n\",\n\t\t\t  ext4_ext_is_uninitialized(newext),\n\t\t\t  ext4_ext_get_actual_len(newext),\n\t\t\t  le32_to_cpu(ex->ee_block),\n\t\t\t  ext4_ext_is_uninitialized(ex),\n\t\t\t  ext4_ext_get_actual_len(ex),\n\t\t\t  ext4_ext_pblock(ex));\n\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t/*\n\t\t * ext4_can_extents_be_merged should have checked that either\n\t\t * both extents are uninitialized, or both aren't. Thus we\n\t\t * need to check only one of them here.\n\t\t */\n\t\tif (ext4_ext_is_uninitialized(ex))\n\t\t\tuninitialized = 1;\n\t\tex->ee_len = cpu_to_le16(ext4_ext_get_actual_len(ex)\n\t\t\t\t\t+ ext4_ext_get_actual_len(newext));\n\t\tif (uninitialized)\n\t\t\text4_ext_mark_uninitialized(ex);\n\t\teh = path[depth].p_hdr;\n\t\tnearex = ex;\n\t\tgoto merge;\n\t}\n\nrepeat:\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max))\n\t\tgoto has_space;\n\n\t/* probably next leaf has space for us? */\n\tfex = EXT_LAST_EXTENT(eh);\n\tnext = ext4_ext_next_leaf_block(inode, path);\n\tif (le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block)\n\t    && next != EXT_MAX_BLOCKS) {\n\t\text_debug(\"next leaf block - %d\\n\", next);\n\t\tBUG_ON(npath != NULL);\n\t\tnpath = ext4_ext_find_extent(inode, next, NULL);\n\t\tif (IS_ERR(npath))\n\t\t\treturn PTR_ERR(npath);\n\t\tBUG_ON(npath->p_depth != path->p_depth);\n\t\teh = npath[depth].p_hdr;\n\t\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)) {\n\t\t\text_debug(\"next leaf isn't full(%d)\\n\",\n\t\t\t\t  le16_to_cpu(eh->eh_entries));\n\t\t\tpath = npath;\n\t\t\tgoto repeat;\n\t\t}\n\t\text_debug(\"next leaf has no free space(%d,%d)\\n\",\n\t\t\t  le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\n\t}\n\n\t/*\n\t * There is no free space in the found leaf.\n\t * We're gonna add a new leaf in the tree.\n\t */\n\tif (flag & EXT4_GET_BLOCKS_PUNCH_OUT_EXT)\n\t\tflags = EXT4_MB_USE_ROOT_BLOCKS;\n\terr = ext4_ext_create_new_leaf(handle, inode, flags, path, newext);\n\tif (err)\n\t\tgoto cleanup;\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\nhas_space:\n\tnearex = path[depth].p_ext;\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (!nearex) {\n\t\t/* there is no extent in this leaf, create first one */\n\t\text_debug(\"first extent in the leaf: %d:%llu:[%d]%d\\n\",\n\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\text4_ext_pblock(newext),\n\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\text4_ext_get_actual_len(newext));\n\t\tpath[depth].p_ext = EXT_FIRST_EXTENT(eh);\n\t} else if (le32_to_cpu(newext->ee_block)\n\t\t\t   > le32_to_cpu(nearex->ee_block)) {\n/*\t\tBUG_ON(newext->ee_block == nearex->ee_block); */\n\t\tif (nearex != EXT_LAST_EXTENT(eh)) {\n\t\t\tlen = EXT_MAX_EXTENT(eh) - nearex;\n\t\t\tlen = (len - 1) * sizeof(struct ext4_extent);\n\t\t\tlen = len < 0 ? 0 : len;\n\t\t\text_debug(\"insert %d:%llu:[%d]%d after: nearest 0x%p, \"\n\t\t\t\t\t\"move %d from 0x%p to 0x%p\\n\",\n\t\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\t\text4_ext_pblock(newext),\n\t\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\t\tnearex, len, nearex + 1, nearex + 2);\n\t\t\tmemmove(nearex + 2, nearex + 1, len);\n\t\t}\n\t\tpath[depth].p_ext = nearex + 1;\n\t} else {\n\t\tBUG_ON(newext->ee_block == nearex->ee_block);\n\t\tlen = (EXT_MAX_EXTENT(eh) - nearex) * sizeof(struct ext4_extent);\n\t\tlen = len < 0 ? 0 : len;\n\t\text_debug(\"insert %d:%llu:[%d]%d before: nearest 0x%p, \"\n\t\t\t\t\"move %d from 0x%p to 0x%p\\n\",\n\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\text4_ext_pblock(newext),\n\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\tnearex, len, nearex + 1, nearex + 2);\n\t\tmemmove(nearex + 1, nearex, len);\n\t\tpath[depth].p_ext = nearex;\n\t}\n\n\tle16_add_cpu(&eh->eh_entries, 1);\n\tnearex = path[depth].p_ext;\n\tnearex->ee_block = newext->ee_block;\n\text4_ext_store_pblock(nearex, ext4_ext_pblock(newext));\n\tnearex->ee_len = newext->ee_len;\n\nmerge:\n\t/* try to merge extents to the right */\n\tif (!(flag & EXT4_GET_BLOCKS_PRE_IO))\n\t\text4_ext_try_to_merge(inode, path, nearex);\n\n\t/* try to merge extents to the left */\n\n\t/* time to correct all indexes above */\n\terr = ext4_ext_correct_indexes(handle, inode, path);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = ext4_ext_dirty(handle, inode, path + depth);\n\ncleanup:\n\tif (npath) {\n\t\text4_ext_drop_refs(npath);\n\t\tkfree(npath);\n\t}\n\text4_ext_invalidate_cache(inode);\n\treturn err;\n}",
        "description": "Multiple off-by-one errors in the ext4 subsystem of the Linux kernel, prior to a specific release candidate, enable local users to trigger a denial of service (resulting in BUG_ON and system crashes) through write operations on sparse files in extent format, particularly when the block number corresponds to the maximum possible 32-bit unsigned integer.",
        "commit": "A vulnerability was identified in the ext4 file system where writing to the last block (2^32-1) of a sparse file in extent format triggers a BUG_ON condition in the ext4_ext_put_gap_in_cache() function. The root cause is that the maximum bytes (s_maxbytes) are set such that the block at s_maxbytes fits into a 32-bit on-disk extent format, but the extent structure stores start block number and length in blocks, requiring EXT_MAX_BLOCK + 1 to cover the entire extent range. To resolve this issue without altering the struct ext4_extent members' meanings, s_maxbytes should be reduced by one filesystem block. Additionally, the commit renames EXT_MAX_BLOCK to EXT_MAX_BLOCKS and adjusts its usage to represent the maximum number of blocks in an extent, addressing inconsistencies in its application throughout the codebase. This bug can be reproduced by sequentially writing to the second-to-last and last blocks of a sparse file using the dd command."
    },
    {
        "cwe": "CWE-672",
        "func_name": "torvalds/get_gate_page",
        "score": 0.7042062878608704,
        "func_before": "static int get_gate_page(struct mm_struct *mm, unsigned long address,\n\t\tunsigned int gup_flags, struct vm_area_struct **vma,\n\t\tstruct page **page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tint ret = -EFAULT;\n\n\t/* user gate pages are read-only */\n\tif (gup_flags & FOLL_WRITE)\n\t\treturn -EFAULT;\n\tif (address > TASK_SIZE)\n\t\tpgd = pgd_offset_k(address);\n\telse\n\t\tpgd = pgd_offset_gate(mm, address);\n\tif (pgd_none(*pgd))\n\t\treturn -EFAULT;\n\tp4d = p4d_offset(pgd, address);\n\tif (p4d_none(*p4d))\n\t\treturn -EFAULT;\n\tpud = pud_offset(p4d, address);\n\tif (pud_none(*pud))\n\t\treturn -EFAULT;\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn -EFAULT;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tpte = pte_offset_map(pmd, address);\n\tif (pte_none(*pte))\n\t\tgoto unmap;\n\t*vma = get_gate_vma(mm);\n\tif (!page)\n\t\tgoto out;\n\t*page = vm_normal_page(*vma, address, *pte);\n\tif (!*page) {\n\t\tif ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte)))\n\t\t\tgoto unmap;\n\t\t*page = pte_page(*pte);\n\t}\n\tif (unlikely(!try_get_page(*page))) {\n\t\tret = -ENOMEM;\n\t\tgoto unmap;\n\t}\nout:\n\tret = 0;\nunmap:\n\tpte_unmap(pte);\n\treturn ret;\n}",
        "func_after": "static int get_gate_page(struct mm_struct *mm, unsigned long address,\n\t\tunsigned int gup_flags, struct vm_area_struct **vma,\n\t\tstruct page **page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tint ret = -EFAULT;\n\n\t/* user gate pages are read-only */\n\tif (gup_flags & FOLL_WRITE)\n\t\treturn -EFAULT;\n\tif (address > TASK_SIZE)\n\t\tpgd = pgd_offset_k(address);\n\telse\n\t\tpgd = pgd_offset_gate(mm, address);\n\tif (pgd_none(*pgd))\n\t\treturn -EFAULT;\n\tp4d = p4d_offset(pgd, address);\n\tif (p4d_none(*p4d))\n\t\treturn -EFAULT;\n\tpud = pud_offset(p4d, address);\n\tif (pud_none(*pud))\n\t\treturn -EFAULT;\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn -EFAULT;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tpte = pte_offset_map(pmd, address);\n\tif (pte_none(*pte))\n\t\tgoto unmap;\n\t*vma = get_gate_vma(mm);\n\tif (!page)\n\t\tgoto out;\n\t*page = vm_normal_page(*vma, address, *pte);\n\tif (!*page) {\n\t\tif ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte)))\n\t\t\tgoto unmap;\n\t\t*page = pte_page(*pte);\n\t}\n\tif (unlikely(!try_grab_page(*page, gup_flags))) {\n\t\tret = -ENOMEM;\n\t\tgoto unmap;\n\t}\nout:\n\tret = 0;\nunmap:\n\tpte_unmap(pte);\n\treturn ret;\n}",
        "description": "\"In the Linux kernel versions 5.7.x and 5.8.x prior to 5.8.7, a privilege escalation vulnerability exists due to incorrect reference counting of the struct page backing the vsyscall page, resulting in a refcount underflow. This issue can be exploited by any 64-bit process that has access to ptrace() or process_vm_readv() functions.\"",
        "commit": "It was discovered that gate pages were overlooked during the conversion from `get` to `pin_user_pages()`, leading to reference count imbalances. This issue can be reliably reproduced by running the x86 selftests with `vsyscall=emulate` enabled (the default setting). The problem arises because `pin_user_pages()` uses a \"bias\" value, manipulating the reference count by 1024 instead of 1, which is used by `get_user_pages()`. Gate pages, such as the vsyscall page, are typically part of the kernel image but are mapped to userspace, allowing access through interfaces using `get/pin_user_pages()`. The reference count of these kernel pages is adjusted similarly to normal user pages on the get/pin side to ensure consistency on the put/unpin side. However, `get_gate_page()` uses `try_get_page()`, which increments the reference count by 1, not 1024, even when called in the `pin_user_pages()` path. This results in a reference count discrepancy of 1023 when `unpin_user_pages()` is eventually called. The fix involves using `try_grab_page()` instead of `try_get_page()` and passing the appropriate flags to respect `FOLL_PIN`. This bug has been present since the introduction of `FOLL_PIN` support in commit 3faa52c03f44, which first appeared in the 5.7 release."
    }
]