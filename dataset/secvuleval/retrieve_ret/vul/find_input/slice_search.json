[
    {
        "cwe": "CWE-416",
        "func_name": "torvalds/ipt_do_table",
        "score": 0.7893100380897522,
        "func_before": "unsigned int\nipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private); /* Address dependency. */\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
        "func_after": "unsigned int\nipt_do_table(struct sk_buff *skb,\n\t     const struct nf_hook_state *state,\n\t     struct xt_table *table)\n{\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tconst struct iphdr *ip;\n\t/* Initializing verdict to NF_DROP keeps gcc happy. */\n\tunsigned int verdict = NF_DROP;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tstruct ipt_entry *e, **jumpstack;\n\tunsigned int stackidx, cpu;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\t/* Initialization */\n\tstackidx = 0;\n\tip = ip_hdr(skb);\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\t/* We handle fragments by dealing with the first fragment as\n\t * if it was a normal packet.  All other fragments are treated\n\t * normally, except that they will NEVER match rules that ask\n\t * things we don't know, ie. tcp syn flag or ports).  If the\n\t * rule is also a fragment-specific rule, non-fragments won't\n\t * match it. */\n\tacpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;\n\tacpar.thoff   = ip_hdrlen(skb);\n\tacpar.hotdrop = false;\n\tacpar.state   = state;\n\n\tWARN_ON(!(table->valid_hooks & (1 << hook)));\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = rcu_access_pointer(table->private);\n\tcpu        = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct ipt_entry **)private->jumpstack[cpu];\n\n\t/* Switch to alternate jumpstack if we're being invoked via TEE.\n\t * TEE issues XT_CONTINUE verdict on original skb so we must not\n\t * clobber the jumpstack.\n\t *\n\t * For recursion via REJECT or SYNPROXY the stack will be clobbered\n\t * but it is no problem since absolute verdict is issued by these.\n\t */\n\tif (static_key_false(&xt_tee_enabled))\n\t\tjumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);\n\n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tconst struct xt_entry_match *ematch;\n\t\tstruct xt_counters *counter;\n\n\t\tWARN_ON(!e);\n\t\tif (!ip_packet_match(ip, indev, outdev,\n\t\t    &e->ip, acpar.fragoff)) {\n no_match:\n\t\t\te = ipt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\txt_ematch_foreach(ematch, e) {\n\t\t\tacpar.match     = ematch->u.kernel.match;\n\t\t\tacpar.matchinfo = ematch->data;\n\t\t\tif (!acpar.match->match(skb, &acpar))\n\t\t\t\tgoto no_match;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, skb->len, 1);\n\n\t\tt = ipt_get_target_c(e);\n\t\tWARN_ON(!t->u.kernel.target);\n\n#if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)\n\t\t/* The packet is traced: log it */\n\t\tif (unlikely(skb->nf_trace))\n\t\t\ttrace_packet(state->net, skb, hook, state->in,\n\t\t\t\t     state->out, table->name, private, e);\n#endif\n\t\t/* Standard target? */\n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t/* Pop from stack? */\n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t    private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = ipt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v != ipt_next_entry(e) &&\n\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t/* Target might have changed stuff. */\n\t\t\tip = ip_hdr(skb);\n\t\t\te = ipt_next_entry(e);\n\t\t} else {\n\t\t\t/* Verdict */\n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse return verdict;\n}",
        "description": "An issue was discovered in the netfilter component of the Linux kernel prior to version 5.10. This vulnerability involves a use-after-free condition in the packet processing context due to improper handling of per-CPU sequence counts during concurrent iptables rule replacements. This flaw could be exploited by users with the CAP_NET_ADMIN capability in an unprivileged namespace.",
        "commit": "When performing concurrent iptables rules replacement, the system checks the per-CPU sequence count after assigning new information. This sequence count is intended to synchronize with the packet path without using explicit locking. If packets are currently using the old table information, the sequence count is incremented to an odd value and then to an even value after processing. After assigning the new table information, a write memory barrier is executed to ensure all CPUs see the latest value. If the packet path starts with the old table information, the sequence counter remains odd, and the iptables replacement waits until the sequence count is even before freeing the old table information. However, if the CPU delays executing the new table information assignment and memory barrier, another CPU's packet path may still use the old table information. This delay can lead to a use-after-free error in the packet processing context, resulting in a kernel NULL pointer dereference. To fix this issue, either enforce instruction ordering after the new table information assignment or switch to RCU for synchronization."
    },
    {
        "cwe": "CWE-94",
        "func_name": "binutils-gdb/setup_group",
        "score": 0.7701159715652466,
        "func_before": "static bfd_boolean\nsetup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)\n{\n  unsigned int num_group = elf_tdata (abfd)->num_group;\n\n  /* If num_group is zero, read in all SHT_GROUP sections.  The count\n     is set to -1 if there are no SHT_GROUP sections.  */\n  if (num_group == 0)\n    {\n      unsigned int i, shnum;\n\n      /* First count the number of groups.  If we have a SHT_GROUP\n\t section with just a flag word (ie. sh_size is 4), ignore it.  */\n      shnum = elf_numsections (abfd);\n      num_group = 0;\n\n#define IS_VALID_GROUP_SECTION_HEADER(shdr, minsize)\t\\\n\t(   (shdr)->sh_type == SHT_GROUP\t\t\\\n\t && (shdr)->sh_size >= minsize\t\t\t\\\n\t && (shdr)->sh_entsize == GRP_ENTRY_SIZE\t\\\n\t && ((shdr)->sh_size % GRP_ENTRY_SIZE) == 0)\n\n      for (i = 0; i < shnum; i++)\n\t{\n\t  Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];\n\n\t  if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))\n\t    num_group += 1;\n\t}\n\n      if (num_group == 0)\n\t{\n\t  num_group = (unsigned) -1;\n\t  elf_tdata (abfd)->num_group = num_group;\n\t}\n      else\n\t{\n\t  /* We keep a list of elf section headers for group sections,\n\t     so we can find them quickly.  */\n\t  bfd_size_type amt;\n\n\t  elf_tdata (abfd)->num_group = num_group;\n\t  elf_tdata (abfd)->group_sect_ptr = (Elf_Internal_Shdr **)\n              bfd_alloc2 (abfd, num_group, sizeof (Elf_Internal_Shdr *));\n\t  if (elf_tdata (abfd)->group_sect_ptr == NULL)\n\t    return FALSE;\n\n\t  num_group = 0;\n\t  for (i = 0; i < shnum; i++)\n\t    {\n\t      Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];\n\n\t      if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))\n\t\t{\n\t\t  unsigned char *src;\n\t\t  Elf_Internal_Group *dest;\n\n\t\t  /* Add to list of sections.  */\n\t\t  elf_tdata (abfd)->group_sect_ptr[num_group] = shdr;\n\t\t  num_group += 1;\n\n\t\t  /* Read the raw contents.  */\n\t\t  BFD_ASSERT (sizeof (*dest) >= 4);\n\t\t  amt = shdr->sh_size * sizeof (*dest) / 4;\n\t\t  shdr->contents = (unsigned char *)\n                      bfd_alloc2 (abfd, shdr->sh_size, sizeof (*dest) / 4);\n\t\t  /* PR binutils/4110: Handle corrupt group headers.  */\n\t\t  if (shdr->contents == NULL)\n\t\t    {\n\t\t      _bfd_error_handler\n\t\t\t(_(\"%B: Corrupt size field in group section header: 0x%lx\"), abfd, shdr->sh_size);\n\t\t      bfd_set_error (bfd_error_bad_value);\n\t\t      return FALSE;\n\t\t    }\n\n\t\t  memset (shdr->contents, 0, amt);\n\n\t\t  if (bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0\n\t\t      || (bfd_bread (shdr->contents, shdr->sh_size, abfd)\n\t\t\t  != shdr->sh_size))\n\t\t    return FALSE;\n\n\t\t  /* Translate raw contents, a flag word followed by an\n\t\t     array of elf section indices all in target byte order,\n\t\t     to the flag word followed by an array of elf section\n\t\t     pointers.  */\n\t\t  src = shdr->contents + shdr->sh_size;\n\t\t  dest = (Elf_Internal_Group *) (shdr->contents + amt);\n\t\t  while (1)\n\t\t    {\n\t\t      unsigned int idx;\n\n\t\t      src -= 4;\n\t\t      --dest;\n\t\t      idx = H_GET_32 (abfd, src);\n\t\t      if (src == shdr->contents)\n\t\t\t{\n\t\t\t  dest->flags = idx;\n\t\t\t  if (shdr->bfd_section != NULL && (idx & GRP_COMDAT))\n\t\t\t    shdr->bfd_section->flags\n\t\t\t      |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;\n\t\t\t  break;\n\t\t\t}\n\t\t      if (idx >= shnum)\n\t\t\t{\n\t\t\t  ((*_bfd_error_handler)\n\t\t\t   (_(\"%B: invalid SHT_GROUP entry\"), abfd));\n\t\t\t  idx = 0;\n\t\t\t}\n\t\t      dest->shdr = elf_elfsections (abfd)[idx];\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n  if (num_group != (unsigned) -1)\n    {\n      unsigned int i;\n\n      for (i = 0; i < num_group; i++)\n\t{\n\t  Elf_Internal_Shdr *shdr = elf_tdata (abfd)->group_sect_ptr[i];\n\t  Elf_Internal_Group *idx = (Elf_Internal_Group *) shdr->contents;\n\t  unsigned int n_elt = shdr->sh_size / 4;\n\n\t  /* Look through this group's sections to see if current\n\t     section is a member.  */\n\t  while (--n_elt != 0)\n\t    if ((++idx)->shdr == hdr)\n\t      {\n\t\tasection *s = NULL;\n\n\t\t/* We are a member of this group.  Go looking through\n\t\t   other members to see if any others are linked via\n\t\t   next_in_group.  */\n\t\tidx = (Elf_Internal_Group *) shdr->contents;\n\t\tn_elt = shdr->sh_size / 4;\n\t\twhile (--n_elt != 0)\n\t\t  if ((s = (++idx)->shdr->bfd_section) != NULL\n\t\t      && elf_next_in_group (s) != NULL)\n\t\t    break;\n\t\tif (n_elt != 0)\n\t\t  {\n\t\t    /* Snarf the group name from other member, and\n\t\t       insert current section in circular list.  */\n\t\t    elf_group_name (newsect) = elf_group_name (s);\n\t\t    elf_next_in_group (newsect) = elf_next_in_group (s);\n\t\t    elf_next_in_group (s) = newsect;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    const char *gname;\n\n\t\t    gname = group_signature (abfd, shdr);\n\t\t    if (gname == NULL)\n\t\t      return FALSE;\n\t\t    elf_group_name (newsect) = gname;\n\n\t\t    /* Start a circular list with one element.  */\n\t\t    elf_next_in_group (newsect) = newsect;\n\t\t  }\n\n\t\t/* If the group section has been created, point to the\n\t\t   new member.  */\n\t\tif (shdr->bfd_section != NULL)\n\t\t  elf_next_in_group (shdr->bfd_section) = newsect;\n\n\t\ti = num_group - 1;\n\t\tbreak;\n\t      }\n\t}\n    }\n\n  if (elf_group_name (newsect) == NULL)\n    {\n      (*_bfd_error_handler) (_(\"%B: no group info for section %A\"),\n\t\t\t     abfd, newsect);\n    }\n  return TRUE;\n}",
        "func_after": "static bfd_boolean\nsetup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)\n{\n  unsigned int num_group = elf_tdata (abfd)->num_group;\n\n  /* If num_group is zero, read in all SHT_GROUP sections.  The count\n     is set to -1 if there are no SHT_GROUP sections.  */\n  if (num_group == 0)\n    {\n      unsigned int i, shnum;\n\n      /* First count the number of groups.  If we have a SHT_GROUP\n\t section with just a flag word (ie. sh_size is 4), ignore it.  */\n      shnum = elf_numsections (abfd);\n      num_group = 0;\n\n#define IS_VALID_GROUP_SECTION_HEADER(shdr, minsize)\t\\\n\t(   (shdr)->sh_type == SHT_GROUP\t\t\\\n\t && (shdr)->sh_size >= minsize\t\t\t\\\n\t && (shdr)->sh_entsize == GRP_ENTRY_SIZE\t\\\n\t && ((shdr)->sh_size % GRP_ENTRY_SIZE) == 0)\n\n      for (i = 0; i < shnum; i++)\n\t{\n\t  Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];\n\n\t  if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))\n\t    num_group += 1;\n\t}\n\n      if (num_group == 0)\n\t{\n\t  num_group = (unsigned) -1;\n\t  elf_tdata (abfd)->num_group = num_group;\n\t}\n      else\n\t{\n\t  /* We keep a list of elf section headers for group sections,\n\t     so we can find them quickly.  */\n\t  bfd_size_type amt;\n\n\t  elf_tdata (abfd)->num_group = num_group;\n\t  elf_tdata (abfd)->group_sect_ptr = (Elf_Internal_Shdr **)\n              bfd_alloc2 (abfd, num_group, sizeof (Elf_Internal_Shdr *));\n\t  if (elf_tdata (abfd)->group_sect_ptr == NULL)\n\t    return FALSE;\n\n\t  num_group = 0;\n\t  for (i = 0; i < shnum; i++)\n\t    {\n\t      Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];\n\n\t      if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))\n\t\t{\n\t\t  unsigned char *src;\n\t\t  Elf_Internal_Group *dest;\n\n\t\t  /* Add to list of sections.  */\n\t\t  elf_tdata (abfd)->group_sect_ptr[num_group] = shdr;\n\t\t  num_group += 1;\n\n\t\t  /* Read the raw contents.  */\n\t\t  BFD_ASSERT (sizeof (*dest) >= 4);\n\t\t  amt = shdr->sh_size * sizeof (*dest) / 4;\n\t\t  shdr->contents = (unsigned char *)\n                      bfd_alloc2 (abfd, shdr->sh_size, sizeof (*dest) / 4);\n\t\t  /* PR binutils/4110: Handle corrupt group headers.  */\n\t\t  if (shdr->contents == NULL)\n\t\t    {\n\t\t      _bfd_error_handler\n\t\t\t(_(\"%B: corrupt size field in group section header: 0x%lx\"), abfd, shdr->sh_size);\n\t\t      bfd_set_error (bfd_error_bad_value);\n\t\t      -- num_group;\n\t\t      continue;\n\t\t    }\n\n\t\t  memset (shdr->contents, 0, amt);\n\n\t\t  if (bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0\n\t\t      || (bfd_bread (shdr->contents, shdr->sh_size, abfd)\n\t\t\t  != shdr->sh_size))\n\t\t    {\n\t\t      _bfd_error_handler\n\t\t\t(_(\"%B: invalid size field in group section header: 0x%lx\"), abfd, shdr->sh_size);\n\t\t      bfd_set_error (bfd_error_bad_value);\n\t\t      -- num_group;\n\t\t      /* PR 17510: If the group contents are even partially\n\t\t\t corrupt, do not allow any of the contents to be used.  */\n\t\t      memset (shdr->contents, 0, amt);\n\t\t      continue;\n\t\t    }\n\t\t  \n\t\t  /* Translate raw contents, a flag word followed by an\n\t\t     array of elf section indices all in target byte order,\n\t\t     to the flag word followed by an array of elf section\n\t\t     pointers.  */\n\t\t  src = shdr->contents + shdr->sh_size;\n\t\t  dest = (Elf_Internal_Group *) (shdr->contents + amt);\n\t\t  while (1)\n\t\t    {\n\t\t      unsigned int idx;\n\n\t\t      src -= 4;\n\t\t      --dest;\n\t\t      idx = H_GET_32 (abfd, src);\n\t\t      if (src == shdr->contents)\n\t\t\t{\n\t\t\t  dest->flags = idx;\n\t\t\t  if (shdr->bfd_section != NULL && (idx & GRP_COMDAT))\n\t\t\t    shdr->bfd_section->flags\n\t\t\t      |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;\n\t\t\t  break;\n\t\t\t}\n\t\t      if (idx >= shnum)\n\t\t\t{\n\t\t\t  ((*_bfd_error_handler)\n\t\t\t   (_(\"%B: invalid SHT_GROUP entry\"), abfd));\n\t\t\t  idx = 0;\n\t\t\t}\n\t\t      dest->shdr = elf_elfsections (abfd)[idx];\n\t\t    }\n\t\t}\n\t    }\n\n\t  /* PR 17510: Corrupt binaries might contain invalid groups.  */\n\t  if (num_group != (unsigned) elf_tdata (abfd)->num_group)\n\t    {\n\t      elf_tdata (abfd)->num_group = num_group;\n\n\t      /* If all groups are invalid then fail.  */\n\t      if (num_group == 0)\n\t\t{\n\t\t  elf_tdata (abfd)->group_sect_ptr = NULL;\n\t\t  elf_tdata (abfd)->num_group = num_group = -1;\n\t\t  (*_bfd_error_handler) (_(\"%B: no valid group sections found\"), abfd);\n\t\t  bfd_set_error (bfd_error_bad_value);\n\t\t}\n\t    }\n\t}\n    }\n\n  if (num_group != (unsigned) -1)\n    {\n      unsigned int i;\n\n      for (i = 0; i < num_group; i++)\n\t{\n\t  Elf_Internal_Shdr *shdr = elf_tdata (abfd)->group_sect_ptr[i];\n\t  Elf_Internal_Group *idx = (Elf_Internal_Group *) shdr->contents;\n\t  unsigned int n_elt = shdr->sh_size / 4;\n\n\t  /* Look through this group's sections to see if current\n\t     section is a member.  */\n\t  while (--n_elt != 0)\n\t    if ((++idx)->shdr == hdr)\n\t      {\n\t\tasection *s = NULL;\n\n\t\t/* We are a member of this group.  Go looking through\n\t\t   other members to see if any others are linked via\n\t\t   next_in_group.  */\n\t\tidx = (Elf_Internal_Group *) shdr->contents;\n\t\tn_elt = shdr->sh_size / 4;\n\t\twhile (--n_elt != 0)\n\t\t  if ((s = (++idx)->shdr->bfd_section) != NULL\n\t\t      && elf_next_in_group (s) != NULL)\n\t\t    break;\n\t\tif (n_elt != 0)\n\t\t  {\n\t\t    /* Snarf the group name from other member, and\n\t\t       insert current section in circular list.  */\n\t\t    elf_group_name (newsect) = elf_group_name (s);\n\t\t    elf_next_in_group (newsect) = elf_next_in_group (s);\n\t\t    elf_next_in_group (s) = newsect;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    const char *gname;\n\n\t\t    gname = group_signature (abfd, shdr);\n\t\t    if (gname == NULL)\n\t\t      return FALSE;\n\t\t    elf_group_name (newsect) = gname;\n\n\t\t    /* Start a circular list with one element.  */\n\t\t    elf_next_in_group (newsect) = newsect;\n\t\t  }\n\n\t\t/* If the group section has been created, point to the\n\t\t   new member.  */\n\t\tif (shdr->bfd_section != NULL)\n\t\t  elf_next_in_group (shdr->bfd_section) = newsect;\n\n\t\ti = num_group - 1;\n\t\tbreak;\n\t      }\n\t}\n    }\n\n  if (elf_group_name (newsect) == NULL)\n    {\n      (*_bfd_error_handler) (_(\"%B: no group info for section %A\"),\n\t\t\t     abfd, newsect);\n      return FALSE;\n    }\n  return TRUE;\n}",
        "description": "The `setup_group` function in the `bfd/elf.c` file of the GNU binutils library, versions 2.24 and earlier, is vulnerable to a denial of service (crash) and potential arbitrary code execution by remote attackers. This vulnerability arises from the handling of crafted section group headers in an ELF file.",
        "commit": "This patch addresses a potential security vulnerability in applications that utilize the bfd library to parse binaries. Specifically, it enhances the handling of corrupt section group headers, which could be exploited by maliciously crafted binaries to cause issues such as buffer overflows or other security breaches."
    },
    {
        "cwe": "CWE-843",
        "func_name": "torvalds/__fib6_rule_action",
        "score": 0.7735347747802734,
        "func_before": "static int __fib6_rule_action(struct fib_rule *rule, struct flowi *flp,\n\t\t\t      int flags, struct fib_lookup_arg *arg)\n{\n\tstruct flowi6 *flp6 = &flp->u.ip6;\n\tstruct rt6_info *rt = NULL;\n\tstruct fib6_table *table;\n\tstruct net *net = rule->fr_net;\n\tpol_lookup_t lookup = arg->lookup_ptr;\n\tint err = 0;\n\tu32 tb_id;\n\n\tswitch (rule->action) {\n\tcase FR_ACT_TO_TBL:\n\t\tbreak;\n\tcase FR_ACT_UNREACHABLE:\n\t\terr = -ENETUNREACH;\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tgoto discard_pkt;\n\tdefault:\n\tcase FR_ACT_BLACKHOLE:\n\t\terr = -EINVAL;\n\t\trt = net->ipv6.ip6_blk_hole_entry;\n\t\tgoto discard_pkt;\n\tcase FR_ACT_PROHIBIT:\n\t\terr = -EACCES;\n\t\trt = net->ipv6.ip6_prohibit_entry;\n\t\tgoto discard_pkt;\n\t}\n\n\ttb_id = fib_rule_get_table(rule, arg);\n\ttable = fib6_get_table(net, tb_id);\n\tif (!table) {\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trt = lookup(net, table, flp6, arg->lookup_data, flags);\n\tif (rt != net->ipv6.ip6_null_entry) {\n\t\terr = fib6_rule_saddr(net, rule, flags, flp6,\n\t\t\t\t      ip6_dst_idev(&rt->dst)->dev);\n\n\t\tif (err == -EAGAIN)\n\t\t\tgoto again;\n\n\t\terr = rt->dst.error;\n\t\tif (err != -EAGAIN)\n\t\t\tgoto out;\n\t}\nagain:\n\tip6_rt_put(rt);\n\terr = -EAGAIN;\n\trt = NULL;\n\tgoto out;\n\ndiscard_pkt:\n\tdst_hold(&rt->dst);\nout:\n\targ->result = rt;\n\treturn err;\n}",
        "func_after": "static int __fib6_rule_action(struct fib_rule *rule, struct flowi *flp,\n\t\t\t      int flags, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct flowi6 *flp6 = &flp->u.ip6;\n\tstruct rt6_info *rt = NULL;\n\tstruct fib6_table *table;\n\tstruct net *net = rule->fr_net;\n\tpol_lookup_t lookup = arg->lookup_ptr;\n\tint err = 0;\n\tu32 tb_id;\n\n\tswitch (rule->action) {\n\tcase FR_ACT_TO_TBL:\n\t\tbreak;\n\tcase FR_ACT_UNREACHABLE:\n\t\terr = -ENETUNREACH;\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tgoto discard_pkt;\n\tdefault:\n\tcase FR_ACT_BLACKHOLE:\n\t\terr = -EINVAL;\n\t\trt = net->ipv6.ip6_blk_hole_entry;\n\t\tgoto discard_pkt;\n\tcase FR_ACT_PROHIBIT:\n\t\terr = -EACCES;\n\t\trt = net->ipv6.ip6_prohibit_entry;\n\t\tgoto discard_pkt;\n\t}\n\n\ttb_id = fib_rule_get_table(rule, arg);\n\ttable = fib6_get_table(net, tb_id);\n\tif (!table) {\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trt = lookup(net, table, flp6, arg->lookup_data, flags);\n\tif (rt != net->ipv6.ip6_null_entry) {\n\t\terr = fib6_rule_saddr(net, rule, flags, flp6,\n\t\t\t\t      ip6_dst_idev(&rt->dst)->dev);\n\n\t\tif (err == -EAGAIN)\n\t\t\tgoto again;\n\n\t\terr = rt->dst.error;\n\t\tif (err != -EAGAIN)\n\t\t\tgoto out;\n\t}\nagain:\n\tip6_rt_put(rt);\n\terr = -EAGAIN;\n\trt = NULL;\n\tgoto out;\n\ndiscard_pkt:\n\tdst_hold(&rt->dst);\nout:\n\tres->rt6 = rt;\n\treturn err;\n}",
        "description": "A flaw was identified in the IPv6 module of the Linux kernel, where the variable `arg.result` was inconsistently utilized within the function `fib6_rule_lookup`. At times, it held a value of type `rt6_info`, while at other times it held a value of type `fib6_info`. This inconsistency was not properly managed in other parts of the code that anticipated `rt6_info` unconditionally, potentially resulting in a kernel panic during the execution of `fib6_rule_suppress`.",
        "commit": "The use of the `result` argument in `fib_lookup_arg` is inconsistent within IPv6 routing mechanisms. Specifically, `arg.result` is sometimes utilized as a `fib6_result` and other times as a container for `rt6_info`. To address this inconsistency, `rt6_info` should be incorporated into `fib6_result`, ensuring uniform usage of `arg.result` throughout IPv6 routing rules. Additionally, the `rt6` entry is populated during lookups that return a `dst_entry`, but not for direct `fib_lookups` that merely require a `fib6_info`."
    },
    {
        "cwe": "CWE-407",
        "func_name": "reddit/find_link_ref",
        "score": 0.7470153570175171,
        "func_before": "static struct link_ref *\nfind_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n{\n\tunsigned int hash = hash_link_ref(name, length);\n\tstruct link_ref *ref = NULL;\n\n\tref = references[hash % REF_TABLE_SIZE];\n\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash)\n\t\t\treturn ref;\n\n\t\tref = ref->next;\n\t}\n\n\treturn NULL;\n}",
        "func_after": "static struct link_ref *\nfind_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n{\n\tunsigned int hash = hash_link_ref(name, length);\n\tstruct link_ref *ref = NULL;\n\n\tref = references[hash % REF_TABLE_SIZE];\n\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash && ref->label->size == length) {\n\t\t\tif (strncasecmp((char *)ref->label->data, (char *) name, length) == 0) {\n\t\t\t\treturn ref;\n\t\t\t}\n\t\t}\n\n\t\tref = ref->next;\n\t}\n\n\treturn NULL;\n}",
        "description": "Snudown, a Reddit-specific fork of the Sundown Markdown parser with Python integration, was found to be vulnerable to denial of service (DoS) attacks due to weaknesses in its reference table implementation. Specifically, the hash function used for inserting references into a hash table was weak, allowing attackers to generate a large number of collisions. Additionally, the hash table permitted duplicate entries, leading to prolonged retrieval times. These issues collectively make the system susceptible to hash-collision DoS attacks, a form of algorithmic complexity attack. Users are advised to update to version 1.7.0 to mitigate these vulnerabilities.",
        "commit": "A vulnerability related to hash collisions has been identified and addressed by implementing a case-insensitive SipHash function to replace the existing reference hash function. Additionally, changes were made to the `link_ref` structure to include a label, and updates were applied to the `find_link_ref` and `add_link_ref` functions to ensure they compare link labels as well as hashes and disallow duplicate entries, respectively. A cast was added to convert from `uint8_t` to `char` for use with `strncasecmp`. The README markdown was updated to remove TODO items, and support for generating Python 2 wheels was added. Furthermore, logic was included to handle older versions of glibc that do not have the `getrandom` function, impacting the staging environment."
    },
    {
        "cwe": "CWE-670",
        "func_name": "xen-project/port_is_valid",
        "score": 0.717853307723999,
        "func_before": "static inline bool_t port_is_valid(struct domain *d, unsigned int p)\n{\n    return p < read_atomic(&d->valid_evtchns);\n}",
        "func_after": "static inline bool_t port_is_valid(struct domain *d, unsigned int p)\n{\n    if ( p >= read_atomic(&d->valid_evtchns) )\n        return false;\n\n    /*\n     * The caller will usually access the event channel afterwards and\n     * may be done without taking the per-domain lock. The barrier is\n     * going in pair the smp_wmb() barrier in evtchn_allocate_port().\n     */\n    smp_rmb();\n\n    return true;\n}",
        "description": "An issue was discovered in Xen through version 4.14.x, where memory barriers are absent during the access or allocation of event channels. Event channels control structures can be accessed without locks as long as the port is deemed valid. However, the absence of an appropriate memory barrier (such as smp_*mb()) allows the compiler and CPU to reorder memory accesses. This could enable a malicious guest to trigger a hypervisor crash, leading to a Denial of Service (DoS). Additionally, information leaks and privilege escalations cannot be ruled out. The vulnerability affects all versions of Xen, with the likelihood of exploitation depending on the CPU and compiler used to build Xen. The exact impact varies based on the compiler's code generation options and the CPU's ability to reorder memory accesses. It is recommended to consult the CPU vendor for guidance on potential vulnerabilities on Arm systems, while x86 systems are only vulnerable if a compiler performs reordering.",
        "commit": "It was discovered that the Xen hypervisor's event channel management lacked appropriate memory barriers during both allocation and access operations. Specifically, while the allocation of an event channel bucket is protected by a per-domain lock, accessing the bucket can occur without the lock being held, relying instead on the `port_is_valid()` function to ensure the port has an associated structure. However, due to potential compiler and processor reordering of memory accesses, there is a risk that updates to `d->valid_evtchns` could occur before the new bucket is fully allocated. To mitigate this issue, memory barriers were added: a write memory barrier during allocation and a read memory barrier when checking if the port is valid. This addresses a reordering problem that could lead to unintended behavior."
    }
]