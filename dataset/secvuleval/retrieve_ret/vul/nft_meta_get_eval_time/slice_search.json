[
    {
        "cwe": "CWE-681",
        "func_name": "FreeRDP/update_recv_secondary_order",
        "score": 0.8291877508163452,
        "func_before": "static BOOL update_recv_secondary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBOOL rc = FALSE;\n\tsize_t start, end, diff;\n\tBYTE orderType;\n\tUINT16 extraFlags;\n\tUINT16 orderLength;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpSecondaryUpdate* secondary = update->secondary;\n\tconst char* name;\n\n\tif (Stream_GetRemainingLength(s) < 5)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 5\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Read_UINT16(s, extraFlags);  /* extraFlags (2 bytes) */\n\tStream_Read_UINT8(s, orderType);    /* orderType (1 byte) */\n\tif (Stream_GetRemainingLength(s) < orderLength + 7U)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) %\" PRIuz \" < %\" PRIu16,\n\t\t           Stream_GetRemainingLength(s), orderLength + 7);\n\t\treturn FALSE;\n\t}\n\n\tstart = Stream_GetPosition(s);\n\tname = secondary_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Secondary Drawing Order %s\", name);\n\n\tif (!check_secondary_order_supported(update->log, settings, orderType, name))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_CACHE_BITMAP_COMPRESSED);\n\t\t\tCACHE_BITMAP_ORDER* order =\n\t\t\t    update_read_cache_bitmap_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmap, context, order);\n\t\t\t\tfree_cache_bitmap_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_BITMAP_COMPRESSED_V2);\n\t\t\tCACHE_BITMAP_V2_ORDER* order =\n\t\t\t    update_read_cache_bitmap_v2_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV2, context, order);\n\t\t\t\tfree_cache_bitmap_v2_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t{\n\t\t\tCACHE_BITMAP_V3_ORDER* order = update_read_cache_bitmap_v3_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV3, context, order);\n\t\t\t\tfree_cache_bitmap_v3_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t{\n\t\t\tCACHE_COLOR_TABLE_ORDER* order =\n\t\t\t    update_read_cache_color_table_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheColorTable, context, order);\n\t\t\t\tfree_cache_color_table_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_ORDER* order = update_read_cache_glyph_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyph, context, order);\n\t\t\t\t\t\tfree_cache_glyph_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_V2_ORDER* order =\n\t\t\t\t\t    update_read_cache_glyph_v2_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyphV2, context, order);\n\t\t\t\t\t\tfree_cache_glyph_v2_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\t/* [MS-RDPEGDI] 2.2.2.2.1.2.7 Cache Brush (CACHE_BRUSH_ORDER) */\n\t\t\t{\n\t\t\t\tCACHE_BRUSH_ORDER* order = update_read_cache_brush_order(update, s, extraFlags);\n\n\t\t\t\tif (order)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBrush, context, order);\n\t\t\t\t\tfree_cache_brush_order(context, order);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", name);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"SECONDARY ORDER %s failed\", name);\n\t}\n\n\tstart += orderLength + 7;\n\tend = Stream_GetPosition(s);\n\tif (start > end)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes too much\",\n\t\t           name, end - start);\n\t\treturn FALSE;\n\t}\n\tdiff = start - end;\n\tif (diff > 0)\n\t{\n\t\tWLog_Print(update->log, WLOG_DEBUG,\n\t\t           \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes short, skipping\", name, diff);\n\t\tStream_Seek(s, diff);\n\t}\n\treturn rc;\n}",
        "func_after": "static BOOL update_recv_secondary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBOOL rc = FALSE;\n\tsize_t start, end, diff;\n\tBYTE orderType;\n\tUINT16 extraFlags;\n\tUINT16 orderLength;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpSecondaryUpdate* secondary = update->secondary;\n\tconst char* name;\n\n\tif (Stream_GetRemainingLength(s) < 5)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 5\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Read_UINT16(s, extraFlags);  /* extraFlags (2 bytes) */\n\tStream_Read_UINT8(s, orderType);    /* orderType (1 byte) */\n\tif (Stream_GetRemainingLength(s) < orderLength + 7U)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) %\" PRIuz \" < %\" PRIu16,\n\t\t           Stream_GetRemainingLength(s), orderLength + 7);\n\t\treturn FALSE;\n\t}\n\n\tstart = Stream_GetPosition(s);\n\tname = secondary_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Secondary Drawing Order %s\", name);\n\n\tif (!check_secondary_order_supported(update->log, settings, orderType, name))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_CACHE_BITMAP_COMPRESSED);\n\t\t\tCACHE_BITMAP_ORDER* order =\n\t\t\t    update_read_cache_bitmap_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmap, context, order);\n\t\t\t\tfree_cache_bitmap_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_BITMAP_COMPRESSED_V2);\n\t\t\tCACHE_BITMAP_V2_ORDER* order =\n\t\t\t    update_read_cache_bitmap_v2_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV2, context, order);\n\t\t\t\tfree_cache_bitmap_v2_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t{\n\t\t\tCACHE_BITMAP_V3_ORDER* order = update_read_cache_bitmap_v3_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV3, context, order);\n\t\t\t\tfree_cache_bitmap_v3_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t{\n\t\t\tCACHE_COLOR_TABLE_ORDER* order =\n\t\t\t    update_read_cache_color_table_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheColorTable, context, order);\n\t\t\t\tfree_cache_color_table_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_ORDER* order = update_read_cache_glyph_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyph, context, order);\n\t\t\t\t\t\tfree_cache_glyph_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_V2_ORDER* order =\n\t\t\t\t\t    update_read_cache_glyph_v2_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyphV2, context, order);\n\t\t\t\t\t\tfree_cache_glyph_v2_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\t/* [MS-RDPEGDI] 2.2.2.2.1.2.7 Cache Brush (CACHE_BRUSH_ORDER) */\n\t\t\t{\n\t\t\t\tCACHE_BRUSH_ORDER* order = update_read_cache_brush_order(update, s, extraFlags);\n\n\t\t\t\tif (order)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBrush, context, order);\n\t\t\t\t\tfree_cache_brush_order(context, order);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", name);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"SECONDARY ORDER %s failed\", name);\n\t}\n\n\tstart += orderLength + 7;\n\tend = Stream_GetPosition(s);\n\tif (start > end)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes too much\",\n\t\t           name, end - start);\n\t\treturn FALSE;\n\t}\n\tdiff = end - start;\n\tif (diff > 0)\n\t{\n\t\tWLog_Print(update->log, WLOG_DEBUG,\n\t\t           \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes short, skipping\", name, diff);\n\t\tif (!Stream_SafeSeek(s, diff))\n\t\t\treturn FALSE;\n\t}\n\treturn rc;\n}",
        "description": "In FreeRDP versions prior to 2.1.2, there exists an integer casting vulnerability within the `update_recv_secondary_order` function. This vulnerability affects all clients configured with both `+glyph-cache` and `relax-order-checks` options. This issue has been addressed in version 2.1.2.",
        "commit": "An out-of-bounds (OOB) read vulnerability was addressed in the `update_recv_secondary_order` function. This issue was identified and reported by @antonio-morales."
    },
    {
        "cwe": "CWE-843",
        "func_name": "GNOME/xsltFormatNumberConversion",
        "score": 0.8229466080665588,
        "func_before": "xmlXPathError\nxsltFormatNumberConversion(xsltDecimalFormatPtr self,\n\t\t\t   xmlChar *format,\n\t\t\t   double number,\n\t\t\t   xmlChar **result)\n{\n    xmlXPathError status = XPATH_EXPRESSION_OK;\n    xmlBufferPtr buffer;\n    xmlChar *the_format, *prefix = NULL, *suffix = NULL;\n    xmlChar *nprefix, *nsuffix = NULL;\n    xmlChar pchar;\n    int\t    prefix_length, suffix_length = 0, nprefix_length, nsuffix_length;\n    double  scale;\n    int\t    j, len;\n    int     self_grouping_len;\n    xsltFormatNumberInfo format_info;\n    /*\n     * delayed_multiplier allows a 'trailing' percent or\n     * permille to be treated as suffix\n     */\n    int\t\tdelayed_multiplier = 0;\n    /* flag to show no -ve format present for -ve number */\n    char\tdefault_sign = 0;\n    /* flag to show error found, should use default format */\n    char\tfound_error = 0;\n\n    if (xmlStrlen(format) <= 0) {\n\txsltTransformError(NULL, NULL, NULL,\n                \"xsltFormatNumberConversion : \"\n\t\t\"Invalid format (0-length)\\n\");\n    }\n    *result = NULL;\n    switch (xmlXPathIsInf(number)) {\n\tcase -1:\n\t    if (self->minusSign == NULL)\n\t\t*result = xmlStrdup(BAD_CAST \"-\");\n\t    else\n\t\t*result = xmlStrdup(self->minusSign);\n\t    /* no-break on purpose */\n\tcase 1:\n\t    if ((self == NULL) || (self->infinity == NULL))\n\t\t*result = xmlStrcat(*result, BAD_CAST \"Infinity\");\n\t    else\n\t\t*result = xmlStrcat(*result, self->infinity);\n\t    return(status);\n\tdefault:\n\t    if (xmlXPathIsNaN(number)) {\n\t\tif ((self == NULL) || (self->noNumber == NULL))\n\t\t    *result = xmlStrdup(BAD_CAST \"NaN\");\n\t\telse\n\t\t    *result = xmlStrdup(self->noNumber);\n\t\treturn(status);\n\t    }\n    }\n\n    buffer = xmlBufferCreate();\n    if (buffer == NULL) {\n\treturn XPATH_MEMORY_ERROR;\n    }\n\n    format_info.integer_hash = 0;\n    format_info.integer_digits = 0;\n    format_info.frac_digits = 0;\n    format_info.frac_hash = 0;\n    format_info.group = -1;\n    format_info.multiplier = 1;\n    format_info.add_decimal = FALSE;\n    format_info.is_multiplier_set = FALSE;\n    format_info.is_negative_pattern = FALSE;\n\n    the_format = format;\n\n    /*\n     * First we process the +ve pattern to get percent / permille,\n     * as well as main format\n     */\n    prefix = the_format;\n    prefix_length = xsltFormatNumberPreSuffix(self, &the_format, &format_info);\n    if (prefix_length < 0) {\n\tfound_error = 1;\n\tgoto OUTPUT_NUMBER;\n    }\n\n    /*\n     * Here we process the \"number\" part of the format.  It gets\n     * a little messy because of the percent/per-mille - if that\n     * appears at the end, it may be part of the suffix instead\n     * of part of the number, so the variable delayed_multiplier\n     * is used to handle it\n     */\n    self_grouping_len = xmlStrlen(self->grouping);\n    while ((*the_format != 0) &&\n\t   (xsltUTF8Charcmp(the_format, self->decimalPoint) != 0) &&\n\t   (xsltUTF8Charcmp(the_format, self->patternSeparator) != 0)) {\n\n\tif (delayed_multiplier != 0) {\n\t    format_info.multiplier = delayed_multiplier;\n\t    format_info.is_multiplier_set = TRUE;\n\t    delayed_multiplier = 0;\n\t}\n\tif (xsltUTF8Charcmp(the_format, self->digit) == 0) {\n\t    if (format_info.integer_digits > 0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    format_info.integer_hash++;\n\t    if (format_info.group >= 0)\n\t\tformat_info.group++;\n\t} else if (xsltUTF8Charcmp(the_format, self->zeroDigit) == 0) {\n\t    format_info.integer_digits++;\n\t    if (format_info.group >= 0)\n\t\tformat_info.group++;\n\t} else if ((self_grouping_len > 0) &&\n\t    (!xmlStrncmp(the_format, self->grouping, self_grouping_len))) {\n\t    /* Reset group count */\n\t    format_info.group = 0;\n\t    the_format += self_grouping_len;\n\t    continue;\n\t} else if (xsltUTF8Charcmp(the_format, self->percent) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 100;\n\t} else  if (xsltUTF8Charcmp(the_format, self->permille) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 1000;\n\t} else\n\t    break; /* while */\n\n\tif ((len=xmlUTF8Strsize(the_format, 1)) < 1) {\n\t    found_error = 1;\n\t    goto OUTPUT_NUMBER;\n\t}\n\tthe_format += len;\n\n    }\n\n    /* We have finished the integer part, now work on fraction */\n    if ( (*the_format != 0) &&\n         (xsltUTF8Charcmp(the_format, self->decimalPoint) == 0) ) {\n        format_info.add_decimal = TRUE;\n        if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n            found_error = 1;\n            goto OUTPUT_NUMBER;\n        }\n\tthe_format += len;\t/* Skip over the decimal */\n    }\n\n    while (*the_format != 0) {\n\n\tif (xsltUTF8Charcmp(the_format, self->zeroDigit) == 0) {\n\t    if (format_info.frac_hash != 0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    format_info.frac_digits++;\n\t} else if (xsltUTF8Charcmp(the_format, self->digit) == 0) {\n\t    format_info.frac_hash++;\n\t} else if (xsltUTF8Charcmp(the_format, self->percent) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 100;\n\t    if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t        found_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    the_format += len;\n\t    continue; /* while */\n\t} else if (xsltUTF8Charcmp(the_format, self->permille) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 1000;\n\t    if  ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t        found_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    the_format += len;\n\t    continue; /* while */\n\t} else if (xsltUTF8Charcmp(the_format, self->grouping) != 0) {\n\t    break; /* while */\n\t}\n\tif ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t    found_error = 1;\n\t    goto OUTPUT_NUMBER;\n\t}\n\tthe_format += len;\n\tif (delayed_multiplier != 0) {\n\t    format_info.multiplier = delayed_multiplier;\n\t    delayed_multiplier = 0;\n\t    format_info.is_multiplier_set = TRUE;\n\t}\n    }\n\n    /*\n     * If delayed_multiplier is set after processing the\n     * \"number\" part, should be in suffix\n     */\n    if (delayed_multiplier != 0) {\n\tthe_format -= len;\n\tdelayed_multiplier = 0;\n    }\n\n    suffix = the_format;\n    suffix_length = xsltFormatNumberPreSuffix(self, &the_format, &format_info);\n    if ( (suffix_length < 0) ||\n\t ((*the_format != 0) &&\n\t  (xsltUTF8Charcmp(the_format, self->patternSeparator) != 0)) ) {\n\tfound_error = 1;\n\tgoto OUTPUT_NUMBER;\n    }\n\n    /*\n     * We have processed the +ve prefix, number part and +ve suffix.\n     * If the number is -ve, we must substitute the -ve prefix / suffix\n     */\n    if (number < 0) {\n        /*\n\t * Note that j is the number of UTF8 chars before the separator,\n\t * not the number of bytes! (bug 151975)\n\t */\n        j =  xmlUTF8Strloc(format, self->patternSeparator);\n\tif (j < 0) {\n\t/* No -ve pattern present, so use default signing */\n\t    default_sign = 1;\n\t}\n\telse {\n\t    /* Skip over pattern separator (accounting for UTF8) */\n\t    the_format = (xmlChar *)xmlUTF8Strpos(format, j + 1);\n\t    /*\n\t     * Flag changes interpretation of percent/permille\n\t     * in -ve pattern\n\t     */\n\t    format_info.is_negative_pattern = TRUE;\n\t    format_info.is_multiplier_set = FALSE;\n\n\t    /* First do the -ve prefix */\n\t    nprefix = the_format;\n\t    nprefix_length = xsltFormatNumberPreSuffix(self,\n\t\t\t\t\t&the_format, &format_info);\n\t    if (nprefix_length<0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\n\t    while (*the_format != 0) {\n\t\tif ( (xsltUTF8Charcmp(the_format, (self)->percent) == 0) ||\n\t\t     (xsltUTF8Charcmp(the_format, (self)->permille)== 0) ) {\n\t\t    if (format_info.is_multiplier_set) {\n\t\t\tfound_error = 1;\n\t\t\tgoto OUTPUT_NUMBER;\n\t\t    }\n\t\t    format_info.is_multiplier_set = TRUE;\n\t\t    delayed_multiplier = 1;\n\t\t}\n\t\telse if (IS_SPECIAL(self, the_format))\n\t\t    delayed_multiplier = 0;\n\t\telse\n\t\t    break; /* while */\n\t\tif ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t\t    found_error = 1;\n\t\t    goto OUTPUT_NUMBER;\n\t\t}\n\t\tthe_format += len;\n\t    }\n\t    if (delayed_multiplier != 0) {\n\t\tformat_info.is_multiplier_set = FALSE;\n\t\tthe_format -= len;\n\t    }\n\n\t    /* Finally do the -ve suffix */\n\t    if (*the_format != 0) {\n\t\tnsuffix = the_format;\n\t\tnsuffix_length = xsltFormatNumberPreSuffix(self,\n\t\t\t\t\t&the_format, &format_info);\n\t\tif (nsuffix_length < 0) {\n\t\t    found_error = 1;\n\t\t    goto OUTPUT_NUMBER;\n\t\t}\n\t    }\n\t    else\n\t\tnsuffix_length = 0;\n\t    if (*the_format != 0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    /*\n\t     * Here's another Java peculiarity:\n\t     * if -ve prefix/suffix == +ve ones, discard & use default\n\t     */\n\t    if ((nprefix_length != prefix_length) ||\n\t\t(nsuffix_length != suffix_length) ||\n\t\t((nprefix_length > 0) &&\n\t\t (xmlStrncmp(nprefix, prefix, prefix_length) !=0 )) ||\n\t\t((nsuffix_length > 0) &&\n\t\t (xmlStrncmp(nsuffix, suffix, suffix_length) !=0 ))) {\n\t\tprefix = nprefix;\n\t\tprefix_length = nprefix_length;\n\t\tsuffix = nsuffix;\n\t\tsuffix_length = nsuffix_length;\n\t    } /* else {\n\t\tdefault_sign = 1;\n\t    }\n\t    */\n\t}\n    }\n\nOUTPUT_NUMBER:\n    if (found_error != 0) {\n\txsltTransformError(NULL, NULL, NULL,\n                \"xsltFormatNumberConversion : \"\n\t\t\"error in format string '%s', using default\\n\", format);\n\tdefault_sign = (number < 0.0) ? 1 : 0;\n\tprefix_length = suffix_length = 0;\n\tformat_info.integer_hash = 0;\n\tformat_info.integer_digits = 1;\n\tformat_info.frac_digits = 1;\n\tformat_info.frac_hash = 4;\n\tformat_info.group = -1;\n\tformat_info.multiplier = 1;\n\tformat_info.add_decimal = TRUE;\n    }\n\n    /* Ready to output our number.  First see if \"default sign\" is required */\n    if (default_sign != 0)\n\txmlBufferAdd(buffer, self->minusSign, xmlUTF8Strsize(self->minusSign, 1));\n\n    /* Put the prefix into the buffer */\n    for (j = 0; j < prefix_length; j++) {\n\tif ((pchar = *prefix++) == SYMBOL_QUOTE) {\n\t    len = xmlUTF8Strsize(prefix, 1);\n\t    xmlBufferAdd(buffer, prefix, len);\n\t    prefix += len;\n\t    j += len - 1;\t/* length of symbol less length of quote */\n\t} else\n\t    xmlBufferAdd(buffer, &pchar, 1);\n    }\n\n    /* Next do the integer part of the number */\n    number = fabs(number) * (double)format_info.multiplier;\n    scale = pow(10.0, (double)(format_info.frac_digits + format_info.frac_hash));\n    number = floor((scale * number + 0.5)) / scale;\n    if ((self->grouping != NULL) &&\n        (self->grouping[0] != 0)) {\n\n\tlen = xmlStrlen(self->grouping);\n\tpchar = xsltGetUTF8Char(self->grouping, &len);\n\txsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n\t\t\t\tformat_info.integer_digits,\n\t\t\t\tformat_info.group,\n\t\t\t\tpchar, len);\n    } else\n\txsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n\t\t\t\tformat_info.integer_digits,\n\t\t\t\tformat_info.group,\n\t\t\t\t',', 1);\n\n    /* Special case: java treats '.#' like '.0', '.##' like '.0#', etc. */\n    if ((format_info.integer_digits + format_info.integer_hash +\n\t format_info.frac_digits == 0) && (format_info.frac_hash > 0)) {\n        ++format_info.frac_digits;\n\t--format_info.frac_hash;\n    }\n\n    /* Add leading zero, if required */\n    if ((floor(number) == 0) &&\n\t(format_info.integer_digits + format_info.frac_digits == 0)) {\n        xmlBufferAdd(buffer, self->zeroDigit, xmlUTF8Strsize(self->zeroDigit, 1));\n    }\n\n    /* Next the fractional part, if required */\n    if (format_info.frac_digits + format_info.frac_hash == 0) {\n        if (format_info.add_decimal)\n\t    xmlBufferAdd(buffer, self->decimalPoint,\n\t\t\t xmlUTF8Strsize(self->decimalPoint, 1));\n    }\n    else {\n      number -= floor(number);\n\tif ((number != 0) || (format_info.frac_digits != 0)) {\n\t    xmlBufferAdd(buffer, self->decimalPoint,\n\t\t\t xmlUTF8Strsize(self->decimalPoint, 1));\n\t    number = floor(scale * number + 0.5);\n\t    for (j = format_info.frac_hash; j > 0; j--) {\n\t\tif (fmod(number, 10.0) >= 1.0)\n\t\t    break; /* for */\n\t\tnumber /= 10.0;\n\t    }\n\t    xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n\t\t\t\tformat_info.frac_digits + j,\n\t\t\t\t0, 0, 0);\n\t}\n    }\n    /* Put the suffix into the buffer */\n    for (j = 0; j < suffix_length; j++) {\n\tif ((pchar = *suffix++) == SYMBOL_QUOTE) {\n            len = xmlUTF8Strsize(suffix, 1);\n\t    xmlBufferAdd(buffer, suffix, len);\n\t    suffix += len;\n\t    j += len - 1;\t/* length of symbol less length of escape */\n\t} else\n\t    xmlBufferAdd(buffer, &pchar, 1);\n    }\n\n    *result = xmlStrdup(xmlBufferContent(buffer));\n    xmlBufferFree(buffer);\n    return status;\n}",
        "func_after": "xmlXPathError\nxsltFormatNumberConversion(xsltDecimalFormatPtr self,\n\t\t\t   xmlChar *format,\n\t\t\t   double number,\n\t\t\t   xmlChar **result)\n{\n    xmlXPathError status = XPATH_EXPRESSION_OK;\n    xmlBufferPtr buffer;\n    xmlChar *the_format, *prefix = NULL, *suffix = NULL;\n    xmlChar *nprefix, *nsuffix = NULL;\n    xmlChar pchar;\n    int\t    prefix_length, suffix_length = 0, nprefix_length, nsuffix_length;\n    double  scale;\n    int\t    j, len;\n    int     self_grouping_len;\n    xsltFormatNumberInfo format_info;\n    /*\n     * delayed_multiplier allows a 'trailing' percent or\n     * permille to be treated as suffix\n     */\n    int\t\tdelayed_multiplier = 0;\n    /* flag to show no -ve format present for -ve number */\n    char\tdefault_sign = 0;\n    /* flag to show error found, should use default format */\n    char\tfound_error = 0;\n\n    if (xmlStrlen(format) <= 0) {\n\txsltTransformError(NULL, NULL, NULL,\n                \"xsltFormatNumberConversion : \"\n\t\t\"Invalid format (0-length)\\n\");\n    }\n    *result = NULL;\n    switch (xmlXPathIsInf(number)) {\n\tcase -1:\n\t    if (self->minusSign == NULL)\n\t\t*result = xmlStrdup(BAD_CAST \"-\");\n\t    else\n\t\t*result = xmlStrdup(self->minusSign);\n\t    /* no-break on purpose */\n\tcase 1:\n\t    if ((self == NULL) || (self->infinity == NULL))\n\t\t*result = xmlStrcat(*result, BAD_CAST \"Infinity\");\n\t    else\n\t\t*result = xmlStrcat(*result, self->infinity);\n\t    return(status);\n\tdefault:\n\t    if (xmlXPathIsNaN(number)) {\n\t\tif ((self == NULL) || (self->noNumber == NULL))\n\t\t    *result = xmlStrdup(BAD_CAST \"NaN\");\n\t\telse\n\t\t    *result = xmlStrdup(self->noNumber);\n\t\treturn(status);\n\t    }\n    }\n\n    buffer = xmlBufferCreate();\n    if (buffer == NULL) {\n\treturn XPATH_MEMORY_ERROR;\n    }\n\n    format_info.integer_hash = 0;\n    format_info.integer_digits = 0;\n    format_info.frac_digits = 0;\n    format_info.frac_hash = 0;\n    format_info.group = -1;\n    format_info.multiplier = 1;\n    format_info.add_decimal = FALSE;\n    format_info.is_multiplier_set = FALSE;\n    format_info.is_negative_pattern = FALSE;\n\n    the_format = format;\n\n    /*\n     * First we process the +ve pattern to get percent / permille,\n     * as well as main format\n     */\n    prefix = the_format;\n    prefix_length = xsltFormatNumberPreSuffix(self, &the_format, &format_info);\n    if (prefix_length < 0) {\n\tfound_error = 1;\n\tgoto OUTPUT_NUMBER;\n    }\n\n    /*\n     * Here we process the \"number\" part of the format.  It gets\n     * a little messy because of the percent/per-mille - if that\n     * appears at the end, it may be part of the suffix instead\n     * of part of the number, so the variable delayed_multiplier\n     * is used to handle it\n     */\n    self_grouping_len = xmlStrlen(self->grouping);\n    while ((*the_format != 0) &&\n\t   (xsltUTF8Charcmp(the_format, self->decimalPoint) != 0) &&\n\t   (xsltUTF8Charcmp(the_format, self->patternSeparator) != 0)) {\n\n\tif (delayed_multiplier != 0) {\n\t    format_info.multiplier = delayed_multiplier;\n\t    format_info.is_multiplier_set = TRUE;\n\t    delayed_multiplier = 0;\n\t}\n\tif (xsltUTF8Charcmp(the_format, self->digit) == 0) {\n\t    if (format_info.integer_digits > 0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    format_info.integer_hash++;\n\t    if (format_info.group >= 0)\n\t\tformat_info.group++;\n\t} else if (xsltUTF8Charcmp(the_format, self->zeroDigit) == 0) {\n\t    format_info.integer_digits++;\n\t    if (format_info.group >= 0)\n\t\tformat_info.group++;\n\t} else if ((self_grouping_len > 0) &&\n\t    (!xmlStrncmp(the_format, self->grouping, self_grouping_len))) {\n\t    /* Reset group count */\n\t    format_info.group = 0;\n\t    the_format += self_grouping_len;\n\t    continue;\n\t} else if (xsltUTF8Charcmp(the_format, self->percent) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 100;\n\t} else  if (xsltUTF8Charcmp(the_format, self->permille) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 1000;\n\t} else\n\t    break; /* while */\n\n\tif ((len=xmlUTF8Strsize(the_format, 1)) < 1) {\n\t    found_error = 1;\n\t    goto OUTPUT_NUMBER;\n\t}\n\tthe_format += len;\n\n    }\n\n    /* We have finished the integer part, now work on fraction */\n    if ( (*the_format != 0) &&\n         (xsltUTF8Charcmp(the_format, self->decimalPoint) == 0) ) {\n        format_info.add_decimal = TRUE;\n        if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n            found_error = 1;\n            goto OUTPUT_NUMBER;\n        }\n\tthe_format += len;\t/* Skip over the decimal */\n    }\n\n    while (*the_format != 0) {\n\n\tif (xsltUTF8Charcmp(the_format, self->zeroDigit) == 0) {\n\t    if (format_info.frac_hash != 0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    format_info.frac_digits++;\n\t} else if (xsltUTF8Charcmp(the_format, self->digit) == 0) {\n\t    format_info.frac_hash++;\n\t} else if (xsltUTF8Charcmp(the_format, self->percent) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 100;\n\t    if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t        found_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    the_format += len;\n\t    continue; /* while */\n\t} else if (xsltUTF8Charcmp(the_format, self->permille) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 1000;\n\t    if  ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t        found_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    the_format += len;\n\t    continue; /* while */\n\t} else if (xsltUTF8Charcmp(the_format, self->grouping) != 0) {\n\t    break; /* while */\n\t}\n\tif ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t    found_error = 1;\n\t    goto OUTPUT_NUMBER;\n\t}\n\tthe_format += len;\n\tif (delayed_multiplier != 0) {\n\t    format_info.multiplier = delayed_multiplier;\n\t    delayed_multiplier = 0;\n\t    format_info.is_multiplier_set = TRUE;\n\t}\n    }\n\n    /*\n     * If delayed_multiplier is set after processing the\n     * \"number\" part, should be in suffix\n     */\n    if (delayed_multiplier != 0) {\n\tthe_format -= len;\n\tdelayed_multiplier = 0;\n    }\n\n    suffix = the_format;\n    suffix_length = xsltFormatNumberPreSuffix(self, &the_format, &format_info);\n    if ( (suffix_length < 0) ||\n\t ((*the_format != 0) &&\n\t  (xsltUTF8Charcmp(the_format, self->patternSeparator) != 0)) ) {\n\tfound_error = 1;\n\tgoto OUTPUT_NUMBER;\n    }\n\n    /*\n     * We have processed the +ve prefix, number part and +ve suffix.\n     * If the number is -ve, we must substitute the -ve prefix / suffix\n     */\n    if (number < 0) {\n        /*\n\t * Note that j is the number of UTF8 chars before the separator,\n\t * not the number of bytes! (bug 151975)\n\t */\n        j =  xmlUTF8Strloc(format, self->patternSeparator);\n\tif (j < 0) {\n\t/* No -ve pattern present, so use default signing */\n\t    default_sign = 1;\n\t}\n\telse {\n\t    /* Skip over pattern separator (accounting for UTF8) */\n\t    the_format = (xmlChar *)xmlUTF8Strpos(format, j + 1);\n\t    /*\n\t     * Flag changes interpretation of percent/permille\n\t     * in -ve pattern\n\t     */\n\t    format_info.is_negative_pattern = TRUE;\n\t    format_info.is_multiplier_set = FALSE;\n\n\t    /* First do the -ve prefix */\n\t    nprefix = the_format;\n\t    nprefix_length = xsltFormatNumberPreSuffix(self,\n\t\t\t\t\t&the_format, &format_info);\n\t    if (nprefix_length<0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\n\t    while (*the_format != 0) {\n\t\tif ( (xsltUTF8Charcmp(the_format, (self)->percent) == 0) ||\n\t\t     (xsltUTF8Charcmp(the_format, (self)->permille)== 0) ) {\n\t\t    if (format_info.is_multiplier_set) {\n\t\t\tfound_error = 1;\n\t\t\tgoto OUTPUT_NUMBER;\n\t\t    }\n\t\t    format_info.is_multiplier_set = TRUE;\n\t\t    delayed_multiplier = 1;\n\t\t}\n\t\telse if (IS_SPECIAL(self, the_format))\n\t\t    delayed_multiplier = 0;\n\t\telse\n\t\t    break; /* while */\n\t\tif ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t\t    found_error = 1;\n\t\t    goto OUTPUT_NUMBER;\n\t\t}\n\t\tthe_format += len;\n\t    }\n\t    if (delayed_multiplier != 0) {\n\t\tformat_info.is_multiplier_set = FALSE;\n\t\tthe_format -= len;\n\t    }\n\n\t    /* Finally do the -ve suffix */\n\t    if (*the_format != 0) {\n\t\tnsuffix = the_format;\n\t\tnsuffix_length = xsltFormatNumberPreSuffix(self,\n\t\t\t\t\t&the_format, &format_info);\n\t\tif (nsuffix_length < 0) {\n\t\t    found_error = 1;\n\t\t    goto OUTPUT_NUMBER;\n\t\t}\n\t    }\n\t    else\n\t\tnsuffix_length = 0;\n\t    if (*the_format != 0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    /*\n\t     * Here's another Java peculiarity:\n\t     * if -ve prefix/suffix == +ve ones, discard & use default\n\t     */\n\t    if ((nprefix_length != prefix_length) ||\n\t\t(nsuffix_length != suffix_length) ||\n\t\t((nprefix_length > 0) &&\n\t\t (xmlStrncmp(nprefix, prefix, prefix_length) !=0 )) ||\n\t\t((nsuffix_length > 0) &&\n\t\t (xmlStrncmp(nsuffix, suffix, suffix_length) !=0 ))) {\n\t\tprefix = nprefix;\n\t\tprefix_length = nprefix_length;\n\t\tsuffix = nsuffix;\n\t\tsuffix_length = nsuffix_length;\n\t    } /* else {\n\t\tdefault_sign = 1;\n\t    }\n\t    */\n\t}\n    }\n\nOUTPUT_NUMBER:\n    if (found_error != 0) {\n\txsltTransformError(NULL, NULL, NULL,\n                \"xsltFormatNumberConversion : \"\n\t\t\"error in format string '%s', using default\\n\", format);\n\tdefault_sign = (number < 0.0) ? 1 : 0;\n\tprefix_length = suffix_length = 0;\n\tformat_info.integer_hash = 0;\n\tformat_info.integer_digits = 1;\n\tformat_info.frac_digits = 1;\n\tformat_info.frac_hash = 4;\n\tformat_info.group = -1;\n\tformat_info.multiplier = 1;\n\tformat_info.add_decimal = TRUE;\n    }\n\n    /* Ready to output our number.  First see if \"default sign\" is required */\n    if (default_sign != 0)\n\txmlBufferAdd(buffer, self->minusSign, xmlUTF8Strsize(self->minusSign, 1));\n\n    /* Put the prefix into the buffer */\n    for (j = 0; j < prefix_length; j++) {\n\tif ((pchar = *prefix++) == SYMBOL_QUOTE) {\n\t    len = xmlUTF8Strsize(prefix, 1);\n\t    xmlBufferAdd(buffer, prefix, len);\n\t    prefix += len;\n\t    j += len - 1;\t/* length of symbol less length of quote */\n\t} else\n\t    xmlBufferAdd(buffer, &pchar, 1);\n    }\n\n    /* Next do the integer part of the number */\n    number = fabs(number) * (double)format_info.multiplier;\n    scale = pow(10.0, (double)(format_info.frac_digits + format_info.frac_hash));\n    number = floor((scale * number + 0.5)) / scale;\n    if ((self->grouping != NULL) &&\n        (self->grouping[0] != 0)) {\n        int gchar;\n\n\tlen = xmlStrlen(self->grouping);\n\tgchar = xsltGetUTF8Char(self->grouping, &len);\n\txsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n\t\t\t\tformat_info.integer_digits,\n\t\t\t\tformat_info.group,\n\t\t\t\tgchar, len);\n    } else\n\txsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n\t\t\t\tformat_info.integer_digits,\n\t\t\t\tformat_info.group,\n\t\t\t\t',', 1);\n\n    /* Special case: java treats '.#' like '.0', '.##' like '.0#', etc. */\n    if ((format_info.integer_digits + format_info.integer_hash +\n\t format_info.frac_digits == 0) && (format_info.frac_hash > 0)) {\n        ++format_info.frac_digits;\n\t--format_info.frac_hash;\n    }\n\n    /* Add leading zero, if required */\n    if ((floor(number) == 0) &&\n\t(format_info.integer_digits + format_info.frac_digits == 0)) {\n        xmlBufferAdd(buffer, self->zeroDigit, xmlUTF8Strsize(self->zeroDigit, 1));\n    }\n\n    /* Next the fractional part, if required */\n    if (format_info.frac_digits + format_info.frac_hash == 0) {\n        if (format_info.add_decimal)\n\t    xmlBufferAdd(buffer, self->decimalPoint,\n\t\t\t xmlUTF8Strsize(self->decimalPoint, 1));\n    }\n    else {\n      number -= floor(number);\n\tif ((number != 0) || (format_info.frac_digits != 0)) {\n\t    xmlBufferAdd(buffer, self->decimalPoint,\n\t\t\t xmlUTF8Strsize(self->decimalPoint, 1));\n\t    number = floor(scale * number + 0.5);\n\t    for (j = format_info.frac_hash; j > 0; j--) {\n\t\tif (fmod(number, 10.0) >= 1.0)\n\t\t    break; /* for */\n\t\tnumber /= 10.0;\n\t    }\n\t    xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n\t\t\t\tformat_info.frac_digits + j,\n\t\t\t\t0, 0, 0);\n\t}\n    }\n    /* Put the suffix into the buffer */\n    for (j = 0; j < suffix_length; j++) {\n\tif ((pchar = *suffix++) == SYMBOL_QUOTE) {\n            len = xmlUTF8Strsize(suffix, 1);\n\t    xmlBufferAdd(buffer, suffix, len);\n\t    suffix += len;\n\t    j += len - 1;\t/* length of symbol less length of escape */\n\t} else\n\t    xmlBufferAdd(buffer, &pchar, 1);\n    }\n\n    *result = xmlStrdup(xmlBufferContent(buffer));\n    xmlBufferFree(buffer);\n    return status;\n}",
        "description": "In libxslt 1.1.33, a type used to store grouping characters for an xsl:number instruction was insufficiently wide, allowing an invalid character/length combination to be passed to the xsltNumberFormatDecimal function. This issue resulted in the reading of uninitialized stack data.",
        "commit": "The vulnerability involves an uninitialized read error in the `xsltFormatNumberConversion` function due to an overly narrow character type. This issue can lead to passing an invalid character/length combination to the `xsltNumberFormatDecimal` function, resulting in an uninitialized read. This problem was identified through OSS-Fuzz testing."
    },
    {
        "cwe": "CWE-763",
        "func_name": "facebook/write",
        "score": 0.8213701844215393,
        "func_before": "size_t\nwrite(Protocol_* iprot, const StructInfo& structInfo, const void* object) {\n  DCHECK(object);\n  size_t written = iprot->writeStructBegin(structInfo.name);\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    const FieldInfo* end = structInfo.fieldInfos + structInfo.numFields;\n    const auto& unionId =\n        activeUnionMemberId(object, structInfo.unionExt->unionTypeOffset);\n    const FieldInfo* found = std::lower_bound(\n        structInfo.fieldInfos,\n        end,\n        unionId,\n        [](const FieldInfo& lhs, FieldID rhs) { return lhs.id < rhs; });\n    if (found < end && found->id == unionId) {\n      const OptionalThriftValue value = getValue(*found->typeInfo, object);\n      if (value.hasValue()) {\n        written += writeField(iprot, *found, value.value());\n      } else if (found->typeInfo->type == protocol::TType::T_STRUCT) {\n        written += iprot->writeFieldBegin(\n            found->name, found->typeInfo->type, found->id);\n        written += iprot->writeStructBegin(found->name);\n        written += iprot->writeStructEnd();\n        written += iprot->writeFieldStop();\n        written += iprot->writeFieldEnd();\n      }\n    }\n  } else {\n    for (std::int16_t index = 0; index < structInfo.numFields; index++) {\n      const auto& fieldInfo = structInfo.fieldInfos[index];\n      if (fieldInfo.isUnqualified || fieldInfo.issetOffset == 0 ||\n          fieldIsSet(object, fieldInfo.issetOffset)) {\n        const OptionalThriftValue value =\n            getValue(*fieldInfo.typeInfo, getMember(fieldInfo, object));\n        if (value.hasValue()) {\n          written += writeField(iprot, fieldInfo, value.value());\n        }\n      }\n    }\n  }\n\n  written += iprot->writeFieldStop();\n  written += iprot->writeStructEnd();\n  return written;\n}",
        "func_after": "size_t\nwrite(Protocol_* iprot, const StructInfo& structInfo, const void* object) {\n  DCHECK(object);\n  size_t written = iprot->writeStructBegin(structInfo.name);\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    const FieldInfo* end = structInfo.fieldInfos + structInfo.numFields;\n    const auto& activeId = getActiveId(object, structInfo);\n    const FieldInfo* found = std::lower_bound(\n        structInfo.fieldInfos,\n        end,\n        activeId,\n        [](const FieldInfo& lhs, FieldID rhs) { return lhs.id < rhs; });\n    if (found < end && found->id == activeId) {\n      const OptionalThriftValue value = getValue(*found->typeInfo, object);\n      if (value.hasValue()) {\n        written += writeField(iprot, *found, value.value());\n      } else if (found->typeInfo->type == protocol::TType::T_STRUCT) {\n        written += iprot->writeFieldBegin(\n            found->name, found->typeInfo->type, found->id);\n        written += iprot->writeStructBegin(found->name);\n        written += iprot->writeStructEnd();\n        written += iprot->writeFieldStop();\n        written += iprot->writeFieldEnd();\n      }\n    }\n  } else {\n    for (std::int16_t index = 0; index < structInfo.numFields; index++) {\n      const auto& fieldInfo = structInfo.fieldInfos[index];\n      if (fieldInfo.isUnqualified || fieldInfo.issetOffset == 0 ||\n          fieldIsSet(object, fieldInfo.issetOffset)) {\n        const OptionalThriftValue value =\n            getValue(*fieldInfo.typeInfo, getMember(fieldInfo, object));\n        if (value.hasValue()) {\n          written += writeField(iprot, fieldInfo, value.value());\n        }\n      }\n    }\n  }\n\n  written += iprot->writeFieldStop();\n  written += iprot->writeStructEnd();\n  return written;\n}",
        "description": "An invalid free operation within Thrift's table-based serialization can lead to application crashes or enable code execution and other unintended consequences. This vulnerability impacts Facebook Thrift versions prior to v2021.02.22.00.",
        "commit": "It was discovered that the table-based serializer improperly handled invalid union data, leading to potential memory leaks and other undesirable effects. Specifically, when duplicate union data was encountered, the previous active member of the union was overwritten without invoking the destructor of the old object. Additionally, if the second piece of data was incomplete, the incorrect destructor was called during stack unwinding, resulting in segmentation faults, data corruption, or other issues. The fix involves clearing the union if there is an active member and correcting the type of the data member that holds the active field ID."
    },
    {
        "cwe": "CWE-189",
        "func_name": "torvalds/i915_gem_execbuffer2",
        "score": 0.8215159773826599,
        "func_before": "int\ni915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n\tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n\tint ret;\n\n\tif (args->buffer_count < 1) {\n\t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\t/* Copy the new buffer offsets back to the user's exec list. */\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}",
        "func_after": "int\ni915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n\tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n\tint ret;\n\n\tif (args->buffer_count < 1 ||\n\t    args->buffer_count > UINT_MAX / sizeof(*exec2_list)) {\n\t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\t/* Copy the new buffer offsets back to the user's exec list. */\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}",
        "description": "An integer overflow vulnerability exists within the `i915_gem_execbuffer2` function of the DRM subsystem in the Linux kernel prior to version 3.3.5 on 32-bit platforms. This flaw allows local users to trigger a denial of service through an out-of-bounds write or potentially cause other unspecified impacts via a specially crafted ioctl call.",
        "commit": "A vulnerability was identified in the i915 driver of the DRM subsystem within the Linux kernel, where a large `args->buffer_count` value provided by userspace through an ioctl call could cause an integer overflow on 32-bit systems. This overflow affects the calculation of the allocation size for temporary execution buffers, potentially leading to out-of-bounds memory access. This issue arose due to changes introduced in commit 8408c282, which attempted to optimize buffer allocation by first trying a normal large `kmalloc`."
    },
    {
        "cwe": "CWE-440",
        "func_name": "eclipse-openj9/Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex",
        "score": 0.8093158006668091,
        "func_before": "JNIEXPORT jint JNICALL Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *env, jclass InterfaceMethodHandle, jlong interfaceArg, jint itableIndex, jlong receiverClassArg)\n   {\n   J9Class  *interfaceClass = (J9Class*)(intptr_t)interfaceArg;\n   J9Class  *receiverClass  = (J9Class*)(intptr_t)receiverClassArg;\n   J9ITable *itableEntry;\n   for (itableEntry = (J9ITable*)receiverClass->iTable; itableEntry; itableEntry = itableEntry->next)\n      if (itableEntry->interfaceClass == interfaceClass)\n         break;\n   TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *itableArray = (UDATA*)(itableEntry+1);\n   return (itableArray[itableIndex] - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } indexAndLiterals =\n      {\n      (UDATA)interfaceClass,\n      (UDATA)itableIndex\n      };\n   J9Object *receiver = (J9Object*)receiverArg;\n   return (jint)jitLookupInterfaceMethod(receiver->clazz, &indexAndLiterals, 0);\n#endif\n   }",
        "func_after": "JNIEXPORT jint JNICALL Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *env, jclass InterfaceMethodHandle, jlong interfaceArg, jint itableIndex, jlong receiverClassArg)\n   {\n   J9Class  *interfaceClass = (J9Class*)(intptr_t)interfaceArg;\n   J9Class  *receiverClass  = (J9Class*)(intptr_t)receiverClassArg;\n   J9ITable *itableEntry;\n   for (itableEntry = (J9ITable*)receiverClass->iTable; itableEntry; itableEntry = itableEntry->next)\n      if (itableEntry->interfaceClass == interfaceClass)\n         break;\n   TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *itableArray = (UDATA*)(itableEntry+1);\n   UDATA vTableOffset = itableArray[itableIndex];\n   J9Method *method = *(J9Method**)((UDATA)receiverClass + vTableOffset);\n   if ((J9_ROM_METHOD_FROM_RAM_METHOD(method)->modifiers & J9AccPublic) == 0)\n      return -1;\n\n   return (vTableOffset - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } indexAndLiterals =\n      {\n      (UDATA)interfaceClass,\n      (UDATA)itableIndex\n      };\n   J9Object *receiver = (J9Object*)receiverArg;\n   return (jint)jitLookupInterfaceMethod(receiver->clazz, &indexAndLiterals, 0);\n#endif\n   }",
        "description": "In versions of Eclipse Openj9 prior to 0.29.0, the Java Virtual Machine (JVM) fails to throw an IllegalAccessError when MethodHandles are used to invoke methods that are not accessible through interfaces.",
        "commit": "The vulnerability involves a situation where an `IllegalAccessError` (IAE) is not being thrown appropriately when an `InterfaceHandle` encounters a non-public method during dispatch. The expected behavior is for the dispatch mechanism implemented by `InterfaceHandle` to mimic that of `invokeinterface`, which throws an `IAE` when attempting to access non-public methods. This discrepancy allows unauthorized access to non-public methods, potentially leading to security vulnerabilities."
    }
]