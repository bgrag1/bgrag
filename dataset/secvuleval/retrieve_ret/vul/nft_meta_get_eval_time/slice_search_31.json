[
    {
        "cwe": "CWE-681",
        "func_name": "FreeRDP/update_recv_secondary_order",
        "score": 0.8291877508163452,
        "func_before": "static BOOL update_recv_secondary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBOOL rc = FALSE;\n\tsize_t start, end, diff;\n\tBYTE orderType;\n\tUINT16 extraFlags;\n\tUINT16 orderLength;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpSecondaryUpdate* secondary = update->secondary;\n\tconst char* name;\n\n\tif (Stream_GetRemainingLength(s) < 5)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 5\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Read_UINT16(s, extraFlags);  /* extraFlags (2 bytes) */\n\tStream_Read_UINT8(s, orderType);    /* orderType (1 byte) */\n\tif (Stream_GetRemainingLength(s) < orderLength + 7U)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) %\" PRIuz \" < %\" PRIu16,\n\t\t           Stream_GetRemainingLength(s), orderLength + 7);\n\t\treturn FALSE;\n\t}\n\n\tstart = Stream_GetPosition(s);\n\tname = secondary_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Secondary Drawing Order %s\", name);\n\n\tif (!check_secondary_order_supported(update->log, settings, orderType, name))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_CACHE_BITMAP_COMPRESSED);\n\t\t\tCACHE_BITMAP_ORDER* order =\n\t\t\t    update_read_cache_bitmap_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmap, context, order);\n\t\t\t\tfree_cache_bitmap_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_BITMAP_COMPRESSED_V2);\n\t\t\tCACHE_BITMAP_V2_ORDER* order =\n\t\t\t    update_read_cache_bitmap_v2_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV2, context, order);\n\t\t\t\tfree_cache_bitmap_v2_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t{\n\t\t\tCACHE_BITMAP_V3_ORDER* order = update_read_cache_bitmap_v3_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV3, context, order);\n\t\t\t\tfree_cache_bitmap_v3_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t{\n\t\t\tCACHE_COLOR_TABLE_ORDER* order =\n\t\t\t    update_read_cache_color_table_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheColorTable, context, order);\n\t\t\t\tfree_cache_color_table_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_ORDER* order = update_read_cache_glyph_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyph, context, order);\n\t\t\t\t\t\tfree_cache_glyph_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_V2_ORDER* order =\n\t\t\t\t\t    update_read_cache_glyph_v2_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyphV2, context, order);\n\t\t\t\t\t\tfree_cache_glyph_v2_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\t/* [MS-RDPEGDI] 2.2.2.2.1.2.7 Cache Brush (CACHE_BRUSH_ORDER) */\n\t\t\t{\n\t\t\t\tCACHE_BRUSH_ORDER* order = update_read_cache_brush_order(update, s, extraFlags);\n\n\t\t\t\tif (order)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBrush, context, order);\n\t\t\t\t\tfree_cache_brush_order(context, order);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", name);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"SECONDARY ORDER %s failed\", name);\n\t}\n\n\tstart += orderLength + 7;\n\tend = Stream_GetPosition(s);\n\tif (start > end)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes too much\",\n\t\t           name, end - start);\n\t\treturn FALSE;\n\t}\n\tdiff = start - end;\n\tif (diff > 0)\n\t{\n\t\tWLog_Print(update->log, WLOG_DEBUG,\n\t\t           \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes short, skipping\", name, diff);\n\t\tStream_Seek(s, diff);\n\t}\n\treturn rc;\n}",
        "func_after": "static BOOL update_recv_secondary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBOOL rc = FALSE;\n\tsize_t start, end, diff;\n\tBYTE orderType;\n\tUINT16 extraFlags;\n\tUINT16 orderLength;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpSecondaryUpdate* secondary = update->secondary;\n\tconst char* name;\n\n\tif (Stream_GetRemainingLength(s) < 5)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 5\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Read_UINT16(s, extraFlags);  /* extraFlags (2 bytes) */\n\tStream_Read_UINT8(s, orderType);    /* orderType (1 byte) */\n\tif (Stream_GetRemainingLength(s) < orderLength + 7U)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) %\" PRIuz \" < %\" PRIu16,\n\t\t           Stream_GetRemainingLength(s), orderLength + 7);\n\t\treturn FALSE;\n\t}\n\n\tstart = Stream_GetPosition(s);\n\tname = secondary_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Secondary Drawing Order %s\", name);\n\n\tif (!check_secondary_order_supported(update->log, settings, orderType, name))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_CACHE_BITMAP_COMPRESSED);\n\t\t\tCACHE_BITMAP_ORDER* order =\n\t\t\t    update_read_cache_bitmap_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmap, context, order);\n\t\t\t\tfree_cache_bitmap_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_BITMAP_COMPRESSED_V2);\n\t\t\tCACHE_BITMAP_V2_ORDER* order =\n\t\t\t    update_read_cache_bitmap_v2_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV2, context, order);\n\t\t\t\tfree_cache_bitmap_v2_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t{\n\t\t\tCACHE_BITMAP_V3_ORDER* order = update_read_cache_bitmap_v3_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV3, context, order);\n\t\t\t\tfree_cache_bitmap_v3_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t{\n\t\t\tCACHE_COLOR_TABLE_ORDER* order =\n\t\t\t    update_read_cache_color_table_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheColorTable, context, order);\n\t\t\t\tfree_cache_color_table_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_ORDER* order = update_read_cache_glyph_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyph, context, order);\n\t\t\t\t\t\tfree_cache_glyph_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_V2_ORDER* order =\n\t\t\t\t\t    update_read_cache_glyph_v2_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyphV2, context, order);\n\t\t\t\t\t\tfree_cache_glyph_v2_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\t/* [MS-RDPEGDI] 2.2.2.2.1.2.7 Cache Brush (CACHE_BRUSH_ORDER) */\n\t\t\t{\n\t\t\t\tCACHE_BRUSH_ORDER* order = update_read_cache_brush_order(update, s, extraFlags);\n\n\t\t\t\tif (order)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBrush, context, order);\n\t\t\t\t\tfree_cache_brush_order(context, order);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", name);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"SECONDARY ORDER %s failed\", name);\n\t}\n\n\tstart += orderLength + 7;\n\tend = Stream_GetPosition(s);\n\tif (start > end)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes too much\",\n\t\t           name, end - start);\n\t\treturn FALSE;\n\t}\n\tdiff = end - start;\n\tif (diff > 0)\n\t{\n\t\tWLog_Print(update->log, WLOG_DEBUG,\n\t\t           \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes short, skipping\", name, diff);\n\t\tif (!Stream_SafeSeek(s, diff))\n\t\t\treturn FALSE;\n\t}\n\treturn rc;\n}",
        "description": "In FreeRDP versions prior to 2.1.2, there exists an integer casting vulnerability within the `update_recv_secondary_order` function. This vulnerability affects all clients configured with both `+glyph-cache` and `relax-order-checks` options. This issue has been addressed in version 2.1.2.",
        "commit": "An out-of-bounds (OOB) read vulnerability was addressed in the `update_recv_secondary_order` function. This issue was identified and reported by @antonio-morales."
    },
    {
        "cwe": "CWE-843",
        "func_name": "GNOME/xsltFormatNumberConversion",
        "score": 0.8229466080665588,
        "func_before": "xmlXPathError\nxsltFormatNumberConversion(xsltDecimalFormatPtr self,\n\t\t\t   xmlChar *format,\n\t\t\t   double number,\n\t\t\t   xmlChar **result)\n{\n    xmlXPathError status = XPATH_EXPRESSION_OK;\n    xmlBufferPtr buffer;\n    xmlChar *the_format, *prefix = NULL, *suffix = NULL;\n    xmlChar *nprefix, *nsuffix = NULL;\n    xmlChar pchar;\n    int\t    prefix_length, suffix_length = 0, nprefix_length, nsuffix_length;\n    double  scale;\n    int\t    j, len;\n    int     self_grouping_len;\n    xsltFormatNumberInfo format_info;\n    /*\n     * delayed_multiplier allows a 'trailing' percent or\n     * permille to be treated as suffix\n     */\n    int\t\tdelayed_multiplier = 0;\n    /* flag to show no -ve format present for -ve number */\n    char\tdefault_sign = 0;\n    /* flag to show error found, should use default format */\n    char\tfound_error = 0;\n\n    if (xmlStrlen(format) <= 0) {\n\txsltTransformError(NULL, NULL, NULL,\n                \"xsltFormatNumberConversion : \"\n\t\t\"Invalid format (0-length)\\n\");\n    }\n    *result = NULL;\n    switch (xmlXPathIsInf(number)) {\n\tcase -1:\n\t    if (self->minusSign == NULL)\n\t\t*result = xmlStrdup(BAD_CAST \"-\");\n\t    else\n\t\t*result = xmlStrdup(self->minusSign);\n\t    /* no-break on purpose */\n\tcase 1:\n\t    if ((self == NULL) || (self->infinity == NULL))\n\t\t*result = xmlStrcat(*result, BAD_CAST \"Infinity\");\n\t    else\n\t\t*result = xmlStrcat(*result, self->infinity);\n\t    return(status);\n\tdefault:\n\t    if (xmlXPathIsNaN(number)) {\n\t\tif ((self == NULL) || (self->noNumber == NULL))\n\t\t    *result = xmlStrdup(BAD_CAST \"NaN\");\n\t\telse\n\t\t    *result = xmlStrdup(self->noNumber);\n\t\treturn(status);\n\t    }\n    }\n\n    buffer = xmlBufferCreate();\n    if (buffer == NULL) {\n\treturn XPATH_MEMORY_ERROR;\n    }\n\n    format_info.integer_hash = 0;\n    format_info.integer_digits = 0;\n    format_info.frac_digits = 0;\n    format_info.frac_hash = 0;\n    format_info.group = -1;\n    format_info.multiplier = 1;\n    format_info.add_decimal = FALSE;\n    format_info.is_multiplier_set = FALSE;\n    format_info.is_negative_pattern = FALSE;\n\n    the_format = format;\n\n    /*\n     * First we process the +ve pattern to get percent / permille,\n     * as well as main format\n     */\n    prefix = the_format;\n    prefix_length = xsltFormatNumberPreSuffix(self, &the_format, &format_info);\n    if (prefix_length < 0) {\n\tfound_error = 1;\n\tgoto OUTPUT_NUMBER;\n    }\n\n    /*\n     * Here we process the \"number\" part of the format.  It gets\n     * a little messy because of the percent/per-mille - if that\n     * appears at the end, it may be part of the suffix instead\n     * of part of the number, so the variable delayed_multiplier\n     * is used to handle it\n     */\n    self_grouping_len = xmlStrlen(self->grouping);\n    while ((*the_format != 0) &&\n\t   (xsltUTF8Charcmp(the_format, self->decimalPoint) != 0) &&\n\t   (xsltUTF8Charcmp(the_format, self->patternSeparator) != 0)) {\n\n\tif (delayed_multiplier != 0) {\n\t    format_info.multiplier = delayed_multiplier;\n\t    format_info.is_multiplier_set = TRUE;\n\t    delayed_multiplier = 0;\n\t}\n\tif (xsltUTF8Charcmp(the_format, self->digit) == 0) {\n\t    if (format_info.integer_digits > 0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    format_info.integer_hash++;\n\t    if (format_info.group >= 0)\n\t\tformat_info.group++;\n\t} else if (xsltUTF8Charcmp(the_format, self->zeroDigit) == 0) {\n\t    format_info.integer_digits++;\n\t    if (format_info.group >= 0)\n\t\tformat_info.group++;\n\t} else if ((self_grouping_len > 0) &&\n\t    (!xmlStrncmp(the_format, self->grouping, self_grouping_len))) {\n\t    /* Reset group count */\n\t    format_info.group = 0;\n\t    the_format += self_grouping_len;\n\t    continue;\n\t} else if (xsltUTF8Charcmp(the_format, self->percent) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 100;\n\t} else  if (xsltUTF8Charcmp(the_format, self->permille) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 1000;\n\t} else\n\t    break; /* while */\n\n\tif ((len=xmlUTF8Strsize(the_format, 1)) < 1) {\n\t    found_error = 1;\n\t    goto OUTPUT_NUMBER;\n\t}\n\tthe_format += len;\n\n    }\n\n    /* We have finished the integer part, now work on fraction */\n    if ( (*the_format != 0) &&\n         (xsltUTF8Charcmp(the_format, self->decimalPoint) == 0) ) {\n        format_info.add_decimal = TRUE;\n        if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n            found_error = 1;\n            goto OUTPUT_NUMBER;\n        }\n\tthe_format += len;\t/* Skip over the decimal */\n    }\n\n    while (*the_format != 0) {\n\n\tif (xsltUTF8Charcmp(the_format, self->zeroDigit) == 0) {\n\t    if (format_info.frac_hash != 0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    format_info.frac_digits++;\n\t} else if (xsltUTF8Charcmp(the_format, self->digit) == 0) {\n\t    format_info.frac_hash++;\n\t} else if (xsltUTF8Charcmp(the_format, self->percent) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 100;\n\t    if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t        found_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    the_format += len;\n\t    continue; /* while */\n\t} else if (xsltUTF8Charcmp(the_format, self->permille) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 1000;\n\t    if  ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t        found_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    the_format += len;\n\t    continue; /* while */\n\t} else if (xsltUTF8Charcmp(the_format, self->grouping) != 0) {\n\t    break; /* while */\n\t}\n\tif ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t    found_error = 1;\n\t    goto OUTPUT_NUMBER;\n\t}\n\tthe_format += len;\n\tif (delayed_multiplier != 0) {\n\t    format_info.multiplier = delayed_multiplier;\n\t    delayed_multiplier = 0;\n\t    format_info.is_multiplier_set = TRUE;\n\t}\n    }\n\n    /*\n     * If delayed_multiplier is set after processing the\n     * \"number\" part, should be in suffix\n     */\n    if (delayed_multiplier != 0) {\n\tthe_format -= len;\n\tdelayed_multiplier = 0;\n    }\n\n    suffix = the_format;\n    suffix_length = xsltFormatNumberPreSuffix(self, &the_format, &format_info);\n    if ( (suffix_length < 0) ||\n\t ((*the_format != 0) &&\n\t  (xsltUTF8Charcmp(the_format, self->patternSeparator) != 0)) ) {\n\tfound_error = 1;\n\tgoto OUTPUT_NUMBER;\n    }\n\n    /*\n     * We have processed the +ve prefix, number part and +ve suffix.\n     * If the number is -ve, we must substitute the -ve prefix / suffix\n     */\n    if (number < 0) {\n        /*\n\t * Note that j is the number of UTF8 chars before the separator,\n\t * not the number of bytes! (bug 151975)\n\t */\n        j =  xmlUTF8Strloc(format, self->patternSeparator);\n\tif (j < 0) {\n\t/* No -ve pattern present, so use default signing */\n\t    default_sign = 1;\n\t}\n\telse {\n\t    /* Skip over pattern separator (accounting for UTF8) */\n\t    the_format = (xmlChar *)xmlUTF8Strpos(format, j + 1);\n\t    /*\n\t     * Flag changes interpretation of percent/permille\n\t     * in -ve pattern\n\t     */\n\t    format_info.is_negative_pattern = TRUE;\n\t    format_info.is_multiplier_set = FALSE;\n\n\t    /* First do the -ve prefix */\n\t    nprefix = the_format;\n\t    nprefix_length = xsltFormatNumberPreSuffix(self,\n\t\t\t\t\t&the_format, &format_info);\n\t    if (nprefix_length<0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\n\t    while (*the_format != 0) {\n\t\tif ( (xsltUTF8Charcmp(the_format, (self)->percent) == 0) ||\n\t\t     (xsltUTF8Charcmp(the_format, (self)->permille)== 0) ) {\n\t\t    if (format_info.is_multiplier_set) {\n\t\t\tfound_error = 1;\n\t\t\tgoto OUTPUT_NUMBER;\n\t\t    }\n\t\t    format_info.is_multiplier_set = TRUE;\n\t\t    delayed_multiplier = 1;\n\t\t}\n\t\telse if (IS_SPECIAL(self, the_format))\n\t\t    delayed_multiplier = 0;\n\t\telse\n\t\t    break; /* while */\n\t\tif ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t\t    found_error = 1;\n\t\t    goto OUTPUT_NUMBER;\n\t\t}\n\t\tthe_format += len;\n\t    }\n\t    if (delayed_multiplier != 0) {\n\t\tformat_info.is_multiplier_set = FALSE;\n\t\tthe_format -= len;\n\t    }\n\n\t    /* Finally do the -ve suffix */\n\t    if (*the_format != 0) {\n\t\tnsuffix = the_format;\n\t\tnsuffix_length = xsltFormatNumberPreSuffix(self,\n\t\t\t\t\t&the_format, &format_info);\n\t\tif (nsuffix_length < 0) {\n\t\t    found_error = 1;\n\t\t    goto OUTPUT_NUMBER;\n\t\t}\n\t    }\n\t    else\n\t\tnsuffix_length = 0;\n\t    if (*the_format != 0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    /*\n\t     * Here's another Java peculiarity:\n\t     * if -ve prefix/suffix == +ve ones, discard & use default\n\t     */\n\t    if ((nprefix_length != prefix_length) ||\n\t\t(nsuffix_length != suffix_length) ||\n\t\t((nprefix_length > 0) &&\n\t\t (xmlStrncmp(nprefix, prefix, prefix_length) !=0 )) ||\n\t\t((nsuffix_length > 0) &&\n\t\t (xmlStrncmp(nsuffix, suffix, suffix_length) !=0 ))) {\n\t\tprefix = nprefix;\n\t\tprefix_length = nprefix_length;\n\t\tsuffix = nsuffix;\n\t\tsuffix_length = nsuffix_length;\n\t    } /* else {\n\t\tdefault_sign = 1;\n\t    }\n\t    */\n\t}\n    }\n\nOUTPUT_NUMBER:\n    if (found_error != 0) {\n\txsltTransformError(NULL, NULL, NULL,\n                \"xsltFormatNumberConversion : \"\n\t\t\"error in format string '%s', using default\\n\", format);\n\tdefault_sign = (number < 0.0) ? 1 : 0;\n\tprefix_length = suffix_length = 0;\n\tformat_info.integer_hash = 0;\n\tformat_info.integer_digits = 1;\n\tformat_info.frac_digits = 1;\n\tformat_info.frac_hash = 4;\n\tformat_info.group = -1;\n\tformat_info.multiplier = 1;\n\tformat_info.add_decimal = TRUE;\n    }\n\n    /* Ready to output our number.  First see if \"default sign\" is required */\n    if (default_sign != 0)\n\txmlBufferAdd(buffer, self->minusSign, xmlUTF8Strsize(self->minusSign, 1));\n\n    /* Put the prefix into the buffer */\n    for (j = 0; j < prefix_length; j++) {\n\tif ((pchar = *prefix++) == SYMBOL_QUOTE) {\n\t    len = xmlUTF8Strsize(prefix, 1);\n\t    xmlBufferAdd(buffer, prefix, len);\n\t    prefix += len;\n\t    j += len - 1;\t/* length of symbol less length of quote */\n\t} else\n\t    xmlBufferAdd(buffer, &pchar, 1);\n    }\n\n    /* Next do the integer part of the number */\n    number = fabs(number) * (double)format_info.multiplier;\n    scale = pow(10.0, (double)(format_info.frac_digits + format_info.frac_hash));\n    number = floor((scale * number + 0.5)) / scale;\n    if ((self->grouping != NULL) &&\n        (self->grouping[0] != 0)) {\n\n\tlen = xmlStrlen(self->grouping);\n\tpchar = xsltGetUTF8Char(self->grouping, &len);\n\txsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n\t\t\t\tformat_info.integer_digits,\n\t\t\t\tformat_info.group,\n\t\t\t\tpchar, len);\n    } else\n\txsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n\t\t\t\tformat_info.integer_digits,\n\t\t\t\tformat_info.group,\n\t\t\t\t',', 1);\n\n    /* Special case: java treats '.#' like '.0', '.##' like '.0#', etc. */\n    if ((format_info.integer_digits + format_info.integer_hash +\n\t format_info.frac_digits == 0) && (format_info.frac_hash > 0)) {\n        ++format_info.frac_digits;\n\t--format_info.frac_hash;\n    }\n\n    /* Add leading zero, if required */\n    if ((floor(number) == 0) &&\n\t(format_info.integer_digits + format_info.frac_digits == 0)) {\n        xmlBufferAdd(buffer, self->zeroDigit, xmlUTF8Strsize(self->zeroDigit, 1));\n    }\n\n    /* Next the fractional part, if required */\n    if (format_info.frac_digits + format_info.frac_hash == 0) {\n        if (format_info.add_decimal)\n\t    xmlBufferAdd(buffer, self->decimalPoint,\n\t\t\t xmlUTF8Strsize(self->decimalPoint, 1));\n    }\n    else {\n      number -= floor(number);\n\tif ((number != 0) || (format_info.frac_digits != 0)) {\n\t    xmlBufferAdd(buffer, self->decimalPoint,\n\t\t\t xmlUTF8Strsize(self->decimalPoint, 1));\n\t    number = floor(scale * number + 0.5);\n\t    for (j = format_info.frac_hash; j > 0; j--) {\n\t\tif (fmod(number, 10.0) >= 1.0)\n\t\t    break; /* for */\n\t\tnumber /= 10.0;\n\t    }\n\t    xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n\t\t\t\tformat_info.frac_digits + j,\n\t\t\t\t0, 0, 0);\n\t}\n    }\n    /* Put the suffix into the buffer */\n    for (j = 0; j < suffix_length; j++) {\n\tif ((pchar = *suffix++) == SYMBOL_QUOTE) {\n            len = xmlUTF8Strsize(suffix, 1);\n\t    xmlBufferAdd(buffer, suffix, len);\n\t    suffix += len;\n\t    j += len - 1;\t/* length of symbol less length of escape */\n\t} else\n\t    xmlBufferAdd(buffer, &pchar, 1);\n    }\n\n    *result = xmlStrdup(xmlBufferContent(buffer));\n    xmlBufferFree(buffer);\n    return status;\n}",
        "func_after": "xmlXPathError\nxsltFormatNumberConversion(xsltDecimalFormatPtr self,\n\t\t\t   xmlChar *format,\n\t\t\t   double number,\n\t\t\t   xmlChar **result)\n{\n    xmlXPathError status = XPATH_EXPRESSION_OK;\n    xmlBufferPtr buffer;\n    xmlChar *the_format, *prefix = NULL, *suffix = NULL;\n    xmlChar *nprefix, *nsuffix = NULL;\n    xmlChar pchar;\n    int\t    prefix_length, suffix_length = 0, nprefix_length, nsuffix_length;\n    double  scale;\n    int\t    j, len;\n    int     self_grouping_len;\n    xsltFormatNumberInfo format_info;\n    /*\n     * delayed_multiplier allows a 'trailing' percent or\n     * permille to be treated as suffix\n     */\n    int\t\tdelayed_multiplier = 0;\n    /* flag to show no -ve format present for -ve number */\n    char\tdefault_sign = 0;\n    /* flag to show error found, should use default format */\n    char\tfound_error = 0;\n\n    if (xmlStrlen(format) <= 0) {\n\txsltTransformError(NULL, NULL, NULL,\n                \"xsltFormatNumberConversion : \"\n\t\t\"Invalid format (0-length)\\n\");\n    }\n    *result = NULL;\n    switch (xmlXPathIsInf(number)) {\n\tcase -1:\n\t    if (self->minusSign == NULL)\n\t\t*result = xmlStrdup(BAD_CAST \"-\");\n\t    else\n\t\t*result = xmlStrdup(self->minusSign);\n\t    /* no-break on purpose */\n\tcase 1:\n\t    if ((self == NULL) || (self->infinity == NULL))\n\t\t*result = xmlStrcat(*result, BAD_CAST \"Infinity\");\n\t    else\n\t\t*result = xmlStrcat(*result, self->infinity);\n\t    return(status);\n\tdefault:\n\t    if (xmlXPathIsNaN(number)) {\n\t\tif ((self == NULL) || (self->noNumber == NULL))\n\t\t    *result = xmlStrdup(BAD_CAST \"NaN\");\n\t\telse\n\t\t    *result = xmlStrdup(self->noNumber);\n\t\treturn(status);\n\t    }\n    }\n\n    buffer = xmlBufferCreate();\n    if (buffer == NULL) {\n\treturn XPATH_MEMORY_ERROR;\n    }\n\n    format_info.integer_hash = 0;\n    format_info.integer_digits = 0;\n    format_info.frac_digits = 0;\n    format_info.frac_hash = 0;\n    format_info.group = -1;\n    format_info.multiplier = 1;\n    format_info.add_decimal = FALSE;\n    format_info.is_multiplier_set = FALSE;\n    format_info.is_negative_pattern = FALSE;\n\n    the_format = format;\n\n    /*\n     * First we process the +ve pattern to get percent / permille,\n     * as well as main format\n     */\n    prefix = the_format;\n    prefix_length = xsltFormatNumberPreSuffix(self, &the_format, &format_info);\n    if (prefix_length < 0) {\n\tfound_error = 1;\n\tgoto OUTPUT_NUMBER;\n    }\n\n    /*\n     * Here we process the \"number\" part of the format.  It gets\n     * a little messy because of the percent/per-mille - if that\n     * appears at the end, it may be part of the suffix instead\n     * of part of the number, so the variable delayed_multiplier\n     * is used to handle it\n     */\n    self_grouping_len = xmlStrlen(self->grouping);\n    while ((*the_format != 0) &&\n\t   (xsltUTF8Charcmp(the_format, self->decimalPoint) != 0) &&\n\t   (xsltUTF8Charcmp(the_format, self->patternSeparator) != 0)) {\n\n\tif (delayed_multiplier != 0) {\n\t    format_info.multiplier = delayed_multiplier;\n\t    format_info.is_multiplier_set = TRUE;\n\t    delayed_multiplier = 0;\n\t}\n\tif (xsltUTF8Charcmp(the_format, self->digit) == 0) {\n\t    if (format_info.integer_digits > 0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    format_info.integer_hash++;\n\t    if (format_info.group >= 0)\n\t\tformat_info.group++;\n\t} else if (xsltUTF8Charcmp(the_format, self->zeroDigit) == 0) {\n\t    format_info.integer_digits++;\n\t    if (format_info.group >= 0)\n\t\tformat_info.group++;\n\t} else if ((self_grouping_len > 0) &&\n\t    (!xmlStrncmp(the_format, self->grouping, self_grouping_len))) {\n\t    /* Reset group count */\n\t    format_info.group = 0;\n\t    the_format += self_grouping_len;\n\t    continue;\n\t} else if (xsltUTF8Charcmp(the_format, self->percent) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 100;\n\t} else  if (xsltUTF8Charcmp(the_format, self->permille) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 1000;\n\t} else\n\t    break; /* while */\n\n\tif ((len=xmlUTF8Strsize(the_format, 1)) < 1) {\n\t    found_error = 1;\n\t    goto OUTPUT_NUMBER;\n\t}\n\tthe_format += len;\n\n    }\n\n    /* We have finished the integer part, now work on fraction */\n    if ( (*the_format != 0) &&\n         (xsltUTF8Charcmp(the_format, self->decimalPoint) == 0) ) {\n        format_info.add_decimal = TRUE;\n        if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n            found_error = 1;\n            goto OUTPUT_NUMBER;\n        }\n\tthe_format += len;\t/* Skip over the decimal */\n    }\n\n    while (*the_format != 0) {\n\n\tif (xsltUTF8Charcmp(the_format, self->zeroDigit) == 0) {\n\t    if (format_info.frac_hash != 0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    format_info.frac_digits++;\n\t} else if (xsltUTF8Charcmp(the_format, self->digit) == 0) {\n\t    format_info.frac_hash++;\n\t} else if (xsltUTF8Charcmp(the_format, self->percent) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 100;\n\t    if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t        found_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    the_format += len;\n\t    continue; /* while */\n\t} else if (xsltUTF8Charcmp(the_format, self->permille) == 0) {\n\t    if (format_info.is_multiplier_set) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    delayed_multiplier = 1000;\n\t    if  ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t        found_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    the_format += len;\n\t    continue; /* while */\n\t} else if (xsltUTF8Charcmp(the_format, self->grouping) != 0) {\n\t    break; /* while */\n\t}\n\tif ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t    found_error = 1;\n\t    goto OUTPUT_NUMBER;\n\t}\n\tthe_format += len;\n\tif (delayed_multiplier != 0) {\n\t    format_info.multiplier = delayed_multiplier;\n\t    delayed_multiplier = 0;\n\t    format_info.is_multiplier_set = TRUE;\n\t}\n    }\n\n    /*\n     * If delayed_multiplier is set after processing the\n     * \"number\" part, should be in suffix\n     */\n    if (delayed_multiplier != 0) {\n\tthe_format -= len;\n\tdelayed_multiplier = 0;\n    }\n\n    suffix = the_format;\n    suffix_length = xsltFormatNumberPreSuffix(self, &the_format, &format_info);\n    if ( (suffix_length < 0) ||\n\t ((*the_format != 0) &&\n\t  (xsltUTF8Charcmp(the_format, self->patternSeparator) != 0)) ) {\n\tfound_error = 1;\n\tgoto OUTPUT_NUMBER;\n    }\n\n    /*\n     * We have processed the +ve prefix, number part and +ve suffix.\n     * If the number is -ve, we must substitute the -ve prefix / suffix\n     */\n    if (number < 0) {\n        /*\n\t * Note that j is the number of UTF8 chars before the separator,\n\t * not the number of bytes! (bug 151975)\n\t */\n        j =  xmlUTF8Strloc(format, self->patternSeparator);\n\tif (j < 0) {\n\t/* No -ve pattern present, so use default signing */\n\t    default_sign = 1;\n\t}\n\telse {\n\t    /* Skip over pattern separator (accounting for UTF8) */\n\t    the_format = (xmlChar *)xmlUTF8Strpos(format, j + 1);\n\t    /*\n\t     * Flag changes interpretation of percent/permille\n\t     * in -ve pattern\n\t     */\n\t    format_info.is_negative_pattern = TRUE;\n\t    format_info.is_multiplier_set = FALSE;\n\n\t    /* First do the -ve prefix */\n\t    nprefix = the_format;\n\t    nprefix_length = xsltFormatNumberPreSuffix(self,\n\t\t\t\t\t&the_format, &format_info);\n\t    if (nprefix_length<0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\n\t    while (*the_format != 0) {\n\t\tif ( (xsltUTF8Charcmp(the_format, (self)->percent) == 0) ||\n\t\t     (xsltUTF8Charcmp(the_format, (self)->permille)== 0) ) {\n\t\t    if (format_info.is_multiplier_set) {\n\t\t\tfound_error = 1;\n\t\t\tgoto OUTPUT_NUMBER;\n\t\t    }\n\t\t    format_info.is_multiplier_set = TRUE;\n\t\t    delayed_multiplier = 1;\n\t\t}\n\t\telse if (IS_SPECIAL(self, the_format))\n\t\t    delayed_multiplier = 0;\n\t\telse\n\t\t    break; /* while */\n\t\tif ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n\t\t    found_error = 1;\n\t\t    goto OUTPUT_NUMBER;\n\t\t}\n\t\tthe_format += len;\n\t    }\n\t    if (delayed_multiplier != 0) {\n\t\tformat_info.is_multiplier_set = FALSE;\n\t\tthe_format -= len;\n\t    }\n\n\t    /* Finally do the -ve suffix */\n\t    if (*the_format != 0) {\n\t\tnsuffix = the_format;\n\t\tnsuffix_length = xsltFormatNumberPreSuffix(self,\n\t\t\t\t\t&the_format, &format_info);\n\t\tif (nsuffix_length < 0) {\n\t\t    found_error = 1;\n\t\t    goto OUTPUT_NUMBER;\n\t\t}\n\t    }\n\t    else\n\t\tnsuffix_length = 0;\n\t    if (*the_format != 0) {\n\t\tfound_error = 1;\n\t\tgoto OUTPUT_NUMBER;\n\t    }\n\t    /*\n\t     * Here's another Java peculiarity:\n\t     * if -ve prefix/suffix == +ve ones, discard & use default\n\t     */\n\t    if ((nprefix_length != prefix_length) ||\n\t\t(nsuffix_length != suffix_length) ||\n\t\t((nprefix_length > 0) &&\n\t\t (xmlStrncmp(nprefix, prefix, prefix_length) !=0 )) ||\n\t\t((nsuffix_length > 0) &&\n\t\t (xmlStrncmp(nsuffix, suffix, suffix_length) !=0 ))) {\n\t\tprefix = nprefix;\n\t\tprefix_length = nprefix_length;\n\t\tsuffix = nsuffix;\n\t\tsuffix_length = nsuffix_length;\n\t    } /* else {\n\t\tdefault_sign = 1;\n\t    }\n\t    */\n\t}\n    }\n\nOUTPUT_NUMBER:\n    if (found_error != 0) {\n\txsltTransformError(NULL, NULL, NULL,\n                \"xsltFormatNumberConversion : \"\n\t\t\"error in format string '%s', using default\\n\", format);\n\tdefault_sign = (number < 0.0) ? 1 : 0;\n\tprefix_length = suffix_length = 0;\n\tformat_info.integer_hash = 0;\n\tformat_info.integer_digits = 1;\n\tformat_info.frac_digits = 1;\n\tformat_info.frac_hash = 4;\n\tformat_info.group = -1;\n\tformat_info.multiplier = 1;\n\tformat_info.add_decimal = TRUE;\n    }\n\n    /* Ready to output our number.  First see if \"default sign\" is required */\n    if (default_sign != 0)\n\txmlBufferAdd(buffer, self->minusSign, xmlUTF8Strsize(self->minusSign, 1));\n\n    /* Put the prefix into the buffer */\n    for (j = 0; j < prefix_length; j++) {\n\tif ((pchar = *prefix++) == SYMBOL_QUOTE) {\n\t    len = xmlUTF8Strsize(prefix, 1);\n\t    xmlBufferAdd(buffer, prefix, len);\n\t    prefix += len;\n\t    j += len - 1;\t/* length of symbol less length of quote */\n\t} else\n\t    xmlBufferAdd(buffer, &pchar, 1);\n    }\n\n    /* Next do the integer part of the number */\n    number = fabs(number) * (double)format_info.multiplier;\n    scale = pow(10.0, (double)(format_info.frac_digits + format_info.frac_hash));\n    number = floor((scale * number + 0.5)) / scale;\n    if ((self->grouping != NULL) &&\n        (self->grouping[0] != 0)) {\n        int gchar;\n\n\tlen = xmlStrlen(self->grouping);\n\tgchar = xsltGetUTF8Char(self->grouping, &len);\n\txsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n\t\t\t\tformat_info.integer_digits,\n\t\t\t\tformat_info.group,\n\t\t\t\tgchar, len);\n    } else\n\txsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n\t\t\t\tformat_info.integer_digits,\n\t\t\t\tformat_info.group,\n\t\t\t\t',', 1);\n\n    /* Special case: java treats '.#' like '.0', '.##' like '.0#', etc. */\n    if ((format_info.integer_digits + format_info.integer_hash +\n\t format_info.frac_digits == 0) && (format_info.frac_hash > 0)) {\n        ++format_info.frac_digits;\n\t--format_info.frac_hash;\n    }\n\n    /* Add leading zero, if required */\n    if ((floor(number) == 0) &&\n\t(format_info.integer_digits + format_info.frac_digits == 0)) {\n        xmlBufferAdd(buffer, self->zeroDigit, xmlUTF8Strsize(self->zeroDigit, 1));\n    }\n\n    /* Next the fractional part, if required */\n    if (format_info.frac_digits + format_info.frac_hash == 0) {\n        if (format_info.add_decimal)\n\t    xmlBufferAdd(buffer, self->decimalPoint,\n\t\t\t xmlUTF8Strsize(self->decimalPoint, 1));\n    }\n    else {\n      number -= floor(number);\n\tif ((number != 0) || (format_info.frac_digits != 0)) {\n\t    xmlBufferAdd(buffer, self->decimalPoint,\n\t\t\t xmlUTF8Strsize(self->decimalPoint, 1));\n\t    number = floor(scale * number + 0.5);\n\t    for (j = format_info.frac_hash; j > 0; j--) {\n\t\tif (fmod(number, 10.0) >= 1.0)\n\t\t    break; /* for */\n\t\tnumber /= 10.0;\n\t    }\n\t    xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n\t\t\t\tformat_info.frac_digits + j,\n\t\t\t\t0, 0, 0);\n\t}\n    }\n    /* Put the suffix into the buffer */\n    for (j = 0; j < suffix_length; j++) {\n\tif ((pchar = *suffix++) == SYMBOL_QUOTE) {\n            len = xmlUTF8Strsize(suffix, 1);\n\t    xmlBufferAdd(buffer, suffix, len);\n\t    suffix += len;\n\t    j += len - 1;\t/* length of symbol less length of escape */\n\t} else\n\t    xmlBufferAdd(buffer, &pchar, 1);\n    }\n\n    *result = xmlStrdup(xmlBufferContent(buffer));\n    xmlBufferFree(buffer);\n    return status;\n}",
        "description": "In libxslt 1.1.33, a type used to store grouping characters for an xsl:number instruction was insufficiently wide, allowing an invalid character/length combination to be passed to the xsltNumberFormatDecimal function. This issue resulted in the reading of uninitialized stack data.",
        "commit": "The vulnerability involves an uninitialized read error in the `xsltFormatNumberConversion` function due to an overly narrow character type. This issue can lead to passing an invalid character/length combination to the `xsltNumberFormatDecimal` function, resulting in an uninitialized read. This problem was identified through OSS-Fuzz testing."
    },
    {
        "cwe": "CWE-440",
        "func_name": "eclipse-openj9/Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex",
        "score": 0.8093158006668091,
        "func_before": "JNIEXPORT jint JNICALL Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *env, jclass InterfaceMethodHandle, jlong interfaceArg, jint itableIndex, jlong receiverClassArg)\n   {\n   J9Class  *interfaceClass = (J9Class*)(intptr_t)interfaceArg;\n   J9Class  *receiverClass  = (J9Class*)(intptr_t)receiverClassArg;\n   J9ITable *itableEntry;\n   for (itableEntry = (J9ITable*)receiverClass->iTable; itableEntry; itableEntry = itableEntry->next)\n      if (itableEntry->interfaceClass == interfaceClass)\n         break;\n   TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *itableArray = (UDATA*)(itableEntry+1);\n   return (itableArray[itableIndex] - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } indexAndLiterals =\n      {\n      (UDATA)interfaceClass,\n      (UDATA)itableIndex\n      };\n   J9Object *receiver = (J9Object*)receiverArg;\n   return (jint)jitLookupInterfaceMethod(receiver->clazz, &indexAndLiterals, 0);\n#endif\n   }",
        "func_after": "JNIEXPORT jint JNICALL Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *env, jclass InterfaceMethodHandle, jlong interfaceArg, jint itableIndex, jlong receiverClassArg)\n   {\n   J9Class  *interfaceClass = (J9Class*)(intptr_t)interfaceArg;\n   J9Class  *receiverClass  = (J9Class*)(intptr_t)receiverClassArg;\n   J9ITable *itableEntry;\n   for (itableEntry = (J9ITable*)receiverClass->iTable; itableEntry; itableEntry = itableEntry->next)\n      if (itableEntry->interfaceClass == interfaceClass)\n         break;\n   TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *itableArray = (UDATA*)(itableEntry+1);\n   UDATA vTableOffset = itableArray[itableIndex];\n   J9Method *method = *(J9Method**)((UDATA)receiverClass + vTableOffset);\n   if ((J9_ROM_METHOD_FROM_RAM_METHOD(method)->modifiers & J9AccPublic) == 0)\n      return -1;\n\n   return (vTableOffset - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } indexAndLiterals =\n      {\n      (UDATA)interfaceClass,\n      (UDATA)itableIndex\n      };\n   J9Object *receiver = (J9Object*)receiverArg;\n   return (jint)jitLookupInterfaceMethod(receiver->clazz, &indexAndLiterals, 0);\n#endif\n   }",
        "description": "In versions of Eclipse Openj9 prior to 0.29.0, the Java Virtual Machine (JVM) fails to throw an IllegalAccessError when MethodHandles are used to invoke methods that are not accessible through interfaces.",
        "commit": "The vulnerability involves a situation where an `IllegalAccessError` (IAE) is not being thrown appropriately when an `InterfaceHandle` encounters a non-public method during dispatch. The expected behavior is for the dispatch mechanism implemented by `InterfaceHandle` to mimic that of `invokeinterface`, which throws an `IAE` when attempting to access non-public methods. This discrepancy allows unauthorized access to non-public methods, potentially leading to security vulnerabilities."
    },
    {
        "cwe": "CWE-863",
        "func_name": "torvalds/internal_get_user_pages_fast",
        "score": 0.8309445381164551,
        "func_before": "static int internal_get_user_pages_fast(unsigned long start, int nr_pages,\n\t\t\t\t\tunsigned int gup_flags,\n\t\t\t\t\tstruct page **pages)\n{\n\tunsigned long addr, len, end;\n\tint nr_pinned = 0, ret = 0;\n\n\tif (WARN_ON_ONCE(gup_flags & ~(FOLL_WRITE | FOLL_LONGTERM |\n\t\t\t\t       FOLL_FORCE | FOLL_PIN | FOLL_GET)))\n\t\treturn -EINVAL;\n\n\tstart = untagged_addr(start) & PAGE_MASK;\n\taddr = start;\n\tlen = (unsigned long) nr_pages << PAGE_SHIFT;\n\tend = start + len;\n\n\tif (end <= start)\n\t\treturn 0;\n\tif (unlikely(!access_ok((void __user *)start, len)))\n\t\treturn -EFAULT;\n\n\tif (IS_ENABLED(CONFIG_HAVE_FAST_GUP) &&\n\t    gup_fast_permitted(start, end)) {\n\t\tlocal_irq_disable();\n\t\tgup_pgd_range(addr, end, gup_flags, pages, &nr_pinned);\n\t\tlocal_irq_enable();\n\t\tret = nr_pinned;\n\t}\n\n\tif (nr_pinned < nr_pages) {\n\t\t/* Try to get the remaining pages with get_user_pages */\n\t\tstart += nr_pinned << PAGE_SHIFT;\n\t\tpages += nr_pinned;\n\n\t\tret = __gup_longterm_unlocked(start, nr_pages - nr_pinned,\n\t\t\t\t\t      gup_flags, pages);\n\n\t\t/* Have to be a bit careful with return values */\n\t\tif (nr_pinned > 0) {\n\t\t\tif (ret < 0)\n\t\t\t\tret = nr_pinned;\n\t\t\telse\n\t\t\t\tret += nr_pinned;\n\t\t}\n\t}\n\n\treturn ret;\n}",
        "func_after": "static int internal_get_user_pages_fast(unsigned long start, int nr_pages,\n\t\t\t\t\tunsigned int gup_flags,\n\t\t\t\t\tstruct page **pages)\n{\n\tunsigned long addr, len, end;\n\tint nr_pinned = 0, ret = 0;\n\n\tif (WARN_ON_ONCE(gup_flags & ~(FOLL_WRITE | FOLL_LONGTERM |\n\t\t\t\t       FOLL_FORCE | FOLL_PIN | FOLL_GET)))\n\t\treturn -EINVAL;\n\n\tstart = untagged_addr(start) & PAGE_MASK;\n\taddr = start;\n\tlen = (unsigned long) nr_pages << PAGE_SHIFT;\n\tend = start + len;\n\n\tif (end <= start)\n\t\treturn 0;\n\tif (unlikely(!access_ok((void __user *)start, len)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * The FAST_GUP case requires FOLL_WRITE even for pure reads,\n\t * because get_user_pages() may need to cause an early COW in\n\t * order to avoid confusing the normal COW routines. So only\n\t * targets that are already writable are safe to do by just\n\t * looking at the page tables.\n\t */\n\tif (IS_ENABLED(CONFIG_HAVE_FAST_GUP) &&\n\t    gup_fast_permitted(start, end)) {\n\t\tlocal_irq_disable();\n\t\tgup_pgd_range(addr, end, gup_flags | FOLL_WRITE, pages, &nr_pinned);\n\t\tlocal_irq_enable();\n\t\tret = nr_pinned;\n\t}\n\n\tif (nr_pinned < nr_pages) {\n\t\t/* Try to get the remaining pages with get_user_pages */\n\t\tstart += nr_pinned << PAGE_SHIFT;\n\t\tpages += nr_pinned;\n\n\t\tret = __gup_longterm_unlocked(start, nr_pages - nr_pinned,\n\t\t\t\t\t      gup_flags, pages);\n\n\t\t/* Have to be a bit careful with return values */\n\t\tif (nr_pinned > 0) {\n\t\t\tif (ret < 0)\n\t\t\t\tret = nr_pinned;\n\t\t\telse\n\t\t\t\tret += nr_pinned;\n\t\t}\n\t}\n\n\treturn ret;\n}",
        "description": "An issue was discovered in the Linux kernel prior to version 5.7.3, affecting the memory management components located in mm/gup.c and mm/huge_memory.c. The get_user_pages (gup) implementation, when utilized for copy-on-write pages, fails to correctly handle read operation semantics, potentially resulting in unintended write access.",
        "commit": "The vulnerability involves the `get_user_pages()` function in the Linux kernel, which can lead to ambiguous behavior when dealing with copy-on-write (COW) pages. Specifically, the function may return a page pointer that is no longer associated with the original virtual memory area (VM) due to potential COW events. This ambiguity arises because the direction and timing of COW events are undefined, and a page can be unmapped by the thread that performed the `get_user_pages()` call, especially under memory pressure.\n\nTo mitigate this issue, the kernel introduces a change to force a COW event by setting the `FOLL_WRITE` flag when `FOLL_GET` or `FOLL_PIN` is used on a COW mapping. This ensures that the page is properly isolated from other VMs, preventing unintended access or control. However, this change affects the behavior of `get_user_pages_fast()`, which now refuses to follow read-only pages due to the potential need for COW breaking, leading to slower processing in such cases.\n\nThe current semantics are as follows:\n- `__get_user_pages_fast()`: No changes; it does not break COW unless explicitly asked.\n- `get_user_pages_fast()`: Refuses to follow read-only pages, requiring the slow path for COW breaking.\n- `get_user_pages()`: Forces COW breaking for COW mappings when using `FOLL_GET` or `FOLL_PIN`.\n\nThis change aims to clarify the semantics of `get_user_pages()` and reduce the risk of subtle bugs related to COW behavior. While this addresses the ambiguity, it is noted that true shared mappings will still allow pages to change under the user, meaning `get_user_pages()` does not guarantee a \"stable\" page."
    }
]