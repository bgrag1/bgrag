[
    {
        "cwe": "CWE-843",
        "func_name": "torvalds/__fib6_rule_action",
        "score": 0.7555786967277527,
        "func_before": "static int __fib6_rule_action(struct fib_rule *rule, struct flowi *flp,\n\t\t\t      int flags, struct fib_lookup_arg *arg)\n{\n\tstruct flowi6 *flp6 = &flp->u.ip6;\n\tstruct rt6_info *rt = NULL;\n\tstruct fib6_table *table;\n\tstruct net *net = rule->fr_net;\n\tpol_lookup_t lookup = arg->lookup_ptr;\n\tint err = 0;\n\tu32 tb_id;\n\n\tswitch (rule->action) {\n\tcase FR_ACT_TO_TBL:\n\t\tbreak;\n\tcase FR_ACT_UNREACHABLE:\n\t\terr = -ENETUNREACH;\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tgoto discard_pkt;\n\tdefault:\n\tcase FR_ACT_BLACKHOLE:\n\t\terr = -EINVAL;\n\t\trt = net->ipv6.ip6_blk_hole_entry;\n\t\tgoto discard_pkt;\n\tcase FR_ACT_PROHIBIT:\n\t\terr = -EACCES;\n\t\trt = net->ipv6.ip6_prohibit_entry;\n\t\tgoto discard_pkt;\n\t}\n\n\ttb_id = fib_rule_get_table(rule, arg);\n\ttable = fib6_get_table(net, tb_id);\n\tif (!table) {\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trt = lookup(net, table, flp6, arg->lookup_data, flags);\n\tif (rt != net->ipv6.ip6_null_entry) {\n\t\terr = fib6_rule_saddr(net, rule, flags, flp6,\n\t\t\t\t      ip6_dst_idev(&rt->dst)->dev);\n\n\t\tif (err == -EAGAIN)\n\t\t\tgoto again;\n\n\t\terr = rt->dst.error;\n\t\tif (err != -EAGAIN)\n\t\t\tgoto out;\n\t}\nagain:\n\tip6_rt_put(rt);\n\terr = -EAGAIN;\n\trt = NULL;\n\tgoto out;\n\ndiscard_pkt:\n\tdst_hold(&rt->dst);\nout:\n\targ->result = rt;\n\treturn err;\n}",
        "func_after": "static int __fib6_rule_action(struct fib_rule *rule, struct flowi *flp,\n\t\t\t      int flags, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct flowi6 *flp6 = &flp->u.ip6;\n\tstruct rt6_info *rt = NULL;\n\tstruct fib6_table *table;\n\tstruct net *net = rule->fr_net;\n\tpol_lookup_t lookup = arg->lookup_ptr;\n\tint err = 0;\n\tu32 tb_id;\n\n\tswitch (rule->action) {\n\tcase FR_ACT_TO_TBL:\n\t\tbreak;\n\tcase FR_ACT_UNREACHABLE:\n\t\terr = -ENETUNREACH;\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tgoto discard_pkt;\n\tdefault:\n\tcase FR_ACT_BLACKHOLE:\n\t\terr = -EINVAL;\n\t\trt = net->ipv6.ip6_blk_hole_entry;\n\t\tgoto discard_pkt;\n\tcase FR_ACT_PROHIBIT:\n\t\terr = -EACCES;\n\t\trt = net->ipv6.ip6_prohibit_entry;\n\t\tgoto discard_pkt;\n\t}\n\n\ttb_id = fib_rule_get_table(rule, arg);\n\ttable = fib6_get_table(net, tb_id);\n\tif (!table) {\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trt = lookup(net, table, flp6, arg->lookup_data, flags);\n\tif (rt != net->ipv6.ip6_null_entry) {\n\t\terr = fib6_rule_saddr(net, rule, flags, flp6,\n\t\t\t\t      ip6_dst_idev(&rt->dst)->dev);\n\n\t\tif (err == -EAGAIN)\n\t\t\tgoto again;\n\n\t\terr = rt->dst.error;\n\t\tif (err != -EAGAIN)\n\t\t\tgoto out;\n\t}\nagain:\n\tip6_rt_put(rt);\n\terr = -EAGAIN;\n\trt = NULL;\n\tgoto out;\n\ndiscard_pkt:\n\tdst_hold(&rt->dst);\nout:\n\tres->rt6 = rt;\n\treturn err;\n}",
        "description": "A flaw was identified in the IPv6 module of the Linux kernel, where the variable `arg.result` was inconsistently utilized within the function `fib6_rule_lookup`. At times, it held a value of type `rt6_info`, while at other times it held a value of type `fib6_info`. This inconsistency was not properly managed in other parts of the code that anticipated `rt6_info` unconditionally, potentially resulting in a kernel panic during the execution of `fib6_rule_suppress`.",
        "commit": "The use of the `result` argument in `fib_lookup_arg` is inconsistent within IPv6 routing mechanisms. Specifically, `arg.result` is sometimes utilized as a `fib6_result` and other times as a container for `rt6_info`. To address this inconsistency, `rt6_info` should be incorporated into `fib6_result`, ensuring uniform usage of `arg.result` throughout IPv6 routing rules. Additionally, the `rt6` entry is populated during lookups that return a `dst_entry`, but not for direct `fib_lookups` that merely require a `fib6_info`."
    },
    {
        "cwe": "CWE-20",
        "func_name": "torvalds/cifs_lookup",
        "score": 0.7692385315895081,
        "func_before": "struct dentry *\ncifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,\n\t    struct nameidata *nd)\n{\n\tint xid;\n\tint rc = 0; /* to get around spurious gcc warning, set to zero here */\n\t__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;\n\t__u16 fileHandle = 0;\n\tbool posix_open = false;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct cifsFileInfo *cfile;\n\tstruct inode *newInode = NULL;\n\tchar *full_path = NULL;\n\tstruct file *filp;\n\n\txid = GetXid();\n\n\tcFYI(1, \"parent inode = 0x%p name is: %s and dentry = 0x%p\",\n\t      parent_dir_inode, direntry->d_name.name, direntry);\n\n\t/* check whether path exists */\n\n\tcifs_sb = CIFS_SB(parent_dir_inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tFreeXid(xid);\n\t\treturn (struct dentry *)tlink;\n\t}\n\tpTcon = tlink_tcon(tlink);\n\n\t/*\n\t * Don't allow the separator character in a path component.\n\t * The VFS will not allow \"/\", but \"\\\" is allowed by posix.\n\t */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {\n\t\tint i;\n\t\tfor (i = 0; i < direntry->d_name.len; i++)\n\t\t\tif (direntry->d_name.name[i] == '\\\\') {\n\t\t\t\tcFYI(1, \"Invalid file name\");\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t}\n\n\t/*\n\t * O_EXCL: optimize away the lookup, but don't hash the dentry. Let\n\t * the VFS handle the create.\n\t */\n\tif (nd && (nd->flags & LOOKUP_EXCL)) {\n\t\td_instantiate(direntry, NULL);\n\t\trc = 0;\n\t\tgoto lookup_out;\n\t}\n\n\t/* can not grab the rename sem here since it would\n\tdeadlock in the cases (beginning of sys_rename itself)\n\tin which we already have the sb rename sem */\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto lookup_out;\n\t}\n\n\tif (direntry->d_inode != NULL) {\n\t\tcFYI(1, \"non-NULL inode in lookup\");\n\t} else {\n\t\tcFYI(1, \"NULL inode in lookup\");\n\t}\n\tcFYI(1, \"Full path: %s inode = 0x%p\", full_path, direntry->d_inode);\n\n\t/* Posix open is only called (at lookup time) for file create now.\n\t * For opens (rather than creates), because we do not know if it\n\t * is a file or directory yet, and current Samba no longer allows\n\t * us to do posix open on dirs, we could end up wasting an open call\n\t * on what turns out to be a dir. For file opens, we wait to call posix\n\t * open till cifs_open.  It could be added here (lookup) in the future\n\t * but the performance tradeoff of the extra network request when EISDIR\n\t * or EACCES is returned would have to be weighed against the 50%\n\t * reduction in network traffic in the other paths.\n\t */\n\tif (pTcon->unix_ext) {\n\t\tif (nd && !(nd->flags & LOOKUP_DIRECTORY) &&\n\t\t     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&\n\t\t     (nd->intent.open.file->f_flags & O_CREAT)) {\n\t\t\trc = cifs_posix_open(full_path, &newInode,\n\t\t\t\t\tparent_dir_inode->i_sb,\n\t\t\t\t\tnd->intent.open.create_mode,\n\t\t\t\t\tnd->intent.open.file->f_flags, &oplock,\n\t\t\t\t\t&fileHandle, xid);\n\t\t\t/*\n\t\t\t * The check below works around a bug in POSIX\n\t\t\t * open in samba versions 3.3.1 and earlier where\n\t\t\t * open could incorrectly fail with invalid parameter.\n\t\t\t * If either that or op not supported returned, follow\n\t\t\t * the normal lookup.\n\t\t\t */\n\t\t\tif ((rc == 0) || (rc == -ENOENT))\n\t\t\t\tposix_open = true;\n\t\t\telse if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))\n\t\t\t\tpTcon->broken_posix_open = true;\n\t\t}\n\t\tif (!posix_open)\n\t\t\trc = cifs_get_inode_info_unix(&newInode, full_path,\n\t\t\t\t\t\tparent_dir_inode->i_sb, xid);\n\t} else\n\t\trc = cifs_get_inode_info(&newInode, full_path, NULL,\n\t\t\t\tparent_dir_inode->i_sb, xid, NULL);\n\n\tif ((rc == 0) && (newInode != NULL)) {\n\t\td_add(direntry, newInode);\n\t\tif (posix_open) {\n\t\t\tfilp = lookup_instantiate_filp(nd, direntry,\n\t\t\t\t\t\t       generic_file_open);\n\t\t\tif (IS_ERR(filp)) {\n\t\t\t\trc = PTR_ERR(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\n\t\t\tcfile = cifs_new_fileinfo(fileHandle, filp, tlink,\n\t\t\t\t\t\t  oplock);\n\t\t\tif (cfile == NULL) {\n\t\t\t\tfput(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t\t}\n\t\t/* since paths are not looked up by component - the parent\n\t\t   directories are presumed to be good here */\n\t\trenew_parental_timestamps(direntry);\n\n\t} else if (rc == -ENOENT) {\n\t\trc = 0;\n\t\tdirentry->d_time = jiffies;\n\t\td_add(direntry, NULL);\n\t/*\tif it was once a directory (but how can we tell?) we could do\n\t\tshrink_dcache_parent(direntry); */\n\t} else if (rc != -EACCES) {\n\t\tcERROR(1, \"Unexpected lookup error %d\", rc);\n\t\t/* We special case check for Access Denied - since that\n\t\tis a common return code */\n\t}\n\nlookup_out:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\tFreeXid(xid);\n\treturn ERR_PTR(rc);\n}",
        "func_after": "struct dentry *\ncifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,\n\t    struct nameidata *nd)\n{\n\tint xid;\n\tint rc = 0; /* to get around spurious gcc warning, set to zero here */\n\t__u32 oplock = enable_oplocks ? REQ_OPLOCK : 0;\n\t__u16 fileHandle = 0;\n\tbool posix_open = false;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct cifsFileInfo *cfile;\n\tstruct inode *newInode = NULL;\n\tchar *full_path = NULL;\n\tstruct file *filp;\n\n\txid = GetXid();\n\n\tcFYI(1, \"parent inode = 0x%p name is: %s and dentry = 0x%p\",\n\t      parent_dir_inode, direntry->d_name.name, direntry);\n\n\t/* check whether path exists */\n\n\tcifs_sb = CIFS_SB(parent_dir_inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tFreeXid(xid);\n\t\treturn (struct dentry *)tlink;\n\t}\n\tpTcon = tlink_tcon(tlink);\n\n\t/*\n\t * Don't allow the separator character in a path component.\n\t * The VFS will not allow \"/\", but \"\\\" is allowed by posix.\n\t */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {\n\t\tint i;\n\t\tfor (i = 0; i < direntry->d_name.len; i++)\n\t\t\tif (direntry->d_name.name[i] == '\\\\') {\n\t\t\t\tcFYI(1, \"Invalid file name\");\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t}\n\n\t/*\n\t * O_EXCL: optimize away the lookup, but don't hash the dentry. Let\n\t * the VFS handle the create.\n\t */\n\tif (nd && (nd->flags & LOOKUP_EXCL)) {\n\t\td_instantiate(direntry, NULL);\n\t\trc = 0;\n\t\tgoto lookup_out;\n\t}\n\n\t/* can not grab the rename sem here since it would\n\tdeadlock in the cases (beginning of sys_rename itself)\n\tin which we already have the sb rename sem */\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto lookup_out;\n\t}\n\n\tif (direntry->d_inode != NULL) {\n\t\tcFYI(1, \"non-NULL inode in lookup\");\n\t} else {\n\t\tcFYI(1, \"NULL inode in lookup\");\n\t}\n\tcFYI(1, \"Full path: %s inode = 0x%p\", full_path, direntry->d_inode);\n\n\t/* Posix open is only called (at lookup time) for file create now.\n\t * For opens (rather than creates), because we do not know if it\n\t * is a file or directory yet, and current Samba no longer allows\n\t * us to do posix open on dirs, we could end up wasting an open call\n\t * on what turns out to be a dir. For file opens, we wait to call posix\n\t * open till cifs_open.  It could be added here (lookup) in the future\n\t * but the performance tradeoff of the extra network request when EISDIR\n\t * or EACCES is returned would have to be weighed against the 50%\n\t * reduction in network traffic in the other paths.\n\t */\n\tif (pTcon->unix_ext) {\n\t\tif (nd && !(nd->flags & LOOKUP_DIRECTORY) &&\n\t\t     (nd->flags & LOOKUP_OPEN) && !pTcon->broken_posix_open &&\n\t\t     (nd->intent.open.file->f_flags & O_CREAT)) {\n\t\t\trc = cifs_posix_open(full_path, &newInode,\n\t\t\t\t\tparent_dir_inode->i_sb,\n\t\t\t\t\tnd->intent.open.create_mode,\n\t\t\t\t\tnd->intent.open.file->f_flags, &oplock,\n\t\t\t\t\t&fileHandle, xid);\n\t\t\t/*\n\t\t\t * The check below works around a bug in POSIX\n\t\t\t * open in samba versions 3.3.1 and earlier where\n\t\t\t * open could incorrectly fail with invalid parameter.\n\t\t\t * If either that or op not supported returned, follow\n\t\t\t * the normal lookup.\n\t\t\t */\n\t\t\tswitch (rc) {\n\t\t\tcase 0:\n\t\t\t\t/*\n\t\t\t\t * The server may allow us to open things like\n\t\t\t\t * FIFOs, but the client isn't set up to deal\n\t\t\t\t * with that. If it's not a regular file, just\n\t\t\t\t * close it and proceed as if it were a normal\n\t\t\t\t * lookup.\n\t\t\t\t */\n\t\t\t\tif (newInode && !S_ISREG(newInode->i_mode)) {\n\t\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase -ENOENT:\n\t\t\t\tposix_open = true;\n\t\t\tcase -EOPNOTSUPP:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpTcon->broken_posix_open = true;\n\t\t\t}\n\t\t}\n\t\tif (!posix_open)\n\t\t\trc = cifs_get_inode_info_unix(&newInode, full_path,\n\t\t\t\t\t\tparent_dir_inode->i_sb, xid);\n\t} else\n\t\trc = cifs_get_inode_info(&newInode, full_path, NULL,\n\t\t\t\tparent_dir_inode->i_sb, xid, NULL);\n\n\tif ((rc == 0) && (newInode != NULL)) {\n\t\td_add(direntry, newInode);\n\t\tif (posix_open) {\n\t\t\tfilp = lookup_instantiate_filp(nd, direntry,\n\t\t\t\t\t\t       generic_file_open);\n\t\t\tif (IS_ERR(filp)) {\n\t\t\t\trc = PTR_ERR(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\n\t\t\tcfile = cifs_new_fileinfo(fileHandle, filp, tlink,\n\t\t\t\t\t\t  oplock);\n\t\t\tif (cfile == NULL) {\n\t\t\t\tfput(filp);\n\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto lookup_out;\n\t\t\t}\n\t\t}\n\t\t/* since paths are not looked up by component - the parent\n\t\t   directories are presumed to be good here */\n\t\trenew_parental_timestamps(direntry);\n\n\t} else if (rc == -ENOENT) {\n\t\trc = 0;\n\t\tdirentry->d_time = jiffies;\n\t\td_add(direntry, NULL);\n\t/*\tif it was once a directory (but how can we tell?) we could do\n\t\tshrink_dcache_parent(direntry); */\n\t} else if (rc != -EACCES) {\n\t\tcERROR(1, \"Unexpected lookup error %d\", rc);\n\t\t/* We special case check for Access Denied - since that\n\t\tis a common return code */\n\t}\n\nlookup_out:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\tFreeXid(xid);\n\treturn ERR_PTR(rc);\n}",
        "description": "The `cifs_lookup` function in the CIFS directory handling module of the Linux kernel, prior to version 3.2.10, permits local users to trigger a denial of service (OOPS) condition by attempting to access a special file, such as a FIFO.",
        "commit": "The CIFS code attempts to open files during lookup under specific conditions. However, if the file turned out to be a FIFO or another special file type, the open file handle would be leaked, resulting in a dentry reference count mismatch and causing an oops error during unmount. This issue has been resolved by ensuring that the file handle on the server is closed if the file is not a regular file. Additionally, the code has been refactored to use a switch statement instead of a complex if-else structure."
    },
    {
        "cwe": "CWE-416",
        "func_name": "torvalds/__ext4_new_inode",
        "score": 0.7677320837974548,
        "func_before": "struct inode *__ext4_new_inode(handle_t *handle, struct inode *dir,\n\t\t\t       umode_t mode, const struct qstr *qstr,\n\t\t\t       __u32 goal, uid_t *owner, __u32 i_flags,\n\t\t\t       int handle_type, unsigned int line_no,\n\t\t\t       int nblocks)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *inode_bitmap_bh = NULL;\n\tstruct buffer_head *group_desc_bh;\n\text4_group_t ngroups, group = 0;\n\tunsigned long ino = 0;\n\tstruct inode *inode;\n\tstruct ext4_group_desc *gdp = NULL;\n\tstruct ext4_inode_info *ei;\n\tstruct ext4_sb_info *sbi;\n\tint ret2, err;\n\tstruct inode *ret;\n\text4_group_t i;\n\text4_group_t flex_group;\n\tstruct ext4_group_info *grp;\n\tint encrypt = 0;\n\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\n\tsb = dir->i_sb;\n\tsbi = EXT4_SB(sb);\n\n\tif (unlikely(ext4_forced_shutdown(sbi)))\n\t\treturn ERR_PTR(-EIO);\n\n\tif ((ext4_encrypted_inode(dir) || DUMMY_ENCRYPTION_ENABLED(sbi)) &&\n\t    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)) &&\n\t    !(i_flags & EXT4_EA_INODE_FL)) {\n\t\terr = fscrypt_get_encryption_info(dir);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tif (!fscrypt_has_encryption_key(dir))\n\t\t\treturn ERR_PTR(-ENOKEY);\n\t\tencrypt = 1;\n\t}\n\n\tif (!handle && sbi->s_journal && !(i_flags & EXT4_EA_INODE_FL)) {\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t\tstruct posix_acl *p = get_acl(dir, ACL_TYPE_DEFAULT);\n\n\t\tif (IS_ERR(p))\n\t\t\treturn ERR_CAST(p);\n\t\tif (p) {\n\t\t\tint acl_size = p->a_count * sizeof(ext4_acl_entry);\n\n\t\t\tnblocks += (S_ISDIR(mode) ? 2 : 1) *\n\t\t\t\t__ext4_xattr_set_credits(sb, NULL /* inode */,\n\t\t\t\t\tNULL /* block_bh */, acl_size,\n\t\t\t\t\ttrue /* is_create */);\n\t\t\tposix_acl_release(p);\n\t\t}\n#endif\n\n#ifdef CONFIG_SECURITY\n\t\t{\n\t\t\tint num_security_xattrs = 1;\n\n#ifdef CONFIG_INTEGRITY\n\t\t\tnum_security_xattrs++;\n#endif\n\t\t\t/*\n\t\t\t * We assume that security xattrs are never\n\t\t\t * more than 1k.  In practice they are under\n\t\t\t * 128 bytes.\n\t\t\t */\n\t\t\tnblocks += num_security_xattrs *\n\t\t\t\t__ext4_xattr_set_credits(sb, NULL /* inode */,\n\t\t\t\t\tNULL /* block_bh */, 1024,\n\t\t\t\t\ttrue /* is_create */);\n\t\t}\n#endif\n\t\tif (encrypt)\n\t\t\tnblocks += __ext4_xattr_set_credits(sb,\n\t\t\t\t\tNULL /* inode */, NULL /* block_bh */,\n\t\t\t\t\tFSCRYPT_SET_CONTEXT_MAX_SIZE,\n\t\t\t\t\ttrue /* is_create */);\n\t}\n\n\tngroups = ext4_get_groups_count(sb);\n\ttrace_ext4_request_inode(dir, mode);\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tei = EXT4_I(inode);\n\n\t/*\n\t * Initialize owners and quota early so that we don't have to account\n\t * for quota initialization worst case in standard inode creating\n\t * transaction\n\t */\n\tif (owner) {\n\t\tinode->i_mode = mode;\n\t\ti_uid_write(inode, owner[0]);\n\t\ti_gid_write(inode, owner[1]);\n\t} else if (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tif (ext4_has_feature_project(sb) &&\n\t    ext4_test_inode_flag(dir, EXT4_INODE_PROJINHERIT))\n\t\tei->i_projid = EXT4_I(dir)->i_projid;\n\telse\n\t\tei->i_projid = make_kprojid(&init_user_ns, EXT4_DEF_PROJID);\n\n\terr = dquot_initialize(inode);\n\tif (err)\n\t\tgoto out;\n\n\tif (!goal)\n\t\tgoal = sbi->s_inode_goal;\n\n\tif (goal && goal <= le32_to_cpu(sbi->s_es->s_inodes_count)) {\n\t\tgroup = (goal - 1) / EXT4_INODES_PER_GROUP(sb);\n\t\tino = (goal - 1) % EXT4_INODES_PER_GROUP(sb);\n\t\tret2 = 0;\n\t\tgoto got_group;\n\t}\n\n\tif (S_ISDIR(mode))\n\t\tret2 = find_group_orlov(sb, dir, &group, mode, qstr);\n\telse\n\t\tret2 = find_group_other(sb, dir, &group, mode);\n\ngot_group:\n\tEXT4_I(dir)->i_last_alloc_group = group;\n\terr = -ENOSPC;\n\tif (ret2 == -1)\n\t\tgoto out;\n\n\t/*\n\t * Normally we will only go through one pass of this loop,\n\t * unless we get unlucky and it turns out the group we selected\n\t * had its last inode grabbed by someone else.\n\t */\n\tfor (i = 0; i < ngroups; i++, ino = 0) {\n\t\terr = -EIO;\n\n\t\tgdp = ext4_get_group_desc(sb, group, &group_desc_bh);\n\t\tif (!gdp)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Check free inodes count before loading bitmap.\n\t\t */\n\t\tif (ext4_free_inodes_count(sb, gdp) == 0)\n\t\t\tgoto next_group;\n\n\t\tgrp = ext4_get_group_info(sb, group);\n\t\t/* Skip groups with already-known suspicious inode tables */\n\t\tif (EXT4_MB_GRP_IBITMAP_CORRUPT(grp))\n\t\t\tgoto next_group;\n\n\t\tbrelse(inode_bitmap_bh);\n\t\tinode_bitmap_bh = ext4_read_inode_bitmap(sb, group);\n\t\t/* Skip groups with suspicious inode tables */\n\t\tif (EXT4_MB_GRP_IBITMAP_CORRUPT(grp) ||\n\t\t    IS_ERR(inode_bitmap_bh)) {\n\t\t\tinode_bitmap_bh = NULL;\n\t\t\tgoto next_group;\n\t\t}\n\nrepeat_in_this_group:\n\t\tret2 = find_inode_bit(sb, group, inode_bitmap_bh, &ino);\n\t\tif (!ret2)\n\t\t\tgoto next_group;\n\n\t\tif (group == 0 && (ino + 1) < EXT4_FIRST_INO(sb)) {\n\t\t\text4_error(sb, \"reserved inode found cleared - \"\n\t\t\t\t   \"inode=%lu\", ino + 1);\n\t\t\text4_mark_group_bitmap_corrupted(sb, group,\n\t\t\t\t\tEXT4_GROUP_INFO_IBITMAP_CORRUPT);\n\t\t\tgoto next_group;\n\t\t}\n\n\t\tif (!handle) {\n\t\t\tBUG_ON(nblocks <= 0);\n\t\t\thandle = __ext4_journal_start_sb(dir->i_sb, line_no,\n\t\t\t\t\t\t\t handle_type, nblocks,\n\t\t\t\t\t\t\t 0);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\terr = PTR_ERR(handle);\n\t\t\t\text4_std_error(sb, err);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tBUFFER_TRACE(inode_bitmap_bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, inode_bitmap_bh);\n\t\tif (err) {\n\t\t\text4_std_error(sb, err);\n\t\t\tgoto out;\n\t\t}\n\t\text4_lock_group(sb, group);\n\t\tret2 = ext4_test_and_set_bit(ino, inode_bitmap_bh->b_data);\n\t\tif (ret2) {\n\t\t\t/* Someone already took the bit. Repeat the search\n\t\t\t * with lock held.\n\t\t\t */\n\t\t\tret2 = find_inode_bit(sb, group, inode_bitmap_bh, &ino);\n\t\t\tif (ret2) {\n\t\t\t\text4_set_bit(ino, inode_bitmap_bh->b_data);\n\t\t\t\tret2 = 0;\n\t\t\t} else {\n\t\t\t\tret2 = 1; /* we didn't grab the inode */\n\t\t\t}\n\t\t}\n\t\text4_unlock_group(sb, group);\n\t\tino++;\t\t/* the inode bitmap is zero-based */\n\t\tif (!ret2)\n\t\t\tgoto got; /* we grabbed the inode! */\n\n\t\tif (ino < EXT4_INODES_PER_GROUP(sb))\n\t\t\tgoto repeat_in_this_group;\nnext_group:\n\t\tif (++group == ngroups)\n\t\t\tgroup = 0;\n\t}\n\terr = -ENOSPC;\n\tgoto out;\n\ngot:\n\tBUFFER_TRACE(inode_bitmap_bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, inode_bitmap_bh);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto out;\n\t}\n\n\tBUFFER_TRACE(group_desc_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, group_desc_bh);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto out;\n\t}\n\n\t/* We may have to initialize the block bitmap if it isn't already */\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tstruct buffer_head *block_bitmap_bh;\n\n\t\tblock_bitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (IS_ERR(block_bitmap_bh)) {\n\t\t\terr = PTR_ERR(block_bitmap_bh);\n\t\t\tgoto out;\n\t\t}\n\t\tBUFFER_TRACE(block_bitmap_bh, \"get block bitmap access\");\n\t\terr = ext4_journal_get_write_access(handle, block_bitmap_bh);\n\t\tif (err) {\n\t\t\tbrelse(block_bitmap_bh);\n\t\t\text4_std_error(sb, err);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUFFER_TRACE(block_bitmap_bh, \"dirty block bitmap\");\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, block_bitmap_bh);\n\n\t\t/* recheck and clear flag under lock if we still need to */\n\t\text4_lock_group(sb, group);\n\t\tif (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\t\tgdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);\n\t\t\text4_free_group_clusters_set(sb, gdp,\n\t\t\t\text4_free_clusters_after_init(sb, group, gdp));\n\t\t\text4_block_bitmap_csum_set(sb, group, gdp,\n\t\t\t\t\t\t   block_bitmap_bh);\n\t\t\text4_group_desc_csum_set(sb, group, gdp);\n\t\t}\n\t\text4_unlock_group(sb, group);\n\t\tbrelse(block_bitmap_bh);\n\n\t\tif (err) {\n\t\t\text4_std_error(sb, err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Update the relevant bg descriptor fields */\n\tif (ext4_has_group_desc_csum(sb)) {\n\t\tint free;\n\t\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\n\t\tdown_read(&grp->alloc_sem); /* protect vs itable lazyinit */\n\t\text4_lock_group(sb, group); /* while we modify the bg desc */\n\t\tfree = EXT4_INODES_PER_GROUP(sb) -\n\t\t\text4_itable_unused_count(sb, gdp);\n\t\tif (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)) {\n\t\t\tgdp->bg_flags &= cpu_to_le16(~EXT4_BG_INODE_UNINIT);\n\t\t\tfree = 0;\n\t\t}\n\t\t/*\n\t\t * Check the relative inode number against the last used\n\t\t * relative inode number in this group. if it is greater\n\t\t * we need to update the bg_itable_unused count\n\t\t */\n\t\tif (ino > free)\n\t\t\text4_itable_unused_set(sb, gdp,\n\t\t\t\t\t(EXT4_INODES_PER_GROUP(sb) - ino));\n\t\tup_read(&grp->alloc_sem);\n\t} else {\n\t\text4_lock_group(sb, group);\n\t}\n\n\text4_free_inodes_set(sb, gdp, ext4_free_inodes_count(sb, gdp) - 1);\n\tif (S_ISDIR(mode)) {\n\t\text4_used_dirs_set(sb, gdp, ext4_used_dirs_count(sb, gdp) + 1);\n\t\tif (sbi->s_log_groups_per_flex) {\n\t\t\text4_group_t f = ext4_flex_group(sbi, group);\n\n\t\t\tatomic_inc(&sbi->s_flex_groups[f].used_dirs);\n\t\t}\n\t}\n\tif (ext4_has_group_desc_csum(sb)) {\n\t\text4_inode_bitmap_csum_set(sb, group, gdp, inode_bitmap_bh,\n\t\t\t\t\t   EXT4_INODES_PER_GROUP(sb) / 8);\n\t\text4_group_desc_csum_set(sb, group, gdp);\n\t}\n\text4_unlock_group(sb, group);\n\n\tBUFFER_TRACE(group_desc_bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, group_desc_bh);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto out;\n\t}\n\n\tpercpu_counter_dec(&sbi->s_freeinodes_counter);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\tflex_group = ext4_flex_group(sbi, group);\n\t\tatomic_dec(&sbi->s_flex_groups[flex_group].free_inodes);\n\t}\n\n\tinode->i_ino = ino + group * EXT4_INODES_PER_GROUP(sb);\n\t/* This is the optimal IO size (for stat), not the fs block size */\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = ei->i_crtime =\n\t\t\t\t\t\t       current_time(inode);\n\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_dir_start_lookup = 0;\n\tei->i_disksize = 0;\n\n\t/* Don't inherit extent flag from directory, amongst others. */\n\tei->i_flags =\n\t\text4_mask_flags(mode, EXT4_I(dir)->i_flags & EXT4_FL_INHERITED);\n\tei->i_flags |= i_flags;\n\tei->i_file_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_group = group;\n\tei->i_last_alloc_group = ~0;\n\n\text4_set_inode_flags(inode);\n\tif (IS_DIRSYNC(inode))\n\t\text4_handle_sync(handle);\n\tif (insert_inode_locked(inode) < 0) {\n\t\t/*\n\t\t * Likely a bitmap corruption causing inode to be allocated\n\t\t * twice.\n\t\t */\n\t\terr = -EIO;\n\t\text4_error(sb, \"failed to insert inode %lu: doubly allocated?\",\n\t\t\t   inode->i_ino);\n\t\text4_mark_group_bitmap_corrupted(sb, group,\n\t\t\t\t\tEXT4_GROUP_INFO_IBITMAP_CORRUPT);\n\t\tgoto out;\n\t}\n\tinode->i_generation = prandom_u32();\n\n\t/* Precompute checksum seed for inode metadata */\n\tif (ext4_has_metadata_csum(sb)) {\n\t\t__u32 csum;\n\t\t__le32 inum = cpu_to_le32(inode->i_ino);\n\t\t__le32 gen = cpu_to_le32(inode->i_generation);\n\t\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&inum,\n\t\t\t\t   sizeof(inum));\n\t\tei->i_csum_seed = ext4_chksum(sbi, csum, (__u8 *)&gen,\n\t\t\t\t\t      sizeof(gen));\n\t}\n\n\text4_clear_state_flags(ei); /* Only relevant on 32-bit archs */\n\text4_set_inode_state(inode, EXT4_STATE_NEW);\n\n\tei->i_extra_isize = sbi->s_want_extra_isize;\n\tei->i_inline_off = 0;\n\tif (ext4_has_feature_inline_data(sb))\n\t\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\tret = inode;\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\t/*\n\t * Since the encryption xattr will always be unique, create it first so\n\t * that it's less likely to end up in an external xattr block and\n\t * prevent its deduplication.\n\t */\n\tif (encrypt) {\n\t\terr = fscrypt_inherit_context(dir, inode, handle, true);\n\t\tif (err)\n\t\t\tgoto fail_free_drop;\n\t}\n\n\tif (!(ei->i_flags & EXT4_EA_INODE_FL)) {\n\t\terr = ext4_init_acl(handle, inode, dir);\n\t\tif (err)\n\t\t\tgoto fail_free_drop;\n\n\t\terr = ext4_init_security(handle, inode, dir, qstr);\n\t\tif (err)\n\t\t\tgoto fail_free_drop;\n\t}\n\n\tif (ext4_has_feature_extents(sb)) {\n\t\t/* set extent flag only for directory, file and normal symlink*/\n\t\tif (S_ISDIR(mode) || S_ISREG(mode) || S_ISLNK(mode)) {\n\t\t\text4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode);\n\t\t}\n\t}\n\n\tif (ext4_handle_valid(handle)) {\n\t\tei->i_sync_tid = handle->h_transaction->t_tid;\n\t\tei->i_datasync_tid = handle->h_transaction->t_tid;\n\t}\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto fail_free_drop;\n\t}\n\n\text4_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_allocate_inode(inode, dir, mode);\n\tbrelse(inode_bitmap_bh);\n\treturn ret;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\nfail_drop:\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nout:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\tbrelse(inode_bitmap_bh);\n\treturn ERR_PTR(err);\n}",
        "func_after": "struct inode *__ext4_new_inode(handle_t *handle, struct inode *dir,\n\t\t\t       umode_t mode, const struct qstr *qstr,\n\t\t\t       __u32 goal, uid_t *owner, __u32 i_flags,\n\t\t\t       int handle_type, unsigned int line_no,\n\t\t\t       int nblocks)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *inode_bitmap_bh = NULL;\n\tstruct buffer_head *group_desc_bh;\n\text4_group_t ngroups, group = 0;\n\tunsigned long ino = 0;\n\tstruct inode *inode;\n\tstruct ext4_group_desc *gdp = NULL;\n\tstruct ext4_inode_info *ei;\n\tstruct ext4_sb_info *sbi;\n\tint ret2, err;\n\tstruct inode *ret;\n\text4_group_t i;\n\text4_group_t flex_group;\n\tstruct ext4_group_info *grp;\n\tint encrypt = 0;\n\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\n\tsb = dir->i_sb;\n\tsbi = EXT4_SB(sb);\n\n\tif (unlikely(ext4_forced_shutdown(sbi)))\n\t\treturn ERR_PTR(-EIO);\n\n\tif ((ext4_encrypted_inode(dir) || DUMMY_ENCRYPTION_ENABLED(sbi)) &&\n\t    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)) &&\n\t    !(i_flags & EXT4_EA_INODE_FL)) {\n\t\terr = fscrypt_get_encryption_info(dir);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t\tif (!fscrypt_has_encryption_key(dir))\n\t\t\treturn ERR_PTR(-ENOKEY);\n\t\tencrypt = 1;\n\t}\n\n\tif (!handle && sbi->s_journal && !(i_flags & EXT4_EA_INODE_FL)) {\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t\tstruct posix_acl *p = get_acl(dir, ACL_TYPE_DEFAULT);\n\n\t\tif (IS_ERR(p))\n\t\t\treturn ERR_CAST(p);\n\t\tif (p) {\n\t\t\tint acl_size = p->a_count * sizeof(ext4_acl_entry);\n\n\t\t\tnblocks += (S_ISDIR(mode) ? 2 : 1) *\n\t\t\t\t__ext4_xattr_set_credits(sb, NULL /* inode */,\n\t\t\t\t\tNULL /* block_bh */, acl_size,\n\t\t\t\t\ttrue /* is_create */);\n\t\t\tposix_acl_release(p);\n\t\t}\n#endif\n\n#ifdef CONFIG_SECURITY\n\t\t{\n\t\t\tint num_security_xattrs = 1;\n\n#ifdef CONFIG_INTEGRITY\n\t\t\tnum_security_xattrs++;\n#endif\n\t\t\t/*\n\t\t\t * We assume that security xattrs are never\n\t\t\t * more than 1k.  In practice they are under\n\t\t\t * 128 bytes.\n\t\t\t */\n\t\t\tnblocks += num_security_xattrs *\n\t\t\t\t__ext4_xattr_set_credits(sb, NULL /* inode */,\n\t\t\t\t\tNULL /* block_bh */, 1024,\n\t\t\t\t\ttrue /* is_create */);\n\t\t}\n#endif\n\t\tif (encrypt)\n\t\t\tnblocks += __ext4_xattr_set_credits(sb,\n\t\t\t\t\tNULL /* inode */, NULL /* block_bh */,\n\t\t\t\t\tFSCRYPT_SET_CONTEXT_MAX_SIZE,\n\t\t\t\t\ttrue /* is_create */);\n\t}\n\n\tngroups = ext4_get_groups_count(sb);\n\ttrace_ext4_request_inode(dir, mode);\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tei = EXT4_I(inode);\n\n\t/*\n\t * Initialize owners and quota early so that we don't have to account\n\t * for quota initialization worst case in standard inode creating\n\t * transaction\n\t */\n\tif (owner) {\n\t\tinode->i_mode = mode;\n\t\ti_uid_write(inode, owner[0]);\n\t\ti_gid_write(inode, owner[1]);\n\t} else if (test_opt(sb, GRPID)) {\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t} else\n\t\tinode_init_owner(inode, dir, mode);\n\n\tif (ext4_has_feature_project(sb) &&\n\t    ext4_test_inode_flag(dir, EXT4_INODE_PROJINHERIT))\n\t\tei->i_projid = EXT4_I(dir)->i_projid;\n\telse\n\t\tei->i_projid = make_kprojid(&init_user_ns, EXT4_DEF_PROJID);\n\n\terr = dquot_initialize(inode);\n\tif (err)\n\t\tgoto out;\n\n\tif (!goal)\n\t\tgoal = sbi->s_inode_goal;\n\n\tif (goal && goal <= le32_to_cpu(sbi->s_es->s_inodes_count)) {\n\t\tgroup = (goal - 1) / EXT4_INODES_PER_GROUP(sb);\n\t\tino = (goal - 1) % EXT4_INODES_PER_GROUP(sb);\n\t\tret2 = 0;\n\t\tgoto got_group;\n\t}\n\n\tif (S_ISDIR(mode))\n\t\tret2 = find_group_orlov(sb, dir, &group, mode, qstr);\n\telse\n\t\tret2 = find_group_other(sb, dir, &group, mode);\n\ngot_group:\n\tEXT4_I(dir)->i_last_alloc_group = group;\n\terr = -ENOSPC;\n\tif (ret2 == -1)\n\t\tgoto out;\n\n\t/*\n\t * Normally we will only go through one pass of this loop,\n\t * unless we get unlucky and it turns out the group we selected\n\t * had its last inode grabbed by someone else.\n\t */\n\tfor (i = 0; i < ngroups; i++, ino = 0) {\n\t\terr = -EIO;\n\n\t\tgdp = ext4_get_group_desc(sb, group, &group_desc_bh);\n\t\tif (!gdp)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Check free inodes count before loading bitmap.\n\t\t */\n\t\tif (ext4_free_inodes_count(sb, gdp) == 0)\n\t\t\tgoto next_group;\n\n\t\tgrp = ext4_get_group_info(sb, group);\n\t\t/* Skip groups with already-known suspicious inode tables */\n\t\tif (EXT4_MB_GRP_IBITMAP_CORRUPT(grp))\n\t\t\tgoto next_group;\n\n\t\tbrelse(inode_bitmap_bh);\n\t\tinode_bitmap_bh = ext4_read_inode_bitmap(sb, group);\n\t\t/* Skip groups with suspicious inode tables */\n\t\tif (EXT4_MB_GRP_IBITMAP_CORRUPT(grp) ||\n\t\t    IS_ERR(inode_bitmap_bh)) {\n\t\t\tinode_bitmap_bh = NULL;\n\t\t\tgoto next_group;\n\t\t}\n\nrepeat_in_this_group:\n\t\tret2 = find_inode_bit(sb, group, inode_bitmap_bh, &ino);\n\t\tif (!ret2)\n\t\t\tgoto next_group;\n\n\t\tif (group == 0 && (ino + 1) < EXT4_FIRST_INO(sb)) {\n\t\t\text4_error(sb, \"reserved inode found cleared - \"\n\t\t\t\t   \"inode=%lu\", ino + 1);\n\t\t\text4_mark_group_bitmap_corrupted(sb, group,\n\t\t\t\t\tEXT4_GROUP_INFO_IBITMAP_CORRUPT);\n\t\t\tgoto next_group;\n\t\t}\n\n\t\tif (!handle) {\n\t\t\tBUG_ON(nblocks <= 0);\n\t\t\thandle = __ext4_journal_start_sb(dir->i_sb, line_no,\n\t\t\t\t\t\t\t handle_type, nblocks,\n\t\t\t\t\t\t\t 0);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\terr = PTR_ERR(handle);\n\t\t\t\text4_std_error(sb, err);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tBUFFER_TRACE(inode_bitmap_bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, inode_bitmap_bh);\n\t\tif (err) {\n\t\t\text4_std_error(sb, err);\n\t\t\tgoto out;\n\t\t}\n\t\text4_lock_group(sb, group);\n\t\tret2 = ext4_test_and_set_bit(ino, inode_bitmap_bh->b_data);\n\t\tif (ret2) {\n\t\t\t/* Someone already took the bit. Repeat the search\n\t\t\t * with lock held.\n\t\t\t */\n\t\t\tret2 = find_inode_bit(sb, group, inode_bitmap_bh, &ino);\n\t\t\tif (ret2) {\n\t\t\t\text4_set_bit(ino, inode_bitmap_bh->b_data);\n\t\t\t\tret2 = 0;\n\t\t\t} else {\n\t\t\t\tret2 = 1; /* we didn't grab the inode */\n\t\t\t}\n\t\t}\n\t\text4_unlock_group(sb, group);\n\t\tino++;\t\t/* the inode bitmap is zero-based */\n\t\tif (!ret2)\n\t\t\tgoto got; /* we grabbed the inode! */\n\n\t\tif (ino < EXT4_INODES_PER_GROUP(sb))\n\t\t\tgoto repeat_in_this_group;\nnext_group:\n\t\tif (++group == ngroups)\n\t\t\tgroup = 0;\n\t}\n\terr = -ENOSPC;\n\tgoto out;\n\ngot:\n\tBUFFER_TRACE(inode_bitmap_bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, inode_bitmap_bh);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto out;\n\t}\n\n\tBUFFER_TRACE(group_desc_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, group_desc_bh);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto out;\n\t}\n\n\t/* We may have to initialize the block bitmap if it isn't already */\n\tif (ext4_has_group_desc_csum(sb) &&\n\t    gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tstruct buffer_head *block_bitmap_bh;\n\n\t\tblock_bitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (IS_ERR(block_bitmap_bh)) {\n\t\t\terr = PTR_ERR(block_bitmap_bh);\n\t\t\tgoto out;\n\t\t}\n\t\tBUFFER_TRACE(block_bitmap_bh, \"get block bitmap access\");\n\t\terr = ext4_journal_get_write_access(handle, block_bitmap_bh);\n\t\tif (err) {\n\t\t\tbrelse(block_bitmap_bh);\n\t\t\text4_std_error(sb, err);\n\t\t\tgoto out;\n\t\t}\n\n\t\tBUFFER_TRACE(block_bitmap_bh, \"dirty block bitmap\");\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, block_bitmap_bh);\n\n\t\t/* recheck and clear flag under lock if we still need to */\n\t\text4_lock_group(sb, group);\n\t\tif (ext4_has_group_desc_csum(sb) &&\n\t\t    (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT))) {\n\t\t\tgdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);\n\t\t\text4_free_group_clusters_set(sb, gdp,\n\t\t\t\text4_free_clusters_after_init(sb, group, gdp));\n\t\t\text4_block_bitmap_csum_set(sb, group, gdp,\n\t\t\t\t\t\t   block_bitmap_bh);\n\t\t\text4_group_desc_csum_set(sb, group, gdp);\n\t\t}\n\t\text4_unlock_group(sb, group);\n\t\tbrelse(block_bitmap_bh);\n\n\t\tif (err) {\n\t\t\text4_std_error(sb, err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Update the relevant bg descriptor fields */\n\tif (ext4_has_group_desc_csum(sb)) {\n\t\tint free;\n\t\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\n\t\tdown_read(&grp->alloc_sem); /* protect vs itable lazyinit */\n\t\text4_lock_group(sb, group); /* while we modify the bg desc */\n\t\tfree = EXT4_INODES_PER_GROUP(sb) -\n\t\t\text4_itable_unused_count(sb, gdp);\n\t\tif (gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)) {\n\t\t\tgdp->bg_flags &= cpu_to_le16(~EXT4_BG_INODE_UNINIT);\n\t\t\tfree = 0;\n\t\t}\n\t\t/*\n\t\t * Check the relative inode number against the last used\n\t\t * relative inode number in this group. if it is greater\n\t\t * we need to update the bg_itable_unused count\n\t\t */\n\t\tif (ino > free)\n\t\t\text4_itable_unused_set(sb, gdp,\n\t\t\t\t\t(EXT4_INODES_PER_GROUP(sb) - ino));\n\t\tup_read(&grp->alloc_sem);\n\t} else {\n\t\text4_lock_group(sb, group);\n\t}\n\n\text4_free_inodes_set(sb, gdp, ext4_free_inodes_count(sb, gdp) - 1);\n\tif (S_ISDIR(mode)) {\n\t\text4_used_dirs_set(sb, gdp, ext4_used_dirs_count(sb, gdp) + 1);\n\t\tif (sbi->s_log_groups_per_flex) {\n\t\t\text4_group_t f = ext4_flex_group(sbi, group);\n\n\t\t\tatomic_inc(&sbi->s_flex_groups[f].used_dirs);\n\t\t}\n\t}\n\tif (ext4_has_group_desc_csum(sb)) {\n\t\text4_inode_bitmap_csum_set(sb, group, gdp, inode_bitmap_bh,\n\t\t\t\t\t   EXT4_INODES_PER_GROUP(sb) / 8);\n\t\text4_group_desc_csum_set(sb, group, gdp);\n\t}\n\text4_unlock_group(sb, group);\n\n\tBUFFER_TRACE(group_desc_bh, \"call ext4_handle_dirty_metadata\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, group_desc_bh);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto out;\n\t}\n\n\tpercpu_counter_dec(&sbi->s_freeinodes_counter);\n\tif (S_ISDIR(mode))\n\t\tpercpu_counter_inc(&sbi->s_dirs_counter);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\tflex_group = ext4_flex_group(sbi, group);\n\t\tatomic_dec(&sbi->s_flex_groups[flex_group].free_inodes);\n\t}\n\n\tinode->i_ino = ino + group * EXT4_INODES_PER_GROUP(sb);\n\t/* This is the optimal IO size (for stat), not the fs block size */\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = ei->i_crtime =\n\t\t\t\t\t\t       current_time(inode);\n\n\tmemset(ei->i_data, 0, sizeof(ei->i_data));\n\tei->i_dir_start_lookup = 0;\n\tei->i_disksize = 0;\n\n\t/* Don't inherit extent flag from directory, amongst others. */\n\tei->i_flags =\n\t\text4_mask_flags(mode, EXT4_I(dir)->i_flags & EXT4_FL_INHERITED);\n\tei->i_flags |= i_flags;\n\tei->i_file_acl = 0;\n\tei->i_dtime = 0;\n\tei->i_block_group = group;\n\tei->i_last_alloc_group = ~0;\n\n\text4_set_inode_flags(inode);\n\tif (IS_DIRSYNC(inode))\n\t\text4_handle_sync(handle);\n\tif (insert_inode_locked(inode) < 0) {\n\t\t/*\n\t\t * Likely a bitmap corruption causing inode to be allocated\n\t\t * twice.\n\t\t */\n\t\terr = -EIO;\n\t\text4_error(sb, \"failed to insert inode %lu: doubly allocated?\",\n\t\t\t   inode->i_ino);\n\t\text4_mark_group_bitmap_corrupted(sb, group,\n\t\t\t\t\tEXT4_GROUP_INFO_IBITMAP_CORRUPT);\n\t\tgoto out;\n\t}\n\tinode->i_generation = prandom_u32();\n\n\t/* Precompute checksum seed for inode metadata */\n\tif (ext4_has_metadata_csum(sb)) {\n\t\t__u32 csum;\n\t\t__le32 inum = cpu_to_le32(inode->i_ino);\n\t\t__le32 gen = cpu_to_le32(inode->i_generation);\n\t\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&inum,\n\t\t\t\t   sizeof(inum));\n\t\tei->i_csum_seed = ext4_chksum(sbi, csum, (__u8 *)&gen,\n\t\t\t\t\t      sizeof(gen));\n\t}\n\n\text4_clear_state_flags(ei); /* Only relevant on 32-bit archs */\n\text4_set_inode_state(inode, EXT4_STATE_NEW);\n\n\tei->i_extra_isize = sbi->s_want_extra_isize;\n\tei->i_inline_off = 0;\n\tif (ext4_has_feature_inline_data(sb))\n\t\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\tret = inode;\n\terr = dquot_alloc_inode(inode);\n\tif (err)\n\t\tgoto fail_drop;\n\n\t/*\n\t * Since the encryption xattr will always be unique, create it first so\n\t * that it's less likely to end up in an external xattr block and\n\t * prevent its deduplication.\n\t */\n\tif (encrypt) {\n\t\terr = fscrypt_inherit_context(dir, inode, handle, true);\n\t\tif (err)\n\t\t\tgoto fail_free_drop;\n\t}\n\n\tif (!(ei->i_flags & EXT4_EA_INODE_FL)) {\n\t\terr = ext4_init_acl(handle, inode, dir);\n\t\tif (err)\n\t\t\tgoto fail_free_drop;\n\n\t\terr = ext4_init_security(handle, inode, dir, qstr);\n\t\tif (err)\n\t\t\tgoto fail_free_drop;\n\t}\n\n\tif (ext4_has_feature_extents(sb)) {\n\t\t/* set extent flag only for directory, file and normal symlink*/\n\t\tif (S_ISDIR(mode) || S_ISREG(mode) || S_ISLNK(mode)) {\n\t\t\text4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode);\n\t\t}\n\t}\n\n\tif (ext4_handle_valid(handle)) {\n\t\tei->i_sync_tid = handle->h_transaction->t_tid;\n\t\tei->i_datasync_tid = handle->h_transaction->t_tid;\n\t}\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text4_std_error(sb, err);\n\t\tgoto fail_free_drop;\n\t}\n\n\text4_debug(\"allocating inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_allocate_inode(inode, dir, mode);\n\tbrelse(inode_bitmap_bh);\n\treturn ret;\n\nfail_free_drop:\n\tdquot_free_inode(inode);\nfail_drop:\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nout:\n\tdquot_drop(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\tbrelse(inode_bitmap_bh);\n\treturn ERR_PTR(err);\n}",
        "description": "A flaw was identified in the Linux kernel's ext4 filesystem code, where a use-after-free condition can occur in the `ext4_ext_remove_space()` function during the mounting and operation of a specially crafted ext4 image.",
        "commit": "The vulnerability involves the `bg_flags` field in block group descriptors within a file system, which should only be considered valid if either the `uninit_bg` or `metadata_csum` feature is enabled. Previously, there was inconsistent checking of this field. Additionally, block group #0 must never have uninitialized allocation bitmaps or require zeroing, as it contains essential inodes such as the root inode. The fix includes checking these conditions and marking the file system as corrupted if any of these issues are detected. This addresses CVE-2018-10876."
    },
    {
        "cwe": "CWE-399",
        "func_name": "torvalds/__udf_read_inode",
        "score": 0.7702674865722656,
        "func_before": "static void __udf_read_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint16_t ident;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tunsigned int link_count;\n\n\t/*\n\t * Set defaults, but the inode is still incomplete!\n\t * Note: get_new_inode() sets the following on a new inode:\n\t *      i_sb = sb\n\t *      i_no = ino\n\t *      i_flags = sb->s_flags\n\t *      i_state = 0\n\t * clean_inode(): zero fills and sets\n\t *      i_count = 1\n\t *      i_nlink = 1\n\t *      i_op = NULL;\n\t */\n\tbh = udf_read_ptagged(inode->i_sb, &iinfo->i_location, 0, &ident);\n\tif (!bh) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed !bh\\n\", inode->i_ino);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\n\tif (ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE &&\n\t    ident != TAG_IDENT_USE) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed ident=%d\\n\",\n\t\t\tinode->i_ino, ident);\n\t\tbrelse(bh);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (fe->icbTag.strategyType == cpu_to_le16(4096)) {\n\t\tstruct buffer_head *ibh;\n\n\t\tibh = udf_read_ptagged(inode->i_sb, &iinfo->i_location, 1,\n\t\t\t\t\t&ident);\n\t\tif (ident == TAG_IDENT_IE && ibh) {\n\t\t\tstruct buffer_head *nbh = NULL;\n\t\t\tstruct kernel_lb_addr loc;\n\t\t\tstruct indirectEntry *ie;\n\n\t\t\tie = (struct indirectEntry *)ibh->b_data;\n\t\t\tloc = lelb_to_cpu(ie->indirectICB.extLocation);\n\n\t\t\tif (ie->indirectICB.extLength &&\n\t\t\t\t(nbh = udf_read_ptagged(inode->i_sb, &loc, 0,\n\t\t\t\t\t\t\t&ident))) {\n\t\t\t\tif (ident == TAG_IDENT_FE ||\n\t\t\t\t\tident == TAG_IDENT_EFE) {\n\t\t\t\t\tmemcpy(&iinfo->i_location,\n\t\t\t\t\t\t&loc,\n\t\t\t\t\t\tsizeof(struct kernel_lb_addr));\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbrelse(ibh);\n\t\t\t\t\tbrelse(nbh);\n\t\t\t\t\t__udf_read_inode(inode);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbrelse(nbh);\n\t\t\t}\n\t\t}\n\t\tbrelse(ibh);\n\t} else if (fe->icbTag.strategyType != cpu_to_le16(4)) {\n\t\tudf_err(inode->i_sb, \"unsupported strategy type: %d\\n\",\n\t\t\tle16_to_cpu(fe->icbTag.strategyType));\n\t\tbrelse(bh);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\tif (fe->icbTag.strategyType == cpu_to_le16(4))\n\t\tiinfo->i_strat4096 = 0;\n\telse /* if (fe->icbTag.strategyType == cpu_to_le16(4096)) */\n\t\tiinfo->i_strat4096 = 1;\n\n\tiinfo->i_alloc_type = le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t\t\t\tICBTAG_FLAG_AD_MASK;\n\tiinfo->i_unique = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenExtents = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_next_alloc_block = 0;\n\tiinfo->i_next_alloc_goal = 0;\n\tif (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {\n\t\tiinfo->i_efe = 1;\n\t\tiinfo->i_use = 0;\n\t\tif (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry))) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 0;\n\t\tif (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -\n\t\t\t\t\t\tsizeof(struct fileEntry))) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct fileEntry),\n\t\t       inode->i_sb->s_blocksize - sizeof(struct fileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 1;\n\t\tiinfo->i_lenAlloc = le32_to_cpu(\n\t\t\t\t((struct unallocSpaceEntry *)bh->b_data)->\n\t\t\t\t lengthAllocDescs);\n\t\tif (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry))) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\treturn;\n\t}\n\n\tread_lock(&sbi->s_cred_lock);\n\ti_uid_write(inode, le32_to_cpu(fe->uid));\n\tif (!uid_valid(inode->i_uid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_SET))\n\t\tinode->i_uid = UDF_SB(inode->i_sb)->s_uid;\n\n\ti_gid_write(inode, le32_to_cpu(fe->gid));\n\tif (!gid_valid(inode->i_gid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_SET))\n\t\tinode->i_gid = UDF_SB(inode->i_sb)->s_gid;\n\n\tif (fe->icbTag.fileType != ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_fmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_fmode;\n\telse if (fe->icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_dmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_dmode;\n\telse\n\t\tinode->i_mode = udf_convert_permissions(fe);\n\tinode->i_mode &= ~sbi->s_umask;\n\tread_unlock(&sbi->s_cred_lock);\n\n\tlink_count = le16_to_cpu(fe->fileLinkCount);\n\tif (!link_count)\n\t\tlink_count = 1;\n\tset_nlink(inode, link_count);\n\n\tinode->i_size = le64_to_cpu(fe->informationLength);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tif (iinfo->i_efe == 0) {\n\t\tinode->i_blocks = le64_to_cpu(fe->logicalBlocksRecorded) <<\n\t\t\t(inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, fe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    fe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, fe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(fe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(fe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(fe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(fe->checkpoint);\n\t} else {\n\t\tinode->i_blocks = le64_to_cpu(efe->logicalBlocksRecorded) <<\n\t\t    (inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, efe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    efe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&iinfo->i_crtime, efe->createTime))\n\t\t\tiinfo->i_crtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, efe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(efe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(efe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(efe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(efe->checkpoint);\n\t}\n\n\tswitch (fe->icbTag.fileType) {\n\tcase ICBTAG_FILE_TYPE_DIRECTORY:\n\t\tinode->i_op = &udf_dir_inode_operations;\n\t\tinode->i_fop = &udf_dir_operations;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_REALTIME:\n\tcase ICBTAG_FILE_TYPE_REGULAR:\n\tcase ICBTAG_FILE_TYPE_UNDEF:\n\tcase ICBTAG_FILE_TYPE_VAT20:\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\telse\n\t\t\tinode->i_data.a_ops = &udf_aops;\n\t\tinode->i_op = &udf_file_inode_operations;\n\t\tinode->i_fop = &udf_file_operations;\n\t\tinode->i_mode |= S_IFREG;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BLOCK:\n\t\tinode->i_mode |= S_IFBLK;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_CHAR:\n\t\tinode->i_mode |= S_IFCHR;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_FIFO:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFIFO, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SOCKET:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFSOCK, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SYMLINK:\n\t\tinode->i_data.a_ops = &udf_symlink_aops;\n\t\tinode->i_op = &udf_symlink_inode_operations;\n\t\tinode->i_mode = S_IFLNK | S_IRWXUGO;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MAIN:\n\t\tudf_debug(\"METADATA FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MIRROR:\n\t\tudf_debug(\"METADATA MIRROR FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BITMAP:\n\t\tudf_debug(\"METADATA BITMAP FILE-----\\n\");\n\t\tbreak;\n\tdefault:\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed unknown file type=%d\\n\",\n\t\t\tinode->i_ino, fe->icbTag.fileType);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (dsea) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tMKDEV(le32_to_cpu(dsea->majorDeviceIdent),\n\t\t\t\t      le32_to_cpu(dsea->minorDeviceIdent)));\n\t\t\t/* Developer ID ??? */\n\t\t} else\n\t\t\tmake_bad_inode(inode);\n\t}\n\tbrelse(bh);\n}",
        "func_after": "static void __udf_read_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct fileEntry *fe;\n\tstruct extendedFileEntry *efe;\n\tuint16_t ident;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n\tunsigned int link_count;\n\tunsigned int indirections = 0;\n\nreread:\n\t/*\n\t * Set defaults, but the inode is still incomplete!\n\t * Note: get_new_inode() sets the following on a new inode:\n\t *      i_sb = sb\n\t *      i_no = ino\n\t *      i_flags = sb->s_flags\n\t *      i_state = 0\n\t * clean_inode(): zero fills and sets\n\t *      i_count = 1\n\t *      i_nlink = 1\n\t *      i_op = NULL;\n\t */\n\tbh = udf_read_ptagged(inode->i_sb, &iinfo->i_location, 0, &ident);\n\tif (!bh) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed !bh\\n\", inode->i_ino);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\n\tif (ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE &&\n\t    ident != TAG_IDENT_USE) {\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed ident=%d\\n\",\n\t\t\tinode->i_ino, ident);\n\t\tbrelse(bh);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\n\tfe = (struct fileEntry *)bh->b_data;\n\tefe = (struct extendedFileEntry *)bh->b_data;\n\n\tif (fe->icbTag.strategyType == cpu_to_le16(4096)) {\n\t\tstruct buffer_head *ibh;\n\n\t\tibh = udf_read_ptagged(inode->i_sb, &iinfo->i_location, 1,\n\t\t\t\t\t&ident);\n\t\tif (ident == TAG_IDENT_IE && ibh) {\n\t\t\tstruct kernel_lb_addr loc;\n\t\t\tstruct indirectEntry *ie;\n\n\t\t\tie = (struct indirectEntry *)ibh->b_data;\n\t\t\tloc = lelb_to_cpu(ie->indirectICB.extLocation);\n\n\t\t\tif (ie->indirectICB.extLength) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tbrelse(ibh);\n\t\t\t\tmemcpy(&iinfo->i_location, &loc,\n\t\t\t\t       sizeof(struct kernel_lb_addr));\n\t\t\t\tif (++indirections > UDF_MAX_ICB_NESTING) {\n\t\t\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\t\t\"too many ICBs in ICB hierarchy\"\n\t\t\t\t\t\t\" (max %d supported)\\n\",\n\t\t\t\t\t\tUDF_MAX_ICB_NESTING);\n\t\t\t\t\tmake_bad_inode(inode);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tgoto reread;\n\t\t\t}\n\t\t}\n\t\tbrelse(ibh);\n\t} else if (fe->icbTag.strategyType != cpu_to_le16(4)) {\n\t\tudf_err(inode->i_sb, \"unsupported strategy type: %d\\n\",\n\t\t\tle16_to_cpu(fe->icbTag.strategyType));\n\t\tbrelse(bh);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\tif (fe->icbTag.strategyType == cpu_to_le16(4))\n\t\tiinfo->i_strat4096 = 0;\n\telse /* if (fe->icbTag.strategyType == cpu_to_le16(4096)) */\n\t\tiinfo->i_strat4096 = 1;\n\n\tiinfo->i_alloc_type = le16_to_cpu(fe->icbTag.flags) &\n\t\t\t\t\t\t\tICBTAG_FLAG_AD_MASK;\n\tiinfo->i_unique = 0;\n\tiinfo->i_lenEAttr = 0;\n\tiinfo->i_lenExtents = 0;\n\tiinfo->i_lenAlloc = 0;\n\tiinfo->i_next_alloc_block = 0;\n\tiinfo->i_next_alloc_goal = 0;\n\tif (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {\n\t\tiinfo->i_efe = 1;\n\t\tiinfo->i_use = 0;\n\t\tif (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry))) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct extendedFileEntry),\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct extendedFileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 0;\n\t\tif (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -\n\t\t\t\t\t\tsizeof(struct fileEntry))) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct fileEntry),\n\t\t       inode->i_sb->s_blocksize - sizeof(struct fileEntry));\n\t} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {\n\t\tiinfo->i_efe = 0;\n\t\tiinfo->i_use = 1;\n\t\tiinfo->i_lenAlloc = le32_to_cpu(\n\t\t\t\t((struct unallocSpaceEntry *)bh->b_data)->\n\t\t\t\t lengthAllocDescs);\n\t\tif (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry))) {\n\t\t\tmake_bad_inode(inode);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(iinfo->i_ext.i_data,\n\t\t       bh->b_data + sizeof(struct unallocSpaceEntry),\n\t\t       inode->i_sb->s_blocksize -\n\t\t\t\t\tsizeof(struct unallocSpaceEntry));\n\t\treturn;\n\t}\n\n\tread_lock(&sbi->s_cred_lock);\n\ti_uid_write(inode, le32_to_cpu(fe->uid));\n\tif (!uid_valid(inode->i_uid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_SET))\n\t\tinode->i_uid = UDF_SB(inode->i_sb)->s_uid;\n\n\ti_gid_write(inode, le32_to_cpu(fe->gid));\n\tif (!gid_valid(inode->i_gid) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_IGNORE) ||\n\t    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_SET))\n\t\tinode->i_gid = UDF_SB(inode->i_sb)->s_gid;\n\n\tif (fe->icbTag.fileType != ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_fmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_fmode;\n\telse if (fe->icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY &&\n\t\t\tsbi->s_dmode != UDF_INVALID_MODE)\n\t\tinode->i_mode = sbi->s_dmode;\n\telse\n\t\tinode->i_mode = udf_convert_permissions(fe);\n\tinode->i_mode &= ~sbi->s_umask;\n\tread_unlock(&sbi->s_cred_lock);\n\n\tlink_count = le16_to_cpu(fe->fileLinkCount);\n\tif (!link_count)\n\t\tlink_count = 1;\n\tset_nlink(inode, link_count);\n\n\tinode->i_size = le64_to_cpu(fe->informationLength);\n\tiinfo->i_lenExtents = inode->i_size;\n\n\tif (iinfo->i_efe == 0) {\n\t\tinode->i_blocks = le64_to_cpu(fe->logicalBlocksRecorded) <<\n\t\t\t(inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, fe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    fe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, fe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(fe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(fe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(fe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(fe->checkpoint);\n\t} else {\n\t\tinode->i_blocks = le64_to_cpu(efe->logicalBlocksRecorded) <<\n\t\t    (inode->i_sb->s_blocksize_bits - 9);\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_atime, efe->accessTime))\n\t\t\tinode->i_atime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_mtime,\n\t\t\t\t\t    efe->modificationTime))\n\t\t\tinode->i_mtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&iinfo->i_crtime, efe->createTime))\n\t\t\tiinfo->i_crtime = sbi->s_record_time;\n\n\t\tif (!udf_disk_stamp_to_time(&inode->i_ctime, efe->attrTime))\n\t\t\tinode->i_ctime = sbi->s_record_time;\n\n\t\tiinfo->i_unique = le64_to_cpu(efe->uniqueID);\n\t\tiinfo->i_lenEAttr = le32_to_cpu(efe->lengthExtendedAttr);\n\t\tiinfo->i_lenAlloc = le32_to_cpu(efe->lengthAllocDescs);\n\t\tiinfo->i_checkpoint = le32_to_cpu(efe->checkpoint);\n\t}\n\n\tswitch (fe->icbTag.fileType) {\n\tcase ICBTAG_FILE_TYPE_DIRECTORY:\n\t\tinode->i_op = &udf_dir_inode_operations;\n\t\tinode->i_fop = &udf_dir_operations;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_REALTIME:\n\tcase ICBTAG_FILE_TYPE_REGULAR:\n\tcase ICBTAG_FILE_TYPE_UNDEF:\n\tcase ICBTAG_FILE_TYPE_VAT20:\n\t\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\telse\n\t\t\tinode->i_data.a_ops = &udf_aops;\n\t\tinode->i_op = &udf_file_inode_operations;\n\t\tinode->i_fop = &udf_file_operations;\n\t\tinode->i_mode |= S_IFREG;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BLOCK:\n\t\tinode->i_mode |= S_IFBLK;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_CHAR:\n\t\tinode->i_mode |= S_IFCHR;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_FIFO:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFIFO, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SOCKET:\n\t\tinit_special_inode(inode, inode->i_mode | S_IFSOCK, 0);\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_SYMLINK:\n\t\tinode->i_data.a_ops = &udf_symlink_aops;\n\t\tinode->i_op = &udf_symlink_inode_operations;\n\t\tinode->i_mode = S_IFLNK | S_IRWXUGO;\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MAIN:\n\t\tudf_debug(\"METADATA FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_MIRROR:\n\t\tudf_debug(\"METADATA MIRROR FILE-----\\n\");\n\t\tbreak;\n\tcase ICBTAG_FILE_TYPE_BITMAP:\n\t\tudf_debug(\"METADATA BITMAP FILE-----\\n\");\n\t\tbreak;\n\tdefault:\n\t\tudf_err(inode->i_sb, \"(ino %ld) failed unknown file type=%d\\n\",\n\t\t\tinode->i_ino, fe->icbTag.fileType);\n\t\tmake_bad_inode(inode);\n\t\treturn;\n\t}\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tstruct deviceSpec *dsea =\n\t\t\t(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);\n\t\tif (dsea) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tMKDEV(le32_to_cpu(dsea->majorDeviceIdent),\n\t\t\t\t      le32_to_cpu(dsea->minorDeviceIdent)));\n\t\t\t/* Developer ID ??? */\n\t\t} else\n\t\t\tmake_bad_inode(inode);\n\t}\n\tbrelse(bh);\n}",
        "description": "The `__udf_read_inode` function in the UDF filesystem module of the Linux kernel up to version 3.16.3 lacks proper restrictions on the depth of ICB (Information Control Block) indirection. This deficiency enables physically proximate attackers to trigger a denial of service condition, such as an infinite loop or excessive stack consumption, by manipulating the UDF filesystem with a specially crafted inode.",
        "commit": "It was discovered that there was a risk of an infinite loop during the processing of indirect ICBs in the UDF file system. The issue arose because there was no limit set on the number of indirect ICBs that could be followed when loading an inode, potentially leading to a stack overflow if the medium was corrupted. To address this vulnerability, the recursion in the `__udf_read_inode()` function was removed, and a limit was imposed on the number of indirect ICBs that could be processed to prevent infinite loops."
    },
    {
        "cwe": "CWE-670",
        "func_name": "xen-project/port_is_valid",
        "score": 0.7135459780693054,
        "func_before": "static inline bool_t port_is_valid(struct domain *d, unsigned int p)\n{\n    return p < read_atomic(&d->valid_evtchns);\n}",
        "func_after": "static inline bool_t port_is_valid(struct domain *d, unsigned int p)\n{\n    if ( p >= read_atomic(&d->valid_evtchns) )\n        return false;\n\n    /*\n     * The caller will usually access the event channel afterwards and\n     * may be done without taking the per-domain lock. The barrier is\n     * going in pair the smp_wmb() barrier in evtchn_allocate_port().\n     */\n    smp_rmb();\n\n    return true;\n}",
        "description": "An issue was discovered in Xen through version 4.14.x, where memory barriers are absent during the access or allocation of event channels. Event channels control structures can be accessed without locks as long as the port is deemed valid. However, the absence of an appropriate memory barrier (such as smp_*mb()) allows the compiler and CPU to reorder memory accesses. This could enable a malicious guest to trigger a hypervisor crash, leading to a Denial of Service (DoS). Additionally, information leaks and privilege escalations cannot be ruled out. The vulnerability affects all versions of Xen, with the likelihood of exploitation depending on the CPU and compiler used to build Xen. The exact impact varies based on the compiler's code generation options and the CPU's ability to reorder memory accesses. It is recommended to consult the CPU vendor for guidance on potential vulnerabilities on Arm systems, while x86 systems are only vulnerable if a compiler performs reordering.",
        "commit": "It was discovered that the Xen hypervisor's event channel management lacked appropriate memory barriers during both allocation and access operations. Specifically, while the allocation of an event channel bucket is protected by a per-domain lock, accessing the bucket can occur without the lock being held, relying instead on the `port_is_valid()` function to ensure the port has an associated structure. However, due to potential compiler and processor reordering of memory accesses, there is a risk that updates to `d->valid_evtchns` could occur before the new bucket is fully allocated. To mitigate this issue, memory barriers were added: a write memory barrier during allocation and a read memory barrier when checking if the port is valid. This addresses a reordering problem that could lead to unintended behavior."
    }
]