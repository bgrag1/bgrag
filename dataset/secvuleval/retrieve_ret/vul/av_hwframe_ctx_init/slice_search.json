[
    {
        "cwe": "CWE-476",
        "func_name": "ImageMagick/LoadOpenCLDevices",
        "score": 0.7515913248062134,
        "func_before": "static void LoadOpenCLDevices(MagickCLEnv clEnv)\n{\n  cl_context_properties\n    properties[3];\n\n  cl_device_id\n    *devices;\n\n  cl_int\n    status;\n\n  cl_platform_id\n    *platforms;\n\n  cl_uint\n    i,\n    j,\n    next,\n    number_devices,\n    number_platforms;\n\n  size_t\n    length;\n\n  number_platforms=0;\n  if (openCL_library->clGetPlatformIDs(0,NULL,&number_platforms) != CL_SUCCESS)\n    return;\n  if (number_platforms == 0)\n    return;\n  platforms=(cl_platform_id *) AcquireMagickMemory(number_platforms*\n    sizeof(cl_platform_id));\n  if (platforms == (cl_platform_id *) NULL)\n    return;\n  if (openCL_library->clGetPlatformIDs(number_platforms,platforms,NULL) != CL_SUCCESS)\n    {\n       platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n       return;\n    }\n  for (i = 0; i < number_platforms; i++)\n  {\n    number_devices=GetOpenCLDeviceCount(clEnv,platforms[i]);\n    if (number_devices == 0)\n      platforms[i]=(cl_platform_id) NULL;\n    else\n      clEnv->number_devices+=number_devices;\n  }\n  if (clEnv->number_devices == 0)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  clEnv->devices=(MagickCLDevice *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(MagickCLDevice));\n  if (clEnv->devices == (MagickCLDevice *) NULL)\n    {\n      RelinquishMagickCLDevices(clEnv);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  (void) ResetMagickMemory(clEnv->devices,0,clEnv->number_devices*\n    sizeof(MagickCLDevice));\n  devices=(cl_device_id *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(cl_device_id));\n  if (devices == (cl_device_id *) NULL)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  clEnv->number_contexts=(size_t) number_platforms;\n  clEnv->contexts=(cl_context *) AcquireQuantumMemory(clEnv->number_contexts,\n    sizeof(cl_context));\n  if (clEnv->contexts == (cl_context *) NULL)\n    {\n      devices=(cl_device_id *) RelinquishMagickMemory(devices);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  next=0;\n  for (i = 0; i < number_platforms; i++)\n  {\n    if (platforms[i] == (cl_platform_id) NULL)\n      continue;\n\n    status=clEnv->library->clGetDeviceIDs(platforms[i],CL_DEVICE_TYPE_CPU | \n      CL_DEVICE_TYPE_GPU,(cl_uint) clEnv->number_devices,devices,&number_devices);\n    if (status != CL_SUCCESS)\n      continue;\n\n    properties[0]=CL_CONTEXT_PLATFORM;\n    properties[1]=(cl_context_properties) platforms[i];\n    properties[2]=0;\n    clEnv->contexts[i]=openCL_library->clCreateContext(properties,number_devices,\n      devices,NULL,NULL,&status);\n    if (status != CL_SUCCESS)\n      continue;\n\n    for (j = 0; j < number_devices; j++,next++)\n    {\n      MagickCLDevice\n        device;\n\n      device=AcquireMagickCLDevice();\n      if (device == (MagickCLDevice) NULL)\n        break;\n\n      device->context=clEnv->contexts[i];\n      device->deviceID=devices[j];\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,0,NULL,\n        &length);\n      device->platform_name=AcquireQuantumMemory(length,\n        sizeof(*device->platform_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,length,\n        device->platform_name,NULL);\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,0,NULL,\n        &length);\n      device->vendor_name=AcquireQuantumMemory(length,\n        sizeof(*device->vendor_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,length,\n        device->vendor_name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,0,NULL,\n        &length);\n      device->name=AcquireQuantumMemory(length,sizeof(*device->name));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,length,\n        device->name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,0,NULL,\n        &length);\n      device->version=AcquireQuantumMemory(length,sizeof(*device->version));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,length,\n        device->version,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_CLOCK_FREQUENCY,\n        sizeof(cl_uint),&device->max_clock_frequency,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_COMPUTE_UNITS,\n        sizeof(cl_uint),&device->max_compute_units,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_TYPE,\n        sizeof(cl_device_type),&device->type,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_LOCAL_MEM_SIZE,\n        sizeof(cl_ulong),&device->local_memory_size,NULL);\n\n      clEnv->devices[next]=device;\n    }\n  }\n  if (next != clEnv->number_devices)\n    RelinquishMagickCLDevices(clEnv);\n  platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n  devices=(cl_device_id *) RelinquishMagickMemory(devices);\n}",
        "func_after": "static void LoadOpenCLDevices(MagickCLEnv clEnv)\n{\n  cl_context_properties\n    properties[3];\n\n  cl_device_id\n    *devices;\n\n  cl_int\n    status;\n\n  cl_platform_id\n    *platforms;\n\n  cl_uint\n    i,\n    j,\n    next,\n    number_devices,\n    number_platforms;\n\n  size_t\n    length;\n\n  number_platforms=0;\n  if (openCL_library->clGetPlatformIDs(0,NULL,&number_platforms) != CL_SUCCESS)\n    return;\n  if (number_platforms == 0)\n    return;\n  platforms=(cl_platform_id *) AcquireMagickMemory(number_platforms*\n    sizeof(cl_platform_id));\n  if (platforms == (cl_platform_id *) NULL)\n    return;\n  if (openCL_library->clGetPlatformIDs(number_platforms,platforms,NULL) != CL_SUCCESS)\n    {\n       platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n       return;\n    }\n  for (i = 0; i < number_platforms; i++)\n  {\n    number_devices=GetOpenCLDeviceCount(clEnv,platforms[i]);\n    if (number_devices == 0)\n      platforms[i]=(cl_platform_id) NULL;\n    else\n      clEnv->number_devices+=number_devices;\n  }\n  if (clEnv->number_devices == 0)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  clEnv->devices=(MagickCLDevice *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(MagickCLDevice));\n  if (clEnv->devices == (MagickCLDevice *) NULL)\n    {\n      RelinquishMagickCLDevices(clEnv);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  (void) ResetMagickMemory(clEnv->devices,0,clEnv->number_devices*\n    sizeof(MagickCLDevice));\n  devices=(cl_device_id *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(cl_device_id));\n  if (devices == (cl_device_id *) NULL)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  clEnv->number_contexts=(size_t) number_platforms;\n  clEnv->contexts=(cl_context *) AcquireQuantumMemory(clEnv->number_contexts,\n    sizeof(cl_context));\n  if (clEnv->contexts == (cl_context *) NULL)\n    {\n      devices=(cl_device_id *) RelinquishMagickMemory(devices);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  next=0;\n  for (i = 0; i < number_platforms; i++)\n  {\n    if (platforms[i] == (cl_platform_id) NULL)\n      continue;\n\n    status=clEnv->library->clGetDeviceIDs(platforms[i],CL_DEVICE_TYPE_CPU | \n      CL_DEVICE_TYPE_GPU,(cl_uint) clEnv->number_devices,devices,&number_devices);\n    if (status != CL_SUCCESS)\n      continue;\n\n    properties[0]=CL_CONTEXT_PLATFORM;\n    properties[1]=(cl_context_properties) platforms[i];\n    properties[2]=0;\n    clEnv->contexts[i]=openCL_library->clCreateContext(properties,number_devices,\n      devices,NULL,NULL,&status);\n    if (status != CL_SUCCESS)\n      continue;\n\n    for (j = 0; j < number_devices; j++,next++)\n    {\n      MagickCLDevice\n        device;\n\n      device=AcquireMagickCLDevice();\n      if (device == (MagickCLDevice) NULL)\n        break;\n\n      device->context=clEnv->contexts[i];\n      device->deviceID=devices[j];\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,0,NULL,\n        &length);\n      device->platform_name=AcquireCriticalMemory(length*\n        sizeof(*device->platform_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,length,\n        device->platform_name,NULL);\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,0,NULL,\n        &length);\n      device->vendor_name=AcquireQuantumMemory(length,\n        sizeof(*device->vendor_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,length,\n        device->vendor_name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,0,NULL,\n        &length);\n      device->name=AcquireQuantumMemory(length,sizeof(*device->name));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,length,\n        device->name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,0,NULL,\n        &length);\n      device->version=AcquireQuantumMemory(length,sizeof(*device->version));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,length,\n        device->version,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_CLOCK_FREQUENCY,\n        sizeof(cl_uint),&device->max_clock_frequency,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_COMPUTE_UNITS,\n        sizeof(cl_uint),&device->max_compute_units,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_TYPE,\n        sizeof(cl_device_type),&device->type,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_LOCAL_MEM_SIZE,\n        sizeof(cl_ulong),&device->local_memory_size,NULL);\n\n      clEnv->devices[next]=device;\n    }\n  }\n  if (next != clEnv->number_devices)\n    RelinquishMagickCLDevices(clEnv);\n  platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n  devices=(cl_device_id *) RelinquishMagickMemory(devices);\n}",
        "description": "An issue was discovered in ImageMagick where a NULL pointer dereference vulnerability exists in the function responsible for loading OpenCL devices. This flaw allows attackers to trigger a denial of service through the use of a specially crafted file.",
        "commit": "It was discovered that ImageMagick, a popular image processing library, contains a vulnerability related to improper handling of certain image formats, potentially leading to buffer overflows or other memory corruption issues."
    },
    {
        "cwe": "CWE-189",
        "func_name": "torvalds/i915_gem_execbuffer2",
        "score": 0.744464099407196,
        "func_before": "int\ni915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n\tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n\tint ret;\n\n\tif (args->buffer_count < 1) {\n\t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\t/* Copy the new buffer offsets back to the user's exec list. */\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}",
        "func_after": "int\ni915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n\tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n\tint ret;\n\n\tif (args->buffer_count < 1 ||\n\t    args->buffer_count > UINT_MAX / sizeof(*exec2_list)) {\n\t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\t/* Copy the new buffer offsets back to the user's exec list. */\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}",
        "description": "An integer overflow vulnerability exists within the `i915_gem_execbuffer2` function of the DRM subsystem in the Linux kernel prior to version 3.3.5 on 32-bit platforms. This flaw allows local users to trigger a denial of service through an out-of-bounds write or potentially cause other unspecified impacts via a specially crafted ioctl call.",
        "commit": "A vulnerability was identified in the i915 driver of the DRM subsystem within the Linux kernel, where a large `args->buffer_count` value provided by userspace through an ioctl call could cause an integer overflow on 32-bit systems. This overflow affects the calculation of the allocation size for temporary execution buffers, potentially leading to out-of-bounds memory access. This issue arose due to changes introduced in commit 8408c282, which attempted to optimize buffer allocation by first trying a normal large `kmalloc`."
    },
    {
        "cwe": "CWE-787",
        "func_name": "OP-TEE/syscall_obj_generate_key",
        "score": 0.7562775015830994,
        "func_before": "TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that maxKeySize follows restrictions */\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tparams = malloc(sizeof(TEE_Attribute) * param_count);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * We have to do it like this because the parity bits aren't\n\t\t * counted when telling the size of the key in bits.\n\t\t */\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}",
        "func_after": "TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that maxKeySize follows restrictions */\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tsize_t alloc_size = 0;\n\n\tif (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))\n\t\treturn TEE_ERROR_OVERFLOW;\n\n\tparams = malloc(alloc_size);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * We have to do it like this because the parity bits aren't\n\t\t * counted when telling the size of the key in bits.\n\t\t */\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}",
        "description": "Linaro/OP-TEE versions 3.3.0 and earlier are vulnerable to a buffer overflow, which could lead to the execution of arbitrary code within the Trusted Execution Environment (TEE) core (kernel) context. This issue affects the optee_os component. The vulnerability has been addressed in versions 3.4.0 and later.",
        "commit": "It was discovered that there is a risk of heap-based overflow due to insufficient checking for allocation overflow in cryptographic function calls. Without verifying the allocation size, there is a possibility of allocating a buffer that is smaller than expected, which could result in attacker-controlled data being written beyond the buffer's boundaries."
    },
    {
        "cwe": "CWE-704",
        "func_name": "ArtifexSoftware/zsethalftone5",
        "score": 0.748059868812561,
        "func_before": "static int\nzsethalftone5(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    uint count;\n    gs_halftone_component *phtc = 0;\n    gs_halftone_component *pc;\n    int code = 0;\n    int j;\n    bool have_default;\n    gs_halftone *pht = 0;\n    gx_device_halftone *pdht = 0;\n    ref sprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];\n    ref tprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];\n    gs_memory_t *mem;\n    uint edepth = ref_stack_count(&e_stack);\n    int npop = 2;\n    int dict_enum = dict_first(op);\n    ref rvalue[2];\n    int cname, colorant_number;\n    byte * pname;\n    uint name_size;\n    int halftonetype, type = 0;\n    gs_gstate *pgs = igs;\n    int space_index = r_space_index(op - 1);\n\n    mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];\n\n    check_type(*op, t_dictionary);\n    check_dict_read(*op);\n    check_type(op[-1], t_dictionary);\n    check_dict_read(op[-1]);\n\n    /*\n     * We think that Type 2 and Type 4 halftones, like\n     * screens set by setcolorscreen, adapt automatically to\n     * the device color space, so we need to mark them\n     * with a different internal halftone type.\n     */\n    code = dict_int_param(op - 1, \"HalftoneType\", 1, 100, 0, &type);\n    if (code < 0)\n          return code;\n    halftonetype = (type == 2 || type == 4)\n                        ? ht_type_multiple_colorscreen\n                        : ht_type_multiple;\n\n    /* Count how many components that we will actually use. */\n\n    have_default = false;\n    for (count = 0; ;) {\n\n        /* Move to next element in the dictionary */\n        if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)\n            break;\n        /*\n         * Verify that we have a valid component.  We may have a\n         * /HalfToneType entry.\n         */\n        if (!r_has_type(&rvalue[0], t_name))\n            continue;\n        if (!r_has_type(&rvalue[1], t_dictionary))\n            continue;\n\n        /* Get the name of the component  verify that we will use it. */\n        cname = name_index(mem, &rvalue[0]);\n        code = gs_get_colorname_string(mem, cname, &pname, &name_size);\n        if (code < 0)\n            break;\n        colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,\n                                                halftonetype);\n        if (colorant_number < 0)\n            continue;\n        else if (colorant_number == GX_DEVICE_COLOR_MAX_COMPONENTS) {\n            /* If here then we have the \"Default\" component */\n            if (have_default)\n                return_error(gs_error_rangecheck);\n            have_default = true;\n        }\n\n        count++;\n        /*\n         * Check to see if we have already reached the legal number of\n         * components.\n         */\n        if (count > GS_CLIENT_COLOR_MAX_COMPONENTS + 1) {\n            code = gs_note_error(gs_error_rangecheck);\n            break;\n        }\n    }\n    if (count == 0 || (halftonetype == ht_type_multiple && ! have_default))\n        code = gs_note_error(gs_error_rangecheck);\n\n    if (code >= 0) {\n        check_estack(5);\t\t/* for sampling Type 1 screens */\n        refset_null(sprocs, count);\n        refset_null(tprocs, count);\n        rc_alloc_struct_0(pht, gs_halftone, &st_halftone,\n                          imemory, pht = 0, \".sethalftone5\");\n        phtc = gs_alloc_struct_array(mem, count, gs_halftone_component,\n                                     &st_ht_component_element,\n                                     \".sethalftone5\");\n        rc_alloc_struct_0(pdht, gx_device_halftone, &st_device_halftone,\n                          imemory, pdht = 0, \".sethalftone5\");\n        if (pht == 0 || phtc == 0 || pdht == 0) {\n            j = 0; /* Quiet the compiler:\n                      gs_note_error isn't necessarily identity,\n                      so j could be left ununitialized. */\n            code = gs_note_error(gs_error_VMerror);\n        }\n    }\n    if (code >= 0) {\n        dict_enum = dict_first(op);\n        for (j = 0, pc = phtc; ;) {\n            int type;\n\n            /* Move to next element in the dictionary */\n            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)\n                break;\n            /*\n             * Verify that we have a valid component.  We may have a\n             * /HalfToneType entry.\n             */\n            if (!r_has_type(&rvalue[0], t_name))\n                continue;\n            if (!r_has_type(&rvalue[1], t_dictionary))\n                continue;\n\n            /* Get the name of the component */\n            cname = name_index(mem, &rvalue[0]);\n            code = gs_get_colorname_string(mem, cname, &pname, &name_size);\n            if (code < 0)\n                break;\n            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,\n                                                halftonetype);\n            if (colorant_number < 0)\n                continue;\t\t/* Do not use this component */\n            pc->cname = cname;\n            pc->comp_number = colorant_number;\n\n            /* Now process the component dictionary */\n            check_dict_read(rvalue[1]);\n            if (dict_int_param(&rvalue[1], \"HalftoneType\", 1, 7, 0, &type) < 0) {\n                code = gs_note_error(gs_error_typecheck);\n                break;\n            }\n            switch (type) {\n                default:\n                    code = gs_note_error(gs_error_rangecheck);\n                    break;\n                case 1:\n                    code = dict_spot_params(&rvalue[1], &pc->params.spot,\n                                                sprocs + j, tprocs + j, mem);\n                    pc->params.spot.screen.spot_function = spot1_dummy;\n                    pc->type = ht_type_spot;\n                    break;\n                case 3:\n                    code = dict_threshold_params(&rvalue[1], &pc->params.threshold,\n                                                        tprocs + j);\n                    pc->type = ht_type_threshold;\n                    break;\n                case 7:\n                    code = dict_threshold2_params(&rvalue[1], &pc->params.threshold2,\n                                                        tprocs + j, imemory);\n                    pc->type = ht_type_threshold2;\n                    break;\n            }\n            if (code < 0)\n                break;\n            pc++;\n            j++;\n        }\n    }\n    if (code >= 0) {\n        pht->type = halftonetype;\n        pht->params.multiple.components = phtc;\n        pht->params.multiple.num_comp = j;\n        pht->params.multiple.get_colorname_string = gs_get_colorname_string;\n        code = gs_sethalftone_prepare(igs, pht, pdht);\n    }\n    if (code >= 0) {\n        /*\n         * Put the actual frequency and angle in the spot function component dictionaries.\n         */\n        dict_enum = dict_first(op);\n        for (pc = phtc; ; ) {\n            /* Move to next element in the dictionary */\n            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)\n                break;\n\n            /* Verify that we have a valid component */\n            if (!r_has_type(&rvalue[0], t_name))\n                continue;\n            if (!r_has_type(&rvalue[1], t_dictionary))\n                continue;\n\n            /* Get the name of the component and verify that we will use it. */\n            cname = name_index(mem, &rvalue[0]);\n            code = gs_get_colorname_string(mem, cname, &pname, &name_size);\n            if (code < 0)\n                break;\n            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,\n                                                halftonetype);\n            if (colorant_number < 0)\n                continue;\n\n            if (pc->type == ht_type_spot) {\n                code = dict_spot_results(i_ctx_p, &rvalue[1], &pc->params.spot);\n                if (code < 0)\n                    break;\n            }\n            pc++;\n        }\n    }\n    if (code >= 0) {\n        /*\n         * Schedule the sampling of any Type 1 screens,\n         * and any (Type 1 or Type 3) TransferFunctions.\n         * Save the stack depths in case we have to back out.\n         */\n        uint odepth = ref_stack_count(&o_stack);\n        ref odict, odict5;\n\n        odict = op[-1];\n        odict5 = *op;\n        pop(2);\n        op = osp;\n        esp += 5;\n        make_mark_estack(esp - 4, es_other, sethalftone_cleanup);\n        esp[-3] = odict;\n        make_istruct(esp - 2, 0, pht);\n        make_istruct(esp - 1, 0, pdht);\n        make_op_estack(esp, sethalftone_finish);\n        for (j = 0; j < count; j++) {\n            gx_ht_order *porder = NULL;\n\n            if (pdht->components == 0)\n                porder = &pdht->order;\n            else {\n                /* Find the component in pdht that matches component j in\n                   the pht; gs_sethalftone_prepare() may permute these. */\n                int k;\n                int comp_number = phtc[j].comp_number;\n                for (k = 0; k < count; k++) {\n                    if (pdht->components[k].comp_number == comp_number) {\n                        porder = &pdht->components[k].corder;\n                        break;\n                    }\n                }\n            }\n            switch (phtc[j].type) {\n            case ht_type_spot:\n                code = zscreen_enum_init(i_ctx_p, porder,\n                                         &phtc[j].params.spot.screen,\n                                         &sprocs[j], 0, 0, space_index);\n                if (code < 0)\n                    break;\n                /* falls through */\n            case ht_type_threshold:\n                if (!r_has_type(tprocs + j, t__invalid)) {\n                    /* Schedule TransferFunction sampling. */\n                    /****** check_xstack IS WRONG ******/\n                    check_ostack(zcolor_remap_one_ostack);\n                    check_estack(zcolor_remap_one_estack);\n                    code = zcolor_remap_one(i_ctx_p, tprocs + j,\n                                            porder->transfer, igs,\n                                            zcolor_remap_one_finish);\n                    op = osp;\n                }\n                break;\n            default:\t/* not possible here, but to keep */\n                                /* the compilers happy.... */\n                ;\n            }\n            if (code < 0) {\t/* Restore the stack. */\n                ref_stack_pop_to(&o_stack, odepth);\n                ref_stack_pop_to(&e_stack, edepth);\n                op = osp;\n                op[-1] = odict;\n                *op = odict5;\n                break;\n            }\n            npop = 0;\n        }\n    }\n    if (code < 0) {\n        gs_free_object(mem, pdht, \".sethalftone5\");\n        gs_free_object(mem, phtc, \".sethalftone5\");\n        gs_free_object(mem, pht, \".sethalftone5\");\n        return code;\n    }\n    pop(npop);\n    return (ref_stack_count(&e_stack) > edepth ? o_push_estack : 0);\n}",
        "func_after": "static int\nzsethalftone5(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    uint count;\n    gs_halftone_component *phtc = 0;\n    gs_halftone_component *pc;\n    int code = 0;\n    int j;\n    bool have_default;\n    gs_halftone *pht = 0;\n    gx_device_halftone *pdht = 0;\n    ref sprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];\n    ref tprocs[GS_CLIENT_COLOR_MAX_COMPONENTS + 1];\n    gs_memory_t *mem;\n    uint edepth = ref_stack_count(&e_stack);\n    int npop = 2;\n    int dict_enum;\n    ref rvalue[2];\n    int cname, colorant_number;\n    byte * pname;\n    uint name_size;\n    int halftonetype, type = 0;\n    gs_gstate *pgs = igs;\n    int space_index;\n\n    if (ref_stack_count(&o_stack) < 2)\n        return_error(gs_error_stackunderflow);\n    check_type(*op, t_dictionary);\n    check_type(*(op - 1), t_dictionary);\n\n    dict_enum = dict_first(op);\n    space_index = r_space_index(op - 1);\n\n    mem = (gs_memory_t *) idmemory->spaces_indexed[space_index];\n\n    check_type(*op, t_dictionary);\n    check_dict_read(*op);\n    check_type(op[-1], t_dictionary);\n    check_dict_read(op[-1]);\n\n    /*\n     * We think that Type 2 and Type 4 halftones, like\n     * screens set by setcolorscreen, adapt automatically to\n     * the device color space, so we need to mark them\n     * with a different internal halftone type.\n     */\n    code = dict_int_param(op - 1, \"HalftoneType\", 1, 100, 0, &type);\n    if (code < 0)\n          return code;\n    halftonetype = (type == 2 || type == 4)\n                        ? ht_type_multiple_colorscreen\n                        : ht_type_multiple;\n\n    /* Count how many components that we will actually use. */\n\n    have_default = false;\n    for (count = 0; ;) {\n\n        /* Move to next element in the dictionary */\n        if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)\n            break;\n        /*\n         * Verify that we have a valid component.  We may have a\n         * /HalfToneType entry.\n         */\n        if (!r_has_type(&rvalue[0], t_name))\n            continue;\n        if (!r_has_type(&rvalue[1], t_dictionary))\n            continue;\n\n        /* Get the name of the component  verify that we will use it. */\n        cname = name_index(mem, &rvalue[0]);\n        code = gs_get_colorname_string(mem, cname, &pname, &name_size);\n        if (code < 0)\n            break;\n        colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,\n                                                halftonetype);\n        if (colorant_number < 0)\n            continue;\n        else if (colorant_number == GX_DEVICE_COLOR_MAX_COMPONENTS) {\n            /* If here then we have the \"Default\" component */\n            if (have_default)\n                return_error(gs_error_rangecheck);\n            have_default = true;\n        }\n\n        count++;\n        /*\n         * Check to see if we have already reached the legal number of\n         * components.\n         */\n        if (count > GS_CLIENT_COLOR_MAX_COMPONENTS + 1) {\n            code = gs_note_error(gs_error_rangecheck);\n            break;\n        }\n    }\n    if (count == 0 || (halftonetype == ht_type_multiple && ! have_default))\n        code = gs_note_error(gs_error_rangecheck);\n\n    if (code >= 0) {\n        check_estack(5);\t\t/* for sampling Type 1 screens */\n        refset_null(sprocs, count);\n        refset_null(tprocs, count);\n        rc_alloc_struct_0(pht, gs_halftone, &st_halftone,\n                          imemory, pht = 0, \".sethalftone5\");\n        phtc = gs_alloc_struct_array(mem, count, gs_halftone_component,\n                                     &st_ht_component_element,\n                                     \".sethalftone5\");\n        rc_alloc_struct_0(pdht, gx_device_halftone, &st_device_halftone,\n                          imemory, pdht = 0, \".sethalftone5\");\n        if (pht == 0 || phtc == 0 || pdht == 0) {\n            j = 0; /* Quiet the compiler:\n                      gs_note_error isn't necessarily identity,\n                      so j could be left ununitialized. */\n            code = gs_note_error(gs_error_VMerror);\n        }\n    }\n    if (code >= 0) {\n        dict_enum = dict_first(op);\n        for (j = 0, pc = phtc; ;) {\n            int type;\n\n            /* Move to next element in the dictionary */\n            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)\n                break;\n            /*\n             * Verify that we have a valid component.  We may have a\n             * /HalfToneType entry.\n             */\n            if (!r_has_type(&rvalue[0], t_name))\n                continue;\n            if (!r_has_type(&rvalue[1], t_dictionary))\n                continue;\n\n            /* Get the name of the component */\n            cname = name_index(mem, &rvalue[0]);\n            code = gs_get_colorname_string(mem, cname, &pname, &name_size);\n            if (code < 0)\n                break;\n            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,\n                                                halftonetype);\n            if (colorant_number < 0)\n                continue;\t\t/* Do not use this component */\n            pc->cname = cname;\n            pc->comp_number = colorant_number;\n\n            /* Now process the component dictionary */\n            check_dict_read(rvalue[1]);\n            if (dict_int_param(&rvalue[1], \"HalftoneType\", 1, 7, 0, &type) < 0) {\n                code = gs_note_error(gs_error_typecheck);\n                break;\n            }\n            switch (type) {\n                default:\n                    code = gs_note_error(gs_error_rangecheck);\n                    break;\n                case 1:\n                    code = dict_spot_params(&rvalue[1], &pc->params.spot,\n                                                sprocs + j, tprocs + j, mem);\n                    pc->params.spot.screen.spot_function = spot1_dummy;\n                    pc->type = ht_type_spot;\n                    break;\n                case 3:\n                    code = dict_threshold_params(&rvalue[1], &pc->params.threshold,\n                                                        tprocs + j);\n                    pc->type = ht_type_threshold;\n                    break;\n                case 7:\n                    code = dict_threshold2_params(&rvalue[1], &pc->params.threshold2,\n                                                        tprocs + j, imemory);\n                    pc->type = ht_type_threshold2;\n                    break;\n            }\n            if (code < 0)\n                break;\n            pc++;\n            j++;\n        }\n    }\n    if (code >= 0) {\n        pht->type = halftonetype;\n        pht->params.multiple.components = phtc;\n        pht->params.multiple.num_comp = j;\n        pht->params.multiple.get_colorname_string = gs_get_colorname_string;\n        code = gs_sethalftone_prepare(igs, pht, pdht);\n    }\n    if (code >= 0) {\n        /*\n         * Put the actual frequency and angle in the spot function component dictionaries.\n         */\n        dict_enum = dict_first(op);\n        for (pc = phtc; ; ) {\n            /* Move to next element in the dictionary */\n            if ((dict_enum = dict_next(op, dict_enum, rvalue)) == -1)\n                break;\n\n            /* Verify that we have a valid component */\n            if (!r_has_type(&rvalue[0], t_name))\n                continue;\n            if (!r_has_type(&rvalue[1], t_dictionary))\n                continue;\n\n            /* Get the name of the component and verify that we will use it. */\n            cname = name_index(mem, &rvalue[0]);\n            code = gs_get_colorname_string(mem, cname, &pname, &name_size);\n            if (code < 0)\n                break;\n            colorant_number = gs_cname_to_colorant_number(pgs, pname, name_size,\n                                                halftonetype);\n            if (colorant_number < 0)\n                continue;\n\n            if (pc->type == ht_type_spot) {\n                code = dict_spot_results(i_ctx_p, &rvalue[1], &pc->params.spot);\n                if (code < 0)\n                    break;\n            }\n            pc++;\n        }\n    }\n    if (code >= 0) {\n        /*\n         * Schedule the sampling of any Type 1 screens,\n         * and any (Type 1 or Type 3) TransferFunctions.\n         * Save the stack depths in case we have to back out.\n         */\n        uint odepth = ref_stack_count(&o_stack);\n        ref odict, odict5;\n\n        odict = op[-1];\n        odict5 = *op;\n        pop(2);\n        op = osp;\n        esp += 5;\n        make_mark_estack(esp - 4, es_other, sethalftone_cleanup);\n        esp[-3] = odict;\n        make_istruct(esp - 2, 0, pht);\n        make_istruct(esp - 1, 0, pdht);\n        make_op_estack(esp, sethalftone_finish);\n        for (j = 0; j < count; j++) {\n            gx_ht_order *porder = NULL;\n\n            if (pdht->components == 0)\n                porder = &pdht->order;\n            else {\n                /* Find the component in pdht that matches component j in\n                   the pht; gs_sethalftone_prepare() may permute these. */\n                int k;\n                int comp_number = phtc[j].comp_number;\n                for (k = 0; k < count; k++) {\n                    if (pdht->components[k].comp_number == comp_number) {\n                        porder = &pdht->components[k].corder;\n                        break;\n                    }\n                }\n            }\n            switch (phtc[j].type) {\n            case ht_type_spot:\n                code = zscreen_enum_init(i_ctx_p, porder,\n                                         &phtc[j].params.spot.screen,\n                                         &sprocs[j], 0, 0, space_index);\n                if (code < 0)\n                    break;\n                /* falls through */\n            case ht_type_threshold:\n                if (!r_has_type(tprocs + j, t__invalid)) {\n                    /* Schedule TransferFunction sampling. */\n                    /****** check_xstack IS WRONG ******/\n                    check_ostack(zcolor_remap_one_ostack);\n                    check_estack(zcolor_remap_one_estack);\n                    code = zcolor_remap_one(i_ctx_p, tprocs + j,\n                                            porder->transfer, igs,\n                                            zcolor_remap_one_finish);\n                    op = osp;\n                }\n                break;\n            default:\t/* not possible here, but to keep */\n                                /* the compilers happy.... */\n                ;\n            }\n            if (code < 0) {\t/* Restore the stack. */\n                ref_stack_pop_to(&o_stack, odepth);\n                ref_stack_pop_to(&e_stack, edepth);\n                op = osp;\n                op[-1] = odict;\n                *op = odict5;\n                break;\n            }\n            npop = 0;\n        }\n    }\n    if (code < 0) {\n        gs_free_object(mem, pdht, \".sethalftone5\");\n        gs_free_object(mem, phtc, \".sethalftone5\");\n        gs_free_object(mem, pht, \".sethalftone5\");\n        return code;\n    }\n    pop(npop);\n    return (ref_stack_count(&e_stack) > edepth ? o_push_estack : 0);\n}",
        "description": "The .sethalftone5 function in Ghostscript, prior to version 9.21, is susceptible to a denial of service (application crash) or arbitrary code execution by remote attackers through a crafted Postscript document that invokes .sethalftone5 with an empty operand stack.",
        "commit": "It was discovered that there is a need to verify the sufficiency of parameters and their types in the `.sethalftone5` function."
    },
    {
        "cwe": "CWE-697",
        "func_name": "cvxopt/spsolve",
        "score": 0.7428058385848999,
        "func_before": "static PyObject* spsolve(PyObject *self, PyObject *args,\n    PyObject *kwrds)\n{\n    spmatrix *B, *X=NULL;\n    cholmod_sparse *Bc=NULL, *Xc=NULL;\n    PyObject *F;\n    cholmod_factor *L;\n    int n, sys=0;\n#if PY_MAJOR_VERSION >= 3\n    const char *descr;\n#else\n    char *descr;\n#endif\n    char *kwlist[] = {\"F\", \"B\", \"sys\", NULL};\n    int sysvalues[] = {CHOLMOD_A, CHOLMOD_LDLt, CHOLMOD_LD,\n        CHOLMOD_DLt, CHOLMOD_L, CHOLMOD_Lt, CHOLMOD_D, CHOLMOD_P,\n        CHOLMOD_Pt };\n\n    if (!set_options()) return NULL;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwrds, \"OO|i\", kwlist, &F,\n        &B, &sys)) return NULL;\n\n#if PY_MAJOR_VERSION >= 3\n    if (!PyCapsule_CheckExact(F) || !(descr = PyCapsule_GetName(F)))\n        err_CO(\"F\");\n    if (strncmp(descr, \"CHOLMOD FACTOR\", 14))\n        PY_ERR_TYPE(\"F is not a CHOLMOD factor\");\n    L = (cholmod_factor *) PyCapsule_GetPointer(F, descr);\n#else\n    if (!PyCObject_Check(F)) err_CO(\"F\");\n    descr = PyCObject_GetDesc(F);\n    if (!descr || strncmp(descr, \"CHOLMOD FACTOR\", 14))\n        PY_ERR_TYPE(\"F is not a CHOLMOD factor\");\n    L = (cholmod_factor *) PyCObject_AsVoidPtr(F);\n#endif\n    if (L->xtype == CHOLMOD_PATTERN)\n        PY_ERR(PyExc_ValueError, \"called with symbolic factor\");\n    n = L->n;\n    if (L->minor<n) PY_ERR(PyExc_ArithmeticError, \"singular matrix\");\n\n    if (sys < 0 || sys > 8)\n         PY_ERR(PyExc_ValueError, \"invalid value for sys\");\n\n    if (!SpMatrix_Check(B) ||\n        (SP_ID(B) == DOUBLE  && L->xtype == CHOLMOD_COMPLEX) ||\n        (SP_ID(B) == COMPLEX && L->xtype == CHOLMOD_REAL))\n            PY_ERR_TYPE(\"B must a sparse matrix of the same \"\n                \"numerical type as F\");\n    if (SP_NROWS(B) != n)\n        PY_ERR(PyExc_ValueError, \"incompatible dimensions for B\");\n\n    if (!(Bc = create_matrix(B))) return PyErr_NoMemory();\n    Xc = CHOL(spsolve)(sysvalues[sys], L, Bc, &Common);\n    free_matrix(Bc);\n    if (Common.status == CHOLMOD_OUT_OF_MEMORY) return PyErr_NoMemory();\n    if (Common.status != CHOLMOD_OK)\n        PY_ERR(PyExc_ValueError, \"solve step failed\");\n\n    if (!(X = SpMatrix_New(Xc->nrow, Xc->ncol,\n        ((int_t*)Xc->p)[Xc->ncol], (L->xtype == CHOLMOD_REAL ? DOUBLE :\n        COMPLEX)))) {\n        CHOL(free_sparse)(&Xc, &Common);\n        return NULL;\n    }\n    memcpy(SP_COL(X), Xc->p, (Xc->ncol+1)*sizeof(int_t));\n    memcpy(SP_ROW(X), Xc->i, ((int_t *)Xc->p)[Xc->ncol]*sizeof(int_t));\n    memcpy(SP_VAL(X), Xc->x,\n        ((int_t *) Xc->p)[Xc->ncol]*E_SIZE[SP_ID(X)]);\n    CHOL(free_sparse)(&Xc, &Common);\n    return (PyObject *) X;\n}",
        "func_after": "static PyObject* spsolve(PyObject *self, PyObject *args,\n    PyObject *kwrds)\n{\n    spmatrix *B, *X=NULL;\n    cholmod_sparse *Bc=NULL, *Xc=NULL;\n    PyObject *F;\n    cholmod_factor *L;\n    int n, sys=0;\n#if PY_MAJOR_VERSION >= 3\n    const char *descr;\n#else\n    char *descr;\n#endif\n    char *kwlist[] = {\"F\", \"B\", \"sys\", NULL};\n    int sysvalues[] = {CHOLMOD_A, CHOLMOD_LDLt, CHOLMOD_LD,\n        CHOLMOD_DLt, CHOLMOD_L, CHOLMOD_Lt, CHOLMOD_D, CHOLMOD_P,\n        CHOLMOD_Pt };\n\n    if (!set_options()) return NULL;\n\n    if (!PyArg_ParseTupleAndKeywords(args, kwrds, \"OO|i\", kwlist, &F,\n        &B, &sys)) return NULL;\n\n#if PY_MAJOR_VERSION >= 3\n    if (!PyCapsule_CheckExact(F) || !(descr = PyCapsule_GetName(F)))\n        err_CO(\"F\");\n    if (!(strcmp(descr, strCFDL) == 0 || strcmp(descr, strCFDU) == 0 || strcmp(descr, strCFZL) == 0 || strcmp(descr, strCFZU) == 0))\n        PY_ERR_TYPE(\"F is not a CHOLMOD factor\");\n    L = (cholmod_factor *) PyCapsule_GetPointer(F, descr);\n#else\n    if (!PyCObject_Check(F)) err_CO(\"F\");\n    descr = PyCObject_GetDesc(F);\n    if (!descr || !(strcmp(descr, strCFDL) == 0 || strcmp(descr, strCFDU) == 0 || strcmp(descr, strCFZL) == 0 || strcmp(descr, strCFZU) == 0))\n        PY_ERR_TYPE(\"F is not a CHOLMOD factor\");\n    L = (cholmod_factor *) PyCObject_AsVoidPtr(F);\n#endif\n    if (L->xtype == CHOLMOD_PATTERN)\n        PY_ERR(PyExc_ValueError, \"called with symbolic factor\");\n    n = L->n;\n    if (L->minor<n) PY_ERR(PyExc_ArithmeticError, \"singular matrix\");\n\n    if (sys < 0 || sys > 8)\n         PY_ERR(PyExc_ValueError, \"invalid value for sys\");\n\n    if (!SpMatrix_Check(B) ||\n        (SP_ID(B) == DOUBLE  && L->xtype == CHOLMOD_COMPLEX) ||\n        (SP_ID(B) == COMPLEX && L->xtype == CHOLMOD_REAL))\n            PY_ERR_TYPE(\"B must a sparse matrix of the same \"\n                \"numerical type as F\");\n    if (SP_NROWS(B) != n)\n        PY_ERR(PyExc_ValueError, \"incompatible dimensions for B\");\n\n    if (!(Bc = create_matrix(B))) return PyErr_NoMemory();\n    Xc = CHOL(spsolve)(sysvalues[sys], L, Bc, &Common);\n    free_matrix(Bc);\n    if (Common.status == CHOLMOD_OUT_OF_MEMORY) return PyErr_NoMemory();\n    if (Common.status != CHOLMOD_OK)\n        PY_ERR(PyExc_ValueError, \"solve step failed\");\n\n    if (!(X = SpMatrix_New(Xc->nrow, Xc->ncol,\n        ((int_t*)Xc->p)[Xc->ncol], (L->xtype == CHOLMOD_REAL ? DOUBLE :\n        COMPLEX)))) {\n        CHOL(free_sparse)(&Xc, &Common);\n        return NULL;\n    }\n    memcpy(SP_COL(X), Xc->p, (Xc->ncol+1)*sizeof(int_t));\n    memcpy(SP_ROW(X), Xc->i, ((int_t *)Xc->p)[Xc->ncol]*sizeof(int_t));\n    memcpy(SP_VAL(X), Xc->x,\n        ((int_t *) Xc->p)[Xc->ncol]*E_SIZE[SP_ID(X)]);\n    CHOL(free_sparse)(&Xc, &Common);\n    return (PyObject *) X;\n}",
        "description": "An incomplete string comparison vulnerability exists in the cvxopt library versions up to 1.2.6 within certain APIs (cvxopt.cholmod.diag, cvxopt.cholmod.getfactor, cvxopt.cholmod.solve, cvxopt.cholmod.spsolve). This flaw enables attackers to carry out Denial of Service (DoS) attacks by constructing fake Capsule objects.",
        "commit": "This update resolves an unspecified issue identified by #193, updates the associated documentation, and increments the version number to 1.2.7."
    }
]