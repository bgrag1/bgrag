[
    {
        "cwe": "CWE-401",
        "func_name": "eclipse/handle__publish",
        "score": 0.7746519446372986,
        "func_before": "int handle__publish(struct mosquitto *context)\n{\n\tuint8_t dup;\n\tint rc = 0;\n\tint rc2;\n\tuint8_t header = context->in_packet.command;\n\tint res = 0;\n\tstruct mosquitto_msg_store *msg, *stored = NULL;\n\tsize_t len;\n\tuint16_t slen;\n\tchar *topic_mount;\n\tmosquitto_property *properties = NULL;\n\tmosquitto_property *p, *p_prev;\n\tmosquitto_property *msg_properties_last;\n\tuint32_t message_expiry_interval = 0;\n\tint topic_alias = -1;\n\tuint8_t reason_code = 0;\n\tuint16_t mid = 0;\n\n\tif(context->state != mosq_cs_active){\n\t\treturn MOSQ_ERR_PROTOCOL;\n\t}\n\n\tmsg = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n\tif(msg == NULL){\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\n\tdup = (header & 0x08)>>3;\n\tmsg->qos = (header & 0x06)>>1;\n\tif(dup == 1 && msg->qos == 0){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n\t\t\t\t\"Invalid PUBLISH (QoS=0 and DUP=1) from %s, disconnecting.\", context->id);\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\tif(msg->qos == 3){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n\t\t\t\t\"Invalid QoS in PUBLISH from %s, disconnecting.\", context->id);\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\tif(msg->qos > context->max_qos){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n\t\t\t\t\"Too high QoS in PUBLISH from %s, disconnecting.\", context->id);\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_QOS_NOT_SUPPORTED;\n\t}\n\tmsg->retain = (header & 0x01);\n\n\tif(msg->retain && db.config->retain_available == false){\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_RETAIN_NOT_SUPPORTED;\n\t}\n\n\tif(packet__read_string(&context->in_packet, &msg->topic, &slen)){\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\tif(!slen && context->protocol != mosq_p_mqtt5){\n\t\t/* Invalid publish topic, disconnect client. */\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\n\tif(msg->qos > 0){\n\t\tif(packet__read_uint16(&context->in_packet, &mid)){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t\t}\n\t\tif(mid == 0){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t}\n\t\t/* It is important to have a separate copy of mid, because msg may be\n\t\t * freed before we want to send a PUBACK/PUBREC. */\n\t\tmsg->source_mid = mid;\n\t}\n\n\t/* Handle properties */\n\tif(context->protocol == mosq_p_mqtt5){\n\t\trc = property__read_all(CMD_PUBLISH, &context->in_packet, &properties);\n\t\tif(rc){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn rc;\n\t\t}\n\n\t\tp = properties;\n\t\tp_prev = NULL;\n\t\tmsg->properties = NULL;\n\t\tmsg_properties_last = NULL;\n\t\twhile(p){\n\t\t\tswitch(p->identifier){\n\t\t\t\tcase MQTT_PROP_CONTENT_TYPE:\n\t\t\t\tcase MQTT_PROP_CORRELATION_DATA:\n\t\t\t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n\t\t\t\tcase MQTT_PROP_RESPONSE_TOPIC:\n\t\t\t\tcase MQTT_PROP_USER_PROPERTY:\n\t\t\t\t\tif(msg->properties){\n\t\t\t\t\t\tmsg_properties_last->next = p;\n\t\t\t\t\t\tmsg_properties_last = p;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmsg->properties = p;\n\t\t\t\t\t\tmsg_properties_last = p;\n\t\t\t\t\t}\n\t\t\t\t\tif(p_prev){\n\t\t\t\t\t\tp_prev->next = p->next;\n\t\t\t\t\t\tp = p_prev->next;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tproperties = p->next;\n\t\t\t\t\t\tp = properties;\n\t\t\t\t\t}\n\t\t\t\t\tmsg_properties_last->next = NULL;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MQTT_PROP_TOPIC_ALIAS:\n\t\t\t\t\ttopic_alias = p->value.i16;\n\t\t\t\t\tp_prev = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n\t\t\t\t\tmessage_expiry_interval = p->value.i32;\n\t\t\t\t\tp_prev = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n\t\t\t\t\tp_prev = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmosquitto_property_free_all(&properties);\n\n\tif(topic_alias == 0 || (context->listener && topic_alias > context->listener->max_topic_alias)){\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_TOPIC_ALIAS_INVALID;\n\t}else if(topic_alias > 0){\n\t\tif(msg->topic){\n\t\t\trc = alias__add(context, msg->topic, (uint16_t)topic_alias);\n\t\t\tif(rc){\n\t\t\t\tdb__msg_store_free(msg);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}else{\n\t\t\trc = alias__find(context, &msg->topic, (uint16_t)topic_alias);\n\t\t\tif(rc){\n\t\t\t\tdb__msg_store_free(msg);\n\t\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef WITH_BRIDGE\n\trc = bridge__remap_topic_in(context, &msg->topic);\n\tif(rc){\n\t\tdb__msg_store_free(msg);\n\t\treturn rc;\n\t}\n\n#endif\n\tif(mosquitto_pub_topic_check(msg->topic) != MOSQ_ERR_SUCCESS){\n\t\t/* Invalid publish topic, just swallow it. */\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\n\tmsg->payloadlen = context->in_packet.remaining_length - context->in_packet.pos;\n\tG_PUB_BYTES_RECEIVED_INC(msg->payloadlen);\n\tif(context->listener && context->listener->mount_point){\n\t\tlen = strlen(context->listener->mount_point) + strlen(msg->topic) + 1;\n\t\ttopic_mount = mosquitto__malloc(len+1);\n\t\tif(!topic_mount){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t\tsnprintf(topic_mount, len, \"%s%s\", context->listener->mount_point, msg->topic);\n\t\ttopic_mount[len] = '\\0';\n\n\t\tmosquitto__free(msg->topic);\n\t\tmsg->topic = topic_mount;\n\t}\n\n\tif(msg->payloadlen){\n\t\tif(db.config->message_size_limit && msg->payloadlen > db.config->message_size_limit){\n\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Dropped too large PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);\n\t\t\treason_code = MQTT_RC_PACKET_TOO_LARGE;\n\t\t\tgoto process_bad_message;\n\t\t}\n\t\tmsg->payload = mosquitto__malloc(msg->payloadlen+1);\n\t\tif(msg->payload == NULL){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t\t/* Ensure payload is always zero terminated, this is the reason for the extra byte above */\n\t\t((uint8_t *)msg->payload)[msg->payloadlen] = 0;\n\n\t\tif(packet__read_bytes(&context->in_packet, msg->payload, msg->payloadlen)){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t\t}\n\t}\n\n\t/* Check for topic access */\n\trc = mosquitto_acl_check(context, msg->topic, msg->payloadlen, msg->payload, msg->qos, msg->retain, MOSQ_ACL_WRITE);\n\tif(rc == MOSQ_ERR_ACL_DENIED){\n\t\tlog__printf(NULL, MOSQ_LOG_DEBUG,\n\t\t\t\t\"Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\",\n\t\t\t\tcontext->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,\n\t\t\t\t(long)msg->payloadlen);\n\t\treason_code = MQTT_RC_NOT_AUTHORIZED;\n\t\tgoto process_bad_message;\n\t}else if(rc != MOSQ_ERR_SUCCESS){\n\t\tdb__msg_store_free(msg);\n\t\treturn rc;\n\t}\n\n\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Received PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);\n\n\tif(!strncmp(msg->topic, \"$CONTROL/\", 9)){\n#ifdef WITH_CONTROL\n\t\trc = control__process(context, msg);\n\t\tdb__msg_store_free(msg);\n\t\treturn rc;\n#else\n\t\treason_code = MQTT_RC_IMPLEMENTATION_SPECIFIC;\n\t\tgoto process_bad_message;\n#endif\n\t}\n\n\t{\n\t\trc = plugin__handle_message(context, msg);\n\t\tif(rc == MOSQ_ERR_ACL_DENIED){\n\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG,\n\t\t\t\t\t\"Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\",\n\t\t\t\t\tcontext->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,\n\t\t\t\t\t(long)msg->payloadlen);\n\n\t\t\treason_code = MQTT_RC_NOT_AUTHORIZED;\n\t\t\tgoto process_bad_message;\n\t\t}else if(rc != MOSQ_ERR_SUCCESS){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif(msg->qos > 0){\n\t\tdb__message_store_find(context, msg->source_mid, &stored);\n\t}\n\n\tif(stored && msg->source_mid != 0 &&\n\t\t\t(stored->qos != msg->qos\n\t\t\t || stored->payloadlen != msg->payloadlen\n\t\t\t || strcmp(stored->topic, msg->topic)\n\t\t\t || memcmp(stored->payload, msg->payload, msg->payloadlen) )){\n\n\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Reused message ID %u from %s detected. Clearing from storage.\", msg->source_mid, context->id);\n\t\tdb__message_remove_incoming(context, msg->source_mid);\n\t\tstored = NULL;\n\t}\n\n\tif(!stored){\n\t\tif(msg->qos == 0\n\t\t\t\t|| db__ready_for_flight(context, mosq_md_in, msg->qos)\n\t\t\t\t|| db__ready_for_queue(context, msg->qos, &context->msgs_in)){\n\n\t\t\tdup = 0;\n\t\t\trc = db__message_store(context, msg, message_expiry_interval, 0, mosq_mo_client);\n\t\t\tif(rc) return rc;\n\t\t}else{\n\t\t\t/* Client isn't allowed any more incoming messages, so fail early */\n\t\t\treason_code = MQTT_RC_QUOTA_EXCEEDED;\n\t\t\tgoto process_bad_message;\n\t\t}\n\t\tstored = msg;\n\t\tmsg = NULL;\n\t}else{\n\t\tdb__msg_store_free(msg);\n\t\tmsg = NULL;\n\t\tdup = 1;\n\t}\n\n\tswitch(stored->qos){\n\t\tcase 0:\n\t\t\trc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);\n\t\t\tif(rc2 > 0) rc = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tutil__decrement_receive_quota(context);\n\t\t\trc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);\n\t\t\t/* stored may now be free, so don't refer to it */\n\t\t\tif(rc2 == MOSQ_ERR_SUCCESS || context->protocol != mosq_p_mqtt5){\n\t\t\t\tif(send__puback(context, mid, 0, NULL)) rc = 1;\n\t\t\t}else if(rc2 == MOSQ_ERR_NO_SUBSCRIBERS){\n\t\t\t\tif(send__puback(context, mid, MQTT_RC_NO_MATCHING_SUBSCRIBERS, NULL)) rc = 1;\n\t\t\t}else{\n\t\t\t\trc = rc2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif(dup == 0){\n\t\t\t\tres = db__message_insert(context, stored->source_mid, mosq_md_in, stored->qos, stored->retain, stored, NULL, false);\n\t\t\t}else{\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t\t/* db__message_insert() returns 2 to indicate dropped message\n\t\t\t * due to queue. This isn't an error so don't disconnect them. */\n\t\t\t/* FIXME - this is no longer necessary due to failing early above */\n\t\t\tif(!res){\n\t\t\t\tif(send__pubrec(context, stored->source_mid, 0, NULL)) rc = 1;\n\t\t\t}else if(res == 1){\n\t\t\t\trc = 1;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tdb__message_write_queued_in(context);\n\treturn rc;\nprocess_bad_message:\n\trc = 1;\n\tif(msg){\n\t\tswitch(msg->qos){\n\t\t\tcase 0:\n\t\t\t\trc = MOSQ_ERR_SUCCESS;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\trc = send__puback(context, msg->source_mid, reason_code, NULL);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\trc = send__pubrec(context, msg->source_mid, reason_code, NULL);\n\t\t\t\tbreak;\n\t\t}\n\t\tdb__msg_store_free(msg);\n\t}\n\treturn rc;\n}",
        "func_after": "int handle__publish(struct mosquitto *context)\n{\n\tuint8_t dup;\n\tint rc = 0;\n\tint rc2;\n\tuint8_t header = context->in_packet.command;\n\tint res = 0;\n\tstruct mosquitto_msg_store *msg, *stored = NULL;\n\tstruct mosquitto_client_msg *cmsg_stored = NULL;\n\tsize_t len;\n\tuint16_t slen;\n\tchar *topic_mount;\n\tmosquitto_property *properties = NULL;\n\tmosquitto_property *p, *p_prev;\n\tmosquitto_property *msg_properties_last;\n\tuint32_t message_expiry_interval = 0;\n\tint topic_alias = -1;\n\tuint8_t reason_code = 0;\n\tuint16_t mid = 0;\n\n\tif(context->state != mosq_cs_active){\n\t\treturn MOSQ_ERR_PROTOCOL;\n\t}\n\n\tmsg = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n\tif(msg == NULL){\n\t\treturn MOSQ_ERR_NOMEM;\n\t}\n\n\tdup = (header & 0x08)>>3;\n\tmsg->qos = (header & 0x06)>>1;\n\tif(dup == 1 && msg->qos == 0){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n\t\t\t\t\"Invalid PUBLISH (QoS=0 and DUP=1) from %s, disconnecting.\", context->id);\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\tif(msg->qos == 3){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n\t\t\t\t\"Invalid QoS in PUBLISH from %s, disconnecting.\", context->id);\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\tif(msg->qos > context->max_qos){\n\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n\t\t\t\t\"Too high QoS in PUBLISH from %s, disconnecting.\", context->id);\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_QOS_NOT_SUPPORTED;\n\t}\n\tmsg->retain = (header & 0x01);\n\n\tif(msg->retain && db.config->retain_available == false){\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_RETAIN_NOT_SUPPORTED;\n\t}\n\n\tif(packet__read_string(&context->in_packet, &msg->topic, &slen)){\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\tif(!slen && context->protocol != mosq_p_mqtt5){\n\t\t/* Invalid publish topic, disconnect client. */\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\n\tif(msg->qos > 0){\n\t\tif(packet__read_uint16(&context->in_packet, &mid)){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t\t}\n\t\tif(mid == 0){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t}\n\t\t/* It is important to have a separate copy of mid, because msg may be\n\t\t * freed before we want to send a PUBACK/PUBREC. */\n\t\tmsg->source_mid = mid;\n\t}\n\n\t/* Handle properties */\n\tif(context->protocol == mosq_p_mqtt5){\n\t\trc = property__read_all(CMD_PUBLISH, &context->in_packet, &properties);\n\t\tif(rc){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn rc;\n\t\t}\n\n\t\tp = properties;\n\t\tp_prev = NULL;\n\t\tmsg->properties = NULL;\n\t\tmsg_properties_last = NULL;\n\t\twhile(p){\n\t\t\tswitch(p->identifier){\n\t\t\t\tcase MQTT_PROP_CONTENT_TYPE:\n\t\t\t\tcase MQTT_PROP_CORRELATION_DATA:\n\t\t\t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n\t\t\t\tcase MQTT_PROP_RESPONSE_TOPIC:\n\t\t\t\tcase MQTT_PROP_USER_PROPERTY:\n\t\t\t\t\tif(msg->properties){\n\t\t\t\t\t\tmsg_properties_last->next = p;\n\t\t\t\t\t\tmsg_properties_last = p;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmsg->properties = p;\n\t\t\t\t\t\tmsg_properties_last = p;\n\t\t\t\t\t}\n\t\t\t\t\tif(p_prev){\n\t\t\t\t\t\tp_prev->next = p->next;\n\t\t\t\t\t\tp = p_prev->next;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tproperties = p->next;\n\t\t\t\t\t\tp = properties;\n\t\t\t\t\t}\n\t\t\t\t\tmsg_properties_last->next = NULL;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MQTT_PROP_TOPIC_ALIAS:\n\t\t\t\t\ttopic_alias = p->value.i16;\n\t\t\t\t\tp_prev = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n\t\t\t\t\tmessage_expiry_interval = p->value.i32;\n\t\t\t\t\tp_prev = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n\t\t\t\t\tp_prev = p;\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tp = p->next;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmosquitto_property_free_all(&properties);\n\n\tif(topic_alias == 0 || (context->listener && topic_alias > context->listener->max_topic_alias)){\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_TOPIC_ALIAS_INVALID;\n\t}else if(topic_alias > 0){\n\t\tif(msg->topic){\n\t\t\trc = alias__add(context, msg->topic, (uint16_t)topic_alias);\n\t\t\tif(rc){\n\t\t\t\tdb__msg_store_free(msg);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}else{\n\t\t\trc = alias__find(context, &msg->topic, (uint16_t)topic_alias);\n\t\t\tif(rc){\n\t\t\t\tdb__msg_store_free(msg);\n\t\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef WITH_BRIDGE\n\trc = bridge__remap_topic_in(context, &msg->topic);\n\tif(rc){\n\t\tdb__msg_store_free(msg);\n\t\treturn rc;\n\t}\n\n#endif\n\tif(mosquitto_pub_topic_check(msg->topic) != MOSQ_ERR_SUCCESS){\n\t\t/* Invalid publish topic, just swallow it. */\n\t\tdb__msg_store_free(msg);\n\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t}\n\n\tmsg->payloadlen = context->in_packet.remaining_length - context->in_packet.pos;\n\tG_PUB_BYTES_RECEIVED_INC(msg->payloadlen);\n\tif(context->listener && context->listener->mount_point){\n\t\tlen = strlen(context->listener->mount_point) + strlen(msg->topic) + 1;\n\t\ttopic_mount = mosquitto__malloc(len+1);\n\t\tif(!topic_mount){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t\tsnprintf(topic_mount, len, \"%s%s\", context->listener->mount_point, msg->topic);\n\t\ttopic_mount[len] = '\\0';\n\n\t\tmosquitto__free(msg->topic);\n\t\tmsg->topic = topic_mount;\n\t}\n\n\tif(msg->payloadlen){\n\t\tif(db.config->message_size_limit && msg->payloadlen > db.config->message_size_limit){\n\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Dropped too large PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);\n\t\t\treason_code = MQTT_RC_PACKET_TOO_LARGE;\n\t\t\tgoto process_bad_message;\n\t\t}\n\t\tmsg->payload = mosquitto__malloc(msg->payloadlen+1);\n\t\tif(msg->payload == NULL){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t\t/* Ensure payload is always zero terminated, this is the reason for the extra byte above */\n\t\t((uint8_t *)msg->payload)[msg->payloadlen] = 0;\n\n\t\tif(packet__read_bytes(&context->in_packet, msg->payload, msg->payloadlen)){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n\t\t}\n\t}\n\n\t/* Check for topic access */\n\trc = mosquitto_acl_check(context, msg->topic, msg->payloadlen, msg->payload, msg->qos, msg->retain, MOSQ_ACL_WRITE);\n\tif(rc == MOSQ_ERR_ACL_DENIED){\n\t\tlog__printf(NULL, MOSQ_LOG_DEBUG,\n\t\t\t\t\"Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\",\n\t\t\t\tcontext->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,\n\t\t\t\t(long)msg->payloadlen);\n\t\treason_code = MQTT_RC_NOT_AUTHORIZED;\n\t\tgoto process_bad_message;\n\t}else if(rc != MOSQ_ERR_SUCCESS){\n\t\tdb__msg_store_free(msg);\n\t\treturn rc;\n\t}\n\n\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Received PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);\n\n\tif(!strncmp(msg->topic, \"$CONTROL/\", 9)){\n#ifdef WITH_CONTROL\n\t\trc = control__process(context, msg);\n\t\tdb__msg_store_free(msg);\n\t\treturn rc;\n#else\n\t\treason_code = MQTT_RC_IMPLEMENTATION_SPECIFIC;\n\t\tgoto process_bad_message;\n#endif\n\t}\n\n\t{\n\t\trc = plugin__handle_message(context, msg);\n\t\tif(rc == MOSQ_ERR_ACL_DENIED){\n\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG,\n\t\t\t\t\t\"Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\",\n\t\t\t\t\tcontext->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,\n\t\t\t\t\t(long)msg->payloadlen);\n\n\t\t\treason_code = MQTT_RC_NOT_AUTHORIZED;\n\t\t\tgoto process_bad_message;\n\t\t}else if(rc != MOSQ_ERR_SUCCESS){\n\t\t\tdb__msg_store_free(msg);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tif(msg->qos > 0){\n\t\tdb__message_store_find(context, msg->source_mid, &cmsg_stored);\n\t}\n\n\tif(cmsg_stored && cmsg_stored->store && msg->source_mid != 0 &&\n\t\t\t(cmsg_stored->store->qos != msg->qos\n\t\t\t || cmsg_stored->store->payloadlen != msg->payloadlen\n\t\t\t || strcmp(cmsg_stored->store->topic, msg->topic)\n\t\t\t || memcmp(cmsg_stored->store->payload, msg->payload, msg->payloadlen) )){\n\n\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Reused message ID %u from %s detected. Clearing from storage.\", msg->source_mid, context->id);\n\t\tdb__message_remove_incoming(context, msg->source_mid);\n\t\tcmsg_stored = NULL;\n\t}\n\n\tif(!cmsg_stored){\n\t\tif(msg->qos == 0\n\t\t\t\t|| db__ready_for_flight(context, mosq_md_in, msg->qos)\n\t\t\t\t){\n\n\t\t\tdup = 0;\n\t\t\trc = db__message_store(context, msg, message_expiry_interval, 0, mosq_mo_client);\n\t\t\tif(rc) return rc;\n\t\t}else{\n\t\t\t/* Client isn't allowed any more incoming messages, so fail early */\n\t\t\treason_code = MQTT_RC_QUOTA_EXCEEDED;\n\t\t\tgoto process_bad_message;\n\t\t}\n\t\tstored = msg;\n\t\tmsg = NULL;\n\t\tdup = 0;\n\t}else{\n\t\tdb__msg_store_free(msg);\n\t\tmsg = NULL;\n\t\tstored = cmsg_stored->store;\n\t\tcmsg_stored->dup++;\n\t\tdup = cmsg_stored->dup;\n\t}\n\n\tswitch(stored->qos){\n\t\tcase 0:\n\t\t\trc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);\n\t\t\tif(rc2 > 0) rc = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tutil__decrement_receive_quota(context);\n\t\t\trc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);\n\t\t\t/* stored may now be free, so don't refer to it */\n\t\t\tif(rc2 == MOSQ_ERR_SUCCESS || context->protocol != mosq_p_mqtt5){\n\t\t\t\tif(send__puback(context, mid, 0, NULL)) rc = 1;\n\t\t\t}else if(rc2 == MOSQ_ERR_NO_SUBSCRIBERS){\n\t\t\t\tif(send__puback(context, mid, MQTT_RC_NO_MATCHING_SUBSCRIBERS, NULL)) rc = 1;\n\t\t\t}else{\n\t\t\t\trc = rc2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif(dup == 0){\n\t\t\t\tres = db__message_insert(context, stored->source_mid, mosq_md_in, stored->qos, stored->retain, stored, NULL, false);\n\t\t\t}else{\n\t\t\t\tres = 0;\n\t\t\t}\n\n\t\t\t/* db__message_insert() returns 2 to indicate dropped message\n\t\t\t * due to queue. This isn't an error so don't disconnect them. */\n\t\t\t/* FIXME - this is no longer necessary due to failing early above */\n\t\t\tif(!res){\n\t\t\t\tif(dup == 0 || dup == 1){\n\t\t\t\t\trc2 = send__pubrec(context, stored->source_mid, 0, NULL);\n\t\t\t\t\tif(rc2) rc = rc2;\n\t\t\t\t}else{\n\t\t\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t\t\t}\n\t\t\t}else if(res == 1){\n\t\t\t\trc = 1;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tdb__message_write_queued_in(context);\n\treturn rc;\nprocess_bad_message:\n\trc = 1;\n\tif(msg){\n\t\tswitch(msg->qos){\n\t\t\tcase 0:\n\t\t\t\trc = MOSQ_ERR_SUCCESS;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\trc = send__puback(context, msg->source_mid, reason_code, NULL);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\trc = send__pubrec(context, msg->source_mid, reason_code, NULL);\n\t\t\t\tbreak;\n\t\t}\n\t\tdb__msg_store_free(msg);\n\t}\n\tif(context->out_packet_count >= db.config->max_queued_messages){\n\t\trc = MQTT_RC_QUOTA_EXCEEDED;\n\t}\n\treturn rc;\n}",
        "description": "The broker in Eclipse Mosquitto versions 1.3.2 through 2.x, prior to 2.0.16, suffers from a memory leak that can be exploited remotely. This vulnerability arises when a client sends numerous QoS 2 messages with duplicate message IDs and fails to respond to PUBREC commands. The issue stems from improper handling of the EAGAIN error returned by the libc send function.",
        "commit": "<Abstracted Description begin>\nA fix has been implemented for a vulnerability identified as CVE-2023-28366.\n<Abstracted Description end>"
    },
    {
        "cwe": "CWE-459",
        "func_name": "torvalds/fuse_do_setattr",
        "score": 0.7690233588218689,
        "func_before": "int fuse_do_setattr(struct dentry *dentry, struct iattr *attr,\n\t\t    struct file *file)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tstruct fuse_conn *fc = fm->fc;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_setattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tbool is_truncate = false;\n\tbool is_wb = fc->writeback_cache;\n\tloff_t oldsize;\n\tint err;\n\tbool trust_local_cmtime = is_wb && S_ISREG(inode->i_mode);\n\tbool fault_blocked = false;\n\n\tif (!fc->default_permissions)\n\t\tattr->ia_valid |= ATTR_FORCE;\n\n\terr = setattr_prepare(dentry, attr);\n\tif (err)\n\t\treturn err;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tif (WARN_ON(!S_ISREG(inode->i_mode)))\n\t\t\treturn -EIO;\n\t\tis_truncate = true;\n\t}\n\n\tif (FUSE_IS_DAX(inode) && is_truncate) {\n\t\tdown_write(&fi->i_mmap_sem);\n\t\tfault_blocked = true;\n\t\terr = fuse_dax_break_layouts(inode, 0, 0);\n\t\tif (err) {\n\t\t\tup_write(&fi->i_mmap_sem);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (attr->ia_valid & ATTR_OPEN) {\n\t\t/* This is coming from open(..., ... | O_TRUNC); */\n\t\tWARN_ON(!(attr->ia_valid & ATTR_SIZE));\n\t\tWARN_ON(attr->ia_size != 0);\n\t\tif (fc->atomic_o_trunc) {\n\t\t\t/*\n\t\t\t * No need to send request to userspace, since actual\n\t\t\t * truncation has already been done by OPEN.  But still\n\t\t\t * need to truncate page cache.\n\t\t\t */\n\t\t\ti_size_write(inode, 0);\n\t\t\ttruncate_pagecache(inode, 0);\n\t\t\tgoto out;\n\t\t}\n\t\tfile = NULL;\n\t}\n\n\t/* Flush dirty data/metadata before non-truncate SETATTR */\n\tif (is_wb && S_ISREG(inode->i_mode) &&\n\t    attr->ia_valid &\n\t\t\t(ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_MTIME_SET |\n\t\t\t ATTR_TIMES_SET)) {\n\t\terr = write_inode_now(inode, true);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tfuse_set_nowrite(inode);\n\t\tfuse_release_nowrite(inode);\n\t}\n\n\tif (is_truncate) {\n\t\tfuse_set_nowrite(inode);\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\t\tif (trust_local_cmtime && attr->ia_size != inode->i_size)\n\t\t\tattr->ia_valid |= ATTR_MTIME | ATTR_CTIME;\n\t}\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\tiattr_to_fattr(fc, attr, &inarg, trust_local_cmtime);\n\tif (file) {\n\t\tstruct fuse_file *ff = file->private_data;\n\t\tinarg.valid |= FATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\n\t/* Kill suid/sgid for non-directory chown unconditionally */\n\tif (fc->handle_killpriv_v2 && !S_ISDIR(inode->i_mode) &&\n\t    attr->ia_valid & (ATTR_UID | ATTR_GID))\n\t\tinarg.valid |= FATTR_KILL_SUIDGID;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t/* For mandatory locking in truncate */\n\t\tinarg.valid |= FATTR_LOCKOWNER;\n\t\tinarg.lock_owner = fuse_lock_owner_id(fc, current->files);\n\n\t\t/* Kill suid/sgid for truncate only if no CAP_FSETID */\n\t\tif (fc->handle_killpriv_v2 && !capable(CAP_FSETID))\n\t\t\tinarg.valid |= FATTR_KILL_SUIDGID;\n\t}\n\tfuse_setattr_fill(fc, &args, inode, &inarg, &outarg);\n\terr = fuse_simple_request(fm, &args);\n\tif (err) {\n\t\tif (err == -EINTR)\n\t\t\tfuse_invalidate_attr(inode);\n\t\tgoto error;\n\t}\n\n\tif (fuse_invalid_attr(&outarg.attr) ||\n\t    (inode->i_mode ^ outarg.attr.mode) & S_IFMT) {\n\t\tmake_bad_inode(inode);\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\n\tspin_lock(&fi->lock);\n\t/* the kernel maintains i_mtime locally */\n\tif (trust_local_cmtime) {\n\t\tif (attr->ia_valid & ATTR_MTIME)\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\tif (attr->ia_valid & ATTR_CTIME)\n\t\t\tinode->i_ctime = attr->ia_ctime;\n\t\t/* FIXME: clear I_DIRTY_SYNC? */\n\t}\n\n\tfuse_change_attributes_common(inode, &outarg.attr,\n\t\t\t\t      attr_timeout(&outarg));\n\toldsize = inode->i_size;\n\t/* see the comment in fuse_change_attributes() */\n\tif (!is_wb || is_truncate || !S_ISREG(inode->i_mode))\n\t\ti_size_write(inode, outarg.attr.size);\n\n\tif (is_truncate) {\n\t\t/* NOTE: this may release/reacquire fi->lock */\n\t\t__fuse_release_nowrite(inode);\n\t}\n\tspin_unlock(&fi->lock);\n\n\t/*\n\t * Only call invalidate_inode_pages2() after removing\n\t * FUSE_NOWRITE, otherwise fuse_launder_page() would deadlock.\n\t */\n\tif ((is_truncate || !is_wb) &&\n\t    S_ISREG(inode->i_mode) && oldsize != outarg.attr.size) {\n\t\ttruncate_pagecache(inode, outarg.attr.size);\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\nout:\n\tif (fault_blocked)\n\t\tup_write(&fi->i_mmap_sem);\n\n\treturn 0;\n\nerror:\n\tif (is_truncate)\n\t\tfuse_release_nowrite(inode);\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\tif (fault_blocked)\n\t\tup_write(&fi->i_mmap_sem);\n\treturn err;\n}",
        "func_after": "int fuse_do_setattr(struct dentry *dentry, struct iattr *attr,\n\t\t    struct file *file)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tstruct fuse_conn *fc = fm->fc;\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tFUSE_ARGS(args);\n\tstruct fuse_setattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tbool is_truncate = false;\n\tbool is_wb = fc->writeback_cache;\n\tloff_t oldsize;\n\tint err;\n\tbool trust_local_cmtime = is_wb && S_ISREG(inode->i_mode);\n\tbool fault_blocked = false;\n\n\tif (!fc->default_permissions)\n\t\tattr->ia_valid |= ATTR_FORCE;\n\n\terr = setattr_prepare(dentry, attr);\n\tif (err)\n\t\treturn err;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tif (WARN_ON(!S_ISREG(inode->i_mode)))\n\t\t\treturn -EIO;\n\t\tis_truncate = true;\n\t}\n\n\tif (FUSE_IS_DAX(inode) && is_truncate) {\n\t\tdown_write(&fi->i_mmap_sem);\n\t\tfault_blocked = true;\n\t\terr = fuse_dax_break_layouts(inode, 0, 0);\n\t\tif (err) {\n\t\t\tup_write(&fi->i_mmap_sem);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (attr->ia_valid & ATTR_OPEN) {\n\t\t/* This is coming from open(..., ... | O_TRUNC); */\n\t\tWARN_ON(!(attr->ia_valid & ATTR_SIZE));\n\t\tWARN_ON(attr->ia_size != 0);\n\t\tif (fc->atomic_o_trunc) {\n\t\t\t/*\n\t\t\t * No need to send request to userspace, since actual\n\t\t\t * truncation has already been done by OPEN.  But still\n\t\t\t * need to truncate page cache.\n\t\t\t */\n\t\t\ti_size_write(inode, 0);\n\t\t\ttruncate_pagecache(inode, 0);\n\t\t\tgoto out;\n\t\t}\n\t\tfile = NULL;\n\t}\n\n\t/* Flush dirty data/metadata before non-truncate SETATTR */\n\tif (is_wb && S_ISREG(inode->i_mode) &&\n\t    attr->ia_valid &\n\t\t\t(ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_MTIME_SET |\n\t\t\t ATTR_TIMES_SET)) {\n\t\terr = write_inode_now(inode, true);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tfuse_set_nowrite(inode);\n\t\tfuse_release_nowrite(inode);\n\t}\n\n\tif (is_truncate) {\n\t\tfuse_set_nowrite(inode);\n\t\tset_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\t\tif (trust_local_cmtime && attr->ia_size != inode->i_size)\n\t\t\tattr->ia_valid |= ATTR_MTIME | ATTR_CTIME;\n\t}\n\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\tiattr_to_fattr(fc, attr, &inarg, trust_local_cmtime);\n\tif (file) {\n\t\tstruct fuse_file *ff = file->private_data;\n\t\tinarg.valid |= FATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\n\t/* Kill suid/sgid for non-directory chown unconditionally */\n\tif (fc->handle_killpriv_v2 && !S_ISDIR(inode->i_mode) &&\n\t    attr->ia_valid & (ATTR_UID | ATTR_GID))\n\t\tinarg.valid |= FATTR_KILL_SUIDGID;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t/* For mandatory locking in truncate */\n\t\tinarg.valid |= FATTR_LOCKOWNER;\n\t\tinarg.lock_owner = fuse_lock_owner_id(fc, current->files);\n\n\t\t/* Kill suid/sgid for truncate only if no CAP_FSETID */\n\t\tif (fc->handle_killpriv_v2 && !capable(CAP_FSETID))\n\t\t\tinarg.valid |= FATTR_KILL_SUIDGID;\n\t}\n\tfuse_setattr_fill(fc, &args, inode, &inarg, &outarg);\n\terr = fuse_simple_request(fm, &args);\n\tif (err) {\n\t\tif (err == -EINTR)\n\t\t\tfuse_invalidate_attr(inode);\n\t\tgoto error;\n\t}\n\n\tif (fuse_invalid_attr(&outarg.attr) ||\n\t    (inode->i_mode ^ outarg.attr.mode) & S_IFMT) {\n\t\tfuse_make_bad(inode);\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\n\tspin_lock(&fi->lock);\n\t/* the kernel maintains i_mtime locally */\n\tif (trust_local_cmtime) {\n\t\tif (attr->ia_valid & ATTR_MTIME)\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\tif (attr->ia_valid & ATTR_CTIME)\n\t\t\tinode->i_ctime = attr->ia_ctime;\n\t\t/* FIXME: clear I_DIRTY_SYNC? */\n\t}\n\n\tfuse_change_attributes_common(inode, &outarg.attr,\n\t\t\t\t      attr_timeout(&outarg));\n\toldsize = inode->i_size;\n\t/* see the comment in fuse_change_attributes() */\n\tif (!is_wb || is_truncate || !S_ISREG(inode->i_mode))\n\t\ti_size_write(inode, outarg.attr.size);\n\n\tif (is_truncate) {\n\t\t/* NOTE: this may release/reacquire fi->lock */\n\t\t__fuse_release_nowrite(inode);\n\t}\n\tspin_unlock(&fi->lock);\n\n\t/*\n\t * Only call invalidate_inode_pages2() after removing\n\t * FUSE_NOWRITE, otherwise fuse_launder_page() would deadlock.\n\t */\n\tif ((is_truncate || !is_wb) &&\n\t    S_ISREG(inode->i_mode) && oldsize != outarg.attr.size) {\n\t\ttruncate_pagecache(inode, outarg.attr.size);\n\t\tinvalidate_inode_pages2(inode->i_mapping);\n\t}\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\nout:\n\tif (fault_blocked)\n\t\tup_write(&fi->i_mmap_sem);\n\n\treturn 0;\n\nerror:\n\tif (is_truncate)\n\t\tfuse_release_nowrite(inode);\n\n\tclear_bit(FUSE_I_SIZE_UNSTABLE, &fi->state);\n\n\tif (fault_blocked)\n\t\tup_write(&fi->i_mmap_sem);\n\treturn err;\n}",
        "description": "An issue was discovered in the FUSE filesystem implementation within the Linux kernel prior to version 5.10.6, identified as CID-5d069dbe8aaf. The function fuse_do_getattr() incorrectly invokes make_bad_inode(), leading to system crashes. Note that the initial fix for this vulnerability was incomplete and is separately tracked as CVE-2021-28950.",
        "commit": "A vulnerability was identified in the FUSE filesystem implementation within the Linux kernel, where opening a directory and attaching a dnotify mark leads to inconsistencies in the attributes returned by the server. This inconsistency triggers a call to `make_bad_inode()`, which sets the inode mode to a regular file. As a result, dnotify fails to properly tear down its structures, ultimately causing a crash. To address this issue, the approach should involve avoiding the use of `make_bad_inode()` on a live inode by introducing a private flag on the FUSE inode instead. Additionally, incorporating the necessary checks from `bad_inode_ops` into the operations can help mitigate this problem. This bug has been present since the initial integration of FUSE into the Linux kernel in version 2.6.14."
    },
    {
        "cwe": "CWE-212",
        "func_name": "linux4sam/secure_decrypt",
        "score": 0.7454324960708618,
        "func_before": "int secure_decrypt(void *data, unsigned int data_length, int is_signed)\n{\n\tat91_aes_key_size_t key_size;\n\tunsigned int cmac_key[8], cipher_key[8];\n\tunsigned int iv[AT91_AES_IV_SIZE_WORD];\n\tunsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int fixed_length;\n\tconst unsigned int *cmac;\n\tint rc = -1;\n\n\t/* Init keys */\n\tinit_keys(&key_size, cipher_key, cmac_key, iv);\n\n\t/* Init periph */\n\tat91_aes_init();\n\n\t/* Check signature if required */\n\tif (is_signed) {\n\t\t/* Compute the CMAC */\n\t\tif (at91_aes_cmac(data_length, data, computed_cmac,\n\t\t\t\t  key_size, cmac_key))\n\t\t\tgoto exit;\n\n\t\t/* Check the CMAC */\n\t\tfixed_length = at91_aes_roundup(data_length);\n\t\tcmac = (const unsigned int *)((char *)data + fixed_length);\n\t\tif (!consttime_memequal(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))\n\t\t\tgoto exit;\n\t}\n\n\t/* Decrypt the whole file */\n\tif (at91_aes_cbc(data_length, data, data, 0,\n\t\t\t key_size, cipher_key, iv))\n\t\tgoto exit;\n\n\trc = 0;\nexit:\n\t/* Reset periph */\n\tat91_aes_cleanup();\n\n\t/* Reset keys */\n\tmemset(cmac_key, 0, sizeof(cmac_key));\n\tmemset(cipher_key, 0, sizeof(cipher_key));\n\tmemset(iv, 0, sizeof(iv));\n\n\treturn rc;\n}",
        "func_after": "static int secure_decrypt(void *data, unsigned int data_length, int is_signed)\n{\n\tat91_aes_key_size_t key_size;\n\tunsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int fixed_length;\n\tconst unsigned int *cmac;\n\tint rc = -1;\n\n#if defined(CONFIG_AES_KEY_SIZE_128)\n\tkey_size = AT91_AES_KEY_SIZE_128;\n#elif defined(CONFIG_AES_KEY_SIZE_192)\n\tkey_size = AT91_AES_KEY_SIZE_192;\n#elif defined(CONFIG_AES_KEY_SIZE_256)\n\tkey_size = AT91_AES_KEY_SIZE_256;\n#else\n#error \"bad AES key size\"\n#endif\n\n\t/* Init periph */\n\tat91_aes_init();\n\n\t/* Check signature if required */\n\tif (is_signed) {\n\t\t/* Compute the CMAC */\n\t\tif (at91_aes_cmac(data_length, data, computed_cmac,\n\t\t\t\t  key_size, cmac_key))\n\t\t\tgoto exit;\n\n\t\t/* Check the CMAC */\n\t\tfixed_length = at91_aes_roundup(data_length);\n\t\tcmac = (const unsigned int *)((char *)data + fixed_length);\n\t\tif (!consttime_memequal(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))\n\t\t\tgoto exit;\n\t}\n\n\t/* Decrypt the whole file */\n\tif (at91_aes_cbc(data_length, data, data, 0,\n\t\t\t key_size, cipher_key, iv))\n\t\tgoto exit;\n\n\trc = 0;\nexit:\n\t/* Reset periph */\n\tat91_aes_cleanup();\n\n\treturn rc;\n}",
        "description": "AT91bootstrap versions prior to 3.9.2 fail to adequately clear encryption and authentication keys from memory before transitioning control to a less privileged software component. This failure can be exploited to expose these keys, potentially allowing attackers to encrypt and sign subsequent boot stages, such as the bootloader.",
        "commit": "The vulnerability knowledge has been abstracted and generalized as follows:\n\n\"Keys were moved into static arrays to prevent their copying from the code section to the stack during initialization. By hardcoding the keys into the data section at compile time and ensuring they can be completely wiped after use, this change enhances security by reducing the risk of key exposure.\""
    },
    {
        "cwe": "CWE-911",
        "func_name": "torvalds/u32_destroy_key",
        "score": 0.7158316969871521,
        "func_before": "static int u32_destroy_key(struct tc_u_knode *n, bool free_pf)\n{\n\tstruct tc_u_hnode *ht = rtnl_dereference(n->ht_down);\n\n\ttcf_exts_destroy(&n->exts);\n\ttcf_exts_put_net(&n->exts);\n\tif (ht && --ht->refcnt == 0)\n\t\tkfree(ht);\n#ifdef CONFIG_CLS_U32_PERF\n\tif (free_pf)\n\t\tfree_percpu(n->pf);\n#endif\n#ifdef CONFIG_CLS_U32_MARK\n\tif (free_pf)\n\t\tfree_percpu(n->pcpu_success);\n#endif\n\tkfree(n);\n\treturn 0;\n}",
        "func_after": "static void u32_destroy_key(struct tc_u_knode *n, bool free_pf)\n{\n\ttcf_exts_put_net(&n->exts);\n#ifdef CONFIG_CLS_U32_PERF\n\tif (free_pf)\n\t\tfree_percpu(n->pf);\n#endif\n#ifdef CONFIG_CLS_U32_MARK\n\tif (free_pf)\n\t\tfree_percpu(n->pcpu_success);\n#endif\n\t__u32_destroy_key(n);\n}",
        "description": "An Improper Update of Reference Count vulnerability in the networking scheduler component of the Linux Kernel enables a local attacker to achieve privilege escalation to root. This issue impacts Linux Kernel versions prior to 5.18 and versions 4.14 and later.",
        "commit": "A vulnerability was identified in the Linux kernel where an extra `put_net()` operation is detected prematurely. Specifically, functions such as `u32_init_knode()` and `tcf_exts_init()` populate the `->exts.net` pointer without elevating the reference count on the network namespace (`netns`). The reference count is incremented only when `tcf_exts_get_net()` is called. Consequently, two calls to `u32_destroy_key()` from `u32_change()` attempt to release an invalid reference on the `netns`, leading to a refcount decrement hitting zero and potential memory leaks. This issue occurs in the Linux kernel prior to a specific version, affecting the handling of network traffic classification and filtering mechanisms."
    },
    {
        "cwe": "CWE-665",
        "func_name": "torvalds/__skb_flow_dissect",
        "score": 0.7796949744224548,
        "func_before": "bool __skb_flow_dissect(const struct sk_buff *skb,\n\t\t\tstruct flow_dissector *flow_dissector,\n\t\t\tvoid *target_container,\n\t\t\tvoid *data, __be16 proto, int nhoff, int hlen)\n{\n\tstruct flow_dissector_key_control *key_control;\n\tstruct flow_dissector_key_basic *key_basic;\n\tstruct flow_dissector_key_addrs *key_addrs;\n\tstruct flow_dissector_key_ports *key_ports;\n\tstruct flow_dissector_key_tags *key_tags;\n\tstruct flow_dissector_key_keyid *key_keyid;\n\tu8 ip_proto = 0;\n\n\tif (!data) {\n\t\tdata = skb->data;\n\t\tproto = skb->protocol;\n\t\tnhoff = skb_network_offset(skb);\n\t\thlen = skb_headlen(skb);\n\t}\n\n\t/* It is ensured by skb_flow_dissector_init() that control key will\n\t * be always present.\n\t */\n\tkey_control = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_CONTROL,\n\t\t\t\t\t\ttarget_container);\n\n\t/* It is ensured by skb_flow_dissector_init() that basic key will\n\t * be always present.\n\t */\n\tkey_basic = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t      FLOW_DISSECTOR_KEY_BASIC,\n\t\t\t\t\t      target_container);\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct ethhdr *eth = eth_hdr(skb);\n\t\tstruct flow_dissector_key_eth_addrs *key_eth_addrs;\n\n\t\tkey_eth_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t  FLOW_DISSECTOR_KEY_ETH_ADDRS,\n\t\t\t\t\t\t\t  target_container);\n\t\tmemcpy(key_eth_addrs, &eth->h_dest, sizeof(*key_eth_addrs));\n\t}\n\nagain:\n\tswitch (proto) {\n\tcase htons(ETH_P_IP): {\n\t\tconst struct iphdr *iph;\n\t\tstruct iphdr _iph;\nip:\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph || iph->ihl < 5)\n\t\t\treturn false;\n\t\tnhoff += iph->ihl * 4;\n\n\t\tip_proto = iph->protocol;\n\t\tif (ip_is_fragment(iph))\n\t\t\tip_proto = 0;\n\n\t\tif (!skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t FLOW_DISSECTOR_KEY_IPV4_ADDRS))\n\t\t\tbreak;\n\n\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t      FLOW_DISSECTOR_KEY_IPV4_ADDRS, target_container);\n\t\tmemcpy(&key_addrs->v4addrs, &iph->saddr,\n\t\t       sizeof(key_addrs->v4addrs));\n\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_IPV6): {\n\t\tconst struct ipv6hdr *iph;\n\t\tstruct ipv6hdr _iph;\n\t\t__be32 flow_label;\n\nipv6:\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph)\n\t\t\treturn false;\n\n\t\tip_proto = iph->nexthdr;\n\t\tnhoff += sizeof(struct ipv6hdr);\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_IPV6_ADDRS)) {\n\t\t\tstruct flow_dissector_key_ipv6_addrs *key_ipv6_addrs;\n\n\t\t\tkey_ipv6_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t   FLOW_DISSECTOR_KEY_IPV6_ADDRS,\n\t\t\t\t\t\t\t\t   target_container);\n\n\t\t\tmemcpy(key_ipv6_addrs, &iph->saddr, sizeof(*key_ipv6_addrs));\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t}\n\n\t\tflow_label = ip6_flowlabel(iph);\n\t\tif (flow_label) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\tFLOW_DISSECTOR_KEY_FLOW_LABEL)) {\n\t\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_FLOW_LABEL,\n\t\t\t\t\t\t\t\t     target_container);\n\t\t\t\tkey_tags->flow_label = ntohl(flow_label);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_8021AD):\n\tcase htons(ETH_P_8021Q): {\n\t\tconst struct vlan_hdr *vlan;\n\t\tstruct vlan_hdr _vlan;\n\n\t\tvlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);\n\t\tif (!vlan)\n\t\t\treturn false;\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_VLANID)) {\n\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_VLANID,\n\t\t\t\t\t\t\t     target_container);\n\n\t\t\tkey_tags->vlan_id = skb_vlan_tag_get_id(skb);\n\t\t}\n\n\t\tproto = vlan->h_vlan_encapsulated_proto;\n\t\tnhoff += sizeof(*vlan);\n\t\tgoto again;\n\t}\n\tcase htons(ETH_P_PPP_SES): {\n\t\tstruct {\n\t\t\tstruct pppoe_hdr hdr;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\t\tproto = hdr->proto;\n\t\tnhoff += PPPOE_SES_HLEN;\n\t\tswitch (proto) {\n\t\tcase htons(PPP_IP):\n\t\t\tgoto ip;\n\t\tcase htons(PPP_IPV6):\n\t\t\tgoto ipv6;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\tcase htons(ETH_P_TIPC): {\n\t\tstruct {\n\t\t\t__be32 pre[3];\n\t\t\t__be32 srcnode;\n\t\t} *hdr, _hdr;\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\t\tkey_basic->n_proto = proto;\n\t\tkey_control->thoff = (u16)nhoff;\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_TIPC_ADDRS)) {\n\t\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_TIPC_ADDRS,\n\t\t\t\t\t\t\t      target_container);\n\t\t\tkey_addrs->tipcaddrs.srcnode = hdr->srcnode;\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;\n\t\t}\n\t\treturn true;\n\t}\n\n\tcase htons(ETH_P_MPLS_UC):\n\tcase htons(ETH_P_MPLS_MC): {\n\t\tstruct mpls_label *hdr, _hdr[2];\nmpls:\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,\n\t\t\t\t\t   hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\n\t\tif ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>\n\t\t     MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_MPLS_ENTROPY)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_MPLS_ENTROPY,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = hdr[1].entry &\n\t\t\t\t\thtonl(MPLS_LS_LABEL_MASK);\n\t\t\t}\n\n\t\t\tkey_basic->n_proto = proto;\n\t\t\tkey_basic->ip_proto = ip_proto;\n\t\t\tkey_control->thoff = (u16)nhoff;\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tcase htons(ETH_P_FCOE):\n\t\tkey_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);\n\t\t/* fall through */\n\tdefault:\n\t\treturn false;\n\t}\n\nip_proto_again:\n\tswitch (ip_proto) {\n\tcase IPPROTO_GRE: {\n\t\tstruct gre_hdr {\n\t\t\t__be16 flags;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\t\t/*\n\t\t * Only look inside GRE if version zero and no\n\t\t * routing\n\t\t */\n\t\tif (hdr->flags & (GRE_VERSION | GRE_ROUTING))\n\t\t\tbreak;\n\n\t\tproto = hdr->proto;\n\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_CSUM)\n\t\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_KEY) {\n\t\t\tconst __be32 *keyid;\n\t\t\t__be32 _keyid;\n\n\t\t\tkeyid = __skb_header_pointer(skb, nhoff, sizeof(_keyid),\n\t\t\t\t\t\t     data, hlen, &_keyid);\n\n\t\t\tif (!keyid)\n\t\t\t\treturn false;\n\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_GRE_KEYID)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_GRE_KEYID,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = *keyid;\n\t\t\t}\n\t\t\tnhoff += 4;\n\t\t}\n\t\tif (hdr->flags & GRE_SEQ)\n\t\t\tnhoff += 4;\n\t\tif (proto == htons(ETH_P_TEB)) {\n\t\t\tconst struct ethhdr *eth;\n\t\t\tstruct ethhdr _eth;\n\n\t\t\teth = __skb_header_pointer(skb, nhoff,\n\t\t\t\t\t\t   sizeof(_eth),\n\t\t\t\t\t\t   data, hlen, &_eth);\n\t\t\tif (!eth)\n\t\t\t\treturn false;\n\t\t\tproto = eth->h_proto;\n\t\t\tnhoff += sizeof(*eth);\n\t\t}\n\t\tgoto again;\n\t}\n\tcase NEXTHDR_HOP:\n\tcase NEXTHDR_ROUTING:\n\tcase NEXTHDR_DEST: {\n\t\tu8 _opthdr[2], *opthdr;\n\n\t\tif (proto != htons(ETH_P_IPV6))\n\t\t\tbreak;\n\n\t\topthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),\n\t\t\t\t\t      data, hlen, &_opthdr);\n\t\tif (!opthdr)\n\t\t\treturn false;\n\n\t\tip_proto = opthdr[0];\n\t\tnhoff += (opthdr[1] + 1) << 3;\n\n\t\tgoto ip_proto_again;\n\t}\n\tcase IPPROTO_IPIP:\n\t\tproto = htons(ETH_P_IP);\n\t\tgoto ip;\n\tcase IPPROTO_IPV6:\n\t\tproto = htons(ETH_P_IPV6);\n\t\tgoto ipv6;\n\tcase IPPROTO_MPLS:\n\t\tproto = htons(ETH_P_MPLS_UC);\n\t\tgoto mpls;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkey_basic->n_proto = proto;\n\tkey_basic->ip_proto = ip_proto;\n\tkey_control->thoff = (u16)nhoff;\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_PORTS)) {\n\t\tkey_ports = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_PORTS,\n\t\t\t\t\t\t      target_container);\n\t\tkey_ports->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,\n\t\t\t\t\t\t\tdata, hlen);\n\t}\n\n\treturn true;\n}",
        "func_after": "bool __skb_flow_dissect(const struct sk_buff *skb,\n\t\t\tstruct flow_dissector *flow_dissector,\n\t\t\tvoid *target_container,\n\t\t\tvoid *data, __be16 proto, int nhoff, int hlen)\n{\n\tstruct flow_dissector_key_control *key_control;\n\tstruct flow_dissector_key_basic *key_basic;\n\tstruct flow_dissector_key_addrs *key_addrs;\n\tstruct flow_dissector_key_ports *key_ports;\n\tstruct flow_dissector_key_tags *key_tags;\n\tstruct flow_dissector_key_keyid *key_keyid;\n\tu8 ip_proto = 0;\n\tbool ret = false;\n\n\tif (!data) {\n\t\tdata = skb->data;\n\t\tproto = skb->protocol;\n\t\tnhoff = skb_network_offset(skb);\n\t\thlen = skb_headlen(skb);\n\t}\n\n\t/* It is ensured by skb_flow_dissector_init() that control key will\n\t * be always present.\n\t */\n\tkey_control = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_CONTROL,\n\t\t\t\t\t\ttarget_container);\n\n\t/* It is ensured by skb_flow_dissector_init() that basic key will\n\t * be always present.\n\t */\n\tkey_basic = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t      FLOW_DISSECTOR_KEY_BASIC,\n\t\t\t\t\t      target_container);\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct ethhdr *eth = eth_hdr(skb);\n\t\tstruct flow_dissector_key_eth_addrs *key_eth_addrs;\n\n\t\tkey_eth_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t  FLOW_DISSECTOR_KEY_ETH_ADDRS,\n\t\t\t\t\t\t\t  target_container);\n\t\tmemcpy(key_eth_addrs, &eth->h_dest, sizeof(*key_eth_addrs));\n\t}\n\nagain:\n\tswitch (proto) {\n\tcase htons(ETH_P_IP): {\n\t\tconst struct iphdr *iph;\n\t\tstruct iphdr _iph;\nip:\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph || iph->ihl < 5)\n\t\t\tgoto out_bad;\n\t\tnhoff += iph->ihl * 4;\n\n\t\tip_proto = iph->protocol;\n\t\tif (ip_is_fragment(iph))\n\t\t\tip_proto = 0;\n\n\t\tif (!skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t FLOW_DISSECTOR_KEY_IPV4_ADDRS))\n\t\t\tbreak;\n\n\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t      FLOW_DISSECTOR_KEY_IPV4_ADDRS, target_container);\n\t\tmemcpy(&key_addrs->v4addrs, &iph->saddr,\n\t\t       sizeof(key_addrs->v4addrs));\n\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_IPV6): {\n\t\tconst struct ipv6hdr *iph;\n\t\tstruct ipv6hdr _iph;\n\t\t__be32 flow_label;\n\nipv6:\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph)\n\t\t\tgoto out_bad;\n\n\t\tip_proto = iph->nexthdr;\n\t\tnhoff += sizeof(struct ipv6hdr);\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_IPV6_ADDRS)) {\n\t\t\tstruct flow_dissector_key_ipv6_addrs *key_ipv6_addrs;\n\n\t\t\tkey_ipv6_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t   FLOW_DISSECTOR_KEY_IPV6_ADDRS,\n\t\t\t\t\t\t\t\t   target_container);\n\n\t\t\tmemcpy(key_ipv6_addrs, &iph->saddr, sizeof(*key_ipv6_addrs));\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t}\n\n\t\tflow_label = ip6_flowlabel(iph);\n\t\tif (flow_label) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\tFLOW_DISSECTOR_KEY_FLOW_LABEL)) {\n\t\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_FLOW_LABEL,\n\t\t\t\t\t\t\t\t     target_container);\n\t\t\t\tkey_tags->flow_label = ntohl(flow_label);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_8021AD):\n\tcase htons(ETH_P_8021Q): {\n\t\tconst struct vlan_hdr *vlan;\n\t\tstruct vlan_hdr _vlan;\n\n\t\tvlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);\n\t\tif (!vlan)\n\t\t\tgoto out_bad;\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_VLANID)) {\n\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_VLANID,\n\t\t\t\t\t\t\t     target_container);\n\n\t\t\tkey_tags->vlan_id = skb_vlan_tag_get_id(skb);\n\t\t}\n\n\t\tproto = vlan->h_vlan_encapsulated_proto;\n\t\tnhoff += sizeof(*vlan);\n\t\tgoto again;\n\t}\n\tcase htons(ETH_P_PPP_SES): {\n\t\tstruct {\n\t\t\tstruct pppoe_hdr hdr;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\tgoto out_bad;\n\t\tproto = hdr->proto;\n\t\tnhoff += PPPOE_SES_HLEN;\n\t\tswitch (proto) {\n\t\tcase htons(PPP_IP):\n\t\t\tgoto ip;\n\t\tcase htons(PPP_IPV6):\n\t\t\tgoto ipv6;\n\t\tdefault:\n\t\t\tgoto out_bad;\n\t\t}\n\t}\n\tcase htons(ETH_P_TIPC): {\n\t\tstruct {\n\t\t\t__be32 pre[3];\n\t\t\t__be32 srcnode;\n\t\t} *hdr, _hdr;\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\tgoto out_bad;\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_TIPC_ADDRS)) {\n\t\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_TIPC_ADDRS,\n\t\t\t\t\t\t\t      target_container);\n\t\t\tkey_addrs->tipcaddrs.srcnode = hdr->srcnode;\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;\n\t\t}\n\t\tgoto out_good;\n\t}\n\n\tcase htons(ETH_P_MPLS_UC):\n\tcase htons(ETH_P_MPLS_MC): {\n\t\tstruct mpls_label *hdr, _hdr[2];\nmpls:\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,\n\t\t\t\t\t   hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\tgoto out_bad;\n\n\t\tif ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>\n\t\t     MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_MPLS_ENTROPY)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_MPLS_ENTROPY,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = hdr[1].entry &\n\t\t\t\t\thtonl(MPLS_LS_LABEL_MASK);\n\t\t\t}\n\n\t\t\tgoto out_good;\n\t\t}\n\n\t\tgoto out_good;\n\t}\n\n\tcase htons(ETH_P_FCOE):\n\t\tkey_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);\n\t\t/* fall through */\n\tdefault:\n\t\tgoto out_bad;\n\t}\n\nip_proto_again:\n\tswitch (ip_proto) {\n\tcase IPPROTO_GRE: {\n\t\tstruct gre_hdr {\n\t\t\t__be16 flags;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\tgoto out_bad;\n\t\t/*\n\t\t * Only look inside GRE if version zero and no\n\t\t * routing\n\t\t */\n\t\tif (hdr->flags & (GRE_VERSION | GRE_ROUTING))\n\t\t\tbreak;\n\n\t\tproto = hdr->proto;\n\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_CSUM)\n\t\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_KEY) {\n\t\t\tconst __be32 *keyid;\n\t\t\t__be32 _keyid;\n\n\t\t\tkeyid = __skb_header_pointer(skb, nhoff, sizeof(_keyid),\n\t\t\t\t\t\t     data, hlen, &_keyid);\n\n\t\t\tif (!keyid)\n\t\t\t\tgoto out_bad;\n\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_GRE_KEYID)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_GRE_KEYID,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = *keyid;\n\t\t\t}\n\t\t\tnhoff += 4;\n\t\t}\n\t\tif (hdr->flags & GRE_SEQ)\n\t\t\tnhoff += 4;\n\t\tif (proto == htons(ETH_P_TEB)) {\n\t\t\tconst struct ethhdr *eth;\n\t\t\tstruct ethhdr _eth;\n\n\t\t\teth = __skb_header_pointer(skb, nhoff,\n\t\t\t\t\t\t   sizeof(_eth),\n\t\t\t\t\t\t   data, hlen, &_eth);\n\t\t\tif (!eth)\n\t\t\t\tgoto out_bad;\n\t\t\tproto = eth->h_proto;\n\t\t\tnhoff += sizeof(*eth);\n\t\t}\n\t\tgoto again;\n\t}\n\tcase NEXTHDR_HOP:\n\tcase NEXTHDR_ROUTING:\n\tcase NEXTHDR_DEST: {\n\t\tu8 _opthdr[2], *opthdr;\n\n\t\tif (proto != htons(ETH_P_IPV6))\n\t\t\tbreak;\n\n\t\topthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),\n\t\t\t\t\t      data, hlen, &_opthdr);\n\t\tif (!opthdr)\n\t\t\tgoto out_bad;\n\n\t\tip_proto = opthdr[0];\n\t\tnhoff += (opthdr[1] + 1) << 3;\n\n\t\tgoto ip_proto_again;\n\t}\n\tcase IPPROTO_IPIP:\n\t\tproto = htons(ETH_P_IP);\n\t\tgoto ip;\n\tcase IPPROTO_IPV6:\n\t\tproto = htons(ETH_P_IPV6);\n\t\tgoto ipv6;\n\tcase IPPROTO_MPLS:\n\t\tproto = htons(ETH_P_MPLS_UC);\n\t\tgoto mpls;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_PORTS)) {\n\t\tkey_ports = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_PORTS,\n\t\t\t\t\t\t      target_container);\n\t\tkey_ports->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,\n\t\t\t\t\t\t\tdata, hlen);\n\t}\n\nout_good:\n\tret = true;\n\nout_bad:\n\tkey_basic->n_proto = proto;\n\tkey_basic->ip_proto = ip_proto;\n\tkey_control->thoff = (u16)nhoff;\n\n\treturn ret;\n}",
        "description": "The `__skb_flow_dissect` function in the Linux kernel, prior to version 4.3, does not guarantee the initialization of certain protocol fields (`n_proto`, `ip_proto`, and `thoff`). This oversight enables remote attackers to exploit a single crafted MPLS packet to trigger a denial of service (system crash) or potentially execute arbitrary code.",
        "commit": "The vulnerability involves a function responsible for dissecting network flows, where instead of returning immediately upon encountering a parsing failure, it jumps to cleanup code. This approach ensures that even in the event of a failure, some protocol values are set in the key_control structure, although there may still be valid information in the key_tags that was established before the error occurred."
    }
]