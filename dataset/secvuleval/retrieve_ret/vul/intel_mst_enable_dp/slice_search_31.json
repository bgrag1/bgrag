[
    {
        "cwe": "CWE-385",
        "func_name": "openssl/ecdsa_sign_setup",
        "score": 0.8132513165473938,
        "func_before": "static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,\n\t\t\t\t\tBIGNUM **kinvp, BIGNUM **rp,\n\t\t\t\t\tconst unsigned char *dgst, int dlen)\n{\n\tBN_CTX   *ctx = NULL;\n\tBIGNUM\t *k = NULL, *r = NULL, *order = NULL, *X = NULL;\n\tEC_POINT *tmp_point=NULL;\n\tconst EC_GROUP *group;\n\tint \t ret = 0;\n\n\tif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\n\tif (ctx_in == NULL) \n\t{\n\t\tif ((ctx = BN_CTX_new()) == NULL)\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t\tctx = ctx_in;\n\n\tk     = BN_new();\t/* this value is later returned in *kinvp */\n\tr     = BN_new();\t/* this value is later returned in *rp    */\n\torder = BN_new();\n\tX     = BN_new();\n\tif (!k || !r || !order || !X)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t}\n\tif ((tmp_point = EC_POINT_new(group)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\tif (!EC_GROUP_get_order(group, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\n#ifdef OPENSSL_FIPS\n\tif (!fips_check_ec_prng(eckey))\n\t\tgoto err;\n#endif\n\t\n\tdo\n\t{\n\t\t/* get random k */\t\n\t\tdo\n#ifndef OPENSSL_NO_SHA512\n\t\t\tif (dgst != NULL)\n\t\t\t{\n\t\t\t\tif (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),\n\t\t\t\t\t\t\t   dgst, dlen, ctx))\n\t\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tif (!BN_rand_range(k, order))\n\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\twhile (BN_is_zero(k));\n\n\t\t/* We do not want timing information to leak the length of k,\n\t\t * so we compute G*k using an equivalent scalar of fixed\n\t\t * bit-length. */\n\n\t\tif (!BN_add(k, k, order)) goto err;\n\t\tif (BN_num_bits(k) <= BN_num_bits(order))\n\t\t\tif (!BN_add(k, k, order)) goto err;\n\n\t\t/* compute r the x-coordinate of generator * k */\n\t\tif (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t}\n\t\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#ifndef OPENSSL_NO_EC2M\n\t\telse /* NID_X9_62_characteristic_two_field */\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GF2m(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!BN_nnmod(r, X, order, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t}\n\t}\n\twhile (BN_is_zero(r));\n\n\t/* compute the inverse of k */\n\tif (!BN_mod_inverse(k, k, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\tgoto err;\t\n\t}\n\t/* clear old values if necessary */\n\tif (*rp != NULL)\n\t\tBN_clear_free(*rp);\n\tif (*kinvp != NULL) \n\t\tBN_clear_free(*kinvp);\n\t/* save the pre-computed values  */\n\t*rp    = r;\n\t*kinvp = k;\n\tret = 1;\nerr:\n\tif (!ret)\n\t{\n\t\tif (k != NULL) BN_clear_free(k);\n\t\tif (r != NULL) BN_clear_free(r);\n\t}\n\tif (ctx_in == NULL) \n\t\tBN_CTX_free(ctx);\n\tif (order != NULL)\n\t\tBN_free(order);\n\tif (tmp_point != NULL) \n\t\tEC_POINT_free(tmp_point);\n\tif (X)\n\t\tBN_clear_free(X);\n\treturn(ret);\n}",
        "func_after": "static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,\n\t\t\t\t\tBIGNUM **kinvp, BIGNUM **rp,\n\t\t\t\t\tconst unsigned char *dgst, int dlen)\n{\n\tBN_CTX   *ctx = NULL;\n\tBIGNUM\t *k = NULL, *r = NULL, *order = NULL, *X = NULL;\n\tEC_POINT *tmp_point=NULL;\n\tconst EC_GROUP *group;\n\tint \t ret = 0;\n\n\tif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\n\tif (ctx_in == NULL) \n\t{\n\t\tif ((ctx = BN_CTX_new()) == NULL)\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t\tctx = ctx_in;\n\n\tk     = BN_new();\t/* this value is later returned in *kinvp */\n\tr     = BN_new();\t/* this value is later returned in *rp    */\n\torder = BN_new();\n\tX     = BN_new();\n\tif (!k || !r || !order || !X)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t}\n\tif ((tmp_point = EC_POINT_new(group)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\tif (!EC_GROUP_get_order(group, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\n#ifdef OPENSSL_FIPS\n\tif (!fips_check_ec_prng(eckey))\n\t\tgoto err;\n#endif\n\t\n\tdo\n\t{\n\t\t/* get random k */\t\n\t\tdo\n#ifndef OPENSSL_NO_SHA512\n\t\t\tif (dgst != NULL)\n\t\t\t{\n\t\t\t\tif (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),\n\t\t\t\t\t\t\t   dgst, dlen, ctx))\n\t\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tif (!BN_rand_range(k, order))\n\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\twhile (BN_is_zero(k));\n\n\t\t/* We do not want timing information to leak the length of k,\n\t\t * so we compute G*k using an equivalent scalar of fixed\n\t\t * bit-length. */\n\n\t\tif (!BN_add(k, k, order)) goto err;\n\t\tif (BN_num_bits(k) <= BN_num_bits(order))\n\t\t\tif (!BN_add(k, k, order)) goto err;\n\n\t\t/* compute r the x-coordinate of generator * k */\n\t\tif (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t}\n\t\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#ifndef OPENSSL_NO_EC2M\n\t\telse /* NID_X9_62_characteristic_two_field */\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GF2m(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!BN_nnmod(r, X, order, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t}\n\t}\n\twhile (BN_is_zero(r));\n\n\t/* compute the inverse of k */\n\tif (EC_GROUP_get_mont_data(group) != NULL)\n\t\t{\n\t\t/* We want inverse in constant time, therefore we utilize the\n\t\t * fact order must be prime and use Fermats Little Theorem\n\t\t * instead. */\n\t\tif (!BN_set_word(X, 2) )\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (!BN_mod_sub(X, order, X, order, ctx))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tBN_set_flags(X, BN_FLG_CONSTTIME);\n\t\tif (!BN_mod_exp_mont_consttime(k, k, X, order, ctx, EC_GROUP_get_mont_data(group)))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tif (!BN_mod_inverse(k, k, order, ctx))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\t\n\t\t\t}\n\t\t}\n\n\t/* clear old values if necessary */\n\tif (*rp != NULL)\n\t\tBN_clear_free(*rp);\n\tif (*kinvp != NULL) \n\t\tBN_clear_free(*kinvp);\n\t/* save the pre-computed values  */\n\t*rp    = r;\n\t*kinvp = k;\n\tret = 1;\nerr:\n\tif (!ret)\n\t{\n\t\tif (k != NULL) BN_clear_free(k);\n\t\tif (r != NULL) BN_clear_free(r);\n\t}\n\tif (ctx_in == NULL) \n\t\tBN_CTX_free(ctx);\n\tif (order != NULL)\n\t\tBN_free(order);\n\tif (tmp_point != NULL) \n\t\tEC_POINT_free(tmp_point);\n\tif (X)\n\t\tBN_clear_free(X);\n\treturn(ret);\n}",
        "description": "A timing attack vulnerability was identified in OpenSSL versions prior to 1.0.1u, enabling a malicious user with local access to potentially recover ECDSA P-256 private keys through the exploitation of timing variations in cryptographic operations.",
        "commit": "The vulnerability knowledge has been abstracted and generalized as follows:\n\n\"The implementation of ECDSA includes an option to utilize BN_mod_exp_mont_consttime, a constant-time modular exponentiation function. This enhancement aims to improve the security of ECDSA operations.\""
    },
    {
        "cwe": "CWE-502",
        "func_name": "godotengine/MultiplayerAPI::_process_rpc",
        "score": 0.7882133722305298,
        "func_before": "void MultiplayerAPI___process_rpc(Node *p_node, const StringName &p_name, int p_from, const uint8_t *p_packet, int p_packet_len, int p_offset) {\n\n\tERR_EXPLAIN(\"Invalid packet received. Size too small.\");\n\tERR_FAIL_COND(p_offset >= p_packet_len);\n\n\t// Check that remote can call the RPC on this node.\n\tRPCMode rpc_mode = RPC_MODE_DISABLED;\n\tconst Map<StringName, RPCMode>::Element *E = p_node->get_node_rpc_mode(p_name);\n\tif (E) {\n\t\trpc_mode = E->get();\n\t} else if (p_node->get_script_instance()) {\n\t\trpc_mode = p_node->get_script_instance()->get_rpc_mode(p_name);\n\t}\n\n\tERR_EXPLAIN(\"RPC '\" + String(p_name) + \"' is not allowed from: \" + itos(p_from) + \". Mode is \" + itos((int)rpc_mode) + \", master is \" + itos(p_node->get_network_master()) + \".\");\n\tERR_FAIL_COND(!_can_call_mode(p_node, rpc_mode, p_from));\n\n\tint argc = p_packet[p_offset];\n\tVector<Variant> args;\n\tVector<const Variant *> argp;\n\targs.resize(argc);\n\targp.resize(argc);\n\n\tp_offset++;\n\n\tfor (int i = 0; i < argc; i++) {\n\n\t\tERR_EXPLAIN(\"Invalid packet received. Size too small.\");\n\t\tERR_FAIL_COND(p_offset >= p_packet_len);\n\n\t\tint vlen;\n\t\tError err = decode_variant(args.write[i], &p_packet[p_offset], p_packet_len - p_offset, &vlen);\n\t\tERR_EXPLAIN(\"Invalid packet received. Unable to decode RPC argument.\");\n\t\tERR_FAIL_COND(err != OK);\n\n\t\targp.write[i] = &args[i];\n\t\tp_offset += vlen;\n\t}\n\n\tVariant::CallError ce;\n\n\tp_node->call(p_name, (const Variant **)argp.ptr(), argc, ce);\n\tif (ce.error != Variant::CallError::CALL_OK) {\n\t\tString error = Variant::get_call_error_text(p_node, p_name, (const Variant **)argp.ptr(), argc, ce);\n\t\terror = \"RPC - \" + error;\n\t\tERR_PRINTS(error);\n\t}\n}",
        "func_after": "void MultiplayerAPI___process_rpc(Node *p_node, const StringName &p_name, int p_from, const uint8_t *p_packet, int p_packet_len, int p_offset) {\n\n\tERR_EXPLAIN(\"Invalid packet received. Size too small.\");\n\tERR_FAIL_COND(p_offset >= p_packet_len);\n\n\t// Check that remote can call the RPC on this node.\n\tRPCMode rpc_mode = RPC_MODE_DISABLED;\n\tconst Map<StringName, RPCMode>::Element *E = p_node->get_node_rpc_mode(p_name);\n\tif (E) {\n\t\trpc_mode = E->get();\n\t} else if (p_node->get_script_instance()) {\n\t\trpc_mode = p_node->get_script_instance()->get_rpc_mode(p_name);\n\t}\n\n\tERR_EXPLAIN(\"RPC '\" + String(p_name) + \"' is not allowed from: \" + itos(p_from) + \". Mode is \" + itos((int)rpc_mode) + \", master is \" + itos(p_node->get_network_master()) + \".\");\n\tERR_FAIL_COND(!_can_call_mode(p_node, rpc_mode, p_from));\n\n\tint argc = p_packet[p_offset];\n\tVector<Variant> args;\n\tVector<const Variant *> argp;\n\targs.resize(argc);\n\targp.resize(argc);\n\n\tp_offset++;\n\n\tfor (int i = 0; i < argc; i++) {\n\n\t\tERR_EXPLAIN(\"Invalid packet received. Size too small.\");\n\t\tERR_FAIL_COND(p_offset >= p_packet_len);\n\n\t\tint vlen;\n\t\tError err = decode_variant(args.write[i], &p_packet[p_offset], p_packet_len - p_offset, &vlen, network_peer->is_object_decoding_allowed());\n\t\tERR_EXPLAIN(\"Invalid packet received. Unable to decode RPC argument.\");\n\t\tERR_FAIL_COND(err != OK);\n\n\t\targp.write[i] = &args[i];\n\t\tp_offset += vlen;\n\t}\n\n\tVariant::CallError ce;\n\n\tp_node->call(p_name, (const Variant **)argp.ptr(), argc, ce);\n\tif (ce.error != Variant::CallError::CALL_OK) {\n\t\tString error = Variant::get_call_error_text(p_node, p_name, (const Variant **)argp.ptr(), argc, ce);\n\t\terror = \"RPC - \" + error;\n\t\tERR_PRINTS(error);\n\t}\n}",
        "description": "In Godot versions up to 3.1, remote code execution is possible due to an incorrect application of the deserialization policy.",
        "commit": "The Multiplayer API has been updated to honor the allow_object_decoding setting."
    },
    {
        "cwe": "CWE-668",
        "func_name": "xen-project/sh_guess_wrmap",
        "score": 0.783342719078064,
        "func_before": "static int sh_guess_wrmap(struct vcpu *v, unsigned long vaddr, mfn_t gmfn)\n/* Look up this vaddr in the current shadow and see if it's a writeable\n * mapping of this gmfn.  If so, remove it.  Returns 1 if it worked. */\n{\n    struct domain *d = v->domain;\n    shadow_l1e_t sl1e, *sl1p;\n    shadow_l2e_t *sl2p;\n    shadow_l3e_t *sl3p;\n#if SHADOW_PAGING_LEVELS >= 4\n    shadow_l4e_t *sl4p;\n#endif\n    mfn_t sl1mfn;\n    int r;\n\n    /* Carefully look in the shadow linear map for the l1e we expect */\n#if SHADOW_PAGING_LEVELS >= 4\n    sl4p = sh_linear_l4_table(v) + shadow_l4_linear_offset(vaddr);\n    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )\n        return 0;\n    sl3p = sh_linear_l3_table(v) + shadow_l3_linear_offset(vaddr);\n    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )\n        return 0;\n#else /* SHADOW_PAGING_LEVELS == 3 */\n    sl3p = ((shadow_l3e_t *) v->arch.paging.shadow.l3table)\n        + shadow_l3_linear_offset(vaddr);\n    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )\n        return 0;\n#endif\n    sl2p = sh_linear_l2_table(v) + shadow_l2_linear_offset(vaddr);\n    if ( !(shadow_l2e_get_flags(*sl2p) & _PAGE_PRESENT) )\n        return 0;\n    sl1p = sh_linear_l1_table(v) + shadow_l1_linear_offset(vaddr);\n    sl1e = *sl1p;\n    if ( ((shadow_l1e_get_flags(sl1e) & (_PAGE_PRESENT|_PAGE_RW))\n          != (_PAGE_PRESENT|_PAGE_RW))\n         || (mfn_x(shadow_l1e_get_mfn(sl1e)) != mfn_x(gmfn)) )\n        return 0;\n\n    /* Found it!  Need to remove its write permissions. */\n    sl1mfn = shadow_l2e_get_mfn(*sl2p);\n    sl1e = shadow_l1e_remove_flags(sl1e, _PAGE_RW);\n    r = shadow_set_l1e(d, sl1p, sl1e, p2m_ram_rw, sl1mfn);\n    if ( r & SHADOW_SET_ERROR ) {\n        /* Can only currently happen if we found a grant-mapped\n         * page.  Just make the guess fail. */\n        return 0;\n    }\n    TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_WRMAP_GUESS_FOUND);\n    return 1;\n}",
        "func_after": "static int sh_guess_wrmap(struct vcpu *v, unsigned long vaddr, mfn_t gmfn)\n/* Look up this vaddr in the current shadow and see if it's a writeable\n * mapping of this gmfn.  If so, remove it.  Returns 1 if it worked. */\n{\n    struct domain *d = v->domain;\n    shadow_l1e_t sl1e, *sl1p;\n    shadow_l2e_t *sl2p;\n    shadow_l3e_t *sl3p;\n#if SHADOW_PAGING_LEVELS >= 4\n    shadow_l4e_t *sl4p;\n#endif\n    mfn_t sl1mfn;\n    int r;\n\n    /* Carefully look in the shadow linear map for the l1e we expect */\n#if SHADOW_PAGING_LEVELS >= 4\n    /* Is a shadow linear map is installed in the first place? */\n    sl4p  = v->arch.paging.shadow.guest_vtable;\n    sl4p += shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START);\n    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )\n        return 0;\n    sl4p = sh_linear_l4_table(v) + shadow_l4_linear_offset(vaddr);\n    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )\n        return 0;\n    sl3p = sh_linear_l3_table(v) + shadow_l3_linear_offset(vaddr);\n    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )\n        return 0;\n#else /* SHADOW_PAGING_LEVELS == 3 */\n    sl3p = ((shadow_l3e_t *) v->arch.paging.shadow.l3table)\n        + shadow_l3_linear_offset(vaddr);\n    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )\n        return 0;\n#endif\n    sl2p = sh_linear_l2_table(v) + shadow_l2_linear_offset(vaddr);\n    if ( !(shadow_l2e_get_flags(*sl2p) & _PAGE_PRESENT) )\n        return 0;\n    sl1p = sh_linear_l1_table(v) + shadow_l1_linear_offset(vaddr);\n    sl1e = *sl1p;\n    if ( ((shadow_l1e_get_flags(sl1e) & (_PAGE_PRESENT|_PAGE_RW))\n          != (_PAGE_PRESENT|_PAGE_RW))\n         || (mfn_x(shadow_l1e_get_mfn(sl1e)) != mfn_x(gmfn)) )\n        return 0;\n\n    /* Found it!  Need to remove its write permissions. */\n    sl1mfn = shadow_l2e_get_mfn(*sl2p);\n    sl1e = shadow_l1e_remove_flags(sl1e, _PAGE_RW);\n    r = shadow_set_l1e(d, sl1p, sl1e, p2m_ram_rw, sl1mfn);\n    if ( r & SHADOW_SET_ERROR ) {\n        /* Can only currently happen if we found a grant-mapped\n         * page.  Just make the guess fail. */\n        return 0;\n    }\n    TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_WRMAP_GUESS_FOUND);\n    return 1;\n}",
        "description": "An issue was discovered in Xen versions up to 4.9.x, where x86 HVM guest OS users could potentially cause a denial of service (hypervisor crash) or escalate privileges due to improper handling of self-linear shadow mappings in translated guests.",
        "commit": "A vulnerability was identified in the x86/shadow component of the Xen hypervisor, specifically within the `sh_guess_wrmap()` function. The fix for XSA-243/CVE-2017-15592 introduced a change in behavior for `sh_guest_wrmap()`, which now needs to handle cases where no shadow linear mapping is present. The issue arises because `guest_vtable` maps the guest's page table rather than Xen's page table, leading to incorrect checks for the presence of a shadow linear slot. As a result, a shadow HVM vCPU switching to 4-level paging mode with an L4 page table containing a mapping that aliases Xen's `SH_LINEAR_PT_VIRT_START` can pass the safety check when it should fail. Consequently, Xen encounters a page fault due to the missing mapping. This problem is part of XSA-243."
    },
    {
        "cwe": "CWE-440",
        "func_name": "eclipse-openj9/Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex",
        "score": 0.7873140573501587,
        "func_before": "JNIEXPORT jint JNICALL Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *env, jclass InterfaceMethodHandle, jlong interfaceArg, jint itableIndex, jlong receiverClassArg)\n   {\n   J9Class  *interfaceClass = (J9Class*)(intptr_t)interfaceArg;\n   J9Class  *receiverClass  = (J9Class*)(intptr_t)receiverClassArg;\n   J9ITable *itableEntry;\n   for (itableEntry = (J9ITable*)receiverClass->iTable; itableEntry; itableEntry = itableEntry->next)\n      if (itableEntry->interfaceClass == interfaceClass)\n         break;\n   TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *itableArray = (UDATA*)(itableEntry+1);\n   return (itableArray[itableIndex] - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } indexAndLiterals =\n      {\n      (UDATA)interfaceClass,\n      (UDATA)itableIndex\n      };\n   J9Object *receiver = (J9Object*)receiverArg;\n   return (jint)jitLookupInterfaceMethod(receiver->clazz, &indexAndLiterals, 0);\n#endif\n   }",
        "func_after": "JNIEXPORT jint JNICALL Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *env, jclass InterfaceMethodHandle, jlong interfaceArg, jint itableIndex, jlong receiverClassArg)\n   {\n   J9Class  *interfaceClass = (J9Class*)(intptr_t)interfaceArg;\n   J9Class  *receiverClass  = (J9Class*)(intptr_t)receiverClassArg;\n   J9ITable *itableEntry;\n   for (itableEntry = (J9ITable*)receiverClass->iTable; itableEntry; itableEntry = itableEntry->next)\n      if (itableEntry->interfaceClass == interfaceClass)\n         break;\n   TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *itableArray = (UDATA*)(itableEntry+1);\n   UDATA vTableOffset = itableArray[itableIndex];\n   J9Method *method = *(J9Method**)((UDATA)receiverClass + vTableOffset);\n   if ((J9_ROM_METHOD_FROM_RAM_METHOD(method)->modifiers & J9AccPublic) == 0)\n      return -1;\n\n   return (vTableOffset - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } indexAndLiterals =\n      {\n      (UDATA)interfaceClass,\n      (UDATA)itableIndex\n      };\n   J9Object *receiver = (J9Object*)receiverArg;\n   return (jint)jitLookupInterfaceMethod(receiver->clazz, &indexAndLiterals, 0);\n#endif\n   }",
        "description": "In versions of Eclipse Openj9 prior to 0.29.0, the Java Virtual Machine (JVM) fails to throw an IllegalAccessError when MethodHandles are used to invoke methods that are not accessible through interfaces.",
        "commit": "The vulnerability involves a situation where an `IllegalAccessError` (IAE) is not being thrown appropriately when an `InterfaceHandle` encounters a non-public method during dispatch. The expected behavior is for the dispatch mechanism implemented by `InterfaceHandle` to mimic that of `invokeinterface`, which throws an `IAE` when attempting to access non-public methods. This discrepancy allows unauthorized access to non-public methods, potentially leading to security vulnerabilities."
    },
    {
        "cwe": "CWE-276",
        "func_name": "minetest/Server::handleCommand_InventoryAction",
        "score": 0.7933445572853088,
        "func_before": "void Server__handleCommand_InventoryAction(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\t// Strip command and create a stream\n\tstd::string datastring(pkt->getString(0), pkt->getSize());\n\tverbosestream << \"TOSERVER_INVENTORY_ACTION: data=\" << datastring\n\t\t<< std::endl;\n\tstd::istringstream is(datastring, std::ios_base::binary);\n\t// Create an action\n\tInventoryAction *a = InventoryAction::deSerialize(is);\n\tif (!a) {\n\t\tinfostream << \"TOSERVER_INVENTORY_ACTION: \"\n\t\t\t\t<< \"InventoryAction::deSerialize() returned NULL\"\n\t\t\t\t<< std::endl;\n\t\treturn;\n\t}\n\n\t// If something goes wrong, this player is to blame\n\tRollbackScopeActor rollback_scope(m_rollback,\n\t\t\tstd::string(\"player:\")+player->getName());\n\n\t/*\n\t\tNote: Always set inventory not sent, to repair cases\n\t\twhere the client made a bad prediction.\n\t*/\n\n\t/*\n\t\tHandle restrictions and special cases of the move action\n\t*/\n\tif (a->getType() == IAction::Move) {\n\t\tIMoveAction *ma = (IMoveAction*)a;\n\n\t\tma->from_inv.applyCurrentPlayer(player->getName());\n\t\tma->to_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ma->from_inv);\n\t\tif (ma->from_inv != ma->to_inv)\n\t\t\tm_inventory_mgr->setInventoryModified(ma->to_inv);\n\n\t\tbool from_inv_is_current_player =\n\t\t\t(ma->from_inv.type == InventoryLocation::PLAYER) &&\n\t\t\t(ma->from_inv.name == player->getName());\n\n\t\tbool to_inv_is_current_player =\n\t\t\t(ma->to_inv.type == InventoryLocation::PLAYER) &&\n\t\t\t(ma->to_inv.name == player->getName());\n\n\t\tInventoryLocation *remote = from_inv_is_current_player ?\n\t\t\t&ma->to_inv : &ma->from_inv;\n\n\t\t// Check for out-of-range interaction\n\t\tif (remote->type == InventoryLocation::NODEMETA) {\n\t\t\tv3f node_pos   = intToFloat(remote->p, BS);\n\t\t\tv3f player_pos = player->getPlayerSAO()->getEyePosition();\n\t\t\tf32 d = player_pos.getDistanceFrom(node_pos);\n\t\t\tif (!checkInteractDistance(player, d, \"inventory\"))\n\t\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items out of craftpreview\n\t\t*/\n\t\tif (ma->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because src is \" << ma->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items into craftresult and craftpreview\n\t\t*/\n\t\tif (ma->to_list == \"craftpreview\" || ma->to_list == \"craftresult\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because dst is \" << ma->to_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow moving items in elsewhere than player's inventory\n\t\t// if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\") &&\n\t\t\t\t(!from_inv_is_current_player ||\n\t\t\t\t!to_inv_is_current_player)) {\n\t\t\tinfostream << \"Cannot move outside of player's inventory: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the drop action\n\t*/\n\telse if (a->getType() == IAction::Drop) {\n\t\tIDropAction *da = (IDropAction*)a;\n\n\t\tda->from_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(da->from_inv);\n\n\t\t/*\n\t\t\tDisable dropping items out of craftpreview\n\t\t*/\n\t\tif (da->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because src is \" << da->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if dead\n\t\tif (playersao->isDead()) {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because player is dead.\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the craft action\n\t*/\n\telse if (a->getType() == IAction::Craft) {\n\t\tICraftAction *ca = (ICraftAction*)a;\n\n\t\tca->craft_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ca->craft_inv);\n\n\t\t//bool craft_inv_is_current_player =\n\t\t//\t(ca->craft_inv.type == InventoryLocation::PLAYER) &&\n\t\t//\t(ca->craft_inv.name == player->getName());\n\n\t\t// Disallow crafting if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tinfostream << \"Cannot craft: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Do the action\n\ta->apply(m_inventory_mgr.get(), playersao, this);\n\t// Eat the action\n\tdelete a;\n}",
        "func_after": "void Server__handleCommand_InventoryAction(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\t// Strip command and create a stream\n\tstd::string datastring(pkt->getString(0), pkt->getSize());\n\tverbosestream << \"TOSERVER_INVENTORY_ACTION: data=\" << datastring\n\t\t<< std::endl;\n\tstd::istringstream is(datastring, std::ios_base::binary);\n\t// Create an action\n\tInventoryAction *a = InventoryAction::deSerialize(is);\n\tif (!a) {\n\t\tinfostream << \"TOSERVER_INVENTORY_ACTION: \"\n\t\t\t\t<< \"InventoryAction::deSerialize() returned NULL\"\n\t\t\t\t<< std::endl;\n\t\treturn;\n\t}\n\n\t// If something goes wrong, this player is to blame\n\tRollbackScopeActor rollback_scope(m_rollback,\n\t\t\tstd::string(\"player:\")+player->getName());\n\n\t/*\n\t\tNote: Always set inventory not sent, to repair cases\n\t\twhere the client made a bad prediction.\n\t*/\n\n\t/*\n\t\tHandle restrictions and special cases of the move action\n\t*/\n\tif (a->getType() == IAction::Move) {\n\t\tIMoveAction *ma = (IMoveAction*)a;\n\n\t\tma->from_inv.applyCurrentPlayer(player->getName());\n\t\tma->to_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ma->from_inv);\n\t\tif (ma->from_inv != ma->to_inv)\n\t\t\tm_inventory_mgr->setInventoryModified(ma->to_inv);\n\n\t\tbool from_inv_is_current_player = false;\n\t\tif (ma->from_inv.type == InventoryLocation::PLAYER) {\n\t\t\tif (ma->from_inv.name != player->getName())\n\t\t\t\treturn;\n\t\t\tfrom_inv_is_current_player = true;\n\t\t}\n\t\t\n\t\tbool to_inv_is_current_player = false;\n\t\tif (ma->to_inv.type == InventoryLocation::PLAYER) {\n\t\t\tif (ma->to_inv.name != player->getName())\n\t\t\t\treturn;\n\t\t\tto_inv_is_current_player = true;\n\t\t}\n\n\t\tInventoryLocation *remote = from_inv_is_current_player ?\n\t\t\t&ma->to_inv : &ma->from_inv;\n\n\t\t// Check for out-of-range interaction\n\t\tif (remote->type == InventoryLocation::NODEMETA) {\n\t\t\tv3f node_pos   = intToFloat(remote->p, BS);\n\t\t\tv3f player_pos = player->getPlayerSAO()->getEyePosition();\n\t\t\tf32 d = player_pos.getDistanceFrom(node_pos);\n\t\t\tif (!checkInteractDistance(player, d, \"inventory\"))\n\t\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items out of craftpreview\n\t\t*/\n\t\tif (ma->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because src is \" << ma->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items into craftresult and craftpreview\n\t\t*/\n\t\tif (ma->to_list == \"craftpreview\" || ma->to_list == \"craftresult\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because dst is \" << ma->to_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow moving items in elsewhere than player's inventory\n\t\t// if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\") &&\n\t\t\t\t(!from_inv_is_current_player ||\n\t\t\t\t!to_inv_is_current_player)) {\n\t\t\tinfostream << \"Cannot move outside of player's inventory: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the drop action\n\t*/\n\telse if (a->getType() == IAction::Drop) {\n\t\tIDropAction *da = (IDropAction*)a;\n\n\t\tda->from_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(da->from_inv);\n\n\t\t/*\n\t\t\tDisable dropping items out of craftpreview\n\t\t*/\n\t\tif (da->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because src is \" << da->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if dead\n\t\tif (playersao->isDead()) {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because player is dead.\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the craft action\n\t*/\n\telse if (a->getType() == IAction::Craft) {\n\t\tICraftAction *ca = (ICraftAction*)a;\n\n\t\tca->craft_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ca->craft_inv);\n\n\t\t//bool craft_inv_is_current_player =\n\t\t//\t(ca->craft_inv.type == InventoryLocation::PLAYER) &&\n\t\t//\t(ca->craft_inv.name == player->getName());\n\n\t\t// Disallow crafting if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tinfostream << \"Cannot craft: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Do the action\n\ta->apply(m_inventory_mgr.get(), playersao, this);\n\t// Eat the action\n\tdelete a;\n}",
        "description": "In versions of Minetest prior to 5.4.0, players have the capability to modify the inventory contents of other players, either by adding or removing items.",
        "commit": "output: \"A vulnerability that allows players to access the inventories of other players.\""
    }
]