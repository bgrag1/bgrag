[
    {
        "cwe": "CWE-385",
        "func_name": "openssl/ecdsa_sign_setup",
        "score": 0.7890111207962036,
        "func_before": "static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,\n\t\t\t\t\tBIGNUM **kinvp, BIGNUM **rp,\n\t\t\t\t\tconst unsigned char *dgst, int dlen)\n{\n\tBN_CTX   *ctx = NULL;\n\tBIGNUM\t *k = NULL, *r = NULL, *order = NULL, *X = NULL;\n\tEC_POINT *tmp_point=NULL;\n\tconst EC_GROUP *group;\n\tint \t ret = 0;\n\n\tif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\n\tif (ctx_in == NULL) \n\t{\n\t\tif ((ctx = BN_CTX_new()) == NULL)\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t\tctx = ctx_in;\n\n\tk     = BN_new();\t/* this value is later returned in *kinvp */\n\tr     = BN_new();\t/* this value is later returned in *rp    */\n\torder = BN_new();\n\tX     = BN_new();\n\tif (!k || !r || !order || !X)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t}\n\tif ((tmp_point = EC_POINT_new(group)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\tif (!EC_GROUP_get_order(group, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\n#ifdef OPENSSL_FIPS\n\tif (!fips_check_ec_prng(eckey))\n\t\tgoto err;\n#endif\n\t\n\tdo\n\t{\n\t\t/* get random k */\t\n\t\tdo\n#ifndef OPENSSL_NO_SHA512\n\t\t\tif (dgst != NULL)\n\t\t\t{\n\t\t\t\tif (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),\n\t\t\t\t\t\t\t   dgst, dlen, ctx))\n\t\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tif (!BN_rand_range(k, order))\n\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\twhile (BN_is_zero(k));\n\n\t\t/* We do not want timing information to leak the length of k,\n\t\t * so we compute G*k using an equivalent scalar of fixed\n\t\t * bit-length. */\n\n\t\tif (!BN_add(k, k, order)) goto err;\n\t\tif (BN_num_bits(k) <= BN_num_bits(order))\n\t\t\tif (!BN_add(k, k, order)) goto err;\n\n\t\t/* compute r the x-coordinate of generator * k */\n\t\tif (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t}\n\t\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#ifndef OPENSSL_NO_EC2M\n\t\telse /* NID_X9_62_characteristic_two_field */\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GF2m(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!BN_nnmod(r, X, order, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t}\n\t}\n\twhile (BN_is_zero(r));\n\n\t/* compute the inverse of k */\n\tif (!BN_mod_inverse(k, k, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\tgoto err;\t\n\t}\n\t/* clear old values if necessary */\n\tif (*rp != NULL)\n\t\tBN_clear_free(*rp);\n\tif (*kinvp != NULL) \n\t\tBN_clear_free(*kinvp);\n\t/* save the pre-computed values  */\n\t*rp    = r;\n\t*kinvp = k;\n\tret = 1;\nerr:\n\tif (!ret)\n\t{\n\t\tif (k != NULL) BN_clear_free(k);\n\t\tif (r != NULL) BN_clear_free(r);\n\t}\n\tif (ctx_in == NULL) \n\t\tBN_CTX_free(ctx);\n\tif (order != NULL)\n\t\tBN_free(order);\n\tif (tmp_point != NULL) \n\t\tEC_POINT_free(tmp_point);\n\tif (X)\n\t\tBN_clear_free(X);\n\treturn(ret);\n}",
        "func_after": "static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,\n\t\t\t\t\tBIGNUM **kinvp, BIGNUM **rp,\n\t\t\t\t\tconst unsigned char *dgst, int dlen)\n{\n\tBN_CTX   *ctx = NULL;\n\tBIGNUM\t *k = NULL, *r = NULL, *order = NULL, *X = NULL;\n\tEC_POINT *tmp_point=NULL;\n\tconst EC_GROUP *group;\n\tint \t ret = 0;\n\n\tif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\n\tif (ctx_in == NULL) \n\t{\n\t\tif ((ctx = BN_CTX_new()) == NULL)\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t\tctx = ctx_in;\n\n\tk     = BN_new();\t/* this value is later returned in *kinvp */\n\tr     = BN_new();\t/* this value is later returned in *rp    */\n\torder = BN_new();\n\tX     = BN_new();\n\tif (!k || !r || !order || !X)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t}\n\tif ((tmp_point = EC_POINT_new(group)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\tif (!EC_GROUP_get_order(group, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\n#ifdef OPENSSL_FIPS\n\tif (!fips_check_ec_prng(eckey))\n\t\tgoto err;\n#endif\n\t\n\tdo\n\t{\n\t\t/* get random k */\t\n\t\tdo\n#ifndef OPENSSL_NO_SHA512\n\t\t\tif (dgst != NULL)\n\t\t\t{\n\t\t\t\tif (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),\n\t\t\t\t\t\t\t   dgst, dlen, ctx))\n\t\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tif (!BN_rand_range(k, order))\n\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\twhile (BN_is_zero(k));\n\n\t\t/* We do not want timing information to leak the length of k,\n\t\t * so we compute G*k using an equivalent scalar of fixed\n\t\t * bit-length. */\n\n\t\tif (!BN_add(k, k, order)) goto err;\n\t\tif (BN_num_bits(k) <= BN_num_bits(order))\n\t\t\tif (!BN_add(k, k, order)) goto err;\n\n\t\t/* compute r the x-coordinate of generator * k */\n\t\tif (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t}\n\t\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#ifndef OPENSSL_NO_EC2M\n\t\telse /* NID_X9_62_characteristic_two_field */\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GF2m(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!BN_nnmod(r, X, order, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t}\n\t}\n\twhile (BN_is_zero(r));\n\n\t/* compute the inverse of k */\n\tif (EC_GROUP_get_mont_data(group) != NULL)\n\t\t{\n\t\t/* We want inverse in constant time, therefore we utilize the\n\t\t * fact order must be prime and use Fermats Little Theorem\n\t\t * instead. */\n\t\tif (!BN_set_word(X, 2) )\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (!BN_mod_sub(X, order, X, order, ctx))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tBN_set_flags(X, BN_FLG_CONSTTIME);\n\t\tif (!BN_mod_exp_mont_consttime(k, k, X, order, ctx, EC_GROUP_get_mont_data(group)))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tif (!BN_mod_inverse(k, k, order, ctx))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\t\n\t\t\t}\n\t\t}\n\n\t/* clear old values if necessary */\n\tif (*rp != NULL)\n\t\tBN_clear_free(*rp);\n\tif (*kinvp != NULL) \n\t\tBN_clear_free(*kinvp);\n\t/* save the pre-computed values  */\n\t*rp    = r;\n\t*kinvp = k;\n\tret = 1;\nerr:\n\tif (!ret)\n\t{\n\t\tif (k != NULL) BN_clear_free(k);\n\t\tif (r != NULL) BN_clear_free(r);\n\t}\n\tif (ctx_in == NULL) \n\t\tBN_CTX_free(ctx);\n\tif (order != NULL)\n\t\tBN_free(order);\n\tif (tmp_point != NULL) \n\t\tEC_POINT_free(tmp_point);\n\tif (X)\n\t\tBN_clear_free(X);\n\treturn(ret);\n}",
        "description": "A timing attack vulnerability was identified in OpenSSL versions prior to 1.0.1u, enabling a malicious user with local access to potentially recover ECDSA P-256 private keys through the exploitation of timing variations in cryptographic operations.",
        "commit": "The vulnerability knowledge has been abstracted and generalized as follows:\n\n\"The implementation of ECDSA includes an option to utilize BN_mod_exp_mont_consttime, a constant-time modular exponentiation function. This enhancement aims to improve the security of ECDSA operations.\""
    },
    {
        "cwe": "CWE-613",
        "func_name": "arangodb/RestAuthHandler::execute",
        "score": 0.7373711466789246,
        "func_before": "RestStatus RestAuthHandler__execute() {\n  auto const type = _request->requestType();\n  if (type != rest::RequestType::POST) {\n    generateError(rest::ResponseCode::METHOD_NOT_ALLOWED, TRI_ERROR_HTTP_METHOD_NOT_ALLOWED);\n    return RestStatus::DONE;\n  }\n\n  bool parseSuccess = false;\n  VPackSlice slice = this->parseVPackBody(parseSuccess);\n  if (!parseSuccess) { // error already set\n    return RestStatus::DONE;\n  }\n\n  if (!slice.isObject()) {\n    return badRequest();\n  }\n\n  VPackSlice usernameSlice = slice.get(\"username\");\n  VPackSlice passwordSlice = slice.get(\"password\");\n\n  if (!usernameSlice.isString() || !passwordSlice.isString()) {\n    return badRequest();\n  }\n\n  _username = usernameSlice.copyString();\n  std::string const password = passwordSlice.copyString();\n\n  auth::UserManager* um = AuthenticationFeature::instance()->userManager();\n  if (um == nullptr) {\n    std::string msg = \"This server does not support users\";\n    LOG_TOPIC(\"2e7d4\", ERR, Logger::AUTHENTICATION) << msg;\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED, msg);\n  } else if (um->checkPassword(_username, password)) {\n    VPackBuilder resultBuilder;\n    {\n      VPackObjectBuilder b(&resultBuilder);\n      std::string jwt = generateJwt(_username, password);\n      resultBuilder.add(\"jwt\", VPackValue(jwt));\n    }\n\n    _isValid = true;\n    generateDocument(resultBuilder.slice(), true, &VPackOptions::Defaults);\n  } else {\n    // mop: rfc 2616 10.4.2 (if credentials wrong 401)\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED,\n                  \"Wrong credentials\");\n  }\n  return RestStatus::DONE;\n}",
        "func_after": "RestStatus RestAuthHandler__execute() {\n  auto const type = _request->requestType();\n  if (type != rest::RequestType::POST) {\n    generateError(rest::ResponseCode::METHOD_NOT_ALLOWED, TRI_ERROR_HTTP_METHOD_NOT_ALLOWED);\n    return RestStatus::DONE;\n  }\n\n  bool parseSuccess = false;\n  VPackSlice slice = this->parseVPackBody(parseSuccess);\n  if (!parseSuccess) { // error already set\n    return RestStatus::DONE;\n  }\n\n  if (!slice.isObject()) {\n    return badRequest();\n  }\n\n  VPackSlice usernameSlice = slice.get(\"username\");\n  VPackSlice passwordSlice = slice.get(\"password\");\n\n  if (!usernameSlice.isString() || !passwordSlice.isString()) {\n    return badRequest();\n  }\n\n  std::string const username = usernameSlice.copyString();\n  std::string const password = passwordSlice.copyString();\n\n  bool isValid = false;\n\n  auto guard = scopeGuard([&]() {\n    try {\n      if (isValid) {\n        events::LoggedIn(*_request, username);\n      } else {\n        events::CredentialsBad(*_request, username);\n      }\n    } catch (...) {\n      // nothing we can do\n    }\n  });\n  \n  auth::UserManager* um = AuthenticationFeature::instance()->userManager();\n  if (um == nullptr) {\n    std::string msg = \"This server does not support users\";\n    LOG_TOPIC(\"2e7d4\", ERR, Logger::AUTHENTICATION) << msg;\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED, msg);\n  } else if (um->checkPassword(username, password)) {\n    VPackBuilder resultBuilder;\n    {\n      VPackObjectBuilder b(&resultBuilder);\n      resultBuilder.add(\"jwt\", VPackValue(generateJwt(username)));\n    }\n\n    isValid = true;\n    generateDocument(resultBuilder.slice(), true, &VPackOptions::Defaults);\n  } else {\n    // mop: rfc 2616 10.4.2 (if credentials wrong 401)\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED,\n                  \"Wrong credentials\");\n  }\n  return RestStatus::DONE;\n}",
        "description": "ArangoDB versions v3.7.6 through v3.8.3 are susceptible to an Insufficient Session Expiration issue. Specifically, when an administrator changes a user's password, the associated session is not invalidated. This failure allows a malicious user who is still logged in to continue performing arbitrary actions within the system.",
        "commit": "The startup parameter `--server.session-timeout` has been revived."
    },
    {
        "cwe": "CWE-362",
        "func_name": "torvalds/fib6_add_rt2node",
        "score": 0.8002826571464539,
        "func_before": "static int fib6_add_rt2node(struct fib6_node *fn, struct fib6_info *rt,\n\t\t\t    struct nl_info *info,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct fib6_info *leaf = rcu_dereference_protected(fn->leaf,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\tstruct fib6_info *iter = NULL;\n\tstruct fib6_info __rcu **ins;\n\tstruct fib6_info __rcu **fallback_ins = NULL;\n\tint replace = (info->nlh &&\n\t\t       (info->nlh->nlmsg_flags & NLM_F_REPLACE));\n\tint add = (!info->nlh ||\n\t\t   (info->nlh->nlmsg_flags & NLM_F_CREATE));\n\tint found = 0;\n\tbool rt_can_ecmp = rt6_qualify_for_ecmp(rt);\n\tbool notify_sibling_rt = false;\n\tu16 nlflags = NLM_F_EXCL;\n\tint err;\n\n\tif (info->nlh && (info->nlh->nlmsg_flags & NLM_F_APPEND))\n\t\tnlflags |= NLM_F_APPEND;\n\n\tins = &fn->leaf;\n\n\tfor (iter = leaf; iter;\n\t     iter = rcu_dereference_protected(iter->fib6_next,\n\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock))) {\n\t\t/*\n\t\t *\tSearch for duplicates\n\t\t */\n\n\t\tif (iter->fib6_metric == rt->fib6_metric) {\n\t\t\t/*\n\t\t\t *\tSame priority level\n\t\t\t */\n\t\t\tif (info->nlh &&\n\t\t\t    (info->nlh->nlmsg_flags & NLM_F_EXCL))\n\t\t\t\treturn -EEXIST;\n\n\t\t\tnlflags &= ~NLM_F_EXCL;\n\t\t\tif (replace) {\n\t\t\t\tif (rt_can_ecmp == rt6_qualify_for_ecmp(iter)) {\n\t\t\t\t\tfound++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallback_ins = fallback_ins ?: ins;\n\t\t\t\tgoto next_iter;\n\t\t\t}\n\n\t\t\tif (rt6_duplicate_nexthop(iter, rt)) {\n\t\t\t\tif (rt->fib6_nsiblings)\n\t\t\t\t\trt->fib6_nsiblings = 0;\n\t\t\t\tif (!(iter->fib6_flags & RTF_EXPIRES))\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\tif (!(rt->fib6_flags & RTF_EXPIRES))\n\t\t\t\t\tfib6_clean_expires_locked(iter);\n\t\t\t\telse\n\t\t\t\t\tfib6_set_expires_locked(iter,\n\t\t\t\t\t\t\t\trt->expires);\n\n\t\t\t\tif (rt->fib6_pmtu)\n\t\t\t\t\tfib6_metric_set(iter, RTAX_MTU,\n\t\t\t\t\t\t\trt->fib6_pmtu);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\t/* If we have the same destination and the same metric,\n\t\t\t * but not the same gateway, then the route we try to\n\t\t\t * add is sibling to this route, increment our counter\n\t\t\t * of siblings, and later we will add our route to the\n\t\t\t * list.\n\t\t\t * Only static routes (which don't have flag\n\t\t\t * RTF_EXPIRES) are used for ECMPv6.\n\t\t\t *\n\t\t\t * To avoid long list, we only had siblings if the\n\t\t\t * route have a gateway.\n\t\t\t */\n\t\t\tif (rt_can_ecmp &&\n\t\t\t    rt6_qualify_for_ecmp(iter))\n\t\t\t\trt->fib6_nsiblings++;\n\t\t}\n\n\t\tif (iter->fib6_metric > rt->fib6_metric)\n\t\t\tbreak;\n\nnext_iter:\n\t\tins = &iter->fib6_next;\n\t}\n\n\tif (fallback_ins && !found) {\n\t\t/* No matching route with same ecmp-able-ness found, replace\n\t\t * first matching route\n\t\t */\n\t\tins = fallback_ins;\n\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\tfound++;\n\t}\n\n\t/* Reset round-robin state, if necessary */\n\tif (ins == &fn->leaf)\n\t\tfn->rr_ptr = NULL;\n\n\t/* Link this route to others same route. */\n\tif (rt->fib6_nsiblings) {\n\t\tunsigned int fib6_nsiblings;\n\t\tstruct fib6_info *sibling, *temp_sibling;\n\n\t\t/* Find the first route that have the same metric */\n\t\tsibling = leaf;\n\t\tnotify_sibling_rt = true;\n\t\twhile (sibling) {\n\t\t\tif (sibling->fib6_metric == rt->fib6_metric &&\n\t\t\t    rt6_qualify_for_ecmp(sibling)) {\n\t\t\t\tlist_add_tail(&rt->fib6_siblings,\n\t\t\t\t\t      &sibling->fib6_siblings);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsibling = rcu_dereference_protected(sibling->fib6_next,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\tnotify_sibling_rt = false;\n\t\t}\n\t\t/* For each sibling in the list, increment the counter of\n\t\t * siblings. BUG() if counters does not match, list of siblings\n\t\t * is broken!\n\t\t */\n\t\tfib6_nsiblings = 0;\n\t\tlist_for_each_entry_safe(sibling, temp_sibling,\n\t\t\t\t\t &rt->fib6_siblings, fib6_siblings) {\n\t\t\tsibling->fib6_nsiblings++;\n\t\t\tBUG_ON(sibling->fib6_nsiblings != rt->fib6_nsiblings);\n\t\t\tfib6_nsiblings++;\n\t\t}\n\t\tBUG_ON(fib6_nsiblings != rt->fib6_nsiblings);\n\t\trt6_multipath_rebalance(temp_sibling);\n\t}\n\n\t/*\n\t *\tinsert node\n\t */\n\tif (!replace) {\n\t\tif (!add)\n\t\t\tpr_warn(\"NLM_F_CREATE should be set when creating new route\\n\");\n\nadd:\n\t\tnlflags |= NLM_F_CREATE;\n\n\t\t/* The route should only be notified if it is the first\n\t\t * route in the node or if it is added as a sibling\n\t\t * route to the first route in the node.\n\t\t */\n\t\tif (!info->skip_notify_kernel &&\n\t\t    (notify_sibling_rt || ins == &fn->leaf)) {\n\t\t\tenum fib_event_type fib_event;\n\n\t\t\tif (notify_sibling_rt)\n\t\t\t\tfib_event = FIB_EVENT_ENTRY_APPEND;\n\t\t\telse\n\t\t\t\tfib_event = FIB_EVENT_ENTRY_REPLACE;\n\t\t\terr = call_fib6_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\tfib_event, rt,\n\t\t\t\t\t\t\textack);\n\t\t\tif (err) {\n\t\t\t\tstruct fib6_info *sibling, *next_sibling;\n\n\t\t\t\t/* If the route has siblings, then it first\n\t\t\t\t * needs to be unlinked from them.\n\t\t\t\t */\n\t\t\t\tif (!rt->fib6_nsiblings)\n\t\t\t\t\treturn err;\n\n\t\t\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t\t\t\t &rt->fib6_siblings,\n\t\t\t\t\t\t\t fib6_siblings)\n\t\t\t\t\tsibling->fib6_nsiblings--;\n\t\t\t\trt->fib6_nsiblings = 0;\n\t\t\t\tlist_del_init(&rt->fib6_siblings);\n\t\t\t\trt6_multipath_rebalance(next_sibling);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\trcu_assign_pointer(rt->fib6_next, iter);\n\t\tfib6_info_hold(rt);\n\t\trcu_assign_pointer(rt->fib6_node, fn);\n\t\trcu_assign_pointer(*ins, rt);\n\t\tif (!info->skip_notify)\n\t\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, nlflags);\n\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries++;\n\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\n\t} else {\n\t\tint nsiblings;\n\n\t\tif (!found) {\n\t\t\tif (add)\n\t\t\t\tgoto add;\n\t\t\tpr_warn(\"NLM_F_REPLACE set, but no existing node found!\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (!info->skip_notify_kernel && ins == &fn->leaf) {\n\t\t\terr = call_fib6_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\tFIB_EVENT_ENTRY_REPLACE,\n\t\t\t\t\t\t\trt, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tfib6_info_hold(rt);\n\t\trcu_assign_pointer(rt->fib6_node, fn);\n\t\trt->fib6_next = iter->fib6_next;\n\t\trcu_assign_pointer(*ins, rt);\n\t\tif (!info->skip_notify)\n\t\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, NLM_F_REPLACE);\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\t\tnsiblings = iter->fib6_nsiblings;\n\t\titer->fib6_node = NULL;\n\t\tfib6_purge_rt(iter, fn, info->nl_net);\n\t\tif (rcu_access_pointer(fn->rr_ptr) == iter)\n\t\t\tfn->rr_ptr = NULL;\n\t\tfib6_info_release(iter);\n\n\t\tif (nsiblings) {\n\t\t\t/* Replacing an ECMP route, remove all siblings */\n\t\t\tins = &rt->fib6_next;\n\t\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\twhile (iter) {\n\t\t\t\tif (iter->fib6_metric > rt->fib6_metric)\n\t\t\t\t\tbreak;\n\t\t\t\tif (rt6_qualify_for_ecmp(iter)) {\n\t\t\t\t\t*ins = iter->fib6_next;\n\t\t\t\t\titer->fib6_node = NULL;\n\t\t\t\t\tfib6_purge_rt(iter, fn, info->nl_net);\n\t\t\t\t\tif (rcu_access_pointer(fn->rr_ptr) == iter)\n\t\t\t\t\t\tfn->rr_ptr = NULL;\n\t\t\t\t\tfib6_info_release(iter);\n\t\t\t\t\tnsiblings--;\n\t\t\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries--;\n\t\t\t\t} else {\n\t\t\t\t\tins = &iter->fib6_next;\n\t\t\t\t}\n\t\t\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\t}\n\t\t\tWARN_ON(nsiblings != 0);\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "func_after": "static int fib6_add_rt2node(struct fib6_node *fn, struct fib6_info *rt,\n\t\t\t    struct nl_info *info,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct fib6_info *leaf = rcu_dereference_protected(fn->leaf,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\tstruct fib6_info *iter = NULL;\n\tstruct fib6_info __rcu **ins;\n\tstruct fib6_info __rcu **fallback_ins = NULL;\n\tint replace = (info->nlh &&\n\t\t       (info->nlh->nlmsg_flags & NLM_F_REPLACE));\n\tint add = (!info->nlh ||\n\t\t   (info->nlh->nlmsg_flags & NLM_F_CREATE));\n\tint found = 0;\n\tbool rt_can_ecmp = rt6_qualify_for_ecmp(rt);\n\tbool notify_sibling_rt = false;\n\tu16 nlflags = NLM_F_EXCL;\n\tint err;\n\n\tif (info->nlh && (info->nlh->nlmsg_flags & NLM_F_APPEND))\n\t\tnlflags |= NLM_F_APPEND;\n\n\tins = &fn->leaf;\n\n\tfor (iter = leaf; iter;\n\t     iter = rcu_dereference_protected(iter->fib6_next,\n\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock))) {\n\t\t/*\n\t\t *\tSearch for duplicates\n\t\t */\n\n\t\tif (iter->fib6_metric == rt->fib6_metric) {\n\t\t\t/*\n\t\t\t *\tSame priority level\n\t\t\t */\n\t\t\tif (info->nlh &&\n\t\t\t    (info->nlh->nlmsg_flags & NLM_F_EXCL))\n\t\t\t\treturn -EEXIST;\n\n\t\t\tnlflags &= ~NLM_F_EXCL;\n\t\t\tif (replace) {\n\t\t\t\tif (rt_can_ecmp == rt6_qualify_for_ecmp(iter)) {\n\t\t\t\t\tfound++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallback_ins = fallback_ins ?: ins;\n\t\t\t\tgoto next_iter;\n\t\t\t}\n\n\t\t\tif (rt6_duplicate_nexthop(iter, rt)) {\n\t\t\t\tif (rt->fib6_nsiblings)\n\t\t\t\t\trt->fib6_nsiblings = 0;\n\t\t\t\tif (!(iter->fib6_flags & RTF_EXPIRES))\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\tif (!(rt->fib6_flags & RTF_EXPIRES))\n\t\t\t\t\tfib6_clean_expires(iter);\n\t\t\t\telse\n\t\t\t\t\tfib6_set_expires(iter, rt->expires);\n\n\t\t\t\tif (rt->fib6_pmtu)\n\t\t\t\t\tfib6_metric_set(iter, RTAX_MTU,\n\t\t\t\t\t\t\trt->fib6_pmtu);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\t/* If we have the same destination and the same metric,\n\t\t\t * but not the same gateway, then the route we try to\n\t\t\t * add is sibling to this route, increment our counter\n\t\t\t * of siblings, and later we will add our route to the\n\t\t\t * list.\n\t\t\t * Only static routes (which don't have flag\n\t\t\t * RTF_EXPIRES) are used for ECMPv6.\n\t\t\t *\n\t\t\t * To avoid long list, we only had siblings if the\n\t\t\t * route have a gateway.\n\t\t\t */\n\t\t\tif (rt_can_ecmp &&\n\t\t\t    rt6_qualify_for_ecmp(iter))\n\t\t\t\trt->fib6_nsiblings++;\n\t\t}\n\n\t\tif (iter->fib6_metric > rt->fib6_metric)\n\t\t\tbreak;\n\nnext_iter:\n\t\tins = &iter->fib6_next;\n\t}\n\n\tif (fallback_ins && !found) {\n\t\t/* No matching route with same ecmp-able-ness found, replace\n\t\t * first matching route\n\t\t */\n\t\tins = fallback_ins;\n\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\tfound++;\n\t}\n\n\t/* Reset round-robin state, if necessary */\n\tif (ins == &fn->leaf)\n\t\tfn->rr_ptr = NULL;\n\n\t/* Link this route to others same route. */\n\tif (rt->fib6_nsiblings) {\n\t\tunsigned int fib6_nsiblings;\n\t\tstruct fib6_info *sibling, *temp_sibling;\n\n\t\t/* Find the first route that have the same metric */\n\t\tsibling = leaf;\n\t\tnotify_sibling_rt = true;\n\t\twhile (sibling) {\n\t\t\tif (sibling->fib6_metric == rt->fib6_metric &&\n\t\t\t    rt6_qualify_for_ecmp(sibling)) {\n\t\t\t\tlist_add_tail(&rt->fib6_siblings,\n\t\t\t\t\t      &sibling->fib6_siblings);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsibling = rcu_dereference_protected(sibling->fib6_next,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\tnotify_sibling_rt = false;\n\t\t}\n\t\t/* For each sibling in the list, increment the counter of\n\t\t * siblings. BUG() if counters does not match, list of siblings\n\t\t * is broken!\n\t\t */\n\t\tfib6_nsiblings = 0;\n\t\tlist_for_each_entry_safe(sibling, temp_sibling,\n\t\t\t\t\t &rt->fib6_siblings, fib6_siblings) {\n\t\t\tsibling->fib6_nsiblings++;\n\t\t\tBUG_ON(sibling->fib6_nsiblings != rt->fib6_nsiblings);\n\t\t\tfib6_nsiblings++;\n\t\t}\n\t\tBUG_ON(fib6_nsiblings != rt->fib6_nsiblings);\n\t\trt6_multipath_rebalance(temp_sibling);\n\t}\n\n\t/*\n\t *\tinsert node\n\t */\n\tif (!replace) {\n\t\tif (!add)\n\t\t\tpr_warn(\"NLM_F_CREATE should be set when creating new route\\n\");\n\nadd:\n\t\tnlflags |= NLM_F_CREATE;\n\n\t\t/* The route should only be notified if it is the first\n\t\t * route in the node or if it is added as a sibling\n\t\t * route to the first route in the node.\n\t\t */\n\t\tif (!info->skip_notify_kernel &&\n\t\t    (notify_sibling_rt || ins == &fn->leaf)) {\n\t\t\tenum fib_event_type fib_event;\n\n\t\t\tif (notify_sibling_rt)\n\t\t\t\tfib_event = FIB_EVENT_ENTRY_APPEND;\n\t\t\telse\n\t\t\t\tfib_event = FIB_EVENT_ENTRY_REPLACE;\n\t\t\terr = call_fib6_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\tfib_event, rt,\n\t\t\t\t\t\t\textack);\n\t\t\tif (err) {\n\t\t\t\tstruct fib6_info *sibling, *next_sibling;\n\n\t\t\t\t/* If the route has siblings, then it first\n\t\t\t\t * needs to be unlinked from them.\n\t\t\t\t */\n\t\t\t\tif (!rt->fib6_nsiblings)\n\t\t\t\t\treturn err;\n\n\t\t\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t\t\t\t &rt->fib6_siblings,\n\t\t\t\t\t\t\t fib6_siblings)\n\t\t\t\t\tsibling->fib6_nsiblings--;\n\t\t\t\trt->fib6_nsiblings = 0;\n\t\t\t\tlist_del_init(&rt->fib6_siblings);\n\t\t\t\trt6_multipath_rebalance(next_sibling);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\trcu_assign_pointer(rt->fib6_next, iter);\n\t\tfib6_info_hold(rt);\n\t\trcu_assign_pointer(rt->fib6_node, fn);\n\t\trcu_assign_pointer(*ins, rt);\n\t\tif (!info->skip_notify)\n\t\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, nlflags);\n\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries++;\n\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\n\t} else {\n\t\tint nsiblings;\n\n\t\tif (!found) {\n\t\t\tif (add)\n\t\t\t\tgoto add;\n\t\t\tpr_warn(\"NLM_F_REPLACE set, but no existing node found!\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (!info->skip_notify_kernel && ins == &fn->leaf) {\n\t\t\terr = call_fib6_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\tFIB_EVENT_ENTRY_REPLACE,\n\t\t\t\t\t\t\trt, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tfib6_info_hold(rt);\n\t\trcu_assign_pointer(rt->fib6_node, fn);\n\t\trt->fib6_next = iter->fib6_next;\n\t\trcu_assign_pointer(*ins, rt);\n\t\tif (!info->skip_notify)\n\t\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, NLM_F_REPLACE);\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\t\tnsiblings = iter->fib6_nsiblings;\n\t\titer->fib6_node = NULL;\n\t\tfib6_purge_rt(iter, fn, info->nl_net);\n\t\tif (rcu_access_pointer(fn->rr_ptr) == iter)\n\t\t\tfn->rr_ptr = NULL;\n\t\tfib6_info_release(iter);\n\n\t\tif (nsiblings) {\n\t\t\t/* Replacing an ECMP route, remove all siblings */\n\t\t\tins = &rt->fib6_next;\n\t\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\twhile (iter) {\n\t\t\t\tif (iter->fib6_metric > rt->fib6_metric)\n\t\t\t\t\tbreak;\n\t\t\t\tif (rt6_qualify_for_ecmp(iter)) {\n\t\t\t\t\t*ins = iter->fib6_next;\n\t\t\t\t\titer->fib6_node = NULL;\n\t\t\t\t\tfib6_purge_rt(iter, fn, info->nl_net);\n\t\t\t\t\tif (rcu_access_pointer(fn->rr_ptr) == iter)\n\t\t\t\t\t\tfn->rr_ptr = NULL;\n\t\t\t\t\tfib6_info_release(iter);\n\t\t\t\t\tnsiblings--;\n\t\t\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries--;\n\t\t\t\t} else {\n\t\t\t\t\tins = &iter->fib6_next;\n\t\t\t\t}\n\t\t\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\t}\n\t\t\tWARN_ON(nsiblings != 0);\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "description": "A race condition exists in the Linux Kernel where an unauthenticated attacker from an adjacent network could exploit it by sending an ICMPv6 router advertisement packet, potentially leading to arbitrary code execution.",
        "commit": "This vulnerability involves a revert of a specific commit due to race conditions related to the management of the `expires` field in a `fib6_info` structure. The original commit introduced issues where the garbage collection (gc) process could start before the entry was added to the gc list and the timer value was set, potentially leading to a use-after-free (UAF) condition. The recommended approach is to revert the commit and address the problem in a future release."
    },
    {
        "cwe": "CWE-662",
        "func_name": "torvalds/do_fontx_ioctl",
        "score": 0.7578685283660889,
        "func_before": "static inline int do_fontx_ioctl(int cmd,\n\t\tstruct consolefontdesc __user *user_cfd,\n\t\tstruct console_font_op *op)\n{\n\tstruct consolefontdesc cfdarg;\n\tint i;\n\n\tif (copy_from_user(&cfdarg, user_cfd, sizeof(struct consolefontdesc)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase PIO_FONTX:\n\t\top->op = KD_FONT_OP_SET;\n\t\top->flags = KD_FONT_FLAG_OLD;\n\t\top->width = 8;\n\t\top->height = cfdarg.charheight;\n\t\top->charcount = cfdarg.charcount;\n\t\top->data = cfdarg.chardata;\n\t\treturn con_font_op(vc_cons[fg_console].d, op);\n\tcase GIO_FONTX: {\n\t\top->op = KD_FONT_OP_GET;\n\t\top->flags = KD_FONT_FLAG_OLD;\n\t\top->width = 8;\n\t\top->height = cfdarg.charheight;\n\t\top->charcount = cfdarg.charcount;\n\t\top->data = cfdarg.chardata;\n\t\ti = con_font_op(vc_cons[fg_console].d, op);\n\t\tif (i)\n\t\t\treturn i;\n\t\tcfdarg.charheight = op->height;\n\t\tcfdarg.charcount = op->charcount;\n\t\tif (copy_to_user(user_cfd, &cfdarg, sizeof(struct consolefontdesc)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}",
        "func_after": "static inline int do_fontx_ioctl(struct vc_data *vc, int cmd,\n\t\tstruct consolefontdesc __user *user_cfd,\n\t\tstruct console_font_op *op)\n{\n\tstruct consolefontdesc cfdarg;\n\tint i;\n\n\tif (copy_from_user(&cfdarg, user_cfd, sizeof(struct consolefontdesc)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase PIO_FONTX:\n\t\top->op = KD_FONT_OP_SET;\n\t\top->flags = KD_FONT_FLAG_OLD;\n\t\top->width = 8;\n\t\top->height = cfdarg.charheight;\n\t\top->charcount = cfdarg.charcount;\n\t\top->data = cfdarg.chardata;\n\t\treturn con_font_op(vc, op);\n\n\tcase GIO_FONTX:\n\t\top->op = KD_FONT_OP_GET;\n\t\top->flags = KD_FONT_FLAG_OLD;\n\t\top->width = 8;\n\t\top->height = cfdarg.charheight;\n\t\top->charcount = cfdarg.charcount;\n\t\top->data = cfdarg.chardata;\n\t\ti = con_font_op(vc, op);\n\t\tif (i)\n\t\t\treturn i;\n\t\tcfdarg.charheight = op->height;\n\t\tcfdarg.charcount = op->charcount;\n\t\tif (copy_to_user(user_cfd, &cfdarg, sizeof(struct consolefontdesc)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}",
        "description": "A flaw was identified in the Linux Kernel where access to a global variable used for managing the foreground console is not adequately synchronized, resulting in a use-after-free error within the function responsible for font operations.",
        "commit": "Some font-related terminal I/O control operations previously utilized the current foreground virtual console (VC) for their execution. This practice has been discontinued to address a data race condition involving the `fg_console` variable. Notably, both Michael Ellerman and Jiri Slaby have observed that these I/O control operations are deprecated and should have been removed earlier. They suggest that most systems now use the `KDFONTOP` ioctl instead. Additionally, Michael notes that BusyBox's `loadfont` program transitioned to using `KDFONTOP` precisely due to this bug, which was identified approximately 12 years ago."
    },
    {
        "cwe": "CWE-78",
        "func_name": "emacs/main",
        "score": 0.7805482149124146,
        "func_before": "int\nmain (int argc, char **argv)\n{\n  int i;\n  int nincluded_files;\n  char **included_files;\n  argument *argbuffer;\n  int current_arg, file_count;\n  linebuffer filename_lb;\n  bool help_asked = false;\n  ptrdiff_t len;\n  char *optstring;\n  int opt;\n\n  progname = argv[0];\n  nincluded_files = 0;\n  included_files = xnew (argc, char *);\n  current_arg = 0;\n  file_count = 0;\n\n  /* Allocate enough no matter what happens.  Overkill, but each one\n     is small. */\n  argbuffer = xnew (argc, argument);\n\n  /*\n   * Always find typedefs and structure tags.\n   * Also default to find macro constants, enum constants, struct\n   * members and global variables.  Do it for both etags and ctags.\n   */\n  typedefs = typedefs_or_cplusplus = constantypedefs = true;\n  globals = members = true;\n\n  /* When the optstring begins with a '-' getopt_long does not rearrange the\n     non-options arguments to be at the end, but leaves them alone. */\n  optstring = concat (\"-ac:Cf:Il:o:Qr:RSVhH\",\n\t\t      (CTAGS) ? \"BxdtTuvw\" : \"Di:\",\n\t\t      \"\");\n\n  while ((opt = getopt_long (argc, argv, optstring, longopts, NULL)) != EOF)\n    switch (opt)\n      {\n      case 0:\n\t/* If getopt returns 0, then it has already processed a\n\t   long-named option.  We should do nothing.  */\n\tbreak;\n\n      case 1:\n\t/* This means that a file name has been seen.  Record it. */\n\targbuffer[current_arg].arg_type = at_filename;\n\targbuffer[current_arg].what     = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\t++file_count;\n\tbreak;\n\n      case STDIN:\n\t/* Parse standard input.  Idea by Vivek <vivek@etla.org>. */\n\targbuffer[current_arg].arg_type = at_stdin;\n\targbuffer[current_arg].what     = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\t++file_count;\n\tif (parsing_stdin)\n\t  fatal (\"cannot parse standard input more than once\");\n\tparsing_stdin = true;\n\tbreak;\n\n\t/* Common options. */\n      case 'a': append_to_tagfile = true;\tbreak;\n      case 'C': cplusplus = true;\t\tbreak;\n      case 'f':\t\t/* for compatibility with old makefiles */\n      case 'o':\n\tif (tagfile)\n\t  {\n\t    error (\"-o option may only be given once.\");\n\t    suggest_asking_for_help ();\n\t  }\n\ttagfile = optarg;\n\tbreak;\n      case 'I':\n      case 'S':\t\t/* for backward compatibility */\n\tignoreindent = true;\n\tbreak;\n      case 'l':\n\t{\n\t  language *lang = get_language_from_langname (optarg);\n\t  if (lang != NULL)\n\t    {\n\t      argbuffer[current_arg].lang = lang;\n\t      argbuffer[current_arg].arg_type = at_language;\n\t      ++current_arg;\n\t    }\n\t}\n\tbreak;\n      case 'c':\n\t/* Backward compatibility: support obsolete --ignore-case-regexp. */\n\toptarg = concat (optarg, \"i\", \"\"); /* memory leak here */\n\tFALLTHROUGH;\n      case 'r':\n\targbuffer[current_arg].arg_type = at_regexp;\n\targbuffer[current_arg].what = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\tbreak;\n      case 'R':\n\targbuffer[current_arg].arg_type = at_regexp;\n\targbuffer[current_arg].what = NULL;\n\t++current_arg;\n\tbreak;\n      case 'V':\n\tprint_version ();\n\tbreak;\n      case 'h':\n      case 'H':\n\thelp_asked = true;\n\tbreak;\n      case 'Q':\n\tclass_qualify = 1;\n\tbreak;\n\n\t/* Etags options */\n      case 'D': constantypedefs = false;\t\t\tbreak;\n      case 'i': included_files[nincluded_files++] = optarg;\tbreak;\n\n\t/* Ctags options. */\n      case 'B': searchar = '?';\t\t\t\t\tbreak;\n      case 'd': constantypedefs = true;\t\t\t\tbreak;\n      case 't': typedefs = true;\t\t\t\tbreak;\n      case 'T': typedefs = typedefs_or_cplusplus = true;\tbreak;\n      case 'u': update = true;\t\t\t\t\tbreak;\n      case 'v': vgrind_style = true;\t\t\t\tFALLTHROUGH;\n      case 'x': cxref_style = true;\t\t\t\tbreak;\n      case 'w': no_warnings = true;\t\t\t\tbreak;\n      default:\n\tsuggest_asking_for_help ();\n      }\n\n  /* No more options.  Store the rest of arguments. */\n  for (; optind < argc; optind++)\n    {\n      argbuffer[current_arg].arg_type = at_filename;\n      argbuffer[current_arg].what = argv[optind];\n      len = strlen (argv[optind]);\n      if (whatlen_max < len)\n\twhatlen_max = len;\n      ++current_arg;\n      ++file_count;\n    }\n\n  argbuffer[current_arg].arg_type = at_end;\n\n  if (help_asked)\n    print_help (argbuffer);\n\n  if (nincluded_files == 0 && file_count == 0)\n    {\n      error (\"no input files specified.\");\n      suggest_asking_for_help ();\n    }\n\n  if (tagfile == NULL)\n    tagfile = savestr (CTAGS ? \"tags\" : \"TAGS\");\n  cwd = etags_getcwd ();\t/* the current working directory */\n  if (cwd[strlen (cwd) - 1] != '/')\n    {\n      char *oldcwd = cwd;\n      cwd = concat (oldcwd, \"/\", \"\");\n      free (oldcwd);\n    }\n\n  /* Compute base directory for relative file names. */\n  if (streq (tagfile, \"-\")\n      || strneq (tagfile, \"/dev/\", 5))\n    tagfiledir = cwd;\t\t /* relative file names are relative to cwd */\n  else\n    {\n      canonicalize_filename (tagfile);\n      tagfiledir = absolute_dirname (tagfile, cwd);\n    }\n\n  linebuffer_init (&lb);\n  linebuffer_init (&filename_lb);\n  linebuffer_init (&filebuf);\n  linebuffer_init (&token_name);\n\n  if (!CTAGS)\n    {\n      if (streq (tagfile, \"-\"))\n\t{\n\t  tagf = stdout;\n\t  set_binary_mode (STDOUT_FILENO, O_BINARY);\n\t}\n      else\n\ttagf = fopen (tagfile, append_to_tagfile ? \"ab\" : \"wb\");\n      if (tagf == NULL)\n\tpfatal (tagfile);\n    }\n\n  /*\n   * Loop through files finding functions.\n   */\n  for (i = 0; i < current_arg; i++)\n    {\n      static language *lang;\t/* non-NULL if language is forced */\n      char *this_file;\n\n      switch (argbuffer[i].arg_type)\n\t{\n\tcase at_language:\n\t  lang = argbuffer[i].lang;\n\t  break;\n\tcase at_regexp:\n\t  analyze_regex (argbuffer[i].what);\n\t  break;\n\tcase at_filename:\n\t      this_file = argbuffer[i].what;\n\t      /* Input file named \"-\" means read file names from stdin\n\t\t (one per line) and use them. */\n\t      if (streq (this_file, \"-\"))\n\t\t{\n\t\t  if (parsing_stdin)\n\t\t    fatal (\"cannot parse standard input \"\n\t\t\t   \"AND read file names from it\");\n\t\t  while (readline_internal (&filename_lb, stdin, \"-\") > 0)\n\t\t    process_file_name (filename_lb.buffer, lang);\n\t\t}\n\t      else\n\t\tprocess_file_name (this_file, lang);\n\t  break;\n        case at_stdin:\n          this_file = argbuffer[i].what;\n          process_file (stdin, this_file, lang);\n          break;\n\tdefault:\n\t  error (\"internal error: arg_type\");\n\t}\n    }\n\n  free_regexps ();\n  free (lb.buffer);\n  free (filebuf.buffer);\n  free (token_name.buffer);\n\n  if (!CTAGS || cxref_style)\n    {\n      /* Write the remaining tags to tagf (ETAGS) or stdout (CXREF). */\n      put_entries (nodehead);\n      free_tree (nodehead);\n      nodehead = NULL;\n      if (!CTAGS)\n\t{\n\t  fdesc *fdp;\n\n\t  /* Output file entries that have no tags. */\n\t  for (fdp = fdhead; fdp != NULL; fdp = fdp->next)\n\t    if (!fdp->written)\n\t      fprintf (tagf, \"\\f\\n%s,0\\n\", fdp->taggedfname);\n\n\t  while (nincluded_files-- > 0)\n\t    fprintf (tagf, \"\\f\\n%s,include\\n\", *included_files++);\n\n\t  if (fclose (tagf) == EOF)\n\t    pfatal (tagfile);\n\t}\n\n      return EXIT_SUCCESS;\n    }\n\n  /* From here on, we are in (CTAGS && !cxref_style) */\n  if (update)\n    {\n      char *cmd =\n\txmalloc (strlen (tagfile) + whatlen_max +\n\t\t sizeof \"mv..OTAGS;grep -Fv '\\t\\t' OTAGS >;rm OTAGS\");\n      for (i = 0; i < current_arg; ++i)\n\t{\n\t  switch (argbuffer[i].arg_type)\n\t    {\n\t    case at_filename:\n\t    case at_stdin:\n\t      break;\n\t    default:\n\t      continue;\t\t/* the for loop */\n\t    }\n\t  char *z = stpcpy (cmd, \"mv \");\n\t  z = stpcpy (z, tagfile);\n\t  z = stpcpy (z, \" OTAGS;grep -Fv '\\t\");\n\t  z = stpcpy (z, argbuffer[i].what);\n\t  z = stpcpy (z, \"\\t' OTAGS >\");\n\t  z = stpcpy (z, tagfile);\n\t  strcpy (z, \";rm OTAGS\");\n\t  if (system (cmd) != EXIT_SUCCESS)\n\t    fatal (\"failed to execute shell command\");\n\t}\n      free (cmd);\n      append_to_tagfile = true;\n    }\n\n  tagf = fopen (tagfile, append_to_tagfile ? \"ab\" : \"wb\");\n  if (tagf == NULL)\n    pfatal (tagfile);\n  put_entries (nodehead);\t/* write all the tags (CTAGS) */\n  free_tree (nodehead);\n  nodehead = NULL;\n  if (fclose (tagf) == EOF)\n    pfatal (tagfile);\n\n  if (CTAGS)\n    if (append_to_tagfile || update)\n      {\n\t/* Maybe these should be used:\n\t   setenv (\"LC_COLLATE\", \"C\", 1);\n\t   setenv (\"LC_ALL\", \"C\", 1); */\n\tchar *cmd = xmalloc (8 * strlen (tagfile) + sizeof \"sort -u -o '' ''\");\n#if defined WINDOWSNT || defined MSDOS\n\t/* Quote \"like this\".  No need to escape the quotes in the file name,\n\t   since it is not allowed in file names on these systems.  */\n\tchar *z = stpcpy (cmd, \"sort -u -o \\\"\");\n\tz = stpcpy (z, tagfile);\n\tz = stpcpy (z, \"\\\" \\\"\");\n\tz = stpcpy (z, tagfile);\n\tstpcpy (z, \"\\\"\");\n#else\n\t/* Quote 'like this', and escape the apostrophe in the file name.  */\n\tchar *z = stpcpy (cmd, \"sort -u -o '\");\n\tchar *escaped_tagfile = z;\n\tfor (; *tagfile; *z++ = *tagfile++)\n\t  if (*tagfile == '\\'')\n\t    z = stpcpy (z, \"'\\\\'\");\n\tptrdiff_t escaped_tagfile_len = z - escaped_tagfile;\n\tz = stpcpy (z, \"' '\");\n\tz = mempcpy (z, escaped_tagfile, escaped_tagfile_len);\n\tstrcpy (z, \"'\");\n#endif\n\treturn system (cmd);\n      }\n  return EXIT_SUCCESS;\n}",
        "func_after": "int\nmain (int argc, char **argv)\n{\n  int i;\n  int nincluded_files;\n  char **included_files;\n  argument *argbuffer;\n  int current_arg, file_count;\n  linebuffer filename_lb;\n  bool help_asked = false;\n  ptrdiff_t len;\n  char *optstring;\n  int opt;\n\n  progname = argv[0];\n  nincluded_files = 0;\n  included_files = xnew (argc, char *);\n  current_arg = 0;\n  file_count = 0;\n\n  /* Allocate enough no matter what happens.  Overkill, but each one\n     is small. */\n  argbuffer = xnew (argc, argument);\n\n  /*\n   * Always find typedefs and structure tags.\n   * Also default to find macro constants, enum constants, struct\n   * members and global variables.  Do it for both etags and ctags.\n   */\n  typedefs = typedefs_or_cplusplus = constantypedefs = true;\n  globals = members = true;\n\n  /* When the optstring begins with a '-' getopt_long does not rearrange the\n     non-options arguments to be at the end, but leaves them alone. */\n  optstring = concat (\"-ac:Cf:Il:o:Qr:RSVhH\",\n\t\t      (CTAGS) ? \"BxdtTuvw\" : \"Di:\",\n\t\t      \"\");\n\n  while ((opt = getopt_long (argc, argv, optstring, longopts, NULL)) != EOF)\n    switch (opt)\n      {\n      case 0:\n\t/* If getopt returns 0, then it has already processed a\n\t   long-named option.  We should do nothing.  */\n\tbreak;\n\n      case 1:\n\t/* This means that a file name has been seen.  Record it. */\n\targbuffer[current_arg].arg_type = at_filename;\n\targbuffer[current_arg].what     = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\t++file_count;\n\tbreak;\n\n      case STDIN:\n\t/* Parse standard input.  Idea by Vivek <vivek@etla.org>. */\n\targbuffer[current_arg].arg_type = at_stdin;\n\targbuffer[current_arg].what     = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\t++file_count;\n\tif (parsing_stdin)\n\t  fatal (\"cannot parse standard input more than once\");\n\tparsing_stdin = true;\n\tbreak;\n\n\t/* Common options. */\n      case 'a': append_to_tagfile = true;\tbreak;\n      case 'C': cplusplus = true;\t\tbreak;\n      case 'f':\t\t/* for compatibility with old makefiles */\n      case 'o':\n\tif (tagfile)\n\t  {\n\t    error (\"-o option may only be given once.\");\n\t    suggest_asking_for_help ();\n\t  }\n\ttagfile = optarg;\n\tbreak;\n      case 'I':\n      case 'S':\t\t/* for backward compatibility */\n\tignoreindent = true;\n\tbreak;\n      case 'l':\n\t{\n\t  language *lang = get_language_from_langname (optarg);\n\t  if (lang != NULL)\n\t    {\n\t      argbuffer[current_arg].lang = lang;\n\t      argbuffer[current_arg].arg_type = at_language;\n\t      ++current_arg;\n\t    }\n\t}\n\tbreak;\n      case 'c':\n\t/* Backward compatibility: support obsolete --ignore-case-regexp. */\n\toptarg = concat (optarg, \"i\", \"\"); /* memory leak here */\n\tFALLTHROUGH;\n      case 'r':\n\targbuffer[current_arg].arg_type = at_regexp;\n\targbuffer[current_arg].what = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\tbreak;\n      case 'R':\n\targbuffer[current_arg].arg_type = at_regexp;\n\targbuffer[current_arg].what = NULL;\n\t++current_arg;\n\tbreak;\n      case 'V':\n\tprint_version ();\n\tbreak;\n      case 'h':\n      case 'H':\n\thelp_asked = true;\n\tbreak;\n      case 'Q':\n\tclass_qualify = 1;\n\tbreak;\n\n\t/* Etags options */\n      case 'D': constantypedefs = false;\t\t\tbreak;\n      case 'i': included_files[nincluded_files++] = optarg;\tbreak;\n\n\t/* Ctags options. */\n      case 'B': searchar = '?';\t\t\t\t\tbreak;\n      case 'd': constantypedefs = true;\t\t\t\tbreak;\n      case 't': typedefs = true;\t\t\t\tbreak;\n      case 'T': typedefs = typedefs_or_cplusplus = true;\tbreak;\n      case 'u': update = true;\t\t\t\t\tbreak;\n      case 'v': vgrind_style = true;\t\t\t\tFALLTHROUGH;\n      case 'x': cxref_style = true;\t\t\t\tbreak;\n      case 'w': no_warnings = true;\t\t\t\tbreak;\n      default:\n\tsuggest_asking_for_help ();\n      }\n\n  /* No more options.  Store the rest of arguments. */\n  for (; optind < argc; optind++)\n    {\n      argbuffer[current_arg].arg_type = at_filename;\n      argbuffer[current_arg].what = argv[optind];\n      len = strlen (argv[optind]);\n      if (whatlen_max < len)\n\twhatlen_max = len;\n      ++current_arg;\n      ++file_count;\n    }\n\n  argbuffer[current_arg].arg_type = at_end;\n\n  if (help_asked)\n    print_help (argbuffer);\n\n  if (nincluded_files == 0 && file_count == 0)\n    {\n      error (\"no input files specified.\");\n      suggest_asking_for_help ();\n    }\n\n  if (tagfile == NULL)\n    tagfile = savestr (CTAGS ? \"tags\" : \"TAGS\");\n  cwd = etags_getcwd ();\t/* the current working directory */\n  if (cwd[strlen (cwd) - 1] != '/')\n    {\n      char *oldcwd = cwd;\n      cwd = concat (oldcwd, \"/\", \"\");\n      free (oldcwd);\n    }\n\n  /* Compute base directory for relative file names. */\n  if (streq (tagfile, \"-\")\n      || strneq (tagfile, \"/dev/\", 5))\n    tagfiledir = cwd;\t\t /* relative file names are relative to cwd */\n  else\n    {\n      canonicalize_filename (tagfile);\n      tagfiledir = absolute_dirname (tagfile, cwd);\n    }\n\n  linebuffer_init (&lb);\n  linebuffer_init (&filename_lb);\n  linebuffer_init (&filebuf);\n  linebuffer_init (&token_name);\n\n  if (!CTAGS)\n    {\n      if (streq (tagfile, \"-\"))\n\t{\n\t  tagf = stdout;\n\t  set_binary_mode (STDOUT_FILENO, O_BINARY);\n\t}\n      else\n\ttagf = fopen (tagfile, append_to_tagfile ? \"ab\" : \"wb\");\n      if (tagf == NULL)\n\tpfatal (tagfile);\n    }\n\n  /*\n   * Loop through files finding functions.\n   */\n  for (i = 0; i < current_arg; i++)\n    {\n      static language *lang;\t/* non-NULL if language is forced */\n      char *this_file;\n\n      switch (argbuffer[i].arg_type)\n\t{\n\tcase at_language:\n\t  lang = argbuffer[i].lang;\n\t  break;\n\tcase at_regexp:\n\t  analyze_regex (argbuffer[i].what);\n\t  break;\n\tcase at_filename:\n\t      this_file = argbuffer[i].what;\n\t      /* Input file named \"-\" means read file names from stdin\n\t\t (one per line) and use them. */\n\t      if (streq (this_file, \"-\"))\n\t\t{\n\t\t  if (parsing_stdin)\n\t\t    fatal (\"cannot parse standard input \"\n\t\t\t   \"AND read file names from it\");\n\t\t  while (readline_internal (&filename_lb, stdin, \"-\", false) > 0)\n\t\t    process_file_name (filename_lb.buffer, lang);\n\t\t}\n\t      else\n\t\tprocess_file_name (this_file, lang);\n\t  break;\n        case at_stdin:\n          this_file = argbuffer[i].what;\n          process_file (stdin, this_file, lang);\n          break;\n\tdefault:\n\t  error (\"internal error: arg_type\");\n\t}\n    }\n\n  free_regexps ();\n  free (lb.buffer);\n  free (filebuf.buffer);\n  free (token_name.buffer);\n\n  if (!CTAGS || cxref_style)\n    {\n      /* Write the remaining tags to tagf (ETAGS) or stdout (CXREF). */\n      put_entries (nodehead);\n      free_tree (nodehead);\n      nodehead = NULL;\n      if (!CTAGS)\n\t{\n\t  fdesc *fdp;\n\n\t  /* Output file entries that have no tags. */\n\t  for (fdp = fdhead; fdp != NULL; fdp = fdp->next)\n\t    if (!fdp->written)\n\t      fprintf (tagf, \"\\f\\n%s,0\\n\", fdp->taggedfname);\n\n\t  while (nincluded_files-- > 0)\n\t    fprintf (tagf, \"\\f\\n%s,include\\n\", *included_files++);\n\n\t  if (fclose (tagf) == EOF)\n\t    pfatal (tagfile);\n\t}\n\n      return EXIT_SUCCESS;\n    }\n\n  /* From here on, we are in (CTAGS && !cxref_style) */\n  if (update)\n    {\n      for (i = 0; i < current_arg; ++i)\n\t{\n\t  switch (argbuffer[i].arg_type)\n\t    {\n\t    case at_filename:\n\t    case at_stdin:\n\t      break;\n\t    default:\n\t      continue;\t\t/* the for loop */\n\t    }\n          clean_matched_file_tag (tagfile, argbuffer[i].what);\n\t}\n      append_to_tagfile = true;\n    }\n\n  tagf = fopen (tagfile, append_to_tagfile ? \"ab\" : \"wb\");\n  if (tagf == NULL)\n    pfatal (tagfile);\n  put_entries (nodehead);\t/* write all the tags (CTAGS) */\n  free_tree (nodehead);\n  nodehead = NULL;\n  if (fclose (tagf) == EOF)\n    pfatal (tagfile);\n\n  if (CTAGS)\n    if (append_to_tagfile || update)\n      {\n\t/* Maybe these should be used:\n\t   setenv (\"LC_COLLATE\", \"C\", 1);\n\t   setenv (\"LC_ALL\", \"C\", 1); */\n\tchar *cmd = xmalloc (8 * strlen (tagfile) + sizeof \"sort -u -o '' ''\");\n#if defined WINDOWSNT || defined MSDOS\n\t/* Quote \"like this\".  No need to escape the quotes in the file name,\n\t   since it is not allowed in file names on these systems.  */\n\tchar *z = stpcpy (cmd, \"sort -u -o \\\"\");\n\tz = stpcpy (z, tagfile);\n\tz = stpcpy (z, \"\\\" \\\"\");\n\tz = stpcpy (z, tagfile);\n\tstpcpy (z, \"\\\"\");\n#else\n\t/* Quote 'like this', and escape the apostrophe in the file name.  */\n\tchar *z = stpcpy (cmd, \"sort -u -o '\");\n\tchar *escaped_tagfile = z;\n\tfor (; *tagfile; *z++ = *tagfile++)\n\t  if (*tagfile == '\\'')\n\t    z = stpcpy (z, \"'\\\\'\");\n\tptrdiff_t escaped_tagfile_len = z - escaped_tagfile;\n\tz = stpcpy (z, \"' '\");\n\tz = mempcpy (z, escaped_tagfile, escaped_tagfile_len);\n\tstrcpy (z, \"'\");\n#endif\n\treturn system (cmd);\n      }\n  return EXIT_SUCCESS;\n}",
        "description": "GNU Emacs versions up to 28.2 are vulnerable to command execution through shell metacharacters in source-code file names. This vulnerability arises due to the use of the system C library function within the implementation of the ctags program in lib-src/etags.c. An attacker can exploit this by using commands like \"ctags *\" in a directory containing files whose names are influenced by untrusted input, leading to unintended command execution.",
        "commit": "The vulnerability knowledge describes the addition of new functions and files within the `lib-src/etags.c` and `test/manual/etags/` directories of a software project. Specifically, the `clean_matched_file_tag` and `do_move_file` functions have been introduced, along with modifications to the `readline_internal` function to include a `leave_cr` parameter that controls whether the `\\r` character should be included. Additionally, new test files (`CTAGS.good_crlf`, `CTAGS.good_update`, and `crlf`) have been added to the `test/manual/etags/` directory, and test cases for `ctags -u` have been incorporated into the `Makefile`."
    }
]