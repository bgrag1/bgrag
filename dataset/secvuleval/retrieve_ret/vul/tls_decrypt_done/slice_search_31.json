[
    {
        "cwe": "CWE-362",
        "func_name": "torvalds/skcipher_recvmsg",
        "score": 0.7680467963218689,
        "func_before": "static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t ignored, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tunsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(\n\t\t&ctx->req));\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tint err = -EAGAIN;\n\tint used;\n\tlong copied = 0;\n\n\tlock_sock(sk);\n\twhile (iov_iter_count(&msg->msg_iter)) {\n\t\tsgl = list_first_entry(&ctx->tsgl,\n\t\t\t\t       struct skcipher_sg_list, list);\n\t\tsg = sgl->sg;\n\n\t\twhile (!sg->length)\n\t\t\tsg++;\n\n\t\tused = ctx->used;\n\t\tif (!used) {\n\t\t\terr = skcipher_wait_for_data(sk, flags);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t\tused = min_t(unsigned long, used, iov_iter_count(&msg->msg_iter));\n\n\t\tused = af_alg_make_sg(&ctx->rsgl, &msg->msg_iter, used);\n\t\terr = used;\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\n\t\tif (ctx->more || used < ctx->used)\n\t\t\tused -= used % bs;\n\n\t\terr = -EINVAL;\n\t\tif (!used)\n\t\t\tgoto free;\n\n\t\tablkcipher_request_set_crypt(&ctx->req, sg,\n\t\t\t\t\t     ctx->rsgl.sg, used,\n\t\t\t\t\t     ctx->iv);\n\n\t\terr = af_alg_wait_for_completion(\n\t\t\t\tctx->enc ?\n\t\t\t\t\tcrypto_ablkcipher_encrypt(&ctx->req) :\n\t\t\t\t\tcrypto_ablkcipher_decrypt(&ctx->req),\n\t\t\t\t&ctx->completion);\n\nfree:\n\t\taf_alg_free_sg(&ctx->rsgl);\n\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\tcopied += used;\n\t\tskcipher_pull_sgl(sk, used);\n\t\tiov_iter_advance(&msg->msg_iter, used);\n\t}\n\n\terr = 0;\n\nunlock:\n\tskcipher_wmem_wakeup(sk);\n\trelease_sock(sk);\n\n\treturn copied ?: err;\n}",
        "func_after": "static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t ignored, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tunsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(\n\t\t&ctx->req));\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tint err = -EAGAIN;\n\tint used;\n\tlong copied = 0;\n\n\tlock_sock(sk);\n\twhile (iov_iter_count(&msg->msg_iter)) {\n\t\tsgl = list_first_entry(&ctx->tsgl,\n\t\t\t\t       struct skcipher_sg_list, list);\n\t\tsg = sgl->sg;\n\n\t\twhile (!sg->length)\n\t\t\tsg++;\n\n\t\tif (!ctx->used) {\n\t\t\terr = skcipher_wait_for_data(sk, flags);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t\tused = min_t(unsigned long, ctx->used, iov_iter_count(&msg->msg_iter));\n\n\t\tused = af_alg_make_sg(&ctx->rsgl, &msg->msg_iter, used);\n\t\terr = used;\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\n\t\tif (ctx->more || used < ctx->used)\n\t\t\tused -= used % bs;\n\n\t\terr = -EINVAL;\n\t\tif (!used)\n\t\t\tgoto free;\n\n\t\tablkcipher_request_set_crypt(&ctx->req, sg,\n\t\t\t\t\t     ctx->rsgl.sg, used,\n\t\t\t\t\t     ctx->iv);\n\n\t\terr = af_alg_wait_for_completion(\n\t\t\t\tctx->enc ?\n\t\t\t\t\tcrypto_ablkcipher_encrypt(&ctx->req) :\n\t\t\t\t\tcrypto_ablkcipher_decrypt(&ctx->req),\n\t\t\t\t&ctx->completion);\n\nfree:\n\t\taf_alg_free_sg(&ctx->rsgl);\n\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\tcopied += used;\n\t\tskcipher_pull_sgl(sk, used);\n\t\tiov_iter_advance(&msg->msg_iter, used);\n\t}\n\n\terr = 0;\n\nunlock:\n\tskcipher_wmem_wakeup(sk);\n\trelease_sock(sk);\n\n\treturn copied ?: err;\n}",
        "description": "A flaw was identified in the `get_user_pages_fast` function within the Linux kernel's symmetric key cipher algorithm interface, specifically in the `skcipher_recvmsg` function. This flaw enables a local user to potentially crash the system.",
        "commit": "The vulnerability involves issues in the `af_alg_make_sg()` function and `skcipher_recvmsg()` within the cryptographic module of the Linux kernel. During the transition to using `iov_iter` interfaces, the calculation of `npages` in `af_alg_make_sg()` was altered to count bytes instead of pages. Additionally, in `skcipher_recvmsg()`, the conversion did not update the value of `ctx->used` after waiting for it to become non-zero. These changes led to functional breaks in both functions. The patch reverts the code to its original state to restore functionality."
    },
    {
        "cwe": "CWE-330",
        "func_name": "torvalds/sfb_enqueue",
        "score": 0.7606478333473206,
        "func_before": "static int sfb_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t       struct sk_buff **to_free)\n{\n\n\tstruct sfb_sched_data *q = qdisc_priv(sch);\n\tstruct Qdisc *child = q->qdisc;\n\tstruct tcf_proto *fl;\n\tint i;\n\tu32 p_min = ~0;\n\tu32 minqlen = ~0;\n\tu32 r, sfbhash;\n\tu32 slot = q->slot;\n\tint ret = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n\n\tif (unlikely(sch->q.qlen >= q->limit)) {\n\t\tqdisc_qstats_overlimit(sch);\n\t\tq->stats.queuedrop++;\n\t\tgoto drop;\n\t}\n\n\tif (q->rehash_interval > 0) {\n\t\tunsigned long limit = q->rehash_time + q->rehash_interval;\n\n\t\tif (unlikely(time_after(jiffies, limit))) {\n\t\t\tsfb_swap_slot(q);\n\t\t\tq->rehash_time = jiffies;\n\t\t} else if (unlikely(!q->double_buffering && q->warmup_time > 0 &&\n\t\t\t\t    time_after(jiffies, limit - q->warmup_time))) {\n\t\t\tq->double_buffering = true;\n\t\t}\n\t}\n\n\tfl = rcu_dereference_bh(q->filter_list);\n\tif (fl) {\n\t\tu32 salt;\n\n\t\t/* If using external classifiers, get result and record it. */\n\t\tif (!sfb_classify(skb, fl, &ret, &salt))\n\t\t\tgoto other_drop;\n\t\tsfbhash = jhash_1word(salt, q->bins[slot].perturbation);\n\t} else {\n\t\tsfbhash = skb_get_hash_perturb(skb, q->bins[slot].perturbation);\n\t}\n\n\n\tif (!sfbhash)\n\t\tsfbhash = 1;\n\tsfb_skb_cb(skb)->hashes[slot] = sfbhash;\n\n\tfor (i = 0; i < SFB_LEVELS; i++) {\n\t\tu32 hash = sfbhash & SFB_BUCKET_MASK;\n\t\tstruct sfb_bucket *b = &q->bins[slot].bins[i][hash];\n\n\t\tsfbhash >>= SFB_BUCKET_SHIFT;\n\t\tif (b->qlen == 0)\n\t\t\tdecrement_prob(b, q);\n\t\telse if (b->qlen >= q->bin_size)\n\t\t\tincrement_prob(b, q);\n\t\tif (minqlen > b->qlen)\n\t\t\tminqlen = b->qlen;\n\t\tif (p_min > b->p_mark)\n\t\t\tp_min = b->p_mark;\n\t}\n\n\tslot ^= 1;\n\tsfb_skb_cb(skb)->hashes[slot] = 0;\n\n\tif (unlikely(minqlen >= q->max)) {\n\t\tqdisc_qstats_overlimit(sch);\n\t\tq->stats.bucketdrop++;\n\t\tgoto drop;\n\t}\n\n\tif (unlikely(p_min >= SFB_MAX_PROB)) {\n\t\t/* Inelastic flow */\n\t\tif (q->double_buffering) {\n\t\t\tsfbhash = skb_get_hash_perturb(skb,\n\t\t\t    q->bins[slot].perturbation);\n\t\t\tif (!sfbhash)\n\t\t\t\tsfbhash = 1;\n\t\t\tsfb_skb_cb(skb)->hashes[slot] = sfbhash;\n\n\t\t\tfor (i = 0; i < SFB_LEVELS; i++) {\n\t\t\t\tu32 hash = sfbhash & SFB_BUCKET_MASK;\n\t\t\t\tstruct sfb_bucket *b = &q->bins[slot].bins[i][hash];\n\n\t\t\t\tsfbhash >>= SFB_BUCKET_SHIFT;\n\t\t\t\tif (b->qlen == 0)\n\t\t\t\t\tdecrement_prob(b, q);\n\t\t\t\telse if (b->qlen >= q->bin_size)\n\t\t\t\t\tincrement_prob(b, q);\n\t\t\t}\n\t\t}\n\t\tif (sfb_rate_limit(skb, q)) {\n\t\t\tqdisc_qstats_overlimit(sch);\n\t\t\tq->stats.penaltydrop++;\n\t\t\tgoto drop;\n\t\t}\n\t\tgoto enqueue;\n\t}\n\n\tr = prandom_u32() & SFB_MAX_PROB;\n\n\tif (unlikely(r < p_min)) {\n\t\tif (unlikely(p_min > SFB_MAX_PROB / 2)) {\n\t\t\t/* If we're marking that many packets, then either\n\t\t\t * this flow is unresponsive, or we're badly congested.\n\t\t\t * In either case, we want to start dropping packets.\n\t\t\t */\n\t\t\tif (r < (p_min - SFB_MAX_PROB / 2) * 2) {\n\t\t\t\tq->stats.earlydrop++;\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\t\tif (INET_ECN_set_ce(skb)) {\n\t\t\tq->stats.marked++;\n\t\t} else {\n\t\t\tq->stats.earlydrop++;\n\t\t\tgoto drop;\n\t\t}\n\t}\n\nenqueue:\n\tret = qdisc_enqueue(skb, child, to_free);\n\tif (likely(ret == NET_XMIT_SUCCESS)) {\n\t\tqdisc_qstats_backlog_inc(sch, skb);\n\t\tsch->q.qlen++;\n\t\tincrement_qlen(skb, q);\n\t} else if (net_xmit_drop_count(ret)) {\n\t\tq->stats.childdrop++;\n\t\tqdisc_qstats_drop(sch);\n\t}\n\treturn ret;\n\ndrop:\n\tqdisc_drop(skb, sch, to_free);\n\treturn NET_XMIT_CN;\nother_drop:\n\tif (ret & __NET_XMIT_BYPASS)\n\t\tqdisc_qstats_drop(sch);\n\tkfree_skb(skb);\n\treturn ret;\n}",
        "func_after": "static int sfb_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t       struct sk_buff **to_free)\n{\n\n\tstruct sfb_sched_data *q = qdisc_priv(sch);\n\tstruct Qdisc *child = q->qdisc;\n\tstruct tcf_proto *fl;\n\tint i;\n\tu32 p_min = ~0;\n\tu32 minqlen = ~0;\n\tu32 r, sfbhash;\n\tu32 slot = q->slot;\n\tint ret = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n\n\tif (unlikely(sch->q.qlen >= q->limit)) {\n\t\tqdisc_qstats_overlimit(sch);\n\t\tq->stats.queuedrop++;\n\t\tgoto drop;\n\t}\n\n\tif (q->rehash_interval > 0) {\n\t\tunsigned long limit = q->rehash_time + q->rehash_interval;\n\n\t\tif (unlikely(time_after(jiffies, limit))) {\n\t\t\tsfb_swap_slot(q);\n\t\t\tq->rehash_time = jiffies;\n\t\t} else if (unlikely(!q->double_buffering && q->warmup_time > 0 &&\n\t\t\t\t    time_after(jiffies, limit - q->warmup_time))) {\n\t\t\tq->double_buffering = true;\n\t\t}\n\t}\n\n\tfl = rcu_dereference_bh(q->filter_list);\n\tif (fl) {\n\t\tu32 salt;\n\n\t\t/* If using external classifiers, get result and record it. */\n\t\tif (!sfb_classify(skb, fl, &ret, &salt))\n\t\t\tgoto other_drop;\n\t\tsfbhash = siphash_1u32(salt, &q->bins[slot].perturbation);\n\t} else {\n\t\tsfbhash = skb_get_hash_perturb(skb, &q->bins[slot].perturbation);\n\t}\n\n\n\tif (!sfbhash)\n\t\tsfbhash = 1;\n\tsfb_skb_cb(skb)->hashes[slot] = sfbhash;\n\n\tfor (i = 0; i < SFB_LEVELS; i++) {\n\t\tu32 hash = sfbhash & SFB_BUCKET_MASK;\n\t\tstruct sfb_bucket *b = &q->bins[slot].bins[i][hash];\n\n\t\tsfbhash >>= SFB_BUCKET_SHIFT;\n\t\tif (b->qlen == 0)\n\t\t\tdecrement_prob(b, q);\n\t\telse if (b->qlen >= q->bin_size)\n\t\t\tincrement_prob(b, q);\n\t\tif (minqlen > b->qlen)\n\t\t\tminqlen = b->qlen;\n\t\tif (p_min > b->p_mark)\n\t\t\tp_min = b->p_mark;\n\t}\n\n\tslot ^= 1;\n\tsfb_skb_cb(skb)->hashes[slot] = 0;\n\n\tif (unlikely(minqlen >= q->max)) {\n\t\tqdisc_qstats_overlimit(sch);\n\t\tq->stats.bucketdrop++;\n\t\tgoto drop;\n\t}\n\n\tif (unlikely(p_min >= SFB_MAX_PROB)) {\n\t\t/* Inelastic flow */\n\t\tif (q->double_buffering) {\n\t\t\tsfbhash = skb_get_hash_perturb(skb,\n\t\t\t    &q->bins[slot].perturbation);\n\t\t\tif (!sfbhash)\n\t\t\t\tsfbhash = 1;\n\t\t\tsfb_skb_cb(skb)->hashes[slot] = sfbhash;\n\n\t\t\tfor (i = 0; i < SFB_LEVELS; i++) {\n\t\t\t\tu32 hash = sfbhash & SFB_BUCKET_MASK;\n\t\t\t\tstruct sfb_bucket *b = &q->bins[slot].bins[i][hash];\n\n\t\t\t\tsfbhash >>= SFB_BUCKET_SHIFT;\n\t\t\t\tif (b->qlen == 0)\n\t\t\t\t\tdecrement_prob(b, q);\n\t\t\t\telse if (b->qlen >= q->bin_size)\n\t\t\t\t\tincrement_prob(b, q);\n\t\t\t}\n\t\t}\n\t\tif (sfb_rate_limit(skb, q)) {\n\t\t\tqdisc_qstats_overlimit(sch);\n\t\t\tq->stats.penaltydrop++;\n\t\t\tgoto drop;\n\t\t}\n\t\tgoto enqueue;\n\t}\n\n\tr = prandom_u32() & SFB_MAX_PROB;\n\n\tif (unlikely(r < p_min)) {\n\t\tif (unlikely(p_min > SFB_MAX_PROB / 2)) {\n\t\t\t/* If we're marking that many packets, then either\n\t\t\t * this flow is unresponsive, or we're badly congested.\n\t\t\t * In either case, we want to start dropping packets.\n\t\t\t */\n\t\t\tif (r < (p_min - SFB_MAX_PROB / 2) * 2) {\n\t\t\t\tq->stats.earlydrop++;\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\t\tif (INET_ECN_set_ce(skb)) {\n\t\t\tq->stats.marked++;\n\t\t} else {\n\t\t\tq->stats.earlydrop++;\n\t\t\tgoto drop;\n\t\t}\n\t}\n\nenqueue:\n\tret = qdisc_enqueue(skb, child, to_free);\n\tif (likely(ret == NET_XMIT_SUCCESS)) {\n\t\tqdisc_qstats_backlog_inc(sch, skb);\n\t\tsch->q.qlen++;\n\t\tincrement_qlen(skb, q);\n\t} else if (net_xmit_drop_count(ret)) {\n\t\tq->stats.childdrop++;\n\t\tqdisc_qstats_drop(sch);\n\t}\n\treturn ret;\n\ndrop:\n\tqdisc_drop(skb, sch, to_free);\n\treturn NET_XMIT_CN;\nother_drop:\n\tif (ret & __NET_XMIT_BYPASS)\n\t\tqdisc_qstats_drop(sch);\n\tkfree_skb(skb);\n\treturn ret;\n}",
        "description": "The flow_dissector feature in the Linux kernel from version 4.3 up to but not including 5.3.10 suffers from a device tracking vulnerability, identified as CID-55667441c84f. This vulnerability arises due to the reliance on a 32-bit hashrnd value as a secret for the auto flowlabel of a UDP IPv6 packet. Additionally, the use of jhash instead of siphash exacerbates the issue. Since the hashrnd value remains constant from the time of system boot, it can be deduced by an attacker, thereby compromising the intended security measures. This problem is present in the net/core/flow_dissector.c file and related components.",
        "commit": "The vulnerability involves the use of a 32-bit secret in generating auto flowlabels for UDP IPv6 packets, which can be inferred by attackers to identify devices or users. The secret is initialized only at boot time and is used in conjunction with the jhash function to create flow labels that are predictable. This predictability poses a significant privacy risk. The proposed solution is to switch from using jhash to a cryptographically strong pseudo-random function like siphash, similar to changes made in the IP ID generator. This switch aims to enhance security by making the flow label generation process less predictable and thereby reducing the risk of device/user identification."
    },
    {
        "cwe": "CWE-824",
        "func_name": "gerbv/gerbv_open_image",
        "score": 0.7577984929084778,
        "func_before": "int\ngerbv_open_image(gerbv_project_t *gerbvProject, gchar const* filename, int idx, int reload,\n\t\tgerbv_HID_Attribute *fattr, int n_fattr, gboolean forceLoadFile)\n{\n    gerb_file_t *fd;\n    gerbv_image_t *parsed_image = NULL, *parsed_image2 = NULL;\n    gint retv = -1;\n    gboolean isPnpFile = FALSE, foundBinary;\n    gerbv_HID_Attribute *attr_list = NULL;\n    int n_attr = 0;\n    /* If we're reloading, we'll pass in our file format attribute list\n     * since this is our hook for letting the user override the fileformat.\n     */\n    if (reload)\n\t{\n\t    /* We're reloading so use the attribute list in memory */\n\t    attr_list =  gerbvProject->file[idx]->image->info->attr_list;\n\t    n_attr =  gerbvProject->file[idx]->image->info->n_attr;\n\t}\n    else\n\t{\n\t    /* We're not reloading so use the attribute list read from the \n\t     * project file if given or NULL otherwise.\n\t     */\n\t    attr_list = fattr;\n\t    n_attr = n_fattr;\n\t}\n    /* if we don't have enough spots, then grow the file list by 2 to account for the possible \n       loading of two images for PNP files */\n    if ((idx+1) >= gerbvProject->max_files) {\n\tgerbvProject->file = g_renew (gerbv_fileinfo_t *,\n\t\t\tgerbvProject->file, gerbvProject->max_files + 2);\n\n\tgerbvProject->file[gerbvProject->max_files] = NULL;\n\tgerbvProject->file[gerbvProject->max_files+1] = NULL;\n\tgerbvProject->max_files += 2;\n    }\n    \n    dprintf(\"In open_image, about to try opening filename = %s\\n\", filename);\n    \n    fd = gerb_fopen(filename);\n    if (fd == NULL) {\n\tGERB_COMPILE_ERROR(_(\"Trying to open \\\"%s\\\": %s\"),\n\t\t\tfilename, strerror(errno));\n\treturn -1;\n    }\n\n    /* Store filename info fd for further use */\n    fd->filename = g_strdup(filename);\n    \n    dprintf(\"In open_image, successfully opened file.  Now check its type....\\n\");\n    /* Here's where we decide what file type we have */\n    /* Note: if the file has some invalid characters in it but still appears to\n       be a valid file, we check with the user if he wants to continue (only\n       if user opens the layer from the menu...if from the command line, we go\n       ahead and try to load it anyways) */\n\n    if (gerber_is_rs274x_p(fd, &foundBinary)) {\n\tdprintf(\"Found RS-274X file\\n\");\n\tif (!foundBinary || forceLoadFile) {\n\t\t/* figure out the directory path in case parse_gerb needs to\n\t\t * load any include files */\n\t\tgchar *currentLoadDirectory = g_path_get_dirname (filename);\n\t\tparsed_image = parse_gerb(fd, currentLoadDirectory);\n\t\tg_free (currentLoadDirectory);\n\t}\n    } else if(drill_file_p(fd, &foundBinary)) {\n\tdprintf(\"Found drill file\\n\");\n\tif (!foundBinary || forceLoadFile)\n\t    parsed_image = parse_drillfile(fd, attr_list, n_attr, reload);\n\t\n    } else if (pick_and_place_check_file_type(fd, &foundBinary)) {\n\tdprintf(\"Found pick-n-place file\\n\");\n\tif (!foundBinary || forceLoadFile) {\n\t\tif (!reload) {\n\t\t\tpick_and_place_parse_file_to_images(fd, &parsed_image, &parsed_image2);\n\t\t} else {\n\t\t\tswitch (gerbvProject->file[idx]->image->layertype) {\n\t\t\tcase GERBV_LAYERTYPE_PICKANDPLACE_TOP:\n\t\t\t\t/* Non NULL pointer is used as \"not to reload\" mark */\n\t\t\t\tparsed_image2 = (void *)!NULL;\n\t\t\t\tpick_and_place_parse_file_to_images(fd, &parsed_image, &parsed_image2);\n\t\t\t\tparsed_image2 = NULL;\n\t\t\t\tbreak;\n\t\t\tcase GERBV_LAYERTYPE_PICKANDPLACE_BOT:\n\t\t\t\t/* Non NULL pointer is used as \"not to reload\" mark */\n\t\t\t\tparsed_image2 = (void *)!NULL;\n\t\t\t\tpick_and_place_parse_file_to_images(fd, &parsed_image2, &parsed_image);\n\t\t\t\tparsed_image2 = NULL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tGERB_COMPILE_ERROR(_(\"%s: unknown pick-and-place board side to reload\"), filename);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tisPnpFile = TRUE;\n\t}\n    } else if (gerber_is_rs274d_p(fd)) {\n\tgchar *str = g_strdup_printf(_(\"Most likely found a RS-274D file \"\n\t\t\t\"\\\"%s\\\" ... trying to open anyways\\n\"), filename);\n\tdprintf(\"%s\", str);\n\tg_warning(\"%s\", str);\n\tg_free (str);\n\n\tif (!foundBinary || forceLoadFile) {\n\t\t/* figure out the directory path in case parse_gerb needs to\n\t\t * load any include files */\n\t\tgchar *currentLoadDirectory = g_path_get_dirname (filename);\n\t\tparsed_image = parse_gerb(fd, currentLoadDirectory);\n\t\tg_free (currentLoadDirectory);\n\t}\n    } else {\n\t/* This is not a known file */\n\tdprintf(\"Unknown filetype\");\n\tGERB_COMPILE_ERROR(_(\"%s: Unknown file type.\"), filename);\n\tparsed_image = NULL;\n    }\n    \n    g_free(fd->filename);\n    gerb_fclose(fd);\n    if (parsed_image == NULL) {\n\treturn -1;\n    }\n    \n    if (parsed_image) {\n\t/* strip the filename to the base */\n\tgchar *baseName = g_path_get_basename (filename);\n\tgchar *displayedName;\n\tif (isPnpFile)\n\t\tdisplayedName = g_strconcat (baseName, _(\" (top)\"), NULL);\n\telse\n\t\tdisplayedName = g_strdup (baseName);\n    \tretv = gerbv_add_parsed_image_to_project (gerbvProject, parsed_image, filename, displayedName, idx, reload);\n    \tg_free (baseName);\n    \tg_free (displayedName);\n    }\n\n    /* Set layer_dirty flag to FALSE */\n    gerbvProject->file[idx]->layer_dirty = FALSE;\n\n    /* for PNP place files, we may need to add a second image for the other\n       board side */\n    if (parsed_image2) {\n      /* strip the filename to the base */\n\tgchar *baseName = g_path_get_basename (filename);\n\tgchar *displayedName;\n\tdisplayedName = g_strconcat (baseName, _(\" (bottom)\"), NULL);\n    \tretv = gerbv_add_parsed_image_to_project (gerbvProject, parsed_image2, filename, displayedName, idx + 1, reload);\n    \tg_free (baseName);\n    \tg_free (displayedName);\n    }\n\n    return retv;\n}",
        "func_after": "int\ngerbv_open_image(gerbv_project_t *gerbvProject, gchar const* filename, int idx, int reload,\n\t\tgerbv_HID_Attribute *fattr, int n_fattr, gboolean forceLoadFile)\n{\n    gerb_file_t *fd;\n    gerbv_image_t *parsed_image = NULL, *parsed_image2 = NULL;\n    gint retv = -1;\n    gboolean isPnpFile = FALSE, foundBinary;\n    gerbv_HID_Attribute *attr_list = NULL;\n    int n_attr = 0;\n    /* If we're reloading, we'll pass in our file format attribute list\n     * since this is our hook for letting the user override the fileformat.\n     */\n    if (reload)\n\t{\n\t    /* We're reloading so use the attribute list in memory */\n\t    attr_list =  gerbvProject->file[idx]->image->info->attr_list;\n\t    n_attr =  gerbvProject->file[idx]->image->info->n_attr;\n\t}\n    else\n\t{\n\t    /* We're not reloading so use the attribute list read from the \n\t     * project file if given or NULL otherwise.\n\t     */\n\t    attr_list = fattr;\n\t    n_attr = n_fattr;\n\t}\n    /* if we don't have enough spots, then grow the file list by 2 to account for the possible \n       loading of two images for PNP files */\n    if ((idx+1) >= gerbvProject->max_files) {\n\tgerbvProject->file = g_renew (gerbv_fileinfo_t *,\n\t\t\tgerbvProject->file, gerbvProject->max_files + 2);\n\n\tgerbvProject->file[gerbvProject->max_files] = NULL;\n\tgerbvProject->file[gerbvProject->max_files+1] = NULL;\n\tgerbvProject->max_files += 2;\n    }\n    \n    dprintf(\"In open_image, about to try opening filename = %s\\n\", filename);\n    \n    fd = gerb_fopen(filename);\n    if (fd == NULL) {\n\tGERB_COMPILE_ERROR(_(\"Trying to open \\\"%s\\\": %s\"),\n\t\t\tfilename, strerror(errno));\n\treturn -1;\n    }\n\n    dprintf(\"In open_image, successfully opened file.  Now check its type....\\n\");\n    /* Here's where we decide what file type we have */\n    /* Note: if the file has some invalid characters in it but still appears to\n       be a valid file, we check with the user if he wants to continue (only\n       if user opens the layer from the menu...if from the command line, we go\n       ahead and try to load it anyways) */\n\n    if (gerber_is_rs274x_p(fd, &foundBinary)) {\n\tdprintf(\"Found RS-274X file\\n\");\n\tif (!foundBinary || forceLoadFile) {\n\t\t/* figure out the directory path in case parse_gerb needs to\n\t\t * load any include files */\n\t\tgchar *currentLoadDirectory = g_path_get_dirname (filename);\n\t\tparsed_image = parse_gerb(fd, currentLoadDirectory);\n\t\tg_free (currentLoadDirectory);\n\t}\n    } else if(drill_file_p(fd, &foundBinary)) {\n\tdprintf(\"Found drill file\\n\");\n\tif (!foundBinary || forceLoadFile)\n\t    parsed_image = parse_drillfile(fd, attr_list, n_attr, reload);\n\t\n    } else if (pick_and_place_check_file_type(fd, &foundBinary)) {\n\tdprintf(\"Found pick-n-place file\\n\");\n\tif (!foundBinary || forceLoadFile) {\n\t\tif (!reload) {\n\t\t\tpick_and_place_parse_file_to_images(fd, &parsed_image, &parsed_image2);\n\t\t} else {\n\t\t\tswitch (gerbvProject->file[idx]->image->layertype) {\n\t\t\tcase GERBV_LAYERTYPE_PICKANDPLACE_TOP:\n\t\t\t\t/* Non NULL pointer is used as \"not to reload\" mark */\n\t\t\t\tparsed_image2 = (void *)!NULL;\n\t\t\t\tpick_and_place_parse_file_to_images(fd, &parsed_image, &parsed_image2);\n\t\t\t\tparsed_image2 = NULL;\n\t\t\t\tbreak;\n\t\t\tcase GERBV_LAYERTYPE_PICKANDPLACE_BOT:\n\t\t\t\t/* Non NULL pointer is used as \"not to reload\" mark */\n\t\t\t\tparsed_image2 = (void *)!NULL;\n\t\t\t\tpick_and_place_parse_file_to_images(fd, &parsed_image2, &parsed_image);\n\t\t\t\tparsed_image2 = NULL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tGERB_COMPILE_ERROR(_(\"%s: unknown pick-and-place board side to reload\"), filename);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tisPnpFile = TRUE;\n\t}\n    } else if (gerber_is_rs274d_p(fd)) {\n\tgchar *str = g_strdup_printf(_(\"Most likely found a RS-274D file \"\n\t\t\t\"\\\"%s\\\" ... trying to open anyways\\n\"), filename);\n\tdprintf(\"%s\", str);\n\tg_warning(\"%s\", str);\n\tg_free (str);\n\n\tif (!foundBinary || forceLoadFile) {\n\t\t/* figure out the directory path in case parse_gerb needs to\n\t\t * load any include files */\n\t\tgchar *currentLoadDirectory = g_path_get_dirname (filename);\n\t\tparsed_image = parse_gerb(fd, currentLoadDirectory);\n\t\tg_free (currentLoadDirectory);\n\t}\n    } else {\n\t/* This is not a known file */\n\tdprintf(\"Unknown filetype\");\n\tGERB_COMPILE_ERROR(_(\"%s: Unknown file type.\"), filename);\n\tparsed_image = NULL;\n    }\n    \n    gerb_fclose(fd);\n    if (parsed_image == NULL) {\n\treturn -1;\n    }\n    \n    if (parsed_image) {\n\t/* strip the filename to the base */\n\tgchar *baseName = g_path_get_basename (filename);\n\tgchar *displayedName;\n\tif (isPnpFile)\n\t\tdisplayedName = g_strconcat (baseName, _(\" (top)\"), NULL);\n\telse\n\t\tdisplayedName = g_strdup (baseName);\n    \tretv = gerbv_add_parsed_image_to_project (gerbvProject, parsed_image, filename, displayedName, idx, reload);\n    \tg_free (baseName);\n    \tg_free (displayedName);\n    }\n\n    /* Set layer_dirty flag to FALSE */\n    gerbvProject->file[idx]->layer_dirty = FALSE;\n\n    /* for PNP place files, we may need to add a second image for the other\n       board side */\n    if (parsed_image2) {\n      /* strip the filename to the base */\n\tgchar *baseName = g_path_get_basename (filename);\n\tgchar *displayedName;\n\tdisplayedName = g_strconcat (baseName, _(\" (bottom)\"), NULL);\n    \tretv = gerbv_add_parsed_image_to_project (gerbvProject, parsed_image2, filename, displayedName, idx + 1, reload);\n    \tg_free (baseName);\n    \tg_free (displayedName);\n    }\n\n    return retv;\n}",
        "description": "A user with control over file input to Gerbv, between versions 2.4.0 and 2.10.0, can trigger a crash and achieve a denial-of-service condition by providing a specially crafted Gerber RS-274X file.",
        "commit": "An out-of-bounds memory access vulnerability related to filename handling was identified. To address this, all filename allocation and deallocation have been centralized within the `gerb_fopen` and `gerb_fclose` functions, eliminating the need for the caller to manage these operations. Additionally, a previously allocated `includeFilename` was not being properly freed, which has now been corrected. Unit tests have been added to ensure proper memory management using Valgrind."
    },
    {
        "cwe": "CWE-385",
        "func_name": "openssl/ecdsa_sign_setup",
        "score": 0.7584820985794067,
        "func_before": "static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,\n\t\t\t\t\tBIGNUM **kinvp, BIGNUM **rp,\n\t\t\t\t\tconst unsigned char *dgst, int dlen)\n{\n\tBN_CTX   *ctx = NULL;\n\tBIGNUM\t *k = NULL, *r = NULL, *order = NULL, *X = NULL;\n\tEC_POINT *tmp_point=NULL;\n\tconst EC_GROUP *group;\n\tint \t ret = 0;\n\n\tif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\n\tif (ctx_in == NULL) \n\t{\n\t\tif ((ctx = BN_CTX_new()) == NULL)\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t\tctx = ctx_in;\n\n\tk     = BN_new();\t/* this value is later returned in *kinvp */\n\tr     = BN_new();\t/* this value is later returned in *rp    */\n\torder = BN_new();\n\tX     = BN_new();\n\tif (!k || !r || !order || !X)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t}\n\tif ((tmp_point = EC_POINT_new(group)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\tif (!EC_GROUP_get_order(group, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\n#ifdef OPENSSL_FIPS\n\tif (!fips_check_ec_prng(eckey))\n\t\tgoto err;\n#endif\n\t\n\tdo\n\t{\n\t\t/* get random k */\t\n\t\tdo\n#ifndef OPENSSL_NO_SHA512\n\t\t\tif (dgst != NULL)\n\t\t\t{\n\t\t\t\tif (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),\n\t\t\t\t\t\t\t   dgst, dlen, ctx))\n\t\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tif (!BN_rand_range(k, order))\n\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\twhile (BN_is_zero(k));\n\n\t\t/* We do not want timing information to leak the length of k,\n\t\t * so we compute G*k using an equivalent scalar of fixed\n\t\t * bit-length. */\n\n\t\tif (!BN_add(k, k, order)) goto err;\n\t\tif (BN_num_bits(k) <= BN_num_bits(order))\n\t\t\tif (!BN_add(k, k, order)) goto err;\n\n\t\t/* compute r the x-coordinate of generator * k */\n\t\tif (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t}\n\t\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#ifndef OPENSSL_NO_EC2M\n\t\telse /* NID_X9_62_characteristic_two_field */\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GF2m(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!BN_nnmod(r, X, order, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t}\n\t}\n\twhile (BN_is_zero(r));\n\n\t/* compute the inverse of k */\n\tif (!BN_mod_inverse(k, k, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\tgoto err;\t\n\t}\n\t/* clear old values if necessary */\n\tif (*rp != NULL)\n\t\tBN_clear_free(*rp);\n\tif (*kinvp != NULL) \n\t\tBN_clear_free(*kinvp);\n\t/* save the pre-computed values  */\n\t*rp    = r;\n\t*kinvp = k;\n\tret = 1;\nerr:\n\tif (!ret)\n\t{\n\t\tif (k != NULL) BN_clear_free(k);\n\t\tif (r != NULL) BN_clear_free(r);\n\t}\n\tif (ctx_in == NULL) \n\t\tBN_CTX_free(ctx);\n\tif (order != NULL)\n\t\tBN_free(order);\n\tif (tmp_point != NULL) \n\t\tEC_POINT_free(tmp_point);\n\tif (X)\n\t\tBN_clear_free(X);\n\treturn(ret);\n}",
        "func_after": "static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,\n\t\t\t\t\tBIGNUM **kinvp, BIGNUM **rp,\n\t\t\t\t\tconst unsigned char *dgst, int dlen)\n{\n\tBN_CTX   *ctx = NULL;\n\tBIGNUM\t *k = NULL, *r = NULL, *order = NULL, *X = NULL;\n\tEC_POINT *tmp_point=NULL;\n\tconst EC_GROUP *group;\n\tint \t ret = 0;\n\n\tif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn 0;\n\t}\n\n\tif (ctx_in == NULL) \n\t{\n\t\tif ((ctx = BN_CTX_new()) == NULL)\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t\tctx = ctx_in;\n\n\tk     = BN_new();\t/* this value is later returned in *kinvp */\n\tr     = BN_new();\t/* this value is later returned in *rp    */\n\torder = BN_new();\n\tX     = BN_new();\n\tif (!k || !r || !order || !X)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t}\n\tif ((tmp_point = EC_POINT_new(group)) == NULL)\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\tif (!EC_GROUP_get_order(group, order, ctx))\n\t{\n\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\tgoto err;\n\t}\n\n#ifdef OPENSSL_FIPS\n\tif (!fips_check_ec_prng(eckey))\n\t\tgoto err;\n#endif\n\t\n\tdo\n\t{\n\t\t/* get random k */\t\n\t\tdo\n#ifndef OPENSSL_NO_SHA512\n\t\t\tif (dgst != NULL)\n\t\t\t{\n\t\t\t\tif (!BN_generate_dsa_nonce(k, order, EC_KEY_get0_private_key(eckey),\n\t\t\t\t\t\t\t   dgst, dlen, ctx))\n\t\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t{\n\t\t\t\tif (!BN_rand_range(k, order))\n\t\t\t\t{\n\t\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\n\t\t\t\t\t\t ECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\twhile (BN_is_zero(k));\n\n\t\t/* We do not want timing information to leak the length of k,\n\t\t * so we compute G*k using an equivalent scalar of fixed\n\t\t * bit-length. */\n\n\t\tif (!BN_add(k, k, order)) goto err;\n\t\tif (BN_num_bits(k) <= BN_num_bits(order))\n\t\t\tif (!BN_add(k, k, order)) goto err;\n\n\t\t/* compute r the x-coordinate of generator * k */\n\t\tif (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\n\t\t\tgoto err;\n\t\t}\n\t\tif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#ifndef OPENSSL_NO_EC2M\n\t\telse /* NID_X9_62_characteristic_two_field */\n\t\t{\n\t\t\tif (!EC_POINT_get_affine_coordinates_GF2m(group,\n\t\t\t\ttmp_point, X, NULL, ctx))\n\t\t\t{\n\t\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!BN_nnmod(r, X, order, ctx))\n\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t}\n\t}\n\twhile (BN_is_zero(r));\n\n\t/* compute the inverse of k */\n\tif (EC_GROUP_get_mont_data(group) != NULL)\n\t\t{\n\t\t/* We want inverse in constant time, therefore we utilize the\n\t\t * fact order must be prime and use Fermats Little Theorem\n\t\t * instead. */\n\t\tif (!BN_set_word(X, 2) )\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tif (!BN_mod_sub(X, order, X, order, ctx))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tBN_set_flags(X, BN_FLG_CONSTTIME);\n\t\tif (!BN_mod_exp_mont_consttime(k, k, X, order, ctx, EC_GROUP_get_mont_data(group)))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tif (!BN_mod_inverse(k, k, order, ctx))\n\t\t\t{\n\t\t\tECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\n\t\t\tgoto err;\t\n\t\t\t}\n\t\t}\n\n\t/* clear old values if necessary */\n\tif (*rp != NULL)\n\t\tBN_clear_free(*rp);\n\tif (*kinvp != NULL) \n\t\tBN_clear_free(*kinvp);\n\t/* save the pre-computed values  */\n\t*rp    = r;\n\t*kinvp = k;\n\tret = 1;\nerr:\n\tif (!ret)\n\t{\n\t\tif (k != NULL) BN_clear_free(k);\n\t\tif (r != NULL) BN_clear_free(r);\n\t}\n\tif (ctx_in == NULL) \n\t\tBN_CTX_free(ctx);\n\tif (order != NULL)\n\t\tBN_free(order);\n\tif (tmp_point != NULL) \n\t\tEC_POINT_free(tmp_point);\n\tif (X)\n\t\tBN_clear_free(X);\n\treturn(ret);\n}",
        "description": "A timing attack vulnerability was identified in OpenSSL versions prior to 1.0.1u, enabling a malicious user with local access to potentially recover ECDSA P-256 private keys through the exploitation of timing variations in cryptographic operations.",
        "commit": "The vulnerability knowledge has been abstracted and generalized as follows:\n\n\"The implementation of ECDSA includes an option to utilize BN_mod_exp_mont_consttime, a constant-time modular exponentiation function. This enhancement aims to improve the security of ECDSA operations.\""
    },
    {
        "cwe": "CWE-191",
        "func_name": "torvalds/deassemble_neg_contexts",
        "score": 0.7669223546981812,
        "func_before": "static __le32 deassemble_neg_contexts(struct ksmbd_conn *conn,\n\t\t\t\t      struct smb2_negotiate_req *req,\n\t\t\t\t      int len_of_smb)\n{\n\t/* +4 is to account for the RFC1001 len field */\n\tstruct smb2_neg_context *pctx = (struct smb2_neg_context *)req;\n\tint i = 0, len_of_ctxts;\n\tint offset = le32_to_cpu(req->NegotiateContextOffset);\n\tint neg_ctxt_cnt = le16_to_cpu(req->NegotiateContextCount);\n\t__le32 status = STATUS_INVALID_PARAMETER;\n\n\tksmbd_debug(SMB, \"decoding %d negotiate contexts\\n\", neg_ctxt_cnt);\n\tif (len_of_smb <= offset) {\n\t\tksmbd_debug(SMB, \"Invalid response: negotiate context offset\\n\");\n\t\treturn status;\n\t}\n\n\tlen_of_ctxts = len_of_smb - offset;\n\n\twhile (i++ < neg_ctxt_cnt) {\n\t\tint clen, ctxt_len;\n\n\t\tif (len_of_ctxts < sizeof(struct smb2_neg_context))\n\t\t\tbreak;\n\n\t\tpctx = (struct smb2_neg_context *)((char *)pctx + offset);\n\t\tclen = le16_to_cpu(pctx->DataLength);\n\t\tctxt_len = clen + sizeof(struct smb2_neg_context);\n\n\t\tif (ctxt_len > len_of_ctxts)\n\t\t\tbreak;\n\n\t\tif (pctx->ContextType == SMB2_PREAUTH_INTEGRITY_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_PREAUTH_INTEGRITY_CAPABILITIES context\\n\");\n\t\t\tif (conn->preauth_info->Preauth_HashId)\n\t\t\t\tbreak;\n\n\t\t\tstatus = decode_preauth_ctxt(conn,\n\t\t\t\t\t\t     (struct smb2_preauth_neg_context *)pctx,\n\t\t\t\t\t\t     ctxt_len);\n\t\t\tif (status != STATUS_SUCCESS)\n\t\t\t\tbreak;\n\t\t} else if (pctx->ContextType == SMB2_ENCRYPTION_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_ENCRYPTION_CAPABILITIES context\\n\");\n\t\t\tif (conn->cipher_type)\n\t\t\t\tbreak;\n\n\t\t\tdecode_encrypt_ctxt(conn,\n\t\t\t\t\t    (struct smb2_encryption_neg_context *)pctx,\n\t\t\t\t\t    ctxt_len);\n\t\t} else if (pctx->ContextType == SMB2_COMPRESSION_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_COMPRESSION_CAPABILITIES context\\n\");\n\t\t\tif (conn->compress_algorithm)\n\t\t\t\tbreak;\n\n\t\t\tdecode_compress_ctxt(conn,\n\t\t\t\t\t     (struct smb2_compression_capabilities_context *)pctx);\n\t\t} else if (pctx->ContextType == SMB2_NETNAME_NEGOTIATE_CONTEXT_ID) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_NETNAME_NEGOTIATE_CONTEXT_ID context\\n\");\n\t\t} else if (pctx->ContextType == SMB2_POSIX_EXTENSIONS_AVAILABLE) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_POSIX_EXTENSIONS_AVAILABLE context\\n\");\n\t\t\tconn->posix_ext_supported = true;\n\t\t} else if (pctx->ContextType == SMB2_SIGNING_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_SIGNING_CAPABILITIES context\\n\");\n\n\t\t\tdecode_sign_cap_ctxt(conn,\n\t\t\t\t\t     (struct smb2_signing_capabilities *)pctx,\n\t\t\t\t\t     ctxt_len);\n\t\t}\n\n\t\t/* offsets must be 8 byte aligned */\n\t\tclen = (clen + 7) & ~0x7;\n\t\toffset = clen + sizeof(struct smb2_neg_context);\n\t\tlen_of_ctxts -= clen + sizeof(struct smb2_neg_context);\n\t}\n\treturn status;\n}",
        "func_after": "static __le32 deassemble_neg_contexts(struct ksmbd_conn *conn,\n\t\t\t\t      struct smb2_negotiate_req *req,\n\t\t\t\t      unsigned int len_of_smb)\n{\n\t/* +4 is to account for the RFC1001 len field */\n\tstruct smb2_neg_context *pctx = (struct smb2_neg_context *)req;\n\tint i = 0, len_of_ctxts;\n\tunsigned int offset = le32_to_cpu(req->NegotiateContextOffset);\n\tunsigned int neg_ctxt_cnt = le16_to_cpu(req->NegotiateContextCount);\n\t__le32 status = STATUS_INVALID_PARAMETER;\n\n\tksmbd_debug(SMB, \"decoding %d negotiate contexts\\n\", neg_ctxt_cnt);\n\tif (len_of_smb <= offset) {\n\t\tksmbd_debug(SMB, \"Invalid response: negotiate context offset\\n\");\n\t\treturn status;\n\t}\n\n\tlen_of_ctxts = len_of_smb - offset;\n\n\twhile (i++ < neg_ctxt_cnt) {\n\t\tint clen, ctxt_len;\n\n\t\tif (len_of_ctxts < (int)sizeof(struct smb2_neg_context))\n\t\t\tbreak;\n\n\t\tpctx = (struct smb2_neg_context *)((char *)pctx + offset);\n\t\tclen = le16_to_cpu(pctx->DataLength);\n\t\tctxt_len = clen + sizeof(struct smb2_neg_context);\n\n\t\tif (ctxt_len > len_of_ctxts)\n\t\t\tbreak;\n\n\t\tif (pctx->ContextType == SMB2_PREAUTH_INTEGRITY_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_PREAUTH_INTEGRITY_CAPABILITIES context\\n\");\n\t\t\tif (conn->preauth_info->Preauth_HashId)\n\t\t\t\tbreak;\n\n\t\t\tstatus = decode_preauth_ctxt(conn,\n\t\t\t\t\t\t     (struct smb2_preauth_neg_context *)pctx,\n\t\t\t\t\t\t     ctxt_len);\n\t\t\tif (status != STATUS_SUCCESS)\n\t\t\t\tbreak;\n\t\t} else if (pctx->ContextType == SMB2_ENCRYPTION_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_ENCRYPTION_CAPABILITIES context\\n\");\n\t\t\tif (conn->cipher_type)\n\t\t\t\tbreak;\n\n\t\t\tdecode_encrypt_ctxt(conn,\n\t\t\t\t\t    (struct smb2_encryption_neg_context *)pctx,\n\t\t\t\t\t    ctxt_len);\n\t\t} else if (pctx->ContextType == SMB2_COMPRESSION_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_COMPRESSION_CAPABILITIES context\\n\");\n\t\t\tif (conn->compress_algorithm)\n\t\t\t\tbreak;\n\n\t\t\tdecode_compress_ctxt(conn,\n\t\t\t\t\t     (struct smb2_compression_capabilities_context *)pctx);\n\t\t} else if (pctx->ContextType == SMB2_NETNAME_NEGOTIATE_CONTEXT_ID) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_NETNAME_NEGOTIATE_CONTEXT_ID context\\n\");\n\t\t} else if (pctx->ContextType == SMB2_POSIX_EXTENSIONS_AVAILABLE) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_POSIX_EXTENSIONS_AVAILABLE context\\n\");\n\t\t\tconn->posix_ext_supported = true;\n\t\t} else if (pctx->ContextType == SMB2_SIGNING_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_SIGNING_CAPABILITIES context\\n\");\n\n\t\t\tdecode_sign_cap_ctxt(conn,\n\t\t\t\t\t     (struct smb2_signing_capabilities *)pctx,\n\t\t\t\t\t     ctxt_len);\n\t\t}\n\n\t\t/* offsets must be 8 byte aligned */\n\t\toffset = (ctxt_len + 7) & ~0x7;\n\t\tlen_of_ctxts -= offset;\n\t}\n\treturn status;\n}",
        "description": "An issue was discovered in the Linux kernel prior to version 6.3.8. Within the ksmbd component located in the SMB server directory, there is an integer underflow and out-of-bounds read vulnerability in the deassemble_neg_contexts function.",
        "commit": "The vulnerability involves an integer underflow condition in the SMB2 protocol negotiation process within the Linux kernel. Specifically, the initial check compares `clen + sizeof(struct smb2_neg_context)` against `len_of_ctxts`. However, during the loop, `len_of_ctxts` is decremented by `((clen + 7) & ~0x7) + sizeof(struct smb2_neg_context)`, which can lead to an underflow if `clen` undergoes 8-byte alignment. To prevent this, the check should use `(clen + 7) & ~0x7` instead. Additionally, certain variables should be declared as unsigned to avoid similar issues. The vulnerability results in a slab-out-of-bounds read error, as indicated by the kernel log, leading to potential memory corruption and system instability."
    }
]