[
    {
        "cwe": "CWE-191",
        "func_name": "torvalds/deassemble_neg_contexts",
        "score": 0.7779625058174133,
        "func_before": "static __le32 deassemble_neg_contexts(struct ksmbd_conn *conn,\n\t\t\t\t      struct smb2_negotiate_req *req,\n\t\t\t\t      int len_of_smb)\n{\n\t/* +4 is to account for the RFC1001 len field */\n\tstruct smb2_neg_context *pctx = (struct smb2_neg_context *)req;\n\tint i = 0, len_of_ctxts;\n\tint offset = le32_to_cpu(req->NegotiateContextOffset);\n\tint neg_ctxt_cnt = le16_to_cpu(req->NegotiateContextCount);\n\t__le32 status = STATUS_INVALID_PARAMETER;\n\n\tksmbd_debug(SMB, \"decoding %d negotiate contexts\\n\", neg_ctxt_cnt);\n\tif (len_of_smb <= offset) {\n\t\tksmbd_debug(SMB, \"Invalid response: negotiate context offset\\n\");\n\t\treturn status;\n\t}\n\n\tlen_of_ctxts = len_of_smb - offset;\n\n\twhile (i++ < neg_ctxt_cnt) {\n\t\tint clen, ctxt_len;\n\n\t\tif (len_of_ctxts < sizeof(struct smb2_neg_context))\n\t\t\tbreak;\n\n\t\tpctx = (struct smb2_neg_context *)((char *)pctx + offset);\n\t\tclen = le16_to_cpu(pctx->DataLength);\n\t\tctxt_len = clen + sizeof(struct smb2_neg_context);\n\n\t\tif (ctxt_len > len_of_ctxts)\n\t\t\tbreak;\n\n\t\tif (pctx->ContextType == SMB2_PREAUTH_INTEGRITY_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_PREAUTH_INTEGRITY_CAPABILITIES context\\n\");\n\t\t\tif (conn->preauth_info->Preauth_HashId)\n\t\t\t\tbreak;\n\n\t\t\tstatus = decode_preauth_ctxt(conn,\n\t\t\t\t\t\t     (struct smb2_preauth_neg_context *)pctx,\n\t\t\t\t\t\t     ctxt_len);\n\t\t\tif (status != STATUS_SUCCESS)\n\t\t\t\tbreak;\n\t\t} else if (pctx->ContextType == SMB2_ENCRYPTION_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_ENCRYPTION_CAPABILITIES context\\n\");\n\t\t\tif (conn->cipher_type)\n\t\t\t\tbreak;\n\n\t\t\tdecode_encrypt_ctxt(conn,\n\t\t\t\t\t    (struct smb2_encryption_neg_context *)pctx,\n\t\t\t\t\t    ctxt_len);\n\t\t} else if (pctx->ContextType == SMB2_COMPRESSION_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_COMPRESSION_CAPABILITIES context\\n\");\n\t\t\tif (conn->compress_algorithm)\n\t\t\t\tbreak;\n\n\t\t\tdecode_compress_ctxt(conn,\n\t\t\t\t\t     (struct smb2_compression_capabilities_context *)pctx);\n\t\t} else if (pctx->ContextType == SMB2_NETNAME_NEGOTIATE_CONTEXT_ID) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_NETNAME_NEGOTIATE_CONTEXT_ID context\\n\");\n\t\t} else if (pctx->ContextType == SMB2_POSIX_EXTENSIONS_AVAILABLE) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_POSIX_EXTENSIONS_AVAILABLE context\\n\");\n\t\t\tconn->posix_ext_supported = true;\n\t\t} else if (pctx->ContextType == SMB2_SIGNING_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_SIGNING_CAPABILITIES context\\n\");\n\n\t\t\tdecode_sign_cap_ctxt(conn,\n\t\t\t\t\t     (struct smb2_signing_capabilities *)pctx,\n\t\t\t\t\t     ctxt_len);\n\t\t}\n\n\t\t/* offsets must be 8 byte aligned */\n\t\tclen = (clen + 7) & ~0x7;\n\t\toffset = clen + sizeof(struct smb2_neg_context);\n\t\tlen_of_ctxts -= clen + sizeof(struct smb2_neg_context);\n\t}\n\treturn status;\n}",
        "func_after": "static __le32 deassemble_neg_contexts(struct ksmbd_conn *conn,\n\t\t\t\t      struct smb2_negotiate_req *req,\n\t\t\t\t      unsigned int len_of_smb)\n{\n\t/* +4 is to account for the RFC1001 len field */\n\tstruct smb2_neg_context *pctx = (struct smb2_neg_context *)req;\n\tint i = 0, len_of_ctxts;\n\tunsigned int offset = le32_to_cpu(req->NegotiateContextOffset);\n\tunsigned int neg_ctxt_cnt = le16_to_cpu(req->NegotiateContextCount);\n\t__le32 status = STATUS_INVALID_PARAMETER;\n\n\tksmbd_debug(SMB, \"decoding %d negotiate contexts\\n\", neg_ctxt_cnt);\n\tif (len_of_smb <= offset) {\n\t\tksmbd_debug(SMB, \"Invalid response: negotiate context offset\\n\");\n\t\treturn status;\n\t}\n\n\tlen_of_ctxts = len_of_smb - offset;\n\n\twhile (i++ < neg_ctxt_cnt) {\n\t\tint clen, ctxt_len;\n\n\t\tif (len_of_ctxts < (int)sizeof(struct smb2_neg_context))\n\t\t\tbreak;\n\n\t\tpctx = (struct smb2_neg_context *)((char *)pctx + offset);\n\t\tclen = le16_to_cpu(pctx->DataLength);\n\t\tctxt_len = clen + sizeof(struct smb2_neg_context);\n\n\t\tif (ctxt_len > len_of_ctxts)\n\t\t\tbreak;\n\n\t\tif (pctx->ContextType == SMB2_PREAUTH_INTEGRITY_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_PREAUTH_INTEGRITY_CAPABILITIES context\\n\");\n\t\t\tif (conn->preauth_info->Preauth_HashId)\n\t\t\t\tbreak;\n\n\t\t\tstatus = decode_preauth_ctxt(conn,\n\t\t\t\t\t\t     (struct smb2_preauth_neg_context *)pctx,\n\t\t\t\t\t\t     ctxt_len);\n\t\t\tif (status != STATUS_SUCCESS)\n\t\t\t\tbreak;\n\t\t} else if (pctx->ContextType == SMB2_ENCRYPTION_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_ENCRYPTION_CAPABILITIES context\\n\");\n\t\t\tif (conn->cipher_type)\n\t\t\t\tbreak;\n\n\t\t\tdecode_encrypt_ctxt(conn,\n\t\t\t\t\t    (struct smb2_encryption_neg_context *)pctx,\n\t\t\t\t\t    ctxt_len);\n\t\t} else if (pctx->ContextType == SMB2_COMPRESSION_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_COMPRESSION_CAPABILITIES context\\n\");\n\t\t\tif (conn->compress_algorithm)\n\t\t\t\tbreak;\n\n\t\t\tdecode_compress_ctxt(conn,\n\t\t\t\t\t     (struct smb2_compression_capabilities_context *)pctx);\n\t\t} else if (pctx->ContextType == SMB2_NETNAME_NEGOTIATE_CONTEXT_ID) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_NETNAME_NEGOTIATE_CONTEXT_ID context\\n\");\n\t\t} else if (pctx->ContextType == SMB2_POSIX_EXTENSIONS_AVAILABLE) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_POSIX_EXTENSIONS_AVAILABLE context\\n\");\n\t\t\tconn->posix_ext_supported = true;\n\t\t} else if (pctx->ContextType == SMB2_SIGNING_CAPABILITIES) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"deassemble SMB2_SIGNING_CAPABILITIES context\\n\");\n\n\t\t\tdecode_sign_cap_ctxt(conn,\n\t\t\t\t\t     (struct smb2_signing_capabilities *)pctx,\n\t\t\t\t\t     ctxt_len);\n\t\t}\n\n\t\t/* offsets must be 8 byte aligned */\n\t\toffset = (ctxt_len + 7) & ~0x7;\n\t\tlen_of_ctxts -= offset;\n\t}\n\treturn status;\n}",
        "description": "An issue was discovered in the Linux kernel prior to version 6.3.8. Within the ksmbd component located in the SMB server directory, there is an integer underflow and out-of-bounds read vulnerability in the deassemble_neg_contexts function.",
        "commit": "The vulnerability involves an integer underflow condition in the SMB2 protocol negotiation process within the Linux kernel. Specifically, the initial check compares `clen + sizeof(struct smb2_neg_context)` against `len_of_ctxts`. However, during the loop, `len_of_ctxts` is decremented by `((clen + 7) & ~0x7) + sizeof(struct smb2_neg_context)`, which can lead to an underflow if `clen` undergoes 8-byte alignment. To prevent this, the check should use `(clen + 7) & ~0x7` instead. Additionally, certain variables should be declared as unsigned to avoid similar issues. The vulnerability results in a slab-out-of-bounds read error, as indicated by the kernel log, leading to potential memory corruption and system instability."
    },
    {
        "cwe": "CWE-444",
        "func_name": "haproxy/http_parse_cont_len_header",
        "score": 0.7538179159164429,
        "func_before": "int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\n\tword.ptr = value->ptr - 1; // -1 for next loop's pre-increment\n\te = value->ptr + value->len;\n\n\twhile (++word.ptr < e) {\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\t*body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}",
        "func_after": "int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\n\tword.ptr = value->ptr;\n\te = value->ptr + value->len;\n\n\twhile (1) {\n\t\tif (word.ptr >= e) {\n\t\t\t/* empty header or empty value */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr))) {\n\t\t\tword.ptr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\t*body_len = cl;\n\t\t*value = word;\n\n\t\t/* Now either n==e and we're done, or n points to the comma,\n\t\t * and we skip it and continue.\n\t\t */\n\t\tif (n++ == e)\n\t\t\tbreak;\n\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}",
        "description": "HAProxy versions up to 2.0.32, 2.1.x, 2.2.x through 2.2.30, 2.3.x, 2.4.x through 2.4.23, 2.5.x, and 2.6.x before 2.6.15, 2.7.x before 2.7.10, and 2.8.x before 2.8.2 forward empty Content-Length headers, which violates RFC 9110 section 8.6. In rare scenarios, an HTTP/1 server positioned behind HAProxy may misinterpret the payload as an additional request.",
        "commit": "A vulnerability was identified in the HTTP content-length header parsing mechanism, where an empty or trailing-comma value could be misinterpreted as an absent header. This oversight allowed such headers to pass through to the backend server without proper validation, potentially exposing vulnerable servers to attacks. The risk varies based on the backend server's handling of content-length headers, but users relying on HAProxy to protect known-vulnerable servers are particularly at risk. A configuration-based workaround involves explicitly rejecting requests with empty content-length headers in the frontend settings. The permanent fix requires modifying the parser to ensure that only valid values are accepted, rejecting any empty values encountered. This change needs to be applied across all supported versions of the software. The modifications were made to functions such as `h1_parse_cont_len_header()` and `http_parse_cont_len_header()`, with additional considerations for compatibility with Lua and future deprecation plans. Comprehensive testing was conducted to validate these changes."
    },
    {
        "cwe": "CWE-193",
        "func_name": "torvalds/ext4_ext_insert_extent",
        "score": 0.7780264616012573,
        "func_before": "int ext4_ext_insert_extent(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_ext_path *path,\n\t\t\t\tstruct ext4_extent *newext, int flag)\n{\n\tstruct ext4_extent_header *eh;\n\tstruct ext4_extent *ex, *fex;\n\tstruct ext4_extent *nearex; /* nearest extent */\n\tstruct ext4_ext_path *npath = NULL;\n\tint depth, len, err;\n\text4_lblk_t next;\n\tunsigned uninitialized = 0;\n\tint flags = 0;\n\n\tif (unlikely(ext4_ext_get_actual_len(newext) == 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"ext4_ext_get_actual_len(newext) == 0\");\n\t\treturn -EIO;\n\t}\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tif (unlikely(path[depth].p_hdr == NULL)) {\n\t\tEXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);\n\t\treturn -EIO;\n\t}\n\n\t/* try to insert block into found extent and return */\n\tif (ex && !(flag & EXT4_GET_BLOCKS_PRE_IO)\n\t\t&& ext4_can_extents_be_merged(inode, ex, newext)) {\n\t\text_debug(\"append [%d]%d block to %d:[%d]%d (from %llu)\\n\",\n\t\t\t  ext4_ext_is_uninitialized(newext),\n\t\t\t  ext4_ext_get_actual_len(newext),\n\t\t\t  le32_to_cpu(ex->ee_block),\n\t\t\t  ext4_ext_is_uninitialized(ex),\n\t\t\t  ext4_ext_get_actual_len(ex),\n\t\t\t  ext4_ext_pblock(ex));\n\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t/*\n\t\t * ext4_can_extents_be_merged should have checked that either\n\t\t * both extents are uninitialized, or both aren't. Thus we\n\t\t * need to check only one of them here.\n\t\t */\n\t\tif (ext4_ext_is_uninitialized(ex))\n\t\t\tuninitialized = 1;\n\t\tex->ee_len = cpu_to_le16(ext4_ext_get_actual_len(ex)\n\t\t\t\t\t+ ext4_ext_get_actual_len(newext));\n\t\tif (uninitialized)\n\t\t\text4_ext_mark_uninitialized(ex);\n\t\teh = path[depth].p_hdr;\n\t\tnearex = ex;\n\t\tgoto merge;\n\t}\n\nrepeat:\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max))\n\t\tgoto has_space;\n\n\t/* probably next leaf has space for us? */\n\tfex = EXT_LAST_EXTENT(eh);\n\tnext = ext4_ext_next_leaf_block(inode, path);\n\tif (le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block)\n\t    && next != EXT_MAX_BLOCK) {\n\t\text_debug(\"next leaf block - %d\\n\", next);\n\t\tBUG_ON(npath != NULL);\n\t\tnpath = ext4_ext_find_extent(inode, next, NULL);\n\t\tif (IS_ERR(npath))\n\t\t\treturn PTR_ERR(npath);\n\t\tBUG_ON(npath->p_depth != path->p_depth);\n\t\teh = npath[depth].p_hdr;\n\t\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)) {\n\t\t\text_debug(\"next leaf isn't full(%d)\\n\",\n\t\t\t\t  le16_to_cpu(eh->eh_entries));\n\t\t\tpath = npath;\n\t\t\tgoto repeat;\n\t\t}\n\t\text_debug(\"next leaf has no free space(%d,%d)\\n\",\n\t\t\t  le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\n\t}\n\n\t/*\n\t * There is no free space in the found leaf.\n\t * We're gonna add a new leaf in the tree.\n\t */\n\tif (flag & EXT4_GET_BLOCKS_PUNCH_OUT_EXT)\n\t\tflags = EXT4_MB_USE_ROOT_BLOCKS;\n\terr = ext4_ext_create_new_leaf(handle, inode, flags, path, newext);\n\tif (err)\n\t\tgoto cleanup;\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\nhas_space:\n\tnearex = path[depth].p_ext;\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (!nearex) {\n\t\t/* there is no extent in this leaf, create first one */\n\t\text_debug(\"first extent in the leaf: %d:%llu:[%d]%d\\n\",\n\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\text4_ext_pblock(newext),\n\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\text4_ext_get_actual_len(newext));\n\t\tpath[depth].p_ext = EXT_FIRST_EXTENT(eh);\n\t} else if (le32_to_cpu(newext->ee_block)\n\t\t\t   > le32_to_cpu(nearex->ee_block)) {\n/*\t\tBUG_ON(newext->ee_block == nearex->ee_block); */\n\t\tif (nearex != EXT_LAST_EXTENT(eh)) {\n\t\t\tlen = EXT_MAX_EXTENT(eh) - nearex;\n\t\t\tlen = (len - 1) * sizeof(struct ext4_extent);\n\t\t\tlen = len < 0 ? 0 : len;\n\t\t\text_debug(\"insert %d:%llu:[%d]%d after: nearest 0x%p, \"\n\t\t\t\t\t\"move %d from 0x%p to 0x%p\\n\",\n\t\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\t\text4_ext_pblock(newext),\n\t\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\t\tnearex, len, nearex + 1, nearex + 2);\n\t\t\tmemmove(nearex + 2, nearex + 1, len);\n\t\t}\n\t\tpath[depth].p_ext = nearex + 1;\n\t} else {\n\t\tBUG_ON(newext->ee_block == nearex->ee_block);\n\t\tlen = (EXT_MAX_EXTENT(eh) - nearex) * sizeof(struct ext4_extent);\n\t\tlen = len < 0 ? 0 : len;\n\t\text_debug(\"insert %d:%llu:[%d]%d before: nearest 0x%p, \"\n\t\t\t\t\"move %d from 0x%p to 0x%p\\n\",\n\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\text4_ext_pblock(newext),\n\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\tnearex, len, nearex + 1, nearex + 2);\n\t\tmemmove(nearex + 1, nearex, len);\n\t\tpath[depth].p_ext = nearex;\n\t}\n\n\tle16_add_cpu(&eh->eh_entries, 1);\n\tnearex = path[depth].p_ext;\n\tnearex->ee_block = newext->ee_block;\n\text4_ext_store_pblock(nearex, ext4_ext_pblock(newext));\n\tnearex->ee_len = newext->ee_len;\n\nmerge:\n\t/* try to merge extents to the right */\n\tif (!(flag & EXT4_GET_BLOCKS_PRE_IO))\n\t\text4_ext_try_to_merge(inode, path, nearex);\n\n\t/* try to merge extents to the left */\n\n\t/* time to correct all indexes above */\n\terr = ext4_ext_correct_indexes(handle, inode, path);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = ext4_ext_dirty(handle, inode, path + depth);\n\ncleanup:\n\tif (npath) {\n\t\text4_ext_drop_refs(npath);\n\t\tkfree(npath);\n\t}\n\text4_ext_invalidate_cache(inode);\n\treturn err;\n}",
        "func_after": "int ext4_ext_insert_extent(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_ext_path *path,\n\t\t\t\tstruct ext4_extent *newext, int flag)\n{\n\tstruct ext4_extent_header *eh;\n\tstruct ext4_extent *ex, *fex;\n\tstruct ext4_extent *nearex; /* nearest extent */\n\tstruct ext4_ext_path *npath = NULL;\n\tint depth, len, err;\n\text4_lblk_t next;\n\tunsigned uninitialized = 0;\n\tint flags = 0;\n\n\tif (unlikely(ext4_ext_get_actual_len(newext) == 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"ext4_ext_get_actual_len(newext) == 0\");\n\t\treturn -EIO;\n\t}\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tif (unlikely(path[depth].p_hdr == NULL)) {\n\t\tEXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);\n\t\treturn -EIO;\n\t}\n\n\t/* try to insert block into found extent and return */\n\tif (ex && !(flag & EXT4_GET_BLOCKS_PRE_IO)\n\t\t&& ext4_can_extents_be_merged(inode, ex, newext)) {\n\t\text_debug(\"append [%d]%d block to %d:[%d]%d (from %llu)\\n\",\n\t\t\t  ext4_ext_is_uninitialized(newext),\n\t\t\t  ext4_ext_get_actual_len(newext),\n\t\t\t  le32_to_cpu(ex->ee_block),\n\t\t\t  ext4_ext_is_uninitialized(ex),\n\t\t\t  ext4_ext_get_actual_len(ex),\n\t\t\t  ext4_ext_pblock(ex));\n\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t/*\n\t\t * ext4_can_extents_be_merged should have checked that either\n\t\t * both extents are uninitialized, or both aren't. Thus we\n\t\t * need to check only one of them here.\n\t\t */\n\t\tif (ext4_ext_is_uninitialized(ex))\n\t\t\tuninitialized = 1;\n\t\tex->ee_len = cpu_to_le16(ext4_ext_get_actual_len(ex)\n\t\t\t\t\t+ ext4_ext_get_actual_len(newext));\n\t\tif (uninitialized)\n\t\t\text4_ext_mark_uninitialized(ex);\n\t\teh = path[depth].p_hdr;\n\t\tnearex = ex;\n\t\tgoto merge;\n\t}\n\nrepeat:\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max))\n\t\tgoto has_space;\n\n\t/* probably next leaf has space for us? */\n\tfex = EXT_LAST_EXTENT(eh);\n\tnext = ext4_ext_next_leaf_block(inode, path);\n\tif (le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block)\n\t    && next != EXT_MAX_BLOCKS) {\n\t\text_debug(\"next leaf block - %d\\n\", next);\n\t\tBUG_ON(npath != NULL);\n\t\tnpath = ext4_ext_find_extent(inode, next, NULL);\n\t\tif (IS_ERR(npath))\n\t\t\treturn PTR_ERR(npath);\n\t\tBUG_ON(npath->p_depth != path->p_depth);\n\t\teh = npath[depth].p_hdr;\n\t\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)) {\n\t\t\text_debug(\"next leaf isn't full(%d)\\n\",\n\t\t\t\t  le16_to_cpu(eh->eh_entries));\n\t\t\tpath = npath;\n\t\t\tgoto repeat;\n\t\t}\n\t\text_debug(\"next leaf has no free space(%d,%d)\\n\",\n\t\t\t  le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\n\t}\n\n\t/*\n\t * There is no free space in the found leaf.\n\t * We're gonna add a new leaf in the tree.\n\t */\n\tif (flag & EXT4_GET_BLOCKS_PUNCH_OUT_EXT)\n\t\tflags = EXT4_MB_USE_ROOT_BLOCKS;\n\terr = ext4_ext_create_new_leaf(handle, inode, flags, path, newext);\n\tif (err)\n\t\tgoto cleanup;\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\nhas_space:\n\tnearex = path[depth].p_ext;\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto cleanup;\n\n\tif (!nearex) {\n\t\t/* there is no extent in this leaf, create first one */\n\t\text_debug(\"first extent in the leaf: %d:%llu:[%d]%d\\n\",\n\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\text4_ext_pblock(newext),\n\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\text4_ext_get_actual_len(newext));\n\t\tpath[depth].p_ext = EXT_FIRST_EXTENT(eh);\n\t} else if (le32_to_cpu(newext->ee_block)\n\t\t\t   > le32_to_cpu(nearex->ee_block)) {\n/*\t\tBUG_ON(newext->ee_block == nearex->ee_block); */\n\t\tif (nearex != EXT_LAST_EXTENT(eh)) {\n\t\t\tlen = EXT_MAX_EXTENT(eh) - nearex;\n\t\t\tlen = (len - 1) * sizeof(struct ext4_extent);\n\t\t\tlen = len < 0 ? 0 : len;\n\t\t\text_debug(\"insert %d:%llu:[%d]%d after: nearest 0x%p, \"\n\t\t\t\t\t\"move %d from 0x%p to 0x%p\\n\",\n\t\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\t\text4_ext_pblock(newext),\n\t\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\t\tnearex, len, nearex + 1, nearex + 2);\n\t\t\tmemmove(nearex + 2, nearex + 1, len);\n\t\t}\n\t\tpath[depth].p_ext = nearex + 1;\n\t} else {\n\t\tBUG_ON(newext->ee_block == nearex->ee_block);\n\t\tlen = (EXT_MAX_EXTENT(eh) - nearex) * sizeof(struct ext4_extent);\n\t\tlen = len < 0 ? 0 : len;\n\t\text_debug(\"insert %d:%llu:[%d]%d before: nearest 0x%p, \"\n\t\t\t\t\"move %d from 0x%p to 0x%p\\n\",\n\t\t\t\tle32_to_cpu(newext->ee_block),\n\t\t\t\text4_ext_pblock(newext),\n\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\tnearex, len, nearex + 1, nearex + 2);\n\t\tmemmove(nearex + 1, nearex, len);\n\t\tpath[depth].p_ext = nearex;\n\t}\n\n\tle16_add_cpu(&eh->eh_entries, 1);\n\tnearex = path[depth].p_ext;\n\tnearex->ee_block = newext->ee_block;\n\text4_ext_store_pblock(nearex, ext4_ext_pblock(newext));\n\tnearex->ee_len = newext->ee_len;\n\nmerge:\n\t/* try to merge extents to the right */\n\tif (!(flag & EXT4_GET_BLOCKS_PRE_IO))\n\t\text4_ext_try_to_merge(inode, path, nearex);\n\n\t/* try to merge extents to the left */\n\n\t/* time to correct all indexes above */\n\terr = ext4_ext_correct_indexes(handle, inode, path);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = ext4_ext_dirty(handle, inode, path + depth);\n\ncleanup:\n\tif (npath) {\n\t\text4_ext_drop_refs(npath);\n\t\tkfree(npath);\n\t}\n\text4_ext_invalidate_cache(inode);\n\treturn err;\n}",
        "description": "Multiple off-by-one errors in the ext4 subsystem of the Linux kernel, prior to a specific release candidate, enable local users to trigger a denial of service (resulting in BUG_ON and system crashes) through write operations on sparse files in extent format, particularly when the block number corresponds to the maximum possible 32-bit unsigned integer.",
        "commit": "A vulnerability was identified in the ext4 file system where writing to the last block (2^32-1) of a sparse file in extent format triggers a BUG_ON condition in the ext4_ext_put_gap_in_cache() function. The root cause is that the maximum bytes (s_maxbytes) are set such that the block at s_maxbytes fits into a 32-bit on-disk extent format, but the extent structure stores start block number and length in blocks, requiring EXT_MAX_BLOCK + 1 to cover the entire extent range. To resolve this issue without altering the struct ext4_extent members' meanings, s_maxbytes should be reduced by one filesystem block. Additionally, the commit renames EXT_MAX_BLOCK to EXT_MAX_BLOCKS and adjusts its usage to represent the maximum number of blocks in an extent, addressing inconsistencies in its application throughout the codebase. This bug can be reproduced by sequentially writing to the second-to-last and last blocks of a sparse file using the dd command."
    },
    {
        "cwe": "CWE-116",
        "func_name": "flatpak/flatpak_context_load_metadata",
        "score": 0.7617793679237366,
        "func_before": "gboolean\nflatpak_context_load_metadata (FlatpakContext *context,\n                               GKeyFile       *metakey,\n                               GError        **error)\n{\n  gboolean remove;\n  g_auto(GStrv) groups = NULL;\n  gsize i;\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SHARED, NULL))\n    {\n      g_auto(GStrv) shares = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                         FLATPAK_METADATA_KEY_SHARED, NULL, error);\n      if (shares == NULL)\n        return FALSE;\n\n      for (i = 0; shares[i] != NULL; i++)\n        {\n          FlatpakContextShares share;\n\n          share = flatpak_context_share_from_string (parse_negated (shares[i], &remove), NULL);\n          if (share == 0)\n            g_info (\"Unknown share type %s\", shares[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_shares (context, share);\n              else\n                flatpak_context_add_shares (context, share);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SOCKETS, NULL))\n    {\n      g_auto(GStrv) sockets = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                          FLATPAK_METADATA_KEY_SOCKETS, NULL, error);\n      if (sockets == NULL)\n        return FALSE;\n\n      for (i = 0; sockets[i] != NULL; i++)\n        {\n          FlatpakContextSockets socket = flatpak_context_socket_from_string (parse_negated (sockets[i], &remove), NULL);\n          if (socket == 0)\n            g_info (\"Unknown socket type %s\", sockets[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_sockets (context, socket);\n              else\n                flatpak_context_add_sockets (context, socket);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_DEVICES, NULL))\n    {\n      g_auto(GStrv) devices = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                          FLATPAK_METADATA_KEY_DEVICES, NULL, error);\n      if (devices == NULL)\n        return FALSE;\n\n\n      for (i = 0; devices[i] != NULL; i++)\n        {\n          FlatpakContextDevices device = flatpak_context_device_from_string (parse_negated (devices[i], &remove), NULL);\n          if (device == 0)\n            g_info (\"Unknown device type %s\", devices[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_devices (context, device);\n              else\n                flatpak_context_add_devices (context, device);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FEATURES, NULL))\n    {\n      g_auto(GStrv) features = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                           FLATPAK_METADATA_KEY_FEATURES, NULL, error);\n      if (features == NULL)\n        return FALSE;\n\n\n      for (i = 0; features[i] != NULL; i++)\n        {\n          FlatpakContextFeatures feature = flatpak_context_feature_from_string (parse_negated (features[i], &remove), NULL);\n          if (feature == 0)\n            g_info (\"Unknown feature type %s\", features[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_features (context, feature);\n              else\n                flatpak_context_add_features (context, feature);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FILESYSTEMS, NULL))\n    {\n      g_auto(GStrv) filesystems = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                              FLATPAK_METADATA_KEY_FILESYSTEMS, NULL, error);\n      if (filesystems == NULL)\n        return FALSE;\n\n      for (i = 0; filesystems[i] != NULL; i++)\n        {\n          const char *fs = parse_negated (filesystems[i], &remove);\n          g_autofree char *filesystem = NULL;\n          FlatpakFilesystemMode mode;\n\n          if (!flatpak_context_parse_filesystem (fs, remove,\n                                                 &filesystem, &mode, NULL))\n            g_info (\"Unknown filesystem type %s\", filesystems[i]);\n          else\n            {\n              g_assert (mode == FLATPAK_FILESYSTEM_MODE_NONE || !remove);\n              flatpak_context_take_filesystem (context, g_steal_pointer (&filesystem), mode);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_PERSISTENT, NULL))\n    {\n      g_auto(GStrv) persistent = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                             FLATPAK_METADATA_KEY_PERSISTENT, NULL, error);\n      if (persistent == NULL)\n        return FALSE;\n\n      for (i = 0; persistent[i] != NULL; i++)\n        flatpak_context_set_persistent (context, persistent[i]);\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, key, NULL);\n          FlatpakPolicy policy;\n\n          if (!flatpak_verify_dbus_name (key, error))\n            return FALSE;\n\n          policy = flatpak_policy_from_string (value, NULL);\n          if ((int) policy != -1)\n            flatpak_context_set_session_bus_policy (context, key, policy);\n        }\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, key, NULL);\n          FlatpakPolicy policy;\n\n          if (!flatpak_verify_dbus_name (key, error))\n            return FALSE;\n\n          policy = flatpak_policy_from_string (value, NULL);\n          if ((int) policy != -1)\n            flatpak_context_set_system_bus_policy (context, key, policy);\n        }\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, key, NULL);\n\n          flatpak_context_set_env_var (context, key, value);\n        }\n    }\n\n  /* unset-environment is higher precedence than Environment, so that\n   * we can put unset keys in both places. Old versions of Flatpak will\n   * interpret the empty string as unset; new versions will obey\n   * unset-environment. */\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT, NULL))\n    {\n      g_auto(GStrv) vars = NULL;\n      gsize vars_count;\n\n      vars = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                         FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT,\n                                         &vars_count, error);\n\n      if (vars == NULL)\n        return FALSE;\n\n      for (i = 0; i < vars_count; i++)\n        {\n          const char *var = vars[i];\n\n          flatpak_context_set_env_var (context, var, NULL);\n        }\n    }\n\n  groups = g_key_file_get_groups (metakey, NULL);\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      const char *group = groups[i];\n      const char *subsystem;\n      int j;\n\n      if (g_str_has_prefix (group, FLATPAK_METADATA_GROUP_PREFIX_POLICY))\n        {\n          g_auto(GStrv) keys = NULL;\n          subsystem = group + strlen (FLATPAK_METADATA_GROUP_PREFIX_POLICY);\n          keys = g_key_file_get_keys (metakey, group, NULL, NULL);\n          for (j = 0; keys != NULL && keys[j] != NULL; j++)\n            {\n              const char *key = keys[j];\n              g_autofree char *policy_key = g_strdup_printf (\"%s.%s\", subsystem, key);\n              g_auto(GStrv) values = NULL;\n              int k;\n\n              values = g_key_file_get_string_list (metakey, group, key, NULL, NULL);\n              for (k = 0; values != NULL && values[k] != NULL; k++)\n                flatpak_context_apply_generic_policy (context, policy_key,\n                                                      values[k]);\n            }\n        }\n    }\n\n  return TRUE;\n}",
        "func_after": "gboolean\nflatpak_context_load_metadata (FlatpakContext *context,\n                               GKeyFile       *metakey,\n                               GError        **error)\n{\n  gboolean remove;\n  g_auto(GStrv) groups = NULL;\n  gsize i;\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SHARED, NULL))\n    {\n      g_auto(GStrv) shares = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                         FLATPAK_METADATA_KEY_SHARED, NULL, error);\n      if (shares == NULL)\n        return FALSE;\n\n      for (i = 0; shares[i] != NULL; i++)\n        {\n          FlatpakContextShares share;\n\n          share = flatpak_context_share_from_string (parse_negated (shares[i], &remove), NULL);\n          if (share == 0)\n            g_info (\"Unknown share type %s\", shares[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_shares (context, share);\n              else\n                flatpak_context_add_shares (context, share);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SOCKETS, NULL))\n    {\n      g_auto(GStrv) sockets = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                          FLATPAK_METADATA_KEY_SOCKETS, NULL, error);\n      if (sockets == NULL)\n        return FALSE;\n\n      for (i = 0; sockets[i] != NULL; i++)\n        {\n          FlatpakContextSockets socket = flatpak_context_socket_from_string (parse_negated (sockets[i], &remove), NULL);\n          if (socket == 0)\n            g_info (\"Unknown socket type %s\", sockets[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_sockets (context, socket);\n              else\n                flatpak_context_add_sockets (context, socket);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_DEVICES, NULL))\n    {\n      g_auto(GStrv) devices = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                          FLATPAK_METADATA_KEY_DEVICES, NULL, error);\n      if (devices == NULL)\n        return FALSE;\n\n\n      for (i = 0; devices[i] != NULL; i++)\n        {\n          FlatpakContextDevices device = flatpak_context_device_from_string (parse_negated (devices[i], &remove), NULL);\n          if (device == 0)\n            g_info (\"Unknown device type %s\", devices[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_devices (context, device);\n              else\n                flatpak_context_add_devices (context, device);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FEATURES, NULL))\n    {\n      g_auto(GStrv) features = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                           FLATPAK_METADATA_KEY_FEATURES, NULL, error);\n      if (features == NULL)\n        return FALSE;\n\n\n      for (i = 0; features[i] != NULL; i++)\n        {\n          FlatpakContextFeatures feature = flatpak_context_feature_from_string (parse_negated (features[i], &remove), NULL);\n          if (feature == 0)\n            g_info (\"Unknown feature type %s\", features[i]);\n          else\n            {\n              if (remove)\n                flatpak_context_remove_features (context, feature);\n              else\n                flatpak_context_add_features (context, feature);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FILESYSTEMS, NULL))\n    {\n      g_auto(GStrv) filesystems = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                              FLATPAK_METADATA_KEY_FILESYSTEMS, NULL, error);\n      if (filesystems == NULL)\n        return FALSE;\n\n      for (i = 0; filesystems[i] != NULL; i++)\n        {\n          const char *fs = parse_negated (filesystems[i], &remove);\n          g_autofree char *filesystem = NULL;\n          g_autoptr(GError) local_error = NULL;\n          FlatpakFilesystemMode mode;\n\n          if (!flatpak_context_parse_filesystem (fs, remove,\n                                                 &filesystem, &mode, &local_error))\n            {\n              if (g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA))\n                {\n                  /* Invalid characters, so just hard-fail. */\n                  g_propagate_error (error, g_steal_pointer (&local_error));\n                  return FALSE;\n                }\n              else\n                {\n                  g_info (\"Unknown filesystem type %s\", filesystems[i]);\n                  g_clear_error (&local_error);\n                }\n            }\n          else\n            {\n              g_assert (mode == FLATPAK_FILESYSTEM_MODE_NONE || !remove);\n              flatpak_context_take_filesystem (context, g_steal_pointer (&filesystem), mode);\n            }\n        }\n    }\n\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_PERSISTENT, NULL))\n    {\n      g_auto(GStrv) persistent = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                                             FLATPAK_METADATA_KEY_PERSISTENT, NULL, error);\n      if (persistent == NULL)\n        return FALSE;\n\n      for (i = 0; persistent[i] != NULL; i++)\n        if (!flatpak_context_set_persistent (context, persistent[i], error))\n          return FALSE;\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, key, NULL);\n          FlatpakPolicy policy;\n\n          if (!flatpak_verify_dbus_name (key, error))\n            return FALSE;\n\n          policy = flatpak_policy_from_string (value, NULL);\n          if ((int) policy != -1)\n            flatpak_context_set_session_bus_policy (context, key, policy);\n        }\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, key, NULL);\n          FlatpakPolicy policy;\n\n          if (!flatpak_verify_dbus_name (key, error))\n            return FALSE;\n\n          policy = flatpak_policy_from_string (value, NULL);\n          if ((int) policy != -1)\n            flatpak_context_set_system_bus_policy (context, key, policy);\n        }\n    }\n\n  if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT))\n    {\n      g_auto(GStrv) keys = NULL;\n      gsize keys_count;\n\n      keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, &keys_count, NULL);\n      for (i = 0; i < keys_count; i++)\n        {\n          const char *key = keys[i];\n          g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, key, NULL);\n\n          flatpak_context_set_env_var (context, key, value);\n        }\n    }\n\n  /* unset-environment is higher precedence than Environment, so that\n   * we can put unset keys in both places. Old versions of Flatpak will\n   * interpret the empty string as unset; new versions will obey\n   * unset-environment. */\n  if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT, NULL))\n    {\n      g_auto(GStrv) vars = NULL;\n      gsize vars_count;\n\n      vars = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                         FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT,\n                                         &vars_count, error);\n\n      if (vars == NULL)\n        return FALSE;\n\n      for (i = 0; i < vars_count; i++)\n        {\n          const char *var = vars[i];\n\n          flatpak_context_set_env_var (context, var, NULL);\n        }\n    }\n\n  groups = g_key_file_get_groups (metakey, NULL);\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      const char *group = groups[i];\n      const char *subsystem;\n      int j;\n\n      if (g_str_has_prefix (group, FLATPAK_METADATA_GROUP_PREFIX_POLICY))\n        {\n          g_auto(GStrv) keys = NULL;\n          subsystem = group + strlen (FLATPAK_METADATA_GROUP_PREFIX_POLICY);\n          keys = g_key_file_get_keys (metakey, group, NULL, NULL);\n          for (j = 0; keys != NULL && keys[j] != NULL; j++)\n            {\n              const char *key = keys[j];\n              g_autofree char *policy_key = g_strdup_printf (\"%s.%s\", subsystem, key);\n              g_auto(GStrv) values = NULL;\n              int k;\n\n              values = g_key_file_get_string_list (metakey, group, key, NULL, NULL);\n              for (k = 0; values != NULL && values[k] != NULL; k++)\n                flatpak_context_apply_generic_policy (context, policy_key,\n                                                      values[k]);\n            }\n        }\n    }\n\n  return TRUE;\n}",
        "description": "In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, Flatpak allowed attackers to publish applications with elevated permissions while hiding these permissions from users through the `flatpak(1)` command-line interface. This was achieved by setting other permissions to crafted values containing non-printable control characters such as `ESC`. A fix is available in the mentioned versions. As a workaround, users are advised to use a graphical user interface like GNOME Software instead of the command-line interface, or to only install applications from trusted maintainers.",
        "commit": "Rejecting paths containing special characters provided to --filesystem/--persist options to mitigate potential security risks associated with displaying such text."
    },
    {
        "cwe": "CWE-617",
        "func_name": "jerryscript-project/ecma_op_object_get_property_names",
        "score": 0.7736659049987793,
        "func_before": "ecma_collection_t *\necma_op_object_get_property_names (ecma_object_t *obj_p, /**< object */\n                                   uint32_t opts) /**< any combination of ecma_list_properties_options_t values  */\n{\n  JERRY_ASSERT (obj_p != NULL\n                && !ecma_is_lexical_environment (obj_p));\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_IS_PROXY (obj_p))\n  {\n    return ecma_proxy_object_own_property_keys (obj_p);\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  if (ecma_op_object_is_fast_array (obj_p))\n  {\n    return ecma_fast_array_get_property_names (obj_p, opts);\n  }\n\n  ecma_collection_t *ret_p = ecma_new_collection ();\n  ecma_collection_t *skipped_non_enumerable_p = ecma_new_collection ();\n\n  const bool is_enumerable_only = (opts & ECMA_LIST_ENUMERABLE) != 0;\n  const bool is_array_indices_only = (opts & ECMA_LIST_ARRAY_INDICES) != 0;\n  const bool is_with_prototype_chain = (opts & ECMA_LIST_PROTOTYPE) != 0;\n#if ENABLED (JERRY_ES2015)\n  const bool is_symbols = (opts & ECMA_LIST_SYMBOLS) != 0;\n  const bool is_symbols_only = (opts & ECMA_LIST_SYMBOLS_ONLY) != 0;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  const size_t bitmap_row_size = sizeof (uint32_t) * JERRY_BITSINBYTE;\n  const size_t names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size;\n  JERRY_VLA (uint32_t, names_hashes_bitmap, names_hashes_bitmap_size);\n\n  memset (names_hashes_bitmap, 0, names_hashes_bitmap_size * sizeof (names_hashes_bitmap[0]));\n\n  while (true)\n  {\n    const ecma_object_type_t type = ecma_get_object_type (obj_p);\n    const bool obj_is_builtin = ecma_get_object_is_builtin (obj_p);\n    ecma_length_t string_named_properties_count = 0;\n    ecma_length_t array_index_named_properties_count = 0;\n#if ENABLED (JERRY_ES2015)\n    ecma_length_t symbol_named_properties_count = 0;\n#endif /* ENABLED (JERRY_ES2015) */\n    ecma_collection_t *prop_names_p = ecma_new_collection ();\n\n#if ENABLED (JERRY_ES2015)\n    if (JERRY_LIKELY (!is_symbols_only))\n    {\n#endif /* ENABLED (JERRY_ES2015) */\n\n      if (obj_is_builtin)\n      {\n        if (type == ECMA_OBJECT_TYPE_FUNCTION && ecma_builtin_function_is_routine (obj_p))\n        {\n          ecma_builtin_routine_list_lazy_property_names (obj_p,\n                                                          opts,\n                                                          prop_names_p,\n                                                          skipped_non_enumerable_p);\n        }\n        else\n        {\n          ecma_builtin_list_lazy_property_names (obj_p,\n                                                 opts,\n                                                 prop_names_p,\n                                                 skipped_non_enumerable_p);\n        }\n      }\n      else\n      {\n        switch (type)\n        {\n          case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:\n          {\n  #if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n            if (ecma_object_is_typedarray (obj_p))\n            {\n              ecma_op_typedarray_list_lazy_property_names (obj_p, prop_names_p);\n            }\n  #endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n            break;\n          }\n          case ECMA_OBJECT_TYPE_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_function_list_lazy_property_names (obj_p,\n                                                         opts,\n                                                         prop_names_p,\n                                                         skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_external_function_list_lazy_property_names (obj_p,\n                                                                  opts,\n                                                                  prop_names_p,\n                                                                  skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_bound_function_list_lazy_property_names (obj_p,\n                                                               opts,\n                                                               prop_names_p,\n                                                               skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_CLASS:\n          {\n            ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n            if (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_STRING_UL)\n            {\n              ecma_op_string_list_lazy_property_names (obj_p,\n                                                       opts,\n                                                       prop_names_p,\n                                                       skipped_non_enumerable_p);\n            }\n\n            break;\n          }\n          case ECMA_OBJECT_TYPE_ARRAY:\n          {\n            ecma_op_array_list_lazy_property_names (obj_p,\n                                                    opts,\n                                                    prop_names_p,\n                                                    skipped_non_enumerable_p);\n            break;\n          }\n          default:\n          {\n            JERRY_ASSERT (type == ECMA_OBJECT_TYPE_GENERAL);\n\n            break;\n          }\n        }\n      }\n#if ENABLED (JERRY_ES2015)\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    ecma_value_t *buffer_p = prop_names_p->buffer_p;\n    uint32_t lazy_prop_name_count = prop_names_p->item_count;\n\n    const size_t own_names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size;\n    JERRY_VLA (uint32_t, own_names_hashes_bitmap, own_names_hashes_bitmap_size);\n    memset (own_names_hashes_bitmap, 0, own_names_hashes_bitmap_size * sizeof (own_names_hashes_bitmap[0]));\n\n    for (uint32_t i = 0; i < prop_names_p->item_count; i++)\n    {\n      ecma_string_t *name_p = ecma_get_string_from_value (buffer_p[i]);\n\n      if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)\n      {\n        array_index_named_properties_count++;\n      }\n#if ENABLED (JERRY_ES2015)\n      else if (ecma_prop_name_is_symbol (name_p))\n      {\n        symbol_named_properties_count++;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      else\n      {\n        string_named_properties_count++;\n      }\n\n#if ENABLED (JERRY_ES2015)\n      /* Symbols are never lazy listed */\n      JERRY_ASSERT (!ecma_prop_name_is_symbol (name_p));\n#endif /* ENABLED (JERRY_ES2015) */\n\n      uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n      uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n      uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n      if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0)\n      {\n        own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n      }\n    }\n\n    jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp;\n\n    if (ecma_op_object_is_fast_array (obj_p) && prop_iter_cp != JMEM_CP_NULL)\n    {\n      ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;\n\n      uint32_t length = ext_obj_p->u.array.length;\n      array_index_named_properties_count = length - ecma_fast_array_get_hole_count (obj_p);\n\n      ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, prop_iter_cp);\n\n      for (uint32_t i = 0; i < length; i++)\n      {\n        if (ecma_is_value_array_hole (values_p[i]))\n        {\n          continue;\n        }\n\n        ecma_string_t *index_str_p = ecma_new_ecma_string_from_uint32 (i);\n\n        uint8_t hash = (uint8_t) ecma_string_hash (index_str_p);\n        uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n        uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n        bool is_add = true;\n\n        if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0)\n        {\n          buffer_p = prop_names_p->buffer_p;\n\n          for (uint32_t j = 0; j < prop_names_p->item_count; j++)\n          {\n            ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n            if (ecma_compare_ecma_strings (index_str_p, current_name_p))\n            {\n              is_add = false;\n              break;\n            }\n          }\n        }\n\n        if (is_add)\n        {\n          own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n\n          ecma_collection_push_back (prop_names_p, ecma_make_string_value (index_str_p));\n        }\n      }\n    }\n    else\n    {\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n      if (prop_iter_cp != JMEM_CP_NULL)\n      {\n        ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n        if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n        {\n          prop_iter_cp = prop_iter_p->next_property_cp;\n        }\n      }\n  #endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n      while (prop_iter_cp != JMEM_CP_NULL)\n      {\n        ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n        JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n        for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)\n        {\n          ecma_property_t *property_p = prop_iter_p->types + i;\n\n          if (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA\n              || ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR)\n          {\n            ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n            if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_MAGIC\n                && prop_pair_p->names_cp[i] >= LIT_NON_INTERNAL_MAGIC_STRING__COUNT\n                && prop_pair_p->names_cp[i] < LIT_MAGIC_STRING__COUNT)\n            {\n              /* Internal properties are never enumerated. */\n              continue;\n            }\n\n            ecma_string_t *name_p = ecma_string_from_property_name (*property_p,\n                                                                    prop_pair_p->names_cp[i]);\n\n            if (!(is_enumerable_only && !ecma_is_property_enumerable (*property_p)))\n            {\n  #if ENABLED (JERRY_ES2015)\n              /* We skip the current property in the following cases:\n                 1. We don't want to list symbols (is_symbols and is_symbols_only are false)\n                    and the current property is a symbol.\n                 2. We only want to list symbols (is_symbols_only is true) and the current\n                    property is NOT a symbol. */\n              bool is_symbol = ecma_prop_name_is_symbol (name_p);\n              if ((!(is_symbols || is_symbols_only) && is_symbol) || (is_symbols_only && !is_symbol))\n              {\n                ecma_deref_ecma_string (name_p);\n                continue;\n              }\n  #endif /* ENABLED (JERRY_ES2015) */\n\n              uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n              uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n              uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n              bool is_add = true;\n\n              if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0)\n              {\n                buffer_p = prop_names_p->buffer_p;\n\n                for (uint32_t j = 0; j < prop_names_p->item_count; j++)\n                {\n                  ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n                  if (ecma_compare_ecma_strings (name_p, current_name_p))\n                  {\n                    is_add = false;\n                    break;\n                  }\n                }\n              }\n\n              if (is_add)\n              {\n                if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)\n                {\n                  /* The name is a valid array index. */\n                  array_index_named_properties_count++;\n                }\n                else if (!is_array_indices_only)\n                {\n  #if ENABLED (JERRY_ES2015)\n                  if (ecma_prop_name_is_symbol (name_p))\n                  {\n                    symbol_named_properties_count++;\n                  }\n                  else\n                  {\n  #endif /* ENABLED (JERRY_ES2015) */\n                    string_named_properties_count++;\n  #if ENABLED (JERRY_ES2015)\n                  }\n  #endif /* ENABLED (JERRY_ES2015) */\n                }\n                else\n                {\n                  ecma_deref_ecma_string (name_p);\n                  continue;\n                }\n\n                own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n\n                ecma_collection_push_back (prop_names_p, ecma_make_prop_name_value (name_p));\n              }\n              else\n              {\n                ecma_deref_ecma_string (name_p);\n              }\n            }\n            else\n            {\n              JERRY_ASSERT (is_enumerable_only && !ecma_is_property_enumerable (*property_p));\n\n              ecma_collection_push_back (skipped_non_enumerable_p, ecma_make_prop_name_value (name_p));\n            }\n          }\n        }\n\n        prop_iter_cp = prop_iter_p->next_property_cp;\n      }\n    }\n\n    ecma_length_t all_properties_count = array_index_named_properties_count + string_named_properties_count;\n\n#if ENABLED (JERRY_ES2015)\n    all_properties_count += symbol_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    /* Second pass: collecting property names into an array. */\n    JMEM_DEFINE_LOCAL_ARRAY (names_p, all_properties_count, ecma_string_t *);\n\n    ecma_string_t **string_names_p = names_p + array_index_named_properties_count;\n#if ENABLED (JERRY_ES2015)\n    ecma_string_t **symbol_names_p = string_names_p + string_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    uint32_t array_index_name_pos = 0;\n    uint32_t string_name_pos = string_named_properties_count;\n    uint32_t lazy_string_name_pos = 0;\n#if ENABLED (JERRY_ES2015)\n    uint32_t symbol_name_pos = symbol_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    buffer_p = prop_names_p->buffer_p;\n\n    for (uint32_t i = 0; i < prop_names_p->item_count; i++)\n    {\n      ecma_string_t *name_p = ecma_get_prop_name_from_value (buffer_p[i]);\n      ecma_ref_ecma_string (name_p);\n\n      uint32_t index = ecma_string_get_array_index (name_p);\n\n      if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n      {\n        JERRY_ASSERT (array_index_name_pos < array_index_named_properties_count);\n\n        uint32_t insertion_pos = 0;\n        while (insertion_pos < array_index_name_pos\n               && index > ecma_string_get_array_index (names_p[insertion_pos]))\n        {\n          insertion_pos++;\n        }\n\n        if (insertion_pos == array_index_name_pos)\n        {\n          names_p[array_index_name_pos++] = name_p;\n        }\n        else\n        {\n          JERRY_ASSERT (insertion_pos < array_index_name_pos);\n          JERRY_ASSERT (index <= ecma_string_get_array_index (names_p[insertion_pos]));\n\n          uint32_t move_pos = array_index_name_pos++;\n\n          while (move_pos > insertion_pos)\n          {\n            names_p[move_pos] = names_p[move_pos - 1u];\n\n            move_pos--;\n          }\n\n          names_p[insertion_pos] = name_p;\n        }\n      }\n#if ENABLED (JERRY_ES2015)\n      else if (ecma_prop_name_is_symbol (name_p))\n      {\n        // Put in the symbols in reverse order.\n        JERRY_ASSERT (symbol_name_pos > 0);\n        JERRY_ASSERT (symbol_name_pos <= symbol_named_properties_count);\n\n        symbol_names_p[--symbol_name_pos] = name_p;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      else\n      {\n        // Put in the strings in reverse order.\n        JERRY_ASSERT (string_name_pos > 0);\n        JERRY_ASSERT (string_name_pos <= string_named_properties_count);\n\n        if (i < lazy_prop_name_count)\n        {\n          string_names_p[lazy_string_name_pos++] = name_p;\n        }\n        else\n        {\n          string_names_p[--string_name_pos] = name_p;\n        }\n      }\n    }\n\n    JERRY_ASSERT (array_index_name_pos == array_index_named_properties_count);\n    JERRY_ASSERT (string_name_pos - lazy_string_name_pos == 0);\n#if ENABLED (JERRY_ES2015)\n    JERRY_ASSERT (symbol_name_pos == 0);\n#endif /* ENABLED (JERRY_ES2015) */\n\n    ecma_collection_free (prop_names_p);\n\n    /* Third pass:\n     *   embedding own property names of current object of prototype chain to aggregate property names collection */\n    for (uint32_t i = 0; i < all_properties_count; i++)\n    {\n      bool is_append = true;\n\n      ecma_string_t *name_p = names_p[i];\n\n      uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n      uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n      uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n      if ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0)\n      {\n        /* This hash has not been used before (for non-skipped). */\n        names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n      }\n      else\n      {\n        /* Name with same hash has already occured. */\n        buffer_p = ret_p->buffer_p;\n\n        for (uint32_t j = 0; j < ret_p->item_count; j++)\n        {\n          ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n          if (ecma_compare_ecma_strings (name_p, current_name_p))\n          {\n            is_append = false;\n            break;\n          }\n        }\n      }\n\n      if (is_append)\n      {\n        buffer_p = skipped_non_enumerable_p->buffer_p;\n\n        for (uint32_t j = 0; j < skipped_non_enumerable_p->item_count; j++)\n        {\n          ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n          if (ecma_compare_ecma_strings (name_p, current_name_p))\n          {\n            is_append = false;\n            break;\n          }\n        }\n      }\n\n      if (is_append)\n      {\n        JERRY_ASSERT ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0);\n\n        ecma_collection_push_back (ret_p, ecma_make_prop_name_value (name_p));\n      }\n      else\n      {\n        ecma_deref_ecma_string (name_p);\n      }\n\n    }\n\n    JMEM_FINALIZE_LOCAL_ARRAY (names_p);\n\n    if (!is_with_prototype_chain || obj_p->u2.prototype_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_p->u2.prototype_cp);\n  }\n\n  ecma_collection_free (skipped_non_enumerable_p);\n\n  return ret_p;\n}",
        "func_after": "ecma_collection_t *\necma_op_object_get_property_names (ecma_object_t *obj_p, /**< object */\n                                   uint32_t opts) /**< any combination of ecma_list_properties_options_t values  */\n{\n  JERRY_ASSERT (obj_p != NULL\n                && !ecma_is_lexical_environment (obj_p));\n\n#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)\n  if (ECMA_OBJECT_IS_PROXY (obj_p))\n  {\n    /* Integrated a part of ECMA 262 v6 7.3.21 EnumerableOwnNames operation. */\n    ecma_collection_t *proxy_keys = ecma_proxy_object_own_property_keys (obj_p);\n    if (JERRY_UNLIKELY (proxy_keys == NULL))\n    {\n      return proxy_keys;\n    }\n    ecma_collection_t *return_keys = ecma_new_collection ();\n\n    /* Move valid elements to the output collection */\n    for (uint32_t i = 0; i < proxy_keys->item_count; i++)\n    {\n      ecma_value_t entry = proxy_keys->buffer_p[i];\n      ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (entry);\n      bool prop_is_symbol = ecma_prop_name_is_symbol (prop_name_p);\n\n      if (prop_is_symbol && ((opts & (ECMA_LIST_SYMBOLS | ECMA_LIST_SYMBOLS_ONLY)) != 0))\n      {\n        ecma_collection_push_back (return_keys, entry);\n      }\n      else if (!prop_is_symbol && (opts & ECMA_LIST_SYMBOLS_ONLY) == 0)\n      {\n        ecma_collection_push_back (return_keys, entry);\n      }\n      else\n      {\n        ecma_free_value (entry);\n      }\n    }\n\n    ecma_collection_destroy (proxy_keys);\n    return return_keys;\n  }\n#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */\n\n  if (ecma_op_object_is_fast_array (obj_p))\n  {\n    return ecma_fast_array_get_property_names (obj_p, opts);\n  }\n\n  ecma_collection_t *ret_p = ecma_new_collection ();\n  ecma_collection_t *skipped_non_enumerable_p = ecma_new_collection ();\n\n  const bool is_enumerable_only = (opts & ECMA_LIST_ENUMERABLE) != 0;\n  const bool is_array_indices_only = (opts & ECMA_LIST_ARRAY_INDICES) != 0;\n  const bool is_with_prototype_chain = (opts & ECMA_LIST_PROTOTYPE) != 0;\n#if ENABLED (JERRY_ES2015)\n  const bool is_symbols = (opts & ECMA_LIST_SYMBOLS) != 0;\n  const bool is_symbols_only = (opts & ECMA_LIST_SYMBOLS_ONLY) != 0;\n#endif /* ENABLED (JERRY_ES2015) */\n\n  const size_t bitmap_row_size = sizeof (uint32_t) * JERRY_BITSINBYTE;\n  const size_t names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size;\n  JERRY_VLA (uint32_t, names_hashes_bitmap, names_hashes_bitmap_size);\n\n  memset (names_hashes_bitmap, 0, names_hashes_bitmap_size * sizeof (names_hashes_bitmap[0]));\n\n  while (true)\n  {\n    const ecma_object_type_t type = ecma_get_object_type (obj_p);\n    const bool obj_is_builtin = ecma_get_object_is_builtin (obj_p);\n    ecma_length_t string_named_properties_count = 0;\n    ecma_length_t array_index_named_properties_count = 0;\n#if ENABLED (JERRY_ES2015)\n    ecma_length_t symbol_named_properties_count = 0;\n#endif /* ENABLED (JERRY_ES2015) */\n    ecma_collection_t *prop_names_p = ecma_new_collection ();\n\n#if ENABLED (JERRY_ES2015)\n    if (JERRY_LIKELY (!is_symbols_only))\n    {\n#endif /* ENABLED (JERRY_ES2015) */\n\n      if (obj_is_builtin)\n      {\n        if (type == ECMA_OBJECT_TYPE_FUNCTION && ecma_builtin_function_is_routine (obj_p))\n        {\n          ecma_builtin_routine_list_lazy_property_names (obj_p,\n                                                          opts,\n                                                          prop_names_p,\n                                                          skipped_non_enumerable_p);\n        }\n        else\n        {\n          ecma_builtin_list_lazy_property_names (obj_p,\n                                                 opts,\n                                                 prop_names_p,\n                                                 skipped_non_enumerable_p);\n        }\n      }\n      else\n      {\n        switch (type)\n        {\n          case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:\n          {\n  #if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)\n            if (ecma_object_is_typedarray (obj_p))\n            {\n              ecma_op_typedarray_list_lazy_property_names (obj_p, prop_names_p);\n            }\n  #endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */\n            break;\n          }\n          case ECMA_OBJECT_TYPE_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_function_list_lazy_property_names (obj_p,\n                                                         opts,\n                                                         prop_names_p,\n                                                         skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_external_function_list_lazy_property_names (obj_p,\n                                                                  opts,\n                                                                  prop_names_p,\n                                                                  skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_BOUND_FUNCTION:\n          {\n            if (!is_array_indices_only)\n            {\n              ecma_op_bound_function_list_lazy_property_names (obj_p,\n                                                               opts,\n                                                               prop_names_p,\n                                                               skipped_non_enumerable_p);\n            }\n            break;\n          }\n          case ECMA_OBJECT_TYPE_CLASS:\n          {\n            ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;\n\n            if (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_STRING_UL)\n            {\n              ecma_op_string_list_lazy_property_names (obj_p,\n                                                       opts,\n                                                       prop_names_p,\n                                                       skipped_non_enumerable_p);\n            }\n\n            break;\n          }\n          case ECMA_OBJECT_TYPE_ARRAY:\n          {\n            ecma_op_array_list_lazy_property_names (obj_p,\n                                                    opts,\n                                                    prop_names_p,\n                                                    skipped_non_enumerable_p);\n            break;\n          }\n          default:\n          {\n            JERRY_ASSERT (type == ECMA_OBJECT_TYPE_GENERAL);\n\n            break;\n          }\n        }\n      }\n#if ENABLED (JERRY_ES2015)\n    }\n#endif /* ENABLED (JERRY_ES2015) */\n\n    ecma_value_t *buffer_p = prop_names_p->buffer_p;\n    uint32_t lazy_prop_name_count = prop_names_p->item_count;\n\n    const size_t own_names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size;\n    JERRY_VLA (uint32_t, own_names_hashes_bitmap, own_names_hashes_bitmap_size);\n    memset (own_names_hashes_bitmap, 0, own_names_hashes_bitmap_size * sizeof (own_names_hashes_bitmap[0]));\n\n    for (uint32_t i = 0; i < prop_names_p->item_count; i++)\n    {\n      ecma_string_t *name_p = ecma_get_string_from_value (buffer_p[i]);\n\n      if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)\n      {\n        array_index_named_properties_count++;\n      }\n#if ENABLED (JERRY_ES2015)\n      else if (ecma_prop_name_is_symbol (name_p))\n      {\n        symbol_named_properties_count++;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      else\n      {\n        string_named_properties_count++;\n      }\n\n#if ENABLED (JERRY_ES2015)\n      /* Symbols are never lazy listed */\n      JERRY_ASSERT (!ecma_prop_name_is_symbol (name_p));\n#endif /* ENABLED (JERRY_ES2015) */\n\n      uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n      uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n      uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n      if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0)\n      {\n        own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n      }\n    }\n\n    jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp;\n\n    if (ecma_op_object_is_fast_array (obj_p) && prop_iter_cp != JMEM_CP_NULL)\n    {\n      ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;\n\n      uint32_t length = ext_obj_p->u.array.length;\n      array_index_named_properties_count = length - ecma_fast_array_get_hole_count (obj_p);\n\n      ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, prop_iter_cp);\n\n      for (uint32_t i = 0; i < length; i++)\n      {\n        if (ecma_is_value_array_hole (values_p[i]))\n        {\n          continue;\n        }\n\n        ecma_string_t *index_str_p = ecma_new_ecma_string_from_uint32 (i);\n\n        uint8_t hash = (uint8_t) ecma_string_hash (index_str_p);\n        uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n        uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n        bool is_add = true;\n\n        if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0)\n        {\n          buffer_p = prop_names_p->buffer_p;\n\n          for (uint32_t j = 0; j < prop_names_p->item_count; j++)\n          {\n            ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n            if (ecma_compare_ecma_strings (index_str_p, current_name_p))\n            {\n              is_add = false;\n              break;\n            }\n          }\n        }\n\n        if (is_add)\n        {\n          own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n\n          ecma_collection_push_back (prop_names_p, ecma_make_string_value (index_str_p));\n        }\n      }\n    }\n    else\n    {\n#if ENABLED (JERRY_PROPRETY_HASHMAP)\n      if (prop_iter_cp != JMEM_CP_NULL)\n      {\n        ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n\n        if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)\n        {\n          prop_iter_cp = prop_iter_p->next_property_cp;\n        }\n      }\n  #endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */\n\n      while (prop_iter_cp != JMEM_CP_NULL)\n      {\n        ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);\n        JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));\n\n        for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)\n        {\n          ecma_property_t *property_p = prop_iter_p->types + i;\n\n          if (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA\n              || ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR)\n          {\n            ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;\n\n            if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_MAGIC\n                && prop_pair_p->names_cp[i] >= LIT_NON_INTERNAL_MAGIC_STRING__COUNT\n                && prop_pair_p->names_cp[i] < LIT_MAGIC_STRING__COUNT)\n            {\n              /* Internal properties are never enumerated. */\n              continue;\n            }\n\n            ecma_string_t *name_p = ecma_string_from_property_name (*property_p,\n                                                                    prop_pair_p->names_cp[i]);\n\n            if (!(is_enumerable_only && !ecma_is_property_enumerable (*property_p)))\n            {\n  #if ENABLED (JERRY_ES2015)\n              /* We skip the current property in the following cases:\n                 1. We don't want to list symbols (is_symbols and is_symbols_only are false)\n                    and the current property is a symbol.\n                 2. We only want to list symbols (is_symbols_only is true) and the current\n                    property is NOT a symbol. */\n              bool is_symbol = ecma_prop_name_is_symbol (name_p);\n              if ((!(is_symbols || is_symbols_only) && is_symbol) || (is_symbols_only && !is_symbol))\n              {\n                ecma_deref_ecma_string (name_p);\n                continue;\n              }\n  #endif /* ENABLED (JERRY_ES2015) */\n\n              uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n              uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n              uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n              bool is_add = true;\n\n              if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0)\n              {\n                buffer_p = prop_names_p->buffer_p;\n\n                for (uint32_t j = 0; j < prop_names_p->item_count; j++)\n                {\n                  ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n                  if (ecma_compare_ecma_strings (name_p, current_name_p))\n                  {\n                    is_add = false;\n                    break;\n                  }\n                }\n              }\n\n              if (is_add)\n              {\n                if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)\n                {\n                  /* The name is a valid array index. */\n                  array_index_named_properties_count++;\n                }\n                else if (!is_array_indices_only)\n                {\n  #if ENABLED (JERRY_ES2015)\n                  if (ecma_prop_name_is_symbol (name_p))\n                  {\n                    symbol_named_properties_count++;\n                  }\n                  else\n                  {\n  #endif /* ENABLED (JERRY_ES2015) */\n                    string_named_properties_count++;\n  #if ENABLED (JERRY_ES2015)\n                  }\n  #endif /* ENABLED (JERRY_ES2015) */\n                }\n                else\n                {\n                  ecma_deref_ecma_string (name_p);\n                  continue;\n                }\n\n                own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n\n                ecma_collection_push_back (prop_names_p, ecma_make_prop_name_value (name_p));\n              }\n              else\n              {\n                ecma_deref_ecma_string (name_p);\n              }\n            }\n            else\n            {\n              JERRY_ASSERT (is_enumerable_only && !ecma_is_property_enumerable (*property_p));\n\n              ecma_collection_push_back (skipped_non_enumerable_p, ecma_make_prop_name_value (name_p));\n            }\n          }\n        }\n\n        prop_iter_cp = prop_iter_p->next_property_cp;\n      }\n    }\n\n    ecma_length_t all_properties_count = array_index_named_properties_count + string_named_properties_count;\n\n#if ENABLED (JERRY_ES2015)\n    all_properties_count += symbol_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    /* Second pass: collecting property names into an array. */\n    JMEM_DEFINE_LOCAL_ARRAY (names_p, all_properties_count, ecma_string_t *);\n\n    ecma_string_t **string_names_p = names_p + array_index_named_properties_count;\n#if ENABLED (JERRY_ES2015)\n    ecma_string_t **symbol_names_p = string_names_p + string_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    uint32_t array_index_name_pos = 0;\n    uint32_t string_name_pos = string_named_properties_count;\n    uint32_t lazy_string_name_pos = 0;\n#if ENABLED (JERRY_ES2015)\n    uint32_t symbol_name_pos = symbol_named_properties_count;\n#endif /* ENABLED (JERRY_ES2015) */\n\n    buffer_p = prop_names_p->buffer_p;\n\n    for (uint32_t i = 0; i < prop_names_p->item_count; i++)\n    {\n      ecma_string_t *name_p = ecma_get_prop_name_from_value (buffer_p[i]);\n      ecma_ref_ecma_string (name_p);\n\n      uint32_t index = ecma_string_get_array_index (name_p);\n\n      if (index != ECMA_STRING_NOT_ARRAY_INDEX)\n      {\n        JERRY_ASSERT (array_index_name_pos < array_index_named_properties_count);\n\n        uint32_t insertion_pos = 0;\n        while (insertion_pos < array_index_name_pos\n               && index > ecma_string_get_array_index (names_p[insertion_pos]))\n        {\n          insertion_pos++;\n        }\n\n        if (insertion_pos == array_index_name_pos)\n        {\n          names_p[array_index_name_pos++] = name_p;\n        }\n        else\n        {\n          JERRY_ASSERT (insertion_pos < array_index_name_pos);\n          JERRY_ASSERT (index <= ecma_string_get_array_index (names_p[insertion_pos]));\n\n          uint32_t move_pos = array_index_name_pos++;\n\n          while (move_pos > insertion_pos)\n          {\n            names_p[move_pos] = names_p[move_pos - 1u];\n\n            move_pos--;\n          }\n\n          names_p[insertion_pos] = name_p;\n        }\n      }\n#if ENABLED (JERRY_ES2015)\n      else if (ecma_prop_name_is_symbol (name_p))\n      {\n        // Put in the symbols in reverse order.\n        JERRY_ASSERT (symbol_name_pos > 0);\n        JERRY_ASSERT (symbol_name_pos <= symbol_named_properties_count);\n\n        symbol_names_p[--symbol_name_pos] = name_p;\n      }\n#endif /* ENABLED (JERRY_ES2015) */\n      else\n      {\n        // Put in the strings in reverse order.\n        JERRY_ASSERT (string_name_pos > 0);\n        JERRY_ASSERT (string_name_pos <= string_named_properties_count);\n\n        if (i < lazy_prop_name_count)\n        {\n          string_names_p[lazy_string_name_pos++] = name_p;\n        }\n        else\n        {\n          string_names_p[--string_name_pos] = name_p;\n        }\n      }\n    }\n\n    JERRY_ASSERT (array_index_name_pos == array_index_named_properties_count);\n    JERRY_ASSERT (string_name_pos - lazy_string_name_pos == 0);\n#if ENABLED (JERRY_ES2015)\n    JERRY_ASSERT (symbol_name_pos == 0);\n#endif /* ENABLED (JERRY_ES2015) */\n\n    ecma_collection_free (prop_names_p);\n\n    /* Third pass:\n     *   embedding own property names of current object of prototype chain to aggregate property names collection */\n    for (uint32_t i = 0; i < all_properties_count; i++)\n    {\n      bool is_append = true;\n\n      ecma_string_t *name_p = names_p[i];\n\n      uint8_t hash = (uint8_t) ecma_string_hash (name_p);\n      uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);\n      uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);\n\n      if ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0)\n      {\n        /* This hash has not been used before (for non-skipped). */\n        names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);\n      }\n      else\n      {\n        /* Name with same hash has already occured. */\n        buffer_p = ret_p->buffer_p;\n\n        for (uint32_t j = 0; j < ret_p->item_count; j++)\n        {\n          ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n          if (ecma_compare_ecma_strings (name_p, current_name_p))\n          {\n            is_append = false;\n            break;\n          }\n        }\n      }\n\n      if (is_append)\n      {\n        buffer_p = skipped_non_enumerable_p->buffer_p;\n\n        for (uint32_t j = 0; j < skipped_non_enumerable_p->item_count; j++)\n        {\n          ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);\n\n          if (ecma_compare_ecma_strings (name_p, current_name_p))\n          {\n            is_append = false;\n            break;\n          }\n        }\n      }\n\n      if (is_append)\n      {\n        JERRY_ASSERT ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0);\n\n        ecma_collection_push_back (ret_p, ecma_make_prop_name_value (name_p));\n      }\n      else\n      {\n        ecma_deref_ecma_string (name_p);\n      }\n\n    }\n\n    JMEM_FINALIZE_LOCAL_ARRAY (names_p);\n\n    if (!is_with_prototype_chain || obj_p->u2.prototype_cp == JMEM_CP_NULL)\n    {\n      break;\n    }\n\n    obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_p->u2.prototype_cp);\n  }\n\n  ecma_collection_free (skipped_non_enumerable_p);\n\n  return ret_p;\n}",
        "description": "JerryScript 2.2.0 allows attackers to trigger a denial of service (assertion failure) due to an unintended property key query result when interacting with a Proxy object.",
        "commit": "The property key query for Proxy objects in JerryScript always returned all keys, regardless of whether any symbols were requested or present in the resulting array."
    }
]